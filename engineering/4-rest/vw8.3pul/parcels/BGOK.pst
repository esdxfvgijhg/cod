<?xml version="1.0"?><st-source><!-- Name: BGOKNotice: Copyright 1999-2015 Cincom Systems, Inc.  All rights reserved.Comment: Contains the Business Graphics Object Kit, which includes both the painter and deployment code for using business graphics in interfaces.If you load the package without the UIPainter loaded then the painter-specific code will not be installed. A subsequent load of the UIPainter will cause this code to be installed. When you try and load the BGOK package without the UIPainter present you will get the warning 'Attempt to load missing class SpecModel.  OK to proceed?'.  Choose OK to load all but the UIPainter code in BGOK.DbIdentifier: bear73DbTrace: 476693DbUsername: smichaelDbVersion: 8.2 - 1DevelopmentPrerequisites: #(#(#any 'UIPainter' ''))PackageName: BGOKParcel: #('BGOK')ParcelName: BGOKPrintStringCache: (8.2 - 1,smichael)Version: 8.2 - 1Date: 1:07:29 PM November 6, 2015 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.2 (nov15.1) of November 6, 2015 on November 6, 2015 at 1:07:29 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>BG_Chart1</name><environment>Examples</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>data </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Business Graphics-Examples</category><attributes><package>BGOK</package></attributes></class><comment><class-id>Examples.BG_Chart1</class-id><body>Instances is an example that contains a very simple bar chart and an action button.  Hitting the button changes the chart's underlying data, causing the length of the bars to change as well. Instance Variables:	data 	&lt;List&gt;	the chart's data</body></comment><class><name>BG_ChartElementLook</name><environment>UI</environment><super>UI.LookPreferences</super><private>false</private><indexed-type>none</indexed-type><inst-vars>marker lineWidth lineStyle fillMask </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Business Graphics-Support</category><attributes><package>BGOK</package></attributes></class><comment><class-id>UI.BG_ChartElementLook</class-id><body>Instances provided a specialized LookPreferences for Business Graphic charts so that there is control over properties of a Chart view, e.g. line width, line type.Instance Variables:	marker	&lt;Symbol | VisualComponent&gt;  	lineWidth	&lt;Integer&gt; 	lineStyle	&lt; nil | (ByteArray of: Integer)&gt;  	fillMask	&lt;Image | nil&gt;  </body></comment><class><name>BG_ChartAxis</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>scale isAutoScaled title unit labels labelsMarkAt isAutoLabeled majorTick minorTick axisLine borderLine sectionLine sectionMarkAt tickPosition </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Business Graphics-Scales</category><attributes><package>BGOK</package></attributes></class><comment><class-id>UI.BG_ChartAxis</class-id><body>I hold a scale and some variables which is needed when the receiver is displayed as an axis. However, I don't know how to display myself. The Methods for displaying the axis is defined in an object which refers to me.Instance Variables:	scale			&lt;BG_ChartScale&gt; my scale	isAutoScaled	&lt;Boolean&gt; answer true if the receiver sets axis scale automatically.	title				&lt;BG_Banner&gt;  axis title label and its attributes.	unit				&lt;BG_Label&gt; axis unit label and its attributes.	labels 			&lt;BG_LabelList&gt; axis labels and its attributes.	labelsMarkAt 	&lt;Symbol&gt; message selector to find out positions at which labels are displayed. (ex. #majorMarks, #divisionMarks, #edgeMarks, #zeroMarks)	isAutoLabeled 	&lt;Boolean&gt; answer true if the receiver sets axis labels automatically from the receiver's labelMarks. 	majorTick 		&lt;BG_ChartElement&gt; a line	minorTick 		&lt;BG_ChartElement&gt; a line	axisLine 		&lt;BG_ChartElement&gt; a line	borderLine		&lt;BG_ChartElement&gt; a line	sectionLine 		&lt;BG_ChartElement&gt; a line	sectionMarkAt 	&lt;Symbol&gt; message selector to find out positions at which section lines are displayed. 	tickPosition		&lt;#hide|#cross|#inside|#outside&gt;</body></comment><class><name>ChartElementLookSpec</name><environment>UI</environment><super>UI.SubSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>foregroundColor backgroundColor pattern markerType lineType lineWidth </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Business Graphics-Specifications</category><attributes><package>BGOK</package></attributes></class><comment><class-id>UI.ChartElementLookSpec</class-id><body>An sub specification, ChartElementLookSpec describes the look of a data series of thebusiness chart. Instance variables:	backgroundColor	&lt;ColorValue&gt;	color value to use when painting the				background of chart elements from this data series	foregroundColor 		&lt;ColorValue&gt; 	color value to use when painting the				foreground of chart elements from this data series	lineType			&lt;Symbol&gt; 		one of the following symbols: 				#default #solid #dotted #dashed #broken #dotted2 				#dashed2 #broken2. It describes the line style. 	lineWidth			&lt;Integer&gt; 	markerType			&lt;Symbol&gt; 		one of the following symbols:				#square #solidSquare #circle #solidCircle #triangle #solidTrinagle				#triangle2 #solidTrinagle2 #diamond #solidDiamond #cross #x.				it describes a shape of the marker used in line charts	pattern				&lt;Integer&gt; 		a number describing what kind of mask to use				when painting the background of the bar chart elements from this data				series. </body></comment><class><name>LineChartOptionsSpec</name><environment>UI</environment><super>UI.SubSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>showMarker showLine dataLocation spline </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Business Graphics-Specifications</category><attributes><package>BGOK</package></attributes></class><comment><class-id>UI.LineChartOptionsSpec</class-id><body>LineChartOptionsSpec is a sub specification which describes the optional parameters for all types of line charts. Instance variables:	dataLocation 	&lt;#show | #hide&gt; 	determines whether to show data in the chart view or not. 	showLine		&lt;Boolean&gt; 			determines whether to show lines in the chart view or not	showMarker		&lt;Boolean&gt; 			determines whether to show markers in the chart view or not	spline			&lt;Boolean&gt;			if true then chart view will use splines</body></comment><class><name>BG_ChartView</name><environment>UI</environment><super>Graphics.DependentComposite</super><private>false</private><indexed-type>none</indexed-type><inst-vars>optionalBlock plotArea elementLooks widgetState </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Business Graphics-Charts</category><attributes><package>BGOK</package></attributes></class><comment><class-id>UI.BG_ChartView</class-id><body>This class is an abstract class for creating a chart.Instance Variables:		optionalBlock	&lt;BlockClosure&gt; for displaying the user optional images (ex. lead-lines and special legend). The optionalBlock has two arguments. First arg is the receiver and second is a GraphicsContext on which the receiver displays.	plotArea			&lt;Rectangle | nil&gt; relative area for displaying mail part of the receiver.	elementLooks	&lt;OrderedCollection of: LookPreferences&gt;  	widgetState	&lt;WidgetState&gt;Class Variables: 	LooksForLines		&lt;Array of: BG_ChartElementLook&gt; line type preferences.	LooksForMarkers	&lt;Array of: BG_ChartElementLook&gt; marker type preferences.	LooksForRegions	&lt;Array of: BG_ChartElementLook&gt; region type preferences.	</body></comment><class><name>BG_GriddedChartView</name><environment>UI</environment><super>UI.BG_ChartView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dataStyle dataLocation labels legend legendFrame legendLocation grid sortedIndex other descriptors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Business Graphics-Charts</category><attributes><package>BGOK</package></attributes></class><comment><class-id>UI.BG_GriddedChartView</class-id><body>This class is an abstract class for creating a grid chart.Instance Variables:	dataStyle 		&lt;BG_LabelList&gt; plot values and its attributes.	dataLocation	&lt;Symbol&gt; position at which data are displayed.	labels 			&lt;OrderedCollection&gt; collection of label string.	legend 			&lt;BG_LabelList&gt; collection of legend label string and its attributes.	legendFrame 	&lt;Wrapper&gt; legend frame and its attributes.	legendLocation	&lt;Integer&gt; position at which legend are displayed.	grid 			&lt;BG_ChartGrid&gt; transformation for plotting values on the receiver.	sortedIndex 		&lt;Array&gt; private variable to sort data.	other 			&lt;String&gt; or nil. The receiver sorts data in descent order except a label specified by 'other'. If 'other' is nil, then data are not sorted. 	descriptors	&lt;OrderedCollection of: BG_ChartDataSetDescription&gt; collection of data descriptions</body></comment><class><name>BG_BarChartView</name><environment>UI</environment><super>UI.BG_GriddedChartView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>barWidth barOverlap </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Business Graphics-Charts</category><attributes><package>BGOK</package></attributes></class><comment><class-id>UI.BG_BarChartView</class-id><body>Instances are for creating a bar chart.Instance Variables:		barWidth 		&lt;Float&gt; the relative width of bar (0.0 - 1.0)	barOverlap		&lt;Float&gt; the degree to which overlap bars cover each other. (.. - 1.0)</body></comment><class><name>BG_StackedBarChartView</name><environment>UI</environment><super>UI.BG_BarChartView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>showLink </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Business Graphics-Charts</category><attributes><package>BGOK</package></attributes></class><comment><class-id>UI.BG_StackedBarChartView</class-id><body>Instances are for creating a stacked bar chart.Instance Variables:		showLink 		&lt;Boolean&gt; flag represents whether the receiver shows lines that link together stack.		</body></comment><class><name>BG_LayerChartView</name><environment>UI</environment><super>UI.BG_StackedBarChartView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Business Graphics-Charts</category><attributes><package>BGOK</package></attributes></class><comment><class-id>UI.BG_LayerChartView</class-id><body>Instances are for creating a layer chart.</body></comment><class><name>BG_StockTool</name><environment>Examples</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>quotes stocks data chartView </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Business Graphics-Examples</category><attributes><package>BGOK</package></attributes></class><comment><class-id>Examples.BG_StockTool</class-id><body>A simple stock tool.  Consists of a list view and a line chart.  When the user selects a stock symbol in the list view, the chart displays values for the selected stock. Use the 'Load data...' menu pick to load quotes.Instance Variables:	quotes &lt;OrderedCollection of: BG_StockQuote&gt; 	contains stock quotes.	stocks &lt;SelectionInList&gt;	the list contains symbols of stocks present in quotes.	data   &lt;ValueHolder on: (OrderedCollection of: BG_StockQuote)&gt; holds the		selected quotes	chartView	&lt;BG_LineChartView&gt;	the chart widget</body></comment><class><name>BG_LineChartView</name><environment>UI</environment><super>UI.BG_GriddedChartView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>showMarker showLine </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Business Graphics-Charts</category><attributes><package>BGOK</package></attributes></class><comment><class-id>UI.BG_LineChartView</class-id><body>Instances are for creating a line chart.Instance Variables:		showMarker		&lt;Boolean&gt; flag represents whether the receiver shows markers.	showLine		&lt;Integer&gt; which type lines are shown.</body></comment><class><name>BG_XYChartView</name><environment>UI</environment><super>UI.BG_LineChartView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Business Graphics-Charts</category><attributes><package>BGOK</package></attributes></class><comment><class-id>UI.BG_XYChartView</class-id><body>Instances are for creating a XY (scatter) chart.</body></comment><class><name>ChartColorTool</name><environment>Tools</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cubesBrightness cubeColors colorValue lookPreferences </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Business Graphics-Specifications</category><attributes><package>BGOK</package></attributes></class><comment><class-id>Tools.ChartColorTool</class-id><body>ChartColorTool is used to assign, display and edit the color policies governing the appearance of data series displayed in a ChartView.Colors can be generated for use in color policies using either the color cube, a rectangular color map display which includes a brightness slider, or an HSV  triplet of analog sliders, or a menu of named colors.  The color cube gives decent but not exhaustive coverage of the available colors in the Screen palette; the sliders can sometimes turn up a few more.  The Hue slider will appear only when the Saturation slider is not zeroed; similarly the Saturation slider will appear only when the Value slider is not zeroed.  The menu of named colors can be summoned by pressing the select mouse button while the cursor is inside the color patch underneath the sliders.Once a color has been selected either by pointing into the color cube, moving the sliders, or selecting a named color, it can be moved to the appropriate display patch at the bottom of the tool by clicking on the policy color patch.Instance Variables:	cubesBrightness	&lt;ValueHolder with: ColorValue&gt;  Brightness setting for the color cube	cubeColors	&lt;OrderedCollection of: ValueHolder on: ColorValue&gt;  The value holders behind the 'paint chips' in the color cube	colorValue	&lt;ValueHolder on: ColorValue&gt;  The color in the master color patch under the sliders	lookPreferences	&lt;LookPreferences&gt;  The current settings of all four policy colors</body></comment><class><name>BG_SalesItem</name><environment>Examples</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>salesHP salesMac salesRS salesSun salesWin month </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Business Graphics-Examples</category><attributes><package>BGOK</package></attributes></class><comment><class-id>Examples.BG_SalesItem</class-id><body>Instances represent sales by platforms for a particular month.Instance Variables:	month 	&lt;String&gt; 	a month name	salesHP &lt;Number&gt; 	a number of boxes sold on HP platform	salesWin &lt;Number&gt; 	a number of boxes sold on Windows platform	salesMac &lt;Number&gt; 	a number of boxes sold on Mac platform	salesSun &lt;Number&gt; 	a number of boxes sold on Sun platform	salesRS	 &lt;Number&gt; 	a number of boxes sold on RS6000 platform</body></comment><class><name>BG_TextLabel</name><environment>UI</environment><super>UI.Label</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Smalltalk.TextConstants.*			</imports><category>Business Graphics-Labels</category><attributes><package>BGOK</package></attributes></class><comment><class-id>UI.BG_TextLabel</class-id><body>This class specializes Label to add any protocol Charts might find convenient.</body></comment><class><name>BG_ChartScale</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sourceMin sourceMax destMin destMax step zero increase div </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Business Graphics-Scales</category><attributes><package>BGOK</package></attributes></class><comment><class-id>UI.BG_ChartScale</class-id><body>BG_ChartScale represents a part of linear scaler to translate a value from source coodinates (sc) to destination coodinates (dc).		applyTo: aSourceValue					answer translated value in dc.	applyInverseTo: aDestinationValue		answer translated value in sc.Instance Variables:	sourceMin		&lt;Number&gt; minimum value in sc.	sourceMax		&lt;Number&gt; maximum value in sc. (&gt; sourceMin)	destMin			&lt;Number&gt; minimum value in dc.	destMax			&lt;Number&gt; maximum value in dc. (&gt; destMin)	step				&lt;Number&gt; interval (in sc) represents receiver's major division (&gt; 0).	zero			&lt;Number&gt; original value to count step in sc.	increase		&lt;Boolean&gt; flag to answer true when source value increases, destination value increases.	div				&lt;Integer&gt; step / div (in sc) represents receiver's minor division (&gt;= 1).</body></comment><class><name>BG_ChartLogScale</name><environment>UI</environment><super>UI.BG_ChartScale</super><private>false</private><indexed-type>none</indexed-type><inst-vars>base </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Business Graphics-Scales</category><attributes><package>BGOK</package></attributes></class><comment><class-id>UI.BG_ChartLogScale</class-id><body>Instances represent a part of logarithmic scaler.Instance Variables:	base	&lt;Number&gt; base of logarithmic scale</body></comment><class><name>BG_ChartGrid</name><environment>UI</environment><super>Graphics.VisualPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>x y transposed </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Business Graphics-Scales</category><attributes><package>BGOK</package></attributes></class><comment><class-id>UI.BG_ChartGrid</class-id><body>Instances are for creating a grid.Instance Variables:	x			&lt;BG_ChartAxis&gt; x axis	y			&lt;BG_ChartAxis&gt; y axis	transposed	&lt;Boolean&gt;</body></comment><class><name>BG_Label</name><environment>UI</environment><super>Graphics.VisualComponent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>item extent textStyle emphasis decoration format foregroundColor image converter </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Business Graphics-Labels</category><attributes><package>BGOK</package></attributes></class><comment><class-id>UI.BG_Label</class-id><body>Instances provide the support for creating and displaying image of any object with its characteristics such as text style and emphasis.Instance Variables:		item 				&lt;Object | nil&gt; object displayed by the receiver.	extent				&lt;Point&gt; composition extent.	textStyle				&lt;TextAttributes&gt;	emphasis			&lt;Symbol | (Array of: Symbol) | nil&gt;	decoration			&lt;String | nil&gt; to decorate image of the receiver by replacing its all occurrences of $# with string to which item has been converted by the receiver	format				&lt;Integer&gt; to format item	foregroundColor		&lt;ColorValue | nil&gt;	image 				&lt;VisualComponent&gt; for caching the bit representation of the receiver's composed text.Class Variables:	FormatConstraint		&lt;Dictionary&gt; for checking constraint of formats.</body></comment><class><name>BG_IconicLabel</name><environment>UI</environment><super>UI.BG_Label</super><private>false</private><indexed-type>none</indexed-type><inst-vars>icon mode gap </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Business Graphics-Labels</category><attributes><package>BGOK</package></attributes></class><comment><class-id>UI.BG_IconicLabel</class-id><body>Instances represents a label with an icon.Instance Variables:	icon	&lt;VisualComponent&gt; the "Icon".	mode	&lt;Integer&gt; display mode of the receiver. (0: icon left 1: label left 2: icon only 3: label only 4: icon top 5: label top)	gap		&lt;Integer&gt; interval icon and label when the receiver displayed</body></comment><class><name>ChartingAxisSpec</name><environment>UI</environment><super>UI.SubSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>scale title unit tickPosition axisLine borderLine sectionLine sectionMarkAt </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Business Graphics-Specifications</category><attributes><package>BGOK</package></attributes></class><comment><class-id>UI.ChartingAxisSpec</class-id><body>ChartingAxisSpec describes the basic properties of a chart axis. Notethat this spec describes strictly the properties of axis. It is thejob of ChartingScaleSpec to describe the properties of the chartscale.Instance variables:	axisLine 	&lt;Boolean&gt; determines whether to show or hide an axis line	borderLine 	&lt;Boolean&gt; determines whether to show or hide a border line	scale	   	&lt;ChartingScaleSpec&gt;	scale description	sectionLine 	&lt;Boolean&gt; determines whether to show or hide section lines	sectionMarkAt 	&lt;Symbol&gt; 	Area to draw the section lines. A symbol is one of the			following: 			#none #majorMarks #minorMarks #divisionMarks #edgeMarks #zeroMarks 	tickPosition &lt;Symbol&gt; Determines where to draw the ticks, and if the ticks should be drawn. 	title	     &lt;String&gt; The title of the axis. If the string starts with:			$# then it is treated as symbol and is sent to the application model,			which provides a real title. 	unit	     &lt;String&gt; a unit used for this axis. If the string starts with:			$# then it is treated as symbol and is sent to the application model,			which provides a real unit. </body></comment><class><name>ChartingValueAxisSpec</name><environment>UI</environment><super>UI.ChartingAxisSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>labelsMarkAt labelFormat </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Business Graphics-Specifications</category><attributes><package>BGOK</package></attributes></class><comment><class-id>UI.ChartingValueAxisSpec</class-id><body>ChartingValueAxisSpec describes the  properties of a chart data axis. It adds to the ChartingAxisSpec positioning labels and labelformatting.Instance variables:	labelFormat		&lt;Symbol&gt; the format of labels. One of the following symbols is used: 		#general #asterisk #comma #float #percent	labelsMarkAt	&lt;Symbol&gt; the position of labels. One of the following symbols is used: 		#none #majorMarks #minorMarks #divisionMarks #edgeMarks #zeroMarks </body></comment><class><name>BG_Company</name><environment>Examples</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>employees </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Business Graphics-Examples</category><attributes><package>BGOK</package></attributes></class><comment><class-id>Examples.BG_Company</class-id><body>Instances are a simple example illustrating the use of data series.It displays the information (salary and age of employees) as a line chart.Instance Variables:	employees &lt;List&gt;	a collection of the company's employees</body></comment><class><name>ChartDataSpec</name><environment>UI</environment><super>UI.SubSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>series </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Business Graphics-Specifications</category><attributes><package>BGOK</package></attributes></class><comment><class-id>UI.ChartDataSpec</class-id><body>A sub specification, ChartDataSpec describes the data series of the business chart. It holds a collection of sub specifications describing single data sets. Instance variables:	 series &lt;Array of: ChartDataSetSpec&gt; contains a definition of the data series</body></comment><class><name>BG_DataPointMarker</name><environment>UI</environment><super>Graphics.VisualComponent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>borderImage internalImage path </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Business Graphics-Support</category><attributes><package>BGOK</package></attributes></class><comment><class-id>UI.BG_DataPointMarker</class-id><body>Instances of BG_DataPointMarker display a bordered geometric symbol or user defined image as a data point marker.Instance Variables:	borderImage	&lt;BG_Label | CachedImage&gt;	visual for marker border.	internalImage	&lt;BG_Label | CachedImage&gt;	visual for marker interior.	path	&lt;Geometric&gt;	 alternate marker geometric to be displayed if graphics medium is not a Screen. Class Variables:	NamedMarkers &lt;IdentityDictionary of: BG_DataPointMarker&gt;  common markers identified by name symbol	</body></comment><class><name>ChartingScaleSpec</name><environment>UI</environment><super>UI.SubSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>min max step zero base minorDivisions scaleType autoScale invert restrictions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Business Graphics-Specifications</category><attributes><package>BGOK</package></attributes></class><comment><class-id>UI.ChartingScaleSpec</class-id><body>ChartingScaleSpec describes the basic properties of the charting scale.Instance variables:	autoScale	&lt;Boolean&gt;	determines whether the scale is set by the user or computed by the view	min			&lt;Number&gt; 	minimum value in source coordinates.	max			&lt;Number&gt; 	maximum value in source coordinates. (&gt; sourceMin)	step		&lt;Number&gt; 	the interval which represents the major division (&gt; 0).	zero		&lt;Number&gt; 	the starting value of count steps	invert		&lt;Boolean&gt; 	false if source and destination increase in the same direction	minorDivisions		&lt;Integer&gt;  	number of minor divisions by step	base 		&lt;Number&gt; base of logarithmic scale	scaleType	&lt;Symbol&gt; 	determines weather the scale is linear or logarithmic 	restrictions	&lt;Set of: Symbol&gt; some charts cannot accept all scale types.		See the ChartView&gt;&gt;setDataScaleRestrictions: method and its senders.</body></comment><class><name>BG_StockQuote</name><environment>Examples</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>symbol date price </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Business Graphics-Examples</category><attributes><package>BGOK</package></attributes></class><comment><class-id>Examples.BG_StockQuote</class-id><body>Instances are a simple stock quote representing date of quote, stock value, and stock symbol. Instance Variables:	date &lt;Date&gt;		date of quote.	price &lt;Float&gt;	the stock value	symbol &lt;String&gt;	the stock symbol</body></comment><class><name>ChartScaleSpecModel</name><environment>Tools</environment><super>Tools.SpecModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>min max zero minorDivisions base step autoScale scaleType invert </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Business Graphics-Specifications</category><attributes><package>BGOK</package></attributes></class><class><name>BG_PictureChartView</name><environment>UI</environment><super>UI.BG_BarChartView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>picture unit </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Business Graphics-Charts</category><attributes><package>BGOK</package></attributes></class><comment><class-id>UI.BG_PictureChartView</class-id><body>Instances are for creating a picture bar (unit) chart.Instance Variables:		picture 		 &lt;BG_Banner&gt; the form and its attributes.	unit			&lt;Number&gt; value per one picture.		</body></comment><class><name>BarChartOptionsSpec</name><environment>UI</environment><super>UI.SubSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>overlap width dataLocation picture unit showLink </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Business Graphics-Specifications</category><attributes><package>BGOK</package></attributes></class><comment><class-id>UI.BarChartOptionsSpec</class-id><body>A sub specification which describes optional parameters for all kinds of bar charts. Instance variables:	overlap		&lt;Number&gt; 	defines the degree of the bar overlap, 0 to 1.	width		&lt;Number&gt; 	defines the relative width of the bar, 0 to 1.	dataLocation	&lt;#none | #inside | #outside&gt; 	defines how data is shown. e.g. #inside means inside the bar.	picture		&lt;Symbol&gt; 			defines the aspect that provides the image from the application model   	unit           	&lt;Number&gt; 			defines the picture's unit    	showLink 	&lt;Boolean&gt; 			controls the appearance of a link line connecting data in Stacked Bar charts and Band Charts.</body></comment><class><name>BG_StepChartView</name><environment>UI</environment><super>UI.BG_LineChartView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Business Graphics-Charts</category><attributes><package>BGOK</package></attributes></class><comment><class-id>UI.BG_StepChartView</class-id><body>Instances are for creating a step line chart.</body></comment><class><name>ChartViewSpec</name><environment>UI</environment><super>UI.WidgetSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>chartType dataLocation orientation dataSeries options xAxis xDataAxis yAxis legendPosition </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Business Graphics-Specifications</category><attributes><package>BGOK</package></attributes></class><comment><class-id>UI.ChartViewSpec</class-id><body>ChartViewSpec describes a component that is an instance of one of theChartView classes. Possible chart types are: 	Bar, Pareto, Picture, Stacked Bar, Band, 	Layer, Line, StackedLine, Step, X, Pie. The model for this view is an indexable collection of objects. Anaccess path for each data series is described in the 'dataSeries' instancevariable. Instance variables:	chartType 	&lt;Symbol&gt; 	dataLocation &lt;Symbol&gt; 	describes where and if the numeric							data is shown on the chart view.	orientation 	&lt;Symbol&gt;	determines weather a chart transposed or not	dataSeries  	&lt;ChartDataSpec&gt; definition of data series	options     	&lt;*ChartOptionsSpec&gt; chart options	xAxis       	&lt;ChartingAxisSpec&gt;  item axis	xDataAxis   	&lt;ChartingValueAxisSpec&gt; x axis for XY charts	yAxis	    	&lt;ChartingValueAxisSpec&gt; data axis	legendPosition &lt;Number&gt; 	describes where and if the legend			      			is shown.Class variables:	ChartTypes	&lt;Dictionary&gt;	 Contains chart properties; see ChartViewSpec class&gt;&gt;initalize							method.</body></comment><class><name>BG_Banner</name><environment>UI</environment><super>UI.BG_Label</super><private>false</private><indexed-type>none</indexed-type><inst-vars>rotation scale isAutoScaled </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Business Graphics-Labels</category><attributes><package>BGOK</package></attributes></class><comment><class-id>UI.BG_Banner</class-id><body>Instances provide the support for creating and displaying scaled and rotated image of the object.Instance Variables:	rotation			&lt;Integer&gt; rotation angle for displaying object. (0 means unchanged, 1 means clockwise 90 degrees, and so on)	scale			&lt;Point&gt; magnification/shrinkage for displaying object.	isAutoScaled	&lt;Boolean&gt; whether the receiver is auto scaled or not</body></comment><class><name>BG_EzChart</name><environment>Examples</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Business Graphics-Examples</category><attributes><package>BGOK</package></attributes></class><comment><class-id>Examples.BG_EzChart</class-id><body>Instances display a simple bar chart. Two interface specs are provided:windowSpec uses one data series only and windowSpec2 usestwo data series and labels.</body></comment><class><name>ChartDataSetSpec</name><environment>UI</environment><super>UI.SubSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>aspect isData name look isComputed </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Business Graphics-Specifications</category><attributes><package>BGOK</package></attributes></class><comment><class-id>UI.ChartDataSetSpec</class-id><body>ChartDataSetSpec is a sub specification describing access paths for a data series.  It also describes the look (appearance) of the data series.Instance variables:	aspect		&lt;Symbol&gt;	a path for a data series. 	isComputed &lt;Boolean&gt;	if true, an aspect message is sent							to the application model which answers a two argument block.							This block is used as a get block while constructing table							adaptor.	isData		&lt;Boolean&gt;	if false the series describes							labels, not data points.	look   		&lt;ChartElementLookSpec&gt;	the appearance of the data series	name   		&lt;String&gt;			name of the data series. This 								name is used in the chart legend.</body></comment><class><name>PieChartOptionsSpec</name><environment>UI</environment><super>UI.SubSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>shape explode doughnutLabel showLines dataLocation sortSlices </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Business Graphics-Specifications</category><attributes><package>BGOK</package></attributes></class><comment><class-id>UI.PieChartOptionsSpec</class-id><body>PieChartOptionsSpec is a sub specification which describes optional parameters for pie charts. Instance variables:	dataLocation 	&lt;#dataAdjacent | #dataBelow | #hide&gt; 	determines whether and where to show		 data in the chart view.	showLines		&lt;#show | #hide&gt; 	determines whether to show lines connecting data 		in the chart view.	doughnutLabel	&lt;String&gt; 	label that is shown in the center of the chart.	explode			&lt;String&gt;		this string is matched against labels of the pie chart. If		it matches then the pie is drawn as an exploded pie.	shape			&lt;Symbol&gt;	determines whether the chart is a circle or an ellipse</body></comment><class><name>BG_ChartElement</name><environment>UI</environment><super>Graphics.GeometricWrapper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stroke fill lineWidth shadowOffset </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Business Graphics-Support</category><attributes><package>BGOK</package></attributes></class><comment><class-id>UI.BG_ChartElement</class-id><body>BG_ChartElement is used to render and specify the appearence of any geometric appearing in a chart such as a line, bar, or arc.  Instance Variables:	fill	&lt;Boolean&gt;	fill component if true and component may be filled.	lineWidth	&lt;SmallInteger | nil&gt;	width of the line used for rendering component.	shadowOffset	&lt;Point&gt;	extent a shadow will be drawn from component.	stroke	&lt;Boolean&gt;	draw component outline if true.Class Variables:	Patterns	&lt;OrderedCollection of: ByteArray&gt; bit pattern choices to mask or fill element images	ShadeMaker &lt;OrderedDither&gt; halftone to shade elements	</body></comment><class><name>BG_ChartDataSetDescription</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>adaptor hasData name foregroundColor backgroundColor pattern markerType lineType lineWidth </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Business Graphics-Support</category><attributes><package>BGOK</package></attributes></class><comment><class-id>UI.BG_ChartDataSetDescription</class-id><body>BG_ChartDataSetDescription describes the look of a data series as obtained from a model. See also class ChartElementLookSpec.Instance Variables:	adaptor	&lt;ValueModel&gt;	data model.	foregroundColor		&lt;ColorValue | nil&gt;  color value to use when painting the 		background of chart elements.	backgroundColor	&lt;ColorValue | nil&gt;  color value to use when painting the 			foreground of chart elements.	hasData	&lt;Boolean&gt;	if false the adaptor has labels, not data points.	lineType	&lt;Symbol&gt; 		one of the following symbols: 				#default #solid #dotted #dashed #broken #dotted2 				#dashed2 #broken2. It describes the line style. 	lineWidth	&lt;SmallInteger&gt;	 pixel width of lines drawn.	markerType	&lt;Symbol&gt; 		one of the following symbols:				#square #solidSquare #circle #solidCircle #triangle #solidTrinagle				#triangle2 #solidTrinagle2 #diamond #solidDiamond #cross #x.				It describes a shape of the marker used in line charts.	name		&lt;String&gt;	name of data series.	pattern	&lt;Integer&gt; 		a number describing what kind of mask to use				when painting the background of the bar chart elements from this data				series. </body></comment><class><name>BG_BandChartView</name><environment>UI</environment><super>UI.BG_StackedBarChartView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>rates </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Business Graphics-Charts</category><attributes><package>BGOK</package></attributes></class><comment><class-id>UI.BG_BandChartView</class-id><body>Instances are for creating a band chart.Instance Variables:		rates 			&lt;BG_TableAdaptor&gt; quantitative data in percents</body></comment><class><name>BG_Sales</name><environment>Examples</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sales </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Business Graphics-Examples</category><attributes><package>BGOK</package></attributes></class><comment><class-id>Examples.BG_Sales</class-id><body>Instances illustrate a simple line chart that uses two data series.Instance Variables:	sales	&lt;List of: BG_SalesItem&gt;		the sales data</body></comment><class><name>BG_StackedLineChartView</name><environment>UI</environment><super>UI.BG_LineChartView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Business Graphics-Charts</category><attributes><package>BGOK</package></attributes></class><comment><class-id>UI.BG_StackedLineChartView</class-id><body>Instances are for creating a stacked line chart.</body></comment><class><name>BG_ParatoChartView</name><environment>UI</environment><super>UI.BG_BarChartView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>auxGrid </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Business Graphics-Charts</category><attributes><package>BGOK</package></attributes></class><comment><class-id>UI.BG_ParatoChartView</class-id><body>Instance are for creating a parato chart.Instance Variables:	auxGrid 		&lt;BG_ChartGrid&gt; only y axis used for displaying percentage value</body></comment><class><name>ChartDataSpecModel</name><environment>Tools</environment><super>Tools.SpecModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>seriesName seriesAspect isLabel selectedIndex selectedSeries menuHolder isComputed </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Business Graphics-Specifications</category><attributes><package>BGOK</package></attributes></class><class><name>BG_PieChartView</name><environment>UI</environment><super>UI.BG_GriddedChartView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>isEllipse rates explode doughnutLabel sortSlices </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Business Graphics-Charts</category><attributes><package>BGOK</package></attributes></class><comment><class-id>UI.BG_PieChartView</class-id><body>Instances are for creating a pie chart.Instance Variables:		isEllipse 		&lt;Boolean&gt; flag to find out the receiver's shape. if 'isEllipse' is true, the shape is ellipse, otherwise circle.	rates	&lt;BG_TableAdaptor of: SequenceableCollection&gt;  quantitative data in percents.	explode	&lt;Array of: String&gt;  collection of label which a slice is emphasized.	doughnutLabel	&lt;BG_Label&gt; a label for center	sortSlices			&lt;Boolean&gt;</body></comment><class><name>BG_TableAdaptor</name><environment>UI</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dependents baseCollection adaptors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Business Graphics-Support</category><attributes><package>BGOK</package></attributes></class><comment><class-id>UI.BG_TableAdaptor</class-id><body>BG_TableAdaptor is used to provide two-dimensional data access to a collection of records for a SelectionInList.  The data records (which provide the basis for the rows of the table) are held in a SequenceableCollection and accessed using a RowAdaptor.  If the size of the table is to be changed dynamically, the data records should be held in a List or OrderedCollection.The difference between TableAdaptor and BG_TableAdaptor is the collection determines number of rows. Instance Variables:	dependents	&lt;Object | nil&gt;  Typically this is the BG_ChartView served by the BG_TableAdaptor	baseCollection	&lt;ArrayedCollection&gt;  A collection of records which will be presented one per row	adaptors	&lt;Collection of: BG_ChartDataSetDescriptions&gt;  An n-tuple of getBlock, putBlock pairs for adapting arbitrary aspects of the records</body></comment><class><name>BG_Employee</name><environment>Examples</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name age salary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Business Graphics-Examples</category><attributes><package>BGOK</package></attributes></class><comment><class-id>Examples.BG_Employee</class-id><body>Instances describe employees in terms of the employee's name, age, and salary. Instance Variables:	name	&lt;String&gt;		employee's name	age		&lt;Number&gt;	employee's age	salary	&lt;Number&gt;	employee's salary</body></comment><class><name>BG_LabelList</name><environment>UI</environment><super>UI.BG_Label</super><private>false</private><indexed-type>none</indexed-type><inst-vars>column individualImages individualExtent </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Business Graphics-Labels</category><attributes><package>BGOK</package></attributes></class><comment><class-id>UI.BG_LabelList</class-id><body>Instances provide a more efficient representation of lists. The receiver's item must be kind of SequenceableCollection.Instance Variables:	column				&lt;Integer&gt; number of column	individualImages		&lt;Array&gt; contains image of each element of item 	individualExtent  	&lt;Point&gt; composition extent of each image</body></comment><class><name>BG_ChartPolarGrid</name><environment>UI</environment><super>UI.BG_ChartGrid</super><private>false</private><indexed-type>none</indexed-type><inst-vars>center xyRate </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Business Graphics-Scales</category><attributes><package>BGOK</package></attributes></class><comment><class-id>UI.BG_ChartPolarGrid</class-id><body>Instances are for creating a polar grid.Instance Variables:	center	&lt;Point&gt;	xyRate	&lt;Float&gt;</body></comment><shared-variable><name>Patterns</name><environment>UI.BG_ChartElement</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>BGOK</package></attributes></shared-variable><shared-variable><name>ShadeMaker</name><environment>UI.BG_ChartElement</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>BGOK</package></attributes></shared-variable><shared-variable><name>ChartTypes</name><environment>UI.ChartViewSpec</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>BGOK</package></attributes></shared-variable><shared-variable><name>NamedMarkers</name><environment>UI.BG_DataPointMarker</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>BGOK</package></attributes></shared-variable><shared-variable><name>LooksForLines</name><environment>UI.BG_ChartView</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>BGOK</package></attributes></shared-variable><shared-variable><name>LooksForMarkers</name><environment>UI.BG_ChartView</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>BGOK</package></attributes></shared-variable><shared-variable><name>LooksForRegions</name><environment>UI.BG_ChartView</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>BGOK</package></attributes></shared-variable><shared-variable><name>FormatConstraint</name><environment>UI.BG_Label</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>BGOK</package></attributes></shared-variable><methods><class-id>Examples.BG_Chart1</class-id> <category>update</category><body package="BGOK">update	| rnd max |	rnd := Random new.	max := 20.	1 to: 3		do: 			[:i | 			| index |			index := (rnd next * self data size) floor + 1.			self data at: index put: max * rnd next]</body></methods><methods><class-id>Examples.BG_Chart1</class-id> <category>data</category><body package="BGOK">data	^data</body></methods><methods><class-id>Examples.BG_Chart1</class-id> <category>initialize</category><body package="BGOK">initialize	super initialize.	data := List new.	1 to: 10 do: [:i | data add: i]</body></methods><methods><class-id>UI.BG_ChartElementLook</class-id> <category>accessing</category><body package="BGOK">fillMask	^fillMask</body><body package="BGOK">fillMask: newMaskOrNil	fillMask := newMaskOrNil</body><body package="BGOK">lineStyle	^lineStyle</body><body package="BGOK">lineStyle: newStyle	lineStyle := newStyle</body><body package="BGOK">lineWidth	^lineWidth</body><body package="BGOK">lineWidth: newWidth	lineWidth := newWidth</body><body package="BGOK">lineWidthAndStyle	^Array with: self lineWidth with: self lineStyle</body><body package="BGOK">lineWidthAndStyle: array	self lineWidth: (array at: 1).	self lineStyle: (array at: 2).</body><body package="BGOK">marker	^marker isSymbol		ifTrue: [BG_DataPointMarker imageAt: marker]		ifFalse: [marker]</body><body package="BGOK">marker: aVisualComponent	marker := aVisualComponent</body></methods><methods><class-id>UI.BG_ChartElementLook class</class-id> <category>instance creation</category><body package="BGOK">from: aLookPreferences	| copy |	(aLookPreferences isKindOf: self)		ifTrue: [^aLookPreferences].	copy := self new.	copy lineWidth: 0.	copy setForegroundColor: aLookPreferences foregroundColor.	copy setSelectionForegroundColor: aLookPreferences selectionForegroundColor.	copy setBackgroundColor: aLookPreferences backgroundColor.	copy setSelectionBackgroundColor: aLookPreferences selectionBackgroundColor.	copy setBorderColor: aLookPreferences borderColor.	^copy</body><body package="BGOK">new	^super new		lineWidth: 0;		yourself</body></methods><methods><class-id>UI.BG_ChartAxis</class-id> <category>lines</category><body package="BGOK">axisLine	"Answer a Line to display axis line"	^axisLine</body><body package="BGOK">borderLine	"Answer a Line to display border line"	^borderLine</body><body package="BGOK">hideAxisLine	axisLine drawLine: false</body><body package="BGOK">hideBorderLine	borderLine drawLine: false</body><body package="BGOK">hideSectionLine	sectionLine drawLine: false</body><body package="BGOK">sectionLine	"Answer a Line to display section line"	^sectionLine</body><body package="BGOK">sectionMarkAt	"Answer a Symbol which represents the messege selector to find out the positions at which section are displayed"	^sectionMarkAt</body><body package="BGOK">sectionMarkAt: aSymbol	"Make the argument, aSymbol, the messege selector to find out the positions at which section are displayed"	sectionMarkAt := aSymbol</body><body package="BGOK">sectionMarks	"Answer positions to display axis section" 	^scale perform: sectionMarkAt</body><body package="BGOK">showAxisLine	axisLine drawLine: true</body><body package="BGOK">showBorderLine	borderLine drawLine: true</body><body package="BGOK">showSectionLine	sectionLine drawLine: true</body></methods><methods><class-id>UI.BG_ChartAxis</class-id> <category>title/unit/labels</category><body package="BGOK">autoLabels	"Set a flag to find out axis labels automatically from the receiver's labelMarks."	isAutoLabeled := true</body><body package="BGOK">isAutoLabeled	"Answer true if the receiver sets axis labels automatically"  	^isAutoLabeled</body><body package="BGOK">labels	"Answer axis label items"	^labels item</body><body package="BGOK">labels: collectionOfString	"Make the argument, collectionOfString, the axis labels"	labels item: collectionOfString</body><body package="BGOK">labelsMarkAt	"Answer a Symbol which represents the messege selector to find out the positions at which labels are displayed"	^labelsMarkAt</body><body package="BGOK">labelsMarkAt: aSymbol	"Make the argument, aSymbol, the messege selector to find out the positions at which labels are displayed"	labelsMarkAt := aSymbol</body><body package="BGOK">labelsMarks	"Answer positions to display axis labels" 	^scale perform: labelsMarkAt</body><body package="BGOK">labelsStyle	"Answer a BG_LabelList represents axis labels attributes"	^labels</body><body package="BGOK">manualLabels	"Set a flag to find out axis labels from instace variable 'labels'."	isAutoLabeled := false</body><body package="BGOK">setLabelFormat: aSymbol 	| lbls |	lbls := self labelsStyle.	lbls notNil ifTrue: [lbls formatType: aSymbol]</body><body package="BGOK">title	"Answer axis title item"	^title item</body><body package="BGOK">title: aString	"Make the argument, aString, the axis title"	title item: aString</body><body package="BGOK">titleStyle	"Answer a BG_Banner represents axis title attributes"	^title</body><body package="BGOK">unit	"Answer axis unit item"	^unit item</body><body package="BGOK">unit: aString	"Make the argument, aString, the axis unit"	unit item: aString</body><body package="BGOK">unitStyle	"Answer a BG_Label represents axis unit attributes"	^unit</body></methods><methods><class-id>UI.BG_ChartAxis</class-id> <category>initialize-release</category><body package="BGOK">compose	"Sets axis labels and scale automatically from the receiver's labelMarks"	isAutoLabeled		ifTrue: 			[| newLabels |			newLabels := self labelsMarks.			newLabels = self labels ifFalse: [self labels: newLabels]]		ifFalse: [isAutoScaled				ifTrue: 					[labelsMarkAt == #divisionMarks 						ifTrue: [self scale sourceMin: 0.5 max: labels item size + 0.5; zero: 0.5]						ifFalse: [self scale sourceMin: 1 max: labels item size; zero: 1].					self scale step: 1; div: 1]]</body><body package="BGOK">dataAxis	self autoScale.	self autoLabels.	self labelsMarkAt: #majorMarks.	self tickInside.</body><body package="BGOK">fixedDataAxis	self manualScale.	self autoLabels.	self labelsMarkAt: #majorMarks.	self tickInside.</body><body package="BGOK">getLookPreferences	^axisLine lookPreferences</body><body package="BGOK">initialize	scale := BG_ChartScale min: 0 max: 100 by: 20 from: 0.	title := BG_Banner new.	unit := BG_Label new.	labels := BG_LabelList new.	majorTick := BG_ChartElement new.	minorTick := BG_ChartElement new.	axisLine := BG_ChartElement new.	borderLine := BG_ChartElement new.	sectionLine := BG_ChartElement new.	self sectionMarkAt: #majorMarks.	self dataAxis.</body><body package="BGOK">itemAxis	self autoScale.	self manualLabels.	self labelsMarkAt: #divisionMarks.	self hideTick</body><body package="BGOK">manualAxis	self manualScale.	self manualLabels</body><body package="BGOK">newGraphicsDevice: aGraphicsDevice 	title newGraphicsDevice: aGraphicsDevice.	unit newGraphicsDevice: aGraphicsDevice.	labels newGraphicsDevice: aGraphicsDevice.</body></methods><methods><class-id>UI.BG_ChartAxis</class-id> <category>tick marks</category><body package="BGOK">hideTick	"No tick marks"	tickPosition := #hideTick.	majorTick drawLine: false.	minorTick drawLine: false</body><body package="BGOK">majorTick	"Answer a Line to display major tick marks"	^majorTick</body><body package="BGOK">minorTick	"Answer a Line to display minor tick marks"	^minorTick</body><body package="BGOK">tickCross	"Set tick marks to display cross the frame"	tickPosition := #tickCross.	majorTick		drawLine: true;		geometric: (LineSegment from: 0 @ -2 to: 0 @ 2).	minorTick		drawLine: true;		geometric: (LineSegment from: 0 @ -1 to: 0 @ 1)</body><body package="BGOK">tickInside	"Set tick marks to display inside the frame"	tickPosition := #tickInside.	majorTick drawLine: true; geometric: (LineSegment from: 0@0 to: 0@4).	minorTick drawLine: true; geometric: (LineSegment from: 0@0 to: 0@2).</body><body package="BGOK">tickOutside	"Set tick marks to display outside the frame"	tickPosition := #tickOutside.	majorTick		drawLine: true;		geometric: (LineSegment from: 0 @ 0 to: 0 @ -4).	minorTick		drawLine: true;		geometric: (LineSegment from: 0 @ 0 to: 0 @ -2)</body><body package="BGOK">tickPosition	"Return tick position"	^tickPosition</body></methods><methods><class-id>UI.BG_ChartAxis</class-id> <category>scale</category><body package="BGOK">autoScale	isAutoScaled := true</body><body package="BGOK">isAutoScaled	^isAutoScaled</body><body package="BGOK">manualScale	isAutoScaled := false</body><body package="BGOK">newScaleOfType: aSymbol 	| newScale |	newScale := (aSymbol == #log				ifTrue: [BG_ChartLogScale]				ifFalse: [BG_ChartScale]) default.	self scale: newScale</body><body package="BGOK">scale	^scale</body><body package="BGOK">scale: aScale	"Make the argument, aScale, the axis scale"	scale := aScale</body></methods><methods><class-id>UI.BG_ChartAxis class</class-id> <category>instance creation</category><body package="BGOK">new	^super new initialize</body></methods><methods><class-id>UI.ChartElementLookSpec</class-id> <category>accessing</category><body package="BGOK">backgroundColor	^backgroundColor</body><body package="BGOK">backgroundColor: aValue	backgroundColor := aValue</body><body package="BGOK">foregroundColor	^foregroundColor</body><body package="BGOK">foregroundColor: aValue	foregroundColor := aValue</body><body package="BGOK">lineType	^lineType == #default ifTrue: [nil] ifFalse: [lineType]</body><body package="BGOK">lineType: aValue 		lineType := aValue == #default				ifTrue: [nil]				ifFalse: [aValue]</body><body package="BGOK">lineWidth	^lineWidth isNil		ifTrue: [1]		ifFalse: [lineWidth]</body><body package="BGOK">lineWidth: aValue	lineWidth := aValue</body><body package="BGOK">markerType	^markerType == #default ifTrue: [nil] ifFalse: [markerType]</body><body package="BGOK">markerType: aValue		markerType := aValue == #default				ifTrue: [nil]				ifFalse: [aValue]</body><body package="BGOK">pattern	^pattern</body><body package="BGOK">pattern: aValue	"Pattern number one is a default pattern. Instead of setting	the default use nil."	pattern := aValue == 1 ifTrue: [nil] ifFalse: [aValue]</body></methods><methods><class-id>UI.ChartElementLookSpec</class-id> <category>private-interface building</category><body package="BGOK">addAspectsForLineTo: builder 	builder aspectAt: #lineStyle put: (self class			adapt: self			forAspect: #lineType			channel: nil).	builder aspectAt: #lineStyleMenu put: self class lineStyleMenu.	builder aspectAt: #markerStyle put: (self class			adapt: self			forAspect: #markerType			channel: nil).	builder aspectAt: #markerStyleMenu put: self class markerStyleMenu.	builder aspectAt: #lineWidth put: (self class			adapt: self			forAspect: #lineWidth			channel: nil)</body><body package="BGOK">addAspectsForRegionTo: builder 	1 to: BG_ChartElement patternsSize		do: 			[:i | 			builder 	visualAt: ('i' , i printString) asSymbol 				 	put: ((BG_ChartElement patternAt: i) magnifiedBy: 2 @ 2).			builder aspectAt: ('m' , i printString) asSymbol				put: 					[self pattern: i.					(builder aspectAt: #accept) value]]</body><body package="BGOK">dialogFor: aDialogType 	| builder dialog spec result |	builder := (dialog := SimpleDialog new) builder.	builder aspectAt: #accept		put: 			[result := true.			dialog close].	builder aspectAt: #cancel		put: 			[result := false.			dialog close].	aDialogType == #region		ifTrue: 			[self addAspectsForRegionTo: builder.			spec := self class regionLookSpec].	aDialogType == #line		ifTrue: 			[self addAspectsForLineTo: builder.			spec := self class lineLookSpec].	dialog allButOpenFrom: (UISpecification from: spec).	builder openDialog.	^result</body><body package="BGOK">insertIntoDescriptor: aDataDescriptor	foregroundColor isNil ifFalse: [aDataDescriptor foregroundColor: foregroundColor].	backgroundColor isNil ifFalse: [aDataDescriptor backgroundColor: backgroundColor].	pattern isNil ifFalse: [aDataDescriptor pattern: pattern].	markerType isNil ifFalse: [aDataDescriptor markerType: markerType].	lineType isNil ifFalse: [aDataDescriptor lineType: lineType].	lineWidth isNil ifFalse: [aDataDescriptor lineWidth: lineWidth].</body></methods><methods><class-id>UI.ChartElementLookSpec</class-id> <category>copying</category><body package="BGOK">postCopy	foregroundColor := foregroundColor copy.	backgroundColor := backgroundColor copy</body></methods><methods><class-id>UI.ChartElementLookSpec</class-id> <category>private</category><body package="BGOK">fromLiteralArrayEncoding: anArray	super fromLiteralArrayEncoding: anArray.	"Foreground and background colors are literal arrays at this point.	I have to decode them."	foregroundColor := foregroundColor decodeAsLiteralArray.	backgroundColor := backgroundColor decodeAsLiteralArray.</body></methods><methods><class-id>UI.LineChartOptionsSpec</class-id> <category>accessing</category><body package="BGOK">dataLocation	dataLocation isNil ifTrue: [^#none].	^dataLocation</body><body package="BGOK">dataLocation: aValue	dataLocation := aValue</body><body package="BGOK">lineLocation	^self showLine		ifTrue: [#show]		ifFalse: [#hide]</body><body package="BGOK">lineLocation: aValue		self showLine: aValue == #show</body><body package="BGOK">markerLocation	^self showMarker		ifTrue: [#show]		ifFalse: [#hide]</body><body package="BGOK">markerLocation: aValue		self showMarker: aValue == #show</body><body package="BGOK">showLine	^showLine ~= false</body><body package="BGOK">showLine: aValue	showLine := aValue</body><body package="BGOK">showMarker	^showMarker == true.</body><body package="BGOK">showMarker: aValue	showMarker := aValue</body><body package="BGOK">spline	^spline == true</body><body package="BGOK">spline: aValue	spline := aValue</body></methods><methods><class-id>UI.LineChartOptionsSpec</class-id> <category>private-interface building</category><body package="BGOK">insertIntoView: aChartView withBuilder: builder 	"Insert optional parameters into a bar chart view"	dataLocation isNil		ifFalse: 			[dataLocation == #none ifTrue: [aChartView hideData].			dataLocation == #inside ifTrue: [aChartView dataInside].			dataLocation == #outside ifTrue: [aChartView dataOutside]].	showLine isNil ifFalse: [showLine			ifTrue: [aChartView showLine]			ifFalse: [aChartView hideLine]].	(spline == true) ifTrue: [aChartView showSpline].	showMarker isNil ifFalse: [showMarker			ifTrue: [aChartView showMarker]			ifFalse: [aChartView hideMarker]]</body></methods><methods><class-id>UI.LineChartOptionsSpec class</class-id> <category>private-interface building</category><body package="BGOK">addBindingsTo: env for: inst channel: aChannel	super addBindingsTo: env for: inst channel: aChannel.	env at: #dataLocation put: (self			adapt: inst			forAspect: #dataLocation			channel: aChannel).	env at: #lineLocation put: (self			adapt: inst			forAspect: #lineLocation			channel: aChannel).	env at: #showSpline put: (self			adapt: inst			forAspect: #spline			channel: aChannel).	env at: #markerLocation put: (self			adapt: inst			forAspect: #markerLocation			channel: aChannel).</body></methods><methods><class-id>UI.BG_ChartView</class-id> <category>color/mask/line/marker</category><body package="BGOK">chartLookList	^LooksForRegions</body><body package="BGOK">chartLookListAt: anIndex 	"Access saftly a collection of looks"	| collection i |	collection := self chartLookList.	i := anIndex.	i &gt; collection size		ifTrue: 			[i := i \\ collection size.			i = 0 ifTrue: [i := collection size]].	^collection at: i</body><body package="BGOK">colors: collectionOfColorValues	| list lookPreference color | 	list := collectionOfColorValues asArray.	self composeLooks: list size.	1 to: list size		do: 			[:i | 			lookPreference := (self looksAt: i) copy.			color := list at: i.			color isNil				ifFalse: 					[color isInteger 						ifTrue: [color := (self chartLookListAt: color) backgroundColor].					lookPreference setBackgroundColor: color.					elementLooks at: i put: lookPreference]]</body><body package="BGOK">looksAt: index 	| lookPrefs |	index &gt; elementLooks size ifTrue: [^self lookPreferences].	lookPrefs := elementLooks at: index.	^lookPrefs isInteger		ifTrue:	[self chartLookListAt: lookPrefs]		ifFalse:	[lookPrefs]</body><body package="BGOK">looksType	"Answer what kind of looks a chart expects. We distinguish two types:	#region for bar and pie charts and	#line for line and xy charts"	^#region</body><body package="BGOK">masks: collectionOfIntegersOrMasks 	| list lookPreference mask |	list := collectionOfIntegersOrMasks asArray.	self composeLooks: list size.	1 to: list size		do: 			[:i | 			lookPreference := (self looksAt: i) copy.			mask := list at: i.			mask isNil				ifFalse: 					[mask isInteger ifTrue: [mask := BG_ChartElement patternAt: mask].					lookPreference fillMask: mask.					elementLooks at: i put: lookPreference]]</body></methods><methods><class-id>UI.BG_ChartView</class-id> <category>options</category><body package="BGOK">optionalBlock	^optionalBlock</body><body package="BGOK">optionalBlock: aBlockClosure	optionalBlock := aBlockClosure</body></methods><methods><class-id>UI.BG_ChartView</class-id> <category>private</category><body package="BGOK">bottomMargin	^0</body><body package="BGOK">compose	"Do nothing"</body><body package="BGOK">composeLooks: size	elementLooks size &lt; size ifTrue: 		[elementLooks := elementLooks asOrderedCollection.		elementLooks size + 1 to: size do: [:i | elementLooks add: i]].</body><body package="BGOK">getClientDataFor: aGraphicsContext	| lp dict chartLook |	chartLook := aGraphicsContext clientDataAt: #chartLook ifAbsent: [].	chartLook == nil ifFalse: [^chartLook].	lp := self lookPreferences.	chartLook := BG_ChartElementLook new.	chartLook setForegroundColor: lp foregroundColor;		setBackgroundColor: lp backgroundColor.	dict := IdentityDictionary new.	dict at: #chartElement put: chartLook.	aGraphicsContext mergeIntoClientData: dict.	aGraphicsContext lineWidth: chartLook lineWidth.	aGraphicsContext paint: chartLook foregroundColor.	^chartLook</body><body package="BGOK">leftMargin	^0</body><body package="BGOK">max: aCollection	| res |	res := aCollection inject: nil into: [:i :j | i==nil ifTrue: [j] ifFalse: [i max: j]].	^res isNil ifTrue: [self defaultScaleRange last] ifFalse: [res]</body><body package="BGOK">min: aCollection	| res |	res := aCollection inject: nil into: [:i :j | i == nil ifTrue: [j] ifFalse: [i min: j]].	^res isNil ifTrue: [self defaultScaleRange first] ifFalse: [res]</body><body package="BGOK">rightMargin	^0</body><body package="BGOK">setChartElementLookUsing: aGraphicsContext 	| dict chartLook gc |	gc := aGraphicsContext copy.	chartLook := aGraphicsContext clientDataAt: #chartElement ifAbsent: [nil].	chartLook == nil ifFalse: [^gc].	chartLook := BG_ChartElementLook from: self lookPreferences.	dict := IdentityDictionary new.	dict at: #chartElement put: chartLook.	gc mergeIntoClientData: dict.	gc lineWidth: chartLook lineWidth.	chartLook foregroundColor ifNotNil: [:paint | gc paint: paint].	^gc</body><body package="BGOK">setClientDataFor: aGraphicsContext index: index foreground: beForeground	| dict chartLook gc |	gc := aGraphicsContext copy.	chartLook := self looksAt: index.	dict := IdentityDictionary new.	dict at: #chartElement put: chartLook.	gc mergeIntoClientData: dict.	gc lineWidth: chartLook lineWidth.	beForeground ifTrue: [gc paint: chartLook foregroundColor].	^gc</body><body package="BGOK">sum: aCollection	^aCollection inject: 0 into: [:i :j | i + j]</body><body package="BGOK">topMargin	^0</body></methods><methods><class-id>UI.BG_ChartView</class-id> <category>displaying</category><body package="BGOK">displayComponentsOn: aGraphicsContext	super displayOn: aGraphicsContext</body><body package="BGOK">displayOn: aGraphicsContext	| gc |		self compose.	gc := aGraphicsContext copy.	gc intersectClip: self bounds.	self displayOptionsOn: gc.	self displayComponentsOn: aGraphicsContext</body><body package="BGOK">displayOptionsOn: aGraphicsContext 	optionalBlock isNil ifTrue: [^self].	optionalBlock value: self value: aGraphicsContext</body></methods><methods><class-id>UI.BG_ChartView</class-id> <category>bounds accessing</category><body package="BGOK">height	^self bounds height</body><body package="BGOK">plotArea	^plotArea isNil		ifTrue: [self bounds				insetOriginBy: self leftMargin @ self topMargin cornerBy: self rightMargin @ self bottomMargin]		ifFalse: [plotArea rectangleRelativeTo: self bounds]</body><body package="BGOK">plotArea: aLayoutObject	plotArea := aLayoutObject</body><body package="BGOK">preferredBounds	^Rectangle origin: 0@0 extent: 300@300</body><body package="BGOK">width	^self bounds width</body></methods><methods><class-id>UI.BG_ChartView</class-id> <category>model accessing</category><body package="BGOK">model: aModel 	"Set the receiver's model to aModel."	self setModel: aModel.</body></methods><methods><class-id>UI.BG_ChartView</class-id> <category>initialize-release</category><body package="BGOK">initialize	super initialize.	self initializeState.	elementLooks := OrderedCollection new</body><body package="BGOK">initializeState	widgetState := WidgetState new.</body></methods><methods><class-id>UI.BG_ChartView</class-id> <category>accessing</category><body package="BGOK">widgetState	^widgetState</body><body package="BGOK">widgetState: aWidgetState	widgetState := aWidgetState</body></methods><methods><class-id>UI.BG_ChartView</class-id> <category>updating</category><body package="BGOK">getNewData	"Get new data from the model."	^self</body></methods><methods><class-id>UI.BG_ChartView</class-id> <category>private-default-model</category><body package="BGOK">defaultScaleRange	^0 to: 100</body></methods><methods><class-id>UI.BG_ChartView class</class-id> <category>private-colors</category><body package="BGOK">backgroundColorForIndex: i 	"Private - used for reagions and lines"	| hue saturation brightness |	hue := i - 1 \\ 12 / 12 * 4.	hue &gt;= 2 ifTrue: [hue := hue - (23 / 12)].	hue &gt;= 1 ifTrue: [hue := hue - (5 / 6)].	saturation := i - 1 // 12 = 1				ifTrue: [0.4]				ifFalse: [1].	brightness := i &gt; 24				ifTrue: [0.8]				ifFalse: [1].	hue = (1 / 3) ifTrue: [brightness := brightness - 0.2].	^ColorValue		hue: hue		saturation: saturation		brightness: brightness</body></methods><methods><class-id>UI.BG_ChartView class</class-id> <category>class initialization</category><body package="BGOK">initialize	"BG_ChartView initialize"	self initializeLines.	self initializeRegions</body><body package="BGOK">initializeLines	"BG_ChartView initializeLines"	| styles width style look markers |	styles := #(solid dotted dashed broken dotted2 dashed2 broken2).	markers := #(#square #solidSquare #circle #solidCircle #triangle #solidTriangle #triangle2 #solidTriangle2 #diamond #solidDiamond #cross #x).	LooksForLines := Array new: 21.	1 to: 21 do:		[:i |		width := i-1//7+2.		style := i-1\\7+1.		look := BG_ChartElementLook new.		look setForegroundColor: (self backgroundColorForIndex: i).		look setBackgroundColor: ColorValue black.		look lineWidth: width.		look lineStyle: (BG_ChartElement perform: (styles at: style)).		LooksForLines at: i put: look].	LooksForMarkers := Array new: 12.	1 to: 12 do:		[:i |		look := BG_ChartElementLook new.		look setForegroundColor: ColorValue black.		look setBackgroundColor: ColorValue white.		look lineWidth: 1.		look lineStyle: BG_ChartElement solid.		look marker: (markers at: i).		LooksForMarkers at: i put: look].</body><body package="BGOK">initializeRegions	"BG_ChartView initializeRegions"	|  look |	LooksForRegions := Array new: 36.	1 to: 36		do: 			[:i | 			look := BG_ChartElementLook new.			look setForegroundColor: ColorValue black.			look setBackgroundColor: (self backgroundColorForIndex: i).			look lineWidth: 1.			look lineStyle: BG_ChartElement solid.			LooksForRegions at: i put: look]</body></methods><methods><class-id>UI.BG_GriddedChartView</class-id> <category>data</category><body package="BGOK">data	^dataStyle item</body><body package="BGOK">data: collectionOfValues 	"Make sure that data item is the BG_TableAdaptor."	dataStyle item: ((collectionOfValues isKindOf: BG_TableAdaptor)					ifTrue: [collectionOfValues]					ifFalse: [BG_TableAdaptor withRow: collectionOfValues]).</body><body package="BGOK">dataInside	dataLocation := #inside</body><body package="BGOK">dataLocation	^dataLocation</body><body package="BGOK">dataOutside	dataLocation := #outside</body><body package="BGOK">dataStyle	^dataStyle</body><body package="BGOK">hideData	dataLocation := #hide</body><body package="BGOK">isDataVisible	^dataLocation ~= #hide</body><body package="BGOK">isPercentage	"Answer true if the receiver displays data labels with values that 	are a percentage of the total"	^dataStyle formatTypes includes: #percent</body><body package="BGOK">isZeroSuppress	"Answer true if the receiver does not display data labels when its value is zero"	^dataStyle formatTypes includes: #zerosuppress</body></methods><methods><class-id>UI.BG_GriddedChartView</class-id> <category>model accessing</category><body package="BGOK">model: aModel 	"Set the receiver's model to aModel. 	Register myself as a dependent of both the model and the model value. 	If the descriptors are already set recompute the chart's data."	super model: aModel.	self getNewData</body></methods><methods><class-id>UI.BG_GriddedChartView</class-id> <category>displaying</category><body package="BGOK">displayAxisOn: aGraphicsContext 	| gc |	gc := aGraphicsContext copy.	grid displayHAxisOn: gc.	grid displayVAxisOn: gc.	grid displayHLabelsOn: aGraphicsContext.	grid displayVLabelsOn: aGraphicsContext</body><body package="BGOK">displayDataOn: aGraphicsContext	^self</body><body package="BGOK">displayGridLinesOn: aGraphicsContext	| gc |	gc := aGraphicsContext copy.	gc paint: self selectionBackgroundColor.	grid displayHLinesOn: gc.	grid displayVLinesOn: gc</body><body package="BGOK">displayLegendOn: aGraphicsContext	| area images iconRect plus gc labelsWidth | 	gc := self setChartElementLookUsing: aGraphicsContext.	legendFrame displayOn: gc. 	area := legendFrame bounds insetBy: 6.	images := legend individualImages.	labelsWidth := self isLegendHorizontal 					ifFalse: [legend individualExtent x] 					ifTrue: [legend computedExtent x].	iconRect := (area topLeft extent: ((area width - labelsWidth) // legend column) @(area height // legend row)) insetBy: 3.	plus := 0@0.	1 to: self legendSize do: 		[:i | 		| eachImage rect |		eachImage := images at: i.		gc := self setClientDataFor: aGraphicsContext			index: i			foreground: false.		self displayLegendSymbol: i in: (rect := iconRect origin + plus extent: iconRect extent) on: gc.		plus := plus + (self isLegendHorizontal				ifTrue: [(6 + iconRect width + eachImage extent x)@0]				ifFalse: [0@(area height //  legend row)]).		eachImage			displayOn: gc			at: (rect rightCenter - (-3 @ (eachImage height // 2)))]</body><body package="BGOK">displayLegendSymbol: anIndex in: aRectangle on: aGraphicsContext 	(BG_ChartElement on: aRectangle) displayOn: aGraphicsContext.</body><body package="BGOK">displayOn: aGraphicsContext 	| gc noData fgColor innerGC | 	self compose. 	gc := aGraphicsContext copy.		"fgColor might not be defined"	(fgColor := self lookPreferences foregroundColor) isNil		ifFalse: [gc paint: fgColor].	gc intersectClip: self bounds.	self displayGridLinesOn: gc.	innerGC := grid gcCopyClipped: gc. 	(noData := self data isNil or: [self data isEmpty]) ifFalse: [self displayPlotOn: innerGC].	self displayAxisOn: gc.	noData		ifFalse: 			[self isDataVisible ifTrue: [self displayDataOn: innerGC].			self isLegendVisible ifTrue: [self displayLegendOn: gc]].	self displayOptionsOn: gc</body><body package="BGOK">displayPlotOn: aGraphicsContext	^self</body></methods><methods><class-id>UI.BG_GriddedChartView</class-id> <category>private-default-model</category><body package="BGOK">defaultDescriptors	"Answer a collection of default descriptors"	^self defaultDescriptorsFor: self defaultNbrOfSeries.</body><body package="BGOK">defaultDescriptorsFor: numberOfSeries 	"Answer a collection of default descriptors. 	When more then one data series is necessary 	make the descriptors use indexes."	| descr nbr |	nbr := numberOfSeries isNil ifTrue: [self defaultNbrOfSeries] ifFalse: [numberOfSeries].	descr := Array new: nbr.	1 to: nbr		do: 			[:i | 			| dd |			dd := BG_ChartDataSetDescription new.			nbr &gt; 1 ifTrue: [dd adaptor: (IndexedAdaptor forIndex: i)].			dd name: (String with: ($A asInteger - 1 + i) asCharacter).			descr at: i put: dd].	^descr</body><body package="BGOK">defaultModelFor: dataDescriptor 	"Answer a default model for specified data descriptors. 	The default model is simply an array containing numbers if just one data 	series is needed, or an list of arrays if more then one data series is requested."	| range step val defModel nbr indxes labelIndex columns |	nbr := dataDescriptor nbrOfDataSeries.	labelIndex := dataDescriptor labelIndex.	columns := nbr + (labelIndex = 0					ifTrue: [0]					ifFalse: [1]).	range := self grid y isAutoScaled				ifTrue: [self defaultRange]				ifFalse: [self defaultRangeFromScale: self grid y scale andNumberOfSeries: nbr].	step := range last - range first / (self defaultNbrOfPoints + 2).	columns &gt; 1		ifTrue: 			[defModel := List new: self defaultNbrOfPoints.			1 to: self defaultNbrOfPoints do: [:i | defModel at: i put: (Array new: columns)]]		ifFalse: [defModel := Array new: self defaultNbrOfPoints].	val := range first + step.	"Swap the first and last index inorder to have more interesting model"	indxes := Array new: defModel size.	2 to: defModel size do: [:i | indxes at: i put: i].	indxes at: 1 put: defModel size.	indxes at: defModel size put: 1.	indxes		do: 			[:i | 			columns &gt; 1				ifTrue: 					[| row |					row := defModel at: i.					1 to: columns do: [:c | c = labelIndex ifFalse: 										[row at: c put: (self defaultPointFor: val column: c range: range)]							ifTrue: [row at: c put: (String with: ($a asInteger - 1 + i) asCharacter)]]]				ifFalse: [defModel at: i put: (self defaultPointFor: val column: 1 range: range)].			val := val + step].	^defModel</body><body package="BGOK">defaultNbrOfPoints	^5</body><body package="BGOK">defaultNbrOfSeries	^1</body><body package="BGOK">defaultPointFor: aValue column: aColumn range: aRange 	| val |	val := (aValue / aColumn min: aRange last)				max: aRange first.	^val abs &gt; 2		ifTrue: [val asInteger]		ifFalse: [val asFloat]</body><body package="BGOK">defaultRange	^10 to: 100</body><body package="BGOK">defaultRangeFromScale:  aScale andNumberOfSeries: aNumber	^Array with: aScale sourceMin with: aScale sourceMax</body><body package="BGOK">useDefaultDescriptors	"Set descriptors to the array of default descriptors"	| descr |	descr := self defaultDescriptorsFor: self defaultNbrOfSeries.	self descriptors: descr</body></methods><methods><class-id>UI.BG_GriddedChartView</class-id> <category>legend</category><body package="BGOK">hideLegend	legendLocation := legendLocation bitAnd: 2r10000</body><body package="BGOK">isLegendHorizontal	^self legendAlignment &lt;= 3 or: [self legendAlignment &gt;= 13]</body><body package="BGOK">isLegendInside	^legendLocation &gt;= 16</body><body package="BGOK">isLegendVisible	^self legendAlignment ~= 0</body><body package="BGOK">legend	^legend item</body><body package="BGOK">legend: collectionOfStrings	legend item: collectionOfStrings</body><body package="BGOK">legendAlignment 	^legendLocation bitAnd: 2r1111</body><body package="BGOK">legendAlignment: anInteger 	legendLocation := (legendLocation bitAnd: 2r10000) bitOr: (anInteger bitAnd: 2r1111).</body><body package="BGOK">legendFrame	^legendFrame</body><body package="BGOK">legendInside	legendLocation := legendLocation bitOr: 2r10000</body><body package="BGOK">legendLocation	^legendLocation</body><body package="BGOK">legendLocation: location	"locations 		[4:1] position at which legends ares placed. 					0: hide						1: top left					2: top center					3: top right					4: left top					5: center top					6: right top					7: left center					8: center					9: right center					10: left bottom					11: center bottom					12: right bottom					13: bottom left					14: bottom center					15: bottom right		[5]: inside/outside of the frame					0: outside					1: inside"	legendLocation := location</body><body package="BGOK">legendOutside	legendLocation := legendLocation bitAnd: 2r01111</body><body package="BGOK">legendStyle	^legend</body></methods><methods><class-id>UI.BG_GriddedChartView</class-id> <category>private</category><body package="BGOK">bottomMargin	^(self isLegendVisible and: [self legendAlignment &gt;= 13 &amp; self isLegendInside not])		ifTrue: [super bottomMargin + (0.05* self height) rounded]		ifFalse: [super bottomMargin]</body><body package="BGOK">compose	| size |	self composeLabels: self labelsSize.	(size := self legendSize) = 0 ifFalse:		[self composeLooks: size.		self composeSortIndex: self sortedValues.		self composeGrid.		self isLegendVisible ifTrue: [self composeLegend: size]].</body><body package="BGOK">composeGrid	grid y isAutoScaled &amp; grid y isAutoLabeled		ifTrue: 			[| matrix |			matrix := self dataRangeMatrix.			grid y scale autoMin: (self min: matrix)				max: (self max: matrix)].	grid bounds: self plotArea.	self isDataOutside		ifTrue: 			["Add extra room for displaying data outside the chart."			| op cp scale offset doCp doOp |			op := 0 @ 0.			cp := 0 @ 0.			doCp := doOp := false.			offset := dataStyle individualExtent + (3 @ 3).			scale := grid y scale.			scale incrementalScaled				ifTrue: 					[doOp := scale sourceMin &lt; 0.					doCp := scale sourceMax &gt;= 0]				ifFalse: 					[doOp := scale sourceMax &gt;= 0.					doCp := scale sourceMin &lt; 0].			grid transposed				ifTrue: 					[doCp ifTrue: [cp := offset x @ 0].					doOp ifTrue: [op := offset x @ 0]]				ifFalse: 					[doCp ifTrue: [cp := 0 @ offset y].					doOp ifTrue: [op := 0 @ offset y]].			grid insetBounds: (grid insetBounds insetOriginBy: op cornerBy: cp)]</body><body package="BGOK">composeLabels: size	labels = grid x labels ifFalse: [grid x labels: labels copy].</body><body package="BGOK">composeLegend: size	| item |	legend item isNil ifTrue: [legend item: (OrderedCollection new: size)].	item := legend item asOrderedCollection.	item size &lt; size		ifTrue: 			[item size + 1 to: size do: [:i | item add: nil].			legend item: item].	self composeLegendFrame: size</body><body package="BGOK">composeLegendFrame: size	| area ie rect rectSym aligns withs delta minFactor|		rectSym := #(topLeft topCenter topRight leftCenter center rightCenter bottomLeft bottomCenter bottomRight).	aligns := #(7 8 9 3 2 1 6 5 4 9 8 7 1 2 3 1 1 2 3 1 2 3 4 5 6 7 8 9 7 8 9).	withs := #(1 2 3 1 2 3 4 5 6 7 8 9 7 8 9).	minFactor := 12 * size.	ie := legend individualExtent.	ie := ie max: 10@10.	area := self isLegendInside 			ifTrue: [grid insetBounds insetBy: 12]			ifFalse: [self plotArea].	self isLegendHorizontal 		ifTrue: 			[			|w|			legend beHorizontal.					w := legend computedExtent x.			rect := 0@0 extent: ((area width rounded min: 30 + minFactor + w) max: minFactor + w)@(((0.05 * self height) rounded min: 40) max: ie y)]		ifFalse:			[legend beVertical.			rect := 0@0 extent: (((0.15 * self width) rounded min: 30 + ie x) max: 18 + ie x)@(((area height - 24) min: 30 * size) max: ie y * size)].	rect := rect expandedBy: 6. 	legendFrame geometric: 			(rect align: (rect perform: (rectSym at: (aligns at: legendLocation))) 					with: (area perform: (rectSym at: (withs at: self legendAlignment)))).	delta := legendFrame bounds amountToTranslateWithin: (self bounds insetBy: 6).	legendFrame geometric: (legendFrame geometric translatedBy: delta).</body><body package="BGOK">composeSortIndex: sortedValues 	| order value includes index glabels |	value := sortedValues.	other isNil		ifTrue: 			[sortedIndex := Array new: value columnSize.			1 to: sortedIndex size do: [:i | sortedIndex at: i put: i]]		ifFalse: 			[includes := false.			index := 0.			(index := labels indexOf: other ifAbsent: [value columnSize + 1]) &lt;= value columnSize ifTrue: [includes := true].			order := SortedCollection sortBlock: [:a :b | (value at: a@1)							&gt; (value at: b@1)].			1 to: value columnSize do: [:i | order add: i].			order := order asOrderedCollection.			includes ifTrue: [order remove: index; addLast: index].			sortedIndex := order asArray.			glabels := OrderedCollection new.			sortedIndex do: [:n | glabels add: (labels at: n)].			grid x labels: glabels]</body><body package="BGOK">dataRangeMatrix	^self data copy</body><body package="BGOK">defaultDataAngle	^grid transposed		ifTrue: [grid y scale incrementalScaled ifTrue: [0] ifFalse: [180]]		ifFalse: [grid y scale incrementalScaled ifTrue: [90] ifFalse: [270]]</body><body package="BGOK">isDataOutside	^dataLocation ~= #hide and: [dataLocation ~= #inside]</body><body package="BGOK">labelsSize	^self data columnSize</body><body package="BGOK">leftMargin	^(self isLegendVisible and: [self legendAlignment \\ 3 = 1 &amp; self isLegendInside not &amp; self isLegendHorizontal not])		ifTrue: [super leftMargin + (0.15* self width) rounded]		ifFalse: [super leftMargin]</body><body package="BGOK">legendSize	^self data rowSize</body><body package="BGOK">rates: values	| sum | 	sum := self sum: values.	^values collect: (sum = 0 ifTrue: [[:n | 0]] ifFalse: [[:n | (n / sum) asFloat]])</body><body package="BGOK">rightMargin	^(self isLegendVisible and: [self legendAlignment \\ 3 = 0 &amp; self isLegendInside not &amp; self isLegendHorizontal not])		ifTrue: [super rightMargin + (0.15* self width) rounded]		ifFalse: [super rightMargin]</body><body package="BGOK">roundedRates: values	| percentages sum max |	percentages := values collect: [:n | n roundTo: 0.001].	((sum := self sum: percentages) &lt; 1 and: [percentages isEmpty not]) ifTrue:		[max := (self max: percentages).		percentages at: (percentages indexOf: max) put: max + (1 - sum)].	^percentages</body><body package="BGOK">sortedValues	| value |	value := BG_TableAdaptor columns: self data columnSize rows: 1.	1 to: self data columnSize do:		[:x |		value atPoint: x@1 put: (self data column: x inject: 0 into: [:sum :i | sum+i])].	^value</body><body package="BGOK">topMargin	^(self isLegendVisible and: [self legendAlignment &lt;= 3 &amp; self isLegendInside not])		ifTrue: [super topMargin + (0.05* self height) rounded]		ifFalse: [super topMargin]</body></methods><methods><class-id>UI.BG_GriddedChartView</class-id> <category>sorting</category><body package="BGOK">other	^other</body><body package="BGOK">other: aStringForOther	other := aStringForOther</body></methods><methods><class-id>UI.BG_GriddedChartView</class-id> <category>grid</category><body package="BGOK">grid	^grid</body><body package="BGOK">transpose	grid transpose.	grid y scale reverse</body><body package="BGOK">transposed	^grid transposed</body></methods><methods><class-id>UI.BG_GriddedChartView</class-id> <category>labels</category><body package="BGOK">labels	^labels</body><body package="BGOK">labels: collectionOfStrings	labels := collectionOfStrings.	grid x labels: labels copy</body><body package="BGOK">labelsStyle	^grid x labelsStyle</body></methods><methods><class-id>UI.BG_GriddedChartView</class-id> <category>private-data-transformation</category><body package="BGOK">basicCollection	"Answer a basic collection held in dataStyle item."	| value |	value := self data.	^value notNil		ifTrue: [value baseCollection]		ifFalse: [nil]</body><body package="BGOK">dataFromDescriptions	"Charts expect the data to be an instance of BG_TableAdaptor 	with rows being data sets. 	Model is a value holder on a collection of objects 	Descriptors provide brake up into separate data sets. 	Here we make ourselves dependent on the collection. 	Note that we have to do transformation of the matrix data."	| adaptor dataDescr lbls labelDescr value oldValue |	oldValue := self basicCollection.	value := (model isKindOf: SelectionInList)				ifTrue: [model list]				ifFalse: [model value].	oldValue ~~ value		ifTrue: 			[oldValue removeDependent: self.			value notNil ifTrue: [value addDependent: self]].	dataDescr := descriptors select: [:descr | descr hasData].	adaptor := BG_TableAdaptor on: value adaptors: (dataDescr collect: [:descr | descr adaptor]).	labelDescr := descriptors detect: [:descr | descr hasData not]				ifNone: [nil].	lbls := labelDescr notNil				ifTrue: [lbls := BG_TableAdaptor on: value adaptors: (Array with: labelDescr adaptor)]				ifFalse: [Array new: value size].	self data: adaptor.	self legend: (dataDescr collect: [:descr | descr name]).	self labels: lbls</body><body package="BGOK">lookFromDescriptions	"Use the data from descriptors to set up apperance of the chart."	|   dataDescr  |	dataDescr := descriptors select: [:descr | descr hasData].	self setChartLooksFrom: dataDescr</body><body package="BGOK">setChartLooksFrom: dataDescriptors 	"Set set a collection of chart element looks"	| list |	list := dataDescriptors asArray.	self composeLooks: list size.	1 to: list size		do: 			[:i | 			| dd lookPreference |			lookPreference := (self looksAt: i) copy.			dd := list at: i.			dd isNil				ifFalse: 					[| pref |					(pref := dd backgroundColor) notNil ifTrue: [lookPreference setBackgroundColor: pref].					(pref := dd foregroundColor) notNil ifTrue: [lookPreference setForegroundColor: pref].					(pref := dd pattern) notNil ifTrue: [lookPreference fillMask: (BG_ChartElement patternAt: pref)].					(pref := dd markerType) notNil ifTrue: [lookPreference marker: (BG_DataPointMarker imageAt: pref)].					(pref := dd lineType) notNil ifTrue: [lookPreference lineStyle: (BG_ChartElement perform: pref)].					(pref := dd lineWidth) notNil ifTrue: [lookPreference lineWidth: pref].					elementLooks at: i put: lookPreference]]</body></methods><methods><class-id>UI.BG_GriddedChartView</class-id> <category>initialize-release</category><body package="BGOK">initialize	super initialize.	grid := BG_ChartGrid new.	grid x itemAxis.	grid y scale decrease.	dataStyle := BG_LabelList new.	dataLocation := #hide.		legend := BG_LabelList new.	legend alignment: 4.	legendFrame := BG_ChartElement new.	legendLocation := 0.	other := nil.</body><body package="BGOK">newGraphicsDevice: aGraphicsDevice	super newGraphicsDevice: aGraphicsDevice.	grid newGraphicsDevice: aGraphicsDevice.	dataStyle newGraphicsDevice: aGraphicsDevice.	legend newGraphicsDevice: aGraphicsDevice.</body><body package="BGOK">release	"Remove the receiver as a dependent of the model's value"	(model value notNil and: [model ~~ model value ]) ifTrue: [model value removeDependent: self].	self descriptors do: [:desc | desc release].	super release</body></methods><methods><class-id>UI.BG_GriddedChartView</class-id> <category>accessing</category><body package="BGOK">descriptors	^descriptors</body><body package="BGOK">descriptors: aColection 	"Set new descriptors if the model is already set 	set create new table adaptor."	descriptors := aColection.	model notNil ifTrue: [self getNewData]</body><body package="BGOK">gridType	"Answer  #normal as a defult. Some charts, like Pie Chart redefine this message"	^#normal</body></methods><methods><class-id>UI.BG_GriddedChartView</class-id> <category>updating</category><body package="BGOK">getNewData	"Get new data and look from the model using descriptors."	descriptors notNil		ifTrue: 			[self dataFromDescriptions.			self lookFromDescriptions]</body><body package="BGOK">update: anAspect with: aParameter from: anObject 	anObject == model value		ifTrue: 			["Update from collection of values - redraw the view. 			We should be more selective as far as wht to invalidate. 			See the method update:with:from: in SelctionView."			anAspect == #at:				ifTrue: ["In case the labels has changed"					self grid x labelsStyle flushCaches]				ifFalse: [self dataFromDescriptions].			self invalidate.			^self].	anAspect == #value ifTrue: [anObject == model			ifTrue: 				[self dataFromDescriptions.				self invalidate.				^self]].	super		update: anAspect		with: aParameter		from: anObject</body></methods><methods><class-id>UI.BG_BarChartView</class-id> <category>private</category><body package="BGOK">defaultDataAlignment: v	^dataLocation = #outside ifTrue: [v &gt;=0 ifTrue: [4] ifFalse: [6]] ifFalse: [5]</body><body package="BGOK">defaultDataOffset: v offset: offset	^dataLocation = #outside ifTrue: [v &gt;=0 ifTrue: [offset@0] ifFalse: [offset negated@0]] ifFalse: [0@0]</body><body package="BGOK">displayBarOn: aGraphicsContext at: index vertex: p1 vertex: p2 	| gc |	gc := self setClientDataFor: aGraphicsContext		index: index		foreground: false.	 (BG_ChartElement on: (Rectangle vertex: p1 vertex: p2)) displayOn: gc</body><body package="BGOK">displayLabel: label angle: angle offset: o alignment: al on: gc at: p	dataLocation = #inside ifTrue:		[| gc2 |		gc2 := gc copy.		gc2 paint: self backgroundColor.		gc2 displayRectangle: (grid box: label bounds by: angle origin: o alignment: al) at: p].	grid		displayLabel: label		angle: angle		offset: o		alignment: al		on: gc		at: p</body><body package="BGOK">legendSize	^self data rowSize" = 1		ifTrue: [self data columnSize]		ifFalse: [self data rowSize]"</body></methods><methods><class-id>UI.BG_BarChartView</class-id> <category>link</category><body package="BGOK">hideLink	"Do noting since bar charts have no link"</body><body package="BGOK">showLink	"Do noting since bar charts have no link"</body></methods><methods><class-id>UI.BG_BarChartView</class-id> <category>bar</category><body package="BGOK">barOverlap	^barOverlap</body><body package="BGOK">barOverlap: relativeDegree	barOverlap := relativeDegree min: 1.0</body><body package="BGOK">barWidth	^barWidth</body><body package="BGOK">barWidth: relativeWidth	barWidth := (relativeWidth max: 0) min: 1</body></methods><methods><class-id>UI.BG_BarChartView</class-id> <category>displaying</category><body package="BGOK">displayDataOn: aGraphicsContext	| value images angle sw ow gc base |	value := self data.	base := grid y scale zero.	gc := aGraphicsContext copy.	images := dataStyle individualImages.	angle := self defaultDataAngle.	ow := barWidth / (value rowSize - ((value rowSize -1) * barOverlap)) * 0.5.	sw := ow * 2 * (1 - barOverlap).	1 to: value columnSize do: 		[:x | 			| n |			n := sortedIndex at: x.			1 to: value rowSize do:				[:y | 					| v py |					v := value at: n@y.					py := dataLocation = #outside ifTrue: [v ] ifFalse: [base + (v - base // 2) ].					self 						displayLabel: (images at: n@y)						angle: angle 						offset: (self defaultDataOffset: v offset: 4)						alignment: (self defaultDataAlignment: v)						on: gc 						at: (grid applyTo: x - ((barWidth / 2)) + ((y-1) * sw) +ow@(py)) rounded]]</body><body package="BGOK">displayPlotOn: aGraphicsContext	| value points collection sw base |	value := self data.  	base := grid y scale zero.	sw := barWidth / (value rowSize - ((value rowSize -1) * barOverlap)) * (1 - barOverlap).	points := BG_TableAdaptor columns: value columnSize * 2 rows: value rowSize.	1 to: value columnSize do: 		[:x | 			| n |			n := sortedIndex at: x.			1 to: value rowSize do:				[:y | 					points at: x * 2 -1@y put: x - (barWidth / 2) + ((y-1) * sw )@(value at: n@y).					points at: x * 2@y put: x + (barWidth / 2) - ((value rowSize - y) * sw)@base]].	collection := grid applyToValues: points.	1 to: value columnSize do: 		[:x |  		value rowSize to: 1 by: -1 do:			[:y | 				self 					displayBarOn: aGraphicsContext 					at: y					vertex: (collection at: x * 2-1@y) rounded 					vertex: (collection at: x * 2@y) rounded]]</body></methods><methods><class-id>UI.BG_BarChartView</class-id> <category>initialize-release</category><body package="BGOK">initialize	super initialize.	barWidth := 0.8.	barOverlap := 0.</body></methods><methods><class-id>UI.BG_BarChartView</class-id> <category>picture/unit</category><body package="BGOK">picture: anObject	"Do nothing since I have no picture. This method is overridden in 	BG_PcitureChartView"</body><body package="BGOK">unit: aNumber	"Do nothing since I have no picture. This method is overridden in 	BG_PcitureChartView"</body></methods><methods><class-id>UI.BG_BarChartView class</class-id> <category>private-images</category><body package="BGOK">defaultPicture	^Image		extent: 16 @ 16		depth: 1		palette: MonoMappedPalette whiteBlack		bits: #[63 252 127 254 7 224 31 248 63 252 125 190 240 15 245 175 245 191 240 15 253 175 245 167 240 15 253 191 255 255 255 255 ]		pad: 16</body></methods><methods><class-id>UI.BG_StackedBarChartView</class-id> <category>link</category><body package="BGOK">hideLink	showLink := false</body><body package="BGOK">isLinkVisible	^showLink</body><body package="BGOK">showLink	showLink := true</body></methods><methods><class-id>UI.BG_StackedBarChartView</class-id> <category>private-default-model</category><body package="BGOK">defaultNbrOfSeries	^2</body><body package="BGOK">defaultPointFor: aValue column: aColumn range: aRange 	| val |	val := (aColumn = 1		ifTrue: [aValue]		ifFalse: [aValue &gt; 0				ifTrue: [aRange last - aValue / aColumn]				ifFalse: [aRange first - aValue / aColumn]]).	^val abs &gt; 2 ifTrue: [val asInteger] ifFalse: [val asFloat]</body><body package="BGOK">defaultRangeFromScale: aScale andNumberOfSeries: aNumber 	^Array with: aScale sourceMin - aScale zero with: aScale sourceMax - aScale zero</body></methods><methods><class-id>UI.BG_StackedBarChartView</class-id> <category>private</category><body package="BGOK">dataRangeMatrix	| matrix value |	value := self data.	matrix := Array new: value columnSize.	1 to: value columnSize do: [:x | matrix at: x put: (self sum: (value columnAt: x))].	^matrix</body><body package="BGOK">rates	| rdata values |	values := self data.	rdata := BG_TableAdaptor columns: values columnSize rows: values rowSize.	1 to: values columnSize do: [:x | rdata columnAt: x put: (self roundedRates: (self rates: (values columnAt: x)))].	^rdata</body></methods><methods><class-id>UI.BG_StackedBarChartView</class-id> <category>initialize-release</category><body package="BGOK">initialize	super initialize.	showLink := false.</body></methods><methods><class-id>UI.BG_StackedBarChartView</class-id> <category>displaying</category><body package="BGOK">displayDataOn: aGraphicsContext	| value images angle savedData isP gc |	dataLocation = #outside		ifTrue:			[savedData := self data.			self data: self sortedValues.			super displayDataOn: aGraphicsContext.			self data: savedData]		ifFalse:			[value := self data.			(isP := self isPercentage) ifTrue: 				[savedData := self data.				self data: self rates].			gc := aGraphicsContext copy.			images := dataStyle individualImages.			angle := self defaultDataAngle.			1 to: value columnSize do: 				[:x |  | v1 v2 | 					v1 := v2 := grid y scale zero.					1 to: value rowSize do: 						[:y | | n |							n := sortedIndex at: x.							v2 := v1 + (value at: n@y).							self 								displayLabel: (images at: n@y)								angle: angle 								offset: 0@0								alignment: 5								on: gc 								at: (grid applyTo: x@((v2 - v1 / 2 ) + v1)) rounded.								v1 := v2]].			isP ifTrue: [self data: savedData]]</body><body package="BGOK">displayPlotOn: aGraphicsContext	| value points collection  |	value := self data.	points := BG_TableAdaptor columns: value columnSize * 2 rows: value rowSize.	1 to: value columnSize do: 		[:x | 			| n v |			n := sortedIndex at: x.			v := grid y scale zero.			1 to: value rowSize do:				[:y | 					points at: x * 2@y  put: x + (barWidth / 2)@v.					points at: x * 2 - 1@y put: x - (barWidth / 2)@ (v := v + (value at: n@y))]].	collection := grid applyToValues: points.	1 to: value columnSize do: 		[:x | 		1 to: value rowSize do:			[:y |				self 					displayBarOn: aGraphicsContext 					at: y 					vertex: (collection at: x * 2-1@y) rounded 					vertex: (collection at: x * 2@y) rounded]].	showLink &amp; (barWidth &lt; 1) ifTrue:		[1 to: value columnSize -1 do: 			[:x | 1 to: value rowSize do:				[:y | 				(LineSegment from: (grid applyTo: (points at: (x * 2@y)) x@((points at: x *2 -1@y) y))						to: (collection at: (x + 1 * 2 -1@y)))					asStroker displayOn: aGraphicsContext]]]</body></methods><methods><class-id>UI.BG_LayerChartView</class-id> <category>private</category><body package="BGOK">legendSize	^self data rowSize</body></methods><methods><class-id>UI.BG_LayerChartView</class-id> <category>displaying</category><body package="BGOK">displayPlotOn: aGraphicsContext	| value points collection gc |	value := self data.	points := BG_TableAdaptor columns: value columnSize rows: (value rowSize+1).	1 to: value columnSize do: 		[:x | 			| n v |			n := sortedIndex at: x.			v := grid y scale zero.			points at: x @1 put: x@grid y scale zero.			1 to: value rowSize do: 				[:y | points at: x @(y+1) put: x@(v := v + (value at: n@y))]].	collection := grid applyToValues: points.	1 to: value rowSize do:		[:y | | vertices |		gc := self setClientDataFor: aGraphicsContext			index: y			foreground: false.		vertices := (collection rowAt: y) , (collection rowAt: y+1) asArray reverse.		(BG_ChartElement on: (Polyline vertices: vertices))			drawLine: false;			displayOn: gc].	1 to: value rowSize do:		[:y |		(Polyline vertices: (collection rowAt: y+1))			asStroker displayOn: aGraphicsContext]</body></methods><methods><class-id>Examples.BG_StockTool</class-id> <category>newSymbol</category><body package="BGOK">newSymbol	"New symbol has been selected by the user. 	Set new value of data holder and change the name of the data set."	chartView descriptors first name: stocks selection.	data value: (quotes select: [:quote| quote symbol = stocks selection])</body></methods><methods><class-id>Examples.BG_StockTool</class-id> <category>initialize</category><body package="BGOK">initialize	super initialize.	stocks := SelectionInList new.	quotes := List new.	stocks selectionIndexHolder onChangeSend: #newSymbol to: self.	data := #() asValue</body></methods><methods><class-id>Examples.BG_StockTool</class-id> <category>loadQuotes</category><body package="BGOK">loadQuotes	"Load the sample quotes data."	self readQuotesFrom: self class sampleQuoteData readStream</body></methods><methods><class-id>Examples.BG_StockTool</class-id> <category>stockNames</category><body package="BGOK">stockNames	^stocks</body></methods><methods><class-id>Examples.BG_StockTool</class-id> <category>readQuotesFrom:</category><body package="BGOK">readQuotesFrom: aStream 	"Read data from stream."	| stocksInFile |	stocksInFile := Set new.	quotes removeAllSuchThat: [:o| true].	[ 	[aStream skipSeparators.	aStream atEnd]		whileFalse: 			[| quote |			quote := BG_StockQuote readFrom: aStream.			stocksInFile add: quote symbol.			quotes add: quote]] ensure: [aStream close].	stocks list: stocksInFile asSortedCollection asList</body></methods><methods><class-id>Examples.BG_StockTool</class-id> <category>postBuildWith:</category><body package="BGOK">postBuildWith: aBuilder 	"I need to access data set descriptors in order to change the name in the legend."	chartView := (aBuilder componentAt: #stocks) widget</body></methods><methods><class-id>Examples.BG_StockTool</class-id> <category>labels</category><body package="BGOK">labels	"We have to limit a number of labels displayed to prevent overlaping.	Every seventh label is displayed as a date, the rest use empty strings."	^(PluggableAdaptor new)		getBlock: [:m | (self data value indexOf: m)				\\ 7 = 1				ifTrue: [m date printFormat: #(2 1 3 $/ 1 2 )]				ifFalse: ['']]		putBlock: [:b :v | ]		updateBlock: [:b :a :p | false]; yourself</body></methods><methods><class-id>Examples.BG_StockTool</class-id> <category>data</category><body package="BGOK">data	^data</body></methods><methods><class-id>Examples.BG_StockTool class</class-id> <category>sampleQuoteData</category><body package="BGOK">sampleQuoteData	"Answer a string with sample quote data."	^'Sep 9, 1993	AAPL 	  26.000	 27.000	 26.000Sep 9, 1993	BORL 	  15.000	 15.750	 14.750Sep 9, 1993	FRAM 	   7.875	  8.000	  7.500Sep 9, 1993	SNPS 	  49.750	 50.000	 46.750Sep 9, 1993	SUNW 	  27.500	 27.625	 26.750Sep 10, 1993	AAPL 	  26.000	 26.250	 25.375Sep 10, 1993	BORL 	  14.875	 15.250	 14.250Sep 10, 1993	FRAM 	   7.750	  7.875	  7.750Sep 10, 1993	SNPS 	  50.000	 50.000	 49.500Sep 10, 1993	SUNW 	  28.000	 28.125	 27.500Sep 13, 1993	AAPL 	  25.250	 26.500	 24.750Sep 13, 1993	BORL 	  14.875	 15.500	 14.500Sep 13, 1993	FRAM 	   8.125	  8.125	  7.750Sep 13, 1993	SNPS 	  48.375	 50.000	 48.250Sep 13, 1993	SUNW 	  27.500	 28.125	 27.500Sep 14, 1993	AAPL 	  24.250	 25.000	 24.000Sep 14, 1993	BORL 	  15.000	 15.250	 14.500Sep 14, 1993	FRAM 	   7.625	  8.125	  7.625Sep 14, 1993	SNPS 	  46.750	 48.000	 46.250Sep 14, 1993	SUNW 	  26.875	 27.500	 26.250Sep 15, 1993	AAPL 	  24.000	 25.000	 23.500Sep 15, 1993	BORL 	  13.875	 15.000	 13.750Sep 15, 1993	FRAM 	   7.750	  8.125	  7.625Sep 15, 1993	SNPS 	  46.875	 46.875	 46.750Sep 15, 1993	SUNW 	  26.750	 26.875	 26.750Sep 16, 1993	AAPL 	  24.750	 25.000	 24.250Sep 16, 1993	BORL 	  14.000	 14.250	 13.000Sep 16, 1993	FRAM 	   7.625	  7.750	  7.500Sep 16, 1993	SNPS 	  47.000	 47.000	 45.750Sep 16, 1993	SUNW 	  25.000	 25.500	 24.750Sep 17, 1993	AAPL 	  25.250	 25.500	 24.250Sep 17, 1993	BORL 	  13.750	 14.000	 13.000Sep 17, 1993	FRAM 	   7.500	  7.625	  7.500Sep 17, 1993	SNPS 	  45.500	 46.500	 44.750Sep 17, 1993	SUNW 	  26.000	 26.250	 24.750Sep 20, 1993	AAPL 	  24.875	 25.500	 24.750Sep 20, 1993	BORL 	  14.000	 14.250	 13.500Sep 20, 1993	FRAM 	   7.875	  7.875	  7.625Sep 20, 1993	SNPS 	  46.250	 46.250	 44.750Sep 20, 1993	SUNW 	  26.125	 27.125	 26.000Sep 21, 1993	AAPL 	  24.500	 25.250	 23.875Sep 21, 1993	BORL 	  13.250	 14.000	 12.750Sep 21, 1993	FRAM 	   7.625	  8.000	  7.625Sep 21, 1993	SNPS 	  45.250	 46.250	 45.000Sep 21, 1993	SUNW 	  26.375	 26.625	 25.875Sep 22, 1993	AAPL 	  25.500	 25.500	 24.250Sep 22, 1993	BORL 	  13.750	 13.750	 13.000Sep 22, 1993	FRAM 	   7.750	  7.875	  7.375Sep 22, 1993	SNPS 	  46.500	 46.500	 45.500Sep 22, 1993	SUNW 	  26.500	 27.000	 26.375Sep 23, 1993	AAPL 	  24.750	 25.500	 24.500Sep 23, 1993	BORL 	  15.000	 15.000	 13.500Sep 23, 1993	FRAM 	   7.875	  7.875	  7.750Sep 23, 1993	SNPS 	  48.750	 49.250	 46.500Sep 23, 1993	SUNW 	  27.000	 27.125	 26.500Sep 24, 1993	AAPL 	  25.250	 25.250	 24.500Sep 24, 1993	BORL 	  14.250	 15.000	 14.250Sep 24, 1993	FRAM 	   7.875	  7.875	  7.750Sep 24, 1993	SNPS 	  48.250	 49.750	 48.250Sep 24, 1993	SUNW 	  26.375	 27.000	 26.125Sep 27, 1993	AAPL 	  24.750	 25.250	 24.250Sep 27, 1993	FRAM 	   7.750	  7.875	  7.750Sep 27, 1993	SNPS 	  47.750	 48.750	 47.500Sep 27, 1993	SUNW 	  26.000	 26.500	 26.000Sep 28, 1993	AAPL 	  24.750	 25.000	 24.250Sep 28, 1993	BORL 	  14.750	 15.000	 14.500Sep 28, 1993	FRAM 	   7.875	  7.875	  7.750Sep 28, 1993	SNPS 	  47.750	 48.250	 47.750Sep 28, 1993	SUNW 	  25.875	 26.250	 25.625Sep 29, 1993	AAPL 	  23.875	 24.875	 23.750Sep 29, 1993	BORL 	  15.125	 16.000	 14.500Sep 29, 1993	FRAM 	   7.750	  7.875	  7.750Sep 29, 1993	SNPS 	  47.250	 47.750	 47.250Sep 29, 1993	SUNW 	  25.250	 25.875	 24.875Sep 30, 1993	AAPL 	  23.375	 24.000	 23.000Sep 30, 1993	BORL 	  15.125	 15.500	 15.000Sep 30, 1993	FRAM 	   7.750	  7.875	  7.625Sep 30, 1993	SNPS 	  47.500	 47.500	 46.750Sep 30, 1993	SUNW 	  24.000	 25.500	 24.000Oct 1, 1993	AAPL 	  22.750	 23.750	 22.500Oct 1, 1993	BORL 	  15.000	 15.500	 14.875Oct 1, 1993	FRAM 	   7.875	  7.875	  7.500Oct 1, 1993	SNPS 	  47.000	 47.500	 47.000Oct 1, 1993	SUNW 	  22.125	 23.875	 21.625Oct 4, 1993	AAPL 	  22.750	 23.000	 22.000Oct 4, 1993	BORL 	  15.125	 15.250	 15.000Oct 4, 1993	FRAM 	   7.500	  7.500	  7.500Oct 4, 1993	SNPS 	  47.125	 47.250	 47.000Oct 4, 1993	SUNW 	  23.125	 23.875	 22.250Oct 6, 1993	AAPL 	  23.625	 24.000	 23.375Oct 6, 1993	BORL 	  15.875	 15.875	 15.500Oct 6, 1993	FRAM 	   7.375	  7.500	  7.250Oct 6, 1993	SNPS 	  45.625	 45.750	 43.500Oct 6, 1993	SUNW 	  22.250	 22.875	 22.125Oct 7, 1993	AAPL 	  23.000	 23.750	 22.750Oct 7, 1993	BORL 	  15.875	 15.875	 15.750Oct 7, 1993	FRAM 	   7.625	  7.625	  7.375Oct 7, 1993	SNPS 	  45.250	 46.250	 45.000Oct 7, 1993	SUNW 	  21.750	 22.250	 21.750Oct 8, 1993	AAPL 	  22.625	 23.250	 22.250Oct 8, 1993	BORL 	  16.125	 16.500	 16.000Oct 8, 1993	FRAM 	   7.625	  7.625	  7.500Oct 8, 1993	SNPS 	  45.000	 46.000	 45.000Oct 8, 1993	SUNW 	  21.250	 21.750	 21.125Oct 11, 1993	AAPL 	  23.750	 24.000	 22.750Oct 11, 1993	BORL 	  16.000	 16.500	 16.000Oct 11, 1993	FRAM 	   7.625	  7.625	  7.500Oct 11, 1993	SNPS 	  45.250	 45.750	 44.750Oct 11, 1993	SUNW 	  22.000	 22.625	 21.125Oct 12, 1993	AAPL 	  24.000	 25.000	 23.750Oct 12, 1993	BORL 	  16.000	 16.375	 15.875Oct 12, 1993	FRAM 	   7.500	  7.625	  7.500Oct 12, 1993	SNPS 	  48.500	 48.750	 45.750Oct 12, 1993	SUNW 	  22.500	 22.750	 22.000Oct 13, 1993	AAPL 	  24.000	 24.250	 23.500Oct 13, 1993	BORL 	  15.500	 15.875	 15.375Oct 13, 1993	FRAM 	   8.500	  8.500	  7.625Oct 13, 1993	SNPS 	  49.000	 49.250	 48.250Oct 13, 1993	SUNW 	  21.625	 22.375	 21.125Oct 14, 1993	AAPL 	  23.750	 24.500	 23.500Oct 14, 1993	BORL 	  15.500	 15.750	 15.500Oct 14, 1993	FRAM 	   8.625	  8.750	  8.375Oct 14, 1993	SNPS 	  50.750	 51.000	 49.000Oct 14, 1993	SUNW 	  23.000	 23.250	 21.250Oct 15, 1993	AAPL 	  28.250	 28.500	 24.500Oct 15, 1993	BORL 	  15.375	 15.625	 15.125Oct 15, 1993	FRAM 	   8.625	  8.750	  8.625Oct 15, 1993	SNPS 	  51.750	 52.000	 50.500Oct 15, 1993	SUNW 	  23.375	 23.625	 22.250Oct 18, 1993	AAPL 	  28.375	 28.750	 27.750Oct 18, 1993	BORL 	  15.500	 15.500	 15.000Oct 18, 1993	FRAM 	   8.875	  9.125	  8.625Oct 18, 1993	SNPS 	  51.000	 51.250	 50.500Oct 18, 1993	SUNW 	  24.125	 24.500	 23.375Oct 19, 1993	AAPL 	  27.750	 28.500	 27.250Oct 19, 1993	BORL 	  14.750	 15.500	 14.750Oct 19, 1993	FRAM 	   9.000	  9.625	  8.875Oct 19, 1993	SNPS 	  48.750	 50.750	 48.250Oct 19, 1993	SUNW 	  24.375	 24.750	 24.125Oct 20, 1993	AAPL 	  27.750	 28.250	 27.250Oct 20, 1993	BORL 	  15.750	 15.875	 14.875Oct 20, 1993	FRAM 	   8.750	  9.250	  8.750Oct 20, 1993	SNPS 	  47.000	 49.000	 47.000Oct 20, 1993	SUNW 	  24.250	 24.875	 24.000Oct 21, 1993	AAPL 	  30.250	 31.250	 27.250Oct 21, 1993	BORL 	  15.625	 15.875	 15.375Oct 21, 1993	FRAM 	   9.125	  9.125	  8.750Oct 21, 1993	SNPS 	  47.500	 48.000	 46.750Oct 21, 1993	SUNW 	  24.750	 25.125	 24.125Oct 22, 1993	AAPL 	  30.500	 31.500	 29.750Oct 22, 1993	BORL 	  16.000	 16.000	 14.875Oct 22, 1993	FRAM 	   8.875	  9.000	  8.750Oct 22, 1993	SNPS 	  49.250	 51.250	 47.500Oct 22, 1993	SUNW 	  25.125	 25.375	 24.625Oct 25, 1993	AAPL 	  29.750	 30.500	 29.625Oct 25, 1993	BORL 	  16.625	 16.875	 15.875Oct 25, 1993	FRAM 	   8.375	  8.875	  8.375Oct 25, 1993	SNPS 	  48.500	 49.500	 48.000Oct 25, 1993	SUNW 	  24.875	 25.625	 24.500Oct 26, 1993	AAPL 	  29.750	 30.000	 29.000Oct 26, 1993	BORL 	  16.625	 16.875	 16.250Oct 26, 1993	FRAM 	   9.500	  9.500	  8.500Oct 26, 1993	SNPS 	  48.250	 48.250	 47.000Oct 26, 1993	SUNW 	  24.625	 25.000	 24.500Oct 27, 1993	AAPL 	  31.750	 32.250	 29.750Oct 27, 1993	AAPL 	  31.750	 32.250	 29.750Oct 27, 1993	BORL 	  17.625	 17.625	 16.625Oct 27, 1993	FRAM 	  10.375	 10.375	  9.500Oct 27, 1993	SNPS 	  50.000	 50.000	 47.750Oct 27, 1993	SUNW 	  24.875	 25.000	 24.500Oct 28, 1993	AAPL 	  31.000	 32.250	 31.000Oct 28, 1993	BORL 	  16.750	 17.625	 16.750Oct 28, 1993	FRAM 	  10.250	 11.000	 10.125Oct 28, 1993	SNPS 	  51.750	 52.750	 49.750Oct 28, 1993	SUNW 	  24.875	 25.125	 24.625Oct 29, 1993	AAPL 	  30.750	 31.750	 30.500Oct 29, 1993	BORL 	  17.375	 17.500	 16.750Oct 29, 1993	FRAM 	   9.625	 10.375	  9.625Oct 29, 1993	SNPS 	  51.750	 52.000	 50.750Oct 29, 1993	SUNW 	  25.625	 25.750	 24.875Nov 1, 1993	AAPL 	  30.875	 31.000	 30.500Nov 1, 1993	BORL 	  17.250	 17.500	 16.750Nov 1, 1993	FRAM 	   9.875	 10.375	  9.625Nov 1, 1993	SNPS 	  52.000	 52.750	 51.750Nov 1, 1993	SUNW 	  25.500	 25.750	 24.875Nov 1, 1993	AAPL 	  31.500	 31.500	 30.250Nov 1, 1993	BORL 	  17.125	 17.500	 17.000Nov 1, 1993	FRAM 	  10.125	 10.250	  9.625Nov 1, 1993	SNPS 	  51.125	 52.750	 50.750Nov 1, 1993	SUNW 	  25.875	 26.250	 25.500Nov 3, 1993	AAPL 	  32.250	 33.000	 32.250Nov 3, 1993	BORL 	  17.125	 17.250	 17.000Nov 3, 1993	FRAM 	  10.750	 10.750	 10.000Nov 3, 1993	SNPS 	  49.500	 49.500	 49.500Nov 3, 1993	SUNW 	  25.000	 25.625	 25.000Nov 5, 1993	AAPL 	  31.750	 32.000	 31.250Nov 5, 1993	BORL 	  16.500	 16.625	 16.500Nov 5, 1993	FRAM 	  10.000	 10.750	 10.000Nov 5, 1993	SNPS 	  47.250	 48.000	 46.750Nov 5, 1993	SUNW 	  24.125	 24.375	 24.125Nov 5, 1993	AAPL 	  31.875	 32.250	 30.750Nov 5, 1993	BORL 	  17.125	 17.250	 16.250Nov 5, 1993	FRAM 	  10.250	 10.250	 10.000Nov 5, 1993	SNPS 	  48.750	 49.000	 46.500Nov 5, 1993	SUNW 	  24.875	 25.125	 23.750Nov 8, 1993	AAPL 	  31.375	 32.250	 31.000Nov 8, 1993	BORL 	  17.625	 17.750	 17.375Nov 8, 1993	FRAM 	   9.750	 10.250	  9.750Nov 8, 1993	SNPS 	  48.875	 49.000	 46.500Nov 8, 1993	SUNW 	  25.000	 25.125	 24.875Nov 8, 1993	AAPL 	  30.750	 32.125	 30.500Nov 8, 1993	BORL 	  17.500	 17.875	 17.250Nov 8, 1993	FRAM 	  10.000	 10.125	  9.750Nov 8, 1993	SNPS 	  49.500	 49.500	 48.500Nov 8, 1993	SUNW 	  24.750	 25.125	 24.500Nov 10, 1993	AAPL 	  30.250	 30.500	 30.250Nov 10, 1993	BORL 	  16.875	 17.125	 16.875Nov 10, 1993	FRAM 	  10.000	 10.250	  9.875Nov 10, 1993	SNPS 	  50.000	 50.750	 49.500Nov 10, 1993	SUNW 	  24.875	 25.000	 24.875'</body></methods><methods><class-id>UI.BG_LineChartView</class-id> <category>line/marker</category><body package="BGOK">chartLookList	^showMarker		ifTrue:	[LooksForMarkers]		ifFalse:	[LooksForLines]</body><body package="BGOK">hideLine	showLine := #hide</body><body package="BGOK">hideMarker	showMarker := false</body><body package="BGOK">isLineVisible	^showLine ~= #hide</body><body package="BGOK">isMarkerVisible	^showMarker</body><body package="BGOK">lineStyles: collectionOfSymbols 	| list lookPreference line style |	list := collectionOfSymbols asArray.	self composeLooks: list size.	1 to: list size		do: 			[:i | 			lookPreference := (self looksAt: i) copy.			line := list at: i.			line isNil				ifFalse: 					[style := BG_ChartElement perform: line.					lookPreference lineStyle: style.					elementLooks at: i put: lookPreference]]</body><body package="BGOK">lineType	^showLine</body><body package="BGOK">lineWidths: collectionOfSymbols 	| list lookPreference line |	list := collectionOfSymbols asArray.	self composeLooks: list size.	1 to: list size		do: 			[:i | 			lookPreference := (self looksAt: i) copy.			line := list at: i.			line isNil				ifFalse: 					[lookPreference lineWidth: line.					elementLooks at: i put: lookPreference]]</body><body package="BGOK">lines: collectionOfLines	| list lookPreference line |	list := collectionOfLines asArray.	self composeLooks: list size.	1 to: list size do:		[:i |		lookPreference := (self looksAt: i) copy.		line := list at: i.		line isInteger			ifTrue: [line := (self chartLookListAt: line) lineWidthAndStyle].		lookPreference lineWidthAndStyle: line.		elementLooks at: i put: lookPreference].</body><body package="BGOK">markers: collectionOfIntegers 	| list lookPreference marker |	list := collectionOfIntegers asArray.	self composeLooks: list size.	1 to: list size		do: 			[:i | 			lookPreference := (self looksAt: i) copy.			marker := list at: i.			marker isNil ifTrue: [marker := i].			marker isInteger				ifTrue: [marker := (self chartLookListAt: marker) marker]				ifFalse: [marker := BG_DataPointMarker imageAt: marker].			lookPreference marker: marker.			elementLooks at: i put: lookPreference]</body><body package="BGOK">showLine	showLine := #polyline</body><body package="BGOK">showMarker	showMarker := true</body><body package="BGOK">showSpline	showLine := #spline</body></methods><methods><class-id>UI.BG_LineChartView</class-id> <category>private</category><body package="BGOK">defaultDataAlignment: v	^v &gt;=0 ifTrue: [4] ifFalse: [6]</body><body package="BGOK">defaultDataOffset: v offset: offset	^v &gt;=0 ifTrue:[offset@0] ifFalse: [offset negated@0]</body><body package="BGOK">displayLineAndMarkerOn: aGraphicsContext at: index points: collectionOfPoints	| gc | 	gc := self setClientDataFor: aGraphicsContext		index: index		foreground: true.	self isLineVisible		ifTrue: 			[| polyline |			showLine = #polyline				ifTrue: [polyline := Polyline vertices: collectionOfPoints asArray]				ifFalse: [polyline := Spline controlPoints: collectionOfPoints].			(BG_ChartElement on: polyline)					fillInside: false;					displayOn: gc].	showMarker ifTrue:		[| dot |		dot := (gc clientDataAt: #chartElement) marker.		dot isNil ifTrue: [dot := (self chartLookListAt: index) marker].		collectionOfPoints do:			[:p | dot displayOn: gc at: p rounded]]</body></methods><methods><class-id>UI.BG_LineChartView</class-id> <category>displaying</category><body package="BGOK">displayDataOn: aGraphicsContext	| value images angle ofs gc |	value := self data.	gc := aGraphicsContext copy.	images := dataStyle individualImages.	angle := self defaultDataAngle.	ofs := 7.	1 to: value columnSize do: 		[:x | 1 to: value rowSize do: 			[:y | | n v |			n := sortedIndex at: x.			v := value at: n@y.			grid 				displayLabel: (images at: n@y)				angle: angle 				offset: (self defaultDataOffset: v offset: ofs)				alignment: (self defaultDataAlignment: v)				on: gc 				at: (grid applyTo: x@v) rounded]]</body><body package="BGOK">displayLegendSymbol: anIndex in: aRectangle on: aGraphicsContext 	self isLineVisible ifTrue: [		(BG_ChartElement on: (LineSegment from: aRectangle leftCenter to: aRectangle rightCenter)) displayOn: aGraphicsContext].	showMarker		ifTrue: 			[| dot |			dot := (aGraphicsContext clientDataAt: #chartElement) marker.			dot isNil ifTrue: [dot := (self chartLookListAt: anIndex) marker].			dot displayOn: aGraphicsContext at: aRectangle center]</body><body package="BGOK">displayPlotOn: aGraphicsContext 	| value points collection |	value := self data. 	points := BG_TableAdaptor columns: value columnSize rows: value rowSize.	1 to: value columnSize do: 		[:x | 			| n |			n := sortedIndex at: x.			1 to: value rowSize do:				[:y | 					points at: x@y put: x@(value at: n@y)]].	collection := grid applyToValues: points.	1 to: value rowSize do:		[:y | 			self				displayLineAndMarkerOn: aGraphicsContext				at: y				points: (collection rowAt: y)]</body></methods><methods><class-id>UI.BG_LineChartView</class-id> <category>initialize-release</category><body package="BGOK">initialize	super initialize.	self showLine.	showMarker := false</body></methods><methods><class-id>UI.BG_LineChartView</class-id> <category>color/mask/line/marker</category><body package="BGOK">looksType	"Answer what kind of looks a chart expects. We distinguish two types:	#region for bar and pie charts and	#line for line and xy charts.	I'm the line chart so the answer is #line"	^#line</body></methods><methods><class-id>UI.BG_XYChartView</class-id> <category>private</category><body package="BGOK">composeGrid	| matrix |	grid x isAutoScaled &amp; grid x isAutoLabeled ifTrue: 		[matrix := self dataRangeMatrixX.		grid x scale autoMin: (self min: matrix) max: (self max: matrix)].	grid y isAutoScaled &amp; grid y isAutoLabeled ifTrue: 		[matrix := self dataRangeMatrix.		grid y scale autoMin: (self min: matrix) max: (self max: matrix)].	grid bounds: self plotArea.</body><body package="BGOK">composeLabels: size</body><body package="BGOK">composeSortIndex: sortedValues</body><body package="BGOK">dataRangeMatrix	^self data collect: [:p | p y]</body><body package="BGOK">dataRangeMatrixX	^self data collect: [:p | p x]</body></methods><methods><class-id>UI.BG_XYChartView</class-id> <category>initialize-release</category><body package="BGOK">initialize	super initialize.	grid x dataAxis.	showMarker := true.	self hideLine</body></methods><methods><class-id>UI.BG_XYChartView</class-id> <category>displaying</category><body package="BGOK">displayDataOn: aGraphicsContext	| value images angle ofs gc |	value := self data.	gc := aGraphicsContext copy.	images := dataStyle individualImages.	angle := self defaultDataAngle.	ofs := 7.	1 to: value columnSize do: 		[:x | 1 to: value rowSize do: 			[:y | | n v |			n :=  x.			v := value at: n@y.			grid 				displayLabel: (images at: n@y)				angle: angle 				offset: (self defaultDataOffset: v y offset: ofs)				alignment: (self defaultDataAlignment: v y)				on: gc 				at: (grid applyTo: v) rounded]]</body><body package="BGOK">displayPlotOn: aGraphicsContext 	| collection value |	value := self data.	collection := grid applyToValues: self data.	1 to: value rowSize do: [:y | self			displayLineAndMarkerOn: aGraphicsContext			at: y			points: (collection rowAt: y)]</body></methods><methods><class-id>UI.BG_XYChartView</class-id> <category>private-default-model</category><body package="BGOK">defaultModelFor: dataDescriptor 	"Answer a default model for specified number of series. 	The default model is a List containing arrays. 	Each element of the array is a point. 	Note that some columns cotain labels."	| defModel xRange inc x |	defModel := super defaultModelFor: dataDescriptor.	xRange := self grid x isAutoScaled				ifTrue: [self defaultRange]				ifFalse: [self grid x scale sourceMin to: self grid x scale sourceMax].	inc := xRange last - xRange first / (defModel size + 2).	x := xRange first + inc.	dataDescriptor columns &lt; 2 		ifTrue: [1 to: defModel size				do: 					[:i | 					| val |					val := defModel at: i.					defModel at: i put: x @ val.					x := x + inc]]		ifFalse: [defModel				do: 					[:row | 					1 to: row size						do: 							[:i | 							| y |							y := row at: i.							row at: i put: x @ y].					x := x + inc]].	^defModel</body></methods><methods><class-id>Tools.ChartColorTool</class-id> <category>private</category><body package="BGOK">changedColor	colorValue value saturation = 0					ifTrue: [(builder componentAt: #hue) beInvisible.							(builder componentAt: #hueLabel) beInvisible]					ifFalse: [(builder componentAt: #hue) beVisible.							(builder componentAt: #hueLabel) beVisible].	colorValue value brightness = 0.0					ifTrue: [(builder componentAt: #saturation) beInvisible.							(builder componentAt: #saturationLabel) beInvisible]					ifFalse: [(builder componentAt: #saturation) beVisible.							(builder componentAt: #saturationLabel) beVisible].</body><body package="BGOK">changedCubesBrightness	cubesBrightness value = 1 ifTrue: [^self].	cubeColors do:		[:v |		| c |		c := v value.		v value: (ColorValue hue: c hue saturation: c saturation brightness: 1.0 - cubesBrightness value)].</body><body package="BGOK">initChips	"Set the background colors of the color chips to be some actual	color (not nil) so that when showColors is initially called it will	definitely print 'none' on those chips that wind up having null	colors."	#(#foregroundChip #backgroundChip #selectionForegroundChip #selectionBackgroundChip)		do:			[:chpname |			(builder componentAt: chpname) getLookPreferences setBackgroundColor:				Screen default defaultPaintPreferences backgroundColor]</body><body package="BGOK">setBGColorFrom: aColor 	| chip button |	chip := builder componentAt: #backgroundChip.	button := builder componentAt: #backgroundButton.	lookPreferences setBackgroundColor: aColor.	chip getLookPreferences setBackgroundColor: aColor.	button labelString: (aColor isNil			ifTrue: [(#none &lt;&lt; #BGOK &gt;&gt; 'none')]			ifFalse: [''])</body><body package="BGOK">setFGColorFrom: aColor 	| chip button |	chip := builder componentAt: #foregroundChip.	button := builder componentAt: #foregroundButton.	lookPreferences setForegroundColor: aColor.	chip getLookPreferences setBackgroundColor: aColor.	button labelString: (aColor isNil			ifTrue: [(#none &lt;&lt; #BGOK &gt;&gt; 'none')]			ifFalse: [''])</body><body package="BGOK">setUpVisuals	|  ext  r c  brightness lead x y sats v cp grays|	(builder componentAt: #foregroundChip) setLookPreferences: LookPreferences new.	(builder componentAt: #backgroundChip)  setLookPreferences:  LookPreferences new.	self setFGColorFrom: lookPreferences foregroundColor.	self setBGColorFrom: lookPreferences backgroundColor. 	(builder componentAt: #theActualColor) widget		add: (ColoredArea model: colorValue) in: (0@0 corner: 1@1).	cp := builder componentAt: #colorSpace.	ext := 20.	lead := 2.	grays :=  #(1 0.94 0.86 0.8 0.7 0.6 0.43 0 ).  	"these values are gama corrected using ((i/7)**(1/2.3))and hand edited to overlap with the system"	0 to: 7 do:		[:i |		r := (0@((i)*ext)+ (lead@lead)) extent: ext@ext - (lead@lead).		c := ValueHolder with: (ColorValue brightness: (grays at: i+1)).		v := ColoredArea new.		v controller: ColoredAreaController new.		v model: colorValue.		v select: c.		cp widget add: v in: r].			cubeColors := OrderedCollection new.	brightness := 1.0 - cubesBrightness value.	sats := 8* brightness.	y := 0.	1 to: sats do:		[:s |		|saturation |		saturation := s asFloat / sats.		x := 1.		#(0 30 60 90 120 150 180 210 240 270 300 330) do:			[:h | 			| hue |			hue := h asFloat /360.0.			r := ((x*ext)@(y*ext)+ (lead@lead) + (2@0)) extent: ext@ext - (lead@lead).			c := ValueHolder with: (ColorValue hue: hue saturation: saturation brightness: brightness).			v := ColoredArea new.			v controller: ColoredAreaController new.			v model: colorValue.			v select: c.			cubeColors add: c.			cp widget add: v in: r.			x := x + 1].		y := y + 1].</body></methods><methods><class-id>Tools.ChartColorTool</class-id> <category>interface opening</category><body package="BGOK">postBuildWith: aBuilder	self setUpVisuals.	(builder componentAt: #saturation) beInvisible.	(builder componentAt: #saturationLabel) beInvisible.	(builder componentAt: #hue) beInvisible.	(builder componentAt: #hueLabel) beInvisible.	builder window icon: (Icon constantNamed: #colorTool)</body></methods><methods><class-id>Tools.ChartColorTool</class-id> <category>aspects</category><body package="BGOK">brightness	^(PluggableAdaptor on: colorValue)		getBlock: [:m | m value brightness]		putBlock: 			[:m :v | 			m value:				(ColorValue					hue: m value hue					saturation: m value saturation					brightness: v).			v = 0				ifTrue: 					[(self builder componentAt: #saturation) beInvisible.					(self builder componentAt: #saturationLabel) beInvisible]				ifFalse: 					[(self builder componentAt: #saturation) beVisible.					(self builder componentAt: #saturationLabel) beVisible]]		updateBlock: [:m :a :p | true]</body><body package="BGOK">hue	^(PluggableAdaptor on: colorValue)		getBlock: [:m | m value hue]		putBlock:			[:m :v |			m value:				(ColorValue					hue:  v					saturation: m value saturation					brightness: m value brightness)]		updateBlock: [:m :a :p | true].</body><body package="BGOK">saturation	^(PluggableAdaptor on: colorValue)			getBlock: [:m | m value saturation]			putBlock:					[:m :v |					m value:							(ColorValue							hue: m value hue							saturation:  v							brightness: m value brightness)]			updateBlock: [:m :a :p | true].</body><body package="BGOK">sliderModel	^cubesBrightness</body></methods><methods><class-id>Tools.ChartColorTool</class-id> <category>accessing</category><body package="BGOK">lookPreferences	^lookPreferences</body><body package="BGOK">lookPreferences: aValue	lookPreferences := aValue</body></methods><methods><class-id>Tools.ChartColorTool</class-id> <category>initialize-release</category><body package="BGOK">initialize	super initialize.	lookPreferences := LookPreferences new.	colorValue := ValueHolder with: ColorValue black.	cubesBrightness := 0.0 asValue.	colorValue onChangeSend: #changedColor to: self.	cubesBrightness onChangeSend: #changedCubesBrightness to: self.</body></methods><methods><class-id>Tools.ChartColorTool</class-id> <category>actions</category><body package="BGOK">changeBGColor	self setBGColorFrom: (lookPreferences backgroundColor == colorValue value			ifTrue: [nil]			ifFalse: [colorValue value])</body><body package="BGOK">changeFGColor	self setFGColorFrom: (lookPreferences foregroundColor == colorValue value			ifTrue: [nil]			ifFalse: [colorValue value])</body></methods><methods><class-id>Examples.BG_SalesItem</class-id> <category>salesHP:</category><body package="BGOK">salesHP: aValue	salesHP := aValue</body></methods><methods><class-id>Examples.BG_SalesItem</class-id> <category>salesSun:</category><body package="BGOK">salesSun: aValue	salesSun := aValue</body></methods><methods><class-id>Examples.BG_SalesItem</class-id> <category>salesRS:</category><body package="BGOK">salesRS: aValue	salesRS := aValue</body></methods><methods><class-id>Examples.BG_SalesItem</class-id> <category>salesWin:</category><body package="BGOK">salesWin: aValue	salesWin := aValue</body></methods><methods><class-id>Examples.BG_SalesItem</class-id> <category>salesMac</category><body package="BGOK">salesMac	^salesMac</body></methods><methods><class-id>Examples.BG_SalesItem</class-id> <category>month</category><body package="BGOK">month	^month</body></methods><methods><class-id>Examples.BG_SalesItem</class-id> <category>total</category><body package="BGOK">total	^self salesWin + self salesSun + self salesMac + self salesHP</body></methods><methods><class-id>Examples.BG_SalesItem</class-id> <category>salesHP</category><body package="BGOK">salesHP	^salesHP</body></methods><methods><class-id>Examples.BG_SalesItem</class-id> <category>month:</category><body package="BGOK">month: aValue	month := aValue</body></methods><methods><class-id>Examples.BG_SalesItem</class-id> <category>salesSun</category><body package="BGOK">salesSun	^salesSun</body></methods><methods><class-id>Examples.BG_SalesItem</class-id> <category>salesRS</category><body package="BGOK">salesRS	^salesRS</body></methods><methods><class-id>Examples.BG_SalesItem</class-id> <category>initialize</category><body package="BGOK">initialize	salesHP := salesMac := salesRS := salesSun := salesWin := 0.</body></methods><methods><class-id>Examples.BG_SalesItem</class-id> <category>salesWin</category><body package="BGOK">salesWin	^salesWin</body></methods><methods><class-id>Examples.BG_SalesItem</class-id> <category>salesMac:</category><body package="BGOK">salesMac: aValue	salesMac := aValue</body></methods><methods><class-id>Examples.BG_SalesItem class</class-id> <category>new</category><body package="BGOK">new	^super new initialize</body></methods><methods><class-id>UI.BG_TextLabel</class-id> <category>accessing</category><body package="BGOK">extent	^self bounds extent</body></methods><methods><class-id>UI.BG_ChartScale</class-id> <category>accessing</category><body package="BGOK">autoMin: min max: max 	"Sets sources automatically from arguments"	| amin amax factors |	(min isNil or: [max isNil])		ifFalse: 			[amin := min min: max.			amax := min max: max.			factors := self getScaleMin: amin max: amax.			self sourceMin: (factors at: 1)				max: (factors at: 2).			self step: (factors at: 3)]</body><body package="BGOK">decrease	increase := false</body><body package="BGOK">destLength	^destMax - destMin</body><body package="BGOK">destLength: anInteger	self destMin: destMin max: destMin + anInteger</body><body package="BGOK">destMax	^destMax</body><body package="BGOK">destMin	^destMin</body><body package="BGOK">destMin: min max: max	destMin := min min: max.	destMax := min max: max.</body><body package="BGOK">div	^div</body><body package="BGOK">div: positiveInteger	div := positiveInteger</body><body package="BGOK">increase	increase := true</body><body package="BGOK">reverse	increase := increase not</body><body package="BGOK">sourceLength	^sourceMax - sourceMin</body><body package="BGOK">sourceLength: anInteger	self sourceMin: sourceMin max: sourceMin + anInteger</body><body package="BGOK">sourceMax	^sourceMax</body><body package="BGOK">sourceMin	^sourceMin</body><body package="BGOK">sourceMin: min max: max	sourceMin := min min: max.	sourceMax := min max: max.</body><body package="BGOK">step	^step</body><body package="BGOK">step: positiveNumber 	positiveNumber isZero		ifTrue: [step := 1]		ifFalse: [step := positiveNumber abs]</body><body package="BGOK">zero	^zero isNil ifTrue: [sourceMin] ifFalse: [zero]</body><body package="BGOK">zero: aNumber	zero := aNumber</body></methods><methods><class-id>UI.BG_ChartScale</class-id> <category>private</category><body package="BGOK">filter: aNumber	"This allows the receiver to introduce non-linear mappings	from data space to presentation space, such as eliminating	gaps in the data."	^aNumber</body><body package="BGOK">getMainlyNegativeScaleMin: min max: max	| minValue maxValue stepValue f i fr count | 	f := (min negated log: 10) roundTo: 0.00001.	i := f asFloat integerPart asInteger.	fr := f - i.	#((0 -1 5) (0.32 -2 4) (0.49 -3 3) (0.7 -5 5) (0.908 -8 4) (1 -10 5)) do:		[:a | 			(fr &lt;= (a at: 1)) ifTrue: 				[minValue := (10 raisedTo: i) * (a at: 2).				stepValue := (minValue / (a at: 3) roundTo: (10 raisedTo: i - 1)) negated.				count  := 0.				[count * stepValue &lt; max] whileTrue: [count := count + 1].				maxValue := stepValue * count.				^(Array with: minValue - (stepValue * 0.48) with: maxValue + (stepValue * 0.48) with: stepValue)]].</body><body package="BGOK">getMainlyPositiveScaleMin: min max: max 	| scale |	scale := self getMainlyNegativeScaleMin: max negated max: min negated.	^Array		with: (scale at: 2) negated		with: (scale at: 1) negated		with: (scale at: 3)</body><body package="BGOK">getOnlyNegativeScaleMin: min max: max	| minValue maxValue stepValue f i fr | 	f := (min negated log: 10) roundTo: 0.00001.	i := f asFloat integerPart asInteger.	fr := f - i.	#((0 -1 5) (0.32 -2 4) (0.49 -3 3) (0.7 -5 5) (0.908 -8 4) (1 -10 5)) do:		[:a | 			(fr &lt;= (a at: 1)) ifTrue: 				[minValue := (10 raisedTo: i) * (a at: 2).				stepValue := (minValue / (a at: 3) roundTo: (10 raisedTo: i - 1)) negated.				maxValue := 0.				^(Array with: minValue - (stepValue * 0.48) with: maxValue with: stepValue)]].</body><body package="BGOK">getOnlyPositiveScaleMin: min max: max 	| scale |	scale := self getOnlyNegativeScaleMin: max negated max: min negated.	^Array		with: (scale at: 2) negated		with: (scale at: 1) negated		with: (scale at: 3)</body><body package="BGOK">getScaleMin: min max: max	(min = 0 and: [max = 0]) ifTrue: [^Array with: 0 with: 100 with: 20].	min &gt;= 0 ifTrue: [^self getOnlyPositiveScaleMin: min max: max].	max &lt;= 0 ifTrue: [^self getOnlyNegativeScaleMin: min max: max].	max abs &gt;= min abs		ifTrue: [^self getMainlyPositiveScaleMin: min max: max]		ifFalse: [^self getMainlyNegativeScaleMin: min max: max]</body><body package="BGOK">inverseFilter: aNumber	"This allows the receiver to introduce non-linear mappings	from presentation space to data space, such as eliminating	gaps in the data."	^aNumber</body><body package="BGOK">setMin: minValue max: maxValue by: stepValue from: zeroValue div: divisionValue	"Initialize the instance variables."	increase := true.	zero := zeroValue.	self sourceMin: minValue max: maxValue.	self destMin: 0 max: self sourceLength.	self step: stepValue.	div := divisionValue</body></methods><methods><class-id>UI.BG_ChartScale</class-id> <category>testing</category><body package="BGOK">includesZero	"Answer true if the receiver's zero is between minimum and maxmum value in source coodinates"	^self zero between: sourceMin and: sourceMax</body><body package="BGOK">incrementalScaled	"Answer true if the receiver is an incremental scale"	^increase</body><body package="BGOK">scaleType	"All subclasses like Log Scale will thier types"	^#normal</body></methods><methods><class-id>UI.BG_ChartScale</class-id> <category>mark access</category><body package="BGOK">divisionMarks	"Answer collection of numbers that repesents positions of division mark in source coodinates"	| offset marks mv | 	marks := OrderedCollection new.	offset := (self zero - sourceMin) abs \\ step.	self zero &lt; sourceMin ifTrue: [offset := step - offset \\ step].	mv := self zero + (step / 2).	sourceMin + offset + (step / 2) to: sourceMax by: step do:		[:n | marks add: (mv coerce: n)].	^marks</body><body package="BGOK">edgeMarks	"Answer collection of numbers that repesents positions of minimum and maximum mark in source coodinates"	^OrderedCollection with: sourceMin with: sourceMax</body><body package="BGOK">majorMarks	"Answer collection of numbers that repesents positions of major mark in source coodinates"	| offset marks mv | 	marks := OrderedCollection new.	offset := (self zero - sourceMin) abs \\ step.	self zero &lt; sourceMin ifTrue: [offset := step - offset \\ step].	mv := self zero + step.	sourceMin + offset to: sourceMax by: step do:		[:n | marks add: (mv coerce: n)].	^marks</body><body package="BGOK">minorMarks	"Answer collection of numbers that repesents positions of minor mark in source coodinates"	| offset marks minorStep mv | 	minorStep := (step / div) asFloat.	marks := OrderedCollection new.	offset := (self zero - sourceMin) abs \\ minorStep.	self zero &lt; sourceMin ifTrue: [offset := minorStep - offset \\ minorStep].	mv := self zero + minorStep.	sourceMin + offset to: sourceMax by: minorStep do:		[:n | marks add: (mv coerce: n)].	^marks</body><body package="BGOK">noMarks	"Answer an empty collection."	^#()</body><body package="BGOK">zeroMarks	"Answer collection of numbers that repesents positions of zero mark in source coodinates"	| marks | 	marks := OrderedCollection new.	self includesZero ifTrue: [marks add: self zero].	^marks</body></methods><methods><class-id>UI.BG_ChartScale</class-id> <category>applying transform</category><body package="BGOK">applyInverseTo: aNumber	"Answer translated value in source coodinates"	| rate |	rate := (aNumber - destMin) / self destLength.	^self inverseFilter: ((increase ifTrue: [rate] ifFalse: [1 - rate]) * self sourceLength + sourceMin)</body><body package="BGOK">applyInverseToValues: collectionOfNumbers 	"Answer translated values in source coodinates"	^collectionOfNumbers collect: [:each | self applyInverseTo: each]</body><body package="BGOK">applyTo: aNumber	"Answer translated value in destination coodinates"	| rate |	self sourceLength = 0 ifTrue: [^destMin].		rate := ((self filter: aNumber) - sourceMin) asFloat / self sourceLength.	^(increase ifTrue: [rate] ifFalse: [1 - rate]) * self destLength + destMin</body><body package="BGOK">applyToValues: collectionOfNumbers 	"Answer translated values in destination coodinates"	^collectionOfNumbers collect: [:each | self applyTo: each]</body></methods><methods><class-id>UI.BG_ChartScale class</class-id> <category>instance creation</category><body package="BGOK">default	"Answer a new instance of BG_ChartScale"	^self		min: 0		max: 100		by: 20</body><body package="BGOK">min: minValue max: maxValue 	"Answer a new instance of BG_ChartScale"	^self		min: minValue		max: maxValue		by: 1</body><body package="BGOK">min: minValue max: maxValue by: stepValue 	"Answer a new instance of BG_ChartScale"	^self		min: minValue		max: maxValue		by: stepValue		from: nil</body><body package="BGOK">min: minValue max: maxValue by: stepValue from: fromValue 	"Answer a new instance of BG_ChartScale"	^self		min: minValue		max: maxValue		by: stepValue		from: fromValue		div: 1</body><body package="BGOK">min: minValue max: maxValue by: stepValue from: fromValue div: divValue 	"Answer a new instance of BG_ChartScale"	^super new		setMin: minValue		max: maxValue		by: stepValue		from: fromValue		div: divValue</body><body package="BGOK">new	"Provide an error notification that BG_ChartScales are not created	using this message."	self error: (#GenKey0 &lt;&lt; #BGOK &gt;&gt; 'BG_ChartScales are created with range: , min:max: ...')</body></methods><methods><class-id>UI.BG_ChartLogScale</class-id> <category>accessing</category><body package="BGOK">base	^base</body><body package="BGOK">base: aNumber 	base := aNumber.	zero := base raisedTo: (sourceMin log: base) floor.</body><body package="BGOK">baseExp	self base: 1 exp</body><body package="BGOK">sourceMin: min max: max	super sourceMin: min max: max.	zero := (base raisedTo: (sourceMin log: base) floor) asFloat.</body><body package="BGOK">step: positiveNumber	step := ((positiveNumber abs max: 1) min: 10) asFloat.</body><body package="BGOK">zero: aNumber</body></methods><methods><class-id>UI.BG_ChartLogScale</class-id> <category>private</category><body package="BGOK">getScaleMin: min max: max 	min &lt;= 0		ifTrue: [^Array				with: 1				with: (base raisedTo: (max log: base) ceiling)				with: 10]		ifFalse: [^Array				with: (base raisedTo: (min log: base) floor)				with: (base raisedTo: (max log: base) ceiling)				with: 10]</body><body package="BGOK">logSourceLength	^(sourceMax log: base) - (sourceMin log: base)</body><body package="BGOK">setMin: minValue max: maxValue by: stepValue from: zeroValue div: divisionValue	"Initialize the instance variables."	base := 10.	super setMin: minValue max: maxValue by: stepValue from: zeroValue div: divisionValue</body></methods><methods><class-id>UI.BG_ChartLogScale</class-id> <category>testing</category><body package="BGOK">scaleType	"I'm a Log Scale"	^#log</body></methods><methods><class-id>UI.BG_ChartLogScale</class-id> <category>applying transform</category><body package="BGOK">applyInverseTo: aNumber	| rate |	rate := (aNumber - destMin) / self destLength.	^self inverseFilter: (base raisedTo: (increase ifTrue: [rate] ifFalse: [1 - rate]) * self logSourceLength + (sourceMin log: base))</body><body package="BGOK">applyTo: aNumber 	| rate |	aNumber = 0 ifTrue: [^0].	rate := ((self filter: aNumber)				log: base)				- (sourceMin log: base) / self logSourceLength.	^(increase		ifTrue: [rate]		ifFalse: [1 - rate])		* self destLength + destMin</body></methods><methods><class-id>UI.BG_ChartLogScale</class-id> <category>mark access</category><body package="BGOK">divisionMarks	| marks start stop by times in |	marks := OrderedCollection new.	times := (sourceMax log: base) ceiling - (sourceMin log: base) floor.	start := self zero.	stop := start * 10.	by := step * start.	1 to: times do: 		[:i | 			in := false.			(by/2) to: stop by: by do: 				[:n | 					n &gt; sourceMax ifTrue: [^marks].					(n &gt; start and: [n &gt;= sourceMin]) ifTrue: [in := true].					in ifTrue: [marks add: n asFloat]].		start := start * 10.		stop := stop * 10.		by := by * 10].	^marks</body><body package="BGOK">majorMarks	| marks start stop by times in |	marks := OrderedCollection new.	times := (sourceMax log: base) ceiling - (sourceMin log: base) floor.	start := self zero.	stop := start * 10.	by := step * start.	start &gt;= sourceMin ifTrue: [marks add: start asFloat].	1 to: times do: 		[:i | 			in := false.			0 to: stop by: by do: 				[:n | 					n &gt; sourceMax ifTrue: [^marks].					(n &gt; start and: [n &gt;= sourceMin]) ifTrue: [in := true].					in ifTrue: [marks add: n asFloat]].		start := start * 10.		stop := stop * 10.		by := by * 10].	^marks</body><body package="BGOK">minorMarks	| marks start stop by times in |	marks := OrderedCollection new.	times := (sourceMax log: base) ceiling - (sourceMin log: base) floor.	start := self zero.	stop := start * 10.	by := step / div * start.	start &gt;= sourceMin ifTrue: [marks add: start asFloat].	1 to: times do: 		[:i | 			in := false.			0 to: stop by: by do: 				[:n | 					n &gt; sourceMax ifTrue: [^marks].					(n &gt; start and: [n &gt;= sourceMin]) ifTrue: [in := true].					in ifTrue: [marks add: n asFloat]].		start := start * 10.		stop := stop * 10.		by := by * 10].	^marks</body></methods><methods><class-id>UI.BG_ChartLogScale class</class-id> <category>instance creation</category><body package="BGOK">default	"Answer a new instance of BG_ChartScale"	^self		min: 0.1		max: 100		by: 5</body></methods><methods><class-id>UI.BG_ChartGrid</class-id> <category>visual properties</category><body package="BGOK">lookPreferences	^x getLookPreferences</body></methods><methods><class-id>UI.BG_ChartGrid</class-id> <category>accessing</category><body package="BGOK">h	"Answer receiver's horizontal axis"	^transposed ifTrue: [y] ifFalse: [x]</body><body package="BGOK">transpose	"Transpose the recever's scales"		transposed := transposed not.	self bounds: self bounds</body><body package="BGOK">v	"Answer receiver's vertical axis"	^transposed ifTrue: [x] ifFalse: [y]</body><body package="BGOK">x	^x</body><body package="BGOK">x: anAxis	"Make the argument, anAxis, the receiver's x axis"	x := anAxis</body><body package="BGOK">y	^y</body><body package="BGOK">y: anAxis	"Make the argument, anAxis, the receiver's y axis"	y := anAxis</body></methods><methods><class-id>UI.BG_ChartGrid</class-id> <category>bounds accessing</category><body package="BGOK">bounds: aRectangle 	| boundingBox op cp offsetx offsety| 	x compose. 	y compose.	boundingBox := Rectangle origin: Point zero extent: (aRectangle extent max: self minimumExtent).	boundingBox := boundingBox align: boundingBox center with: aRectangle center.	op := 0@0.	cp := 0@0. 	offsetx := self h labelsStyle individualExtent x // 2.	offsety := (self v labelsStyle individualExtent y // 2) + 5.	self h unit notNil ifTrue: 		[offsetx := offsetx + 7 + (self h unitStyle extent x )].	self v unit notNil ifTrue: 		["Since the last label can be at the end I have to have room 		for the whole unit"		offsety := offsety + (self v unitStyle extent y)].	self h scale incrementalScaled 			ifTrue: [op := op + (self horizontalMargin @ 0).					cp := cp + (offsetx @ 0)]			ifFalse: [cp := cp + (self horizontalMargin @ 0).					op := op + (offsetx @ 0)].	self v scale incrementalScaled 			ifTrue: [op := op + (0 @ self verticalMargin).					cp := cp + (0 @ offsety)]			ifFalse: [cp := cp + (0 @ self verticalMargin).					op := op + (0 @ offsety)].	cp := cp max: 2@2.	op := op max: 2@2.	self insetBounds: (boundingBox insetOriginBy: op cornerBy: cp)</body><body package="BGOK">insetBounds 	"Answer a Rectangle represents the receiver's insetBounds (in destination coodinate system)"	^Rectangle origin: self h scale destMin @ self v scale destMin corner: self h scale destMax @ self v scale destMax</body><body package="BGOK">insetBounds:  aRectangle	"Make the argument, aRectangle, the receiver's insetBounds"	self h scale destMin: aRectangle left max: aRectangle right.	self v scale destMin: aRectangle top max: aRectangle bottom.</body><body package="BGOK">preferredBounds	^self insetBounds expandedBy: self horizontalMargin@self verticalMargin</body></methods><methods><class-id>UI.BG_ChartGrid</class-id> <category>displaying</category><body package="BGOK">displayHAxisOn: aGraphicsContext 	| h hs vs py line marks |	hs := (h := self h) scale.	vs := self v scale.	py := (vs includesZero				ifTrue: [vs applyTo: vs zero]				ifFalse: [vs incrementalScaled ifTrue: [vs destMin] ifFalse: [vs destMax]]) rounded.	"Display axis line"	(line := h axisLine) isPathVisible ifTrue:		[aGraphicsContext				displayLineFrom: hs destMin @ py				to: hs destMax @ py].	"Display major tick marks"	(line := h majorTick) isPathVisible ifTrue:		[marks := hs applyToValues: hs majorMarks.		line := line geometric.	 	vs incrementalScaled			ifFalse: [line := LineSegment from: line start negated to: line end negated].		line := line asStroker.		1 to: marks size do: [:i | line displayOn: aGraphicsContext at: (marks at: i) rounded @ py]].	"Display minor tick marks"	((line := h minorTick) isPathVisible and: [hs div ~= 1]) ifTrue: 		[marks := hs applyToValues: hs minorMarks.		line := line geometric.	 	vs incrementalScaled			ifFalse: [line := LineSegment from: line start negated to: line end negated].		line := line asStroker.		1 to: marks size do: [:i | line displayOn: aGraphicsContext at: (marks at: i) rounded @ py]]</body><body package="BGOK">displayHLabelsOn: aGraphicsContext 	| gc h hs vs marks py images sizeOfLabels |	hs := (h := self h) scale.	vs := self v scale.	py := ((vs includesZero and: [h isAutoLabeled])				ifTrue: [vs applyTo: vs zero]				ifFalse: [vs incrementalScaled ifTrue: [vs destMin] ifFalse: [vs destMax]]) rounded.	"Display axis labels"	marks := hs applyToValues: h labelsMarks.	gc := aGraphicsContext copy.	images := h labelsStyle individualImages.	sizeOfLabels := marks size min: images size.	1 to: sizeOfLabels do: 		[:i | 			| image |			image := images at: i.			image displayOn: gc at: (marks at: i) rounded - (image bounds extent x // 2) @ (vs incrementalScaled ifTrue: [py - 5 - image bounds extent y] ifFalse: [py + 5])].	"Display axis unit"	(h unit notNil and: [sizeOfLabels &gt; 0]) ifTrue:		[h unitStyle displayOn: aGraphicsContext at: (marks at: sizeOfLabels) rounded + (hs incrementalScaled ifTrue: [(images at: sizeOfLabels) bounds extent x // 2 + 5] ifFalse: [0-((images at: sizeOfLabels) bounds extent x // 2 + 5 + h unitStyle extent x)])@ (vs incrementalScaled ifTrue: [py - 5 - h unitStyle extent y] ifFalse: [py + 5])].	"Display axis title"	h title notNil ifTrue: 		[| lh |		h titleStyle rotation ~= 0 ifTrue: [h titleStyle rotation: 0].		h titleStyle scale ~= (1 @ 1) ifTrue: [h titleStyle scale: 1 @ 1].		lh := h labelsStyle individualExtent y.		h titleStyle displayOn: aGraphicsContext at: self insetBounds center x - (h titleStyle extent x // 2) @ (vs incrementalScaled ifTrue: [py - (lh + 5 + h titleStyle extent y)] ifFalse: [py + (lh + 5)])]</body><body package="BGOK">displayHLinesOn: aGraphicsContext 	| v hs vs block marks line startX endX |	vs := (v := self v) scale.	hs := self h scale.	startX := hs destMin rounded.	endX := hs destMax rounded.	line := v sectionLine.	block := 			[:py :gc | 			gc displayLineFrom: startX @ py to: endX @ py].	"Display section lines"	line isPathVisible ifTrue:		[marks := vs applyToValues: v sectionMarks.		1 to: marks size do: [:i | block value: (marks at: i) rounded value: aGraphicsContext]].	"Display border lines"	(line := v borderLine) isPathVisible ifTrue:		[marks := vs applyToValues: vs edgeMarks.		block value: marks first rounded value: aGraphicsContext.		block value: marks last rounded value: aGraphicsContext]</body><body package="BGOK">displayOn: aGraphicsContext 	self displayHLinesOn: aGraphicsContext.	self displayVLinesOn: aGraphicsContext.	self displayHAxisOn: aGraphicsContext.	self displayVAxisOn: aGraphicsContext.	self displayHLabelsOn: aGraphicsContext.	self displayVLabelsOn: aGraphicsContext</body><body package="BGOK">displayVAxisOn: aGraphicsContext	| v vs hs px line marks fixup |	vs := (v := self v) scale.	hs := self h scale.	px := (hs includesZero				ifTrue: [hs applyTo: hs zero]				ifFalse: [hs incrementalScaled ifTrue: [hs destMin] ifFalse: [hs destMax]]) rounded.	"Display axis line"	(line := v axisLine) isPathVisible ifTrue:		[aGraphicsContext displayLineFrom: px @ vs destMin				to: px @ vs destMax].	"Display major tick marks"	(line := v majorTick) isPathVisible ifTrue:			[marks := vs applyToValues: vs majorMarks.		fixup := hs incrementalScaled ifTrue: [1] ifFalse: [-1].		line := line geometric.		line := (LineSegment from: line start transpose * fixup						to: line end transpose * fixup) asStroker.		1 to: marks size do: [:i | line displayOn: aGraphicsContext at: px @ (marks at: i) rounded]].	"Display minor tick marks"				((line := v minorTick) isPathVisible and: [vs div ~= 1]) ifTrue: 		[marks := vs applyToValues: vs minorMarks.		fixup := hs incrementalScaled ifTrue: [1] ifFalse: [-1].		line := line geometric.		line := (LineSegment from: line start transpose * fixup						to: line end transpose * fixup) asStroker.		1 to: marks size do: [:i | line displayOn: aGraphicsContext at: px @ (marks at: i) rounded]]</body><body package="BGOK">displayVLabelsOn: aGraphicsContext 	| gc v hs vs marks px images sizeOfLabels |	vs := (v := self v) scale.	hs := self h scale.	"Display axis labels"	marks := vs applyToValues: v labelsMarks.	px := ((hs includesZero and: [v isAutoLabeled])				ifTrue: [hs applyTo: hs zero]				ifFalse: [hs incrementalScaled						ifTrue: [hs destMin]						ifFalse: [hs destMax]]) rounded.	gc := aGraphicsContext copy.	images := v labelsStyle individualImages.	sizeOfLabels := marks size min: images size.	1 to: sizeOfLabels		do: 			[:i | 			| image |			image := images at: i.			image displayOn: gc at: (hs incrementalScaled					ifTrue: [px - 5 - image width]					ifFalse: [px + 5])					@ ((marks at: i) rounded - (image height // 2))].	(v unit notNil and: [sizeOfLabels &gt; 0])		ifTrue: ["Display axis unit"			v unitStyle displayOn: aGraphicsContext at: (hs incrementalScaled					ifTrue: [px - 5 - v unitStyle extent x]					ifFalse: [px + 5])					@ ((marks at: sizeOfLabels) rounded + (vs incrementalScaled								ifTrue: [(images at: sizeOfLabels) bounds extent y // 2 + 5]								ifFalse: [0 - ((images at: sizeOfLabels) bounds extent y // 2 + 5 + v unitStyle extent y)]))]. 	v title notNil		ifTrue: 			["Display axis title" 			| lw |			v titleStyle rotation ~= 3 ifTrue: [v titleStyle rotation: 3].			v titleStyle scale ~= (1 @ 1) ifTrue: [v titleStyle scale: 1 @ 1].			lw := v labelsStyle individualExtent x.			v titleStyle displayOn: aGraphicsContext at: (hs incrementalScaled					ifTrue: [px - (lw + 5 + v titleStyle extent x)]					ifFalse: [px + (lw + 5)])					@ (self insetBounds center y - (v titleStyle extent y // 2))]</body><body package="BGOK">displayVLinesOn: aGraphicsContext 	| h hs vs block marks line startY endY |	vs := self v scale.	hs := (h := self h) scale.	startY := vs destMin rounded.	endY := vs destMax rounded.	line := h sectionLine.	block := 			[:px :gc | 			gc displayLineFrom: px @ startY to: px @ endY].	"Display section lines"	line isPathVisible ifTrue:		[marks := hs applyToValues: h sectionMarks.		1 to: marks size do: [:i | block value: (marks at: i) rounded value: aGraphicsContext]].	"Display border lines"	(line := h borderLine) isPathVisible ifTrue:		[marks := hs applyToValues: hs edgeMarks.		block value: marks first rounded value: aGraphicsContext.		block value: marks last rounded value: aGraphicsContext]</body></methods><methods><class-id>UI.BG_ChartGrid</class-id> <category>animation</category><body package="BGOK">follow: locationBlock while: durationBlock on: aGraphicsContext</body><body package="BGOK">moveTo: newLoc on: aGraphicsContext restoring: backGC</body></methods><methods><class-id>UI.BG_ChartGrid</class-id> <category>utility</category><body package="BGOK">box: box by: angle origin: originPoint alignment: alignment	| rorigin ang as ai ad d delta idx dpi qpi |	ang := angle degreesToRadians. 	rorigin := originPoint isZero 			ifTrue: [originPoint] 			ifFalse: [(self rotatePoint: originPoint by: ang origin: 0@0) rounded].	alignment = 5 ifTrue: [^box align: box center with: rorigin].	"center"	as := #(topLeft topCenter topRight leftCenter center rightCenter bottomLeft bottomCenter bottomRight).	ad := #(0 0 0.5 0.5 0 0 -0.5 -0.5).	ai := #(1 2 3 6 9 8 7 4).	dpi := 2 * Float pi.	qpi := 1 /4 * Float pi.	idx := (ai indexOf: alignment) + (ang \\ dpi // qpi) - 1 \\ 8 + 1.	delta := 0@0.	d := ang \\ dpi \\ qpi / qpi.	d = 0 ifFalse: [delta := ((ad at: idx + 1 \\ 8 +1)@(ad at: idx) * box extent * d) rounded].	^box align: (box perform: (as at: (ai at: idx))) + delta with: rorigin</body><body package="BGOK">displayLabel: aVisualComponent angle: angle offset: offset alignment: alignment on: aGraphicsContext at: aPoint	aVisualComponent		displayOn: aGraphicsContext		at: aPoint + (self					box: aVisualComponent bounds					by: angle					origin: offset					alignment: alignment) origin</body><body package="BGOK">rotatePoint: aPoint by: angle origin: originPoint	| p px py |	angle \\ (2 * Float pi) = 0 ifTrue: [^aPoint].	p := aPoint- originPoint.	px := (angle cos * p x) - (angle sin * p y).	py := (angle cos * p y) + (angle sin * p x).	^(px@py) + originPoint</body></methods><methods><class-id>UI.BG_ChartGrid</class-id> <category>applying transform</category><body package="BGOK">applyInverseTo: aPoint	| p |		p := transposed ifTrue: [aPoint transpose] ifFalse: [aPoint].	p := (x scale applyInverseTo: p x)@(y scale applyInverseTo: p y).	^p</body><body package="BGOK">applyInverseToValues: collectionOfPoint	^collectionOfPoint collect: [:each | self applyInverseTo: each]</body><body package="BGOK">applyTo: aPoint	| p |	p := (x scale applyTo: aPoint x)@(y scale applyTo: aPoint y).	transposed ifTrue: [p := p transpose].	^p</body><body package="BGOK">applyToValues: collectionOfPoint 	^collectionOfPoint collect: [:each | self applyTo: each]</body></methods><methods><class-id>UI.BG_ChartGrid</class-id> <category>private</category><body package="BGOK">horizontalMargin	"Answer the maximum of title plus labels or unit and labels."	| h v vte ext labExt |	v := self v.	h := self h.	vte := v titleStyle extent.	labExt := v labelsMarkAt == #noMarks				ifTrue: [0]				ifFalse: [v labelsStyle individualExtent x].	ext := v labelsMarkAt == #noMarks				ifTrue: [0]				ifFalse: [v unitStyle extent x].	ext := ext max: (v titleStyle rotation = 0					ifTrue: [vte y]					ifFalse: [vte x]).	^5 + (ext + labExt max: (h labelsStyle individualExtent x // 2))</body><body package="BGOK">minimumExtent	| h v vte hte |	h := self h.	v := self v.	vte := v titleStyle extent.	hte := h titleStyle extent.	^(((v titleStyle rotation = 0		ifTrue: [vte y]		ifFalse: [vte x])		+ v labelsStyle individualExtent x + 10 * 2 max: (h titleStyle rotation = 0			ifTrue: [hte x]			ifFalse: [hte y]))		max: (h labelsStyle individualExtent x max: h unitStyle extent x))		@ (((h titleStyle rotation = 0				ifTrue: [hte y]				ifFalse: [hte x])				+ h labelsStyle individualExtent y + 10 * 2 max: (v titleStyle rotation = 0					ifTrue: [vte x]					ifFalse: [vte y])) max: (v labelsStyle individualExtent y max: v unitStyle extent y))</body><body package="BGOK">verticalMargin	"Answer amximum of unit y and labels y plus title."	| h v hte |	h := self h.	v := self v.	hte := h titleStyle extent.	^(h titleStyle rotation = 0		ifTrue: [hte y]		ifFalse: [hte x])		+ h labelsStyle individualExtent y + 10 max: (v labelsStyle individualExtent y max: v unitStyle extent y)</body></methods><methods><class-id>UI.BG_ChartGrid</class-id> <category>testing</category><body package="BGOK">transposed	"Answer true if the receiver is transposed"	^transposed</body></methods><methods><class-id>UI.BG_ChartGrid</class-id> <category>initialize-release</category><body package="BGOK">initialize	x := BG_ChartAxis new.	y := BG_ChartAxis new.	transposed := false.</body><body package="BGOK">newGraphicsDevice: aGraphicsDevice	x newGraphicsDevice: aGraphicsDevice.	y newGraphicsDevice: aGraphicsDevice.</body></methods><methods><class-id>UI.BG_ChartGrid</class-id> <category>bounds clipping</category><body package="BGOK">gcCopyClipped: aGraphicsContext 	"Copy the GraphicsContext, limiting the display area to the area inside the grid axes.  Use this limited GraphicsContext when displaying data."	^aGraphicsContext copy intersectClip: (Rectangle 				left: self h scale destMin rounded				right: self h scale destMax rounded				top: self v scale destMin rounded				bottom: self v scale destMax rounded)</body></methods><methods><class-id>UI.BG_Label</class-id> <category>visual properties</category><body package="BGOK">foregroundColor	^foregroundColor</body><body package="BGOK">foregroundColor: aColor	foregroundColor := aColor</body><body package="BGOK">lookPreferences	| lp |	lp := LookPreferences defaultForWindows.	lp := lp foregroundColor: foregroundColor.	^lp</body><body package="BGOK">lookPreferences: aLookPreferences	self foregroundColor: aLookPreferences foregroundColor</body><body package="BGOK">setColorOn: aGraphicsContext 	"Set the receiver's color on aGraphicsContext"	(foregroundColor ~~ nil and: [foregroundColor ~~ aGraphicsContext paint])		ifFalse: [^self].	[aGraphicsContext paint: foregroundColor]		on: Error do: [:ex | ex return]</body></methods><methods><class-id>UI.BG_Label</class-id> <category>bounds accessing</category><body package="BGOK">bottom	^self top + self height</body><body package="BGOK">bounds: newBounds	self extent: newBounds extent</body><body package="BGOK">extent	^extent isNil ifTrue: [self image bounds extent] ifFalse: [extent]</body><body package="BGOK">extent: aPoint	"Set the receiver's extent to be aPoint."	extent := aPoint</body><body package="BGOK">height 	^self extent y</body><body package="BGOK">height: aHeight	"Set the height of the receiver's bounding box to be aHeight."	self extent: self width@aHeight</body><body package="BGOK">left	^0</body><body package="BGOK">preferredBounds	"Answer the receiver's actual bounding rectangle."	^Rectangle origin: 0@0 extent: self extent</body><body package="BGOK">right	^self left + self width</body><body package="BGOK">top	^0</body><body package="BGOK">topLeft	^0@0</body><body package="BGOK">width	^self extent x</body><body package="BGOK">width: aWidth	"Set the width of the receiver's bounding box to be aWidth."	self extent: aWidth@self height</body></methods><methods><class-id>UI.BG_Label</class-id> <category>private</category><body package="BGOK">alignOffset: alignedObject	| al x y ax ay |	x := y := 0.	al := self alignmentForDisplay.	(ax := al \\ 3) = 1 ifFalse: 		[ | width ext |		ext := self extent.		width := alignedObject bounds width.		ax = 2 			ifTrue: [x := ext x - width // 2]			ifFalse: [x := ext x - width]].	(ay := al - 1 // 3) = 0 ifFalse: 		[ | height ext |		ext := self extent.		height := alignedObject bounds height.			ay = 1 			ifTrue: [y := ext y - height // 2]			ifFalse: [y := ext y - height]].	^x@y</body><body package="BGOK">alignmentForDisplay 	"Answer Integer that represents alignment for displaying"		| al |	^(al := self alignment) = 0 		ifTrue: [(item isKindOf: Number) ifTrue: [3] ifFalse: [1]]		ifFalse: [al]</body><body package="BGOK">alignmentForTextStyle	"Answer Integer that represents alignment for TextStyle"	^#[1 0 2] at: self alignmentForDisplay \\ 3 + 1</body><body package="BGOK">compose	"Cache the form for displaying the object."	| str |	item isNil ifTrue: [^image := '' asComposedText].	(item isKindOf: VisualComponent) ifTrue: [^image := item].	textStyle alignment: self alignmentForTextStyle.	str := self composeString.	(str includes: Character cr)		ifTrue: [image := ComposedText						withText: (Text string: str									emphasis: emphasis)						style: textStyle]		ifFalse: [image := BG_TextLabel						with: (Text string: str									emphasis: emphasis)						attributes: textStyle]</body><body package="BGOK">composeString	| string |	item isString		ifTrue: [string := item]		ifFalse: [(item isKindOf: Number)				ifTrue: [string := self stringFromNumber: item]				ifFalse: [(item isMemberOf: Point)						ifTrue: [string := self stringFromPoint: item]						ifFalse: [(item isKindOf: Text)								ifTrue: [string := self stringFromText: item]								ifFalse: [([string := item printString]										on: Error do: [:ex | ex returnWith: #bad])										== #bad ifTrue: [string := 'a ' , item class printString]]]]].	^(decoration isNil or: [decoration isEmpty or: [string isEmpty]])		ifTrue: [string]		ifFalse: [decoration copyReplaceAll: '#' with: string]</body><body package="BGOK">formatConstraintCheck: aSymbol	"Check format type constraint. see class initialize FormatConstraint"	| v o |	o := self format.	v := FormatConstraint at: aSymbol ifAbsent: [^o].	^(o bitAnd: (v at: 2)) bitOr: (v at: 1)</body><body package="BGOK">formatTypes: aSet	"Set format types to be aSet"	aSet do: [:c | self formatType: c]</body><body package="BGOK">stringFromNumber: aNumber	| n type s base |	(type := format bitAnd: 2r111111100) = 0 ifTrue: [^aNumber printString].	n := aNumber.	(type anyMask: 2r001000000) ifTrue: [n := n *100].	(type anyMask: 2r000000100) ifTrue: [n := n asFloat] ifFalse: [(type anyMask: 2r110001000) ifTrue: [n := n rounded asInteger]].	(n = 0 and: [type anyMask: 2r000010000]) ifTrue: [^''].	(type anyMask: 2r100000000) ifTrue: 		[n &gt; 100 ifTrue: 				[base := 10 raisedTo: (n log: 10) truncated - 1.				 n := (n / base) rounded].		^n &gt; 0 ifTrue: [String new: n withAll:$*] ifFalse: ['']].	(type anyMask: 2r010000000) 			ifTrue: [s := self withComma: n] 			ifFalse: [(type anyMask: 2r000001000)  						ifTrue: [s := n printString]						ifFalse: [(type anyMask: 2r000000100)									ifTrue: [s := self withFloat: n]									ifFalse: [s := n printString]]].	((type anyMask: 2r000100000) and: [n &gt; 0]) ifTrue: [s := '+', s].	(type anyMask: 2r001000000) ifTrue: [s := s , '%']. 	^s</body><body package="BGOK">stringFromPoint: aPoint	(aPoint isZero and: [format anyMask: 2r000010000]) ifTrue: [^''].	"zero" 	^(self stringFromNumber: aPoint x) , '@' , (self stringFromNumber: aPoint y)</body><body package="BGOK">stringFromText: aText 	^aText string</body><body package="BGOK">withComma: anInteger	"Answer a string representing anInteger "	| s size n r |	s := anInteger abs printString.	(size := s size) &lt;= 3 ifTrue: [^anInteger printString].	n := size - ((size // 3) * 3).	r := (n =0) ifTrue: [''] ifFalse: [s copyFrom: 1 to: n].	n + 1 to: size by: 3 do:		[:i | (i=1) ifFalse: [r := r , ','].		r := r , (s copyFrom: i to: i+2)].	anInteger negative ifTrue: [r := '-' , r].	^r</body><body package="BGOK">withFloat: aFloat	"Answer the string represented aFloat as fixed-decimal point"	| f s n length |	length := self decimalPartLength.	f := aFloat asFloat.	length = 0		ifTrue: [^f printString]		ifFalse: [s := (f roundTo: 1 / (10 raisedTo: length) asFloat) printString.				s ='0' ifTrue: [s := '0.0'].				^s , ((n := s size - (s indexOf: $.)) &lt;  length						ifTrue: [String new: length - n  withAll: $0] 						ifFalse: [''])]</body></methods><methods><class-id>UI.BG_Label</class-id> <category>format/decoration</category><body package="BGOK">alignment	^format bitShift: -9</body><body package="BGOK">alignment: anInteger	"Set the current setting of the alignment to be anInteger--	0: default (if item is kind of number, then alignment is same to 3 , otherwise is 1).	1: top left (left flush)	2: top center (centered)	3: top right (right flush)	4: left center	5: center	6: right center	7: bottom left	8: bottom center	9: bottom right"	format := (format bitAnd: 2r111111111) bitOr: (anInteger bitShift: 9).	self flushCaches</body><body package="BGOK">asterisk	"Add asterisk type to current display formats."	self formatType: #asterisk</body><body package="BGOK">comma	"Add comma type to current display formats"	self formatType: #comma</body><body package="BGOK">decimalPartLength	"Answer decimal-part length"		^self format bitAnd: 2r11</body><body package="BGOK">decimalPartLength: anInteger	"Make argument, anInteger, decimal-part length"		| order |	order := anInteger \\ 3.	format := (self format bitAnd: 2r111111100) bitOr: order.	self flushCaches</body><body package="BGOK">decoration	^decoration</body><body package="BGOK">decoration: aString	"Make the argument, aString, the receiver's decoration"	decoration := aString.	self flushCaches</body><body package="BGOK">float	"Add float type to current display formats"	self formatType: #float</body><body package="BGOK">format	"Answer the receiver's format"	^format</body><body package="BGOK">formatType: typeChar 	"Add typeChar to the receiver format after checking type constarain"	format := self formatConstraintCheck: typeChar.	self flushCaches</body><body package="BGOK">formatTypes	"Answer current format types set"			| f s n |	f := (format bitAnd: 2r111111100) bitShift: -2.	f = 0 ifTrue: [^Set with: #general].	s := Set new.	n :=1.	#(float integer zerosuppress sign percent comma asterisk) 		do: [:c | (f anyMask: n) ifTrue: [s add: c]. n := n bitShift: 1].	^s</body><body package="BGOK">general	"Add general type to current display formats."	self formatType: #general</body><body package="BGOK">integer	"Add integer type to curren display formats"	self formatType: #integer</body><body package="BGOK">percent	"Add percent type to current display formats"	self formatType: #percent</body><body package="BGOK">sign	"Add sign type to current display formats"	self formatType: #sign</body><body package="BGOK">zerosuppress	"Add zero suppress type to current display formats"	self formatType: #zerosuppress</body></methods><methods><class-id>UI.BG_Label</class-id> <category>copying</category><body package="BGOK">postCopy	textStyle := textStyle copy</body></methods><methods><class-id>UI.BG_Label</class-id> <category>displaying</category><body package="BGOK">displayOn: aGraphicsContext	"Display the receiver on aGraphicsContext"	self displayOn: aGraphicsContext at: Point zero</body><body package="BGOK">displayOn: aGraphicsContext at: aPoint	"Display the receiver on aGraphicsContext translated by aPoint."	| gc |	item isNil ifTrue: [^self].	gc := aGraphicsContext copy.	self setColorOn: gc.	extent ~~ nil 		ifTrue: 			[gc intersectClip: (Rectangle origin: aPoint extent: extent).			self image displayOn: gc	at: aPoint + (self alignOffset: image)]		ifFalse:			[self image displayOn: gc	at: aPoint]</body></methods><methods><class-id>UI.BG_Label</class-id> <category>text style/emphasis</category><body package="BGOK">emphasis	^emphasis</body><body package="BGOK">emphasis: code	"Set the emphasis. code is same as emphasis of Text"	emphasis := code.	self flushCaches</body><body package="BGOK">indent: anInteger 	"Set the all indent of style"	textStyle firstIndent: anInteger; restIndent: anInteger; rightIndent: anInteger.	self flushCaches</body><body package="BGOK">textStyle 	^textStyle</body><body package="BGOK">textStyle: aTextAttributes 	"Set the style by which the receiver should display its item."	textStyle := aTextAttributes.	self flushCaches</body></methods><methods><class-id>UI.BG_Label</class-id> <category>initialize-release</category><body package="BGOK">flushCaches	"Forget the receiver's image."	image := nil</body><body package="BGOK">initialize	super initialize. 	textStyle := TextAttributes default.	format := 0</body><body package="BGOK">newGraphicsDevice: aGraphicsDevice 	self image newGraphicsDevice: aGraphicsDevice.</body></methods><methods><class-id>UI.BG_Label</class-id> <category>accessing</category><body package="BGOK">image	"Answer the visual component containing the composed item."	image isNil ifTrue: [self compose].	^image</body><body package="BGOK">item	^item</body><body package="BGOK">item: anObject	"Make the argument, anObject, the receiver's item"	item := anObject.	self flushCaches</body></methods><methods><class-id>UI.BG_Label class</class-id> <category>class initialization</category><body package="BGOK">initialize	"BG_Label initialize"	FormatConstraint := Dictionary new: 8.	FormatConstraint at: #general put: (Array with: 2r000000000 with: 2r1111000000011). "all"	FormatConstraint at: #asterisk put: (Array with: 2r100000000 with: 2r1111100011011). "#(comma float percent sign)"	FormatConstraint at: #comma put: (Array with: 2r010000000 with: 2r1111011111011). "#(asterisk float)"			FormatConstraint at: #percent put: (Array with: 2r001000000 with: 2r1111011111111). "#(asterisk)"				FormatConstraint at: #sign put: (Array with: 2r000100000 with: 2r1111011111111). "#(asterisk)"					FormatConstraint at: #zerosuppress put: (Array with: 2r000010000 with: 2r1111111111111). "#()"					FormatConstraint at: #integer put: (Array with: 2r000001000 with: 2r1111111111011). "#(float)"					FormatConstraint at: #float put: (Array with: 2r000000100 with: 2r1111001110111). "#(asterisk comma integer)"</body></methods><methods><class-id>UI.BG_Label class</class-id> <category>instance creation</category><body package="BGOK">item: anObject	"Answer an instance of the receiver with displaying item"	^self new item: anObject</body></methods><methods><class-id>UI.BG_IconicLabel</class-id> <category>accessing</category><body package="BGOK">icon	^icon</body><body package="BGOK">icon: aVisualComponent	icon := aVisualComponent</body></methods><methods><class-id>UI.BG_IconicLabel</class-id> <category>mode/gap</category><body package="BGOK">gap	^gap</body><body package="BGOK">gap: anInteger	gap := anInteger</body><body package="BGOK">mode	^mode</body><body package="BGOK">mode: anInteger	mode := anInteger</body></methods><methods><class-id>UI.BG_IconicLabel</class-id> <category>bounds accessing</category><body package="BGOK">extent	extent isNil ifFalse: [^extent].	icon isNil ifTrue: [^super extent].	^self extentOfIconicLabel</body></methods><methods><class-id>UI.BG_IconicLabel</class-id> <category>initialize-release</category><body package="BGOK">initialize	super initialize.	mode := 0.	gap := 0.</body><body package="BGOK">newGraphicsDevice: aGraphicsDevice	super newGraphicsDevice: aGraphicsDevice.	icon ifNotNil:[icon newGraphicsDevice: aGraphicsDevice].</body></methods><methods><class-id>UI.BG_IconicLabel</class-id> <category>private</category><body package="BGOK">alignIconOffset	| al ext x y ax ay iconicLabelExt |	x := y := 0.	al := self alignmentForDisplay.	ext := self extent.	iconicLabelExt := self extentOfIconicLabel.	mode &gt;= 4		ifTrue: 			[| height |			height := mode = 5						ifTrue: [iconicLabelExt y - icon bounds height]						ifFalse: [0].			(ax := al - 1 \\ 3) = 0 ifFalse: [ax = 1					ifTrue: [x := ext x - icon bounds width // 2]					ifFalse: [x := ext x - icon bounds width]].			(ay := al - 1 // 3) = 0 ifFalse: [ay = 1					ifTrue: [y := ext y - iconicLabelExt y // 2]					ifFalse: [y := ext y - iconicLabelExt y]].			y := y + height]		ifFalse: 			[| width |			width := mode = 1						ifTrue: [iconicLabelExt x - icon bounds width]						ifFalse: [0].			(ax := al - 1 \\ 3) = 0 ifFalse: [ax = 1					ifTrue: [x := ext x - iconicLabelExt x // 2]					ifFalse: [x := ext x - iconicLabelExt x]].			x := x + width.			(ay := al - 1 // 3) = 0 ifFalse: [ay = 1					ifTrue: [y := ext y - icon bounds height // 2]					ifFalse: [y := ext y - icon bounds height]]].	^x @ y</body><body package="BGOK">alignOffset: alignedObject 	| al ext x y ax ay iconicLabelExt |	icon isNil ifTrue: [^super alignOffset: alignedObject].	x := y := 0.	al := self alignmentForDisplay.	ext := self extent.	iconicLabelExt := self extentOfIconicLabel.	mode &gt;= 4		ifTrue: 			[| height |			height := mode = 4						ifTrue: [iconicLabelExt y - alignedObject bounds height]						ifFalse: [0].			(ax := al - 1 \\ 3) = 0 ifFalse: [ax = 1					ifTrue: [x := ext x - alignedObject bounds width // 2]					ifFalse: [x := ext x - alignedObject bounds width]].			(ay := al - 1 // 3) = 0 ifFalse: [ay = 1					ifTrue: [y := ext y - iconicLabelExt y // 2]					ifFalse: [y := ext y - iconicLabelExt y]].			y := y + height]		ifFalse: 			[| width |			width := mode = 0						ifTrue: [iconicLabelExt x - alignedObject bounds width]						ifFalse: [0].			(ax := al - 1 \\ 3) = 0 ifFalse: [ax = 1					ifTrue: [x := ext x - iconicLabelExt x // 2]					ifFalse: [x := ext x - iconicLabelExt x]].			x := x + width.			(ay := al - 1 // 3) = 0 ifFalse: [ay = 1					ifTrue: [y := ext y - alignedObject bounds height // 2]					ifFalse: [y := ext y - alignedObject bounds height]]].	^x @ y</body><body package="BGOK">extentOfIconicLabel	mode &lt;= 1 ifTrue: [^self image bounds width + icon bounds width + gap @ (image bounds height max: icon bounds height)].	mode = 2 ifTrue: [^icon bounds extent].	mode = 3 ifTrue: [^self image bounds extent].	^(self image bounds width max: icon bounds width)		@ (image bounds height + icon bounds height + gap)</body></methods><methods><class-id>UI.BG_IconicLabel</class-id> <category>displaying</category><body package="BGOK">displayOn: aGraphicsContext at: aPoint 	"Display the receiver on aGraphicsContext translated by aPoint."	| gc |	icon == nil ifTrue: [^super displayOn: aGraphicsContext at: aPoint].	gc := aGraphicsContext copy.	self setColorOn: gc.	extent ~~ nil ifTrue: [gc intersectClip: (self bounds translatedBy: aPoint)].	mode even		ifTrue: 			[icon displayOn: gc at: aPoint + self alignIconOffset.			mode ~= 2 &amp; item notNil ifTrue: [self image displayOn: gc at: aPoint + (self alignOffset: image)]]		ifFalse: 			[item notNil ifTrue: [self image displayOn: gc at: aPoint + (self alignOffset: image)].			mode ~= 3 ifTrue: [icon displayOn: gc at: aPoint + self alignIconOffset]]</body></methods><methods><class-id>UI.BG_IconicLabel class</class-id> <category>instance creation</category><body package="BGOK">icon: anIcon item: anObject	| label |	label := super item: anObject.	label icon: anIcon.	^label</body><body package="BGOK">item: anObject	| label |	label := super item: anObject.	label mode: 3.	^label</body><body package="BGOK">item: anObject icon: anIcon	| label |	label := self icon: anIcon item: anObject.	label mode: 1.	^label</body></methods><methods><class-id>UI.ChartingAxisSpec</class-id> <category>accessing</category><body package="BGOK">axisLine	^axisLine ~= false</body><body package="BGOK">axisLine: aValue	axisLine := aValue</body><body package="BGOK">borderLine	^borderLine ~= false</body><body package="BGOK">borderLine: aValue	borderLine := aValue</body><body package="BGOK">scale	^scale</body><body package="BGOK">scale: aValue	scale := aValue</body><body package="BGOK">sectionLine	^sectionLine ~= false</body><body package="BGOK">sectionLine: aValue	sectionLine := aValue</body><body package="BGOK">sectionMarkAt	^sectionMarkAt isNil ifTrue: [#majorMarks] ifFalse: [sectionMarkAt]</body><body package="BGOK">sectionMarkAt: aValue	sectionMarkAt := aValue</body><body package="BGOK">tickPosition		^tickPosition isNil ifTrue: [#hideTick] ifFalse: [tickPosition]</body><body package="BGOK">tickPosition: aValue	tickPosition := aValue</body><body package="BGOK">title	^title</body><body package="BGOK">title: aValue	title := aValue</body><body package="BGOK">unit	^unit</body><body package="BGOK">unit: aValue	unit := aValue</body></methods><methods><class-id>UI.ChartingAxisSpec</class-id> <category>copying</category><body package="BGOK">postCopy	scale := scale copy</body></methods><methods><class-id>UI.ChartingAxisSpec</class-id> <category>private</category><body package="BGOK">fromLiteralArrayEncoding: anArray	super fromLiteralArrayEncoding: anArray.	"Scale is a literal array. At this point and I have to decode it."	scale := scale decodeAsLiteralArray.</body><body package="BGOK">simplified	"First simplify the scale spec and then use default criterion."	scale notNil ifTrue: [scale := scale simplified].	^super simplified.</body></methods><methods><class-id>UI.ChartingAxisSpec</class-id> <category>private-interface building</category><body package="BGOK">insertIntoAxis: anAxis with: aBuilder	"Set the parameters of an existing axis to reflect 	those set in an axis spec"	| marks |	self insertScalePart: anAxis with: aBuilder.	title notNil ifTrue: [anAxis title: (self labelUsing: aBuilder)].	unit notNil		ifTrue: [anAxis unit: (self getStringFrom: unit with: aBuilder)].	tickPosition notNil ifTrue: [anAxis perform: tickPosition].	borderLine notNil		ifTrue: 			[self borderLine				ifTrue: [anAxis showBorderLine]				ifFalse: [anAxis hideBorderLine]].	axisLine notNil		ifTrue: 			[self axisLine ifTrue: [anAxis showAxisLine] ifFalse: [anAxis hideAxisLine]].	(marks := sectionMarkAt) notNil		ifTrue: 			[marks == #none				ifTrue: [anAxis hideSectionLine]				ifFalse: 					[anAxis showSectionLine.					anAxis sectionMarkAt: sectionMarkAt]]</body><body package="BGOK">insertScalePart: anAxis with: aBuilder 	"This method deals with the differences in spec and view implementations. 	Some parameters from scale spec on the implementation side are stored 	in an axis"	scale notNil		ifTrue: 			[scale autoScaleSet ifTrue: [scale autoScale					ifTrue: [anAxis autoScale]					ifFalse: [anAxis manualScale]].			anAxis scale scaleType == scale scaleType ifFalse: 				["it is time to create new scale, I can use default since 				the spec will set all aspects"				anAxis newScaleOfType: scale scaleType].			scale insertIntoScale: anAxis scale]</body><body package="BGOK">labelUsing: aBuilder	title asString isEmpty		ifTrue: 			[title := nil.			^nil].	aBuilder isEditing ifTrue: [^title asString].	^title isSymbol		ifTrue: 			[(aBuilder labelAt: title)				ifNotNil: 					[:value |					value takesMessageCatalog ifTrue: [value asString] ifFalse: [value]]]		ifFalse: [title asString]</body></methods><methods><class-id>UI.ChartingAxisSpec</class-id> <category>accessing-properties</category><body package="BGOK">labelFromApplication	^self propertyAt: #labelFromApplication answerIfAbsent: false</body><body package="BGOK">labelFromApplication: aBooleanOrNil	aBooleanOrNil == nil		ifTrue: [self removePropertyAt: #labelFromApplication]		ifFalse: [self propertyAt: #labelFromApplication put: aBooleanOrNil]</body></methods><methods><class-id>UI.ChartingAxisSpec</class-id> <category>private-labels</category><body package="BGOK">getLabel	^title</body><body package="BGOK">setLabel: aLabel	title := aLabel</body></methods><methods><class-id>UI.ChartingAxisSpec class</class-id> <category>private-interface building</category><body package="BGOK">addBindingsTo: env for: inst channel: aChannel	| lblMode hasImage lblCnvrtr lblAdptr  |		super addBindingsTo: env for: inst channel: aChannel.	lblAdptr := (self adapt: inst forAspect: #label channel: aChannel).	env at: #label put: (lblCnvrtr :=		(inst hasImageOrientedLabel			ifTrue: [TypeConverter onSymbolValue: lblAdptr]			ifFalse: [TypeConverter onStringOrSymbolValue: lblAdptr])).	env at: #unit put: (self adapt: inst forAspect: #unit channel: aChannel).	env at: #axisLine put: (self adapt: inst forAspect: #axisLine channel: aChannel).	env at: #sectionLine put: (self adapt: inst forAspect: #sectionLine channel: aChannel).	env at: #borderLine put: (self adapt: inst forAspect: #borderLine channel: aChannel).	env at: #sectionMarks put: (self adapt: inst forAspect: #sectionMarkAt channel: aChannel).	env at: #tickPosition put: (self adapt: inst forAspect: #tickPosition channel: aChannel).	env at: #tickPositionMenu put: self tickPositionMenuSpec asValue.	env at: #sectionMarksMenu put: self labelPositionMenuSpec asValue.		env at: #labelFromApplication put: (self adapt: inst forAspect: #labelFromApplication channel: aChannel).	env at: #labelIsMessage put: (lblMode := inst label isSymbol asValue).	inst label isSymbol ifTrue: [(env at: #labelFromApplication) value: true].	env at: #hasImageOrientedLabel put: 		(hasImage := self adapt: inst forAspect: #hasImageOrientedLabel channel: aChannel).	hasImage		compute: 			[:v | 			v				ifTrue: [lblCnvrtr symbolToText]				ifFalse: [lblCnvrtr stringOrSymbolToText].			v				ifTrue: [lblMode value: true]				ifFalse: [lblMode value: inst label isSymbol].			(env at: #propertiesTool) update: #updateLabelIsImage with: nil from: nil.			(lblAdptr value notNil and: [lblAdptr value asString isEmpty not]) ifTrue: 				[lblAdptr changed: #value]]</body></methods><methods><class-id>UI.ChartingValueAxisSpec</class-id> <category>accessing</category><body package="BGOK">labelFormat	^labelFormat isNil ifTrue: [#general] ifFalse: [labelFormat]</body><body package="BGOK">labelFormat: aValue	labelFormat := aValue</body><body package="BGOK">labelsMarkAt	labelsMarkAt isNil ifTrue: [^#majorMarks].	^labelsMarkAt</body><body package="BGOK">labelsMarkAt: aValue	labelsMarkAt := aValue</body><body package="BGOK">tickPosition	^tickPosition isNil ifTrue: [#tickInside] ifFalse: [tickPosition]</body></methods><methods><class-id>UI.ChartingValueAxisSpec</class-id> <category>private-interface building</category><body package="BGOK">insertIntoAxis: anAxis with: aBuilder 	"Set the parameters of an existing axis to reflect 	those set in an axis spec"	| marks |	super insertIntoAxis: anAxis with: aBuilder.	labelFormat notNil ifTrue: [anAxis setLabelFormat: labelFormat].	(marks := labelsMarkAt) notNil ifTrue: [marks == #none			ifTrue: [anAxis labelsMarkAt: #noMarks]			ifFalse: [anAxis labelsMarkAt: labelsMarkAt]]</body></methods><methods><class-id>UI.ChartingValueAxisSpec class</class-id> <category>private-interface building</category><body package="BGOK">addBindingsTo: env for: inst channel: aChannel	super addBindingsTo: env for: inst channel: aChannel.	env at: #labelPosition put: (self adapt: inst forAspect: #labelsMarkAt channel: aChannel).	env at: #labelPositionMenu put: self labelPositionMenuSpec asValue.	env at: #labelFormat put: (self adapt: inst forAspect: #labelFormat channel: aChannel).	env at: #labelFormatMenu put: self labelFormatMenuSpec asValue.</body></methods><methods><class-id>Examples.BG_Company</class-id> <category>employees</category><body package="BGOK">employees	^employees</body></methods><methods><class-id>Examples.BG_Company</class-id> <category>initialize</category><body package="BGOK">initialize	"Create a list of employees, and convert it into a ValueHolder."	super initialize.	employees := List new.	self initializeData.	employees := employees asValue.</body></methods><methods><class-id>Examples.BG_Company</class-id> <category>initializeData</category><body package="BGOK">initializeData	"Initalize the employees collection."	|employee|	employee := BG_Employee new.	employee name: 'Fred'; age: 50; salary: 40.	employees  add: employee.	employee := BG_Employee new.	employee name: 'Joe'; age: 25; salary: 32.	employees add: employee.	employee := BG_Employee new.	employee name: 'Bob'; age: 36; salary: 33.	employees  add: employee.</body></methods><methods><class-id>UI.ChartDataSpec</class-id> <category>accessing</category><body package="BGOK">columns	"Answers the number of data series."	^series size</body><body package="BGOK">labelIndex	"Answer an index of series containing label or 0."	series size &lt; 1		ifTrue: [^0]		ifFalse: 			[series keysAndValuesDo: [:i :s | s isData ifFalse: [^i]].			^0]</body><body package="BGOK">labelSeries	"Answer a collection contianing indexes of 	series containing labels."	| set |	set := Set new.	series size &gt; 0 ifTrue: [series keysAndValuesDo: [:k :s | s isData ifFalse: [set add: k]]].	^set</body><body package="BGOK">nbrOfDataSeries	"Answer a number of series containing data"	^series size &lt; 1		ifTrue: [0]		ifFalse: 			[| i |			i := 0.			series do: [:s | s isData ifTrue: [i := i + 1]].			i]</body><body package="BGOK">series	^series</body><body package="BGOK">series: aValue	series := aValue</body><body package="BGOK">seriesAt: index 	(series isNil or: [index isZero])		ifTrue: [^ChartDataSetSpec new].	series size &lt; index ifTrue: [^ChartDataSetSpec new].	^series at: index</body><body package="BGOK">seriesList	^self series isNil		ifTrue: [^List new]		ifFalse: [self series]</body></methods><methods><class-id>UI.ChartDataSpec</class-id> <category>copying</category><body package="BGOK">postCopy	"I need a deep copy of the collection."	series notNil ifTrue: [series := series collect: [:el | el copy]]</body></methods><methods><class-id>UI.ChartDataSpec</class-id> <category>private-interface building</category><body package="BGOK">dataSeriesMenu	| mb |	mb := MenuBuilder new.	series isNil		ifTrue: [mb add: (#Empty &lt;&lt; #BGOK &gt;&gt; 'Empty') -&gt; 1]		ifFalse: [1 to: series size				do: 					[:i | 					| nm s |					s := series at: i.					nm := s name.					nm isNil ifTrue: [nm := s aspect isNil									ifTrue: ['']									ifFalse: [s aspect printString]].					mb add: nm -&gt; i]].	^mb menu</body><body package="BGOK">fromLiteralArrayEncoding: anArray 	"Need to unpack the chart data series."	super fromLiteralArrayEncoding: anArray.	series isNil ifFalse: [series := series collect: [:s | s decodeAsLiteralArray]]</body><body package="BGOK">insertIntoView: aChartView withBuilder: builder andPrefix: aSymbol	"Iterate over the collection of specs defining the series of data."	| descr  |	(series isNil or: [series isEmpty])		ifTrue: [aChartView useDefaultDescriptors]		ifFalse: 			[descr := Array new: series size.			1 to: descr size				do: 					[:i | 					| dd |					dd := BG_ChartDataSetDescription new.					"Array of arrays"					descr size &gt; 1 ifTrue: [dd adaptor: (IndexedAdaptor forIndex: i)]. 					(series at: i)						insertIntoDescriptor: dd withBuilder: builder andPrefix: aSymbol.					descr at: i put: dd].			aChartView descriptors: descr]</body><body package="BGOK">simplified	"Note that it is possible to have Data Set Descriptors that contain 	only nils."	^(series isNil or: [series isEmpty])		ifTrue: [nil]		ifFalse: 			[| newSeries |			newSeries := series collect: [:ss | ss simplified].			series := newSeries select: [:ss | ss notNil].			series isEmpty				ifTrue: [nil]				ifFalse: [self]]</body></methods><methods><class-id>UI.ChartDataSpec</class-id> <category>private-actions</category><body package="BGOK">addNewSeriesAfter: anIndex 	"Add new data set descriptors spec. Answer an index of a new spec"	| baby res indx |	indx := anIndex isNil ifTrue: [0] ifFalse: [anIndex].	baby := ChartDataSetSpec new.	series isNil		ifTrue: 			[series := Array with: baby.			res := 1]		ifFalse: 			[| coll |			coll := List new.			coll addAll: series.			indx = coll size				ifTrue: [coll addLast: baby]				ifFalse: [coll add: baby beforeIndex: indx + 1].			series := coll asArray.			res := indx + 1].	baby name: ((#New1s &lt;&lt; #BGOK &gt;&gt; 'New-&lt;1s&gt;')			expandMacrosWith: res printString); aspect: #value.	^res</body><body package="BGOK">deleteSeriesAt: anIndex 	"Remove an entry at index 'anIndex'. If after removal the collection is empty 	replace it with nil. 	Answer a new index."	^series isNil ifFalse: [series size = 1			ifTrue: 				[series := nil.				0]			ifFalse: 				[series := series copyWithout: (series at: anIndex).				anIndex = 1					ifTrue: [1]					ifFalse: [anIndex - 1]]]</body></methods><methods><class-id>UI.ChartDataSpec</class-id> <category>private-validation</category><body package="BGOK">isDataValidForChart: aChartType 	"Test if the data is valid for a specified chart type. 	Answer false if there is a problem."		self simplified isNil ifTrue: [^true].	self nbrOfDataSeries &lt; 1		ifTrue: 			[Dialog warn: (#GenKey2 &lt;&lt; #BGOK &gt;&gt; 'You have to specify at least one data series').			^false].	^true</body></methods><methods><class-id>UI.ChartDataSpec class</class-id> <category>instance creation</category><body package="BGOK">new: aNumberOfSeries 	"Create a new instance with aNumberOfSeries data descriptors."	| baby series |	baby := self new.	series := Array new: aNumberOfSeries.	1 to: aNumberOfSeries do: [:i | series at: i put: ChartDataSetSpec new].	baby series: series.	^baby</body></methods><methods><class-id>UI.BG_DataPointMarker</class-id> <category>displaying</category><body package="BGOK">displayImageOn: aGraphicsContext preferences: pref	aGraphicsContext paint: pref foregroundColor.	borderImage		displayOn: aGraphicsContext		at: borderImage bounds center negated.	internalImage == nil		ifFalse:			[aGraphicsContext paint: pref backgroundColor.			internalImage				displayOn: aGraphicsContext				at: internalImage bounds center negated].</body><body package="BGOK">displayOn: aGraphicsContext	| pref |	pref := aGraphicsContext clientDataAt: #chartElement ifAbsent: [nil].	pref == nil		ifTrue:	[pref := self lookPreferences].	(self usePathsOn: aGraphicsContext)		ifTrue:	[self displayPathOn: aGraphicsContext preferences: pref]		ifFalse:	[self displayImageOn: aGraphicsContext preferences: pref]</body><body package="BGOK">displayPathOn: aGraphicsContext preferences: pref	| scaledPath |	scaledPath := path scaledBy: borderImage bounds extent.	internalImage == nil		ifTrue: [aGraphicsContext paint: pref foregroundColor]		ifFalse: [aGraphicsContext paint: pref backgroundColor].	aGraphicsContext translateBy: scaledPath bounds center negated.	scaledPath displayFilledOn: aGraphicsContext.	aGraphicsContext paint: pref foregroundColor.	scaledPath displayStrokedOn: aGraphicsContext</body><body package="BGOK">usePathsOn: aGraphicsContext	^(aGraphicsContext medium screen isMemberOf: Screen) not</body></methods><methods><class-id>UI.BG_DataPointMarker</class-id> <category>initialize-release</category><body package="BGOK">borderImage: image1 internalImage: image2	borderImage := image1.	internalImage := image2</body><body package="BGOK">image: image1	borderImage := image1.	internalImage := nil</body><body package="BGOK">path: aGeometric	path := aGeometric</body></methods><methods><class-id>UI.BG_DataPointMarker</class-id> <category>scaling</category><body package="BGOK">magnifiedBy: aScale 	^self class new borderImage: (borderImage image magnifiedBy: aScale)		internalImage: (internalImage image magnifiedBy: aScale)</body></methods><methods><class-id>UI.BG_DataPointMarker class</class-id> <category>constants</category><body package="BGOK">imageAt: markerName	^NamedMarkers at: markerName ifAbsent: [nil]</body><body package="BGOK">imageAt: markerName put: marker	NamedMarkers at: markerName put: marker</body></methods><methods><class-id>UI.BG_DataPointMarker class</class-id> <category>class initialization</category><body package="BGOK">eraseBorderPixelsOn: image1	| image2 bounds w h |	image2 := image1 copy.	bounds := image2 bounds.	w := bounds width.	h := bounds height.	image2 copy: (0@0 extent: 1@h) from: 0@0 in: nil rule: RasterOp writeZeros.	image2 copy: (0@0 extent: w@1) from: 0@0 in: nil rule: RasterOp writeZeros.	image2 copy: (w-1@0 extent: 1@h) from: 0@0 in: nil rule: RasterOp writeZeros.	image2 copy: (0@(h-1) extent: w@1) from: 0@0 in: nil rule: RasterOp writeZeros.	image2 copy: bounds from: 0@1 in: image1 rule: RasterOp and.	image2 copy: bounds from: 1@0 in: image1 rule: RasterOp and.	image2 copy: bounds from: 0@ -1 in: image1 rule: RasterOp and.	image2 copy: bounds from: -1@0 in: image1 rule: RasterOp and.	^image2</body><body package="BGOK">initialize	"BG_DataPointMarker initialize."	NamedMarkers := IdentityDictionary new.	self initializeSquares.	self initializeCircles.	self initializeDiamonds.	self initializeTriangles.	self initializeExtras.</body><body package="BGOK">initializeCircles	"BG_DataPointMarker initializeCircles"	| circle1 circle2 path |	path := Circle center: 0.5@0.5 radius: 0.5.	circle1 := Image				extent: 8 @ 8				depth: 1				palette: CoveragePalette monoMaskPalette				bits: #[60 126 255 255 255 255 126 60]				pad: 8.	circle2 := self eraseBorderPixelsOn: circle1.	circle1 := CachedImage on: circle1.	circle2 := CachedImage on: circle2.	self imageAt: #circle put: (self new borderImage: circle1 internalImage: circle2; path: path).	self imageAt: #solidCircle put: (self new image: circle1; path: path).</body><body package="BGOK">initializeDiamonds	"BG_DataPointMarker initializeDiamonds"	| diamond1 diamond2 path |	path := Polyline vertices: ((Array with: 1@0.5 with: 0.5@1 with: 0@0.5 with: 0.5@0) copyWith: 1@0.5).	diamond1 := Image				extent: 8 @ 8				depth: 1				palette: CoveragePalette monoMaskPalette				bits: #[24 60 126 255 255 126 60 24 ]				pad: 8.	diamond2 := self eraseBorderPixelsOn: diamond1.	diamond1 := CachedImage on: diamond1.	diamond2 := CachedImage on: diamond2.	self imageAt: #diamond put: (self new borderImage: diamond1 internalImage: diamond2; path: path).	self imageAt: #solidDiamond put: (self new image: diamond1; path: path).</body><body package="BGOK">initializeExtras	"BG_DataPointMarker initializeExtras"	| image path |	path := Polyline vertices: (Array with: 0.5@1 with: 0.5@0 with: 0.5@0.5 with: 1@0.5), (Array with: 0@0.5 with: 0.5@0.5).	image := Image				extent: 8 @ 8				depth: 1				palette: CoveragePalette monoMaskPalette				bits: #[16 16 16 254 16 16 16 0 ]				pad: 8.	image := CachedImage on: image.	self imageAt: #cross put: (self new image: image; path: path).	path := Polyline vertices: (Array with: 1@1 with: 0@0 with: 0.5@0.5 with: 1@0), (Array with: 0@1 with: 0.5@0.5).	image := Image				extent: 9 @ 9				depth: 1				palette: CoveragePalette monoMaskPalette				bits: #[128 128 65 0 34 0 20 0 8 0 20 0 34 0 65 0 128 128]				pad: 8.	image := CachedImage on: image.	self imageAt: #x put: (self new image: image; path: path).</body><body package="BGOK">initializeSquares	"BG_DataPointMarker initializeSquares"	| square1 square2 path |	path := Polyline vertices: ((Array with: 1@1 with: 0@1 with: 0@0 with: 1@0) copyWith: 1@1).	square1 := Image				extent: 8 @ 8				depth: 1				palette: CoveragePalette monoMaskPalette				bits: #[255 255 255 255 255 255 255 255 ]				pad: 8.	square2 := self eraseBorderPixelsOn: square1.	square1 := CachedImage on: square1.	square2 := CachedImage on: square2.	self imageAt: #square put: (self new borderImage: square1 internalImage: square2; path: path).	self imageAt: #solidSquare put: (self new image: square1; path: path).</body><body package="BGOK">initializeTriangles	"BG_DataPointMarker initializeTriangles"	| triangle1 triangle2 path |	path := Polyline vertices: (Array with: 1@1 with: 0@1 with: 0.5@0 with: 1@1).	triangle1 := Image				extent: 8 @ 8				depth: 1				palette: CoveragePalette monoMaskPalette				bits: #[24 60 60 126 126 255 255 255 ]				pad: 8.	triangle2 := self eraseBorderPixelsOn: triangle1.	triangle1 := CachedImage on: triangle1.	triangle2 := CachedImage on: triangle2.	self imageAt: #triangle put: (self new borderImage: triangle1 internalImage: triangle2; path: path).	self imageAt: #solidTriangle put: (self new image: triangle1; path: path).	path := Polyline vertices: (Array with: 1@0 with: 0@0 with: 0.5@1 with: 1@0).	triangle1 := Image				extent: 8 @ 8				depth: 1				palette: CoveragePalette monoMaskPalette				bits: #[255 255 255 126 126 60 60 24 ]				pad: 8.	triangle2 := self eraseBorderPixelsOn: triangle1.	triangle1 := CachedImage on: triangle1.	triangle2 := CachedImage on: triangle2.	self imageAt: #triangle2 put: (self new borderImage: triangle1 internalImage: triangle2; path: path).	self imageAt: #solidTriangle2 put: (self new image: triangle1; path: path).</body></methods><methods><class-id>UI.ChartingScaleSpec</class-id> <category>private</category><body package="BGOK">simplified	"Remove the base definition if the scale type is normal. 	If the auto scale flag is on, also remove the of max, min, and step definitions."	self scaleType == #normal		ifTrue: 			[base := nil.			scaleType := nil].	(restrictions notNil and: [restrictions isEmpty]) ifTrue: [restrictions := nil].	^super simplified</body></methods><methods><class-id>UI.ChartingScaleSpec</class-id> <category>accessing</category><body package="BGOK">addRestrictions: aCollection	self restrictions: (self restrictions asSet addAll: aCollection; asArray)</body><body package="BGOK">autoScale	"Nil and true return true"	(self restrictions includes: #auto) ifTrue: [^true].	^autoScale ~= false</body><body package="BGOK">autoScale: aValue	autoScale := aValue</body><body package="BGOK">autoScaleSet	"Return the state of the autoScale variable. Return true if 	autoScale is not nil. Specs need to distinguish when its value is nil"	(self restrictions includes: #auto) ifTrue: [^false].	^autoScale notNil</body><body package="BGOK">base	^base</body><body package="BGOK">base: aValue	base := aValue</body><body package="BGOK">getMax	"Always answer a number. If the instance variable is nil answer 0."	^max isNil ifTrue: [100] ifFalse: [max].</body><body package="BGOK">getMin	"Always answer a number. If the instance variable is nil answer 0."	^min isNil ifTrue: [0] ifFalse: [min].</body><body package="BGOK">getZero	"Always answer a number. If the instance variable is nil answer 0."	^zero isNil ifTrue: [self getMin] ifFalse: [zero].</body><body package="BGOK">invert	^invert == true</body><body package="BGOK">invert: aValue 	invert := aValue</body><body package="BGOK">max	^max</body><body package="BGOK">max: aValue	max := aValue</body><body package="BGOK">min	^min</body><body package="BGOK">min: aValue	min := aValue</body><body package="BGOK">minorDivisions	^minorDivisions</body><body package="BGOK">minorDivisions: aValue	minorDivisions := aValue</body><body package="BGOK">restrictions	^restrictions isNil ifTrue: [#()] ifFalse: [restrictions].</body><body package="BGOK">restrictions: aValue	restrictions := aValue</body><body package="BGOK">scaleType	"Nil or #normal return #normal"	scaleType isNil ifTrue: [^#normal].	^scaleType</body><body package="BGOK">scaleType: aValue	scaleType := aValue</body><body package="BGOK">step	^step</body><body package="BGOK">step: aValue	step := aValue</body><body package="BGOK">zero	^zero</body><body package="BGOK">zero: aValue	zero := aValue</body></methods><methods><class-id>UI.ChartingScaleSpec</class-id> <category>private-interface building</category><body package="BGOK">insertIntoScale: aScale 	| setStep | 	setStep := false.	self autoScale ifFalse: [	(min notNil and: [max notNil])		ifTrue: 			[aScale sourceMin: min max: max.			zero isNil ifTrue: [aScale zero: min].			setStep := true].	(step notNil and: [step isZero not])		ifTrue: [aScale step: step]		ifFalse: [setStep				ifTrue: 					[| st |					st := (max - min // 5) abs.					aScale step: st]]].	((self restrictions includes: #zero) or: [zero isNil]) ifFalse: [aScale zero: zero].	(minorDivisions notNil and: [minorDivisions isZero not])		ifTrue: [aScale div: minorDivisions rounded].	self invert		ifTrue: [aScale decrease]		ifFalse: [aScale increase].	(base notNil and: [self scaleType == #log])		ifTrue: [aScale base: base rounded]</body></methods><methods><class-id>UI.ChartingScaleSpec</class-id> <category>private-validation</category><body package="BGOK">checkLogScaleForChart: aChart 	"Log scale must have a minimum value higher than zero and a base	greater than 1."	self base rounded &gt; 1 		ifFalse: 			[Dialog warn: (#GenKey5 &lt;&lt; #BGOK &gt;&gt; 'The base for a logarithmic scalemust be greater than or equal to 1.5.').			^false].	self autoScale ifTrue: [^true].	self getMin &gt; 0		ifFalse: 			[Dialog warn: (#GenKey4 &lt;&lt; #BGOK &gt;&gt; 'The minimum value for a logarithmic   scale must be greater then 0.').			^false].	^true</body><body package="BGOK">checkMinForChart: aChartType 	"Bar charts must have zero value between maximum and minimum."	((#(#BG_BarChartView #BG_ParatoChartView #BG_PictureChartView #BG_StackedBarChartView #BG_BandChartView #BG_LayerChartView ) includes: aChartType)		and: [self autoScale not])		ifTrue: [(self getMin &lt;= self getZero and: [self getZero &lt;= self getMax])				ifFalse: 					[Dialog warn: (#GenKey6 &lt;&lt; #BGOK &gt;&gt; 'The zero value for a scale for this type of chart must be between the minimum and maximum value.').					^false]].	^true</body><body package="BGOK">checkMinMax	"Check min and max values for manual scales."	min &lt; max		ifFalse: 			[Dialog warn: (#GenKey7 &lt;&lt; #BGOK &gt;&gt; 'The minimum value for a scale must be smaller then the maximum value.').			^false].	^true</body><body package="BGOK">isDataValidForChart: aChartType 	"Answer true if the data is valid, false otherwise."	(self minorDivisions notNil and: [self minorDivisions &lt; 1])		ifTrue: 			[Dialog warn: (#GenKey8 &lt;&lt; #BGOK &gt;&gt; 'The value for minor divisionshas to be a positive integer.').			^false].	self scaleType == #normal ifFalse: [(self checkLogScaleForChart: aChartType)			ifFalse: [^false]].	self autoScale ifTrue: [^true].	(self checkMinMax and: [self checkMinForChart: aChartType])		ifFalse: [^false].	^true</body></methods><methods><class-id>Examples.BG_StockQuote</class-id> <category>date</category><body package="BGOK">date	^date</body></methods><methods><class-id>Examples.BG_StockQuote</class-id> <category>price:</category><body package="BGOK">price: aValue	price := aValue</body></methods><methods><class-id>Examples.BG_StockQuote</class-id> <category>date:</category><body package="BGOK">date: aValue	date := aValue</body></methods><methods><class-id>Examples.BG_StockQuote</class-id> <category>symbol</category><body package="BGOK">symbol	^symbol</body></methods><methods><class-id>Examples.BG_StockQuote</class-id> <category>price</category><body package="BGOK">price	^price</body></methods><methods><class-id>Examples.BG_StockQuote</class-id> <category>symbol:</category><body package="BGOK">symbol: aValue	symbol := aValue</body></methods><methods><class-id>Examples.BG_StockQuote class</class-id> <category>readFrom:</category><body package="BGOK">readFrom: aStream	"Create an instance from text. The format of a quote is as follows: 	'Sep 10, 1993	ASPX 10.750	\n'"	| baby |	baby := self new.	baby date: (Date readFrom: aStream).	aStream skipSeparators.	baby symbol: (aStream upTo: $ ).	aStream skipSeparators.	baby price: (Float readFrom: aStream).	aStream through: Character cr.	^baby</body></methods><methods><class-id>Tools.ChartScaleSpecModel</class-id> <category>interface opening</category><body package="BGOK">postBuildWith: aBuilder 	"Update the state of the input fields in order to disable some 	of them."	super postBuildWith: aBuilder. 	self disableRangeButtons: autoScale value.	self changedScaleType: scaleType value.	self addRestrictions: specChannel value.	autoScale		compute: 			[:v | 			v ifFalse: [self switchToManual].			self disableRangeButtons: v].	scaleType compute: [:v | self changedScaleType: v]</body></methods><methods><class-id>Tools.ChartScaleSpecModel</class-id> <category>accessing</category><body package="BGOK">autoScale	^autoScale</body><body package="BGOK">base	^base</body><body package="BGOK">invert	^invert</body><body package="BGOK">max	^max</body><body package="BGOK">min	^min</body><body package="BGOK">minorDivisions	^minorDivisions</body><body package="BGOK">scaleType	^scaleType</body><body package="BGOK">specChannel: aValueHolder	"All aspects are dependent of a spec channel. 	So any changes are propagated to the parent model."	super specChannel: aValueHolder.	min := (AspectAdaptor subjectChannel: aValueHolder)				forAspect: #min.	max := (AspectAdaptor subjectChannel: aValueHolder)				forAspect: #max.	zero := (AspectAdaptor subjectChannel: aValueHolder)				forAspect: #zero.	minorDivisions := (AspectAdaptor subjectChannel: aValueHolder)				forAspect: #minorDivisions.	base := (AspectAdaptor subjectChannel: aValueHolder)				forAspect: #base.	invert := (AspectAdaptor subjectChannel: aValueHolder)				forAspect: #invert.	autoScale := (AspectAdaptor subjectChannel: aValueHolder)				forAspect: #autoScale.	scaleType := (AspectAdaptor subjectChannel: aValueHolder)				forAspect: #scaleType.	step := (AspectAdaptor subjectChannel: aValueHolder)				forAspect: #step</body><body package="BGOK">step	^step</body><body package="BGOK">zero	^zero</body></methods><methods><class-id>Tools.ChartScaleSpecModel</class-id> <category>private</category><body package="BGOK">addRestrictions: aSpec 	"Check if we are dealing with the restricted version of the scale"	| restr |	restr := aSpec restrictions.	(restr includes: #auto)		ifTrue: 			[self disableRangeButtons: true.			(builder componentAt: #autoScaleBox) disable].	(restr includes: #zero)		ifTrue: 			[(builder componentAt: #zeroField) disable.			(builder componentAt: #zeroLabel) disable].	(restr includes: #div)		ifTrue: 			[(builder componentAt: #divField) disable.			(builder componentAt: #divLabel) disable].	(restr includes: #log)		ifTrue: [(builder componentAt: #scaleLog) disable]</body><body package="BGOK">changedScaleType: newType 	"The scale type has changed. 	If the new type is #log then: 	enable base field and put 10 into it (if not defined)"	newType == #log		ifTrue: 			[(builder componentAt: #baseField) enable.			(builder componentAt: #baseLabel) enable.			base value isNil ifTrue: [base value: 10]]		ifFalse: 			[(builder componentAt: #baseField) disable.			(builder componentAt: #baseLabel) disable]</body><body package="BGOK">disableRangeButtons: aValue 	"If aValue is true disable range buttons."	#(#minField #maxField #stepField #minLabel #maxLabel #stepLabel)		do: 			[:sym | 			| comp |			comp := builder componentAt: sym.			aValue				ifTrue: [comp disable]				ifFalse: [comp enable]]</body><body package="BGOK">switchToManual	min value isNil ifTrue: [min value: (self scaleType value == #normal				ifTrue: [0]				ifFalse: [1])].	max value isNil ifTrue: [max value: 100].	step value isNil ifTrue: [step value: 20]</body></methods><methods><class-id>UI.BG_PictureChartView</class-id> <category>private</category><body package="BGOK">compose	self composeLabels: self labelsSize.	self composeSortIndex: self sortedValues.	self composeGrid.	self isLegendVisible ifTrue: [self composeLegend: 1].</body><body package="BGOK">composeLegend: size	legend item: (Array with: unit).	legend alignment: 1.	self composeLegendFrame: size</body><body package="BGOK">legendSize	^1</body></methods><methods><class-id>UI.BG_PictureChartView</class-id> <category>private-data-transformation</category><body package="BGOK">dataFromDescriptions	"I can accept only one set of data."	| dataDescr labelDescr |	dataDescr := descriptors detect: [:descr | descr hasData]				ifNone: [BG_ChartDataSetDescription new].	labelDescr := descriptors detect: [:descr | descr hasData not]				ifNone: [nil].	descriptors := labelDescr isNil				ifTrue: [Array with: dataDescr]				ifFalse: [Array with: dataDescr with: labelDescr].	super dataFromDescriptions</body></methods><methods><class-id>UI.BG_PictureChartView</class-id> <category>picture/unit</category><body package="BGOK">picture	^picture item</body><body package="BGOK">picture: anObject	picture item: anObject</body><body package="BGOK">pictureStyle	^picture</body><body package="BGOK">unit	^unit</body><body package="BGOK">unit: aNumber	unit := aNumber</body></methods><methods><class-id>UI.BG_PictureChartView</class-id> <category>displaying</category><body package="BGOK">displayLegendOn: aGraphicsContext 	| area iconRect gc |	self legendAlignment = 0 ifTrue: [^self].	gc := self setChartElementLookUsing: aGraphicsContext.	legendFrame displayOn: gc. 	area := legendFrame bounds insetBy: 6.	iconRect := (area topLeft extent: area width - legend individualExtent x @ area height) insetBy: 3.	picture autoScale.	picture extent: iconRect extent.	picture displayOn: aGraphicsContext at: area topLeft + (3 @ 3).	legend displayOn: aGraphicsContext at: iconRect rightCenter - (-3 @ (legend height // 2))</body><body package="BGOK">displayPlotOn: aGraphicsContext 	| value uv points collection gc clip base |	value := self data.	base := grid y scale zero.	points := Array new: value columnSize * 2.	gc := aGraphicsContext copy.	1 to: value columnSize		do: 			[:i | 			| n |			n := sortedIndex at: i.			points at: i * 2 - 1 put: i - (barWidth / 2) @ (value at: n @ 1).			points at: i * 2 put: i + (barWidth / 2) @ base].	uv := ((grid applyTo: barWidth @ unit)				- (grid applyTo: 0 @ 0)) abs rounded.	picture extent: uv.	collection := grid applyToValues: points.	clip := gc clippingBounds.	picture scale: 1 @ 1.	picture scale: uv / picture image extent.	1 to: value columnSize		do: 			[:i | 			| v p1 p2 bclip |			v := value at: (sortedIndex at: i)							@ 1.			v := v - base.			p1 := (collection at: i * 2 - 1) rounded.			p2 := (collection at: i * 2) rounded.			bclip := clip intersect: (Rectangle vertex: p1 vertex: p2).			v &gt;= 0				ifTrue: [1 to: (v / unit) ceiling						do: 							[:j | 							p1 := (grid applyTo: (points at: i * 2 - 1) x @ (base + (unit * (j - 1)))) rounded.							p2 := (grid applyTo: (points at: i * 2) x @ (base + (unit * j))) rounded.							gc clippingRectangle: (bclip intersect: (Rectangle vertex: p1 vertex: p2)).							picture displayOn: gc at: (p1 min: p2)]]				ifFalse: [1 to: (v / unit) floor abs						do: 							[:j | 							picture rotation: picture rotation + 2 \\ 4.							p1 := (grid applyTo: (points at: i * 2 - 1) x @ (base + (unit * (j - 1) * -1))) rounded.							p2 := (grid applyTo: (points at: i * 2) x @ (base + (unit * j * -1))) rounded.							gc clippingRectangle: (bclip intersect: (Rectangle vertex: p1 vertex: p2)).							picture displayOn: gc at: (p1 min: p2).							picture rotation: picture rotation + 2 \\ 4]]]</body></methods><methods><class-id>UI.BG_PictureChartView</class-id> <category>private-default-model</category><body package="BGOK">defaultDescriptorsFor: numberOfSeries 	"I use only one data series"	^super defaultDescriptorsFor: 1</body><body package="BGOK">defaultModelFor: dataDescriptor 	"I use only one data series"	dataDescriptor nbrOfDataSeries &gt; 1		ifTrue: 			[| series first |			first := true.			series := dataDescriptor series select: 			[:s | s isData ifFalse: [true]						ifTrue: [first								ifTrue: 									[first := false.									true]								ifFalse: [false]]].			dataDescriptor series: series].	^super defaultModelFor: dataDescriptor</body></methods><methods><class-id>UI.BG_PictureChartView</class-id> <category>initialize-release</category><body package="BGOK">initialize	super initialize.	legendLocation := 6.	unit := 20.	picture := BG_Banner new.	picture item: self class defaultPicture</body><body package="BGOK">newGraphicsDevice: aGraphicsDevice	super newGraphicsDevice: aGraphicsDevice.	picture newGraphicsDevice: aGraphicsDevice.</body></methods><methods><class-id>UI.BarChartOptionsSpec</class-id> <category>accessing</category><body package="BGOK">dataLocation	dataLocation isNil ifTrue: [^#none].	^dataLocation</body><body package="BGOK">dataLocation: aValue	dataLocation := aValue</body><body package="BGOK">overlap	^overlap isNil		ifTrue: [0]		ifFalse: [overlap]</body><body package="BGOK">overlap: aValue	overlap := aValue</body><body package="BGOK">picture	^picture</body><body package="BGOK">picture: aValue	picture := aValue</body><body package="BGOK">showLink	"Returns false if showLink is false or nil"	^showLink == true</body><body package="BGOK">showLink: aValue	showLink := aValue</body><body package="BGOK">unit	^unit</body><body package="BGOK">unit: aValue	unit := aValue</body><body package="BGOK">width	^width isNil		ifTrue: [0.8]		ifFalse: [width]</body><body package="BGOK">width: aValue	width := aValue</body></methods><methods><class-id>UI.BarChartOptionsSpec</class-id> <category>private</category><body package="BGOK">simplified	"Remove the default values."	dataLocation == #none ifTrue: [dataLocation := nil].	showLink == false ifTrue: [showLink := nil].		^super simplified</body></methods><methods><class-id>UI.BarChartOptionsSpec</class-id> <category>private-interface building</category><body package="BGOK">insertIntoView: aChartView withBuilder: builder 	"Insert optional parameters into a bar chart view"	dataLocation isNil		ifFalse: 			[dataLocation == #none ifTrue: [aChartView hideData].			dataLocation == #inside ifTrue: [aChartView dataInside].			dataLocation == #outside ifTrue: [aChartView dataOutside]].	overlap isNil ifFalse: [aChartView barOverlap: overlap].	width isNil ifFalse: [aChartView barWidth: width].	showLink isNil ifFalse: [showLink			ifTrue: [aChartView showLink]			ifFalse: [aChartView hideLink]].	unit isNil ifFalse: [aChartView unit: unit].	picture isNil		ifFalse: 			[| image |			image := builder aspectAt: picture.			image isNil				ifTrue: 					[image := aChartView class defaultPicture.					builder isEditing ifFalse: [image := builder raiseErrorMessage: (#aspect1pNotFound &lt;&lt; #BGOK &gt;&gt; 'aspect: &lt;1p&gt; not found!') with: picture]].			aChartView picture: image]</body></methods><methods><class-id>UI.BarChartOptionsSpec class</class-id> <category>private-interface building</category><body package="BGOK">addBindingsTo: env for: inst channel: aChannel 	| width overlap unit |	super		addBindingsTo: env		for: inst		channel: aChannel.	width := self				adapt: inst				forAspect: #width				channel: aChannel.	overlap := self				adapt: inst				forAspect: #overlap				channel: aChannel.	unit := self			adapt: inst			forAspect: #unit			channel: aChannel.	unit compute: [:v|		(v notNil and: [v &lt; 0]) ifTrue: [unit value: nil]].	super		addBindingsTo: env		for: inst		channel: aChannel.	env at: #barWidth put: width.	env at: #barOverlap put: overlap.	env at: #showLink put: (self			adapt: inst			forAspect: #showLink			channel: aChannel).	env at: #dataLocation put: (self			adapt: inst			forAspect: #dataLocation			channel: aChannel).	env at: #unit put: (unit).	env at: #picture put: (self				adapt: inst				forAspect: #picture				channel: aChannel)</body></methods><methods><class-id>UI.BG_StepChartView</class-id> <category>displaying</category><body package="BGOK">displayDataOn: aGraphicsContext	| value images angle ofs gc |	value := self data.	gc := aGraphicsContext copy.	images := dataStyle individualImages.	angle := self defaultDataAngle.	ofs := 7.	1 to: value rowSize do: 		[:y | 1 to: value columnSize do: 			[:x | | n v |			n := sortedIndex at: x.			v := value at: n@y.			(x = 1 or: [v ~= (value at: (sortedIndex at: x-1)@y)]) ifTrue:				[grid 					displayLabel: (images at: n@y)					angle: angle 					offset: (self defaultDataOffset: v offset: ofs)					alignment: (self defaultDataAlignment: v)					on: gc 					at: (grid applyTo: x@v) rounded]]]</body><body package="BGOK">displayPlotOn: aGraphicsContext 	| value points collection |	value := self data.	points := BG_TableAdaptor columns: value columnSize * 2 rows: value rowSize.	1 to: value columnSize do: 		[:x | 			| n  |			n := sortedIndex at: x.			1 to: value rowSize do: 			[:y | 				points at: x *2 -1@y put: x - 0.5 @ (value at: n@y).				points at: x *2@y put: x + 0.5@(value at: n@y)]].	collection := grid applyToValues: points.	1 to: value rowSize do: 		[:y | self			displayLineAndMarkerOn: aGraphicsContext			at: y			points: (collection rowAt: y)]</body></methods><methods><class-id>UI.ChartViewSpec</class-id> <category>accessing</category><body package="BGOK">chartType	"Answer a default type if not set."	chartType isNil ifTrue: [^#BG_BarChartView].	^chartType</body><body package="BGOK">chartType: aValue 	chartType := aValue.</body><body package="BGOK">dataAxis	"Answer yAxis."	^yAxis</body><body package="BGOK">dataLocation	^dataLocation</body><body package="BGOK">dataLocation: aValue	dataLocation := aValue</body><body package="BGOK">dataSeries	^dataSeries</body><body package="BGOK">dataSeries: aValue	dataSeries := aValue</body><body package="BGOK">itemAxis	"If the chart type is XY. Answer xDataAxis, otherwise 	answer xAxis."	^self isXAxisData 		ifTrue: [xDataAxis]		ifFalse: [xAxis]</body><body package="BGOK">legendPosition	"For picture charts the default legend position is 6 (upper right corner)"	^legendPosition isNil		ifTrue: [self chartType == #BG_PictureChartView				ifTrue: [6]				ifFalse: [0]]		ifFalse: [legendPosition]</body><body package="BGOK">legendPosition: aValue		legendPosition := aValue</body><body package="BGOK">options	"Return the subspec describing that options that are compatible with the chart type."	options isNil ifTrue: [^nil].	^options at: self optionsType ifAbsent: [nil]</body><body package="BGOK">options: aValue	options := aValue</body><body package="BGOK">orientation	(orientation isNil or: [chartType == #BCxOK_PictureChartView]) ifTrue: [^#vertical].	^orientation</body><body package="BGOK">orientation: aValue	orientation := aValue</body><body package="BGOK">setChartType	^self chartType</body><body package="BGOK">setChartType: aValue 	"A chart type is about to change. Do the necessary transformations."	| restrictions | 	chartType := aValue.	restrictions := Set new.	self isYAxisManual ifTrue: [restrictions add: #auto].	self setDataScaleRestrictions: restrictions</body><body package="BGOK">transposed: aValue	orientation := aValue ifTrue: [#horizontal] ifFalse: [nil].</body><body package="BGOK">xAxis	^xAxis</body><body package="BGOK">xAxis: aValue	xAxis := aValue</body><body package="BGOK">xDataAxis	^xDataAxis</body><body package="BGOK">xDataAxis: aValue	xDataAxis := aValue</body><body package="BGOK">yAxis	^yAxis</body><body package="BGOK">yAxis: aValue	yAxis := aValue</body></methods><methods><class-id>UI.ChartViewSpec</class-id> <category>private</category><body package="BGOK">defaultModel	"The dispatchTo:with:  method creates the real default model	by asking the chart view. The one used here is only for the definer."	^List new asValue</body><body package="BGOK">dispatchTo: policy with: builder 	"Build the chart view. 	Construct chart views since charts do not change its look according to 	the policy. If the builder is editing, ask a chart view for a default 	model."	| cv data ds |	cv := (BindingReference pathString: self chartType) value new.	ds := (dataSeries isNil or: [dataSeries series isNil])				ifTrue: [ChartDataSpec new: cv defaultNbrOfSeries]				ifFalse: [dataSeries].	cv gridType == #normal ifTrue: [		"The scales have to be set before generating default models."		self insertAxisIntoView: cv with: builder].	data := self modelInBuilder: builder.	(builder isEditing and: [data size = 0])		ifTrue: ["Get better default model using view's knowledge."			data := cv defaultModelFor: ds].	(data isKindOf: SelectionInList)		ifTrue: [cv model: data listHolder]		ifFalse: [cv model: data asValue].	"Insert descriptions of data series into a Chart View."	ds		insertIntoView: cv		withBuilder: builder		andPrefix: model.	legendPosition notNil ifTrue: [cv legendAlignment: legendPosition].	self options notNil ifTrue: [self options insertIntoView: cv withBuilder: builder].	self orientation == #horizontal ifTrue: [cv transpose].	builder component: cv.	builder wrapWith: (policy simpleWrapperFor: self).	builder applyLayout: self layout.	builder wrapWith: (policy			simpleWidgetWrapperOn: builder			spec: self			state: cv widgetState)</body><body package="BGOK">fromLiteralArrayEncoding: anArray 	"Need to unpack subspecs. 	Options are internally stored as a dictionary containing options specs 	for all chart types, but in literal encoding only the relevant spec is 	preserved. This method restores a dictionary and puts the options spec 	in the proper slot. 	"	super fromLiteralArrayEncoding: anArray.	xAxis := xAxis decodeAsLiteralArray.	yAxis := yAxis decodeAsLiteralArray.	xDataAxis := xDataAxis decodeAsLiteralArray.	dataSeries := dataSeries decodeAsLiteralArray.	options notNil		ifTrue: 			[| spec |			spec := options decodeAsLiteralArray.			options := nil.			self setOptions: spec]</body><body package="BGOK">insertAxisIntoView: aView with: aBuilder	"Depending on the chart type insert proper axis data."	self dataAxis notNil ifTrue: [self dataAxis insertIntoAxis: aView grid y with: aBuilder].	self itemAxis notNil ifTrue: [self itemAxis insertIntoAxis: aView grid x with: aBuilder].</body><body package="BGOK">literalArrayEncoding	"Answer a literal array representing this specification. 	Make sure that only options relevant to the currently selected 	chart type are stored."	| savedOptions res |	self simplify.	savedOptions := options.	options := self options.	res := super literalArrayEncoding.	options := savedOptions.	^res</body><body package="BGOK">setDataScaleRestrictions: aSet	"Note that this method creates a data set 	scale if neccessary."	| scale |	scale := self yScaleSpec. 	scale restrictions: aSet asArray.</body><body package="BGOK">setOptions: aSpec	"This method is different from the 'options:' method since it assumes 	the parameter is an instance of SubSpec."	options isNil ifTrue: [options := IdentityDictionary new].	options at: self optionsType put: aSpec</body><body package="BGOK">simplify	"Check if we can remove some sub specs. 	A lot of unimportant information may be created as the user looks	around and switches the slices in the properties tool. "	xAxis notNil ifTrue: [xAxis := xAxis simplified].	xDataAxis notNil ifTrue: [xDataAxis := xDataAxis simplified].	yAxis notNil ifTrue: [yAxis := yAxis simplified].	dataSeries notNil ifTrue: [dataSeries := dataSeries simplified].	self options notNil ifTrue: [self setOptions: self options simplified].</body></methods><methods><class-id>UI.ChartViewSpec</class-id> <category>private-accessing</category><body package="BGOK">chartInfo	"Answer the array from the ChartTypes. 	This is the primary method of obtaining chart characteristics."	^ChartTypes at: self chartType.</body><body package="BGOK">isXAxisData	"Answer true if a chart is given a type. The item axis should be data axis.	Currently this is true only for XY charts.  "	^(self chartInfo at: 1) == #xdata</body><body package="BGOK">isYAxisManual	"Answer true if this chart's axis is restricted to manual."	^(self chartInfo at: 2) == #yrestricted</body><body package="BGOK">optionsSpecClass	"Answer a class appropriate for chart options."	| type |	type := self optionsType.	type == #bar ifTrue: [^BarChartOptionsSpec].	type == #line ifTrue: [^LineChartOptionsSpec].	^PieChartOptionsSpec</body><body package="BGOK">optionsType	"Answer a type of options dialog appropriate for a given chart type. 	Chart option types fall into the following three categories: 		bar, line, pie.	See the ChartViewSpec class &gt;&gt; initalize message"	^(self chartInfo at: 4)</body></methods><methods><class-id>UI.ChartViewSpec</class-id> <category>copying</category><body package="BGOK">postCopy	"Copy all sub-specs."	xAxis := xAxis copy.	xDataAxis := xDataAxis copy.	yAxis := yAxis copy.	dataSeries := dataSeries copy.	options := options copy.</body></methods><methods><class-id>UI.ChartViewSpec</class-id> <category>private-interface building</category><body package="BGOK">dataSeriesSpec	"Answer a sub-spec responsible for the definiton of a data series.	This method is used by the properties tool to get the proper slice."	| series | 	series := self dataSeries.	series isNil		ifTrue: 			[series := ChartDataSpec new.			self  dataSeries: series].	^series</body><body package="BGOK">optionsSpec	"Answer a sub-spec responsible for the char options.	This method is used by the properties tool to get the proper slice."	| spec |	spec := self options.	spec isNil		ifTrue: 			[spec := self optionsSpecClass new.			self setOptions: spec].	^spec</body><body package="BGOK">subSpecFor: aSlice	"Given a slice, answer an appropriate sub-spec.	Note that this action may create the sub-specs.	If the requested slice does not exist, answer self." 	aSlice == #dataSeries ifTrue: [^self dataSeriesSpec].	aSlice == #options ifTrue: [^self optionsSpec].	aSlice == #xAxis ifTrue: [^self xAxisSpec].	aSlice == #yAxis ifTrue: [^self yAxisSpec].	aSlice == #xScale ifTrue: [^self xScaleSpec].		aSlice == #yScale ifTrue: [^self yScaleSpec].	^self.</body><body package="BGOK">xAxisSpec	"Answer a sub-spec responsible for the item axis. 	Note that for charts other than XY, the item scale is restricted."	self itemAxis isNil ifTrue: [self isXAxisData			ifTrue: [self xDataAxis: ChartingValueAxisSpec new]			ifFalse: [self xAxis: ChartingAxisSpec new]].	^self itemAxis</body><body package="BGOK">xScaleSpec	"Answer a sub-spec responsible for the item scale"	| scaleSpec |	scaleSpec := self xAxisSpec scale.	scaleSpec isNil		ifTrue: 			[scaleSpec := ChartingScaleSpec new.			self isXAxisData ifFalse: [scaleSpec restrictions: #(#auto #zero #div #log )].			self xAxisSpec scale: scaleSpec].	^scaleSpec</body><body package="BGOK">yAxisSpec	"Answer a sub-spec responsible for the data axis" 	self dataAxis isNil ifTrue: [self yAxis: ChartingValueAxisSpec new].	^self dataAxis</body><body package="BGOK">yScaleSpec	"Answer a sub-spec responsible for the data scale"	| scaleSpec |	scaleSpec := self yAxisSpec scale.	scaleSpec isNil		ifTrue: 			[scaleSpec := ChartingScaleSpec new.			scaleSpec invert: true.			self isYAxisManual ifTrue: [scaleSpec addRestrictions: #(auto)].			self yAxisSpec scale: scaleSpec].	^scaleSpec</body></methods><methods><class-id>UI.ChartViewSpec</class-id> <category>private-validation</category><body package="BGOK">isDataValid	"Test if the data is valid, and if it is answer true.	The properties tool uses this method to check integrity of the spec before 	building a view."		dataSeries notNil ifTrue: [(dataSeries isDataValidForChart: self chartType)			ifFalse: [^false]].	yAxis notNil ifTrue: [		yAxis scale notNil ifTrue: [(yAxis scale isDataValidForChart: self chartType)				ifFalse: [^false]]].	^true</body></methods><methods><class-id>UI.ChartViewSpec class</class-id> <category>private-interface building</category><body package="BGOK">addBindingsTo: env for: inst channel: aChannel 	| chartType  |	super		addBindingsTo: env		for: inst		channel: aChannel.	env at: #position put: (self				adapt: inst				forAspect: #legendPosition				channel: aChannel).	chartType := self				adapt: inst				forAspect: #setChartType				channel: aChannel.	env at: #labels put: (TypeConverter onSymbolValue: (self				adapt: inst				forAspect: #labels				channel: aChannel)).	env at: #orientation put: (self			adapt: inst			forAspect: #orientation			channel: aChannel).	env at: #setChartType put: chartType.	env at: #chartTypeMenu put: self chartTypeMenu asValue</body><body package="BGOK">componentName	^(#Chart &lt;&lt; #BGOK &gt;&gt; 'Chart')  asString</body></methods><methods><class-id>UI.ChartViewSpec class</class-id> <category>class-initialization</category><body package="BGOK">initialize	"Initialize the class."	"Create a dictionary, use chart types as keys and put arrays describing 	properties of charts as values. Each array has the following 	structure: 	1st element describes the type of data axis appropriate for the given 	chart type. Choice are xitem meaning that x axis is item axis so it 	can only be automatically labeled. The only exception is XY chart which 	has the x axis as full blown data axis. 	2nd element of the array describes the y axis. Restricted axis are 	used for Pareto and band charts. 	3th element describes if the chart uses fill patterns or line widths 	as options.	4th element says what kind of options dialog should be used.	Also: Install ChartViewSpec into the UIPalette activeSpecsList"	"self initalize"	ChartTypes := IdentityDictionary new.	ChartTypes at: #BG_BarChartView put: #(#xitem #ynormal  #regions #bar).	ChartTypes at: #BG_ParatoChartView put: #(#xitem #yrestricted  #regions  #bar).	ChartTypes at: #BG_PictureChartView put: #(#xitem #ynormal  #regions  #bar).	ChartTypes at: #BG_StackedBarChartView put: #(#xitem #ynormal  #regions  #bar).	ChartTypes at: #BG_BandChartView put: #(#xitem #yrestricted  #regions  #bar).	ChartTypes at: #BG_LayerChartView put: #(#xitem #ynormal  #regions  #bar).	ChartTypes at: #BG_LineChartView put: #(#xitem #ynormal  #lines #line).	ChartTypes at: #BG_StackedLineChartView put: #(#xitem #ynormal  #lines #line).	ChartTypes at: #BG_StepChartView put: #(#xitem #ynormal  #lines #line).	ChartTypes at: #BG_XYChartView put: #(#xdata #ynormal  #lines #line).	ChartTypes at: #BG_PieChartView put: #(#xitem #yrestricted  #regions #pie).	#{UIPalette} ifDefinedDo: [:uip |		(uip activeSpecsList includes: #ChartViewSpec) 			ifFalse: [uip activeSpecsList add: #ChartViewSpec]]</body></methods><methods><class-id>UI.ChartViewSpec class</class-id> <category>resources</category><body package="BGOK">iconForWidgetTree	^ToolbarIconLibrary visualFor: #chartWidget</body></methods><methods><class-id>UI.ChartViewSpec class</class-id> <category>property slices</category><body package="BGOK">basicSlice	^#(5 #(#(#{Kernel.UserMessage} #key: #Basics #defaultString: 'Basics' #catalogID: #BGOK) #defaultDialogSpec))</body><body package="BGOK">dataAxisSlice	^#(28 #(#(#{Kernel.UserMessage} #key: #DataAxis #defaultString: 'Data - Axis' #catalogID: #BGOK) #defaultDialogSpec nil #yAxis))</body><body package="BGOK">dataScaleSlice	^#(31 #(#(#{Kernel.UserMessage} #key: #DataScale #defaultString: 'Data - Scale' #catalogID: #BGOK) #defaultPropertySpec #ChartScaleSpecModel #yScale))</body><body package="BGOK">dataSeriesSlice	^#(13 #(#(#{Kernel.UserMessage} #key: #DataSeries #defaultString: 'Data Series' #catalogID: #BGOK) #defaultPropertySpec #ChartDataSpecModel #dataSeries))</body><body package="BGOK">detailsSlice	"Empty means NO PAGE!"	^#(1 #())</body><body package="BGOK">itemAxisSlice	^#(22 #(#(#{Kernel.UserMessage} #key: #ItemAxis #defaultString: 'Item - Axis' #catalogID: #BGOK) #defaultDialogSpec nil #xAxis))</body><body package="BGOK">itemScaleSlice	^#(25 #(#(#{Kernel.UserMessage} #key: #ItemScale #defaultString: 'Item - Scale' #catalogID: #BGOK) #defaultPropertySpec #ChartScaleSpecModel #xScale))</body><body package="BGOK">legendSlice	^#(19 #(#(#{Kernel.UserMessage} #key: #Legend #defaultString: 'Legend' #catalogID: #BGOK) #legendDialogSpec))</body><body package="BGOK">notificationSlice	"Empty array means no page!"	^#(1 #())</body><body package="BGOK">optionsSlice	^#(10 #(#(#{Kernel.UserMessage} #key: #Options #defaultString: 'Options' #catalogID: #BGOK) #defaultDialogSpec nil #options))</body><body package="BGOK">validationSlice	"Empty array means no page!"	^#(1 #())</body></methods><methods><class-id>UI.ChartViewSpec class</class-id> <category>private-implementation classes</category><body package="BGOK">writeImplementationClassesToFilename: aFilename	"Write the private implementation classes as binary into the given filename.  They can be reloaded later with the readImplementationClassesFromFilename: message."	"ChartView writeImplementationClassesToFilename: 'bgraph.boss' asFilename"	"| bossFile |	bossFile := BinaryObjectStorage onNew: aFilename writeStream.	bossFile sourceMode: #discard.	[	aBossFile nextPutClasses: 		] ensure: [bossFile close]"</body></methods><methods><class-id>UI.BG_Banner</class-id> <category>rotation/scale</category><body package="BGOK">autoScale	isAutoScaled := true.	scale := nil</body><body package="BGOK">isAutoScaled	^isAutoScaled</body><body package="BGOK">rotation	^rotation</body><body package="BGOK">rotation: anInteger 	"Make the argument anInteger the receiver's rataion. 	anInteger = 0 means unchanged, 1 means clockwise 90 degrees, and so on"	rotation := anInteger.	self flushCaches</body><body package="BGOK">rotationForDisplay	^(rotation odd and: ['ja_*' match: Locale current name])		ifTrue: [0]		ifFalse: [rotation]</body><body package="BGOK">scale	^scale</body><body package="BGOK">scale: aPoint	"Make the argument aPoint the receiver's scale and reset auto scale"	 	scale := aPoint.	isAutoScaled := false.	self flushCaches</body></methods><methods><class-id>UI.BG_Banner</class-id> <category>bounds accessing</category><body package="BGOK">extent: aPoint	"Set the point that represents the width and height of the	receiver"	aPoint ~= extent ifTrue:		[extent := aPoint.		self flushCaches]</body></methods><methods><class-id>UI.BG_Banner</class-id> <category>private</category><body package="BGOK">compose	"Cache the image for displaying the object."	| rot isText |	super compose.	image bounds extent isZero ifTrue: [^self].	rot := self rotationForDisplay.	(rot isZero and: [isAutoScaled not and: [scale = (1 @ 1)]]) 		ifTrue: [^self].	isText := image respondsTo: #text.	(item isKindOf: Image) 		ifFalse: 			[| mask |			mask := Pixmap extent: image extent ceiling.			super displayOn: mask graphicsContext at: Point zero.			image := mask asImage.			mask close].	rot isZero ifFalse: [image := image rotatedByQuadrants: rot].	(isAutoScaled not and: [scale = (1 @ 1)]) 		ifFalse: 			[image := image shrunkenBy: (isAutoScaled 								ifTrue: [image extent / self extent]								ifFalse: [1.0 @ 1.0 / scale])].	"Use an OpaqueImage to subtract background from text"	image := isText 				ifTrue: 					[| shape |					shape := image 								convertToPalette: CoveragePalette monoMaskPalette								renderedBy: NearestPaint new								paintTransfer: 									[:paint | 									paint = ColorValue white 										ifTrue: [CoverageValue transparent]										ifFalse: [CoverageValue opaque]].					OpaqueImage figure: (CachedImage on: image) shape: (CachedImage on: shape)]				ifFalse: [CachedImage on: image]</body><body package="BGOK">composeString	| s s1 |	s := super composeString.	self rotationForDisplay = self rotation		ifFalse:			[s1 := String new writeStream.			s do: [:i | s1 nextPut: i] separatedBy: [s1 cr].			s := s1 contents].	^s</body></methods><methods><class-id>UI.BG_Banner</class-id> <category>initialize-release</category><body package="BGOK">initialize	super initialize.	rotation := 0.	isAutoScaled := true.</body></methods><methods><class-id>UI.BG_Banner</class-id> <category>displaying</category><body package="BGOK">displayOn: aGraphicsContext at: aPoint	"Display the receiver on aGraphicsContext translated by aPoint."	| gc |	item isNil ifTrue: [^self].	gc := aGraphicsContext copy.	self getColorFrom: gc.	extent ~~ nil ifTrue: [gc intersectClip: (self bounds translatedBy: aPoint)].	self image displayOn: gc at: aPoint + (self alignOffset: image)</body></methods><methods><class-id>UI.BG_Banner</class-id> <category>visual properties</category><body package="BGOK">getColorFrom: aGraphicsContext 	| currentForeground |	currentForeground := aGraphicsContext paint.	foregroundColor = currentForeground 		ifFalse: 			[foregroundColor := currentForeground.			self flushCaches]</body></methods><methods><class-id>Examples.BG_EzChart</class-id> <category>data2</category><body package="BGOK">data2	^#(#(100 20 'A')  #(50 30 'B') #(-30 35 'C') #(34 30 'D') #(50 70 'E'))</body></methods><methods><class-id>Examples.BG_EzChart</class-id> <category>data</category><body package="BGOK">data	^#(1 2 3 4)</body></methods><methods><class-id>UI.ChartDataSetSpec</class-id> <category>accessing</category><body package="BGOK">aspect	^aspect</body><body package="BGOK">aspect: aValue	aspect := aValue</body><body package="BGOK">isComputed	^isComputed == true</body><body package="BGOK">isComputed: aValue	isComputed := aValue</body><body package="BGOK">isData	^isData ~= false</body><body package="BGOK">isData: aValue	isData := aValue</body><body package="BGOK">isLabel	^self isData not</body><body package="BGOK">isLabel: aBoolean	self isData: aBoolean not</body><body package="BGOK">look	^look</body><body package="BGOK">look: aValue	look := aValue</body><body package="BGOK">name	^name</body><body package="BGOK">name: aValue	name := aValue</body></methods><methods><class-id>UI.ChartDataSetSpec</class-id> <category>copying</category><body package="BGOK">postCopy	look := look copy</body></methods><methods><class-id>UI.ChartDataSetSpec</class-id> <category>private-interface building</category><body package="BGOK">fromLiteralArrayEncoding: anArray 	super fromLiteralArrayEncoding: anArray.	"At this moment look is encoded as a literal array and has	to be unpacked."	look := look decodeAsLiteralArray</body><body package="BGOK">insertIntoDescriptor: dataDescriptor withBuilder: builder andPrefix: aSymbol	"Transfer the knowledge from spec into the data descriptor. 	aSymbol describes a main data model for the chart view.	Note that while a builder is editing data, access methods are suppressed."	(builder isEditing not and: [aspect notNil])		ifTrue: 			[			| model fullAspect|			fullAspect := self isComputed 					ifTrue: [aspect] 					ifFalse: [aSymbol , ' ', aspect asSymbol].			model := builder aspectAt: fullAspect.			model isNil				ifTrue: [model := builder raiseErrorMessage: (#aspect1pNotFound &lt;&lt; #BGOK &gt;&gt; 'aspect: &lt;1p&gt; not found!') with: fullAspect].			dataDescriptor adaptor: model].	self isData ifFalse: [dataDescriptor holdLabel].	name isNil ifFalse: [dataDescriptor name: name].	look isNil ifFalse: [look insertIntoDescriptor: dataDescriptor]</body><body package="BGOK">simplified	"Check if look spec can be simplified, but never answer nil."	look isNil ifFalse: [look := look simplified]</body></methods><methods><class-id>UI.PieChartOptionsSpec</class-id> <category>accessing</category><body package="BGOK">dataLocation	^dataLocation isNil		ifTrue: [#dataBelow]		ifFalse: [dataLocation]</body><body package="BGOK">dataLocation: aValue	dataLocation := aValue</body><body package="BGOK">doughnutLabel	^doughnutLabel</body><body package="BGOK">doughnutLabel: aValue	doughnutLabel := aValue</body><body package="BGOK">explode	^explode</body><body package="BGOK">explode: aValue	explode := aValue</body><body package="BGOK">lines	^self showLines		ifTrue: [#show]		ifFalse: [#hide]</body><body package="BGOK">lines: aValue	self showLines: aValue = #show</body><body package="BGOK">shape	shape isNil ifTrue: [^#circle].	^shape</body><body package="BGOK">shape: aValue	shape := aValue</body><body package="BGOK">showLines	^showLines == true</body><body package="BGOK">showLines: aValue	showLines := aValue</body><body package="BGOK">sortSlices	"Default is true"	^sortSlices ~= false</body><body package="BGOK">sortSlices: aValue	sortSlices := aValue</body></methods><methods><class-id>UI.PieChartOptionsSpec</class-id> <category>private-interface building</category><body package="BGOK">insertIntoView: aChartView withBuilder: builder 	"Insert optional parameters into a pie chart view"	shape isNil		ifFalse: 			[shape == #circle ifTrue: [aChartView beCircle].			shape == #ellipse ifTrue: [aChartView beEllipse]].	doughnutLabel isNil ifFalse: [aChartView doughnutLabel: doughnutLabel].	explode isNil		ifFalse: 			[| lbls |			lbls := self getStringFrom:  explode with: builder.			lbls isNil ifFalse: [aChartView explode: lbls]].	dataLocation isNil		ifFalse: 			[| sym |			sym := dataLocation.			sym == #hideData ifFalse: [self showLines ifTrue: [sym := (sym , #WithLine) asSymbol]].			aChartView perform: sym].	self sortSlices isNil		ifFalse: 			[aChartView sortSlices: sortSlices].</body></methods><methods><class-id>UI.PieChartOptionsSpec class</class-id> <category>private-interface building</category><body package="BGOK">addBindingsTo: env for: inst channel: aChannel	super addBindingsTo: env for: inst channel: aChannel.	env at: #shape put: (self adapt: inst forAspect: #shape channel: aChannel).	env at: #explode put: (self adapt: inst forAspect: #explode channel: aChannel).	env at: #dLabel put: (self adapt: inst forAspect: #doughnutLabel channel: aChannel).	env at: #dataLocation put: (self adapt: inst forAspect: #dataLocation channel: aChannel).	env at: #lines put: (self adapt: inst forAspect: #lines channel: aChannel).</body></methods><methods><class-id>UI.BG_ChartElement</class-id> <category>accessing</category><body package="BGOK">drawLine: aBoolean	stroke := aBoolean</body><body package="BGOK">fillInside: aBoolean	fill := aBoolean and: [self geometric canBeFilled]</body><body package="BGOK">lineWidth	"Answer the width of the line used for rendering this object"	^lineWidth</body><body package="BGOK">lineWidth: aNumber	"Set the width of the line used for rendering this object"	lineWidth := aNumber</body><body package="BGOK">shadowOffset: aPoint	shadowOffset := aPoint asPoint</body></methods><methods><class-id>UI.BG_ChartElement</class-id> <category>bounds accessing</category><body package="BGOK">bounds	"Answer the component's bounds."	^self preferredBounds</body></methods><methods><class-id>UI.BG_ChartElement</class-id> <category>testing</category><body package="BGOK">intersects: aRectangle	"Answer whether the receiver's display area intersects aRectangle."	(fill and: [self geometric regionIntersects: aRectangle])		ifTrue:	[^true].	^lineWidth == nil		ifTrue:	[self geometric outlineIntersects: aRectangle]		ifFalse:	[self geometric outlineIntersects: (aRectangle expandedBy: lineWidth+1//2)]</body><body package="BGOK">isPathVisible	^stroke</body></methods><methods><class-id>UI.BG_ChartElement</class-id> <category>initialization</category><body package="BGOK">geometric: aGeometric	"Set aGeometric to be the receiver's geometric."	super geometric: aGeometric.	fill := aGeometric canBeFilled</body><body package="BGOK">initialize	"Set aGeometric to be the receiver's component."	super initialize.	stroke := true.	fill := false.	shadowOffset := 0@0</body></methods><methods><class-id>UI.BG_ChartElement</class-id> <category>displaying</category><body package="BGOK">displayOn: aGraphicsContext 	"Display my component by filling and then stroking it."	| style gc |	lineWidth == nil ifFalse: [aGraphicsContext lineWidth: lineWidth].	style := aGraphicsContext clientDataAt: #chartElement ifAbsent: [].	gc := aGraphicsContext copy.	style == nil		ifTrue: 			[style := self lookPreferences.			style setForegroundColor: aGraphicsContext paint].	shadowOffset = (0 @ 0)		ifFalse: 			[gc translateBy: shadowOffset.			gc paint: (style selectionBackgroundColor ifNil: [SymbolicPaint selectionBackground]).			fill ifTrue: [self geometric displayFilledOn: gc].			stroke ifTrue: [self geometric displayStrokedOn: gc]].	fill		ifTrue: 			[gc paint: (style backgroundColor ifNil: [SymbolicPaint background]).			self fillOn: gc style: style].	(stroke and: [style lineStyle ~= #none])		ifTrue: 			[gc paint: (style foregroundColor ifNil: [SymbolicPaint foreground]).			self strokeOn: gc style: style]</body><body package="BGOK">fillOn: aGraphicsContext style: style 	"Display my component by filling it."	((style respondsTo: #fillMask) not or: [style fillMask == nil])		ifTrue: [self geometric displayFilledOn: aGraphicsContext]		ifFalse: 			[| mask gc rect |			rect := self bounds rounded.			(rect width &gt; 0 and: [rect height &gt; 0])				ifTrue: 					[mask := Mask extent: rect extent.					gc := mask graphicsContext.					gc translateBy: rect origin negated.					gc paint: style fillMask asPattern.					self geometric displayFilledOn: gc.					mask displayOn: aGraphicsContext at: rect origin.					mask close]]</body><body package="BGOK">lookPreferences	^BG_ChartElementLook from: super lookPreferences</body><body package="BGOK">strokeDottedOn: aGraphicsContext style: style	"Display my component by stroking it."	| p1 p2 p3 theta lineStyle path |	lineStyle := style lineStyle.	path := self geometric asPolyline vertices.	self displayDottedPolyline: path on: aGraphicsContext using: lineStyle.	((self geometric isKindOf: EllipticalArc) and: [self geometric sweepAngle abs &lt; 360])		ifFalse:	[^self].	p2 := self geometric center.	theta := self geometric startAngle degreesToRadians.	p1 := theta cos@theta sin * self geometric radiusAsPoint + p2.	theta := (self geometric startAngle + self geometric sweepAngle) degreesToRadians.	p3 := theta cos@theta sin * self geometric radiusAsPoint + p2.	self displayDottedPolyline: (Array with: p1 with: p2 with: p3) on: aGraphicsContext using: lineStyle.</body><body package="BGOK">strokeOn: aGraphicsContext style: style	"Display my component by stroking it."	| p1 p2 p3 theta |	style lineStyle == nil ifFalse: [^self strokeDottedOn: aGraphicsContext style: style].	self geometric displayStrokedOn: aGraphicsContext.	((self geometric isKindOf: EllipticalArc) and: [self geometric sweepAngle abs &lt; 360])		ifFalse:	[^self].	p2 := self geometric center.	theta := self geometric startAngle degreesToRadians.	p1 := theta cos@theta sin * self geometric radiusAsPoint + p2.	theta := (self geometric startAngle + self geometric sweepAngle) degreesToRadians.	p3 := theta cos@theta sin * self geometric radiusAsPoint + p2.	(Polyline vertices: (Array with: p1 with: p2 with: p3))		displayStrokedOn: aGraphicsContext</body></methods><methods><class-id>UI.BG_ChartElement</class-id> <category>private</category><body package="BGOK">displayDottedPolyline: pointArray on: aGraphicsContext using: lineStyle	| len count styleSize penDown capDelta |	len := 0.	count := 0.	styleSize := lineStyle size.	capDelta := aGraphicsContext capStyle = GraphicsContext capButt ifTrue: [0] ifFalse: [aGraphicsContext lineWidth].	penDown := false.	1 to: pointArray size -1 do: [:i | 		| lineLength lineAngle originX originY stepX stepY p1 p2 dash startPoint endPoint |		startPoint := pointArray at: i.		endPoint := pointArray at: i + 1.		(lineLength := startPoint dist: endPoint) = 0.0 ifFalse:			[originX := startPoint x.			originY := startPoint y.			lineAngle := (endPoint - startPoint) theta.			stepX := lineAngle cos.			stepY := lineAngle sin.			len &lt;= lineLength 				ifTrue:					[len = 0 						ifTrue: [p1 := startPoint]						ifFalse:							[p1:= Point x: (originX + (stepX * len)) rounded y: (originY + (stepY * len)) rounded.							penDown ifTrue: [aGraphicsContext displayLineFrom: startPoint to: p1]].					[| index |					index := (count := count + 1) - 1 \\ styleSize + 1.					penDown := index odd.					len := len + (dash := (lineStyle at: index) + (penDown ifTrue: [0] ifFalse: [capDelta])).					len &lt;= lineLength]						whileTrue: 							[penDown								ifTrue: 									[p2 := Point x: (p1 x + (stepX * dash)) rounded y: (p1 y + (stepY * dash)) rounded.									aGraphicsContext displayLineFrom: p1 to: p2]								ifFalse: [p2 := Point x: (originX + (stepX * len)) rounded y: (originY + (stepY * len)) rounded].							p1 := p2]]				ifFalse: [p1 := startPoint].			penDown ifTrue: [aGraphicsContext displayLineFrom: p1 to: endPoint].			len := (len - lineLength) rounded]]</body></methods><methods><class-id>UI.BG_ChartElement</class-id> <category>component protocol suppression</category><body package="BGOK">preferredBounds	"Answer the component's preferredBounds."	^(self geometric isKindOf: EllipticalArc)		ifTrue: [super preferredBounds merge: (self geometric center extent: 0@0)]		ifFalse: [super preferredBounds]</body></methods><methods><class-id>UI.BG_ChartElement class</class-id> <category>line style constants</category><body package="BGOK">broken	^#[6 4 4 4 6]</body><body package="BGOK">broken2	^#[10 4 4 4 4 4 10]</body><body package="BGOK">dashed	^#[4 2 4]</body><body package="BGOK">dashed2	^#[8 4 8]</body><body package="BGOK">dotted	^#[2 4 2]</body><body package="BGOK">dotted2	^#[4 8 4]</body><body package="BGOK">none	^#none</body><body package="BGOK">solid	^nil</body></methods><methods><class-id>UI.BG_ChartElement class</class-id> <category>class initialization</category><body package="BGOK">initialize	"BG_ChartElement initialize"	self initializePatterns.	self initializeShades</body><body package="BGOK">initializePatterns	"BG_ChartElement initializePatterns"	Patterns := OrderedCollection new.	Patterns add: #[255 255 255 255 255 255 255 255].	Patterns add: #[0 0 0 0 0 0 0 0].	Patterns add: #[85 85 85 85 85 85 85 85].	Patterns add: #[51 51 51 51 51 51 51 51].	Patterns add: #[255 68 68 68 255 68 68 68].	Patterns add: #[8 8 8 8 255 8 8 8].	Patterns add: #[17 136 68 34 17 136 68 34].	Patterns add: #[68 136 17 34 68 136 17 34].	Patterns add: #[16 32 64 128 1 2 4 8].	Patterns add: #[193 224 112 56 28 14 7 131].	Patterns add: #[224 193 131 7 14 28 56 112].	Patterns add: #[12 18 33 192 192 33 18 12].	Patterns add: #[130 68 40 16 40 68 130 1].	Patterns add: #[0 255 0 255 0 255 0 255].	Patterns add: #[221 221 221 221 221 221 221 221 ].	Patterns add: #[255 255 0 255 255 255 0 255 ].	Patterns add: #[63 63  63 63   63 63  63 63  ].	Patterns add: #[255 255 0 255 255 255 255 255].	Patterns add: #[0 0 255 255 0 0 255 255].	Patterns add: #[187 187 0 187 187 187 0 187].	Patterns add: #[247 247 0 247 247 247 247 247].	Patterns add: #[187 221 238 119 187 221 238 119 ].	Patterns add: #[238 221 187 119 238 221 187 119 ].	Patterns add: #[239 247 251 253 254 127 191 223].	Patterns add: #[191 127 254 253 251 247 239 223].	Patterns add: #[204 102 51 153 204 102 51 153].	Patterns add: #[51 102 204 153 51 102 204 153].	Patterns add: #[222 63 63 222 237 243 243 237].	Patterns add: #[215 239 215 187 125 254 125 187].	Patterns add: #[2 2 32 32 2 2 32 32 ].	Patterns add: #[68 136 17 0 68 136 17 0].	Patterns add: #[120 120 120 120 135 135 135 135].	Patterns add: #[127 62 28 8 0 8 28 62 ].	Patterns add: #[27 24 129 177 54 6 96 99].	Patterns add: #[2 4 8 16 32 80 136 5 ].	Patterns add: #[255 4 4 4 255 64 64 64].	Patterns add: #[32 64 128 0 8 4 2 0].	Patterns add: #[15 30 36 66 225 240 72 132].	Patterns add: #[227 197 136 92 62 29 136 209].	Patterns add: #[68 68 40 16 1 130 68 68 ].	Patterns add: #[17 34 68 136 136 68 34 17].	Patterns add: #[17 0 16 0 85 0 16 0 ].	Patterns add: #[32 32 80 143 2 2 5 248 ].	Patterns add: #[187 76 124 124 187 196 199 199].	Patterns add: #[64 160 0 0 4 10 0 0].	Patterns add: #[0 0 153 0 0 0 102 0].	Patterns add: #[0 34 17 136 0 34 17 136].	Patterns add: #[51 204 204 51 51 204 204 51].	Patterns add: #[20 8 0 8 20 42 85 42 ].	Patterns add: #[8 128 16 2 64 4 32 1].	Patterns add: #[8 4 2 3 132 72 48 16 ].	Patterns add: #[251 251 0 191 191 191 0 251 ].	Patterns add: #[16 16 40 68 147 68 40 16].	Patterns add: #[8 16 32 64 168 85 255 4 ].	Patterns add: #[65 127 239 40 239 111 111 127 ].	Patterns add: #[32 32 170 5 2 2 170 80 ].	Patterns add: #[36 24 129 66 36 24 129 66 ].	Patterns add: #[32 32 96 144 9 6 129 64 ].	Patterns add: #[52 44 190 125 190 125 52 44 ].	Patterns add: #[85 0 68 10 17 160 68 0 ].	Patterns add: #[11 11 251 0 251 251 11 11].	Patterns add: #[128 8 0 0 32 2 0 0 ].	Patterns add: #[69 8 164 64 42 132 72 128 ].	Patterns add: #[170 68 170 17 170 68 170 17 ].	Patterns add: #[17 164 74 136 37 72 163 68 ].	Patterns add: #[0 9 64 4 1 16 128 36 ].	Patterns add: #[0 85 1 85 1 85 1 127 ].	Patterns add: #[63 33 33 63 243 18 18 243 ].		Patterns add: #[4 168 4 34 1 168 1 34 ].	Patterns add: #[16 8 4 2 21 170 255 32 ].	Patterns add: #[239 238 254 130 254 238 239 40 ].	Patterns add: #[4 164 85 170 4 4 4 4 ].	Patterns add: #[239 123 255 222 247 127 223 253 ].	Patterns add: #[223 186 223 238 247 186 247 238 ].	Patterns add: #[175 250 246 175 123 238 191 234].	Patterns add: #[125 238 255 170 255 238 215 187 ].</body><body package="BGOK">initializePatterns_Orig	"BG_ChartElement initializePatterns"	Patterns := OrderedCollection new.	Patterns add: #[255 255 255 255 255 255 255 255].	Patterns add: #[0 0 0 0 0 0 0 0].	Patterns add: #[85 85 85 85 85 85 85 85].	Patterns add: #[34 34 34 34 34 34 34 34].	Patterns add: #[255 0 0 0 255 0 0 0].	Patterns add: #[128 128 128 128 128 128 128 128].	Patterns add: #[0 0 0 0 255 0 0 0].	Patterns add: #[51 51 51 51 51 51 51 51].	Patterns add: #[255 68 68 68 255 68 68 68].	Patterns add: #[8 8 8 8 255 8 8 8].	Patterns add: #[17 136 68 34 17 136 68 34].	Patterns add: #[68 136 17 34 68 136 17 34].	Patterns add: #[64 32 16 8 4 2 1 128].	Patterns add: #[16 32 64 128 1 2 4 8].	Patterns add: #[193 224 112 56 28 14 7 131].	Patterns add: #[224 193 131 7 14 28 56 112].	Patterns add: #[12 18 33 192 192 33 18 12].	Patterns add: #[130 68 40 16 40 68 130 1].	Patterns add: #[0 255 0 255 0 255 0 255].	Patterns add: #[221 221 221 221 221 221 221 221 ].	Patterns add: #[255 255 0 255 255 255 0 255 ].	Patterns add: #[127 127 127 127 127 127 127 127].	Patterns add: #[255 255 0 255 255 255 255 255].	Patterns add: #[0 0 255 255 0 0 255 255].	Patterns add: #[187 187 0 187 187 187 0 187].	Patterns add: #[247 247 0 247 247 247 247 247].	Patterns add: #[187 221 238 119 187 221 238 119 ].	Patterns add: #[238 221 187 119 238 221 187 119 ].	Patterns add: #[239 247 251 253 254 127 191 223].	Patterns add: #[191 127 254 253 251 247 239 223].	Patterns add: #[204 102 51 153 204 102 51 153].	Patterns add: #[51 102 204 153 51 102 204 153].	Patterns add: #[222 63 63 222 237 243 243 237].	Patterns add: #[215 239 215 187 125 254 125 187].	Patterns add: #[2 2 32 32 2 2 32 32 ].	Patterns add: #[68 136 17 0 68 136 17 0].	Patterns add: #[120 120 120 120 135 135 135 135].	Patterns add: #[127 62 28 8 0 8 28 62 ].	Patterns add: #[27 24 129 177 54 6 96 99].	Patterns add: #[2 4 8 16 32 80 136 5 ].	Patterns add: #[255 4 4 4 255 64 64 64].	Patterns add: #[32 64 128 0 8 4 2 0].	Patterns add: #[15 30 36 66 225 240 72 132].	Patterns add: #[227 197 136 92 62 29 136 209].	Patterns add: #[68 68 40 16 1 130 68 68 ].	Patterns add: #[17 34 68 136 136 68 34 17].	Patterns add: #[17 0 16 0 85 0 16 0 ].	Patterns add: #[32 32 80 143 2 2 5 248 ].	Patterns add: #[187 76 124 124 187 196 199 199].	Patterns add: #[64 160 0 0 4 10 0 0].	Patterns add: #[0 0 153 0 0 0 102 0].	Patterns add: #[0 34 17 136 0 34 17 136].	Patterns add: #[51 204 204 51 51 204 204 51].	Patterns add: #[20 8 0 8 20 42 85 42 ].	Patterns add: #[8 128 16 2 64 4 32 1].	Patterns add: #[8 4 2 3 132 72 48 16 ].	Patterns add: #[251 251 0 191 191 191 0 251 ].	Patterns add: #[16 16 40 68 147 68 40 16].	Patterns add: #[8 16 32 64 168 85 255 4 ].	Patterns add: #[65 127 239 40 239 111 111 127 ].	Patterns add: #[32 32 170 5 2 2 170 80 ].	Patterns add: #[36 24 129 66 36 24 129 66 ].	Patterns add: #[32 32 96 144 9 6 129 64 ].	Patterns add: #[52 44 190 125 190 125 52 44 ].	Patterns add: #[85 0 68 10 17 160 68 0 ].	Patterns add: #[11 11 251 0 251 251 11 11].	Patterns add: #[128 8 0 0 32 2 0 0 ].	Patterns add: #[69 8 164 64 42 132 72 128 ].	Patterns add: #[170 68 170 17 170 68 170 17 ].	Patterns add: #[17 164 74 136 37 72 163 68 ].	Patterns add: #[0 9 64 4 1 16 128 36 ].	Patterns add: #[0 85 1 85 1 85 1 127 ].	Patterns add: #[63 33 33 63 243 18 18 243 ].		Patterns add: #[4 168 4 34 1 168 1 34 ].	Patterns add: #[16 8 4 2 21 170 255 32 ].	Patterns add: #[239 238 254 130 254 238 239 40 ].	Patterns add: #[4 164 85 170 4 4 4 4 ].	Patterns add: #[239 123 255 222 247 127 223 253 ].	Patterns add: #[223 186 223 238 247 186 247 238 ].	Patterns add: #[175 250 246 175 123 238 191 234].	Patterns add: #[125 238 255 170 255 238 215 187 ].</body><body package="BGOK">initializeShades	"BG_ChartElement initializeShades"	ShadeMaker := OrderedDither order: 6</body></methods><methods><class-id>UI.BG_ChartElement class</class-id> <category>shades and patterns</category><body package="BGOK">patternAt: anInteger	"BG_ChartElement patternAt: 33"	^self patternAt: anInteger palette: CoveragePalette monoMaskPalette</body><body package="BGOK">patternAt: anInteger palette: aDepth1Palette 	"BG_ChartElement patternAt: 20 palette: (MappedPalette with: ColorValue red with: 	ColorValue blue)"	^Image		extent: 8 @ 8		depth: 1		palette: aDepth1Palette		bits: (Patterns at: anInteger - 1 \\ Patterns size + 1)		pad: 8</body><body package="BGOK">patternsSize	^Patterns size</body><body package="BGOK">shadeAt: anInteger 	"BG_ChartElement shadeAt: 33"	| size index gc |	size := self shadesSize.	index := anInteger - 1 \\ size + 1.	gc := (Image				extent: ShadeMaker extent				depth: CoveragePalette monoMaskPalette depth				palette: CoveragePalette monoMaskPalette) asRetainedMedium graphicsContext.	gc paintPolicy: ((PaintPolicy new) imageRenderer: ShadeMaker; paintRenderer: ShadeMaker).	gc paint: (CoverageValue coverage: index - 1 / (size - 1)).	gc displayRectangle: (0 @ 0 extent: ShadeMaker extent).	^gc medium asImage</body><body package="BGOK">shadesSize	^ShadeMaker uniformRangeLevels</body></methods><methods><class-id>UI.BG_ChartDataSetDescription</class-id> <category>accessing</category><body package="BGOK">adaptor	^adaptor</body><body package="BGOK">adaptor: aValue	adaptor := aValue</body><body package="BGOK">backgroundColor	^backgroundColor</body><body package="BGOK">backgroundColor: aValue	backgroundColor := aValue</body><body package="BGOK">foregroundColor	^foregroundColor</body><body package="BGOK">foregroundColor: aValue	foregroundColor := aValue</body><body package="BGOK">hasData		^hasData</body><body package="BGOK">hasData: aValue	hasData := aValue</body><body package="BGOK">hasLabel		^hasData not</body><body package="BGOK">holdData		hasData := true.</body><body package="BGOK">holdLabel		hasData := false.</body><body package="BGOK">lineType	^lineType</body><body package="BGOK">lineType: aValue	lineType := aValue</body><body package="BGOK">lineWidth	^lineWidth</body><body package="BGOK">lineWidth: aValue	lineWidth := aValue</body><body package="BGOK">markerType	^markerType</body><body package="BGOK">markerType: aValue	markerType := aValue</body><body package="BGOK">name	^name</body><body package="BGOK">name: aString	name := aString</body><body package="BGOK">pattern	^pattern</body><body package="BGOK">pattern: aValue	pattern := aValue</body></methods><methods><class-id>UI.BG_ChartDataSetDescription</class-id> <category>initalize-release</category><body package="BGOK">initialize		name := ''.	self holdData</body><body package="BGOK">release	self adaptor isNil		ifFalse: [self adaptor releaseParts].	super release</body></methods><methods><class-id>UI.BG_ChartDataSetDescription class</class-id> <category>instance-creation</category><body package="BGOK">new	^super new initialize</body></methods><methods><class-id>UI.BG_BandChartView</class-id> <category>private</category><body package="BGOK">compose	super compose.	self composeData</body><body package="BGOK">composeData	| rdata values |	values := self data.	rdata := BG_TableAdaptor columns: values columnSize rows: values rowSize.	1 to: values columnSize do:		[:x | rdata columnAt: x put: (self rates: (values columnAt: x))].	rates := rdata.</body></methods><methods><class-id>UI.BG_BandChartView</class-id> <category>displaying</category><body package="BGOK">displayDataOn: aGraphicsContext 	| value images angle savedData isP gc |	dataLocation = #outside		ifTrue: 			[savedData := self data.			self data: self sortedValues.			value := self data collect: [:v| 100].						gc := aGraphicsContext copy.			images := dataStyle individualImages.			angle := self defaultDataAngle.			1 to: value columnSize				do: 					[:i | 					| n |					n := sortedIndex at: i.					1 to: value rowSize						do: 							[:y | 							| v |							v := value at: n @ y.							self								displayLabel: (images at: n @ y)								angle: angle								offset: (self defaultDataOffset: v offset: 4)								alignment: (self defaultDataAlignment: v)								on: gc								at: (grid applyTo: i @ v) rounded]].			self data: savedData]		ifFalse: 			[value := rates collect: [:r | r * 100].			(isP := self isPercentage)				ifTrue: 					[savedData := self data.					self data: self rates].			gc := aGraphicsContext copy.			images := dataStyle individualImages.			angle := self defaultDataAngle.			1 to: value columnSize				do: 					[:x | 					| v1 v2 |					v1 := v2 := 0.					1 to: value rowSize						do: 							[:y | 							| n |							n := sortedIndex at: x.							v2 := v1 + (value at: n @ y).							self								displayLabel: (images at: n @ y)								angle: angle								offset: 0 @ 0								alignment: 5								on: gc								at: (grid applyTo: x @ (v2 - v1 / 2 + v1)) rounded.							v1 := v2]].			isP ifTrue: [self data: savedData]]</body><body package="BGOK">displayPlotOn: aGraphicsContext 	| savedItem  savedZero |	savedZero := grid y scale zero.	grid y scale zero: 0.	savedItem := self data.	self data: (rates collect: [:r | r * 100]).	super displayPlotOn: aGraphicsContext.	grid y scale zero: savedZero.	self data: savedItem</body></methods><methods><class-id>UI.BG_BandChartView</class-id> <category>initialize-release</category><body package="BGOK">initialize	super initialize.	grid y manualScale.	showLink := false</body></methods><methods><class-id>Examples.BG_Sales</class-id> <category>sales</category><body package="BGOK">sales 	^sales</body></methods><methods><class-id>Examples.BG_Sales</class-id> <category>initialize</category><body package="BGOK">initialize	"Create a ValueHolder containing a list of sales items."		| item |	super initialize.	sales := List new.	item := BG_SalesItem new.	item month: 'Oct'; salesWin: 16; salesMac: 5.	sales add: item.	item := BG_SalesItem new.	item month: 'Nov'; salesWin: 35; salesMac: 15.	sales add: item.	item := BG_SalesItem new.	item month: 'Dec'; salesWin: 56; salesMac: 5.	sales add: item.	sales := sales asValue.</body></methods><methods><class-id>UI.BG_StackedLineChartView</class-id> <category>private</category><body package="BGOK">dataRangeMatrix	| matrix value |	value := self data.	matrix := Array new: value columnSize.	1 to: value columnSize do: [:x | matrix at: x put: ((value columnAt: x) inject: 0 into: [:i :j | i+j])].	^matrix</body></methods><methods><class-id>UI.BG_StackedLineChartView</class-id> <category>displaying</category><body package="BGOK">displayDataOn: aGraphicsContext	| value images angle ofs gc |	value := self data.	gc := aGraphicsContext copy.	images := dataStyle individualImages.	angle := self defaultDataAngle.	ofs := 7.	1 to: value columnSize do: 		[:x | | v | 			v := 0.			1 to: value rowSize do: 			[:y | | n |			n := sortedIndex at: x.			v := v + (value at: n@y).			grid 				displayLabel: (images at: n@y)				angle: angle 				offset: (self defaultDataOffset: v offset: ofs)				alignment: (self defaultDataAlignment: v)				on: gc 				at: (grid applyTo: x@v) rounded]]</body><body package="BGOK">displayPlotOn: aGraphicsContext	| value points collection   |	value := self data.	points := BG_TableAdaptor columns: value columnSize rows: value rowSize.	1 to: value columnSize do: 		[:x | 			| n v |			n := sortedIndex at: x.			v := 0.			1 to: value rowSize do: 				[:y | points at: x @y put: x@(v := v + (value at: n@y))]].	collection := grid applyToValues: points.	1 to: value rowSize do: 		[:y | self			displayLineAndMarkerOn: aGraphicsContext			at: y			points: (collection rowAt: y)]</body></methods><methods><class-id>UI.BG_StackedLineChartView</class-id> <category>private-default-model</category><body package="BGOK">defaultNbrOfSeries	^2</body><body package="BGOK">defaultPointFor: aValue column: aColumn range: aRange 	| val |	val := (aColumn = 1		ifTrue: [aValue]		ifFalse: [aValue &gt; 0				ifTrue: [aRange last - aValue / aColumn]				ifFalse: [aRange first - aValue / aColumn]]).	^val abs &gt; 2 ifTrue: [val asInteger] ifFalse: [val asFloat]</body></methods><methods><class-id>UI.BG_ParatoChartView</class-id> <category>private</category><body package="BGOK">composeGrid	| insetArea max bounds | 	super composeGrid.	bounds := grid insetBounds.	auxGrid x: grid x.	auxGrid x scale reverse.	auxGrid bounds: self plotArea.	auxGrid x scale reverse.	insetArea := bounds intersect: auxGrid insetBounds.	grid insetBounds: insetArea.	auxGrid insetBounds: insetArea.	max := self max: self dataRangeMatrix.	auxGrid transposed		ifTrue: [auxGrid y scale destMin: auxGrid y scale destMin max: (grid y scale applyTo: max)]		ifFalse: [auxGrid y scale destMin: (grid y scale applyTo: max) max: auxGrid y scale destMax]</body><body package="BGOK">dataRangeMatrix	^Array with: 0 with: (self sum: self data)</body></methods><methods><class-id>UI.BG_ParatoChartView</class-id> <category>grid</category><body package="BGOK">auxGrid	^auxGrid</body><body package="BGOK">transpose	super transpose.	auxGrid transpose.	auxGrid y scale reverse</body></methods><methods><class-id>UI.BG_ParatoChartView</class-id> <category>labels</category><body package="BGOK">labels: collectionOfStrings	super labels: collectionOfStrings.	auxGrid x labels: labels copy</body></methods><methods><class-id>UI.BG_ParatoChartView</class-id> <category>initialize-release</category><body package="BGOK">initialize	super initialize.	other := 'others'.	barWidth := 1.0.	auxGrid := BG_ChartGrid new.	auxGrid x itemAxis.	auxGrid y fixedDataAxis.	auxGrid y scale: (BG_ChartScale min: 0 max: 1 by: 0.5 from: 0 div: 5) decrease.	auxGrid y labelsStyle percent; integer</body><body package="BGOK">newGraphicsDevice: aGraphicsDevice	super newGraphicsDevice: aGraphicsDevice.	auxGrid newGraphicsDevice: aGraphicsDevice.</body></methods><methods><class-id>UI.BG_ParatoChartView</class-id> <category>displaying</category><body package="BGOK">displayAxisOn: aGraphicsContext 	| gc |	gc := aGraphicsContext copy.	super displayAxisOn: gc.	auxGrid x scale reverse.	auxGrid transposed		ifTrue: 			[auxGrid displayHAxisOn: aGraphicsContext.			auxGrid displayHLabelsOn: aGraphicsContext]		ifFalse: 			[auxGrid displayVAxisOn: aGraphicsContext.			auxGrid displayVLabelsOn: aGraphicsContext].	auxGrid x scale reverse</body><body package="BGOK">displayDataOn: aGraphicsContext	| value images angle rates isP gc base | 	value := self data.	base := grid y scale zero.	rates := self rates: value.	(isP := self isPercentage) ifTrue: [self data: (self roundedRates: rates)].	gc := aGraphicsContext copy.	images := dataStyle individualImages.	angle := self defaultDataAngle.	1 to: value columnSize do: 		[: i | 			| n v py |			n := sortedIndex at: i.			v := value at: n@1.			py := dataLocation = #outside ifTrue: [v ] ifFalse: [base + (v - base // 2) ].			self 				displayLabel: (images at: n@1)				angle: angle 				offset: (self defaultDataOffset: v offset: 4)				alignment: (self defaultDataAlignment: v)				on: gc 				at: (grid applyTo: i@(py)) rounded].	isP ifTrue: [self data: value].</body><body package="BGOK">displayPlotOn: aGraphicsContext 	| value points collection sum k | 	sum := self sum: self data.	value := self data.	super displayPlotOn: aGraphicsContext.	points := Array new: value columnSize + 1.	points at: 1 put: 0.5 @ (k := 0).	1 to: value columnSize do: 		[:i | 		| n |		n := sortedIndex at: i.		points at: i + 1 put: i +0.5@ (k := k + ((value at: n@1) / sum))].	collection := auxGrid applyToValues: points.	(Polyline vertices: collection)		asStroker displayOn: aGraphicsContext</body></methods><methods><class-id>Tools.ChartDataSpecModel</class-id> <category>private</category><body package="BGOK">buildSeriesMenu	"Answer a menu containing names of the defined data series.	Values correspond to indexes in the series collection.	If the menu is empty answer a menu with only one item	containing 'Empty-&gt;1'."	| mb series |	series := specChannel value series.	mb := MenuBuilder new.	series isNil		ifTrue: [mb add: (#Empty &lt;&lt; #BGOK &gt;&gt; 'Empty') -&gt; 1]		ifFalse: [1 to: series size				do: 					[:i | 					| nm s |					s := series at: i.					nm := s name. 					(nm isNil or: [nm isEmpty]) ifTrue: [nm := s aspect isNil									ifTrue: ['']									ifFalse: [s aspect printString]].					mb add: nm -&gt; i]].	^mb menu</body><body package="BGOK">checkForDoubleLabel	| coll | 	coll := specChannel value labelSeries.	coll size &gt; 1		ifTrue: 			[| name series index res | 			coll remove: selectedIndex value.			index := coll asArray first.			series := specChannel value seriesAt: index.			(name := series name) isNil ifTrue: 				[name := series aspect isNil					 ifFalse: [series aspect printString]					 ifTrue: ['#' , index printString]].			res := Dialog						choose: ((#GenKey3 &lt;&lt; #BGOK &gt;&gt; 'The chart can only have one data series defining labels.&lt;n&gt;There is already a series &lt;1s&gt; marked as a label.&lt;nn&gt;You can cancel the last operation by pressing Cancel or&lt;n&gt;remove the &lt;2s&gt; series by pressing Remove.')			expandMacrosWith: name			with: name)						labels: (Array with: (#Cancel &lt;&lt; #BGOK &gt;&gt; 'Cancel') with: (#Remove &lt;&lt; #BGOK &gt;&gt; 'Remove'))						values: #(#cancel #remove )						default: #cancel						for: builder window.			res == #remove				ifTrue: 					[specChannel value deleteSeriesAt: index.					self updateMenuButton.]				ifFalse: [isLabel value: false]]</body><body package="BGOK">newSeriesName	"A name of selected series has changed, update	the menu button."	self updateMenuButton</body><body package="BGOK">redefinedAspect	"Refresh the menu button if the name is empty."	self updateMenuButton.	selectedIndex value: selectedIndex value</body><body package="BGOK">redefinedName	"Refresh the menu button."	selectedIndex value: selectedIndex value</body><body package="BGOK">seriesDefined	"Answer true if at least one series is defined."	^specChannel value series notNil</body><body package="BGOK">updateDialog	"Check the number of series and disable or enable fields in the	property dialog."	| list |	self updateMenuButton.	list := #(#dataSeriesMenuButton #deleteButton #nameField #aspectField #labelCheckBox #colorToolButton #lineLookToolButton #regionLookToolButton #computedCheckBox #aspectLabel #nameLabel).	self seriesDefined		ifTrue: [list do: [:sym | (builder componentAt: sym) enable]]		ifFalse: [list do: [:sym | (builder componentAt: sym) disable]]</body><body package="BGOK">updateMenuButton	"Build a new menu to reflect changes in the series."	self dataSeriesMenu value: self buildSeriesMenu.</body><body package="BGOK">updateSeriesLookButtons	"The status of label button has changed. Action buttons controlling the look 	of a data series are enabled or disabled.	Do nothing if no series is defined."	| list comp | 	self  seriesDefined ifFalse: [^self].	list := #(#colorToolButton #lineLookToolButton #regionLookToolButton ).	self isLabel value		ifTrue: [list do: [:sym | (comp := builder componentAt: sym) notNil ifTrue: [comp disable]]]		ifFalse: [list do: [:sym | (comp := builder componentAt: sym) notNil ifTrue: [comp enable]]]</body></methods><methods><class-id>Tools.ChartDataSpecModel</class-id> <category>aspects</category><body package="BGOK">dataSeries	^selectedIndex</body><body package="BGOK">dataSeriesMenu	"Answer a value holder with a menu containing names of the defined data series.	Values correspond to indexes in the series collection.	The delayed initalization is necessary, because an instance 	is created when the specChannel is unknown."	menuHolder isNil ifTrue: [menuHolder := self buildSeriesMenu asValue].	^menuHolder</body><body package="BGOK">isComputed	"Answers true when the selected series is described by the block closure."	^isComputed.</body><body package="BGOK">isLabel	"Answers true when the selected series is a label"	^isLabel.</body><body package="BGOK">seriesAspect	^seriesAspect</body><body package="BGOK">seriesName	^seriesName</body></methods><methods><class-id>Tools.ChartDataSpecModel</class-id> <category>interface opening</category><body package="BGOK">postBuildWith: aBuilder 	"Updates the state of the input fields in order to initially disable some	of them."	super postBuildWith: aBuilder.	self updateSeriesLookButtons.	self updateDialog.	"(self builder componentAt: #newSeriesButton) takeKeyboardFocus"</body><body package="BGOK">preBuildWith: aBuilder 	"Update the selection index. This refreshes the data from 	selected data series."	selectedIndex value: selectedIndex value.</body></methods><methods><class-id>Tools.ChartDataSpecModel</class-id> <category>updating</category><body package="BGOK">update: anAspectSymbol with: aParameter from: aSender 	"Receive a change notice from a spec channel."	aSender == specChannel		ifTrue: 			[selectedIndex value: 1.			self updateDialog]</body></methods><methods><class-id>Tools.ChartDataSpecModel</class-id> <category>actions</category><body package="BGOK">colorTool	"Pop up a dialog showing the color tool. If the user accepts	the dialog, set background and foreground colors for the 	selected series."	| dialog look in lookPref |	lookPref := LookPreferences new.	in := selectedSeries value.	look := in look copy.	look isNil ifTrue: [look := ChartElementLookSpec new].	dialog := ChartColorTool new.	lookPref setBackgroundColor: look backgroundColor.	lookPref setForegroundColor: look foregroundColor.	dialog lookPreferences: lookPref.	dialog open.	dialog accept value		ifTrue: 			[look backgroundColor: dialog lookPreferences backgroundColor.			look foregroundColor: dialog lookPreferences foregroundColor.			in look: look.			self notifyParent]</body><body package="BGOK">deleteSeries	"Remove a selected series.  Move the selection to the series 	preceding the selected one."	| indx  |	indx := specChannel value deleteSeriesAt: selectedIndex value.	indx isNil ifTrue: [indx := 0].	self updateMenuButton.	indx isZero		ifTrue: 			[selectedIndex value: 1.			self updateDialog]		ifFalse: [selectedIndex value: indx].	self notifyParent.</body><body package="BGOK">lineLookTool	"Pop up a tool (line chooser) for selecting the look of the selected data series."	self lookToolFor: #line</body><body package="BGOK">lookToolFor: lookTypeSymbol	"Pop up a tool (line or pattern chooser) for selecting the look of the selected data series."	| look in |	in := selectedSeries value.	look := in look copy.	look isNil ifTrue: [look := ChartElementLookSpec new].	(look dialogFor: lookTypeSymbol)		ifTrue: 			[in look: look.			self notifyParent]</body><body package="BGOK">newSeries	"Add a new series, then move the selection to the new series."	| indx | 	indx := specChannel value addNewSeriesAfter: selectedIndex value.	self updateDialog.	selectedIndex value: indx.	self notifyParent.</body><body package="BGOK">regionLookTool	"Pop up a tool (fill pattern chooser) for selecting the look of the selected data series"	self lookToolFor: #region</body></methods><methods><class-id>Tools.ChartDataSpecModel</class-id> <category>initialize-release</category><body package="BGOK">initialize	"Initalize instance variables. Leave the specChannel, since it has to 	be initalized from outside. 	Make sure that selectedSeries is synchronized with selectedIndex."	super initialize.	selectedIndex := 1 asValue.	selectedSeries := nil asValue.	seriesName := (AspectAdaptor subjectChannel: selectedSeries)				forAspect: #name.	seriesAspect := (AspectAdaptor subjectChannel: selectedSeries)				forAspect: #aspect.	isLabel := (AspectAdaptor subjectChannel: selectedSeries)				forAspect: #isLabel.	isComputed := (AspectAdaptor subjectChannel: selectedSeries)				forAspect: #isComputed.	selectedIndex compute: [:v | selectedSeries value: (specChannel value seriesAt: v)].	seriesName onChangeSend: #newSeriesName to: self.	isComputed compute: 			[:v | 			self notifyParent].	isLabel		compute: 			[:v | 			self notifyParent.			self updateSeriesLookButtons.			v ifTrue: [self checkForDoubleLabel]]</body></methods><methods><class-id>Tools.ChartDataSpecModel class</class-id> <category>binary storage</category><body package="BGOK">postLoad: aParcel	"The BGOK Parcel includes UIPainter code, but can be loaded with-out the UIPainter	 being present.  If so, ChartViewSpec cannot add it self to the UIPainter's collection	 of Spec types, sicne UIPainter is not present.  When the UIPainter is loaded this class	 can be installed, since it inherits from SpecModel in the UIPainter parcel.  We can	 identify when the UIPainter is being loaded after BGOK since aParcel will be loaded.	 Hence when the UIPainter is loaded after BGOK we reinitialize ChartViewSpec."	super postLoad: aParcel.	aParcel isLoaded ifTrue: [ChartViewSpec postLoad: aParcel]</body></methods><methods><class-id>UI.BG_PieChartView</class-id> <category>accessing</category><body package="BGOK">gridType	"I use a polar grid"	^#polar</body><body package="BGOK">sortSlices	"True is the default"	^sortSlices ~= false</body><body package="BGOK">sortSlices: aValue	sortSlices := aValue</body></methods><methods><class-id>UI.BG_PieChartView</class-id> <category>exploding</category><body package="BGOK">explode	^explode</body><body package="BGOK">explode: anExplodingLabels		explode := anExplodingLabels isString ifTrue: [Array with: anExplodingLabels] ifFalse: [anExplodingLabels]</body></methods><methods><class-id>UI.BG_PieChartView</class-id> <category>shape</category><body package="BGOK">beCircle	isEllipse := false</body><body package="BGOK">beEllipse	isEllipse := true</body><body package="BGOK">isEllipse	^isEllipse</body></methods><methods><class-id>UI.BG_PieChartView</class-id> <category>private</category><body package="BGOK">compose	super compose.	self composeData</body><body package="BGOK">composeData	rates := self rates: self data.</body><body package="BGOK">composeGrid	grid bounds: self plotArea.	grid center: grid center radius: grid radius / 1.5.	isEllipse ifFalse: [grid xyRate: 1.0]</body><body package="BGOK">composeLegend: size	| item |	item := labels asOrderedCollection.	item size &lt; size ifTrue: [item size + 1 to: size do: [:i | item add: nil]].	legend item: item.	self composeLegendFrame: size</body><body package="BGOK">displayLabel: label angle: angle offset: o alignment: al on: gc at: p	dataLocation = #inside ifTrue:		[| gc2 |		gc2 := gc copy.		gc2 paint: self backgroundColor.		gc2 displayRectangle: (grid box: label bounds by: angle origin: o alignment: al) at: p].	grid		displayLabel: label		angle: angle		offset: o		alignment: al		on: gc		at: p</body><body package="BGOK">legendSize	^self data columnSize</body><body package="BGOK">sortedValues	^self data</body></methods><methods><class-id>UI.BG_PieChartView</class-id> <category>private-data-transformation</category><body package="BGOK">dataFromDescriptions	"I can accept only one set of data."	| dataDescr labelDescr |	dataDescr := descriptors detect: [:descr | descr hasData]				ifNone: [BG_ChartDataSetDescription new].	labelDescr := descriptors detect: [:descr | descr hasData not]				ifNone: [nil].	descriptors := labelDescr isNil				ifTrue: [Array with: dataDescr]				ifFalse: [Array with: dataDescr with: labelDescr].	super dataFromDescriptions</body><body package="BGOK">lookFromDescriptions	"Ignore descriptors."</body></methods><methods><class-id>UI.BG_PieChartView</class-id> <category>private-default-model</category><body package="BGOK">defaultDescriptorsFor: unused 	"I use only one data series"	^super defaultDescriptorsFor: 1</body><body package="BGOK">defaultModelFor: dataDescriptor 	"Answer a default model. 	The default model is a List containing arrays. 	Note that the last column cotains labels."	| dataPoints defModel labelIndex dataIndex |	dataDescriptor nbrOfDataSeries &gt; 1		ifTrue: 			[| series first |			first := true.			series := dataDescriptor series select: [:s | s isData ifFalse: [true]							ifTrue: [first									ifTrue: 										[first := false.										true]									ifFalse: [false]]].			dataDescriptor series: series].	dataPoints := 7.	labelIndex := dataDescriptor labelIndex.	dataIndex := labelIndex = 1				ifTrue: [2]				ifFalse: [1].	labelIndex &gt; 0		ifTrue: 			[defModel := Array new: dataPoints.			1 to: dataPoints				do: 					[:i | 					| val |					val := Array new: 2.					val at: labelIndex put: (String with: ($a asInteger - 1 + i) asCharacter).					val at: dataIndex put: i.					defModel at: i put: val]]		ifFalse: 			[defModel := Array new: dataPoints.			1 to: dataPoints do: [:i | defModel at: i put: i]].	^defModel</body></methods><methods><class-id>UI.BG_PieChartView</class-id> <category>legend</category><body package="BGOK">legend: collectionOfStrings	super legend: collectionOfStrings.	self labels: collectionOfStrings</body></methods><methods><class-id>UI.BG_PieChartView</class-id> <category>data</category><body package="BGOK">dataAdjacent	dataLocation := #adjacent</body><body package="BGOK">dataAdjacentWithLine	dataLocation := #adjacentLine</body><body package="BGOK">dataBelow	dataLocation := #below</body><body package="BGOK">dataBelowWithLine	dataLocation := #belowLine</body></methods><methods><class-id>UI.BG_PieChartView</class-id> <category>labels</category><body package="BGOK">doughnutLabel	^doughnutLabel item</body><body package="BGOK">doughnutLabel: aString	doughnutLabel item: aString</body><body package="BGOK">doughnutLabelStyle	^doughnutLabel</body></methods><methods><class-id>UI.BG_PieChartView</class-id> <category>displaying</category><body package="BGOK">displayAxisOn: aGraphicsContext	| withLabel images dimages savedLabels newLabels v isP isZ savedData gc prevRectClt |	self isLegendVisible ifTrue: [^self]. 	isZ := self isZeroSuppress.	(withLabel := self isDataOutside) ifTrue: 		[savedLabels := grid x labels.		images := grid x labels.		(isP := self isPercentage) ifTrue:			[savedData := self data.			self data: (self roundedRates: rates)].		dimages := dataStyle individualImages.		newLabels := Array new: self data columnSize.		1 to: newLabels size do: 			[:i | | n |					n := sortedIndex at: i.				(dataLocation = #adjacent or: [dataLocation = #adjacentLine])					ifTrue: 						[ | labelList |						labelList := BG_IconicLabel icon: ((BG_Label item: (images at: i)) foregroundColor: grid x labelsStyle foregroundColor; yourself) item: ((BG_Label item: (dimages at: n@1)) foregroundColor: dataStyle foregroundColor; yourself).						labelList gap: 4.						labelList alignment: 1.						newLabels at: i put: labelList]					ifFalse:						[ | labelList |						labelList := BG_LabelList item: (Array with: ((BG_Label item: (images at: i)) foregroundColor: grid x labelsStyle foregroundColor; yourself) with: ((BG_Label item: (dimages at: n@1)) foregroundColor: dataStyle foregroundColor; yourself)).						labelList beVertical.						labelList alignment: 2.						newLabels at: i put: labelList]].		grid x labels: newLabels.		grid x scale sourceMin: 0 max: 1].	prevRectClt := OrderedCollection new.	prevRectClt add: (0@0 corner: 0@0).	gc := aGraphicsContext copy.	images := grid x labelsStyle individualImages.	v := 1.0.	rates columnSize to: 1 by: -1 do:		[:i | 			| n r |			r := rates at: (n := sortedIndex at: i)@1.			(isZ and: [r &lt;= 0]) ifFalse:				[| h dl p1 p2 image myBounds |				h := v - (r /2).				dl := #(inside adjacent below adjacentLine belowLine) indexOf: dataLocation.				dl := r  &lt;= 0.1 ifTrue: [#(4 -1 4 5 4 5) at: dl + 1] ifFalse: [dl].				dl = -1 ifFalse: [				(explode notNil and: [explode includes: (labels at: n)]) 					ifTrue: 						[p1 := grid applyTo: h@(dl &gt;= 4 ifTrue: [1.3] ifFalse: [1.2]).						p2 := grid applyTo: h@0.9]					ifFalse: 						[p1 := grid applyTo: h@(dl &gt;= 4 ifTrue: [1.2] ifFalse: [1.0]).						p2 := grid applyTo: h@0.7].				image := images at: i.					dl &gt;= 4 ifTrue:						[[myBounds := p1 rounded + (grid						box: image bounds						by:  (grid theta scale applyTo: h) 						origin: 5@0						alignment: 4) origin extent: image bounds extent.					(prevRectClt select: [:p | p intersects: myBounds]) isEmpty or: [h &lt; 0]]						whileFalse:							[h := h - 0.005.							p1 := (grid applyTo: h@((explode notNil and: [explode includes: (labels at: n)]) 							ifTrue: [dl &gt;= 4 ifTrue: [1.4] ifFalse: [1.3]] ifFalse: [dl &gt;= 4 ifTrue: [1.3] ifFalse: [1.1]])) rounded].					prevRectClt add: myBounds.					(LineSegment from: p1 to: p2) asStroker displayOn: gc].				grid 					displayLabel: image 					angle: (grid theta scale applyTo: h) 					offset: 5@0					alignment: 4  					on: gc 					at: p1 rounded]]. 					v := v - r].	withLabel ifTrue: 		[isP ifTrue: [self data: savedData].		grid x labels: savedLabels.		grid x scale sourceMin: 0 max: 1].</body><body package="BGOK">displayDataOn: aGraphicsContext	| v savedData images image  isP isZ gc prevRectClt |	(self isLegendVisible not and:			[dataLocation ~= #outside and:			[dataLocation ~= #hide]])		ifTrue: [^self].	(isP := self isPercentage) ifTrue:		[savedData := self data.		self data: (self roundedRates: rates)].	isZ := self isZeroSuppress.	prevRectClt := OrderedCollection new.	prevRectClt add: (0@0 corner: 0@0).	v := 1.	gc := aGraphicsContext copy.	images := dataStyle individualImages.	rates columnSize to: 1 by: -1 do:		[:i | 			| n r |			r := rates at: (n := sortedIndex at: i)@1.			(isZ and: [r &lt;=0]) ifFalse:				[| h dl p1 p2 myBounds |				h := v - (r /2).				dl := #(inside adjacent below adjacentLine belowLine) indexOf: dataLocation.				dl := r  &lt;= 0.1 ifTrue: [#[4 4 5 4 5] at: dl] ifFalse: [dl]. 				(explode notNil and: [explode includes: (labels at: n)]) 					ifTrue: [p1 := (grid applyTo: h@(#(0.8 1.2 1.2 1.3 1.3) at: dl)) rounded.							p2 := grid applyTo: h@0.9]					ifFalse: [p1 := (grid applyTo: h@(#(0.6 1.0 1.0 1.2 1.2) at: dl)) rounded.							p2 := grid applyTo: h@0.7].				((dataLocation = #inside and: [r &lt;= 0.1]) and: [self isLegendVisible not])					ifTrue: [ image := BG_IconicLabel icon: ((BG_Label item: (grid x labelsStyle individualImages at: n)) foregroundColor: grid x labelsStyle foregroundColor; yourself) item: ((BG_Label item: (images at: n)) foregroundColor: dataStyle foregroundColor; yourself).							image gap: 4.							image alignment: 1] 					ifFalse: [image := images at: n@1].							dl &gt;= 4 ifTrue:					[[myBounds := p1 rounded + (grid						box: image bounds						by:  (grid theta scale applyTo: h) 						origin: 5@0						alignment: 4) origin  extent: image bounds extent.					(prevRectClt select: [:p | p intersects: myBounds]) isEmpty or: [h &lt; 0]]						whileFalse:							[h := h - 0.005.							p1 := (grid applyTo: h@(((explode notNil and: [explode includes: (labels at: n)]) 								ifTrue: [#(0.8 1.3 1.3 1.4 1.4)] ifFalse: [#(0.6 1.1 1.1 1.3 1.3)]) at: dl)) rounded].					prevRectClt add: myBounds.					(LineSegment from: p1 to: p2)						asStroker displayOn: gc].				self 					displayLabel: image 					angle: (grid theta scale applyTo: h)					offset: (dl = 1 ifTrue: [0@0] ifFalse: [5@0]) 					alignment: (dl = 1 ifTrue: [5] ifFalse: [4])  					on: gc 					at: p1.				v := v - r]].	isP ifTrue: [self data: savedData].</body><body package="BGOK">displayGridLinesOn: aGraphicsContext	^self</body><body package="BGOK">displayPlotOn: aGraphicsContext	| oldAngle newAngle v | 	oldAngle := grid theta scale applyTo: 0.	v := 0.	1 to: rates columnSize do: 		[:i | 		| n ep h gc wedge |		n := (self sortSlices) ifTrue: [sortedIndex at: i] ifFalse: [ i ]. 		(explode notNil and: [explode includes: (labels at: n)]) 			ifTrue:				[h := v + ((rates at: n@1) / 2).				ep := ((grid applyTo: h@0.2) - grid center) rounded]			ifFalse: [ep := 0@0].		v := v + (rates at: n@1).		newAngle := grid theta scale applyTo: v.		gc := self setClientDataFor: aGraphicsContext			index: n			foreground: false.		wedge := EllipticalArc				boundingBox: grid insetBounds				startAngle: oldAngle				sweepAngle: newAngle-oldAngle.		wedge sweepAngle &gt; 0.1 ifTrue: [(BG_ChartElement on: wedge) displayOn: gc at: ep].		oldAngle := newAngle].	(doughnutLabel item isNil or: [doughnutLabel item isEmpty]) ifFalse:		[| rect elp |		rect :=	(0@0 extent: 0.3@0.3) rectangleRelativeTo: grid insetBounds.		elp := EllipticalArc boundingBox: (rect align: rect center with: grid center).		(BG_ChartElement on: elp) displayOn: aGraphicsContext.		doughnutLabel displayOn: aGraphicsContext at: (doughnutLabel bounds align: doughnutLabel bounds center with: grid center) origin]</body></methods><methods><class-id>UI.BG_PieChartView</class-id> <category>grid</category><body package="BGOK">transpose</body></methods><methods><class-id>UI.BG_PieChartView</class-id> <category>initialize-release</category><body package="BGOK">initialize	| newGrid | 	super initialize.	newGrid := BG_ChartPolarGrid new.	newGrid theta: grid x.	newGrid theta manualAxis.	newGrid theta scale: (BG_ChartScale min: 0 max: 1).	newGrid r: grid y.	newGrid r scale: (BG_ChartScale min: 0 max: 1).	grid := newGrid.	grid startAngle: -90 stopAngle: 270.	dataLocation := #below.	dataStyle percent.	other := ''.	isEllipse := false.		doughnutLabel :=BG_Label new.</body><body package="BGOK">newGraphicsDevice: aGraphicsDevice	super newGraphicsDevice: aGraphicsDevice.	doughnutLabel newGraphicsDevice: aGraphicsDevice.</body></methods><methods><class-id>UI.BG_TableAdaptor</class-id> <category>initialize-release</category><body package="BGOK">adaptors	^adaptors</body><body package="BGOK">adaptors: aRowAdaptors	adaptors := aRowAdaptors</body><body package="BGOK">baseCollection	^baseCollection</body><body package="BGOK">baseCollection: aCollection	baseCollection := aCollection</body><body package="BGOK">baseCollection: aCollection adaptors: aRowAdaptor	self baseCollection: aCollection.	self adaptors: aRowAdaptor</body></methods><methods><class-id>UI.BG_TableAdaptor</class-id> <category>enumerating</category><body package="BGOK">collect: aBlock	| new |	new := self species columns: self columnSize rows: self rowSize.	self keysAndValuesDo:		[:key :value |		new atPoint: key put: (aBlock value: value)].	^new</body><body package="BGOK">column: x do: aBlock	1 to: self rowSize do:		[:y |		aBlock value: (self atPoint: x@y)]</body><body package="BGOK">column: x inject: thisValue into: binaryBlock 	"Accumulate a running value associated with evaluating the argument,	binaryBlock, with the current value and the receiver as block arguments. 	The initial value is the value of the argument, thisValue."	"For example, to sum a collection, use: 		collection inject: 0 into: [:subTotal :next | subTotal + next]."	| nextValue |	nextValue := thisValue.	self column: x do: [:each | nextValue := binaryBlock value: nextValue value: each].	^nextValue</body><body package="BGOK">keysAndValuesDo: aBlock  	"Evaluate aBlock with each of the receiver's key/value pairs	(e.g. indexes and elements) as the arguments."	1 to: self rowSize do:		[:y |		1 to: self columnSize do:			[:x |			aBlock value: x@y value: (self atPoint: x@y)]]</body></methods><methods><class-id>UI.BG_TableAdaptor</class-id> <category>accessing</category><body package="BGOK">at: anIndex	^anIndex indexAccessInto: self</body><body package="BGOK">at: anIndex put: anElement	^anIndex indexAccessInto: self put: anElement</body><body package="BGOK">atInteger: anInteger	^self atPoint: (self pointIndexFor: anInteger)</body><body package="BGOK">atInteger: anInteger put: aValue	^self atPoint: (self pointIndexFor: anInteger) put: aValue</body><body package="BGOK">atPoint: aPoint 	"Get the proper adaptor and and answer the rendering value 	using an object from collection as a subject."	| adaptor |	^(adaptor := adaptors at: aPoint y) isNil		ifTrue: [baseCollection at: aPoint x]		ifFalse: [adaptor renderingValueUsingSubject: (baseCollection at: aPoint x)]</body><body package="BGOK">atPoint: aPoint put: aValue 	"Get the proper adaptor and put block and use it to store aValue 	in the column."	| adaptor |	^(adaptor := adaptors at: aPoint y) isNil		ifTrue: [baseCollection at: aPoint x put: aValue]		ifFalse: [adaptor setValueUsingTarget: (baseCollection at: aPoint x)				to: aValue]</body><body package="BGOK">columnAt: anInteger 	"Answer a collection containing items from 	the given row."	| coll |	coll := Array new: self rowSize.	1 to: self rowSize do: 		[:i | coll at: i put: (self atPoint: anInteger @ i)].	^coll</body><body package="BGOK">columnAt: anInteger put: aCollection 	"Replace values at a given colmun with a values from aCollection."	self rowSize == aCollection size ifFalse: 		[self error: (#WrongSizeOfColumn &lt;&lt; #BGOK &gt;&gt; 'Wrong size of column.')].	1 to: self rowSize do: 		[:r | self atPoint: anInteger @ r put: (aCollection at: r)].	dependents == nil ifFalse:		 [self changed: #atRow: with: anInteger]</body><body package="BGOK">columnSize	^baseCollection size</body><body package="BGOK">defaultElement	^baseCollection defaultElement</body><body package="BGOK">dimensions	^self columnSize @ self rowSize</body><body package="BGOK">rowAt: y	| result |	result := Array new: self columnSize.	1 to: result size do:		[:x |		result at: x put: (self atPoint: x@y)].	^result</body><body package="BGOK">rowSize	"Answer the number of rows in the table"	^adaptors size</body><body package="BGOK">size	"Answer the total number of elements in the table."	^self rowSize * self columnSize</body></methods><methods><class-id>UI.BG_TableAdaptor</class-id> <category>copying</category><body package="BGOK">postCopy	"Answer a copy of the receiver."	super postCopy.	self breakDependents.	baseCollection :=  baseCollection copy.	adaptors := adaptors copy.</body></methods><methods><class-id>UI.BG_TableAdaptor</class-id> <category>private</category><body package="BGOK">myDependents	^dependents</body><body package="BGOK">myDependents: anObject	dependents := anObject</body><body package="BGOK">pointIndexFor: anInteger	| base |	base := (anInteger-1) // self rowSize.	^(base + 1)@(anInteger - (base*self rowSize))</body></methods><methods><class-id>UI.BG_TableAdaptor class</class-id> <category>instance creation</category><body package="BGOK">columns: columnSize rows: rowSize 	"BG_TableAdaptor columns: 10 rows: 3"	| adaptors collection |	collection := Array new: columnSize.	1 to: collection size do: 		[:i | collection at: i put: (Array new: rowSize)].	adaptors := Array new: rowSize.	1 to: adaptors size do: 		[:i | adaptors at: i put: (IndexedAdaptor forIndex: i)].	^self on: collection adaptors: adaptors</body><body package="BGOK">on: aBaseCollection adaptors: aCollectionOfAdaptors	| inst |	inst := self basicNew.	inst baseCollection: aBaseCollection adaptors: aCollectionOfAdaptors.	^inst</body><body package="BGOK">withRow: aList 	| data |	data := Array new: aList size.	aList keysAndValuesDo: [:i :v | data at: i put: (Array with: v)].	^self on: data adaptors: (Array with: (IndexedAdaptor forIndex: 1))</body><body package="BGOK">withRowData: aList 	"Answer an instance containing as many rows as are elemnts in aList"	| rows columns new row  |	aList isEmpty ifTrue: [^self columns: 0 rows: 0].	rows := aList size.	columns := aList first size.	new := self columns: columns rows: rows.	1 to: aList size do:		[:y |		row := aList at: y.		row size = columns ifFalse: [self error: (#GenKey1 &lt;&lt; #BGOK &gt;&gt; 'All rows are not the same size')].		1 to: columns do:			[:x |			new atPoint: x@y put: (row at: x)]].	^new</body></methods><methods><class-id>Examples.BG_Employee</class-id> <category>name</category><body package="BGOK">name	^name</body></methods><methods><class-id>Examples.BG_Employee</class-id> <category>salary</category><body package="BGOK">salary	^salary</body></methods><methods><class-id>Examples.BG_Employee</class-id> <category>salary:</category><body package="BGOK">salary: aValue	salary := aValue</body></methods><methods><class-id>Examples.BG_Employee</class-id> <category>name:</category><body package="BGOK">name: aValue	name := aValue</body></methods><methods><class-id>Examples.BG_Employee</class-id> <category>age</category><body package="BGOK">age	^age</body></methods><methods><class-id>Examples.BG_Employee</class-id> <category>age:</category><body package="BGOK">age: aValue	age := aValue</body></methods><methods><class-id>UI.BG_LabelList</class-id> <category>bounds accessing</category><body package="BGOK">computedExtent	| ext |	ext := 0 @ 0.	self individualImages do: [:each | ext := ext + each extent].	^ext</body><body package="BGOK">extent	^extent isNil 		ifTrue: 			[self individualExtent * (column@self row)]		ifFalse:			[extent]</body><body package="BGOK">extent: aPoint	"Set the point that represents the width and height of the	receiver"		| iw ih |	iw := column &gt; 0 ifTrue: [aPoint x // column] ifFalse: [0].	ih := self row &gt; 0 ifTrue: [aPoint y // self row] ifFalse: [0].	self individualExtent: iw@ih.	extent := self extent</body><body package="BGOK">individualExtent	| ext |	individualExtent isNil		ifTrue: 			[ext := 0 @ 0.			self individualImages do: [:each | ext := ext max: each extent].			^ext]		ifFalse: [^individualExtent]</body><body package="BGOK">individualExtent: aPoint	"Set the point that represents the width and height of each label of the	receiver"	individualExtent := aPoint.	extent := nil.	super flushCaches</body><body package="BGOK">individualImages	"Answer the collection of the image containing the composed element of item."	individualImages isNil ifTrue: [self compose].	^individualImages</body></methods><methods><class-id>UI.BG_LabelList</class-id> <category>private</category><body package="BGOK">compose	"Cache the visual components for displaying the object."	| savedItem | 	item == nil		ifTrue: 			[individualImages := #().			^self].	savedItem := item.	(item isKindOf: BG_TableAdaptor)		ifTrue: [individualImages := BG_TableAdaptor columns: item columnSize rows: item rowSize]		ifFalse: [individualImages := Array new: item size].	savedItem keysAndValuesDo:		[:i :v |		item := v.		super compose.		individualImages at: i put: image].	image := nil.	item := savedItem</body><body package="BGOK">separate: aString	| labels oc rs |	(labels := aString) isString ifTrue:		[oc := OrderedCollection new.		rs := ReadStream on: aString.		[rs atEnd] whileFalse: [oc add: (rs upTo: Character cr)].		labels := oc asArray].	^labels</body></methods><methods><class-id>UI.BG_LabelList</class-id> <category>column</category><body package="BGOK">beHorizontal	self column: item size</body><body package="BGOK">beVertical	self column: 1</body><body package="BGOK">column	^column</body><body package="BGOK">column: anInteger	column := anInteger.	super flushCaches</body><body package="BGOK">isHorizontal	^column = item size</body><body package="BGOK">isVertical	^column = 1</body><body package="BGOK">row	^(item size / column) ceiling</body></methods><methods><class-id>UI.BG_LabelList</class-id> <category>displaying</category><body package="BGOK">displayItemAt: index on: aGraphicsContext 	self		displayItemAt: index		on: aGraphicsContext		at: Point zero</body><body package="BGOK">displayItemAt: index on: aGraphicsContext at: aPoint	| gc savedItem savedExtent |	item == nil ifTrue: [^self].	self individualImages.	savedItem := item.	savedExtent := extent.	extent := self individualExtent.	gc := aGraphicsContext copy.	self setColorOn: gc.	gc intersectClip: (Rectangle origin: aPoint extent: extent).	item := savedItem at: index.	image := individualImages at: index.	image displayOn: gc	at: aPoint + (self alignOffset: image).	item := savedItem.	extent := savedExtent.</body><body package="BGOK">displayOn: aGraphicsContext at: aPoint	"Display the receiver on aGraphicsContext translated by aPoint."	| gc row savedItem savedExtent clippingBox iw ih |	(item isNil or: [item isEmpty]) ifTrue: [^self].	individualImages isNil ifTrue: [self compose].	row := self row.	savedItem := item.	gc := aGraphicsContext copy.	self setColorOn: gc.	extent ~~ nil ifTrue: [gc intersectClip: (self bounds translatedBy: aPoint)].	savedExtent := extent.	extent := self individualExtent.	clippingBox := gc clippingBounds translatedBy: aPoint negated.	iw := extent x.	ih := extent y.	(clippingBox left // iw max: 0) to: (clippingBox right // iw min: column -1) do:		[:c | (clippingBox top // ih max: 0) to: (clippingBox bottom // ih min: row -1) do:				[:r | | i |					i := r * column + (c + 1).					(i &lt;= savedItem size and: [(item := savedItem at: i) notNil]) ifTrue:						[image := individualImages at: i.						image displayOn: gc at: aPoint + ((c@r) * self extent) + (self alignOffset: image)]]].	item := savedItem.	extent := savedExtent.</body></methods><methods><class-id>UI.BG_LabelList</class-id> <category>accessing</category><body package="BGOK">fitItem	item do: [:each | (each isKindOf: BG_Label)			ifTrue: [each extent: self individualExtent]].	super flushCaches</body><body package="BGOK">item: anObject	super item: (self separate: anObject)</body><body package="BGOK">lineGrid	"Answer the line grid of the receiver."	^self individualExtent y max: 1</body><body package="BGOK">numberOfLines	"Answer the number of lines of item in the receiver."	^self row</body></methods><methods><class-id>UI.BG_LabelList</class-id> <category>initialize-release</category><body package="BGOK">flushCaches	super flushCaches.	individualImages := nil</body><body package="BGOK">initialize	super initialize.	self beVertical</body><body package="BGOK">newGraphicsDevice: aGraphicsDevice 	self individualImages do:[:each| each newGraphicsDevice: aGraphicsDevice].</body></methods><methods><class-id>UI.BG_LabelList</class-id> <category>line accessing</category><body package="BGOK">lineIndexOfTop: top	"Answer the line index for the y position aTop."	^(top // self lineGrid + 1 max: 1) min: self numberOfLines</body><body package="BGOK">topAtLineIndex: lineIndex 	"Answer the top y of the line at lineIndex."	^lineIndex - 1 * self lineGrid</body><body package="BGOK">visibleRectangleFrom: start to: stop	"Answer the rectangle for the lines in the range start to stop."	|  firstLineIndex lastLineIndex |	firstLineIndex := start.	firstLineIndex &lt; 1 ifTrue: [firstLineIndex := 1].	lastLineIndex := stop.	lastLineIndex &gt; self numberOfLines 		ifTrue: [lastLineIndex := self numberOfLines].	^(Rectangle 		origin: self left @ (self topAtLineIndex: firstLineIndex) 		corner: self right @ ((self topAtLineIndex: lastLineIndex) + self lineGrid))</body></methods><methods><class-id>UI.BG_LabelList class</class-id> <category>instance creation</category><body package="BGOK">onList: aListArray 	^self item: aListArray</body></methods><methods><class-id>UI.BG_ChartPolarGrid</class-id> <category>accessing</category><body package="BGOK">center	^center</body><body package="BGOK">center: aPoint radius: anInteger	center := aPoint.	y scale destMin: 0 max: anInteger</body><body package="BGOK">r	^y</body><body package="BGOK">r: anAxis	"Make the argument, anAxis, the receiver's r axis"	y := anAxis</body><body package="BGOK">radius	^y scale destLength</body><body package="BGOK">startAngle	^x scale destMin</body><body package="BGOK">startAngle: anAngle1 stopAngle: anAngle2	x scale destMin: anAngle1 max: anAngle2</body><body package="BGOK">stopAngle	^x scale destMax</body><body package="BGOK">theta	^x</body><body package="BGOK">theta: anAxis	"Make the argument, anAxis, the receiver's theta axis"	x := anAxis</body><body package="BGOK">transpose	"The receiver can't transpose axis"</body><body package="BGOK">xyRate	^xyRate</body><body package="BGOK">xyRate: aPositiveFloat 	aPositiveFloat &gt; xyRate ifTrue: [self center: self center radius: self radius * xyRate / aPositiveFloat].	xyRate := aPositiveFloat</body></methods><methods><class-id>UI.BG_ChartPolarGrid</class-id> <category>displaying</category><body package="BGOK">displayHAxisOn: aGraphicsContext	| ts rs arc line angle beginPoint endPoint sy rx ry |	ts := x scale.	rs := y scale.	sy := ((rs includesZero and: [rs zero ~= rs sourceMin &amp; (rs zero ~= rs sourceMax)]) and: [y isAutoLabeled])			ifTrue: [rs zero]			ifFalse: [rs incrementalScaled ifTrue: [rs sourceMax] ifFalse: [rs sourceMin]].	"Display axis line"	x axisLine isPathVisible ifTrue:		[ry := (rs applyTo: sy) - rs destMin.		rx := ry * self xyRate.		arc := EllipticalArc				boundingBox:					(center - (rx@ry) extent: (rx@ry)*2)				startAngle: self startAngle				sweepAngle: self stopAngle - self startAngle.		(BG_ChartElement on: arc) fillInside: false; displayOn: aGraphicsContext].	"Display major tick mark"	(line := x majorTick) isPathVisible ifTrue:		[line := line geometric.		beginPoint := rs incrementalScaled 					ifTrue: [line start transpose] 					ifFalse: [line start transpose negated].		endPoint := rs incrementalScaled 					ifTrue: [line end transpose] 					ifFalse: [line end transpose negated].		ts majorMarks do:			[:mx | 				| p |				angle := (ts applyTo: mx) degreesToRadians.				(p := self applyTo: mx@sy) ~= center ifTrue:					[(LineSegment							from: (self rotatePoint: beginPoint by: angle origin: 0@0) rounded							to: (self rotatePoint: endPoint by: angle origin: 0@0) rounded)						asStroker displayOn: aGraphicsContext at: p rounded]]].	"Display minor tick marks"	((line := x minorTick) isPathVisible and: [ts div ~= 1]) ifTrue: 		[line := line copy geometric: line geometric copy.		beginPoint := rs incrementalScaled 					ifTrue: [line geometric start transpose] 					ifFalse: [line geometric start transpose negated].		endPoint := rs incrementalScaled 					ifTrue: [line geometric end transpose] 					ifFalse: [line geometric end transpose negated].		ts minorMarks do:			[:mx | 				| p |				angle := (ts applyTo: mx) degreesToRadians.				(p := self applyTo: mx@sy) ~= center ifTrue:					[line geometric						setStart: (self rotatePoint: beginPoint by: angle origin: 0@0) rounded						end: (self rotatePoint: endPoint by: angle origin: 0@0) rounded.					line displayOn: aGraphicsContext at: p rounded]]].</body><body package="BGOK">displayHLabelsOn: aGraphicsContext 	| gc ts rs marks images alignment offset sy size |	ts := x scale.	rs := y scale.	alignment := rs incrementalScaled ifTrue: [4] ifFalse: [6].	offset := rs incrementalScaled ifTrue: [5@0] ifFalse: [-5@0].	sy := ((rs includesZero and: [rs zero ~= rs sourceMin &amp; (rs zero ~= rs sourceMax)]) and: [x isAutoLabeled])			ifTrue: [rs zero]			ifFalse: [rs incrementalScaled ifTrue: [rs sourceMax] ifFalse: [rs sourceMin]].	"Display axis labels"	marks := x labelsMarks.	gc := aGraphicsContext copy.	images := x labelsStyle individualImages.	(size := marks size min: images size) = 0 ifFalse:		[((x labels at: 1) = nil or: [(x labels at: size) = nil]) ifFalse:			[| fa la |			fa := (ts applyTo: (marks at: 1)) \\ 360.			la := (ts applyTo: (marks at: size)) \\ 360.			fa = la ifTrue:				[| delta |				delta := (rs incrementalScaled ifTrue: [10] ifFalse: [15]) * (ts incrementalScaled ifTrue: [1] ifFalse: [-1]).				marks at: 1 put: (ts applyInverseTo: fa + delta).				marks at: size put: (ts applyInverseTo: la - delta)]].		1 to: size do: 			[:i | self				displayLabel: (images at: i)				angle: (ts applyTo: (marks at: i))				offset: offset				alignment: alignment				on: gc				at: (self applyTo: (marks at: i) @ sy) rounded]].		"Display axis unit --- skip"	"Display axis title"	x title notNil ifTrue:		[x titleStyle scale: 1@1.		x titleStyle			displayOn: aGraphicsContext			at: self insetBounds bottomCenter + (x titleStyle width // -2@(x labelsStyle individualExtent y +5))].</body><body package="BGOK">displayHLinesOn: aGraphicsContext 	| rs block marks |	rs := y scale.	block := 			[:ry | 			| rx arc |			rx := ry * self xyRate.			arc := EllipticalArc					boundingBox: (center - (rx @ ry) extent: rx @ ry * 2)					startAngle: self startAngle					sweepAngle: self stopAngle - self startAngle.			arc := BG_ChartElement on: arc.			arc fillInside: false; displayOn: aGraphicsContext].	"Display section lines"	y sectionLine isPathVisible		ifTrue:			[marks := (rs applyToValues: y sectionMarks)						collect: [:n | n - rs destMin].			1 to: marks size do: [:i | block value: (marks at: i)]].	"Display border lines"	y borderLine isPathVisible		ifTrue:			[marks := rs applyToValues: rs edgeMarks.			block value: marks first.			block value: marks last]</body><body package="BGOK">displayVAxisOn: aGraphicsContext	| ts rs line marksX angle beginPoint endPoint sx |	ts := x scale.	rs := y scale.	sx := ts includesZero			ifTrue: [ts zero]			ifFalse: [ts incrementalScaled ifTrue: [ts sourceMin] ifFalse: [ts sourceMax]].	"Display axis line"	(line := y axisLine) isPathVisible ifTrue:		[(LineSegment				from: (self applyTo: sx@rs sourceMax) rounded				to: (self applyTo: sx@rs sourceMin) rounded)			asStroker displayOn: aGraphicsContext].	"Display major tick mark"	marksX := ts majorMarks.	(line := y majorTick) isPathVisible ifTrue:		[beginPoint := line geometric start.		endPoint := line geometric end.		marksX do:			[:mx |				angle := (ts applyTo: mx) degreesToRadians.				line := LineSegment						from: (self rotatePoint: beginPoint by: angle origin: 0@0) rounded						to: (self rotatePoint: endPoint by: angle origin: 0@0) rounded.				rs majorMarks do: 					[:my | | p |						(p := self applyTo: mx@my) ~= center ifTrue:							[line asStroker displayOn: aGraphicsContext at: p rounded]]]].	"Display minor tick mark"	((line := y minorTick) isPathVisible and: [rs div ~= 1]) ifTrue:		[line := line copy geometric: line geometric copy.		beginPoint := line geometric start.		endPoint := line geometric end.		marksX do:			[:mx |				angle := (ts applyTo: mx) degreesToRadians.				line geometric					setStart: (self rotatePoint: beginPoint by: angle origin: 0@0) rounded					end: (self rotatePoint: endPoint by: angle origin: 0@0) rounded.				rs minorMarks do: 					[:my | | p |						(p := self applyTo: mx@my) ~= center ifTrue:							[line displayOn: aGraphicsContext at: p rounded]]]].</body><body package="BGOK">displayVLabelsOn: aGraphicsContext	"Display axis labels"	| gc ts rs marks images angle alignment offset sx sizeOfLabels |	ts := x scale.	rs := y scale.	alignment := ts incrementalScaled ifTrue: [8] ifFalse: [2].	offset := ts incrementalScaled ifTrue: [0 @ -5] ifFalse: [0 @ 5].	marks := y labelsMarks.	gc := aGraphicsContext copy.	images := y labelsStyle individualImages.	sx := ts includesZero				ifTrue: [ts zero]				ifFalse: [ts incrementalScaled ifTrue: [ts sourceMin] ifFalse: [ts sourceMax]].	angle := ts applyTo: sx.	sizeOfLabels := marks size min: images size.	1 to: sizeOfLabels		do: 			[:i |			self				displayLabel: (images at: i)				angle: angle				offset: offset				alignment: alignment				on: gc				at: (self applyTo: sx @ (marks at: i)) rounded].	"Display axis unit"	y unit notNil		ifTrue: 			[self				displayLabel: y unitStyle				angle: angle				offset: offset + (((images at: sizeOfLabels) bounds extent x // 2 + 5) @ 0)				alignment: (ts incrementalScaled ifTrue: [7] ifFalse: [1])				on: aGraphicsContext				at: (self applyTo: sx @ (marks at: sizeOfLabels)) rounded].	"Display axis title"	y title notNil		ifTrue: 			[| lh image |			lh := y labelsStyle individualExtent x.			alignment := ts incrementalScaled ifTrue: [8] ifFalse: [2].			offset := (rs destLength // 2) @ (ts incrementalScaled ifTrue: [-5 - lh] ifFalse: [5 + lh]).			image := y titleStyle.			image scale: 1 @ 1.			image rotation: (angle degreesToRadians sin abs &gt; (0.25 * Float pi) sin ifTrue: [3] ifFalse: [0]).			self				displayLabel: image				angle: angle				offset: offset				alignment: alignment				on: aGraphicsContext				at: self center]</body><body package="BGOK">displayVLinesOn: aGraphicsContext 	| rs line marks block |	rs := y scale.	line := x sectionLine.	block := 			[:sx :gc | 			line geometric: (LineSegment					from: (self applyTo: sx @ rs sourceMax) rounded					to: (self applyTo: sx @ rs sourceMin) rounded).			line displayOn: gc].	"Display section lines"	line isPathVisible ifTrue: 		[marks := x sectionMarks.		1 to: marks size do: [:i | block value: (marks at: i) value: aGraphicsContext]].	"Display border lines"	(line := x borderLine) isPathVisible ifTrue: 		[marks := x scale edgeMarks.		block value: marks first value: aGraphicsContext.		block value: marks last value: aGraphicsContext]</body></methods><methods><class-id>UI.BG_ChartPolarGrid</class-id> <category>bounds accessing</category><body package="BGOK">insetBounds	| length |	length := self radius * xyRate@self radius.	^center - length extent: length * 2</body><body package="BGOK">insetBounds: aRectangle	| radius |	radius := aRectangle height // 2 max: 1.	self center: aRectangle center radius: radius.	xyRate := (aRectangle width / (radius * 2)) asFloat.</body></methods><methods><class-id>UI.BG_ChartPolarGrid</class-id> <category>testing</category><body package="BGOK">transposed	^false</body></methods><methods><class-id>UI.BG_ChartPolarGrid</class-id> <category>applying transform</category><body package="BGOK">applyInverseTo: aPoint	| d t r m |	d := aPoint - center.	m := (self startAngle + self stopAngle / 2) degreesToRadians.		t := d theta + (m // (2 * Float pi) * (2 * Float pi)).	t &gt; (m + Float pi) 		ifTrue: [t := t - (2 * Float pi)]		ifFalse: [t &lt; (m - Float pi) ifTrue: [t := t + (2 * Float pi)]].	r := d r.	t := t radiansToDegrees.	^(x scale applyInverseTo: t)@(y scale applyInverseTo: r)</body><body package="BGOK">applyTo: aPoint	| r t |	t := (x scale applyTo: aPoint x) degreesToRadians.	r := y scale applyTo: aPoint y.	^(t cos * xyRate@t sin) * r + center</body></methods><methods><class-id>UI.BG_ChartPolarGrid</class-id> <category>initialize-release</category><body package="BGOK">initialize	super initialize.	self startAngle: 0 stopAngle: 360.	xyRate := 1.	y tickCross</body></methods><methods><class-id>UI.BG_ChartPolarGrid</class-id> <category>bounds clipping</category><body package="BGOK">gcCopyClipped: aGraphicsContext	^aGraphicsContext</body></methods><methods><class-id>Examples.BG_Chart1 class</class-id> <category>windowSpec</category><body package="BGOK">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: #(#{Kernel.UserMessage} #key: #SimpleChart #defaultString: 'Simple Chart' #catalogID: #BGOK) 			#bounds: #(#Rectangle 501 132 866 509 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#ChartViewSpec 					#layout: #(#Rectangle 20 20 345 337 ) 					#model: #data 					#options: 					#(#BarChartOptionsSpec 						#width: 0.6 ) ) 				#(#ActionButtonSpec 					#layout: #(#Rectangle 147 342 219 372 ) 					#model: #update 					#label: #(#{Kernel.UserMessage} #key: #Update #defaultString: 'Update' #catalogID: #BGOK) 					#isDefault: true 					#defaultable: true ) ) ) )</body></methods><methods><class-id>UI.ChartElementLookSpec class</class-id> <category>resources</category><body package="BGOK">lineStyleMenu	"MenuEditor new openOnClass: self andSelector: #lineStyleMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Default #defaultString: 'Default' #catalogID: #BGOK) 				#value: #default ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Solid #defaultString: 'Solid' #catalogID: #BGOK) 				#value: #solid ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Dotted #defaultString: 'Dotted' #catalogID: #BGOK) 				#value: #dotted ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Dashed #defaultString: 'Dashed' #catalogID: #BGOK) 				#value: #dashed ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Broken #defaultString: 'Broken' #catalogID: #BGOK) 				#value: #broken ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Dotted2 #defaultString: 'Dotted 2' #catalogID: #BGOK) 				#value: #dotted2 ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Dashed2 #defaultString: 'Dashed 2' #catalogID: #BGOK) 				#value: #dashed2 ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Broken2 #defaultString: 'Broken 2' #catalogID: #BGOK) 				#value: #broken2 ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #None #defaultString: 'None' #catalogID: #BGOK) 				#value: #none ) ) #(8 1 ) nil ) decodeAsLiteralArray</body><body package="BGOK">markerStyleMenu	"MenuEditor new openOnClass: self andSelector: #markerStyleMenu"	&lt;resource: #menu&gt;	^#(#{Menu} #(			#(#{MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Default #defaultString: 'Default' #catalogID: #BGOK) 				#value: #default ) 			#(#{MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Square #defaultString: 'Square' #catalogID: #BGOK) 				#value: #square ) 			#(#{MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #SolidSquare #defaultString: 'Solid Square' #catalogID: #BGOK) 				#value: #solidSquare ) 			#(#{MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Circle #defaultString: 'Circle' #catalogID: #BGOK) 				#value: #circle ) 			#(#{MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #SolidCircle #defaultString: 'Solid Circle' #catalogID: #BGOK) 				#value: #solidCircle ) 			#(#{MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Triangle #defaultString: 'Triangle' #catalogID: #BGOK) 				#value: #triangle ) 			#(#{MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #SolidTriangle #defaultString: 'Solid Triangle' #catalogID: #BGOK) 				#value: #solidTrinagle ) 			#(#{MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Triangle2 #defaultString: 'Triangle 2' #catalogID: #BGOK) 				#value: #triangle2 ) 			#(#{MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #SolidTriangle2 #defaultString: 'Solid Triangle 2' #catalogID: #BGOK) 				#value: #solidTrinagle2 ) 			#(#{MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Diamond #defaultString: 'Diamond' #catalogID: #BGOK) 				#value: #diamond ) 			#(#{MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #SolidDiamond #defaultString: 'Solid Diamond' #catalogID: #BGOK) 				#value: #solidDiamond ) 			#(#{MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Cross #defaultString: 'Cross' #catalogID: #BGOK) 				#value: #cross ) 			#(#{MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #X #defaultString: 'X' #catalogID: #BGOK) 				#value: #x ) ) #(13 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>UI.ChartElementLookSpec class</class-id> <category>interface specs</category><body package="BGOK">lineLookSpec	"UIPainter new openOnClass: self andSelector: #lineLookSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: '' 			#min: #(#Point 222 230 ) 			#max: #(#Point 640 235 ) 			#bounds: #(#Rectangle 660 125 902 355 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#LabelSpec 					#layout: #(#AlignmentOrigin 0 0.5 9 0 0.5 0 ) 					#label: #(#{Kernel.UserMessage} #key: #DefineTheLookOfLines #defaultString: 'Define the look of lines:' #catalogID: #BGOK) ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame -82 0.5 -35 1 -16 0.5 -5 1 ) 					#name: #okButton 					#model: #accept 					#label: #(#{Kernel.UserMessage} #key: #OK #defaultString: 'OK' #catalogID: #BGOK) 					#isDefault: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 16 0.5 -35 1 82 0.5 -5 1 ) 					#name: #cancelButton 					#model: #cancel 					#label: #(#{Kernel.UserMessage} #key: #Cancel #defaultString: 'Cancel' #catalogID: #BGOK) 					#defaultable: true ) 				#(#MenuButtonSpec 					#layout: #(#LayoutFrame 73 0 58 0 -18 1 81 0 ) 					#model: #lineStyle 					#menu: #lineStyleMenu ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 15 0 83 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #Style #defaultString: 'Style:' #catalogID: #BGOK) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 15 0 178 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #Style #defaultString: 'Style:' #catalogID: #BGOK) ) 				#(#MenuButtonSpec 					#layout: #(#LayoutFrame 73 0 153 0 -18 1 176 0 ) 					#model: #markerStyle 					#menu: #markerStyleMenu ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 15 0 115 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #Width #defaultString: 'Width:' #catalogID: #BGOK) ) 				#(#InputFieldSpec 					#layout: #(#Rectangle 73 90 150 113 ) 					#model: #lineWidth 					#numChars: 3 					#type: #number ) 				#(#GroupBoxSpec 					#layout: #(#LayoutFrame 10 0 32 0 -10 1 125 0 ) 					#label: #(#{Kernel.UserMessage} #key: #Line #defaultString: 'Line' #catalogID: #BGOK) ) 				#(#GroupBoxSpec 					#layout: #(#LayoutFrame 10 0 128 0 -10 1 189 0 ) 					#label: #(#{Kernel.UserMessage} #key: #Marker #defaultString: 'Marker' #catalogID: #BGOK) ) ) ) )</body><body package="BGOK">regionLookSpec	"UIPainter new openOnClass: self andSelector: #regionLookSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: #(#{Kernel.UserMessage} #key: #FillPattern #defaultString: 'Fill Pattern' #catalogID: #BGOK) 			#min: #(#Point 236 223 ) 			#max: #(#Point 236 223 ) 			#bounds: #(#Rectangle 401 277 637 500 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 16 0 18 0 34 0 36 0 ) 					#model: #m1 					#label: #i1 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 46 0 18 0 64 0 36 0 ) 					#model: #m2 					#label: #i2 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 76 0 18 0 94 0 36 0 ) 					#model: #m3 					#label: #i3 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 106 0 18 0 124 0 36 0 ) 					#model: #m4 					#label: #i4 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 136 0 18 0 154 0 36 0 ) 					#model: #m5 					#label: #i5 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 166 0 18 0 184 0 36 0 ) 					#model: #m6 					#label: #i6 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 196 0 18 0 214 0 36 0 ) 					#model: #m7 					#label: #i7 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 16 0 53 0 34 0 71 0 ) 					#model: #m8 					#label: #i8 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 46 0 53 0 64 0 71 0 ) 					#model: #m9 					#label: #i9 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 76 0 53 0 94 0 71 0 ) 					#model: #m10 					#label: #i10 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 106 0 53 0 124 0 71 0 ) 					#model: #m11 					#label: #i11 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 136 0 53 0 154 0 71 0 ) 					#model: #m12 					#label: #i12 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 166 0 53 0 184 0 71 0 ) 					#model: #m13 					#label: #i13 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 196 0 53 0 214 0 71 0 ) 					#model: #m14 					#label: #i14 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 16 0 88 0 34 0 106 0 ) 					#model: #m16 					#label: #i16 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 46 0 88 0 64 0 106 0 ) 					#model: #m17 					#label: #i17 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 76 0 88 0 94 0 106 0 ) 					#model: #m18 					#label: #i18 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 106 0 88 0 124 0 106 0 ) 					#model: #m19 					#label: #i19 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 136 0 88 0 154 0 106 0 ) 					#model: #m20 					#label: #i20 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 166 0 88 0 184 0 106 0 ) 					#model: #m21 					#label: #i21 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 196 0 88 0 214 0 106 0 ) 					#model: #m15 					#label: #i15 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 16 0 123 0 34 0 141 0 ) 					#model: #m29 					#label: #i29 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 46 0 123 0 64 0 141 0 ) 					#model: #m30 					#label: #i30 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 76 0 123 0 94 0 141 0 ) 					#model: #m31 					#label: #i31 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 106 0 123 0 124 0 141 0 ) 					#model: #m32 					#label: #i32 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 136 0 123 0 154 0 141 0 ) 					#model: #m33 					#label: #i33 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 166 0 123 0 184 0 141 0 ) 					#model: #m34 					#label: #i34 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 196 0 123 0 214 0 141 0 ) 					#model: #m35 					#label: #i35 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 16 0 158 0 34 0 176 0 ) 					#model: #m22 					#label: #i22 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 46 0 158 0 64 0 176 0 ) 					#model: #m23 					#label: #i23 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 76 0 158 0 94 0 176 0 ) 					#model: #m24 					#label: #i24 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 106 0 158 0 124 0 176 0 ) 					#model: #m25 					#label: #i25 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 136 0 158 0 154 0 176 0 ) 					#model: #m26 					#label: #i26 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 166 0 158 0 184 0 176 0 ) 					#model: #m27 					#label: #i27 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 196 0 158 0 214 0 176 0 ) 					#model: #m28 					#label: #i28 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#Rectangle 83 187 149 217 ) 					#name: #cancelButton 					#model: #cancel 					#label: #(#{Kernel.UserMessage} #key: #Cancel #defaultString: 'Cancel' #catalogID: #BGOK) 					#defaultable: true ) ) ) )</body></methods><methods><class-id>UI.LineChartOptionsSpec class</class-id> <category>interface specs</category><body package="BGOK">defaultDialogSpec	"UIPainter new openOnClass: self andSelector: #defaultDialogSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: '' 			#min: #(#Point 20 20 ) 			#bounds: #(#Rectangle 98 272 355 570 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#RadioButtonSpec 					#layout: #(#AlignmentOrigin 87 0 196 0 0 1 ) 					#model: #dataLocation 					#label: #(#{Kernel.UserMessage} #key: #Hide #defaultString: 'Hide' #catalogID: #BGOK) 					#select: #none ) 				#(#RadioButtonSpec 					#layout: #(#AlignmentOrigin 14 0 196 0 0 1 ) 					#model: #dataLocation 					#label: #(#{Kernel.UserMessage} #key: #Show #defaultString: 'Show' #catalogID: #BGOK) 					#select: #inside ) 				#(#GroupBoxSpec 					#layout: #(#LayoutFrame 10 0 149 0 -10 1 200 0 ) 					#label: #(#{Kernel.UserMessage} #key: #Data #defaultString: 'Data:' #catalogID: #BGOK) ) 				#(#GroupBoxSpec 					#layout: #(#LayoutFrame 10 0 16 0 -10 1 92 0 ) 					#label: #(#{Kernel.UserMessage} #key: #LineC #defaultString: 'Line:' #catalogID: #BGOK) ) 				#(#RadioButtonSpec 					#layout: #(#AlignmentOrigin 87 0 63 0 0 1 ) 					#model: #lineLocation 					#label: #(#{Kernel.UserMessage} #key: #Hide #defaultString: 'Hide' #catalogID: #BGOK) 					#select: #hide ) 				#(#GroupBoxSpec 					#layout: #(#LayoutFrame 10 0 95 0 -10 1 146 0 ) 					#label: #(#{Kernel.UserMessage} #key: #MarkerC #defaultString: 'Marker:' #catalogID: #BGOK) ) 				#(#RadioButtonSpec 					#layout: #(#AlignmentOrigin 87 0 142 0 0 1 ) 					#model: #markerLocation 					#label: #(#{Kernel.UserMessage} #key: #Hide #defaultString: 'Hide' #catalogID: #BGOK) 					#select: #hide ) 				#(#RadioButtonSpec 					#layout: #(#AlignmentOrigin 14 0 63 0 0 1 ) 					#model: #lineLocation 					#label: #(#{Kernel.UserMessage} #key: #Show #defaultString: 'Show' #catalogID: #BGOK) 					#select: #show ) 				#(#CheckBoxSpec 					#layout: #(#AlignmentOrigin 15 0 88 0 0 1 ) 					#model: #showSpline 					#label: #(#{Kernel.UserMessage} #key: #Spline #defaultString: 'Spline' #catalogID: #BGOK) ) 				#(#RadioButtonSpec 					#layout: #(#AlignmentOrigin 14 0 142 0 0 1 ) 					#model: #markerLocation 					#label: #(#{Kernel.UserMessage} #key: #Show #defaultString: 'Show' #catalogID: #BGOK) 					#select: #show ) ) ) )</body></methods><methods><class-id>Examples.BG_StockTool class</class-id> <category>windowSpec</category><body package="BGOK">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{FullSpec} 		#window: 		#(#{WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #Stocks #defaultString: 'Stocks' #catalogID: #BGOK) 			#min: #(#{Point} 20 20 ) 			#bounds: #(#{Rectangle} 297 271 937 546 ) 			#flags: 4 			#menu: #menuBar ) 		#component: 		#(#{SpecCollection} 			#collection: #(				#(#{SequenceViewSpec} 					#layout: #(#{LayoutFrame} 10 0 10 0 152 0 -10 1 ) 					#model: #stockNames 					#multipleSelections: false ) 				#(#{ChartViewSpec} 					#layout: #(#{LayoutFrame} 172 0 10 0 -10 1 -10 1 ) 					#name: #stocks 					#model: #data 					#chartType: #BG_LineChartView 					#dataSeries: 					#(#{ChartDataSpec} 						#series: #(							#(#{ChartDataSetSpec} 								#aspect: #price 								#name: 'Stock1' ) 							#(#{ChartDataSetSpec} 								#aspect: #labels 								#isData: false 								#name: 'Labels' 								#isComputed: true ) ) ) 					#xAxis: 					#(#{ChartingAxisSpec} 						#scale: 						#(#{ChartingScaleSpec} 							#step: 5 							#restrictions: #(#auto #zero #div #log ) ) 						#tickPosition: #hideTick 						#sectionMarkAt: #divisionMarks ) 					#yAxis: 					#(#{ChartingValueAxisSpec} 						#scale: 						#(#{ChartingScaleSpec} 							#invert: true ) 						#unit: '$' ) 					#legendPosition: 3 ) ) ) )</body></methods><methods><class-id>Examples.BG_StockTool class</class-id> <category>menuBar</category><body package="BGOK">menuBar	"UIMenuEditor new openOnClass: self andSelector: #menuBar"	&lt;resource: #menu&gt;	^#(#Menu #(#(#MenuItem #rawLabel: #(#{Kernel.UserMessage} #key: #File #defaultString: 'File' #catalogID: #BGOK) #submenu: #(#Menu #(#(#MenuItem #rawLabel: #(#{Kernel.UserMessage} #key: #LoadExampleData #defaultString: 'Load example data' #catalogID: #BGOK) ) ) #(1 ) #(#loadQuotes ) ) ) ) #(1 ) #(nil ) ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.ChartColorTool class</class-id> <category>interface specs</category><body package="BGOK">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: #(#{Kernel.UserMessage} #key: #ColorTool #defaultString: 'Color Tool' #catalogID: #BGOK) 			#min: #(#Point 389 236 ) 			#max: #(#Point 389 236 ) 			#bounds: #(#Rectangle 442 207 831 443 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#CompositeSpecCollection 					#collection: #() 					#compositeSpec: 					#(#CompositeSpec 						#layout: #(#Rectangle 316 151 382 175 ) 						#name: #theActualColor 						#colors: #(#LookPreferences ) ) ) 				#(#RegionSpec 					#layout: #(#Rectangle 316 151 382 175 ) 					#lineWidth: 1 ) 				#(#SliderSpec 					#layout: #(#Rectangle 8 9 29 175 ) 					#model: #sliderModel 					#orientation: #vertical ) 				#(#LabelSpec 					#layout: #(#Point 319 131 ) 					#label: #(#{Kernel.UserMessage} #key: #V #defaultString: 'V' #catalogID: #BGOK) ) 				#(#LabelSpec 					#layout: #(#Point 366 131 ) 					#name: #hueLabel 					#label: #(#{Kernel.UserMessage} #key: #H #defaultString: 'H' #catalogID: #BGOK) ) 				#(#CompositeSpecCollection 					#collection: #() 					#compositeSpec: 					#(#CompositeSpec 						#layout: #(#Rectangle 34 8 304 176 ) 						#name: #colorSpace 						#flags: 8 						#isOpaque: true ) ) 				#(#SliderSpec 					#layout: #(#Rectangle 362 9 384 133 ) 					#name: #hue 					#model: #hue 					#orientation: #vertical 					#start: 0.999 					#stop: 0 					#step: -0.001 ) 				#(#SliderSpec 					#layout: #(#Rectangle 314 9 336 133 ) 					#model: #brightness 					#orientation: #vertical 					#start: 1.0 					#stop: 0.0 					#step: -0.001 ) 				#(#SliderSpec 					#layout: #(#Rectangle 338 9 360 133 ) 					#name: #saturation 					#model: #saturation 					#orientation: #vertical 					#start: 1.0 					#stop: 0.0 					#step: -0.001 ) 				#(#LabelSpec 					#layout: #(#Point 343 131 ) 					#name: #saturationLabel 					#label: #(#{Kernel.UserMessage} #key: #S #defaultString: 'S' #catalogID: #BGOK) ) 				#(#ActionButtonSpec 					#layout: #(#Rectangle 314 202 385 232 ) 					#name: #cancelButton 					#model: #cancel 					#tabable: false 					#label: #(#{Kernel.UserMessage} #key: #Cancel #defaultString: 'Cancel' #catalogID: #BGOK) 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#Rectangle 235 202 309 232 ) 					#name: #applyButton 					#model: #accept 					#tabable: false 					#label: #(#{Kernel.UserMessage} #key: #OK #defaultString: 'OK' #catalogID: #BGOK) 					#isDefault: true ) 				#(#RegionSpec 					#layout: #(#Rectangle 12 208 81 232 ) 					#name: #foregroundChip 					#isOpaque: true 					#lineWidth: 1 ) 				#(#ActionButtonSpec 					#layout: #(#Rectangle 12 208 81 232 ) 					#name: #foregroundButton 					#flags: 0 					#model: #changeFGColor 					#tabable: false 					#label: ' ' ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 47 0 208 0 0.5 1 ) 					#name: #foregroundChipLabel 					#label: #(#{Kernel.UserMessage} #key: #Foreground #defaultString: 'Foreground' #catalogID: #BGOK) 					#style: #small ) 				#(#RegionSpec 					#layout: #(#Rectangle 116 207 185 231 ) 					#name: #backgroundChip 					#isOpaque: true 					#lineWidth: 1 ) 				#(#ActionButtonSpec 					#layout: #(#Rectangle 116 208 185 231 ) 					#name: #backgroundButton 					#flags: 0 					#model: #changeBGColor 					#tabable: false 					#label: ' ' ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 151 0 208 0 0.5 1 ) 					#name: #backgroundChipLabel 					#label: #(#{Kernel.UserMessage} #key: #Background #defaultString: 'Background' #catalogID: #BGOK) 					#style: #small ) ) ) )</body></methods><methods><class-id>Tools.ChartColorTool class</class-id> <category>resources</category><body package="BGOK">colorMenu	"UIMenuEditor new openOnClass: self andSelector: #colorMenu"	&lt;resource: #menu&gt;	^#(#PopUpMenu #(#(#{Kernel.UserMessage} #key: #NamedColors #defaultString: 'Named Colors' #catalogID: #BGOK) #(#{Kernel.UserMessage} #key: #PolicyColors #defaultString: 'Policy Colors' #catalogID: #BGOK) ) #() #(#(#PopUpMenu #(#(#{Kernel.UserMessage} #key: #black #defaultString: 'black' #catalogID: #BGOK) #(#{Kernel.UserMessage} #key: #blue #defaultString: 'blue' #catalogID: #BGOK) #(#{Kernel.UserMessage} #key: #brown #defaultString: 'brown' #catalogID: #BGOK) #(#{Kernel.UserMessage} #key: #chartreuse #defaultString: 'chartreuse' #catalogID: #BGOK) #(#{Kernel.UserMessage} #key: #cyan #defaultString: 'cyan' #catalogID: #BGOK) #(#{Kernel.UserMessage} #key: #darkCyan #defaultString: 'darkCyan' #catalogID: #BGOK) #(#{Kernel.UserMessage} #key: #darkGray #defaultString: 'darkGray' #catalogID: #BGOK) #(#{Kernel.UserMessage} #key: #darkGreen #defaultString: 'darkGreen' #catalogID: #BGOK) #(#{Kernel.UserMessage} #key: #darkMagenta #defaultString: 'darkMagenta' #catalogID: #BGOK) #(#{Kernel.UserMessage} #key: #darkRed #defaultString: 'darkRed' #catalogID: #BGOK) #(#{Kernel.UserMessage} #key: #olive #defaultString: 'olive' #catalogID: #BGOK) #(#{Kernel.UserMessage} #key: #gray #defaultString: 'gray' #catalogID: #BGOK) #(#{Kernel.UserMessage} #key: #green #defaultString: 'green' #catalogID: #BGOK) #(#{Kernel.UserMessage} #key: #lightYellow #defaultString: 'lightYellow' #catalogID: #BGOK) #(#{Kernel.UserMessage} #key: #lightGray #defaultString: 'lightGray' #catalogID: #BGOK) #(#{Kernel.UserMessage} #key: #magenta #defaultString: 'magenta' #catalogID: #BGOK) #(#{Kernel.UserMessage} #key: #navy #defaultString: 'navy' #catalogID: #BGOK) #(#{Kernel.UserMessage} #key: #orange #defaultString: 'orange' #catalogID: #BGOK) #(#{Kernel.UserMessage} #key: #orchid #defaultString: 'orchid' #catalogID: #BGOK) #(#{Kernel.UserMessage} #key: #paleGreen #defaultString: 'paleGreen' #catalogID: #BGOK) #(#{Kernel.UserMessage} #key: #pink #defaultString: 'pink' #catalogID: #BGOK) #(#{Kernel.UserMessage} #key: #purple #defaultString: 'purple' #catalogID: #BGOK) #(#{Kernel.UserMessage} #key: #red #defaultString: 'red' #catalogID: #BGOK) #(#{Kernel.UserMessage} #key: #royalBlue #defaultString: 'royalBlue' #catalogID: #BGOK) #(#{Kernel.UserMessage} #key: #salmon #defaultString: 'salmon' #catalogID: #BGOK) #(#{Kernel.UserMessage} #key: #lightCyan #defaultString: 'lightCyan' #catalogID: #BGOK) #(#{Kernel.UserMessage} #key: #springGreen #defaultString: 'springGreen' #catalogID: #BGOK) #(#{Kernel.UserMessage} #key: #veryDarkGray #defaultString: 'veryDarkGray' #catalogID: #BGOK) #(#{Kernel.UserMessage} #key: #veryLightGray #defaultString: 'veryLightGray' #catalogID: #BGOK) #(#{Kernel.UserMessage} #key: #white #defaultString: 'white' #catalogID: #BGOK) #(#{Kernel.UserMessage} #key: #yellow #defaultString: 'yellow' #catalogID: #BGOK) ) #() #(#black #blue #brown #chartreuse #cyan #darkCyan #darkGray #darkGreen #darkMagenta #darkRed #olive #gray #green #lightYellow #lightGray #magenta #navy #orange #orchid #paleGreen #pink #purple #red #royalBlue #salmon #lightCyan #springGreen #veryDarkGray #veryLightGray #white #yellow ) ) #(#PopUpMenu #(#(#{Kernel.UserMessage} #key: #Foreground #defaultString: 'Foreground' #catalogID: #BGOK) #(#{Kernel.UserMessage} #key: #Background #defaultString: 'Background' #catalogID: #BGOK) #(#{Kernel.UserMessage} #key: #SelnFrgnd #defaultString: 'Sel''n Frgnd' #catalogID: #BGOK) #(#{Kernel.UserMessage} #key: #SelnBkgnd #defaultString: 'Sel''n Bkgnd' #catalogID: #BGOK) ) #() #(#foregroundColor #backgroundColor #selectionForegroundColor #selectionBackgroundColor ) ) ) ) decodeAsLiteralArray</body></methods><methods><class-id>UI.ChartingAxisSpec class</class-id> <category>resources</category><body package="BGOK">labelPositionMenuSpec	"UIMenuEditor new openOnClass: self andSelector: #labelPositionMenuSpec"&lt;resource: #menu&gt;	^#(#PopUpMenu #(#(#{Kernel.UserMessage} #key: #None #defaultString: 'None' #catalogID: #BGOK) #(#{Kernel.UserMessage} #key: #Major #defaultString: 'Major' #catalogID: #BGOK)  #(#{Kernel.UserMessage} #key: #Division #defaultString: 'Division' #catalogID: #BGOK) #(#{Kernel.UserMessage} #key: #Edge #defaultString: 'Edge' #catalogID: #BGOK) ) #() #(#none #majorMarks  #divisionMarks #edgeMarks  ) ) decodeAsLiteralArray</body><body package="BGOK">tickPositionMenuSpec	"UIMenuEditor new openOnClass: self andSelector: #tickPositionmenuSpec"	&lt;resource: #menu&gt;	^#(#PopUpMenu #(#(#{Kernel.UserMessage} #key: #Hide #defaultString: 'Hide' #catalogID: #BGOK) #(#{Kernel.UserMessage} #key: #Cross #defaultString: 'Cross' #catalogID: #BGOK) #(#{Kernel.UserMessage} #key: #Inside #defaultString: 'Inside' #catalogID: #BGOK) #(#{Kernel.UserMessage} #key: #Outside #defaultString: 'Outside' #catalogID: #BGOK) ) #() #(#hideTick #tickCross #tickInside #tickOutside ) ) decodeAsLiteralArray</body></methods><methods><class-id>UI.ChartingAxisSpec class</class-id> <category>interface specs</category><body package="BGOK">defaultDialogSpec	"Tools.UIPainter new openOnClass: self andSelector: #defaultDialogSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: '' 			#min: #(#{Core.Point} 301 127 ) 			#max: #(#{Core.Point} 301 143 ) 			#bounds: #(#{Graphics.Rectangle} 534 616 794 972 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 8 0 169 0 -10 1 286 0 ) 					#name: #GroupBox1 					#label: 					#(#{Kernel.UserMessage} 						#key: #LinesC 						#defaultString: 'Lines:' 						#catalogID: #BGOK ) ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 10 0 -10 1 130 0 ) 					#flags: 0 					#majorKey: #{UIPainterTool} 					#minorKey: #labelConstructorSpec 					#clientKey: #labelConstructor ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 143 0 -10 1 164 0 ) 					#name: #InputField1 					#model: #unit 					#menu: #fieldMenu ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 90 0 199 0 224 0 220 0 ) 					#name: #MenuButton1 					#model: #sectionMarks 					#menu: #sectionMarksMenu ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 90 0 228 0 224 0 249 0 ) 					#name: #MenuButton2 					#model: #tickPosition 					#menu: #tickPositionMenu ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Graphics.LayoutOrigin} 20 0 256 0 ) 					#name: #CheckBox1 					#model: #borderLine 					#label: 					#(#{Kernel.UserMessage} 						#key: #Border 						#defaultString: 'Border' 						#catalogID: #BGOK ) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Graphics.LayoutOrigin} 105 0 256 0 ) 					#name: #CheckBox2 					#model: #axisLine 					#label: 					#(#{Kernel.UserMessage} 						#key: #Axis 						#defaultString: 'Axis' 						#catalogID: #BGOK ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 161 0 0 1 ) 					#name: #Label1 					#label: 					#(#{Kernel.UserMessage} 						#key: #Unit 						#defaultString: 'Unit:' 						#catalogID: #BGOK ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 15 0 250 0 0 1 ) 					#name: #Label2 					#label: 					#(#{Kernel.UserMessage} 						#key: #Ticks 						#defaultString: 'Ticks:' 						#catalogID: #BGOK ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 15 0 221 0 0 1 ) 					#name: #Label3 					#label: 					#(#{Kernel.UserMessage} 						#key: #Section 						#defaultString: 'Section:' 						#catalogID: #BGOK ) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Graphics.LayoutOrigin} 20 0 293 0 ) 					#model: #hasImageOrientedLabel 					#tabable: true 					#label: 					#(#{Kernel.UserMessage} 						#key: #LabelIsImage 						#defaultString: 'Label Is Image' 						#catalogID: #UIPainter ) ) ) ) )</body></methods><methods><class-id>UI.ChartingValueAxisSpec class</class-id> <category>resources</category><body package="BGOK">labelFormatMenuSpec	"UIMenuEditor new openOnClass: self andSelector: #labelFormatMenuSpec"	&lt;resource: #menu&gt;	^#(#PopUpMenu #(#(#{Kernel.UserMessage} #key: #General #defaultString: 'General' #catalogID: #BGOK) #(#{Kernel.UserMessage} #key: #Comma #defaultString: 'Comma' #catalogID: #BGOK) #(#{Kernel.UserMessage} #key: #Float #defaultString: 'Float' #catalogID: #BGOK) #(#{Kernel.UserMessage} #key: #Percent #defaultString: 'Percent' #catalogID: #BGOK) ) #() #(#general  #comma #float #percent  ) ) decodeAsLiteralArray</body><body package="BGOK">labelPositionMenuSpec 	"UIMenuEditor new openOnClass: self andSelector: #labelPositionMenuSpec"		&lt;resource: #menu&gt;	^#(#PopUpMenu #(#(#{Kernel.UserMessage} #key: #None #defaultString: 'None' #catalogID: #BGOK) #(#{Kernel.UserMessage} #key: #Major #defaultString: 'Major' #catalogID: #BGOK) #(#{Kernel.UserMessage} #key: #Minor #defaultString: 'Minor' #catalogID: #BGOK) #(#{Kernel.UserMessage} #key: #Division #defaultString: 'Division' #catalogID: #BGOK) #(#{Kernel.UserMessage} #key: #Edge #defaultString: 'Edge' #catalogID: #BGOK) #(#{Kernel.UserMessage} #key: #Zero #defaultString: 'Zero' #catalogID: #BGOK) ) #() #(#none #majorMarks #minorMarks #divisionMarks #edgeMarks #zeroMarks ) ) decodeAsLiteralArray</body></methods><methods><class-id>UI.ChartingValueAxisSpec class</class-id> <category>interface specs</category><body package="BGOK">defaultDialogSpec	"Tools.UIPainter new openOnClass: self andSelector: #defaultDialogSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: '' 			#min: #(#{Core.Point} 20 20 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 537 449 793 901 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 10 0 -10 1 130 0 ) 					#name: #Subcanvas1 					#flags: 0 					#majorKey: #{UIPainterTool} 					#minorKey: #labelConstructorSpec 					#clientKey: #labelConstructor ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 8 0 298 0 -10 1 396 0 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #Labels 						#defaultString: 'Labels' 						#catalogID: #BGOK ) ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 8 0 173 0 -10 1 293 0 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #LinesC 						#defaultString: 'Lines:' 						#catalogID: #BGOK ) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 146 0 -10 1 167 0 ) 					#model: #unit 					#menu: #fieldMenu ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 90 0 206 0 224 0 227 0 ) 					#model: #sectionMarks 					#menu: #sectionMarksMenu ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 90 0 235 0 224 0 256 0 ) 					#model: #tickPosition 					#menu: #tickPositionMenu ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Graphics.LayoutOrigin} 20 0 260 0 ) 					#model: #borderLine 					#label: 					#(#{Kernel.UserMessage} 						#key: #Border 						#defaultString: 'Border' 						#catalogID: #BGOK ) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Graphics.LayoutOrigin} 105 0 260 0 ) 					#model: #axisLine 					#label: 					#(#{Kernel.UserMessage} 						#key: #Axis 						#defaultString: 'Axis' 						#catalogID: #BGOK ) ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 90 0 329 0 224 0 350 0 ) 					#model: #labelFormat 					#menu: #labelFormatMenu ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 90 0 359 0 224 0 380 0 ) 					#model: #labelPosition 					#menu: #labelPositionMenu ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 165 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #Unit 						#defaultString: 'Unit:' 						#catalogID: #BGOK ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 15 0 253 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #Ticks 						#defaultString: 'Ticks:' 						#catalogID: #BGOK ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 15 0 225 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #Section 						#defaultString: 'Section:' 						#catalogID: #BGOK ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 15 0 348 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #Format 						#defaultString: 'Format:' 						#catalogID: #BGOK ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 15 0 378 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #PositionC 						#defaultString: 'Position:' 						#catalogID: #BGOK ) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Graphics.LayoutOrigin} 13 0 402 0 ) 					#name: #CheckBox2 					#model: #hasImageOrientedLabel 					#tabable: true 					#label: 					#(#{Kernel.UserMessage} 						#key: #LabelIsImage 						#defaultString: 'Label Is Image' 						#catalogID: #UIPainter ) ) ) ) )</body></methods><methods><class-id>Examples.BG_Company class</class-id> <category>windowSpec</category><body package="BGOK">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: #(#{Kernel.UserMessage} #key: #Employees #defaultString: 'Employees' #catalogID: #BGOK) 			#bounds: #(#Rectangle 306 282 621 533 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#ChartViewSpec 					#layout: #(#LayoutFrame 13 0 4 0 -5 1 -6 1 ) 					#model: #employees 					#chartType: #BG_LineChartView 					#orientation: #vertical 					#dataSeries: 					#(#ChartDataSpec 						#series: #(							#(#ChartDataSetSpec 								#aspect: #salary 								#name: 'Salary' 								#look: 								#(#ChartElementLookSpec 									#lineWidth: 3 ) ) 							#(#ChartDataSetSpec 								#aspect: #name 								#isData: false 								#name: 'Name' ) 							#(#ChartDataSetSpec 								#aspect: #age 								#name: 'Age' 								#look: 								#(#ChartElementLookSpec 									#foregroundColor: #(#ColorValue #blue ) 									#backgroundColor: #(#ColorValue #blue ) 									#lineType: #dashed 									#lineWidth: 3 ) ) ) ) 					#xAxis: 					#(#ChartingAxisSpec 						#sectionMarkAt: #divisionMarks ) 					#yAxis: 					#(#ChartingValueAxisSpec 						#scale: 						#(#ChartingScaleSpec 							#invert: true ) ) 					#legendPosition: 6 ) ) ) )</body></methods><methods><class-id>Tools.ChartScaleSpecModel class</class-id> <category>interface specs</category><body package="BGOK">defaultPropertySpec	"UIPainter new openOnClass: self andSelector: #defaultPropertySpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: '' 			#min: #(#Point 20 20 ) 			#bounds: #(#Rectangle 61 203 318 501 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#CheckBoxSpec 					#layout: #(#Point 10 30 ) 					#name: #autoScaleBox 					#model: #autoScale 					#label: #(#{Kernel.UserMessage} #key: #AutoScale #defaultString: 'Auto Scale' #catalogID: #BGOK) ) 				#(#CheckBoxSpec 					#layout: #(#Point 10 55 ) 					#model: #invert 					#label: #(#{Kernel.UserMessage} #key: #InvertScale #defaultString: 'Invert Scale' #catalogID: #BGOK) ) 				#(#InputFieldSpec 					#layout: #(#Rectangle 62 95 112 120 ) 					#name: #zeroField 					#model: #zero 					#menu: #fieldMenu 					#type: #number ) 				#(#InputFieldSpec 					#layout: #(#Rectangle 181 95 231 120 ) 					#name: #divField 					#model: #minorDivisions 					#menu: #fieldMenu 					#type: #number ) 				#(#InputFieldSpec 					#layout: #(#Rectangle 62 128 112 153 ) 					#name: #minField 					#model: #min 					#menu: #fieldMenu 					#type: #number ) 				#(#InputFieldSpec 					#layout: #(#Rectangle 181 128 231 153 ) 					#name: #maxField 					#model: #max 					#menu: #fieldMenu 					#type: #number ) 				#(#InputFieldSpec 					#layout: #(#Rectangle 62 161 112 186 ) 					#name: #stepField 					#model: #step 					#menu: #fieldMenu 					#type: #number ) 				#(#RadioButtonSpec 					#layout: #(#Point 21 219 ) 					#name: #scaleNormal 					#model: #scaleType 					#label: #(#{Kernel.UserMessage} #key: #Normal #defaultString: 'Normal' #catalogID: #BGOK) 					#select: #normal ) 				#(#RadioButtonSpec 					#layout: #(#Point 21 243 ) 					#name: #scaleLog 					#model: #scaleType 					#label: #(#{Kernel.UserMessage} #key: #Log #defaultString: 'Log' #catalogID: #BGOK) 					#select: #log ) 				#(#InputFieldSpec 					#layout: #(#Rectangle 181 241 231 266 ) 					#name: #baseField 					#model: #base 					#menu: #fieldMenu 					#type: #number ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 10 0 154 0 0 1 ) 					#name: #minLabel 					#label: #(#{Kernel.UserMessage} #key: #Min #defaultString: 'Min:' #catalogID: #BGOK) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 132 0 154 0 0 1 ) 					#name: #maxLabel 					#label: #(#{Kernel.UserMessage} #key: #Max #defaultString: 'Max:' #catalogID: #BGOK) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 10 0 121 0 0 1 ) 					#name: #zeroLabel 					#label: #(#{Kernel.UserMessage} #key: #ZeroC #defaultString: 'Zero:' #catalogID: #BGOK) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 10 0 186 0 0 1 ) 					#name: #stepLabel 					#label: #(#{Kernel.UserMessage} #key: #StepC #defaultString: 'Step:' #catalogID: #BGOK) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 132 0 121 0 0 1 ) 					#name: #divLabel 					#label: #(#{Kernel.UserMessage} #key: #Div #defaultString: 'Div:' #catalogID: #BGOK) ) 				#(#GroupBoxSpec 					#layout: #(#LayoutFrame 10 0 195 0 -10 1 276 0 ) 					#label: #(#{Kernel.UserMessage} #key: #ScaleType #defaultString: 'Scale Type:' #catalogID: #BGOK) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 132 0 267 0 0 1 ) 					#name: #baseLabel 					#label: #(#{Kernel.UserMessage} #key: #Base #defaultString: 'Base:' #catalogID: #BGOK) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 0 0.5 4 0 0.5 0 ) 					#label: #(#{Kernel.UserMessage} #key: #Scale #defaultString: 'Scale' #catalogID: #BGOK) ) ) ) )</body></methods><methods><class-id>UI.BarChartOptionsSpec class</class-id> <category>interface specs</category><body package="BGOK">defaultDialogSpec	"UIPainter new openOnClass: self andSelector: #defaultDialogSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: '' 			#min: #(#Point 20 20 ) 			#bounds: #(#Rectangle 82 274 344 640 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#GroupBoxSpec 					#layout: #(#LayoutFrame 10 0 72 0 -10 1 177 0 ) 					#label: #(#{Kernel.UserMessage} #key: #DataLocation #defaultString: 'Data Location:' #catalogID: #BGOK) ) 				#(#RadioButtonSpec 					#layout: #(#Point 21 94 ) 					#model: #dataLocation 					#label: #(#{Kernel.UserMessage} #key: #None #defaultString: 'None' #catalogID: #BGOK) 					#select: #none ) 				#(#RadioButtonSpec 					#layout: #(#Point 21 121 ) 					#model: #dataLocation 					#label: #(#{Kernel.UserMessage} #key: #Inside #defaultString: 'Inside' #catalogID: #BGOK) 					#select: #inside ) 				#(#RadioButtonSpec 					#layout: #(#Point 21 148 ) 					#model: #dataLocation 					#label: #(#{Kernel.UserMessage} #key: #Outside #defaultString: 'Outside' #catalogID: #BGOK) 					#select: #outside ) 				#(#CheckBoxSpec 					#layout: #(#Point 10 184 ) 					#name: #linkLine 					#model: #showLink 					#label: #(#{Kernel.UserMessage} #key: #LinkLine #defaultString: 'Link Line' #catalogID: #BGOK) ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 90 0 237 0 -16 1 262 0 ) 					#model: #picture 					#menu: #fieldMenu 					#type: #symbol ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 90 0 272 0 -16 1 297 0 ) 					#model: #unit 					#menu: #fieldMenu 					#type: #number ) 				#(#LabelSpec 					#layout: #(#Point 10 11 ) 					#label: #(#{Kernel.UserMessage} #key: #BarWidth #defaultString: 'Bar Width:' #catalogID: #BGOK) ) 				#(#LabelSpec 					#layout: #(#Point 10 40 ) 					#label: #(#{Kernel.UserMessage} #key: #BarOverlap #defaultString: 'Bar Overlap:' #catalogID: #BGOK) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 18 0 263 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #Aspect #defaultString: 'Aspect:' #catalogID: #BGOK) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 19 0 298 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #Unit #defaultString: 'Unit:' #catalogID: #BGOK) ) 				#(#GroupBoxSpec 					#layout: #(#LayoutFrame 10 0 211 0 -10 1 308 0 ) 					#label: #(#{Kernel.UserMessage} #key: #PictureC #defaultString: 'Picture:' #catalogID: #BGOK) ) 				#(#SliderSpec 					#layout: #(#LayoutFrame 120 0 10 0 -10 1 33 0 ) 					#model: #barWidth 					#orientation: #horizontal 					#start: 0.2 					#stop: 1 					#step: 0.1 ) 				#(#SliderSpec 					#layout: #(#LayoutFrame 120 0 40 0 -10 1 63 0 ) 					#model: #barOverlap 					#orientation: #horizontal 					#start: -1 					#stop: 1 					#step: 0.2 ) ) ) )</body></methods><methods><class-id>UI.ChartViewSpec class</class-id> <category>resources</category><body package="BGOK">chartTypeMenu	"UIMenuEditor new openOnClass: self andSelector: #chartTypeMenu"	&lt;resource: #menu&gt;	^#(#PopUpMenu #(#(#{Kernel.UserMessage} #key: #Bar #defaultString: 'Bar' #catalogID: #BGOK) #(#{Kernel.UserMessage} #key: #Pareto #defaultString: 'Pareto' #catalogID: #BGOK) #(#{Kernel.UserMessage} #key: #Picture #defaultString: 'Picture' #catalogID: #BGOK) #(#{Kernel.UserMessage} #key: #StackedBar #defaultString: 'StackedBar' #catalogID: #BGOK) #(#{Kernel.UserMessage} #key: #Band #defaultString: 'Band' #catalogID: #BGOK) #(#{Kernel.UserMessage} #key: #Layer #defaultString: 'Layer' #catalogID: #BGOK) #(#{Kernel.UserMessage} #key: #Line #defaultString: 'Line' #catalogID: #BGOK) #(#{Kernel.UserMessage} #key: #StackedLine #defaultString: 'StackedLine' #catalogID: #BGOK) #(#{Kernel.UserMessage} #key: #Step #defaultString: 'Step' #catalogID: #BGOK) #(#{Kernel.UserMessage} #key: #XY #defaultString: 'XY' #catalogID: #BGOK) #(#{Kernel.UserMessage} #key: #Pie #defaultString: 'Pie' #catalogID: #BGOK) ) #(6 10 ) #(#BG_BarChartView #BG_ParatoChartView #BG_PictureChartView #BG_StackedBarChartView #BG_BandChartView #BG_LayerChartView #BG_LineChartView #BG_StackedLineChartView #BG_StepChartView #BG_XYChartView #BG_PieChartView ) ) decodeAsLiteralArray</body><body package="BGOK">paletteIcon	"UIMaskEditor new openOnClass: self andSelector: #paletteIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 26@26 depth: 3 bitsPerPixel: 4 palette: (MappedPalette withColors: ((Array new: 8) at: 1 put: ColorValue black; at: 2 put: (ColorValue scaledRed: 6553 scaledGreen: 6553 scaledBlue: 6553); at: 3 put: (ColorValue scaledRed: 3822 scaledGreen: 3822 scaledBlue: 3822); at: 4 put: ColorValue white; at: 5 put: (ColorValue scaledRed: 7645 scaledGreen: 0 scaledBlue: 0); at: 6 put: (ColorValue scaledRed: 0 scaledGreen: 0 scaledBlue: 3822); at: 7 put: (ColorValue scaledRed: 0 scaledGreen: 3822 scaledBlue: 0); at: 8 put: ColorValue blue; yourself)) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@L3L3L3L3L3L3L3L2@@@@@CDQDQDQDQDQDQDQD @@@@@1DQDQDQDQDQDQDQH@@@@@LP@@@@@@@@@@@@@R@@@@@CDCL3L3L3L3L3L0D @@@@@1@3L3L3L5M#P7LAH@@@@@LPL3L3L3L@@@@C@R@@@@@CDCL3L3L3L3L3L0D @@@@@1@CUUL3L3L3L3LAH@@@@@LPL5USL3L3L3L3@R@@@@@CDCMUT3L3L3M7\0D @@@@@1@3UUL3L3L3]7LAH@@@@@LP@5USY&amp;L3L7]3@R@@@@@CDCMUT6Y#L3M7\0D @@@@@1@3UUM&amp;X3L3]7LAH@@@@@LPL5USY&amp;L3L7]3@R@@@@@CD@MUT6Y#QDM7\0D @@@@@1@3UUM&amp;X4QC]7LAH@@@@@LPL5USY&amp;MDP7]3@R@@@@@CDCMUT6Y#QDM7\0D @@@@@1@3UUM&amp;X4QC]7LAH@@@@@LP@@@@@@@@@@@@@R@@@@@CDQDQDQDQDQDQDQD @@@@@"H"H"H"H"H"H"H"H@@@@@@@@@@@@@@@@@@@@@@@@@@b'))</body><body package="BGOK">paletteMonoIcon	"UIMaskEditor new openOnClass: self andSelector: #paletteMonoIcon"	&lt;resource: #image&gt;	^(Image extent: 26@26 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 255 255 192 128 0 0 192 128 0 0 192 159 255 254 192 144 0 2 192 144 2 170 192 144 3 250 192 144 0 2 192 155 128 2 192 147 128 2 192 147 128 58 192 147 128 58 192 155 184 58 192 147 184 58 192 147 184 58 192 147 184 58 192 155 187 186 192 147 187 186 192 147 187 186 192 147 187 186 192 147 187 186 192 159 255 254 192 128 0 0 192 128 0 0 192 255 255 255 192 255 255 255 192 ])</body></methods><methods><class-id>UI.ChartViewSpec class</class-id> <category>interface specs</category><body package="BGOK">defaultDialogSpec	"UIPainter new openOnClass: self andSelector: #defaultDialogSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #BGOK) 			#min: #(#Point 20 20 ) 			#bounds: #(#Rectangle 98 185 345 516 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#LabelSpec 					#layout: #(#AlignmentOrigin 10 0 54 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #Aspect #defaultString: 'Aspect:' #catalogID: #BGOK) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 10 0 85 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #ID #defaultString: 'ID:' #catalogID: #BGOK) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 10 0 115 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #Type #defaultString: 'Type:' #catalogID: #BGOK) ) 				#(#GroupBoxSpec 					#layout: #(#LayoutFrame 10 0 123 0 -10 1 179 0 ) 					#label: #(#{Kernel.UserMessage} #key: #Orientation #defaultString: 'Orientation' #catalogID: #BGOK) ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 86 0 28 0 -10 1 53 0 ) 					#model: #model 					#menu: #fieldMenu ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 86 0 59 0 -10 1 84 0 ) 					#model: #name 					#menu: #fieldMenu ) 				#(#MenuButtonSpec 					#layout: #(#Rectangle 86 90 220 114 ) 					#model: #setChartType 					#menu: #chartTypeMenu ) 				#(#RadioButtonSpec 					#layout: #(#AlignmentOrigin 18 0 170 0 0 1 ) 					#model: #orientation 					#label: #(#{Kernel.UserMessage} #key: #Vertical #defaultString: 'Vertical' #catalogID: #BGOK) 					#select: #vertical ) 				#(#RadioButtonSpec 					#layout: #(#AlignmentOrigin 110 0 170 0 0 1 ) 					#model: #orientation 					#label: #(#{Kernel.UserMessage} #key: #Horizontal #defaultString: 'Horizontal' #catalogID: #BGOK) 					#select: #horizontal ) ) ) )</body><body package="BGOK">legendDialogSpec	"UIPainter new openOnClass: self andSelector: #legendDialogSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: '' 			#min: #(#Point 20 20 ) 			#bounds: #(#Rectangle 97 278 354 576 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#GroupBoxSpec 					#layout: #(#LayoutFrame 14 0 7 0 130 0 143 0 ) 					#label: #(#{Kernel.UserMessage} #key: #Position #defaultString: 'Position' #catalogID: #BGOK) ) 				#(#RadioButtonSpec 					#layout: #(#AlignmentOrigin 139 0 41 0 0 0.5 ) 					#model: #position 					#label: #(#{Kernel.UserMessage} #key: #Hidden #defaultString: 'Hidden' #catalogID: #BGOK) 					#select: 0 ) 				#(#RadioButtonSpec 					#layout: #(#LayoutOrigin 39 0 32 0 ) 					#model: #position 					#select: 1 ) 				#(#RadioButtonSpec 					#layout: #(#LayoutOrigin 60 0 32 0 ) 					#model: #position 					#select: 2 ) 				#(#RadioButtonSpec 					#layout: #(#Rectangle 82 32 105 50 ) 					#model: #position 					#select: 3 ) 				#(#RadioButtonSpec 					#layout: #(#AlignmentOrigin 44 0 56 0 1 0 ) 					#model: #position 					#select: 4 ) 				#(#RadioButtonSpec 					#layout: #(#LayoutOrigin 60 0 56 0 ) 					#model: #position 					#select: 5 ) 				#(#RadioButtonSpec 					#layout: #(#LayoutOrigin 103 0 56 0 ) 					#model: #position 					#select: 6 ) 				#(#RadioButtonSpec 					#layout: #(#AlignmentOrigin 44 0 74 0 1 0 ) 					#model: #position 					#select: 7 ) 				#(#RadioButtonSpec 					#layout: #(#LayoutOrigin 60 0 74 0 ) 					#model: #position 					#select: 8 ) 				#(#RadioButtonSpec 					#layout: #(#LayoutOrigin 103 0 74 0 ) 					#model: #position 					#select: 9 ) 				#(#RadioButtonSpec 					#layout: #(#AlignmentOrigin 44 0 93 0 1 0 ) 					#model: #position 					#select: 10 ) 				#(#RadioButtonSpec 					#layout: #(#LayoutOrigin 60 0 93 0 ) 					#model: #position 					#select: 11 ) 				#(#RadioButtonSpec 					#layout: #(#LayoutOrigin 103 0 93 0 ) 					#model: #position 					#select: 12 ) 				#(#RadioButtonSpec 					#layout: #(#LayoutOrigin 39 0 117 0 ) 					#model: #position 					#select: 13 ) 				#(#RadioButtonSpec 					#layout: #(#LayoutOrigin 60 0 117 0 ) 					#model: #position 					#select: 14 ) 				#(#RadioButtonSpec 					#layout: #(#LayoutOrigin 82 0 117 0 ) 					#model: #position 					#select: 15 ) 				#(#GroupBoxSpec 					#layout: #(#LayoutFrame 44 0 53 0 99 0 113 0 ) ) ) ) )</body></methods><methods><class-id>Examples.BG_EzChart class</class-id> <category>windowSpec2</category><body package="BGOK">windowSpec2	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec2"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #EasyChart2 				#defaultString: 'Easy Chart 2' 				#catalogID: #BGOK ) 			#min: #(#{Core.Point} 20 20 ) 			#bounds: #(#{Graphics.Rectangle} 800 600 1065 791 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ChartViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 5 0 -5 1 -5 1 ) 					#model: #data2 					#dataSeries: 					#(#{UI.ChartDataSpec} 						#series: #(							#(#{UI.ChartDataSetSpec} 								#name: 'Data1' ) 							#(#{UI.ChartDataSetSpec} 								#name: 'Data2' ) 							#(#{UI.ChartDataSetSpec} 								#isData: false 								#name: 'Labels' ) ) ) ) ) ) )</body></methods><methods><class-id>Examples.BG_EzChart class</class-id> <category>windowSpec</category><body package="BGOK">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec		#window:		#(#WindowSpec			#label: #(#{Kernel.UserMessage} #key: #EasyChart1 #defaultString: 'Easy Chart 1' #catalogID: #BGOK)			#min: #(#Point 20 20 )			#bounds: #(#Rectangle 217 233 482 424 ) )		#component:		#(#SpecCollection			#collection: #(				#(#ChartViewSpec					#layout: #(#LayoutFrame 5 0 5 0 -5 1 -5 1 )					#model: #data ) ) ) )</body></methods><methods><class-id>UI.PieChartOptionsSpec class</class-id> <category>interface specs</category><body package="BGOK">defaultDialogSpec	"UIPainter new openOnClass: self andSelector: #defaultDialogSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: '' 			#min: #(#Point 20 20 ) 			#bounds: #(#Rectangle 103 351 360 649 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#GroupBoxSpec 					#layout: #(#LayoutFrame 10 0 107 0 -10 1 207 0 ) 					#label: #(#{Kernel.UserMessage} #key: #Data #defaultString: 'Data:' #catalogID: #BGOK) ) 				#(#GroupBoxSpec 					#layout: #(#LayoutFrame 10 0 210 0 -4 0.5 290 0 ) 					#label: #(#{Kernel.UserMessage} #key: #Shape #defaultString: 'Shape:' #catalogID: #BGOK) ) 				#(#GroupBoxSpec 					#layout: #(#LayoutFrame 4 0.5 210 0 -10 1 290 0 ) 					#label: #(#{Kernel.UserMessage} #key: #LinesC #defaultString: 'Lines:' #catalogID: #BGOK) ) 				#(#RadioButtonSpec 					#layout: #(#Point 24 128 ) 					#model: #dataLocation 					#label: #(#{Kernel.UserMessage} #key: #Hide #defaultString: 'Hide' #catalogID: #BGOK) 					#select: #hideData ) 				#(#RadioButtonSpec 					#layout: #(#Point 24 176 ) 					#model: #dataLocation 					#label: #(#{Kernel.UserMessage} #key: #Adjacent #defaultString: 'Adjacent' #catalogID: #BGOK) 					#select: #dataAdjacent ) 				#(#RadioButtonSpec 					#layout: #(#Point 24 152 ) 					#model: #dataLocation 					#label: #(#{Kernel.UserMessage} #key: #Below #defaultString: 'Below' #catalogID: #BGOK) 					#select: #dataBelow ) 				#(#RadioButtonSpec 					#layout: #(#LayoutOrigin 14 0.5 257 0 ) 					#model: #lines 					#label: #(#{Kernel.UserMessage} #key: #Hide #defaultString: 'Hide' #catalogID: #BGOK) 					#select: #hide ) 				#(#RadioButtonSpec 					#layout: #(#LayoutOrigin 14 0.5 232 0 ) 					#model: #lines 					#label: #(#{Kernel.UserMessage} #key: #Show #defaultString: 'Show' #catalogID: #BGOK) 					#select: #show ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 12 0 31 0 -10 1 56 0 ) 					#model: #explode 					#menu: #fieldMenu 					#type: #string ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 12 0 83 0 -10 1 108 0 ) 					#model: #dLabel 					#menu: #fieldMenu 					#type: #string ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 10 0 32 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #LabelsToExplode #defaultString: 'Labels to Explode:' #catalogID: #BGOK) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 10 0 83 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #DoughnutLabel #defaultString: 'Doughnut Label:' #catalogID: #BGOK) ) 				#(#RadioButtonSpec 					#layout: #(#Point 18 232 ) 					#model: #shape 					#label: #(#{Kernel.UserMessage} #key: #Circle #defaultString: 'Circle' #catalogID: #BGOK) 					#select: #circle ) 				#(#RadioButtonSpec 					#layout: #(#Point 18 257 ) 					#model: #shape 					#label: #(#{Kernel.UserMessage} #key: #Ellipse #defaultString: 'Ellipse' #catalogID: #BGOK) 					#select: #ellipse ) ) ) )</body></methods><methods><class-id>Examples.BG_Sales class</class-id> <category>windowSpec</category><body package="BGOK">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec		#window:		#(#WindowSpec			#label: #(#{Kernel.UserMessage} #key: #SalesByPlatform #defaultString: 'Sales by Platform' #catalogID: #BGOK)			#bounds: #(#Rectangle 310 277 593 482 ) )		#component:		#(#SpecCollection			#collection: #(				#(#ChartViewSpec					#layout: #(#LayoutFrame 2 0 2 0 -10 1 -2 1 )					#model: #sales					#chartType: #BG_LineChartView					#dataSeries:					#(#ChartDataSpec						#series: #(							#(#ChartDataSetSpec								#aspect: #salesWin								#name: 'Windows'								#look:								#(#ChartElementLookSpec									#lineWidth: 3 ) )							#(#ChartDataSetSpec								#aspect: #salesMac								#name: 'Mac'								#look:								#(#ChartElementLookSpec									#lineWidth: 3 ) )							#(#ChartDataSetSpec								#aspect: #month								#isData: false								#name: 'Month' ) ) )					#xAxis:					#(#ChartingAxisSpec						#sectionMarkAt: #divisionMarks )					#yAxis:					#(#ChartingValueAxisSpec						#scale:						#(#ChartingScaleSpec							#invert: true )						#unit: 'Boxes' )					#legendPosition: 3 ) ) ) )</body></methods><methods><class-id>Tools.ChartDataSpecModel class</class-id> <category>interface specs</category><body package="BGOK">defaultPropertySpec	"UIPainter new openOnClass: self andSelector: #defaultPropertySpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: '' 			#min: #(#Point 20 20 ) 			#bounds: #(#Rectangle 562 343 889 729 ) )		#component: 		#(#SpecCollection 			#collection: #(				#(#LabelSpec 					#layout: #(#Point 10 13 ) 					#label: #(#{Kernel.UserMessage} #key: #DataSet #defaultString: 'Data Set:' #catalogID: #BGOK) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 17 0 147 0 0 1 ) 					#name: #nameLabel 					#label: #(#{Kernel.UserMessage} #key: #Name #defaultString: 'Name:' #catalogID: #BGOK) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 17 0 176 0 0 1 ) 					#name: #aspectLabel 					#label: #(#{Kernel.UserMessage} #key: #Aspect #defaultString: 'Aspect:' #catalogID: #BGOK) ) 				#(#GroupBoxSpec 					#layout: #(#LayoutFrame 10 0 95 0 -10 1 283 0 ) 					#label: #(#{Kernel.UserMessage} #key: #Attributes #defaultString: 'Attributes:' #catalogID: #BGOK) ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame -82 0.5 51 0 -16 0.5 81 0 ) 					#name: #newSeriesButton 					#model: #newSeries 					#label: #(#{Kernel.UserMessage} #key: #New #defaultString: 'New' #catalogID: #BGOK) 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 16 0.5 51 0 82 0.5 81 0 ) 					#name: #deleteButton 					#model: #deleteSeries 					#label: #(#{Kernel.UserMessage} #key: #Delete #defaultString: 'Delete' #catalogID: #BGOK) 					#defaultable: true ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 90 0 121 0 -16 1 146 0 ) 					#name: #nameField 					#flags: 40 					#model: #seriesName 					#callbacksSpec: 					#(#UIEventCallbackSubSpec 						#valueChangeSelector: #redefinedName ) 					#menu: #fieldMenu ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 90 0 150 0 -16 1 175 0 ) 					#name: #aspectField 					#flags: 40 					#model: #seriesAspect 					#callbacksSpec: 					#(#UIEventCallbackSubSpec 						#valueChangeSelector: #redefinedAspect ) 					#menu: #fieldMenu 					#type: #symbol ) 				#(#CheckBoxSpec 					#layout: #(#Point 17 182 ) 					#name: #labelCheckBox 					#model: #isLabel 					#label: #(#{Kernel.UserMessage} #key: #Label #defaultString: 'Label' #catalogID: #BGOK) ) 				#(#CheckBoxSpec 					#layout: #(#Point 17 207 ) 					#name: #computedCheckBox 					#model: #isComputed 					#label: #(#{Kernel.UserMessage} #key: #Computed #defaultString: 'Computed' #catalogID: #BGOK) ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 20 0 242 0 -2 0.33 272 0 ) 					#name: #colorToolButton 					#model: #colorTool 					#label: #(#{Kernel.UserMessage} #key: #Color #defaultString: 'Color...' #catalogID: #BGOK) 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 2 0.33 242 0 -18 0.67 272 0 ) 					#name: #lineLookToolButton 					#model: #lineLookTool 					#label: #(#{Kernel.UserMessage} #key: #LinesDot #defaultString: 'Lines...' #catalogID: #BGOK) 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame -14 0.67 242 0 -20 1 272 0 ) 					#name: #regionLookToolButton 					#model: #regionLookTool 					#label: #(#{Kernel.UserMessage} #key: #Patterns #defaultString: 'Patterns...' #catalogID: #BGOK) 					#defaultable: true ) 				#(#MenuButtonSpec 					#layout: #(#LayoutFrame 93 0 13 0 -10 1 36 0 ) 					#name: #dataSeriesMenuButton 					#model: #dataSeries 					#menu: #dataSeriesMenu ) ) ) )</body></methods><methods><class-id>Tools.ToolbarIconLibrary class</class-id> <category>resources</category><body package="BGOK">chartWidget20x20	"Tools.UIMaskEditor new openOnClass: self andSelector: #chartWidget20x20"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 4 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 9) at: 1 put: Graphics.ColorValue black; at: 2 put: (Graphics.ColorValue scaledRed: 0 scaledGreen: 0 scaledBlue: 4111); at: 3 put: (Graphics.ColorValue scaledRed: 0 scaledGreen: 4111 scaledBlue: 0); at: 4 put: Graphics.ColorValue red; at: 5 put: Graphics.ColorValue white; at: 6 put: (Graphics.ColorValue scaledRed: 7644 scaledGreen: 0 scaledBlue: 0); at: 7 put: (Graphics.ColorValue scaledRed: 0 scaledGreen: 0 scaledBlue: 3822); at: 8 put: (Graphics.ColorValue scaledRed: 0 scaledGreen: 3822 scaledBlue: 0); at: 9 put: Graphics.ColorValue blue; yourself)) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@ADQDQDQDQDQDP@@@ADQDQDQFQ4UHP@@@ADQDQDQ@@@@@P@@@ADQDQDQDQDQDP@@@@DY&amp;QDQDQDQDP@@@ADY&amp;QDQDQDQDP@@@ADY&amp;QDQDQD"HP@@@ADY&amp;QDQDQD"HP@@@@DY&amp;Q7]DQD"HP@@@ADY&amp;Q7]DQD"HP@@@ADY&amp;Q7]DQD"HP@@@ADY&amp;Q7]DQD"HP@@@@DY&amp;Q7]EUT"HP@@@ADY&amp;Q7]EUT"HP@@@ADY&amp;Q7]EUT"HP@@@ADY&amp;Q7]EUT"HP@@@ADY&amp;Q7]EUT"HP@@@ADDQP"ICL4"HP@@@@@@@@@@@@@@@@@@@'))</body><body package="BGOK">chartWidget20x20mask	"Tools.UIMaskEditor new openOnClass: self andSelector: #chartWidget20x20mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 255 240 0 128 0 16 0 128 21 80 0 128 31 208 0 128 0 16 0 220 0 16 0 156 0 16 0 156 1 208 0 156 1 208 0 221 193 208 0 157 193 208 0 157 193 208 0 157 193 208 0 221 221 208 0 157 221 208 0 157 221 208 0 157 221 208 0 157 221 208 0 157 221 208 0 255 255 240 0])</body></methods><initialize><class-id>UI.BG_ChartView</class-id></initialize><initialize><class-id>UI.BG_Label</class-id></initialize><initialize><class-id>UI.BG_DataPointMarker</class-id></initialize><initialize><class-id>UI.ChartViewSpec</class-id></initialize><initialize><class-id>UI.BG_ChartElement</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>VisualComponent</name><environment>Graphics</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Visual Objects</category><attributes><package>Graphics-Visual Objects</package></attributes></class><class><name>Label</name><environment>UI</environment><super>Graphics.VisualComponent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>text attributes width offset needsScan fontPolicy verticalAlignment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Support</category><attributes><package>UIBasics-Support</package></attributes></class><class><name>LookPreferences</name><environment>UI</environment><super>UI.ColorPreferencesCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>foregroundColor backgroundColor selectionForegroundColor selectionBackgroundColor borderColor hiliteColor shadowColor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Support</category><attributes><package>Interface-Support</package></attributes></class><class><name>VisualPart</name><environment>Graphics</environment><super>Graphics.VisualComponent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>container eventHandlers properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Visual Objects</category><attributes><package>Graphics-Visual Objects</package></attributes></class><class><name>DependentComposite</name><environment>Graphics</environment><super>Graphics.CompositePart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>model </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Visual Objects</category><attributes><package>Graphics-Visual Objects</package></attributes></class><class><name>SubSpec</name><environment>UI</environment><super>UI.UISpecification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Specifications</category><attributes><package>UIBuilder-Specifications</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>GeometricWrapper</name><environment>Graphics</environment><super>Graphics.VisualComponent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>geometric </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Geometrical Objects</category><attributes><package>Graphics-Geometrical Objects</package></attributes></class><class><name>SimpleDialog</name><environment>UI</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>close accept cancel preBuildBlock postBuildBlock postOpenBlock escapeIsCancel parentView useParentColors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Dialogs</category><attributes><package>Interface-Dialogs</package></attributes></class><class><name>WidgetSpec</name><environment>UI</environment><super>UI.NamedSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>model callbacksSpec tabable helpText helpField </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Specifications</category><attributes><package>UIBuilder-Specifications</package></attributes></class><class><name>SpecModel</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>specChannel </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Specifications</category><attributes><package>UIPainter</package></attributes></class><class><name>ArrayedCollection</name><environment>Core</environment><super>Core.SequenceableCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class></st-source>