<?xml version="1.0"?><st-source><!-- Name: Browser-SupportNotice: Copyright 2016 Cincom Systems, Inc.  All rights reserved.Comment: This package contains support for language specific services provided by the refactoring browser.DbIdentifier: bear73DbTrace: 487887DbUsername: smichaelDbVersion: 8.2 - 2PackageName: Browser-SupportParcel: #('Browser-Support')ParcelName: Browser-SupportPrintStringCache: (8.2 - 2,smichael)Version: 8.2 - 2Date: 3:26:52 PM June 30, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (jun17.4) of June 23, 2017 on June 30, 2017 at 3:26:52 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>LanguageServices</name><environment>Refactory.Browser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>languages </inst-vars><class-inst-vars>default </class-inst-vars><imports></imports><category></category><attributes><package>Browser-Support</package></attributes></class><comment><class-id>Refactory.Browser.LanguageServices</class-id><body>LanguageServices provides information about programming languages that the RB can use to support those languages, such as what parser class to use, how to catch compilation errors in the source code editor, what plugins and decorations to use in the source code editor and any other language related stuff that might be switched based on which programming language you're writing in.This class can be extended to add methods that contain programs #language:category: or #language:category:priority: which are used to populate the default instance. If more than one pragma for the same language+category combination exists, the value becomes an ordered array of values. You may also add categories, which must be defined with methods using the #category: pragma to indicate whether they contain a single value (#value) or an array of values (#array). Categories are common to all languages, but not every category or service must be implemented for each language.Instance Variables:	languages	&lt;Dictionary&gt;	A dictionary of languages to categories to valuesClass Instance Variables:	default	&lt;LanguageServices&gt;	The singleton instance of this class</body></comment><methods><class-id>Refactory.Browser.LanguageServices</class-id> <category>accessing</category><body package="Browser-Support">language: aLanguage category: aCategory ifAbsent: absentBlock	^(languages at: aLanguage ifAbsent: [^absentBlock value])		at: aCategory ifAbsent: [^absentBlock value]</body><body package="Browser-Support">languageForClass: aClass ifAbsent: aBlock	"Language can be determined from the class's defined compilerClass."	aClass ifNil: [^aBlock value].	^self languageForCompilerClass: aClass compilerClass ifAbsent: [aBlock]</body><body package="Browser-Support">languageForCompilerClass: aCompilerClass ifAbsent: aBlock	^self value: aCompilerClass category: #compilerClass ifAbsent: [		self languagesAndValuesFor: #compilerClass do: [:language :class |			(aCompilerClass inheritsFrom: class) ifTrue: [				^language]].		aBlock value]</body><body package="Browser-Support">value: aValue category: aCategory ifAbsent: absentBlock	languages keysAndValuesDo: [:language :categories |		categories at: aCategory ifPresent: [:value |			value = aValue ifTrue: [^language]]].	^absentBlock value</body></methods><methods><class-id>Refactory.Browser.LanguageServices</class-id> <category>initialize-release</category><body package="Browser-Support">initialize	| dictionary |	dictionary := Dictionary new.	self languageServices do: [:service |		[:language :category :value |			| languageEntry categoryEntry |			languageEntry := dictionary at: language ifAbsentPut: [self serviceCategories].			categoryEntry := languageEntry at: category ifAbsent: [nil].			categoryEntry == nil				ifTrue: [languageEntry at: #unknown put: category]				ifFalse: [					categoryEntry class == Array						ifTrue: [categoryEntry := categoryEntry copyWith: value]						ifFalse: [categoryEntry := value].					languageEntry at: category put: categoryEntry]		] valueWithArguments: service].	"Prune all unused categories."	dictionary associationsDo: [:lang |		| dict removes |		dict := lang value.		removes := dict associations select: [:assoc | 			assoc value == #none or: [assoc value class == Array and: [assoc value isEmpty]]].		removes do: [:ea |			dict removeKey: ea key]].		languages := dictionary</body><body package="Browser-Support">languageServices	^((Tools.Pragma allNamed: #language:category:priority: from: self class to: LanguageServices sortedByArgument: 3)		collect: [:pragma | (pragma arguments first: 2), (Array with: (self perform: pragma selector))]),	  ((Tools.Pragma allNamed: #language:category: from: self class to: LanguageServices)		collect: [:pragma | pragma arguments, (Array with: (self perform: pragma selector))])</body><body package="Browser-Support">serviceCategories	"Provide a sparse Dictionary with placeholders to be filled in from service pragmas.	 This will be pruned of empty or unused items during initialization."	^(Tools.Pragma allNamed: #category: from: self class to: LanguageServices)		inject: Dictionary new			into: [:dict :pragma |				dict at: (self perform: pragma selector) ifAbsentPut: [					(pragma argumentAt: 1) = #value ifTrue: [#none] ifFalse: [#()]].				dict]</body></methods><methods><class-id>Refactory.Browser.LanguageServices</class-id> <category>enumerating</category><body package="Browser-Support">languagesAndValuesFor: aCategory do: aBlockClosure	languages keysAndValuesDo: [:language :categories |		categories at: aCategory ifPresent: [:value |			aBlockClosure value: language value: value]]</body></methods><methods><class-id>Refactory.Browser.LanguageServices class</class-id> <category>accessing</category><body package="Browser-Support">default	^default ifNil: [default := self new]</body><body package="Browser-Support">reset	default := nil</body></methods><methods><class-id>Refactory.Browser.LanguageServices class</class-id> <category>instance creation</category><body package="Browser-Support">new	^super new initialize</body></methods><methods><class-id>Refactory.Browser.LanguageServices class</class-id> <category>compiling</category><body package="Browser-Support">instanceMethodsChanged	self reset</body></methods><methods><class-id>Refactory.Browser.LanguageServices</class-id> <category>smalltalk</category><body package="Browser-Support">smalltalkCloseDelimiters	&lt;language: #smalltalk category: #closeDelimiters&gt;	^'|}])''"'</body><body package="Browser-Support">smalltalkCompilerClass	&lt;language: #smalltalk category: #compilerClass&gt;	^Kernel.Compiler</body><body package="Browser-Support">smalltalkDelimiterEscaping	&lt;language: #smalltalk category: #delimiterEscaping&gt;	^Dictionary new		at: (Array with: $' with: $') put: (Dictionary new			at: $' put: [:document :position :direction |				((position + direction) &lt;= document size and: [(document at: position + direction) = $'])					ifTrue: [position + direction]					ifFalse: [position]];			yourself);		yourself</body><body package="Browser-Support">smalltalkNestingDelimiters	&lt;language: #smalltalk category: #nestingDelimiters&gt;	^'{}[]()'</body><body package="Browser-Support">smalltalkOpenDelimiters	&lt;language: #smalltalk category: #openDelimiters&gt;	^'|{[(''"'</body><body package="Browser-Support">smalltalkParserClass	&lt;language: #smalltalk category: #parserClass&gt;	^RBParser</body></methods><methods><class-id>Refactory.Browser.LanguageServices</class-id> <category>service categories</category><body package="Browser-Support">closeDelimitersCategory	&lt;category: #value&gt;	^#closeDelimiters</body><body package="Browser-Support">compilerClassCategory	&lt;category: #value&gt;	^#compilerClass</body><body package="Browser-Support">delimiterEscapingCategory	&lt;category: #value&gt;	^#delimiterEscaping</body><body package="Browser-Support">nestingDelimitersCategory	&lt;category: #value&gt;	^#nestingDelimiters</body><body package="Browser-Support">openDelimitersCategory	&lt;category: #value&gt;	^#openDelimiters</body><body package="Browser-Support">parserClassCategory	&lt;category: #value&gt;	^#parserClass</body></methods><methods><class-id>Refactory.Browser.LanguageServices class</class-id> <category>pragmas</category><body package="Browser-Support">pragmas	&lt;pragmas: #instance&gt;	^#(category: language:category: language:category:priority:)</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class></st-source>