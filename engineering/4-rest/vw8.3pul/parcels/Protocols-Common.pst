<?xml version="1.0"?><st-source><!-- Name: Protocols-CommonNotice: Copyright 1999-2017 Cincom Systems, Inc.  All rights reserved.Comment: These are common Base extensions that are shared by various network communication and security frameworks.DbIdentifier: bear73DbTrace: 500276DbUsername: jkottDbVersion: 8.3 - 5DevelopmentPrerequisites: #(#(#any 'Protocol-Common-Namespace' ''))PackageName: Protocols-CommonParcel: #('Protocols-Common')ParcelName: Protocols-CommonPrerequisiteDescriptions: #(#(#name 'Protocol-Common-Namespace' #componentType #package))PrerequisiteParcels: #(#('Protocol-Common-Namespace' ''))PrintStringCache: (8.3 - 5,jkott)Version: 8.3 - 5Date: 1:17:52 PM July 14, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (jul17.2) of July 14, 2017 on July 14, 2017 at 1:17:52 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>AnnouncementLogger</name><environment>Protocols</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>isLogging accessProtect announcements announcers </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Protocols-Common</package></attributes></class><comment><class-id>Protocols.AnnouncementLogger</class-id><body>AnnouncementLogger is superclass that provides generic announcement logging facilities.A logger is created for a specified set of announcers via that #announcers: instance creation message. It can also be configured for specific set of announcements to log. By default all announcements are logged. A logger can be suspended or active which is controlled with the #start/#stop messages. When stopped, nothing is logged. Logger is created in the stopped state.Received announcements are processed with the #log: method, which must be defined by the concrete logger subclasses. There is no default behavior for this, it's marked as subclassResponsibility. As different announcements can have widely different shape, concrete loggers will likely want to employ double dispatch against the announcement object to transform the announcements to a form suitable for its specific logging target (be it a file, an internal log structure, a database, a network logging target, a statistics collector, etc). Note that announcements can be volatile, i.e. they may carry parameters that can change after the announcement is delivered, so in some cases it may be desirable to take a suitable snapshot of the announcement state, rather than simply retaining the announcement instance itself.Note that all invocations of the #log: method are serialized with an internal access lock, which is usually desirable because most logging targets need to be protected against concurrent access. This also usually defines suitable transactional boundaries for the logging action (e.g. to make sure that parts of two separate log records do not end up being interleaved). However care should be taken designing the logging action to keep the critical section minimal, as the announcements can be delivered by processes where a too large a delay in the logging activity can be detrimental. If the logging action is particularly expensive, it may be worthwhile to offload at least some of it to an additional background process managed by the logger.Subclasses must implement the following messages:	services		log:Instance Variables	isLogging	&lt;Boolean&gt; defines is the logger in on or off	accessProtect	&lt;RecursionLock&gt; protects the resource to log announcements	announcements	&lt;AnnouncementSet&gt; which announcements should we subscribed to	announcers	&lt;Array of: Announcer&gt; which announcers should we subscribed to</body></comment><class><name>AnnouncementCollector</name><environment>Protocols</environment><super>Protocols.AnnouncementLogger</super><private>false</private><indexed-type>none</indexed-type><inst-vars>log </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Protocols-Common</package></attributes></class><comment><class-id>Protocols.AnnouncementCollector</class-id><body>This is a trivial logger example that simply collects all received announcements in an internal collection. There are no provisions for controlling the size of the collection, it will keep growing as long as the logger is active.Instance Variables	log	&lt;OrderedCollection of: Announcement&gt;</body></comment><class><name>CachedReadStream</name><environment>Protocols</environment><super>Core.PeekableStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream cache </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XMK-Streams</category><attributes><package>Protocols-Common</package></attributes></class><comment><class-id>Protocols.CachedReadStream</class-id><body>This stream allows to skip back and forward relative to the current position of the underlying stream, without requiring the undelying stream to be capable of positioning or skipping. This is achieved by caching the input from the underlying stream in a fixed size buffer. Consequently maximum size of the skip back is limited by the size of the cache and obviously by the current position within the buffer. Skipping forward is unlimited but the cache has to follow along to the target position. Once a previously read element falls out of the bottom of the cache it is not accessible anymore. The underlying stream is moving only forward never back.The API is identical to other read streams with the exception of #skip: behavior being always predictable, regardless of the type of the underlying stream. This also motivates addition of message #previous, a counterpart of #next, however only time will show how useful will this capability be in practice.Another important difference is that this stream explicitly translates the EndOfStreamNotification into a hard IncompleteNextCountError. I believe that the whole deal with the notification and returning a nil as the result of #next at the end of the stream is a mistake, so this is an attempt to start moving away from this behavior. We'll see if I'll have to back down on this one. The name EndOfStream for the error would probably be better, however the IncompleteNextCountError has been used for a very similar purpose for a long time so I have doubts about introducing a new exception class for almost the same thing.The cache is implemented as a circular buffer used as a FIFO queue. It has a pointer to the current "top", i.e. pointing at the latest element read in from the stream, and a "position" pointer to the current position within the buffer. Consequently the position can back off from the top one full length of the buffer, but not more. Initially the buffer is empty and only fills up as elements are read from the stream. Once it fills up the "oldest" elements will start "falling out" of the bottom of the buffer as new elements are added at the top.The implementation also pays special attention to the block based APIs based on #next:into:startingAt:, translating that to as few block calls as possible. This allows taking advantage of block based copying primitives and can push through larger quantities of data more efficiently. This is clearly an optimization, but the difference is significant enough in most non-trivial applications.Instance Variables:	stream	&lt;Stream&gt; underlying stream	cache	&lt;CircularBuffer&gt; internal buffer for the stream</body></comment><class><name>CachedWriteStream</name><environment>Protocols</environment><super>Protocols.CachedReadStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XMK-Streams</category><attributes><package>Protocols-Common</package></attributes></class><comment><class-id>Protocols.CachedWriteStream</class-id><body>This stream allows to skip back and forward relative to the current position of the underlying stream, without requiring the underlying stream to be capable of positioning or skipping. This is achieved by caching the written elements in a fixed size buffer. Consequently maximum size of the skip back is limited by the size of the buffer and obviously by the current position within the buffer. Skipping forward is also limited by the top of the buffer, because that represents the absolute end of the write stream. Once a previously written element falls out of the bottom of the buffer it gets written into the underlying stream and is not accessible anymore. The underlying write stream is moving only forward never back. Since the stream is tracking the bottom of the buffer, not the top, it is possible to rewrite elements many times while they are in the buffer. The stream also provides reading capability within the confines of the buffer which can also be useful with some types of algorithms. Note however, that the reading and writing operations share the same position pointer. So a #next moves the position the same way as #nextPut:. So, for example	(String new writeStream writeCache: 5) nextPutAll: 'abcdef'; skip: -4; next: 2; nextPutAll: 'EF'; contents yields result 'abcdEF'. Otherwise the API is identical to other write streams, however it is important to note that it is important to #flush or #close the stream in order to get the buffered elements written into the underlying stream. That applies equally to both internal and external streams.The implementation also pays special attention to the block based APIs based on #next:putAll:startingAt:, translating that to as few block calls as possible. This allows taking advantage of block based copying primitives and can push through larger quantities of data more efficiently. This is clearly an optimization, but the difference is significant enough in most non-trivial applications.</body></comment><class><name>EventProcessor</name><environment>Protocols</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>accessProtect </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk</category><attributes><package>Protocols-Common</package></attributes></class><comment><class-id>Protocols.EventProcessor</class-id><body>This is the abstract event processor. It takes any message that it does not understand and treats it as an event, i.e. it runs it through the #process: method. Processing is protected by a recursion lock to serialize events coming in from multiple processes. Concrete subclasses should specify the processing by defining the #privateProcess: method.Instance Variables:	accessProtect	&lt;RecursionLock&gt; process serializer to protect event processing logic</body></comment><class><name>EventPrinter</name><environment>Protocols</environment><super>Protocols.EventProcessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>label </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk</category><attributes><package>Protocols-Common</package></attributes></class><comment><class-id>Protocols.EventPrinter</class-id><body>This class provides for printing broker event messages to a Stream or to the Transcript.Instance Variables:	accessProtect	&lt;Semaphore&gt;	mutex for event logging</body></comment><class><name>MessageForwarder</name><environment>Protocols</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars>object </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Protocols-Common</category><attributes><package>Protocols-Common</package></attributes></class><comment><class-id>Protocols.MessageForwarder</class-id><body>This class is a generic message forwarder. It's protocol is absolutely minimal, only #doesNotUnderstand: and couple of supporting methods prefixed with $_ to minimize the chance of clashes.Instance Variables:	object	&lt;Object&gt; undocumented</body></comment><class><name>OutputParameter</name><environment>Protocols</environment><super>Protocols.MessageForwarder</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Protocols-Common</category><attributes><package>Protocols-Common</package></attributes></class><comment><class-id>Protocols.OutputParameter</class-id><body>Output parameters are remote call parameters that can change value during the call. They can be used to carry one value to the server and bring different value from the server.</body></comment><class><name>AnnouncementPrinter</name><environment>Protocols</environment><super>Protocols.AnnouncementLogger</super><private>false</private><indexed-type>none</indexed-type><inst-vars>out </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Protocols-Common</package></attributes></class><comment><class-id>Protocols.AnnouncementPrinter</class-id><body>This is a simple logger example that logs printStrings of incoming announcements into a write stream. It can be used to log announcements into the Transcript (the default setup), standard out, or a file stream. Note that it does not open or close the stream, that is responsibility of the provider of the stream.Instance Variables	out	&lt;WriteStream&gt;</body></comment><class><name>ArgumentTransformer</name><environment>Core</environment><super>Core.EvaluableAction</super><private>false</private><indexed-type>none</indexed-type><inst-vars>block </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk</category><attributes><package>Protocols-Common</package></attributes></class><comment><class-id>Core.ArgumentTransformer</class-id><body>This class is intended to help with setting up broker event handlers (or any object event handlers for that matter). The existing event-API implemented in Object provides a lot of flexibility, however there isn't anything that would allow to transform an event with X arguments into a message with Y arguments. That's what this class is meant for. It's transformation block will receive all the event arguments and produces one output argument. If you need several output arguments, setup corresponding number of argument transformers. An example event handler can look like following:	broker objectAdaptor		when: #exportedObject:ooid:in:		send: #show:		to: Transcript		with: (ArgumentTransformer withBlock: [ :args |			'Exported &lt;1p&gt; with ooid &lt;2p&gt;' expandMacrosWithArguments: args ])Instance Variables:	block	&lt;BlockClosure&gt;	one parameter block defining the argument transformation</body></comment><class><name>CircularBuffer</name><environment>Protocols</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cache top position full atTop </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ComputingStreams</category><attributes><package>Protocols-Common</package></attributes></class><comment><class-id>Protocols.CircularBuffer</class-id><body>Instance Variables:	cache	&lt;SequenceableCollection&gt; internal buffer for the cache	top	&lt;Integer&gt; index of the last occupied slot	position	&lt;Integer&gt; maintains current position, index of the last processed element	full	&lt;Boolean&gt; indicates that the cache has filled up and started wrapping around	atTop	&lt;Boolean&gt; indicates that the current position is "at the top", i.e. postion = top and is not backed up all the way</body></comment><class><name>EventConverter</name><environment>Protocols</environment><super>Protocols.EventProcessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>next converter </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk</category><attributes><package>Protocols-Common</package></attributes></class><comment><class-id>Protocols.EventConverter</class-id><body>I'm a generic event transformer. I'm supposed to take an event run it through my 'converter' and then pass it on to the 'next' processor in line. An example of my use is EventProcessor&gt;&gt;attachReceiver: which transforms an event Message into a MessageSend.Instance Variables:	next	&lt;EventProcessor&gt; next processor in the line	converter	&lt;BlockClosure&gt; converter block</body></comment><class><name>DecodedStreamConstructor</name><environment>Protocols</environment><super>Core.InternalEncodedStreamConstructor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Protocols-Common</category><attributes><package>Protocols-Common</package></attributes></class><comment><class-id>Protocols.DecodedStreamConstructor</class-id><body>This constructor helps building decoded streams on top of Strings. It also maintains a registry of additional encoders for decoded stream that is separate from the general StreamEncoder registry.Shared Class Variables:	Encoders	&lt;Dictionary key: Symbol value: (Class | StreamEncoder) &gt; maps encoding names to encoder factories</body></comment><class><name>IPMulticastRequest</name><environment>Protocols</environment><super>Core.UninterpretedBytes</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Protocols-Common</category><attributes><package>Protocols-Common</package></attributes></class><comment><class-id>Protocols.IPMulticastRequest</class-id><body>To use multicast, socket options must be set, and the argument required is a C structure.  This class implements the argument structure for IP_ADD_MEMBERSHIP and IP_DROP_MEMBERSHIP.  See netinet/in.h	sturct ip_mreq {		struct in_addr imr_multiaddr; /* IP multicast address of group */		struct in_addr imr_interface; '* local IP address of interface */	}</body></comment><class><name>Base64FastCoder</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>shiftRegister valuesLeft inputStream quartetMap </inst-vars><class-inst-vars>mapArray quartetMap nullInteger </class-inst-vars><imports></imports><category></category><attributes><package>Protocols-Common</package></attributes></class><comment><class-id>Base64FastCoder</class-id><body>Encode and decode between ByteArrays and base64-encoded ByteStrings or ByteArrays.  Encoding is a class-side method.  Decoding creates an instance with a shift register which can hold all four values of a base64 quartet in locations of the same register.  The implementation does not write line ends while encoding, nor does it expect to encounter them when decoding.  The base64 character set is held as a string literal.  The encoding and decoding integer values are computed from it during class initialization and held in class-instance variables.Instance Variables	shiftRegister	&lt;Integer&gt;	shifted character-valued integer holding an overall value corresponding to the quartet 	valuesLeft		&lt;Integer&gt;	the number (3, 2, 1 or 0) of characters in the quartet remaining to be processed	inputStream	&lt;ReadStream&gt;	a stream on the input base-64 encoded stringClass Instance Variables	mapArray		&lt;ByteArray&gt; the base 64 characters as integers	nullInteger	&lt;Integer&gt; the base64 no-more-data character ($=) asInteger	quartetMap	&lt;ByteArray&gt; at each integer value of a base 64 character, holds the decoding value</body></comment><class><name>ProtoObject</name><environment>Protocols</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Protocols-Common</category><attributes><package>Protocols-Common</package></attributes></class><comment><class-id>Protocols.ProtoObject</class-id><body>This is a trimmed down version of Object with a reduced set of basic capabilities. The recognized set of selectors is chosen so that there's is only minimal probability of conflict with application domain selectors (we intentionally avoid things like #value, #size, #name, etc). Note however that in order to satisfy some of the more prevalent expectations of the environment we do define #=, #==, #hash and #class.</body></comment><class><name>Struct</name><environment>Protocols</environment><super>Protocols.ProtoObject</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>name lastIndex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Protocols-Common</category><attributes><package>Protocols-Common</package></attributes></class><comment><class-id>Protocols.Struct</class-id><body>Struct is aimed to replace the 'struct' construct from C-like languages. Member elements of Structs can be accessed using usual Smalltalk accessor convention. Alternatively Structs also support Dictionary like protocol #at:, #at:put:, etc. Note however that unlike Dictionary the order of elements is maintained. When a new element is added it is added at the end. Structs, like Dictionaries, grow automatically when necessary.Instance Variables:	name	&lt;String&gt; struct name; accessed as #structName	lastIndex	&lt;Integer&gt; index of the last element</body></comment><class><name>TimedPromise</name><environment>Protocols</environment><super>Core.Promise</super><private>false</private><indexed-type>none</indexed-type><inst-vars>delay </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>IMAPSupport</category><attributes><package>Protocols-Common</package></attributes></class><comment><class-id>Protocols.TimedPromise</class-id><body>A TimedPromise represents the same  value as a Promise does.  An attempt to read the value of a TimedPromise will wait until the process has finished computing it or the specified timeout expires.  If the process terminates with an exception, an attempt to read the value of the TimedPromise will raise the same exception. In case of the timeout the OsNeedRetryError will be raised.Instance Variables:	delay	&lt;Delay&gt;	TimedPromise is using the delay semaphore to tells the consumers there is information available	ms	&lt;Number&gt;	The number of milliseconds to create Delay</body></comment><class><name>Base64StreamEncoder</name><environment>Protocols</environment><super>Core.StreamEncoder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>index nibble nEncoded </inst-vars><class-inst-vars>sextetMap octetMap </class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>Protocols-Common</package></attributes></class><comment><class-id>Protocols.Base64StreamEncoder</class-id><body>Base64StreamEncoder is used to encode and decode base64 formatInstance Variables:	index	&lt;Number&gt;	octet index 	nEncoded	&lt;ArithmeticValue&gt;	number of encoded octets	nibble	&lt;Integer&gt;	octet to encode or decode</body></comment><class><name>PromiseExpiredError</name><environment>Protocols</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Protocols-Common</package></attributes></class><class><name>EventCollector</name><environment>Protocols</environment><super>Protocols.EventPrinter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>events baseClockValue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk</category><attributes><package>Protocols-Common</package></attributes></class><comment><class-id>Protocols.EventCollector</class-id><body>This class is for collecting broker event messages. Every event is recorded with millisecond clock value of its occurence (see #log:). The class also provides event printing services (see #toTranscript).Instance Variables:	events			&lt;OrderedCollection&gt;		of (SmallInteger-&gt;Message) records of logged events	baseClockValue	&lt;SmallInteger&gt;			allows to record 'starting' clock value, relative to which the event trace will be printed out</body></comment><class><name>SharedRegistry</name><environment>Protocols</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>elements lock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Protocols-Common</category><attributes><package>Protocols-Common</package></attributes></class><comment><class-id>Protocols.SharedRegistry</class-id><body>This is a keyed registry of objects suitable for use by multiple concurrent processes. It provides extended accessing methods that allow coupling actions with registry operations "atomically", i.e. within the same criticial region.Instance Variables:	elements	&lt;Dictionary&gt; registered elements	lock	&lt;RecursionLock&gt; access lock</body></comment><class><name>DecodedStream</name><environment>Protocols</environment><super>Core.EncodedStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cache crPreceeding </inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.IOConstants.*			</imports><category>HTTP</category><attributes><package>Protocols-Common</package></attributes></class><comment><class-id>Protocols.DecodedStream</class-id><body>This is the inverse of EncodedStream. It expects character stream below which are decoded by this stream into bytes on read and bytes are encoded to characters on writing.Instance Variables:	cache	&lt;ReadWriteStream&gt; an internal cache for individual character encoding bytes	crPreceeding	&lt;Boolean&gt; indicates if previously written byte was 13 (CR)</body></comment><class><name>B64StreamDecoder</name><environment>Protocols</environment><super>Core.StreamEncoder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>quart offset leftover lineLength finishing </inst-vars><class-inst-vars>defaultLineLength </class-inst-vars><imports>			OS.IOConstants.*			</imports><category>Protocols-Common</category><attributes><package>Protocols-Common</package></attributes></class><comment><class-id>Protocols.B64StreamDecoder</class-id><body>This is a Base64 encoder intended for use with the DecodedStream, therefore it expects to convert bytes into characters of Base64 encoding as specified in RFC 2045.Example - Writing	| stream input |	input := ByteArray withAll: (1 to: 32).	stream := DecodedStream 				on: String new writeStream 				encodedBy: B64StreamDecoder asEncoder. 	stream nextPutAll: input.	stream close.	stream encodedContents.Example - Reading	| stream input |	input := 'AQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGRobHB0eHyA='.	stream := DecodedStream 				on: input readStream 				encodedBy: B64StreamDecoder asEncoder. 	stream contents.RFC 2045: Internet Message Bodies; chapter 6.8. Base64 Content-Transfer-EncodingThe Base64 Content-Transfer-Encoding is designed to represent arbitrary sequences of octets in a form that need not be humanly readable.  The encoding and decoding algorithms are simple, but the encoded data are consistently only about 33 percent larger than the unencoded data.  This encoding is virtually identical to the one used in Privacy Enhanced Mail (PEM) applications, as defined in RFC 1421.A 65-character subset of US-ASCII is used, enabling 6 bits to be represented per printable character. (The extra 65th character, "=", is used to signify a special processing function.)NOTE:  This subset has the important property that it is represented identically in all versions of ISO 646, including US-ASCII, and all characters in the subset are also represented identically in all versions of EBCDIC. Other popular encodings, such as the encoding used by the uuencode utility, Macintosh binhex 4.0 [RFC-1741], and the base85 encoding specified as part of Level 2 PostScript, do not share these properties, and thus do not fulfill the portability requirements a binary transport encoding for mail must meet.The encoding process represents 24-bit groups of input bits as output strings of 4 encoded characters.  Proceeding from left to right, a 24-bit input group is formed by concatenating 3 8bit input groups. These 24 bits are then treated as 4 concatenated 6-bit groups, each of which is translated into a single digit in the base64 alphabet. When encoding a bit stream via the base64 encoding, the bit stream must be presumed to be ordered with the most-significant-bit first. That is, the first bit in the stream will be the high-order bit in the first 8bit byte, and the eighth bit will be the low-order bit in the first 8bit byte, and so on.Each 6-bit group is used as an index into an array of 64 printable characters.  The character referenced by the index is placed in the output string.  These characters, identified in Table 1, below, are selected so as to be universally representable, and the set excludes characters with particular significance to SMTP (e.g., ".", CR, LF) and to the multipart boundary delimiters defined in RFC 2046 (e.g., "-").	Table 1: The Base64 Alphabet	0 A		17 R		34 i			51 z	1 B		18 S		35 j			52 0	2 C		19 T		36 k		53 1	3 D		20 U		37 l			54 2	4 E		21 V		38 m		55 3	5 F		22 W		39 n		56 4	6 G		23 X		40 o		57 5	7 H		24 Y		41 p		58 6	8 I		25 Z		42 q		59 7	9 J		26 a		43 r			60 8	10 K	27 b		44 s		61 9	11 L	28 c		45 t			62 +	12 M	29 d		46 u		63 /	13 N	30 e		47 v	14 O	31 f			48 w		(pad) =	15 P	32 g		49 x	16 Q	33 h		50 yThe encoded output stream must be represented in lines of no more than 76 characters each.  All line breaks or other characters not found in Table 1 must be ignored by decoding software.  In base64 data, characters other than those in Table 1, line breaks, and other white space probably indicate a transmission error, about which a warning message or even a message rejection might be appropriate under some circumstances.Special processing is performed if fewer than 24 bits are available at the end of the data being encoded.  A full encoding quantum is always completed at the end of a body.  When fewer than 24 input bits are available in an input group, zero bits are added (on the right) to form an integral number of 6-bit groups.  Padding at the end of the data is performed using the "=" character.  Since all base64 input is an integral number of octets, only the following cases can arise: (1) the final quantum of encoding input is an integral multiple of 24 bits; here, the final unit of encoded output will be an integral multiple of 4 characters with no "=" padding, (2) the final quantum of encoding input is exactly 8 bits; here, the final unit of encoded output will be two characters followed by two "=" padding characters, or (3) the final quantum of encoding input is exactly 16 bits; here, the final unit of encoded output will be three characters followed by one "=" padding character.Because it is used only for padding at the end of the data, the occurrence of any "=" characters may be taken as evidence that the end of the data has been reached (without truncation in transit).  No such assurance is possible, however, when the number of octets transmitted was a multiple of three and no "=" characters are present.Any characters outside of the base64 alphabet are to be ignored in base64-encoded data.Care must be taken to use the proper octets for line breaks if base64 encoding is applied directly to text material that has not been converted to canonical form.  In particular, text line breaks must be converted into CRLF sequences prior to base64 encoding.  The important thing to note is that this may be done directly by the encoder rather than in a prior canonicalization step in some implementations.NOTE: There is no need to worry about quoting potential boundary delimiters within base64-encoded bodies within multipart entities because no hyphen characters are used in the base64 encoding.Instance Variables:	quart	&lt;Integer&gt; zero based offset of the next character in current quartet {0,1,2,3}	offset	&lt;Integer&gt; zero based offset of the next character on current line	leftover	&lt;Integer&gt; whatever is left over from the previous octet	lineLength	&lt;Integer&gt; specifies the line length where to emit CR and wrap to the next line when encoding	finishing	&lt;Boolean&gt; flag indicating if we're reading final pad characters $=Class Instance Variables:	defaultLineLength	&lt;Integer&gt; specifies the default line length where to emit CR and wrap to the next line when encodingShared Class Variables:	LineLength	&lt;Integer&gt; the line length where we should emit CR and wrap to the next line	OctetMap	&lt;Dictionary key: Character value: Integer&gt; maps characters to sextets	SextetMap	&lt;String&gt; maps sextets (indices) to characters	Whitespace	&lt;Object&gt; undocumented	Zeros	&lt;Stream&gt; an infinite stream of zeros</body></comment><shared-variable><name>Encoder</name><environment>Protocols.Base64StreamEncoder</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><initializer>nil</initializer><attributes><package>Protocols-Common</package></attributes></shared-variable><shared-variable><name>OctetMap</name><environment>Protocols.B64StreamDecoder</environment><private>false</private><constant>false</constant><category>all</category><initializer>nil</initializer><attributes><package>Protocols-Common</package></attributes></shared-variable><shared-variable><name>Zeros</name><environment>Protocols.B64StreamDecoder</environment><private>false</private><constant>false</constant><category>all</category><initializer>nil</initializer><attributes><package>Protocols-Common</package></attributes></shared-variable><shared-variable><name>Whitespace</name><environment>Protocols.B64StreamDecoder</environment><private>false</private><constant>false</constant><category>all</category><initializer>nil</initializer><attributes><package>Protocols-Common</package></attributes></shared-variable><shared-variable><name>SextetMap</name><environment>Protocols.B64StreamDecoder</environment><private>false</private><constant>false</constant><category>all</category><initializer>nil</initializer><attributes><package>Protocols-Common</package></attributes></shared-variable><shared-variable><name>Encoders</name><environment>Protocols.DecodedStreamConstructor</environment><private>false</private><constant>false</constant><category>As yet unclassified </category><initializer>IdentityDictionary new</initializer><attributes><package>Protocols-Common</package></attributes></shared-variable><methods><class-id>Protocols.AnnouncementLogger</class-id> <category>services</category><body package="Protocols-Common">log: anAnnouncement	^self subclassResponsibility</body><body package="Protocols-Common">start	self isLogging ifTrue: [^self].	accessProtect critical: [		isLogging := true.		self startLogging ]</body><body package="Protocols-Common">stop	self isLogging ifFalse: [^self].	accessProtect critical: [		isLogging := false.		self stopLogging ]</body></methods><methods><class-id>Protocols.AnnouncementLogger</class-id> <category>accessing</category><body package="Protocols-Common">announcements	^announcements ifNil: [ Announcement ]</body><body package="Protocols-Common">announcers	^announcers</body></methods><methods><class-id>Protocols.AnnouncementLogger</class-id> <category>logging</category><body package="Protocols-Common">privateLog: ann	accessProtect critical: [ self log: ann ]</body><body package="Protocols-Common">startLogging	self announcers do: [ :annoucer | self startLogging: annoucer]</body><body package="Protocols-Common">startLogging: anAnnoucer	anAnnoucer		when: self announcements		do: [ :ann | isLogging ifTrue: [ self privateLog: ann ] ]		for: self</body><body package="Protocols-Common">stopLogging	self announcers do: [ :announcer | self stopLogging: announcer ].</body><body package="Protocols-Common">stopLogging: anAnnoucer	anAnnoucer unsubscribe: self</body></methods><methods><class-id>Protocols.AnnouncementLogger</class-id> <category>testing</category><body package="Protocols-Common">isLogging	^isLogging</body></methods><methods><class-id>Protocols.AnnouncementLogger</class-id> <category>initialize-release</category><body package="Protocols-Common">announcements: classes	announcements := classes</body><body package="Protocols-Common">announcers: anObjectOrCollection	anObjectOrCollection isSequenceable 		ifTrue: [ announcers addAll: anObjectOrCollection ] 		ifFalse: [ announcers add: anObjectOrCollection ]</body><body package="Protocols-Common">initialize	isLogging := false.	accessProtect := RecursionLock new.	announcers := OrderedCollection new.</body></methods><methods><class-id>Protocols.AnnouncementLogger class</class-id> <category>instance creation</category><body package="Protocols-Common">announcers: anObjectOrOrderedCollection	^self new announcers: anObjectOrOrderedCollection</body><body package="Protocols-Common">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Protocols.AnnouncementCollector</class-id> <category>initialize-release</category><body package="Protocols-Common">initialize	super initialize.	self resetLog.</body><body package="Protocols-Common">resetLog	log := OrderedCollection new</body></methods><methods><class-id>Protocols.AnnouncementCollector</class-id> <category>accessing</category><body package="Protocols-Common">log	^log</body></methods><methods><class-id>Protocols.AnnouncementCollector</class-id> <category>services</category><body package="Protocols-Common">log: announcement	log add: announcement</body></methods><methods><class-id>Protocols.CachedReadStream</class-id> <category>private</category><body package="Protocols-Common">contentsSpecies	^stream contentsSpecies</body><body package="Protocols-Common">pullNext	^[	stream next	]	on: EndOfStreamNotification		do: [ :ex | "resignal the notification as hard error"			ex resignalAs: (				IncompleteNextCountError new					messageText: ex messageText;					parameter: 0 "this is supposed to be the size of bytes read";					yourself ) ]</body><body package="Protocols-Common">skipBack: step	| size |	size := cache skipBack: step.	size = step ifFalse: [ self steppingUnderTheBottom: size ]</body><body package="Protocols-Common">skipForward: step	| size left |	size := cache skipForward: step.	size = step ifTrue: [ ^self ].	left := step - size.	"pull the rest from the stream"	left &gt; cache size ifTrue: [		stream skip: left - cache size.		left := cache size ].	cache next: left putAll: stream.	^self</body><body package="Protocols-Common">steppingUnderTheBottom: size	^IncompleteNextCountError new		messageText: 'Cannot skip back past the buffer limits!';		parameter: size;		raise</body></methods><methods><class-id>Protocols.CachedReadStream</class-id> <category>accessing</category><body package="Protocols-Common">next	^cache nextIfNone: [ cache nextPut: self pullNext ]</body><body package="Protocols-Common">next: total into: target startingAt: start	| cached newTotal newStart |	"read what is in the buffer"	cached := cache next: total into: target startingAt: start.	cached = total ifTrue: [ ^target ].	"pull the rest from the stream"	newTotal := total - cached.	newStart := start + cached.	stream next: newTotal into: target startingAt: newStart.	"update the buffer from the end of the target"	cache 		next: (newTotal min: cache size)		putAll: target		startingAt: (start + total - cache size max: newStart).	^target</body><body package="Protocols-Common">previous	^cache previousIfNone: [ self steppingUnderTheBottom: 0 ]</body><body package="Protocols-Common">skip: step	step &lt; 0		ifTrue: [ self skipBack: step negated ]		ifFalse: [ self skipForward: step ]</body></methods><methods><class-id>Protocols.CachedReadStream</class-id> <category>testing</category><body package="Protocols-Common">atEnd	^cache atEnd and: [ stream atEnd ]</body><body package="Protocols-Common">isReadable	"Answer whether the stream implements #next."	^true</body><body package="Protocols-Common">isWritable	"Answer whether the stream implements #nextPut:."	^true</body></methods><methods><class-id>Protocols.CachedReadStream</class-id> <category>status</category><body package="Protocols-Common">close	cache clear.	stream close</body></methods><methods><class-id>Protocols.CachedReadStream</class-id> <category>initialize-release</category><body package="Protocols-Common">initializeFor: next size: size	stream := next.	cache := CircularBuffer cache: (self contentsSpecies new: size)</body></methods><methods><class-id>Protocols.CachedReadStream class</class-id> <category>instance creation</category><body package="Protocols-Common">wrap: stream cache: size	^self basicNew		initializeFor: stream		size: size</body></methods><methods><class-id>Protocols.CachedWriteStream</class-id> <category>testing</category><body package="Protocols-Common">atEnd	^cache atEnd</body><body package="Protocols-Common">isWritable	"Answer whether the stream implements #nextPut:."	^true</body></methods><methods><class-id>Protocols.CachedWriteStream</class-id> <category>status</category><body package="Protocols-Common">close	self commit.	stream close</body><body package="Protocols-Common">commit	self flush.	stream commit</body></methods><methods><class-id>Protocols.CachedWriteStream</class-id> <category>accessing</category><body package="Protocols-Common">contents	self flush.	^stream contents</body><body package="Protocols-Common">flush"Flush everything that was written so far (regardless of the current position) and empty the buffer.Note that this necessarily sets the position to the end of written data (to the top), because once flushed there's no access to previously written elements." 	cache reset.	cache next: cache size into: stream.	stream flush.	cache clear</body><body package="Protocols-Common">next	^cache nextIfNone: [ self steppingOverTheTop: 0 ]</body><body package="Protocols-Common">next: total into: target startingAt: start"Only allow reading within the cache. Raise IncompleteNextCountError if reading past the top of the buffer."	| size |	size := cache next: total into: target startingAt: start.	^total = size		ifTrue: [ target ]		ifFalse: [ self steppingOverTheTop: size ]</body><body package="Protocols-Common">next: total putAll: source startingAt: start	| size left next |	size := cache headroom min: total.	cache next: size putAll: source startingAt: start.	size = total ifTrue: [^source].	left := total - size.	next := start + size.	cache reset.	"flush how much is necessary, possibly all"	cache next: left into: stream.	cache setToEnd.	left &gt; cache size ifTrue: [		size := left - cache size.		stream next: size putAll: source startingAt: next.		next := next + size.		left := cache size ].	cache next: left putAll: source startingAt: next.	^source</body><body package="Protocols-Common">nextPut: anObject	^cache nextPut: anObject ifReplacingDo: [ :outgoing | stream nextPut: outgoing ].</body></methods><methods><class-id>Protocols.CachedWriteStream</class-id> <category>private</category><body package="Protocols-Common">skipForward: step	| size |	size := cache skipForward: step.	size = step ifFalse: [ self steppingOverTheTop: size ]</body><body package="Protocols-Common">steppingOverTheTop: size	^IncompleteNextCountError new		messageText: 'Cannot step forward past the write buffer limit!';		parameter: size;		raise</body></methods><methods><class-id>Protocols.EventProcessor</class-id> <category>converting</category><body package="Protocols-Common">attachReceiver: anObject	^Protocols.EventConverter on: self using: [ :msg |		MessageSend			receiver: anObject			selector: msg selector			arguments: msg arguments ]</body></methods><methods><class-id>Protocols.EventProcessor</class-id> <category>services</category><body package="Protocols-Common">process: anEvent	accessProtect critical: [ self privateProcess: anEvent ]</body></methods><methods><class-id>Protocols.EventProcessor</class-id> <category>private</category><body package="Protocols-Common">doesNotUnderstand: aMessage	"Let's consider any message that is not understood an event action."	self process: aMessage</body><body package="Protocols-Common">privateProcess: aMessage	self subclassResponsibility</body></methods><methods><class-id>Protocols.EventProcessor</class-id> <category>initialize/release</category><body package="Protocols-Common">initialize	accessProtect := RecursionLock new.</body></methods><methods><class-id>Protocols.EventProcessor class</class-id> <category>instance creation</category><body package="Protocols-Common">new	^super new initialize</body></methods><methods><class-id>Protocols.EventPrinter</class-id> <category>private</category><body package="Protocols-Common">eventEmphasis	^#bold	"^#color -&gt; ColorValue navy"</body><body package="Protocols-Common">parameterEmphasis	^nil</body><body package="Protocols-Common">printEvent: aMessage on: aStream	label notNil ifTrue: [		aStream nextPutAll: label; nextPutAll: '&gt;&gt;' ].	(aMessage isKindOf: MessageSend)		ifTrue: [self printSend: aMessage on: aStream]		ifFalse: [self printMessage: aMessage on: aStream]</body><body package="Protocols-Common">printMessage: aMessage on: aStream	| originalEmphasis |	originalEmphasis := aStream emphasis.	aMessage selector isKeyword		ifTrue: [ aMessage selector keywords			with: aMessage arguments			do: [ :keyword :argument |				aStream					emphasis: self eventEmphasis;					space; nextPutAll: keyword;					emphasis: self parameterEmphasis;					space.				argument _isRemote					ifTrue: [argument _printOn: aStream]					ifFalse: [argument printOn: aStream]]]		ifFalse: [	aStream					emphasis: self eventEmphasis;					space; nextPutAll: aMessage selector;					emphasis: self parameterEmphasis;					space.				aMessage arguments do: [ :argument |					argument _isRemote						ifTrue: [argument _printOn: aStream]						ifFalse: [argument printOn: aStream]]].	aStream emphasis: originalEmphasis</body><body package="Protocols-Common">printSend: aMessageSend on: aStream	| receiver |	(receiver := aMessageSend receiver) _isRemote		ifTrue: [receiver _printOn: aStream]		ifFalse: [receiver printOn: aStream].	aStream space.	self printMessage: aMessageSend on: aStream</body><body package="Protocols-Common">privateProcess: anEvent	self transcriptTextStreamDo: [ :ts |		self printEvent: anEvent on: ts ]</body><body package="Protocols-Common">transcriptTextStreamDo: aBlock	| ts |	ts := TextStream on: (String new: 20).	ts nextPutAllText: Transcript value; cr.	aBlock value: ts.	Transcript		value: ts contents;		changed: #update</body></methods><methods><class-id>Protocols.EventPrinter</class-id> <category>services</category><body package="Protocols-Common">log: anEvent	self process: anEvent</body></methods><methods><class-id>Protocols.EventPrinter</class-id> <category>accessing</category><body package="Protocols-Common">label: aString	label := aString</body></methods><methods><class-id>Protocols.EventPrinter class</class-id> <category>instance creation</category><body package="Protocols-Common">new: aString	^self new label: aString</body></methods><methods><class-id>Protocols.MessageForwarder</class-id> <category>accessing</category><body package="Protocols-Common">_object	^object</body></methods><methods><class-id>Protocols.MessageForwarder</class-id> <category>testing</category><body package="Protocols-Common">_isForwarder	^true</body></methods><methods><class-id>Protocols.MessageForwarder</class-id> <category>private</category><body package="Protocols-Common">_forwardMessage: aMessage	^object perform: aMessage selector withArguments: aMessage arguments</body></methods><methods><class-id>Protocols.MessageForwarder</class-id> <category>initialize-release</category><body package="Protocols-Common">_initializeWith: anObject	object := anObject</body></methods><methods><class-id>Protocols.MessageForwarder</class-id> <category>error handling</category><body package="Protocols-Common">doesNotUnderstand: aMessage	^self _forwardMessage: aMessage</body></methods><methods><class-id>Protocols.MessageForwarder class</class-id> <category>instance creation</category><body package="Protocols-Common">with: anObject	^self new _initializeWith: anObject</body></methods><methods><class-id>Protocols.OutputParameter</class-id> <category>comparing</category><body package="Protocols-Common">= anObject 	"Answer whether the receiver and the argument represent the same object.	If = is redefined in any subclass, also redefine the message hash."	^self == anObject</body><body package="Protocols-Common">== anObject	"Answer true if the receiver and the argument are the same object (have the 	same object pointer) and false otherwise.  Do not redefine the message == 	in any other class!  No Lookup."	"Added here to support the machinery used in AspectAdaptors and other like	machinery, which requires that we test proxies for identity."	&lt;primitive: 110&gt;	nil primitiveFailed</body><body package="Protocols-Common">hash	"See the method comment in class Object. ... added so that we do not 	have to go remote to put aProxy in a dictionary."	&lt;primitive: 75&gt;	nil primitiveFailed</body><body package="Protocols-Common">identityHash	"See the method comment in class Object. ... added so that we do not 	have to go remote to put aProxy in a dictionary."	&lt;primitive: 75&gt;	nil primitiveFailed</body></methods><methods><class-id>Protocols.OutputParameter</class-id> <category>converting</category><body package="Protocols-Common">asOutputParameter	^self</body></methods><methods><class-id>Protocols.OutputParameter</class-id> <category>accessing</category><body package="Protocols-Common">value	^object</body><body package="Protocols-Common">value: anObject	object := anObject</body></methods><methods><class-id>Protocols.OutputParameter</class-id> <category>testing</category><body package="Protocols-Common">isOutputParameter	^true</body></methods><methods><class-id>Protocols.AnnouncementPrinter</class-id> <category>accessing</category><body package="Protocols-Common">out	^out ifNil: [ Transcript ]</body><body package="Protocols-Common">out: stream	out := stream</body></methods><methods><class-id>Protocols.AnnouncementPrinter</class-id> <category>services</category><body package="Protocols-Common">log: announcement	self out cr; print: announcement; flush</body></methods><methods><class-id>Core.ArgumentTransformer</class-id> <category>event evaluating</category><body package="Protocols-Common">evaluate	^self evaluateWithArguments: nil</body><body package="Protocols-Common">evaluateWithArguments: evaluationArguments	^block isNil		ifTrue: [evaluationArguments]		ifFalse: [block value: evaluationArguments]</body></methods><methods><class-id>Core.ArgumentTransformer</class-id> <category>accessing</category><body package="Protocols-Common">setBlock: aBlock	block := aBlock</body></methods><methods><class-id>Core.ArgumentTransformer class</class-id> <category>instance creation</category><body package="Protocols-Common">withBlock: aBlock	^self new setBlock: aBlock</body></methods><methods><class-id>Protocols.CircularBuffer</class-id> <category>accessing</category><body package="Protocols-Common">headroom	| headroom |	headroom := top - position \\ cache size.	(headroom isZero and: [ atTop not ]) ifTrue: [		headroom := cache size ].	^full  ifTrue: [ headroom ]		ifFalse: [			cache size = top				ifTrue: [ cache size ]				ifFalse: [ cache size - top + headroom ] ]</body><body package="Protocols-Common">next: total"Return a collection of up to total available elements.	total &lt;Integer&gt; number of elements to return	^&lt;SequenceableCollection&gt; resulting elements"	| result size |	result := cache species new: total.	size := self next: total into: result startingAt: 1.	^size = total		ifTrue: [ result ]		ifFalse: [ result copyFrom: 1 to: size ]</body><body package="Protocols-Common">next: total into: target"Put up to @total available elements into @target stream. Return number of elements actually transferred.	total &lt;Integer&gt; desired number of elements to write	target &lt;Stream&gt; a writable stream to write elements into	^&lt;Integer&gt; number of actually written elements"	| size size1 size2 |	atTop ifTrue: [^0].	size1 := 0.	position &gt;= top ifTrue: [		(size1 := cache size - position min: total) isZero ifFalse: [			target next: size1 putAll: cache startingAt: position + 1.			position := position + size1.			total = size1 ifTrue: [ ^size1 ] ].		position := 0 ].			size2 := top - position min: total - size1.	size := size1 + size2.	target next: size2 putAll: cache startingAt: position + 1.	position := position + size2.	atTop := position = top.	^size</body><body package="Protocols-Common">next: total into: target startingAt: start"Put up to @total available elements into @target starting at index @start. Return number of elements actually transferred.	total &lt;Integer&gt; number of bytes to put into target	target &lt;SequenceableCollection&gt; the target collection	start &lt;Integer&gt; the initial index where to start writing	^&lt;Integer&gt; the actual number of elements transferred"	| size size1 size2 |	atTop ifTrue: [^0].	size1 := 0.	position &gt;= top ifTrue: [		(size1 := cache size - position min: total) isZero ifFalse: [			target replaceFrom: start to: start + size1 - 1 with: cache startingAt: position + 1.			position := position + size1.			total = size1 ifTrue: [ ^size1 ] ].		position := 0 ].			size2 := top - position min: total - size1.	size := size1 + size2.	target replaceFrom: start + size1 to: start + size - 1 with: cache startingAt: position + 1.	position := position + size2.	atTop := position = top.	^size</body><body package="Protocols-Common">next: total putAll: source"Write up to total elements from source stream into the buffer. Elements will fill up any available headeroom plus up to a buffer size worth of additional elements, but not more. Return number of elements actually read.	total &lt;Integer&gt; number of bytes to get from the source	target &lt;Stream&gt; the source stream	^&lt;Integer&gt; the actual number of elements transferred"	| left size |	total isZero ifTrue: [^0].	size := self fillUpNext: total putAll: source.	left := total - size.	left isZero ifTrue: [ ^total ].	"Now we should be at the top"	(size := cache size - position min: left) isZero ifFalse: [		source next: size into: cache startingAt: position + 1.		left := left - size.		left isZero ifTrue: [			top := position := position + size.			position = cache size ifTrue: [ full := true ].			^total ].		full := true ].	size := position min: left.	source next: size into: cache startingAt: 1.	left := left - size.	top := position := size.	top = cache size ifTrue: [ full := true ].	^total - left</body><body package="Protocols-Common">next: total putAll: source startingAt: start"Write up to total elements from source starting at index start into the buffer. Elements will fill up any available headeroom plus up to a buffer size worth of additional elements, but not more. Return number of elements actually written.	total &lt;Integer&gt; number of bytes to get from the source	source &lt;SequenceableCollection&gt; the source collection	start &lt;Integer&gt; the initial index where to start reading	^&lt;Integer&gt; the actual number of elements transferred"	| left next size |	total isZero ifTrue: [^0].	size := self fillUpNext: total putAll: source startingAt: start.	left := total - size.	left isZero ifTrue: [ ^total ].	next := start + size.	"Now we should be at the top"	(size := cache size - position min: left) isZero ifFalse: [		cache replaceFrom: position + 1 to: position + size with: source startingAt: next.		left := left - size.		left isZero ifTrue: [			top := position := position + size.			position = cache size ifTrue: [ full := true ].			^total ].		full := true.		next := next + size ].	size := position min: left. 	cache replaceFrom: 1 to: size with: source startingAt: next.	left := left - size.	top := position := size.	top = cache size ifTrue: [ full := true ].	^total - left</body><body package="Protocols-Common">nextIfNone: aBlock"Return next element from the buffer. If there isn't one evaluate aBlock and return result of that."	^atTop		ifTrue: aBlock		ifFalse: [			position := position \\ cache size + 1.			atTop := position = top.			cache at: position ]</body><body package="Protocols-Common">nextPut: anObject"Put anObject into the buffer. Ignore replaced elements."	^self nextPut: anObject ifReplacingDo: [ :replaced | ].</body><body package="Protocols-Common">nextPut: anObject ifReplacingDo: aBlock"Put anObject into the buffer. If there's an old element being replaced, evaluate aBlock with it."	position := position \\ cache size + 1.	atTop		ifTrue: [ top := position.			full ifTrue: [ aBlock value: (cache at: top) ].			top = cache size ifTrue: [ full := true ] ]		ifFalse: [ atTop := position = top ].	^cache at: position put: anObject</body><body package="Protocols-Common">nextPutAll: source"Write elements from the source collection into the buffer. Elements will fill up any available headeroom plus up to a buffer size worth of additional elements, but not more. Return number of elements actually written.	source &lt;SequenceableCollection&gt; the source collection	^&lt;Integer&gt; the actual number of elements transferred"	^self next: source size putAll: source startingAt: 1</body><body package="Protocols-Common">previousIfNone: aBlock	| previous |	((full not and: [ position = cache size ])	or: [ top = position and: [ atTop not ] ])		ifTrue: [ ^aBlock value ].	previous := cache at: position.	(position := position - 1) isZero ifTrue: [ position := cache size ].	atTop := false.	^previous</body><body package="Protocols-Common">size	^cache size</body><body package="Protocols-Common">unread	| unread |	^(unread := top - position \\ self size) isZero		ifTrue: [ atTop ifTrue: [ 0 ] ifFalse: [ self size ] ]		ifFalse: [ unread ]</body></methods><methods><class-id>Protocols.CircularBuffer</class-id> <category>testing</category><body package="Protocols-Common">atBottom	^full		ifTrue: [ position = top and: [ atTop not ] ]		ifFalse: [ position = cache size ]</body><body package="Protocols-Common">atEnd	^self atTop</body><body package="Protocols-Common">atTop	^atTop</body></methods><methods><class-id>Protocols.CircularBuffer</class-id> <category>skipping</category><body package="Protocols-Common">reset	full		ifTrue: [ position := top.			atTop := false ]		ifFalse: [ position := cache size.			atTop := position = top ]</body><body package="Protocols-Common">setToEnd	position := top.	atTop := true.</body><body package="Protocols-Common">skip: step	^self skipForward: step</body><body package="Protocols-Common">skipBack: step	| size left |	step &lt; 0 ifTrue: [ ^self skipForward: step negated ].	step isZero ifTrue: [^0].	self atBottom ifTrue: [^0].	atTop := false.	size := 0.	position &lt;= top ifTrue: [		size := position min: step.		position := position - size.		position isZero ifTrue: [ position := cache size ].		step = size ifTrue: [ ^step ] ].	left := step - size.	full ifTrue: [			size := position - top min: left.		position := position - size.		left := left - size ].	^step - left</body><body package="Protocols-Common">skipForward: step	| size left |	step &lt; 0 ifTrue: [ ^self skipBack: step negated ].	(step isZero or: [ atTop ]) ifTrue: [^0].	size := 0.	position &gt;= top ifTrue: [		size := cache size - position min: step.		position := position + size.		step = size ifTrue: [ ^step ].		position := 0 ].	left := step - size.		size := top - position min: left.	position := position + size.	atTop := position = top.	left := left - size.	^step - left</body></methods><methods><class-id>Protocols.CircularBuffer</class-id> <category>printing</category><body package="Protocols-Common">printDetailsOn: aStream	| stream show back forward |	show := 5. "how many elements around current position to show"	stream := (cache species new: 2*show) writeStream.	back := self skipBack: show.	forward := (self next: show + back into: stream) - show.	self skipBack: forward.	"Here we rely on pretty printing capability of internal streams, so that we don't need to reimplement it"	stream := stream printString readStream.	stream skipThrough: $[.	aStream		nextPutAll: '[ ';		nextPutAll: (stream through: $[);		nextPut: $-;		print: self unread;		nextPut: $];		nextPutAll: (stream through: $]; upTo: $]);		nextPut: $]</body><body package="Protocols-Common">printOn: aStream	aStream	print: self class; space.	self printDetailsOn: aStream.</body></methods><methods><class-id>Protocols.CircularBuffer</class-id> <category>private</category><body package="Protocols-Common">clear"Reset the buffer to an empty state, throwing away any contents"	full := false.	top := position := cache size.	atTop := true</body><body package="Protocols-Common">fillUpNext: total putAll: source	| left size |	(total isZero or: [ atTop ]) ifTrue: [^0].	left := total.	position &lt; top ifFalse: [		(size := cache size - position min: left) isZero ifFalse: [			source next: size into: cache startingAt: position + 1.			position := position + size.			atTop := position = top.			left := left - size.			left isZero ifTrue: [ ^total ] ].		position := 0 ].			size := top - position min: left.	source next: size into: cache startingAt: position + 1.	position := position + size.	atTop := position = top.	left := left - size.	^total - left</body><body package="Protocols-Common">fillUpNext: total putAll: source startingAt: start	| left next size |	(total isZero or: [ atTop ]) ifTrue: [^0].	left := total.	next := start.	position &lt; top ifFalse: [		(size := cache size - position min: left) isZero ifFalse: [			cache replaceFrom: position + 1 to: position + size with: source startingAt: next.			position := position + size.			atTop := position = top.			left := left - size.			left isZero ifTrue: [ ^total ].			next := next + size ].		position := 0 ].			size := top - position min: left.	cache replaceFrom: position + 1 to: position + size with: source startingAt: next.	position := position + size.	atTop := position = top.	left := left - size.	^total - left</body></methods><methods><class-id>Protocols.CircularBuffer</class-id> <category>initialize-release</category><body package="Protocols-Common">cache: aCollection	cache := aCollection.	self clear.</body></methods><methods><class-id>Protocols.CircularBuffer class</class-id> <category>instance creation</category><body package="Protocols-Common">cache: aCollection	^self new cache: aCollection</body></methods><methods><class-id>Protocols.EventConverter</class-id> <category>private</category><body package="Protocols-Common">privateProcess: anEvent	next process: (converter value: anEvent)</body></methods><methods><class-id>Protocols.EventConverter</class-id> <category>initialize/release</category><body package="Protocols-Common">on: anEventProcessor using: aConverter	next := anEventProcessor.	converter := aConverter</body></methods><methods><class-id>Protocols.EventConverter class</class-id> <category>instance creation</category><body package="Protocols-Common">on: anEventProcessor using: aConverter	^self new on: anEventProcessor using: aConverter</body></methods><methods><class-id>Protocols.DecodedStreamConstructor</class-id> <category>initialize</category><body package="Protocols-Common">addEncodingTo: aStream	^DecodedStream		on: aStream		encodedBy: (self getEncoder) initializeForMemory</body></methods><methods><class-id>Protocols.DecodedStreamConstructor</class-id> <category>private</category><body package="Protocols-Common">getEncoder	^encoding isBehavior		ifTrue: [ encoding asEncoder ]		ifFalse: [ self class encoderFor: encoding ]</body></methods><methods><class-id>Protocols.DecodedStreamConstructor class</class-id> <category>accessing</category><body package="Protocols-Common">encoderFor: encoding"Get or create an encoder for specified encoding name	encoding	&lt;String|Symbol&gt;	the encoding name will be normalized, so capitalization differences will be ignored when looking up the encoder type"	^(Encoders at: encoding asLowercase asSymbol ifAbsent: [ nil ])		ifNil: [ StreamEncoder new: encoding ]		ifNotNil: [ :factory | factory asEncoder ]</body><body package="Protocols-Common">register: encoderFactory as: encoding"Register a encoder factory, i.e. something that can provide a encoder in response to #asEncoder, under a specified encoding name.The name can later be used as an argument for the #withEncoding: stream constructor.	encoderFactory	&lt;Class | StreamEncoder &gt;	usually a class or a re-entrant, state-less signleton encoder instance	encoding	&lt;String | Symbol&gt;	the encoding name will be normalized so capitalization differences will be ignored when looking up a encoder factory"	^Encoders at: encoding asLowercase asSymbol put: encoderFactory</body></methods><methods><class-id>Protocols.IPMulticastRequest</class-id> <category>testing</category><body package="Protocols-Common">inMulticast: aByteArray	"Is aByteArray a multicast address?"	^self class inMulticast: aByteArray</body></methods><methods><class-id>Protocols.IPMulticastRequest</class-id> <category>accessing</category><body package="Protocols-Common">address	"IP multicast address of group" 	^( ByteArray new: 4 ) replaceBytesFrom: 1 to: 4 with: self startingAt: 1</body><body package="Protocols-Common">address: aByteArray	"Sets the IP multicast address of the group."	(self inMulticast: aByteArray)		ifFalse: 			[self				error: #NotAnIPMulticastAddress &lt;&lt; #protocols &gt;&gt; 'Not an IP multicast address.'].	^self		replaceBytesFrom: 1		to: 4		with: aByteArray		startingAt: 1</body><body package="Protocols-Common">interface	"local IP address of interface"	^( ByteArray new: 4 ) replaceBytesFrom: 1 to: 4 with: self startingAt: 5</body><body package="Protocols-Common">interface: aByteArray	"local IP address of interface"	^self replaceBytesFrom: 5 to: 8 with: aByteArray startingAt: 1</body></methods><methods><class-id>Protocols.IPMulticastRequest class</class-id> <category>testing</category><body package="Protocols-Common">inMulticast: aByteArray	"Is aByteArray a multicast address?	IP Address: #[224 0 0 0] - #[239 255 255 255]"	| byte |	byte := aByteArray byteAt: 1.	^( byte bitAnd: 16rF0 ) = 16rE0"self new inMulticast:  #[239 255 255 255]"</body></methods><methods><class-id>Protocols.IPMulticastRequest class</class-id> <category>instance creation</category><body package="Protocols-Common">interface: aByteArray address: addrByteArray	^( self new )		interface: aByteArray; 		address: addrByteArray; 		yourself</body><body package="Protocols-Common">new	"sturct ip_mreq {		struct in_addr imr_multiaddr; /* IP multicast address of group */		struct in_addr imr_interface; '* local IP address of interface */	}"	^self new: 8</body><body package="Protocols-Common">toAddress: addrByteArray	^( self new )		address: addrByteArray; 		yourself</body></methods><methods><class-id>Base64FastCoder</class-id> <category>private-accessing</category><body package="Protocols-Common">shiftRegister	^shiftRegister</body><body package="Protocols-Common">shiftRegister: anInteger	shiftRegister := anInteger</body><body package="Protocols-Common">valuesLeft	^valuesLeft</body><body package="Protocols-Common">valuesLeft: anInteger	valuesLeft := anInteger</body></methods><methods><class-id>Base64FastCoder</class-id> <category>accessing</category><body package="Protocols-Common">atEnd	^self peek isNil</body><body package="Protocols-Common">next	| result |	result := self peek.	result notNil ifTrue:		[shiftRegister := (shiftRegister bitAnd: 16rFFFF) bitShift: 8.		self valuesLeft: self valuesLeft - 1].	^result</body><body package="Protocols-Common">peek	self valuesLeft = 0 ifTrue:		[(self inputStream atEnd or: [self inputStream peek == $=])			ifTrue: [^nil]			ifFalse: [self ensureEnoughDataInShiftRegister]].	^(16rFF0000 bitAnd: self shiftRegister) bitShift: -16</body><body package="Protocols-Common">quartetMap	^quartetMap</body><body package="Protocols-Common">upToEnd	| outputStream |	outputStream := (ByteArray new: (self inputStream size / 4) ceiling * 3) writeStream.	[self atEnd] whileFalse: [outputStream nextPut: self next].	^outputStream contents</body></methods><methods><class-id>Base64FastCoder</class-id> <category>private</category><body package="Protocols-Common">ensureEnoughDataInShiftRegister	| newValues |	newValues := 3.	1 to: 4 do:		[:i || nextDecodedSixBits |   		nextDecodedSixBits := self quartetMap at: self inputStream next asInteger.		nextDecodedSixBits notNil   			ifTrue: [self shiftRegister: (self shiftRegister bitShift: 6) + nextDecodedSixBits]			ifFalse:				[self shiftRegister: (self shiftRegister bitShift: 6).				newValues := newValues - 1]].	valuesLeft := newValues.</body><body package="Protocols-Common">inputStream	^inputStream</body><body package="Protocols-Common">inputStream: aStream	inputStream := aStream.</body></methods><methods><class-id>Base64FastCoder</class-id> <category>initialize-release</category><body package="Protocols-Common">initialize	quartetMap := self class quartetMap.	shiftRegister := 0.	valuesLeft := 0.</body></methods><methods><class-id>Base64FastCoder class</class-id> <category>accessing</category><body package="Protocols-Common">quartetMap	^quartetMap</body></methods><methods><class-id>Base64FastCoder class</class-id> <category>encoding</category><body package="Protocols-Common">encode: aByteArray asBase64: aByteClass map: sextetMap nullValue: equalsSign	"Convert triplets of (character-value) integers in the input to quartets in the output using the supplied map."	| output thirdTripletIndex firstQuartetIndex firstOfThree secondOfThree thirdOfThree remainder |	output := aByteClass new: (aByteArray size / 3) ceiling * 4.	thirdTripletIndex := 3.	firstQuartetIndex := 1.	"Process all complete triplets."	[thirdTripletIndex &gt; aByteArray size] whileFalse: 			[firstOfThree := aByteArray at: thirdTripletIndex - 2.			secondOfThree := aByteArray at: thirdTripletIndex - 1.			thirdOfThree := aByteArray at: thirdTripletIndex.			output at: firstQuartetIndex				put: (sextetMap at: ((firstOfThree bitAnd: 2r11111100) bitShift: -2) + 1).			output at: firstQuartetIndex + 1				put: (sextetMap						at: (((firstOfThree bitAnd: 2r00000011) bitShift: 4)								bitOr: ((secondOfThree bitAnd: 2r11110000) bitShift: -4)) + 1).			output at: firstQuartetIndex + 2				put: (sextetMap						at: (((secondOfThree bitAnd: 2r00001111) bitShift: 2)								bitOr: ((thirdOfThree bitAnd: 2r11000000) bitShift: -6)) + 1).			output at: firstQuartetIndex + 3				put: (sextetMap at: (thirdOfThree bitAnd: 2r00111111) + 1).			thirdTripletIndex := thirdTripletIndex + 3.			firstQuartetIndex := firstQuartetIndex + 4].	"Process any final incomplete triplet."	remainder := thirdTripletIndex - aByteArray size.	remainder = 3 ifTrue: [^output].	firstOfThree := aByteArray at: thirdTripletIndex - 2.	output at: firstQuartetIndex		put: (sextetMap at: ((firstOfThree bitAnd: 2r11111100) bitShift: -2) + 1).	output at: firstQuartetIndex + 3 put: equalsSign.	remainder = 1		ifFalse: 			["the byte array is missing two values of another triplet"			output at: firstQuartetIndex + 1				put: (sextetMap at: ((firstOfThree bitAnd: 2r00000011) bitShift: 4) + 1).			output at: firstQuartetIndex + 2 put: equalsSign]		ifTrue: 			["the byte array is only missing one value of another triplet"			secondOfThree := aByteArray at: thirdTripletIndex - 1.			output at: firstQuartetIndex + 1				put: (sextetMap						at: (((firstOfThree bitAnd: 2r00000011) bitShift: 4)								bitOr: ((secondOfThree bitAnd: 2r11110000) bitShift: -4)) + 1).			output at: firstQuartetIndex + 2				put: (sextetMap at: ((secondOfThree bitAnd: 2r00001111) bitShift: 2) + 1)].	^output</body><body package="Protocols-Common">encodeAsBase64ByteArray: aByteArray	"Convert triplets of (character-value) integers in the input to quartets of (character-value) integers in the output."	^self		encode: aByteArray		asBase64: ByteArray		map: mapArray		nullValue: nullInteger</body><body package="Protocols-Common">encodeAsBase64String: aByteArray	"Convert triplets of (character-value) integers in the input to quartets of characters in the output."	^self		encode: aByteArray		asBase64: ByteString		map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'		nullValue: $=</body></methods><methods><class-id>Base64FastCoder class</class-id> <category>instance creation</category><body package="Protocols-Common">decodeBase64Encoded: aStringOrByteArray	"It does not matter whether the input is a base64-encoded string or the ByteArray of such a string;  the same decoded ByteArray is returned in either case."	^self new inputStream: aStringOrByteArray readStream; upToEnd</body><body package="Protocols-Common">new	"Instnces are only used when decoding; encoding is a class-side method."	^super new initialize</body></methods><methods><class-id>Base64FastCoder class</class-id> <category>class initialization</category><body package="Protocols-Common">initialize	mapArray := 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/' asByteArray.	quartetMap := Array new: 128.	mapArray doWithIndex:		[:b64CharVal :index | quartetMap at: b64CharVal put: index - 1].	nullInteger := $= asInteger.</body></methods><methods><class-id>Protocols.ProtoObject</class-id> <category>system primitives</category><body package="Protocols-Common">beImmutable	"Set the receiver to be immutable"	self isImmutable: true.	^self</body><body package="Protocols-Common">beMutable	"Set the receiver to be mutable"	self isImmutable: false.	^self</body><body package="Protocols-Common">become: otherObject " Swap the state of the receiver with that of anObject."	self primBecome: otherObject</body><body package="Protocols-Common">instVarAt: index	"Answer with a fixed variable in an object.  The numbering of the variables	corresponds to the named instance variables.  Fail if the index is not an	Integer or is not the index of a fixed variable."	&lt;primitive: 73&gt;	"Access beyond fixed variables."	^self basicAt: index - self class instSize</body><body package="Protocols-Common">instVarAt: anInteger put: anObject	"Store a value into a fixed variable in the receiver.  The numbering of	 the variables corresponds to the named instance variables.  Fail if	 the index is not an Integer or is not the index of a fixed variable, or	 if the receiver is immutable. Answer with the value stored as the result.	 (Using this message violates the principle that each object has sovereign	 control over the storing of values into its instance variables.)."	&lt;primitive: 74&gt;	self isImmutable ifTrue:		[^self noModificationErrorFor: #instVarAt:put: index: anInteger value: anObject].	"Access beyond fixed fields"	^self basicAt: anInteger - self class instSize put: anObject</body><body package="Protocols-Common">isImmutable: aBoolean	"Set the receiver's immutability.   Answer if the receiver was	 previously immutable.  Fail if the argument is not a boolean	 or if the receiver is immediate and the argument is false."	&lt;primitive: 1064 errorCode: error&gt;	^self primitiveFailed</body><body package="Protocols-Common">primBecome: otherObject 	"Swap the instance data and appropriate header information of the receiver and the	 argument, otherObject. In other words, transform the receiver into the argument and	 vice-versa.  Fail if either object is an immediate or a MethodContext or a	 BlockContext or if there is insufficient memory to perform the become, or if either	 object is immutable. Answer with the argument which is now the semantic equivalent	 of the object that formerly denoted the receiver."	&lt;primitive: 72 errorCode: errCode&gt;	^(errCode ~~ nil	   and: [errCode name = #'no modification'])		ifTrue: [self noModificationErrorFor: #primBecome: index: nil value: otherObject]		ifFalse: [self handleFailedBecome: otherObject]</body></methods><methods><class-id>Protocols.ProtoObject</class-id> <category>user interface</category><body package="Protocols-Common">inspect	"Create and schedule an Inspector in which the user can examine the	receiver's variables."	Tools.Trippy.Inspector useSimpleInspector		ifTrue: [self inspectorClass openOn: self]		ifFalse: [Tools.Trippy.Inspector openOn: self]</body><body package="Protocols-Common">inspectorActions	"Answer a collection of Action instances listing the common actions	a user might want to perform on an object. They are added to the 	inspector's Object menu."	^#()</body><body package="Protocols-Common">inspectorClass	^Inspector</body><body package="Protocols-Common">inspectorClasses	"Answer a sequence of inspector classes that can represent the receiver in an	inspector. The first page in the array is the one used by default in a new inspector."	^Array with: Tools.Trippy.BasicInspector</body><body package="Protocols-Common">inspectorCollaborators	"Answer a collection of Collaborator instances listing the important other	objects a person looking at this one might want to see. For example,	collaborators of a view would be its model and the controller.	Collaborators are added to the inspector's Go menu."	^#()</body><body package="Protocols-Common">inspectorExtraAttributes	"Subclasses may reimplement this to answer a sequence of	DerivedAttribute or TextAttribute instances that should show up	in the inspector in addition to named instance variables and	indexed variables. See implementors for an example."	^#()</body><body package="Protocols-Common">inspectorHierarchies	"Answer a collection of instances of Hierarchy describing the hierarchies	this object is a member of."	^#()</body><body package="Protocols-Common">safeToolListIcon		^[self toolListIcon]		toolSafeIn: 100 milliseconds		else: [GeneralIcons inaccessibleToolIcon]</body></methods><methods><class-id>Protocols.ProtoObject</class-id> <category>message handling</category><body package="Protocols-Common">perform: aSymbol	"Send the receiver the unary message indicated by the argument. The argument is	 the selector of the message.	 Invoke messageNotUnderstood: if the selector is not understood by the receiver.	 Fail the primitive if the looked-up method does not expect zero arguments."	&lt;primitive: 511&gt;	^self perform: aSymbol withArguments: (Array new: 0)</body><body package="Protocols-Common">perform: aSymbol with: anObject 	"Send the receiver the keyword or binary message indicated by the 	 arguments. The first argument is the selector of the message. The other 	 argument is the argument of the message to be sent.	 Invoke messageNotUnderstood: if the selector is not understood by the receiver.	 Fail the primitive if the looked-up method does not expect one argument."	&lt;primitive: 512&gt;	^self perform: aSymbol withArguments: (Array with: anObject)</body><body package="Protocols-Common">perform: aSymbol with: firstObject with: secondObject	"Send the receiver the keyword message indicated by the arguments. The first	 argument is the selector of the message. The other arguments are the	 arguments of the message to be sent.	 Invoke messageNotUnderstood: if the selector is not understood by the receiver.	 Fail the primitive if the looked-up method does not expect two arguments."	&lt;primitive: 513&gt;	^self perform: aSymbol withArguments: (Array with: firstObject with: secondObject)</body><body package="Protocols-Common">perform: aSymbol with: firstObject with: secondObject with: thirdObject	"Send the receiver the keyword message indicated by the arguments. The first	 argument is the selector of the message.	 Invoke messageNotUnderstood: if the selector is not understood by the receiver.	 Fail the primitive if the looked-up method does not expect three arguments."	&lt;primitive: 514&gt;	^self perform: aSymbol withArguments: (Array			with: firstObject			with: secondObject			with: thirdObject)</body><body package="Protocols-Common">perform: selector withArguments: anArray	"Send the receiver the message indicated by the arguments. The argument	 selector is the selector of the message. The arguments of the message are	 the elements of anArray.	 Invoke messageNotUnderstood: if the selector is not understood by the receiver.	 Fail the primitive if anArray is not an Array with the same number of elements as	 the number of arguments expected by the looked-up method."	&lt;primitive: 510&gt;	^self primitiveFailed</body><body package="Protocols-Common">performMethod: method	"Evaluate the first argument, a CompiledMethod, with the receiver as	receiver.  The method must be expecting no arguments."	^self performMethod: method arguments: #()</body><body package="Protocols-Common">performMethod: method arguments: args	"Evaluate the first argument, a CompiledMethod, with the receiver as	receiver.  The other argument is the list of arguments of the method.	The number of arguments expected by the method must match the size of the	Array."	^method valueWithReceiver: self arguments: args</body><body package="Protocols-Common">performMethod: method with: arg1	"Evaluate the first argument, a CompiledMethod, with the receiver as	receiver.  The other argument is the argument of the method. The method	must be expecting one argument."	^self performMethod: method arguments: (Array with: arg1)</body><body package="Protocols-Common">performMethod: method with: arg1 with: arg2	"Evaluate the first argument, a CompiledMethod, with the receiver as	receiver.  The other arguments are the arguments of the method. The method	must be expecting two arguments."	^self performMethod: method arguments: (Array with: arg1 with: arg2)</body><body package="Protocols-Common">performMethod: method with: arg1 with: arg2 with: arg3	"Evaluate the first argument, a CompiledMethod, with the receiver as	receiver.  The other arguments are the arguments of the method. The method	must be expecting three arguments."	^self performMethod: method arguments: (Array with: arg1 with: arg2 with: arg3)</body></methods><methods><class-id>Protocols.ProtoObject</class-id> <category>accessing</category><body package="Protocols-Common">basicAt: index	"Answer the value of an indexable field in the receiver. Fail if the	argument index is not an Integer or is out of bounds. Do not override this	message in any subclass."	&lt;primitive: 60&gt;	index isInteger ifTrue: [^self subscriptBoundsErrorFor: #basicAt: index: index].	index respondsToArithmetic		ifTrue: [^self basicAt: index asSmallInteger]		ifFalse: [^self nonIntegerIndexError: index]</body><body package="Protocols-Common">basicAt: index put: value	"Store the second argument value in the indexable field of the receiver	indicated by index. Fail if the index is not an Integer or is out of bounds. Or	fail if the value is not of the right type for this kind of collection. Answer	the value that was stored. Do not override in a subclass."	&lt;primitive: 61&gt;	index isInteger ifTrue:		[(index &gt;= 1 and: [index &lt;= self basicSize])			ifTrue:				[self isImmutable					ifTrue: [^self noModificationErrorFor: #basicAt:put: index: index value: value]					ifFalse: [^self improperStoreError]]			ifFalse: [^self subscriptBoundsErrorFor: #basicAt:put: index: index value: value]].	index respondsToArithmetic		ifTrue: [^self basicAt: index asSmallInteger put: value]		ifFalse: [^self nonIntegerIndexError: index]</body><body package="Protocols-Common">basicSize	"Answer the number of indexable fields in the receiver. This value is the	same as the largest legal subscript. Do not override in any subclass."	&lt;primitive: 62&gt;	"The number of indexable fields of fixed-length objects is 0"	^0</body><body package="Protocols-Common">toolListIcon	^self class toolListIcon</body></methods><methods><class-id>Protocols.ProtoObject</class-id> <category>comparing</category><body package="Protocols-Common">= anObject 	"Answer whether the receiver and the argument represent the same object.	If = is redefined in any subclass, consider also redefining the message hash."	^self == anObject</body><body package="Protocols-Common">== anObject	"Answer true if the receiver and the argument are the same object (have the same	object pointer) and false otherwise.  Do not redefine the message == in any	other class!  No Lookup."	&lt;primitive: 110&gt;	self primitiveFailed</body><body package="Protocols-Common">hash	"Answer a SmallInteger that is equal to the hash value of 	any object that is equal to (=) the receiver. 	When two objects are not =, their hash values may or may not be the same.	The hash value may change based on the receiver's contents."	"If hash is redefined in a subclass, it may also be necessary to	redefine the = method to maintain the semantics described above.	Primitive 75 fails for immediate objects, so immediate subclasses such as	SmallInteger must override this method."	&lt;primitive: 75&gt;	self primitiveFailed</body><body package="Protocols-Common">identityHash	"Answer a SmallInteger that is equal to the identityHash of 	any object that is == to the receiver. 	When two objects are not ==, their identityHash values may or may not 	be the same. The identityHash value does not change across the life	of the object."	"If identityHash is redefined in a subclass, the new implementation must	answer the same identityHash when two objects are ==. Changing the	== method has no effect on the execution machinery -- in effect, you	cannot redefine == to echo a changed implementation of identityHash.	Primitive 75 fails for immediate objects, so immediate subclasses such as	SmallInteger must override this method."	&lt;primitive: 75&gt;	self primitiveFailed</body><body package="Protocols-Common">~= anObject 	"Answer whether the receiver and the argument do not represent the same 	object."	^self = anObject == false</body><body package="Protocols-Common">~~ anObject 	"Answer true if the receiver and the argument are not the same object 	(have the same object pointer) and false otherwise."	&lt;primitive: 109&gt;	^(self == anObject) not</body></methods><methods><class-id>Protocols.ProtoObject</class-id> <category>error handling</category><body package="Protocols-Common">doesNotUnderstand: aMessage 	^MessageNotUnderstood new		parameter: aMessage;		messageText: [| selectorString |			selectorString :=				[aMessage selector printString]					on: Error					do: [:ex |						ex return:							(#errSelectorNotPrintable &lt;&lt; #dialogs &gt;&gt; '** unprintable selector **')							expandMacros asString].			(#errNotUnderstood &lt;&lt; #dialogs &gt;&gt; 'Message not understood: &lt;1s&gt;')				expandMacrosWith: selectorString];		raiseSignal.</body><body package="Protocols-Common">handleFailedBecome: otherObject 	"Called if the primBecome: primitive fails. This primitive can fail for	one of the following reasons: 	1. Either object is immutable (which includes immediate objects)	2. Either object is a MethodContext 	3. Either object is a BlockContext 	4. If there is insufficient memory to perform the become. 	In the first three cases, raise an error. In the latter case, attempt to 	make space and try again."	| recClass argClass  |	(self isImmutable	or: [otherObject isImmutable]) ifTrue:		[^Error raiseSignal: (#cannotBecomeObject &lt;&lt; #dialogs &gt;&gt; 'cannot use become: on immutable objects')].	((recClass := self class) == MethodContext	 or: [(argClass := otherObject class) == MethodContext]) ifTrue:		[^Error raiseSignal: (#cannotBecomeMethod &lt;&lt; #dialogs &gt;&gt; 'cannot use become: on a MethodContext')].	(recClass == BlockContext or: [argClass == BlockContext]) ifTrue:		[^Error raiseSignal: (#cannotBecomeBlock &lt;&lt; #dialogs &gt;&gt; 'cannot use become: on a BlockContext')].	ObjectMemory handleBecomeFailureBetween: self and: otherObject.	^self becomeNoRetry: otherObject</body><body package="Protocols-Common">improperStoreError	"Create an error notification that an improper store was attempted."	Error raiseSignal: (#errImproperIndex &lt;&lt; #dialogs &gt;&gt; 'Improper store into indexable object')</body><body package="Protocols-Common">mustBeBoolean	"Catches attempts to test truth of non-Booleans.  This message is sent from the VM."	SystemNotification		raiseRequestWith: thisContext		errorString: (#nonBoolReceiver &lt;&lt; #dialogs &gt;&gt; 'NonBoolean receiver--proceed for truth.').	^true</body><body package="Protocols-Common">noModificationErrorFor: selector index: index value: value	^(NoModificationError receiver: self selector: selector index: index value: value) raiseRequest</body><body package="Protocols-Common">nonIntegerIndexError: index	"Raise a signal indicating that an improper object was used as an index."	^Object nonIntegerIndexSignal raiseWith: index</body><body package="Protocols-Common">primitiveFailed	"Announce that a primitive has failed and there is no appropriate 	Smalltalk code to run."	Error raiseSignal: (#errPrimitiveFailed &lt;&lt; #dialogs &gt;&gt; 'a primitive has failed')</body><body package="Protocols-Common">subscriptBoundsErrorFor: selector index: index	"Raise a signal indicating that an improper index was used as an index in a send of selector with index."	^(SubscriptOutOfBoundsError receiver: self selector: selector index: index value: nil) raiseRequest</body><body package="Protocols-Common">subscriptBoundsErrorFor: selector index: index value: aValue	"Raise a signal indicating that an improper index was used as an index in a send of selector with index and aValue."	^(SubscriptOutOfBoundsError receiver: self selector: selector index: index value: aValue) raiseRequest</body></methods><methods><class-id>Protocols.ProtoObject</class-id> <category>controlling</category><body package="Protocols-Common">ifNil: aBlock	"Return the receiver if it is not nil, or evaluate the block	and return the result if the receiver is nil."	^self</body><body package="Protocols-Common">ifNil: nilBlock ifNotNil: notNilBlock	"If the receiver is not nil, answer the evaluation of aBlock (with the receiver as	 its argument if it takes one), otherwise answer nil.	 UndefinedObject redefines this to answer the evaluation of nilBlock, and hence	 since here the receiver is not nil answer the evaluation of notNilBlock."	^0 == notNilBlock numArgs		ifTrue: [notNilBlock value]		ifFalse: [notNilBlock value: self]</body><body package="Protocols-Common">ifNotNil: aBlock	"If the receiver is not nil, answer the evaluation of aBlock (with the receiver as	 its argument if it takes one), otherwise answer nil.  Since the receiver is not nil,	 answer aBlock's evaluation.  Passing the receiver to aBlock is handy for idioms	 such as		self toolBarSpec ifNotNil: [:spec | ...].	UndefinedObject reimplements this to not evaluate aBlock."	^0 == aBlock numArgs		ifTrue: [aBlock value]		ifFalse: [aBlock value: self]</body><body package="Protocols-Common">ifNotNil: notNilBlock ifNil: nilBlock	"If the receiver is not nil, answer the evaluation of notNilBlock (with the	 receiver as its argument if it takes one), otherwise answer the evaluation	 of nilBlock.  UndefinedObject redefines this to answer the evaluation of nilBlock,	 and hence since here the receiver is not nil answer the evaluation of notNilBlock."	^0 == notNilBlock numArgs		ifTrue: [notNilBlock value]		ifFalse: [notNilBlock value: self]</body></methods><methods><class-id>Protocols.ProtoObject</class-id> <category>testing</category><body package="Protocols-Common">_isForwarder	^false</body><body package="Protocols-Common">allowsSelfDefinition	"Answer true if the object replies to the message #definition	with a string that can be evaluated to reconstruct the receiver	in a new environment."	^false</body><body package="Protocols-Common">isBehavior	"Answer whether the object can be the 'class' of another object"	^false</body><body package="Protocols-Common">isImmediate	"Answer true if this object has immediate representation."	"Currently, SmallInteger and Character are represented as	immediate (or zero-sized storage) objects."	^self class hasImmediateInstances</body><body package="Protocols-Common">isImmutable	"Answer if the receiver is immutable.  This is always true of immediates.	 Cannot fail."	&lt;primitive: 1063&gt;	^false</body><body package="Protocols-Common">isNil	"Coerce nil to true and everything else to false.  UndefinedObject 	overrides with ^true"	^false</body><body package="Protocols-Common">isVariableBinding 	^false</body><body package="Protocols-Common">notNil	"Coerce nil to false and everything else to true.  UndefinedObject 	overrides with ^false"	^true</body></methods><methods><class-id>Protocols.ProtoObject</class-id> <category>class membership</category><body package="Protocols-Common">changeClassTo: aClass	"Change the class of the receiver to aClass."	aClass adoptInstance: self.	^self</body><body package="Protocols-Common">changeClassToThatOf: anObject 	"Change the class of the receiver to the class of anObject. Fail if either the	 receiver or anObject is immutable (which includes immediates), 	 or if none of the following cases holds:	1. The receiver and anObject are both byte-type.	2. The receiver is any pointer-type object, anObject is a		non-indexable pointer-type object, and the storage sizes (i.e. the		number of named instance variables plus the number of indexed		instance variables, if any) of the two objects are the same.	3. The receiver is any pointer-type object, anObject is an indexable		pointer-type object, and the storage size of the receiver is at least		as large as the number of named instance variables of anObject.	Note that if the receiver does not have instance variables, the primitive	will assume the receiver is not a weak object or an ephemeron before	the class change, and that after the class change the receiver will not	be a weak object or an ephemeron either.	Compare with the adoptInstance: primitive."	&lt;primitive: 535 errorCode: errCode&gt;	^(errCode ~~ nil	   and: [errCode name = #'no modification'])		ifTrue: [self noModificationErrorFor: #changeClassToThatOf: index: nil value: anObject]		ifFalse: [self primitiveFailed]</body><body package="Protocols-Common">class	"Answer the object which is the receiver's class."	&lt;primitive: 111&gt;	self primitiveFailed</body><body package="Protocols-Common">isKindOf: aClass 	"Answer a Boolean as to whether the class, aClass, is a superclass or class of	the receiver."	^self class includesBehavior: aClass</body><body package="Protocols-Common">isMemberOf: aClass 	"Answer a Boolean as to whether the receiver is an instance of the class, aClass."	^self class == aClass</body><body package="Protocols-Common">respondsTo: aSymbol 	"Answer a Boolean as to whether the method dictionary of the receiver's class 	contains aSymbol as a message selector."	^self class canUnderstand: aSymbol</body></methods><methods><class-id>Protocols.ProtoObject</class-id> <category>private</category><body package="Protocols-Common">becomeNoRetry: otherObject 	"Swap the instance data and appropriate header information of the receiver and the	argument, otherObject. In other words, transform the receiver into the argument and	vice-versa.  Fail if either object is an immediate or a MethodContext or a	BlockContext or if there is insufficient memory to perform the become. Answer	with the argument which is now the semantic equivalent of the object that formerly	denoted the receiver."	&lt;primitive: 72 errorCode: errCode&gt;	^(errCode ~~ nil	   and: [errCode name = #'no modification'])		ifTrue: [self noModificationErrorFor: #becomeNoRetry: index: nil value: otherObject]		ifFalse: [self primitiveFailed]</body><body package="Protocols-Common">nilFields</body></methods><methods><class-id>Protocols.ProtoObject</class-id> <category>printing</category><body package="Protocols-Common">basicPrintOn: aStream        "Append to the argument aStream a sequence of characters        that describes the receiver."        | title |        title := self class printString.        aStream nextPutAll:                ((title at: 1) isVowel ifTrue: ['an '] ifFalse: ['a ']).        aStream nextPutAll: title</body><body package="Protocols-Common">basicPrintString	"Answer a String whose characters are a description of the receiver."	| aStream |	aStream := WriteStream on: (String new: 16).	self basicPrintOn: aStream.	^aStream contents</body><body package="Protocols-Common">forStackDumpPrintUsing: aPolicy	^aPolicy printObject: self</body><body package="Protocols-Common">printOn: aStream        "Append to the argument aStream a sequence of characters        that describes the receiver."        | title |        title := self class printString.        aStream nextPutAll:                ((title at: 1) isVowel ifTrue: ['an '] ifFalse: ['a ']).        aStream nextPutAll: title</body><body package="Protocols-Common">printString	"Answer a String whose characters are a description of the receiver."	| aStream |	aStream := WriteStream on: (String new: 16).	self printOn: aStream.	^aStream contents</body></methods><methods><class-id>Protocols.ProtoObject</class-id> <category>opentalk</category><body package="Protocols-Common">_isRemote	^false</body><body package="Protocols-Common">_printString	^self printString</body></methods><methods><class-id>Protocols.ProtoObject class</class-id> <category>accessing</category><body package="Protocols-Common">toolListIcon	^BehaviorIcons Proxy</body></methods><methods><class-id>Protocols.Struct</class-id> <category>accessing-dictionary</category><body package="Protocols-Common">add: anAssociation 	( self associationAt: anAssociation key		ifAbsent: [ ^self addLast: anAssociation ]	)	value: anAssociation value.	^anAssociation</body><body package="Protocols-Common">associationAt: key 	^self associationAt: key ifAbsent: [self keyNotFoundErrorFor: #associationAt: index: key]</body><body package="Protocols-Common">associationAt: key ifAbsent: aBlock	1 to: lastIndex do: [ :i || asc |		asc := self basicAt: i.		asc key = key ifTrue: [^asc] ].	^aBlock value</body><body package="Protocols-Common">associations      | coll |	coll := OrderedCollection new.	1 to: lastIndex do: [ :i | coll add: (self basicAt: i)  ].	^coll</body><body package="Protocols-Common">associationsDo: aBlock 	"Evaluate aBlock for each of the receiver's key/value associations."      	1 to: lastIndex do: [ :i | aBlock value: (self basicAt: i)  ].</body><body package="Protocols-Common">associationsDo: aBlock separatedBy: separatorBlock	"Evaluate aBlock for each of the receiver's key/value associations.	Between each pair of elements, but not before the first or after the last, evaluate the separatorBlock."	| first |	first := true.	1 to: lastIndex do: [ :i |		first ifTrue: [ first := false ] ifFalse: [ separatorBlock value ].		aBlock value: (self basicAt: i)  ].</body><body package="Protocols-Common">do: aBlock 	self associationsDo: [ :asc | aBlock value: asc value ]</body><body package="Protocols-Common">do: elementBlock separatedBy: separatorBlock	"Evaluate elementBlock for each element in the collection.	Between each pair of elements, but not before the first or	after the last, evaluate the separatorBlock."	| first |	first := true.	self do:		[:elmnt |		first ifTrue: [first := false]			ifFalse: [separatorBlock value].		elementBlock value: elmnt]</body><body package="Protocols-Common">includesKey: key 	"Answer whether the receiver has a key equal to the argument, key."	^(self associationAt: key ifAbsent: [nil]) notNil</body><body package="Protocols-Common">keysAndValuesDo: aBlock 	self associationsDo: [ :asc | aBlock value: asc key value: asc value ].</body><body package="Protocols-Common">removeKey: key	^self removeKey: key ifAbsent: [self keyNotFoundErrorFor: #removeKey: index: key]</body><body package="Protocols-Common">removeKey: key ifAbsent: aBlock 	1 to: lastIndex do: [ :i || asc |		asc := self basicAt: i.		asc key = key ifTrue: [			i + 1 to: lastIndex do: [ :j | self basicAt: j - 1 put: (self basicAt: j) ].			self basicAt: lastIndex put: nil.			lastIndex := lastIndex - 1.			^asc value ] ].	^aBlock value</body></methods><methods><class-id>Protocols.Struct</class-id> <category>copying</category><body package="Protocols-Common">copy	^self shallowCopy postCopy</body><body package="Protocols-Common">copyEmpty: aSize	"Answer a copy of the receiver that contains no elements.	This method should be redefined in subclasses that add	instance variables, so that the state of those variables	is preserved"	| newSelf |	newSelf := self class new: aSize.	newSelf structName: self structName.	^newSelf</body><body package="Protocols-Common">postCopy	1 to: lastIndex do: [ :i | self basicAt: i put: (self basicAt: i) copy ]</body><body package="Protocols-Common">shallowCopy	"Answer a copy of the receiver which shares the receiver's instance 	variables."	&lt;primitive: 532&gt;	| class newObject index |	class := self class.	newObject := class basicNew: (index := self basicSize).	1 to: index do: [ :i |  newObject basicAt: i put: (self basicAt: i)  ].	1 to: class instSize do: [ :i |  newObject instVarAt: i put: (self instVarAt: i)  ].	^newObject</body></methods><methods><class-id>Protocols.Struct</class-id> <category>accessing</category><body package="Protocols-Common">at: key	^self at: key ifAbsent: [ self keyNotFoundError: key ]</body><body package="Protocols-Common">at: key ifAbsent: aBlock	^(self		associationAt: key		ifAbsent: [ ^aBlock value ]	)	value</body><body package="Protocols-Common">at: key ifAbsentPut: aBlock	^self	associationAt: key		ifAbsent: [ | value |			value := aBlock value.			self addLast: key -&gt; value.			value ]</body><body package="Protocols-Common">at: key put: value	(self	associationAt: key		ifAbsent: [ self addLast: key -&gt; value ])		value: value.	^value</body><body package="Protocols-Common">structName	^name</body><body package="Protocols-Common">structName: aString	name := aString</body><body package="Protocols-Common">structSize	^lastIndex</body><body package="Protocols-Common">yourself	"Answer self."</body></methods><methods><class-id>Protocols.Struct</class-id> <category>comparing</category><body package="Protocols-Common">= anObject	"... must handle different orderings of the associations consequent upon the DER's constraints governing transmission order."	^( self class == anObject class )		and: [ ( self structName = anObject structName )			and: [ self contentsEquals: anObject ] ]</body><body package="Protocols-Common">contentsEquals: aStruct	"Anwer true if  the receiver and aStruct contain the same key/values in the same order."	self structSize == aStruct structSize ifFalse: [ ^false ].	1 to: lastIndex do: [ :i |		(self basicAt: i) = (aStruct basicAt: i) ifFalse: [^false] ].	^true</body><body package="Protocols-Common">hash	| h |	h := self structName hash.	1 to: self basicSize do: [ :i |		(self basicAt: i) ifNotNil: [ :asc |			h := (h bitXor: asc key hash) bitXor: asc value hash] ].	^h</body></methods><methods><class-id>Protocols.Struct</class-id> <category>error handling</category><body package="Protocols-Common">keyNotFoundError: key	"Raise a signal indicating that the key was not found."	^(KeyNotFoundError receiver: self selector: nil index: key) raiseRequest</body><body package="Protocols-Common">keyNotFoundErrorFor: selector index: key	"Raise a signal indicating that the key was not found."	^(KeyNotFoundError receiver: self selector: selector index: key) raiseRequest</body></methods><methods><class-id>Protocols.Struct</class-id> <category>private</category><body package="Protocols-Common">addLast: anAssociation 	anAssociation key == nil ifTrue: [		^self subscriptBoundsErrorFor: #addLast: index: nil value: anAssociation value].	lastIndex = self basicSize ifTrue: [self makeRoomAtLast].	lastIndex := lastIndex + 1.	self basicAt: lastIndex put: anAssociation.	^anAssociation</body><body package="Protocols-Common">changeCapacityTo: newCapacity	| newSelf | 	newSelf := self copyEmpty: newCapacity.	self associationsDo: [:each | newSelf noCheckAddLast: each].	self become: newSelf</body><body package="Protocols-Common">doesNotUnderstand: aMessage	| selector numArgs |	selector := aMessage selector.	(numArgs := aMessage arguments size) isZero ifTrue: [		^self at: selector ifAbsent: [ super doesNotUnderstand: aMessage ] ].	(numArgs &gt; 1 or: [ selector last ~= $: ]) ifTrue: [		^super doesNotUnderstand: aMessage ].	self at: (selector copyFrom: 1 to: selector size - 1) asSymbol put: aMessage arguments first</body><body package="Protocols-Common">growSize	"Answer an amount by which the receiver should grow 	to make room for more elements."	^5</body><body package="Protocols-Common">increaseCapacity	"Increase the number of elements of the collection."	self changeCapacityTo: self basicSize + self growSize.</body><body package="Protocols-Common">makeRoomAtLast	^self increaseCapacity</body><body package="Protocols-Common">noCheckAddLast: anAssociation 	lastIndex := lastIndex + 1.	self basicAt: lastIndex put: anAssociation</body></methods><methods><class-id>Protocols.Struct</class-id> <category>initialize-release</category><body package="Protocols-Common">initialize	lastIndex := 0</body></methods><methods><class-id>Protocols.Struct</class-id> <category>testing</category><body package="Protocols-Common">isEmpty	^lastIndex = 0</body><body package="Protocols-Common">isString	^false</body><body package="Protocols-Common">isStruct	^true</body><body package="Protocols-Common">notEmpty	^self isEmpty not</body></methods><methods><class-id>Protocols.Struct</class-id> <category>printing</category><body package="Protocols-Common">printNameOn: aStream	( name notNil ) ifTrue: [ name printOn: aStream. aStream space ]</body><body package="Protocols-Common">printOn: aStream	self printNameOn: aStream.	aStream nextPut: ${.	self	associationsDo: [ :asc |			asc key isString ifTrue: [ aStream nextPutAll: asc key] ifFalse: [ aStream print: asc key ].			aStream nextPutAll: ' '; print: asc value ]		separatedBy: [ aStream nextPutAll: ', ' ].	aStream nextPut: $}.</body></methods><methods><class-id>Protocols.Struct</class-id> <category>binary storage</category><body package="Protocols-Common">representBinaryOn: binWriter	" By default, objects do nothing special	to represent themselves in binary form. "	^nil</body></methods><methods><class-id>Protocols.Struct class</class-id> <category>instance creation</category><body package="Protocols-Common">name: aString	^self new		structName: aString;		yourself</body><body package="Protocols-Common">new	^self new: 5</body><body package="Protocols-Common">new: anInteger	^(super new: anInteger) initialize</body></methods><methods><class-id>Protocols.Struct class</class-id> <category>accessing</category><body package="Protocols-Common">toolListIcon	^Dictionary toolListIcon</body></methods><methods><class-id>Protocols.TimedPromise</class-id> <category>accessing-parent</category><body package="Protocols-Common">signalTimeout	^PromiseExpiredError new		messageText: (#errPromiseExpiredError &lt;&lt; #protocols &gt;&gt; 'Promise expiration error');		parameter: self;		raiseSignal</body><body package="Protocols-Common">value	delay wait.	"Wait for data arrival or alarm expiry."	delay disable.	sync signal. "To allow multiple reads of the result"	^exception == nil 		ifTrue: [hasValue				ifTrue: [					value]				ifFalse: [self signalTimeout.					"If resumed, start over"					sync wait. "Undo the signal above"					self value]]		ifFalse: [exception				clearForReraise;				searchFrom: thisContext;				raise]</body></methods><methods><class-id>Protocols.TimedPromise</class-id> <category>initialization</category><body package="Protocols-Common">initialize: msec	delay := Delay forMilliseconds: msec.	sync := delay delaySemaphore.</body></methods><methods><class-id>Protocols.TimedPromise class</class-id> <category>instance creation</category><body package="Protocols-Common">forMilliseconds: anInteger	^self new initialize: anInteger</body></methods><methods><class-id>Protocols.Base64StreamEncoder</class-id> <category>manipulating sextets</category><body package="Protocols-Common">fillNibbleFrom: aStream	|  nSextets code enc |	enc := self class octetMap.	nibble := 0.	nSextets := 0.	1 to: 4 do: [ :idx |		aStream atEnd ifTrue: [ ^nSextets ].		code := aStream next.		(code isNil or: [ code == self padChar ]) ifTrue: [ ^nSextets ].		nibble := nibble bitOr: ((enc at: code ) bitShift: (self shiftValueAt: idx)).		nSextets := nSextets + 1.	].	^nSextets</body><body package="Protocols-Common">nextPutNibble: ival on: aStream	| nchars code dec |	dec := self class sextetMap.	nchars := self charsToEncode.	1 to: nchars do: [ :idx |		code := ((ival bitAnd: (self sextetMaskAt: idx)) bitShift: (self shiftValueAt: idx) negated) bitAnd: 16r3f. 		aStream nextPut: ( dec at: (code + 1)).	].	self charsToPad timesRepeat: [ aStream nextPut: self padChar ].	self reset</body><body package="Protocols-Common">octetsToDecodeFromSextets: nSextets	" Depending on how many characters was read from source stream, answer "	" how many octets can be decoded from these characters (nSextets is zero-based) "	^#(0 0 1 2 3 ) at: nSextets + 1</body><body package="Protocols-Common">sextetMaskAt: idx	^#(		2r111111000000000000000000		2r000000111111000000000000		2r000000000000111111000000		2r000000000000000000111111	) at: idx.</body><body package="Protocols-Common">shiftValueAt: idx	^#( 18 12 6 0 ) at: idx.</body></methods><methods><class-id>Protocols.Base64StreamEncoder</class-id> <category>private</category><body package="Protocols-Common">charsToEncode	^#(1 2 3 4) at: index + 1.</body><body package="Protocols-Common">charsToPad	^#(0 2 1 0) at: index + 1.</body><body package="Protocols-Common">index	^index</body><body package="Protocols-Common">nibble	^nibble</body><body package="Protocols-Common">padChar	^$= asInteger</body><body package="Protocols-Common">privateNextPut: int on: aStream	| length |	length := int digitLength.	length = 1 		ifTrue: [ self nextPutOctet: int on: aStream]		ifFalse: [ 1 to: length do: [ :idx | self nextPackOctet: (int digitAt: idx) ] ]</body><body package="Protocols-Common">reset	index := 0.	nEncoded := 0.	nibble := 0.</body></methods><methods><class-id>Protocols.Base64StreamEncoder</class-id> <category>initialization</category><body package="Protocols-Common">initialize	super initialize.	self reset</body></methods><methods><class-id>Protocols.Base64StreamEncoder</class-id> <category>packing/unpacking octets</category><body package="Protocols-Common">getNibbleFrom: aStream	| nSextets |	nSextets := self fillNibbleFrom: aStream.	nEncoded := self octetsToDecodeFromSextets: nSextets.	index := 3.</body><body package="Protocols-Common">nEncoded	" Answer number of encoded octets "	^nEncoded</body><body package="Protocols-Common">nextPackOctet: octet	nibble := (nibble bitShift: 8) bitOr: octet.</body><body package="Protocols-Common">nextPutOctet: octet on: aStream	self nextPackOctet: octet.	index := index + 1.	index = 3 ifTrue: [ self nextPutNibble: nibble on: aStream ]</body><body package="Protocols-Common">nextUnpackOctet	"Decode the next byte(s) in the stream and answer the character."	| octet |	nEncoded = 0 ifTrue: [ ^nil ].	octet := nibble digitAt: index.	index := index - 1.	nEncoded := nEncoded - 1.	^octet</body></methods><methods><class-id>Protocols.Base64StreamEncoder</class-id> <category>accessing</category><body package="Protocols-Common">characterSize: char	"Return the size in bytes of &lt;char&gt;."	^1</body><body package="Protocols-Common">encoder: anEncoder	encoder := anEncoder</body><body package="Protocols-Common">nextFrom: aStream	"Decode the next byte(s) in the stream and answer the code."	nEncoded = 0 ifTrue: [ self getNibbleFrom: aStream ].	^self nextUnpackOctet.</body><body package="Protocols-Common">nextPut: c on: aStream	| code |	((code := self encoder encode: c) &gt; 255 or: [ code &lt; 0 ])		ifTrue: [self noEncodingFor: c]		ifFalse: [ self privateNextPut: code on: aStream]</body><body package="Protocols-Common">prepareToClose: aStream	"If there are some conventions about the state of the file	at closing, prepare those conventions."	index &gt; 0 ifTrue: [		index to: 2 do: [ :idx | self nextPackOctet: 0 ].		self nextPutNibble: self nibble on: aStream.	]</body></methods><methods><class-id>Protocols.Base64StreamEncoder class</class-id> <category>accesing</category><body package="Protocols-Common">octetMap	^octetMap</body><body package="Protocols-Common">sextetMap	^sextetMap</body><body package="Protocols-Common">streamEncodingType	^#BASE64</body></methods><methods><class-id>Protocols.Base64StreamEncoder class</class-id> <category>testing</category><body package="Protocols-Common">test1	"self test1"	| stream |	" Encoding string as base64 "	stream := (ByteArray new withEncoding: #BASE64) writeStream.	stream nextPutAll: 'Aladdin:open sesame'.	stream close.	" Should be 'QWxhZGRpbjpvcGVuIHNlc2FtZQ==' "	^(stream encodedContents withEncoding: #ASCII) readStream contents</body><body package="Protocols-Common">test2	"self test2"	| stream input output char |	" Decoding base64-encoded string "	input := 'QWxhZGRpbjpvcGVuIHNlc2FtZQ==' asByteArray readStream.	stream := EncodedStream on: input encodedBy: Base64StreamEncoder asEncoder.	output := (ByteArray new: 64) writeStream.	[ (char := stream next) notNil ] whileTrue: [ output nextPut: char ].	^(output contents withEncoding: #ASCII) readStream contents		" should be 'Aladdin:open sesame'. "</body><body package="Protocols-Common">test3	" self test3 "	| output stream input unistr base64str stream1 result char unistr1 stream2 |" Test encoding/decoding Unicode strings as base64. We take regular string 'Aladdin:open sesame', encode it as Unicode bytes (byte array) and then encodeUnicode bytes as base64. Then the process is reverted: base64-encoded stringis decoded back into Unicode byte array which is then decoded back into the original string "	output := (ByteArray new: 64) writeStream.	stream := EncodedStream on: output encodedBy: UnicodeStreamEncoder asEncoder. " Default string-&gt;Unicode encoder "	stream nextPutAll: 'Aladdin:open sesame'.	stream close.						" This is needed to flush byte buffer "	unistr := output contents.			" Unicode bytes "	output := (ByteArray new: 64) writeStream.	stream := EncodedStream on: output encodedBy: ((Base64StreamEncoder asEncoder) encoder: UnicodeCharacterEncoder new; yourself).	" Unicode bytes-&gt;base64 encoder "	stream nextPutAll: unistr.				stream close.						" This is needed to flush byte buffer "	base64str := output contents.	" base64-encoded string "	input := base64str readStream.		stream1 := EncodedStream on: input encodedBy: 	" Base64-&gt;Unicode decoder "								((Base64StreamEncoder asEncoder) encoder: UnicodeCharacterEncoder new; yourself).	result := (ByteArray new: 64) writeStream.	[ (char := stream1 next) notNil ] whileTrue: [ result nextPut: char ].		" Convert from base64 to Unicode "	unistr1 := result contents. 	" should be 'Aladdin:open sesame' in Unicode as byte array "	stream2 := EncodedStream on: unistr1 readStream encodedBy: UnicodeStreamEncoder asEncoder.	" Unicode-&gt;default string decoder "	^stream2 upToEnd.					" should be 'Aladdin:open sesame'. "</body></methods><methods><class-id>Protocols.Base64StreamEncoder class</class-id> <category>class initialization</category><body package="Protocols-Common">initialize	"Initialize class variables"	self initializeMaps.	self flushEncoderDirectory.</body><body package="Protocols-Common">initializeMaps	| stream |	stream := ((ByteArray new: 64) withEncoding: #ASCII) writeStream.	stream nextPutAll: self sextetMapCharacters.	sextetMap := stream encodedContents.	octetMap := IdentityDictionary new.	1 to: sextetMap size		do: [ :idx | octetMap at: ( sextetMap at: idx) put: (idx -1)].</body></methods><methods><class-id>Protocols.Base64StreamEncoder class</class-id> <category>private</category><body package="Protocols-Common">characterSet	^'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'</body><body package="Protocols-Common">defaultCharacterEncoder	^String defaultPlatformClass encoder</body><body package="Protocols-Common">sextetMapCharacters	^'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'</body></methods><methods><class-id>Protocols.Base64StreamEncoder class</class-id> <category>initialize-release</category><body package="Protocols-Common">obsolete	StreamEncoder.EncoderDirectory removeKey: #base64 ifAbsent: [].	super obsolete</body></methods><methods><class-id>Protocols.PromiseExpiredError class</class-id> <category>testing</category><body package="Protocols-Common">mayResume	^true</body></methods><methods><class-id>Protocols.EventCollector</class-id> <category>deprecated</category><body package="Protocols-Common">dumpToTranscript	self clearToTranscript</body></methods><methods><class-id>Protocols.EventCollector</class-id> <category>private</category><body package="Protocols-Common">clockEmphasis	^Array with: #color -&gt; ColorValue darkMagenta</body><body package="Protocols-Common">printEventsOn: aStream	| originalEmphasis |	originalEmphasis := aStream emphasis.	events do: [ :rec |		aStream cr; emphasis: self clockEmphasis.		self	printTime: (				baseClockValue isNil					ifTrue: [rec key]					ifFalse: [rec key - baseClockValue])			on: aStream.		aStream tab.		self printEvent: rec value on: aStream ].	aStream emphasis: originalEmphasis.</body><body package="Protocols-Common">printTime: milliseconds on: aStream	| tm |	tm := (Time aTime: milliseconds // 1000) last.	tm hours printOn: aStream paddedWith: $0 to: 2 base: 10.	aStream nextPut: $:.	tm minutes printOn: aStream paddedWith: $0 to: 2 base: 10.	aStream nextPut: $:.	tm seconds printOn: aStream paddedWith: $0 to: 2 base: 10.	aStream	nextPut: $..	(milliseconds \\ 1000) printOn: aStream paddedWith: $0 to: 3 base: 10</body><body package="Protocols-Common">privateProcess: anEvent	events add: (Time millisecondClockValue -&gt; anEvent)</body></methods><methods><class-id>Protocols.EventCollector</class-id> <category>services</category><body package="Protocols-Common">clear	events := OrderedCollection new: events size</body><body package="Protocols-Common">clearToTranscript	self toTranscript; clear</body><body package="Protocols-Common">resetClock	baseClockValue := Time millisecondClockValue</body><body package="Protocols-Common">toTranscript	self transcriptTextStreamDo: [ :ts |		self printEventsOn: ts ]	"Transcript flush"</body></methods><methods><class-id>Protocols.EventCollector</class-id> <category>initialize/release</category><body package="Protocols-Common">initialize: eventsSize	events := OrderedCollection new: eventsSize</body><body package="Protocols-Common">release	events := nil.	super release</body></methods><methods><class-id>Protocols.EventCollector</class-id> <category>accessing</category><body package="Protocols-Common">events	^events</body></methods><methods><class-id>Protocols.EventCollector class</class-id> <category>instance creation</category><body package="Protocols-Common">new	^self new: 50</body><body package="Protocols-Common">new: eventsSize	^super new initialize: eventsSize</body></methods><methods><class-id>Protocols.SharedRegistry</class-id> <category>accessing</category><body package="Protocols-Common">at: key ifAbsent: absent"Find and return the element at key. If it is not present, run the absent block."	^lock critical: [		elements at: key ifAbsent: absent ]</body><body package="Protocols-Common">at: key ifAbsent: absent ifPresent: present"Find an object at key. Run the present block with it if it is present, otherwise run the absent block. Return the resulting value."	^lock critical: [ | element found |		found := true.		element := elements at: key ifAbsent: [ found := false ].		found			ifTrue: [ present value: element ]			ifFalse: [ absent value ] ]</body><body package="Protocols-Common">at: key ifAbsentPut: absent"Find an object at key or, if there isn't one, register a result of absent block at that key instead."	^lock critical: [ elements at: key ifAbsentPut: absent ]</body><body package="Protocols-Common">at: key ifAbsentPut: absent do: block"Find an object at key or if there isn't one register a result of absent block at that key instead. Then run block with either of them."	^lock critical: [ | element |		element := elements at: key ifAbsentPut: absent.		block value: element.		element ]</body><body package="Protocols-Common">at: key put: object"Add an object to the registry."	^lock critical: [		elements at: key put: object ]</body><body package="Protocols-Common">at: key put: object do: block"Add an object to the registry and execute block"	lock critical: [		elements at: key put: object.		block value ].	^object</body><body package="Protocols-Common">includesKey: key	^lock critical: [ elements includesKey: key ]</body><body package="Protocols-Common">keys	^lock critical: [ elements keys ]</body><body package="Protocols-Common">removeKey: key ifAbsent: absent"Find an object at key and remove it. Run the the absent block if the key is absent."	^lock critical: [		elements removeKey: key ifAbsent: absent ]</body><body package="Protocols-Common">removeKey: key ifAbsent: absent ifPresent: present"Find an object at key and remove it. Run the present block with the element if it is present, otherwise run the absent block.."	^lock critical: [ | element found |		found := true.		element := elements removeKey: key ifAbsent: [ found := false ].		found			ifTrue: [ present value: element ]			ifFalse: [ absent value ] ]</body><body package="Protocols-Common">size	^elements size</body></methods><methods><class-id>Protocols.SharedRegistry</class-id> <category>initialize-release</category><body package="Protocols-Common">initialize	elements := Dictionary new.	lock := RecursionLock new.</body></methods><methods><class-id>Protocols.SharedRegistry</class-id> <category>enumerating</category><body package="Protocols-Common">do: block	lock critical: [		"We have to copy because block might be adding/removing elements"		elements values do: block ]</body></methods><methods><class-id>Protocols.SharedRegistry class</class-id> <category>instance creation</category><body package="Protocols-Common">new	^super new initialize</body></methods><methods><class-id>Protocols.DecodedStream</class-id> <category>accessing</category><body package="Protocols-Common">close	self finish.	stream close</body><body package="Protocols-Common">contents	"Answer with a copy of the receiver's readable information.	 Assuming that the size of encoded file in byte is always	 equal or bigger than the number of Unicode characters."	| str c |	str := (self contentsSpecies new: (stream size)) writeStream.	[self atEnd]		whileFalse:			[c := self next.			c == nil ifFalse: [str nextPut: c]].	^str contents</body><body package="Protocols-Common">finish	self flush.	cache position isZero ifFalse: [		self error: 'Incomplete encoding for the last character!' ].	super finish</body><body package="Protocols-Common">flush	self decodeAndPushCharacters.	super flush</body><body package="Protocols-Common">next	"Answer the next object in the Stream represented by the receiver."	binary ifFalse: [^stream next].	[ cache atEnd and: [ stream atEnd not ] ] whileTrue: [		self pullAndEncodeCharacter.		cache reset ].	cache atEnd ifTrue: [ encoder checkAtEnd ].	^cache next</body><body package="Protocols-Common">nextPut: anObject	binary ifFalse: [^stream nextPut: anObject].	cache nextPut: anObject.	cache position &gt; 10 ifTrue: [		"If we accumulated a few bytes, let's try to push some characters through"		self decodeAndPushCharacters ].	^anObject</body><body package="Protocols-Common">peek"Answer what would be returned with a self next, without changing position.  If the receiver is at the end, answer nil."	| next |	binary ifFalse: [^stream peek].	self atEnd ifTrue: [^nil].	next := self next.	cache skip: -1.	^next</body><body package="Protocols-Common">peekFor: anObject "Answer false and do not move the position if self next ~= anObject or if the receiver is at the end. Answer true and increment position if self next = anObject."	| next |	binary ifFalse: [^stream peekFor: anObject ].	self atEnd ifTrue: [^false].	next := self next.	"peek for matching element"	anObject = next ifTrue: [^true].	"gobble it if found"	cache skip: -1.	^false</body><body package="Protocols-Common">skip: anInteger"Skip anInteger of elements."	| step |	binary ifFalse: [^stream skip: anInteger].	anInteger &lt; 0 ifFalse: [		anInteger timesRepeat: [self next isNil ifTrue: [^self]].		^self].	"skip back"	step := anInteger.	[ cache position &lt; step negated ] whileTrue: [		step := step + cache position.		stream skip: -2.		self pullAndEncodeCharacter ].	cache skip: step.	^self</body></methods><methods><class-id>Protocols.DecodedStream</class-id> <category>private</category><body package="Protocols-Common">contentsSpecies	^binary		ifTrue: [ByteArray]		ifFalse: [stream contentsSpecies]</body><body package="Protocols-Common">decodeAndPushCharacters	| position leftover |	cache reset.	leftover := #[].	[	position := cache position.		cache atEnd	] whileFalse: [		(encoder nextFrom: cache)			ifNil: [ "we don't have entire encoding of the last character yet, let's capture the leftover"				cache position: position.				leftover := cache upToEnd ]			ifNotNil: [ :c |				c == LF					ifTrue: [						(crPreceeding and: [ lineEndConvention = LineEndCRLF ]) ifFalse: [							stream nextPut: (								lineEndConvention == LineEndLF									ifTrue: [ CR ]									ifFalse: [ LF ]) ] ]					ifFalse: [ stream nextPut: c ].				crPreceeding := c == CR ] ].	cache on: cache collection. "reinitialize stream"	cache nextPutAll: leftover</body><body package="Protocols-Common">pullAndEncodeCharacter	cache := cache on: cache collection. "reinitialize the stream"	stream next ifNotNil: [ :char |		char == CR			ifTrue: [ lineEndConvention == LineEndLF					ifTrue: [ encoder nextPut: LF on: cache ]					ifFalse: [ encoder nextPut: CR on: cache ].				lineEndConvention == LineEndCRLF ifTrue: [					encoder nextPut: LF on: cache ] ]			ifFalse: [ encoder nextPut: char on: cache ] ]</body></methods><methods><class-id>Protocols.DecodedStream</class-id> <category>initialize</category><body package="Protocols-Common">on: aStream encodedBy: aStreamEncoder	super on: aStream encodedBy: aStreamEncoder.	binary := true.	cache := ReadWriteStream on: (ByteArray new: 10).	crPreceeding := false.</body></methods><methods><class-id>Protocols.DecodedStream</class-id> <category>positioning</category><body package="Protocols-Common">position: anInteger		cache on: cache collection. "reinitialize stream"	crPreceeding := false.	^super position: anInteger</body><body package="Protocols-Common">reset		cache on: cache collection. "reinitialize stream"	crPreceeding := false.	^super reset</body></methods><methods><class-id>Protocols.DecodedStream</class-id> <category>testing</category><body package="Protocols-Common">atEnd	binary ifFalse: [ ^stream atEnd ].	[ cache atEnd and: [ stream atEnd not ] ] whileTrue: [		self pullAndEncodeCharacter.		cache reset ].	^cache atEnd and: [ encoder checkAtEnd ]</body></methods><methods><class-id>Protocols.B64StreamDecoder</class-id> <category>printing</category><body package="Protocols-Common">encoding	^#base64</body><body package="Protocols-Common">printOn: aStream	aStream nextPutAll: 'B64';		nextPut: $[.	leftover printOn: aStream base: 16 digitsToPad: 2 highDigit: 2.	aStream		nextPut: $@;		print: quart;		nextPut: $]</body></methods><methods><class-id>Protocols.B64StreamDecoder</class-id> <category>private</category><body package="Protocols-Common">advance	offset := offset + 1.	quart := (quart + 1) \\ 4.</body><body package="Protocols-Common">checkAtEnd"This is called at the end of the underlying stream and is meant to check that the encoding of the last bytes was complete, that there isn't anything left over unfinished."		quart isZero ifFalse: [		self error: #Base64IncompleteByteEncoding &lt;&lt; #protocols &gt;&gt; 'Incomplete encoding of last byte!' ].	^true</body><body package="Protocols-Common">nextPartFor: sextet	| mask shift |	mask := #(2r11111100 2r11110000 2r11000000).	shift := #(-2 -4 -6).	^(leftover bitAnd: (mask at: sextet))		bitShift: (shift at: sextet)</body><body package="Protocols-Common">nextPartOf: sextet	| shift |	quart = 0 ifTrue: [^0].	shift := #(2 4 6).	^(sextet bitShift: (shift at: quart)) bitAnd: 16rFF</body><body package="Protocols-Common">previousPartFor: sextet	| mask shift |	mask := #(2r00000011 2r00001111 2r00111111).	shift := #(4 2 0).	^(leftover bitAnd: (mask at: sextet))		bitShift: (shift at: sextet)</body><body package="Protocols-Common">previousPartOf: sextet	| shift |	shift := #(-4  -2 0).	^leftover bitOr: (sextet bitShift: (shift at: quart))</body><body package="Protocols-Common">privateNextFrom: aStream	| next |	next := 0.	quart = 0 ifFalse: [		next := self previousPartFor: quart ].	self advance.	quart = 0 ifFalse: [		leftover := aStream next.		next := next bitOr: (self nextPartFor: quart) ].	^next</body><body package="Protocols-Common">privateNextPut: sextet on: aStream	quart = 0 ifFalse: [		leftover := self previousPartOf: sextet.		aStream nextPut: leftover ].	self advance.	leftover := self nextPartOf: sextet</body></methods><methods><class-id>Protocols.B64StreamDecoder</class-id> <category>accessing</category><body package="Protocols-Common">lineLength	^lineLength ifNil: [ self class defaultLineLength ]</body><body package="Protocols-Common">lineLength: length"	&lt;Integer&gt; specifies the line length where to emit CR and wrap to the next line when encoding"	lineLength := length</body><body package="Protocols-Common">nextFrom: aStream	offset &lt; self lineLength ifFalse: [		offset := 0.		^CR ].	^SextetMap at: (self privateNextFrom: aStream) + 1</body><body package="Protocols-Common">nextPut: c on: aStream	c = $= ifTrue: [ finishing := true ].	(Whitespace includes: c) ifTrue: [^c].	finishing ifTrue: [		(c = $= and: [ quart &gt; 1 ])			ifTrue: [ self advance. ^c ]			ifFalse: [ self error: 'Reading past the end of Base 64 encoding!' ] ].	(OctetMap at: c ifAbsent: [ nil ])		ifNil: [self noEncodingFor: c]		ifNotNil: [ :code | self privateNextPut: code on: aStream].	^c</body><body package="Protocols-Common">prepareToClose: aStream	"If there are some conventions about the state of the file	at closing, prepare those conventions."	quart = 0 ifFalse: [  "flush the last nibble"		aStream nextPut: (			self nextFrom: Zeros) ].	"at this point quart is one of 0,2,3"	quart = 0 ifFalse: [		4 - quart timesRepeat: [ aStream nextPut: $= ] ].	self reset</body><body package="Protocols-Common">reset	quart := 0.	offset := 0.	leftover := 0.	finishing := false.</body></methods><methods><class-id>Protocols.B64StreamDecoder class</class-id> <category>zeros</category><body package="Protocols-Common">next"This method is here to have the receiver emulate an efficient infinite stream of zeros."	^0</body></methods><methods><class-id>Protocols.B64StreamDecoder class</class-id> <category>accessing</category><body package="Protocols-Common">defaultLineLength	^defaultLineLength ifNil: [ self defaultLineLengthValue ]</body><body package="Protocols-Common">defaultLineLength: length"	length &lt;Integer&gt; specifies the default line length where to emit CR and wrap to the next line when encoding"	defaultLineLength := length</body><body package="Protocols-Common">defaultLineLengthValue	^76</body><body package="Protocols-Common">streamEncodingType	^nil "Don't register this encoder"</body></methods><methods><class-id>Protocols.B64StreamDecoder class</class-id> <category>instance creation</category><body package="Protocols-Common">new: symbol	^symbol = #base64		ifTrue: [ self asEncoder ]		ifFalse: [ super new: symbol ]</body></methods><methods><class-id>Protocols.B64StreamDecoder class</class-id> <category>class initialization</category><body package="Protocols-Common">initialize	SextetMap := 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.	OctetMap := IdentityDictionary new.	1 to: SextetMap size		do: [ :idx | OctetMap at: ( SextetMap at: idx) put: (idx -1)].	"the class is also used to emulate an efficient, infinite stream of zeros. See the class method #next"	Zeros := self.	Whitespace := Array with: CR with: LF with: Character tab with: Character space.	DecodedStreamConstructor		register: self as: #base64;		register: self as: #b64.</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="Protocols-Common">_isForwarder	^false</body></methods><methods><class-id>Core.Object</class-id> <category>private</category><body package="Protocols-Common">_printOn: aStream	self printOn: aStream</body></methods><methods><class-id>Core.Object</class-id> <category>converting</category><body package="Protocols-Common">asOutputParameter	^Protocols.OutputParameter with: self</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="Protocols-Common">isOutputParameter	^false</body></methods><methods><class-id>Core.Locale class</class-id> <category>protocols extensions</category><body package="Protocols-Common">getLocaleNamed: aString"aString is a language name from an Http Accept-Language field. If there is no such locale use #C as a default.Retuns Locale object that is exact match to the accept-language value. S "	| httpLocaleName localeName |	httpLocaleName := self transformHTTPLocaleName: aString.	localeName := self availableLocales 		detect: [:each | each = httpLocaleName]		ifNone: [#C].	^self named: localeName.</body><body package="Protocols-Common">getLocalesNamed: aString"aString is a language name from an Http Accept-Language field. If there is no such locale use #C as a default.Returns a collection of Locale objects corresponding the first token of the aString. For 'en-us' returns 'en', 'en_AS', 'en_AU' and so on.""This method has a single sender, HttpServletRequest class &gt;&gt; #getLocales:, which has no senders (this may not be true if a legacy component is loaded in the image). In the absence of senders, it's difficult to see the expected return value, but the method did not do what the comment above indicated, so I've modified it to conform.	self getLocalesNamed: 'en-us'.	self getLocalesNamed: 'en-as'.	self getLocalesNamed: 'en'."	| localeNames httpLocaleName |	httpLocaleName := (self transformHTTPLocaleName: aString) readStream upTo: $_.	localeNames := self availableLocales select: [:each | (each readStream upTo: $_) = httpLocaleName].	localeNames isEmpty ifTrue: [localeNames := #(#C)].	"No need to send #getLocaleNamed: to self, as it essentially repeats the first part of this method. We can go straight to 'self named: each':"	^localeNames collect: [:each | self named: each].</body><body package="Protocols-Common">getLocalesWithNames: httpAcceptableLanguages"Return a list of acceptable locales given the language and character sets. This is messy, because http separates out language and character set, but vw combines them into a single locale. Try to find one which matches both. If impossible, try just one, giving priority to the charset. If they all fail, use the defaultReturn collection of Locale objects:	- if the name found returns exact match (for 'en-us' returns Locale named 'en_US')	- if the name is not found returns parent locale (for 'en-xx' returns Locale named 'en')	- if there is '*' wild card returns all available Locale objects"	| httpLocaleNames exactMatches languageButNotTerritoryMatches available pureLanguageNames |		httpAcceptableLanguages isEmpty ifTrue: [ ^ Array with: self current ].	httpLocaleNames := httpAcceptableLanguages collect: [:each | self transformHTTPLocaleName: each].	available := self availableLocales.		exactMatches := httpLocaleNames select: [:localeName| available includes: localeName   ].		exactMatches notEmpty ifTrue: [^exactMatches collect: [:each | self named: each ]].			pureLanguageNames := httpLocaleNames collect: [:each | each readStream upTo: $_].	languageButNotTerritoryMatches := available select: [:locName | 		pureLanguageNames anySatisfy: [ :lang | (locName readStream upTo: $_) = lang ]].	languageButNotTerritoryMatches notEmpty ifTrue: [		^languageButNotTerritoryMatches collect: [:each | self named: each]].			^(httpLocaleNames includes: #*) 		ifTrue: [available collect: [:each | self named: each]] 		ifFalse: [ Array with: self current ].</body><body package="Protocols-Common">getLocaleWithNames: httpAcceptableLanguages"Retuns Locale object:	- if the name found returns exact match (for 'en-us' returns Locale named 'en_US')	- if the exact name is not found returns parent locale (for 'en-xx' returns Locale named 'en')	- if the name is not found returns Locale current."	| httpLocaleNames available pureLanguageNames |	httpAcceptableLanguages isEmpty ifTrue: [ ^ self current ].	httpLocaleNames := httpAcceptableLanguages collect: [:each | self transformHTTPLocaleName: each].	available := self availableLocales.	httpLocaleNames do: [:httpLocale| 		available detect: [:eaName| eaName = httpLocale ] ifFound: [ :match | ^self named: match]].			pureLanguageNames := httpLocaleNames collect: [:each | (each readStream upTo: $_) asSymbol].	pureLanguageNames do: [:each| 		available detect: [:eaName| eaName = each ] ifFound: [ :match |^self named: match]].		^self current.</body><body package="Protocols-Common">transformHTTPLocaleName: aString"Http gives us names like da or en-gb. Transform to correspond to vw locales, which use underscores and second token as uppercase en_GBExamples:	self transformHTTPLocaleName: 'de'.	self transformHTTPLocaleName: 'en-gb'."	| answer uppercase |	(aString = 'c' or: [aString = 'C']) ifTrue: [^#C].	uppercase := false.	answer := String new: aString size.	aString keysAndValuesDo: [ :index :char |		('-_' includes: char)			ifTrue: [ answer at: index put: $_. uppercase := true ]			ifFalse: [ answer at: index put: (uppercase ifTrue: [ char asUppercase ] ifFalse: [ char ]) ]].	^answer asSymbol</body></methods><methods><class-id>Core.CompositeLocale</class-id> <category>converting</category><body package="Protocols-Common">asHttpLanguageTag	^ self languageAndTerritory asLowercase replaceAll: $_ with: $-</body></methods><methods><class-id>Core.ByteArray class</class-id> <category>instance creation</category><body package="Protocols-Common">fromBase64String: b64String"Convert a string containing a MIME base-64 encoded byte sequence into a ByteArray	ByteArray fromBase64String: 'AQIDBAUGBw=='"	^(b64String withEncoding: 'Base64') readStream contents</body></methods><methods><class-id>Core.ByteArray class</class-id> <category>encryption</category><body package="Protocols-Common">fromHexString: aString"(((self fromHexString: 'A00B0210FF00')))"	| lookup byteArray readStream |	lookup := #(0 1 2 3 4 5 6 7 8 9 nil nil nil nil nil nil nil 10 11 12 13 14 15 nil nil nil nil nil nil 		nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 10 11 12 13 14 15 nil).	byteArray := self new: aString size // 2.	readStream := aString readStream.	1 to: byteArray size do: [ :i || highChar lowChar |		highChar := readStream next.		highChar := lookup at: (highChar asInteger - 47).		lowChar := readStream next.		lowChar := lookup at: (lowChar asInteger - 47).		byteArray at: i put: ((highChar bitShift: 4) bitOr: lowChar) ].	^byteArray</body></methods><methods><class-id>Core.ByteArray</class-id> <category>converting</category><body package="Protocols-Common">asBase64String"Convert the receiver into a String using the MIME base-64 encoding.	#[1 2 3 4 5] asBase64String"	^((String new: self size) withEncoding: 'Base64') writeStream		nextPutAll: self;		close;		encodedContents</body></methods><methods><class-id>Core.ByteArray</class-id> <category>security</category><body package="Protocols-Common">asFormattedHexStrings"(((#[160 11 2 16 255 0] asFormattedHexStrings)))"		^ self asHexStringChunks: 1</body><body package="Protocols-Common">asHexString"(((#[160 11 2 16 255 0] asHexString)))"		^ self asHexStringChunks: 0</body><body package="Protocols-Common">asHexStringChunks: chunkSize"	(#[160 11 2 16 255 0] asHexStringChunks: 0)	(#[160 11 2 16 255 0] asHexStringChunks: 1)	((ByteArray withAll: (0 to: 255)) asHexStringChunks: 2)	((ByteArray withAll: (0 to: 255)) asHexStringChunks: 4)	((ByteArray withAll: (0 to: 255)) asHexStringChunks: 8)"	| lookup s ws chunk |	lookup := '0123456789ABCDEF'.	chunk := chunkSize isZero		ifTrue: [self size + 1]		ifFalse: [chunkSize].	s := String new: (self size * 2) + (self size // chunk).	ws := s writeStream.		self keysAndValuesDo: [ :index :b |		ws nextPut: (lookup at: (b bitShift: -4) + 1).		ws nextPut: (lookup at: (b bitAnd: 15) + 1).		chunkSize isZero ifFalse: [			(index \\ chunkSize) isZero ifTrue: [ws space ] ] ].	^ ws contents</body></methods><methods><class-id>Core.Process</class-id> <category>opentalk</category><body package="Protocols-Common">isSuspended	"Copied from Opentalk-Core-Support. May be moved to Kernel?"	^self suspendingList isNil</body></methods><methods><class-id>Core.EncodedStream</class-id> <category>status</category><body package="Protocols-Common">finish	encoder prepareToClose: stream.	stream finish</body></methods><methods><class-id>OS.MacOSXSocketAccessor class</class-id> <category>opentalk</category><body package="Protocols-Common">otReuseAddress: aBoolean for: aSocket	aSocket soReuseport: aBoolean</body></methods><methods><class-id>Core.Exception</class-id> <category>accessing</category><body package="Protocols-Common">clearForReraise"This is to get the exception instance ready for transport to the client side and reraise it in the calling thread.  The method 'copyForReraise' doesn't seem to be good enough to support user defined exception parameters.  Moreover, it seems to make sense to make the exception nonresumable, when raised in the client thread."	messageText := self description.	initialContext := nil.	firstUnwindContext := nil.	handlerContext := nil.	proceedBlock := nil.	isResumable := false.	signal := nil.	searchContext := nil</body></methods><methods><class-id>Core.Exception</class-id> <category>opentalk</category><body package="Protocols-Common">nestedStackTraceOn: aStream indentedTo: level	aStream 		tab: level; nextPutAll: (#TraceDescription &lt;&lt; #opentalk &gt;&gt; 'Description: ') asString;		nextPutAll: self description; cr;		tab: level; nextPutAll: (#TraceParameter &lt;&lt; #opentalk &gt;&gt; 'Parameter: ') asString.	parameter isSignalledException		ifTrue: [ aStream nextPutAll: (#TraceInnerException &lt;&lt; #opentalk &gt;&gt; 'INNER EXCEPTION') asString; cr.			parameter nestedStackTraceOn: aStream indentedTo: level + 1 ]		ifFalse: [ aStream print: parameter; cr ].	initialContext notNil ifTrue: [		aStream tab: level; nextPutAll: (#TraceStack &lt;&lt; #opentalk &gt;&gt; 'Stack: ') asString; cr.		(initialContext sendersTo: nil) do: [ :ctx |			aStream tab: level; nextPutAll: ctx printString; cr ] ]</body></methods><methods><class-id>Core.Exception</class-id> <category>accessing</category><body package="Protocols-Common">stackTraceOn: aStream indentedTo: level	aStream 		tab: level; nextPutAll: (#TraceDescription &lt;&lt; #protocols &gt;&gt; 'Description: ') asString;		nextPutAll: self description; cr;		tab: level; nextPutAll: (#TraceParameter &lt;&lt; #protocols &gt;&gt; 'Parameter: ') asString.	parameter isSignalledException		ifTrue: [ aStream nextPutAll: (#TraceInnerException &lt;&lt; #protocols &gt;&gt; 'INNER EXCEPTION') asString; cr.			parameter nestedStackTraceOn: aStream indentedTo: level + 1 ]		ifFalse: [ aStream print: parameter; cr ].	initialContext notNil ifTrue: [		aStream tab: level; nextPutAll: (#TraceStack &lt;&lt; #protocols &gt;&gt; 'Stack: ') asString; cr.		(initialContext sendersTo: nil) do: [ :ctx |			aStream tab: level; nextPutAll: ctx printString; cr ] ]</body></methods><methods><class-id>Kernel.BlockClosure</class-id> <category>scheduling</category><body package="Protocols-Common">timedPromiseFor: aMillisecondClockDuration	"Answer a TimedPromise that represents the result of evaluating the receiver.  See class Promise for more information."	| prom |	prom := Protocols.TimedPromise forMilliseconds: aMillisecondClockDuration.	( self promiseBlock: prom ) fork.	^prom</body><body package="Protocols-Common">timedPromiseFor: aMillisecondClockDuration at: aPriority	"Answer a TimedPromise that represents the result of evaluating the receiver at the given priority  See class Promise for more information."	| prom |	prom := Protocols.TimedPromise forMilliseconds: aMillisecondClockDuration.	( self promiseBlock: prom ) forkAt: aPriority.	^prom</body></methods><methods><class-id>Core.StreamEncoder</class-id> <category>querying</category><body package="Protocols-Common">checkAtEnd"This is called by DecodedStream at the end of the underlying stream and is meant to check that the encoding of the last bytes was complete, that there isn't anything left over unfinished."		^true</body></methods><methods><class-id>OS.SocketAccessor class</class-id> <category>private-socket options</category><body package="Protocols-Common">_soReuseport	"Socket option constant allowing local port reuse."	^16r200</body></methods><methods><class-id>OS.SocketAccessor class</class-id> <category>opentalk</category><body package="Protocols-Common">otReuseAddress: aBoolean for: aSocket	aSocket soReuseaddr: aBoolean</body></methods><methods><class-id>OS.SocketAccessor class</class-id> <category>constants-socket options</category><body package="Protocols-Common">SO_REUSEPORT	"Socket option constant allowing local port reuse."	^self defaultClass _soReuseport</body></methods><methods><class-id>OS.SocketAccessor</class-id> <category>opentalk</category><body package="Protocols-Common">otReuseAddress: aBoolean	self defaultClass otReuseAddress: aBoolean for: self</body></methods><methods><class-id>OS.SocketAccessor</class-id> <category>options</category><body package="Protocols-Common">soReuseport: aBoolean 	"... allows or prohibits the use of the same port for	multiple broadcast groups or adaptors.  But note	that not all casting implementations support this."	^self setOptionsLevel: SocketAccessor SOL_SOCKET		name: SocketAccessor SO_REUSEPORT		value: (aBoolean  ifTrue: [1] ifFalse: [0])</body></methods><methods><class-id>Core.Stream</class-id> <category>status</category><body package="Protocols-Common">finish</body></methods><methods><class-id>Core.Stream</class-id> <category>computed streaming</category><body package="Protocols-Common">readCache: size"Create a cached stream wrapping the receiver.	size &lt;Integer&gt; desired size of the cache, in number of cached elements"	^Protocols.CachedReadStream wrap: self cache: size</body><body package="Protocols-Common">writeCache: size"Create a cached stream wrapping the receiver.	size &lt;Integer&gt; desired size of the cache, in number of cached elements"	^Protocols.CachedWriteStream wrap: self cache: size</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>converting</category><body package="Protocols-Common">withEncoding: encoding	^Protocols.DecodedStreamConstructor		on: self		encoding: encoding</body></methods><methods><class-id>OS.AIXSocketAccessor class</class-id> <category>opentalk</category><body package="Protocols-Common">otReuseAddress: aBoolean for: aSocket	aSocket soReuseport: aBoolean</body></methods><initialize><class-id>Base64FastCoder</class-id></initialize><initialize><class-id>Protocols.Base64StreamEncoder</class-id></initialize><initialize><class-id>Protocols.B64StreamDecoder</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>ByteArray</name><environment>Core</environment><super>Core.IntegerArray</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>StreamEncoder</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>encoder errorPolicy skipRecord </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>Exception</name><environment>Core</environment><super>Core.GenericException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>SocketAccessor</name><environment>OS</environment><super>OS.BlockableIOAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>networkFamily </inst-vars><class-inst-vars>concreteClass </class-inst-vars><imports></imports><category>OS-Sockets</category><attributes><package>OS-Sockets</package></attributes></class><class><name>Process</name><environment>Core</environment><super>Core.Link</super><private>false</private><indexed-type>none</indexed-type><inst-vars>suspendedContext priority myList systemRecords interruptProtect environment isSystem name debugger locale </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Processes</category><attributes><package>Kernel-Processes</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>Stream</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private IOConstants.*			</imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>PeekableStream</name><environment>Core</environment><super>Core.Stream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>EncodedStream</name><environment>Core</environment><super>Core.PeekableStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>binary stream encoder policy lineEndConvention lineEndCharacter skipSize </inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.IOConstants.*			</imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>Promise</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sync value hasValue exception </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Processes</category><attributes><package>Kernel-Processes</package></attributes></class><class><name>CharacterArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>BlockClosure</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method outerContext copiedValues </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>CompositeLocale</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>localizationComponent encodingComponent </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Internationalization</package></attributes></class><class><name>EvaluableAction</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Dependency Events</category><attributes><package>System-Dependency Events</package></attributes></class><class><name>UninterpretedBytes</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>InternalEncodedStreamConstructor</name><environment>Core</environment><super>Core.EncodedStreamConstructor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class></st-source>