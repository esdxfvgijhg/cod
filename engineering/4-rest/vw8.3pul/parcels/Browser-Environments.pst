<?xml version="1.0"?><st-source><!-- Name: Browser-EnvironmentsNotice: Copyright 1999-2016 Cincom Systems, Inc.  All rights reserved.Portions © 1998-2002 The Refactory, IncComment: This package contains the environments for the browser. A browser environment determines what a user of the browser can and cannot see within that browser. For example, an environment for implementers of X can only see the X methods.DbIdentifier: bear73DbTrace: 491977DbUsername: kgreekDbVersion: 8.2 - 2DevelopmentPrerequisites: #(#(#any 'Browser-Namespace' ''))PackageName: Browser-EnvironmentsParcel: #('Browser-Environments')ParcelName: Browser-EnvironmentsPrerequisiteParcels: #(#('Browser-Namespace' ''))PrintStringCache: (8.2 - 2,kgreek)Version: 8.2 - 2Date: 3:26:53 PM June 30, 2017 --><time-stamp>From VisualWorks®, Pre-Release 8.3 (jun17.4) of June 23, 2017 on June 30, 2017 at 3:26:53 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>AbstractBrowserEnvironment</name><environment>Refactory.Browser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>label generalSearchStrings specificSearchStrings </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Browser-Environments</package></attributes></class><comment><class-id>Refactory.Browser.AbstractBrowserEnvironment</class-id><body>I represent the classes/methods that are to be browsed.DO NOT EXTEND THIS CLASS UNLESS THE BEHAVIOR IS COMPATIBLE WITH ALL SUBCLASS IMPLEMENTATIONS.This abstract superclass is the common parent to the RB and Store browser sibling implementations.  This strategy helps insulate the Store browsers from what should be RB-only behavior.Instance Variables	label	&lt;String&gt;	a description of what we're looking at	generalSearchStrings 	&lt;Collection of: String&gt;	strings to look for whenever we select a method	specificSearchStrings	&lt;Dictionary key: class-&gt;selector value: &lt;Collection of: String&gt;&gt;										strings to look for whenever we select the method given as key</body></comment><class><name>BrowserEnvironment</name><environment>Refactory.Browser</environment><super>Refactory.Browser.AbstractBrowserEnvironment</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Environments</category><attributes><package>Browser-Environments</package></attributes></class><comment><class-id>Refactory.Browser.BrowserEnvironment</class-id><body>I represent the classes/methods in the system browser. Not only is this the superclass of all standard system environments, it also represents browsing everything.</body></comment><class><name>BrowserEnvironmentWrapper</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserEnvironment</super><private>false</private><indexed-type>none</indexed-type><inst-vars>environment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Environments</category><attributes><package>Browser-Environments</package></attributes></class><comment><class-id>Refactory.Browser.BrowserEnvironmentWrapper</class-id><body>BrowserEnvironmentWrapper is a wrapper for BrowserEnvironments that limits what is shown. While it does not have any #subclassResponsibility methods, it is an abstract class since it doesn't provide any useful behavior by itselfInstance Variables:	environment	&lt;BrowserEnvironment&gt;	the environment we're wrapping</body></comment><class><name>ClassEnvironment</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserEnvironmentWrapper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>instanceBehaviorNames classBehaviorNames </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Environments</category><attributes><package>Browser-Environments</package></attributes></class><comment><class-id>Refactory.Browser.ClassEnvironment</class-id><body>ClassEnvironment represents a collection of classes to be browsed.Instance Variables:	instanceBehaviorNames	&lt;Collection of: Symbol&gt;	the class names (not metaclasses)	classBehaviorNames	&lt;Collection of: Symbol&gt;	the class names for the metaclasses that are selected</body></comment><class><name>RBInitializerDefinition</name><environment>Refactory.Browser</environment><super>Tools.InitializerDefinition</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Support</category><attributes><package>Browser-Environments</package></attributes></class><comment><class-id>Refactory.Browser.RBInitializerDefinition</class-id><body>RBInitializerDefinition is an InitializerDefinition with a special displayString.</body></comment><class><name>PundleEnvironment</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserEnvironmentWrapper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bundleNames packageNames </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Environments</category><attributes><package>Browser-Environments</package></attributes></class><comment><class-id>Refactory.Browser.PundleEnvironment</class-id><body>PundleEnvironment represents all of the classes and methods in a set of bundles and packages.Instance Variables:	bundleNames	&lt;(SequenceableCollection of: String)&gt;	Bundles represented by this environment.	packageNames	&lt;(Collection of: String)&gt;	Packages represented by this environment.</body></comment><class><name>NotEnvironment</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserEnvironmentWrapper</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Environments</category><attributes><package>Browser-Environments</package></attributes></class><comment><class-id>Refactory.Browser.NotEnvironment</class-id><body>NotEnvironment represents the complement of its environment. It contains all of the methods and classes in the image that are NOT in its environment.</body></comment><class><name>AndEnvironment</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserEnvironmentWrapper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>andedEnvironment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Environments</category><attributes><package>Browser-Environments</package></attributes></class><comment><class-id>Refactory.Browser.AndEnvironment</class-id><body>AndEnvironment represents an environment that contains all of the classes in methods that occur in its environment AND andedEnvironment.Instance Variables:	andedEnvironment	&lt;BrowserEnvironmentWrapper&gt;	The environment to AND with.</body></comment><class><name>ProtocolEnvironment</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserEnvironmentWrapper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>targetClass protocols </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Environments</category><attributes><package>Browser-Environments</package></attributes></class><comment><class-id>Refactory.Browser.ProtocolEnvironment</class-id><body>ProtocolEnvironment represents a collection of protocols in a class to be browsed.Instance Variables:	targetClass	&lt;Behavior&gt;	the class that contains the protocols	protocols	&lt;Collection of: Symbol&gt;	the protocols to be browsed</body></comment><class><name>VariableEnvironment</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserEnvironmentWrapper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>instanceVariables instanceVariableReaders instanceVariableWriters selectorCache </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Environments</category><attributes><package>Browser-Environments</package></attributes></class><comment><class-id>Refactory.Browser.VariableEnvironment</class-id><body>VariableEnvironment represents a set of classes and methods that refer to a set of instance variables.Instance Variables:	instanceVariables	&lt;Dictionary key: String value: (Set of: String)&gt;	Keys are the classes, values are the variables whose references are in this environment.	instanceVariableReaders	&lt;Dictionary key: String value: (Set of: String)&gt;	Keys are the classes, values are the selectors that read these instance variables.	instanceVariableWriters	&lt;Dictionary key: String value: (Set of: String)&gt;	Keys are the classes, values are the selectors that write to these instance variables.	selectorCache	&lt;Dictionary key: String value: (Set of: String)&gt;	Keys are the classes, values are the selectors that refer to these instance variables.</body></comment><class><name>OrEnvironment</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserEnvironmentWrapper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>orEnvironment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Environments</category><attributes><package>Browser-Environments</package></attributes></class><comment><class-id>Refactory.Browser.OrEnvironment</class-id><body>OrEnvironment represents an environment that contains all of the classes in methods that occur in its environment OR orEnvironment.Instance Variables:	orEnvironment	&lt;BrowserEnvironmentWrapper&gt;	The environment to OR with.</body></comment><class><name>SelectorEnvironment</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserEnvironmentWrapper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classSelectors metaClassSelectors initializers </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Environments</category><attributes><package>Browser-Environments</package></attributes></class><comment><class-id>Refactory.Browser.SelectorEnvironment</class-id><body>SelectorEnvironment represents a collection of methods to be browsed.Instance Variables:	classSelectors	&lt;Dictionary key: Symbol value: (Collection of: Symbol)&gt;	selectors for the class side	initializers	&lt;Collection&gt;	the binding references of all shared variable initializers in our environment	metaClassSelectors	&lt;Dictionary key: Symbol value: (Collection of: Symbol)&gt;	selectors for the metaclass side</body></comment><class><name>MethodDefinitionEnvironment</name><environment>Refactory.Browser</environment><super>Refactory.Browser.SelectorEnvironment</super><private>false</private><indexed-type>none</indexed-type><inst-vars>definitions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Environments</category><attributes><package>Browser-Environments</package></attributes></class><comment><class-id>Refactory.Browser.MethodDefinitionEnvironment</class-id><body>MethodDefinitionEnvironment provided compatibility with the previous browsers so that the extra text of a method definition can be displayed.Instance Variables:	definitions	&lt;OrderedCollection of: GeneralMethodDefinition&gt;	all the method definitions</body></comment><methods><class-id>Refactory.Browser.AbstractBrowserEnvironment</class-id> <category>private</category><body package="Browser-Environments">classEnvironmentClass	^ClassEnvironment</body><body package="Browser-Environments">defaultLabel	^''</body><body package="Browser-Environments">label	^label isNil ifTrue: [self defaultLabel] ifFalse: [label]</body><body package="Browser-Environments">selectorEnvironmentClass	^SelectorEnvironment</body></methods><methods><class-id>Refactory.Browser.AbstractBrowserEnvironment</class-id> <category>printing</category><body package="Browser-Environments">printOn: aStream	aStream nextPutAll: self label</body><body package="Browser-Environments">storeOn: aStream 	aStream		nextPutAll: self class fullName;		nextPutAll: ' new'</body></methods><methods><class-id>Refactory.Browser.AbstractBrowserEnvironment</class-id> <category>environments</category><body package="Browser-Environments">&amp; anEnvironment 	"If we or anEnvironment includes everything, then return it instead of creating an AND that will include everything."	self isSystem ifTrue: [^anEnvironment].	anEnvironment isSystem ifTrue: [^self].	^AndEnvironment onEnvironment: self and: anEnvironment</body><body package="Browser-Environments">forClass: aClass protocols: protocolCollection 	^self protocolEnvironmentClass		onEnvironment: self		class: aClass		protocols: protocolCollection</body><body package="Browser-Environments">forClassHierarchy: aClass	| classHierarchy |	classHierarchy := Set withAll: aClass withAllSuperclasses.	classHierarchy addAll: aClass class withAllSuperclasses.	classHierarchy addAll: aClass allSubclasses.	classHierarchy addAll: aClass class allSubclasses.	^self forClasses: classHierarchy</body><body package="Browser-Environments">forClasses: classCollection 	^self classEnvironmentClass onEnvironment: self classes: classCollection</body><body package="Browser-Environments">forCodeComponents: aCollection	^self pundleEnvironmentClass onEnvironment: self codeComponents: aCollection</body><body package="Browser-Environments">forPundles: pundleList 	"old terminology - backward compatibility"	^self forCodeComponents: pundleList</body><body package="Browser-Environments">implementorsMatching: aString 	^self selectorEnvironmentClass implementorsMatching: aString in: self</body><body package="Browser-Environments">implementorsOf: aSelector 	^self selectorEnvironmentClass implementorsOf: aSelector in: self</body><body package="Browser-Environments">matches: aString 	^self selectorEnvironmentClass matches: aString in: self</body><body package="Browser-Environments">not	self isSystem ifTrue: [^self selectorEnvironmentClass new].	^NotEnvironment onEnvironment: self</body><body package="Browser-Environments">protocolEnvironmentClass	^ProtocolEnvironment</body><body package="Browser-Environments">pundleEnvironmentClass	^PundleEnvironment</body><body package="Browser-Environments">selectMethods: aBlock 	| env |	env := self selectorEnvironmentClass onEnvironment: self.	self classesAndSelectorsDo: 			[:each :sel | 			(aBlock value: (each compiledMethodAt: sel)) 				ifTrue: [env addClass: each selector: sel]].	^env</body><body package="Browser-Environments">sourceCodeMatching: aString 	^self selectMethods: 			[:each | 			| source |			source := each getSource.			source notNil and: [aString match: source]]</body><body package="Browser-Environments">| anEnvironment	"If we or anEnvironment includes everything, then return it instead of creating an OR that will include everything."		self isSystem ifTrue: [^self].	anEnvironment isSystem ifTrue: [^anEnvironment].	^OrEnvironment onEnvironment: self or: anEnvironment</body></methods><methods><class-id>Refactory.Browser.AbstractBrowserEnvironment</class-id> <category>accessing-classes</category><body package="Browser-Environments">allClassesDo: aBlock 	Root allBehaviorsDo: aBlock</body><body package="Browser-Environments">classForName: aString	"Map the name to the class (or namespace - the object is not necessarily a class, despite this method's name) in the image.  Override in specialised subclass environments that use the RB machinery to browse code not in the image, e.g. in a Store repository, remote image or whatever."	^(aString asStrictReference home: nil) bindingOrNil value</body><body package="Browser-Environments">classNames	| names |	names := Set new.	self classesDo: [:each | names add: each instanceBehavior fullRootName].	^names</body><body package="Browser-Environments">classesDo: aBlock 	self 		allClassesDo: [:each | (self includesClass: each) ifTrue: [aBlock value: each]]</body><body package="Browser-Environments">nameSpaceObjectNames	| names |	names := Set new.	Root withAllNameSpacesDo: 			[:each | 			each bindingsDo: 					[:binding | 					(self includesBinding: binding in: each) 						ifTrue: 							[names add: (binding isForGeneral 										ifTrue: [each fullRootName]										ifFalse: [binding value fullRootName])]]].	^names</body><body package="Browser-Environments">nameSpacesDo: aBlock 	Root withAllNameSpacesDo: 			[:each | 			(self includesNameSpace: each) ifTrue: [aBlock value: each]]</body></methods><methods><class-id>Refactory.Browser.AbstractBrowserEnvironment</class-id> <category>accessing</category><body package="Browser-Environments">addSearchString: aString 	generalSearchStrings isNil 		ifTrue: 			[generalSearchStrings := SortedCollection sortBlock: 							[:a :b | 							(a indexOf: $: ifAbsent: [a size]) &gt; (b indexOf: $: ifAbsent: [b size])]].	generalSearchStrings add: aString</body><body package="Browser-Environments">addSearchString: aString forClass: cls selector:  m 	specificSearchStrings isNil 		ifTrue: 			[specificSearchStrings := Dictionary new].	(specificSearchStrings at: cls-&gt;m ifAbsentPut: [OrderedCollection new]) add: aString</body><body package="Browser-Environments">bindingReferencesDo: aBlock 	Root withAllNameSpacesDo: 			[:ns | 			| ref |			ref := ns fullyQualifiedReference.			ns bindingsDo: 					[:each | 					(self includesBinding: each in: ns) 						ifTrue: [aBlock value: (ref append: each key)]]].	Root allBehaviorsDo: 			[:cls | 			cls isMeta 				ifFalse: 					[cls asNameSpace bindingsDo: 							[:each | 							(self includesBinding: each in: cls) 								ifTrue: 									[| ref |									ref := cls fullyQualifiedReference.									aBlock value: (ref append: each key)]]]]</body><body package="Browser-Environments">bundlesAndPackagesDo: aBlock	self		bundlesDo: aBlock;		packagesDo: aBlock</body><body package="Browser-Environments">bundlesDo: aBlock	Store.Registry bundlesDo: aBlock</body><body package="Browser-Environments">classesAndSelectorsDo: aBlock 	self classesDo: 			[:class | 			self selectorsForClass: class do: [:sel | aBlock value: class value: sel]]</body><body package="Browser-Environments">methodDefinitions	| defs |	defs := OrderedCollection new.	self classesAndSelectorsDo: 			[:class :selector | 			defs add: (MethodDefinition class: class selector: selector)].	self sharedVariableReferencesDo: 			[:each | 			defs 				add: (InitializerDefinition nameSpace: each environment key: each name)].	^defs</body><body package="Browser-Environments">methodsDo: aBlock 	self 		classesAndSelectorsDo: [:class :selector | aBlock value: (class compiledMethodAt: selector)]</body><body package="Browser-Environments">numberClasses	^self classNames size</body><body package="Browser-Environments">numberSelectors	| total |	total := 0.	self 		allClassesDo: [:each | self selectorsForClass: each do: [:sel | total := total + 1]].	^total</body><body package="Browser-Environments">packagesDo: aBlock	Store.Registry packagesDo: aBlock</body><body package="Browser-Environments">protocolsFor: aClass 	^aClass organization categories 		select: [:each | self includesProtocol: each in: aClass]</body><body package="Browser-Environments">searchStrings: aCollection 	generalSearchStrings := aCollection</body><body package="Browser-Environments">searchStringsForClass: cls selector: m	| specific |	(specificSearchStrings notNil and: [specificSearchStrings includesKey: cls -&gt; m])		ifTrue: [specific := specificSearchStrings at: cls -&gt; m]		ifFalse: [specific := #()].	generalSearchStrings isNil ifTrue: [^specific].	^specific, generalSearchStrings</body><body package="Browser-Environments">selectionIntervalFor: aString inMethod: selector class: class	| interval |	(self searchStringsForClass: class selector: selector) isEmpty ifTrue: [^nil].	interval := self selectionParseTreeIntervalFor: aString inMethod: selector class: class.	interval notNil ifTrue: [^interval].	(self searchStringsForClass: class selector: selector) do: 			[:each | 			| search index |			search := each isSymbol ifTrue: [each keywords first] ifFalse: [each].			index := aString indexOfSubCollection: search startingAt: 1.			index &gt; 0 ifTrue: [^index to: index + search size - 1]].	^nil</body><body package="Browser-Environments">selectionParseTreeIntervalFor: aString inMethod: selector class: class 	| parseTree answerBlock |	parseTree := RBParser parseMethod: aString onError: [:str :pos | ^nil].	answerBlock := [:aNode :answer | ^aNode sourceInterval].	(self searchStringsForClass: class selector: selector) do: 			[:each | 			| matcher tree |			matcher := ParseTreeSearcher new.			matcher matchesTree: (RBLiteralNode value: each) do: answerBlock.			each isSymbol 				ifTrue: 					[tree := ParseTreeSearcher buildSelectorTree: each.					tree notNil ifTrue: [matcher matchesTree: tree do: answerBlock]]				ifFalse: 					[each notEmpty 						ifTrue: 							[tree := RBVariableNode named: each.							matcher								matchesTree: tree do: answerBlock;								matchesArgumentTree: tree do: answerBlock]].			matcher executeTree: parseTree].	^nil</body><body package="Browser-Environments">selectorsFor: aProtocol in: aClass	^(aClass organization listAtCategoryNamed: aProtocol)		select: [:each | self includesSelector: each in: aClass]</body><body package="Browser-Environments">selectorsForClass: aClass 	| selectors |	selectors := Set new: 50.	self selectorsForClass: aClass do: [:each | selectors add: each].	^selectors</body><body package="Browser-Environments">selectorsForClass: aClass do: aBlock 	aClass selectorsAndMethodsDo: 			[:each :meth | 			(self includesSelector: each in: aClass) ifTrue: [aBlock value: each]]</body><body package="Browser-Environments">sharedVariableProtocolsFor: aClass 	^aClass asNameSpace organization sharedVariableCategories 		select: [:each | self includesDataProtocol: each in: aClass]</body><body package="Browser-Environments">sharedVariableReferencesDo: aBlock 	self bindingReferencesDo: 			[:each | 			| binding |			binding := each bindingOrNil.			(binding notNil and: [binding isForGeneral]) ifTrue: [aBlock value: each]]</body><body package="Browser-Environments">sharedVariablesFor: aProtocol in: aClassOrNameSpace 	^(aClassOrNameSpace asNameSpace organization 		listAtCategoryNamed: aProtocol) select: 				[:each | 				| binding |				binding := aClassOrNameSpace bindingFor: each.				binding isForGeneral 					and: [self includesBinding: binding in: aClassOrNameSpace]]</body><body package="Browser-Environments">sharedVariablesForClass: aClass 	| vars |	vars := Set new.	aClass asNameSpace bindingsDo: 			[:each | 			(each isForGeneral and: [self includesBinding: each in: aClass]) 				ifTrue: [vars add: each key]].	^vars</body><body package="Browser-Environments">whichProtocolIncludes: aSelector in: aClass	^aClass organization categoryOfElement: aSelector</body><body package="Browser-Environments">whichProtocolIncludesVariable: aSymbol in: aClass 	^aClass asNameSpace organization categoryOfElement: aSymbol</body></methods><methods><class-id>Refactory.Browser.AbstractBrowserEnvironment</class-id> <category>comparing</category><body package="Browser-Environments">= anEnvironment		^self otherAttributesToCompare , self instVarsToCompare		allSatisfy:			[:each | (self perform: each) = (anEnvironment perform: each)]</body><body package="Browser-Environments">attributesToCompare		^self otherAttributesToCompare, self instVarsToCompare</body><body package="Browser-Environments">hash		^(self otherAttributesToCompare , self instVarsToCompare) hash</body><body package="Browser-Environments">instVarsNotToCompare		^#(#label)</body><body package="Browser-Environments">instVarsToCompare		^(self class allInstVarNames collect: [:each | each asSymbol])		select:			[:each | 			(self respondsTo: each)				and: [(self instVarsNotToCompare includes: each) not]]</body><body package="Browser-Environments">otherAttributesToCompare		^#(#class)</body></methods><methods><class-id>Refactory.Browser.AbstractBrowserEnvironment</class-id> <category>initialize-release</category><body package="Browser-Environments">label: aString	label := aString</body></methods><methods><class-id>Refactory.Browser.AbstractBrowserEnvironment</class-id> <category>testing</category><body package="Browser-Environments">includesBinding: aBinding in: aNameSpace 	^true</body><body package="Browser-Environments">includesClass: aClass	^true</body><body package="Browser-Environments">includesDataProtocol: aProtocol in: aClass	^true</body><body package="Browser-Environments">includesNameSpace: aNameSpace 	^true</body><body package="Browser-Environments">includesProtocol: aProtocol in: aClass	^true</body><body package="Browser-Environments">includesSelector: aSelector in: aClass	^true</body><body package="Browser-Environments">isClassContainer	^self isSystem</body><body package="Browser-Environments">isClassEnvironment	^false</body><body package="Browser-Environments">isEmpty	^false</body><body package="Browser-Environments">isSelector	^false</body><body package="Browser-Environments">isSystem	^true</body><body package="Browser-Environments">notEmpty	^self isEmpty not</body></methods><methods><class-id>Refactory.Browser.AbstractBrowserEnvironment</class-id> <category>copying</category><body package="Browser-Environments">copyEmpty	^self class new</body></methods><methods><class-id>Refactory.Browser.AbstractBrowserEnvironment class</class-id> <category>instance creation</category><body package="Browser-Environments">new	^(super new)		initialize;		yourself</body></methods><methods><class-id>Refactory.Browser.BrowserEnvironment</class-id> <category>environments</category><body package="Browser-Environments">forClass: aClass selectors: selectorCollection 	^(self selectorEnvironmentClass 		onMethods: selectorCollection		forClass: aClass		in: self)		label: aClass fullName , '&gt;&gt;' 					, (selectorCollection detect: [:each | true] ifNone: ['']);		yourself</body><body package="Browser-Environments">instVarReadersTo: instVarName in: aClass 	^VariableEnvironment 		on: self		readersOfInstanceVariable: instVarName		in: aClass</body><body package="Browser-Environments">instVarRefsTo: instVarName in: aClass 	^VariableEnvironment 		on: self		referencesToInstanceVariable: instVarName		in: aClass</body><body package="Browser-Environments">instVarWritersTo: instVarName in: aClass 	^VariableEnvironment 		on: self		writersOfInstanceVariable: instVarName		in: aClass</body><body package="Browser-Environments">referencesTo: aLiteral 	^self selectorEnvironmentClass referencesTo: aLiteral in: self</body><body package="Browser-Environments">referencesTo: aLiteral in: aClass	^(self forClassHierarchy: aClass) referencesTo: aLiteral</body></methods><methods><class-id>Refactory.Browser.BrowserEnvironment</class-id> <category>accessing-classes</category><body package="Browser-Environments">classes	| classes |	classes := Set new.	self classesDo: [:each | classes add: each].	^classes</body></methods><methods><class-id>Refactory.Browser.BrowserEnvironment</class-id> <category>accessing</category><body package="Browser-Environments">bindingsFor: aCategoryName in: aNameSpace 	| bindings |	bindings := OrderedCollection new.	(aNameSpace organization listAtCategoryNamed: aCategoryName) do: 			[:each | 			| binding |			binding := aNameSpace bindingFor: each.			(binding notNil and: [self includesBinding: binding in: aNameSpace]) 				ifTrue: [bindings add: binding]].	^bindings</body><body package="Browser-Environments">instanceVariablesFor: aClass 	^aClass instVarNames</body></methods><methods><class-id>Refactory.Browser.BrowserEnvironment</class-id> <category>testing</category><body package="Browser-Environments">definesClass: aClass	^true</body></methods><methods><class-id>Refactory.Browser.BrowserEnvironment</class-id> <category>initialize-release</category><body package="Browser-Environments">initialize</body></methods><methods><class-id>Refactory.Browser.BrowserEnvironmentWrapper</class-id> <category>private</category><body package="Browser-Environments">environment	^environment</body></methods><methods><class-id>Refactory.Browser.BrowserEnvironmentWrapper</class-id> <category>testing</category><body package="Browser-Environments">definesClass: aClass 	^environment definesClass: aClass</body><body package="Browser-Environments">includesBinding: aBinding in: aNameSpace 	^environment includesBinding: aBinding in: aNameSpace</body><body package="Browser-Environments">includesClass: aClass	^environment includesClass: aClass</body><body package="Browser-Environments">includesDataProtocol: aProtocol in: aClass 	^(aClass isBehavior not or: [self includesClass: aClass]) 		and: [environment includesDataProtocol: aProtocol in: aClass]</body><body package="Browser-Environments">includesNameSpace: aNameSpace 	^environment includesNameSpace: aNameSpace</body><body package="Browser-Environments">includesProtocol: aProtocol in: aClass	^(self includesClass: aClass)		and: [environment includesProtocol: aProtocol in: aClass]</body><body package="Browser-Environments">includesSelector: aSelector in: aClass	^(self includesClass: aClass)		and: [environment includesSelector: aSelector in: aClass]</body><body package="Browser-Environments">isEmpty	self classesDo: [:each | ^false].	^true</body><body package="Browser-Environments">isSystem	^false</body></methods><methods><class-id>Refactory.Browser.BrowserEnvironmentWrapper</class-id> <category>initialize-release</category><body package="Browser-Environments">onEnvironment: anEnvironment	environment := anEnvironment</body></methods><methods><class-id>Refactory.Browser.BrowserEnvironmentWrapper</class-id> <category>printing</category><body package="Browser-Environments">storeOn: aStream 	aStream		nextPutAll: '(';		nextPutAll: self class fullName;		nextPutAll: ' onEnvironment: '.	environment storeOn: aStream.	aStream nextPut: $)</body></methods><methods><class-id>Refactory.Browser.BrowserEnvironmentWrapper class</class-id> <category>instance creation</category><body package="Browser-Environments">new	^self onEnvironment: BrowserEnvironment new</body><body package="Browser-Environments">onEnvironment: anEnvironment 	^(self basicNew)		initialize;		onEnvironment: anEnvironment;		yourself</body></methods><methods><class-id>Refactory.Browser.ClassEnvironment</class-id> <category>initialize-release</category><body package="Browser-Environments">classes: aCollection 	aCollection do: [:each | self addClass: each]</body><body package="Browser-Environments">initialize	super initialize.	instanceBehaviorNames := Set new.	classBehaviorNames := Set new</body></methods><methods><class-id>Refactory.Browser.ClassEnvironment</class-id> <category>testing</category><body package="Browser-Environments">includesBinding: aBinding in: aNameSpace 	^(super includesBinding: aBinding in: aNameSpace) and: 			[aBinding isForClass and: 					[(self includesClass: aBinding value) 						or: [self includesClass: aBinding value class]]]</body><body package="Browser-Environments">includesClass: aClass 	^(aClass isMeta		ifTrue: [classBehaviorNames includes: aClass soleInstance fullRootName]		ifFalse: [instanceBehaviorNames includes: aClass fullRootName])			and: [super includesClass: aClass]</body><body package="Browser-Environments">includesNameSpace: aNameSpace 	^false</body><body package="Browser-Environments">isClassEnvironment	^true</body><body package="Browser-Environments">isEmpty	^instanceBehaviorNames isEmpty and: [classBehaviorNames isEmpty]</body></methods><methods><class-id>Refactory.Browser.ClassEnvironment</class-id> <category>copying</category><body package="Browser-Environments">postCopy	instanceBehaviorNames := instanceBehaviorNames copy.	classBehaviorNames := classBehaviorNames copy.	^super postCopy</body></methods><methods><class-id>Refactory.Browser.ClassEnvironment</class-id> <category>private</category><body package="Browser-Environments">defaultLabel	| stream |	stream := String new writeStream.	instanceBehaviorNames do: 			[:each | 			stream				nextPutAll: each;				nextPut: $ ].	^stream contents</body></methods><methods><class-id>Refactory.Browser.ClassEnvironment</class-id> <category>accessing-classes</category><body package="Browser-Environments">classNames	^(Set withAll: instanceBehaviorNames)		addAll: classBehaviorNames;		yourself</body><body package="Browser-Environments">classesDo: aBlock 	instanceBehaviorNames do: 			[:each | 			| class |			class := each asQualifiedReference value.			(class notNil and: [environment includesClass: class]) 				ifTrue: [aBlock value: class]].	classBehaviorNames do: 			[:each | 			| class |			class := each asQualifiedReference value.			(class notNil and: [environment includesClass: class class]) 				ifTrue: [aBlock value: class class]]</body><body package="Browser-Environments">instanceBehaviorNames		^instanceBehaviorNames</body></methods><methods><class-id>Refactory.Browser.ClassEnvironment</class-id> <category>printing</category><body package="Browser-Environments">storeOn: aStream 	aStream nextPut: $(.	super storeOn: aStream.	aStream nextPutAll: ' classes: (('.	instanceBehaviorNames asArray storeOn: aStream.	aStream 		nextPutAll: ' inject: OrderedCollection new into: [:sum :each | 				| class |				class := (BindingReference pathString: each) valueOrDo: [nil].				class notNil ifTrue: [sum add: class].				sum]) , ('.	classBehaviorNames asArray storeOn: aStream.	aStream 		nextPutAll: ' inject: OrderedCollection new into: [:sum :each | 				| class |				class := (BindingReference pathString: each) valueOrDo: [nil].				class notNil ifTrue: [sum add: class class].				sum])))'</body></methods><methods><class-id>Refactory.Browser.ClassEnvironment</class-id> <category>adding</category><body package="Browser-Environments">addClass: aClass 	aClass isMeta		ifTrue: [classBehaviorNames add: aClass soleInstance fullRootName]		ifFalse: [instanceBehaviorNames add: aClass fullRootName]</body></methods><methods><class-id>Refactory.Browser.ClassEnvironment</class-id> <category>removing</category><body package="Browser-Environments">removeClass: aClass 	aClass isMeta		ifTrue: [classBehaviorNames remove: aClass soleInstance fullRootName ifAbsent: []]		ifFalse: [instanceBehaviorNames remove: aClass fullRootName ifAbsent: []]</body></methods><methods><class-id>Refactory.Browser.ClassEnvironment</class-id> <category>accessing</category><body package="Browser-Environments">classBehaviorNames		^classBehaviorNames</body></methods><methods><class-id>Refactory.Browser.ClassEnvironment class</class-id> <category>instance creation</category><body package="Browser-Environments">onEnvironment: anEnvironment classes: aCollection 	^(self onEnvironment: anEnvironment)		classes: aCollection;		yourself</body></methods><methods><class-id>Refactory.Browser.RBInitializerDefinition</class-id> <category>printing</category><body package="Browser-Environments">displayString	^self variableName asString</body></methods><methods><class-id>Refactory.Browser.RBInitializerDefinition</class-id> <category>private</category><body package="Browser-Environments">species	^InitializerDefinition</body></methods><methods><class-id>Refactory.Browser.PundleEnvironment</class-id> <category>accessing-classes</category><body package="Browser-Environments">classesDo: aBlock 	| classes block |	classes := Set new: 100.	block := 		[:each | 		| class |		class := each actual.		class notNil ifTrue: 			[(classes includes: class) ifFalse: 				[classes add: class.				aBlock value: class]]].	self packagesDo: 		[:each | 		each classesDefinedInPackage do: block.		each classesExtendedInPackage do: block.		each metaclassesDefinedInPackage do: block.		each metaclassesExtendedInPackage do: block]</body></methods><methods><class-id>Refactory.Browser.PundleEnvironment</class-id> <category>copying</category><body package="Browser-Environments">postCopy	super postCopy.	bundleNames := bundleNames copy.	packageNames := packageNames copy</body></methods><methods><class-id>Refactory.Browser.PundleEnvironment</class-id> <category>initialize-release</category><body package="Browser-Environments">bundleNames: bundleCollection packageNames: packageCollection 	bundleNames := bundleCollection.	packageNames := packageCollection</body><body package="Browser-Environments">pundles: aCollection 	bundleNames := OrderedCollection new.	packageNames := OrderedCollection new.	aCollection do: 			[:each | 			(each isPackage ifTrue: [packageNames] ifFalse: [bundleNames]) 				add: each name]</body></methods><methods><class-id>Refactory.Browser.PundleEnvironment</class-id> <category>printing</category><body package="Browser-Environments">storeOn: aStream 	aStream nextPut: $(.	super storeOn: aStream.	aStream nextPutAll: ' bundleNames: '.	bundleNames asArray storeOn: aStream.	aStream nextPutAll: ' packageNames: '.	packageNames asArray storeOn: aStream.	aStream nextPut: $)</body></methods><methods><class-id>Refactory.Browser.PundleEnvironment</class-id> <category>testing</category><body package="Browser-Environments">definesClass: aBehavior	^self anyPackageSatisfies: [:each | each definesClass: aBehavior]</body><body package="Browser-Environments">includesBinding: aBinding in: aNameSpace		(super includesBinding: aBinding in: aNameSpace) ifFalse: 		[^false].	aBinding isForClass ifTrue: 		[^(self includesClass: aBinding value) or: [self includesClass: aBinding value class]].	aBinding isForNameSpace ifTrue: 		[^self includesNameSpace: aBinding value].	^self anyPackageSatisfies:		[:each | 		each			definesName: aBinding key			in: aNameSpace]</body><body package="Browser-Environments">includesClass: aClass	(super includesClass: aClass) ifFalse: [^false].	^self anyPackageSatisfies: [:each | (each definesClass: aClass) or: [each extendsClass: aClass]]</body><body package="Browser-Environments">includesNameSpace: aNameSpace	^self anyPackageSatisfies: [:each | each definesClassOrNameSpace: aNameSpace]</body><body package="Browser-Environments">includesProtocol: aProtocol in: aClass 	^(super includesProtocol: aProtocol in: aClass) and: 			[(environment selectorsFor: aProtocol in: aClass) 				anySatisfy: [:aSelector | self includesSelector: aSelector in: aClass]]</body><body package="Browser-Environments">includesSelector: aSelector in: aClass	^(environment includesSelector: aSelector in: aClass) and: 		[self anyPackageSatisfies: [:each | each definesSelector: aSelector forClass: aClass]]</body><body package="Browser-Environments">isClassContainer	^true</body></methods><methods><class-id>Refactory.Browser.PundleEnvironment</class-id> <category>accessing</category><body package="Browser-Environments">anyPackageSatisfies: aBlock	self packagesDo: [:each | (aBlock value: each) ifTrue: [^true]].	^false</body><body package="Browser-Environments">bindingReferencesDo: aBlock	| traversed enumerationBlock |	traversed := Set new.	enumerationBlock :=			[:reference |			(traversed includes: reference)				ifFalse: 					[traversed add: reference.					aBlock value: reference]].	self packagesDo: 			[:eachPackage |			eachPackage definedClassesDo: 					[:eachClass |					(environment includesClass: eachClass)						ifTrue: 							[enumerationBlock value: eachClass fullyQualifiedReference makeUnambiguous]].			eachPackage extendedClasses do: 					[:eachClass |					(environment includesClass: eachClass)						ifTrue: 							[enumerationBlock value: eachClass fullyQualifiedReference makeUnambiguous]].			eachPackage definedNameSpaces do: 					[:eachNamespace |					(environment includesNameSpace: eachNamespace)						ifTrue: 							[enumerationBlock								value: eachNamespace fullyQualifiedReference makeUnambiguous]].			eachPackage actualDefinedBindings do: 					[:eachShareBinding |					(environment includesBinding: eachShareBinding						in: eachShareBinding environment)							ifTrue: [enumerationBlock value: eachShareBinding makeUnambiguous]]]</body><body package="Browser-Environments">bundleNames		^bundleNames</body><body package="Browser-Environments">bundlesDo: aBlock	| visited |	visited := IdentitySet new.	self bundlesFrom: self pundles		do: 			[:each |			(visited includes: each)				ifFalse: 					[visited add: each.					aBlock value: each]]</body><body package="Browser-Environments">bundlesFrom: somePundles do: aBlock	somePundles do: 			[:each |			each isBundle				ifTrue: 					[aBlock value: each.					self bundlesFrom: each containedItems do: aBlock]]</body><body package="Browser-Environments">numberSelectors	"do not use PackageModel methods method, it includes overriden methods"	| count |	count := 0.	self packagesDo: [:each | each classModelsDo: [:eachClassModel | count := count + eachClassModel methods size]].	^count</body><body package="Browser-Environments">packageNames		^packageNames</body><body package="Browser-Environments">packages	| packages |	packages := OrderedCollection new.	self packagesDo: [:each | packages add: each].	^packages</body><body package="Browser-Environments">packagesDo: aBlock	| visited |	visited := IdentitySet new.	self packagesFrom: self pundles		do: 			[:each |			(visited includes: each)				ifFalse: 					[visited add: each.					aBlock value: each]]</body><body package="Browser-Environments">packagesFrom: somePundles do: aBlock		somePundles do:		[:each | 		each isBundle			ifTrue: [self packagesFrom: each containedItems do: aBlock]			ifFalse: [aBlock value: each]]</body><body package="Browser-Environments">pundles	| pundles |	pundles := OrderedCollection new: packageNames size + bundleNames size.	bundleNames do: 			[:each | 			| bundle |			bundle := Store.Registry bundleNamed: each.			bundle notNil ifTrue: [pundles add: bundle]].	packageNames do: 			[:each | 			| package |			package := Store.Registry packageNamed: each.			package notNil ifTrue: [pundles add: package]].	^pundles</body><body package="Browser-Environments">selectorsForClass: aClass do: aBlock		self packagesDo:		[:eachPackage | 		(eachPackage definedSelectorsFor: aClass) do: 			[:eachSelector | 			((aClass includesSelector: eachSelector) and: [environment includesSelector: eachSelector in: aClass]) ifTrue: [aBlock value: eachSelector]]]</body><body package="Browser-Environments">sharedVariableReferencesDo: aBlock		| sharedVariableReferences |	sharedVariableReferences := Set new.	self packagesDo:		[:eachPackage | 		eachPackage data do: 			[:eachSharedVariableReference | 			sharedVariableReferences add: eachSharedVariableReference fullName asQualifiedReference]].	sharedVariableReferences do: [:each | each isDefined ifTrue: [aBlock value: each]]</body></methods><methods><class-id>Refactory.Browser.PundleEnvironment class</class-id> <category>instance creation</category><body package="Browser-Environments">onEnvironment: aBrowserEnvironment bundleNames: bundleCollection packageNames: packageCollection 	^(self onEnvironment: aBrowserEnvironment)		bundleNames: bundleCollection packageNames: packageCollection;		yourself</body><body package="Browser-Environments">onEnvironment: aBrowserEnvironment codeComponents: aCollection 	^(self onEnvironment: aBrowserEnvironment)		pundles: aCollection;		yourself</body></methods><methods><class-id>Refactory.Browser.NotEnvironment</class-id> <category>testing</category><body package="Browser-Environments">includesBinding: aBinding in: aNameSpace 	^aBinding isForClass 		ifTrue: 			[(self includesClass: aBinding value) 				or: [self includesClass: aBinding value class]]		ifFalse: [(super includesBinding: aBinding in: aNameSpace) not]</body><body package="Browser-Environments">includesClass: aClass 	(environment includesClass: aClass) ifFalse: [^true].	aClass selectorsAndMethodsDo: 			[:each :meth | 			(environment includesSelector: each in: aClass) ifFalse: [^true]].	^false</body><body package="Browser-Environments">includesNameSpace: aNameSpace 	^(environment includesNameSpace: aNameSpace) not</body><body package="Browser-Environments">includesProtocol: aProtocol in: aClass 	^(self selectorsFor: aProtocol in: aClass) notEmpty</body><body package="Browser-Environments">includesSelector: aSelector in: aClass	^(environment includesSelector: aSelector in: aClass) not</body></methods><methods><class-id>Refactory.Browser.NotEnvironment</class-id> <category>environments</category><body package="Browser-Environments">not	^environment</body></methods><methods><class-id>Refactory.Browser.NotEnvironment</class-id> <category>printing</category><body package="Browser-Environments">storeOn: aStream	environment storeOn: aStream.	aStream nextPutAll: ' not'</body></methods><methods><class-id>Refactory.Browser.AndEnvironment</class-id> <category>private</category><body package="Browser-Environments">andedEnvironment	^andedEnvironment</body></methods><methods><class-id>Refactory.Browser.AndEnvironment</class-id> <category>initialize-release</category><body package="Browser-Environments">andedEnvironment: aBrowserEnvironment 	andedEnvironment := aBrowserEnvironment</body></methods><methods><class-id>Refactory.Browser.AndEnvironment</class-id> <category>accessing</category><body package="Browser-Environments">classesDo: aBlock 	environment 		classesDo: [:each | (self includesClass: each) ifTrue: [aBlock value: each]]</body><body package="Browser-Environments">numberSelectors	| total |	total := 0.	environment classesAndSelectorsDo: 			[:each :sel | 			(andedEnvironment includesSelector: sel in: each) 				ifTrue: [total := total + 1]].	^total</body><body package="Browser-Environments">selectionIntervalFor: aString inMethod: selector class: cls	| interval |	interval := super selectionIntervalFor: aString inMethod: selector class: cls.	interval notNil ifTrue: [^interval].	^andedEnvironment selectionIntervalFor: aString inMethod: selector class: cls</body><body package="Browser-Environments">selectorsForClass: aClass do: aBlock 	environment selectorsForClass: aClass		do: 			[:each | 			(andedEnvironment includesSelector: each in: aClass) 				ifTrue: [aBlock value: each]]</body></methods><methods><class-id>Refactory.Browser.AndEnvironment</class-id> <category>testing</category><body package="Browser-Environments">includesBinding: aBinding in: aNameSpace 	^aBinding isForClass 		ifTrue: 			[(self includesClass: aBinding value) 				or: [self includesClass: aBinding value class]]		ifFalse: 			[(super includesBinding: aBinding in: aNameSpace) 				and: [andedEnvironment includesBinding: aBinding in: aNameSpace]]</body><body package="Browser-Environments">includesClass: aClass 	| doesntHaveSelectors |	(environment includesClass: aClass) ifFalse: [^false].	(andedEnvironment includesClass: aClass) ifFalse: [^false].	doesntHaveSelectors := true.	environment selectorsForClass: aClass		do: 			[:each | 			doesntHaveSelectors := false.			(andedEnvironment includesSelector: each in: aClass) ifTrue: [^true]].	^doesntHaveSelectors</body><body package="Browser-Environments">includesNameSpace: aNameSpace 	^(super includesNameSpace: aNameSpace) 		and: [andedEnvironment includesNameSpace: aNameSpace]</body><body package="Browser-Environments">includesProtocol: aProtocol in: aClass 	^(self selectorsFor: aProtocol in: aClass) notEmpty</body><body package="Browser-Environments">includesSelector: aSelector in: aClass 	^(environment includesSelector: aSelector in: aClass) 		and: [andedEnvironment includesSelector: aSelector in: aClass]</body></methods><methods><class-id>Refactory.Browser.AndEnvironment</class-id> <category>printing</category><body package="Browser-Environments">storeOn: aStream 	aStream nextPut: $(.	environment storeOn: aStream.	aStream nextPutAll: ' &amp; '.	andedEnvironment storeOn: aStream.	aStream nextPut: $)</body></methods><methods><class-id>Refactory.Browser.AndEnvironment class</class-id> <category>instance creation</category><body package="Browser-Environments">onEnvironment: anEnvironment and: anotherEnvironment 	^(self onEnvironment: anEnvironment)		andedEnvironment: anotherEnvironment;		yourself</body></methods><methods><class-id>Refactory.Browser.ProtocolEnvironment</class-id> <category>initialize-release</category><body package="Browser-Environments">class: aClass protocols: aCollection	targetClass := aClass.	protocols := aCollection</body></methods><methods><class-id>Refactory.Browser.ProtocolEnvironment</class-id> <category>private</category><body package="Browser-Environments">defaultLabel	| stream |	stream := String new writeStream.	stream		nextPutAll: targetClass fullName;		nextPut: $&gt;.	protocols do: 			[:each | 			stream				nextPutAll: each;				nextPut: $ ].	^stream contents</body></methods><methods><class-id>Refactory.Browser.ProtocolEnvironment</class-id> <category>testing</category><body package="Browser-Environments">includesBinding: aBinding in: aNameSpace 	^(super includesBinding: aBinding in: aNameSpace) and: 			[(aBinding isForClass and: 					[(self includesClass: aBinding value) 						or: [self includesClass: aBinding value class]]) 				or: 					[aNameSpace = targetClass 						and: [aBinding isForGeneral and: [protocols includes: aBinding category]]]]</body><body package="Browser-Environments">includesClass: aClass	^aClass == targetClass and: [super includesClass: aClass]</body><body package="Browser-Environments">includesNameSpace: aNameSpace 	^false</body><body package="Browser-Environments">includesProtocol: aProtocol in: aClass 	^aClass == targetClass and: 			[(super includesProtocol: aProtocol in: aClass) 				and: [protocols includes: aProtocol]]</body><body package="Browser-Environments">includesSelector: aSelector in: aClass 	^(super includesSelector: aSelector in: aClass) and: 			[protocols 				includes: (environment whichProtocolIncludes: aSelector in: aClass)]</body><body package="Browser-Environments">isEmpty	^protocols isEmpty</body></methods><methods><class-id>Refactory.Browser.ProtocolEnvironment</class-id> <category>copying</category><body package="Browser-Environments">postCopy	protocols := protocols copy.	^super postCopy</body></methods><methods><class-id>Refactory.Browser.ProtocolEnvironment</class-id> <category>printing</category><body package="Browser-Environments">storeOn: aStream 	aStream nextPut: $(.	super storeOn: aStream.	aStream		nextPutAll: ' class: ';		nextPutAll: targetClass fullRootName;		nextPutAll: ' protocols: '.	protocols asArray storeOn: aStream.	aStream nextPut: $)</body></methods><methods><class-id>Refactory.Browser.ProtocolEnvironment class</class-id> <category>instance creation</category><body package="Browser-Environments">onEnvironment: anEnvironment class: aClass protocols: aCollection 	^(self onEnvironment: anEnvironment)		class: aClass protocols: aCollection;		yourself</body></methods><methods><class-id>Refactory.Browser.VariableEnvironment</class-id> <category>private</category><body package="Browser-Environments">accessorMethods	^#(#instanceVariables #instanceVariableReaders #instanceVariableWriters)</body><body package="Browser-Environments">allClassesDo: aBlock 	| classes instVarBlock |	classes := Set new.	instVarBlock := 			[:each | 			| class |			class := self classForName: each.			classes				addAll: class allSuperclasses;				addAll: class withAllSubclasses].	instanceVariables keysDo: instVarBlock.	instanceVariableReaders keysDo: instVarBlock.	instanceVariableWriters keysDo: instVarBlock.	classes do: aBlock</body><body package="Browser-Environments">computeSelectorCacheFor: aClass 	^self instanceVariableSelectorsFor: aClass</body><body package="Browser-Environments">flushCachesFor: aClass 	| nonMetaClass |	selectorCache isNil ifTrue: [^self].	nonMetaClass := aClass instanceBehavior.	nonMetaClass withAllSubclasses do: 			[:each | 			selectorCache				removeKey: each ifAbsent: [];				removeKey: each class ifAbsent: []]</body><body package="Browser-Environments">instanceVariableReaders	^instanceVariableReaders</body><body package="Browser-Environments">instanceVariableReaders: anObject	instanceVariableReaders := anObject</body><body package="Browser-Environments">instanceVariableSelectorsFor: aClass 	| selectors |	selectors := Set new.	#(#instanceVariables #instanceVariableReaders #instanceVariableWriters) 		with: #(#whichSelectorsAccess: #whichSelectorsRead: #whichSelectorsAssign:)		do: 			[:var :sel | 			| instVars |			instVars := Set new.			(self perform: var) keysDo: 					[:each | 					| cls |					cls := self classForName: each.					(cls notNil 						and: [(aClass includesBehavior: cls) or: [cls includesBehavior: aClass]]) 							ifTrue: [instVars addAll: ((self perform: var) at: each)]].			instVars do: [:each | selectors addAll: (aClass perform: sel with: each)]].	^selectors</body><body package="Browser-Environments">instanceVariableWriters	^instanceVariableWriters</body><body package="Browser-Environments">instanceVariableWriters: anObject	instanceVariableWriters := anObject</body><body package="Browser-Environments">instanceVariables	^instanceVariables</body><body package="Browser-Environments">instanceVariables: anObject	instanceVariables := anObject</body><body package="Browser-Environments">selectorCache	^selectorCache isNil 		ifTrue: [selectorCache := Dictionary new]		ifFalse: [selectorCache]</body><body package="Browser-Environments">selectorCacheFor: aClass 	^self selectorCache at: aClass		ifAbsentPut: [self computeSelectorCacheFor: aClass]</body></methods><methods><class-id>Refactory.Browser.VariableEnvironment</class-id> <category>accessing</category><body package="Browser-Environments">addClass: aClass instanceVariable: aString 	(instanceVariables at: aClass fullRootName ifAbsentPut: [Set new]) 		add: aString.	self flushCachesFor: aClass.	self addSearchString: aString</body><body package="Browser-Environments">addClass: aClass instanceVariableReader: aString 	(instanceVariableReaders at: aClass fullRootName ifAbsentPut: [Set new]) 		add: aString.	self flushCachesFor: aClass.	self addSearchString: aString</body><body package="Browser-Environments">addClass: aClass instanceVariableWriter: aString 	(instanceVariableWriters at: aClass fullRootName ifAbsentPut: [Set new]) 		add: aString.	self flushCachesFor: aClass.	self addSearchString: aString</body><body package="Browser-Environments">classNamesWithVariables	| classNames |	classNames := Set new.	classNames		addAll: instanceVariables keys;		addAll: instanceVariableReaders keys;		addAll: instanceVariableWriters keys.	^classNames</body><body package="Browser-Environments">environmentForInstanceVariable: aString in: aClass 	| selectorEnvironment isReader isWriter |	selectorEnvironment := SelectorEnvironment onEnvironment: self.	selectorEnvironment addSearchString: aString.	isReader := isWriter := false.	((instanceVariables at: aClass fullRootName ifAbsent: [#()]) includes: aString) 		ifTrue: 			[isReader := true.			isWriter := true].	((instanceVariableWriters at: aClass fullRootName ifAbsent: [#()]) 		includes: aString) ifTrue: [isWriter := true].	((instanceVariableReaders at: aClass fullRootName ifAbsent: [#()]) 		includes: aString) ifTrue: [isReader := true].	aClass allSuperclasses , aClass withAllSubclasses do: 			[:each | 			isWriter 				ifTrue: 					[(each whichSelectorsAssign: aString) 						do: [:sel | selectorEnvironment addClass: each selector: sel]].			isReader 				ifTrue: 					[(each whichSelectorsRead: aString) 						do: [:sel | selectorEnvironment addClass: each selector: sel]]].	^selectorEnvironment</body><body package="Browser-Environments">instanceVariablesFor: aClass 	| vars name |	vars := Set new.	name := aClass fullRootName.	vars		addAll: (instanceVariables at: name ifAbsent: [#()]);		addAll: (instanceVariableReaders at: name ifAbsent: [#()]);		addAll: (instanceVariableWriters at: name ifAbsent: [#()]).	^vars</body><body package="Browser-Environments">numberVariables	^self accessorMethods inject: 0		into: [:sum :each | sum + ((self perform: each) inject: 0 into: [:s :e | s + e size])]</body><body package="Browser-Environments">removeClass: aClass instanceVariable: aString 	| vars |	vars := instanceVariables at: aClass fullRootName ifAbsent: [Set new].	vars remove: aString ifAbsent: [].	vars isEmpty 		ifTrue: [instanceVariables removeKey: aClass fullRootName ifAbsent: []].	self flushCachesFor: aClass</body><body package="Browser-Environments">removeClass: aClass instanceVariableReader: aString 	| vars |	vars := instanceVariableReaders at: aClass fullRootName ifAbsent: [Set new].	vars remove: aString ifAbsent: [].	vars isEmpty 		ifTrue: [instanceVariableReaders removeKey: aClass fullRootName ifAbsent: []].	self flushCachesFor: aClass</body><body package="Browser-Environments">removeClass: aClass instanceVariableWriter: aString 	| vars |	vars := instanceVariableWriters at: aClass fullRootName ifAbsent: [Set new].	vars remove: aString ifAbsent: [].	vars isEmpty 		ifTrue: [instanceVariableWriters removeKey: aClass fullRootName ifAbsent: []].	self flushCachesFor: aClass</body></methods><methods><class-id>Refactory.Browser.VariableEnvironment</class-id> <category>copying</category><body package="Browser-Environments">copyDictionary: aDictionary 	| copy |	copy := Dictionary new: aDictionary size.	aDictionary keysAndValuesDo: [:key :value | copy at: key put: value].	^copy</body><body package="Browser-Environments">postCopy	super postCopy.	instanceVariables := self copyDictionary: instanceVariables.	instanceVariableReaders := self copyDictionary: instanceVariableReaders.	instanceVariableWriters := self copyDictionary: instanceVariableWriters.	selectorCache := nil</body></methods><methods><class-id>Refactory.Browser.VariableEnvironment</class-id> <category>testing</category><body package="Browser-Environments">includesBinding: aBinding in: aNameSpace 	^(super includesBinding: aBinding in: aNameSpace) and: 			[aBinding isForClass and: 					[(self includesClass: aBinding value) 						or: [self includesClass: aBinding value class]]]</body><body package="Browser-Environments">includesClass: aClass 	(super includesClass: aClass) ifFalse: [^false].	(instanceVariables includesKey: aClass name) ifTrue: [^true].	^(self selectorCacheFor: aClass) 		anySatisfy: [:each | self includesSelector: each in: aClass]</body><body package="Browser-Environments">includesProtocol: aProtocol in: aClass 	^(self selectorsFor: aProtocol in: aClass) notEmpty</body><body package="Browser-Environments">includesSelector: aSymbol in: aClass 	^(environment includesSelector: aSymbol in: aClass) 		and: [(self selectorCacheFor: aClass) includes: aSymbol]</body><body package="Browser-Environments">isEmpty	^self accessorMethods allSatisfy: [:each | (self perform: each) isEmpty]</body></methods><methods><class-id>Refactory.Browser.VariableEnvironment</class-id> <category>initialize-release</category><body package="Browser-Environments">initialize	super initialize.	instanceVariables := Dictionary new.	instanceVariableReaders := Dictionary new.	instanceVariableWriters := Dictionary new</body></methods><methods><class-id>Refactory.Browser.VariableEnvironment</class-id> <category>printing</category><body package="Browser-Environments">storeOn: aStream 	aStream		nextPut: $(;		nextPutAll: self class fullRootName;		nextPutAll: ' new '.	self accessorMethods do: 			[:each | 			aStream				nextPutAll: each;				nextPutAll: ': '.			(self perform: each) storeOn: aStream.			aStream nextPutAll: '; '].	aStream nextPutAll: ' yourself)'</body></methods><methods><class-id>Refactory.Browser.VariableEnvironment</class-id> <category>accessing-classes</category><body package="Browser-Environments">classForName: aString 	| name isMeta class |	isMeta := aString includes: $ .	name := (isMeta 				ifTrue: [aString copyFrom: 1 to: (aString size - 6 max: 1)]				ifFalse: [aString]) asSymbol.	class := name asQualifiedReference valueOrDo: [nil].	^class notNil &amp; isMeta ifTrue: [class class] ifFalse: [class]</body></methods><methods><class-id>Refactory.Browser.VariableEnvironment class</class-id> <category>instance creation</category><body package="Browser-Environments">on: anEnvironment readersOfInstanceVariable: aString in: aClass 	^(self onEnvironment: anEnvironment)		label: ((#ReadersOf1sIn2s &lt;&lt; #browser &gt;&gt; 'Readers of ''&lt;1s&gt;'' in &lt;2s&gt;')			expandMacrosWith: aString			with: aClass fullName);		addClass: aClass instanceVariableReader: aString;		yourself</body><body package="Browser-Environments">on: anEnvironment referencesToInstanceVariable: aString in: aClass 	^(self onEnvironment: anEnvironment)		label: ((#ReferencesTo1sIn2s &lt;&lt; #browser &gt;&gt; 'References to ''&lt;1s&gt;'' in &lt;2s&gt;')			expandMacrosWith: aString			with: aClass fullName);		addClass: aClass instanceVariable: aString;		yourself</body><body package="Browser-Environments">on: anEnvironment writersOfInstanceVariable: aString in: aClass 	^(self onEnvironment: anEnvironment)		label: ((#WritersOf1sIn2s &lt;&lt; #browser &gt;&gt; 'Writers of ''&lt;1s&gt;'' in &lt;2s&gt;')			expandMacrosWith: aString			with: aClass fullName);		addClass: aClass instanceVariableWriter: aString;		yourself</body><body package="Browser-Environments">readersOfInstanceVariable: aString in: aClass 	^self 		on: BrowserEnvironment new		readersOfInstanceVariable: aString		in: aClass</body><body package="Browser-Environments">referencesToInstanceVariable: aString in: aClass 	^self 		on: BrowserEnvironment new		referencesToInstanceVariable: aString		in: aClass</body><body package="Browser-Environments">writersOfInstanceVariable: aString in: aClass 	^self 		on: BrowserEnvironment new		writersOfInstanceVariable: aString		in: aClass</body></methods><methods><class-id>Refactory.Browser.OrEnvironment</class-id> <category>accessing</category><body package="Browser-Environments">classesDo: aBlock		| enumerated |	enumerated := Set new.	environment		classesDo:			[:each | 			aBlock value: each.			enumerated add: each].	orEnvironment		classesDo:			[:each | (enumerated includes: each) ifFalse: [aBlock value: each]]</body><body package="Browser-Environments">numberSelectors		| total |	total := 0.	self		classesDo:			[:eachClass | 			self				selectorsForClass: eachClass				do: [:ignored | total := total + 1]].	^total</body><body package="Browser-Environments">selectionIntervalFor: aString inMethod: selector class: cls		^(environment selectionIntervalFor: aString inMethod: selector class: cls)		ifNil: [orEnvironment selectionIntervalFor: aString inMethod: selector class: cls]</body><body package="Browser-Environments">selectorsForClass: aClass do: aBlock		| enumerated |	enumerated := Set new.	environment		selectorsForClass: aClass		do:			[:each | 			enumerated add: each.			aBlock value: each].	orEnvironment		selectorsForClass: aClass		do: [:each | (enumerated includes: each) ifFalse: [aBlock value: each]]</body></methods><methods><class-id>Refactory.Browser.OrEnvironment</class-id> <category>printing</category><body package="Browser-Environments">storeOn: aStream 	aStream nextPut: $(.	environment storeOn: aStream.	aStream nextPutAll: ' | '.	orEnvironment storeOn: aStream.	aStream nextPut: $)</body></methods><methods><class-id>Refactory.Browser.OrEnvironment</class-id> <category>initialize-release</category><body package="Browser-Environments">orEnvironment: aBrowserEnvironment 	orEnvironment := aBrowserEnvironment</body></methods><methods><class-id>Refactory.Browser.OrEnvironment</class-id> <category>private</category><body package="Browser-Environments">orEnvironment	^orEnvironment</body></methods><methods><class-id>Refactory.Browser.OrEnvironment</class-id> <category>testing</category><body package="Browser-Environments">includesBinding: aBinding in: aNameSpace		^(environment includesBinding: aBinding in: aNameSpace)		or: [orEnvironment includesBinding: aBinding in: aNameSpace]</body><body package="Browser-Environments">includesClass: aClass		(environment includesClass: aClass) ifTrue: [^true].	(orEnvironment includesClass: aClass) ifTrue: [^true].	(environment selectorsForClass: aClass) isEmpty ifFalse: [^true].	(orEnvironment selectorsForClass: aClass) isEmpty ifFalse: [^true].	^false</body><body package="Browser-Environments">includesNameSpace: aNameSpace 	^(environment includesNameSpace: aNameSpace) 		or: [orEnvironment includesNameSpace: aNameSpace]</body><body package="Browser-Environments">includesProtocol: aProtocol in: aClass		^(environment includesProtocol: aProtocol in: aClass)		or: [orEnvironment includesProtocol: aProtocol in: aClass]</body><body package="Browser-Environments">includesSelector: aSelector in: aClass		^(environment includesSelector: aSelector in: aClass)		or: [orEnvironment includesSelector: aSelector in: aClass]</body></methods><methods><class-id>Refactory.Browser.OrEnvironment class</class-id> <category>instance creation</category><body package="Browser-Environments">onEnvironment: anEnvironment or: anotherEnvironment		^(self onEnvironment: anEnvironment)		orEnvironment: anotherEnvironment;		yourself</body></methods><methods><class-id>Refactory.Browser.SelectorEnvironment</class-id> <category>initialize-release</category><body package="Browser-Environments">classSelectors: classSelectorDictionary metaClassSelectors: metaClassSelectorDictionary 	classSelectors := classSelectorDictionary.	metaClassSelectors := metaClassSelectorDictionary</body><body package="Browser-Environments">classes: classArray metaClasses: metaArray 	"Used to recreate an environment from its storeString"	classSelectors := Dictionary new.	metaClassSelectors := Dictionary new.	classArray 		do: [:each | classSelectors at: each first put: each last asSet].	metaArray 		do: [:each | metaClassSelectors at: each first put: each last asSet]</body><body package="Browser-Environments">initialize	super initialize.	classSelectors := Dictionary new.	metaClassSelectors := Dictionary new.	initializers := Set new.</body><body package="Browser-Environments">initializers: initializerCollection 	initializers := initializerCollection</body><body package="Browser-Environments">on: aDict 	aDict keysAndValuesDo: 			[:class :selectors | 			class isMeta 				ifTrue: [metaClassSelectors at: class soleInstance fullRootName put: selectors]				ifFalse: 					[classSelectors at: class fullRootName						put: (selectors select: [:each | each isSymbol])]]</body></methods><methods><class-id>Refactory.Browser.SelectorEnvironment</class-id> <category>accessing-classes</category><body package="Browser-Environments">classNames	| names |	names := Set new: classSelectors size + metaClassSelectors size.	names		addAll: classSelectors keys;		addAll: metaClassSelectors keys.	initializers do: 			[:each | 			| env |			env := each environment.			env isBehavior ifTrue: [names add: each environment fullRootName]].	^names</body><body package="Browser-Environments">classesDo: aBlock 	classSelectors keysDo: 			[:each | 			| class |			class := each asQualifiedReference valueOrDo: [nil].			class notNil 				ifTrue: [(self includesClass: class) ifTrue: [aBlock value: class]]].	metaClassSelectors keysDo: 			[:each | 			| class |			class := each asQualifiedReference valueOrDo: [nil].			class notNil 				ifTrue: 					[(self includesClass: class class) ifTrue: [aBlock value: class class]]]</body><body package="Browser-Environments">nameSpaceObjectNames	| names |	names := Set new.	self classesDo: [:each | names add: each instanceBehavior fullRootName].	initializers do: [:each | names add: each environment fullRootName].	^names</body><body package="Browser-Environments">uniqueMethodDefinitionScope	"Determine if there is a unique class (meta or non meta) OR namespace containing my methods return it, otherwise nil."		| unique |	unique := nil.	self		classesDo:			[:each | 			unique				ifNil: [unique := each instanceBehavior]				ifNotNil: [unique == each instanceBehavior ifFalse: [^nil]]].	initializers		do:			[:each | 			| object |			object := each environment.			unique				ifNil: [unique := object]				ifNotNil: [unique == object ifFalse: [^nil]]].	^unique</body></methods><methods><class-id>Refactory.Browser.SelectorEnvironment</class-id> <category>private</category><body package="Browser-Environments">privateIncludesSelector: aSelector inClass: aClass 	^(self privateSelectorsForClass: aClass) includes: aSelector</body><body package="Browser-Environments">privateSelectorsForClass: aClass 	^aClass isMeta 		ifTrue: [metaClassSelectors at: aClass soleInstance fullRootName ifAbsent: [#()]]		ifFalse: [classSelectors at: aClass fullRootName ifAbsent: [#()]]</body></methods><methods><class-id>Refactory.Browser.SelectorEnvironment</class-id> <category>testing</category><body package="Browser-Environments">hasInitializerForClass: aClass 	^initializers anySatisfy: [:each | each environment = aClass]</body><body package="Browser-Environments">includesBinding: aBinding in: aNameSpace 	(super includesBinding: aBinding in: aNameSpace) ifFalse: [^false].	aBinding isForClass 		ifTrue: 			[^(self includesClass: aBinding value) 				or: [self includesClass: aBinding value class]].	^initializers anySatisfy: [:ref | ref binding = aBinding]</body><body package="Browser-Environments">includesClass: aClass 	^((self privateSelectorsForClass: aClass) notEmpty 		or: [self hasInitializerForClass: aClass]) 			and: [super includesClass: aClass]</body><body package="Browser-Environments">includesNameSpace: aNameSpace 	^initializers anySatisfy: [:each | each environment = aNameSpace]</body><body package="Browser-Environments">includesProtocol: aProtocol in: aClass 	^(super includesProtocol: aProtocol in: aClass) and: 			[(environment selectorsFor: aProtocol in: aClass) 				anySatisfy: [:aSelector | self privateIncludesSelector: aSelector inClass: aClass]]</body><body package="Browser-Environments">includesSelector: aSelector in: aClass 	^(environment includesSelector: aSelector in: aClass)		and: [self privateIncludesSelector: aSelector inClass: aClass]</body><body package="Browser-Environments">isEmpty	^classSelectors isEmpty 		and: [metaClassSelectors isEmpty and: [initializers isEmpty]]</body><body package="Browser-Environments">isSelector	^true</body></methods><methods><class-id>Refactory.Browser.SelectorEnvironment</class-id> <category>accessing</category><body package="Browser-Environments">classSelectors	^classSelectors</body><body package="Browser-Environments">fold: aSelectorEnvironment	"Adopt all of the selectors and intializers found in aSelectorEnvironment into the receiver. When you have two or more SelectorEnvironments, this method of 'or'ing them together is faster than the generic or mechanism."		aSelectorEnvironment metaClassSelectors		keysAndValuesDo:			[:class :selectors | 			(metaClassSelectors				at: class				ifAbsentPut: [Set new]) addAll: selectors].	aSelectorEnvironment classSelectors		keysAndValuesDo:			[:class :selectors | 			(classSelectors				at: class				ifAbsentPut: [Set new]) addAll: selectors].	initializers addAll: aSelectorEnvironment initializers</body><body package="Browser-Environments">initializers	^initializers</body><body package="Browser-Environments">metaClassSelectors	^metaClassSelectors</body><body package="Browser-Environments">numberSelectors	"This doesn't compute the correct result when a method that is included in our method list is not in the	environment we are wrapping. It is implemented this way for efficiency."	^(classSelectors inject: 0 into: [:sum :each | sum + each size]) 		+ (metaClassSelectors inject: 0 into: [:sum :each | sum + each size]) 			"+ initializers size"</body><body package="Browser-Environments">selectorsForClass: aClass do: aBlock 	^(self privateSelectorsForClass: aClass) 		do: [:each | (aClass includesSelector: each) ifTrue: [aBlock value: each]]</body><body package="Browser-Environments">sharedVariableReferencesDo: aBlock 	initializers do: aBlock</body><body package="Browser-Environments">uniquePackage	"Determine if there is a unique package containing my methods and return it, otherwise nil."		| unique |	unique := nil.	self methodDefinitions		do:			[:each | 			each isPatched ifTrue: [^nil].			unique				ifNil: [unique := each package]				ifNotNil: [unique == each package ifFalse: [^nil]]].	^unique</body></methods><methods><class-id>Refactory.Browser.SelectorEnvironment</class-id> <category>copying</category><body package="Browser-Environments">postCopy	| newDict |	newDict := classSelectors copy.	newDict keysAndValuesDo: [:key :value | newDict at: key put: value copy].	classSelectors := newDict.	newDict := metaClassSelectors copy.	newDict keysAndValuesDo: [:key :value | newDict at: key put: value copy].	metaClassSelectors := newDict.	initializers := initializers copy.	^super postCopy</body></methods><methods><class-id>Refactory.Browser.SelectorEnvironment</class-id> <category>removing</category><body package="Browser-Environments">removeClass: aClass 	aClass isMeta 		ifTrue: 			[metaClassSelectors removeKey: aClass soleInstance fullRootName ifAbsent: []]		ifFalse: [classSelectors removeKey: aClass fullRootName ifAbsent: []]</body><body package="Browser-Environments">removeClass: aClass selector: aSelector 	(aClass isMeta 		ifTrue: 			[metaClassSelectors at: aClass soleInstance fullRootName ifAbsent: [^self]]		ifFalse: [classSelectors at: aClass fullRootName ifAbsent: [^self]]) 			remove: aSelector			ifAbsent: []</body><body package="Browser-Environments">removeInitializer: aQualifiedReference 	initializers remove: aQualifiedReference ifAbsent: []</body><body package="Browser-Environments">removeScopes: aCollectionOfObjects	"Remove all selectors which are bound to any of the Objects for compilation scope (Classes and Namespaces)."		aCollectionOfObjects		do:			[:each | 			each isBehavior				ifTrue:					[self						removeClass: each instanceBehavior;						removeClass: each classBehavior].			each asNameSpace dataReferences				do:					[:eachRef | 					initializers						remove: eachRef						ifAbsent: []]]</body></methods><methods><class-id>Refactory.Browser.SelectorEnvironment</class-id> <category>adding</category><body package="Browser-Environments">addClass: aClass 	aClass isMeta 		ifTrue: 			[metaClassSelectors at: aClass soleInstance fullRootName put: aClass selectors]		ifFalse: [classSelectors at: aClass fullRootName put: aClass selectors]</body><body package="Browser-Environments">addClass: aClass selector: aSymbol 	(aClass isMeta 		ifTrue: 			[metaClassSelectors at: aClass soleInstance fullRootName ifAbsentPut: [Set new]]		ifFalse: [classSelectors at: aClass fullRootName ifAbsentPut: [Set new]]) 			add: aSymbol</body><body package="Browser-Environments">addDefinition: aGeneralMethodDefinition 	aGeneralMethodDefinition isForSharedVariable 		ifTrue: 			[self 				addInitializer: aGeneralMethodDefinition fullName asQualifiedReference]		ifFalse: 			[self addClass: aGeneralMethodDefinition implementingClass				selector: aGeneralMethodDefinition selector]</body><body package="Browser-Environments">addInitializer: aQualifiedReference 	initializers add: aQualifiedReference</body></methods><methods><class-id>Refactory.Browser.SelectorEnvironment</class-id> <category>printing</category><body package="Browser-Environments">storeOn: aStream 	| classBlock |	aStream		nextPutAll: '((';		nextPutAll: self class fullRootName;		nextPutAll: ' onEnvironment: '.	environment storeOn: aStream.	aStream		nextPut: $);		nextPutAll: ' classes: #('.	classBlock := 			[:key :value | 			aStream				nextPutAll: '#(';				store: key;				nextPutAll: ' #('.			value do: 					[:each | 					aStream						store: each;						nextPut: $ ].			aStream				nextPutAll: '))';				cr].	classSelectors keysAndValuesDo: classBlock.	aStream nextPutAll: ') metaClasses: #('.	metaClassSelectors keysAndValuesDo: classBlock.	aStream nextPutAll: '))'</body></methods><methods><class-id>Refactory.Browser.SelectorEnvironment class</class-id> <category>instance creation</category><body package="Browser-Environments">implementorsMatching: aString in: anEnvironment 	| classDict metaDict |	classDict := Dictionary new.	metaDict := Dictionary new.	anEnvironment classesDo: 			[:class | 			| selectors |			selectors := Set new.			anEnvironment selectorsForClass: class				do: [:each | (aString match: each) ifTrue: [selectors add: each]].			selectors notEmpty 				ifTrue: 					[class isMeta 						ifTrue: [metaDict at: class soleInstance fullRootName put: selectors]						ifFalse: [classDict at: class fullRootName put: selectors]]].	^(self onEnvironment: anEnvironment)		classSelectors: classDict metaClassSelectors: metaDict;		label: ((#ImplementorsOf1s &lt;&lt; #browser &gt;&gt; 'Implementors of &lt;1s&gt;')			expandMacrosWith: aString);		yourself</body><body package="Browser-Environments">implementorsOf: aSelector in: anEnvironment 	| classDict metaDict selectors |	classDict := Dictionary new.	metaDict := Dictionary new.	selectors := Set with: aSelector.	anEnvironment classesDo: 			[:class | 			((class includesSelector: aSelector) 				and: [anEnvironment includesSelector: aSelector in: class]) 					ifTrue: 						[class isMeta 							ifTrue: [metaDict at: class soleInstance fullRootName put: selectors copy]							ifFalse: [classDict at: class fullRootName put: selectors copy]]].	^(self onEnvironment: anEnvironment)		classSelectors: classDict metaClassSelectors: metaDict;		label: ((#ImplementorsOf1s &lt;&lt; #browser &gt;&gt; 'Implementors of &lt;1s&gt;')			expandMacrosWith: aSelector);		yourself</body><body package="Browser-Environments">matches: aString in: anEnvironment 	| newEnvironment |	newEnvironment := (self onEnvironment: anEnvironment)				label: ((#Matching1s &lt;&lt; #browser &gt;&gt; 'Matching: &lt;1s&gt;')			expandMacrosWith: aString);				searchStrings: (Array with: aString);				yourself.	anEnvironment classesAndSelectorsDo: 			[:each :sel | 			| method |			method := each compiledMethodAt: sel.			method allLiterals do: 					[:lit | 					(self checkLiteral: lit matches: aString) 						ifTrue: [newEnvironment addClass: each selector: sel]]].	^newEnvironment</body><body package="Browser-Environments">onMethods: aMethodDefinitionCollection 	"We have to preserve the extra text in the original method definitions, so we defer to some specialized subclass."	^MethodDefinitionEnvironment onMethods: aMethodDefinitionCollection</body><body package="Browser-Environments">onMethods: selectorCollection forClass: aClass in: anEnvironment 	| env |	env := self onEnvironment: anEnvironment.	selectorCollection do: [:each | env addClass: aClass selector: each].	^env</body><body package="Browser-Environments">referencesTo: aLiteral in: anEnvironment 	| classDict literalPrintString specialIndex variables |	literalPrintString := aLiteral isVariableBinding 				ifTrue: [aLiteral key asString]				ifFalse: 					[aLiteral isString ifTrue: [aLiteral] ifFalse: [aLiteral printString]].	specialIndex := CompiledCode specialSelectorIndexFor: aLiteral.	classDict := Dictionary new.	anEnvironment classesDo: 			[:class | 			| selectors |			selectors := (class whichSelectorsReferTo: aLiteral) 						select: [:aSelector | anEnvironment includesSelector: aSelector in: class].			selectors notEmpty ifTrue: [classDict at: class put: selectors]].	variables := OrderedCollection new.	anEnvironment sharedVariableReferencesDo: 			[:each | 			| binding init method |			binding := each bindingOrNil.			binding notNil 				ifTrue: 					[init := binding initializer.					init notNil 						ifTrue: 							[method := init method.							((method refersToLiteral: aLiteral) or: 									[(specialIndex &gt; 0 and: [method sendsSpecialSelector: specialIndex]) 										or: [method refersToSpecialLiteral: aLiteral]]) 								ifTrue: [variables add: each]]]].	^(self onEnvironment: anEnvironment)		on: classDict;		initializers: variables;		label: ((#ReferencesTo1s &lt;&lt; #browser &gt;&gt; 'References to: &lt;1s&gt;')			expandMacrosWith: literalPrintString);		searchStrings: (Array with: literalPrintString);		yourself</body></methods><methods><class-id>Refactory.Browser.SelectorEnvironment class</class-id> <category>private</category><body package="Browser-Environments">checkLiteral: aLiteral matches: aString 	aLiteral class = Array 		ifTrue: [^aLiteral anySatisfy: [:each | self checkLiteral: each matches: aString]].	^aLiteral isString and: [aString match: aLiteral]</body></methods><methods><class-id>Refactory.Browser.MethodDefinitionEnvironment</class-id> <category>accessing</category><body package="Browser-Environments">definitions	^definitions</body><body package="Browser-Environments">methodDefinitions	definitions removeAllSuchThat: 			[:each | 			each isForSharedVariable 				ifTrue: [each binding isNil]				ifFalse: [each hasMethod not]].	^definitions</body></methods><methods><class-id>Refactory.Browser.MethodDefinitionEnvironment</class-id> <category>initialize-release</category><body package="Browser-Environments">definitions: aMethodDefinitionCollection 	definitions := aMethodDefinitionCollection asOrderedCollection</body><body package="Browser-Environments">initialize	definitions := OrderedCollection new.	super initialize</body></methods><methods><class-id>Refactory.Browser.MethodDefinitionEnvironment</class-id> <category>removing</category><body package="Browser-Environments">removeClass: aClass 	definitions removeAllSuchThat: [:each | each classOrNameSpace = aClass].	super removeClass: aClass</body><body package="Browser-Environments">removeClass: aClass selector: aSelector 	definitions removeAllSuchThat: 			[:each | 			each classOrNameSpace = aClass and: [each selector = aSelector]].	super removeClass: aClass selector: aSelector</body><body package="Browser-Environments">removeInitializer: aQualifiedReference 	definitions removeAllSuchThat: 			[:each | 			each isForSharedVariable and: 					[each classOrNameSpace = aQualifiedReference environment 						and: [each variableName = aQualifiedReference simpleName]]].	super removeInitializer: aQualifiedReference</body></methods><methods><class-id>Refactory.Browser.MethodDefinitionEnvironment</class-id> <category>copying</category><body package="Browser-Environments">postCopy	definitions := definitions copy.	^super postCopy</body></methods><methods><class-id>Refactory.Browser.MethodDefinitionEnvironment</class-id> <category>adding</category><body package="Browser-Environments">addClass: aClass 	aClass selectors do: [:each | self addClass: aClass selector: each].	aClass asNameSpace bindingsDo: 			[:each | 			self addInitializer: (aClass asQualifiedReference append: each key)]</body><body package="Browser-Environments">addClass: aClass selector: aSymbol 	definitions add: (MethodDefinition class: aClass selector: aSymbol).	super addClass: aClass selector: aSymbol</body><body package="Browser-Environments">addDefinition: aGeneralMethodDefinition 	aGeneralMethodDefinition isForSharedVariable 		ifTrue: 			[super 				addInitializer: aGeneralMethodDefinition fullName asQualifiedReference]		ifFalse: 			[super addClass: aGeneralMethodDefinition implementingClass				selector: aGeneralMethodDefinition selector].	definitions add: aGeneralMethodDefinition</body><body package="Browser-Environments">addInitializer: aQualifiedReference 	definitions 		add: (RBInitializerDefinition nameSpace: aQualifiedReference environment				key: aQualifiedReference simpleName).	super addInitializer: aQualifiedReference</body></methods><methods><class-id>Refactory.Browser.MethodDefinitionEnvironment class</class-id> <category>instance creation</category><body package="Browser-Environments">onMethods: aMethodDefinitionCollection 	| env |	env := self new.	aMethodDefinitionCollection do: 			[:each | 			each isBindingReference 				ifTrue: [env addInitializer: each]				ifFalse: [env addDefinition: each]].	^env</body></methods><methods><class-id>Kernel.NameSpaceOrganizer</class-id> <category>categories</category><body package="Browser-Environments">classCategories	| all |	all := Set withAll: emptyCategories.	self environment 		bindingsDo: [:i | i isForGeneral ifFalse: [all add: i category]].	^all</body><body package="Browser-Environments">sharedVariableCategories	| all |	all := Set withAll: emptyCategories.	self environment 		bindingsDo: [:i | i isForGeneral ifTrue: [all add: i category]].	^all</body></methods><methods><class-id>Kernel.GeneralNameSpace</class-id> <category>accessing</category><body package="Browser-Environments">dataReferences	"Return a List of BindingRefs for shared variables"		^self dataBindings		collect: [:each | self fullyQualifiedReferenceOf: each key]</body></methods><methods><class-id>Kernel.NameSpace</class-id> <category>RefactoringBrowser</category><body package="Browser-Environments">fullRootName	| stream |	self environment isNil ifTrue: [^self name].	stream := WriteStream on: (String new: 64).	self fullRootNameInto: stream.	^stream contents</body><body package="Browser-Environments">fullRootNameInto: aStream 	self environment notNil 		ifTrue: 			[self environment fullRootNameInto: aStream.			aStream nextPut: $.].	aStream nextPutAll: self name</body><body package="Browser-Environments">whoDefinesBinding: aBinding 	self withAllNameSpacesDo: 			[:each | 			(each localBindingFor: aBinding key) == aBinding ifTrue: [^each]].	self allBehaviorsDo: 			[:each | 			each isMeta 				ifFalse: [(each localBindingFor: aBinding key) == aBinding ifTrue: [^each]]].	^nil</body></methods><methods><class-id>Store.PackageModel</class-id> <category>accessing</category><body package="Browser-Environments">actualDefinedBindings		| result |	result := OrderedCollection new.	self definedBindings		keysAndValuesDo:			[:eachEnvironment :keyCollection | 			keyCollection				do:					[:eachKey | result add: (eachEnvironment fullyQualifiedReference append: eachKey)]].	^result</body></methods><methods><class-id>Core.Behavior</class-id> <category>RefactoringBrowser</category><body package="Browser-Environments">fullRootName	| stream |	stream := WriteStream on: (String new: 64).	self fullRootNameInto: stream.	^stream contents</body><body package="Browser-Environments">fullRootNameInto: aStream 	self environment fullRootNameInto: aStream.	aStream nextPut: $..	aStream nextPutAll: self name</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>InitializerDefinition</name><environment>Tools</environment><super>Tools.GeneralMethodDefinition</super><private>false</private><indexed-type>none</indexed-type><inst-vars>nameSpace key </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Programming</category><attributes><package>Tools-Programming</package></attributes></class><class><name>Behavior</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>superclass methodDict format subclasses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>GeneralNameSpace</name><environment>Kernel</environment><super>Core.KeyedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>organization bindings specificImports generalImports </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Name Spaces</category><attributes><package>System-Name Spaces</package></attributes></class><class><name>NameSpace</name><environment>Kernel</environment><super>Kernel.GeneralNameSpace</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parent name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Name Spaces</category><attributes><package>System-Name Spaces</package></attributes></class><class><name>NameSpaceOrganizer</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>comment environment emptyCategories </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Name Spaces</category><attributes><package>System-Name Spaces</package></attributes></class><class><name>PackageModel</name><environment>Store</environment><super>Store.PundleModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>models </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class></st-source>