<?xml version="1.0"?><st-source><!-- Name: Browser-TypeInferencerNotice: Copyright 2015-2017 Cincom Systems, Inc.  All rights reserved.Comment: This package contains classes for the refactoring browser's type inferencer.This type inferencer is designed to start from am RBProgramNode built from an RBParser. The program node represents itself as a VirtualType. VirtualTypes represent potential concrete types that can be discovered through known and inferred information from the system itself.Information is typically discovered by looking at instance variable uses, messages sent to nodes and variables and what is returned from a message send. Subclasses of VirtualType represent each of these kinds of virtual information.TypeInterface represents the 'type' of something in the system, which is a union of known types, known objects, known exceptions, constraints and inferred information. All of this is combined together and matched against classes that exist in the system to resolve the type interface to actual classes.Because parsing methods to create RBProgramNode objects can be expensive, TypeSearch and its subclasses are used to discover information by simulating the execution of bytecode with a fake stack.Searching the system can be expensive, so the type inferencer is designed to find a best guess. It always starts with known information, such as classes, literals or message sends. If it can resolve a class from that alone, it will ends its search. If it cannot, it will attempt to infer types by seeking deeper in to the system. This usually means looking at all methods that reference an instance variable, or looking for the return types of all implementors of a particular selector. This can become an expensive search, so the system does not do reverse-discovery, ie: looking at messages that send this message, to determine the types of method arguments; nor does it allow a search to span super-polymorphic message sends, eg: messages like #printOn: or #hash.DbIdentifier: bear73DbTrace: 501593DbUsername: smichaelDbVersion: 8.3 - 1DevelopmentPrerequisites: #(#(#any 'Browser-Parser' ''))PackageName: Browser-TypeInferencerParcel: #('Browser-TypeInferencer')ParcelName: Browser-TypeInferencerPrerequisiteDescriptions: #(#(#name 'Browser-Parser' #componentType #package))PrerequisiteParcels: #(#('Browser-Parser' ''))PrintStringCache: (8.3 - 1,smichael)Version: 8.3 - 1Date: 3:26:56 PM June 30, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (jun17.4) of June 23, 2017 on June 30, 2017 at 3:26:56 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>TypeInferencer</name><environment>Smalltalk</environment><private>false</private><imports>			private Core.*			</imports><category></category><attributes><package>Browser-TypeInferencer</package></attributes></name-space><class><name>VirtualType</name><environment>TypeInferencer</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Browser-TypeInferencer</package></attributes></class><comment><class-id>TypeInferencer.VirtualType</class-id><body>VirtualType represents the potential discovery of real Type or ContainerType information that can be found by adding known or inferred information to a TypeInterface. Each subclass represents a different kind of potential type discovery.The API for a VirtualType is split in to two paths, addKnownInto: and addInferredInto:. Both add what they know to a TypeInterface argument, but addInferredInto: might invoke further system searches to do so, by resolving other VirtualType instances against copies of TypeInterface.Subclasses that can find inferred information must implement #= and #hash and use #inferredTypeOf:ifAbsentPut: to avoid endless recursion when searching for inferred information.Subclasses must implement the following messages:	api		addInferredInto:		addKnownInto:</body></comment><class><name>InstanceVariableType</name><environment>TypeInferencer</environment><super>TypeInferencer.VirtualType</super><private>false</private><indexed-type>none</indexed-type><inst-vars>behavior index </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Browser-TypeInferencer</package></attributes></class><comment><class-id>TypeInferencer.InstanceVariableType</class-id><body>InstanceVariableType is inferred information about an instance variable on a class. Classes from the behavior to the class that defines the instance variable are searched for this classes specialisation of the instance variable type information. All compiled methods in this slice of the class hierarchy that reference the instance variable are searched with the InstanceVariableTypeSearch for known and inferrable information.Instance Variables:	behavior	&lt;Class&gt;	the class to search from	index		&lt;Integer&gt;	the instance variable index to search for</body></comment><class><name>MessageType</name><environment>TypeInferencer</environment><super>TypeInferencer.VirtualType</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector arguments </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Browser-TypeInferencer</package></attributes></class><comment><class-id>TypeInferencer.MessageType</class-id><body>MessageType is inferred information about a message send when no receiver is known. All implementors of selector are searched with the optional arguments for type information.Instance Variables:	arguments	&lt;Array of: VirtualType&gt;	the arguments of the message	selector	&lt;Symbol&gt;				the selector of the message</body></comment><class><name>TypeSearch</name><environment>TypeInferencer</environment><super>Kernel.InstructionClient</super><private>false</private><indexed-type>none</indexed-type><inst-vars>interface input stack initialStack saveStacks block copied messages assignments returns receiverType methodReturns environmentals keyTypes valueTypes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Browser-TypeInferencer</package></attributes></class><comment><class-id>TypeInferencer.TypeSearch</class-id><body>TypeSearch uses an InstructionStream to iterate over the byte codes of a CompiledMethod and simulate that execution of the method to gather up metrics about the potential execution of the method. Information collected includes what is returned by the method, what is assigned to what inside a method, potential key or value types used on potential collection types in a method. Subclasses use this information to search for specific things, such as how an instance variable is used, how a method is used or how the parameter of a block closure is used.Instance Variables:	block			&lt;CompiledCode&gt;	The code being searched	copied		&lt;OrderedCollection&gt;	A part of an instantiating stack to make the CompiledCode a closure	input			&lt;InstructionStream&gt;	The bytecode stream being iterated	interface		&lt;TypeInterface&gt;		The virtual type interface being constructed for and to	stack			&lt;OrderedCollection&gt;	The simulated execution stack	initialStack		&lt;OrderedCollection&gt;	The initial state of the simulted execution stack, usually the method parameters and temporary variables	saveStacks		&lt;Dictionary&gt;		Copies of the stack at specific instruction stream positions to simulate jump instructions	receiverType	&lt;Type&gt;			The type of the receiver, self, used when evaluating block closures	assignments	&lt;Dictionary&gt;		All assignments (keys) and what they are assigned to (values)	environmentals	&lt;Dictionary&gt;		Simulated changes to global variables such as class instance variables or shared variables	messages		&lt;Dictionary&gt;		All message sends (values) to a receiver (keys)	methodReturns	&lt;Collection of: VirtualType&gt;	All method return types	returns		&lt;Collection of: VirtualType&gt;	All returns whether local or method	keyTypes		&lt;Dictionary&gt;		All key types used on a container receiver	valueTypes		&lt;Dictionary&gt;		All value types used on a container receiver</body></comment><class><name>MethodReturnTypeSearch</name><environment>TypeInferencer</environment><super>TypeInferencer.TypeSearch</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Browser-TypeInferencer</package></attributes></class><comment><class-id>TypeInferencer.MethodReturnTypeSearch</class-id><body>MethodReturnTypeSearch searches for return type information from the block. Information is gathered up after a regular type search from the assignments and method returns collections.</body></comment><class><name>NamedVariableType</name><environment>TypeInferencer</environment><super>TypeInferencer.VirtualType</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Browser-TypeInferencer</package></attributes></class><comment><class-id>TypeInferencer.NamedVariableType</class-id><body>NamedVariableType is a mixture of known or inferred information. This class is used by RBVariableNode which at the time might not know the context of a named variable. It could be a temporary variable, instance variable or even a reference to a shared variable somewhere within its executable scope. If it is an instance variable, the type information must be inferred instead of being known.Instance Variables:	name		&lt;Symbol&gt;	The name of the variable</body></comment><class><name>ConstraintType</name><environment>TypeInferencer</environment><super>TypeInferencer.VirtualType</super><private>false</private><indexed-type>none</indexed-type><inst-vars>constraints fallback </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Browser-TypeInferencer</package></attributes></class><comment><class-id>TypeInferencer.ConstraintType</class-id><body>ConstraintType is a known piece of information, representing a constraint on other information. The constraints are message selectors and if an exact intersection of those selectors yields a single class in the system, that becomes the inferred type for this virtual type, otherwise the constraints are applied to the fallback type, which is usually the receiver of the constraint messages.Instance Variables:	constraints	&lt;Set of: Symbol&gt;	message selectors that the fallback type must respond to	fallback	&lt;VirtualType&gt;		a VirtualType to be resolved if the constraints cannot resolve the virtual type by themselves</body></comment><class><name>Type</name><environment>TypeInferencer</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>behavior </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Browser-TypeInferencer</package></attributes></class><comment><class-id>TypeInferencer.Type</class-id><body>Type represents a resolved concrete type in the system, ie: a behavior.Instance Variables:	behavior	&lt;Behavior&gt;	the behavior this type represents</body></comment><class><name>ContainerType</name><environment>TypeInferencer</environment><super>TypeInferencer.Type</super><private>false</private><indexed-type>none</indexed-type><inst-vars>keyTypes valueTypes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Browser-TypeInferencer</package></attributes></class><comment><class-id>TypeInferencer.ContainerType</class-id><body>ContainerType represents a type in the system that can contain other things generically, such as a Collection. An example is CharacterArray with a key of SmallInteger and a value of Character.Instance Variables:	keyTypes	&lt;Collection of: Type&gt;	The types being used as keys in this container	valueTypes	&lt;Collection of: Type&gt;	The types being used as values in this container</body></comment><class><name>ObjectType</name><environment>TypeInferencer</environment><super>TypeInferencer.VirtualType</super><private>false</private><indexed-type>none</indexed-type><inst-vars>object </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Browser-TypeInferencer</package></attributes></class><comment><class-id>TypeInferencer.ObjectType</class-id><body>ObjectType is a known piece of information, representing an object that came directly from the system, such as a literal in compiled code, eg: ^#foobar, or ^'foobar', or ^12345Instance Variables:	object	&lt;Object&gt;	The object</body></comment><class><name>MessageSendType</name><environment>TypeInferencer</environment><super>TypeInferencer.VirtualType</super><private>false</private><indexed-type>none</indexed-type><inst-vars>receiver selector arguments searchFrom </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Browser-TypeInferencer</package></attributes></class><comment><class-id>TypeInferencer.MessageSendType</class-id><body>MessageSendType is inferred information about a message send return type.Instance Variables:	receiver		&lt;VirtualType&gt;	The receiver of the message	arguments		&lt;Array of: VirtualType&gt;	The arguments of the message	selector		&lt;Symbol&gt;		The selector of the message	searchFrom	&lt;UndefinedObject | Class | Symbol&gt;	A class to search from if this is a super send, or the symbol #fromReceiver to search for super from the receiver type</body></comment><class><name>BehaviorType</name><environment>TypeInferencer</environment><super>TypeInferencer.VirtualType</super><private>false</private><indexed-type>none</indexed-type><inst-vars>type </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Browser-TypeInferencer</package></attributes></class><comment><class-id>TypeInferencer.BehaviorType</class-id><body>BehaviorType is a known piece of information, representing a type that came directly from the system, such as a reference to a class in compiled code, eg: ^OrderedCollection new.Instance Variables:	type	&lt;Type&gt;	The type this virtual type represents</body></comment><class><name>BlockClosureParameterTypeSearch</name><environment>TypeInferencer</environment><super>TypeInferencer.TypeSearch</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parameter destinations invocationParameter </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Browser-TypeInferencer</package></attributes></class><comment><class-id>TypeInferencer.BlockClosureParameterTypeSearch</class-id><body>BlockClosureParameterTypeSearch searches for uses of a particular block closure until the block closure is evaluated with one of the value* primitives, at which point the original search parameter for the block closure can be resolved to type information.Instance Variables:	destinations		&lt;Collection of: VirtualType&gt;	message sends that contain the target block closure as a parameter or the receiver	invocationParameter	&lt;Integer&gt;	The original parameter index where the block closure is instantiated	parameter			&lt;Type&gt;	The parameter passed to this type searches block</body></comment><class><name>PrimitiveType</name><environment>TypeInferencer</environment><super>TypeInferencer.VirtualType</super><private>false</private><indexed-type>none</indexed-type><inst-vars>number arguments receiverClass receiverType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Browser-TypeInferencer</package></attributes></class><comment><class-id>TypeInferencer.PrimitiveType</class-id><body>PrimitiveType is a sometimes a known piece of information, representing the return value of a method that runs a primitive.A database of primitives and the actions to take if asking for known or inferred type information exists for every primitive in the system. Many primitives return a known type, others reflect back an argument of the primitive. More complex primitives, such as the invocation of a BlockClosure require further exploration of the system.As well as a database of primitives, this class also treats arithmetic primitives by simulating the 'generalization' of numeric types that happens when a mathematical primitive is applied to the arguments. Typically, one of the two parameters will be made more general until both parameters are of the same generality and only then is the primitive applied. This means that a SmallInteger + Float will become a Float + Float, making the arithmetic return type probably a Float.Instance Variables:	arguments		&lt;OrderedCollection of: VirtualType&gt;	the arguments passed to the primitive method	number		&lt;Integer&gt;	The primitive number of the method	receiverClass	&lt;Type&gt;	The receiverClass for the primitive	receiverType	&lt;BlockClosureType&gt;	The receiverType, when it is a BlockClosureType is used to evaluate BlockClosure primitives value*Shared Variables:	Generalities	&lt;Dictionary of: Class -&gt; Integer&gt;	A mapping of arithmetic classes to their generality	Primitives		&lt;Array&gt;	A mapping of primitive numbers to their primitive classification	Actions		&lt;Array&gt;	A mapping of primitive numbers to inferred actions	KnownActions	&lt;Array&gt;	A mapping of primitive numbers to known actions</body></comment><class><name>LocalVariableType</name><environment>TypeInferencer</environment><super>TypeInferencer.VirtualType</super><private>false</private><indexed-type>none</indexed-type><inst-vars>variable </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Browser-TypeInferencer</package></attributes></class><comment><class-id>TypeInferencer.LocalVariableType</class-id><body>LocalVariableType is inferred information about an RBVariableNode that usually represents a temporary variable. More information is discoverable about an RBVariableNode than with a TemporaryVariableType, but otherwise the two classes are analogous. Instance Variables:	variable	&lt;RBVariableNode&gt;	the variable to infer type information about</body></comment><class><name>InstanceVariableTypeSearch</name><environment>TypeInferencer</environment><super>TypeInferencer.TypeSearch</super><private>false</private><indexed-type>none</indexed-type><inst-vars>targetVariableIndex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Browser-TypeInferencer</package></attributes></class><comment><class-id>TypeInferencer.InstanceVariableTypeSearch</class-id><body>InstanceVariableTypeSearch searches for all references to an instance variable in the block. This information is gathered at the end after a regular search is performed, based on the gathered information about the block.Instance Variables:	targetVariableIndex	&lt;Integer&gt;	The instance variable index for the block's mclass.</body></comment><class><name>BlockClosureType</name><environment>TypeInferencer</environment><super>TypeInferencer.VirtualType</super><private>false</private><indexed-type>none</indexed-type><inst-vars>block interface copied </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Browser-TypeInferencer</package></attributes></class><comment><class-id>TypeInferencer.BlockClosureType</class-id><body>BlockClosureType is a partially known and inferred information. Normally it resolves to just a BlockClosure, but if the BlockClosure is being evaluated via a value* primitive, then the block, copied and interface values are used to evaluate the BlockClosure for its types instead. This is done from PrimitiveType.Instance Variables:	block		&lt;BlockClosure | RBBlockNode&gt;	The block closure to resolve for value* primitives	copied	&lt;Array&gt;			Values closed over by the block closure	interface	&lt;TypeInterface&gt;		The interface bound to the instantiation of the block closure</body></comment><class><name>TypeInterface</name><environment>TypeInferencer</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cache receiverClass environment behaviors constraints exceptions objects inferred keys values </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Browser-TypeInferencer</package></attributes></class><comment><class-id>TypeInferencer.TypeInterface</class-id><body>TypeInterface represents the construction of a 'type interface', a set of known requirements for a message send, variable, method return, etc that must be true for a type in the system to be acceptable for this interface. Usually these are in the form of message constraints, ie: a type must respond to #copy, #at:put:, #yourself, #respondsToArithmetic. The type inference gathers up requirements on to an instance of TypeInterface and then sends #resolve to transform those requirements in to Type instances of concrete classes in the system.Instance Variables:	cache			&lt;Dictionary&gt;	A cache of resolved VirtualType instances	environment	&lt;NameSpace&gt;	The namespace this interface is scoped to	receiverClass	&lt;Type&gt;		The behavior this interface is scoped to	behaviors		&lt;Collection of: Type&gt;	Known behaviors that exist for this type interface	exceptions		&lt;Collection of: Type&gt;	Known exceptions that might be raised when using this type interface	inferred		&lt;Collection of: Type&gt;	Inferred behaviors for this type interface that may be culled during #resolve	keys			&lt;Collection of: Type&gt;	Known key types that make this type interface resolve to container types	values		&lt;Collection of: Type&gt;	Known value types that make this type interface resolve to container types	constraints		&lt;Collection of: Symbol&gt;	Message selectors this type interface must respond to	objects		&lt;Collection of: Object&gt;	Known objects that exist for this type interface</body></comment><class><name>TemporaryVariableType</name><environment>TypeInferencer</environment><super>TypeInferencer.VirtualType</super><private>false</private><indexed-type>none</indexed-type><inst-vars>searcher index </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Browser-TypeInferencer</package></attributes></class><comment><class-id>TypeInferencer.TemporaryVariableType</class-id><body>TemporaryVariableType is a mixture of known and inferred information about a temporary variable discovered by a TypeSearch. The return type of a method might be a temporary variable, in which case it will be a TemporaryVariableType. The only information known about a temporary variable in this state is from the type search that created it.Instance Variables:	index		&lt;Integer&gt;	the temporary variable index from the searcher block	searcher	&lt;TypeSearch&gt;	the searcher that owns this temporary variable</body></comment><class><name>ConcreteError</name><environment>TypeInferencer</environment><super>TypeInferencer.VirtualType</super><private>false</private><indexed-type>none</indexed-type><inst-vars>signal </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Browser-TypeInferencer</package></attributes></class><comment><class-id>TypeInferencer.ConcreteError</class-id><body>ConcreteError is a known piece of information, representing an exception signal that came directly from the system, such as a reference to an error in compiled code, eg: ^Error raiseSignal: 'woops'Instance Variables:	signal	&lt;Exception&gt;	The exception that could be raised by this virtual type</body></comment><class><name>BlockClosureParameterVariableType</name><environment>TypeInferencer</environment><super>TypeInferencer.VirtualType</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parameter invocationParameter receiver selector arguments </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Browser-TypeInferencer</package></attributes></class><comment><class-id>TypeInferencer.BlockClosureParameterVariableType</class-id><body>BlockClosureParameterVariableType is inferred information about a parameter to a block closure. Uses of the block closure are tracked until the block closure is evaluated with a value* primitive from PrimitiveType. This virtual type acts like a MessageSend, except one of the arguments to the message send (or perhaps the receiver itself) is the block closure being tracked. This is known by the parameter variable. The target parameter in the block closure is invocationParameter.Instance Variables:	arguments	&lt;Array of: VirtualType&gt;	The arguments of the message	selector	&lt;Symbol&gt;		The selector of the message	receiver	&lt;VirtualType&gt;	The message receiver	invocationParameter	&lt;Integer&gt;	The parameter of the target parameter to find information about	parameter	&lt;Integer&gt;		The parameter of the arguments (or 0 for the receiver) to track</body></comment><shared-variable><name>SuperVariable</name><environment>TypeInferencer.NamedVariableType</environment><private>false</private><constant>false</constant><category>accessing</category><attributes><package>Browser-TypeInferencer</package></attributes></shared-variable><shared-variable><name>SelfVariable</name><environment>TypeInferencer.NamedVariableType</environment><private>false</private><constant>false</constant><category>accessing</category><attributes><package>Browser-TypeInferencer</package></attributes></shared-variable><shared-variable><name>DebugDepth</name><environment>TypeInferencer.MessageSendType</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>0</initializer><attributes><package>Browser-TypeInferencer</package></attributes></shared-variable><shared-variable><name>KnownActions</name><environment>TypeInferencer.PrimitiveType</environment><private>false</private><constant>false</constant><category>accessing</category><attributes><package>Browser-TypeInferencer</package></attributes></shared-variable><shared-variable><name>Primitives</name><environment>TypeInferencer.PrimitiveType</environment><private>false</private><constant>false</constant><category>accessing</category><attributes><package>Browser-TypeInferencer</package></attributes></shared-variable><shared-variable><name>Generalities</name><environment>TypeInferencer.PrimitiveType</environment><private>false</private><constant>false</constant><category>accessing</category><attributes><package>Browser-TypeInferencer</package></attributes></shared-variable><shared-variable><name>Actions</name><environment>TypeInferencer.PrimitiveType</environment><private>false</private><constant>false</constant><category>accessing</category><attributes><package>Browser-TypeInferencer</package></attributes></shared-variable><methods><class-id>TypeInferencer.VirtualType</class-id> <category>private</category><body package="Browser-TypeInferencer">implementorsOfReceiverType: aReceiverType selector: selector searchFrom: searchFrom interface: aTypeInterface do: aBlockClosure	"For a ReceiverType and searchFrom (eg: a super class), find compiled code for selector and pass them to aBlockClosure"	| typeInterface receiverClasses |	typeInterface := aReceiverType inferTypeInterfaceFrom: aTypeInterface.	typeInterface addConstraint: selector.	receiverClasses := typeInterface resolve.	receiverClasses isEmpty ifTrue: [		typeInterface := aTypeInterface clone.		typeInterface addConstraint: selector.		receiverClasses := typeInterface resolve].	receiverClasses do: [:aReceiverClass |		| implementorClass |		implementorClass := searchFrom == nil			ifTrue: [aReceiverClass whichClassIncludesSelector: selector]			ifFalse: [searchFrom == #fromReceiver				ifTrue: [aReceiverClass superclass behavior ifNotNil: [:superclass | superclass whichClassIncludesSelector: selector]]				ifFalse: [searchFrom whichClassIncludesSelector: selector]].		implementorClass == nil ifFalse: [			aBlockClosure value: aReceiverClass value: (implementorClass compiledMethodAt: selector)]]</body><body package="Browser-TypeInferencer">numArgs	^nil</body></methods><methods><class-id>TypeInferencer.VirtualType</class-id> <category>api</category><body package="Browser-TypeInferencer">addInferredInto: aTypeInterface	"Infer types into aTypeInterface for the receiver, exploring the system as required."	self addKnownInto: aTypeInterface</body><body package="Browser-TypeInferencer">addKnownInto: aTypeInterface	"Add known types into aTypeInterface for the receiver, without further exploration of the system."	self subclassResponsibility</body><body package="Browser-TypeInferencer">inferTypeInterfaceFrom: aTypeInterface	"Infer types into a copy of aTypeInterface for the receiver, exploring the system as required."	| interface |	self addInferredInto: (interface := aTypeInterface clone).	^interface</body></methods><methods><class-id>TypeInferencer.InstanceVariableType</class-id> <category>comparing</category><body package="Browser-TypeInferencer">= anInstanceVariableType	^self class == anInstanceVariableType class and: [behavior = anInstanceVariableType behavior and: [index = anInstanceVariableType index]]</body><body package="Browser-TypeInferencer">hash	^behavior hash bitXor: index hash</body></methods><methods><class-id>TypeInferencer.InstanceVariableType</class-id> <category>accessing</category><body package="Browser-TypeInferencer">behavior	^behavior</body><body package="Browser-TypeInferencer">behavior: anObject	behavior := anObject</body><body package="Browser-TypeInferencer">index	^index</body><body package="Browser-TypeInferencer">index: anObject	index := anObject</body></methods><methods><class-id>TypeInferencer.InstanceVariableType</class-id> <category>printing</category><body package="Browser-TypeInferencer">printOn: aStream	aStream nextPutAll: behavior name; nextPutAll: '.'; nextPutAll: (behavior allInstVarNames at: index)</body></methods><methods><class-id>TypeInferencer.InstanceVariableType</class-id> <category>testing</category><body package="Browser-TypeInferencer">isVariableSatisfiedEnough: aTypeInterface	aTypeInterface behaviors isEmpty ifTrue: [^false].	(aTypeInterface behaviors size == 1 and: [aTypeInterface behaviors any == UndefinedObject]) ifTrue: [^false].	^true</body></methods><methods><class-id>TypeInferencer.InstanceVariableType</class-id> <category>api</category><body package="Browser-TypeInferencer">addInferredInto: aTypeInterface	aTypeInterface inferredTypeOf: self ifAbsentPut: [		behavior isMeta			ifTrue: [aTypeInterface addKnownObject: (behavior soleInstance instVarAt: index)]			ifFalse: [				| class searches |				searches := OrderedCollection new.				class := behavior.				[class == nil or: [class instSize &lt; index]] whileFalse: [					class methodDictionary do: [:method |						(Kernel.InstanceVariableSearch new							method: method;							searchFor: index - 1 type: #readWrite) ifTrue: [								searches add: (InstanceVariableTypeSearch new									targetVariableIndex: index;									search: method copied: #() into: aTypeInterface;									addKnownInto: aTypeInterface;									yourself)]].					class := class superclass].				aTypeInterface isTightlySatisfied ifFalse: [					searches do: [:each | each addInferredInto: aTypeInterface]]]]</body><body package="Browser-TypeInferencer">addKnownInto: aTypeInterface	"Nothing is known about an instance variable, it must be inferred"</body></methods><methods><class-id>TypeInferencer.InstanceVariableType class</class-id> <category>instance creation</category><body package="Browser-TypeInferencer">behavior: aBehavior index: anIndex	^self new		behavior: aBehavior;		index: anIndex;		yourself</body></methods><methods><class-id>TypeInferencer.MessageType</class-id> <category>accessing</category><body package="Browser-TypeInferencer">arguments	^arguments</body><body package="Browser-TypeInferencer">arguments: anObject	arguments := anObject</body><body package="Browser-TypeInferencer">selector	^selector</body><body package="Browser-TypeInferencer">selector: anObject	selector := anObject</body></methods><methods><class-id>TypeInferencer.MessageType</class-id> <category>comparing</category><body package="Browser-TypeInferencer">= aMessageType	^aMessageType class == self class and: [aMessageType selector = selector]</body><body package="Browser-TypeInferencer">hash	^selector hash</body></methods><methods><class-id>TypeInferencer.MessageType</class-id> <category>api</category><body package="Browser-TypeInferencer">addInferredInto: aTypeInterface	aTypeInterface inferredTypeOf: self ifAbsentPut: [		| receiverClasses |		receiverClasses := Refactory.Browser.SourceCodeDatabase default implementorsIndex at: selector ifAbsent: [#()].		receiverClasses do: [:aReceiverClass |			self	inference: aTypeInterface				implementorClass: aReceiverClass				receiverClass: aReceiverClass]]</body><body package="Browser-TypeInferencer">addKnownInto: aTypeInterface	"Nothing is known about a message, it must be inferred"</body><body package="Browser-TypeInferencer">inference: aTypeInterface implementorClass: implementorClass receiverClass: aReceiverClass	| interface compiledMethod searcher |	compiledMethod := implementorClass compiledMethodAt: selector.	interface := TypeInterface on: (Type of: aReceiverClass) in: compiledMethod environment cache: aTypeInterface cache.	searcher := MethodReturnTypeSearch new.	arguments == nil		ifTrue: [searcher search: compiledMethod copied: #() into: interface]		ifFalse: [searcher search: compiledMethod arguments: arguments copied: #() into: interface].	searcher addInferredInto: interface.	aTypeInterface addInferredTypes: interface resolve.	aTypeInterface addKnownExceptions: interface exceptions</body></methods><methods><class-id>TypeInferencer.MessageType class</class-id> <category>instance creation</category><body package="Browser-TypeInferencer">selector: aSelector	^self selector: aSelector arguments: nil</body><body package="Browser-TypeInferencer">selector: aSelector arguments: aCollection	^self new		selector: aSelector;		arguments: aCollection;		yourself</body></methods><methods><class-id>TypeInferencer.TypeSearch</class-id> <category>opcodes-control</category><body package="Browser-TypeInferencer">jump: delta	delta &gt; 0 ifTrue: [self saveStacks at: input pc + delta put: stack copy]</body><body package="Browser-TypeInferencer">jump: delta if: condition	self pop.	delta &gt; 0 ifTrue: [self saveStacks at: input pc + delta put: stack copy].</body><body package="Browser-TypeInferencer">makeCopyingBlock: aBlock count: count	self makeFullCopyingBlock: aBlock count: count</body><body package="Browser-TypeInferencer">makeFullBlock: aBlock	self makeFullCopyingBlock: aBlock count: 0</body><body package="Browser-TypeInferencer">makeFullCopyingBlock: aBlockClosure copiedValues: capture	| searcher arguments |	searcher := self newTypeSearch.	arguments := (1 to: aBlockClosure numArgs) collect: [:each | TemporaryVariableType searcher: searcher index: each].	searcher search: aBlockClosure arguments: arguments copied: capture into: interface.	self mergeTypeSearch: searcher.	stack add: (BlockClosureType block: aBlockClosure copied: capture interface: interface clone)</body><body package="Browser-TypeInferencer">makeFullCopyingBlock: aBlockClosure count: count	self makeFullCopyingBlock: aBlockClosure copiedValues: (stack removeLast: count)</body><body package="Browser-TypeInferencer">methodPrimitive: index	self shouldNotImplement</body><body package="Browser-TypeInferencer">methodReturnTop: levels	stack last == #unknown ifFalse: [		returns add: stack last.		methodReturns add: stack last].	stack := nil</body><body package="Browser-TypeInferencer">returnTop	stack last == #unknown ifFalse: [returns add: stack last].	stack := nil</body><body package="Browser-TypeInferencer">send: selector numArgs: na	| rcvr args |	args := stack removeLast: na.	rcvr := stack removeLast.	(messages at: rcvr ifAbsentPut: [Set new]) add: selector.	rcvr == #uninitialized ifTrue: [		stack add: (MessageType selector: selector arguments: args).		^self].	rcvr == #unknown ifTrue: [		stack add: (MessageType selector: selector arguments: args).		^self].	selector = #add: ifTrue: [		(valueTypes at: rcvr ifAbsentPut: [Set new]) add: args first].	selector = #remove:ifAbsent: ifTrue: [		(valueTypes at: rcvr ifAbsentPut: [Set new]) add: args first].	selector = #at:put: ifTrue: [		(keyTypes at: rcvr ifAbsentPut: [Set new]) add: args first.		(valueTypes at: rcvr ifAbsentPut: [Set new]) add: args last].	stack add: (MessageSendType receiver: rcvr selector: selector arguments: args)</body><body package="Browser-TypeInferencer">sendNoCheck: selector numArgs: na	self send: selector numArgs: na</body><body package="Browser-TypeInferencer">sendNonImmediate: selector numArgs: na	self send: selector numArgs: na</body><body package="Browser-TypeInferencer">sendSuper: selector numArgs: na	| args rcvr mclass superclass |	mclass := stack removeLast object.	args := stack removeLast: na.	rcvr := stack removeLast.	mclass superclass == nil ifTrue: [		stack add: (ConcreteError signal: MessageNotUnderstood).		^self].	superclass := mclass superclass whichClassIncludesSelector: selector.	superclass == nil ifTrue: [		stack add: (ConcreteError signal: MessageNotUnderstood).		^self].	stack add: (MessageSendType receiver: rcvr selector: selector arguments: args searchFrom: mclass superclass)</body></methods><methods><class-id>TypeInferencer.TypeSearch</class-id> <category>opcodes-data movement</category><body package="Browser-TypeInferencer">dupFirst	stack add: stack last</body><body package="Browser-TypeInferencer">dupLast	stack removeLast</body><body package="Browser-TypeInferencer">dupNext	stack		removeLast;		add: stack last</body><body package="Browser-TypeInferencer">pop	stack removeLast</body><body package="Browser-TypeInferencer">pushConstant: value	(value isKindOf: Core.BlockClosure)		ifTrue: [self makeFullCopyingBlock: value method copiedValues: value copiedValues]		ifFalse: [stack add: (ObjectType of: value)]</body><body package="Browser-TypeInferencer">pushContext	block isBlockMethod		ifTrue: [stack add: (BehaviorType of: Kernel.BlockContext)]		ifFalse: [stack add: (BehaviorType of: Kernel.MethodContext)]</body><body package="Browser-TypeInferencer">pushCopiedValues: count	copied size = count ifFalse: [self error: (#copiedMismatch &lt;&lt; #dialogs &gt;&gt; 'copied mismatch')].	stack addAll: copied.	initialStack addAll: copied</body><body package="Browser-TypeInferencer">pushInst: index	stack add: (InstanceVariableType behavior: block mclass index: index + 1)</body><body package="Browser-TypeInferencer">pushLocal: index	stack add: (stack at: index + 1)</body><body package="Browser-TypeInferencer">pushLocalIndirect: majorIndex index: minorIndex	| object |	object := stack at: majorIndex + 1.	object class == Array ifTrue: [		stack add: (object at: minorIndex + 1).		^self].	(object class == BehaviorType and: [object type = interface receiverClass]) ifTrue: [		^self pushInst: minorIndex].	environmentals at: object ifPresent: [:known |		known at: minorIndex + 1 ifPresent: [:value |			stack add: value.			^self]].	stack add: #unknown</body><body package="Browser-TypeInferencer">pushNewArray: size	stack add: (Array new: size withAll: #uninitialized)</body><body package="Browser-TypeInferencer">pushReceiver	stack add: (BehaviorType type: interface receiverClass)</body><body package="Browser-TypeInferencer">pushStatic: assoc	| value |	(assoc isKindOf: Kernel.GeneralBindingReference)		ifTrue: [			value := assoc valueOrDo: [				stack add: (ConcreteError signal: Object errorSignal).				^self]]		ifFalse: [value := assoc value].	stack add: (ObjectType of: value)</body><body package="Browser-TypeInferencer">storeInst: index	| variable |	variable := InstanceVariableType behavior: block mclass index: index + 1.	(assignments at: variable ifAbsentPut: [Set new]) add: stack last.	self merge: variable with: stack last</body><body package="Browser-TypeInferencer">storeLocal: index	(assignments at: index + 1 ifAbsentPut: [Set new]) add: stack last.	stack at: index + 1 put: stack last.	self merge: index + 1 with: stack last</body><body package="Browser-TypeInferencer">storeLocalIndirect: majorIndex index: minorIndex	| object |	object := stack at: majorIndex + 1.	object class == Array ifTrue: [		| key |		key := (minorIndex + 1) / 10 + (majorIndex + 1).		(assignments at: key ifAbsentPut: [Set new]) add: stack last.		object at: minorIndex + 1 put: stack last.		self merge: key with: stack last.		^self].	(object class == BehaviorType and: [object type = interface receiverClass]) ifTrue: [		^self storeInst: minorIndex].	(environmentals at: object ifAbsentPut: [Dictionary new])		at: minorIndex + 1 put: stack last</body><body package="Browser-TypeInferencer">storePopLocalIndirect: majorIndex index: minorIndex	self storeLocalIndirect: majorIndex index: minorIndex.	self pop</body></methods><methods><class-id>TypeInferencer.TypeSearch</class-id> <category>private</category><body package="Browser-TypeInferencer">merge: index1 with: index2	| set1 set2 |	(index1 isKindOf: Number) ifFalse: [^self].	(index2 isKindOf: Number) ifFalse: [^self].	set1 := assignments at: index1 ifAbsent: [Set new].	set2 := assignments at: index2 ifAbsent: [Set new].	set1 addAll: set2.	assignments at: index2 put: set1</body><body package="Browser-TypeInferencer">mergeTypeSearch: searcher	searcher messages keysAndValuesDo: [:key :set | (messages at: key ifAbsentPut: [Set new]) addAll: set].	searcher assignments keysAndValuesDo: [:key :set | (assignments at: key ifAbsentPut: [Set new]) addAll: set].	searcher keyTypes keysAndValuesDo: [:key :set | (keyTypes at: key ifAbsentPut: [Set new]) addAll: set].	searcher valueTypes keysAndValuesDo: [:key :set | (valueTypes at: key ifAbsentPut: [Set new]) addAll: set].	searcher environmentals keysAndValuesDo: [:key :set | (environmentals at: key ifAbsentPut: [Dictionary new]) addAll: set].	methodReturns addAll: searcher methodReturns.	returns addAll: searcher methodReturns</body><body package="Browser-TypeInferencer">newTypeSearch	^self class new</body><body package="Browser-TypeInferencer">primitive: aPrimitiveNumber arguments: anArguments	returns add: (PrimitiveType new		number: aPrimitiveNumber;		arguments: anArguments;		receiverClass: interface receiverClass;		receiverType: receiverType;		yourself)</body><body package="Browser-TypeInferencer">reloadStack	self saveStacks at: input pc ifPresent: [:savedStack | ^stack := savedStack].	stack == nil ifTrue: [stack := initialStack copy]</body><body package="Browser-TypeInferencer">saveStacks	saveStacks == nil ifTrue: [saveStacks := Dictionary new].	^saveStacks</body></methods><methods><class-id>TypeInferencer.TypeSearch</class-id> <category>testing</category><body package="Browser-TypeInferencer">isInstanceVariable: anObject	^anObject isInteger and: [anObject negative]</body><body package="Browser-TypeInferencer">isLocalVariable: anObject	^(anObject isKindOf: Number) and: [anObject positive]</body><body package="Browser-TypeInferencer">isMessageSend: anObject	^anObject isBehavior</body><body package="Browser-TypeInferencer">isStackClosure: anObject	^anObject class == Array</body><body package="Browser-TypeInferencer">isType: anObject	^anObject isBehavior</body><body package="Browser-TypeInferencer">isVariable: anObject	^(self isInstanceVariable: anObject) or: [self isLocalVariable: anObject]</body></methods><methods><class-id>TypeInferencer.TypeSearch</class-id> <category>accessing</category><body package="Browser-TypeInferencer">assignments	^assignments</body><body package="Browser-TypeInferencer">block	^block</body><body package="Browser-TypeInferencer">environmentals	^environmentals</body><body package="Browser-TypeInferencer">keyTypes	^keyTypes</body><body package="Browser-TypeInferencer">messages	^messages</body><body package="Browser-TypeInferencer">methodReturns	^methodReturns</body><body package="Browser-TypeInferencer">receiverType	^receiverType</body><body package="Browser-TypeInferencer">receiverType: anObject	receiverType := anObject</body><body package="Browser-TypeInferencer">returns	^returns</body><body package="Browser-TypeInferencer">valueTypes	^valueTypes</body></methods><methods><class-id>TypeInferencer.TypeSearch</class-id> <category>initialize-release</category><body package="Browser-TypeInferencer">initialize		environmentals := Dictionary new.	messages := Dictionary new.	assignments := Dictionary new.	keyTypes := Dictionary new.	valueTypes := Dictionary new.	returns := Set new.	methodReturns := Set new</body></methods><methods><class-id>TypeInferencer.TypeSearch</class-id> <category>api - inferencing</category><body package="Browser-TypeInferencer">addInferredInto: aTypeInterface	"Add inferred information to aTypeInterface even if that requires further exploration of the system."		^self subclassResponsibility</body><body package="Browser-TypeInferencer">addKnownInto: aTypeInterface	"Add known information to aTypeInterface that does not require further exploration of the system."		^self subclassResponsibility</body></methods><methods><class-id>TypeInferencer.TypeSearch</class-id> <category>api - searching</category><body package="Browser-TypeInferencer">search: aBlockClosure arguments: anArguments copied: aCopied into: aTypeInterface	"Search aBlockClosure for type information based on aTypeInterface."		| end arguments |	self initialize.	interface := aTypeInterface.	copied := aCopied.	block := aBlockClosure.		arguments := anArguments.	(aBlockClosure isBlockMethod not and: [aBlockClosure primitiveNumber notNil]) ifTrue: [		^self primitive: aBlockClosure primitiveNumber arguments: arguments].		"cull: and its cousins make a choice about which BlockClosure&gt;&gt;value:* API to call	depending on the number of arguments, but we don't get that information during our	static search, so we cull or add arguments as necessary here."	arguments size &gt; block numArgs ifTrue: [		arguments := anArguments first: block numArgs].	arguments size &lt; block numArgs ifTrue: [		arguments := arguments, (arguments size + 1 to: block numArgs) collect: [:each |			TemporaryVariableType searcher: self index: each]].		input := Kernel.InstructionStream on: block.	stack := OrderedCollection new.	stack addAll: arguments.	stack addAll: ((1 to: block numTempsOnly) collect: [:each | TemporaryVariableType searcher: self index: each]).	initialStack := stack copy.	end := block bytes size.	[input pc &lt;= end]		whileTrue:			[self reloadStack.			input interpretNextInstructionFor: self]</body><body package="Browser-TypeInferencer">search: aBlockClosure copied: aCopied into: aTypeInterface	"Search aBlockClosure for type information based on aTypeInterface."		| arguments |	arguments := (1 to: aBlockClosure numArgs) collect: [:each | TemporaryVariableType searcher: self index: each].	self search: aBlockClosure arguments: arguments copied: aCopied into: aTypeInterface</body></methods><methods><class-id>TypeInferencer.MethodReturnTypeSearch</class-id> <category>api - inferencing</category><body package="Browser-TypeInferencer">addInferredInto: aTypeInterface	self addConstraintsInto: aTypeInterface.	returns do: [:each |		each addInferredInto: aTypeInterface.		(assignments at: each ifAbsent: [#()]) do: [:anAssignment |			anAssignment addInferredInto: aTypeInterface]].</body><body package="Browser-TypeInferencer">addKnownInto: aTypeInterface	self addConstraintsInto: aTypeInterface.	returns do: [:each |		each addKnownInto: aTypeInterface.		(assignments at: each ifAbsent: [#()]) do: [:anAssignment |			anAssignment addKnownInto: aTypeInterface]].</body></methods><methods><class-id>TypeInferencer.MethodReturnTypeSearch</class-id> <category>private</category><body package="Browser-TypeInferencer">addConstraintsInto: aTypeInterface		returns do: [:each |		(keyTypes at: each ifAbsent: [#()]) do: [:type |			aTypeInterface addContainerKeyTypes: (type inferTypeInterfaceFrom: aTypeInterface) resolve].		(valueTypes at: each ifAbsent: [#()]) do: [:type |			aTypeInterface addContainerValueTypes: (type inferTypeInterfaceFrom: aTypeInterface) resolve].		aTypeInterface addConstraints: (messages at: each ifAbsent: [#()])].		"Implicit return type"	returns isEmpty ifTrue: [aTypeInterface addKnownType: aTypeInterface receiverClass]</body></methods><methods><class-id>TypeInferencer.NamedVariableType</class-id> <category>testing</category><body package="Browser-TypeInferencer">isSelf	^self == SelfVariable</body><body package="Browser-TypeInferencer">isSuper	^self == SuperVariable</body></methods><methods><class-id>TypeInferencer.NamedVariableType</class-id> <category>printing</category><body package="Browser-TypeInferencer">printOn: aStream	aStream nextPutAll: name</body></methods><methods><class-id>TypeInferencer.NamedVariableType</class-id> <category>comparing</category><body package="Browser-TypeInferencer">= aNamedVariableType	^self class == aNamedVariableType class and: [name = aNamedVariableType name]</body><body package="Browser-TypeInferencer">hash	^name hash</body></methods><methods><class-id>TypeInferencer.NamedVariableType</class-id> <category>accessing</category><body package="Browser-TypeInferencer">name	^name</body><body package="Browser-TypeInferencer">name: anObject	name := anObject</body></methods><methods><class-id>TypeInferencer.NamedVariableType</class-id> <category>api</category><body package="Browser-TypeInferencer">addInferredInto: aTypeInterface	aTypeInterface inferredTypeOf: self ifAbsentPut: [		| binding index |		self isSelf ifTrue: [^aTypeInterface addKnownType: aTypeInterface receiverClass].		self isSuper ifTrue: [^aTypeInterface addKnownClass: aTypeInterface receiverClass behavior superclass].		(index := aTypeInterface receiverClass behavior allInstVarNames indexOf: name) &gt; 0 ifTrue: [			^(InstanceVariableType behavior: aTypeInterface receiverClass behavior index: index) addInferredInto: aTypeInterface].		binding := Kernel.SystemUtils			resolveBindingAsReference: name			inClass: aTypeInterface receiverClass behavior			inEnvironment: aTypeInterface environment.		aTypeInterface addKnownObject: binding value]</body><body package="Browser-TypeInferencer">addKnownInto: aTypeInterface	| binding |	self isSelf ifTrue: [^aTypeInterface addKnownType: aTypeInterface receiverClass].	self isSuper ifTrue: [^aTypeInterface addKnownClass: aTypeInterface receiverClass behavior superclass].	(aTypeInterface receiverClass behavior allInstVarNames indexOf: name) &gt; 0 ifTrue: [^nil].	binding := Kernel.SystemUtils		resolveBindingAsReference: name		inClass: aTypeInterface receiverClass behavior		inEnvironment: aTypeInterface environment.	aTypeInterface addKnownObject: binding value</body></methods><methods><class-id>TypeInferencer.NamedVariableType class</class-id> <category>instance creation</category><body package="Browser-TypeInferencer">behavior: aBehavior named: aName	^self new		behavior: aBehavior;		name: aName;		yourself</body><body package="Browser-TypeInferencer">named: aName	^self new		name: aName;		yourself</body><body package="Browser-TypeInferencer">selfVariable	^SelfVariable ifNil: [SelfVariable := self named: 'self']</body><body package="Browser-TypeInferencer">superVariable	^SuperVariable ifNil: [SuperVariable := self named: 'super']</body></methods><methods><class-id>TypeInferencer.ConstraintType</class-id> <category>accessing</category><body package="Browser-TypeInferencer">constraints	^constraints</body><body package="Browser-TypeInferencer">constraints: anObject	constraints := anObject</body><body package="Browser-TypeInferencer">fallback	^fallback</body><body package="Browser-TypeInferencer">fallback: anObject	fallback := anObject</body></methods><methods><class-id>TypeInferencer.ConstraintType</class-id> <category>api</category><body package="Browser-TypeInferencer">addInferredInto: aTypeInterface	| types reduced interface |	aTypeInterface addConstraints: constraints.	types := aTypeInterface resolve.	reduced := self findCommonAncestors: types.	types isEmpty ifTrue: [^fallback addInferredInto: aTypeInterface].	reduced size = 1 ifTrue: [^self].	interface := fallback inferTypeInterfaceFrom: aTypeInterface.	aTypeInterface inferred: (interface resolve select: [:each |		types anySatisfy: [:aSuperclass |			each = aSuperclass or: [each inheritsFrom: aSuperclass]]])</body><body package="Browser-TypeInferencer">addKnownInto: aTypeInterface	aTypeInterface addConstraints: constraints</body></methods><methods><class-id>TypeInferencer.ConstraintType</class-id> <category>private</category><body package="Browser-TypeInferencer">findCommonAncestors: types	| all |	all := Set new.	types do: [:aType |		all addAll: ((aType behavior withAllSuperclasses			reject: [:each | each superclass == nil])				collect: [:aBehavior | Type of: aBehavior])].	^TypeInterface new reduceBehaviors: all</body></methods><methods><class-id>TypeInferencer.Type</class-id> <category>api</category><body package="Browser-TypeInferencer">becomeContainer	self become: (ContainerType of: behavior keyTypes: Set new valueTypes: Set new).	^self</body><body package="Browser-TypeInferencer">whichClassIncludesSelector: aSelector	^behavior whichClassIncludesSelector: aSelector</body></methods><methods><class-id>TypeInferencer.Type</class-id> <category>accessing</category><body package="Browser-TypeInferencer">allSuperclasses	^behavior allSuperclasses</body><body package="Browser-TypeInferencer">behavior	^behavior</body><body package="Browser-TypeInferencer">behavior: anObject	behavior := anObject</body><body package="Browser-TypeInferencer">classBehavior	^Type of: behavior</body><body package="Browser-TypeInferencer">instanceBehavior	^Type of: behavior instanceBehavior</body><body package="Browser-TypeInferencer">keyTypes	^#()</body><body package="Browser-TypeInferencer">name	^behavior name</body><body package="Browser-TypeInferencer">superclass	^Type of: behavior superclass</body><body package="Browser-TypeInferencer">valueTypes	^#()</body><body package="Browser-TypeInferencer">withAllSubclasses	^behavior withAllSubclasses</body></methods><methods><class-id>TypeInferencer.Type</class-id> <category>testing</category><body package="Browser-TypeInferencer">inheritsFrom: aType	^behavior inheritsFrom: aType behavior</body><body package="Browser-TypeInferencer">inheritsFromClass: aClass	^behavior inheritsFrom: aClass</body><body package="Browser-TypeInferencer">is: aBehavior	^behavior = aBehavior</body><body package="Browser-TypeInferencer">isMeta	^behavior isMeta</body></methods><methods><class-id>TypeInferencer.Type</class-id> <category>printing</category><body package="Browser-TypeInferencer">printOn: aStream	aStream print: behavior</body></methods><methods><class-id>TypeInferencer.Type</class-id> <category>comparing</category><body package="Browser-TypeInferencer">= aType	aType isBehavior ifTrue: [^aType = behavior].	^(aType class == Type or: [aType class == ContainerType]) and: [aType behavior = behavior]</body><body package="Browser-TypeInferencer">hash	^behavior hash</body></methods><methods><class-id>TypeInferencer.Type class</class-id> <category>instance creation</category><body package="Browser-TypeInferencer">of: aBehavior	^self new		behavior: aBehavior;		yourself</body></methods><methods><class-id>TypeInferencer.ContainerType</class-id> <category>accessing</category><body package="Browser-TypeInferencer">keyTypes	^keyTypes</body><body package="Browser-TypeInferencer">name	^self printString</body><body package="Browser-TypeInferencer">valueTypes	^valueTypes</body></methods><methods><class-id>TypeInferencer.ContainerType</class-id> <category>printing</category><body package="Browser-TypeInferencer">printOn: aStream	aStream nextPutAll: '('.	super printOn: aStream.	aStream nextPutAll: ' of: '.	keyTypes notEmpty ifTrue: [		keyTypes size = 1 ifTrue: [aStream print: keyTypes any] ifFalse: [aStream print: keyTypes].		aStream nextPutAll: ' -&gt; '].	valueTypes size = 1 ifTrue: [aStream print: valueTypes any] ifFalse: [aStream print: valueTypes].	aStream nextPutAll: ')'</body></methods><methods><class-id>TypeInferencer.ContainerType</class-id> <category>api</category><body package="Browser-TypeInferencer">becomeContainer</body></methods><methods><class-id>TypeInferencer.ContainerType</class-id> <category>initialize-release</category><body package="Browser-TypeInferencer">behavior: aBehavior keyTypes: aKeyTypes valueTypes: aValueTypes	behavior := aBehavior.	keyTypes := aKeyTypes.	valueTypes := aValueTypes</body></methods><methods><class-id>TypeInferencer.ContainerType</class-id> <category>copying</category><body package="Browser-TypeInferencer">postCopy	keyTypes := keyTypes copy.	valueTypes := valueTypes copy</body></methods><methods><class-id>TypeInferencer.ContainerType</class-id> <category>configuring</category><body package="Browser-TypeInferencer">addContainerKeyType: aType	keyTypes add: aType</body><body package="Browser-TypeInferencer">addContainerKeyTypes: aCollection	aCollection do: [:each | self addContainerKeyType: each]</body><body package="Browser-TypeInferencer">addContainerValueType: aType	valueTypes add: aType</body><body package="Browser-TypeInferencer">addContainerValueTypes: aCollection	aCollection do: [:each | self addContainerValueType: each]</body></methods><methods><class-id>TypeInferencer.ContainerType class</class-id> <category>instance creation</category><body package="Browser-TypeInferencer">of: aBehavior keyTypes: aKeyTypes valueTypes: aValueTypes	^self new behavior: aBehavior keyTypes: aKeyTypes valueTypes: aValueTypes</body></methods><methods><class-id>TypeInferencer.ObjectType</class-id> <category>comparing</category><body package="Browser-TypeInferencer">= anObjectType	^self class == anObjectType class and: [object == anObjectType object]</body><body package="Browser-TypeInferencer">hash	^object hash</body></methods><methods><class-id>TypeInferencer.ObjectType</class-id> <category>accessing</category><body package="Browser-TypeInferencer">object	^object</body><body package="Browser-TypeInferencer">object: anObject	object := anObject</body></methods><methods><class-id>TypeInferencer.ObjectType</class-id> <category>printing</category><body package="Browser-TypeInferencer">printOn: aStream	aStream print: object</body></methods><methods><class-id>TypeInferencer.ObjectType</class-id> <category>api</category><body package="Browser-TypeInferencer">addKnownInto: aTypeInterface	aTypeInterface addKnownObject: object</body></methods><methods><class-id>TypeInferencer.ObjectType class</class-id> <category>instance creation</category><body package="Browser-TypeInferencer">of: anObject	^self new object: anObject</body></methods><methods><class-id>TypeInferencer.MessageSendType</class-id> <category>accessing</category><body package="Browser-TypeInferencer">arguments	^arguments</body><body package="Browser-TypeInferencer">arguments: anObject	arguments := anObject</body><body package="Browser-TypeInferencer">receiver	^receiver</body><body package="Browser-TypeInferencer">receiver: anObject	receiver := anObject</body><body package="Browser-TypeInferencer">searchFrom	^searchFrom</body><body package="Browser-TypeInferencer">searchFrom: anObject	searchFrom := anObject</body><body package="Browser-TypeInferencer">selector	^selector</body><body package="Browser-TypeInferencer">selector: anObject	selector := anObject</body></methods><methods><class-id>TypeInferencer.MessageSendType</class-id> <category>api</category><body package="Browser-TypeInferencer">addInferredInto: aTypeInterface	"#hash and magnitude selectors are rabbit holes"	selector = #hash ifTrue: [		aTypeInterface addKnownClass: SmallInteger.		^self].	(#(&lt; &gt; &lt;= &gt;= = == ~= ~~) includes: selector) ifTrue: [		aTypeInterface addKnownClass: True.		aTypeInterface addKnownClass: False.		^self].	aTypeInterface inferredTypeOf: self ifAbsentPut: [		| searchers interface |		interface := aTypeInterface clone.		searchers := OrderedCollection new.		self			implementorsOfReceiverType: receiver			selector: selector			searchFrom: searchFrom			interface: aTypeInterface			do: [:receiverClass :compiledMethod |				self addSearcherInto: searchers interface: interface forReceiverClass: receiverClass method: compiledMethod].		interface isTightlySatisfied ifFalse: [			searchers do: [:each | each addInferredInto: interface]].		aTypeInterface addTypeInterface: interface]</body><body package="Browser-TypeInferencer">addKnownInto: aTypeInterface	"Nothing is known about a message send, it must be inferred"</body></methods><methods><class-id>TypeInferencer.MessageSendType</class-id> <category>comparing</category><body package="Browser-TypeInferencer">= aMessageSendType	^self class == aMessageSendType class and: [receiver = aMessageSendType receiver and: [selector = aMessageSendType selector and: [searchFrom = aMessageSendType searchFrom]]]</body><body package="Browser-TypeInferencer">hash	^(receiver hash bitXor: selector hash) bitXor: searchFrom hash</body></methods><methods><class-id>TypeInferencer.MessageSendType</class-id> <category>printing</category><body package="Browser-TypeInferencer">printOn: aStream	aStream print: receiver.	searchFrom == nil ifFalse: [aStream nextPutAll: '('; print: searchFrom; nextPutAll: ')'].	aStream space; print: selector</body></methods><methods><class-id>TypeInferencer.MessageSendType</class-id> <category>private</category><body package="Browser-TypeInferencer">addSearcherInto: searchers interface: aTypeInterface forReceiverClass: aReceiverClass method: compiledMethod	| searcher interface |	((aReceiverClass inheritsFromClass: Exception) and: [selector beginsWith: 'raise']) ifTrue: [		^aTypeInterface addKnownException: aReceiverClass].	interface := TypeInterface on: aReceiverClass in: compiledMethod environment cache: aTypeInterface cache.	searcher := MethodReturnTypeSearch new		receiverType: receiver;		yourself.	arguments == nil		ifTrue: [searcher search: compiledMethod copied: #() into: interface]		ifFalse: [searcher search: compiledMethod arguments: arguments copied: #() into: interface].	searcher addKnownInto: aTypeInterface.	searchers add: searcher</body></methods><methods><class-id>TypeInferencer.MessageSendType class</class-id> <category>instance creation</category><body package="Browser-TypeInferencer">receiver: aVirtualType selector: aSelector arguments: anArguments	^self receiver: aVirtualType selector: aSelector arguments: anArguments searchFrom: nil</body><body package="Browser-TypeInferencer">receiver: aVirtualType selector: aSelector arguments: anArguments searchFrom: aSuperBehavior	^self new		receiver: aVirtualType;		selector: aSelector;		arguments: anArguments;		searchFrom: aSuperBehavior;		yourself</body><body package="Browser-TypeInferencer">receiver: aVirtualType selector: aSelector searchFrom: aSuperBehavior	^self new		receiver: aVirtualType;		selector: aSelector;		searchFrom: aSuperBehavior;		yourself</body><body package="Browser-TypeInferencer">type: aVirtualType selector: aSelector arguments: anArguments	^self type: aVirtualType selector: aSelector arguments: anArguments searchFrom: nil</body><body package="Browser-TypeInferencer">type: aVirtualType selector: aSelector arguments: anArguments searchFrom: aSuperBehavior	^self new		type: aVirtualType;		selector: aSelector;		arguments: anArguments;		searchFrom: aSuperBehavior;		yourself</body><body package="Browser-TypeInferencer">type: aVirtualType selector: aSelector searchFrom: aSuperBehavior	^self new		type: aVirtualType;		selector: aSelector;		searchFrom: aSuperBehavior;		yourself</body></methods><methods><class-id>TypeInferencer.BehaviorType</class-id> <category>comparing</category><body package="Browser-TypeInferencer">= aBehaviorType	^self class == aBehaviorType class and: [type = aBehaviorType type]</body><body package="Browser-TypeInferencer">hash	^type hash</body></methods><methods><class-id>TypeInferencer.BehaviorType</class-id> <category>printing</category><body package="Browser-TypeInferencer">printOn: aStream	aStream nextPutAll: type name</body></methods><methods><class-id>TypeInferencer.BehaviorType</class-id> <category>api</category><body package="Browser-TypeInferencer">addKnownInto: aTypeInterface	aTypeInterface addKnownType: type</body></methods><methods><class-id>TypeInferencer.BehaviorType</class-id> <category>accessing</category><body package="Browser-TypeInferencer">type	^type</body><body package="Browser-TypeInferencer">type: anObject	type := anObject</body></methods><methods><class-id>TypeInferencer.BehaviorType class</class-id> <category>instance creation</category><body package="Browser-TypeInferencer">of: aBehavior	^self type: (Type of: aBehavior)</body><body package="Browser-TypeInferencer">type: aType	^self new type: aType</body></methods><methods><class-id>TypeInferencer.BlockClosureParameterTypeSearch</class-id> <category>private</category><body package="Browser-TypeInferencer">mergeTypeSearch: searcher	super mergeTypeSearch: searcher.	destinations addAll: searcher destinations</body><body package="Browser-TypeInferencer">newTypeSearch	^super newTypeSearch		parameter: parameter;		invocationParameter: invocationParameter;		yourself</body><body package="Browser-TypeInferencer">primitive: aPrimitiveNumber arguments: anArguments	| argumentInterface |	(PrimitiveType primitives at: aPrimitiveNumber) = #value ifFalse: [^super primitive: aPrimitiveNumber arguments: anArguments].	interface receiverClass == parameter ifFalse: [^super primitive: aPrimitiveNumber arguments: anArguments].	invocationParameter &gt; anArguments size ifTrue: [		"Here we have identified a bug in the developers code. The BlockClosure originally created requires more parameters than are being provided by the invocation."		^self].	argumentInterface := (anArguments at: invocationParameter) inferTypeInterfaceFrom: interface.	destinations addAll: (argumentInterface resolve collect: [:each | BehaviorType type: each])</body></methods><methods><class-id>TypeInferencer.BlockClosureParameterTypeSearch</class-id> <category>accessing</category><body package="Browser-TypeInferencer">destinations	^destinations</body><body package="Browser-TypeInferencer">invocationParameter	^invocationParameter</body><body package="Browser-TypeInferencer">invocationParameter: anObject	invocationParameter := anObject</body><body package="Browser-TypeInferencer">parameter	^parameter</body><body package="Browser-TypeInferencer">parameter: anObject	parameter := anObject</body></methods><methods><class-id>TypeInferencer.BlockClosureParameterTypeSearch</class-id> <category>initialize-release</category><body package="Browser-TypeInferencer">initialize	super initialize.	destinations := Set new</body></methods><methods><class-id>TypeInferencer.BlockClosureParameterTypeSearch</class-id> <category>api - inferencing</category><body package="Browser-TypeInferencer">addInferredInto: aTypeInterface	destinations do: [:each | each addInferredInto: aTypeInterface]</body><body package="Browser-TypeInferencer">addKnownInto: aTypeInterface	destinations do: [:each | each addKnownInto: aTypeInterface]</body></methods><methods><class-id>TypeInferencer.BlockClosureParameterTypeSearch</class-id> <category>opcodes-control</category><body package="Browser-TypeInferencer">send: selector numArgs: na	| parameters |	parameters := stack last: na + 1.	(parameters includes: parameter) ifTrue: [		| destination |		destination := BlockClosureParameterVariableType new			receiver: parameters first;			selector: selector;			arguments: (parameters allButFirst: 1);			invocationParameter: invocationParameter;			parameter: (parameters indexOf: parameter) - 1;			yourself.		destinations add: destination].	super send: selector numArgs: na</body></methods><methods><class-id>TypeInferencer.PrimitiveType</class-id> <category>accessing</category><body package="Browser-TypeInferencer">arguments	^arguments</body><body package="Browser-TypeInferencer">arguments: anObject	arguments := anObject</body><body package="Browser-TypeInferencer">number	^number</body><body package="Browser-TypeInferencer">number: anObject	number := anObject</body><body package="Browser-TypeInferencer">receiverClass	^receiverClass</body><body package="Browser-TypeInferencer">receiverClass: anObject	receiverClass := anObject</body><body package="Browser-TypeInferencer">receiverType	^receiverType</body><body package="Browser-TypeInferencer">receiverType: anObject	receiverType := anObject</body></methods><methods><class-id>TypeInferencer.PrimitiveType</class-id> <category>private</category><body package="Browser-TypeInferencer">arithmeticPrimitive: aTypeInterface	| argumentInterface arithmeticType arithmeticGenerality argumentGenerality |	arguments isEmpty ifTrue: [^aTypeInterface addKnownType: receiverClass].	argumentInterface := arguments first inferTypeInterfaceFrom: aTypeInterface.	arithmeticType := receiverClass.	arithmeticGenerality := self class generalities at: receiverClass behavior ifAbsent: [0].	argumentInterface resolve do: [:each |		argumentGenerality := self class generalities at: each behavior ifAbsent: [0].		argumentGenerality &gt; arithmeticGenerality ifTrue: [			arithmeticType := each.			arithmeticGenerality := argumentGenerality]].	aTypeInterface addKnownType: arithmeticType</body><body package="Browser-TypeInferencer">getKeyType	^receiverClass keyTypes</body><body package="Browser-TypeInferencer">getValueType	^receiverClass valueTypes</body><body package="Browser-TypeInferencer">setKeyType: aVirtualType interface: aTypeInterface	"| argumentInterface |	receiverClass becomeContainer.	argumentInterface := aVirtualType inferTypeInterfaceFrom: aTypeInterface.	receiverClass addContainerKeyTypes: argumentInterface resolve"</body><body package="Browser-TypeInferencer">setValueType: aVirtualType interface: aTypeInterface	| argumentInterface types |	argumentInterface := aVirtualType inferTypeInterfaceFrom: aTypeInterface.	types := argumentInterface resolve.	types isEmpty ifFalse: [		receiverClass becomeContainer.		receiverClass addContainerValueTypes: types]</body><body package="Browser-TypeInferencer">valuePrimitive: aTypeInterface	| closureInterface |	(receiverType ~~ nil and: [receiverType class == BlockClosureType]) ifFalse: [		^aTypeInterface addKnownClass: Object].	closureInterface := receiverType interface clone.	(receiverType block class ~~ Refactory.Browser.RBBlockNode)		ifTrue: [			| searcher |			(searcher := MethodReturnTypeSearch new) search: receiverType block arguments: arguments copied: receiverType copied into: closureInterface.			searcher addInferredInto: closureInterface]		ifFalse: [			| type |			type := receiverType block body asVirtualType: closureInterface.			type == nil ifFalse: [type addInferredInto: closureInterface]].	aTypeInterface addTypeInterface: closureInterface</body><body package="Browser-TypeInferencer">valueWithArgumentsPrimitive: aTypeInterface	self valuePrimitive: aTypeInterface</body></methods><methods><class-id>TypeInferencer.PrimitiveType</class-id> <category>api</category><body package="Browser-TypeInferencer">addInferredInto: aTypeInterface	number &gt; self class actions size ifTrue: [^self].	(self class actions at: number) value: self value: aTypeInterface</body><body package="Browser-TypeInferencer">addKnownInto: aTypeInterface	number &gt; self class knownActions size ifTrue: [^self].	(self class knownActions at: number) value: self value: aTypeInterface</body></methods><methods><class-id>TypeInferencer.PrimitiveType class</class-id> <category>accessing</category><body package="Browser-TypeInferencer">actions	^Actions</body><body package="Browser-TypeInferencer">generalities	^Generalities</body><body package="Browser-TypeInferencer">knownActions	^KnownActions</body><body package="Browser-TypeInferencer">primitives	^Primitives</body></methods><methods><class-id>TypeInferencer.PrimitiveType class</class-id> <category>class initialization</category><body package="Browser-TypeInferencer">initialize	"self initialize"	Primitives := self initializePrimitives.	Actions := self initializeActions.	KnownActions := self initializeKnownActions.	Generalities := self initializeGeneralities</body><body package="Browser-TypeInferencer">initializeActions	| actions |	actions := Dictionary new		at: #self put: [:type :interface | interface addKnownType: type receiverClass instanceBehavior];		at: #selfclass put: [:type :interface | interface addKnownType: type receiverClass classBehavior];		at: #selfclassclass put: [:type :interface | interface addKnownClass: type receiverClass behavior class];		at: #valueWithArguments put: [:type :interface | type valueWithArgumentsPrimitive: interface];		at: #value put: [:type :interface | type valuePrimitive: interface];		at: #arithmetic put: [:type :interface | type arithmeticPrimitive: interface];		at: 1 put: [:type :interface | (type arguments at: 1) addInferredInto: interface];		at: 2 put: [:type :interface | (type arguments at: 2) addInferredInto: interface];		at: 3 put: [:type :interface | (type arguments at: 3) addInferredInto: interface];		at: #become put: [:type :interface | self notYetImplemented];		at: #onewaybecome put: [:type :interface | self notYetImplemented];		at: #creturntype put: [:type :interface | self notYetImplemented];		at: #next put: [:type :interface |			interface addKnownTypes: type getValueType];		at: #at put: [:type :interface |			type setKeyType: type arguments first interface: interface.			interface addKnownTypes: type getValueType];		at: #objectat put: [:type :interface |			type setKeyType: (type arguments at: 2) interface: interface.			interface addKnownTypes: type getValueType];		at: #nextPut put: [:type :interface |			type setValueType: type arguments first interface: interface.			type arguments first addInferredInto: interface];		at: #atput put: [:type :interface |			type setKeyType: type arguments first interface: interface.			type setValueType: type arguments last interface: interface.			type arguments last addInferredInto: interface];		at: #objectatput put: [:type :interface |			type setKeyType: (type arguments at: 2) interface: interface.			type setValueType: type arguments last interface: interface.			type arguments last addInferredInto: interface];		yourself.		^self primitives collect: [:types |		actions at: types ifAbsent: [			[:type :interface | interface addKnownTypes: (types collect: [:aBehavior | Type of: aBehavior])]]].</body><body package="Browser-TypeInferencer">initializeGeneralities	| generalities |	generalities := Dictionary new.	ArithmeticValue allSubclassesDo: [:each |		| method generality |		method := each compiledMethodAt: #generality ifAbsent: [nil].		method ifNotNil: [			generality := method copy				mclass: nil;				valueWithReceiver: nil arguments: #().			each withAllSubclasses do: [:aClass |				generalities at: aClass put: generality]]].	^generalities</body><body package="Browser-TypeInferencer">initializeKnownActions	| actions |	actions := Dictionary new		at: #self put: [:type :interface | interface addKnownType: type receiverClass instanceBehavior];		at: #selfclass put: [:type :interface | interface addKnownType: type receiverClass classBehavior];		at: #selfclassclass put: [:type :interface | interface addKnownClass: type receiverClass behavior class];		at: #valueWithArguments put: [:type :interface | ];		at: #value put: [:type :interface | ];		at: #arithmetic put: [:type :interface | type arithmeticPrimitive: interface];		at: 1 put: [:type :interface | ];		at: 2 put: [:type :interface | ];		at: 3 put: [:type :interface | ];		at: #become put: [:type :interface | self notYetImplemented];		at: #onewaybecome put: [:type :interface | self notYetImplemented];		at: #creturntype put: [:type :interface | self notYetImplemented];		at: #next put: [:type :interface |			interface addKnownTypes: type getValueType];		at: #at put: [:type :interface |			interface addKnownTypes: type getValueType];		at: #objectat put: [:type :interface |			interface addKnownTypes: type getValueType];		at: #nextPut put: [:type :interface | ];		at: #atput put: [:type :interface | ];		at: #objectatput put: [:type :interface | ];		yourself.		^self primitives collect: [:types |		actions at: types ifAbsent: [			[:type :interface | interface addKnownTypes: (types collect: [:aBehavior | Type of: aBehavior])]]].</body><body package="Browser-TypeInferencer">initializePrimitives	| types primitives primitiveTypes |	primitives := Array new: 2048 withAll: #selfclass.	types := self primitiveTypes.	self primitiveCategories do: [:primitive |		primitiveTypes := types at: primitive first.		(primitive allButFirst: 1) do: [:primitiveNumber |			primitives at: primitiveNumber put: primitiveTypes]].	^primitives</body></methods><methods><class-id>TypeInferencer.PrimitiveType class</class-id> <category>private</category><body package="Browser-TypeInferencer">primitiveCategories	^#(	(arithmetic 1 2 9 10 21 22 29 30 41 42 49 50 54 55 56 57 561 562 569 570 574 576 577 578 579 580 581 582 583 584 585 587 591 592 593 600 601 602 603 604 605 606 609 821 822 829 830 834 836 837 838 839 840 841 842 843 844 845 847)		(comparison 3 4 5 6 7 8 23 24 25 26 27 28 43 44 45 46 47 48 67 109 110 210 223 415 417 465 466 467 468 472 563 564 565 566 567 568 823 824 825 826 827 828 1041)		(integer 11 12 13 14 15 16 17 31 32 33 34 35 36 37 38 39 51 52 53 58 115 410 418 419 422 486 524 525 571 572 573 575 590 831 832 833 835)		(time 351)		(size 62 162 396 529 611 666 669 802 915 1606)		(hash 75 820 1065 1075 1700 1701 1702 1747)		(MakePoint 18 973 974)		(MakeFloat 40 588 848)		(MakeDouble 560 589)		(MakeSmallDouble 849)		(MakeCharacter 411)		(MakeSymbol 432)		(MakeContext 808)		(MakeProcess 1052)		(MakeObjectMemory 326)		(at 60 73 163 480 482 484 490 527 693 800 803)		(atput 61 74 481 483 485 491 528 801 804)		(next 65)		(nextPut 66)		(characterat 63 342 412)		(characteratput 64 343 413)		(integerat 420 423 425 540 542 544 546 552 554)		(integeratput 421 424 426 541 543 545 547 553 555)		(floatat 548 550)		(floatatput 549 551)		(new 70 71 77 1040)		(become 72)		(onewaybecome 108)		(class 111)		(objectat 160 173)		(objectatput 161 174)		(objectperform 184)		(objectclass 211)		(vmarray 142 306 309 340 346 400 657 905 908 914 942 947 955 977 978 1055 1104 1105 1204 1206 1207 1214 1621 1622 1690)		(vmbytes 302 303 471 631 632 633 640 906 941 1600)		(vmstring 641 645 646 647 648 649 910 949 1205 1620)		(vmboolean 407 534 634 1047 1059 1063 1064 1602 1607 1609 1710)		(vminteger 642 643 692 1216 1217 1617)		(mapaddress 330 332 333 386 391 393 612 1044)		(getheapstring 335 382 384 385)		(callc 337)		(malloc 397)		(instance 197 198 530 531)		(instances 402 403 404 408 440 )		(valueWithArguments 500)		(value 501 502 503 504)		(perform 510 511 512 513 514)		(valueWithReceiver 523))</body><body package="Browser-TypeInferencer">primitiveTypes	^Dictionary new		at: #arithmetic put: #arithmetic;		at: #comparison put: (Array with: True with: False);		at: #integer put: (Array with: SmallInteger);		at: #largeinteger put: (Array with: LargeInteger);		at: #time put: (Array with: LargePositiveInteger);		at: #size put: (Array with: SmallInteger);		at: #hash put: (Array with: SmallInteger);		at: #MakePoint put: (Array with: Point);		at: #MakeFloat put: (Array with: Float);		at: #MakeDouble put: (Array with: Double);		at: #MakeSmallDouble put: (Array with: SmallDouble);		at: #MakeCharacter put: (Array with: Character);		at: #MakeSymbol put: (Array with: Symbol);		at: #MakeContext put: (Array with: Kernel.Context);		at: #MakeProcess put: (Array with: Process);		at: #at put: #at;		at: #atput put: #atput;		at: #next put: #next;		at: #nextPut put: #nextPut;		at: #characterat put: (Array with: Character);		at: #characteratput put: (Array with: Character);		at: #integerat put: (Array with: SmallInteger);		at: #integeratput put: (Array with: SmallInteger);		at: #floatat put: (Array with: LimitedPrecisionReal);		at: #floatatput put: (Array with: LimitedPrecisionReal);		at: #new put: #self;		at: #become put: #become;		at: #onewaybecome put: #onewaybecome;		at: #class put: #selfclassclass;		at: #objectat put: #objectat;		at: #objectatput put: #objectatput;		at: #objectperform put: (Array with: Object);		at: #objectclass put: 1;		at: #vmarray put: (Array with: Array);		at: #vmbytes put: (Array with: ByteArray);		at: #vmstring put: (Array with: String);		at: #vmboolean put: (Array with: True with: False);		at: #vminteger put: (Array with: SmallInteger);		at: #MakeObjectMemory put: (Array with: Kernel.ObjectMemory);		at: #mapaddress put: (Array with: SmallInteger);		at: #getheapstring put: (Array with: String);		at: #callc put: #creturntype;		at: #malloc put: (Array with: External.CPointer);		at: #instance put: (Array with: Object);		at: #instances put: (Array with: Collection);		at: #valueWithArguments put: #valueWithArguments;		at: #value put: #value;		at: #perform put: (Array with: Object);		at: #valueWithReceiver put: 1;		yourself</body></methods><methods><class-id>TypeInferencer.LocalVariableType</class-id> <category>printing</category><body package="Browser-TypeInferencer">printOn: aStream	aStream nextPutAll: '@'; print: variable name</body></methods><methods><class-id>TypeInferencer.LocalVariableType</class-id> <category>accessing</category><body package="Browser-TypeInferencer">variable	^variable</body><body package="Browser-TypeInferencer">variable: anObject	variable := anObject</body></methods><methods><class-id>TypeInferencer.LocalVariableType</class-id> <category>comparing</category><body package="Browser-TypeInferencer">= aLocalVariableType	^self class == aLocalVariableType class and: [variable == aLocalVariableType variable]</body><body package="Browser-TypeInferencer">hash	^variable hash</body></methods><methods><class-id>TypeInferencer.LocalVariableType</class-id> <category>api</category><body package="Browser-TypeInferencer">addInferredInto: aTypeInterface	aTypeInterface inferredTypeOf: self ifAbsentPut: [		| assignments |		assignments := OrderedCollection new.		variable top nodesDo: [:node |			(node isAssignment and: [node variable = variable])				ifTrue: [assignments add: (node value asVirtualType: aTypeInterface clone)].			(node isAssignment and: [node value = variable])				ifTrue: [assignments add: (node variable asVirtualType: aTypeInterface clone)]].		assignments do: [:anAssignment | anAssignment addInferredInto: aTypeInterface]]</body><body package="Browser-TypeInferencer">addKnownInto: aTypeInterface		"Nothing is known about a local variable, it must be inferred"</body></methods><methods><class-id>TypeInferencer.LocalVariableType class</class-id> <category>instance creation</category><body package="Browser-TypeInferencer">variable: aVariable	^self new		variable: aVariable;		yourself</body></methods><methods><class-id>TypeInferencer.InstanceVariableTypeSearch</class-id> <category>accessing</category><body package="Browser-TypeInferencer">targetVariableIndex	^targetVariableIndex</body><body package="Browser-TypeInferencer">targetVariableIndex: anObject	targetVariableIndex := anObject</body></methods><methods><class-id>TypeInferencer.InstanceVariableTypeSearch</class-id> <category>private</category><body package="Browser-TypeInferencer">addConstraintsInto: aTypeInterface	| variable |	variable := InstanceVariableType behavior: block mclass index: targetVariableIndex.	aTypeInterface addConstraints: (messages at: variable ifAbsent: [#()])</body><body package="Browser-TypeInferencer">newTypeSearch	^super newTypeSearch		targetVariableIndex: targetVariableIndex;		yourself</body></methods><methods><class-id>TypeInferencer.InstanceVariableTypeSearch</class-id> <category>api - inferencing</category><body package="Browser-TypeInferencer">addInferredInto: aTypeInterface	| variable |	self addConstraintsInto: aTypeInterface.	variable := InstanceVariableType behavior: block mclass index: targetVariableIndex.	(assignments at: variable ifAbsent: [#()]) do: [:anAssignment |		anAssignment addInferredInto: aTypeInterface]</body><body package="Browser-TypeInferencer">addKnownInto: aTypeInterface	| variable |	self addConstraintsInto: aTypeInterface.	variable := InstanceVariableType behavior: block mclass index: targetVariableIndex.	(assignments at: variable ifAbsent: [#()]) do: [:anAssignment |		anAssignment addKnownInto: aTypeInterface]</body></methods><methods><class-id>TypeInferencer.BlockClosureType</class-id> <category>accessing</category><body package="Browser-TypeInferencer">block	^block</body><body package="Browser-TypeInferencer">block: anObject	block := anObject</body><body package="Browser-TypeInferencer">copied	^copied</body><body package="Browser-TypeInferencer">copied: anObject	copied := anObject</body><body package="Browser-TypeInferencer">interface	^interface</body><body package="Browser-TypeInferencer">interface: anObject	interface := anObject</body><body package="Browser-TypeInferencer">numArgs	^block class == Refactory.Browser.RBBlockNode		ifTrue: [block arguments size]		ifFalse: [block numArgs]</body></methods><methods><class-id>TypeInferencer.BlockClosureType</class-id> <category>api</category><body package="Browser-TypeInferencer">addKnownInto: aTypeInterface	aTypeInterface addKnownClass: Core.BlockClosure</body></methods><methods><class-id>TypeInferencer.BlockClosureType class</class-id> <category>instance creation</category><body package="Browser-TypeInferencer">block: aBlockClosure	^self new block: aBlockClosure</body><body package="Browser-TypeInferencer">block: aBlockClosure copied: aCopied interface: aTypeInterface	^self new		block: aBlockClosure;		copied: aCopied;		interface: aTypeInterface;		yourself</body></methods><methods><class-id>TypeInferencer.TypeInterface</class-id> <category>accessing</category><body package="Browser-TypeInferencer">behaviors	^behaviors</body><body package="Browser-TypeInferencer">behaviors: anObject	behaviors := anObject</body><body package="Browser-TypeInferencer">cache	^cache</body><body package="Browser-TypeInferencer">constraints	^constraints</body><body package="Browser-TypeInferencer">constraints: anObject	constraints := anObject</body><body package="Browser-TypeInferencer">environment	^environment</body><body package="Browser-TypeInferencer">environment: anObject	environment := anObject</body><body package="Browser-TypeInferencer">exceptions	^exceptions</body><body package="Browser-TypeInferencer">exceptions: anObject	exceptions := anObject</body><body package="Browser-TypeInferencer">inferred	^inferred</body><body package="Browser-TypeInferencer">inferred: anObject	inferred := anObject</body><body package="Browser-TypeInferencer">keys	^keys</body><body package="Browser-TypeInferencer">keys: anObject	keys := anObject</body><body package="Browser-TypeInferencer">objects	^objects</body><body package="Browser-TypeInferencer">objects: anObject	objects := anObject</body><body package="Browser-TypeInferencer">receiverClass	^receiverClass</body><body package="Browser-TypeInferencer">receiverClass: anObject	receiverClass := anObject</body><body package="Browser-TypeInferencer">values	^values</body><body package="Browser-TypeInferencer">values: anObject	values := anObject</body></methods><methods><class-id>TypeInferencer.TypeInterface</class-id> <category>private</category><body package="Browser-TypeInferencer">addContainer: aType	| behavior theKeys isKeyed |	behavior := aType behavior.	(behavior inheritsFrom: Collection) ifFalse: [^aType].	isKeyed := behavior == Dictionary or: [behavior == KeyedCollection or: [(behavior inheritsFrom: Dictionary) or: [behavior inheritsFrom: KeyedCollection]]].	theKeys := isKeyed ifTrue: [keys] ifFalse: [Set new].	(theKeys isEmpty and: [values isEmpty]) ifTrue: [^aType].	aType class = ContainerType ifTrue: [		^aType copy			addContainerKeyTypes: theKeys;			addContainerValueTypes: values;			yourself].	^ContainerType of: behavior keyTypes: theKeys copy valueTypes: values copy</body><body package="Browser-TypeInferencer">addContainers: types	^types collect: [:each | self addContainer: each]</body><body package="Browser-TypeInferencer"> inferredTypeOf: aVirtualType ifAbsentPut: aBlockClosure	"Inference type information for aVirtualType only if it hasn't already been inferred before."	"cache removeKey: aVirtualType"	cache at: aVirtualType ifPresent: [:existing | ^self addTypeInterface: existing].	cache at: aVirtualType put: self.	aBlockClosure value</body><body package="Browser-TypeInferencer">reduceBehaviors: aBehaviors	| reduced |	reduced := Set withAll: aBehaviors.	aBehaviors do: [:aBehavior |		(aBehavior allSuperclasses anySatisfy: [:aSuperclass | aSuperclass ~~ Object and: [reduced includes: aSuperclass]]) ifTrue: [			reduced remove: aBehavior]].	(reduced includes: Object) ifTrue: [		reduced := reduced reject: [:each | (each is: Object) not and: [(each inheritsFromClass: Object) not]]].	^reduced</body></methods><methods><class-id>TypeInferencer.TypeInterface</class-id> <category>configuring</category><body package="Browser-TypeInferencer">addConstraint: aSelector	constraints add: aSelector</body><body package="Browser-TypeInferencer">addConstraints: aCollection	constraints addAll: aCollection</body><body package="Browser-TypeInferencer">addContainerKeyType: aType	keys add: aType</body><body package="Browser-TypeInferencer">addContainerKeyTypes: aCollection	aCollection do: [:each | self addContainerKeyType: each]</body><body package="Browser-TypeInferencer">addContainerValueType: aType	values add: aType</body><body package="Browser-TypeInferencer">addContainerValueTypes: aCollection	aCollection do: [:each | self addContainerValueType: each]</body><body package="Browser-TypeInferencer">addInferredType: aType	inferred add: aType</body><body package="Browser-TypeInferencer">addInferredTypes: aCollection	aCollection do: [:each | self addInferredType: each]</body><body package="Browser-TypeInferencer">addKnownClass: aBehavior	self addKnownType: (Type of: aBehavior)</body><body package="Browser-TypeInferencer">addKnownException: anException	exceptions add: anException</body><body package="Browser-TypeInferencer">addKnownExceptions: aCollection	aCollection do: [:each | self addKnownException: each]</body><body package="Browser-TypeInferencer">addKnownObject: anObject	(objects identityIndexOf: anObject) == 0 ifTrue: [		objects add: anObject]</body><body package="Browser-TypeInferencer">addKnownType: aType	behaviors add: aType</body><body package="Browser-TypeInferencer">addKnownTypes: aCollection	aCollection do: [:each | self addKnownType: each]</body><body package="Browser-TypeInferencer">addTypeInterface: aTypeInterface	aTypeInterface objects do: [:object| self addKnownObject: object].	behaviors addAll: aTypeInterface behaviors.	exceptions addAll: aTypeInterface exceptions.	constraints addAll: aTypeInterface constraints.	keys addAll: aTypeInterface keys.	values addAll: aTypeInterface values.	inferred addAll: aTypeInterface inferred</body></methods><methods><class-id>TypeInferencer.TypeInterface</class-id> <category>printing</category><body package="Browser-TypeInferencer">printOn: aStream	aStream nextPutAll: 'TypeInterface: '; print: self identityHash</body></methods><methods><class-id>TypeInferencer.TypeInterface</class-id> <category>testing</category><body package="Browser-TypeInferencer">isSatisfiedEnough	^(self resolve		remove: #UndefinedObject ifAbsent: [];		yourself) notEmpty</body><body package="Browser-TypeInferencer">isTightlySatisfied	^(self resolve		remove: UndefinedObject ifAbsent: [];		yourself) size = 1</body></methods><methods><class-id>TypeInferencer.TypeInterface</class-id> <category>api</category><body package="Browser-TypeInferencer">clone	"Make a new TypeInterface with the same receiverClass, environment and re-use the cache."	^self class on: receiverClass in: environment cache: cache</body><body package="Browser-TypeInferencer">resolve	"Take all known and inferred information, apply the constraints to resolve to a set of types for this interface."	| types tolerance base firstTime |	base := behaviors copy addAll: (objects collect: [:each | Type of: each class]); yourself.	types := inferred addAll: base; yourself.		"The average broadness of most classes is 5 subclasses,	 while the average polymorphism of a selector is 4 implementors.	 For the sake of flexibility, we declare super-polymorphism to be	 &gt; 8 implementors per selector we're narrowing the types down by'."	tolerance := 8 * (constraints size + 1).	firstTime := true.	constraints do: [:selector |		| implementors |		implementors := Refactory.Browser.SourceCodeDatabase default implementorsIndex at: selector ifAbsent: [#()].		implementors := implementors reject: [:each |			(each compiledMethodAt: selector) isSubclassResponsibility].		types isEmpty			ifTrue: [				firstTime ifTrue: [					firstTime := false.					types := implementors collect: [:each | Type of: each]]]			ifFalse: [				implementors size &lt;= tolerance ifTrue: [					types := types select: [:each |						implementors anySatisfy: [:implementor | each = implementor or: [each inheritsFromClass: implementor]]]]]].	types isEmpty ifTrue: [^self addContainers: base].	types := self reduceBehaviors: types.	types size &lt;= tolerance ifTrue: [^self addContainers: types].	^Set new</body></methods><methods><class-id>TypeInferencer.TypeInterface</class-id> <category>initialize-release</category><body package="Browser-TypeInferencer">initialize: aReceiverClass in: anEnvironment cache: aCache	receiverClass := aReceiverClass.	environment := anEnvironment.	cache := aCache.	constraints := Set new.	behaviors := Set new.	exceptions := Set new.	objects := OrderedCollection new.	inferred := Set new.	keys := Set new.	values := Set new</body></methods><methods><class-id>TypeInferencer.TypeInterface class</class-id> <category>instance creation</category><body package="Browser-TypeInferencer">on: aReceiverClass in: anEnvironment	^self on: aReceiverClass in: anEnvironment cache: Dictionary new</body><body package="Browser-TypeInferencer">on: aReceiverClass in: anEnvironment cache: aCache	^super new initialize: aReceiverClass in: anEnvironment cache: aCache</body></methods><methods><class-id>TypeInferencer.TemporaryVariableType</class-id> <category>accessing</category><body package="Browser-TypeInferencer">block	^searcher block</body><body package="Browser-TypeInferencer">index	^index</body><body package="Browser-TypeInferencer">index: anObject	index := anObject</body><body package="Browser-TypeInferencer">searcher	^searcher</body><body package="Browser-TypeInferencer">searcher: anObject	searcher := anObject</body></methods><methods><class-id>TypeInferencer.TemporaryVariableType</class-id> <category>comparing</category><body package="Browser-TypeInferencer">= aTemporaryVariableType	^self class == aTemporaryVariableType class and: [aTemporaryVariableType block == self block and: [aTemporaryVariableType index == index]]</body><body package="Browser-TypeInferencer">hash	^self block hash bitXor: index hash</body></methods><methods><class-id>TypeInferencer.TemporaryVariableType</class-id> <category>api</category><body package="Browser-TypeInferencer">addInferredInto: aTypeInterface	(searcher assignments at: self ifAbsent: [#()]) do: [:anAssignment |		anAssignment addInferredInto: aTypeInterface].	aTypeInterface addConstraints: (searcher messages at: self ifAbsent: [#()])</body><body package="Browser-TypeInferencer">addKnownInto: aTypeInterface	(searcher assignments at: self ifAbsent: [#()]) do: [:anAssignment |		anAssignment addKnownInto: aTypeInterface].	aTypeInterface addConstraints: (searcher messages at: self ifAbsent: [#()])</body></methods><methods><class-id>TypeInferencer.TemporaryVariableType class</class-id> <category>instance creation</category><body package="Browser-TypeInferencer">searcher: aSearcher index: anIndex	^self new		searcher: aSearcher;		index: anIndex;		yourself</body></methods><methods><class-id>TypeInferencer.ConcreteError</class-id> <category>printing</category><body package="Browser-TypeInferencer">printOn: aStream	aStream nextPutAll: 'Error '; print: signal</body></methods><methods><class-id>TypeInferencer.ConcreteError</class-id> <category>accessing</category><body package="Browser-TypeInferencer">signal	^signal</body><body package="Browser-TypeInferencer">signal: anObject	signal := anObject</body></methods><methods><class-id>TypeInferencer.ConcreteError</class-id> <category>api</category><body package="Browser-TypeInferencer">addKnownInto: aTypeInterface	aTypeInterface addKnownException: signal</body></methods><methods><class-id>TypeInferencer.ConcreteError class</class-id> <category>instance creation</category><body package="Browser-TypeInferencer">signal: aSignal	^self new signal: aSignal</body></methods><methods><class-id>TypeInferencer.BlockClosureParameterVariableType</class-id> <category>accessing</category><body package="Browser-TypeInferencer">arguments	^arguments</body><body package="Browser-TypeInferencer">arguments: anObject	arguments := anObject</body><body package="Browser-TypeInferencer">invocationParameter	^invocationParameter</body><body package="Browser-TypeInferencer">invocationParameter: anObject	invocationParameter := anObject</body><body package="Browser-TypeInferencer">parameter	^parameter</body><body package="Browser-TypeInferencer">parameter: anObject	parameter := anObject</body><body package="Browser-TypeInferencer">receiver	^receiver</body><body package="Browser-TypeInferencer">receiver: anObject	receiver := anObject</body><body package="Browser-TypeInferencer">selector	^selector</body><body package="Browser-TypeInferencer">selector: anObject	selector := anObject</body></methods><methods><class-id>TypeInferencer.BlockClosureParameterVariableType</class-id> <category>api</category><body package="Browser-TypeInferencer">addInferredInto: aTypeInterface	"Valid only if our block is the receiver or an argument of a message send, eg:		[:foo | ] cull: 123		aCollection do: [:foo | ]"	"Create arguments including a 'target' block argument which is the block we're after"	"Keep following any call that uses the target argument as receiver or argument"	"Stop when the target block argument is sent a #value* primitive, the arguments	 at this point are the result we're looking for"	aTypeInterface inferredTypeOf: self ifAbsentPut: [		| searchers interface |		interface := aTypeInterface clone.		searchers := OrderedCollection new.		self			implementorsOfReceiverType: receiver			selector: selector			searchFrom: nil			interface: aTypeInterface			do: [:receiverClass :compiledMethod |				self addSearcherInto: searchers interface: interface forReceiverClass: receiverClass method: compiledMethod].		interface isTightlySatisfied ifFalse: [			searchers do: [:each | each addInferredInto: interface]].		aTypeInterface addTypeInterface: interface]</body><body package="Browser-TypeInferencer">addKnownInto: aTypeInterface	"Nothing is know about a block parameter, it must be inferred"</body></methods><methods><class-id>TypeInferencer.BlockClosureParameterVariableType</class-id> <category>private</category><body package="Browser-TypeInferencer">addSearcherInto: searchers interface: aTypeInterface forReceiverClass: aReceiverClass method: compiledMethod	| interface searcher args numArgs |	parameter &lt;= compiledMethod numArgs ifFalse: [^self].	interface := TypeInterface on: aReceiverClass in: compiledMethod environment cache: aTypeInterface cache.	searcher := BlockClosureParameterTypeSearch new.	(args := arguments) == nil ifTrue: [		numArgs := receiver numArgs ifNil: [compiledMethod numArgs].		numArgs &lt; parameter ifTrue: [^self].		args := (1 to: numArgs) collect: [:each | TemporaryVariableType searcher: searcher index: each].		parameter &gt; 0 ifTrue: [args at: parameter put: (BehaviorType of: Core.BlockClosure)]].	searcher receiverType: receiver.	searcher parameter: (parameter == 0 ifTrue: [aReceiverClass] ifFalse: [args at: parameter]).	searcher invocationParameter: invocationParameter.	searcher search: compiledMethod arguments: args copied: #() into: interface.	searcher addKnownInto: aTypeInterface.	searchers add: searcher</body></methods><methods><class-id>TypeInferencer.BlockClosureParameterVariableType</class-id> <category>comparing</category><body package="Browser-TypeInferencer">= aBlockClosureParameterVariableType	^self class == aBlockClosureParameterVariableType class and: [receiver = aBlockClosureParameterVariableType receiver and: [selector = aBlockClosureParameterVariableType selector and: [parameter = aBlockClosureParameterVariableType parameter]]]</body><body package="Browser-TypeInferencer">hash	^(receiver hash bitXor: selector hash) bitXor: parameter hash</body></methods><methods><class-id>TypeInferencer.BlockClosureParameterVariableType</class-id> <category>printing</category><body package="Browser-TypeInferencer">printOn: aStream	aStream print: receiver.	aStream space; print: selector</body></methods><methods><class-id>Refactory.Browser.RBLiteralNode</class-id> <category>accessing</category><body package="Browser-TypeInferencer">asVirtualType: aTypeInterface	^TypeInferencer.ObjectType of: self value</body></methods><methods><class-id>Refactory.Browser.RBMessageNode</class-id> <category>accessing</category><body package="Browser-TypeInferencer">asVirtualType: aTypeInterface	| messageSendType |	messageSendType := self asVirtualTypeWithoutConstraint: aTypeInterface.	(parent isMessage and: [parent receiver == self and: [parent isValidForTypeInferencing]]) ifTrue: [		^TypeInferencer.ConstraintType new			constraints: (Array with: parent selector);			fallback: messageSendType;			yourself].	^messageSendType</body><body package="Browser-TypeInferencer">asVirtualTypeWithoutConstraint: aTypeInterface	^TypeInferencer.MessageSendType		receiver: (receiver isSuper				ifTrue: [TypeInferencer.NamedVariableType selfVariable]				ifFalse: [receiver asVirtualType: aTypeInterface])		selector: self selector		arguments: (arguments collect: [:each | each asVirtualType: aTypeInterface])		searchFrom: (receiver isSuper ifTrue: [#fromReceiver] ifFalse: [nil])</body><body package="Browser-TypeInferencer">inferReceiverTypeInterfaceOn: aReceiverClass in: anEnvironment	^receiver inferTypeInterfaceOn: aReceiverClass in: anEnvironment</body></methods><methods><class-id>Refactory.Browser.RBMessageNode</class-id> <category>testing</category><body package="Browser-TypeInferencer">isValidForTypeInferencing	^(self propertyAt: #isValidForTypeInferencing ifAbsent: [true]) and: [		SourceCodeDatabase default implementorsIndex includesKey: selector]</body><body package="Browser-TypeInferencer">isValidForTypeInferencing: aBoolean	self propertyAt: #isValidForTypeInferencing put: aBoolean</body></methods><methods><class-id>Refactory.Browser.SourceCodeEditor</class-id> <category>actions - browsing</category><body package="Browser-TypeInferencer">styleType: aNode types: aTypeArray exceptions: anExceptionArray time: aTime	| typedocument position layer1 layer2 layer1style layer2style |	layer1 := ''.	(aTypeArray asSortedCollection: [:a :b | a name &lt;= b name]) do: [:each | layer1 := layer1, each name] separatedBy: [layer1 := layer1, ', '].	aNode isMessage ifTrue: [anExceptionArray do: [:anException | layer1 := layer1, ' !!', anException name]].	layer2 := ((aNode class name allButFirst: 2) allButLast: 4), ' ', aTime printString, 'ms'.	layer1style := DocumentStyle default copy		fontDescription: (self theme default fontDescription copy			pixelSize: 10;			yourself);		color: ColorValue white;		backgroundColor: ColorValue darkGray;		padding: ((0 @ 1) corner: (0 @ 1));		intern.	layer2style := layer1style copy		fontDescription: (layer1style fontDescription copy			pixelSize: 6;			yourself);		intern.	typedocument := Document new.	layer1 notEmpty ifTrue: [		typedocument insert: layer1, '' style: layer1style].	typedocument insert: layer2 style: layer2style.	position := aNode stop.	aNode isMessage ifTrue: [position := aNode selectorParts last stop].	aNode isAssignment ifTrue: [position := aNode assignmentPosition].	self invalidateSelectionWhile: [		flow replaceBetween: position - 1 and: position apply: [:aStyle |			aStyle copy				annotationStyle: #dodge;				annotation: typedocument;				intern]]</body></methods><methods><class-id>Refactory.Browser.RBAssignmentNode</class-id> <category>accessing</category><body package="Browser-TypeInferencer">asVirtualType: aTypeInterface	^value asVirtualType: aTypeInterface</body></methods><methods><class-id>Kernel.CompiledCode</class-id> <category>testing</category><body package="Browser-TypeInferencer">isSubclassResponsibility	"A shortcut to quickly determine if a method is a stub for subclassResponsibility"		| bytecodes |	"^self subclassResponsibility"	(bytecodes := self bytes) = #[68 206 72 101] ifTrue: [^true].	"self subclassResponsibility"	^bytecodes = #[68 206 72 69 101]</body></methods><methods><class-id>Refactory.Browser.RBVariableNode</class-id> <category>accessing</category><body package="Browser-TypeInferencer">asSimpleVirtualType: aTypeInterface	self isSelf ifTrue: [^TypeInferencer.NamedVariableType selfVariable].	self isSuper ifTrue: [^TypeInferencer.NamedVariableType superVariable].	self isThisContext ifTrue: [		^TypeInferencer.BehaviorType of: (self methodNode ~~ nil			ifTrue: [MethodContext]			ifFalse: [BlockContext])].	^nil</body><body package="Browser-TypeInferencer">asVirtualType: aTypeInterface	| constraints fallback |	(self asSimpleVirtualType: aTypeInterface) ifNotNil: [:aVirtualType | ^aVirtualType].			fallback := self asVirtualTypeWithoutConstraint: aTypeInterface.		constraints := Set new.	self top nodesDo: [:node |		(node isMessage and: [node receiver = self and: [node isValidForTypeInferencing]])			ifTrue: [constraints add: node selector]].		constraints isEmpty ifTrue: [^fallback].	^TypeInferencer.ConstraintType new		constraints: constraints;		fallback: fallback;		yourself</body><body package="Browser-TypeInferencer">asVirtualTypeWithoutConstraint: aTypeInterface	| definer |		(self asSimpleVirtualType: aTypeInterface) ifNotNil: [:aVirtualType | ^aVirtualType].			definer := self whoDefines: self name.	definer == nil ifTrue: [^TypeInferencer.NamedVariableType named: self name].		definer isBlock ifTrue: [		| message |		(message := definer parent) isMessage ifTrue: [			^TypeInferencer.BlockClosureParameterVariableType new				receiver: (message receiver asVirtualType: aTypeInterface);				selector: message selector;				arguments: (message arguments collect: [:each | each asVirtualType: aTypeInterface]);				parameter: (message receiver == definer ifTrue: [0] ifFalse: [message arguments indexOf: definer]);				invocationParameter: (definer arguments indexOf: self);				yourself]].	^TypeInferencer.LocalVariableType variable: self</body></methods><methods><class-id>Refactory.Browser.RBSequenceNode</class-id> <category>accessing</category><body package="Browser-TypeInferencer">asVirtualType: aTypeInterface	statements isEmpty ifTrue: [^nil].	^statements last asVirtualType: aTypeInterface</body></methods><methods><class-id>Refactory.Browser.RBProgramNode</class-id> <category>accessing</category><body package="Browser-TypeInferencer">asVirtualType: aTypeInterface	"Return a VirtualType for the program node, or nil if none can represent this program node."		^nil</body><body package="Browser-TypeInferencer">asVirtualTypeWithoutConstraint: aTypeInterface	"Return a VirtualType for the program node that is not a ConstraintType, or nil if none can represent this program node."	^self asVirtualType: aTypeInterface</body><body package="Browser-TypeInferencer">inferReceiverTypeInterfaceOn: aReceiverClass in: anEnvironment	"For a receiverClass and environment, infer the types of this program node's receiver, returning a TypeInterface that can be resolved."	^self inferTypeInterfaceOn: aReceiverClass in: anEnvironment</body><body package="Browser-TypeInferencer">inferTypeInterfaceOn: aReceiverClass in: anEnvironment	"For a receiverClass and environment, infer the types of this program node, returning a TypeInterface that can be resolved."	| type interface |	interface := TypeInferencer.TypeInterface on: (TypeInferencer.Type of: aReceiverClass) in: anEnvironment.	(type := self asVirtualType: interface) == nil ifFalse: [type addInferredInto: interface].	^interface</body></methods><methods><class-id>Refactory.Browser.RBProgramNode</class-id> <category>testing</category><body package="Browser-TypeInferencer">isValidForTypeInferencing: aBoolean</body></methods><methods><class-id>Refactory.Browser.RBCascadeNode</class-id> <category>accessing</category><body package="Browser-TypeInferencer">asVirtualType: aTypeInterface	^messages last asVirtualType: aTypeInterface</body><body package="Browser-TypeInferencer">inferReceiverTypeInterfaceOn: aReceiverClass in: anEnvironment	^messages first inferTypeInterfaceOn: aReceiverClass in: anEnvironment</body></methods><methods><class-id>Refactory.Browser.RBMethodNode</class-id> <category>accessing</category><body package="Browser-TypeInferencer">asVirtualType: aTypeInterface	^TypeInferencer.MessageSendType		receiver: (TypeInferencer.BehaviorType type: aTypeInterface receiverClass)		selector: selector		searchFrom: nil</body></methods><methods><class-id>Refactory.Browser.RBReturnNode</class-id> <category>accessing</category><body package="Browser-TypeInferencer">asVirtualType: aTypeInterface	^value asVirtualType: aTypeInterface</body></methods><methods><class-id>Refactory.Browser.RBBlockNode</class-id> <category>accessing</category><body package="Browser-TypeInferencer">asVirtualType: aTypeInterface	^TypeInferencer.BlockClosureType block: self copied: #() interface: aTypeInterface</body></methods><methods><class-id>Refactory.Browser.SourceCodeEditor</class-id> <category>actions - browsing</category><body package="Browser-TypeInferencer">exposeType	"A temporary 'secret' command to discover the type of the currently selected node."	&lt;state: #active modifiers: #(command shift) key: $l&gt;	&lt;state: #active modifiers: #(control shift) key: $l&gt;		| node types interface time |	(node := self selectionNode) ifNil: [^self].	types := #().	time := Time millisecondsToRun: [		node isValidForTypeInferencing: false.		(interface := node inferTypeInterfaceOn: self doItReceiverClass in: self doItEnvironment) ~~ nil ifTrue: [			types := interface resolve].		node isValidForTypeInferencing: true].	self styleType: node types: types exceptions: interface exceptions time: time</body><body package="Browser-TypeInferencer">exposeTypes	"A temporary 'secret' command to discover the types of the currently compilable method."	&lt;state: #active modifiers: #(command shift) key: $k&gt;	&lt;state: #active modifiers: #(control shift) key: $k&gt;		UI.Cursor wait showWhile: [		self invalidateSelectionWhile: [			| selectionNode |			selectionNode := self selectionNode.			selectionNode isValidForTypeInferencing: false.			self parseTree nodesDo: [:node |				| types interface time |				time := -1.				time := Time millisecondsToRun: [					interface := node inferTypeInterfaceOn: self doItReceiverClass in: self doItEnvironment.					interface == nil ifFalse: [types :=  interface resolve]].				self styleType: node types: types exceptions: interface exceptions time: time].			selectionNode isValidForTypeInferencing: true]]</body></methods><initialize><class-id>TypeInferencer.PrimitiveType</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>RBProgramNode</name><environment>Refactory.Browser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parent comments errors properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parser</category><attributes><package>Browser-Parser</package></attributes></class><class><name>RBReturnNode</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBProgramNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>return value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parser</category><attributes><package>Browser-Parser</package></attributes></class><class><name>RBVariableNode</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>token </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parser</category><attributes><package>Browser-Parser</package></attributes></class><class><name>RBAssignmentNode</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>variable assignment value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parser</category><attributes><package>Browser-Parser</package></attributes></class><class><name>CompiledCode</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>bytes </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>SourceCodeEditor</name><environment>Refactory.Browser</environment><super>UI.DocumentView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>decorations plugins theme evaluator needsRedecoration warning parseTree parserClass acceptAnimationCancel language errorHandlerClass timingStatistics compilerClass </inst-vars><class-inst-vars>defaultTheme compilationPragmas evaluationPragmas enablement </class-inst-vars><imports>			private Text2.*			</imports><category></category><attributes><package>Browser-SourceCodeUI</package></attributes></class><class><name>RBCascadeNode</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>messages semicolons </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parser</category><attributes><package>Browser-Parser</package></attributes></class><class><name>RBLiteralNode</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parser</category><attributes><package>Browser-Parser</package></attributes></class><class><name>RBSequenceNode</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBProgramNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>leftBar rightBar statements periods temporaries </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parser</category><attributes><package>Browser-Parser</package></attributes></class><class><name>RBMessageNode</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>receiver selector selectorParts arguments </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parser</category><attributes><package>Browser-Parser</package></attributes></class><class><name>RBBlockNode</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>left right colons body arguments bar </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parser</category><attributes><package>Browser-Parser</package></attributes></class><class><name>RBMethodNode</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBProgramNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector selectorParts body source arguments tags replacements nodeReplacements </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parser</category><attributes><package>Browser-Parser</package></attributes></class><class><name>InstructionClient</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class></st-source>