<?xml version="1.0"?><st-source><!-- Name: Compression-ZipNotice: Copyright 1999-2013 Cincom Systems, Inc.  All rights reserved.Comment: Provides facilities for reading file archives in 'zip' format (http://www.pkware.com/documents/casestudies/APPNOTE.TXT) that have been compressed using the 'deflate' method (generally the default). An archive is represented by an instance of Archive containing a collection of ArchiveEntries describing the compressed files. In general the contents of a file can be accessed through a decompression stream. The right kind of stream can be obtained from an ArchiveEntry using the #readStream message. Archives, entries and decompression streams also have potentially interesting attributes associated with them, for example #compressedSize, #uncompressedSize, #fileName, #lastModificationDate/Time, etc. See the 'accessing' protocol on corresponding classes for a full list of available attributes.Here is an example of how to get contents of all files in an archive:	archive := OS.Zip.Archive filename: 'archive.zip'.	[ archive entries collect: [ :each | each contents ] ] ensure: [ archive close ]Here is how to access contents of the last file in an archive as a stream:	archive := OS.Zip.Archive filename: 'archive.zip'.	[ archive entries last readStream upToEnd ] ensure: [ archive close ]Both archives and entries understand message #extractTo: which takes a directory (String or Filename) as an argument, and extract the entire contents of the receiver into that directory.	(OS.Zip.Archive filename: 'archive.zip') extractTo: '.'	"The archive is closed automatically."	archive := OS.Zip.Archive filename: 'archive.zip'.	[ archive entries last extractTo: '.' ] ensure: [ archive close ]The directory structures embedded in the archive will be respected and reconstructed as needed.LIMITATIONS:- only the basic (commonly used) archiving capabilities are supported, none of the extended features like 64-bit extensions, encryption, multiple volumes, etc are availableDbIdentifier: bear73DbTrace: 400340DbUsername: nrossDbVersion: 7.10 - 1DevelopmentPrerequisites: #(#(#any 'Compression-ZLib' ''))PackageName: Compression-ZipParcel: #('Compression-Zip')PrerequisiteParcels: #(#('Compression-ZLib' ''))PrintStringCache: (7.10 - 1,nross)Version: 7.10 - 1Post-Load Block: 	[:package |	''When initializers depenend on other shared variables we need to make sure the dependents are initialized after all initializers have run.''	#{OS.Zip.CompressionStreamMap} binding reinitializeValue.]Date: 6:45:02 AM April 3, 2013 --><time-stamp>From VisualWorksÂ®, Pre-Release 7.10 (mar13.5) of April 3, 2013 on April 3, 2013 at 6:45:02 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>Zip</name><environment>OS</environment><private>false</private><imports>			Core.*			External.*			OS.*			</imports><category>Net-Namespace</category><attributes><package>Compression-Zip</package></attributes></name-space><class><name>FileAlreadyExists</name><environment>OS.Zip</environment><super>Core.Warning</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Compression-Zip</package></attributes></class><comment><class-id>OS.Zip.FileAlreadyExists</class-id><body>Raised when extracting an entry into a file and the file already exists. The parameter carries the original file name. Returning from the handler will stop the extraction and leave the original file unmodified. Resuming the exception will overwrite the original file with the contents of the entry. Resuming with a different name will extract the entry using the new name. If the new name also matches an existing file, the file will be overwritten without warning.	archive := OS.Zip.Archive filename: 'archive.zip'.	[ archive entries last extractTo: '.' ] on: FileAlreadyExists do: [ :ex | ex resume: 'newName.txt' ].	archive close</body></comment><class><name>LimitedReadStream</name><environment>OS.ZLib</environment><super>Core.Stream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream readLimit </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Compression-Zip</category><attributes><package>Compression-Zip</package></attributes></class><comment><class-id>OS.ZLib.LimitedReadStream</class-id><body>Allows to read only up to a specified &lt;limit&gt; from an underlying stream. The limit is specified in terms of position in the underlying stream, e.g. if limit is 10 that means this stream will refuse to read past position 10 in the underlying stream.	(self on: 'Hello' readStream limit: 4) upToEnd	(self on: 'Hello' readStream limit: 4) nextAvailable: 10	[ (self on: 'Hello' readStream limit: 4) next: 10 ] on: IncompleteNextCountError do: [ :ex | ex parameter ]	(self on: ('Hello' readStream skip: 3; yourself) limit: 2) atEndInstance Variables:	stream	&lt;Stream&gt; the underlying stream	readLimit	&lt;Integer&gt; maximum number of elements to read</body></comment><class><name>StoredStream</name><environment>OS.Zip</environment><super>OS.ZLib.LimitedReadStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>header fileName extraField </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Compression-Zip</category><attributes><package>Compression-Zip</package></attributes></class><comment><class-id>OS.Zip.StoredStream</class-id><body>Reads files archived using the 'stored' compression method ('stored' means no compression, the file is archived as is).Instance Variables:	header	&lt;FileHeader&gt; the local file header	fileName	&lt;String&gt; the stored file name	extraField	&lt;String&gt; the extra field value</body></comment><class><name>FileHeader</name><environment>OS.Zip</environment><super>Core.UninterpretedBytes</super><private>true</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Compression-Zip</category><attributes><package>Compression-Zip</package></attributes></class><comment><class-id>OS.Zip.FileHeader</class-id><body>Helps ZipReadStream and ZipStoredStream deal with their headers.</body></comment><class><name>DeflatedStream</name><environment>OS.Zip</environment><super>OS.ZLib.InflateStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>checkCrc crc header fileName extraField </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Zlib Interface</category><attributes><package>Compression-Zip</package></attributes></class><comment><class-id>OS.Zip.DeflatedStream</class-id><body>Provides access to the decompressed contents and the adjacent attributes of a file stored in a ZIP archive. It is generally obtained from a ZIP archive entry through the #readStream method.	IMPLEMENTATION NOTES	(contains excerpts from http://www.pkware.com/documents/casestudies/APPNOTE.TXT)Overall .ZIP file format:	[local file header 1]	[file data 1]	[data descriptor 1]	. 	.	.	[local file header n]	[file data n]	[data descriptor n]	[archive decryption header] 	[archive extra data record] 	[central directory]	[zip64 end of central directory record]	[zip64 end of central directory locator] 	[end of central directory record]The stream reads the [local file header] and is then ready to decompress the [file data]. No support for [data descriptor] yet.  A.  Local file header:	local file header signature	4 bytes  (0x04034b50)	version needed to extract		2 bytes	general purpose bit flag		2 bytes	compression method			2 bytes	last mod file time				2 bytes	last mod file date				2 bytes	crc-32						4 bytes	compressed size				4 bytes	uncompressed size			4 bytes	file name length				2 bytes	extra field length				2 bytes	file name					(variable size)	extra field					(variable size)  B.  File dataImmediately following the local header for a file is the compressed or stored data for the file. The series of [local file header][file data][data descriptor] repeats for each file in the .ZIP archive.   C.  Data descriptor:	crc-32					4 bytes	compressed size			4 bytes	uncompressed size		4 bytesThis descriptor exists only if bit 3 of the general purpose bit flag is set (see below).  It is byte aligned and immediately follows the last byte of compressed data. This descriptor is used only when it was not possible to seek in the output .ZIP file, e.g., when the output .ZIP file was standard output or a non-seekable device.  For ZIP64(tm) format archives, the compressed and uncompressed sizes are 8 bytes each.When compressing files, compressed and uncompressed sizes  should be stored in ZIP64 format (as 8 byte values) when a  files size exceeds 0xFFFFFFFF.   However ZIP64 format may be used regardless of the size of a file.  When extracting, if  the zip64 extended information extra field is present for  the file the compressed and uncompressed sizes will be 8 byte values.  Although not originally assigned a signature, the value  0x08074b50 has commonly been adopted as a signature value  for the data descriptor record.  Implementers should be  aware that ZIP files may be encountered with or without this  signature marking data descriptors and should account for either case when reading ZIP files to ensure compatibility. When writing ZIP files, it is recommended to include the signature value marking the data descriptor record.  When the signature is used, the fields currently defined for the data descriptor record will immediately follow the signature.An extensible data descriptor will be released in a future version of this APPNOTE.  This new record is intended to resolve conflicts with the use of this record going forward, and to provide better support for streamed file processing.When the Central Directory Encryption method is used, the data descriptor record is not required, but may be used.  If present, and bit 3 of the general purpose bit field is set to indicate its presence, the values in fields of the data descriptor record should be set to binary zeros.Instance Variables:	checkCrc	&lt;Boolean&gt; should we perform CRC checking on the contents during decompression	crc	&lt;Integer&gt; running CRC value	header	&lt;FileHeader&gt; the local file header	fileName	&lt;String&gt; the stored file name	extraField	&lt;String&gt; the extra field value</body></comment><class><name>Archive</name><environment>OS.Zip</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream directory entries comment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Zlib Interface</category><attributes><package>Compression-Zip</package></attributes></class><comment><class-id>OS.Zip.Archive</class-id><body>Represents a single ZIP archive (e.g. a .zip file), providing access to global archive attributes and all archive entries. There's one entry for each file in the archive.	IMPLEMENTATION NOTES	(contains excerpts from http://www.pkware.com/documents/casestudies/APPNOTE.TXT)Overall .ZIP file format:	[local file header 1]	[file data 1]	[data descriptor 1]	. 	.	.	[local file header n]	[file data n]	[data descriptor n]	[archive decryption header] 	[archive extra data record] 	[central directory]	[zip64 end of central directory record]	[zip64 end of central directory locator] 	[end of central directory record]An archive instance is built from the last section in the file, [end of central directory record], containing the metadata associated with the archive as a whole and then initialized with entries from the central directory section (see ZipArchiveEntry for details on that).I.  End of central directory record:	end of central dir signature    4 bytes  (0x06054b50)	number of this disk             2 bytes	number of the disk with the	start of the central directory  2 bytes	total number of entries in the	central directory on this disk  2 bytes	total number of entries in	the central directory           2 bytes	size of the central directory   4 bytes	offset of start of central	directory with respect to	the starting disk number        4 bytes	.ZIP file comment length        2 bytes	.ZIP file comment       (variable size)Instance Variables:	stream	&lt;ReadStream&gt; binary readable, positionable stream containing the .ZIP archive	directory	&lt;UninterpretedBytes&gt; the central directory of the archive	entries	&lt;Array&gt; all the archive entries	comment	&lt;String&gt; optional archive comment</body></comment><class><name>ArchiveEntry</name><environment>OS.Zip</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream header fileName extraField comment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Zlib Interface</category><attributes><package>Compression-Zip</package></attributes></class><comment><class-id>OS.Zip.ArchiveEntry</class-id><body>Encapsulates a single file entry in a Zip file's central directory structure and provides access to the corresponding file.	IMPLEMENTATION NOTES	(contains excerpts from http://www.pkware.com/documents/casestudies/APPNOTE.TXT)Overall .ZIP file format:	[local file header 1]	[file data 1]	[data descriptor 1]	. 	.	.	[local file header n]	[file data n]	[data descriptor n]	[archive decryption header] 	[archive extra data record] 	[central directory]	[zip64 end of central directory record]	[zip64 end of central directory locator] 	[end of central directory record]An entry represents a single entry in archive's [central directory].F.  Central directory structure:      [file header 1]      .      .      .       [file header n]      [digital signature]       File header:        central file header signature   4 bytes  (0x02014b50)        version made by                 2 bytes        version needed to extract       2 bytes        general purpose bit flag        2 bytes        compression method              2 bytes        last mod file time              2 bytes        last mod file date              2 bytes        crc-32                          4 bytes        compressed size                 4 bytes        uncompressed size               4 bytes        file name length                2 bytes        extra field length              2 bytes        file comment length             2 bytes        disk number start               2 bytes        internal file attributes        2 bytes        external file attributes        4 bytes        relative offset of local header 4 bytes        file name (variable size)        extra field (variable size)        file comment (variable size)      Digital signature:        header signature                4 bytes  (0x05054b50)        size of data                    2 bytes        signature data (variable size)With the introduction of the Central Directory Encryption feature in version 6.2 of this specification, the Central Directory Structure may be stored both compressed and encrypted. Although not required, it is assumed when encrypting the Central Directory Structure, that it will be compressed for greater storage efficiency.  Information on the Central Directory Encryption feature can be found in the section describing the Strong Encryption Specification. The Digital Signature record will be neither compressed nor encrypted.Instance Variables:	stream	&lt;ReadStream&gt; binary, positionable read stream containing the ZIP archive	header	&lt;UninterpretedBytes&gt; the fixed contents of the header	fileName	&lt;String&gt; the name of the file	extraField	&lt;String&gt; extra field	comment	&lt;String&gt; optional file comment</body></comment><shared-variable><name>Reduced4</name><environment>OS.Zip</environment><private>false</private><constant>true</constant><category>compression method codes</category><initializer>		"Compression method code."		^5</initializer><attributes><package>Compression-Zip</package></attributes></shared-variable><shared-variable><name>CompressionStreamMap</name><environment>OS.Zip</environment><private>false</private><constant>false</constant><category>miscellanous constants</category><initializer>["Maps compression method codes to stream classes that implement those methods."	"The error handling below is just to work around current limitations of Shared Variable initialization. It will go away as soon as that is improved. All the relevant bits of this initializer are inside the first block below. You can safely ignore the rest."	Dictionary new		at: Stored put: StoredStream;		at: Deflated put: DeflatedStream;		yourself] on: SubscriptOutOfBoundsError do: [:ex | ex index isNil			ifTrue: ["This happens if the shared variables that this depends on were not initialized yet"					ex return: Dictionary new]			ifFalse: [ex pass					"Something else is wrong"]]</initializer><attributes><package>Compression-Zip</package></attributes></shared-variable><shared-variable><name>Reduced1</name><environment>OS.Zip</environment><private>false</private><constant>true</constant><category>compression method codes</category><initializer>		"Compression method code."		^2</initializer><attributes><package>Compression-Zip</package></attributes></shared-variable><shared-variable><name>Reduced2</name><environment>OS.Zip</environment><private>false</private><constant>true</constant><category>compression method codes</category><initializer>		"Compression method code."		^3</initializer><attributes><package>Compression-Zip</package></attributes></shared-variable><shared-variable><name>PKImploded</name><environment>OS.Zip</environment><private>false</private><constant>true</constant><category>compression method codes</category><initializer>		"Compression method code."		^10</initializer><attributes><package>Compression-Zip</package></attributes></shared-variable><shared-variable><name>Shrunk</name><environment>OS.Zip</environment><private>false</private><constant>true</constant><category>compression method codes</category><initializer>		"Compression method code."		^1</initializer><attributes><package>Compression-Zip</package></attributes></shared-variable><shared-variable><name>Imploded</name><environment>OS.Zip</environment><private>false</private><constant>true</constant><category>compression method codes</category><initializer>		"Compression method code."		^6</initializer><attributes><package>Compression-Zip</package></attributes></shared-variable><shared-variable><name>EndCentralDirectorySignature</name><environment>OS.Zip</environment><private>false</private><constant>true</constant><category>miscellanous constants</category><initializer>"Marks the beginging of the final directory section"	#[16r50 16r4b 16r05 16r06]</initializer><attributes><package>Compression-Zip</package></attributes></shared-variable><shared-variable><name>CentralFileHeaderSignature</name><environment>OS.Zip</environment><private>false</private><constant>false</constant><category>miscellanous constants</category><initializer>"Marks the begining of a directory entry"	#[16r50 16r4b 16r01 16r02]</initializer><attributes><package>Compression-Zip</package></attributes></shared-variable><shared-variable><name>Deflated</name><environment>OS.Zip</environment><private>false</private><constant>true</constant><category>compression method codes</category><initializer>		"Compression method code."		^8</initializer><attributes><package>Compression-Zip</package></attributes></shared-variable><shared-variable><name>Stored</name><environment>OS.Zip</environment><private>false</private><constant>true</constant><category>compression method codes</category><initializer>		"Compression method code."		^0</initializer><attributes><package>Compression-Zip</package></attributes></shared-variable><shared-variable><name>Reduced3</name><environment>OS.Zip</environment><private>false</private><constant>true</constant><category>compression method codes</category><initializer>		"Compression method code."		^4</initializer><attributes><package>Compression-Zip</package></attributes></shared-variable><shared-variable><name>LocalFileHeaderSignature</name><environment>OS.Zip</environment><private>false</private><constant>true</constant><category>miscellanous constants</category><initializer>"Marks the begining of a local file header"	#[16r50 16r4b 16r03 16r04]</initializer><attributes><package>Compression-Zip</package></attributes></shared-variable><methods><class-id>OS.Zip.FileAlreadyExists</class-id> <category>printing</category><body package="Compression-Zip">defaultMessageText	^(#FileAlreadyExists1s &lt;&lt; #dialogs &gt;&gt; 'File &lt;1s&gt; already exists.') expandMacrosWith: parameter</body></methods><methods><class-id>OS.Zip.FileAlreadyExists</class-id> <category>constants</category><body package="Compression-Zip">defaultResumeValue	^parameter</body></methods><methods><class-id>OS.Zip.FileAlreadyExists</class-id> <category>private - actions</category><body package="Compression-Zip">defaultAction	| replacement question |	question :=		(#WhatFileNameShouldBeUsed1s &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt;&lt;n&gt;What file name should be used?')			expandMacrosWith: self description.	replacement := UI.Dialog request: question initialAnswer: parameter.	^replacement isEmpty ifTrue: [nil] ifFalse: [replacement]</body></methods><methods><class-id>OS.ZLib.LimitedReadStream</class-id> <category>initialize-release</category><body package="Compression-Zip">on: sourceStream limit: limit	stream := sourceStream.	readLimit := limit</body></methods><methods><class-id>OS.ZLib.LimitedReadStream</class-id> <category>testing</category><body package="Compression-Zip">atEnd	^stream position &gt;= readLimit  or: [ stream atEnd ]</body><body package="Compression-Zip">isReadable	^true</body><body package="Compression-Zip">isWritable	"Answer whether the stream implements #nextPut:."	^false</body></methods><methods><class-id>OS.ZLib.LimitedReadStream</class-id> <category>accessing</category><body package="Compression-Zip">next	self atEnd ifTrue: [EndOfStreamNotification raiseRequestFrom: self].	^stream next</body><body package="Compression-Zip">next: anInteger into: aSequenceableCollection startingAt: startIndex 	"Store the next anInteger elements of the receiver into aSequenceableCollection 	starting at startIndex in aSequenceableCollection. Answer aSequenceableCollection."	| amount |	amount := anInteger min: (readLimit - stream position).	stream next: amount into: aSequenceableCollection startingAt: startIndex.	amount &lt; anInteger ifTrue: [ IncompleteNextCountError raiseRequestWith: amount ].	^aSequenceableCollection</body></methods><methods><class-id>OS.ZLib.LimitedReadStream</class-id> <category>private</category><body package="Compression-Zip">contentsSpecies	^stream contentsSpecies</body></methods><methods><class-id>OS.ZLib.LimitedReadStream class</class-id> <category>instance creation</category><body package="Compression-Zip">on: sourceStream limit: limit	^self basicNew on: sourceStream limit: limit</body></methods><methods><class-id>OS.Zip.StoredStream</class-id> <category>accessing</category><body package="Compression-Zip">compressedSize	^header compressedSize</body><body package="Compression-Zip">compressionMethod	^header compressionMethod</body><body package="Compression-Zip">crc32	^header crc32</body><body package="Compression-Zip">extraField	^extraField</body><body package="Compression-Zip">extraFieldLength	^header extraFieldLength</body><body package="Compression-Zip">fileName	^fileName</body><body package="Compression-Zip">fileNameLength	^header fileNameLength</body><body package="Compression-Zip">generalBitFlags	^header generalBitFlags</body><body package="Compression-Zip">lastModificationDate	^header lastModificationDate</body><body package="Compression-Zip">lastModificationTime	^header lastModificationTime</body><body package="Compression-Zip">uncompressedSize	^header uncompressedSize</body><body package="Compression-Zip">versionToExtract	^header versionToExtract</body></methods><methods><class-id>OS.Zip.StoredStream</class-id> <category>initialize-release</category><body package="Compression-Zip">on: sourceStream	(sourceStream next: 4) ~= LocalFileHeaderSignature ifTrue: [^self error: 'Local file header signature not found.'].	header := (sourceStream next: 26) changeClassTo: FileHeader.	fileName := (sourceStream next: header fileNameLength) asString.	extraField := (sourceStream next: header extraFieldLength) asString.	super on: sourceStream limit: sourceStream position + header uncompressedSize</body></methods><methods><class-id>OS.Zip.StoredStream</class-id> <category>debugging</category><body package="Compression-Zip">inspectorExtraAttributes	^#{Tools.Trippy.TextAttribute}		ifDefinedDo: [ :class |			OrderedCollection new				add: (class label: 'compressed size' text: self compressedSize printString);				add: (class label: 'uncompressed size' text: self uncompressedSize printString);				add: (class label: 'modification time' text: self lastModificationTime printString);				add: (class label: 'modification date' text: self lastModificationDate printString);				add: (class label: 'compression method' text: self compressionMethod printString);				add: (class label: 'version needed to extract' text: self versionToExtract printString);				add: (class label: 'CRC-32' text: self crc32 printString);				add: (class label: 'flags' text: self generalBitFlags printString);				yourself ]		elseDo: [ Array new ]</body></methods><methods><class-id>OS.Zip.StoredStream class</class-id> <category>instance </category><body package="Compression-Zip">on: sourceStream	^self basicNew on: sourceStream</body><body package="Compression-Zip">on: sourceStream limit: limit	^self error: 'The limit will be read from the stream header, use #on: instead!'</body></methods><methods><class-id>OS.Zip.FileHeader</class-id> <category>accessing</category><body package="Compression-Zip">compressedSize	^self unsignedLongAt: 15 bigEndian: false</body><body package="Compression-Zip">compressionMethod	^self unsignedShortAt: 5 bigEndian: false</body><body package="Compression-Zip">crc32	^self unsignedLongAt: 11 bigEndian: false</body><body package="Compression-Zip">extraFieldLength	^self unsignedShortAt: 25 bigEndian: false</body><body package="Compression-Zip">fileNameLength	^self unsignedShortAt: 23 bigEndian: false</body><body package="Compression-Zip">generalBitFlags	^self unsignedShortAt: 3 bigEndian: false</body><body package="Compression-Zip">lastModificationDate	^Archive dateFromDOS: (self unsignedShortAt: 9 bigEndian: false)</body><body package="Compression-Zip">lastModificationTime	^Archive timeFromDOS: (self unsignedShortAt: 7 bigEndian: false)</body><body package="Compression-Zip">uncompressedSize	^self unsignedLongAt: 19 bigEndian: false</body><body package="Compression-Zip">versionToExtract	^self unsignedShortAt: 1 bigEndian: false</body></methods><methods><class-id>OS.Zip.DeflatedStream</class-id> <category>accessing</category><body package="Compression-Zip">checkCrc: aBoolean	checkCrc := aBoolean</body><body package="Compression-Zip">compressedSize	^header compressedSize</body><body package="Compression-Zip">compressionMethod	^header compressionMethod</body><body package="Compression-Zip">crc	^crc</body><body package="Compression-Zip">crc32	^header crc32</body><body package="Compression-Zip">extraField	^extraField</body><body package="Compression-Zip">extraFieldLength	^header extraFieldLength</body><body package="Compression-Zip">fileName	^fileName</body><body package="Compression-Zip">fileNameLength	^header fileNameLength</body><body package="Compression-Zip">generalBitFlags	^header generalBitFlags</body><body package="Compression-Zip">lastModificationDate	^header lastModificationDate</body><body package="Compression-Zip">lastModificationTime	^header lastModificationTime</body><body package="Compression-Zip">uncompressedSize	^header uncompressedSize</body><body package="Compression-Zip">versionToExtract	^header versionToExtract</body></methods><methods><class-id>OS.Zip.DeflatedStream</class-id> <category>private</category><body package="Compression-Zip">checkHeader	(sourceStream next: 4) ~= LocalFileHeaderSignature ifTrue: [^self error: 'Local file header signature not found.'].	header := (sourceStream next: 26) changeClassTo: FileHeader.	fileName := (sourceStream next: self fileNameLength) asString.	extraField := (sourceStream next: self extraFieldLength) asString.	(checkCrc := self crc32 isZero not) ifTrue: [		crc := interface cCrc32: 16rffffffff buffer: 0 length: 0 ]</body><body package="Compression-Zip">nextBuffer	| notAtEnd |	notAtEnd := super nextBuffer.	checkCrc ifTrue: [		readLimit &gt; 0 ifTrue: [crc := interface cCrc32: crc buffer: collection length: readLimit].		notAtEnd ifFalse: [			crc ~= self crc32 ifTrue: [self error: 'file crc error'].			interface total_out  ~= self uncompressedSize ifTrue: [self error: 'file length error']] ].	^notAtEnd</body></methods><methods><class-id>OS.Zip.DeflatedStream</class-id> <category>debugging</category><body package="Compression-Zip">inspectorExtraAttributes	^#{Tools.Trippy.TextAttribute}		ifDefinedDo: [ :class |			OrderedCollection new				add: (class label: 'compressed size' text: self compressedSize printString);				add: (class label: 'uncompressed size' text: self uncompressedSize printString);				add: (class label: 'modification time' text: self lastModificationTime printString);				add: (class label: 'modification date' text: self lastModificationDate printString);				add: (class label: 'compression method' text: self compressionMethod printString);				add: (class label: 'version needed to extract' text: self versionToExtract printString);				add: (class label: 'CRC-32' text: self crc32 printString);				add: (class label: 'flags' text: self generalBitFlags printString);				yourself ]		elseDo: [ Array new ]</body></methods><methods><class-id>OS.Zip.Archive</class-id> <category>accessing</category><body package="Compression-Zip">comment	^comment</body><body package="Compression-Zip">commentLength	^directory unsignedShortAt: 21 bigEndian: false</body><body package="Compression-Zip">directoryDiskNumber	^directory unsignedShortAt: 7 bigEndian: false</body><body package="Compression-Zip">directoryOffset	^directory unsignedLongAt: 17 bigEndian: false</body><body package="Compression-Zip">directorySize	^directory unsignedLongAt: 13 bigEndian: false</body><body package="Compression-Zip">diskNumber	^directory unsignedShortAt: 5 bigEndian: false</body><body package="Compression-Zip">entries	^entries</body><body package="Compression-Zip">totalEntries	^directory unsignedShortAt: 11 bigEndian: false</body><body package="Compression-Zip">totalEntriesOnDisk	^directory unsignedShortAt: 9 bigEndian: false</body></methods><methods><class-id>OS.Zip.Archive</class-id> <category>debugging</category><body package="Compression-Zip">inspectorExtraAttributes	^#{Tools.Trippy.TextAttribute}		ifDefinedDo: [ :class |			OrderedCollection new				add: (class label: 'total number of entries' text: self totalEntries printString);				add: (class label: 'total number of entries on disk' text: self totalEntriesOnDisk printString);				add: (class label: 'directory size' text: self directorySize printString);				add: (class label: 'disk number' text: self diskNumber printString);				add: (class label: 'directory disk number' text: self directoryDiskNumber printString);				add: (class label: 'directory offset' text: self directoryOffset printString);				yourself ]		elseDo: [ Array new ]</body></methods><methods><class-id>OS.Zip.Archive</class-id> <category>initialize-release</category><body package="Compression-Zip">on: aStream	stream := aStream.	stream reset.	(stream next: 4) ~= LocalFileHeaderSignature ifTrue: [^self error: 'Not a zip file - invalid signature'].	"The following can be made a good bit faster by scanning smaller blocks for the signature.  But this is the easiest for now..."	stream position: (0 max: (stream size - self class maxEndCentralDirectorySize)).	(stream skipToAll: EndCentralDirectorySignature)		isNil ifTrue: [^self error: 'End of central directory signature not found'].	directory := (stream next: 22) changeClassTo: UninterpretedBytes.	(self diskNumber ~= 0	or: [ self directoryDiskNumber ~= 0	or: [ self totalEntriesOnDisk ~= self totalEntries ] ]	) ifTrue: [^self error: 'Multiple disk archives are not currently supported.'].	comment := (stream next: self commentLength) asString.	entries := Array new: self totalEntries.	stream position: self directoryOffset.	1 to: self totalEntries do: [ :i |		entries at: i put: (ArchiveEntry on: stream) ]</body></methods><methods><class-id>OS.Zip.Archive</class-id> <category>services</category><body package="Compression-Zip">close	stream close</body><body package="Compression-Zip">extractTo: targetDirectory"Extract all files from this archive into the provided directory. The directory must already exist. Note that for convenience this method will automatically close the archive.	directory	&lt;Filename|String&gt; an existing directory to extract into"	self entries do: [ :entry | entry extractTo: targetDirectory ].	self close</body></methods><methods><class-id>OS.Zip.Archive class</class-id> <category>DOS utility</category><body package="Compression-Zip">dateFromDOS: aDOSFormattedDate	"Given a date in DOS 2-byte format, answer an instance of Date."	^Date		newDay: (aDOSFormattedDate bitAnd: 16r1F)		monthNumber: ((aDOSFormattedDate bitShift: -5) bitAnd: 16rF)		year: 1980 + (aDOSFormattedDate bitShift: -9)</body><body package="Compression-Zip">timeFromDOS: aDOSFormattedTime	"Given a time in DOS 2-byte format, answer an instance of Time."	^Time		fromSeconds: (((aDOSFormattedTime bitShift: -11) * 60 * 60)		"hours"						+ (((aDOSFormattedTime bitShift: -5) bitAnd: 16r3F) * 60)		"minutes"						+ (aDOSFormattedTime bitAnd: 16r1F))		"seconds"</body></methods><methods><class-id>OS.Zip.Archive class</class-id> <category>instance creation</category><body package="Compression-Zip">filename: aFilename	| stream |	stream := aFilename asFilename readStream binary.	^self on: stream</body><body package="Compression-Zip">on: aStream	^self new on: aStream</body></methods><methods><class-id>OS.Zip.Archive class</class-id> <category>constants</category><body package="Compression-Zip">maxEndCentralDirectorySize	"Maximum size of the 'end of central directory record' is the fixed size plus the maximum variable comment size.  Since the comment size is defined in 2 bytes, it can't be greater than 65535."	^65535 + self minEndCentralDirectorySize</body><body package="Compression-Zip">minEndCentralDirectorySize	^22</body></methods><methods><class-id>OS.Zip.ArchiveEntry</class-id> <category>services</category><body package="Compression-Zip">contents	^self readStream next: self uncompressedSize</body><body package="Compression-Zip">extractTo: directory"Extract this file into the provided directory. The directory must already exist. Note that this method will not automatically close the archive (assuming other entries might be extracted too).	directory	&lt;Filename|String&gt; an existing directory to extract into"	| path last file buffer source |	path := (self fileName tokensBasedOn: $/).	self isDirectory ifFalse: [		last := path last.		path := path copyFrom: 1 to: path size - 1 ].	file := path inject: directory asFilename		into: [ :parent :name || filename |			filename := parent construct: name.			filename exists ifFalse: [ filename makeDirectory ].			filename ].	self isDirectory ifTrue: [ ^self "we're done" ].	file := file construct: last.	file exists ifTrue: [		last := (FileAlreadyExists raiseRequestWith: last) ifNil: [ ^self ].		file := file directory construct: last ].	file := file writeStream binary; yourself.	[	buffer := ByteArray new: 4096.		source := self readStream.		[ source atEnd ] whileFalse: [			file	next: (source nextAvailable: buffer size into: buffer startingAt: 1)				putAll: buffer				startingAt: 1 ]	] ensure: [ file close ]</body><body package="Compression-Zip">readStream	"Decompress the compressed file that I refer to and answer it as a single ByteArray."	stream position: self offset.	^(self streamClassFor: self compressionMethod) on: stream</body></methods><methods><class-id>OS.Zip.ArchiveEntry</class-id> <category>testing</category><body package="Compression-Zip">isDirectory	^self fileName last = $/</body></methods><methods><class-id>OS.Zip.ArchiveEntry</class-id> <category>initialize-release</category><body package="Compression-Zip">on: aStream	"Assume that aStream is pre-positioned, ready to load up a file header from the directory."	stream := aStream.	(aStream next: 4) ~= CentralFileHeaderSignature		ifTrue: [^self error: 'Central file header signature not found.'].	header := (stream next: 42) changeClassTo: UninterpretedBytes.	self diskNumber ~= 0 ifTrue: [self error: 'Multi-part archives not currently supported.'].	fileName := (aStream next: self fileNameLength) asString.	extraField := (aStream next: self extraFieldLength) asString.	comment := (aStream next: self commentLength) asString.</body></methods><methods><class-id>OS.Zip.ArchiveEntry</class-id> <category>debugging</category><body package="Compression-Zip">inspectorExtraAttributes	^#{Tools.Trippy.TextAttribute}		ifDefinedDo: [ :class |			OrderedCollection new				add: (class label: 'compressed size' text: self compressedSize printString);				add: (class label: 'uncompressed size' text: self uncompressedSize printString);				add: (class label: 'modification time' text: self lastModificationTime printString);				add: (class label: 'modification date' text: self lastModificationDate printString);				add: (class label: 'compression method' text: self compressionMethod printString);				add: (class label: 'made by version' text: self madeByVersion printString);				add: (class label: 'version needed to extract' text: self versionToExtract printString);				add: (class label: 'disk number' text: self diskNumber printString);				add: (class label: 'CRC-32' text: self crc32 printString);				add: (class label: 'flags' text: self generalBitFlags printString);				add: (class label: 'external attributes' text: self externalAttributes printString);				add: (class label: 'internal attributes' text: self internalAttributes printString);				yourself ]		elseDo: [ Array new ]</body></methods><methods><class-id>OS.Zip.ArchiveEntry</class-id> <category>accessing</category><body package="Compression-Zip">commentLength	^header unsignedShortAt: 29 bigEndian: false</body><body package="Compression-Zip">compressedSize	^header unsignedLongAt: 17 bigEndian: false</body><body package="Compression-Zip">compressionMethod	^header unsignedShortAt: 7 bigEndian: false</body><body package="Compression-Zip">crc32	^header unsignedLongAt: 13 bigEndian: false</body><body package="Compression-Zip">diskNumber	^header unsignedShortAt: 31 bigEndian: false</body><body package="Compression-Zip">externalAttributes	^header unsignedLongAt: 35 bigEndian: false</body><body package="Compression-Zip">extraField	^extraField</body><body package="Compression-Zip">extraFieldLength	^header unsignedShortAt: 27 bigEndian: false</body><body package="Compression-Zip">fileName	^fileName</body><body package="Compression-Zip">fileNameLength	^header unsignedShortAt: 25 bigEndian: false</body><body package="Compression-Zip">generalBitFlags	^header unsignedShortAt: 5 bigEndian: false</body><body package="Compression-Zip">internalAttributes	^header unsignedShortAt: 33 bigEndian: false</body><body package="Compression-Zip">lastModificationDate	^Archive dateFromDOS: (header unsignedShortAt: 11 bigEndian: false)</body><body package="Compression-Zip">lastModificationTime	^Archive timeFromDOS: (header unsignedShortAt: 9 bigEndian: false)</body><body package="Compression-Zip">madeByVersion	^header unsignedShortAt: 1 bigEndian: false</body><body package="Compression-Zip">offset	^header unsignedLongAt: 39 bigEndian: false</body><body package="Compression-Zip">uncompressedSize	^header unsignedLongAt: 21 bigEndian: false</body><body package="Compression-Zip">versionToExtract	^header unsignedShortAt: 3 bigEndian: false</body></methods><methods><class-id>OS.Zip.ArchiveEntry</class-id> <category>printing</category><body package="Compression-Zip">printOn: aStream	super printOn: aStream.	aStream nextPut: $(; nextPutAll: self fileName displayString; nextPut: $).</body></methods><methods><class-id>OS.Zip.ArchiveEntry</class-id> <category>private</category><body package="Compression-Zip">streamClassFor: method	^CompressionStreamMap		at: self compressionMethod		ifAbsent: [ self error: 'Unable to handle compression method ', self compressionMethod printString ]</body></methods><methods><class-id>OS.Zip.ArchiveEntry class</class-id> <category>instance creation</category><body package="Compression-Zip">on: aStream	^self new on: aStream</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Stream</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private IOConstants.*			</imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>Warning</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>InflateStream</name><environment>OS.ZLib</environment><super>Core.ReadStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>inputBuffer inputLimit interface sourceStream superPosition eof </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Compression-ZLib</category><attributes><package>Compression-ZLib</package></attributes></class><class><name>UninterpretedBytes</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class></st-source>