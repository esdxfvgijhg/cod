<?xml version="1.0"?><st-source><!-- Name: Tools-ChangesNotice: Copyright 1999-2017 Cincom Systems, Inc.  All rights reserved.Comment: Tools-Changes provides the tools for dealing with changes and change files.   These tools are:ChangeList	Manages a sequence of Change objects taken from a number of source files or the system itself.ChangeSetManager	Allows one to create and manage NamedChangeSets. OverrideList	Manage any overridden definitions that are in the imageOnce loaded these tools can be opened from the VisualLauncher.DbIdentifier: bear73DbTrace: 501803DbUsername: willowDbVersion: 8.3 - 2PackageName: Tools-ChangesParcel: #('Tools-Changes')ParcelName: Tools-ChangesPrintStringCache: (8.3 - 2,willow)Version: 8.3 - 2Date: 3:26:51 PM June 30, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (jun17.4) of June 23, 2017 on June 30, 2017 at 3:26:51 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>AbstractChangeList</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value listName changes selectionIndex list filter removed filterList filterKey changeDict checkSystem fieldList selectionInList verticalConflicts differencesMode classesDistinct menuBar menus </inst-vars><class-inst-vars></class-inst-vars><imports>			XML.MalformedSignal			</imports><category>Tools-Changes</category><attributes><package>Tools-Changes</package></attributes></class><comment><class-id>Tools.AbstractChangeList</class-id><body>Class AbstractChangeList is the abstract superclass for applications that manage a sequence of Change objects.  These Change objects are taken from a number of source files and/or the system itself.  It can perform numerous useful operations on these change objects such as- various conflict analyses on its changes, comparing external code against the system, or identifying conflicts amongst a set of sources- organizing a set fo changes for producing a file-out- crash recovery, by reading in the unsaved changes from the changes fileInstance Variables:	value &lt;String&gt;						the text of the currently selected change, or an empty string	listName &lt;String&gt;					label for browser, the set of files that have been read 	changes &lt;List of: Change&gt;		the underlying collection of changes 	selectionIndex	&lt;Integer&gt;			currently selected change, or 0 if none 	list &lt;List of: Change&gt;				filtered collection of changes 	filter &lt;BlockClosure&gt;				filter predicate to select which changes are displayed in the list	removed &lt;Set&gt;						changes marked for removal from the list (displayed struck-out in the list)	filterList &lt;(Array of: Symbol) | nil&gt;		filters (messages to Change) that are used to select subsets of the changes										to display in the list.	filterKey &lt;Change&gt;					the change supplying the key value(s) for the filter(s) 	changeDict &lt;Dictionary from: Symbol to: (OrderedCollection of: Change)&gt;										cross-index for conflict detection 	checkSystem &lt;Symbol | nil&gt;			symbol specifying whether conflicts are checked against the system or										internally amongst the current sequence of changes.  If nil, conflicts are										checked amongst the receiver's changes.  Otherwise changes are checked										against the corresponding system code.  In this case, checkSystem is #exact										for a textual check or #code for a code check (which ignores comments).	fieldList &lt;nil | (Array of: Symbol)&gt;		individual field options	selectionInList &lt;SelectionInList&gt;		UI wrapper for list used to control entry redisplay etc.	verticalConflicts &lt;Boolean&gt;			variable which decides the layout of the text and conflict views.										If verticalConflicts is true then these views are side-by-side,										and if false, these views are top-by-bottom. 	differencesMode &lt;Symbol&gt;			either #code for comparing changes code token by code token, ignoring										comments, or #exact for comparing changes textually, including comments	classesDistinct &lt;Boolean&gt;				variable controlling matching via the 'class' button and 'Find class...'										dialog.  If classesDistinct is true then class matching is "exact".  If false then										class and metaclass changes are equivalent and included.  classesDistinct is										initially false.	menuBar &lt;Menu&gt;					the menu bar.Class Variables:	ChangeListYellowButtonMenu	&lt;Menu&gt;			the ChangeList's Operate pop-up menu	EmphasizeDifferences	&lt;Boolean&gt;		if true then entries in the list that are the same as the system are											shown in italics, and those that are different are emboldened.  If false,											then all entries are in normal face.	DifferencesMode &lt;Symbol&gt;			Default value for differencesMode above.	VerticalConflicts			&lt;Boolean&gt;		default value of verticalConflicts above</body></comment><class><name>OverrideList</name><environment>Tools</environment><super>Tools.AbstractChangeList</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Changes</category><attributes><package>Tools-Changes</package></attributes></class><comment><class-id>Tools.OverrideList</class-id><body>OverrideList displays overridden methods in the conventional ChangeList format that one might see when opening up a ChangeList on a file.</body></comment><class><name>ChangeSetManager</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>listModel listMenu menuBar currentSetIcon </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Changes</category><attributes><package>Tools-Changes</package></attributes></class><comment><class-id>Tools.ChangeSetManager</class-id><body>ChangeSetManager is the application for managing the current list of change sets held by the NamedChangedSet class. Instance Variables:	listModel	&lt;SelectionInList&gt;  UI widget on the list of change sets	listMenu	&lt;ValueHolder on: Menu&gt;  value holder for the list menu	menuBar	&lt;Menu&gt;  the menu bar menu	currentSetIcon &lt;Image&gt; The icon used be the dataset to indicate the current change set.</body></comment><class><name>ChangeEditor</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>source classList methodList destinationList text changeType classRemove classRename classComment classOrganize mode menus </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Changes</category><attributes><package>Tools-Changes</package></attributes></class><class><name>ChangeList</name><environment>Tools</environment><super>Tools.AbstractChangeList</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Changes</category><attributes><package>Tools-Changes</package></attributes></class><comment><class-id>Tools.ChangeList</class-id><body>ChangeList manages a sequence of Change objects taken from a number of source files or the system itself.</body></comment><shared-variable><name>EmphasizeDifferences</name><environment>Tools.AbstractChangeList</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><initializer>false</initializer><attributes><package>Tools-Changes</package></attributes></shared-variable><shared-variable><name>DifferencesMode</name><environment>Tools.AbstractChangeList</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><initializer>#exact</initializer><attributes><package>Tools-Changes</package></attributes></shared-variable><shared-variable><name>VerticalConflicts</name><environment>Tools.AbstractChangeList</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><initializer>true</initializer><attributes><package>Tools-Changes</package></attributes></shared-variable><methods><class-id>Tools.AbstractChangeList</class-id> <category>menu messages</category><body package="Tools-Changes">check	self		getWriteFilenameWithPrompt: (#TypeNameOfFileToWriteConflicts &lt;&lt; #dialogs &gt;&gt; 'Type name of file on which to write conflicts')		do: 			[:aFilename || aFile |			aFile := (aFilename withEncoding: #Source) writeStream. 			[Cursor execute showWhile: [self checkWithSystem: false].			self reportConflictsOn: aFile]				ensure: [aFile close]]</body><body package="Tools-Changes">checkWithSystem	self		getWriteFilenameWithPrompt: (#TypeNameOfFileToWriteConflicts &lt;&lt; #dialogs &gt;&gt; 'Type name of file on which to write conflicts')		do: 			[:aFilename || aFile |			aFile := (aFilename withEncoding: #Source) writeStream. 			[Cursor execute showWhile: [self checkWithSystem: true].			self reportConflictsOn: aFile]				ensure: [aFile close]]</body><body package="Tools-Changes">copyView	"Create and schedule a list browser containing only the displayed items 	that are not marked for removal. Accessed by choosing the menu 	command clone."	self filterCopy open</body><body package="Tools-Changes">doAll	self doFrom: 1</body><body package="Tools-Changes">doFromHere	"Replay from the current selection to the end. If there is no current	selection, replay from the top."	self doFrom: (1 max: self listIndex)</body><body package="Tools-Changes">doThis	"Replay the current selection."	Notice 		show: #ReplayingChangesDots &lt;&lt; #dialogs &gt;&gt; 'Replaying Changes...' 		while: [selectionIndex &gt; 0 ifTrue: [self doThis: selectionIndex]]</body><body package="Tools-Changes">fileIn	"File-in changes from file(s)."	self checkSystem: false; scanFilename</body><body package="Tools-Changes">fileInDifferences	"The fileIn menu item has been selected. File-in changes from file(s)	 that differ in effect to code in the system."	self checkSystem: #code; scanFilename</body><body package="Tools-Changes">fileInSourceDifferences	"The fileIn menu item has been selected. File-in changes from file(s)	 that differ in any way to code in the system."	self checkSystem: #exact; scanFilename</body><body package="Tools-Changes">fileOut	self anyToFileOut		ifFalse: [^Dialog warn: (#NoEntriesToFileOut &lt;&lt; #dialogs &gt;&gt; 'No entries to file out.')].	self		getWriteFilenameWithPrompt: (#TypeNameOfFileForWriting &lt;&lt; #dialogs &gt;&gt; 'type name of file for writing')		do: 			[:aFilename | | sfm |			sfm := SourceCodeStream write: aFilename.			[self fileOutOn: sfm]				ensure: [sfm close]]</body><body package="Tools-Changes">findClass	"Prompt and search for all changes of a given class. Select these changes"	| message |	message := classesDistinct ifTrue: [#className] ifFalse: [#nonMetaClassName].	self find: message prompt: #class filter: #className</body><body package="Tools-Changes">findProtocol	"Prompt and search for all changes of a given type. Select these changes"	self find: #category prompt: #protocol filter: #category</body><body package="Tools-Changes">findSelector	"Prompt and search for all changes of a given selector. Select these changes"	self find: #selector prompt: #selector filter: #selector</body><body package="Tools-Changes">findType	"Prompt and search for all changes of a given type. Select these changes"	self find: #type prompt: (#ChangeType &lt;&lt; #dialogs &gt;&gt; 'change type') asString filter: #type</body><body package="Tools-Changes">spawnBrowserOnSelection	"Create and schedule a browser or workspace on the selection.	 Ask the change to open a browser on its system version	 and if it declines open up a workspace on its text."	| change txt |	selectionIndex &gt; 0 ifFalse: [^self].	change := list at: selectionIndex.	change browseSystemVersionIfExists 		ifFalse: 			[ ( txt := change text ) == nil				ifTrue: [ ^Dialog warn: (#NothingToSpawn &lt;&lt; #dialogs &gt;&gt; 'Nothing to spawn') ].			ComposedTextView				open: ( ValueHolder with: txt )				label: change name			].</body><body package="Tools-Changes">spawnChangesContainingString	"Spawn a ChangeList on those changes that textually contain (or match) a given string."	| matches |	matches := self selectMatching: (#Spawn &lt;&lt; #labels &gt;&gt; 'Spawn') asString fromRemoved: false.	matches key isEmpty ifTrue: [^self].	matches value isEmpty ifTrue: [^Dialog warn: (#None &lt;&lt; #dialogs &gt;&gt; 'None')].	(self class new		listName: '(', self listName, ' ', matches key, ')'		changes: matches value		removed: Set new) open</body></methods><methods><class-id>Tools.AbstractChangeList</class-id> <category>menu messages-removing</category><body package="Tools-Changes">exchangeRemoved	"Exchange the sets of removed and unremoved changes."	| addToRemoved removeFromRemoved oldSelection |	selectionIndex &gt; 0 ifTrue: [		oldSelection := list at: selectionIndex].	addToRemoved := list copyEmpty: list size.	removeFromRemoved := list copyEmpty: list size.	list do: [:change|		((removed includes: change)			ifTrue: [removeFromRemoved]			ifFalse: [addToRemoved]) add: change].	removed removeAll: removeFromRemoved; addAll: addToRemoved.	oldSelection ~~ nil ifTrue: [		selectionIndex := list indexOf: oldSelection ifAbsent: [0]].	self redisplayList</body><body package="Tools-Changes">forgetAll	"Forget all changes marked for removal, including those not displayed in the list.."	changes := changes reject: [:c | removed includes: c].	removed := IdentitySet new.	self updateList.	self makeChangesVisible</body><body package="Tools-Changes">forgetSelection	"Forget the selected change that is marked for removal."	| toBeForgotten |	toBeForgotten := self selection.	(removed includes: toBeForgotten) ifFalse: [^nil].	changes remove: toBeForgotten.	removed remove: toBeForgotten.	self updateList.	self makeChangesVisible</body><body package="Tools-Changes">forgetThese	"Forget changes marked for removal that are currently being displayed."		| toBeForgotten |	toBeForgotten := IdentitySet withAll: (list select: [:each | removed includes: each]).	changes := changes reject: [:each | toBeForgotten includes: each].	removed removeAll: toBeForgotten.	self updateList.	self makeChangesVisible</body><body package="Tools-Changes">removeAll	removed addAll: list.	self redisplayList</body><body package="Tools-Changes">removeAllAbove	"Remove all changes above the currently selected change."	selectionIndex &gt; 1 ifTrue:		[removed addAll: (list copyFrom: 1 to: selectionIndex - 1).		self redisplayList]</body><body package="Tools-Changes">removeAllBelow	"Remove all changes above the currently selected change."	(selectionIndex &gt; 0	and: [selectionIndex &lt; list size]) ifTrue:		[removed addAll: (list copyFrom: selectionIndex + 1 to: list size).		self redisplayList]</body><body package="Tools-Changes">removeChangesContainingString	"Remove those changes that textually contain (or match) a given string."	removed addAll: (self selectMatching: (#Remove &lt;&lt; #labels &gt;&gt; 'Remove') asString fromRemoved: false) value.	self redisplayList</body><body package="Tools-Changes">removeClassesNotInSystem	"Remove those changes that have no class in the system."	Cursor execute showWhile:		[removed addAll: (list select: [:change|									change isClassRelated									and: [(removed includes: change) not									and: [change classObject isNil]]])].	self redisplayList</body><body package="Tools-Changes">removeConflictsInList	"Remove all changes in the list that conflict with other changes in the list (even if they're duplicates)"	| sortedList |	Cursor wait showWhile: [		"Sort associations keyed by index to keep the sort stable."		sortedList := ((1 to: list size) collect: [:index| index -&gt; (list at: index)]) asSortedCollection: [:a1 :a2|						| c1 c2 |						c1 := a1 value.						c2 := a2 value.						c1 checkingName &lt; c2 checkingName						or: [c1 checkingName = c2 checkingName							and: [a1 key &lt;= a2 key]]]].	Cursor execute showWhile: [		| candidates |		candidates := Set new.		1 to: sortedList size do: [:index|			| change changeName sameChangeIndex sameChange |			change := (sortedList at: index) value.			(removed includes: change) ifFalse: [				changeName := change checkingName.				sameChangeIndex := index.				[((sameChangeIndex := sameChangeIndex + 1) between: 1 and: sortedList size)				and: [(sameChange := (sortedList at: sameChangeIndex) value) checkingName = changeName]]					whileTrue: [						candidates add: sameChange; add: change]]].		removed addAll: candidates].	self redisplayList</body><body package="Tools-Changes">removeConflictsWithSystem	"Remove those changes that differ in effect to the system's versions."	checkSystem := #code.	Cursor execute showWhile: [		removed addAll: (list select: [:change|									(removed includes: change) not									and: [(change sameAsSystem: self) not]])].	self redisplayList</body><body package="Tools-Changes">removeDuplicates	"Remove any duplicate changes in the list to leave only one version of each change.	 If the left-shift is down then remove duplicates later in the list, otherwise remove	 duplicates earlier in the list."	| sortedList reverse |	reverse := InputState default shiftDown.	Cursor wait showWhile: [		"Sort associations keyed by index to keep the sort stable."		sortedList := ((1 to: list size) collect: [:index| index -&gt; (list at: index)]) asSortedCollection: [:a1 :a2|						| c1 c2 |						c1 := a1 value.						c2 := a2 value.						c1 class name &lt; c2 class name						or: [c1 class name = c2 class name							and: [c1 checkingName &lt; c2 checkingName								or: [c1 checkingName = c2 checkingName									and: [a1 key &lt;= a2 key]]]]]].	Cursor execute showWhile: [		| candidates start end delta |		candidates := Set new.		reverse			ifTrue: ["Go through the list forwards to preferentially remove later changes."				start := 1. end := sortedList size. delta := 1]			ifFalse: ["Go through the list backwards to preferentially remove earlier changes."				start := sortedList size. end := 1. delta := -1].		start to: end by: delta do: [:index|			| change changeName changeText sameChangeIndex sameChange |			change := (sortedList at: index) value.			(removed includes: change) ifFalse: [				changeName := change checkingName.				sameChangeIndex := index.				[((sameChangeIndex := sameChangeIndex + delta) between: 1 and: sortedList size)				and: [(sameChange := (sortedList at: sameChangeIndex) value) checkingName = changeName]]					whileTrue: [						"Cache change text to avoid going to the file system to get it more than once."						changeText isNil ifTrue: [changeText := change text].						changeText = sameChange text ifTrue: [							candidates add: sameChange]]]].		removed addAll: candidates].	self redisplayList</body><body package="Tools-Changes">removeItem	"Remove the currently selected change."	selectionIndex &gt; 0 ifTrue:		[removed add: (list at: selectionIndex).		self updateListSelection: selectionIndex]</body><body package="Tools-Changes">removeMethodsNotInSystem	"Remove those method changes that have no corresponding method in the system."	Cursor execute showWhile: [		removed addAll: (list select: [:change|									change isMethodRelated									and: [(removed includes: change) not									and: [change hasVersionInSystem not]]])].	self redisplayList</body><body package="Tools-Changes">removeOldVersions	"Remove any conflicting changes earlier in the list to leave only the latest	 version of each change. If leftShift is pressed remove later changes to	 leave only the earliest change."	| sortedList reverse |	reverse := InputState default shiftDown.	Cursor wait showWhile: [		"Sort associations keyed by index to keep the sort stable."		sortedList := ((1 to: list size) collect: [:index| index -&gt; (list at: index)]) asSortedCollection: [:a1 :a2|						| c1 c2 |						c1 := a1 value.						c2 := a2 value.						c1 checkingName &lt; c2 checkingName						or: [c1 checkingName = c2 checkingName							and: [a1 key &lt;= a2 key]]]].	Cursor execute showWhile: [		| candidates start end delta |		candidates := Set new.		reverse			ifTrue: ["Go through the list forwards to preferentially remove later changes."				start := 1. end := sortedList size. delta := 1]			ifFalse: ["Go through the list backwards to preferentially remove earlier changes."				start := sortedList size. end := 1. delta := -1].		start to: end by: delta do: [:index|			| change changeName sameChangeIndex sameChange |			change := (sortedList at: index) value.			(removed includes: change) ifFalse: [				changeName := change checkingName.				sameChangeIndex := index.				[((sameChangeIndex := sameChangeIndex + delta) between: 1 and: sortedList size)				and: [(sameChange := (sortedList at: sameChangeIndex) value) checkingName = changeName]]					whileTrue: [						candidates add: sameChange]]].		removed addAll: candidates].	self redisplayList</body><body package="Tools-Changes">removeSameAsSystem	"Remove those changes that are the same in effect as the system."	checkSystem := #code.	Cursor execute showWhile: [		removed addAll: (list select: [:change|									(removed includes: change) not									and: [change sameAsSystem: self]])].	self redisplayList</body><body package="Tools-Changes">removeSameSourceAsSystem	"Remove those changes that are exactly the same as the system."	checkSystem := #exact.	Cursor execute showWhile: [		removed addAll: (list select: [:change|									(removed includes: change) not									and: [change sameAsSystem: self]])].	self redisplayList</body><body package="Tools-Changes">removeSourceConflictsWithSystem	"Remove those changes that differ at all to the system's versions."	checkSystem := #exact.	Cursor execute showWhile: [		removed addAll: (list select: [:change|									(removed includes: change) not									and: [(change sameAsSystem: self) not									and: [change hasVersionInSystem]]])].	self redisplayList</body><body package="Tools-Changes">restoreAll	list do: [:change | removed remove: change ifAbsent: []].	self redisplayList</body><body package="Tools-Changes">restoreChangesContainingString	"Restore those changes that textually contain (or match) a given string."	(self selectMatching: (#Restore &lt;&lt; #labels &gt;&gt; 'Restore') asString fromRemoved: true) value do:		[:aChange|		removed remove: aChange ifAbsent: nil].	self redisplayList</body><body package="Tools-Changes">restoreItem	"Un-remove the currently selected change."	selectionIndex &gt; 0 ifTrue:		[removed remove: (list at: selectionIndex) ifAbsent: [].		self updateListSelection: selectionIndex]</body></methods><methods><class-id>Tools.AbstractChangeList</class-id> <category>drag and drop</category><body package="Tools-Changes">addChangeSetFromBrowserDrag: aChangeSet atIndex: index	"Add all the changes in a ChangeSet that were built-up as a result of	 a browser drag. Return the effect of the drag."	Cursor wait showWhile:		[| changeList |		changeList := self class new.		aChangeSet addChangesToChangeList: changeList.		index &lt;= list size			ifTrue:				[changes addAll: changeList changes beforeIndex: (index &gt; 0						ifTrue: [changes indexOf: (list at: index)]						ifFalse: [1]).				list addAll: changeList changes beforeIndex: (index max: 1)]			ifFalse:				[changes addAllLast: changeList changes.				list addAllLast: changeList changes]].	self updateList.	self updateSelection: (index min: list size).	^#dragEffectCopy</body><body package="Tools-Changes">canAcceptDropFrom: aDC 	"Answer true if a drop can occur in the change list.  Accept drops from change lists and browsers"	| appl |	^((appl := aDC data contextApplicationType) = #vw_changes)	or: [appl = #vw_browser]</body><body package="Tools-Changes">doDrag: aController 	"Drag the currently selected change. Include all available information so that the 	drop target can use whatever it needs."	| data change selIdx |	data := DragDropData new.	data key: #change.	data contextWindow: self builder window.	data contextWidget: aController.	data contextApplication: self; contextApplicationType: #vw_changes.	data clientData: (change := list at: (selIdx := selectionIndex)).	(DragDropManager			withDropSource: DropSource new			withData: data) doDragDrop == #dropEffectMove		ifTrue:			[changes remove: change.			removed remove: change ifAbsent: [].			self updateList.			self updateSelection: (selIdx min: list size)]</body><body package="Tools-Changes">doDropFromBrowserDrag: aDragContext	"A drop has occurred on the change list of a change browser from a	 browser. Add the dragged class from the browser and insert it in the	 receiver's list. The behaviour is modified via the alt or shift keys.	 If alt is down then expand the drag into all relevant changes. E.g. By	 default, dragging a class into the list adds the class definition only, but	 if the alt is down then the entire class gets added.  If shift is down the	 add removals of the corresponding entities.  e.g. shift-dragging	 a class adds a class removal change."	| dict index mode category meta class protocol selector changeSet |	dict := aDragContext data clientData.	index := aDragContext dropTarget clientData at: #effectiveTargetIndex.	meta := dict at: #meta ifAbsent: [false].	((dict includesKey: #class)	and: [class := (dict at: #class) asQualifiedReference value.		meta])			ifTrue: [class := class class].	"Make a ChangeSet to hold the changes that will get added"	changeSet := ChangeSet new.	(selector := dict at: #selector ifAbsent: []) notNil		ifTrue:			["shift implies reverse-the-sense, so instead of adding			 a method definition change we add a method remove change."			aDragContext shiftDown				ifTrue: [changeSet removeSelector: selector class: class]				ifFalse: [changeSet addSelector: selector class: class].			^self addChangeSetFromBrowserDrag: changeSet atIndex: index].	(protocol := dict at: #protocol ifAbsent: []) notNil		ifTrue:			[(class organization listAtCategoryNamed: protocol)				do:					[:sel|						aDragContext shiftDown							ifTrue: [changeSet removeSelector: sel class: class]							ifFalse: [changeSet addSelector: sel class: class]].			^self addChangeSetFromBrowserDrag: changeSet atIndex: index].	"If the browser has told us about its text mode we can be	 more specific in a class drag. e.g. copy comment or organisation"	mode := dict at: #textMode ifAbsent: [].	class notNil		ifTrue:			["alt implies add everything.  It overrides shift."			aDragContext altDown				ifTrue:					[mode == #hierarchy						ifTrue:							[class allSuperclasses, class withAllSubclasses								do:									[:sc| changeSet addClass: sc]]						ifFalse:							[changeSet addClass: class]]				ifFalse: [					aDragContext shiftDown						ifTrue: [							mode == #hierarchy								ifTrue: [									class allSuperclasses, class withAllSubclasses										do:											[:sc| changeSet removeClass: sc]]									ifFalse: [changeSet removeClass: class]]						ifFalse: [							mode == #comment								ifTrue: [changeSet commentClass: class]								ifFalse: [									mode == #protocols										ifTrue: [changeSet reorganizeClass: class]										ifFalse: [											mode == #hierarchy												ifTrue: [													class allSuperclasses, class withAllSubclasses														do:															[:sc| changeSet changeClass: sc]]												ifFalse: [changeSet changeClass: class]]]]].				^self addChangeSetFromBrowserDrag: changeSet atIndex: index].	(category := dict at: #category ifAbsent: []) notNil		ifTrue:			[mode == #categories				ifTrue: [(dict at: #environment) reorganize]				ifFalse:					[((dict at: #environment) organization listAtCategoryNamed: category)						do:							[:cn| | clss |							clss := (dict at: #environment) at: cn.							meta ifTrue: [clss := clss class].							aDragContext altDown								ifTrue: [changeSet addClass: clss]								ifFalse: [									aDragContext shiftDown										ifTrue: [changeSet removeClass: clss]										ifFalse: [changeSet changeClass: clss]]]].		^self addChangeSetFromBrowserDrag: changeSet atIndex: index].	^#dragEffectNone</body><body package="Tools-Changes">doDropFromChangeListDrag: aDragContext	"A drop has occurred on the change list of a change browser from another change browser.  Remove the change from the other change browser and insert it in the receiver's list."	| change sourceIndex effectiveTargetIndex view destIndex |	change := aDragContext data clientData.	effectiveTargetIndex := aDragContext dropTarget clientData at: #effectiveTargetIndex.	(aDragContext data contextApplication == self)		ifTrue:			["Dropping in the receiver itself.  We need to map the list target and drop indices			 from the displayed list to the underlying list of changes and move the change in			 the underlying list of changes.  First find out where the target really is."			effectiveTargetIndex := (view := (self builder componentAt: #listView) widget)										elementIndexFor: view controller sensor cursorPoint.			"Find out where the dragged change is in the underlying list of changes."			sourceIndex := changes indexOf: change.			"Find out where the target change is in the underlying list of changes.			 The list can't be empty because it was dragged from."			destIndex := changes indexOf: (list at: ((effectiveTargetIndex min: list size) max: 1)).			"If the effectiveTargetIndex is the same as the sourceIndex, do nothing"			effectiveTargetIndex == sourceIndex ifTrue: [^#dropEffectNone].			changes removeAtIndex: sourceIndex.			(destIndex &gt;= sourceIndex)				ifTrue:					[destIndex &gt; changes size						ifTrue: [changes addLast: change]						ifFalse: [changes add: change beforeIndex: destIndex ]]				ifFalse:					[changes add: change beforeIndex: destIndex].			self updateList.			self updateSelection: (effectiveTargetIndex min: list size).			^#dropEffectNone].	effectiveTargetIndex &lt;= list size		ifTrue:			[changes				add: change				beforeIndex: (effectiveTargetIndex &gt; 0								ifTrue: [changes indexOf: (list at: effectiveTargetIndex)]								ifFalse: [1]).			list add: change beforeIndex: (effectiveTargetIndex max: 1)]		ifFalse:			[changes addLast: change.			list addLast: change].	self updateList.	self updateSelection: (effectiveTargetIndex min: list size).	^aDragContext ctrlDown		ifTrue: [#dropEffectCopy]		ifFalse: [#dropEffectMove]</body><body package="Tools-Changes">dragEnter: aDragContext	"A drag has entered the class list of a change browser.	 If the receiver is happy to accept a drag from the target the	 fill-in the appropriate data and answer that dragging should continue."	(self canAcceptDropFrom: aDragContext)		ifFalse: [^#dropEffectNone].	aDragContext dropTarget clientData: self initialDropState.	^#dropEffectMove</body><body package="Tools-Changes">dragLeave: aDragContext	"A drag has left the change list of a change browser. If the drag contains a 	change, we must restore the state of the list."	(self canAcceptDropFrom: aDragContext)		ifFalse: [^#dropEffectNone].	self restoreListStateFrom: aDragContext dropTarget clientData.	aDragContext dropTarget clientData: nil.	^#dropEffectNone</body><body package="Tools-Changes">dragOver: aDragContext	"A drag is over the change list of a change list."	| dict view ctrl |	^(self canAcceptDropFrom: aDragContext)		ifTrue: [			dict := aDragContext dropTarget clientData.			ctrl := (view := (self builder componentAt: #listView) widget) controller.			dict at: #effectiveTargetIndex put: (view elementIndexFor: ctrl sensor cursorPoint).			self				showDropFeedbackForList: #listView				in: aDragContext.			#dropEffectMove]		ifFalse: [#dropEffectNone]</body><body package="Tools-Changes">drop: aDragContext 	"A drop has occurred on the change list of a change browser. If the 	 drop is a change then insert it into the list. If the drop is from a 	 browser add a corresponding change."	(self canAcceptDropFrom: aDragContext)		ifFalse: [^#dropEffectNone].	"If there are changes to the text, prompt before discarding them"	self changeRequest ifFalse: [^#dropEffectNone].	(aDragContext data contextApplicationType = #vw_changes)		ifTrue:			[^self doDropFromChangeListDrag: aDragContext].	(aDragContext data contextApplicationType = #vw_browser)		ifTrue:			[^self doDropFromBrowserDrag: aDragContext].	^#dropEffectNone</body><body package="Tools-Changes">initialDropState	"Answer the initial state of the list when a drag has begun within its 	bounds. The state will be used to re-establish the appearance of the list when 	a drag leaves."	| dict view ctrl |	ctrl := (view := (self builder componentAt: #listView) widget) controller.	dict := IdentityDictionary new.	dict at: #ctrl put: ctrl.	dict at: #targetIndex put: view targetIndex.	dict at: #effectiveTargetIndex put: (view elementIndexFor: ctrl sensor cursorPoint).	dict at: #hasFocus put: ctrl view hasFocus.	ctrl view hasFocus: true.	^dict</body><body package="Tools-Changes">restoreListStateFrom: aDictionary 	"Reset the state of the change list when a drag has left its bounds."	| ctrl |	ctrl := aDictionary at: #ctrl.	ctrl view targetIndex: (aDictionary at: #targetIndex).	ctrl view hasFocus: (aDictionary at: #hasFocus)</body><body package="Tools-Changes">showDropFeedbackForList: aSymbol in: aDragContext 	"Track the mouse with the target index while dragging in the list named 	aSymbol."	| wrap |	wrap := self builder componentAt: aSymbol.	wrap isNil 		ifFalse: [wrap widget showDropFeedbackIn: aDragContext allowScrolling: true]</body><body package="Tools-Changes">wantToDrag: listController	"Answer true if the receiver wants to initiate a drag."	^list size &gt; 0 and: [self hasSelection]</body></methods><methods><class-id>Tools.AbstractChangeList</class-id> <category>menus</category><body package="Tools-Changes">changeListMenu	"Return the menu to use for the ChangeList."	^menus at: #changeListMenu		ifAbsentPut: 			[| menu |			menu := self class changeListMenu.			menu				augmentFrom: self class				to: AbstractChangeList				menuName: #changeListMenu				for: self.			menu]</body><body package="Tools-Changes">changeListMenuHolder	^[self changeListMenu]</body><body package="Tools-Changes">existingTextMenu	"Answer a minimal Menu for the existing text pane."	^menus at: #existingTextMenu 		ifAbsentPut: [Menu 						labelArray: (Array with: (#Find &lt;&lt; #dialogs &gt;&gt; 'Find...') with: (#Copy &lt;&lt; #dialogs &gt;&gt; 'Copy') with: (#DoIt &lt;&lt; #dialogs &gt;&gt; 'Do it') with: (#Cancel &lt;&lt; #dialogs &gt;&gt; 'Cancel')) 						values: #(#find #copySelection #doIt #cancel)]</body><body package="Tools-Changes">existingTextMenuHolder	^[self existingTextMenu]</body><body package="Tools-Changes">textMenu	"Answer a minimal Menu for the text pane."	^menus at: #textMenu ifAbsentPut: [self buildTextMenu]</body><body package="Tools-Changes">textMenuHolder	^[self textMenu]</body></methods><methods><class-id>Tools.AbstractChangeList</class-id> <category>private</category><body package="Tools-Changes">addFilter: aSymbol 	"Add a specific filter to the current set of filters. This is one of 	 #fileName, #category, #changeType, #className (or 	 #nonMetaClassName), #selector, or #values. #className is really 	 selected on the basis of classesDistinct. If classesDistinct then we 	 use #className, otherwise #nonMetaClassName."	| theSymbol filterKeyValue oldFilter |	theSymbol := (aSymbol == #className and: [classesDistinct not])						ifTrue: [#nonMetaClassName]						ifFalse: [aSymbol].	filterKeyValue := filterKey perform: theSymbol.	filter isNil		ifTrue: [filter := [:change | (change perform: theSymbol) = filterKeyValue]]		ifFalse: 			[oldFilter := filter.			filter := [:change | (change perform: theSymbol) = filterKeyValue							and: [oldFilter value: change]]]</body><body package="Tools-Changes">changes	"Return the receiver's changes.  This is to assist in the implementation of drag and drop."	^changes</body><body package="Tools-Changes">displayDifferences: aSymbol	"Flip the receiver's conflict view mode."	DifferencesMode := differencesMode := aSymbol.	self setMenuState.	self updateSelection: selectionIndex</body><body package="Tools-Changes">doFrom: firstIndex	"replay all the changes from the supplied index. Reset selection each time through the loop,	 so that if an error occurs, the selection is left at the item which caused it."	Notice 		show: #ReplayingChangesDots &lt;&lt; #dialogs &gt;&gt; 'Replaying Changes...' 		while: 				[ | listView |			firstIndex = self listIndex ifTrue: [self toggleListIndex: firstIndex].			listView := (builder componentAt: #listView) widget.			firstIndex to: list size do:				[:index |				(self hasRemoved: index) ifFalse:					[self toggleListIndex: index.					self updateSelection: index.					listView makeVisible: index.							(list at: index) fileIn]]]</body><body package="Tools-Changes">fieldMessage: aMenuSelector	"Toggle a field."	| index |	index := self fieldTemplates first indexOf: aMenuSelector.	self switchField: index perform: (self fieldTemplates last at: index)</body><body package="Tools-Changes">fieldTemplates	^self subclassResponsibility</body><body package="Tools-Changes">filterMessage: aMenuSelector	"Toggle a filter."	| index |	index := self filterTemplates first indexOf: aMenuSelector.	self switchFilter: index perform: (self filterTemplates last at: index)</body><body package="Tools-Changes">filterTemplates	^self subclassResponsibility</body><body package="Tools-Changes">find: aspect prompt: promptName filter: filterSymbol	"Search for all changes whose aspect (selector, className fileName etc)	 which match a user-supplied pattern string. Select those changes by switching	 on the relevant filter. If the user presses the shift-key _always_ use a menu."	| aString filterIndex aspectNames aspectName bestScore closest |	filterIndex := self validFilters indexOf: filterSymbol ifAbsent: [self error: (#invalidChangeFilter &lt;&lt; #dialogs &gt;&gt; 'invalid change filter')].	( aString := self findPrompt: promptName ) == nil		ifTrue: [ ^false ].	aspectNames := Set new.	((aString includes: $*) or: [aString includes: $#])		ifTrue: 			[ aspectNames := self wildcardListFor: aspect prompt: promptName input: aString.			aspectNames isEmpty ifTrue: [ ^self ].			( closest := Dialog 					choose: ((#Which1s &lt;&lt; #dialogs &gt;&gt; 'Which &lt;1s&gt;?')						expandMacrosWith: promptName)					fromList: (aspectNames := aspectNames asSortedCollection)					values: aspectNames					lines: 32					cancel: []					for: self interfaceWindow) isNil ifTrue: [ ^self ].			closest = (' ', (#none &lt;&lt; #dialogs &gt;&gt; '(none)') asString) ifTrue: [closest := '']			]		ifFalse: [			1 to: changes size do: [:i|				(aspectName := (changes at: i) perform: aspect) isNil					ifTrue: [aspectName := 'nil']					ifFalse: [aspectName isString ifFalse: [aspectName := aspectName name]].				(aString sameAs: aspectName)					ifTrue: [						1 to: filterList size do: [:index|	"Turn off all existing filter buttons"							(filterList at: index) notNil ifTrue: [								filterList at: index put: nil.								self changed: #filter with: index]].						list := changes.						selectionIndex := i.						filterList := #().	"Turn on button to filter for matching change"						^self switchFilter: filterIndex perform: aspect]					ifFalse: [aspectNames add: aspectName]].			bestScore := 0.			aspectNames do: [:name | | score |				(score := name spellAgainst: aString) &gt; bestScore								ifTrue:  [bestScore := score. closest := name]].			closest == nil ifTrue: [^Dialog warn: ((#ErrorNotCorrectable &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; not found, and couldn''t correct')			expandMacrosWith: aString)].			(Dialog				choose: ((#correctTo1s &lt;&lt; #dialogs &gt;&gt; 'correct to &lt;1s&gt; ?')					expandMacrosWith: (closest contractTo: 25))				labels: (Array with: (#OK &lt;&lt; #dialogs &gt;&gt; 'OK') with: (#Cancel &lt;&lt; #dialogs &gt;&gt; 'Cancel'))				values: #(#ok #cancel)				default: #ok				for: self interfaceWindow) = #cancel					ifTrue: [^self]].	1 to: changes size do: [:i|		(aspectName := (changes at: i) perform: aspect) isNil			ifTrue: [aspectName := 'nil']			ifFalse: [aspectName isString ifFalse: [aspectName := aspectName name]].				(closest sameAs: aspectName) ifTrue: [					1 to: filterList size do: [:index|	"Turn off all existing filter buttons"						(filterList at: index) notNil ifTrue: [							filterList at: index put: nil.							self changed: #filter with: index]].					list := changes.					selectionIndex := i.					filterList := #().	"Turn on button to filter for matching change"					^self switchFilter: filterIndex perform: aspect]]</body><body package="Tools-Changes">findLast: aString in: aStream	^SourceFileManager findLast: aString in: aStream</body><body package="Tools-Changes">findPrompt: promptName	"Answer a search criteria for an aspect or nil if canceled"	| aString |	self changeRequest ifFalse: [ ^nil ].	aString := InputState default shiftDown				ifTrue: [ '*' ]				ifFalse: [ Dialog request: ((#FindWhich1s &lt;&lt; #dialogs &gt;&gt; 'Find which &lt;1s&gt;?')					expandMacrosWith: promptName) initialAnswer: '*' ].	^aString isEmpty 		ifTrue: [ nil ]		ifFalse: [ aString ].</body><body package="Tools-Changes">getWriteFilenameWithPrompt: promptString do: actionBlock	"Find out the file name of a file to write to using the Filename utility that	prompts for existing files."	| fileName |		[fileName := Dialog requestNewFileName: promptString				default: TextEditorController currentSelection.	fileName isEmpty or: 			[(self includesFileName: fileName)				ifTrue: 					[Dialog						warn: (#SourceFileStillInUse &lt;&lt; #dialogs								&gt;&gt; '&lt;1s&gt; cannot be used because&lt;n&gt;it holds the source of some or all entries.&lt;n&gt;Please try again.'									expandMacrosWith: fileName).					false]				ifFalse: [true]]]			whileFalse.	fileName isEmpty		ifFalse: [Cursor write showWhile: [actionBlock value: fileName asFilename]]</body><body package="Tools-Changes">hasFilter: index	"Answer whether one of the receiver's filters is set to on."	^index &lt;= filterList size and: [(filterList at: index) notNil]</body><body package="Tools-Changes">hasRemoved: index	"Answer whether the item at position index has been marked for removal.  Answer false if position index is outside the boundaries of the receiver's list."		^index &gt; 0 and: [index &lt;= list size and: [removed includes: (list at: index)]]</body><body package="Tools-Changes">interfaceWindow	builder == nil ifTrue: [^nil].	^builder window</body><body package="Tools-Changes">listEntryForChange: aChange	"Return the string to display in the list for the supplied change.	 This depends on the showing filters."	| name v |	name := nil.	1 to: (fieldList size min: 2) do: [:i| "fieldList also contains conflicts, must avoid sending this to changes."		| f |		nil == (f := fieldList at: i) ifFalse: [			v := aChange perform: f.			v size &gt; 0 ifTrue: [				nil == name ifTrue: [name := WriteStream on: (String new: 50)].				name nextPut: $(; nextPutAll: v; nextPutAll: ') ']]].	^EmphasizeDifferences		ifTrue: [			(nil == name 				ifTrue: [aChange name]				ifFalse: [name nextPutAll: aChange name. name contents])					asText emphasizeAllWith: ((aChange sameAsSystem: self)													ifTrue: [#italic]													ifFalse: [#bold])]		ifFalse: [			nil == name 				ifTrue: [aChange name]				ifFalse: [name nextPutAll: aChange name. name contents]]</body><body package="Tools-Changes">listName: aString changes: aChangeCollection removed: aSet	"Initialize the receiver with the given title, changes and removed set."	listName := aString.	changes addAll: aChangeCollection.	list addAll: aChangeCollection.	removed addAll: aSet.	self updateList</body><body package="Tools-Changes">makeChangesVisible	"Attempt to make at least one chnage visible; assuming that all changes are filtered out."	| filters |	filters := self filterTemplates first.	filters size to: 1 by: -1 do:		[:i|		list isEmpty ifFalse: [^self].		(self hasFilter: i) ifTrue:			[self filterMessage: (filters at: i)]]</body><body package="Tools-Changes">queryParcel	"Let the user select a Parcel from a list and return the name of the parcel."	| names parcel |	names := Parcel parcelNames asSortedCollection.	parcel := Dialog				choose: (#DisplayWhichParcelQ &lt;&lt; #dialogs &gt;&gt; 'Display which Parcel?')				fromList: names				values: names				lines: 20				cancel: [nil].	^parcel</body><body package="Tools-Changes">rebuildMenu	menuBar notNil		ifTrue:			[self				rebuildMenu: menuBar				with: self class menuBar				augmentTo: AbstractChangeList]</body><body package="Tools-Changes">redisplayList	"Redisplay the list unless the interface is not actually open."	builder notNil ifTrue: [(builder componentAt: #listView) widget invalidate]</body><body package="Tools-Changes">scanFilename: aFilename	"Scan the file/directory name specified.  If aFilename is	a directory, then scan all the files in it."	Transcript cr; show: ((#Scanning1s &lt;&lt; #dialogs &gt;&gt; 'Scanning &lt;1s&gt;')			expandMacrosWith: aFilename asString).	aFilename isDirectory		ifTrue: [			aFilename directoryContents asSortedStrings do: [:each |				self scanFilename: (aFilename construct: each)]]		ifFalse: [ | stream |			stream := (aFilename withEncoding: #Source) readStream.			[self scanFile: stream] ensure: [stream close]]</body><body package="Tools-Changes">selectionIndexChange	self toggleListIndex: selectionInList selectionIndex</body><body package="Tools-Changes">selectMatching: promptPrefix fromRemoved: aBoolean	"Return an association of string to list where the list contains	 all unremoved changes which match a string."	| string |	string := Dialog				request: ((#{RxParser} isDefined					ifTrue: [#x1sChangesContainingRegexp &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; changes containing regexp']					ifFalse: [#x1sChangesContainingString &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; changes containing string'])						expandMacrosWith: promptPrefix).	string isEmpty ifTrue: [^string -&gt; List new].	Cursor execute showWhile:		[| re |		^string -&gt; (#{RxParser} isDefined						ifTrue:							[re := string asRegex.							list select:								[ :change |								change text ~~ nil									and: [ (aBoolean = (removed includes: change)									and: [re search: change text])]]]						ifFalse:							[string first = $* ifFalse: [string := '*', string].							string last = $* ifFalse: [string := string, '*'].							list select:								[ :change |								change text ~~ nil									and: [ (aBoolean = (removed includes: change)									and: [string match: change text])]]])]</body><body package="Tools-Changes">setLabel	"Set the selected change label."	| label |	builder isNil ifTrue: [^self].	nil == (label := builder componentAt: #changeLabel) ifTrue: [^self].	label		label: (Label				with: (self labelFor: #changeLabel) asText allBold				attributes: (self currentSkin styleNamed: #small)).	self showingConflicts ifFalse: [^self].	nil == (label := builder componentAt: #imageLabel) ifTrue: [^self].	label		label: (Label				with: (self labelFor: #imageLabel) asText allBold				attributes: (self currentSkin styleNamed: #small))</body><body package="Tools-Changes">setMenuState	"Set up all our toggleable menu items."	| filters fields |	filters := self filterTemplates first.	filters do: [:f|		(menuBar atNameKey: f)			indication: ((self hasFilter: (filters indexOf: f)))].	fields := self fieldTemplates first.	fields do: [:f|		(menuBar atNameKey: f)			indication: ((self showingField: (fields indexOf: f)))].	(menuBar atNameKey: #viewConflictsVertically)		indication: (verticalConflicts).	(menuBar atNameKey: #viewConflictsHorizontally)		indication: (verticalConflicts not).	(menuBar atNameKey: #highlightSourceDifferences)		indication: ((#code == differencesMode) not).	(menuBar atNameKey: #highlightCodeDifferences)		indication: (#code == differencesMode).	(menuBar atNameKey: #lineEndsTreated)		indication: (Change normalizeLineEnds).	(menuBar atNameKey: #lineEndsRaw)		indication: (Change normalizeLineEnds not).	(menuBar atNameKey: #toggleListEmphasis)		indication: (EmphasizeDifferences).	(menuBar atNameKey: #toggleTypesIncludeSame)		indication: (MethodDefinitionChange typesIncludeSame).	(menuBar atNameKey: #groupClassAndMetaclass)		indication: classesDistinct not.	(menuBar atNameKey: #ungroupClassAndMetaclass)		indication: classesDistinct</body><body package="Tools-Changes">setValue: aValue	value := aValue</body><body package="Tools-Changes">showingConflicts	"Return true of the receiver is also displaying conflicts."	^fieldList size &gt;= 3 and: [(fieldList at: 3) notNil]</body><body package="Tools-Changes">showingField: index	^index &lt;= fieldList size and: [(fieldList at: index) notNil]</body><body package="Tools-Changes">switchField: index perform: aSymbol 	"Handle the show button panel. Handle show conflicts specially because its 	done by an extra view, not by the list of changes."	| tempSelectionIndex |	self changeRequest ifFalse: [^false].	index &gt; fieldList size ifTrue: [		fieldList := fieldList , (Array new: index - fieldList size)].	fieldList at: index put: ((fieldList at: index) isNil ifTrue: [aSymbol]).	self setMenuState.	(aSymbol == #conflicts)		ifTrue:			[builder notNil				ifTrue:					[(builder componentAt: #textCanvas) widget						client: self						spec: ((self showingField: 3)								ifTrue: [VerticalConflicts											ifTrue: [#verticalDifferencesText]											ifFalse: [#horizontalDifferencesText]]								ifFalse: [#standardText])						builder: builder].			"This to bludgeon way around TextView update bug which is to not update			 text if only its emphasis has changed (which it does when we switch on &amp; off			 the conflict text.  So simply deselect &amp; reselect."			tempSelectionIndex := selectionIndex.			self	toggleListIndex: tempSelectionIndex;				toggleListIndex: tempSelectionIndex;				updateSelection: tempSelectionIndex]		ifFalse:			[self changed: #field with: index. 			self updateList]</body><body package="Tools-Changes">switchFilter: index perform: aSymbol	"Set the action aSymbol to be the action associated with the filter 	denoted by index (the position in the list of filters)."	self changeRequest ifFalse: [^false].	index &gt; filterList size		ifTrue:			[filterList := filterList , (Array new: index - filterList size)].	(filterList at: index) isNil		ifTrue:			[selectionIndex &gt; 0 ifTrue:				[filterKey := list at: selectionIndex.				filterList at: index put: aSymbol]]		ifFalse:			[filterList at: index put: nil].	self changed: #filter with: index.	self updateList</body><body package="Tools-Changes">updateList	"Update the current list by recomputing the displayed list from the underlying list.	 Note that we do so lazily to display the visible part of the new list quicker.	 Each actual list entry is calculated in the selectionInList's visualBlocks created	 in the receiver's postBuildWith: method."	Cursor execute showWhile: [		| oldChange newIndex |		selectionIndex &gt; 0 ifTrue: [oldChange := list at: selectionIndex].		filter := nil.		filterList do: [:aSymbol | aSymbol notNil ifTrue: [self addFilter: aSymbol]].		filter isNil			ifTrue: [filter := [:change | true].					list := changes copy]			ifFalse: [list := changes select: filter].		newIndex :=			oldChange == nil				ifTrue: [0]				ifFalse: [list identityIndexOf: oldChange].		"Simply set the selectionInList's list to be the empty list.  This speeds		 up redisplay at the cost of slightly slower scrolling."		selectionInList list: (List withSize: list size).		self updateSelection: newIndex]</body><body package="Tools-Changes">updateListSelection: newIndex	"Ensure that the list entry selection at newIndex is updated and redisplayed.	 Do not bother to update the text selection.	 This is for toggling the removed status on a list item."	(selectionIndex between: 1 and: selectionInList list size)		ifTrue:			[selectionInList list				at: selectionIndex				put: (self listEntryForChange: (list at: selectionIndex))]</body><body package="Tools-Changes">updateSelection: newIndex	"Ensure that the selection at newIndex is updated and redisplayed."	self deselect.	selectionInList selectionIndex: newIndex.	self updateListSelection: newIndex</body><body package="Tools-Changes">validFilters	"Answer an array of valid filters"	^self filterTemplates last</body><body package="Tools-Changes">viewConflictsVertically: aBoolean	"Flip the receiver's conflict view and set the class variable."	VerticalConflicts := verticalConflicts := aBoolean.	self showingConflicts		ifTrue:			[self fieldMessage: #showConflicts.			self fieldMessage: #showConflicts].	self setMenuState</body><body package="Tools-Changes">wildcardListFor: aspect prompt: promptName input: aString	"Answer a list of strings for an aspect that exists in the list."	| aspectName aspectNames |	aspectNames := Set new.	1 to: changes size do: 		[ :i |		( aspectName := ( changes at: i ) perform: aspect ) size = 0			ifTrue: [ aspectNames add: (' ', (#none &lt;&lt; #dialogs &gt;&gt; '(none)') asString) ]			ifFalse: 				[ aspectName isString ifFalse: [ aspectName := aspectName name ].				(( aspectName size = 0 or: [ aString match: aspectName ] )				or: [(aspectName includes: $.) and: ['*.', aString match: aspectName]]) 					ifTrue: [ aspectNames add: aspectName asString ]				]		].	aspectNames isEmpty 		ifTrue:  [	Dialog warn: ((#noMatching1s &lt;&lt; #dialogs &gt;&gt; 'no matching &lt;1s&gt;')					expandMacrosWith: promptName)				].	^aspectNames.</body></methods><methods><class-id>Tools.AbstractChangeList</class-id> <category>interface opening</category><body package="Tools-Changes">postBuildWith: aBuilder	"Ensure that		a) the relevant wrappers are used for the list of changes, and		b) the scroll-bar for the change text view is on the left if conflicts			are being shown, and the layout is vertical."	| component |	listName size &gt; 0 ifTrue: [builder window label: listName].	(component := aBuilder componentAt: #listView) notNil ifTrue:		[component widget			selectedVisualBlock:				[:view :index | | rw tx |				"If the entry is empty then compute it."				nil == (view sequence at: index) ifTrue:					[view sequence at: index put: (self listEntryForChange: (list at: index))].				tx := view displayStringAt: index.				rw := ((self hasRemoved: index)						ifTrue: [StrikeOutWrapper]						ifFalse: [ReversingWrapper])							on: (Label with: tx attributes: view textStyle offset: 2@0).				rw reverse setValue: true.				BoundedWrapper on: rw];			visualBlock: 				[:view :index | | tx lb |				"If the entry is empty then compute it."				nil == (view sequence at: index) ifTrue:					[view sequence at: index put: (self listEntryForChange: (list at: index))].				tx := view displayStringAt: index.				lb := Label with: tx attributes: view textStyle offset: 2@0.				(self hasRemoved: index)					ifTrue:						[lb := StrikeOutWrapper on: lb.						lb reverse setValue: false].				BoundedWrapper on: lb]].	(component := aBuilder componentAt: #textView) notNil ifTrue:		[(verticalConflicts		and: [self showingConflicts])			ifTrue:				[component decorator useLocalEdgeDecorationPolicy.				component decorator edgeDecorationPolicy inset: 0].		component widget controller autoAccept: false]</body><body package="Tools-Changes">postOpenWith: aBuilder 	"Ensure we get window events so we update the toggleable menuBar options on each enter."	aBuilder window application: self; sendWindowEvents: #(enter exit close).	(aBuilder componentAt: #textCanvas) widget		client: self		spec: ((self showingField: 3)					ifTrue: [VerticalConflicts								ifTrue: [#verticalDifferencesText]								ifFalse: [#horizontalDifferencesText]]					ifFalse: [#standardText]).</body><body package="Tools-Changes">preBuildWith: aBuilder 	"Hook-up the builder to our menu."	builder menuAt: #menuBar put: menuBar.	self setMenuState</body><body package="Tools-Changes">windowEvent: anAssociation from: anApplicationWindow 	"Handle window events to build the menu bar and to ask Change to 	close any open files at appropriate times."	| type |	type := anAssociation key.	#enter == type ifTrue: [self setMenuState].	#close == type ifTrue: [Change closeOpenFiles]</body></methods><methods><class-id>Tools.AbstractChangeList</class-id> <category>menu bar actions</category><body package="Tools-Changes">groupClassAndMetaclass	"Ingore the distinction between class &amp; metaclass changes."	classesDistinct		ifTrue:			[classesDistinct := false.			self setMenuState.			(filterList includes: #className) ifTrue: [self updateList]]</body><body package="Tools-Changes">highlightCodeDifferences	"Set code conflict display."	self displayDifferences: #code</body><body package="Tools-Changes">highlightSourceDifferences	"Set source conflict display."	self displayDifferences: #exact</body><body package="Tools-Changes">lineEndsRaw	"Set line-ends not to be normalized by changes."	Change normalizeLineEnds: false.	self updateSelection: selectionIndex.	self setMenuState</body><body package="Tools-Changes">lineEndsTreated	"Set line-ends to be normalized by changes."	Change normalizeLineEnds: true.	self updateSelection: selectionIndex.	self setMenuState</body><body package="Tools-Changes">toggleClassFilter	self filterMessage: #filterByClass</body><body package="Tools-Changes">toggleListEmphasis	"Toggle the emphasis of list items."	EmphasizeDifferences := EmphasizeDifferences not.	self setMenuState.	self updateList</body><body package="Tools-Changes">togglePackageFilter	self filterMessage: #filterByPackage</body><body package="Tools-Changes">toggleParcelFilter	self filterMessage: #filterByParcel</body><body package="Tools-Changes">toggleProtocolFilter	self filterMessage: #filterByProtocol</body><body package="Tools-Changes">toggleSameFilter	self filterMessage: #filterBySame</body><body package="Tools-Changes">toggleSelectorFilter	self filterMessage: #filterBySelector</body><body package="Tools-Changes">toggleShowConflicts	self fieldMessage: #showConflicts</body><body package="Tools-Changes">toggleShowProtocol	self fieldMessage: #showProtocol</body><body package="Tools-Changes">toggleTypeFilter	self filterMessage: #filterByType</body><body package="Tools-Changes">toggleTypesIncludeSame	"Toggle the naming of MethodDefinitionChanges."	MethodDefinitionChange typesIncludeSame: MethodDefinitionChange typesIncludeSame not.	self setMenuState.	self updateList</body><body package="Tools-Changes">ungroupClassAndMetaclass	"Recognize the distinction between class &amp; metaclass changes."	classesDistinct		ifFalse:			[classesDistinct := true.			self setMenuState.			(filterList includes: #className) ifTrue: [self updateList]]</body><body package="Tools-Changes">viewConflictsHorizontally	"Set conflicts to be viewn horizontally."	self viewConflictsVertically: false</body><body package="Tools-Changes">viewConflictsVertically	"Set conflicts to be viewn vertically."	self viewConflictsVertically: true</body></methods><methods><class-id>Tools.AbstractChangeList</class-id> <category>accessing</category><body package="Tools-Changes">conflictTextFor: anItem	"Answer the text to display in the conflict text window.	Default is the system version of the selected item." 	^anItem systemText</body><body package="Tools-Changes">existingText	"Answer a Text corresponding to the current version of the change	 (method or class) in the system."	| change src conflictText originalText sysCat different srcFragments originalFragments differences |	selectionIndex &lt;= 0 ifTrue: [^self blankText].	"Take a copy of both texts to ensure the emphasis in the text itself is 	not modified by the comparison."	(originalText := self selectionText) isNil ifTrue: [originalText := ''].	originalText := originalText copy asText.	(conflictText := self noConflictTextFor: (change := self selection))		== nil			ifFalse: 				[self setValue: originalText.				self changed: #value.				^conflictText].	src := (change cleanSourceFrom: (self conflictTextFor: change)) copy				asText.	srcFragments := src smalltalkOrWordAndWhitespaceFragments.	originalFragments := originalText smalltalkOrWordAndWhitespaceFragments.	differences := originalFragments differences: srcFragments.	different := differences anySatisfy: [:each | each isMatch not].	differences do: #applyAnyDifferenceTextEmphases.	self setValue: originalText.	self changed: #value.	^different		ifTrue: [src]		ifFalse: 			[((change isMethodRelated				and: [change category ~= (sysCat := change systemCategory)])					ifTrue: 						[#protocolC1s &lt;&lt; #dialogs &gt;&gt; 'protocol: &lt;1s&gt;' expandMacrosWith: (sysCat isNil									ifTrue: [ClassOrganizer defaultProtocol]									ifFalse: [sysCat])]					ifFalse: [(#NoConflict &lt;&lt; #dialogs &gt;&gt; 'no conflict') asString]) asText				emphasizeAllWith: #italic]</body><body package="Tools-Changes">filterCopy	"Answer a list of all the items not marked for removal."		^self class new listName: '(', self listName, ')' changes: list removed: (list select: [:c | removed includes: c])</body><body package="Tools-Changes">listName	"Answer the label for a browser on the receiver. The default is Change List."	listName size = 0		ifTrue: [^(#ChangeList &lt;&lt; #labels &gt;&gt; 'Change List') asString]		ifFalse: [^listName]</body><body package="Tools-Changes">listName: aString	"Set the receiver's listName"	listName := aString.	builder notNil ifTrue: [builder window label: aString]</body><body package="Tools-Changes">noConflictTextFor: anItem	"Answer a Text corresponding to the conflicting text of the selected item in the system.	This is in fact, the reason why there is no text to compare to. Answer nil if okay to compare."	^self subclassResponsibility</body><body package="Tools-Changes">selection	"Answer the currently selected item, or nil if none."	^selectionIndex &gt; 0 		ifTrue: [ list at: selectionIndex ]</body><body package="Tools-Changes">selectionText	"Answer the text of the item currently selected, or nil if none."	^selectionIndex &gt; 0 		ifTrue: [ self selection text ]</body><body package="Tools-Changes">showConflicts: aBoolean 	"Enable or disable the conflict display."	self showingConflicts ~= aBoolean ifTrue: [self fieldMessage: #showConflicts]</body><body package="Tools-Changes">value	^value</body><body package="Tools-Changes">value: aValue 	"The receiver's text for the currently selected change (if any) has 	changed. Update the text view, and update the change's text."	| thisChange newChange |	value := aValue.	self changed: #value.	(value size &gt; 0 and: [selectionIndex &gt; 0]) ifTrue:		[thisChange := list at: selectionIndex.		thisChange text ~= value asString ifTrue: [			"Since this ChangeList may share changes with others			 (via spawning or Drag+Drop), copy the change to			 ensure the change in text doesn't affect anything else."			newChange := thisChange copy.			newChange text: value asString.			list at: selectionIndex				put: (changes						at: (changes indexOf: thisChange)						put: newChange).			self updateSelection: selectionIndex]]</body></methods><methods><class-id>Tools.AbstractChangeList</class-id> <category>aspects</category><body package="Tools-Changes">changeTypeFilterAdaptor	| index |	index := self checkBoxNumberFor: #type.	^(PluggableAdaptor on: self)		getBlock: [:m | m hasFilter: index]		putBlock: [:m :v | m switchFilter: index perform: #type]		updateBlock: [:m :a :p | a == #filter and: [p = index]]</body><body package="Tools-Changes">checkBoxNumberFor: anAspect	^self validFilters indexOf: anAspect ifAbsent: [ self error: (#InvalidFilter &lt;&lt; #dialogs &gt;&gt; 'Invalid filter') ].</body><body package="Tools-Changes">classNameFilterAdaptor	| index |	index := self checkBoxNumberFor: #className.	^(PluggableAdaptor on: self)		getBlock: [:m | m hasFilter: index]		putBlock: [:m :v | m switchFilter: index perform: #className]		updateBlock: [:m :a :p | a == #filter and: [p = index]]</body><body package="Tools-Changes">existingTextAdaptor	^(PluggableAdaptor on: self)		getBlock: [:m | m existingText]		putBlock: [:m :v | ]		updateBlock: [:m :a :p | a == #existingText]</body><body package="Tools-Changes">labelFor: aKey	"Return a label for the existingText view."	| change protocol |	selectionIndex &gt; 0 ifTrue:		[change := list at: selectionIndex.		(aKey == #imageLabel		and: [change isMethodRelated		and: [(protocol := change systemCategory) notNil]])			ifTrue: [^((#SelectedChange1s &lt;&lt; #dialogs &gt;&gt; 'Selected change (&lt;1s&gt;)')			expandMacrosWith: protocol)].		aKey == #changeLabel ifTrue: [^((#Selection1s &lt;&lt; #dialogs &gt;&gt; 'Selection (&lt;1s&gt;)')			expandMacrosWith: (change fileName contractTo: 30))]].	aKey == #imageLabel ifTrue: [^(#SystemVersion &lt;&lt; #dialogs &gt;&gt; 'System version')].	aKey == #changeLabel ifTrue: [^(#SelectedChange &lt;&lt; #dialogs &gt;&gt; 'Selected change')].	^nil</body><body package="Tools-Changes">packageFilterAdaptor	| index |	index := self checkBoxNumberFor: #packageName.	^( PluggableAdaptor on: self )		getBlock: [ :m | m hasFilter: index ]		putBlock: [ :m :v | m switchFilter: index perform: #packageName ]		updateBlock: [ :m :a :p | a == #filter and: [ p = index ] ]</body><body package="Tools-Changes">parcelFilterAdaptor	| index |	index := self checkBoxNumberFor: #parcelName.	^( PluggableAdaptor on: self )		getBlock: [ :m | m hasFilter: index ]		putBlock: [ :m :v | m switchFilter: index perform: #parcelName ]		updateBlock: [ :m :a :p | a == #filter and: [ p = index ] ]</body><body package="Tools-Changes">protocolFilterAdaptor	| index |	index := self checkBoxNumberFor: #category.	^(PluggableAdaptor on: self)		getBlock: [:m | m hasFilter: index]		putBlock: [:m :v | m switchFilter: index perform: #category]		updateBlock: [:m :a :p | a == #filter and: [p = index]]</body><body package="Tools-Changes">selectionInList	^selectionInList</body><body package="Tools-Changes">selectorFilterAdaptor	| index |	index := self checkBoxNumberFor: #selector.	^(PluggableAdaptor on: self)		getBlock: [:m | m hasFilter: index]		putBlock: [:m :v | m switchFilter: index perform: #selector]		updateBlock: [:m :a :p | a == #filter and: [p = index]]</body><body package="Tools-Changes">valueHolder	"Answer the receiver. The receiver is the value holder for a change's text."	^self</body><body package="Tools-Changes">valuesFilterAdaptor	| index |	index := self checkBoxNumberFor: #values.	^(PluggableAdaptor on: self)		getBlock: [:m | m hasFilter: index]		putBlock: [:m :v | m switchFilter: index perform: #values]		updateBlock: [:m :a :p | a == #filter and: [p = index]]</body></methods><methods><class-id>Tools.AbstractChangeList</class-id> <category>initialize-release</category><body package="Tools-Changes">initialize	"Initialize the receiver's instance variables."	super initialize.	self setValue: ''.	listName := ''.	changes := List new.	list := List new.	selectionIndex := 0.	filter := [:change | true].	removed := IdentitySet new.	filterList := #().	fieldList := #().	verticalConflicts := VerticalConflicts.	differencesMode := DifferencesMode.	classesDistinct := false.	selectionInList := SelectionInList with: list.	selectionInList selectionIndexHolder		onChangeSend: #selectionIndexChange		to: self.	menuBar := self class menuBar.	menuBar		augmentFrom: self class		to: AbstractChangeList		menuName: #menuBar		for: self.	menus := Dictionary new.</body><body package="Tools-Changes">openOn: aSequenceOfChanges	"Open up the receiver on the given set of changes."	changes := aSequenceOfChanges asList.	self updateList.	self open</body></methods><methods><class-id>Tools.AbstractChangeList</class-id> <category>doIt/accept/explain</category><body package="Tools-Changes">doItReceiver	"Return a suitable doItReceiver for doIts in the text view.	 For consistency with the Browser return the non-meta	 class of a change if valid, or nil otherwise."	^selectionIndex &gt; 0		ifTrue: [(list at: selectionIndex) nonMetaClassName asQualifiedReference valueOrDo: []]		ifFalse: []</body><body package="Tools-Changes">format: aText from: aController 	"Format the text. Have the controller replace its contents with the new Text, 	or nil if the format operation was unsuccessful."	| selectedClass aCompiler newText change node |	selectedClass := (change := list at: selectionIndex) classObject.	"For formatting any class will do."	selectedClass isNil ifTrue: [selectedClass := Object].	change isCommentChange		ifTrue: [newText := selectedClass formatComment: aText]		ifFalse:			[aCompiler := selectedClass compilerClass new.			node := aCompiler							parse: aText							in: selectedClass							notifying: aController.			node notNil ifTrue: [newText := node formattedCode].			(newText notNil			and: [change isClassDefinitionChange])				ifTrue: [newText := newText asText makeSelectorBoldIn: selectedClass]].	newText notNil		ifTrue:			[aController				selectFrom: 1 to: aController text size;				deselect;				replaceSelectionWith: newText asText;				selectAt: 1]		ifFalse: [aController view flash]</body></methods><methods><class-id>Tools.AbstractChangeList</class-id> <category>checking</category><body package="Tools-Changes">checkSystem	"Answer whether the receiver (as a conflict checker) is also checking with system."	^checkSystem notNil</body><body package="Tools-Changes">checkSystem: aBooleanOrSymbol	"Set the checking mode to allow the filtering of changes on filing in.	 Unlike checkWithSystem: do not do any checking. Return the previous	 checking mode."	| oldMode |	oldMode := checkSystem.	checkSystem := aBooleanOrSymbol isSymbol						ifTrue: [differencesMode := aBooleanOrSymbol] "use #code or #exact checking"						ifFalse: [aBooleanOrSymbol ifTrue: [#code]].	^oldMode</body><body package="Tools-Changes">checkSystemMethod	"Answer how the receiver (as a conflict checker) is checking with system."	^checkSystem isNil		ifTrue: [differencesMode]		ifFalse: [checkSystem]</body><body package="Tools-Changes">checkWithSystem: aBooleanOrSymbol 	"Produce the conflict list for the list of changes. If aBoolean is true, then also 	check with the system. After the conflict list is reproduced then 	checking-reporting methods can be called."	changeDict := Dictionary new.	self checkSystem: aBooleanOrSymbol.	list do: [:change |		(removed includes: change) ifFalse: [			change checkWith: self]]</body></methods><methods><class-id>Tools.AbstractChangeList</class-id> <category>selecting</category><body package="Tools-Changes">blankText 	self setValue: '' asText.	self changed: #value.	^'' asText</body><body package="Tools-Changes">deselect	"Deselect the current selection (if any) and display a null text."	selectionInList selectionIndex: ( selectionIndex := 0 ).	self blankText</body><body package="Tools-Changes">listIndex	"Answer the position of the current selection."	^selectionIndex</body><body package="Tools-Changes">toggleListIndex: anInteger	"If the item at position anInteger is selected, deselect it, or vice versa.	 The flow of control for viewing the selected change's value is a little	 convoluted.  If conflicts are not being shown then the change's text	 will be redisplayed if #value is changed.  If conflicts are being showing	 then change #existingText, which causes self existingText to happen,	 and within existingText the receiver's value is changed.  This means that	 the currently selected change's text isn't displayed twice if conflicts are	 being shown (first undifferentiated, immediately after differentiated), and	 we eliminate a horrible hack to do with changing the change's text by	 appending a space to get the highlighted version to be displayed."	selectionIndex = anInteger		ifTrue:			[self deselect]		ifFalse:			[selectionIndex := anInteger.			self showingConflicts ifFalse: [ self setValue: self selectionText  ] ].	self changed: #listIndex.	self showingConflicts		ifTrue: [self changed: #existingText]		ifFalse: [self changed: #value].	self setLabel</body><body package="Tools-Changes">toggleRemoveForListController: aController	"On double-click toggle the removed status of the current list entry."	| targetIndex selection |	(targetIndex := aController view targetIndex) = 0 ifTrue: [^self].	(removed includes: (selection := list at: targetIndex))		ifTrue: [removed remove: selection]		ifFalse: [removed add: selection].	self updateListSelection: targetIndex</body></methods><methods><class-id>Tools.AbstractChangeList</class-id> <category>fileIn/Out</category><body package="Tools-Changes">anyToFileOut	"Answer a boolean, true if there are non-removed entries, false if there are none"	list isEmpty ifTrue: [^false].	list do: [:next | (removed includes: next) ifFalse: [^true]].	^false</body><body package="Tools-Changes">doThis: listIndex	"Replay the change at listIndex in the list and update the entry."	(list at: listIndex) fileIn.	self updateSelection: listIndex</body><body package="Tools-Changes">fileOutOn: aSourceCodeStream	list do:		[:next |		(removed includes: next) ifFalse:			[next fileOutOn: aSourceCodeStream]].	aSourceCodeStream checkMethodChunkClass: nil protocol: nil</body><body package="Tools-Changes">includesFileName: aString	"Answer true if any of the non-removed changes in the list is 	from a file named aString."	list do:		[:change |		(removed includes: change) ifFalse:			[change fileName = aString ifTrue: [^true]]].	^false</body><body package="Tools-Changes">scanFile: aFileStream	"Obtain changes from aFileStream.  Depending on the checkSystem mode	 either read in all changes, or only changes which differ in source or code."	(aFileStream isExternalStream	and: [aFileStream fileName hasSourceExtension]) ifTrue:		[aFileStream lineEndTransparent].	Cursor read showWhile:		[[ChangeScanner new			scanFile: aFileStream			do:				[:change |				(nil == checkSystem				or: [(change sameAsSystem: self) not]) ifTrue:					[changes add: change]]]			ensure: [aFileStream close]].	listName isEmpty		ifTrue: [listName := aFileStream isExternalStream								ifTrue: [aFileStream name]								ifFalse: [(#someLocalStream &lt;&lt; #dialogs &gt;&gt; 'some local stream') asString]]		ifFalse:			[('*...' match: listName) ifFalse: [listName := listName, ' ...']].	self updateList</body><body package="Tools-Changes">scanFilename	"Prompt for the name of an existing file to scan."	| selections |	selections := Dialog				requestFileName: #NameOfFileToScanQ &lt;&lt; #dialogs						&gt;&gt; 'Name of file(s) to scan?'				default: TextEditorController currentSelection				version: #multipleOld				ifFail: [^self].	selections isCharacters		ifTrue: [self scanFilename: selections asFilename]		ifFalse: 			[selections asSortedCollection				do: [:each | self scanFilename: each asFilename]]</body></methods><methods><class-id>Tools.AbstractChangeList</class-id> <category>checking-change</category><body package="Tools-Changes">addChange: aChange	"Add a change to the receiver's collection of changes for ChangeSet adding."	changes add: aChange</body><body package="Tools-Changes">changesAt: changeName	^changeDict at: changeName ifAbsent: [#()]</body><body package="Tools-Changes">changesAt: changeName add: aChange	(changeDict at: changeName ifAbsent: [changeDict at: changeName put: OrderedCollection new])		add: aChange</body><body package="Tools-Changes">equalWithoutComments: text1 and: text2	| stream1 stream2 t |	stream1 := ReadStream on: text1.	stream2 := ReadStream on: text2.	[(t := self nextNonComment: stream1) = (self nextNonComment: stream2)]		whileTrue:			[t == nil ifTrue: [^true]].	^false</body></methods><methods><class-id>Tools.AbstractChangeList</class-id> <category>private-checking</category><body package="Tools-Changes">finishReportOn: aStream	"report conflicts among the changes"	| noConflicts additions addedClassNames |		(noConflicts := aStream isEmpty) ifTrue:		[Transcript cr; show: (#NoConflicts &lt;&lt; #dialogs &gt;&gt; '*** no conflicts ***').		aStream nextChunkPut: '"', (#NoConflicts &lt;&lt; #dialogs &gt;&gt; '*** no conflicts ***') asString, '"'; cr].	"Compute all the additions.  Eliminate redundant additions, i.e. if a	 new class is defined, just report the class, not its comment, methods	 etc, etc"	addedClassNames := Set new.	changeDict do:		[:changeCollection|		(changeCollection size = 1		and: [changeCollection first isClassDefinitionChange])			ifTrue:				[addedClassNames add: changeCollection first className]].			additions := Dictionary new.	changeDict do:		[:changeCollection|		changeCollection size = 1 ifTrue: [			(additions				at: changeCollection first fileName				ifAbsent: [additions								at: changeCollection first fileName								put: OrderedCollection new])				addLast: changeCollection first]].	additions size &gt; 0 ifTrue:		[noConflicts ifTrue:			[Transcript show: (#ButThereAreAdditions &lt;&lt; #dialogs &gt;&gt; ' (but there are additions)')].				additions keysAndValuesDo:			[:fileName :changeCollection|			aStream nextChunkPut: ((#AdditionsFrom1s &lt;&lt; #dialogs &gt;&gt; '"Additions from &lt;1s&gt;"')			expandMacrosWith: fileName); cr; cr.			(changeCollection asSortedCollection:					[:ca :cb|					ca class name &lt; cb class name					or: [ca class == cb class						and: [ca className &lt;= cb className]]])				do:					[:aChange|					(aChange isClassDefinitionChange					or: [(addedClassNames includes: aChange className) not])						ifTrue:							[self tabText: aChange name on: aStream]]]].			^aStream close</body><body package="Tools-Changes">identifySubset: contendors name: change on: reportStream"Report conflicts among the changes--if all of the changes are textually identical, there are no conflicts, so don't do a report"	| matched |	matched := true.	1 to: contendors size - 1 do: [:i | | firstText |		matched ifTrue: [			firstText := (contendors at: i) text.			i + 1 to: contendors size do: [:j | | secondText |				secondText := (contendors at: j) text.				matched := matched and: [firstText = secondText]]]].	matched ifFalse: [ | oldText |		reportStream cr; nextChunkPut: ((#ConflictC1s &lt;&lt; #dialogs &gt;&gt; '"*** conflict: &lt;1s&gt; ***"')			expandMacrosWith: change); cr.		oldText := '...'.		contendors do: [:contender |			oldText := self writeContender: contender on: reportStream oldText: oldText]]</body><body package="Tools-Changes">nextNonComment: sourceStream	"Return the next item from the sourceStream (assumed not atEnd),	carefully ignoring comments and separators."	| char sepr |	sepr := false.	[char := sourceStream peek.	char == nil ifTrue: [^nil].	char == $$ ifTrue: [sourceStream next.  ^sourceStream next].	"catch chars/strings"	char == $' ifTrue: [^String readFrom: sourceStream].	char == $"		ifTrue: [sourceStream next; skipThrough: $".  sepr := true]		ifFalse:			[char isSeparator				ifTrue: [sourceStream skipSeparators.  sepr := true]				ifFalse:					[sepr ifTrue: [^Character space].					sourceStream next.					^char]]] repeat</body><body package="Tools-Changes">reportChangesOn: reportStream"Report conflicts among the changes"	| contendors |	changeDict keys asSortedStrings do: [:change | 		contendors := changeDict at: change.		contendors size &gt; 1 ifTrue: [			self				identifySubset: contendors				name: change				on: reportStream]]</body><body package="Tools-Changes">reportConflictsOn: aStream"Report conflicts among the changes"	self reportChangesOn: aStream.	self finishReportOn: aStream</body><body package="Tools-Changes">tabText: text on: aStream	"report conflicts among the changes"	| cr previous terminator |	cr := Character cr.	terminator := $!.	previous := cr.	text do:		[:char |		char = cr ifFalse: [previous = cr ifTrue: [aStream tab]].		aStream nextPut: (previous := char).		char = terminator ifTrue: [aStream nextPut: char]].	aStream nextPut: terminator; cr</body><body package="Tools-Changes">writeContender: source on: aStream oldText: oldText	"Write out the change and answer the code of the source past the initial comment (for further comparisons)."	| text method endComment code |	aStream cr; nextChunkPut: ((#FileC1s &lt;&lt; #dialogs &gt;&gt; '"File: &lt;1s&gt;"')			expandMacrosWith: source fileName); cr.	text := source text.	(source isKindOf: MethodDefinitionChange) ifFalse:		[self tabText: text on: aStream.		^oldText].	method := ReadStream on: text.	method skipSeparators; skipThrough: Character cr; skipSeparators. 	"skip header"	(method peekFor: $")		ifTrue:			[method skipThrough: $"; skipSeparators].	endComment := method position.	code := method upToEnd.	(self equalWithoutComments: code and: oldText)		ifTrue:			[method reset.			aStream cr; nextPutAll: (method next: endComment);					nextPutAll: (#SameCodeExceptComments &lt;&lt; #dialogs &gt;&gt; '[SAME CODE AS ABOVE; COMMENT OR FORMAT DIFFERS]') asString; cr]		ifFalse:			[aStream cr; nextChunkPut: text; cr].	^code</body></methods><methods><class-id>Tools.AbstractChangeList</class-id> <category>testing</category><body package="Tools-Changes">isEmpty	"Answer if the receiver has no changes."	^changes isEmpty</body><body package="Tools-Changes">notEmpty	"Answer if the receiver has changes."	^changes notEmpty</body></methods><methods><class-id>Tools.AbstractChangeList</class-id> <category>private-menus</category><body package="Tools-Changes">buildTextMenu	| menu |	menu := Menu				labelList: (Array with: (Array with: #Accept &lt;&lt; #dialogs &gt;&gt; 'Accept')						with: (Array								with: #DoIt &lt;&lt; #dialogs &gt;&gt; 'Do it'								with: #PrintIt &lt;&lt; #dialogs &gt;&gt; 'Print it'								with: #InspectIt &lt;&lt; #dialogs &gt;&gt; 'Inspect it'								with: #DebugIt &lt;&lt; #dialogs &gt;&gt; 'Debug it'))							, TextEditorController editGroupLabels , (Array									with: (Array with: #ChangeTextStyle &lt;&lt; #dialogs &gt;&gt; 'Change Text Style')									with: (Array with: #Format &lt;&lt; #dialogs &gt;&gt; 'Format'											with: #Cancel &lt;&lt; #dialogs &gt;&gt; 'Cancel'))				values: #(#accept #doIt #printIt #inspectIt #debugIt)						, TextEditorController editGroupSelectors							, #(#changeTextStyle #format:from: #cancel).	(menu menuItemWithValue: #accept)		shortcutKeyCharacter: $S;		shortcutModifiers: 2.	#(#doIt #printIt #inspectIt #debugIt #cut #paste)		with: #($D $P $Q $B $X $V)		do: 			[:each :eachKey |			(menu menuItemWithValue: each)				labelImage: (ToolbarIconLibrary visualFor: each);				shortcutKeyCharacter: eachKey;				shortcutModifiers: 2].	(menu menuItemWithValue: #copySelection)		labelImage: (ToolbarIconLibrary visualFor: #copy);		shortcutKeyCharacter: $C;		shortcutModifiers: 2.	^menu</body><body package="Tools-Changes">hasItems	"Used for dynamically updating menus."	"Do I have any items that are displayed currently?"	^changes isEmpty not</body><body package="Tools-Changes">hasItemsDisplayed	"Used for dynamically updating menus."	"Do I have any items that are displayed currently?"	^list isEmpty not</body><body package="Tools-Changes">hasRemovedItems	"Used for dynamically updating menus."	^removed isEmpty not</body><body package="Tools-Changes">hasRemovedItemsDisplayed	"Used for dynamically updating menus. Do I have any 	 'removed' items that are displayed currently?"	^self hasRemovedItems and: [list contains: [:ea | removed includes: ea]]</body><body package="Tools-Changes">hasRemovedSelection	"Used for dynamically updating menus."	^self hasSelection and: [removed includes: self selection]</body><body package="Tools-Changes">hasSelection	"Used for dynamically updating menus."	^self selection notNil</body><body package="Tools-Changes">hasUnremovedItemsDisplayed	"Used for dynamically updating menus."	"Do I have any items that are displayed currently but haven't been removed?"	^self hasItemsDisplayed and: [list anySatisfy: [:ea | (removed includes: ea) not]]</body><body package="Tools-Changes">hasUnremovedSelection	"Used for dynamically updating menus."	^self hasSelection and: [(removed includes: self selection) not]</body></methods><methods><class-id>Tools.AbstractChangeList class</class-id> <category>resources</category><body package="Tools-Changes">changeListMenu	^self subclassResponsibility</body><body package="Tools-Changes">menuBar	^self subclassResponsibility</body></methods><methods><class-id>Tools.AbstractChangeList class</class-id> <category>initialize</category><body package="Tools-Changes">instanceMethodsChanged	"A Menu has changed.  Update all open ChangeList menuBars."	Screen default allScheduledWindowsDo:		[:each |		(each model isKindOf: self) ifTrue:			[each model rebuildMenu]]</body></methods><methods><class-id>Tools.OverrideList</class-id> <category>aspects</category><body package="Tools-Changes">labelFor: aKey	"Return a label for the existingText view."	aKey == #imageLabel ifTrue: [^self labelForImageText].	aKey == #changeLabel ifTrue: [^self labelForChangeText].	^nil</body></methods><methods><class-id>Tools.OverrideList</class-id> <category>menu messages</category><body package="Tools-Changes">findPackage	"Prompt and search for all changes of a given package. Select these changes"	self find: #packageName prompt: #package filter: #packageName</body><body package="Tools-Changes">findParcel	"Prompt and search for all changes of a given parcel. Select these changes"	self find: #parcelName prompt: #parcel filter: #parcelName</body><body package="Tools-Changes">getOverrides	changes :=  Override overrideList asList.	self  updateList</body><body package="Tools-Changes">getPackage	"Add a given Package's changes to the change list. Should be hidden if Store not loaded."	| selectedPackage overrides registry |	registry := #{Store.Registry} valueOrDo: [^self].	(selectedPackage := self queryForPackage: registry) isNil ifTrue:		[^self].	overrides := selectedPackage overrides.	overrides isEmpty ifTrue: 		[^Dialog warn: ((#IsHasNotBeenOverridden &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; has not been overridden.') expandMacrosWith: selectedPackage name)].	changes addAll: (Override sortOverridesForLoading: overrides).	self updateList</body><body package="Tools-Changes">getParcel	"Add a given Parcel's changes to the change list."	| parcelName overrides |	(parcelName := self queryParcel) isNil ifTrue: [^self].	overrides := (Parcel parcelNamed: parcelName) overrides.	overrides isEmpty ifTrue: [^Dialog warn: ((#IsHasNotBeenOverridden &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; has not been overridden.') expandMacrosWith:  parcelName)].	changes addAll: (Override sortOverridesForLoading: overrides).	self updateList</body><body package="Tools-Changes">purgeSelection	selectionIndex == 0		ifTrue: [ ^Dialog warn: (#NoSelection &lt;&lt; #dialogs &gt;&gt; 'No selection') ].	list := Array with: ( changes at: selectionIndex ).	( self purgeWarning: list )		ifTrue: [ self purge: list ].</body><body package="Tools-Changes">purgeThese	"Removes the removed overrides from the system"	| toBeForgotten |	removed isEmpty		ifTrue: [ ^Dialog warn: (#NoOverridesHaveBeenMarked &lt;&lt; #dialogs &gt;&gt; 'No overrides have been marked') ].	( self purgeWarning: removed )		ifFalse: [ ^self ].	toBeForgotten := removed.	removed := IdentitySet new.	changes := changes reject: [ :over | toBeForgotten includes: over ].	self purge: toBeForgotten.</body></methods><methods><class-id>Tools.OverrideList</class-id> <category>private</category><body package="Tools-Changes">fieldTemplates	"return the templates for the fields (show file etc)"	^#(#(showComponent showProtocol showConflicts)		#(systemComponentString systemCategory conflicts))</body><body package="Tools-Changes">filterTemplates	"return the templates for the filters"	^#(	#( filterByParcel filterByPackage filterByType filterByClass filterByProtocol 			filterBySelector filterBySame )		#( parcelName packageName type className category selector values))</body><body package="Tools-Changes">getWriteFilenameWithPrompt: promptString do: actionBlock	"Find out the file name of a file to write to using the Filename utility that	prompts for existing files."	| fileName |	fileName := Dialog requestNewFileName: promptString				default: TextEditorController currentSelection.	fileName isEmpty		ifFalse: [Cursor write showWhile: [actionBlock value: fileName asFilename]]</body><body package="Tools-Changes">labelForChangeText	| over |	^selectionIndex &gt; 0 		ifTrue: [ 			over := list at: selectionIndex.			(#Inactive1s &lt;&lt; #dialogs &gt;&gt; '[inactive] &lt;1s&gt;') expandMacrosWith: over inactiveVersionLabel]		ifFalse: [#SelectedOverride &lt;&lt; #dialogs &gt;&gt; 'Selected Override']</body><body package="Tools-Changes">labelForImageText	^selectionIndex &gt; 0 		ifTrue: [			| over |			over := list at: selectionIndex.			(#Current1s &lt;&lt; #dialogs &gt;&gt; '[current] &lt;1s&gt;') expandMacrosWith: over systemVersionLabel]		ifFalse: [#SystemVersion &lt;&lt; #dialogs &gt;&gt; 'System version']</body><body package="Tools-Changes">purge: overrides	overrides do:		[ :override |		changes remove: override ifAbsent: [ ].		removed remove: override ifAbsent: [ ].		override purge.		selectionIndex := 0.		self updateList.		self makeChangesVisible		].</body><body package="Tools-Changes">purgeWarning: overrides	"Display a warning before purging overrides."	| classes namespaces |	classes := overrides select: [ :o | o isForClass ].	namespaces := overrides select: [ :o | o isForNameSpace ].	( Dialog confirm: (#PurgingOverridesWarning &lt;&lt; #dialogs &gt;&gt; '  Purged overrides will be removed from&lt;n&gt;their components and cannot be restored.&lt;nttt&gt;Continiue?') expandMacros )		ifFalse: [ ^false ].	classes isEmpty		ifFalse: 			[ ( Dialog confirm: (#PurgingClassOverridesWarning &lt;&lt; #dialogs &gt;&gt; 'Purging class overrides may invalidate methods or shared variables&lt;n&gt;owned by that class that are still in these components.&lt;ntttt&gt;Continue?') expandMacros )				ifFalse: [ ^false ].			].	namespaces isEmpty		ifFalse: 			[ ( Dialog confirm: (#PurgingNameSpaceOverridesWarning &lt;&lt; #dialogs &gt;&gt; 'Purging namespaces overrides may invalidate&lt;n&gt;any contents remaining in the components.&lt;nttt&gt;Continue?') expandMacros )				ifFalse: [ ^false ].			].	^true</body><body package="Tools-Changes">queryForPackage: registry 	"Let the user select a Package from a list.  Return the selected 	 package or nil if one was not selected."	| packages |	packages := registry allPackages asSortedCollection: [:a :b | a name &lt; b name].	^Dialog 		choose: (#DisplayWhichPackage &lt;&lt; #dialogs &gt;&gt; 'Display which Package?')		fromList: (packages collect: [:each | each name])		values: packages		lines: 20		cancel: [nil]</body><body package="Tools-Changes">setMenuState	"The primary function of this UI is to show conflicts, which is always turned on, so avoid the superfluous indication."	super setMenuState.	(menuBar atNameKey:#showConflicts) indication: false</body></methods><methods><class-id>Tools.OverrideList</class-id> <category>accessing</category><body package="Tools-Changes">listName	"Answer the label for a browser on the receiver. The default is Change List."	listName size = 0		ifTrue: [^(#OverrideList &lt;&lt; #labels &gt;&gt; 'Override List') asString]		ifFalse: [^listName]</body><body package="Tools-Changes">noConflictTextFor: over	"Answer a Text corresponding to the conflicting text of the selected item in the system.	This is in fact, the reason why there is no text to compare to. Answer nil if okay to compare."	| conflictText |	over targetObject == nil		ifTrue: [ conflictText := ((#x1sNotInSystem &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; not in system')			expandMacrosWith: over classDescription) asText emphasizeAllWith: #italic]		ifFalse: 			[ ( self conflictTextFor: over ) == nil 				ifTrue: 					[ conflictText := (( over hasVersionInSystem						ifTrue: [ (#x1sSourceNotAvailable &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; source not available') ]						ifFalse: [ (#x1sNotInSystem &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; not in system') ] ) 							expandMacrosWith: over classDescription)								asText emphasizeAllWith: #italic					].			].	over isSameAsImage 		ifTrue: [ conflictText := (#NoConflict &lt;&lt; #dialogs &gt;&gt; 'no conflict') asText emphasizeAllWith: #italic ].	^conflictText</body></methods><methods><class-id>Tools.OverrideList</class-id> <category>initialize-release</category><body package="Tools-Changes">openOn: aSequenceOfChanges	"Open up the receiver on the given set of changes."	changes := ( Override sortOverridesForLoading: aSequenceOfChanges ) asList.	self updateList.	self open</body></methods><methods><class-id>Tools.OverrideList</class-id> <category>interface opening</category><body package="Tools-Changes">postOpenWith: aBuilder 	| visible |	super postOpenWith: aBuilder.	visible := #{Store} isDefined.	(menuBar atNameKey: #findPackage) visibility: visible.	(menuBar atNameKey: #filterByPackage) visibility: visible.	(menuBar atNameKey: #getPackage) visibility: visible.	(self wrapperAt: #packageFilter) isEnabled: visible.	"The primary function of this UI is to show conflicts, so it's always turned on."	self showConflicts: true.</body></methods><methods><class-id>Tools.OverrideList</class-id> <category>menu bar actions</category><body package="Tools-Changes">toggleShowComponent	self fieldMessage: #showComponent</body></methods><methods><class-id>Tools.OverrideList</class-id> <category>fileIn/Out</category><body package="Tools-Changes">includesFileName: aString	"Answer true if any of the non-removed changes in the list is 	from a file named aString."	^false</body></methods><methods><class-id>Tools.ChangeSetManager</class-id> <category>events</category><body package="Tools-Changes">noticeOfWindowClose: aWindow	super noticeOfWindowClose: aWindow.	self release</body></methods><methods><class-id>Tools.ChangeSetManager</class-id> <category>actions</category><body package="Tools-Changes">browseChangedMethods	"Launch a method browser for all the changes in the change set." 	self class browseChangedMethodsIn: self currentPackage</body><body package="Tools-Changes">browseImplementors	"Browse implementors of a particular message from code in the	 selected change set, or in all change sets, if none is selected."	| symbol theList title |	symbol := SmalltalkWorkbench					promptForSelector: (#findImplementorsOfWhat &lt;&lt; #dialogs &gt;&gt; 'Find implementors of what?')					for: builder window.	symbol isNil ifTrue: [^self].	self listModel selection isNil		ifTrue:			[title := (#implementorsOfXWithinChangeSets &lt;&lt; #labels &gt;&gt; 'Implementors of &lt;1s&gt; within change sets') 				expandMacrosWith: symbol storeString.			theList := OrderedCollection new: 100.			listModel list do:				[:cs|				theList addAll: ((cs implementorsOf: symbol) collect: 					[:md| md extraText: ((#selectorXinChangeSetY &lt;&lt; #labels &gt;&gt; '&lt;tt&gt;-- in &lt;1s&gt;') expandMacrosWith: cs name). md])]]		ifFalse:			[title := (#referencesToXWithinY &lt;&lt; #labels &gt;&gt; 'References to &lt;1s&gt; within &lt;2s&gt;')				expandMacrosWith: symbol storeString with: self currentPackage name.			theList := self currentPackage implementorsOf: symbol].	theList isEmpty ifTrue:		[^Dialog warn: (#nobody &lt;&lt; #dialogs &gt;&gt; 'Nobody')].	MethodCollector new		openListBrowserOn: theList		label: title		initialSelection: (symbol isSymbol								ifTrue: [symbol]								ifFalse: [symbol storeString])</body><body package="Tools-Changes">browseSenders	"Browse senders of a particular message from code in the	 selected change set, or in all change sets, if none is selected."	| symbol literal theList title |	symbol := SmalltalkWorkbench		promptForSelector: (#findReferencesToWhat &lt;&lt; #dialogs &gt;&gt; 'Find references to what?')		for: builder window.	symbol isNil ifTrue: [^self].	literal := Smalltalk bindingFor: symbol.	literal == nil ifTrue: [literal := symbol].	self listModel selection isNil		ifTrue:			[title := (#referencesToXWithinChangeSets &lt;&lt; #labels &gt;&gt; 'References to &lt;1s&gt; within change sets')				expandMacrosWith: symbol storeString.			theList := OrderedCollection new: 100.			listModel list do:				[:cs|				theList addAll: ((cs sendersOf: literal) collect: 					[:md | md extraText: ((#selectorXinChangeSetY &lt;&lt; #labels &gt;&gt; '&lt;tt&gt;-- in &lt;1s&gt;') expandMacrosWith: cs name). md])]]		ifFalse:			[title := (#referencesToXWithinY &lt;&lt; #labels &gt;&gt; 'References to &lt;1s&gt; within &lt;2s&gt;')				expandMacrosWith: symbol storeString with: self currentPackage name.			theList := self currentPackage sendersOf: literal].	theList isEmpty ifTrue:		[^Dialog warn: (#nobody &lt;&lt; #dialogs &gt;&gt;'Nobody')].	MethodCollector new		openListBrowserOn: theList		label: title		initialSelection: (symbol isSymbol								ifTrue: [symbol]								ifFalse: [symbol storeString])</body><body package="Tools-Changes">changeSetBeCurrent	self listModel selectionDo:		[:selection | ChangeSet current: selection]</body><body package="Tools-Changes">deleteChangeSet	self class removeChangeSet: self currentPackage</body><body package="Tools-Changes">editChangeSet	| cs |	self changeSetBeCurrent.	cs := ChangeEditor new.	cs sourceHolder: ChangeSet currentChangeSetHolder.	self addDependent: cs.	cs open</body><body package="Tools-Changes">emptyChangeSet	self class forgetChangesIn: self currentPackage.	self refreshSelection</body><body package="Tools-Changes">expungeCurrentProjectFromSystem	self class removeFromSystemChangesIn: self currentPackage.</body><body package="Tools-Changes">fileInFrom	"Read in some code."	self class fileIntoChangeSet: self currentPackage</body><body package="Tools-Changes">fileOutAllChangeSets	self class fileOutAllChangeSets: listModel list.	self refreshSelections</body><body package="Tools-Changes">fileOutChangeSet	self class fileOutChangeSet: self currentPackage.	self refreshSelection</body><body package="Tools-Changes">findClass	"Select the next project in the list referring to class."	| nameString className |	nameString := Dialog request: (#findChangeSetReferringToClass &lt;&lt; #dialogs &gt;&gt; 'Find change set referring to class:').	nameString isEmpty ifTrue: [^self].	((className := Symbol findInterned: nameString) notNil	and: [ className asQualifiedReference isDefined ]) ifFalse:		[className := (Smalltalk allClassNames						inject: 0-&gt;nil						into: [:choice :name| choice max: (nameString spellAgainst: name) -&gt; name]) value].	className isNil ifFalse:		[className := className asString. "ChangeSets store class names as strings, not symbols"		listModel selectionIndex + 1			to: listModel list size			do: [:csi|				((listModel list at: csi) refersToClassNamed: className) ifTrue:					[^listModel selectionIndex: csi]]].	Dialog warn: 		((#noChangeSetsReferToClassX &lt;&lt; #dialogs &gt;&gt; 'No ChangeSets refer to class &lt;1s&gt;')			expandMacrosWith: className)</body><body package="Tools-Changes">findSelector	"Select the next project in the list referring to selector."	| response selector |	response := Dialog request: (#findChangeSetReferringToSelector &lt;&lt; #dialogs &gt;&gt; 'Find change set referring to selector:').	response isEmpty ifTrue: [^self].	((selector := Symbol findInterned: response) isNil	and: [(selector := Symbol correctMessage: response) isNil]) ifTrue: [^self].	listModel selectionIndex + 1		to: listModel list size		do: [:csi|			((listModel list at: csi) refersToSelector: selector) ifTrue:				[^listModel selectionIndex: csi]].	^Dialog warn: 		((#noChangeSetsReferToSelectorX &lt;&lt; #dialogs &gt;&gt; 'No ChangeSets refer to selector &lt;1p&gt;') expandMacrosWith: selector)</body><body package="Tools-Changes">helpAbout	AboutVisualWorksDialog open</body><body package="Tools-Changes">helpChangeSetBrowser	'topic:vw.help.tools.changeSet' asURI open</body><body package="Tools-Changes">helpChangesAndChangeSets	'topic:vw.help.systemChanges' asURI open</body><body package="Tools-Changes">importChangeSets		self class fileIntoNewChangeSets</body><body package="Tools-Changes">inspectChangeSet	self currentPackage copy inspect</body><body package="Tools-Changes">newChangeSet	self class createChangeSet</body><body package="Tools-Changes">renameChangeSet	| current |	current := self currentPackage.	self class renameChangeSet: current.	self listModel selection: current.	self refreshSelection</body></methods><methods><class-id>Tools.ChangeSetManager</class-id> <category>private</category><body package="Tools-Changes">currentChangeSetIcon	^currentSetIcon ifNil: 		[currentSetIcon := ToolbarIconLibrary visualFor: #edit]</body><body package="Tools-Changes">currentPackage	^self listModel selection</body><body package="Tools-Changes">listMenu	self updateListMenu.	^listMenu</body><body package="Tools-Changes">menuBar	menuBar := self class menuBar.	menuBar isNil ifTrue: [^Menu new].	[menuBar 		augmentFrom: self class 		to: ChangeSetManager 		menuName: #menuBar 		for: self]  			on: Object errorSignal  			do: [:ex | ex return].	^menuBar</body><body package="Tools-Changes">rebuildMenuBar	menuBar notNil		ifTrue:			[self				rebuildMenu: menuBar				with: self menuBar				augmentTo: ChangeSetManager]</body><body package="Tools-Changes">refreshSelection	self listModel list changed: #at: with: self listModel selectionIndex</body><body package="Tools-Changes">refreshSelections	| list |	list := self listModel list.	1 to: list size do: [:index| list changed: #at: with: index]</body><body package="Tools-Changes">statusColumnSpec	^ArbitraryViewSpec new		source: #statusColumnVisual:;		flags: 0</body><body package="Tools-Changes">statusColumnVisual: isCurrent	^isCurrent 		ifTrue: [self currentChangeSetIcon]		ifFalse: [VisualPart new]</body></methods><methods><class-id>Tools.ChangeSetManager</class-id> <category>aspects</category><body package="Tools-Changes">currentChangeSetHolder	^nil asValue</body><body package="Tools-Changes">listModel	^listModel</body></methods><methods><class-id>Tools.ChangeSetManager</class-id> <category>updating</category><body package="Tools-Changes">changeSetSelected	"The current change set selection has changed independently	from us. The whole view needs updating to reflect reality."	(self widgetAt: #listModel) ifNotNil: [:list | list invalidate]</body><body package="Tools-Changes">update: aspectSymbol with: parameterObject from: originatorObject	^originatorObject == ChangeSet		ifTrue: [self updateCurrentChangeSetEntry]		ifFalse: [super update: aspectSymbol with: parameterObject from: originatorObject]</body><body package="Tools-Changes">updateCurrentChangeSetEntry	| index |	self builder notNil ifTrue:		[index := self listModel list indexOf: ChangeSet current.		index ~= 0 ifTrue:			[(self widgetAt: #listModel) updateAt: index]]</body><body package="Tools-Changes">updateListMenu	| menu |	menu := self class listMenu.	menu 		augmentFrom: self class		to: ChangeSetManager		menuName: #listMenu		for: self.	listMenu value: menu</body></methods><methods><class-id>Tools.ChangeSetManager</class-id> <category>initialize-release</category><body package="Tools-Changes">initialize	listModel := SelectionInList with: NamedChangeSet changeSetList.	self listModel selection: ChangeSet current.	ChangeSet currentChangeSetHolder onChangeSend: #changeSetSelected to: self.	ChangeSet addDependent: self.	listMenu := nil asValue</body><body package="Tools-Changes">postBuildWith: aBuilder 	| descriptors |	super postBuildWith: aBuilder.	builder window		application: self;		sendWindowEvents: #(#newGraphicsDevice).	descriptors := (self widgetAt: #listModel) columnDescriptors.	descriptors first rendererSpec: self statusColumnSpec</body><body package="Tools-Changes">release	super release.	ChangeSet currentChangeSetHolder retractInterestsFor: self.	ChangeSet removeDependent: self</body></methods><methods><class-id>Tools.ChangeSetManager</class-id> <category>testing</category><body package="Tools-Changes">isChangeSetSelected	^self listModel selectionIndex ~= 0</body></methods><methods><class-id>Tools.ChangeSetManager class</class-id> <category>utilities</category><body package="Tools-Changes">browseChangedMethodsIn: aChangeSet	"Create a browser on the changed message list."	| changes |	changes := aChangeSet changedMessageList.	changes := changes, (aChangeSet changedObjects select: [:each | each isBindingReference]) asSortedCollection asArray.	MethodCollector new		openListBrowserOn: changes		label: ((#ChangedMethodsInChangeSet &lt;&lt; #dialogs &gt;&gt; 'Changed Methods in Change Set &lt;1s&gt;') expandMacrosWith: self current name asString)</body><body package="Tools-Changes">createChangeSet	| newSetName newSet |	newSetName := NamedChangeSet		requestUniqueName: (#createChangeSetNamed &lt;&lt; #dialogs &gt;&gt; 'Create change set named:')		initial: ''		ifCancel: [^self].	newSet := NamedChangeSet withName: newSetName asSymbol.	NamedChangeSet addChangeSet: newSet.	ChangeSet current: newSet</body><body package="Tools-Changes">fileIntoChangeSet: aChangeSet	"Read in some code."	| filename |	filename := Dialog				requestFileName: (#PleaseTypeAFileNameC &lt;&lt; #dialogs &gt;&gt; 'Please type a file name:')				default: ChangeSet current name, '.st'				version: #mustBeOld				ifFail: [''].	filename isEmpty ifTrue: [ ^self ].	Notice		show: (#FilingInN1S &lt;&lt; #dialogs &gt;&gt; 'Filing in&lt;n&gt;&lt;1s&gt;' expandMacrosWith: filename asString)		while: 			[ | source |			source := (filename asFilename withEncoding: #Source) readStream.			[aChangeSet fileInFrom: source] ensure: [source close]]</body><body package="Tools-Changes">fileIntoNewChangeSets	| selections |	selections := Dialog				requestFileName: #NameOfFilesToImport &lt;&lt; #dialogs						&gt;&gt; 'Name of file(s) to import?'				default: TextEditorController currentSelection				version: #multipleOld				ifFail: [^self].	"At least the win32 native dialog returns the sequence in a screwy order.	 Sorted order is at least consistent and workable."	(selections isCharacters		ifTrue: [Array with: selections]		ifFalse: [selections asSortedCollection]) do: 				[:file |				Cursor read showWhile: 						[| changeSetName |						changeSetName := self changeSetNameFor: file asFilename.												[changeSetName ~= 'Default' or: 								[Dialog									confirm: (#OKToUseDefault &lt;&lt; #dialogs											&gt;&gt; 'Are you sure you want to use Default&lt;n&gt;as the target ChangeSet?')												expandMacros]]								whileFalse: 									[changeSetName := Dialog request: #NewNameForChangeSet &lt;&lt; #dialogs														&gt;&gt; 'Please supply a new name for the ChangeSet'].						self importChangeSetFrom: file asFilename named: changeSetName]]</body><body package="Tools-Changes">fileOutAllChangeSets: aCollection	| directory stream |	directory := Dialog					requestDirectoryName: (#FileOutDirectoryForChangeSets &lt;&lt; #dialogs &gt;&gt; 'File out projects on which directory?')					default: (#projects &lt;&lt; #dialogs &gt;&gt; 'projects') asString.	directory isEmpty ifTrue: [^self].	(directory := directory asFilename) exists		ifTrue: [directory isDirectory ifFalse: [^Dialog warn: ((#FileIsNotADirectory &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; exists but is not a directory')			expandMacrosWith: directory asString)]]		ifFalse: [directory makeDirectory].	aCollection do:		[:each | | fileName |		fileName := directory constructString: (Filename filterFilename: (each name copyWithout: Character space), Filename changeExtension).		stream := SourceCodeStream write: fileName.		Cursor write showWhile:			[[each fileOutOn: stream] ensure: [stream close]]]</body><body package="Tools-Changes">fileOutChangeSet: aChangeSet		| fileName oldSeparator |	fileName := aChangeSet lastFileOutName.	(fileName isNil or: [(fileName := fileName asString) isEmpty])		ifTrue: [fileName := aChangeSet name asString , '.st'].	oldSeparator := (fileName includes: UnixFilename separator)		ifTrue: [UnixFilename separator]		ifFalse:			[(fileName includes: PCFilename separator)				ifTrue: [PCFilename separator]				ifFalse: [nil]].	fileName		replaceAll: oldSeparator		with: Filename separator.	fileName := fileName asFilename.	fileName := fileName directory		construct: (fileName tail copyWithout: Character space).	fileName := Dialog		requestNewFileName:			#FileOutAsFileNamed &lt;&lt; #dialogs &gt;&gt; 'File out as file named'		default: fileName.	fileName isEmpty ifTrue: [^self].	Cursor write		showWhile:			[| stream |			stream := SourceCodeStream write: fileName.			[aChangeSet fileOutOn: stream] ensure: [stream close]]</body><body package="Tools-Changes">forgetChangesIn: aChangeSet	(Dialog confirm: (#emptyThisChangeSet &lt;&lt; #dialogs &gt;&gt; 'Empty this change set?'))		ifTrue: [aChangeSet initialize]</body><body package="Tools-Changes">removeChangeSet: aChangeSet	aChangeSet name = #Default ifTrue:		[ ^Dialog warn: #defaultChangeSetCannotBeRemoved &lt;&lt; #dialogs &gt;&gt; 'Default change set cannot be removed.' ].	aChangeSet isEmpty ifFalse:		[(Dialog confirm: #changeSetNotEmptyAreYouSure &lt;&lt; #dialogs &gt;&gt; 'This change set is not empty. Are you sure you want to remove it?')			ifFalse: [^self]].	aChangeSet = ChangeSet current ifTrue:		[ChangeSet current: NamedChangeSet default].	NamedChangeSet removeChangeSet: aChangeSet</body><body package="Tools-Changes">removeFromSystemChangesIn: aChangeSet	"Remove the changes the change set contains."	(Dialog confirm: #allMethodsAndClassesWillBeRemovedAreYouSure &lt;&lt; #dialogs &gt;&gt; 'All methods and classes in this change set will be removed from the image. Are you sure?')  ifFalse: [^self].	(Dialog confirm: #areYouReallyReallySure &lt;&lt; #dialogs &gt;&gt; 'Are you really really sure?')  ifFalse: [^self].	aChangeSet sendTheInfidelToParadise</body><body package="Tools-Changes">renameChangeSet: aChangeSet	| oldName newName |	oldName := aChangeSet name.	newName := NamedChangeSet		requestUniqueName: #renameChangeSetTo &lt;&lt; #dialogs &gt;&gt; 'Rename change set to:'		initial: oldName		ifCancel: [^self].	aChangeSet name: newName asSymbol.	oldName = #Default 		ifTrue: [NamedChangeSet addChangeSet: (NamedChangeSet withName: #Default)]		ifFalse: [NamedChangeSet sortChangeSetList]</body></methods><methods><class-id>Tools.ChangeSetManager class</class-id> <category>class initialization</category><body package="Tools-Changes">instanceMethodsChanged	"A Menu has changed.  Update all open Launcher menuBars."	Screen default allScheduledControllersDo: 			[:ctrlr | 			(ctrlr model isKindOf: self) 				ifTrue: 					[ctrlr model						rebuildMenuBar;						updateListMenu]]</body></methods><methods><class-id>Tools.ChangeSetManager class</class-id> <category>current set access</category><body package="Tools-Changes">current	"Obsolete"	^ChangeSet current</body><body package="Tools-Changes">newChanges: aChangeSet 	"Obsolete"	ChangeSet current: aChangeSet</body><body package="Tools-Changes">noChanges	"Reset the current change set."	"self noChanges"	ChangeSetManager current initialize</body></methods><methods><class-id>Tools.ChangeSetManager class</class-id> <category>interface opening</category><body package="Tools-Changes">open	"Override to use the currently-open manager, if one exists."	^self raiseSingleInstance ifNil: [super open]</body></methods><methods><class-id>Tools.ChangeSetManager class</class-id> <category>private</category><body package="Tools-Changes">changeSetNameFor: aFilename	| stream |	stream := aFilename readStream.	^[| pattern changeSetName |		pattern := 'Changes in change set '.		((stream skipToAll: pattern) isNil 				or: [(stream skip: pattern size).					(changeSetName := stream upToAll: ' --') isNil]) 			ifTrue:				[^aFilename tail copyReplaceAll: aFilename extension with: ''].		 changeSetName]			ensure: [stream close]</body><body package="Tools-Changes">importChangeSetFrom: aFilename named: aString	| nameSymbol changeSet stream |	((nameSymbol := Symbol findInterned: aString) isNil	 or: [(changeSet := NamedChangeSet lookup: nameSymbol) isNil]) ifTrue:		[changeSet := NamedChangeSet withName: aString asSymbol.		 NamedChangeSet addChangeSet: changeSet].	stream := (aFilename asFilename withEncoding: #Source) readStream.	Notice		show: (#FilingInN1S &lt;&lt; #dialogs &gt;&gt; 'Filing in&lt;n&gt;&lt;1s&gt;' expandMacrosWith: aFilename asString)		while: [[changeSet fileInFrom: stream] ensure: [stream close]]</body></methods><methods><class-id>Tools.ChangeEditor</class-id> <category>initialize-release</category><body package="Tools-Changes">initialize	classList := SelectionInList new.	methodList := SelectionInList new.	menus := Dictionary new.	destinationList := SelectionInList with: (self changeSetClass changeSetList).	text := String new asValue.	changeType := nil asValue.	classRemove := false asValue.	classRename := false asValue.	classComment := false asValue.	classOrganize := false asValue.	mode := #none.	classList selectionIndexHolder onChangeSend: #setMethodList to: self.	methodList selectionIndexHolder onChangeSend: #setTextAndFlags to: self.	destinationList selectionIndexHolder onChangeSend: #setTextAndFlags to: self.	changeType onChangeSend: #changedChangeType to: self.	classComment onChangeSend: #changedClassComment to: self.	classOrganize onChangeSend: #changedClassOrganize to: self.	self sourceHolder: self changeSetManager current asValue.</body><body package="Tools-Changes">sourceHolder: aSourceHolder	source notNil ifTrue: [source retractInterestsFor: aSourceHolder].	source := aSourceHolder.	source onChangeSend: #changedSource to: self.	self changedSource</body></methods><methods><class-id>Tools.ChangeEditor</class-id> <category>aspects</category><body package="Tools-Changes">changeType	^changeType</body><body package="Tools-Changes">classComment	^classComment</body><body package="Tools-Changes">classList	^classList</body><body package="Tools-Changes">classOrganize	^classOrganize</body><body package="Tools-Changes">classRemove	^classRemove</body><body package="Tools-Changes">classRename	^classRename</body><body package="Tools-Changes">destinationList	^destinationList</body><body package="Tools-Changes">methodList	^methodList</body><body package="Tools-Changes">text	^text</body></methods><methods><class-id>Tools.ChangeEditor</class-id> <category>actions</category><body package="Tools-Changes">acceptText: aTextEditorController	"If we're displaying a change set's comment, then update the comment."	| string |	self className notNil ifTrue:		[aTextEditorController view flash. ^false].	self destination isNil		ifTrue:			[(string := aTextEditorController text string) ~= self computeText string ifTrue:				[source value comment: (string size &gt; 0 ifTrue: [string])]]		ifFalse:			[self editDoits].	text value: self computeText.	^true</body><body package="Tools-Changes">browseClass	| class |	(class := self currentSource classNamed: self className) isBehavior		ifTrue: [SmalltalkWorkbench browseClass: class]		ifFalse: [Screen default ringBell]</body><body package="Tools-Changes">copyAllClasses	classList list do:		[:eachClass |		self currentSource copy: eachClass to: self destination].</body><body package="Tools-Changes">copyClass	(self className isNil or: [self destination isNil]) ifTrue: [^nil].	self currentSource copy: self className to: self destination</body><body package="Tools-Changes">copyMethod	(self method isNil or: [self destination isNil]) ifTrue: [^nil].	self currentSource copy: self className method: self method to: self destination</body><body package="Tools-Changes">editDoits	| stream doIts |	stream := text value readStream.	doIts := OrderedCollection new.	[stream atEnd] whileFalse:		[(doIts addLast: stream nextChunk) isEmpty ifTrue:			[doIts removeLast]].	self destination doIts: doIts</body><body package="Tools-Changes">forgetClass	| theName theChangeSet |	(theName := self className) isNil ifTrue: [^nil].	((theChangeSet := self currentSource) representsComponent: theName)		ifTrue:			[theChangeSet removeAllChangesForComponent: theName]		ifFalse:			[theChangeSet forget: theName].	self setClassList</body><body package="Tools-Changes">forgetComponentChange: aComponentChange in: componentName	self currentSource forgetComponentChange: aComponentChange in: componentName.	self setClassList</body><body package="Tools-Changes">forgetMethod	self method isNil ifTrue: [^nil].	( self currentSource representsComponent: self className )		ifTrue: [ ^self forgetComponentChange: self method in: self className ].	self currentSource removeSelectorChanges: self method class: self selectedClass. 	(self currentSource listOfClasses includes: self className)			ifTrue: [self setMethodList]			ifFalse: [self setClassList]</body><body package="Tools-Changes">moveAllClasses	classList list do:		[:eachClass |		self currentSource copy: eachClass to: self destination.		self currentSource forget: eachClass].	self setClassList</body><body package="Tools-Changes">moveClass	(self className isNil or: [self destination isNil]) ifTrue: [^nil].	self currentSource copy: self className to: self destination.	self currentSource forget: self className.	self setClassList</body><body package="Tools-Changes">moveMethod	| theMethod theSource theName |	((theMethod := self method) isNil or: [self destination isNil])		ifTrue: [^nil].	(theSource := self currentSource)		copy: (theName := self className)		method: theMethod		to: self destination.	(theSource representsComponent: theName)		ifTrue: [theSource removeComponentChange: theMethod]		ifFalse: [theSource removeSelectorChanges: theMethod class: self selectedClass].	(theSource methodChangesAt: self className) isEmpty		ifTrue: [self setClassList]		ifFalse: [self setMethodList]</body><body package="Tools-Changes">spawnMethod	| class definition |	self method isNil ifTrue: [^nil].	((class := self currentSource classNamed: self className) isBehavior	and: [class includesSelector: self method asSymbol])		ifTrue:			[definition := MethodDefinition class: class selector: self method asSymbol.			MethodCollector new				openListBrowserOn: (Array with: definition)				label: ((#CurrentDefinitionOf1s &lt;&lt; #dialogs &gt;&gt; 'Current Definition of &lt;1s&gt;')			expandMacrosWith: definition simpleDisplayString)]		ifFalse: [Screen default ringBell]</body><body package="Tools-Changes">updateClasses 	self setClassList</body></methods><methods><class-id>Tools.ChangeEditor</class-id> <category>menus</category><body package="Tools-Changes">classMenu	^[self getClassMenu]</body><body package="Tools-Changes">getClassMenu	self className isNil ifTrue: [^nil].	^(self destination isNil or: [self destination  == self currentSource])		ifTrue: [self shortClassMenu]		ifFalse:[self longClassMenu]</body><body package="Tools-Changes">getMethodMenu	self method isNil ifTrue: [^nil].	^(self destination isNil or: [self destination == self currentSource])		ifTrue: [self shortMethodMenu]		ifFalse: [self longMethodMenu]</body><body package="Tools-Changes">longClassMenu	^menus 		at: #longClassMenu 		ifAbsentPut: [			Menu				labelArray: (OrderedCollection new						add: (#Browse &lt;&lt; #menus &gt;&gt; 'Browse');						add: (#Move &lt;&lt; #menus &gt;&gt; 'Move');						add: (#Copy &lt;&lt; #menus &gt;&gt; 'Copy');						add: (#Forget &lt;&lt; #menus &gt;&gt; 'Forget');						add: (#MoveAll &lt;&lt; #menus &gt;&gt; 'Move All');						add: (#CopyAll &lt;&lt; #menus &gt;&gt; 'Copy All');						add: (#Update &lt;&lt; #menus &gt;&gt; 'Update');						asArray)				lines: #(1 4 6)				values: #(#browseClass #moveClass #copyClass #forgetClass						 #moveAllClasses #copyAllClasses #updateClasses)]</body><body package="Tools-Changes">longMethodMenu	^menus 		at: #longMethodMenu 		ifAbsentPut: [			Menu				labelArray: (Array						with: (#Spawn &lt;&lt; #menus &gt;&gt; 'Spawn')						with: (#Move &lt;&lt; #menus &gt;&gt; 'Move')						with: (#Copy &lt;&lt; #menus &gt;&gt; 'Copy')						with: (#Forget &lt;&lt; #menus &gt;&gt; 'Forget'))				values: #(spawnMethod moveMethod copyMethod forgetMethod)]</body><body package="Tools-Changes">methodMenu	^[self getMethodMenu]</body><body package="Tools-Changes">shortClassMenu	^menus 		at: #shortClassMenu 		ifAbsentPut: [			Menu				labelArray: (Array						with: (#Browse &lt;&lt; #menus &gt;&gt; 'Browse')						with: (#Forget &lt;&lt; #menus &gt;&gt; 'Forget')						with: (#Update &lt;&lt; #menus &gt;&gt; 'Update'))				lines: #(1 2)				values: #(#browseClass #forgetClass #updateClasses)]</body><body package="Tools-Changes">shortMethodMenu	^menus 		at: #shortMethodMenu 		ifAbsentPut: [			Menu				labelArray: (Array						with: (#Spawn &lt;&lt; #menus &gt;&gt; 'Spawn')						with: (#Forget &lt;&lt; #menus &gt;&gt; 'Forget'))				values: #(spawnMethod forgetMethod)]</body></methods><methods><class-id>Tools.ChangeEditor</class-id> <category>events</category><body package="Tools-Changes">noticeOfWindowClose: aWindow		source retractInterestsFor: self.	"Quick hack:"	ChangeSetManager allInstances do: [:lwp|		lwp removeDependent: self]</body></methods><methods><class-id>Tools.ChangeEditor</class-id> <category>updating</category><body package="Tools-Changes">updateRequest	"We don't want updates if change set comments are being edited."	^text changeRequest</body></methods><methods><class-id>Tools.ChangeEditor</class-id> <category>private</category><body package="Tools-Changes">allInvisible	builder == nil ifTrue: [^self].	#(rbadd rbchange rbremove classRemove classRename classComment classOrganize)		do: [:s | (builder componentAt: s) beInvisible]</body><body package="Tools-Changes">basicChangeTypeFor: types	(types includes: #add) ifTrue: [^#add].	(types includes: #change) ifTrue: [^#change].	^nil</body><body package="Tools-Changes">changedChangeType	self isInTransition ifTrue: [^self].	mode == #method		ifTrue: [self currentSource					changeTypeFor: self className					method: self method					put: changeType value.				^self]</body><body package="Tools-Changes">changedClassComment	self isInTransition ifTrue: [^self].	classComment value		ifTrue: [self currentSource atClass: self selectedClass add: #comment]		ifFalse: [self currentSource atClass: self selectedClass remove: #comment]</body><body package="Tools-Changes">changedClassOrganize	self isInTransition ifTrue: [^self].	classOrganize value		ifTrue: [self currentSource atClass: self selectedClass add: #reorganize ]		ifFalse: [self currentSource atClass: self selectedClass remove: #reorganize ]</body><body package="Tools-Changes">changedSource	self setWindowLabel.	self setClassList</body><body package="Tools-Changes">changeSetClass	^NamedChangeSet</body><body package="Tools-Changes">changeSetManager	^ChangeSetManager</body><body package="Tools-Changes">className	^classList selection</body><body package="Tools-Changes">classSetVisible	builder == nil ifTrue: [^self].	#(rbremove )		do: [:s | (builder componentAt: s) beInvisible].	#(rbadd rbchange classRemove classRename classComment classOrganize)		do: [:s | (builder componentAt: s) beVisible].</body><body package="Tools-Changes">classSetVisible: aType	builder == nil ifTrue: [^self].	#(rbadd rbchange)		do: [:s | (builder componentAt: s) isEnabled: false].	#(rbremove )		do: [:s | (builder componentAt: s) beInvisible].	#(classComment classOrganize)		do: [:s |			(builder componentAt: s) isEnabled: aType ~~ #add].	#(rbadd rbchange classRemove classRename classComment classOrganize)		do: [:s |			(builder componentAt: s) beVisible].</body><body package="Tools-Changes">computeListOfClasses	self currentSource isNil ifTrue: [^List new].	^self currentSource listOfClasses</body><body package="Tools-Changes">computeListOfMethods	self currentSource isNil ifTrue: [^List new].	^self currentSource listOfMethodsForClassNamed: (classList selection)</body><body package="Tools-Changes">computeText	"Return the text to be displayed in the text pane."	self className isNil		ifTrue:			[^self destination isNil				ifTrue: [self textForChangeSet]				ifFalse: [self textForDestination]].	self method isNil ifTrue: [^self textForClass].	^self textForMethod</body><body package="Tools-Changes">currentSource	^source value</body><body package="Tools-Changes">destination	^destinationList selection</body><body package="Tools-Changes">isInTransition	^mode == #transition</body><body package="Tools-Changes">method	^methodList selection</body><body package="Tools-Changes">methodSetVisible	builder == nil ifTrue: [^self].	#(rbadd rbchange)		do: [:s | (builder componentAt: s) isEnabled: true].	#(classRemove classRename classComment classOrganize)		do: [:s | (builder componentAt: s) beInvisible].	#(rbadd rbchange rbremove )		do: [:s | (builder componentAt: s) beVisible]</body><body package="Tools-Changes">postOpenWith: aBuilder	self setWindowLabel.	self setTextAndFlags</body><body package="Tools-Changes">selectedClass	^self currentSource classNamed: self className</body><body package="Tools-Changes">setClassList	"Recompute the class list.  Try and maintain the selection index if possible."	| selectionIndex thisSelection previousSelection newList |	(newList := self computeListOfClasses) = classList list ifTrue: [^self].	(selectionIndex := classList selectionIndex) &gt;= 1 ifTrue: [		thisSelection := classList list at: selectionIndex.		selectionIndex &gt; 1 ifTrue: [			previousSelection := classList list at: selectionIndex - 1]].	classList list: newList.	(classList list includes: thisSelection)		ifTrue: [classList selection: thisSelection]		ifFalse: [			(classList list includes: previousSelection) ifTrue: [				classList selectionIndex: (selectionIndex min: classList list size)]]</body><body package="Tools-Changes">setMethodList		methodList list: self computeListOfMethods.	self setTextAndFlags</body><body package="Tools-Changes">setTextAndFlags	| types |	mode := #transition.	text value: self computeText.	( self currentSource representsComponent: self className )		ifTrue: [ ^self setTextAndFlagsForComponent ].	self method notNil		ifTrue: [self methodSetVisible.			changeType value: (self currentSource changeTypeFor: self className method: self method).			mode := #method]		ifFalse: [self className notNil					ifTrue: [types := self currentSource changeTypesFor: self className.							changeType value: (self basicChangeTypeFor: types).							self classSetVisible: changeType value.							classRemove value: (self currentSource hasRemovesFor: self className).							classRename value: (types includes: #rename).							classComment value: (types includes: #comment).							classOrganize value: (types includes: #reorganize).							mode := #class]					ifFalse: [self allInvisible.							changeType value: nil.							mode := #none]].</body><body package="Tools-Changes">setTextAndFlagsForComponent	self method notNil		ifTrue: 				[ self methodSetVisible.			changeType value: ( self method changeSetChange ).			mode := #method			]</body><body package="Tools-Changes">setWindowLabel	builder notNil ifTrue:		[builder window			label: (self currentSource notNil				ifTrue: [#ChangeSetEditorOn1s &lt;&lt; #dialogs &gt;&gt; 'Change Set Editor on &lt;1s&gt;'					expandMacrosWith: self currentSource name asString]				ifFalse: [#ChangeSetEditor &lt;&lt; #dialogs &gt;&gt; 'Change Set Editor'])]</body><body package="Tools-Changes">textForChangeSet	| comment |	^(comment := source value comment) isNil		ifTrue: [			source value isEmpty				ifTrue: [source value printString]				ifFalse: [(#ThisChangeSetHasNoComment &lt;&lt; #dialogs &gt;&gt; 'This ChangeSet has no comment') asString]]		ifFalse: [			(comment size &gt; 0 and: [comment first = $"])				ifTrue:					[comment := comment copyFrom: 2 to: comment size].			(comment size &gt; 0 and: [comment last = $"])				ifTrue:					[comment := comment copyFrom: 1 to: comment size - 1].			comment]</body><body package="Tools-Changes">textForClass		^String new</body><body package="Tools-Changes">textForDestination	^self destination doIts asText</body><body package="Tools-Changes">textForMethod	"Answer the text for the currently selected change, which may be a component change instead of a method."		( self currentSource representsComponent: self className )		ifTrue: [ ^self method description ].	^(self currentSource changeTypeFor: self className method: self method) = #remove		ifTrue: ['remove' asText]		ifFalse:			[| class |			(class := self currentSource classNamed: self className) isNil				ifTrue: [((#sourcesUnavailableNoClass &lt;&lt; #dialogs &gt;&gt; 'source unavailable because &lt;1s&gt; has been removed or renamed.')			expandMacrosWith: self className)]				ifFalse:					[(class includesSelector: self method)						ifTrue: [class sourceMethodAt: self method]						ifFalse: [((#sourcesUnavailableNoMethod &lt;&lt; #dialogs &gt;&gt; 'source unavailable because &lt;1s&gt; is no longer a method.')			expandMacrosWith: self method)]]]</body></methods><methods><class-id>Tools.ChangeList</class-id> <category>accessing</category><body package="Tools-Changes">noConflictTextFor: change	"Answer a Text corresponding to the conflicting text of the selected item in the system.	This is in fact, the reason why there is no text to compare to. Answer nil if okay to compare."	change targetObject == nil		ifTrue: [			^change isClassDefinitionChange 				ifTrue: [					(change type = #'class definition'						ifTrue: [ #ClassNotInSystem &lt;&lt; #dialogs &gt;&gt; 'class not in system' ]						ifFalse: [ change type = #'shared variable definition'							ifTrue: [ #SharedVariableNotInSystem &lt;&lt; #dialogs &gt;&gt; 'shared variable not in system' ]							ifFalse: [change type = #'namespace definition'								ifTrue: [ #NameSpaceNotInSystem &lt;&lt; #dialogs &gt;&gt; 'namespace not in system' ]								ifFalse: [ #UnknownDefinitionType &lt;&lt; #dialogs &gt;&gt; 'unknown definition type' ]]])					asText emphasizeAllWith: #italic ]				ifFalse: [ '' asText ]].	( ( self conflictTextFor: change ) == nil and: [ change isMethodRelated ] ) 		ifTrue:			[ ^( change hasVersionInSystem					ifTrue: [ (#MethodSourceNotAvailable &lt;&lt; #dialogs &gt;&gt; 'method source not available') ]					ifFalse: [ (#MethodNotInSystem &lt;&lt; #dialogs &gt;&gt; 'method not in system') ]				) asText emphasizeAllWith: #italic			].	^nil</body><body package="Tools-Changes">recoverFile: aFileStream	"Recover all the changes from a .changes file since one of the last	snapshots. The user is given a list of snapshots to pick from."	| positions position|	positions := SourceFileManager 		find: self snapshotsToGoBack 		lastSnapshotsIn: aFileStream.	positions isEmpty		ifTrue: [position := 0]		ifFalse:			[position := self pickPositionAmong: positions in: aFileStream.			position isNil ifTrue: [^self]].	aFileStream position: position.	self checkSystem: false.	self scanFile: aFileStream</body><body package="Tools-Changes">recoverLastFromFile: aFileStream	"Recover all the changes from a .changes file since the last snapshot."	| position |	position := SourceFileManager findLastSnapshotIn: aFileStream.	aFileStream position: (position ifNil: [0]).	self checkSystem: false.	self scanFile: aFileStream</body></methods><methods><class-id>Tools.ChangeList</class-id> <category>aspects</category><body package="Tools-Changes">changeTypeFilterAdaptor	^(PluggableAdaptor on: self)		getBlock: [:m | m hasFilter: 2]		putBlock: [:m :v | m switchFilter: 2 perform: #type]		updateBlock: [:m :a :p | a == #filter and: [p = 2]]</body><body package="Tools-Changes">fileFilterAdaptor	^(PluggableAdaptor on: self)		getBlock: [:m | m hasFilter: 1]		putBlock: [:m :v | m switchFilter:1 perform: #fileName]		updateBlock: [:m :a :p | a == #filter and: [p = 1]]</body></methods><methods><class-id>Tools.ChangeList</class-id> <category>fileIn/Out</category><body package="Tools-Changes">scanFile: aFileStream	"Obtain changes from aFileStream.  Depending on the checkSystem mode	 either read in all changes, or only changes which differ in source or code."	(aFileStream isExternalStream	and: [aFileStream fileName hasSourceExtension]) ifTrue:		[aFileStream lineEndTransparent].	Cursor read showWhile:		[[ChangeScanner new			scanFile: aFileStream			do:				[:change |				(nil == checkSystem				or: [(change sameAsSystem: self) not]) ifTrue:					[changes add: change]]]			ensure: [aFileStream close]].	listName isEmpty		ifTrue: [listName := aFileStream isExternalStream								ifTrue: [aFileStream name]								ifFalse: [(#someLocalStream &lt;&lt; #dialogs &gt;&gt; 'some local stream') asString]]		ifFalse:			[('*...' match: listName) ifFalse: [listName := listName, ' ...']].	self updateList</body></methods><methods><class-id>Tools.ChangeList</class-id> <category>doIt/accept/explain</category><body package="Tools-Changes">doItReceiver	"Return a suitable doItReceiver for doIts in the text view."	^selectionIndex &gt; 0		ifTrue: [ ( list at: selectionIndex) doItReceiver ]		ifFalse: [ ]</body></methods><methods><class-id>Tools.ChangeList</class-id> <category>menu messages</category><body package="Tools-Changes">addOriginals	"Add to the list versions of all changes in the list that are also found in the sources files."	| changeNames sfm |	"Collect all changes based on their checking names (to make look-up more efficient)."	changeNames := Set new: changes size.	changes do:		[:change|		(removed includes: change) ifFalse:			[changeNames add: change checkingName]].	(sfm := SourceFileManager default) fileIndicesDo:		[:fileIndex| | file originals |		fileIndex ~= sfm changesIndex ifTrue:			[file := (sfm nameStringAt: fileIndex) asLogicalFileSpecification readStream.			file lineEndConvention: (sfm fileAt: fileIndex) lineEndConvention.			Transcript cr; show: ((#Scanning1s &lt;&lt; #dialogs &gt;&gt; 'Scanning &lt;1s&gt;')			expandMacrosWith: file name asString).			originals := OrderedCollection new: list size.			Cursor read showWhile:				[ChangeScanner new scanFile: file do:					[:change|					(changeNames includes: change checkingName) ifTrue:						[originals addLast: change.						"The following speeds things up but prevents one seeing						 e.g. overrides in later source files."						"originals size = changes size ifTrue:							[changes addAllLast: originals.							^self updateList]"]]].			originals size &gt; 0 ifTrue:				[changes addAllLast: originals.				 self updateList]]]</body><body package="Tools-Changes">addSystemConflicts	"Add to the list system versions of all messages in the list that conflict with the system."	| conflicts |	checkSystem := #exact.	conflicts := OrderedCollection new: list size.	list do: [:change| | systemVersion |		(change hasVersionInSystem		and: [change sameAsSystem: self]) ifFalse:			[nil ~~ (systemVersion := change systemVersion) ifTrue:				[conflicts addLast: systemVersion]]].	changes addAllLast: conflicts.	self updateList</body><body package="Tools-Changes">findFile	"Prompt and search for all changes in a given file. Select these changes"	self find: #fileName prompt: #fileName filter: #fileName</body><body package="Tools-Changes">findSelector	"Prompt and search for all changes of a given selector. Select these changes"	self find: #selector prompt: #selector filter: #selector</body><body package="Tools-Changes">getAllChanges	"Add all the changes in the system to the receiver."		| sourceFileManager |	sourceFileManager := SourceFileManager default.	Cursor execute showWhile:		[| changedClasses |		changedClasses := Set new.		ChangeSet withAllSubclasses do: 			[:eachClass | eachClass allInstancesDo: 				[:eachInstance | changedClasses addAll: eachInstance changedClassDefinitions]].		SystemUtils allBehaviorsDo:			[:eachBehavior | 			(changedClasses includes: eachBehavior) ifTrue:				[self addChange:					(eachBehavior isMeta						ifTrue:							[(ClassOtherChange new)								className: eachBehavior fullName;								type: #'inst vars for';								yourself]						ifFalse:							[(ClassDefinitionChange new)								objectType: #class;								className: eachBehavior fullName;								yourself])].			(eachBehavior organization hasNoComment not and: 				[(sourceFileManager fileIndexFor: eachBehavior organization commentKey) = sourceFileManager changesIndex])					ifTrue:						[self addChange:							((ClassCommentChange new)								className: eachBehavior fullName;								yourself)].			eachBehavior selectorsAndMethodsDo:				[:eachSelector :eachMethod | 				sourceFileManager changesIndex = (sourceFileManager fileIndexFor: eachMethod sourcePointer)					ifTrue:						[self addChange:							((MethodDefinitionChange new)								className: eachBehavior fullName;								selector: eachSelector;								category: (eachBehavior whichCategoryIncludesSelector: eachSelector);								yourself)]]]].	self updateList</body><body package="Tools-Changes">getChanges	"Add the current project's changes to the change list."	Cursor execute showWhile: [ChangeSet current addChangesToChangeList: self].	self  updateList</body><body package="Tools-Changes">getParcel	"Add a given Parcel's changes to the change list."	| parcelName |	parcelName := self queryParcel.	nil == parcelName ifTrue: [^self].	Cursor execute showWhile:		[(Parcel parcelNamed: parcelName) addChangesToChangeList: self].	self updateList</body><body package="Tools-Changes">helpAbout	AboutVisualWorksDialog open</body><body package="Tools-Changes">helpChangeList	'topic:vw.help.tools.changeList' asURI open</body><body package="Tools-Changes">helpChangesAndChangeSets	'topic:vw.help.systemChanges' asURI open</body><body package="Tools-Changes">recover	"Recover changes since one of the last snapshots from the changes file.	The user is given a list of snapshots to pick from."	Cursor read showWhile:		[self recoverFile: SourceFileManager default targetFile].	builder window label: self listName</body><body package="Tools-Changes">recoverLast	"Recover changes since the last snapshot from the changes file."	Cursor read showWhile:		[self recoverLastFromFile: SourceFileManager default targetFile].	builder window label: self listName</body><body package="Tools-Changes">spawnConvergeScriptToSystem	"Spawn a new ChangeList containing changes necessary to convert the code in the receiver's	 changes to that of the current system. The method assumes that the current ChangeList contains	 complete code for one or more classes from some other system which differs from this system.	 One wants to compute the set of changes to file-in to the other system to make it the same as the	 current system. E.g. imagine one wanted to file-in this ChangeList and Change classes into a	 system without it. One would file-out the ChangeList and Change classes in the deficient system,	 use this method in this system, and file-in the resulting script into the deficient system."	self spawnConvergeScriptToSystem: #exact</body><body package="Tools-Changes">spawnConvergeScriptToSystem: codeOrExactSymbol	"Spawn a new ChangeList containing changes necessary to convert the code in the receiver's	 changes to that of the current system. The method assumes that the current ChangeList contains	 complete code for one or more classes from some other system which differs from this system.	 One wants to compute the set of changes to file-in to the other system to make it the same as the	 current system. E.g. imagine one wanted to file-in this ChangeList and Change classes into a	 system without it. One would file-out the ChangeList and Change classes in the deficient system,	 use this method in this system, and file-in the resulting script into the deficient system."	| changeList methodDefinitions |	methodDefinitions := Dictionary new.	list do: [:c| | index |		c isDefinition			ifTrue:				["Collect methodDefinitions for later use."				c isMethodRelated					ifTrue: [(methodDefinitions at: c className ifAbsentPut: [Set new]) add: c selector]]			ifFalse:				[((removed includes: c) not				and: [c trivial not])					ifTrue:						[(index := list indexOf: c) ~= selectionIndex ifTrue: [self  updateSelection: index].						(builder componentAt: #listView) widget makeVisible: index.						^Dialog warn: (#ChangesIncludeSomethingBad &lt;&lt; #dialogs &gt;&gt; 'Changes contain non-definitional changes (e.g. this change).Please remove all such changes before trying again.')]]].	Cursor wait showWhile: [changeList := self class open window model].	"This algorithm is a naive first-cut.  One thing it doesn't do is prevent	 undeclared inst vars.  Since one goal of script generation is to keep the	 filing-in system maximally functional during file-in one should probably do	 class declarations as follows.  First, construct a definition with the union	 of both class definitions instance &amp; class variables.  Then include method	 changes.  Then append the desired class definition.  This isn't implemented	 yet."	checkSystem := codeOrExactSymbol.	Cursor execute showWhile:		[| removedClasses |		removedClasses := Dictionary new.		list do: [:c|			((removedClasses includesKey: c nonMetaClassName)			or: [c sameAsSystem: self])				ifFalse:					[c hasVersionInSystem						ifTrue: [changeList addChange: c systemVersion]						ifFalse:							[c isClassDefinitionChange								ifTrue: [removedClasses at: c nonMetaClassName put: c]								ifFalse: [changeList addChange: c versionToRemove]]].			"Ensure we add all methods not implemented in these changes."			(c isClassDefinitionChange			and: [(removedClasses includesKey: c nonMetaClassName) not]) ifTrue:				[(Array with: c classObject instanceBehavior with: c classObject classBehavior)					do: [:class| | className implementedSelectors |						className := class fullName.						implementedSelectors := methodDefinitions at: className ifAbsent: [Set new].						class selectors do: [:sel|							(implementedSelectors includes: sel)								ifFalse: [changeList											addChange: (MethodDefinitionChange new																className: className;																selector: sel;																category: (class whichCategoryIncludesSelector: sel);																yourself)]]]]].			"Should be done in reverse superclass order, which should be			 reverse file-out order."			removedClasses do: [:c| changeList add: c versionToRemove]].	changeList updateList</body></methods><methods><class-id>Tools.ChangeList</class-id> <category>menu messages-removing</category><body package="Tools-Changes">addChangesToCurrentChangeSet	"Remove from the current change set those changes that correspond	 to the currently listed changes."	[Cursor execute showWhile: [				list do: [:change|					(removed includes: change) ifFalse: [change addToCurrentChangeSet]]]]		on: Object errorSignal		do:			[:ex| | index |			(ex originator isKindOf: Change) ifTrue:				[selectionIndex ~= (index := list indexOf: ex originator) ifTrue:					[self updateSelection: index].				(builder componentAt: #listView) widget makeVisible: selectionIndex].			ex pass]</body><body package="Tools-Changes">removeChangesFromCurrentChangeSet	"Remove from the current change set those changes that	 correspond to the currently listed changes."	[Cursor execute showWhile:				[list do: [:change|					(removed includes: change) ifFalse:						[change removeFromCurrentChangeSet]]]]		on: Object errorSignal		do:			[:ex| | index |			(ex originator isKindOf: Change) ifTrue:				[selectionIndex ~= (index := list indexOf: ex originator) ifTrue:					[self updateSelection: index].				(builder componentAt: #listView) widget makeVisible: selectionIndex].			ex pass]</body></methods><methods><class-id>Tools.ChangeList</class-id> <category>menu bar actions</category><body package="Tools-Changes">toggleFileFilter	self filterMessage: #filterByFile</body><body package="Tools-Changes">toggleShowFile	self fieldMessage: #showFile</body></methods><methods><class-id>Tools.ChangeList</class-id> <category>checking</category><body package="Tools-Changes">checkSystem: aBooleanOrSymbol	"Set the checking mode to allow the filtering of changes on filing in.	 Unlike checkWithSystem: do not do any checking. Return the previous	 checking mode."	| oldMode |	oldMode := checkSystem.	checkSystem := aBooleanOrSymbol isSymbol						ifTrue: [differencesMode := aBooleanOrSymbol] "use #code or #exact checking"						ifFalse: [aBooleanOrSymbol ifTrue: [#code]].	^oldMode</body></methods><methods><class-id>Tools.ChangeList</class-id> <category>private</category><body package="Tools-Changes">fieldTemplates	"return the templates for the fields (show file etc)"	^#(	#( showFile showProtocol showConflicts )		#( fileName category conflicts))</body><body package="Tools-Changes">filterTemplates	"return the templates for the filters"	^#(	#( filterByFile filterByType filterByClass filterByProtocol filterBySelector filterBySame )		#( fileName type className category selector values))</body><body package="Tools-Changes">getWriteFilenameWithPrompt: promptString do: actionBlock	"Find out the file name of a file to write to using the Filename utility that	prompts for existing files."	| fileName |		[fileName := Dialog requestNewFileName: promptString				default: TextEditorController currentSelection.	fileName isEmpty or: 			[(self includesFileName: fileName)				ifTrue: 					[Dialog						warn: (#SourceFileStillInUse &lt;&lt; #dialogs								&gt;&gt; '&lt;1s&gt; cannot be used because&lt;n&gt;it holds the source of some or all entries.&lt;n&gt;Please try again.'									expandMacrosWith: fileName).					false]				ifFalse: [true]]]			whileFalse.	fileName isEmpty		ifFalse: [Cursor write showWhile: [actionBlock value: fileName asFilename]]</body><body package="Tools-Changes">makeChangesVisible	"Attempt to make at least one chnage visible; assuming that all changes are filtered out."	| filters |	filters := self filterTemplates first.	filters size to: 1 by: -1 do:		[:i|		list isEmpty ifFalse: [^self].		(self hasFilter: i) ifTrue:			[self filterMessage: (filters at: i)]]</body><body package="Tools-Changes">pickPositionAmong: aCollection in: aFileStream	"aCollection is a collection of snapshot marker positions in 'aFileStream' 	open on the changes file. Open a dialog to let the user pick one and return 	it.  Return nil if cancelled. If there were fewer entries in aCollection than	normally selected, include the file beginning into choices. "	| positions labels beginningOfChangesFileMessage recoverLastNMessage |	beginningOfChangesFileMessage := #beginningOfChangeFile &lt;&lt; #dialogs 		&gt;&gt; 'Beginning of the changes file'.	recoverLastNMessage := #recoverLastNMessage &lt;&lt; #dialogs		&gt;&gt; 'Recover going as far back as:'.	positions := OrderedCollection new.	labels := OrderedCollection new.	aCollection do:		[:markerLocation | | comment |		comment := self snapshotLabelAfter: markerLocation in: aFileStream.		comment notNil ifTrue:			[positions add: markerLocation.			labels add: comment]].	aCollection size &lt; self snapshotsToGoBack ifTrue:		[positions add: 0.		labels add: beginningOfChangesFileMessage asString].	positions isEmpty ifTrue: [^nil].	^Dialog		choose: recoverLastNMessage		fromList: labels		values: positions		lines: 8		cancel: [nil]</body><body package="Tools-Changes">redisplayList	"Redisplay the list unless the interface is not actually open."	builder notNil ifTrue: [(builder componentAt: #listView) widget invalidate]</body><body package="Tools-Changes">scanFilename: aFilename	"Scan the file/directory name specified.  If aFilename is	a directory, then scan all the files in it."	Transcript cr; show: ((#Scanning1s &lt;&lt; #dialogs &gt;&gt; 'Scanning &lt;1s&gt;')			expandMacrosWith: aFilename asString).	aFilename isDirectory		ifTrue: [			aFilename directoryContents asSortedStrings do: [:each |				self scanFilename: (aFilename construct: each)]]		ifFalse: [ | stream |			stream := (aFilename withEncoding: #Source) readStream.			[self scanFile: stream] ensure: [stream close]]</body><body package="Tools-Changes">snapshotLabelAfter: position in: aFileStream	"aFileStream is expected to be a stream on the changes file. Find a	snapshot label following the 'position' and return the timestamp part of it.	Return nil if there are problems finding a label. 'position' is expected to point	at a snapshot marker."	| comment descr date time |	aFileStream position: position.	aFileStream through: $".	aFileStream position - position &gt; 50 ifTrue: [^nil].	comment := aFileStream upTo: $".	^(('#(*)' match: comment)			and: [(descr := Object readFrom: comment readStream) class == Array			and: [descr size = 3			and: [descr allSatisfy: [:s | s isString]]]])		ifTrue:			[date := Date readFrom: (descr at: 2) readStream.			time := Time readFrom: (descr at: 3) readStream.			#snapShotCreated &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; created at &lt;2p&gt; &lt;3p&gt;'				expandMacrosWith: descr first				with: date				with: time]		ifFalse: [nil]</body><body package="Tools-Changes">snapshotsToGoBack	"The number of snapshots the Recover Last Changes	action goes back in the changes file."	^8</body></methods><methods><class-id>Tools.ChangeList class</class-id> <category>instance creation</category><body package="Tools-Changes">openOnFileNamed: aFilenameOrString	|cl |	cl := self new.	cl scanFile: (aFilenameOrString asFilename withEncoding: #Source ) readStream.	cl open</body></methods><methods><class-id>Kernel.Override</class-id> <category>change list support</category><body package="Tools-Changes">browseSystemVersionIfExists	"Open a browser on the system version of this override if possible.	 Answer if it was possible."	self hasVersionInSystem		ifFalse: [ ^false ].	self browseSystemVersion.	^true</body><body package="Tools-Changes">inactiveVersionLabel	^self componentString</body><body package="Tools-Changes">systemVersionLabel	^self systemComponentString</body></methods><methods><class-id>Kernel.ClassOtherChange</class-id> <category>checking</category><body package="Tools-Changes">addToCurrentChangeSet	"Add the receiver's corresponding entry in the current ChangeSet (if it exists)."	type == #'class initialize' ifTrue: [^self].	type == #'class inst vars for' ifTrue:		[^ChangeSet changeClass: self validClassObject].	type == #'class remove' ifTrue:		[^ChangeSet addClass: self validTargetObject].	type == #'class comment' ifTrue:		[^ChangeSet commentClass: self validTargetObject].	type == #'class reorganize' ifTrue:		[^ChangeSet reorganizeClass: self validTargetObject].	self error: (#OperationNotImplemented &lt;&lt; #dialogs &gt;&gt; 'operation not implemented')</body></methods><methods><class-id>Kernel.ClassOtherChange</class-id> <category>source code</category><body package="Tools-Changes">browseSystemVersionIfExists	"Open a browser on the system version of this change if possible.	 Answer if it was possible. By default its not possible."	self hasVersionInSystem ifFalse: [^false].	(type == #'class inst vars for'	or: [type == #'class reorganize']) ifTrue:		["In olden times a class reorg would cause the browser to open in		  ``edit all'' mode, but the new browser doesn't support such a notion."		SmalltalkWorkbench browseClass: self classObject.		^true].	^false</body></methods><methods><class-id>Kernel.ComponentChange</class-id> <category>checking</category><body package="Tools-Changes">addToCurrentChangeSet	"Add the receiver's corresponding entry in the current ChangeSet (if it exists)."	ChangeSet current addComponentChange: self</body></methods><methods><class-id>Kernel.ClassDefinitionChange</class-id> <category>checking</category><body package="Tools-Changes">addToCurrentChangeSet	"Add the receiver's corresponding entry in the current ChangeSet (if it exists)."	ChangeSet changeClass: self validTargetObject</body></methods><methods><class-id>Kernel.ClassDefinitionChange</class-id> <category>source code</category><body package="Tools-Changes">browseSystemVersionIfExists	"Open a browser on the system version of this change if possible.	 Answer if it was possible. By default its not possible."	self hasVersionInSystem ifFalse: [^false].	self isSharedVariableDefinition 		ifTrue: [SmalltalkWorkbench browseBindingReference: self targetObject]		ifFalse: [SmalltalkWorkbench browseClass: self classObject].	^true</body></methods><methods><class-id>Kernel.Change</class-id> <category>checking</category><body package="Tools-Changes">addToCurrentChangeSet	"Add the receiver's corresponding entry in the current ChangeSet (if it exists)."	^self subclassResponsibility</body></methods><methods><class-id>Kernel.Change</class-id> <category>source code</category><body package="Tools-Changes">browseSystemVersionIfExists	"Open a browser on the system version of this change if possible.	 Answer if it was possible. By default its not possible."	^false</body></methods><methods><class-id>Kernel.Change</class-id> <category>checking</category><body package="Tools-Changes">checkWith: aConflictChecker 	"Add the receiver to aConflictChecker's set of potential conflicts so it 	can later compare related changes for conflicts. If aConflictChecker 	is checking against the system and the receiver conflicts with the	system then also add the corresponding system version of the receiver	so the checker can spot the conflict between the receiver and the system."	self trivial		ifFalse:			[aConflictChecker changesAt: self checkingName add: self.			(aConflictChecker checkSystem			and: [self hasVersionInSystem			and: [(self sameAsSystem: aConflictChecker) not]])				ifTrue:					[aConflictChecker						changesAt: self checkingName						add: self systemVersion]]</body></methods><methods><class-id>Kernel.ClassCommentChange</class-id> <category>source code</category><body package="Tools-Changes">browseSystemVersionIfExists	"Open a browser on the system version of this change if possible.	 Answer if it was possible. By default its not possible."	^self hasVersionInSystem and: 			[SmalltalkWorkbench browseClass: self classObject.			true]</body></methods><methods><class-id>Kernel.OverridenMethod</class-id> <category>change list support</category><body package="Tools-Changes">inactiveVersionLabel	| category |	category := self category.	^category isNil		ifTrue: [self componentString]		ifFalse: ['&lt;1s&gt; (&lt;2s&gt;)' expandMacrosWith: self componentString with: category]</body><body package="Tools-Changes">systemVersionLabel	| category |	category := self systemCategory.	^category isNil		ifTrue: [self systemComponentString]		ifFalse: ['&lt;1s&gt; (&lt;2s&gt;)' expandMacrosWith: self systemComponentString with: category]</body></methods><methods><class-id>Kernel.UnknownChange</class-id> <category>checking</category><body package="Tools-Changes">addToCurrentChangeSet	"Add the receiver's corresponding entry in the current ChangeSets (if it exists)."	^self</body></methods><methods><class-id>Kernel.OverridenStatic</class-id> <category>change list support</category><body package="Tools-Changes">inactiveVersionLabel		| category |	category := self category.	^category isNil		ifTrue: [self componentString]		ifFalse: ['&lt;1s&gt; (&lt;2s&gt;)' expandMacrosWith: self componentString with: category]</body><body package="Tools-Changes">systemVersionLabel		| category |	category := self systemCategory.	^category isNil		ifTrue: [self systemComponentString]		ifFalse: ['&lt;1s&gt; (&lt;2s&gt;)' expandMacrosWith: self systemComponentString with: category]</body></methods><methods><class-id>Kernel.OtherChange</class-id> <category>checking</category><body package="Tools-Changes">addToCurrentChangeSet	"Add the receiver's corresponding entry in the current ChangeSets (if it exists)."	ChangeSet addDoIt: self text</body></methods><methods><class-id>Kernel.MethodChange</class-id> <category>checking</category><body package="Tools-Changes">addToCurrentChangeSet	"Add the receiver's corresponding entry in the current ChangeSet (if it exists)."	self isCommentChange		ifTrue: [ChangeSet					changeSelector: self selector					class: self validClassObject					protocol: self category]		ifFalse: [ChangeSet 					changeSelector: selector					class: self validClassObject]</body></methods><methods><class-id>Kernel.MethodChange</class-id> <category>source code</category><body package="Tools-Changes">browseSystemVersionIfExists	"Open a browser on the system version of this method change if possible.	 Answer if it was possible."	^self hasVersionInSystem	and: [MethodCollector new			openListBrowserOn: (Array with: (MethodDefinition class: self classObject selector: selector))			label: (#CurrentDefinition &lt;&lt; #labels &gt;&gt; 'Current Definition').		true]</body></methods><methods><class-id>Tools.AbstractChangeList class</class-id> <category>interface specs</category><body package="Tools-Changes">horizontalDifferencesText	"Tools.UIPainter new openOnClass: self andSelector: #horizontalDifferencesText"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #HorizontalDifferences 				#defaultString: 'Horizontal Differences' 				#catalogID: #labels ) 			#bounds: #(#{Graphics.Rectangle} 512 288 903 768 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 18 0 0 1 -2 0.5 ) 					#name: #textView 					#model: #valueHolder 					#menu: #textMenuHolder 					#tabRequiresControl: true ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 18 0.5 0 1 0 1 ) 					#name: #existingTextView 					#model: #existingTextAdaptor 					#menu: #existingTextMenuHolder 					#tabRequiresControl: true ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 -2 0.5 0 1 1 0.5 ) 					#name: #ResizingSplitter1 					#horizontal: true 					#minAboveSize: 30 					#minBelowSize: 30 					#aboveWidgets: 'textView' 					#belowWidgets: 'existingTextView imageLabel' ) 				#(#{UI.LabelSpec} 					#properties: #(#{UI.PropertyListDictionary} #labelFromApplication true ) 					#layout: #(#{Graphics.LayoutOrigin} 5 0 2 0 ) 					#name: #changeLabel 					#label: #changeLabel 					#style: #small ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 5 0 2 0.5 ) 					#name: #imageLabel 					#label: #imageLabel 					#style: #small ) ) ) )</body><body package="Tools-Changes">standardText	"UIPainter new openOnClass: self andSelector: #standardText"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: #(#{Kernel.UserMessage} #key: #StandardText #defaultString: 'Standard Text' #catalogID: #labels) 			#bounds: #(#Rectangle 0 0 391 480 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#TextEditorSpec 					#layout: #(#LayoutFrame 0 0 0 0 0 1 0 1 ) 					#name: #textView 					#model: #valueHolder 					#menu: #textMenuHolder ) ) ) )</body><body package="Tools-Changes">verticalDifferencesText	"Tools.UIPainter new openOnClass: self andSelector: #verticalDifferencesText"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #VerticalDifferences 				#defaultString: 'Vertical Differences' 				#catalogID: #labels ) 			#bounds: #(#{Graphics.Rectangle} 512 288 903 768 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 18 0 -2 0.5 0 1 ) 					#name: #textView 					#model: #valueHolder 					#menu: #textMenuHolder 					#tabRequiresControl: true ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0.5 18 0 0 1 0 1 ) 					#name: #existingTextView 					#model: #existingTextAdaptor 					#menu: #existingTextMenuHolder 					#tabRequiresControl: true ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} -2 0.5 0 0 1 0.5 0 1 ) 					#name: #ResizingSplitter1 					#horizontal: false 					#minAboveSize: 30 					#minBelowSize: 30 					#aboveWidgets: 'textView changeLabel' 					#belowWidgets: 'existingTextView imageLabel' ) 				#(#{UI.LabelSpec} 					#properties: #(#{UI.PropertyListDictionary} #labelFromApplication true ) 					#layout: #(#{Graphics.LayoutOrigin} 5 0 2 0 ) 					#name: #changeLabel 					#label: #changeLabel 					#style: #small ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 5 0.5 2 0 ) 					#name: #imageLabel 					#label: #imageLabel 					#style: #small ) ) ) )</body></methods><methods><class-id>Tools.OverrideList class</class-id> <category>resources</category><body package="Tools-Changes">changeListMenu	"MenuEditor new openOnClass: self andSelector: #changeListMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #FileInOut #defaultString: '&amp;File In/Out' #catalogID: #menus) 				#nameKey: #fileMenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #WriteFileDot #defaultString: '&amp;Write File...' #catalogID: #menus) 							#value: #fileOut 							#enablementSelector: #anyToFileOut ) ) #(1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Re_playAll #defaultString: 'Re&amp;play All' #catalogID: #menus) 				#nameKey: #replayAllMenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #FromHere #defaultString: 'From &amp;Here' #catalogID: #menus) 							#value: #doFromHere 							#enablementSelector: #hasSelection ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #FromTheTop #defaultString: 'From the &amp;Top' #catalogID: #menus) 							#value: #doAll 							#enablementSelector: #hasItemsDisplayed ) ) #(2 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #RemoveAll #defaultString: 'Re&amp;move All' #catalogID: #menus) 				#value: #removeAll 				#enablementSelector: #hasUnremovedItemsDisplayed ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_SpawnAll #defaultString: '&amp;Spawn All' #catalogID: #menus) 				#value: #copyView 				#enablementSelector: #hasItemsDisplayed ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Re_storeMarked #defaultString: 'Re&amp;store Marked' #catalogID: #menus) 				#value: #restoreAll 				#enablementSelector: #hasRemovedItemsDisplayed ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_ForgetMarked #defaultString: '&amp;Forget Marked' #catalogID: #menus) 				#value: #forgetThese 				#enablementSelector: #hasRemovedSelection ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #R_eplay #defaultString: 'R&amp;eplay' #catalogID: #menus) 				#value: #doThis 				#enablementSelector: #hasSelection ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Rem_ove #defaultString: 'Rem&amp;ove' #catalogID: #menus) 				#value: #removeItem 				#enablementSelector: #hasUnremovedSelection ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Res_tore #defaultString: 'Res&amp;tore' #catalogID: #menus) 				#value: #restoreItem 				#enablementSelector: #hasRemovedSelection ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #For_get #defaultString: 'For&amp;get' #catalogID: #menus) 				#value: #forgetSelection 				#enablementSelector: #hasRemovedSelection ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Spa_wn #defaultString: 'Spa&amp;wn' #catalogID: #menus) 				#value: #spawnBrowserOnSelection 				#enablementSelector: #hasSelection ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Conflicts #defaultString: '&amp;Conflicts' #catalogID: #menus) 				#nameKey: #conflictsMenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Save_ConflictsAsDot #defaultString: 'Save &amp;Conflicts As...' #catalogID: #menus) 							#value: #check ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #SaveConflictsWith_SystemAsDot #defaultString: 'Save Conflicts with &amp;System As...' #catalogID: #menus) 							#value: #checkWithSystem ) ) #(2 ) nil ) ) ) #(1 3 2 5 1 ) nil ) decodeAsLiteralArray</body><body package="Tools-Changes">menuBar	"Tools.MenuEditor new openOnClass: self andSelector: #menuBar"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_File 					#defaultString: '&amp;File' 					#catalogID: #menus ) 				#nameKey: #file 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #DisplaySystemOverrides 								#defaultString: 'Display &amp;System Overrides' 								#catalogID: #menus ) 							#value: #getOverrides ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #DisplayPar_celDot 								#defaultString: 'Display Par&amp;cel...' 								#catalogID: #menus ) 							#value: #getParcel ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #DisplayPackageDot 								#defaultString: 'Display &amp;Package...' 								#catalogID: #menus ) 							#nameKey: #getPackage 							#value: #getPackage 							#visible: false ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #WriteFileDot 								#defaultString: '&amp;Write File...' 								#catalogID: #menus ) 							#value: #fileOut 							#enablementSelector: #anyToFileOut ) ) #(3 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Replay 					#defaultString: '&amp;Replay' 					#catalogID: #menus ) 				#nameKey: #replay 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Selection 								#defaultString: '&amp;Selection' 								#catalogID: #menus ) 							#value: #doThis 							#enablementSelector: #hasSelection ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #AllFromTheTop 								#defaultString: 'All from the &amp;Top' 								#catalogID: #menus ) 							#value: #doAll 							#enablementSelector: #hasItemsDisplayed ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #AllFromHereDown 								#defaultString: 'All from here &amp;Down' 								#catalogID: #menus ) 							#value: #doFromHere 							#enablementSelector: #hasSelection ) ) #(1 2 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Re_move 					#defaultString: 'Re&amp;move' 					#catalogID: #menus ) 				#nameKey: #remove 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Selection 								#defaultString: '&amp;Selection' 								#catalogID: #menus ) 							#value: #removeItem 							#enablementSelector: #hasSelection ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #A_ll 								#defaultString: 'A&amp;ll' 								#catalogID: #menus ) 							#value: #removeAll 							#enablementSelector: #hasUnremovedItemsDisplayed ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #AllAbove 								#defaultString: 'All &amp;Above' 								#catalogID: #menus ) 							#value: #removeAllAbove 							#enablementSelector: #hasSelection ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #AllBelow 								#defaultString: 'All &amp;Below' 								#catalogID: #menus ) 							#value: #removeAllBelow 							#enablementSelector: #hasSelection ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ExchangeRemoved 								#defaultString: 'E&amp;xchange Removed' 								#catalogID: #menus ) 							#value: #exchangeRemoved 							#enablementSelector: #hasItemsDisplayed ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SameCodeAsSystem 								#defaultString: 'Same &amp;Code as System' 								#catalogID: #menus ) 							#value: #removeSameAsSystem 							#enablementSelector: #hasUnremovedItemsDisplayed ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SameSourceAsSystem 								#defaultString: 'Same &amp;Source as System' 								#catalogID: #menus ) 							#value: #removeSameSourceAsSystem 							#enablementSelector: #hasUnremovedItemsDisplayed ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #DifferentCodeToSystem 								#defaultString: 'Different C&amp;ode to System' 								#catalogID: #menus ) 							#value: #removeConflictsWithSystem 							#enablementSelector: #hasUnremovedItemsDisplayed ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #DifferentSourceToSystem 								#defaultString: 'Different So&amp;urce to System' 								#catalogID: #menus ) 							#value: #removeSourceConflictsWithSystem 							#enablementSelector: #hasUnremovedItemsDisplayed ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #CodeForClassesNotInSystem 								#defaultString: 'Code for Classes &amp;not in System' 								#catalogID: #menus ) 							#value: #removeClassesNotInSystem 							#enablementSelector: #hasUnremovedItemsDisplayed ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #MethodsNotInSystem 								#defaultString: '&amp;Methods not in System' 								#catalogID: #menus ) 							#value: #removeMethodsNotInSystem 							#enablementSelector: #hasUnremovedItemsDisplayed ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #OldVersions 								#defaultString: 'Old &amp;Versions' 								#catalogID: #menus ) 							#value: #removeOldVersions 							#enablementSelector: #hasUnremovedItemsDisplayed ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ExactDuplicates 								#defaultString: 'Exact &amp;Duplicates' 								#catalogID: #menus ) 							#value: #removeDuplicates 							#enablementSelector: #hasUnremovedItemsDisplayed ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Con_flicts 								#defaultString: 'Con&amp;flicts' 								#catalogID: #menus ) 							#value: #removeConflictsInList 							#enablementSelector: #hasUnremovedItemsDisplayed ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ChangesWithTextDot 								#defaultString: 'Changes with &amp;Text ...' 								#catalogID: #menus ) 							#value: #removeChangesContainingString 							#enablementSelector: #hasRemovedItemsDisplayed ) ) #(4 1 2 2 2 3 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Fo_rget 					#defaultString: 'Fo&amp;rget' 					#catalogID: #menus ) 				#nameKey: #forget 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ForgetSelection 								#defaultString: 'Forget &amp;Selection' 								#catalogID: #menus ) 							#value: #forgetSelection 							#enablementSelector: #hasRemovedSelection ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Forget_Marked 								#defaultString: 'Forget &amp;Marked' 								#catalogID: #menus ) 							#value: #forgetThese 							#enablementSelector: #hasRemovedItemsDisplayed ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ForgetAllMarked 								#defaultString: 'Forget &amp;All Marked' 								#catalogID: #menus ) 							#value: #forgetAll 							#enablementSelector: #hasRemovedItems ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #PurgeMarked 								#defaultString: '&amp;Purge Marked' 								#catalogID: #menus ) 							#nameKey: #purgeThese 							#value: #purgeThese 							#enablementSelector: #hasRemovedItems ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #PurgeSelection 								#defaultString: 'P&amp;urge Selection' 								#catalogID: #menus ) 							#nameKey: #purgeSelection 							#value: #purgeSelection 							#enablementSelector: #hasRemovedSelection ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #RestoreSelection 								#defaultString: '&amp;Restore Selection' 								#catalogID: #menus ) 							#value: #restoreItem 							#enablementSelector: #hasRemovedSelection ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #RestoreAll 								#defaultString: 'R&amp;estore All' 								#catalogID: #menus ) 							#value: #restoreAll 							#enablementSelector: #hasRemovedItemsDisplayed ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #RestoreChangesWithText 								#defaultString: 'Restore Changes with &amp;Text' 								#catalogID: #menus ) 							#value: #restoreChangesContainingString 							#enablementSelector: #hasRemovedItemsDisplayed ) ) #(3 2 3 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Fi_nd 					#defaultString: 'Fi&amp;nd' 					#catalogID: #menus ) 				#nameKey: #find 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Pa_rcelDot 								#defaultString: 'Pa&amp;rcel ...' 								#catalogID: #menus ) 							#value: #findParcel ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #PackageDot 								#defaultString: 'Pac&amp;kage...' 								#catalogID: #menus ) 							#nameKey: #findPackage 							#value: #findPackage 							#visible: false ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #T_ypeDot 								#defaultString: 'T&amp;ype ...' 								#catalogID: #menus ) 							#value: #findType ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ClassDot 								#defaultString: '&amp;Class ...' 								#catalogID: #menus ) 							#value: #findClass ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ProtocolDot 								#defaultString: '&amp;Protocol ...' 								#catalogID: #menus ) 							#value: #findProtocol ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SelectorDot 								#defaultString: '&amp;Selector ...' 								#catalogID: #menus ) 							#value: #findSelector ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SpawnSelection 								#defaultString: 'Spa&amp;wn Selection' 								#catalogID: #menus ) 							#value: #spawnBrowserOnSelection 							#enablementSelector: #hasSelection ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Spawn_All 								#defaultString: 'Spawn &amp;All' 								#catalogID: #menus ) 							#value: #copyView 							#enablementSelector: #hasItemsDisplayed ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SpawnOverridesWithTextDot 								#defaultString: 'Spawn Overrides with &amp;Text...' 								#catalogID: #menus ) 							#value: #spawnChangesContainingString 							#enablementSelector: #hasUnremovedItemsDisplayed ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ClassMatching 								#defaultString: 'Class &amp;Matching' 								#catalogID: #menus ) 							#nameKey: #classMatching 							#submenu: #(#{UI.Menu} #(									#(#{UI.MenuItem} 										#rawLabel: 										#(#{Kernel.UserMessage} 											#key: #InstanceAndClass 											#defaultString: '&amp;Instance and Class' 											#catalogID: #menus ) 										#nameKey: #groupClassAndMetaclass 										#value: #groupClassAndMetaclass 										#indication: true ) 									#(#{UI.MenuItem} 										#rawLabel: 										#(#{Kernel.UserMessage} 											#key: #SelectedClassOnly 											#defaultString: 'Selected Class &amp;Only' 											#catalogID: #menus ) 										#nameKey: #ungroupClassAndMetaclass 										#value: #ungroupClassAndMetaclass 										#indication: true ) ) #(2 ) nil ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SameParcel 								#defaultString: 'Same Parcel' 								#catalogID: #menus ) 							#nameKey: #filterByParcel 							#value: #toggleParcelFilter 							#indication: true ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SamePackage 								#defaultString: 'Same Package' 								#catalogID: #menus ) 							#nameKey: #filterByPackage 							#value: #togglePackageFilter 							#visible: false 							#indication: true ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SameType 								#defaultString: 'Same Type' 								#catalogID: #menus ) 							#nameKey: #filterByType 							#value: #toggleTypeFilter 							#indication: true ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SameClass 								#defaultString: 'Same Class' 								#catalogID: #menus ) 							#nameKey: #filterByClass 							#value: #toggleClassFilter 							#indication: true ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SameProtocol 								#defaultString: 'Same Protocol' 								#catalogID: #menus ) 							#nameKey: #filterByProtocol 							#value: #toggleProtocolFilter 							#indication: true ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SameSelector 								#defaultString: 'Same Selector' 								#catalogID: #menus ) 							#nameKey: #filterBySelector 							#value: #toggleSelectorFilter 							#indication: true ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SameOverride 								#defaultString: 'Same Override' 								#catalogID: #menus ) 							#nameKey: #filterBySame 							#value: #toggleSameFilter 							#indication: true ) ) #(6 3 1 7 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Show 					#defaultString: '&amp;Show' 					#catalogID: #menus ) 				#nameKey: #show 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ShowCodeComponents 								#defaultString: 'Show C&amp;ode Components' 								#catalogID: #menus ) 							#nameKey: #showComponent 							#value: #toggleShowComponent 							#indication: true ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ShowProtocol 								#defaultString: 'Show &amp;Protocol' 								#catalogID: #menus ) 							#nameKey: #showProtocol 							#value: #toggleShowProtocol 							#indication: true ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Co_nflicts 								#defaultString: 'Co&amp;nflicts' 								#catalogID: #menus ) 							#nameKey: #showConflicts 							#submenu: #(#{UI.Menu} #(									#(#{UI.MenuItem} 										#rawLabel: 										#(#{Kernel.UserMessage} 											#key: #VerticalView 											#defaultString: '&amp;Vertical View' 											#catalogID: #menus ) 										#nameKey: #viewConflictsVertically 										#value: #viewConflictsVertically 										#indication: true ) 									#(#{UI.MenuItem} 										#rawLabel: 										#(#{Kernel.UserMessage} 											#key: #HorizontalView 											#defaultString: '&amp;Horizontal View' 											#catalogID: #menus ) 										#nameKey: #viewConflictsHorizontally 										#value: #viewConflictsHorizontally 										#indication: true ) 									#(#{UI.MenuItem} 										#rawLabel: 										#(#{Kernel.UserMessage} 											#key: #SourceDifferences 											#defaultString: '&amp;Source Differences' 											#catalogID: #menus ) 										#nameKey: #highlightSourceDifferences 										#value: #highlightSourceDifferences 										#indication: true ) 									#(#{UI.MenuItem} 										#rawLabel: 										#(#{Kernel.UserMessage} 											#key: #CodeDifferences 											#defaultString: 'Co&amp;de Differences' 											#catalogID: #menus ) 										#nameKey: #highlightCodeDifferences 										#value: #highlightCodeDifferences 										#indication: true ) 									#(#{UI.MenuItem} 										#rawLabel: 										#(#{Kernel.UserMessage} 											#key: #EmphasizeInList 											#defaultString: '&amp;Emphasize in List' 											#catalogID: #menus ) 										#nameKey: #toggleListEmphasis 										#value: #toggleListEmphasis ) 									#(#{UI.MenuItem} 										#rawLabel: 										#(#{Kernel.UserMessage} 											#key: #IndicateSameMethods 											#defaultString: '&amp;Indicate Same Methods' 											#catalogID: #menus ) 										#nameKey: #toggleTypesIncludeSame 										#value: #toggleTypesIncludeSame ) ) #(2 2 2 ) nil ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #LineEndTreatment 								#defaultString: '&amp;Line End Treatment' 								#catalogID: #menus ) 							#nameKey: #lineEndTreatment 							#submenu: #(#{UI.Menu} #(									#(#{UI.MenuItem} 										#rawLabel: 										#(#{Kernel.UserMessage} 											#key: #AsInFile 											#defaultString: '&amp;As in File' 											#catalogID: #menus ) 										#nameKey: #lineEndsRaw 										#value: #lineEndsRaw 										#indication: true ) 									#(#{UI.MenuItem} 										#rawLabel: 										#(#{Kernel.UserMessage} 											#key: #_ConvertedToCRs 											#defaultString: '&amp;Converted to CRs' 											#catalogID: #menus ) 										#nameKey: #lineEndsTreated 										#value: #lineEndsTreated 										#indication: true ) ) #(2 ) nil ) ) ) #(2 2 ) nil ) ) ) #(6 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.OverrideList class</class-id> <category>interface specs</category><body package="Tools-Changes">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #OverrideList 				#defaultString: 'Override List' 				#catalogID: #labels ) 			#min: #(#{Core.Point} 300 400 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 505 200 985 700 ) 			#flags: 4 			#menu: #menuBar ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#properties: 					#(#{UI.PropertyListDictionary} #dragOkSelector 						#wantToDrag: #dragEnterSelector 						#dragEnter: #dragOverSelector 						#dragOver: #dragStartSelector 						#doDrag: #dropSelector 						#drop: #dragExitSelector 						#dragLeave: ) 					#layout: #(#{Graphics.LayoutFrame} 2 0 2 0 -102 1 178 0 ) 					#name: #listView 					#model: #selectionInList 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#doubleClickSelector: 						#toggleRemoveForListController: 						#requestValueChangeSelector: #changeRequest ) 					#menu: #changeListMenuHolder ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0 0 0 ) 							#model: #parcelFilterAdaptor 							#label: 							#(#{Kernel.UserMessage} 								#key: #parcel 								#defaultString: 'parcel' 								#catalogID: #labels ) ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0 25 0 ) 							#name: #packageFilter 							#flags: 32 							#model: #packageFilterAdaptor 							#label: 							#(#{Kernel.UserMessage} 								#key: #package 								#defaultString: 'package' 								#catalogID: #labels ) ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0 50 0 ) 							#model: #changeTypeFilterAdaptor 							#label: 							#(#{Kernel.UserMessage} 								#key: #type 								#defaultString: 'type' 								#catalogID: #labels ) ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0 75 0 ) 							#model: #classNameFilterAdaptor 							#label: 							#(#{Kernel.UserMessage} 								#key: #class 								#defaultString: 'class' 								#catalogID: #labels ) ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0 100 0 ) 							#model: #protocolFilterAdaptor 							#label: 							#(#{Kernel.UserMessage} 								#key: #protocol 								#defaultString: 'protocol' 								#catalogID: #labels ) ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0 125 0 ) 							#model: #selectorFilterAdaptor 							#label: 							#(#{Kernel.UserMessage} 								#key: #selector 								#defaultString: 'selector' 								#catalogID: #labels ) ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0 150 0 ) 							#model: #valuesFilterAdaptor 							#label: 							#(#{Kernel.UserMessage} 								#key: #same 								#defaultString: 'same' 								#catalogID: #labels ) ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} -100 1 2 0 -2 1 178 0 ) 						#name: #typeFilters 						#flags: 8 ) ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0 179 0 -2 1 181 0 ) 					#name: #ResizingSplitter1 					#horizontal: true 					#minAboveSize: 176 					#minBelowSize: 150 					#aboveWidgets: 'listView typeFilters' 					#belowWidgets: 'textCanvas' ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0 182 0 -2 1 -2 1 ) 					#name: #textCanvas 					#flags: 0 					#minorKey: #standardText ) ) ) )</body></methods><methods><class-id>Tools.ChangeSetManager class</class-id> <category>interface specs</category><body package="Tools-Changes">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #ChangeSets #defaultString: 'Change Sets' #catalogID: #labels) 			#min: #(#{Core.Point} 200 100 ) 			#max: #(#{Core.Point} 1024 768 ) 			#bounds: #(#{Graphics.Rectangle} 516 372 916 732 ) 			#flags: 4 			#menu: #menuBar 			#isEventDriven: true ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.DataSetSpec} 					#properties: #(#{UI.PropertyListDictionary} #showHorizontalLines false #allowColumnResizing true #rowSize 22 #showVerticalLines false #allowColumnReordering false ) 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 1 ) 					#name: #listModel 					#flags: 13 					#model: #listModel 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#doubleClickSelector: #changeSetBeCurrent ) 					#menu: #listMenu 					#columns: #(						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting false #labelFromApplication false ) 							#model: #'currentChangeSetHolder isCurrent' 							#labelIsImage: false 							#width: 22 							#rendererType: #Text 							#editorType: #None 							#noScroll: false ) 						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #labelFromApplication false #allowSorting false #allowResizing true ) 							#model: #'currentChangeSetHolder labelForNameColumn' 							#label: #(#{Kernel.UserMessage} #key: #Name #defaultString: 'Name' #catalogID: #labels) 							#labelIsImage: false 							#width: 200 							#rendererType: #Text 							#editorType: #None 							#noScroll: false ) 						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #labelFromApplication false #allowSorting false #allowResizing true ) 							#model: #'currentChangeSetHolder changedClassCount' 							#label: #(#{Kernel.UserMessage} #key: #Classes #defaultString: 'Classes' #catalogID: #labels) 							#labelIsImage: false 							#width: 70 							#rendererType: #Text 							#editorType: #None 							#type: #number 							#noScroll: false ) 						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #labelFromApplication false #allowSorting false #allowResizing true ) 							#model: #'currentChangeSetHolder changedMethodCount' 							#label: #(#{Kernel.UserMessage} #key: #Methods #defaultString: 'Methods' #catalogID: #labels) 							#labelIsImage: false 							#width: 70 							#rendererType: #Text 							#editorType: #None 							#type: #number 							#noScroll: false ) ) 					#labelsAsButtons: true ) ) ) )</body></methods><methods><class-id>Tools.ChangeSetManager class</class-id> <category>resources</category><body package="Tools-Changes">listMenu	"Tools.MenuEditor new openOnClass: self andSelector: #listMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_NewDot 					#defaultString: '&amp;New...' 					#catalogID: #menus ) 				#value: #newChangeSet ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Make_Current 					#defaultString: 'Make &amp;Current' 					#catalogID: #menus ) 				#nameKey: #changeSetBeCurrent 				#value: #changeSetBeCurrent 				#enablementSelector: #isChangeSetSelected 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #edit ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Edit 					#defaultString: '&amp;Edit' 					#catalogID: #menus ) 				#value: #editChangeSet 				#enablementSelector: #isChangeSetSelected ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Inspect 					#defaultString: '&amp;Inspect' 					#catalogID: #menus ) 				#value: #inspectChangeSet 				#enablementSelector: #isChangeSetSelected 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #inspect ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_BrowseMethods 					#defaultString: '&amp;Browse Methods' 					#catalogID: #menus ) 				#value: #browseChangedMethods 				#enablementSelector: #isChangeSetSelected ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_RenameDot 					#defaultString: '&amp;Rename...' 					#catalogID: #menus ) 				#value: #renameChangeSet 				#enablementSelector: #isChangeSetSelected ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Re_move 					#defaultString: 'Re&amp;move' 					#catalogID: #menus ) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_ForgetChanges 								#defaultString: '&amp;Forget Changes...' 								#catalogID: #menus ) 							#nameKey: #emptyChangeSet 							#value: #emptyChangeSet 							#enablementSelector: #isChangeSetSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Re_moveChangeSet 								#defaultString: 'Re&amp;move Change Set...' 								#catalogID: #menus ) 							#value: #deleteChangeSet 							#enablementSelector: #isChangeSetSelected 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #delete ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #RemoveChangedCode 								#defaultString: 'Remove Changed &amp;Code from System...' 								#catalogID: #menus ) 							#value: #expungeCurrentProjectFromSystem 							#enablementSelector: #isChangeSetSelected ) ) #(3 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_File 					#defaultString: '&amp;File' 					#catalogID: #menus ) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #File_In 								#defaultString: 'File &amp;In...' 								#catalogID: #menus ) 							#value: #fileInFrom 							#enablementSelector: #isChangeSetSelected 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #fileIn ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #FileInto_New 								#defaultString: 'File into &amp;New...' 								#catalogID: #menus ) 							#value: #importChangeSets ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #File_Out 								#defaultString: 'File &amp;Out...' 								#catalogID: #menus ) 							#value: #fileOutChangeSet 							#enablementSelector: #isChangeSetSelected 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #fileSave ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #FileOutA_ll 								#defaultString: 'File out A&amp;ll...' 								#catalogID: #menus ) 							#value: #fileOutAllChangeSets ) ) #(2 2 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Fi_nd 					#defaultString: 'Fi&amp;nd' 					#catalogID: #menus ) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Class 								#defaultString: '&amp;Class...' 								#catalogID: #menus ) 							#value: #findClass 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #findClass ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Selector 								#defaultString: '&amp;Selector...' 								#catalogID: #menus ) 							#value: #findSelector 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #findSelector ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Se_ndersDot 								#defaultString: 'Se&amp;nders...' 								#catalogID: #menus ) 							#value: #browseSenders 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #selectorReferences ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #I_mplementors 								#defaultString: 'I&amp;mplementors...' 								#catalogID: #menus ) 							#value: #browseImplementors 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #selectorImplementors ) ) ) #(2 2 ) nil ) ) ) #(1 1 5 2 ) nil ) decodeAsLiteralArray</body><body package="Tools-Changes">menuBar	"Tools.MenuEditor new openOnClass: self andSelector: #menuBar"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_File 					#defaultString: '&amp;File' 					#catalogID: #menus ) 				#nameKey: #fileSubmenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #File_In 								#defaultString: 'File &amp;In...' 								#catalogID: #menus ) 							#value: #fileInFrom 							#enablementSelector: #isChangeSetSelected 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #fileIn ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #FileInto_New 								#defaultString: 'File into &amp;New...' 								#catalogID: #menus ) 							#value: #importChangeSets ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #File_Out 								#defaultString: 'File &amp;Out...' 								#catalogID: #menus ) 							#value: #fileOutChangeSet 							#enablementSelector: #isChangeSetSelected 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #fileSave ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #FileOut_All 								#defaultString: 'File out &amp;All...' 								#catalogID: #menus ) 							#value: #fileOutAllChangeSets ) ) #(2 2 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Set 					#defaultString: '&amp;Set' 					#catalogID: #menus ) 				#nameKey: #setSubmenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_NewDot 								#defaultString: '&amp;New...' 								#catalogID: #menus ) 							#value: #newChangeSet ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Make_Current 								#defaultString: 'Make &amp;Current' 								#catalogID: #menus ) 							#nameKey: #changeSetBeCurrent 							#value: #changeSetBeCurrent 							#enablementSelector: #isChangeSetSelected 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #edit ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Edit 								#defaultString: '&amp;Edit' 								#catalogID: #menus ) 							#value: #editChangeSet 							#enablementSelector: #isChangeSetSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Inspect 								#defaultString: '&amp;Inspect' 								#catalogID: #menus ) 							#value: #inspectChangeSet 							#enablementSelector: #isChangeSetSelected 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #inspect ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_BrowseMethods 								#defaultString: '&amp;Browse Methods' 								#catalogID: #menus ) 							#value: #browseChangedMethods 							#enablementSelector: #isChangeSetSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Re_nameDot 								#defaultString: 'Re&amp;name...' 								#catalogID: #menus ) 							#value: #renameChangeSet 							#enablementSelector: #isChangeSetSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_ForgetChanges 								#defaultString: '&amp;Forget Changes...' 								#catalogID: #menus ) 							#value: #emptyChangeSet 							#enablementSelector: #isChangeSetSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Re_moveDot 								#defaultString: 'Re&amp;move...' 								#catalogID: #menus ) 							#value: #deleteChangeSet 							#enablementSelector: #isChangeSetSelected 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #delete ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #RemoveChangedCode 								#defaultString: 'Remove Changed &amp;Code from System...' 								#catalogID: #menus ) 							#value: #expungeCurrentProjectFromSystem 							#enablementSelector: #isChangeSetSelected ) ) #(1 1 4 3 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Fi_nd 					#defaultString: 'Fi&amp;nd' 					#catalogID: #menus ) 				#nameKey: #findSubmenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Class 								#defaultString: '&amp;Class...' 								#catalogID: #menus ) 							#value: #findClass 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #findClass ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Selector 								#defaultString: '&amp;Selector...' 								#catalogID: #menus ) 							#value: #findSelector 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #findSelector ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Se_ndersDot 								#defaultString: 'Se&amp;nders...' 								#catalogID: #menus ) 							#value: #browseSenders 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #selectorReferences ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #I_mplementors 								#defaultString: 'I&amp;mplementors...' 								#catalogID: #menus ) 							#value: #browseImplementors 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #selectorImplementors ) ) ) #(2 2 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Help 					#defaultString: '&amp;Help' 					#catalogID: #menus ) 				#nameKey: #helpSubmenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_ChangeSetManager 								#defaultString: '&amp;Change Set Manager' 								#catalogID: #menus ) 							#value: #helpChangeSetBrowser ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #C_hangesAndChangeSets 								#defaultString: 'C&amp;hanges and Change Sets' 								#catalogID: #menus ) 							#value: #helpChangesAndChangeSets ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_AboutVisualWorksDot 								#defaultString: '&amp;About VisualWorks...' 								#catalogID: #menus ) 							#value: #helpAbout ) ) #(2 1 ) nil ) ) ) #(4 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.ChangeEditor class</class-id> <category>interface specs</category><body package="Tools-Changes">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: #(#{Kernel.UserMessage} #key: #ChangeSet #defaultString: 'Change Set' #catalogID: #labels) 			#bounds: #(#Rectangle 413 187 770 527 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#TextEditorSpec 					#layout: #(#LayoutFrame 0 0 0 0.333333 0 1 -50 1 ) 					#model: #text 					#callbacksSpec: 					#(#UIEventCallbackSubSpec 						#valueChangeSelector: 						#acceptText: ) ) 				#(#SequenceViewSpec 					#layout: #(#LayoutFrame 0 0 0 0 0 0.333333 0 0.333333 ) 					#model: #classList 					#menu: #classMenu ) 				#(#SequenceViewSpec 					#layout: #(#LayoutFrame 0 0.333333 0 0 0 0.666666 0 0.333333 ) 					#model: #methodList 					#menu: #methodMenu ) 				#(#SequenceViewSpec 					#layout: #(#LayoutFrame 0 0.666666 0 0 0 1 0 0.333333 ) 					#model: #destinationList ) 				#(#RadioButtonSpec 					#layout: #(#LayoutOrigin 5 0 -47 1 ) 					#name: #rbadd 					#flags: 16 					#model: #changeType 					#label: #(#{Kernel.UserMessage} #key: #add #defaultString: 'add' #catalogID: #labels) 					#select: #add ) 				#(#RadioButtonSpec 					#layout: #(#LayoutOrigin 60 0 -47 1 ) 					#name: #rbchange 					#flags: 16 					#model: #changeType 					#label: #(#{Kernel.UserMessage} #key: #change #defaultString: 'change' #catalogID: #labels) 					#select: #change ) 				#(#RadioButtonSpec 					#layout: #(#LayoutOrigin 134 0 -47 1 ) 					#name: #rbremove 					#flags: 16 					#model: #changeType 					#label: #(#{Kernel.UserMessage} #key: #remove #defaultString: 'remove' #catalogID: #labels) 					#select: #remove ) 				#(#CheckBoxSpec 					#layout: #(#LayoutOrigin 139 0 -25 1 ) 					#name: #classComment 					#flags: 16 					#model: #classComment 					#label: #(#{Kernel.UserMessage} #key: #comment #defaultString: 'comment' #catalogID: #labels) ) 				#(#CheckBoxSpec 					#layout: #(#LayoutOrigin 4 0 -25 1 ) 					#name: #classRename 					#flags: 48 					#model: #classRename 					#label: #(#{Kernel.UserMessage} #key: #rename #defaultString: 'rename' #catalogID: #labels) ) 				#(#CheckBoxSpec 					#layout: #(#LayoutOrigin 71 0 -25 1 ) 					#name: #classRemove 					#flags: 48 					#model: #classRemove 					#label: #(#{Kernel.UserMessage} #key: #remove #defaultString: 'remove' #catalogID: #labels) ) 				#(#CheckBoxSpec 					#layout: #(#LayoutOrigin 214 0 -25 1 ) 					#name: #classOrganize 					#flags: 16 					#model: #classOrganize 					#label: #(#{Kernel.UserMessage} #key: #organize #defaultString: 'organize' #catalogID: #labels) ) ) ) )</body></methods><methods><class-id>Tools.ChangeList</class-id> <category>menu messages</category><body package="Tools-Changes">functionsSubmenu	&lt;submenu: #(#Functions #menus 'Functions')		nameKey: #functionsSubmenu		menu: #(#menuBar)		position: 10.075&gt;</body><body package="Tools-Changes">relocateToNameSpace	&lt;menuItem: #(#RelocateToNamespace #menus 'Relocate To Namespace')		nameKey: nil		menu: #(#menuBar #functionsSubmenu)		position: 10.01&gt;	| nameSpaceName |	nameSpaceName := Dialog							request: (#RlctToWhchNmSpc &lt;&lt; #dialogs &gt;&gt; 'Relocate to which name space?')							initialAnswer: (#NameSpace &lt;&lt; #labels &gt;&gt; 'NameSpace') asString.	nameSpaceName isEmpty ifTrue: [^self].	list do:		[:change|		(removed includes: change) ifFalse: [change relocateTo: nameSpaceName]].	self updateList</body></methods><methods><class-id>Tools.ChangeList class</class-id> <category>interface specs</category><body package="Tools-Changes">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #ChangeList 				#defaultString: 'Change List' 				#catalogID: #labels ) 			#min: #(#{Core.Point} 300 400 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 1064 470 1544 970 ) 			#flags: 4 			#menu: #menuBar ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#properties: 					#(#{UI.PropertyListDictionary} #dragOkSelector 						#wantToDrag: #dragEnterSelector 						#dragEnter: #dragOverSelector 						#dragOver: #dragStartSelector 						#doDrag: #dropSelector 						#drop: #dragExitSelector 						#dragLeave: ) 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 -100 1 150 0 ) 					#name: #listView 					#model: #selectionInList 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#doubleClickSelector: 						#toggleRemoveForListController: 						#requestValueChangeSelector: #changeRequest ) 					#menu: #changeListMenuHolder ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 4 0 0 0 ) 							#model: #fileFilterAdaptor 							#label: 							#(#{Kernel.UserMessage} 								#key: #file 								#defaultString: 'file' 								#catalogID: #labels ) ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 4 0 25 0 ) 							#model: #changeTypeFilterAdaptor 							#label: 							#(#{Kernel.UserMessage} 								#key: #type 								#defaultString: 'type' 								#catalogID: #labels ) ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 4 0 50 0 ) 							#model: #classNameFilterAdaptor 							#label: 							#(#{Kernel.UserMessage} 								#key: #class 								#defaultString: 'class' 								#catalogID: #labels ) ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 4 0 75 0 ) 							#model: #protocolFilterAdaptor 							#label: 							#(#{Kernel.UserMessage} 								#key: #protocol 								#defaultString: 'protocol' 								#catalogID: #labels ) ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 4 0 100 0 ) 							#model: #selectorFilterAdaptor 							#label: 							#(#{Kernel.UserMessage} 								#key: #selector 								#defaultString: 'selector' 								#catalogID: #labels ) ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 4 0 125 0 ) 							#model: #valuesFilterAdaptor 							#label: 							#(#{Kernel.UserMessage} 								#key: #same 								#defaultString: 'same' 								#catalogID: #labels ) ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} -100 1 0 0 0 1 150 0 ) 						#name: #filters 						#flags: 8 ) ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 150 0 0 1 153 0 ) 					#name: #ResizingSplitter1 					#horizontal: true 					#minAboveSize: 150 					#minBelowSize: 25 					#aboveWidgets: 'listView filters' 					#belowWidgets: 'textCanvas' ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 153 0 0 1 0 1 ) 					#name: #textCanvas 					#flags: 0 					#minorKey: #standardText ) ) ) )</body></methods><methods><class-id>Tools.ChangeList class</class-id> <category>resources</category><body package="Tools-Changes">changeListMenu	"Tools.MenuEditor new openOnClass: self andSelector: #changeListMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #FileInOut 					#defaultString: '&amp;File In/Out' 					#catalogID: #menus ) 				#nameKey: #fileMenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ReadFilesDot 								#defaultString: '&amp;Read File(s)...' 								#catalogID: #menus ) 							#value: #fileIn ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #RecoverLastChanges 								#defaultString: 'Recover &amp;Last Changes' 								#catalogID: #menus ) 							#value: #recoverLast ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Display_SystemChanges 								#defaultString: 'Display &amp;System Changes' 								#catalogID: #menus ) 							#value: #getChanges ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #WriteFileDot 								#defaultString: '&amp;Write File...' 								#catalogID: #menus ) 							#value: #fileOut 							#enablementSelector: #anyToFileOut ) ) #(3 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Re_playAll 					#defaultString: 'Re&amp;play All' 					#catalogID: #menus ) 				#nameKey: #replayAllMenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #FromHere 								#defaultString: 'From &amp;Here' 								#catalogID: #menus ) 							#value: #doFromHere 							#enablementSelector: #hasSelection ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #FromTheTop 								#defaultString: 'From the &amp;Top' 								#catalogID: #menus ) 							#value: #doAll 							#enablementSelector: #hasItemsDisplayed ) ) #(2 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #RemoveAll 					#defaultString: 'Re&amp;move All' 					#catalogID: #menus ) 				#value: #removeAll 				#enablementSelector: #hasUnremovedItemsDisplayed ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_SpawnAll 					#defaultString: '&amp;Spawn All' 					#catalogID: #menus ) 				#value: #copyView 				#enablementSelector: #hasItemsDisplayed ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_RestoreMarked 					#defaultString: '&amp;Restore Marked' 					#catalogID: #menus ) 				#value: #restoreAll 				#enablementSelector: #hasRemovedItemsDisplayed ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_ForgetMarked 					#defaultString: '&amp;Forget Marked' 					#catalogID: #menus ) 				#value: #forgetThese 				#enablementSelector: #hasRemovedItemsDisplayed ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #R_eplay 					#defaultString: 'R&amp;eplay' 					#catalogID: #menus ) 				#value: #doThis 				#enablementSelector: #hasSelection ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Rem_ove 					#defaultString: 'Rem&amp;ove' 					#catalogID: #menus ) 				#value: #removeItem 				#enablementSelector: #hasUnremovedSelection ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Res_tore 					#defaultString: 'Res&amp;tore' 					#catalogID: #menus ) 				#value: #restoreItem 				#enablementSelector: #hasRemovedSelection ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Forget 					#defaultString: '&amp;Forget' 					#catalogID: #menus ) 				#value: #forgetSelection 				#enablementSelector: #hasRemovedSelection ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Spa_wn 					#defaultString: 'Spa&amp;wn' 					#catalogID: #menus ) 				#value: #spawnBrowserOnSelection 				#enablementSelector: #hasSelection ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Conflicts 					#defaultString: '&amp;Conflicts' 					#catalogID: #menus ) 				#nameKey: #conflictsMenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Save_ConflictsAsDot 								#defaultString: 'Save &amp;Conflicts As...' 								#catalogID: #menus ) 							#value: #check ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SaveConflictsWith_SystemAsDot 								#defaultString: 'Save Conflicts with &amp;System As...' 								#catalogID: #menus ) 							#value: #checkWithSystem ) ) #(2 ) nil ) ) ) #(1 3 2 5 1 ) nil ) decodeAsLiteralArray</body><body package="Tools-Changes">menuBar	"Tools.MenuEditor new openOnClass: self andSelector: #menuBar"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_File 					#defaultString: '&amp;File' 					#catalogID: #menus ) 				#nameKey: #file 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ReadFilesDot 								#defaultString: '&amp;Read File(s)...' 								#catalogID: #menus ) 							#value: #fileIn ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ReadDifferentSourceFromFilesDot 								#defaultString: 'Read Different &amp;Source from File(s)...' 								#catalogID: #menus ) 							#value: #fileInSourceDifferences ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ReadDifferentCodeFromFilesDot 								#defaultString: 'Read Different &amp;Code from File(s)...' 								#catalogID: #menus ) 							#value: #fileInDifferences ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #RecoverLastChanges 								#defaultString: 'Recover &amp;Last Changes' 								#catalogID: #menus ) 							#value: #recoverLast ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #RecoverC_hangesDots 								#defaultString: 'Recover C&amp;hanges...' 								#catalogID: #menus ) 							#value: #recover ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #DisplayS_ystemChanges 								#defaultString: 'Display S&amp;ystem Changes' 								#catalogID: #menus ) 							#value: #getChanges ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #DisplayAllSystemChanges 								#defaultString: 'Display &amp;All System Changes' 								#catalogID: #menus ) 							#value: #getAllChanges ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Display_ParcelDot 								#defaultString: 'Display &amp;Parcel...' 								#catalogID: #menus ) 							#value: #getParcel ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #WriteFileDot 								#defaultString: '&amp;Write File...' 								#catalogID: #menus ) 							#value: #fileOut 							#enablementSelector: #anyToFileOut ) ) #(1 2 4 1 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Replay 					#defaultString: '&amp;Replay' 					#catalogID: #menus ) 				#nameKey: #replay 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Selection 								#defaultString: '&amp;Selection' 								#catalogID: #menus ) 							#value: #doThis 							#enablementSelector: #hasSelection ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #AllFromTheTop 								#defaultString: 'All from the &amp;Top' 								#catalogID: #menus ) 							#value: #doAll 							#enablementSelector: #hasItemsDisplayed ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #AllFromHereDown 								#defaultString: 'All from here &amp;Down' 								#catalogID: #menus ) 							#value: #doFromHere 							#enablementSelector: #hasSelection ) ) #(1 2 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Re_move 					#defaultString: 'Re&amp;move' 					#catalogID: #menus ) 				#nameKey: #remove 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Selection 								#defaultString: '&amp;Selection' 								#catalogID: #menus ) 							#value: #removeItem 							#enablementSelector: #hasSelection ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #A_ll 								#defaultString: 'A&amp;ll' 								#catalogID: #menus ) 							#value: #removeAll 							#enablementSelector: #hasUnremovedItemsDisplayed ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #AllAbove 								#defaultString: 'All &amp;Above' 								#catalogID: #menus ) 							#value: #removeAllAbove 							#enablementSelector: #hasSelection ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #AllBelow 								#defaultString: 'All &amp;Below' 								#catalogID: #menus ) 							#value: #removeAllBelow 							#enablementSelector: #hasSelection ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ExchangeRemoved 								#defaultString: 'E&amp;xchange Removed' 								#catalogID: #menus ) 							#value: #exchangeRemoved 							#enablementSelector: #hasItemsDisplayed ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SameCodeAsSystem 								#defaultString: 'Same &amp;Code as System' 								#catalogID: #menus ) 							#value: #removeSameAsSystem 							#enablementSelector: #hasUnremovedItemsDisplayed ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SameSourceAsSystem 								#defaultString: 'Same &amp;Source as System' 								#catalogID: #menus ) 							#value: #removeSameSourceAsSystem 							#enablementSelector: #hasUnremovedItemsDisplayed ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #DifferentCodeToSystem 								#defaultString: 'Different C&amp;ode to System' 								#catalogID: #menus ) 							#value: #removeConflictsWithSystem 							#enablementSelector: #hasUnremovedItemsDisplayed ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #DifferentSourceToSystem 								#defaultString: 'Different So&amp;urce to System' 								#catalogID: #menus ) 							#value: #removeSourceConflictsWithSystem 							#enablementSelector: #hasUnremovedItemsDisplayed ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #CodeForClassesNotInSystem 								#defaultString: 'Code for Classes &amp;not in System' 								#catalogID: #menus ) 							#value: #removeClassesNotInSystem 							#enablementSelector: #hasUnremovedItemsDisplayed ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #MethodsNotInSystem 								#defaultString: '&amp;Methods not in System' 								#catalogID: #menus ) 							#value: #removeMethodsNotInSystem 							#enablementSelector: #hasUnremovedItemsDisplayed ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #OldVersions 								#defaultString: 'Old &amp;Versions' 								#catalogID: #menus ) 							#value: #removeOldVersions 							#enablementSelector: #hasUnremovedItemsDisplayed ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ExactDuplicates 								#defaultString: 'Exact &amp;Duplicates' 								#catalogID: #menus ) 							#value: #removeDuplicates 							#enablementSelector: #hasUnremovedItemsDisplayed ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Con_flicts 								#defaultString: 'Con&amp;flicts' 								#catalogID: #menus ) 							#value: #removeConflictsInList 							#enablementSelector: #hasUnremovedItemsDisplayed ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ChangesWithTextDot 								#defaultString: 'Changes with &amp;Text ...' 								#catalogID: #menus ) 							#value: #removeChangesContainingString 							#enablementSelector: #hasRemovedItemsDisplayed ) ) #(4 1 2 2 2 3 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #For_get 					#defaultString: 'For&amp;get' 					#catalogID: #menus ) 				#nameKey: #forget 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ForgetSelection 								#defaultString: 'Forget &amp;Selection' 								#catalogID: #menus ) 							#value: #forgetSelection 							#enablementSelector: #hasRemovedSelection ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Forget_Marked 								#defaultString: 'Forget &amp;Marked' 								#catalogID: #menus ) 							#value: #forgetThese 							#enablementSelector: #hasRemovedItemsDisplayed ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ForgetAllMarked 								#defaultString: 'Forget &amp;All Marked' 								#catalogID: #menus ) 							#value: #forgetAll 							#enablementSelector: #hasRemovedItems ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #RestoreSelection 								#defaultString: '&amp;Restore Selection' 								#catalogID: #menus ) 							#value: #restoreItem 							#enablementSelector: #hasRemovedSelection ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #RestoreAll 								#defaultString: 'R&amp;estore All' 								#catalogID: #menus ) 							#value: #restoreAll 							#enablementSelector: #hasRemovedItemsDisplayed ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #RestoreChangesWithTextDot 								#defaultString: 'Restore Changes with &amp;Text...' 								#catalogID: #menus ) 							#value: #restoreChangesContainingString 							#enablementSelector: #hasRemovedItemsDisplayed ) ) #(3 3 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Fi_nd 					#defaultString: 'Fi&amp;nd' 					#catalogID: #menus ) 				#nameKey: #find 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #FileDot 								#defaultString: '&amp;File ...' 								#catalogID: #menus ) 							#value: #findFile ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_TypeDot 								#defaultString: '&amp;Type ...' 								#catalogID: #menus ) 							#value: #findType ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ClassDot 								#defaultString: '&amp;Class ...' 								#catalogID: #menus ) 							#value: #findClass ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ProtocolDot 								#defaultString: '&amp;Protocol ...' 								#catalogID: #menus ) 							#value: #findProtocol ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SelectorDot 								#defaultString: '&amp;Selector ...' 								#catalogID: #menus ) 							#value: #findSelector ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SpawnSelection 								#defaultString: 'Spa&amp;wn Selection' 								#catalogID: #menus ) 							#value: #spawnBrowserOnSelection 							#enablementSelector: #hasSelection ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Spawn_All 								#defaultString: 'Spawn &amp;All' 								#catalogID: #menus ) 							#value: #copyView 							#enablementSelector: #hasItemsDisplayed ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SpawnChangesWithTextDot 								#defaultString: 'Spawn Changes with &amp;Text ...' 								#catalogID: #menus ) 							#value: #spawnChangesContainingString 							#enablementSelector: #hasUnremovedItemsDisplayed ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ClassMatching 								#defaultString: 'Class &amp;Matching' 								#catalogID: #menus ) 							#nameKey: #classMatching 							#submenu: #(#{UI.Menu} #(									#(#{UI.MenuItem} 										#rawLabel: 										#(#{Kernel.UserMessage} 											#key: #InstanceAndClass 											#defaultString: '&amp;Instance and Class' 											#catalogID: #menus ) 										#nameKey: #groupClassAndMetaclass 										#value: #groupClassAndMetaclass 										#indication: true ) 									#(#{UI.MenuItem} 										#rawLabel: 										#(#{Kernel.UserMessage} 											#key: #SelectedClassOnly 											#defaultString: 'Selected Class &amp;Only' 											#catalogID: #menus ) 										#nameKey: #ungroupClassAndMetaclass 										#value: #ungroupClassAndMetaclass 										#indication: true ) ) #(2 ) nil ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SameFile 								#defaultString: 'Same File' 								#catalogID: #menus ) 							#nameKey: #filterByFile 							#value: #toggleFileFilter 							#indication: true ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SameType 								#defaultString: 'Same Type' 								#catalogID: #menus ) 							#nameKey: #filterByType 							#value: #toggleTypeFilter 							#indication: true ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SameClass 								#defaultString: 'Same Class' 								#catalogID: #menus ) 							#nameKey: #filterByClass 							#value: #toggleClassFilter 							#indication: true ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SameProtocol 								#defaultString: 'Same Protocol' 								#catalogID: #menus ) 							#nameKey: #filterByProtocol 							#value: #toggleProtocolFilter 							#indication: true ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SameSelector 								#defaultString: 'Same Selector' 								#catalogID: #menus ) 							#nameKey: #filterBySelector 							#value: #toggleSelectorFilter 							#indication: true ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SameChange 								#defaultString: 'Same Change' 								#catalogID: #menus ) 							#nameKey: #filterBySame 							#value: #toggleSameFilter 							#indication: true ) ) #(5 3 1 6 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Conflicts 					#defaultString: '&amp;Conflicts' 					#catalogID: #menus ) 				#nameKey: #conflicts 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_SaveConflictsAsDot 								#defaultString: '&amp;Save Conflicts As...' 								#catalogID: #menus ) 							#value: #check ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Save_ConflictsWithSystemAsDot 								#defaultString: 'Save &amp;Conflicts with System As...' 								#catalogID: #menus ) 							#value: #checkWithSystem ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #RemoveConflicts 								#defaultString: '&amp;Remove Conflicts' 								#catalogID: #menus ) 							#value: #removeConflictsInList ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #RemoveConflictsWithSystem 								#defaultString: 'Remove Conflicts &amp;with System' 								#catalogID: #menus ) 							#value: #removeConflictsWithSystem ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #AddSystemConflicts 								#defaultString: '&amp;Add System Conflicts' 								#catalogID: #menus ) 							#value: #addSystemConflicts ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #AddOriginalVersions 								#defaultString: 'Add &amp;Original Versions' 								#catalogID: #menus ) 							#value: #addOriginals ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #AddToChangeSet 								#defaultString: 'A&amp;dd to Change Set' 								#catalogID: #menus ) 							#value: #addChangesToCurrentChangeSet ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #RemoveFromChangeSet 								#defaultString: 'Remove &amp;from Change Set' 								#catalogID: #menus ) 							#value: #removeChangesFromCurrentChangeSet ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #BuildScriptToSystem 								#defaultString: '&amp;Build Script to System' 								#catalogID: #menus ) 							#value: #spawnConvergeScriptToSystem ) ) #(2 2 2 3 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Show 					#defaultString: '&amp;Show' 					#catalogID: #menus ) 				#nameKey: #show 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ShowFile 								#defaultString: 'Show &amp;File' 								#catalogID: #menus ) 							#nameKey: #showFile 							#value: #toggleShowFile 							#indication: true ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ShowProtocol 								#defaultString: 'Show &amp;Protocol' 								#catalogID: #menus ) 							#nameKey: #showProtocol 							#value: #toggleShowProtocol 							#indication: true ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ShowConflicts 								#defaultString: 'Show &amp;Conflicts' 								#catalogID: #menus ) 							#nameKey: #showConflicts 							#value: #toggleShowConflicts 							#indication: true ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Co_nflicts 								#defaultString: 'Co&amp;nflicts' 								#catalogID: #menus ) 							#nameKey: #showConflicts 							#submenu: #(#{UI.Menu} #(									#(#{UI.MenuItem} 										#rawLabel: 										#(#{Kernel.UserMessage} 											#key: #VerticalView 											#defaultString: '&amp;Vertical View' 											#catalogID: #menus ) 										#nameKey: #viewConflictsVertically 										#value: #viewConflictsVertically 										#indication: true ) 									#(#{UI.MenuItem} 										#rawLabel: 										#(#{Kernel.UserMessage} 											#key: #HorizontalView 											#defaultString: '&amp;Horizontal View' 											#catalogID: #menus ) 										#nameKey: #viewConflictsHorizontally 										#value: #viewConflictsHorizontally 										#indication: true ) 									#(#{UI.MenuItem} 										#rawLabel: 										#(#{Kernel.UserMessage} 											#key: #SourceDifferences 											#defaultString: '&amp;Source Differences' 											#catalogID: #menus ) 										#nameKey: #highlightSourceDifferences 										#value: #highlightSourceDifferences 										#indication: true ) 									#(#{UI.MenuItem} 										#rawLabel: 										#(#{Kernel.UserMessage} 											#key: #CodeDifferences 											#defaultString: 'Co&amp;de Differences' 											#catalogID: #menus ) 										#nameKey: #highlightCodeDifferences 										#value: #highlightCodeDifferences 										#indication: true ) 									#(#{UI.MenuItem} 										#rawLabel: 										#(#{Kernel.UserMessage} 											#key: #EmphasizeInList 											#defaultString: '&amp;Emphasize in List' 											#catalogID: #menus ) 										#nameKey: #toggleListEmphasis 										#value: #toggleListEmphasis ) 									#(#{UI.MenuItem} 										#rawLabel: 										#(#{Kernel.UserMessage} 											#key: #IndicateSameMethods 											#defaultString: '&amp;Indicate Same Methods' 											#catalogID: #menus ) 										#nameKey: #toggleTypesIncludeSame 										#value: #toggleTypesIncludeSame ) ) #(2 2 2 ) nil ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #LineEndTreatment 								#defaultString: '&amp;Line End Treatment' 								#catalogID: #menus ) 							#nameKey: #lineEndTreatment 							#submenu: #(#{UI.Menu} #(									#(#{UI.MenuItem} 										#rawLabel: 										#(#{Kernel.UserMessage} 											#key: #AsInFile 											#defaultString: '&amp;As in File' 											#catalogID: #menus ) 										#nameKey: #lineEndsRaw 										#value: #lineEndsRaw 										#indication: true ) 									#(#{UI.MenuItem} 										#rawLabel: 										#(#{Kernel.UserMessage} 											#key: #C_onvertedToCRs 											#defaultString: 'C&amp;onverted to CRs' 											#catalogID: #menus ) 										#nameKey: #lineEndsTreated 										#value: #lineEndsTreated 										#indication: true ) ) #(2 ) nil ) ) ) #(3 2 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Help 					#defaultString: '&amp;Help' 					#catalogID: #menus ) 				#nameKey: #help 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_ChangeList 								#defaultString: '&amp;Change List' 								#catalogID: #menus ) 							#value: #helpChangeList 							#shortcutKeyCharacter: #F1 							#shortcutModifiers: 0 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #help ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #C_hangesAndChangeSets 								#defaultString: 'C&amp;hanges and Change Sets' 								#catalogID: #menus ) 							#value: #helpChangesAndChangeSets ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_AboutVisualWorksDot 								#defaultString: '&amp;About VisualWorks...' 								#catalogID: #menus ) 							#value: #helpAbout ) ) #(2 1 ) nil ) ) ) #(8 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>UI.CommandRegistry class</class-id> <category>commands - launcher</category><body package="Tools-Changes">openChangeListCommand	&lt;command: #openChangeList&gt;	^Command		label: (#_ChangeList &lt;&lt; #menus &gt;&gt; '&amp;Change List')		group: #launcher		bindings: #(			isMSWindows #(F7)			isMacOSX #(F7)			isX11 #(F7)		)</body><body package="Tools-Changes">openChangeSetManagerCommand	&lt;command: #openChangeSetManager&gt;	^Command		label: (#openChangeSets &lt;&lt; #menus &gt;&gt; 'Open Change Set Manager')		group: #launcher		bindings: #(			isMSWindows #(F4)			isMacOSX #(F4)			isX11 #(F4)		)</body><body package="Tools-Changes">openSystemOverrideListCommand	&lt;command: #openSystemOverrideList&gt;	^Command		label: (#openSystemOverrideList &lt;&lt; #menus &gt;&gt; 'Open System Override List')		group: #launcher		bindings: #()</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>menus - tools</category><body package="Tools-Changes">menuItemOpenChangeList	&lt;vwPrivileged&gt;	&lt;menuItemForCommand: #openChangeList		icon: nil		nameKey: nil		menu: #(#menuBar #tools)		position: 10.5&gt;	self openApplicationForClassNamed: #{ChangeList}</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>menus - changes</category><body package="Tools-Changes">menuItemOpenChangeSets	&lt;menuItemForCommand: #openChangeSetManager		nameKey: nil		menu: #(#menuBar #system #changes)		position: 10.1&gt;	self openApplicationForClassNamed: #{ChangeSetManager}</body><body package="Tools-Changes">menuItemOpenSystemOverrides	&lt;menuItemForCommand: #openSystemOverrideList		nameKey: nil		menu: #(#menuBar #system #changes)		position: 40.1&gt;	OverrideList new openOn: Override overrideList</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Override</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sources definition </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Overrides</category><attributes><package>System-Overrides</package></attributes></class><class><name>Change</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sourceCode manager name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Changes</category><attributes><package>System-Changes</package></attributes></class><class><name>MethodChange</name><environment>Kernel</environment><super>Kernel.ClassRelatedChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector category </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Changes</category><attributes><package>System-Changes</package></attributes></class><class><name>OverridenMethod</name><environment>Kernel</environment><super>Kernel.Override</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector protocol instVarNames </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Overrides</category><attributes><package>System-Overrides</package></attributes></class><class><name>ClassOtherChange</name><environment>Kernel</environment><super>Kernel.ClassChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars>type otherData </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Changes</category><attributes><package>System-Changes</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>OtherChange</name><environment>Kernel</environment><super>Kernel.Change</super><private>false</private><indexed-type>none</indexed-type><inst-vars>text type </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Changes</category><attributes><package>System-Changes</package></attributes></class><class><name>ClassCommentChange</name><environment>Kernel</environment><super>Kernel.ClassOtherChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Changes</category><attributes><package>System-Changes</package></attributes></class><class><name>ComponentChange</name><environment>Kernel</environment><super>Kernel.Change</super><private>false</private><indexed-type>none</indexed-type><inst-vars>componentType componentName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Code Component Changes</category><attributes><package>System-Code Component Changes</package></attributes></class><class><name>OverridenStatic</name><environment>Kernel</environment><super>Kernel.Override</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>method </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Overrides</category><attributes><package>System-Overrides</package></attributes></class><class><name>ClassDefinitionChange</name><environment>Kernel</environment><super>Kernel.ClassChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars>superclassName nameSpaceName otherParameters </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Changes</category><attributes><package>System-Changes</package></attributes></class><class><name>VisualLauncher</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuBar toolBar textCollector transcriptView statusBar </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>Tools-Misc</package></attributes></class><class><name>UnknownChange</name><environment>Kernel</environment><super>Kernel.OtherChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Changes</category><attributes><package>System-Changes</package></attributes></class></st-source>