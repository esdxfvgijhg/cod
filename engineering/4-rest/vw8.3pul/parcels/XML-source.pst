<?xml version="1.0"?><st-source><!-- Name: XML-sourceNotice: Copyright 1999-2015 Cincom Systems, Inc.  All rights reserved.Comment: This parcel implements the reading and writing of XML-format Smalltalk source code.DevelopmentPrerequisites: #(#(#any 'XML' ''))HideSource: falseIsFunctional: falsePackageName: XML-sourcePackageName:: XML-sourceParcel: #('XML-source')PrerequisiteParcels: #(#('XML' ''))SaveSource: trueVersion: 8.2 - 1Date: 12:05:13 PM July 28, 2017 --><time-stamp>From VisualWorksÂ®, 8.3 of July 28, 2017 on July 28, 2017 at 12:05:13 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>SourceScannerNodeBuilder</name><environment>XML</environment><super>XML.XMLNodeBuilder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selectors currentFile currentPosition positions changeBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Source Code</category><attributes><package>XML-source</package></attributes></class><comment><class-id>XML.SourceScannerNodeBuilder</class-id><body>This subclass of XMLNodeBuilder is used by the VisualWorks ChangeScanner to scan a VisualWorks XML source file and distill it into first XML elements and then into valid Smalltalk objects for display in the Change List tool.Instance Variables:	selectors	&lt;Dictionary&gt;  comment	currentFile	&lt;ReadStream&gt;  comment	currentPosition	&lt;Integer&gt;  comment	positions	&lt;Dictionary&gt;  comment	changeBlock	&lt;BlockClosure&gt;  comment</body></comment><class><name>SourceNodeBuilder</name><environment>XML</environment><super>XML.XMLNodeBuilder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selectors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Source Code</category><attributes><package>XML-source</package></attributes></class><comment><class-id>XML.SourceNodeBuilder</class-id><body>This subclass of XMLNodeBuilder is used by the XML parser to distill a VisualWorks XML source document (stream) into first XML elements and then into valid Smalltalk objectsInstance Variables:	selectors	&lt;Dictionary&gt;  map from tag name to accessing selector</body></comment><class><name>XMLSourceFileFormat</name><environment>Kernel</environment><super>Kernel.SourceFileFormat</super><private>false</private><indexed-type>none</indexed-type><inst-vars>state docName cachedFile cachedParser </inst-vars><class-inst-vars></class-inst-vars><imports>			private XML.*			</imports><category>Kernel-Support</category><attributes><package>XML-source</package></attributes></class><comment><class-id>Kernel.XMLSourceFileFormat</class-id><body>This class is used to translate abstract system modifications (such as "remove a class", "add a NameSpace", et al) into a recognized XML syntax. It is also used when reading from files that have this recognized syntax, to implement what is commonly known as a "file-in" operation.Instance Variables:state	&lt;#open | #closed | #writing | #fragment&gt;	Used to guarantee that the correct header and trailer are added to the file.docName	&lt;String&gt;	Name of the XML document element, which is the top-level element in the XML file. For Smalltalk source, this should always be 'st-source'.</body></comment><shared-variable><name>SaveEmphasis</name><environment>Kernel.XMLSourceFileFormat</environment><private>false</private><constant>false</constant><category>policy</category><initializer> false </initializer><attributes><package>XML-source</package></attributes></shared-variable><methods><class-id>XML.SourceScannerNodeBuilder</class-id> <category>initialize</category><body package="XML-source">initialize	super initialize.	selectors := IdentityDictionary new.	positions := IdentityDictionary new.</body></methods><methods><class-id>XML.SourceScannerNodeBuilder</class-id> <category>accessing</category><body package="XML-source">currentFile	^currentFile</body><body package="XML-source">forgetPosition: elm	positions removeKey: elm ifAbsent: []</body><body package="XML-source">positionAt: elm	^positions at: elm</body><body package="XML-source">positionAt: elm put: p	positions at: elm put: p</body></methods><methods><class-id>XML.SourceScannerNodeBuilder</class-id> <category>building</category><body package="XML-source">comment: aText	| comment |	comment := Comment new text: aText.	changeBlock value: (OtherChange new text: aText; type: #comment).	^comment</body><body package="XML-source">scanFile: file do: aBlock	changeBlock := aBlock.	XMLParser new		builder: self;		parseElements: file.</body><body package="XML-source">tag: tag attributes: attributes elements: elements position: p stream: stream	| elm |	elm := Element tag: tag attributes: attributes elements: elements.	(tagStack size = 1 or: [(tagStack at: tagStack size-1) tag type = 'st-source'])		ifTrue:			[currentFile := stream stream.			currentPosition := p.			self scan: elm.			elm discard].	(#('body' 'method') includes: tag type) ifTrue: [self positionAt: elm put: p].	^elm</body></methods><methods><class-id>XML.SourceScannerNodeBuilder</class-id> <category>scanning</category><body package="XML-source">scan: element	| name |	name := self selectorFor: element tag.	(self respondsTo: name)		ifTrue: [[self perform: name with: element]				on: Error				do: [:x |					Transcript cr; show: x errorString.					x return: (self scan_unknown: element)]]		ifFalse: [self scan_unknown: element]</body><body package="XML-source">scan_class: anElement	| parameters superStringTheory attr |	"N.B. Must create otherParameters in same order as keywords in class def."	parameters := OrderedCollection new.	superStringTheory := self getString: 'super' from: anElement default: ''.	parameters addLast:			#superclass:			-&gt; (superStringTheory = 'nil' ifFalse:					[(BindingReference pathString: (self getString: 'super' from: anElement default: '')) makeUnambiguous]).	parameters addLast:			#indexedType:			-&gt; (self getSymbol: 'indexed-type' from: anElement default: #none).	parameters addLast:			#private:			-&gt; (self getBoolean: 'private' from: anElement default: 'false').	parameters addLast:			#instanceVariableNames:			-&gt; (self getString: 'inst-vars' from: anElement default: '').	parameters addLast:			#classInstanceVariableNames:			-&gt; (self getString: 'class-inst-vars' from: anElement default: '').	parameters addLast:			#imports:			-&gt; (self getString: 'imports' from: anElement default: '').	parameters addLast:			#category:			-&gt; (self getString: 'category' from: anElement default: NameSpaceOrganizer defaultProtocol asString).	attr := self getAttributesList: 'attributes' from: anElement.	attr isEmpty ifFalse: [parameters addLast: #attributes: -&gt; attr].	self doChange: ((ClassDefinitionChange new)		objectType: #class;		className: (self getString: 'name' from: anElement default: '');		nameSpaceName: (self getString: 'environment' from: anElement default: #Smalltalk) asQualifiedReference makeUnambiguous asString asSymbol			otherParameters: parameters)</body><body package="XML-source">scan_comment: anElement		| class changeType |	class := self 		getGlobalIdAny: #('class-id' 'name-space-id' 'object-id') 		from: anElement 		do: [:type | changeType := type].	self doChange:		((ClassCommentChange new)			className: class;			objectType: changeType)</body><body package="XML-source">scan_copyright: anElement	self doChange: (OtherChange new type: #copyright)</body><body package="XML-source">scan_documentation: anElement 	self scan_comment: anElement</body><body package="XML-source">scan_do_it: anElement	self doChange: OtherChange new</body><body package="XML-source">scan_initialize: anElement 	| class tp |	class := self				getGlobalIdAny: #('class-id' 'name-space-id' 'object-id' 'variable-id')				from: anElement				do: [:type | tp := type].	self doChange: ((ClassOtherChange new)				className: class;				type: #initialize;				objectType: tp)</body><body package="XML-source">scan_methods: anElement	| class protocol bodies classObject selector attributes savedCurrentPosition |	class := self getGlobalId: 'class-id' from: anElement.	classObject := (class includes: Character space)			ifTrue: [((class copyUpTo: Character space)					asQualifiedReference valueOrDo: []) class]			ifFalse: [class asQualifiedReference valueOrDo: []].	classObject isBehavior ifFalse: [classObject := Object].	protocol := self getSymbol: 'category' from: anElement default: ClassOrganizer defaultProtocol.	bodies := anElement elements select: [:e | e isElement and: [#('body' 'method') includes: e tag type]].	savedCurrentPosition := currentPosition.	bodies do: [:elm | | e2 |		attributes := Dictionary new.		e2 := elm anyElementNamed: 'body'.		e2 attributes do: [:attr |			attributes at: attr tag type asSymbol put: attr value].		selector := attributes at: #selector ifAbsent: [].		selector == nil			ifTrue: [selector := classObject parserClass new parseSelector: e2 characterData]			ifFalse: [selector := selector asSymbol].		currentPosition := self positionAt: elm.		self doChange: (MethodDefinitionChange new						className: class;						selector: selector;						category: protocol;						attributes: attributes;						yourself).		self forgetPosition: elm; forgetPosition: e2].	currentPosition := savedCurrentPosition</body><body package="XML-source">scan_name_space: anElement	| name env private category imports parameters attr |	"N.B. Must create otherParameters in same order as keywords in class def."	name := self getSymbol: 'name' from: anElement.	env := self getGlobalId: 'environment' from: anElement.	env := env asQualifiedReference makeUnambiguous asString.	private := self getBoolean: 'private' from: anElement default: 'false'.	imports := self getString: 'imports' from: anElement default: ''.	category := self getString: 'category' from: anElement default: NameSpaceOrganizer defaultProtocol asString.	(parameters := OrderedCollection new)		addLast: #private: -&gt; private;		addLast: #imports: -&gt; imports;		addLast: #category: -&gt; category.	attr := self getAttributesList: 'attributes' from: anElement.	attr isEmpty ifFalse: [parameters addLast: #attributes: -&gt; attr].	self doChange: ((ClassDefinitionChange new)		objectType: #nameSpace;		className: name;		nameSpaceName: env asSymbol otherParameters: parameters)</body><body package="XML-source">scan_new_page: anElement</body><body package="XML-source">scan_relocate: anElement	| class newParent tp change |	class := self getGlobalIdAny: #('class-id' 'name-space-id' 'object-id' 'variable-id') from: anElement do: [:type | tp := type].	newParent := (self getGlobalId: 'environment' from: anElement).	change := OtherChange new.	change text: ('#{&lt;1s&gt;} relocateTo: &lt;2s&gt;' expandMacrosWith: class with: newParent).	changeBlock value: change</body><body package="XML-source">scan_remove: anElement 	| class tp |	class := self				getGlobalIdAny: #('class-id' 'name-space-id' 'object-id' 'variable-id')				from: anElement				do: [:type | tp := type].	self doChange: ((ClassOtherChange new)				className: class;				type: #remove;				objectType: tp)</body><body package="XML-source">scan_remove_selector: anElement	| class selector |	class := self getGlobalId: 'class-id' from: anElement.	selector := (anElement elementNamed: 'selector') elements first text.	self doChange: (MethodOtherChange new					className: class; selector: selector; type: #remove)</body><body package="XML-source">scan_rename: anElement 	| class newName tp |	class := self				getGlobalIdAny: #('class-id' 'name-space-id' 'object-id' 'variable-id')				from: anElement				do: [:type | tp := type].	newName := self getSymbol: 'name' from: anElement.	self doChange: ((ClassRenameChange new)				className: newName;				oldClassName: class;				objectType: tp)</body><body package="XML-source">scan_reorganize: anElement 	| class data tp |	class := self				getGlobalIdAny: #('class-id' 'name-space-id')				from: anElement				do: [:type | tp := type].	data := self				getString: 'organization'				from: anElement				default: [''].	self doChange: ((ClassOtherChange new)				className: class;				type: #reorganize;				objectType: tp;				otherData: data;				yourself)</body><body package="XML-source">scan_reorganize_data: anElement 	| class data tp |	class := self				getGlobalIdAny: #('class-id' 'name-space-id')				from: anElement				do: [:type | tp := type].	data := self				getString: 'organization'				from: anElement				default: [''].	self doChange: ((ClassOtherChange new)				className: class;				type: #reorganize;				otherData: data;				objectType: tp;				yourself)</body><body package="XML-source">scan_shared_variable: anElement	| name env private category constant initializer parameters attr |	"N.B. Must create otherParameters in same order as keywords in class def."	name := self getSymbol: 'name' from: anElement.	env := self getGlobalId: 'environment' from: anElement.	env := env asQualifiedReference makeUnambiguous asString.	private := self getBoolean: 'private' from: anElement default: 'false'.	constant := self getBoolean: 'constant' from: anElement default: 'false'.	category := self getString: 'category' from: anElement default: NameSpaceOrganizer defaultProtocol asString.	initializer := self getString: 'initializer' from: anElement default: nil.	(parameters := OrderedCollection new)		addLast: #private: -&gt; private;		addLast: #constant: -&gt; constant;		addLast: #category: -&gt; category;		addLast: #initializer: -&gt; initializer.	attr := self getAttributesList: 'attributes' from: anElement.	attr isEmpty ifFalse: [parameters addLast: #attributes: -&gt; attr].	self doChange: ((ClassDefinitionChange new)		objectType: #variable;		className: name;		nameSpaceName: env asSymbol otherParameters: parameters)</body><body package="XML-source">scan_static: anElement	"Backward compatibility."	^self scan_shared_variable: anElement</body><body package="XML-source">scan_st_source: anElement	"Do nothing"	^self</body><body package="XML-source">scan_time_stamp: anElement	self doChange: (OtherChange new type: #timeStamp)</body><body package="XML-source">scan_unknown: anElement	self doChange: (UnknownChange new type: anElement tag type asSymbol)</body></methods><methods><class-id>XML.SourceScannerNodeBuilder</class-id> <category>private</category><body package="XML-source">decodeLiteral: node	"Over time, we may want to accomodate more complex	annotations for a class."	| c type |	(node elements isEmpty or: [node elements contains: [:e | e isElement]])		ifTrue:			[c := node elements select: [:i | i isElement].			^c collect: [:i | self decodeLiteral: i]].	type := node valueOfAttribute: 'type' ifAbsent: [].	type = 'sym' ifTrue: [^node characterData asSymbol].	type = 'eval' ifTrue: [^Object readFrom: node characterData readStream].	^node characterData</body><body package="XML-source">doChange: aChange	aChange file == nil		ifTrue: [aChange file: currentFile position: currentPosition].	changeBlock value: aChange</body><body package="XML-source">elementDataFor: element	| type |	type := element tag type.	(#('beVirtual' 'optimizationLevel') includes: type)		ifFalse: [^element characterData]		ifTrue: 			[type = 'beVirtual' ifTrue: [^Boolean fromString: element elements first text].			type = 'optimizationLevel' ifTrue: [^element characterData asSymbol]]</body><body package="XML-source">getAttributesList: tag from: element	| list newList |	list := element elementsNamed: tag.	newList := OrderedCollection new.	list do: [:node |		self listFrom: node to: newList].	^newList asArray</body><body package="XML-source">getGlobalId: tag from: element	| list item |	list := element elementsNamed: tag.	item := list size = 1		ifTrue: [list first characterData]		ifFalse: [self error: ((#elementNotUnique1 &lt;&lt; #xml &gt;&gt; 'Could not find unique "&lt;1s&gt;".') expandMacrosWith: tag)].	^item</body><body package="XML-source">getGlobalIdAny: possibleTags from: element do: aBlock	| list item name |	list := OrderedCollection new.	possibleTags do: [:tag | list addAll: (element elementsNamed: tag)].	item := list size = 1		ifTrue: [list first characterData]		ifFalse: [self error: ((#elementNotUnique2 &lt;&lt; #xml &gt;&gt; 'Could not find unique &lt;1p&gt;.') expandMacrosWith: possibleTags)].	name := #('name-space-id' 'class-id' 'object-id' 'variable-id') indexOf: list first tag type.	name := #(#nameSpace #class #object #variable) at: name.	aBlock value: name.	^item</body><body package="XML-source">getString: tag from: element default: defaultValue	| list item |	list := element elementsNamed: tag.	item := list size = 1		ifTrue: [list first characterData]		ifFalse: [list size = 0			ifTrue: [defaultValue]			ifFalse: [self error: ((#elementNotUnique1 &lt;&lt; #xml &gt;&gt; 'Could not find unique "&lt;1s&gt;".') expandMacrosWith: tag)]].	^item</body><body package="XML-source">getSymbol: tag from: element	| list item |	list := element elementsNamed: tag.	item := list size = 1		ifTrue: [list first characterData]		ifFalse: [self error: ((#elementNotUnique1 &lt;&lt; #xml &gt;&gt; 'Could not find unique "&lt;1s&gt;".') expandMacrosWith: tag)].	^item asSymbol</body><body package="XML-source">getSymbol: tag from: element default: defaultValue	| list item |	list := element elementsNamed: tag.	item := list size = 1		ifTrue: [list first characterData]		ifFalse: [list size = 0			ifTrue: [defaultValue]			ifFalse: [self error: ((#elementNotUnique1 &lt;&lt; #xml &gt;&gt; 'Could not find unique "&lt;1s&gt;".') expandMacrosWith: tag)]].	^item asSymbol</body><body package="XML-source">getValue: tag from: element default: defaultValue	| item |	item := self getString: tag from: element default: defaultValue.	^Object readFromString: item.</body><body package="XML-source">listFrom: node to: list	"Over time, we may want to accomodate more complex	annotations for a class."	| selectedElements |	node elements do: 		[:each |		each isText ifFalse: 			[(each elements isEmpty or: [each elements contains: [:eachElement | eachElement isElement]])				ifTrue: 					[selectedElements := each elements select: [:eachElement | eachElement isElement].					list add: (Array 						with: each tag type asSymbol 						with: (selectedElements collect: [:eachElement | eachElement characterData]))]				ifFalse: [list add: (Array with: each tag type asSymbol with: (self elementDataFor: each))]]]</body><body package="XML-source">selectorFor: aTag	^selectors at: aTag ifAbsentPut:			[| t |			t := aTag type copy replaceAll: $: with: $_.			t replaceAll: $. with: $_.			t replaceAll: $- with: $_.			('scan_', t, ':') asSymbol]</body></methods><methods><class-id>XML.SourceScannerNodeBuilder</class-id> <category>scanning-code components</category><body package="XML-source">scan_component_created: anElement 	self doChange: 		( ComponentCreatedChange new			componentName: ( self getString: 'name' from: anElement default: nil );			componentType: ( self getSymbol: 'type' from: anElement );			yourself 		  )</body><body package="XML-source">scan_component_definition_change: anElement 	self doChange: 		( ComponentDefinitionChange new			componentName: ( self getString: 'name' from: anElement default: nil );			componentType: ( self getSymbol: 'type' from: anElement default: '' );			definitionName:  ( self getString: 'definitionName' from: anElement default: '' );			definitionChange: ( self getSymbol: 'definitionChange' from: anElement );			yourself 		  )</body><body package="XML-source">scan_component_property: anElement 	self doChange: 		( PropertyChange new			componentName: ( self getString: 'name' from: anElement default: nil );			componentType: ( self getSymbol: 'type' from: anElement );			property: ( self getSymbol: 'property' from: anElement );			value: ( self getValue: 'value' from: anElement default: nil );			yourself 		  )</body><body package="XML-source">scan_component_rename: anElement 	self doChange: 		( ComponentRenamedChange new			componentName: ( self getString: 'newName' from: anElement default: nil );			componentType: ( self getSymbol: 'type' from: anElement );			oldName: ( self getString: 'name' from: anElement default: nil );			yourself 		  )</body><body package="XML-source">scan_component_selector_change: anElement 	| selector |	selector := self getString: 'selector' from: anElement default: nil.	selector == nil		ifTrue: [^self scan_component_static_change: anElement].	self doChange: 		( ComponentSelectorChange new			componentName: ( self getString: 'name' from: anElement default: nil );			componentType: ( self getSymbol: 'type' from: anElement default: '' );			definitionName:  ( self getString: 'definitionName' from: anElement default: '' );			selector: ( self getSymbol: 'selector' from: anElement );			meta: ( self getBoolean: 'meta' from: anElement default: 'false' );			definitionChange: ( self getSymbol: 'definitionChange' from: anElement );			yourself 		  )</body><body package="XML-source">scan_component_static_change: anElement 	self doChange: 		( ComponentStaticChange new			componentName: ( self getString: 'name' from: anElement default: nil );			componentType: ( self getSymbol: 'type' from: anElement default: '' );			definitionName:  ( self getString: 'definitionName' from: anElement default: '' );			staticKey: ( self getSymbol: 'staticKey' from: anElement );			definitionChange: ( self getSymbol: 'definitionChange' from: anElement );			yourself 		  )</body><body package="XML-source">scan_component_unloaded: anElement 	self doChange: 		( ComponentUnloadedChange new			componentName: ( self getString: 'name' from: anElement default: nil );			componentType: ( self getSymbol: 'type' from: anElement );			yourself 		  )</body><body package="XML-source">scan_parcel_loaded: anElement 	self doChange: 		( ParcelLoadedChange new			componentName: ( self getString: 'name' from: anElement default: nil );			filename: ( self getString: 'filename' from: anElement default: nil );			yourself 		  )</body></methods><methods><class-id>XML.SourceNodeBuilder</class-id> <category>initialize</category><body package="XML-source">initialize	super initialize.	selectors := IdentityDictionary new</body></methods><methods><class-id>XML.SourceNodeBuilder</class-id> <category>building</category><body package="XML-source">comment: aText	^Comment new text: aText; discard</body><body package="XML-source">tag: tag attributes: attributes elements: elements position: p stream: stream	| elm |	elm := Element tag: tag attributes: attributes elements: elements.	(tagStack size = 1 or: [(tagStack at: tagStack size-1) tag type = 'st-source'])		ifTrue:			[self compile: elm.			elm discard].	^elm</body></methods><methods><class-id>XML.SourceNodeBuilder</class-id> <category>compiling</category><body package="XML-source">compile: element	| name |	name := self selectorFor: element tag.	(self respondsTo: name)		ifTrue: [self perform: name with: element]		ifFalse: [Transcript cr; show: ((#ChangeTypeUnknownC1s &lt;&lt; #xml &gt;&gt; 'Change type unknown: &lt;1s&gt;')					expandMacrosWith: element tag asString)]</body><body package="XML-source">compile_class: anElement	| name env superclass private indexed instVars classInstVars imports category annotations |	name := self getSymbol: 'name' from: anElement.	env := self getGlobalId: 'environment' from: anElement.	env == nil ifTrue: [env := #{Smalltalk}].	superclass := self getGlobalId: 'super' from: anElement.	private := self getBoolean: 'private' from: anElement default: 'false'.	indexed := self getSymbol: 'indexed-type' from: anElement default: 'none'.	instVars := self getString: 'inst-vars' from: anElement default: ''.	classInstVars := self getString: 'class-inst-vars' from: anElement default: ''.	imports := self getString: 'imports' from: anElement default: ''.	category := self getString: 'category' from: anElement default: 'As yet unclassified'.	annotations := self getDictionary: 'attributes' from: anElement.	env value defineClass: name		superclass: superclass		indexedType: indexed		private: private		instanceVariableNames: instVars		classInstanceVariableNames: classInstVars		imports: imports		category: category		attributes: annotations</body><body package="XML-source">compile_comment: anElement	| class body |	class := self getGlobal: #('class-id' 'name-space-id' 'object-id') from: anElement.	body := anElement elementNamed: 'body'.	class comment: body characterData</body><body package="XML-source">compile_copyright: anElement	"Do nothing."	^self</body><body package="XML-source">compile_documentation: anElement	self compile_comment: anElement</body><body package="XML-source">compile_do_it: anElement	Compiler evaluate: anElement characterData.</body><body package="XML-source">compile_initialize: anElement	| class |	class := self getGlobal: #('class-id' 'name-space-id' 'object-id' 'variable-id') from: anElement.	class initialize</body><body package="XML-source">compile_methods: anElement		| class protocol bodies |	class := self getGlobal: #('class-id') from: anElement.	protocol := self getSymbol: 'category' from: anElement default: ClassOrganizer defaultProtocol.	bodies := anElement elementsNamed: 'body'.	bodies do:		[:eachElement | 		| attributes |		attributes := Dictionary new.		eachElement attributes do: [:eachAttribute | attributes at: eachAttribute tag type asSymbol put: eachAttribute value].		class 			compile: eachElement characterData 			classified: protocol 			notifying: nil 			attributes: attributes 			environment: (self environmentForClass: class attributes: attributes)]</body><body package="XML-source">compile_name_space: anElement	| name env private category imports annotations |	name := self getSymbol: 'name' from: anElement.	env := self getGlobalId: 'environment' from: anElement.	private := self getBoolean: 'private' from: anElement default: 'false'.	imports := self getString: 'imports' from: anElement default: ''.	category := self getString: 'category' from: anElement default: NameSpaceOrganizer defaultProtocol.	annotations := self getDictionary: 'attributes' from: anElement.	env value defineNameSpace: name		private: private		imports: imports		category: category		attributes: annotations.</body><body package="XML-source">compile_new_page: anElement	"Do nothing."	^self</body><body package="XML-source">compile_relocate: anElement	| class |	class := self getGlobal: #('class-id' 'name-space-id' 'object-id' 'variable-id') from: anElement.	class relocateTo: (self getGlobal: #('environment') from: anElement)</body><body package="XML-source">compile_remove: anElement	| class |	class := self getGlobal: #('class-id' 'name-space-id' 'object-id' 'variable-id') from: anElement.	class removeFromSystem</body><body package="XML-source">compile_remove_selector: anElement	| class selector |	class := self getGlobal: #('class-id') from: anElement.	selector := anElement elementNamed: 'selector'.	class removeSelector: selector characterData asSymbol</body><body package="XML-source">compile_rename: anElement	| class |	class := self getGlobal: #('class-id' 'name-space-id' 'object-id' 'variable-id') from: anElement.	class renameTo: (self getSymbol: 'name' from: anElement)</body><body package="XML-source">compile_reorganize: anElement	| class |	class := self getGlobal: #('class-id' 'name-space-id') from: anElement.	class reorganizeFromString: (self getString: 'organization' from: anElement default: [''])</body><body package="XML-source">compile_reorganize_data: anElement	| class |	class := self getGlobal: #('class-id' 'name-space-id') from: anElement.	class asNameSpace reorganizeFromString: (self getString: 'organization' from: anElement default: [''])</body><body package="XML-source">compile_shared_variable: anElement	| name env private category constant initializer annotations |	name := self getSymbol: 'name' from: anElement.	env := self getGlobalId: 'environment' from: anElement.	env == nil ifTrue: [env := #{Smalltalk}].	private := self getBoolean: 'private' from: anElement default: 'false'.	constant := self getBoolean: 'constant' from: anElement default: 'false'.	category := self getString: 'category' from: anElement default: NameSpaceOrganizer defaultProtocol.	initializer := self getString: 'initializer' from: anElement default: nil.	annotations := self getDictionary: 'attributes' from: anElement.	[env value defineSharedVariable: name		private: private		constant: constant		category: category		initializer: initializer		attributes: annotations]			on: VariableConfirmation			do: 				[:notification | 				Transcript show: (#nASharedVariableNamed1pInClass2p &lt;&lt; #dialogs &gt;&gt; '&lt;n&gt;A Shared variable named &lt;1p&gt; in class &lt;2p&gt; has been loaded.&lt;n&gt;It should be renamed to &lt;3p&gt;'					expandMacrosWith: name asString					with: env value					with: notification parameter).				notification resume: false]</body><body package="XML-source">compile_static: anElement	"Backward compatibility."	^self compile_shared_variable: anElement</body><body package="XML-source">compile_st_source: anElement	"Do nothing"	^self</body><body package="XML-source">compile_time_stamp: anElement	"Do nothing"	^self</body><body package="XML-source">environmentForClass: aClass attributes: aDictionary	"Given the class, and the set of attributes that defines the selector and (if applicable) the package, return the environment in which we expect to compile this, or nil if we should use the default."	| packageName package selector |	packageName := aDictionary at: #package ifAbsent: [^nil].	"If we don't have the selector in the properties, this is technically malformed, but it might happen in hand-written XML source. Or at least it happened once. If it does, just ignore the method."	selector := aDictionary at: #selector ifAbsent: [^nil].	package := Store.Registry packageNamed: packageName.	package isNil ifTrue: [^nil].	^package environmentFor: selector in: aClass.</body></methods><methods><class-id>XML.SourceNodeBuilder</class-id> <category>private</category><body package="XML-source">decodeLiteral: node	"Over time, we may want to accomodate more complex	annotations for a class."	| c type |	(node elements isEmpty or: [node elements contains: [:e | e isElement]])		ifTrue:			[c := node elements select: [:i | i isElement].			^c collect: [:i | self decodeLiteral: i]].	type := node valueOfAttribute: 'type' ifAbsent: [].	type = 'sym' ifTrue: [^node characterData asSymbol].	type = 'eval' ifTrue: [^Object readFrom: node characterData readStream].	^node characterData</body><body package="XML-source">dictionaryFrom: node to: dict	"Over time, we may want to accomodate more complex	annotations for a class."	node elements do: [:elm |		elm isText ifFalse: [			dict at: elm tag type asSymbol put: (self decodeLiteral: elm)]]</body><body package="XML-source">getDictionary: tag from: element	| list dict |	list := element elementsNamed: tag.	dict := Dictionary new.	list do: [:node |		self dictionaryFrom: node to: dict].	^dict</body><body package="XML-source">getGlobal: possibleTags from: element	| list item data |	list := OrderedCollection new.	possibleTags do: [:tag | list addAll: (element elementsNamed: tag)].	list size = 1		ifTrue: [item := list first]		ifFalse: [self error: ((#elementNotUnique2 &lt;&lt; #xml &gt;&gt; 'Could not find unique &lt;1p&gt;.') expandMacrosWith: possibleTags)].	data := item characterData.	^((item tag isLike: 'class-id') and: ['* class' match: data ignoreCase: false])		ifTrue:			[item := data copyFrom: 1 to: data size-6.			item asQualifiedReference value class]		ifFalse: [(item tag isLike: 'variable-id')			ifTrue: [data asQualifiedReference]			ifFalse: [data asQualifiedReference value]]</body><body package="XML-source">getGlobalId: tag from: element	| list item |	list := element elementsNamed: tag.	item := list size = 1		ifTrue: [list first characterData]		ifFalse: [self error: ((#elementNotUnique1 &lt;&lt; #xml &gt;&gt; 'Could not find unique "&lt;1s&gt;".') expandMacrosWith: tag)].	^item isEmpty		ifTrue: [nil]		ifFalse: [item asQualifiedReference]</body><body package="XML-source">getString: tag from: element default: defaultValue	| list item |	list := element elementsNamed: tag.	item := list size = 1		ifTrue: [list first characterData]		ifFalse: [list size = 0			ifTrue: [defaultValue]			ifFalse: [self error: ((#elementNotUnique1 &lt;&lt; #xml &gt;&gt; 'Could not find unique "&lt;1s&gt;".') expandMacrosWith: tag)]].	^item</body><body package="XML-source">getSymbol: tag from: element	| list item |	list := element elementsNamed: tag.	item := list size = 1		ifTrue: [list first characterData]		ifFalse: [self error: ((#elementNotUnique1 &lt;&lt; #xml &gt;&gt; 'Could not find unique "&lt;1s&gt;".') expandMacrosWith: tag)].	^item asSymbol</body><body package="XML-source">getSymbol: tag from: element default: defaultValue	| list item |	list := element elementsNamed: tag.	item := list size = 1		ifTrue: [list first characterData]		ifFalse: [list size = 0			ifTrue: [defaultValue]			ifFalse: [self error: ((#elementNotUnique1 &lt;&lt; #xml &gt;&gt; 'Could not find unique "&lt;1s&gt;".') expandMacrosWith: tag)]].	^item asSymbol</body><body package="XML-source">selectorFor: aTag	^selectors at: aTag ifAbsentPut:			[| t |			t := aTag type copy replaceAll: $: with: $_.			t replaceAll: $. with: $_.			t replaceAll: $- with: $_.			('compile_', t, ':') asSymbol]</body></methods><methods><class-id>XML.SourceNodeBuilder</class-id> <category>compiling-code components</category><body package="XML-source">compile_component_created: anElement	CodeComponent		create: ( self getSymbol: 'type' from: anElement )		named: ( self getString: 'name' from: anElement default: nil )</body><body package="XML-source">compile_component_definition_change: anElement	CodeComponent		type: ( self getSymbol: 'type' from: anElement )		named: ( self getString: 'name' from: anElement default: nil )		objectNamed:  ( self getString: 'definitionName' from: anElement default: '' )		change: ( self getSymbol: 'definitionChange' from: anElement )</body><body package="XML-source">compile_component_property: anElement	CodeComponent		type: ( self getSymbol: 'type' from: anElement )		named: ( self getString: 'name' from: anElement default: nil )		property: ( self getSymbol: 'property' from: anElement )		value:  ( self getString: 'value' from: anElement default: '' )</body><body package="XML-source">compile_component_renamed: anElement	CodeComponent		type: ( self getSymbol: 'type' from: anElement )		renamed: ( self getString: 'name' from: anElement default: nil )		to:  ( self getString: 'newName' from: anElement default: nil )</body><body package="XML-source">compile_component_selector_change: anElement	| selector |	selector := self getString: 'selector' from: anElement default: nil.	selector == nil		ifTrue: [^self compile_component_static_change: anElement].	CodeComponent		type: ( self getSymbol: 'type' from: anElement )		named: ( self getString: 'name' from: anElement default: nil )		classNamed:  ( self getString: 'definitionName' from: anElement default: '' )		meta: ( self getBoolean: 'meta' from: anElement default: 'false' )		selector: ( self getSymbol: 'selector' from: anElement )		change: ( self getSymbol: 'definitionChange' from: anElement )</body><body package="XML-source">compile_component_static_change: anElement	CodeComponent		type: ( self getSymbol: 'type' from: anElement )		named: ( self getString: 'name' from: anElement default: nil )		ownerNamed:  ( self getString: 'definitionName' from: anElement default: '' )		static: ( self getSymbol: 'staticKey' from: anElement )		change: ( self getSymbol: 'definitionChange' from: anElement )</body><body package="XML-source">compile_component_unloaded: anElement	CodeComponent		unload: ( self getSymbol: 'type' from: anElement )		named: ( self getString: 'name' from: anElement default: nil )</body><body package="XML-source">compile_parcel_loaded: anElement	| filename |	( filename := self getString: 'filename' from: anElement default: nil ) == nil		ifTrue: 			[ ^Dialog warn: 				( (#Parcel1sLoadMissingFilename &lt;&lt; #xml &gt;&gt; 'Parcel &lt;1s&gt; load missing filename.')					expandMacrosWith: ( self getString: 'name' from: anElement default: nil ) )			].	Notice 		show: (#LoadingParcelN1S &lt;&lt; #xml &gt;&gt; 'Loading Parcel&lt;n&gt;&lt;1s&gt;' expandMacrosWith: filename asString)		while: 			[Parcel loadParcelFrom: (('*fromComponents:*' match: filename)				ifTrue: [Object readFromString: filename]				ifFalse: [filename asLogicalFileSpecification])]</body><body package="XML-source">compile_parcel_saved: anElement	Parcel 		savedParcel: ( self getString: 'name' from: anElement default: nil )		to: ( self getString: 'filename' from: anElement default: nil )</body></methods><methods><class-id>Kernel.XMLSourceFileFormat</class-id> <category>initialize</category><body package="XML-source">forFragment	state := #fragment.</body><body package="XML-source">initialize	super initialize.	state := #open.	docName := 'st-source'</body></methods><methods><class-id>Kernel.XMLSourceFileFormat</class-id> <category>accessing</category><body package="XML-source">close: output	self checkForClose: output.	output close</body><body package="XML-source">docName	^docName</body><body package="XML-source">docName: aString	docName := aString</body><body package="XML-source">syntax	^#'VW XML'</body></methods><methods><class-id>Kernel.XMLSourceFileFormat</class-id> <category>actions</category><body package="XML-source">addComment: aComment on: aStream	| cmt |	self checkForWrite: aStream.	cmt := aComment.	[(cmt findString: '--' startingAt: 1) = 0]		whileFalse: [cmt := cmt copyReplaceAll: '--' with: '- '].	aStream nextPutAll: '&lt;!-- '; nextPutAll: cmt; nextPutAll: ' --&gt;'.	aStream cr</body><body package="XML-source">closeMethodGroup: aFileStream	aFileStream cr.	self on: aFileStream closeTag: 'methods'</body><body package="XML-source">comment: object value: comment on: aStream for: aSourceFileManager	| filePosition |	self checkForWrite: aStream.	aStream cr; cr.	filePosition := aSourceFileManager getWritePosition: aStream.	self on: aStream tag: 'comment' do:		[:xml :str |		str cr.		xml on: str tag: (self idTagFor: object) value: object fullName.		str cr.		xml putBodyOn: str attributes: nil value: comment.		str cr].	^aSourceFileManager keyForFile: aSourceFileManager target position: filePosition</body><body package="XML-source">copyright: string on: output	self on: output tag: 'copyright' value: string.	output cr</body><body package="XML-source">documentation: object value: comment on: aStream for: aSourceFileManager	| filePosition |	(DocumentationSystem isCommentOnly: comment)		ifTrue: [^self comment: object				value: (DocumentationSystem extractCommentFrom: comment)				on: aStream				for: aSourceFileManager].	self checkForWrite: aStream.	aStream cr; cr.	filePosition := aSourceFileManager getWritePosition: aStream.	self on: aStream tag: 'documentation' do:		[:xml :str |		str cr.		xml on: str tag: (self idTagFor: object) value: object fullName.		str cr.		XMLParser new			validate: false;			handlers: (SAXWriter new output: str);			parse: comment readStream.		str cr].	^aSourceFileManager keyForFile: aSourceFileManager target position: filePosition</body><body package="XML-source">initializeObject: anObject on: aStream	self checkForWrite: aStream.	aStream cr; cr.	self on: aStream tag: 'initialize' do:		[:xml :str |		str cr.		xml on: str tag: (self idTagFor: anObject) value: anObject fullName.		str cr]</body><body package="XML-source">methodBody: src class: class attributes: attributes on: aFileStream for: aSourceFileManager	| filePosition attList selector |	aFileStream cr; cr.	attributes == nil		ifTrue: [class == nil			ifTrue: [attList := #()]			ifFalse:				[selector := [class parserClass new parseSelector: src]						on: Error do: [:x | x return: nil].				attList := self attributesFor: class method: selector]]		ifFalse:			[attList := OrderedCollection new.			attributes keysAndValuesDo: [:key :value |				attList add: (Array with: key with: value)].			attList := attList asArray].	filePosition := aSourceFileManager getWritePosition: aFileStream.	self putBodyOn: aFileStream attributes: attList value: src.	^aSourceFileManager keyForFile: aSourceFileManager target position: filePosition</body><body package="XML-source">methodBody: sourceCode class: aClass selector: aSymbol attributes: aDictionaryOrNil on: aFileStream for: aSourceFileManager		| filePosition attributeList selector |	aFileStream		cr;		cr.	aDictionaryOrNil isNil		ifTrue:			[aClass isNil				ifTrue: [attributeList := #()]				ifFalse:					[selector := aSymbol isNil 						ifTrue: [							[aClass parserClass new parseSelector: sourceCode] 								on: Error 								do: [:exception | exception return: nil]] 						ifFalse: [aSymbol].					attributeList := self attributesFor: aClass method: selector]]		ifFalse:			[attributeList := OrderedCollection new.			aDictionaryOrNil keysAndValuesDo: 				[:key :value | 				attributeList add: (Array with: key with: value)].			attributeList := attributeList asArray].	selector ifNotNil: 		[attributeList := (attributeList select: [:each | each first ~= #selector]) copyWith: (Array with: #selector with: selector)].	attributeList := (attributeList asSortedCollection: [:each :other | each first asString &lt;= other first asString]) asArray.	filePosition := aSourceFileManager getWritePosition: aFileStream.	self putBodyOn: aFileStream attributes: attributeList value: sourceCode.	^aSourceFileManager keyForFile: aSourceFileManager target position: filePosition</body><body package="XML-source">methodSources: methodSources class: class selector: sel attributes: attributes on: aFileStream for: aSourceFileManager	| filePosition attList selector |	aFileStream cr; cr.	attributes == nil		ifTrue: [class == nil			ifTrue: [attList := #()]			ifFalse:				[selector := sel == nil					ifTrue: [[class parserClass new parseSelector: methodSources source]							on: Error do: [:x | x return: nil]]					ifFalse: [sel].				attList := self attributesFor: class method: selector]]		ifFalse:			[attList := OrderedCollection new.			attributes keysAndValuesDo: [:key :value |				attList add: (Array with: key with: value)].			attList := attList asArray].	sel == nil		ifFalse: [attList := (attList select: [:att | att first ~= #selector])				copyWith: (Array with: #selector with: sel)].	attList := (attList asSortedCollection: [:a1 :a2 | a1 first asString &lt;= a2 first asString]) asArray.	filePosition := aSourceFileManager getWritePosition: aFileStream.	methodSources stDocumentation size = 0		ifTrue: [self putBodyOn: aFileStream attributes: attList value: methodSources source]		ifFalse: [self on: aFileStream tag: 'method' do: [:xml :src |				src cr.				xml putBodyOn: src attributes: attList value: methodSources source.				src cr.				XMLParser new					validate: false;					handlers: (SAXWriter new output: src);					parse: methodSources stDocumentation readStream.				src cr]].	^aSourceFileManager keyForFile: aSourceFileManager target position: filePosition</body><body package="XML-source">printCategoryChunk: aString for: aClass on: aFileStream	self checkForWrite: aFileStream.	aFileStream cr; cr.	self on: aFileStream openTag: 'methods'.	aFileStream cr.	self on: aFileStream tag: 'class-id' value: (self classNameFor: aClass).	aString == nil		ifFalse:			[aFileStream space.			self on: aFileStream tag: 'category' value: aString]</body><body package="XML-source">putRawChunk: src on: aFileStream	self checkForWrite: aFileStream.	aFileStream cr; cr.	aFileStream nextPutAll: src</body><body package="XML-source">remove: objName type: type on: aStream	self checkForWrite: aStream.	aStream cr; cr.	self on: aStream tag: 'remove' do:		[:xml :str |		str cr.		xml on: str tag: (self idTagForType: type) value: objName.		str cr]</body><body package="XML-source">removeSelector: sel from: class on: aStream	self checkForWrite: aStream.	aStream cr; cr.	self on: aStream tag: 'remove-selector' do:		[:xml :str |		str cr.		xml on: str tag: (self idTagFor: class) value: class fullName.		str space.		xml on: str tag: 'selector' value: sel.		str cr]</body><body package="XML-source">rename: newName from: oldName type: type on: aStream	| name n1 n2 |	self checkForWrite: aStream.	n1 := self homeAndNameOf: oldName.	n2 := self homeAndNameOf: newName.	n1 first = n2 first		ifFalse:			[name := n2 first = '' ifTrue: ['Smalltalk'] ifFalse: [n2 first].			aStream cr; cr.			self on: aStream tag: 'relocate' do:				[:xml :str |				str cr.				xml on: str tag: (self idTagForType: type) value: oldName.				str cr.				xml on: str tag: 'environment' value: name.				str cr]].	n1 last = n2 last		ifFalse:			[name := n2 first = '' ifTrue: [n1 last] ifFalse: [n2 first, '.', n1 last].			aStream cr; cr.			self on: aStream tag: 'rename' do:				[:xml :str |				str cr.				xml on: str tag: (self idTagForType: type) value: name.				str cr.				xml on: str tag: 'name' value: n2 last.				str cr]]</body><body package="XML-source">reorganize: object on: aStream	self checkForWrite: aStream.	aStream cr; cr.	self on: aStream tag: 'reorganize' do:		[:xml :str |		str cr.		xml on: str tag: (self idTagFor: object) value: object fullName.		str space.		xml on: str tag: 'organization' value: object organization printString.		str cr]</body><body package="XML-source">reorganizeName: objectName type: type organization: orgString on: aStream	"Store a snapshot of the object's organization	on the stream."	| tag |	self checkForWrite: aStream.	aStream cr; cr.	tag := type == #nameSpace ifTrue: ['reorganize-data'] ifFalse: ['reorganize'].	self on: aStream tag: tag do:		[:xml :str |		str cr.		xml on: str tag: (self idTagForType: type) value: objectName.		str space.		xml on: str tag: 'organization' value: orgString.		str cr]</body><body package="XML-source">reorganizeNameSpace: object on: aStream	self checkForWrite: aStream.	aStream cr; cr.	self on: aStream tag: 'reorganize-data' do:		[:xml :str |		str cr.		xml on: str tag: (self idTagFor: object) value: object fullName.		str space.		xml on: str tag: 'organization' value: object organization printString.		str cr]</body><body package="XML-source">storeClassDefinition: aClassDefinitionChange on: aFileStream		self checkForWrite: aFileStream.	aFileStream cr; cr.	aClassDefinitionChange xmlDefinition: self onto: aFileStream</body><body package="XML-source">storeDefinition: anObject on: aStream	| extraAttributes xmlString element attributeElements |	self checkForWrite: aStream.	xmlString := anObject xmlDefinition.	xmlString isEmpty ifTrue: [^self].	aStream cr; cr.	extraAttributes := self attributesFor: anObject.	element := XML.XMLParser new parseElement: xmlString readStream.	element elements: (element elements select: [:each | each isElement]).	extraAttributes isEmpty		ifFalse: 			[attributeElements := element elementsNamed: 'attributes'.			attributeElements size = 0				ifTrue: 					[attributeElements := element class tag: 'attributes'.					element addNode: attributeElements]				ifFalse: [attributeElements := attributeElements first].			extraAttributes do: 				[:each |				| attributeElement |				attributeElement := attributeElements class tag: each first.				attributeElement addNode: (XML.Text text: each last).				attributeElements addNode: attributeElement]].	SmalltalkWorkbench prettyPrint: element on: aStream</body><body package="XML-source">storeExpression: src on: aFileStream	self checkForWrite: aFileStream.	aFileStream cr; cr.	self on: aFileStream tag: 'do-it' value: src.</body><body package="XML-source">storeNotation: src type: type on: aFileStream	"Store a general textual notation on the file."	| map |	map := #(#timeStamp #copyright) indexOf: type.	map := map = 0			ifTrue: [type asString]			ifFalse: [#('time-stamp' 'copyright') at: map].	self checkForWrite: aFileStream.	self on: aFileStream tag: map value: src.	aFileStream cr.</body><body package="XML-source">timeStamp: output	| aStream |	self checkForWrite: output.	aStream := WriteStream on: (String new: 16).	SystemUtils timeStamp: aStream.	self on: output tag: 'time-stamp' value: aStream contents.	output cr</body></methods><methods><class-id>Kernel.XMLSourceFileFormat</class-id> <category>formatting</category><body package="XML-source">addElement: elm toText: textStream	"Add an XML Element to the textStream. This means	modifying the stream's emphasis based on the element's	tag, dumping the contents onto the stream, then resetting	the emphasis. Dumping the contents may invoke other	elements, which will further modify the emphasis."	| save newM |	save := textStream emphasis.	newM := (self inverseMapEmphasis: elm tag type).	save == nil		ifFalse: [save class == Array			ifTrue: [newM := save copyWith: newM]			ifFalse: [newM := Array with: save with: newM]].	textStream emphasis: newM.	elm elements do: [:el2 |		el2 isText			ifTrue: [textStream nextPutAll: el2 text]			ifFalse: [self addElement: el2 toText: textStream]].	textStream emphasis: save</body><body package="XML-source">addTags: open to: all on: str	"Add the 'open' emphasis items to the stack ('all'),	and add start tags to the stream to match the new	emphases."	open do: [:i |		all add: i.		str nextPutAll: '&lt;', (self mapEmphasis: i), '&gt;'.]</body><body package="XML-source">closeTags: close from: all on: str	"Remove the 'close' tags from the stack ('all'),	and generate end tags on the stream. This must	be done carefully, because if we remove items	from the middle of the stack, we have to pop off	any items that are above them on the stack, then	push the popped items back on the stack, generating	end and start tags so that the XML elements we	create are properly nested."	| cl index pop |	cl := all select: [:c | close includes: c].	cl size = close size ifFalse: [self error: (#xmlCloseTagMissing &lt;&lt; #dialogs &gt;&gt; 'Some close tag will not be generated')].	cl size = 0 ifTrue: [^self].	index := all indexOf: cl first.	pop := all removeLast: all size-index+1.	pop reverseDo: [:i |		str nextPutAll: '&lt;/', (self mapEmphasis: i), '&gt;'].	pop := pop reject: [:i | cl includes: i].	self addTags: pop to: all on: str.</body><body package="XML-source">cr: aStream	"Add a line-break marker."	self checkForWrite: aStream.	aStream cr</body><body package="XML-source">inverseMapEmphasis: emphasis	"Map an element tag to the corresponding	text emphasis. This is the inverse of 'mapEmphasis:'.	We also include a map for 'body', which is not an	emphasis tag, but is just the wrapper tag for the	whole text. We assume that this maps to 'no	emphasis'."	"If saving text emphasis in the file has been turned off,	all emphases contained in the file are discarded."	SaveEmphasis == true ifFalse: [^nil].	emphasis = 'body' ifTrue: [^nil].	emphasis = 'SM' ifTrue: [^#small].	emphasis = 'LG' ifTrue: [^#large].	emphasis = 'S' ifTrue: [^#serif].	emphasis = 'SS' ifTrue: [^#sansSerif].	emphasis = 'B' ifTrue: [^#bold].	emphasis = 'I' ifTrue: [^#italic].	emphasis = 'U' ifTrue: [^#underline].	^emphasis asSymbol</body><body package="XML-source">makeArrayFrom: emphasis	"An emphasis may be nil, a Symbol, or an	Array of Symbols--for simplicity, we don't have	anything else. In order to treat these as Arrays,	we map them to an empty Array, an Array of	the single Symbol, or the existing Array."	"If we're not saving emphasis on the file, answering an empty array	here makes all text appear to have a nil emphasis"	SaveEmphasis == true ifFalse: [^#()].	emphasis == nil ifTrue: [^#()].	emphasis class == Array ifTrue: [^emphasis].	^Array with: emphasis</body><body package="XML-source">mapEmphasis: emphasis	"Map emphasis keys to element tags. For emphasis,	we are willing to use very abbreviated tags."	emphasis == #small ifTrue: [^'SM'].	emphasis == #large ifTrue: [^'LG'].	emphasis == #serif ifTrue: [^'S'].	emphasis == #sansSerif ifTrue: [^'SS'].	emphasis == #bold ifTrue: [^'B'].	emphasis == #italic ifTrue: [^'I'].	emphasis == #underline ifTrue: [^'U'].	^emphasis asString</body><body package="XML-source">newPage: output	self on: output tag: 'new-page'</body><body package="XML-source">putBodyOn: aStream attributes: attributes value: aValue	"Put the body of a method or of a class comment	on the stream. This means mapping all text emphases	to XML tags so that they aren't lost."	| emph stack start end oldEmph removed added |	emph := #().	stack := OrderedCollection new.	self on: aStream tag: 'body' attributes: attributes do:		[:ignored :stream |		| oldLineEnd |		oldLineEnd := stream lineEndConvention.		start := 1.		[stream lineEndTransparent.		[start &gt; aValue size] whileFalse:			[end := (aValue runLengthFor: start) + start - 1.			oldEmph := emph.			emph := self makeArrayFrom: (aValue emphasisAt: start).			removed := self subtractEmphasis: emph from: oldEmph.			added := self subtractEmphasis: oldEmph from: emph.			self closeTags: removed from: stack on: stream.			self addTags: added to: stack on: stream.			self on: stream value: (aValue copyFrom: start to: end).			start := end+1]		] ensure: [stream lineEndConvention: oldLineEnd].		self closeTags: stack copy from: stack on: stream].</body><body package="XML-source">putBodyOn: aStream value: aValue	"Put the body of a method or of a class comment	on the stream. This means mapping all text emphases	to XML tags so that they aren't lost."	| emph stack start end oldEmph removed added |	emph := #().	stack := OrderedCollection new.	self on: aStream tag: 'body' do:		[:xml :str |		start := 1.		[start &gt; aValue size] whileFalse:			[end := (aValue runLengthFor: start) + start - 1.			oldEmph := emph.			emph := self makeArrayFrom: (aValue emphasisAt: start).			removed := self subtractEmphasis: emph from: oldEmph.			added := self subtractEmphasis: oldEmph from: emph.			self closeTags: removed from: stack on: str.			self addTags: added to: stack on: str.			self on: str value: (aValue copyFrom: start to: end).			start := end+1].		self closeTags: stack copy from: stack on: str].</body><body package="XML-source">subtractEmphasis: oldEmphasis from: newEmphasis	"When switching from one emphasis to another,	we need to find out what the difference between	the two is, so that we can open or close the right	element tags. This computes that difference."	| t e s |	t := 'a' asText.	t addEmphasis: newEmphasis removeEmphasis: #() allowDuplicates: false. 	t addEmphasis: #() removeEmphasis: oldEmphasis allowDuplicates: false.	e := t emphasisAt: 1.	e == nil ifTrue: [^#()].	e class == Array ifFalse: [e := Array with: e].	s := #(#small #large #serif #sansSerif #bold #italic #underline) asSet.	^e select: [:emp | s includes: emp]</body></methods><methods><class-id>Kernel.XMLSourceFileFormat</class-id> <category>xml</category><body package="XML-source">on: output closeTag: name	"This is not very safe. It is preferred when possible that you	use the 'tag:' messages, which ensure some level of XML	conformity."	self checkForWrite: output.	output nextPutAll: '&lt;/', name, '&gt;'</body><body package="XML-source">on: output openTag: name	"This is not very safe. It is preferred when possible that you	use the 'tag:' messages, which ensure some level of XML	conformity."	self checkForWrite: output.	output nextPutAll: '&lt;', name, '&gt;'</body><body package="XML-source">on: output openTag: name attributes: array	"This is not very safe. It is preferred when possible that you	use the 'tag:' messages, which ensure some level of XML	conformity."	self checkForWrite: output.	output nextPutAll: '&lt;', name.	array notNil ifTrue:		[array do:			[:attr | | ak av |			ak := attr at: 1.			av := attr at: 2.			output space; nextPutAll: ak, '="'.			Attribute new printCanonical: av on: output.			output nextPut: $"]].	output nextPutAll: '&gt;'.</body><body package="XML-source">on: output tag: name	self checkForWrite: output.	output nextPutAll: '&lt;', name, '/&gt;'</body><body package="XML-source">on: output tag: name attributes: array do: aBlock	self on: output openTag: name attributes: array.	aBlock value: self value: output.	output nextPutAll: '&lt;/', name, '&gt;'.</body><body package="XML-source">on: output tag: name attributes: array value: value	| v |	self on: output openTag: name attributes: array.	v := value == nil ifTrue: [''] ifFalse: [value].	v := v copyReplaceAll: '&amp;' with: '&amp;amp;'.	v := v copyReplaceAll: '&lt;' with: '&amp;lt;'.	v := v copyReplaceAll: '&gt;' with: '&amp;gt;'.	output nextPutAll: v.	output nextPutAll: '&lt;/', name, '&gt;'.</body><body package="XML-source">on: output tag: name do: aBlock	self checkForWrite: output.	output nextPutAll: '&lt;', name, '&gt;'.	aBlock value: self value: output.	output nextPutAll: '&lt;/', name, '&gt;'.</body><body package="XML-source">on: output tag: name encodeLiteral: object	(object isKindOf: Array)		ifTrue: [^self				on: output				tag: name				do: [:xml2 :str2 |					object do: [:s | xml2 on: str2 tag: 'item' encodeLiteral: s] separatedBy: [str2 space]]].	object isSymbol		ifTrue: [^self				on: output				tag: name				attributes: #(#('type' 'sym'))				value: object].	object isString		ifTrue: [^self				on: output				tag: name				value: object].	self		on: output		tag: name		attributes: #(#('type' 'eval'))		value: object storeString</body><body package="XML-source">on: output tag: name value: value	| v |	self checkForWrite: output.	output nextPutAll: '&lt;', name, '&gt;'.	v := value == nil ifTrue: [''] ifFalse: [value].	v := v copyReplaceAll: '&amp;' with: '&amp;amp;'.	v := v copyReplaceAll: '&lt;' with: '&amp;lt;'.	v := v copyReplaceAll: '&gt;' with: '&amp;gt;'.	output nextPutAll: v.	output nextPutAll: '&lt;/', name, '&gt;'.</body><body package="XML-source">on: output value: value	| v |	self checkForWrite: output.	v := value == nil ifTrue: [''] ifFalse: [value].	v := v copyReplaceAll: '&amp;' with: '&amp;amp;'.	v := v copyReplaceAll: '&lt;' with: '&amp;lt;'.	v := v copyReplaceAll: '&gt;' with: '&amp;gt;'.	output nextPutAll: v.</body></methods><methods><class-id>Kernel.XMLSourceFileFormat</class-id> <category>reading</category><body package="XML-source">commentStringAt: anInteger in: aFileStream	"Unlike our cousins, we can answer #emptyComment, which we translate as a there, but empty string vs not there	This keeps us from blowing up on an old style empty stDoc comment"		^[| element textStream count |	aFileStream position: anInteger.	element := XMLParser new parseElement: aFileStream.	textStream := TextStream on: (String new: 128).	count := 0.	(element anyElementsNamed: 'body') do:		[:eachElement | 		count := count + 1.		self addElement: eachElement toText: textStream].	count = 1 ifFalse: [^nil].	textStream contents notEmpty 		ifTrue: [textStream contents] 		ifFalse: [#emptyComment]]			on: XMLSignal			do:				[:exception | 				exception getSignal = BadCharacterSignal ifTrue: 					[exception resume].				(SourceNotAvailable new) parameter:					#SourcePointerBad &lt;&lt; #dialogs &gt;&gt;						'The source was unavailable because the source pointer appears to point to an incorrect position in the file. The file may have been modified after this method was updated.';					raiseSignal.				exception returnWith: nil]</body><body package="XML-source">containingStringAt: position in: file	^[| element |	file position: position.	element := XMLParser new parseElement: file.	element noIndentPrintString]		on: XMLSignal		do: [:x |			x getSignal = BadCharacterSignal				ifTrue: [x resume].			SourceNotAvailable new				parameter: (#SourcePointerBad &lt;&lt; #dialogs &gt;&gt; 'The source was unavailable because the source pointer appears to point to an incorrect position in the file. The file may have been modified after this method was updated.');				raiseSignal.			x returnWith: nil]</body><body package="XML-source">createMarkerString: aString	^'&lt;n&gt;%&lt;do-it%&gt;&lt;1p&gt;%&lt;/do-it%&gt;&lt;n&gt;' expandMacrosWith: aString</body><body package="XML-source">documentationAt: position in: file	| sub s |	sub := [| element |		file position: position.		element := XMLParser new parseElement: file.		(#('documentation') includes: element tag type)			ifTrue: [element children					detect: [:e | e isElement and: [e tag namespace = DocumentationSystem xmlNamespace]]					ifNone: [nil]]			ifFalse: [#notDocumentation]]				on: XMLSignal				do: [:x |					x getSignal = BadCharacterSignal						ifTrue: [x resume].					SourceNotAvailable new						parameter: (#SourcePointerBad &lt;&lt; #dialogs &gt;&gt; 'The source was unavailable because the source pointer appears to point to an incorrect position in the file. The file may have been modified after this method was updated.');						raiseSignal.					x returnWith: nil].	^sub == #notDocumentation		ifTrue: [DocumentationSystem replaceCommentIn: ''				with: (self embeddedStringAt: position in: file)]		ifFalse: [sub == nil			ifTrue: [nil]			ifFalse:				[s := String new writeStream.				sub saxDo: (SAXWriter new output: s).				s contents]]</body><body package="XML-source">embeddedStringAt: position in: file	^[| element textStream count |	file position: position.	element := XMLParser new parseElement: file.	textStream := TextStream on: (String new: 128).	count := 0.	(element anyElementsNamed: 'body') do: [:e |		count := count+1.		self addElement: e toText: textStream].	count = 1 ifFalse: [self error: #NoTextFound &lt;&lt; #dialogs &gt;&gt; 'no text found'].	textStream contents]		on: XMLSignal		do: 			[:exception |			exception getSignal = BadCharacterSignal				ifTrue: [exception resume].			SourceNotAvailable new				parameter: (#SourcePointerBad &lt;&lt; #dialogs &gt;&gt; 'The source was unavailable because the source pointer appears to point to an incorrect position in the file. The file may have been modified after this method was updated.');				raiseSignal.			exception returnWith: nil]</body><body package="XML-source">fileInFrom: aStream	[XMLParser new		validate: false;		builder: SourceNodeBuilder new;		parseElements: aStream]		on: BadCharacterSignal		do: [:x | x resume].</body><body package="XML-source">methodSourceAt: position in: file	| doc s |	^[| element t src |	file position: position.	element := XMLParser new parseElement: file.	element tag type = 'body'		ifTrue:			[t := TextStream on: (String new: 128).			self addElement: element toText: t.			src := MethodSourceCollection source: t contents]		ifFalse: [element tag type = 'method'			ifTrue:				[t := TextStream on: (String new: 128).				self addElement: (element elementNamed: 'body') toText: t.				src := MethodSourceCollection source: t contents.				doc := element children detect: [:e | e isElement and: [e tag namespace = DocumentationSystem xmlNamespace]] ifNone: [].				doc == nil ifFalse:					[s := String new writeStream.					doc saxDo: (SAXWriter new output: s).					src stDocumentation: s contents]]			ifFalse: [XMLSignal raiseSignal]].	src]		on: XMLSignal		do: [:x |			x getSignal = BadCharacterSignal				ifTrue: [x resume].			SourceNotAvailable new				parameter: (#SourcePointerBad &lt;&lt; #dialogs &gt;&gt; 'The source was unavailable because the source pointer appears to point to an incorrect position in the file. The file may have been modified after this method was updated.');				raiseSignal.			x returnWith: nil]</body><body package="XML-source">stringAt: position in: file	^[| element body t |	file position: position.	element := (self parserFor: file) parseElement.	body := element anyElementNamed: 'body'.	body == nil ifTrue: [body := element].	t := TextStream on: (String new: 128).	self addElement: body toText: t.	t contents]		on: XMLSignal		do: [:x |			x getSignal = BadCharacterSignal				ifTrue: [x resume].			SourceNotAvailable new				parameter: (#SourcePointerBad &lt;&lt; #dialogs &gt;&gt; 'The source was unavailable because the source pointer appears to point to an incorrect position in the file. The file may have been modified after this method was updated.');				raiseSignal.			x returnWith: nil]</body></methods><methods><class-id>Kernel.XMLSourceFileFormat</class-id> <category>private</category><body package="XML-source">checkForClose: output	state = #open		ifTrue: [state := #closed].	state = #writing		ifTrue:			[state := #closed.			output cr; cr; nextPutAll: '&lt;/', self docName, '&gt;'; cr].</body><body package="XML-source">checkForWrite: output	state = #open		ifTrue:			[state := #writing.			output nextPutAll: '&lt;?xml version="1.0"?&gt;'; cr; cr.			output nextPutAll: '&lt;', self docName, '&gt;'; cr].	state = #closed		ifTrue:			[self error: (#ThisStreamHasBeenClosed &lt;&lt; #dialogs &gt;&gt; 'This stream has been closed')].</body><body package="XML-source">idTagFor: object	^self idTagForType: object fileOutObjectType</body><body package="XML-source">idTagForType: type	^type = #class		ifTrue: ['class-id']		ifFalse: [type = #nameSpace			ifTrue: ['name-space-id']			ifFalse: [type = #variable				ifTrue: ['variable-id']				ifFalse: ['object-id']]]</body><body package="XML-source">parserFor: file	(cachedParser ~~ nil	and: [cachedFile = file]) ifTrue:		[^cachedParser].	cachedFile := file.	^cachedParser := XMLParser new validate: false; on: cachedFile</body></methods><methods><class-id>Kernel.XMLSourceFileFormat</class-id> <category>code component support</category><body package="XML-source">component: typeSymbol named: name definitionName: aString change: aSymbol on: aStream	"Add the addition/removal of a definition from a CodeComponent event on a stream. "	self checkForWrite: aStream.	aStream cr; cr.	self on: aStream tag: 'component_definition_change' do:		[ :xml :str |		str cr.		xml on: str tag: 'name' value: name.		str space.		xml on: str tag: 'type' value: typeSymbol.		str cr.		xml on: str tag: 'definitionName' value: aString.		str space.		xml on: str tag: 'definitionChange' value: aSymbol.		str cr		]</body><body package="XML-source">component: typeSymbol named: name definitionName: aString meta: isMeta selector: aSelector change: aSymbol on: aStream	"Add the addition/removal of a method from a CodeComponent event on a stream. "	self checkForWrite: aStream.	aStream cr; cr.	self on: aStream tag: 'component_selector_change' do:		[ :xml :str |		str cr.		xml on: str tag: 'name' value: name.		str space.		xml on: str tag: 'type' value: typeSymbol.		str cr.		xml on: str tag: 'definitionName' value: aString.		str space.		xml on: str tag: 'meta' value: isMeta printString.		str space.		xml on: str tag: 'selector' value: aSelector.		str space.		xml on: str tag: 'definitionChange' value: aSymbol.		str cr		]</body><body package="XML-source">component: typeSymbol named: name definitionName: aString static: staticKey change: aSymbol on: aStream	"Add the addition/removal of a static from a CodeComponent event on a stream. "	self checkForWrite: aStream.	aStream cr; cr.	self on: aStream tag: 'component_static_change' do:		[ :xml :str |		str cr.		xml on: str tag: 'name' value: name.		str space.		xml on: str tag: 'type' value: typeSymbol.		str cr.		xml on: str tag: 'definitionName' value: aString.		str space.		xml on: str tag: 'staticKey' value: staticKey.		str space.		xml on: str tag: 'definitionChange' value: aSymbol.		str cr		]</body><body package="XML-source">component: typeSymbol named: name newName: aString on: aStream	"Add the renaming of a CodeComponent event on a stream. "	self checkForWrite: aStream.	aStream cr; cr.	self on: aStream tag: 'component-rename' do:		[ :xml :str |		str cr.		xml on: str tag: 'name' value: name.		str space.		xml on: str tag: 'type' value: typeSymbol.		str cr.		xml on: str tag:  'newName' value: aString.		str cr		]</body><body package="XML-source">component: typeSymbol named: name property: propertySymbol value: valueString on: aStream	self checkForWrite: aStream.	aStream cr; cr.	self on: aStream tag: 'component-property' do:		[ :xml :str |		str cr.		xml on: str tag: 'name' value: name.		str space.		xml on: str tag: 'type' value: typeSymbol.		str cr.		xml on: str tag: 'property' value: propertySymbol.		str space.		xml on: str tag: 'value' value: valueString safeStoreString.		str cr		]</body><body package="XML-source">createdComponent: typeSymbol named: aString on: aStream	"Add the creation of a CodeComponent event on a stream. "	self checkForWrite: aStream.	aStream cr; cr.	self on: aStream tag: 'component-created' do:		[ :xml :str |		str cr.		xml on: str tag: 'name' value: aString.		str space.		xml on: str tag: 'type' value: typeSymbol.		str cr		]</body><body package="XML-source">loadComponent: cName type: typeSymbol version: vString on: aStream	self checkForWrite: aStream.	aStream cr; cr.	self on: aStream tag: 'component-loaded' do:		[ :xml :str |		str cr.		xml on: str tag: 'name' value: cName.		str space.		xml on: str tag: 'type' value: typeSymbol.		str cr.		xml on: str tag: 'version' value: vString.		str cr		]</body><body package="XML-source">loadParcel: name filename: aFilename on: aStream	"Add the loading of a Parcel event on a stream. "	self checkForWrite: aStream.	aStream cr; cr.	self on: aStream tag: 'parcel-loaded' do:		[ :xml :str |		str cr.		xml on: str tag: 'name' value: name.		str space.		xml			on: str			tag: 'filename'			value: (aFilename isLogicalFileSpecification						ifTrue: [aFilename storeString]						ifFalse: [aFilename asString]).		str cr]</body><body package="XML-source">savedParcel: name filename: aFilename on: aStream	"Add the saving of a Parcel event on a stream. "	self checkForWrite: aStream.	aStream cr; cr.	self on: aStream tag: 'parcel-saved' do:		[ :xml :str |		str cr.		xml on: str tag: 'name' value: name.		str space.		xml on: str tag: 'filename' value: aFilename asString.		str cr		]</body><body package="XML-source">unloadComponent: typeSymbol named: name on: aStream	"Add the unloading of a CodeComponent event on a stream. "	self checkForWrite: aStream.	aStream cr; cr.	self on: aStream tag: 'component-unloaded' do:		[ :xml :str |		str cr.		xml on: str tag: 'name' value: name.		str space.		xml on: str tag: 'type' value: typeSymbol.		str cr		]</body></methods><methods><class-id>Kernel.XMLSourceFileFormat class</class-id> <category>utilities</category><body package="XML-source">canFormatStream: aStream	| p |	p := aStream position.	aStream position: 0.	aStream skipSeparators.	^[aStream peekFor: $&lt;] ensure: [aStream position: p]</body></methods><methods><class-id>XML.XMLNodeBuilder</class-id> <category>private</category><body package="XML-source">getBoolean: tag from: element default: defaultValue	| elements item |	elements := element elementsNamed: tag.	item := elements size = 1		ifTrue: [elements first characterData]		ifFalse: 			[elements size = 0				ifTrue: [defaultValue]				ifFalse: [self error: (#elementNotUnique1 &lt;&lt; #xml &gt;&gt; 'Could not find unique "&lt;1s&gt;".' expandMacrosWith: tag)]].	^Boolean fromString: item</body></methods><methods><class-id>Kernel.GeneralBindingReference</class-id> <category>file-in/out</category><body package="XML-source">xmlDefinition	| aStream |	aStream := (String new: 128) writeStream.	self xmlDefinition: XMLSourceFileFormat new forFragment onto: aStream.	^aStream contents</body></methods><methods><class-id>Kernel.NameSpace</class-id> <category>printing</category><body package="XML-source">xmlDefinition: anXMLFormatter onto: aStream	^anXMLFormatter		on: aStream tag: 'name-space' do: [:xml :str | | nm private |			xml on: str cr tag: 'name' value: self name.			self environment == nil				ifTrue:					[nm := ''.					private := false]				ifFalse:					[nm := self environment fullName.					private := (self environment bindingFor: self name) isPrivate].			xml on: str cr tag: 'environment' value: nm.			xml on: str cr tag: 'private' value: private printString.			xml on: str cr tag: 'imports' value: self importString.			xml on: str cr tag: 'category' value: self category.			str cr]</body></methods><methods><class-id>XML.Attribute</class-id> <category>printing</category><body package="XML-source">printNoIndentOn: aStream endSpacing: endSpacingBlock spacing: spacingBlock	aStream nextPutAll: self tag asString, '="'.	self printCanonical: value on: aStream.	aStream nextPutAll: '"'.</body></methods><methods><class-id>Core.Metaclass</class-id> <category>fileIn/Out</category><body package="XML-source">xmlDefinition: anXMLFormatter onto: aStream	^self</body></methods><methods><class-id>XML.Document</class-id> <category>printing</category><body package="XML-source">printNoIndentOn: aStream endSpacing: endSpacingBlock spacing: spacingBlock	nodes do: [:n | n printNoIndentOn: aStream endSpacing: endSpacingBlock spacing: spacingBlock]</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>fileIn/Out</category><body package="XML-source">xmlDefinition: anXMLFormatter onto: aStream	^self subclassResponsibility</body></methods><methods><class-id>Kernel.NameSpace</class-id> <category>definition</category><body package="XML-source">xmlDefinition	"Answer a string that defines the receiver."	| aStream |	aStream := (String new: 128) writeStream.	self xmlDefinition: XMLSourceFileFormat new forFragment onto: aStream.	^aStream contents</body></methods><methods><class-id>XML.PI</class-id> <category>printing</category><body package="XML-source">printNoIndentOn: aStream endSpacing: endSpacingBlock spacing: spacingBlock	aStream nextPutAll: '&lt;?', name, ' ', text, '?&gt;'</body></methods><methods><class-id>Core.Class</class-id> <category>fileIn/Out</category><body package="XML-source">xmlDefinition: anXMLFormatter onto: aStream	| extra |	^anXMLFormatter		on: aStream 		tag: 'class' 		do: 			[:xmlFormatter :stream | 			| superclassName private |			xmlFormatter on: stream cr tag: 'name' value: self name.			xmlFormatter on: stream cr tag: 'environment' value: self environment fullName.			superclassName := self superclass isNil				ifTrue: ['']				ifFalse: [(self isAbsentClass ifTrue: [self absentSuperclass] ifFalse: [self superclass]) fullName].			xmlFormatter on: stream cr tag: 'super' value: superclassName.			private := self environment bindingFor: self name.			private := private isNil ifTrue: [false] ifFalse: [private isPrivate].			xmlFormatter on: stream cr tag: 'private' value: private printString.			xmlFormatter on: stream cr tag: 'indexed-type' value: self behaviorType.			xmlFormatter on: stream cr tag: 'inst-vars' value: self instanceVariablesString.			xmlFormatter on: stream cr tag: 'class-inst-vars' value: self class instanceVariablesString.			xmlFormatter on: stream cr tag: 'imports' value: self asNameSpace importString.			xmlFormatter on: stream cr tag: 'category' value: self category asString.			extra := self extraAttributesForDefinition.			extra isEmpty ifFalse: 				[xmlFormatter on: stream cr tag: 'attributes' do: 					[:innerXMLFormatter :innerStream |					extra do: 						[:each |						(each last isKindOf: Array)							ifTrue: [innerXMLFormatter on: innerStream cr tag: each first do: 								[:extraItemsXMLFormatter :extraItemsStream |								each last do: [:eachItems | extraItemsXMLFormatter on: extraItemsStream tag: 'item' encodeLiteral: eachItems] separatedBy: [extraItemsStream space]]]							ifFalse: [innerXMLFormatter on: innerStream cr tag: each first value: each last displayString]].						stream cr]].			stream cr]</body></methods><methods><class-id>UI.UISettings class</class-id> <category>accessing preferences</category><body package="XML-source">fileOutReset	(self preferenceModelFor: #fileOutTypeEditing)		value: (self preferenceFor: #fileOutType).</body></methods><methods><class-id>XML.Node</class-id> <category>printing</category><body package="XML-source">printNoIndentOn: aStream endSpacing: endSpacingBlock spacing: spacingBlock	"Print myself on the stream with line breaks between adjacent	elements, but no indentation."	self subclassResponsibility</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>printing</category><body package="XML-source">xmlDefinition	"Answer a string that defines the receiver."	| aStream |	aStream := (String new: 128) writeStream.	self xmlDefinition: XMLSourceFileFormat new forFragment onto: aStream.	^aStream contents</body></methods><methods><class-id>XML.Element</class-id> <category>printing</category><body package="XML-source">printNoIndentOn: aStream endSpacing: endSpacingBlock spacing: spacingBlock	| elem |	self saxDo: (SAXWriter new output: aStream)		forBodyDo:			[elem := elements == nil				ifTrue: [#()]				ifFalse: [elements reject: [:e | e isBlankText]].			(elem contains: [:e | e isElement])				ifTrue:					[endSpacingBlock value: self value: elem.					elem do: [:e | e							printNoIndentOn: aStream							endSpacing: endSpacingBlock							spacing: spacingBlock]						separatedBy: [spacingBlock value: self value: elem].					endSpacingBlock value: self value: elem]				ifFalse: [elem do: [:e | e							printNoIndentOn: aStream							endSpacing: endSpacingBlock							spacing: spacingBlock]]]</body></methods><methods><class-id>UI.UISettings class</class-id> <category>accessing preferences</category><body package="XML-source">fileOutAccept	(self preferenceModelFor: #fileOutType)		value: (self preferenceFor: #fileOutTypeEditing).</body></methods><methods><class-id>XML.Comment</class-id> <category>printing</category><body package="XML-source">printNoIndentOn: aStream endSpacing: endSpacingBlock spacing: spacingBlock	^self printOn: aStream</body></methods><methods><class-id>XML.Text</class-id> <category>printing</category><body package="XML-source">printNoIndentOn: aStream endSpacing: endSpacingBlock spacing: spacingBlock	text == nil ifTrue: [^self].	self isStripped		ifFalse: [self printQuoted: text on: aStream.]</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Node</name><environment>XML</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parent flags userData </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Nodes</category><attributes><package>XML</package></attributes></class><class><name>Element</name><environment>XML</environment><super>XML.Node</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tag attributes namespaces elements definition </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Nodes</category><attributes><package>XML</package></attributes></class><class><name>Document</name><environment>XML</environment><super>XML.Node</super><private>false</private><indexed-type>none</indexed-type><inst-vars>root nodes dtd ids </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Nodes</category><attributes><package>XML</package></attributes></class><class><name>Text</name><environment>XML</environment><super>XML.Node</super><private>false</private><indexed-type>none</indexed-type><inst-vars>text stripped </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Nodes</category><attributes><package>XML</package></attributes></class><class><name>Comment</name><environment>XML</environment><super>XML.Node</super><private>false</private><indexed-type>none</indexed-type><inst-vars>text </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Nodes</category><attributes><package>XML</package></attributes></class><class><name>ClassDescription</name><environment>Core</environment><super>Core.Behavior</super><private>false</private><indexed-type>none</indexed-type><inst-vars>instanceVariables organization </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>Metaclass</name><environment>Core</environment><super>Core.ClassDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>thisClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>NameSpace</name><environment>Kernel</environment><super>Kernel.GeneralNameSpace</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parent name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Name Spaces</category><attributes><package>System-Name Spaces</package></attributes></class><class><name>Class</name><environment>Core</environment><super>Core.ClassDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name classPool environment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>PI</name><environment>XML</environment><super>XML.Node</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name text </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Nodes</category><attributes><package>XML</package></attributes></class><class><name>SourceFileFormat</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>objectProperties methodProperties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Support</category><attributes><package>Kernel-Support</package></attributes></class><class><name>Attribute</name><environment>XML</environment><super>XML.Node</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Nodes</category><attributes><package>XML</package></attributes></class><class><name>GeneralBindingReference</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>path cache </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Name Spaces</category><attributes><package>System-Name Spaces</package></attributes></class><class><name>XMLNodeBuilder</name><environment>XML</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tagStack tags </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Parsing</category><attributes><package>XML</package></attributes></class></st-source>