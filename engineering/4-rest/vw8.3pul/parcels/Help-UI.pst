<?xml version="1.0"?><st-source><!-- Name: Help-UINotice: Copyright 2017 Cincom Systems, Inc.  All rights reserved.Comment: This package provides the UI for browsing the Help folder of a VisualWorks installationDbIdentifier: bear73DbTrace: 502947DbUsername: cgundelDbVersion: 8.3 - 6DevelopmentPrerequisites: #(#(#any 'Help-Model' ''))PackageName: Help-UIParcel: #('Help-UI')ParcelName: Help-UIPrerequisiteDescriptions: #(#(#name 'Help-Model' #componentType #package))PrerequisiteParcels: #(#('Help-Model' ''))PrintStringCache: (8.3 - 6,cgundel)Version: 8.3 - 6Date: 3:30:15 PM June 30, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (jun17.5) of June 30, 2017 on June 30, 2017 at 3:30:15 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>DitaDocumentObject</name><environment>Help</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>children name referingDocument ditaObject </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Help-UI</package></attributes></class><comment><class-id>Help.DitaDocumentObject</class-id><body>DitaDocumentObject represent the parts of a document that is created from a DitaMap. Documents are hierarchically created from topicRef and topic objects. Each is represented by a DitaDocumentTopic or DitaDocumentTopicRef object. The root-object is always a DitaDocument.To create a tree of navigable document objects send #navigationChildren. This method will typically return DitaDocumentTopicRefs that can define the name of their referenced DocumentObject. It can also return DitaDocumentTopic objects.The navigationChildren of a DitaDocumentTopicRef are not only the direct children inside the topicRef's document but also the children of the referenced DitaDocumentObject. The implementation allows TopicRefs to refer to Topic objects that contain other Topics or TopicRefs. In the navigation only the outer TopicRef is visible and the children of the Topic. As the Topic is already represented by the TopicRef it's not part of these children.Instance Variables:	children	&lt;OrderedCollection of: DitaDocumentObject&gt;	the children that make up this document's hierarchy	name	&lt;String&gt;					name of the object	referingDocument 	&lt;DitaDocument&gt; 	the document that refers to this document.	ditaObject 	&lt;DitaObject&gt; 				the dita object that is rendered and that can resolve links</body></comment><class><name>DitaDocumentTopicRef</name><environment>Help</environment><super>Help.DitaDocumentObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>referenceDocument </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Help-UI</package></attributes></class><comment><class-id>Help.DitaDocumentTopicRef</class-id><body>DitaDocumentTopicRef is a reference to a topic that is part of a document. Instance Variables:	topicRef			&lt;DitaTopicRef&gt;		the actual topicRef that knows which topic is referenced	referenceDocument	&lt;DitaDocument&gt; 	the document that's referenced by the topicRef</body></comment><class><name>HelpCompilerErrorHandler</name><environment>Help</environment><super>Kernel.SilentCompilerErrorHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>internalErrorHandler </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Help-UI</package></attributes></class><comment><class-id>Help.HelpCompilerErrorHandler</class-id><body>HelpCompilerErrorHandler is a SilentCompilerErrorHandler that can be used by the SourceCodeEditor. It will not react to any found errors in a way that changes the annotations of the source code, because that would break the annotations that are put on the code by the Help-SystemInstance Variables:	internalErrorHandler 	&lt;SourceCodeErrorHandler&gt; 	the error handler that is used to handle certain errors that are worth showing</body></comment><class><name>DitaDocument</name><environment>Help</environment><super>Help.DitaDocumentObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Help-UI</package></attributes></class><comment><class-id>Help.DitaDocument</class-id><body>DitaDocument is a root object in the hierarchy that a DitaDocument represents. Children are either DitaDocumentTopic or DitaDocumentTopicRef objects</body></comment><class><name>DitaAnnotationDecorator</name><environment>Help</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Help-UI</package></attributes></class><comment><class-id>Help.DitaAnnotationDecorator</class-id><body>DitaAnnotationDecorator is used to apply annotations that were made in Dita-XML to source code that is displayed in a SourceCodeEditor.The Dita-XML can have code like: 	Dialog &lt;b&gt;warn:&lt;/b&gt; 'a message'. This boldness information is stored in the Text2.Document's style information as property #tag by the DitaRenderer. After the document was formatted and colored, this information is gone from the SourceCodeEditor's #document. It is still available in the SourceCodeEditor's #model because the #document is just the visible representation, while the #model is the accepted data.The original Text2.Document is tokenized and the annotation-information is extracted using AnnotatedWord objects. For each word of the document an instance of AnnotatedWord is created. Each stores the word and its annotation.AnnotatedWords can then be matched on a ReadStream in the same order they were originally created. This results in AnnotatedWordMatch objects that know where they were matched in the new Text2.Document. These objects can then be used to add additional styling to the new Text2.Document in order to visualize the annotation.</body></comment><class><name>AnnotationWordScanner</name><environment>Help</environment><super>Kernel.Scanner</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Help-UI</package></attributes></class><comment><class-id>Help.AnnotationWordScanner</class-id><body>AnnotationWordScanner is used to tokenize a Text2.Document into its parts. It will correctly skip all separators but also break between numbers and binary operators like 24@44. It will also ignore Quotes and Strings, creating separate tokens for each quote character. Same goes for literals that start with #. That will create a '#' token. The reason behind it is that the Document needs to be broken into its parts on a more or less language aware basis. It is used by the DitaAnnotationDecorator that ensures that decorations in the source code are carried accross formattings. That enables autoformatting of source snippets but preserves annotations that aid the documentation.Usage	AnnotationWordScanner tokenStringsFrom:' This is a "Test" 123abc'</body></comment><class><name>HelpNavigator</name><environment>Help</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>backwardHistory forwardHistory selectedNode rootNode navigableDocuments folder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Help-UI</package></attributes></class><comment><class-id>Help.HelpNavigator</class-id><body>HelpNavigator models the navigation in a DitaDocument hierarchy that was transformed into DitaDocumentNode objects. It supports a history for backward and forward navigation and also supports navigation by href strings to other documents.It operates on a list of DitaDocument objects from which it created a hierarchy of DitaDocumentNode objects.The navigator's rootNode is typically used in a tree. For that it provides #children and #parent methods. The navigator takes care that the navigation by href also results in a selected DitaDocumentNode part of rootNode's hierarchy. Otherwise it is hard to use the navigator as backend to a TreeView where the selection has to be maintained properly.Usage	"create a navigator using:"	HelpNavigator onHelpFolder: 'help' rootMap: 'vwHelpTopics.ditamap'Instance Variables:	backwardHistory	&lt;OrderedCollection of: DitaDocumentNode&gt;	the nodes that can be revisted using the #goBackBy: method.	forwardHistory		&lt;OrderedCollection of: DitaDocumentNode&gt;	the nodes that can be revisted using the #goForwardBy: method. This collection is only filled after #goBackBy: is called	navigableDocuments	&lt;OrderedCollection of: DitaDocument&gt;	the list of documents that can be navigated. 	rootNode			&lt;DitaDocumentNode&gt;	the node of the document that was named on instance creation for providing the rootMap.	selectedNode		&lt;DitaDocumentNode&gt;	the selected node	folder			&lt;DitaFolder&gt; 			the folder whose content is shown. It resolves URLs and provides images.</body></comment><class><name>SourceCodeEvaluator</name><environment>Help</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>doItEnvironment doItReceiver doItExpectPattern doItReceiverClass language formatterClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Help-UI</package></attributes></class><comment><class-id>Help.SourceCodeEvaluator</class-id><body>SourceCodeEvaluator is a configurable object to be used in a SourceCodeEditor to handle code-execution. It provides all the required information needed by the SourceCodeEditor to perform doIts or to color the code.Instance Variables:	doItEnvironment		&lt;Namespace&gt;	the namespace that's used to start looking for class names	doItExpectPattern	&lt;Boolean&gt;	if true the code is a method and not an expression	doItReceiver		&lt;Object&gt;		the object that's receiving messages when &lt;self&gt; is used in a script	doItReceiverClass	&lt;Class&gt;		the class that defines which parser and compiler to use. Can be the class of the doItReceiver but doesn't have to (like when the doItReceiver is nil)	language 			&lt;Symbol&gt; 	typically #smalltalk	formatterClass		&lt;Refactory.Browser.RBFormatter&gt; typically Refactory.Browser.RBFormatter (if the language is #smalltalk)</body></comment><class><name>AnnotatedWordMatch</name><environment>Help</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>annotatedWord position </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Help-UI</package></attributes></class><comment><class-id>Help.AnnotatedWordMatch</class-id><body>AnnotatedWordMatch is used to store the information that an AnnotatedWord was found in another Text2.Document at a specific location. See DitaAnnotationDecorator's comment for more details on the motivation.Instance Variables:	annotatedWord	&lt;AnnotatedWord&gt;	the annotated word that was found	position		&lt;Integer&gt;			the position in a Text2.Document where this annotated word was found.</body></comment><class><name>HelpAutocompleteModel</name><environment>Help</environment><super>UI.DocumentAutocompleteModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>navigator </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Help-UI</package></attributes></class><comment><class-id>Help.HelpAutocompleteModel</class-id><body>HelpAutocompleteModel shows relative to the whole search-field and not relative to the search-text.Instance Variables:	navigator 	&lt;HelpNavigator&gt; 		the navigator will show the selected search result</body></comment><class><name>DitaDocumentViewer</name><environment>Help</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>breadCrump compoundWrapper showSource navigator showHiddenCharacters searchString scrollWrapper showDebugControls compoundCreator resolveFonts </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Help-UI</package></attributes></class><comment><class-id>Help.DitaDocumentViewer</class-id><body>DitaDocumentViewer renders a DitaDocument's dita-object using a CompoundViewDitaRenderer. Rendering happens into multiple DocumentViews so that source editors and help-text viewers exist side-by-side.Instance Variables:	breadCrump		&lt;ValueHolder&gt;	description of breadCrump	compoundCreator	&lt;DocumentCompoundCreator&gt; 	the object that creates the DocumentViews that are used to display the current document.	compoundWrapper	&lt;VisualPart&gt;				the wrapper of the compound, used by the #windowSpec.	scrollWrapper 		&lt;ScrollWrapper&gt; 			the scrollWrapper of the compound. Used to reset the scroll position on rendering	navigator			&lt;HelpNavigator&gt;			the navigator that knows what object to display. 											I register as dependent to be notified of selection changes	searchString 			&lt;ValueModel&gt; 			holds the current search string	showDebugControls 	&lt;Boolean&gt; 			if true, the developer tools to show the source or hidden characters are shown. Defaults to false	showHiddenCharacters	&lt;ValueModel&gt;			if true, hidden characters like linebreaks are shown	showSource		&lt;ValueModel&gt;				if true the xml-source is shown	resolveFonts 		&lt;ValueModel&gt; 				if true the text will have tooltips showing the font it uses</body></comment><class><name>DitaChunk</name><environment>Help</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>ditaObject document builder contentStack splitByTopic selectWholeBranch </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Help-UI</package></attributes></class><comment><class-id>Help.DitaChunk</class-id><body>DitaChunk represents a Chunk that contains a certain part of a dita map. It is used internally by the DitaDocumentBuilder to handle the #chunk attributes of the DitaObjects properly.Instance Variables:	builder		&lt;DitaDocumentBuilder&gt;		the builder that's used to create new chunks	document		&lt;DitaDocument&gt;			the document that represents the content of this chunk	contentStack	&lt;(OrderedCollection of: DitaDocumentObject)&gt;	the top object of the stack will receive the next document object	ditaObject		&lt;DitaObject&gt;				the object that defines this chunk. Typically a map or a topicRef	selectWholeBranch	&lt;Boolean&gt;			if true the whole branch is put into the same chunk	splitByTopic	&lt;Boolean&gt;				if true each topic will be put into a new chunk</body></comment><class><name>DitaDocumentNode</name><environment>Help</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>children parent documentObject </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Help-UI</package></attributes></class><comment><class-id>Help.DitaDocumentNode</class-id><body>DitaDocumentNode represents the DitaDocumentObjects in the Help-Browser's tree navigation. It is used and built by the HelpNavigator. The nodes know their tree-information like children and parents, which the DitaDocumentObjects don't know. The parent-information for example is used for breadcrump support.Instance Variables:	children		&lt;Collection of: DitaDocumentNode&gt;	the sub nodes	documentObject	&lt;DitaDocumentObject&gt;	the document object that's represented. It knows the displayString or what to render and also provides the documentObjects that were used to create the sub nodes.	parent		&lt;DitaDocumentNode&gt;	the parent node</body></comment><class><name>HelpAutocomplete</name><environment>Help</environment><super>UI.DocumentAutocomplete</super><private>false</private><indexed-type>none</indexed-type><inst-vars>navigator </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Help-UI</package></attributes></class><comment><class-id>Help.HelpAutocomplete</class-id><body>HelpAutocomplete is an autocomplete used by the DitaBrowser's search field. It'll search in a HelpNavigator and upon selection it'll present the selected DitaDocument.Instance Variables:	navigator	&lt;HelpNavigator&gt;	the navigator that provides the search-space and that handles the navigation upon selection</body></comment><class><name>HelpBrowser</name><environment>Help</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>topicsTree ditaDocumentViewer navigator toolbarHolder searchString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Help-UI</package></attributes></class><comment><class-id>Help.HelpBrowser</class-id><body>HelpBrowser provides a navigation interface and a renderer for DitaDocuments. Its navigation functionality is provided by a HelpNavigator instance. The rendering is performed by a DitaDocumentViewer instance.Instance Variables:	navigator		&lt;HelpNavigator&gt;	the navigator that provides the DitaDocuments and handles the navigation	toolbarHolder	&lt;ValueModel&gt;		holds the toolbar and is refreshed on navigation in order to update the toolbar buttons	ditaDocumentViewer		&lt;DitaDocumentViewer&gt;		renders and shows the selected DitaDocument	topicsTree		&lt;SelectionInTree&gt;	handles the selection in the tree	searchString 	&lt;ValueHolder&gt; 		holds string of the search field</body></comment><class><name>CompoundViewDitaRenderer</name><environment>Help</environment><super>Help.DitaRenderer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>compoundCreator currentCell currentRow columnWidths columnNames </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Help-UI</package></attributes></class><comment><class-id>Help.CompoundViewDitaRenderer</class-id><body>CompoundViewDitaRenderer not only renders on a DocumentCanvas but also manages a DocumentCompoundView to which it adds new DocumentView instances depending on the rendered content. When it creates a new view it also creates a new Document for each view. The reasoning is that table cells are rendered into separate DocumentViews and also that SourceCodeEditors can be used instead of DocumentView instances when code is rendered.The views will not have their content visible after rendering. Each view needs to receive a #basicCancel in order to update their content to their model.Instance Variables:	compoundCreator	&lt;DocumentCompoundCreator&gt;	the creator that can create multiple DocumentView instances in a table-like fashion	currentCell		&lt;DocumentView&gt;				the DocumentView that receives the current Document	currentRow		&lt;CompositePart&gt;				the row to which cells are added	columnWidths		&lt;Array of: Number&gt;				the widths of the columns (between 0..1)	columnNames 		&lt;Dictionary key: String value: Number&gt; 	maps the column names to their index</body></comment><class><name>DocumentCompoundCreator</name><environment>Help</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>composite </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Help-UI</package></attributes></class><comment><class-id>Help.DocumentCompoundCreator</class-id><body>DocumentCompoundCreator creates a CompositePart that handles multiple DocumentView instances that are interconnected in the order that they are added. As a result it appears as if all DocumentViews behave as one single DocumentView in regards to navigation and selection.Instance Variables:	composite	&lt;CompositePart&gt;	the CompositePart that's created. It contains CompositeParts for each row and DocumentViews for each cell.</body></comment><class><name>HelpAutocompleteSearch</name><environment>Help</environment><super>UI.DocumentAutocompleteSearch</super><private>false</private><indexed-type>none</indexed-type><inst-vars>documents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Help-UI</package></attributes></class><comment><class-id>Help.HelpAutocompleteSearch</class-id><body>HelpAutocompleteSearch provides the search space that's searched by the HelpAutocompleteInstance Variables:	documents		&lt;Collection of: DitaDocumentObject&gt;	the documents that are searched</body></comment><class><name>DitaDocumentTopic</name><environment>Help</environment><super>Help.DitaDocumentObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Help-UI</package></attributes></class><comment><class-id>Help.DitaDocumentTopic</class-id><body>DitaDocumentTopic represents the parts of a DitaDocument that are topics.Instance Variables:	topic	&lt;DitaTopic&gt;	the actual topic that contains the content</body></comment><class><name>AnnotatedWord</name><environment>Help</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>annotation word </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Help-UI</package></attributes></class><comment><class-id>Help.AnnotatedWord</class-id><body>AnnotatedWord is used to tokenize words from a Text2.Document and store its annotation information. The word's annotation information is part of the Document's style as a property under the key #tag. See DitaAnnotationDecorator for more information on why this has to be done.Usage	"the following will only create AnnotatedWords with nil annotation because the String lacks the correct style property"	AnnotatedWord annotatedWordsFrom:'1 + 1' asDocument.Instance Variables:	annotation	&lt;Symbol | nil&gt;	the name of the annotation, if available.	word		&lt;String&gt;		the string-representation of this word</body></comment><class><name>DitaDocumentBuilder</name><environment>Help</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>chunks </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Help-UI</package></attributes></class><comment><class-id>Help.DitaDocumentBuilder</class-id><body>DitaDocumentBuilder is used to create DitaDocument objects from DitaObjects based on the #chunk attribute of these objects.The DitaObjects are iterated hierarchically depths-first. DitaChunk objects are created internally. These chunks represent a DitaDocument which contains the DitaDocumentTopic or DitaDocumentTopicRef objects.Usage	"returns an OrderedCollection of DitaDocument objects ordered by creation moment"	Help.DitaDocumentBuilder documentsForMap: aDitaMapInstance Variables:	chunks	&lt;OrderedCollection of: DitaChunk&gt;	the chunks in order of their creation</body></comment><methods><class-id>Help.DitaDocumentObject</class-id> <category>accessing</category><body package="Help-UI">actualDocument	(children size = 1 and: [children first isReferenceOnly])		ifTrue: [^children first actualDocument].	^self</body><body package="Help-UI">addObject: aDocumentObject	children add: aDocumentObject</body><body package="Help-UI">allNavigationChildren	| writeStream |	writeStream := Array new writeStream.	self navigationChildrenOn: writeStream.	^writeStream contents</body><body package="Help-UI">documentObjectForDitaObjectLike: aBlock	children		do: [:each | (each documentObjectForDitaObjectLike: aBlock) ifNotNil: [:res | ^res]].	(aBlock value: ditaObject) ifTrue: [^self].	^nil</body><body package="Help-UI">documentObjectForDitaTopic: anObject	^self documentObjectForDitaObjectLike: [:each | each = anObject]</body><body package="Help-UI">filePath	^ditaObject filePath</body><body package="Help-UI">name	^name</body><body package="Help-UI">navigationChildren	^children select: #isReferenceOnly</body><body package="Help-UI">navigationChildrenOn: aWriteStream	self navigationChildren do: 			[:each |			aWriteStream nextPut: each.			each navigationChildrenOn: aWriteStream]</body><body package="Help-UI">referencingTitle	^referingDocument referencingTitle</body><body package="Help-UI">renderAsTopicOn: aDitaRenderer	ditaObject renderTitleOn: aDitaRenderer</body><body package="Help-UI">representsDocument: aDocumentTopic	^self = aDocumentTopic</body><body package="Help-UI">resolveTopicAtUrl: aURL	^ditaObject resolveUrl: aURL</body><body package="Help-UI">resolveUrl: aURL	^ditaObject resolveObjectAtUrl: aURL</body><body package="Help-UI">suggestToAutocomplete: helpAutocomplete visited: visitedDocuments	(visitedDocuments includes: self) ifTrue: [^self].	helpAutocomplete		suggest: ditaObject title		for: self		as: #title.	visitedDocuments add: self.	children		do: [:each | each suggestToAutocomplete: helpAutocomplete visited: visitedDocuments]</body><body package="Help-UI">xmlSource	^ditaObject xmlSource</body></methods><methods><class-id>Help.DitaDocumentObject</class-id> <category>initialize-release</category><body package="Help-UI">initialize	super initialize.	children := OrderedCollection new</body><body package="Help-UI">named: aString with: aDitaObject	aDitaObject isNil ifTrue: [self halt].	name := aString.	ditaObject := aDitaObject</body></methods><methods><class-id>Help.DitaDocumentObject</class-id> <category>printing</category><body package="Help-UI">debugDisplayString	^self debugString , ' ' , self displayString</body><body package="Help-UI">debugString	^self subclassResponsibility</body><body package="Help-UI">displayString	ditaObject title isEmpty ifTrue:[^name].	^ditaObject title.</body><body package="Help-UI">inspectString	^self debugDisplayString</body><body package="Help-UI">printOn: aStream	super printOn: aStream.	aStream		space;		print: name</body></methods><methods><class-id>Help.DitaDocumentObject</class-id> <category>testing</category><body package="Help-UI">isDocument	^false</body><body package="Help-UI">isReferenceOnly	^children allSatisfy: #isReferenceOnly</body><body package="Help-UI">lastTopic	children reverseDo: [:each | ^each lastTopic].	^self</body><body package="Help-UI">referingDocument: aDocumentTopicRef	referingDocument := aDocumentTopicRef</body></methods><methods><class-id>Help.DitaDocumentObject</class-id> <category>user interface</category><body package="Help-UI">inspectorHierarchies	^Array with: (Tools.Trippy.Hierarchy				id: #documentHierarchy				label: 'Document Hierarchy'				parentBlock: [:each | each instVarNamed: #referingDocument asString]				childrenBlock: #navigationChildren)</body></methods><methods><class-id>Help.DitaDocumentObject class</class-id> <category>instance creation</category><body package="Help-UI">named: aString with: aDitaObject	^self new named: aString with: aDitaObject</body><body package="Help-UI">new	^super new initialize</body></methods><methods><class-id>Help.DitaDocumentTopicRef</class-id> <category>testing</category><body package="Help-UI">hasReferencingTitle	^true</body><body package="Help-UI">isReferenceOnly	^true</body></methods><methods><class-id>Help.DitaDocumentTopicRef</class-id> <category>accessing</category><body package="Help-UI">actualDocument	^self referencedTopicDocument actualDocument</body><body package="Help-UI">documentObjectForDitaObjectLike: aBlock	(aBlock value: ditaObject target) ifTrue: [^self].	(self referencedTopicDocument documentObjectForDitaObjectLike: aBlock) ifNotNil: [:each | ^each].	^super documentObjectForDitaObjectLike: aBlock</body><body package="Help-UI">filePath	^self actualDocument filePath</body><body package="Help-UI">navigationChildren	| myChildren |	myChildren := super navigationChildren.	myChildren isEmpty		ifTrue: [^(self actualDocument ifNotNil: #navigationChildren) ifNil: [#()]].	^myChildren</body><body package="Help-UI">referencedTopicDocument	| aDitaObject |	aDitaObject := ditaObject typeConformTarget.	aDitaObject isTopic ifFalse: [^referenceDocument].	^(referenceDocument documentObjectForDitaTopic: aDitaObject)		ifNil: [referenceDocument]</body><body package="Help-UI">referencingTitle	(referingDocument notNil and: [referingDocument hasReferencingTitle])		ifTrue: [^referingDocument referencingTitle].	^self displayString</body><body package="Help-UI">renderAsTopicOn: aRenderer	| actualDocument |	actualDocument := self actualDocument.	actualDocument isDocument		ifTrue: [ditaObject typeConformTarget renderAsTopicOn: aRenderer]		ifFalse: [actualDocument renderAsTopicOn: aRenderer]</body><body package="Help-UI">renderNormalOn: aRenderer	aRenderer renderTopicRef: ditaObject</body><body package="Help-UI">representsDocument: aDocumentTopic	self referencedTopicDocument = aDocumentTopic ifTrue: [^true].	self actualDocument = aDocumentTopic ifTrue: [^true].	^super representsDocument: aDocumentTopic</body><body package="Help-UI">resolveTopicAtUrl: aUrl	^self actualDocument resolveTopicAtUrl: aUrl</body><body package="Help-UI">resolveUrl: aUrl	^self actualDocument resolveUrl: aUrl</body><body package="Help-UI">suggestToAutocomplete: helpAutocomplete visited: visitedDocuments	(visitedDocuments includes: self) ifTrue: [^self].	visitedDocuments add: self.	super suggestToAutocomplete: helpAutocomplete visited: visitedDocuments.	self actualDocument suggestToAutocomplete: helpAutocomplete		visited: visitedDocuments</body><body package="Help-UI">topic	^ditaObject topic</body><body package="Help-UI">with: aTopicRef referencing: aDitaDocument	ditaObject := aTopicRef.	name := ditaObject topic id.	referenceDocument := aDitaDocument</body><body package="Help-UI">xmlSource	^self actualDocument xmlSource</body></methods><methods><class-id>Help.DitaDocumentTopicRef</class-id> <category>printing</category><body package="Help-UI">debugString	^'R' , (ditaObject typeConformTarget isTopic ifTrue: ['T'] ifFalse: ['M'])</body><body package="Help-UI">displayString	^ditaObject title</body><body package="Help-UI">printOn: aStream	super printOn: aStream.	aStream		space;		print: ditaObject</body></methods><methods><class-id>Help.DitaDocumentTopicRef</class-id> <category>enumerating</category><body package="Help-UI">renderOnRenderer: aDitaRenderer	aDitaRenderer renderTopicRef: ditaObject</body></methods><methods><class-id>Help.DitaDocumentTopicRef class</class-id> <category>instance creation</category><body package="Help-UI">with: aTopicRef referencing: aDitaDocument	^self new with: aTopicRef referencing: aDitaDocument</body></methods><methods><class-id>Help.HelpCompilerErrorHandler</class-id> <category>accessing</category><body package="Help-UI">check: aMethod selector: aSelector</body><body package="Help-UI">initialize: aDocument editor: aSourceCodeEditor selector: aSelector offset: aDecoratingOffset reason: aReason	"no need to initialize something here"	internalErrorHandler := Refactory.Browser.SourceCodeErrorHandler new				initialize: aDocument				editor: aSourceCodeEditor				selector: aSelector				offset: aDecoratingOffset				reason: aReason</body><body package="Help-UI">retry: aBlock	retryBlock := aBlock.	internalErrorHandler retry: aBlock.</body></methods><methods><class-id>Help.HelpCompilerErrorHandler</class-id> <category>error handling</category><body package="Help-UI">error: type with: message at: sourcePosition	internalErrorHandler error: type with: message at: sourcePosition</body><body package="Help-UI">error: type with: message in: node from: codeStream	"the following list of warnings is ignored. It is taken from the warning-section in 	SourceCodeErrorHandler&gt;&gt;error:with:in:from:"	| typesToIgnore |	typesToIgnore := #(#warning #readBeforeWritten #neverRead #neverUsed #notOptimized #noEffect).	(typesToIgnore includes: type) ifTrue: [^self].	internalErrorHandler		error: type		with: message		in: node		from: codeStream</body></methods><methods><class-id>Help.DitaDocument</class-id> <category>testing</category><body package="Help-UI">basicIsEmpty	^children isEmpty</body><body package="Help-UI">hasReferencingTitle	^referingDocument notNil and: [referingDocument hasReferencingTitle]</body><body package="Help-UI">isDocument	^true</body><body package="Help-UI">isEmpty	^(children reject: #isReferenceOnly) isEmpty</body></methods><methods><class-id>Help.DitaDocument</class-id> <category>printing</category><body package="Help-UI">debugString	^'D'</body></methods><methods><class-id>Help.DitaAnnotationDecorator</class-id> <category>instance creation</category><body package="Help-UI">annotate: tag in: aDocument from: start to: stop	| newFont |	^aDocument		replaceBetween: start		and: stop		apply: 			[:style |			| font newStyle |			font := style fontDescription.			newFont := DocumentationStyles fontAt: tag ifAbsent: [font].			"keep the pixelsize and the foreground color because that's defined by the theme"			newFont := newFont copy				pixelSize: font pixelSize;				family: font family;				color: style color;				yourself.			newStyle := style copy.			newStyle fontDescription: newFont.			"add the tag back to the style. That will allow subsequent decorations"			newStyle propertyAt: #tag put: tag.			newStyle intern]</body><body package="Help-UI">decorate: aDocument withAnnotationsFrom: originalDocument	| matches |	matches := self matchAnnotatedWordsIn: originalDocument against: aDocument.	matches do: 			[:each |			each annotation				ifNotNil: 					[:tag |					self						annotate: tag						in: aDocument						from: each start						to: each stop]]</body><body package="Help-UI">matchAnnotatedWordsIn: originalDocument against: aDocument	| match matches readStream originalWords wordStream |	originalWords := AnnotatedWord annotatedWordsFrom: originalDocument.	wordStream := originalWords readStream.	readStream := aDocument readStream.	matches := OrderedCollection new.	[readStream atEnd or: [wordStream atEnd]] whileFalse: 			[match := wordStream next matchOn: readStream.			match notNil ifTrue: [matches add: match] ifFalse: [^#()]].	^matches</body></methods><methods><class-id>Help.DitaAnnotationDecorator class</class-id> <category>instance creation</category><body package="Help-UI">decorate: aDocument parseTree: aParseTree editor: aSourceCodeEditor offset: decoratingOffset reason: aReason	^self decorate: aDocument		withAnnotationsFrom: aSourceCodeEditor model value</body><body package="Help-UI">decorate: aDocument withAnnotationsFrom: originalDocument	^self new decorate: aDocument withAnnotationsFrom: originalDocument</body><body package="Help-UI">isForWorkspace	^false</body></methods><methods><class-id>Help.AnnotationWordScanner</class-id> <category>multi-character scans</category><body package="Help-UI">tokenStringsFrom: aDocument	| tokens end |	self on: aDocument readStream.	tokens := OrderedCollection new.		[token := self scanToken.	token isNil] whileFalse: 				[(#(#leftParenthesis #rightParenthesis #period) includes: tokenType)					ifFalse: 						[end := hereChar = nil									ifTrue: [aDocument size]									ifFalse: [source position - 1].						tokens add: (aDocument copyFrom: mark to: end) trimSeparators]].	^tokens asArray</body><body package="Help-UI">xDoubleQuote	"collect comment"	tokenType := #doubleQuote.	token := $".	hereChar := source next</body><body package="Help-UI">xLitQuote	tokenType := #hash.	token := $#.	hereChar := source next</body><body package="Help-UI">xSingleQuote	tokenType := #singleQuote.	token := $'.	hereChar := source next</body></methods><methods><class-id>Help.AnnotationWordScanner class</class-id> <category>instance creation</category><body package="Help-UI">tokenStringsFrom: aDocument	| scanner |	scanner := self new.	^scanner tokenStringsFrom: aDocument</body></methods><methods><class-id>Help.HelpNavigator</class-id> <category>history</category><body package="Help-UI">backMenu	^self navigationMenuFor: self visibleBackwardHistory		using: [:index | self goBackBy: index]</body><body package="Help-UI">forwardMenu	^self navigationMenuFor: forwardHistory		using: [:index | self goForwardBy: index]</body><body package="Help-UI">goBack	self goBackBy: 1</body><body package="Help-UI">goForward	self goForwardBy: 1</body><body package="Help-UI">navigationMenuFor: history using: aBlock	| menu |	menu := UI.Menu new.	"reverse the history so that the latest item is on top"	history reverse doWithIndex: 			[:each :i |			menu addItem: ((UI.MenuItem labeled: each displayString)						value: [aBlock value: i];						yourself)].	^menu</body><body package="Help-UI">nextBackLabel	^self nextLabelFrom: self visibleBackwardHistory		ifNone: [#GoBackInHistory &lt;&lt; #menus &gt;&gt; 'Back']</body><body package="Help-UI">nextForwardLabel	^self nextLabelFrom: forwardHistory		ifNone: [#GoForwardInHistory &lt;&lt; #menus &gt;&gt; 'Forward']</body><body package="Help-UI">nextLabelFrom: historyCollection ifNone: aBlock	historyCollection isEmpty ifTrue: [^aBlock value].	^historyCollection last displayString</body><body package="Help-UI">visibleBackwardHistory	"the last item in backwardHistory is the current selection. This method is supposed to return the name of the item that's selected when #goBack is fired"	^backwardHistory allButLast: 1</body></methods><methods><class-id>Help.HelpNavigator</class-id> <category>testing</category><body package="Help-UI">canGoBack	^backwardHistory size &gt; 1</body><body package="Help-UI">canGoForward	^forwardHistory notEmpty</body><body package="Help-UI">isForFolder: aFilename rootMap: rootName	^folder isForFolder: aFilename rootMap: rootName</body></methods><methods><class-id>Help.HelpNavigator</class-id> <category>initialize-release</category><body package="Help-UI">onFolder: aFolder	folder := aFolder.	navigableDocuments := DitaDocumentBuilder documentsForMap: aFolder rootMap.	rootNode := DitaDocumentNode hierarchyWithRoot: navigableDocuments first actualDocument.	selectedNode := rootNode.	backwardHistory := OrderedCollection with: selectedNode.	forwardHistory := OrderedCollection new</body><body package="Help-UI">onHelpFolder: aFilename rootMap: rootFile	| aFolder |	aFolder := DitaFolder forPath: aFilename withRoot: rootFile.	self onFolder: aFolder</body></methods><methods><class-id>Help.HelpNavigator</class-id> <category>accessing</category><body package="Help-UI">documentForTopic: aDitaTopic	navigableDocuments		do: [:each | (each documentObjectForDitaTopic: aDitaTopic) ifNotNil: [:child | ^child]].	^self selectedDocument</body><body package="Help-UI">navigationChildForDocument: aDitaDocumentTopic	"this method returns the navigatable object that relates to &lt;nextDocument&gt;.	Each navigatable document will possibly render as another document. Typically the navigatable documents 	are DitaDocumentTopicRef objects while the rendered objects are DitaDocumentTopic objects.	This method returns the topic-ref object that would render the provided topic.		The algorithm first searches under the selected document in case it's a sibling. If nothing is found, search in all documents.	If nothing is found stick to the selected document"	(Array with: selectedNode with: rootNode)		do: [:each | (each childWithDocument: aDitaDocumentTopic) ifNotNil: [:child | ^child]].	^selectedNode</body><body package="Help-UI">rootNode	^rootNode</body><body package="Help-UI">searchableDocuments	^rootNode allChildren collect: #documentObject.</body><body package="Help-UI">selectedNode	^selectedNode</body><body package="Help-UI">selectedNode: aNode	selectedNode = aNode ifTrue: [^self].	selectedNode := aNode.	self changed: #selectedNode</body><body package="Help-UI">selectedPath	^selectedNode fullPath</body></methods><methods><class-id>Help.HelpNavigator</class-id> <category>navigation</category><body package="Help-UI">goBackBy: aNumber	aNumber timesRepeat: [forwardHistory add: backwardHistory removeLast].	self selectedNode: backwardHistory last</body><body package="Help-UI">goForwardBy: aNumber	aNumber timesRepeat: [backwardHistory add: forwardHistory removeLast].	self selectedNode: backwardHistory last</body><body package="Help-UI">navigateTo: aString	| aDitaTopic documentTopic |	aDitaTopic := self selectedDocument resolveUrl: aString asURI.	documentTopic := self documentForTopic: aDitaTopic.	self navigateToDocument: documentTopic</body><body package="Help-UI">navigateToDocument: documentTopic	| node |	node := self navigationChildForDocument: documentTopic.	self navigateToNode: node</body><body package="Help-UI">navigateToNode: aNode	| node |	node := aNode ifNil:[rootNode].	(backwardHistory last ~= node)		ifTrue: 			[backwardHistory add: node.			forwardHistory removeAll].	self selectedNode: node</body><body package="Help-UI">selectedDocument	^selectedNode documentObject</body></methods><methods><class-id>Help.HelpNavigator</class-id> <category>navigating</category><body package="Help-UI">navigateToTopicWithID: topicId	| topic |	topic := rootNode findDocumentForTopicWithId: topicId.	self navigateToDocument: topic</body></methods><methods><class-id>Help.HelpNavigator class</class-id> <category>instance creation</category><body package="Help-UI">new	"Answer a newly created and initialized instance."	^super new initialize</body><body package="Help-UI">onHelpFolder: aFilename rootMap: rootFile	^self new onHelpFolder: aFilename rootMap: rootFile</body></methods><methods><class-id>Help.SourceCodeEvaluator</class-id> <category>accessing</category><body package="Help-UI">doItEnvironment	^doItEnvironment ifNil: [self doItReceiverClass ifNotNil: #environment]</body><body package="Help-UI">doItEnvironment: anEnvironment	doItEnvironment := anEnvironment</body><body package="Help-UI">doItExpectPattern		^doItExpectPattern ifNil: [false]</body><body package="Help-UI">doItExpectPattern: aBoolean		doItExpectPattern := aBoolean</body><body package="Help-UI">doItReceiver		^doItReceiver</body><body package="Help-UI">doItReceiver: anObject	doItReceiver := anObject</body><body package="Help-UI">doItReceiverClass	^doItReceiverClass ifNil:[doItReceiver ifNotNil: #class].</body><body package="Help-UI">doItReceiverClass: aClass	doItReceiverClass := aClass</body><body package="Help-UI">formatterClass	^formatterClass</body><body package="Help-UI">language	^language</body></methods><methods><class-id>Help.SourceCodeEvaluator</class-id> <category>testing</category><body package="Help-UI">doItReceiverAllowed		^doItReceiver notNil</body></methods><methods><class-id>Help.SourceCodeEvaluator</class-id> <category>initialize-release</category><body package="Help-UI">compile: aString	| compiledMethod |	compiledMethod := self compilerClass new		compile: aString readStream		in: self doItContext		allowReceiver: self doItReceiverAllowed		class: self doItReceiverClass		environment: self doItEnvironment		noPattern: doItExpectPattern not		notifying: nil		ifFail: [nil]		handler: Kernel.SilentCompilerErrorHandler new.	"set the sourcePointer, otherwise the debugger will work on decompiled code"	compiledMethod sourcePointer: aString.	^compiledMethod</body><body package="Help-UI">compilerClass	^self doItReceiverClass compilerClass</body><body package="Help-UI">doItContext	^nil</body><body package="Help-UI">forSmalltalkExpressions	self forSmalltalkMethods.	doItExpectPattern := false</body><body package="Help-UI">forSmalltalkMethods	language := #smalltalk.	formatterClass := Refactory.Browser.RBFormatter.	doItReceiverClass := Object.	doItExpectPattern := true</body></methods><methods><class-id>Help.SourceCodeEvaluator</class-id> <category>doIt</category><body package="Help-UI">debug: aString	| aCompiledMethod |	aCompiledMethod := self compile: aString.	aCompiledMethod debugWithReceiver: self doItReceiver		inContext: self doItContext</body><body package="Help-UI">inspect: aString	| method |	method := self compile: aString.	(self doItReceiver performMethod: method) inspect</body></methods><methods><class-id>Help.SourceCodeEvaluator class</class-id> <category>instance creation</category><body package="Help-UI">new	"Answer a newly created and initialized instance."	^super new initialize</body><body package="Help-UI">withReceiver: anObject	^(self new)		doItReceiver: anObject;		yourself</body><body package="Help-UI">withReceiverClass: anObject	^(self new)		doItReceiverClass: anObject;		yourself</body></methods><methods><class-id>Help.AnnotatedWordMatch</class-id> <category>accessing</category><body package="Help-UI">annotation	^annotatedWord annotation</body><body package="Help-UI">start	^position</body><body package="Help-UI">stop	^position + annotatedWord word size</body></methods><methods><class-id>Help.AnnotatedWordMatch</class-id> <category>printing</category><body package="Help-UI">printOn: aStream	super printOn: aStream.	aStream		space;		nextPut: $@;		print: position;		nextPutAll: ' (';		print: annotatedWord;		nextPut: $)</body></methods><methods><class-id>Help.AnnotatedWordMatch</class-id> <category>initialize-release</category><body package="Help-UI">withMatch: anAnnotatedWord at: aPosition	annotatedWord := anAnnotatedWord.	position := aPosition</body></methods><methods><class-id>Help.AnnotatedWordMatch class</class-id> <category>instance creation</category><body package="Help-UI">withMatch: annotatedWord at: aPosition	^self new withMatch: annotatedWord at: aPosition</body></methods><methods><class-id>Help.HelpAutocompleteModel</class-id> <category>accessing</category><body package="Help-UI">inputFieldWrapper	| borderWrapper |	borderWrapper := view				findParent: [:each | each isKindOf: InputFieldWrapper].	borderWrapper isNil ifTrue: [borderWrapper := view].	^borderWrapper</body><body package="Help-UI">navigator: aNavigator	navigator := aNavigator</body><body package="Help-UI">presentForSource: source matches: indices inScope: scope	| matchingIndices range visibleRange fullString group ranges characterPadding |	fullString := source asString.	group := WordGroupMatch withWords: indices.	range := group bestRange.	characterPadding := 20.	visibleRange := (range first - characterPadding max: 1)				to: (range last + characterPadding min: source asString size).	visibleRange size &gt; 50		ifTrue: [visibleRange := visibleRange first to: visibleRange first + 50].	matchingIndices := OrderedCollection new.	indices do: 			[:each |			ranges := each ranges.			matchingIndices addAll: (visibleRange						select: [:i | ranges anySatisfy: [:r | r includes: i]])].	^Array with: scope		with: (Array				with: (fullString copyFrom: visibleRange first to: visibleRange last)				with: (matchingIndices collect: [:each | each - visibleRange first + 1])				with: #(#default))</body></methods><methods><class-id>Help.HelpAutocompleteModel</class-id> <category>initialize-release</category><body package="Help-UI">extent	^view topComponent width @ 400</body><body package="Help-UI">scopeWidth	| borderWrapper |	borderWrapper := self inputFieldWrapper.	^borderWrapper bounds left</body></methods><methods><class-id>Help.HelpAutocompleteModel</class-id> <category>api</category><body package="Help-UI">position	"position the auto complete window under the border wrapper instead of the view itself so that it doesn't overlay the lower border.	The position and extent are so that the window covers the whole input editor and not just the word-bounds because it's for a single 	search field, not a multiline SourceCodeEditor"	| wrapper |	wrapper := self inputFieldWrapper.	^view topComponent globalOrigin + (0				@ (wrapper localPointToGlobal: 0 @ wrapper bounds bottom) y)</body></methods><methods><class-id>Help.DitaDocumentViewer</class-id> <category>accessing</category><body package="Help-UI">navigateTo: aLink	navigator navigateTo: aLink</body><body package="Help-UI">showDebugControls: anObject	showDebugControls := anObject</body></methods><methods><class-id>Help.DitaDocumentViewer</class-id> <category>aspects</category><body package="Help-UI">breadCrump	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^breadCrump isNil		ifTrue:			[breadCrump := ((Text2.Document new: 0)) asValue]		ifFalse:			[breadCrump]</body><body package="Help-UI">compoundWrapper	^compoundWrapper</body><body package="Help-UI">resolveFonts	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^resolveFonts isNil		ifTrue:			[resolveFonts := false asValue]		ifFalse:			[resolveFonts]</body><body package="Help-UI">showHiddenCharacters	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^showHiddenCharacters isNil		ifTrue:			[showHiddenCharacters := false asValue]		ifFalse:			[showHiddenCharacters]</body><body package="Help-UI">showSource	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^showSource isNil		ifTrue:			[showSource := false asValue]		ifFalse:			[showSource]</body></methods><methods><class-id>Help.DitaDocumentViewer</class-id> <category>updating</category><body package="Help-UI">renderAsDocument: aDitaDocument	| renderer |	renderer := CompoundViewDitaRenderer forCompoundCreator: compoundCreator.	renderer showFontNames: self resolveFonts value.	renderer resolveLinksUsing: [:href | self navigateTo: href].	renderer renderDocument: aDitaDocument</body><body package="Help-UI">renderAsSource: aDitaDocument	| xmlElement |	xmlElement := aDitaDocument xmlSource.	compoundCreator addRowUsing: 			[:row |			compoundCreator				addViewCellFor: xmlElement printString				width: 1				to: row]</body><body package="Help-UI">renderDocumentation: aDitaDocument	scrollWrapper setOrigin: Point zero.	self updateWindowTitleFor: aDitaDocument.	compoundCreator preserveFindWhile: 			[compoundCreator clearAll.			aDitaDocument isNil				ifFalse: 					[self showSource value						ifTrue: [self renderAsSource: aDitaDocument]						ifFalse: [self renderAsDocument: aDitaDocument]]].	compoundCreator widgetsDo: 			[:each |			each showHiddenCharacters: (self showHiddenCharacters value						and: [self showSource value not])].	self updateSearchStringHighlight</body><body package="Help-UI">updateDocumentationAndBreadcrump	| window |	window := compoundWrapper topComponent.	(window isNil or: [window isOpen not]) ifTrue: [^self].	"refresh the styles in case they changed (or if the settings changed)"	Help.DocumentationStyles initialize.	self renderDocumentation: navigator selectedDocument.	self breadCrump value: self generateBreadCrump</body><body package="Help-UI">updateForSearchString: aSearchString	searchString := aSearchString.	self updateDocumentationAndBreadcrump</body><body package="Help-UI">updateSearchStringHighlight	| document search fuzzyMatch highlights |	searchString isEmpty ifTrue: [^self].	compoundCreator widgetsDo: 			[:documentView |			document := CaseInsensitiveStringTrie fromString: documentView document.			search := MultiWordFuzzyStringSearch criteria: searchString.			(search searchIn: document for: nil as: #unused)				ifTrue: 					[fuzzyMatch := search suggestions first.					highlights := OrderedCollection new.					fuzzyMatch indices do: 							[:wordMatch |							wordMatch ranges do: 									[:range |									highlights add: (UI.DocumentHighlight												color: Graphics.ColorValue yellow												between: range first												and: range last												direction: #rightToLeft)]].					documentView highlights: highlights]]</body><body package="Help-UI">updateWindowTitleFor: aDitaDocument	compoundWrapper topComponent		ifNotNil: 			[:window |			| topicName title |			topicName := aDitaDocument ifNotNil: #displayString ifNil: [''].			title := #Help1s &lt;&lt; #help &gt;&gt; 'Help: &lt;1s&gt;' expandMacrosWith: topicName.			window label: title]</body></methods><methods><class-id>Help.DitaDocumentViewer</class-id> <category>initialize-release</category><body package="Help-UI">forNavigator: aNavigator	navigator := aNavigator.	navigator		expressInterestIn: #selectedNode		for: self		sendBack: #updateDocumentationAndBreadcrump.	self updateDocumentationAndBreadcrump</body><body package="Help-UI">initialize	super initialize.	showDebugControls := false.	searchString := ''.	compoundCreator := DocumentCompoundCreator new.	compoundWrapper := UI.BorderDecorator on: compoundCreator composite.	scrollWrapper := compoundWrapper scrollerComponent.	scrollWrapper scrollOffsetHolder grid: [1 @ 16].	self showSource onChangeSend: #updateDocumentationAndBreadcrump to: self.	self resolveFonts onChangeSend: #updateDocumentationAndBreadcrump to: self.	self showHiddenCharacters onChangeSend: #updateDocumentationAndBreadcrump		to: self</body></methods><methods><class-id>Help.DitaDocumentViewer</class-id> <category>menu</category><body package="Help-UI">breadCrumpMenu	^(UI.Menu new)		addItemLabel: 'Copy Path' value: [self copySelectedPath];		yourself</body></methods><methods><class-id>Help.DitaDocumentViewer</class-id> <category>private</category><body package="Help-UI">copyFilePathOf: aDocumentNode	self copyToClipboard: aDocumentNode filePath</body><body package="Help-UI">copySelectedPath	self copyToClipboard: self breadCrump value</body><body package="Help-UI">copyToClipboard: variable	UI.Screen default		putExternalSelection: ('"&lt;1s&gt;"' expandMacrosWith: variable)</body><body package="Help-UI">generateBreadCrump	| renderer |	renderer := (DitaRenderer new)				showFontNames: self resolveFonts value;				yourself.	navigator selectedPath do: 			[:each |			renderer pushStyle: #breadCrumpLink				while: 					[renderer pushStyle: 							[:style |							style								action: ((Text2.DocumentActionScript new)											block: [navigator navigateToNode: each];											menu: ((UI.Menu new)														addItemLabel: 'Copy File Path' value: [self copyFilePathOf: each];														yourself);											yourself);								intern]						while: [renderer appendString: each displayString]]]		separatedBy: 			[renderer pushStyle: #breadCrumpSeparator				while: [renderer appendString: ' &gt; ']].	^renderer document</body></methods><methods><class-id>Help.DitaDocumentViewer</class-id> <category>interface opening</category><body package="Help-UI">postBuildWith: aBuilder	super postBuildWith: aBuilder.	(self widgetAt: #breadCrump)		showSelection: false;		showInputCursor: false;		menuHolder: [self breadCrumpMenu].	#(#showHiddenCharacters #showSource #resolveFonts)		do: [:each | (self wrapperAt: each) isVisible: showDebugControls].</body></methods><methods><class-id>Help.DitaDocumentViewer class</class-id> <category>interface specs</category><body package="Help-UI">forNavigator: aNavigator	^self new forNavigator: aNavigator</body></methods><methods><class-id>Help.DitaDocumentViewer class</class-id> <category>class initialization</category><body package="Help-UI">initialize	Refactory.Browser.SourceCodeEditor		expressInterestIn: #defaultThemeKey		for: self		sendBack: #sourceCodeThemeChanged.	Refactory.Browser.SourceCodeTheme		expressInterestIn: #fontSize		for: self		sendBack: #sourceCodeThemeChanged</body></methods><methods><class-id>Help.DitaDocumentViewer class</class-id> <category>initialize-release</category><body package="Help-UI">obsolete	Refactory.Browser.SourceCodeEditor retractAllInterestsFor: self.	Refactory.Browser.SourceCodeTheme retractAllInterestsFor: self.	super obsolete</body></methods><methods><class-id>Help.DitaDocumentViewer class</class-id> <category>changing</category><body package="Help-UI">sourceCodeThemeChanged	"triggered when the theme's font changes or when the theme changes"	self allGeneralInstancesDo: #updateDocumentationAndBreadcrump</body></methods><methods><class-id>Help.DitaChunk</class-id> <category>initialize-release</category><body package="Help-UI">beSplitByTopic	splitByTopic := true</body><body package="Help-UI">forDitaObject: aDitaObject from: aBuilder documentDita: documentDitaObject	ditaObject := aDitaObject.	document := DitaDocument named: aDitaObject documentName with: documentDitaObject.	contentStack := OrderedCollection with: document.	builder := aBuilder</body><body package="Help-UI">initialize	super initialize.	splitByTopic := false.	selectWholeBranch := false</body></methods><methods><class-id>Help.DitaChunk</class-id> <category>testing</category><body package="Help-UI">combineByDocument	^ditaObject combineByDocument</body><body package="Help-UI">renderToContent	^ditaObject renderToContent</body><body package="Help-UI">shouldCreateNewChunkForTopic: aHelpDitaTopicRef	selectWholeBranch ifTrue: [^false].	ditaObject renderToContent ifTrue: [^false].	document basicIsEmpty		ifTrue: 			["if i'm empty, it can be added to myself, right?"			^false].	^true</body><body package="Help-UI">shouldCreateNewChunkForTopicReference: aHelpDitaTopicRef	aHelpDitaTopicRef renderToContent		ifTrue: 			["if the topicRef has a #to-content, create a new chunk"			^true].	ditaObject renderToContent ifTrue: [^false].	^true</body><body package="Help-UI">splitByTopic	^splitByTopic or: [ditaObject splitByTopic]</body></methods><methods><class-id>Help.DitaChunk</class-id> <category>printing</category><body package="Help-UI">printOn: aStream	super printOn: aStream.	aStream		space;		print: self name;		nextPutAll: ' ( ';		print: contentStack last;		nextPutAll: ' )'</body></methods><methods><class-id>Help.DitaChunk</class-id> <category>building</category><body package="Help-UI">addDocumentObject: newContent	contentStack last addObject: newContent.	contentStack add: newContent</body><body package="Help-UI">addTopic: aHelpDitaTopic	| newContent |	newContent := DitaDocumentTopic with: aHelpDitaTopic.	newContent referingDocument: document.	self addDocumentObject: newContent</body><body package="Help-UI">addTopicRef: aHelpDitaTopicRef to: referenceChunk	| newDocumentObject |	newDocumentObject := DitaDocumentTopicRef with: aHelpDitaTopicRef				referencing: referenceChunk document.	referenceChunk document referingDocument: newDocumentObject.	newDocumentObject referingDocument: document.	self addDocumentObject: newDocumentObject</body><body package="Help-UI">createChunkFor: aDitaObject documentObject: documentDitaObject	| newChunk |	newChunk := builder createChunkFor: aDitaObject				documentObject: documentDitaObject.	self splitByTopic ifTrue: [newChunk beSplitByTopic].	^newChunk</body><body package="Help-UI">fixStackWhile: aBlock	| stackSize |	stackSize := contentStack size.	aBlock ensure: [contentStack := contentStack first: stackSize]</body><body package="Help-UI">pushLastTopic	"push the last topic on the stack. That only makes sense if the last object on the stack is the document itself"	| topic |	contentStack last ~= document ifTrue: [^self].	topic := document lastTopic.	topic ~= document ifTrue: [contentStack add: topic]</body><body package="Help-UI">selectWholeBranchWhile: aBlockClosure	| oldValue |	oldValue := selectWholeBranch.	selectWholeBranch := true.	aBlockClosure ensure: [selectWholeBranch := oldValue]</body></methods><methods><class-id>Help.DitaChunk</class-id> <category>accessing</category><body package="Help-UI">document	^document</body><body package="Help-UI">name	^document name</body><body package="Help-UI">structure	^document structure</body></methods><methods><class-id>Help.DitaChunk class</class-id> <category>instance creation</category><body package="Help-UI">forDitaObject: aDitaObject from: aBuilder documentDita: documentDitaObject	^self new forDitaObject: aDitaObject from: aBuilder documentDita: documentDitaObject</body><body package="Help-UI">new	^super new initialize</body></methods><methods><class-id>Help.DitaDocumentNode</class-id> <category>accessing</category><body package="Help-UI">allChildren	| writeStream |	writeStream := Array new writeStream.	self allChildrenDo:[:each | writeStream nextPut: each].	^writeStream contents</body><body package="Help-UI">allChildrenDo: aBlock	aBlock value: self.	children do: [:each | each allChildrenDo: aBlock]</body><body package="Help-UI">children	^children</body><body package="Help-UI">children: anObject	children := anObject</body><body package="Help-UI">childrenOn: aWriteStream	aWriteStream nextPut: self.	children do: [:each | each childrenOn: aWriteStream]</body><body package="Help-UI">documentObject	^documentObject</body><body package="Help-UI">documentObject: anObject	documentObject := anObject</body><body package="Help-UI">filePath	^documentObject filePath</body><body package="Help-UI">findDocumentForTopicWithId: aByteString	self allChildrenDo: 			[:each |			(each documentObject documentObjectForDitaObjectLike: 					[:ditaObject |					ditaObject isTopic and: [ditaObject id = aByteString]])				ifNotNil: [:document | ^document]].	^nil</body><body package="Help-UI">parent	^parent</body><body package="Help-UI">parent: anObject	parent := anObject</body></methods><methods><class-id>Help.DitaDocumentNode</class-id> <category>initialize-release</category><body package="Help-UI">hierarchyWithRoot: ditaDocumentObject	documentObject := ditaDocumentObject.	children := ditaDocumentObject navigationChildren				collect: [:each | self class hierarchyWithRoot: each].	children do: [:each | each parent: self]</body></methods><methods><class-id>Help.DitaDocumentNode</class-id> <category>printing</category><body package="Help-UI">childWithDocument: aDocument	(documentObject representsDocument: aDocument) ifTrue: [^self].	children		do: [:each | (each childWithDocument: aDocument) ifNotNil: [:child | ^child]].	^nil</body><body package="Help-UI">debugDisplayString	^documentObject debugDisplayString</body><body package="Help-UI">displayString	^documentObject displayString</body><body package="Help-UI">fullPath	parent isNil ifTrue: [^Array with: self].	^parent fullPath copyWith: self</body><body package="Help-UI">printOn: aStream	super printOn: aStream.	aStream		space;		nextPut: $(.	aStream nextPutAll: documentObject displayString.	aStream nextPut: $)</body></methods><methods><class-id>Help.DitaDocumentNode class</class-id> <category>instance creation</category><body package="Help-UI">hierarchyWithRoot: ditaDocumentObject	^self new hierarchyWithRoot: ditaDocumentObject</body></methods><methods><class-id>Help.HelpAutocomplete</class-id> <category>actions - events</category><body package="Help-UI">selectedBeforeStartOfList	self autocompleteModel selectEnd</body><body package="Help-UI">selectedPastEndOfList	self autocompleteModel selectHome</body></methods><methods><class-id>Help.HelpAutocomplete</class-id> <category>private</category><body package="Help-UI">currentWordInterval	^0 to: view document size</body></methods><methods><class-id>Help.HelpAutocomplete</class-id> <category>initialize-release</category><body package="Help-UI">helpNavigator: aHelpNavigator	navigator := aHelpNavigator.</body><body package="Help-UI">newAutocompleteModel	^(HelpAutocompleteModel new)		configure: self;		navigator: navigator;		yourself</body><body package="Help-UI">newSearcher: word	^HelpAutocompleteSearch		for: word		inDocuments: navigator searchableDocuments		ofView: view</body></methods><methods><class-id>Help.HelpAutocomplete</class-id> <category>actions</category><body package="Help-UI">acceptSuggestion: acceptance	"do nothing, we don't apply the result to our text as we use it for navigation"</body><body package="Help-UI">applySuggestion: aSuggestion	"do nothing, we don't apply the result to our text as we use it for navigation"</body></methods><methods><class-id>Help.HelpAutocomplete class</class-id> <category>instance creation</category><body package="Help-UI">on: aView searchIn: navigator	| instance |	instance := self on: aView.	instance helpNavigator: navigator.	^instance</body></methods><methods><class-id>Help.HelpBrowser</class-id> <category>initialize-release</category><body package="Help-UI">highlightSearchString	self ditaDocumentViewer updateForSearchString: self searchString value</body><body package="Help-UI">initialize	super initialize.	self searchString onChangeSend: #highlightSearchString to: self</body><body package="Help-UI">navigateToTopicWithID: topicId	navigator navigateToTopicWithID: topicId</body><body package="Help-UI">onHelpFolderAt: aFilename rootMap: rootFile showRoot: showRoot	| folder |	folder := HelpNavigator onHelpFolder: aFilename rootMap: rootFile.	self onHelpNavigator: folder showRoot: showRoot</body><body package="Help-UI">onHelpNavigator: helpNavigator showRoot: showRoot	navigator := helpNavigator.	self topicsTree selectionHolder onChangeSend: #updateDocumentation to: self.	self topicsTree tree: (TreeModel				on: navigator rootNode				displayRoot: showRoot).	navigator		expressInterestIn: #selectedNode		for: self		sendBack: #updateSelectedContext</body></methods><methods><class-id>Help.HelpBrowser</class-id> <category>aspects</category><body package="Help-UI">searchString	^searchString isNil		ifTrue: 			["has to be initialized with a Text2.Document otherwise undo context-menu will raise an error"			searchString := '' asDocument asValue]		ifFalse: [searchString]</body><body package="Help-UI">toolbarHolder	^toolbarHolder isNil		ifTrue: [toolbarHolder := self toolbarMenu asValue]		ifFalse: [toolbarHolder]</body><body package="Help-UI">topicsTree	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^topicsTree isNil		ifTrue:			[topicsTree := SelectionInTree new]		ifFalse:			[topicsTree]</body></methods><methods><class-id>Help.HelpBrowser</class-id> <category>changing</category><body package="Help-UI">showDebugControls	^false</body><body package="Help-UI">updateDebugMode	| selector showDebugDescription |	showDebugDescription := false.	selector := showDebugDescription				ifTrue: [#debugDisplayString]				ifFalse: [#displayString].	(self widgetAt: #topicsTree)		ifNotNil: 			[:widget |			widget				displayStringSelector: selector;				invalidate]</body><body package="Help-UI">updateDocumentation	navigator navigateToNode: self topicsTree selection</body><body package="Help-UI">updateSelectedContext	self topicsTree tree expandFound: navigator selectedNode.	self topicsTree selection: navigator selectedNode.	"rebuild the toolbar in order to refresh the enablement of their buttons"	self toolbarHolder value: self toolbarMenu.	self mainWindow isMapped		ifTrue: 			["this is for situations where the search changes the selection. Then the tree should take focus"			[(self wrapperAt: #topicsTree) takeKeyboardFocus]				uiEventFor: self mainWindow]</body></methods><methods><class-id>Help.HelpBrowser</class-id> <category>testing</category><body package="Help-UI">isForFolder: aFilename rootMap: rootName	^navigator isForFolder: aFilename rootMap: rootName</body></methods><methods><class-id>Help.HelpBrowser</class-id> <category>interface opening</category><body package="Help-UI">addFindField	| toolbar findField |	toolbar := self widgetAt: #toolbarHolder.	toolbar isNil ifTrue: [^self].	toolbar addTool: 			[| toolBuilder |			toolBuilder := builder newSubBuilder.			toolBuilder source: builder source.			toolBuilder bindings: builder bindings.			toolBuilder add: self findFieldSpec.			findField := toolBuilder component.			"tell our builder about the searchField so that we know it doesn't need to be added again"			builder componentAt: #searchString				put: (toolBuilder componentAt: #searchString).			findField controller				addBehavior: (HelpAutocomplete on: findField searchIn: navigator).			findField autoAccept: true.			toolBuilder wrapper component]		width: #fill.	toolbar invalidateWidget</body><body package="Help-UI">createHelpIcon	| pixmap gc iconImage |	pixmap := Pixmap extent: Icon default extent.	gc := pixmap graphicsContext.	gc paint: ColorValue black.	gc displayRectangle: (0 @ 0 extent: pixmap extent).	(FontDescription default copy)		family: 'Arial';		pixelSize: pixmap height negated;		installOn: gc.	gc paint: (ColorValue brightness: 0.1).	gc displayString: '?' at: 0 @ pixmap height.	iconImage := pixmap asImage.	^Icon figure: iconImage		transparentPixels: (Array with: (iconImage atPoint: 0 @ 0))</body><body package="Help-UI">findFieldSpec	| spec |	spec := self class findSpec decodeAsLiteralArray.	^spec component</body><body package="Help-UI">finishDocumentViewSetup	"tell the DitaDocumentViewer about our searchString and make it render the current content"	self highlightSearchString</body><body package="Help-UI">postBuildWith: aBuilder	super postBuildWith: aBuilder.	self updateSelectedContext.	self updateDebugMode</body><body package="Help-UI">postOpenWith: aBuilder	| icon |	super postOpenWith: aBuilder.	(self widgetAt: #searchString) isNil ifTrue: [self addFindField].	icon := self createHelpIcon.	self mainWindow icon: icon.	self privateToggleNavigation.	self finishDocumentViewSetup</body></methods><methods><class-id>Help.HelpBrowser</class-id> <category>toolbar</category><body package="Help-UI">globalSplitterOffset	| splitter globalOrigin |	splitter := self widgetAt: #splitter.	globalOrigin := splitter localPointToGlobal: splitter bounds topLeft.	^globalOrigin x</body><body package="Help-UI">isNavigationVisible	^self globalSplitterOffset &gt; 50</body><body package="Help-UI">privateToggleNavigation	| targetLeft splitter offset |	targetLeft := self isNavigationVisible ifTrue: [0] ifFalse: [300].	splitter := self widgetAt: #splitter.	offset := targetLeft - self globalSplitterOffset.	splitter moveBy: offset @ 0</body><body package="Help-UI">toolbarMenu	^Menu new		augment: #(#toolbar)		from: self class		to: HelpBrowser		for: self</body></methods><methods><class-id>Help.HelpBrowser</class-id> <category>accessing</category><body package="Help-UI">ditaDocumentViewer	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^ditaDocumentViewer isNil		ifTrue: 			[ditaDocumentViewer := (DitaDocumentViewer forNavigator: navigator)						showDebugControls: self showDebugControls;						yourself]		ifFalse: [ditaDocumentViewer]</body></methods><methods><class-id>Help.HelpBrowser class</class-id> <category>interface specs</category><body package="Help-UI">onHelpFolderAt: aFilename rootMap: rootFile showRoot: showRoot	^self new onHelpFolderAt: aFilename rootMap: rootFile showRoot: showRoot</body><body package="Help-UI">onVwHelp		^self		openOnHelpFolder: (OS.LogicalFilename named:'$(VISUALWORKS)') asFilename / 'help'		rootMap: 'vwHelpTopics.ditamap'		showRoot: false</body><body package="Help-UI">openOnHelpFolder: aFilename rootMap: rootFile showRoot: showRoot	| browser window |	window := self singleInstanceWindow.	browser := window ifNotNil: #model.	(browser notNil and: [browser isForFolder: aFilename rootMap: rootFile])		ifFalse: 			[browser := 					[self onHelpFolderAt: aFilename rootMap: rootFile showRoot: showRoot]							on: HelpNotFoundError							do: 								[:ex |								Dialog warn: (#ErrorOpeningHelp1s &lt;&lt; #help &gt;&gt; 'Error opening Help.&lt;n&gt;File not found: &lt;1s&gt;'											expandMacrosWith: ex parameter).								^nil]].	window := browser mainWindow.	window isNil		ifTrue: [browser open]		ifFalse: [browser mainWindow expand raise].	^browser</body><body package="Help-UI">openOnTopicWithID: topicID	^self onVwHelp		ifNotNil: [:browser | browser navigateToTopicWithID: topicID]</body></methods><methods><class-id>Help.CompoundViewDitaRenderer</class-id> <category>tags-block</category><body package="Help-UI">addDoItButtonsToExecute: sourceCode in: evaluator	self renderSoftBlock: 			[self				linkTo: [evaluator inspect: sourceCode]				named: 'Execute the code and inspect the result'				while: [self appendString: 'Inspect It']				usingStyleNamed: #actionLink.			self appendSpace.			self				linkTo: [evaluator debug: sourceCode]				named: 'Open a Debugger at the beginning of the code'				while: [self appendString: 'Debug It']				usingStyleNamed: #actionLink]</body><body package="Help-UI">appendSpace	self privateAppendString: ' '</body><body package="Help-UI">appendTab	self privateAppendString: '	'</body><body package="Help-UI">createCodeCellWhile: aBlock	| editor |	currentCell := compoundCreator				addSceCellFor: canvas startNewDocument				width: 1				to: currentRow				withReceiverClass: Object.	currentCell		margin: (currentStyle lineIndent @ 0 corner: 0 @ 0).	editor := currentCell.	aBlock ensure: [self newBlock].	self tagPreservingFormatCodeIn: editor</body><body package="Help-UI">createNewRow	self finishCell.	compoundCreator addRowUsing: [:row | currentRow := row]</body><body package="Help-UI">createViewCell	self createViewCellWidth: 1</body><body package="Help-UI">createViewCellWidth: width	self finishCell.	currentCell := compoundCreator				addViewCellFor: canvas startNewDocument				width: width				to: currentRow.	insideLI		ifTrue: 			["ensure the next text is indented like in the previous cell"			canvas continueListItem]</body><body package="Help-UI">indentCodeBlockWhile: aBlock	"if code-blocks are rendered inside an LI, they need to be indented once more. Otherwise they appear too far left.	The indentation for LIs starts with their numbering. The indentation of the code needs to start after the content of	the LI, which cannot easily be computed or set. Indenting a second time in this case is easier."	self indentWhile: 			[insideLI ifTrue: [self indentWhile: aBlock] ifFalse: [aBlock value]]</body><body package="Help-UI">newBlock	self finishCell.	currentCell := nil.	currentRow := nil.	^canvas startNewDocument</body><body package="Help-UI">newRowWhile: aBlock	self createNewRow.	aBlock ensure: [self createNewRow]</body><body package="Help-UI">renderCODEBLOCK: codeblockElement	| otherProbs evaluator addDoItButtons shouldAddDoItButtons |	canvas cleanEndOfDocumentIncludingParagraphBreak: false.	self indentCodeBlockWhile: 			[self newRowWhile: 					[self createCodeCellWhile: 							[evaluator := currentCell evaluator.							evaluator forSmalltalkExpressions.							addDoItButtons := true.							(codeblockElement attributeAt: 'otherprops')								ifNotNil: 									[:propAttribute |									otherProbs := ((propAttribute value tokensBasedOn: Character space)												asArray reject: #isEmpty)												collect: [:each | each asLowercase asSymbol].									otherProbs = #(#smalltalk #method)										ifTrue: 											[evaluator forSmalltalkMethods.											addDoItButtons := false].									(otherProbs beginsWith: #(#smalltalk)) not										ifTrue: [addDoItButtons := false]].							super renderCODEBLOCK: codeblockElement]]].	shouldAddDoItButtons := false.	(shouldAddDoItButtons and: [addDoItButtons])		ifTrue: 			[self addDoItButtonsToExecute: codeblockElement characterData in: evaluator]</body><body package="Help-UI">tagPreservingFormatCodeIn: editor	| formatter formattedCode originalCode |	formatter := editor evaluator formatterClass new.	"call #trimSeparators because formatting expressions may add leading line-breaks"	formattedCode := (formatter format: editor parseTree) asDocument trimSeparators.	originalCode := editor model value.	DitaAnnotationDecorator decorate: formattedCode		withAnnotationsFrom: originalCode.	"use our own error handler class in order to prevent the default error handler from destroying our styles 	with its own annotations. Lets just pretend the Help-Examples don't have compiler errors that need to be seen"	editor errorHandlerClass: HelpCompilerErrorHandler.	editor model value: formattedCode.	"add the decorator to the editor in order to reapply the annotations whenever the text changes"	editor decorations: (editor decorations copyWith: DitaAnnotationDecorator)</body></methods><methods><class-id>Help.CompoundViewDitaRenderer</class-id> <category>tags-table</category><body package="Help-UI">renderCOLUMNSPEC: colSpecElement	| columnIndex width columnName |	columnIndex := (colSpecElement attributeAt: 'colnum')				ifNil: [^self]				ifNotNil: [:attr | attr value asNumber].	columnName := (colSpecElement attributeAt: 'colname')				ifNil: [^self]				ifNotNil: [:attr | attr value].	width := (colSpecElement attributeAt: 'colwidth')				ifNil: [^self]				ifNotNil: [:attr | attr value asNumber].	width &gt; 1		ifTrue: 			["percent value"			width := width / 100].	columnWidths size &lt; columnIndex ifTrue: [^self].	columnWidths at: columnIndex put: width.	columnNames at: columnName put: columnIndex.	super renderCOLUMNSPEC: colSpecElement</body><body package="Help-UI">renderTABLEENTRY: tableEntryElement	| column width |	column := (tableEntryElement attributeAt: 'colname')				ifNotNil: #value				ifNil: [^self].	width := self widthOfColumnNamed: column.	self createViewCellWidth: width.	super renderTABLEENTRY: tableEntryElement</body><body package="Help-UI">renderTABLEGROUP: tableGroupElement	| cols |	columnWidths := #().	columnNames := Dictionary new.	cols := (tableGroupElement attributeAt: 'cols')				ifNotNil: [:attr | attr value asNumber]				ifNil: [^self].	columnWidths := Array new: cols withAll: 100.	super renderTABLEGROUP: tableGroupElement</body><body package="Help-UI">renderTABLEROW: rowElement		self createNewRow.	super renderTABLEROW: rowElement.</body><body package="Help-UI">widthOfColumnNamed: columnName	| index |	index := columnNames at: columnName ifAbsent: [^100].	^columnWidths at: index</body></methods><methods><class-id>Help.CompoundViewDitaRenderer</class-id> <category>utility</category><body package="Help-UI">finishCell	currentCell		ifNotNil: 			[canvas cleanEndOfDocumentIncludingParagraphBreak: true.			currentCell basicCancel.			currentCell settings at: #drawTabStop put: true]</body><body package="Help-UI">privateAppendString: text	currentRow isNil ifTrue: [self createNewRow].	currentCell isNil		ifTrue: 			[text = ' ' ifTrue: [^self].			self createViewCell].	super privateAppendString: text</body></methods><methods><class-id>Help.CompoundViewDitaRenderer</class-id> <category>rendering</category><body package="Help-UI">renderDocument: aDitaDocument	super renderDocument: aDitaDocument.	self finishCell</body></methods><methods><class-id>Help.CompoundViewDitaRenderer</class-id> <category>initialize-release</category><body package="Help-UI">forCompoundCreator: aCompoundCreator	compoundCreator := aCompoundCreator.	self createNewRow.</body></methods><methods><class-id>Help.CompoundViewDitaRenderer</class-id> <category>tags-list</category><body package="Help-UI">renderLI: liElement	"insert an empty string so that we can ensure that currentCell is set. 	Otherwise the cell would be created when the LI's text is rendered, removing the list-Item-token that's sent directly to the canvas"	self privateAppendString: ''.	super renderLI: liElement</body></methods><methods><class-id>Help.CompoundViewDitaRenderer class</class-id> <category>instance creation</category><body package="Help-UI">forCompoundCreator: aCompoundCreator	^self new forCompoundCreator: aCompoundCreator</body></methods><methods><class-id>Help.DocumentCompoundCreator</class-id> <category>initialize-release</category><body package="Help-UI">initialize	composite := CompositePart new</body></methods><methods><class-id>Help.DocumentCompoundCreator</class-id> <category>accessing</category><body package="Help-UI">clearAll	composite components copy reverseDo: [:each | composite removeComponent: each].</body><body package="Help-UI">composite	^composite</body><body package="Help-UI">documentSearch	self widgetsDo: [:each | each search ifNotNil: [:search | ^search]].	^nil</body><body package="Help-UI">preserveFindWhile: aBlock	| search searchString isOpen |	search := self documentSearch.	search isNil ifTrue: [^aBlock value].	searchString := search searchDocument value.	isOpen := search isOpen.	isOpen		ifTrue: 			["close the search, otherwise its widgets will be left in the view hierarchy"			search close].	[aBlock value] ensure: 			[search := self documentSearch.			search notNil				ifTrue: 					["seems #reset needs to be called, otherwise changing the searchDocument will result in an error"					search reset.					isOpen ifTrue: [search open].					search searchDocument value: searchString.					"deactivate findmode so that that the view is not in mode #find and doesn't react to mouse move events"					isOpen ifFalse: [search deactivateFindMode]]]</body><body package="Help-UI">widgetsDo: aBlock	composite components do: 			[:rowWrapper |			rowWrapper bottomComponent components				do: [:cellWrapper | aBlock value: cellWrapper bottomComponent]]</body></methods><methods><class-id>Help.DocumentCompoundCreator</class-id> <category>public</category><body package="Help-UI">addEditCellFor: aDocument width: aNumber to: row	| documentView |	documentView := UI.DocumentEditor model: aDocument asDocument asValue.	^self addView: documentView width: aNumber to: row</body><body package="Help-UI">addRowUsing: aBlock	| row previousRowWrapper wrapper |	previousRowWrapper := composite components isEmpty				ifTrue: [nil]				ifFalse: [composite components last].	(previousRowWrapper notNil		and: [previousRowWrapper bottomComponent components isEmpty])			ifTrue: 				["if the row is empty, reuse it, otherwise the layout seems 				to break and nothing following this row will be visible"				row := previousRowWrapper bottomComponent]			ifFalse: 				[row := CompositePart new.				wrapper := composite addWrapper: (Graphics.ConstraintWrapper on: row).				(wrapper constraints)					left: composite constraints left right: composite constraints right;					top: (previousRowWrapper								ifNil: [composite constraints top]								ifNotNil: [previousRowWrapper constraints bottom])						height: 							[row components inject: 0								into: [:all :each | (all max: each intrinsicHeight) ceiling]]].	aBlock value: row</body><body package="Help-UI">addSceCellFor: aDocument width: aNumber to: row withEvaluator: evaluator	| documentView |	documentView := Refactory.Browser.SourceCodeEditor				model: '' asDocument asValue.	documentView language: evaluator language.	documentView evaluator: evaluator.	documentView theme: documentView theme asThemeWithoutErrors.	"isWorkspace: false will create a parse-tree, allowing the search to also test for keyword-selectors"	documentView isWorkspace: false.	documentView model value: aDocument.	^self addView: documentView width: aNumber to: row</body><body package="Help-UI">addSceCellFor: aDocument width: aNumber to: row withReceiver: doItReceiver	^self		addSceCellFor: aDocument		width: aNumber		to: row		withEvaluator: ((SourceCodeEvaluator withReceiver: doItReceiver)				doItEnvironment: ((Kernel.NameSpace new)						imports: 'Smalltalk.*Core.*Help.*';						yourself))</body><body package="Help-UI">addSceCellFor: aDocument width: aNumber to: row withReceiverClass: doItReceiverClass	^self		addSceCellFor: aDocument		width: aNumber		to: row		withEvaluator: ((SourceCodeEvaluator withReceiverClass: doItReceiverClass)				doItEnvironment: ((Kernel.NameSpace new)						imports: 'Smalltalk.*Core.*Help.*';						yourself))</body><body package="Help-UI">addView: documentView width: aNumber to: row	| wrappedView previousCell previousRow |	self connectToNewDocumentView: documentView.	wrappedView := Graphics.ConstraintWrapper on: documentView.	previousRow := composite components size &gt; 1 ifTrue:[composite components at: composite components size - 1] ifFalse:[nil].	previousCell := row components notEmpty				ifTrue: [row components last]				ifFalse: [nil].	(wrappedView constraints)		left: (previousCell					ifNil: [row container constraints left]					ifNotNil: [previousCell constraints right])			width: [row container constraints width value * aNumber];		top: (previousRow					ifNil: [row container constraints top]					ifNotNil: [previousRow constraints bottom])			height: wrappedView bottomComponent intrinsicHeightConstraint.	row addWrapper: wrappedView.	^documentView</body><body package="Help-UI">addViewCellFor: aDocument width: aNumber to: row	| documentView |	documentView := UI.DocumentView model: aDocument asDocument asValue.	^self addView: documentView width: aNumber to: row</body></methods><methods><class-id>Help.DocumentCompoundCreator</class-id> <category>private</category><body package="Help-UI">connectToNewDocumentView: documentView	| previous |	documentView propertyAt: #creator put: self.	documentView interconnectionCompound: composite.	previous := nil.	self widgetsDo: [:each | previous := each].	previous isNil ifTrue: [^self].	previous connectWithSuccessor: documentView</body></methods><methods><class-id>Help.DocumentCompoundCreator class</class-id> <category>instance creation</category><body package="Help-UI">exampleEditors	"self exampleEditors"	| view window str builder |	builder := [:string :size | | res | res := string. size timesRepeat: [res := res , ' ', res]. res].	str := [:string | builder value: string value: 5].	view := self new.	view addRowUsing: [:row | view addEditCellFor: (str value:'adda') width: 1 to: row].	view addRowUsing: 			[:row |			view addEditCellFor: (str value: 'abba') width: 0.5 to: row.			view addEditCellFor: (str value: 'balla') width: 0.5 to: row].	view addRowUsing: 			[:row |			view addEditCellFor: (str value: 'adda') width: 1/3 to: row.			view addEditCellFor: (str value: 'blub') width: 1/3 to: row.			view addEditCellFor: (str value: 'cubba') width: 1/3 to: row].	view addRowUsing: [:row | view addEditCellFor: (str value: 'dadda') width: 1 to: row].	window := UI.ScheduledWindow model: nil asValue label: thisContext selector minimumSize: 300@300.	window component: (UI.BorderDecorator on: view).	window open.	^view</body><body package="Help-UI">exampleSourceCodeEditors	"self exampleSourceCodeEditor"	| view window str builder receiverClass |	builder := [:string :size | | res | res := string. size timesRepeat: [res := res , ' ' , res]. res].	str := [:string | builder value: string value: 5].	view := self new.		receiverClass := Object.	view addRowUsing: [:row | view addSceCellFor: (str value: '1 + 1.') width: 1 to: row withReceiverClass: receiverClass].	view addRowUsing: [:row | 		view addSceCellFor: (str value: '2 + 2.') width: 0.5 to: row withReceiver: receiverClass.		view addSceCellFor: (str value: 'Array with: 3 with: 3.') width: 0.5 to: row withReceiver: receiverClass].	view addRowUsing: [:row |			view addSceCellFor: (str value: '4 + 4.') width: 1 / 3 to: row withReceiver: receiverClass.			view addSceCellFor: (str value: '5 raisedTo: 5.') width: 1 / 3 to: row withReceiver: receiverClass.			view addSceCellFor: (str value: '6 + 6.') width: 1 / 3 to: row withReceiver: receiverClass].	view addRowUsing: [:row | view addSceCellFor: (str value: '7 @ 7.') width: 1 to: row withReceiver: receiverClass].		window := UI.ScheduledWindow				model: nil asValue				label: thisContext selector				minimumSize: 300 @ 300.	window component: (UI.BorderDecorator on: view).	window open.	^view</body><body package="Help-UI">exampleViewers	"self exampleViewers"	| view window str builder |	builder := [:string :size | | res | res := string. size timesRepeat: [res := res , ' ', res]. res].	str := [:string | builder value: string value: 5].	view := self new.	view addRowUsing: [:row | view addViewCellFor: (str value:'adda') width: 1 to: row].	view addRowUsing: 			[:row |			view addViewCellFor: (str value: 'abba') width: 0.5 to: row.			view addViewCellFor: (str value: 'balla') width: 0.5 to: row].	view addRowUsing: 			[:row |			view addViewCellFor: (str value: 'adda') width: 1/3 to: row.			view addViewCellFor: (str value: 'blub') width: 1/3 to: row.			view addViewCellFor: (str value: 'cubba') width: 1/3 to: row].	view addRowUsing: [:row | view addViewCellFor: (str value: 'dadda') width: 1 to: row].	window := UI.ScheduledWindow model: nil asValue label: thisContext selector minimumSize: 300@300.	window component: (UI.BorderDecorator on: view).	window open.	^view</body><body package="Help-UI">new	^super new initialize</body></methods><methods><class-id>Help.HelpAutocompleteSearch</class-id> <category>initialize-release</category><body package="Help-UI">searchInDocuments: searchDocuments	documents := searchDocuments.	search := MultiWordFuzzyStringSearch criteria: word.	requireFirstLetterMatch := false</body></methods><methods><class-id>Help.HelpAutocompleteSearch class</class-id> <category>instance creation</category><body package="Help-UI">for: word inDocuments: documents ofView: anObject	^(self on: anObject for: word) searchInDocuments: documents</body></methods><methods><class-id>Help.DitaDocumentTopic</class-id> <category>printing</category><body package="Help-UI">debugString	^'T'</body><body package="Help-UI">printOn: aStream	super printOn: aStream.	aStream		space;		print: ditaObject</body><body package="Help-UI">url 	^ditaObject fullUrl</body></methods><methods><class-id>Help.DitaDocumentTopic</class-id> <category>testing</category><body package="Help-UI">isReferenceOnly	^false</body></methods><methods><class-id>Help.DitaDocumentTopic</class-id> <category>accessing</category><body package="Help-UI">actualDocument	^self</body><body package="Help-UI">documentObjectForDitaObjectLike: aBlock	(aBlock value: ditaObject) ifTrue: [^self].	^super documentObjectForDitaObjectLike: aBlock</body><body package="Help-UI">renderAsTopicOn: aRenderer	ditaObject renderAsTopicOn: aRenderer</body><body package="Help-UI">renderNormalOn: aRenderer	aRenderer renderTopic: ditaObject</body><body package="Help-UI">resolveTopicAtUrl: aPartialURL	^ditaObject resolveTopicAtUrl: aPartialURL</body><body package="Help-UI">suggestToAutocomplete: helpAutocomplete visited: visitedDocuments	(visitedDocuments includes: self) ifTrue: [^self].	super suggestToAutocomplete: helpAutocomplete visited: visitedDocuments.	visitedDocuments add: self.	helpAutocomplete		suggest: ditaObject searchString		for: self		as: #topic</body><body package="Help-UI">topic	^ditaObject</body><body package="Help-UI">with: aTopic	ditaObject := aTopic.	name := aTopic id</body></methods><methods><class-id>Help.DitaDocumentTopic class</class-id> <category>instance creation</category><body package="Help-UI">with: aTopic	^self new with: aTopic</body></methods><methods><class-id>Help.AnnotatedWord</class-id> <category>accessing</category><body package="Help-UI">annotation	^annotation</body><body package="Help-UI">fromDocument: aDocument	word := aDocument asString.	annotation := nil.	aDocument offsetsAndSegmentsDo: 			[:offset :segment |			(segment style propertyAt: #tag) ifNotNil: [:tag | annotation := tag]]</body><body package="Help-UI">matchOn: aReadStream	| match |	aReadStream upToAll: word.	aReadStream atEnd		ifFalse: 			[match := AnnotatedWordMatch withMatch: self at: aReadStream position.			aReadStream skip: word size.			^match].	^nil</body><body package="Help-UI">word	^word</body></methods><methods><class-id>Help.AnnotatedWord</class-id> <category>printing</category><body package="Help-UI">printOn: aStream	super printOn: aStream.	aStream		space;		print: word.	annotation notNil		ifTrue: 			[aStream				space;				nextPut: $#;				print: annotation]</body></methods><methods><class-id>Help.AnnotatedWord class</class-id> <category>instance creation</category><body package="Help-UI">annotatedWordsFrom: aDocument	"converts aDocument into an array of words. Words do include special characters.	Words do NOT include parenthesis or points because those can be added or removed by the auto-formatted"	^(AnnotationWordScanner tokenStringsFrom: aDocument)		collect: [:each | self fromDocument: each]</body><body package="Help-UI">fromDocument: aDocument	^self new fromDocument: aDocument</body></methods><methods><class-id>Help.DitaDocumentBuilder</class-id> <category>initialize-release</category><body package="Help-UI">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	chunks := OrderedCollection new.	^self</body></methods><methods><class-id>Help.DitaDocumentBuilder</class-id> <category>private</category><body package="Help-UI">addChildrenOf: aDitaObject to: chunk	aDitaObject children do: 			[:each |			"adding and object to a chunk will make this object the receiver.			By fixing the stack, all children are added to the same chunk"			chunk fixStackWhile: [self add: each to: chunk]]</body><body package="Help-UI">addMap: aDitaMap to: chunk	self addChildrenOf: aDitaMap to: chunk</body><body package="Help-UI">addTopic: aTopic to: aChunk	| chunkForChildren |	chunkForChildren := (aChunk shouldCreateNewChunkForTopic: aTopic)				ifTrue: [aChunk createChunkFor: aTopic documentObject: aTopic]				ifFalse: [aChunk].	chunkForChildren ~~ aChunk		ifTrue: 			["if a new chunk was created, add a reference to the new chunk"			aChunk addTopicRef: aTopic asTopicRef to: chunkForChildren].	chunkForChildren addTopic: aTopic.	self addChildrenOf: aTopic to: chunkForChildren</body><body package="Help-UI">addTopicReference: aTopicReference to: aChunk	| chunkForChildren |	chunkForChildren := (aChunk				shouldCreateNewChunkForTopicReference: aTopicReference)					ifTrue: 						[aChunk createChunkFor: aTopicReference							documentObject: aTopicReference target]					ifFalse: [aChunk].	aChunk renderToContent		ifTrue: 			[aChunk addTopic: aTopicReference topic.			aTopicReference selectWholeBranch				ifTrue: 					[aChunk						selectWholeBranchWhile: [self addChildrenOf: aTopicReference topic to: aChunk]]]		ifFalse: 			[aChunk ~~ chunkForChildren				ifTrue: 					["if we created a new chunk, add a link to the new chunk from the old chunk"					aChunk						fixStackWhile: [aChunk addTopicRef: aTopicReference to: chunkForChildren]].			self add: aTopicReference typeConformTarget to: chunkForChildren.			"if the #target is not a topic, its DitaDocumentTopic will not be on the chunk's stack anymore.			By adding the last topic back on the stack, the #addChildrenOf:to: call below will add the children to that topic"			chunkForChildren pushLastTopic].	self addChildrenOf: aTopicReference to: chunkForChildren</body><body package="Help-UI">createChunkFor: aDitaObject documentObject: documentDitaObject	| chunk |	chunk := DitaChunk				forDitaObject: aDitaObject				from: self				documentDita: documentDitaObject.	chunks add: chunk.	^chunk</body><body package="Help-UI">documents	^chunks collect: #document</body></methods><methods><class-id>Help.DitaDocumentBuilder</class-id> <category>public</category><body package="Help-UI">add: anObject	| chunk |	chunk := self createChunkFor: anObject documentObject: anObject.	self add: anObject to: chunk</body><body package="Help-UI">add: anObject to: aChunk	anObject class = DitaTopicRef		ifTrue: [^self addTopicReference: anObject to: aChunk].	anObject class = DitaMap ifTrue: [^self addMap: anObject to: aChunk].	anObject class = Dita		ifTrue: 			["a dita is really just a container and itself not relevant for chunking. Its content is the interesting part"			^self addChildrenOf: anObject to: aChunk].	(anObject isKindOf: DitaTopic)		ifTrue: [^self addTopic: anObject to: aChunk].	^self</body></methods><methods><class-id>Help.DitaDocumentBuilder class</class-id> <category>instance creation</category><body package="Help-UI">documentsForMap: aDitaMap	| builder |	builder := self new.	builder add: aDitaMap.	^builder documents</body><body package="Help-UI">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Refactory.Browser.SourceCodeTheme</class-id> <category>comparing</category><body package="Help-UI">asThemeWithoutErrors	^(self copy)		removeInvalidStyles;		source: [source value asThemeWithoutErrors];		yourself</body><body package="Help-UI">removeInvalidStyles	| newStyles isInvalid |	newStyles := Dictionary new.	styles keysAndValuesDo: 			[:key :value |			isInvalid := key anySatisfy: 							[:each |							"the following list does not contain #invalid or #error. 							When an Error occurs during compilation (as part of a do-it)							then the error should be visible. All other errors shall be invisible"							#(#missing #warning#unused #repeatedDefinition #illegal)								includes: each].			isInvalid ifFalse: [newStyles at: key put: value]].	styles := newStyles</body></methods><methods><class-id>Help.DitaMap</class-id> <category>accessing</category><body package="Help-UI">renderAsTopicOn: aDitaRenderer	"only render the title, the map's content is rendered by the sender already"	aDitaRenderer renderTitle: title</body></methods><methods><class-id>Help.DitaRenderer</class-id> <category>rendering</category><body package="Help-UI">renderDocument: aDitaDocument	aDitaDocument isNil ifTrue: [^self].	aDitaDocument renderAsTopicOn: self.	self indentWhile: 			[aDitaDocument navigationChildren do: [:each | each renderNormalOn: self]]</body><body package="Help-UI">renderGlossEntry: aDitaGlossaryEntry	self renderElement: aDitaGlossaryEntry xmlSource</body></methods><methods><class-id>Help.DitaRenderer</class-id> <category>utility</category><body package="Help-UI">renderTitle: aString	self renderInlineBlock: 			[self pushStyleAndFontNamed: self currentHeadingStyle				while: [self appendString: aString]]</body><body package="Help-UI">renderTopic: aTopic	| xml title body |	self pushDitaObject: aTopic		while: 			[xml := aTopic xmlSource.			title := xml realElements						detect: [:each | each isText not and: [each tag asString asLowercase = 'title']]						ifNone: [].			body := xml realElements						detect: [:each | each isText not and: [each tag asString asLowercase = 'body']]						ifNone: [].			self renderElement: title.			self renderElement: body]</body><body package="Help-UI">renderTopicRef: ditaTopicRef	| href title |	href := ditaTopicRef href.	title := ditaTopicRef title.	self indentWhile: 			[self renderBlock: 					[self						linkTo: [self openLink: href]						named: nil						while: [self appendString: title]]].	self		indentWhile: [ditaTopicRef children do: [:each | each renderOnRenderer: self]]</body></methods><methods><class-id>Kernel.CompiledCode</class-id> <category>user interface</category><body package="Help-UI">debugWithReceiver: doItReceiver inContext: doItContext	"Open the debugger on the first expression of myself."		| context guineaPig |	guineaPig := doItContext isNil				ifTrue: [[doItReceiver performMethod: self] newProcess]				ifFalse: [[doItReceiver performMethod: self with: doItContext] newProcess].	"Need to manually push copied values from the closure into the context			before stepping because they are not getting pushed during the simulation!"	context := guineaPig suspendedContext.	context receiver pushCopiedValues: context.	[context method == self] whileFalse: [context := context send].	guineaPig suspendedContext: context.	Notifier developmentNotifier		openOnProcess: guineaPig		interrupted: true		label: #DebugIt &lt;&lt; #pdp &gt;&gt; 'Debug It'</body></methods><methods><class-id>Help.DitaTopic</class-id> <category>accessing</category><body package="Help-UI">renderAsTopicOn: aRenderer	aRenderer renderTopic: self</body></methods><methods><class-id>Help.DitaTopic</class-id> <category>enumerating</category><body package="Help-UI">renderOnRenderer: aDitaRenderer	aDitaRenderer renderTopic: self</body></methods><methods><class-id>Help.DitaTopicRef</class-id> <category>enumerating</category><body package="Help-UI">renderOnRenderer: aDitaRenderer	aDitaRenderer renderTopicRef: self</body></methods><methods><class-id>Help.DitaGlossaryEntry</class-id> <category>accessing</category><body package="Help-UI">renderAsTopicOn: aRenderer	aRenderer renderGlossEntry: self</body></methods><methods><class-id>Help.HelpAutocompleteModel</class-id> <category>accessing</category><body package="Help-UI">acceptTopic: aString in: aDocumentTopic	&lt;accept: #topic&gt;	&lt;accept: #title&gt;	navigator navigateToDocument: aDocumentTopic</body><body package="Help-UI">presentTitle: aDocumentTopic in: source indices: indices	&lt;presentation: #title&gt;	^self		presentForSource: source		matches: indices		inScope: (navigator navigationChildForDocument: aDocumentTopic) parent				displayString</body><body package="Help-UI">presentTopic: aDocumentTopic in: source indices: indices	&lt;presentation: #topic&gt;	^self		presentForSource: source		matches: indices		inScope: aDocumentTopic displayString</body></methods><methods><class-id>Help.DitaDocumentViewer class</class-id> <category>interface specs</category><body package="Help-UI">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Unlabeled Canvas' 			#bounds: #(#{Graphics.Rectangle} 1017 489 1544 912 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 21 0 0 1 0 1 ) 					#name: #compoundWrapper 					#flags: 0 					#component: #compoundWrapper ) 				#(#{UI.InputEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 0 0 -200 1 21 0 ) 					#name: #breadCrump 					#flags: 0 					#isOpaque: true 					#model: #breadCrump 					#isWrapped: false 					#isReadOnly: true 					#showHiddenCharacters: false 					#showLineStriping: false 					#autoAccept: false 					#showInputCursor: true 					#showSelection: true ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Graphics.LayoutOrigin} -300 1 5 0 ) 					#name: #resolveFonts 					#model: #resolveFonts 					#helpText: 'If true, the resolved fonts will be rendered as hoverhelp over the strings' 					#label: 'Resolve Fonts' ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{UI.AlignmentOrigin} -200 1 5 0 0 0 ) 					#name: #showHiddenCharacters 					#model: #showHiddenCharacters 					#label: 'Hidden Chars' ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Graphics.LayoutOrigin} -100 1 5 0 ) 					#name: #showSource 					#model: #showSource 					#helpText: 'If true, the xml-source will be shown' 					#label: 'Show Source' ) ) ) )</body></methods><methods><class-id>Help.HelpAutocomplete</class-id> <category>actions - events</category><body package="Help-UI">cursorMoved: anEvent	&lt;state: #active key: #Left&gt;	&lt;state: #active key: #Up&gt;	&lt;state: #active key: #Right&gt;	&lt;state: #active key: #Down&gt;	self isAutocompleteModelMapped ifFalse: [self startSearch]</body><body package="Help-UI">mouseDown: anEvent	&lt;state: #inactive event: #Button1Down&gt;	&lt;state: #active event: #Button1Down&gt;		^self startSearch</body><body package="Help-UI">stateChanged: anEvent	&lt;state: #* event: #StateChange&gt;	(anEvent newState beginsWith: #selecting) ifTrue: [^self].	super stateChanged: anEvent</body></methods><methods><class-id>Help.HelpBrowser</class-id> <category>toolbar</category><body package="Help-UI">goBack	&lt;itemInMenu: #(#toolbar) position: 1.1&gt;	^(MenuItem forCommand: #goBackInHistory)		labelImage: Refactory.Browser.BrowserIcons arrowLeft;		helpText: [navigator nextBackLabel];		value: [navigator goBack];		submenu: [navigator backMenu];		enablement: [navigator canGoBack];		yourself</body><body package="Help-UI">goForward	&lt;itemInMenu: #(#toolbar) position: 1.2&gt;	^(MenuItem forCommand: #goForwardInHistory)		labelImage: Refactory.Browser.BrowserIcons arrowRight;		helpText: [navigator nextForwardLabel];		value: [navigator goForward];		submenu: [navigator forwardMenu];		enablement: [navigator canGoForward];		yourself</body><body package="Help-UI">toggleNavigation	&lt;itemInMenu: #(#toolbar) position: 2.1&gt;	^(MenuItem forCommand: #toggleNavigation)		labelImage: Refactory.Browser.BrowserIcons browseSystem;		helpText: 				[self isNavigationVisible					ifTrue: [#HideNavigation &lt;&lt; #help &gt;&gt; 'Hide Navigation']					ifFalse: [#ShowNavigation &lt;&lt; #help &gt;&gt; 'Show Navigation']];		value: [self privateToggleNavigation];		yourself</body></methods><methods><class-id>Help.HelpBrowser class</class-id> <category>interface specs</category><body package="Help-UI">findSpec	"Tools.UIPainter new openOnClass: self andSelector: #findSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Unlabeled Canvas' 			#min: #(#{Core.Point} 20 20 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 740 493 940 527 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.InputEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 7 0 -10 1 28 0 ) 					#name: #searchString 					#isOpaque: true 					#model: #searchString 					#isWrapped: false 					#isReadOnly: false 					#showHiddenCharacters: false 					#showLineStriping: false 					#autoAccept: false 					#showInputCursor: true 					#showSelection: true 					#defaultString: 'Search' ) ) ) )</body><body package="Help-UI">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'TopicViewer' 			#min: #(#{Core.Point} 20 20 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 2232 242 3049 785 ) 			#toolBar: #toolbarHolder ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TreeViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 300 0 0 1 ) 					#name: #topicsTree 					#flags: 15 					#model: #topicsTree 					#useModifierKeys: true 					#selectionType: #highlight 					#rootExpander: true ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} 301 0 0 0 304 0 0 1 ) 					#name: #splitter 					#horizontal: false 					#minAboveSize: 0 					#minBelowSize: 30 					#aboveWidgets: 'topicsTree' 					#belowWidgets: 'ditaDocumentViewer' ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 305 0 0 0 0 1 0 1 ) 					#name: #ditaDocumentViewer 					#flags: 0 					#majorKey: #{Help.DitaDocumentViewer} 					#minorKey: #windowSpec 					#clientKey: #ditaDocumentViewer ) ) ) )</body></methods><methods><class-id>Help.HelpAutocompleteSearch</class-id> <category>accessing</category><body package="Help-UI">documentSearch: aBlock	&lt;source: #always&gt;	| visited |	visited := IdentitySet new.	documents do: [:each | each suggestToAutocomplete: self visited: visited].	exactMatchFound := false.</body></methods><initialize><class-id>Help.DitaDocumentViewer</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>DitaTopic</name><environment>Help</environment><super>Help.DitaNamedGroup</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Help-Model</package></attributes></class><class><name>DitaGlossaryEntry</name><environment>Help</environment><super>Help.DitaTopic</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Help-Model</package></attributes></class><class><name>SourceCodeTheme</name><environment>Refactory.Browser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name source author website styles default </inst-vars><class-inst-vars></class-inst-vars><imports>			private Text2.*			</imports><category></category><attributes><package>Browser-SourceCodeUI</package></attributes></class><class><name>DitaRenderer</name><environment>Help</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>canvas tagMap currentStyle headingLevel trimSeparators lineIndent showFontNames keepWhiteSpace linkResolutionBlock ignoreEmptyText ditaObject beginningOfBlock insideLI elementStack </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Help-Model</package></attributes></class><class><name>DitaMap</name><environment>Help</environment><super>Help.DitaNamedGroup</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Help-Model</package></attributes></class><class><name>Model</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dependents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>DocumentAutocompleteModel</name><environment>UI</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>list gap defaultStyle defaultRightAlignedStyle styles matchingStyles views view openingSemaphore opened autocomplete positionTop positionBottom </inst-vars><class-inst-vars>presentations acceptors </class-inst-vars><imports>			Text2.*			</imports><category></category><attributes><package>UIBasics-Text2</package></attributes></class><class><name>SilentCompilerErrorHandler</name><environment>Kernel</environment><super>Kernel.CompilerErrorHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>editor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Support</category><attributes><package>System-Compiler-Support</package></attributes></class><class><name>DocumentAutocompleteSearch</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>search requireFirstLetterMatch prefix searchTime view word exactMatchFound </inst-vars><class-inst-vars>sources </class-inst-vars><imports></imports><category></category><attributes><package>UIBasics-Text2</package></attributes></class><class><name>DitaTopicRef</name><environment>Help</environment><super>Help.DitaNamedGroup</super><private>false</private><indexed-type>none</indexed-type><inst-vars>href type format </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Help-Model</package></attributes></class><class><name>Scanner</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>source mark prevEnd hereChar token tokenType saveComments currentComment buffer typeTable </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Public Access</category><attributes><package>System-Compiler-Public Access</package></attributes></class><class><name>CompiledCode</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>bytes </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>DocumentAutocomplete</name><environment>UI</environment><super>UI.ViewBehavior</super><private>false</private><indexed-type>none</indexed-type><inst-vars>view autocompleteModel searchProcess windowSemaphore searchSemaphore </inst-vars><class-inst-vars></class-inst-vars><imports>			private Text2.*			</imports><category></category><attributes><package>UIBasics-Text2</package></attributes></class></st-source>