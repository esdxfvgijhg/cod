<?xml version="1.0"?><st-source><!-- Name: LDM-FrameworkNotice: Copyright 1999-2017 Cincom Systems, Inc.  All rights reserved.Comment: LDM-Framework provides private support code necessary to browse, graph, or generate object mapping to a relational database. It is used by the Store and ObjectLens components.DbIdentifier: bear73DbTrace: 499360DbUsername: smichaelDbVersion: 8.3 - 1DevelopmentPrerequisites: #(#(#any 'Lens-Namespace' ''))HideSource: falsePackageName: LDM-FrameworkParcel: #('LDM-Framework')ParcelName: LDM-FrameworkPrerequisiteParcels: #(#('Lens-Namespace' ''))PrintStringCache: (8.3 - 1,smichael)SaveSource: trueVersion: 8.3 - 1Date: 1:40:47 PM March 17, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (mar17.2) of March 10, 2017 on March 17, 2017 at 1:40:47 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>LDMRelationship</name><environment>Lens</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name description reverse </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-Tools-Browsing</category><attributes><package>LDM-Framework</package></attributes></class><comment><class-id>Lens.LDMRelationship</class-id><body>This class is private to the implementation of the ObjectLens.  Users should not use this class directly and should not subclass it.Represents a relationship between elements. The simplest relationships are implemented by just sending a message to the elements. More complex relationships are implemented as a combination of other relationships. Subclasses implement the most common opperators for combining relationships.The combination of relationships can also be done programatically at the level of the methods implementing the relationships. That seems to be the most useful way to do it when the perspectives are built also programatically and the user has no control over the relationships. In a more dynamic schema, the relationships could be constructed based on the simple ones by combinations using the operators.Note that the NOT operator (which would make the set algebraicly complete) is not provided. The reason for that is that the NOT operator would require the knowledge and the existance of a Universe of elements, which is in general not known. It could be implemented for a particular kind of elements if it is possible to compute the universe in reasonable time.Instance Variables:	name	&lt;Symbol&gt; the name of the relationship	description	&lt;String&gt; a description of the relationship. This description can be used in tools that work with general perspectives and refer to the relationships according to what is actually found in the perspective. Most tools using this browsers have their own hard-coded menus and explanations so they do not require descriptions in the relationships.	reverse	&lt;LDMRelationship&gt; the reverse relationship. It may be set or computed. Sometimes the reverse relationship is not simple or not even known. Note that the reverse relationship is not the Negation of the relationship. For example, the reverse of 'calls' is 'is called by', and NOT 'does not call'.Class Variables:	Relationships	&lt;Dictionary&gt; Hold onto all the known relationships. This is a global context for relationships. Perhaps it would make sense to have the relationships been local to the context where they are used.Subclasses must implement the following messages	instance protocol		computing			computeReverse'</body></comment><class><name>LDMHighOrderRel</name><environment>Lens</environment><super>Lens.LDMRelationship</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-Tools-Browsing</category><attributes><package>LDM-Framework</package></attributes></class><comment><class-id>Lens.LDMHighOrderRel</class-id><body>This class is private to the implementation of the ObjectLens.  Users should not use this class directly and should not subclass it.A relationship composed of other relationships. The composition rules are given by the specific subclasses.'</body></comment><class><name>LDMMonadicRel</name><environment>Lens</environment><super>Lens.LDMHighOrderRel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>r1 </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-Tools-Browsing</category><attributes><package>LDM-Framework</package></attributes></class><comment><class-id>Lens.LDMMonadicRel</class-id><body>This class is private to the implementation of the ObjectLens.  Users should not use this class directly and should not subclass it.A relationship can be defined in terms of a more basic one. A typical example is the transitive closure, which results from the application of a relationship any number of times.Instance Variables:	r1 &lt;LDMRelationship&gt;  the basic relationship'</body></comment><class><name>LDMNonReflexiveRel</name><environment>Lens</environment><super>Lens.LDMMonadicRel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-Tools-Browsing</category><attributes><package>LDM-Framework</package></attributes></class><comment><class-id>Lens.LDMNonReflexiveRel</class-id><body>This class is private to the implementation of the ObjectLens.  Users should not use this class directly and should not subclass it.The same as the basic relationship it is composed of, but it doesn't allow for an element to be related to itself.'</body></comment><class><name>LDMElementView</name><environment>Lens</environment><super>UI.CompositeView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dependents element hasIn hasOut povIcons firstPovIconX touchFlag selected label recycle </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-Tools-Components</category><attributes><package>LDM-Framework</package></attributes></class><comment><class-id>Lens.LDMElementView</class-id><body>This class is private to the implementation of the ObjectLens.  Users should not use this class directly and should not subclass it.LDMElementView is the graphical representation of an element, It holdsthe element's label, the in and out arrows and any perspective icon attachedto the element.Instance Variables:	hasIn &lt;nil | Boolean&gt; 		nil ::= doesn't have incoming (to the left) relationships		false ::= all the incoming relationships are already open in the graph		true ::= there are incoming relationships not yet open in the graph	hasOut &lt;nil | Boolean&gt; 		as hasIn but for outgoing (to the right) relationships	povIcons &lt;OrderedCollection of: CYPovIconView&gt; The perspective icons attached	firstPovIconX &lt;Number&gt; The X position of the first POV icon attached to the element		 (for drawing purposes)	touchFlag &lt;Boolean&gt; when created or reused this flag is reset, so unused ones		can be released	selected &lt;ValueHolder on: Boolean&gt; true iff the element is selected	label &lt;Wrapper on: Label&gt; the visual component for the element's label	recycle &lt;Boolean&gt; true iff the elementView is to be used again and hence shouldn't		be released even if it's container is released'</body></comment><class><name>LDMVariable</name><environment>Lens</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>elements arcsOnSide </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-Tools-Browsing</category><attributes><package>LDM-Framework</package></attributes></class><comment><class-id>Lens.LDMVariable</class-id><body>This class is private to the implementation of the ObjectLens.  Users should not use this class directly and should not subclass it.This class represents one variable in a perspective definition and isused in computing initial displayable graphs as well as updating displayable graphs as the user opens relationships.A Variable is a holder for elements. When computing the graphs, theelements in this variable represent the computed set of variables thatcorrespond to this variable. When elements are added to a variablethey may cause other elements to be added to the variables at theother side of the relationships connected to this variable.Instance Variables:	elements		&lt;Set of: Object&gt;	The elements that the variable holds	arcsOnSide 		&lt;Array of: Collection of: Arc&gt;	The Arcs outgoing from this variable one Collection per side. This was done as an array to allow for iterations on the 'sides' of a variable'</body></comment><class><name>LDMFocusVariable</name><environment>Lens</environment><super>Lens.LDMVariable</super><private>false</private><indexed-type>none</indexed-type><inst-vars>focusNumber </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-Tools-Browsing</category><attributes><package>LDM-Framework</package></attributes></class><comment><class-id>Lens.LDMFocusVariable</class-id><body>This class is private to the implementation of the ObjectLens.  Users should not use this class directly and should not subclass it.Represent an LDMVariable that is initialized with the set of elements in the focus.The focus number is an interesting feature not in use in any of the applications, nor supported by the tools, but may be useful nevertheless. The idea is that there may be more than one focus set, in that case, the different numbered focus variables will get the numbered foci. This could be useful for a  browser where there are two sets of elements that make sense for starting relationships. One example could be a browser where the focus is a group of methods and a class, the browser shows the call graph from the methods to methods included in the class.The focusNumber is not required for any of the applications currently using this browsing system.Instance Variables:	focusNumber &lt;Number&gt; the index of this focus variable'</body></comment><class><name>LensBrowsingToolModel</name><environment>Lens</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-Tools-Support</category><attributes><package>LDM-Framework</package></attributes></class><comment><class-id>Lens.LensBrowsingToolModel</class-id><body>This class is private to the implementation of LensGraphView.  Users should not use this class directly and should not subclass it.'</body></comment><class><name>LDMPerspective</name><environment>Lens</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>rows labelHints relDesc name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-Tools-Browsing</category><attributes><package>LDM-Framework</package></attributes></class><comment><class-id>Lens.LDMPerspective</class-id><body>This class is private to the implementation of the ObjectLens.  Users should not use this class directly and should not subclass it.Instance variables:	rows &lt;List of: Array&gt; see the class method 'initialize' for an explanation	labelHints &lt;List of: Symbol&gt; hints to be used in the construction of element views. For example, a perspective may want the labels to be as short as possible, then it may have as hint #small. The hint is then passed to the elements which can cooperate (or not) in doing what the hint was meant to mean. The hints are the mechanism for displaying the same element in different ways according to the perspective.	relDesc &lt;List of: Array&gt; the description of the relationships, for each relationship that appears in the perspective there is an indication of the width of the line, the color and whteher it is displayed or not.	name &lt;Symbol&gt; the name of the perspective - the name should be unique in the system'</body></comment><class><name>LensGraphView</name><environment>Lens</environment><super>Lens.LensBrowsingToolModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bm focus perspective </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-Tools-Support</category><attributes><package>LDM-Framework</package></attributes></class><comment><class-id>Lens.LensGraphView</class-id><body>This class is private to the implementation of the ObjectLens.  Users should not use this class directly and should not subclass it.This class is used as a subCanvas in any lens application using graphical browsers. It encapsulate the browser's capabilities so they are really easy to integrate into any application.This class defines some utility methods to isolate the world of the browsers from the Lens tools.'</body></comment><class><name>LDMDiadicRel</name><environment>Lens</environment><super>Lens.LDMHighOrderRel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>r1 r2 </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-Tools-Browsing</category><attributes><package>LDM-Framework</package></attributes></class><comment><class-id>Lens.LDMDiadicRel</class-id><body>This class is private to the implementation of the ObjectLens.  Users should not use this class directly and should not subclass it.A relationship composed of two other relationships.Instance variables:	r1 &lt;LDMRelationship&gt; the first composing relationship	r2 &lt;LDMRelationship&gt; the second one'</body></comment><class><name>LDMComposedRel</name><environment>Lens</environment><super>Lens.LDMDiadicRel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-Tools-Browsing</category><attributes><package>LDM-Framework</package></attributes></class><comment><class-id>Lens.LDMComposedRel</class-id><body>This class is private to the implementation of the ObjectLens.  Users should not use this class directly and should not subclass it.Represents relationships that are formed by computing one relationship and then the other relationship on the result set. For example, the relationship between a method and all the classes that contain methods it calls can be represented by the relationship defined as the composition between callsRel and isContainedInRel.'</body></comment><class><name>LDMAbstractVisualBuilder</name><environment>Lens</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>composite graph nodeDict spacing viewModel visualComponentBlock visualConnectionBlock midPoint nodeExtent builder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-Tools-Browsing</category><attributes><package>LDM-Framework</package></attributes></class><comment><class-id>Lens.LDMAbstractVisualBuilder</class-id><body>This class is private to the implementation of the ObjectLens.  Users should not use this class directly and should not subclass it.Instance Variables:	composite &lt;LDMGraphCompositeView&gt; the composite where the view is built	graph &lt;LDMGraph&gt; the graph for which the view is built	nodeDict &lt;IdentityDictionary&gt; (key: element, value: LDMGraphElementWrapper) the dictionary where for each element we have encountered so far. AgraphWrapper is associated so it can be reused. The wrapper is used to relocate the element's view inside the graphs view and to compute the graph geometry	spacing &lt;Point&gt; the spacing between elements in the graph view	viewModel &lt;LDMBrowserModel&gt; the browser model which is used as the model for all the views	visualComponentBlock &lt;BlockClosure&gt; used to create element views for the elements	visualConnectionBlock &lt;BlockClosure&gt; used to create views for relationships (arcs)	midPoint &lt;Number&gt;	nodeExtent &lt;Number&gt;	builder &lt;UIBuilder&gt; The builder used to build widgets from specs (element views can construct their label from specs)Subclasses must implement the following messages	instance protocol		layout			layout		build			internalBuild:depth:'</body></comment><class><name>LDMGraphBuilder</name><environment>Lens</environment><super>Lens.LDMAbstractVisualBuilder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mins orientation columnPositions hwyPositions channelOffsets channelsPending buildPath </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-Tools-Browsing</category><attributes><package>LDM-Framework</package></attributes></class><comment><class-id>Lens.LDMGraphBuilder</class-id><body>This class is private to the implementation of the ObjectLens.  Users should not use this class directly and should not subclass it.Instance Variables:	mins &lt;Array of: Number&gt;	orientation &lt;Symbol&gt; only #horizontal is in use, #vertical only partially works. Indicate what is the orientation of the graph view	columnPositions &lt;Array of: Number&gt; the position of the different columns	hwyPositions &lt;Array of: Number&gt; the positions of the highways	channelOffsets &lt;IdentityDictionary&gt;	channelsPending &lt;Array of: OrderedCollection&gt;	buildPath &lt;OrderedCollection&gt; collection of element wrappers'</body></comment><class><name>LDMWidgetController</name><environment>UI</environment><super>UI.WidgetController</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>LDM-Framework</package></attributes></class><class><name>LDMFirstOrderRel</name><environment>Lens</environment><super>Lens.LDMRelationship</super><private>false</private><indexed-type>none</indexed-type><inst-vars>token </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-Tools-Browsing</category><attributes><package>LDM-Framework</package></attributes></class><comment><class-id>Lens.LDMFirstOrderRel</class-id><body>This class is private to the implementation of the ObjectLens.  Users should not use this class directly and should not subclass it.First order relationships are not built based on any other relationship. Computes a relationship by delegating the question to the lement. Subclases may further refine the answers by applying some particular logic to the results.Instance Variables:	token &lt;Symbol&gt; the token to be passed to the elements when computing the relationship. According to the token the element decides which set of related elements it returns. One typical implementation at the element side is to send the token to itself as amessage and return the result. This is useful as a token because this way it can be sent to any object, and if the object does not implement the relationship, an empty set will be returned, which is the right default.'</body></comment><class><name>LDMRelationsGenerator</name><environment>Lens</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>variables graph userOpensArcs userOpensGraph </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-Tools-Components</category><attributes><package>LDM-Framework</package></attributes></class><comment><class-id>Lens.LDMRelationsGenerator</class-id><body>This class is private to the implementation of the ObjectLens.  Users should not use this class directly and should not subclass it.'</body></comment><class><name>LDMBrowserSpec</name><environment>Lens</environment><super>UI.MenuComponentSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-Tools-Browsing</category><attributes><package>LDM-Framework</package></attributes></class><comment><class-id>Lens.LDMBrowserSpec</class-id><body>This class is private to the implementation of the ObjectLens.  Users should not use this class directly and should not subclass it.BrowsertSpec describes the layout and external decoration of a browser view, which is expected to be supplied by the user's application at interface building time.LDMBrowserSpec is not accessible from the palette. It is only used internally, to create new windowSpecs having this spec in them you have to copy the spec from an existing windowSpec.See also comments on NamedSpecNo Instance Variables'</body></comment><class><name>LDMSelectionService</name><environment>Lens</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>viewsValue performersValue </inst-vars><class-inst-vars>GlobalInstance </class-inst-vars><imports></imports><category>Lens-Private-Tools-Browsing</category><attributes><package>LDM-Framework</package></attributes></class><comment><class-id>Lens.LDMSelectionService</class-id><body>This class is private to the implementation of the ObjectLens.  Users should not use this class directly and should not subclass it.I keep track of the selected views and can propagate request for deselection.I also provide convenience protocol to send messages to the performers of the views.Instance Variables	viewsValue 	&lt;ValueModel on: OrderedCollection of: views&gt;	currently selected views	performersValue &lt;BlockValue&gt; 	computes the performers corresponding to the selected views'</body></comment><class><name>LDMGraph</name><environment>Lens</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>relationships </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-Tools-Browsing</category><attributes><package>LDM-Framework</package></attributes></class><comment><class-id>Lens.LDMGraph</class-id><body>This class is private to the implementation of the ObjectLens.  Users should not use this class directly and should not subclass it.Instance Variables	relationships &lt;IdentityDictionary&gt; The keys are all the elements present in the graph, the values are for each element a pair of dictionaries, each one of them has as key a relationship and as value the identitySet of elements related through the relationship to the first element.'</body></comment><class><name>LDMAbstractBody</name><environment>Lens</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>foa locked missedUpdate viewModel </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-Tools-Browsing</category><attributes><package>LDM-Framework</package></attributes></class><comment><class-id>Lens.LDMAbstractBody</class-id><body>This class is private to the implementation of the ObjectLens.  Users should not use this class directly and should not subclass it.The manager of the graph of displayed relationships. There are many ways the display of the graph could be implemented. For example, a body could be an editor for the text related to the elements, or another body could be a debugger. The typical "graph" browser is implemented by LDMRelationsBody.The graph displayed can be manipulated by oppening and closing relationship. In addition there are facilities to manage the update of graphs when changes happen in the elements themselves. There are two kinds of changes, changes in the label of one or more elements or changes in the relationships between the elements. This class provides the protocol for managing those changes and making them reflect into the graph. Since the idea behind the graphs was that they should not change for each small change in the elements, the graph does not depend on the elements themselves, but on a 'dataBase' defined by the element, then the 'dataBase' notifies of changes when the graphs should be updated.For the current use of the graphs it could make sense to implement a graph update mechanism that uses the regular dependency and change notification mechanisms.Updating a graph is not an easy task, you want to keep relationships that were open open, you want to close (and remove) relationships that do not exist any more. The problems appear inpoints like 'what to do with a new relationship that appear where the user opened all of the outgoing relationships?' - currently this is handled by indicating that there is a new relationship. Perhaps a more intuitive solution would open that relationship automatically; in order to implement that, the graph would have to remember what elements have all their relationships open for both directions.NOTE: The implementation of change notification was geared towards the first usage of this browsing model. The current usage is much more geard towards using the regular Smalltalk change notification.Instance Variables:	foa	&lt;Set of: elements&gt; the focus of the graph (Focus Of Attention)	locked	&lt;Boolean&gt; whether the view is locked. If locked, no update in the underlying graph is reflected in the view. This is useful for the cases where the developer want the user to have the option to leave obsolete graphs open, which is useful for comparisons of 'before' and 'after'.	missedUpdate	&lt;Array&gt; if it lost an update from the database because of being locked the update sender and symbol are stored here	viewModel	&lt;LDMBrowserModel&gt; the browser model associated with this bodySubclasses must implement the following messages	instance protocol		accessing			focus:			perspective:		private			rebuild'</body></comment><class><name>LDMRelationsBody</name><environment>Lens</environment><super>Lens.LDMAbstractBody</super><private>false</private><indexed-type>none</indexed-type><inst-vars>composite generator graph canOpen visualBuilder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-Tools-Browsing</category><attributes><package>LDM-Framework</package></attributes></class><comment><class-id>Lens.LDMRelationsBody</class-id><body>This class is private to the implementation of the ObjectLens.  Users should not use this class directly and should not subclass it.The graph is displayed as a real graph, with elements represented by nodes in the graph and relationships represented by arcs between them.Instance Variables:		composite &lt;LDMGraphCompositeView&gt; the composite where the graph is drawn	generator  &lt;LDMRelationsGenerator&gt; used to generate the relationships. Holds the graph and the user opens graph	graph &lt;LDMGraph&gt; the graph of elements and relationships	canOpen &lt;LDMGraph&gt; the graph of the relationships that the user can open	visualBuilder &lt;LDMAbstractVisualBuilder&gt; the builder helps in constructing the graph to be displayed'</body></comment><class><name>LDMAbstractElementWrapper</name><environment>Lens</environment><super>Graphics.TranslatingWrapper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>depth pass children isRoot </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-Tools-Components</category><attributes><package>LDM-Framework</package></attributes></class><comment><class-id>Lens.LDMAbstractElementWrapper</class-id><body>This class is private to the implementation of the ObjectLens.  Users should not use this class directly and should not subclass it.'</body></comment><class><name>LDMTransitiveClosureRel</name><environment>Lens</environment><super>Lens.LDMMonadicRel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-Tools-Browsing</category><attributes><package>LDM-Framework</package></attributes></class><comment><class-id>Lens.LDMTransitiveClosureRel</class-id><body>This class is private to the implementation of the ObjectLens.  Users should not use this class directly and should not subclass it.Computes the transitive closure of the application of a relationship. Can be quite expensive if computing a relationship takes any significant amount of time.'</body></comment><class><name>LDMOrRel</name><environment>Lens</environment><super>Lens.LDMDiadicRel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-Tools-Browsing</category><attributes><package>LDM-Framework</package></attributes></class><comment><class-id>Lens.LDMOrRel</class-id><body>This class is private to the implementation of the ObjectLens.  Users should not use this class directly and should not subclass it.The conjunction between two relationships. The relationship includes all the pairs that comply with either one of the basic relationships.'</body></comment><class><name>LDMNodeChild</name><environment>Lens</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>rel node </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-Tools-Browsing</category><attributes><package>LDM-Framework</package></attributes></class><comment><class-id>Lens.LDMNodeChild</class-id><body>This class is private to the implementation of the ObjectLens.  Users should not use this class directly and should not subclass it.This class was created to hold an element and a relationship together. Initially, only the element was kept as the kid of another element in a graph, but later, when added flexibility was needed, the relationship indicated whether it should be dispayed, and in what color, therefore there was the need for holding onto the relationship that brought the child element.'</body></comment><class><name>LDMElementViewController</name><environment>Lens</environment><super>UI.ControllerWithMenu</super><private>false</private><indexed-type>none</indexed-type><inst-vars>charged </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-Tools-Components</category><attributes><package>LDM-Framework</package></attributes></class><comment><class-id>Lens.LDMElementViewController</class-id><body>This class is private to the implementation of the ObjectLens.  Users should not use this class directly and should not subclass it.I redefine drag and drop functionality'</body></comment><class><name>LDMCompositeView</name><environment>Lens</environment><super>UI.CompositeView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-Tools-Components</category><attributes><package>LDM-Framework</package></attributes></class><comment><class-id>Lens.LDMCompositeView</class-id><body>This class is private to the implementation of the ObjectLens.  Users should not use this class directly and should not subclass it.'</body></comment><class><name>LDMVisualTreeConnection</name><environment>Lens</environment><super>Graphics.VisualComponent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>orientation parent children preferredBounds </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-Tools-Components</category><attributes><package>LDM-Framework</package></attributes></class><comment><class-id>Lens.LDMVisualTreeConnection</class-id><body>This class is private to the implementation of the ObjectLens.  Users should not use this class directly and should not subclass it.'</body></comment><class><name>LDMArrowView</name><environment>Lens</environment><super>UI.LabeledBooleanView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-Tools-Components</category><attributes><package>LDM-Framework</package></attributes></class><comment><class-id>Lens.LDMArrowView</class-id><body>This class is private to the implementation of the ObjectLens.  Users should not use this class directly and should not subclass it.'</body></comment><class><name>LDMWidgetTracker</name><environment>UI</environment><super>UI.WidgetTracker</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>LDM-Framework</package></attributes></class><class><name>LDMBrowserModel</name><environment>Lens</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>body focusHolder perspectiveHolder attributes selectionService application visualBuilderClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-Tools-Browsing</category><attributes><package>LDM-Framework</package></attributes></class><comment><class-id>Lens.LDMBrowserModel</class-id><body>This class is private to the implementation of the ObjectLens.  Users should not use this class directly and should not subclass it.This class is the model for browser body views.  It holds and controls a body which has and/or computes the contents of the view.  This class updates thebody whenever the focus or perspective changes.  Instance Variables:	body 				&lt;LDMAbstractBody&gt;		The view computation body	focusHolder 			&lt;ValueModel on: IdentitySet&gt;  (or something that behaves like a Set)	perspectiveHolder 	&lt;ValueModel on: LDMPerspective&gt;	attributes 		&lt;IdentityDictionary - keys are relationships, values are relationship attributes. They are used to decide on whether to display a relationship, what color it is, etc. The values are taken from the perspective, they could conceivably be changed programatically.	selectionService 	&lt;LDMSelectionService&gt; Can be shared with other models or the whole system. Whenever VisualWorks is made to use the host machine selection service, it is possible that changes will be required here'</body></comment><class><name>LDMBrowserBodyView</name><environment>Lens</environment><super>UI.CompositeView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>decorator </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-Tools-Components</category><attributes><package>LDM-Framework</package></attributes></class><comment><class-id>Lens.LDMBrowserBodyView</class-id><body>This class is private to the implementation of the ObjectLens.  Users should not use this class directly and should not subclass it.'</body></comment><class><name>LDMIndentedListBuilder</name><environment>Lens</environment><super>Lens.LDMAbstractVisualBuilder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bottom referenceConnections </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-Tools-Browsing</category><attributes><package>LDM-Framework</package></attributes></class><comment><class-id>Lens.LDMIndentedListBuilder</class-id><body>This class is private to the implementation of the ObjectLens.  Users should not use this class directly and should not subclass it.NOTE that the algorithms here work only if the graph is a true tree. If there arecycles or multiple paths from the root to any leave, the indented list will not be correctly displayed.Instance variables:	bottom &lt;Number&gt;	referenceConnections &lt;IdentityDictionary&gt; not in use'</body></comment><class><name>LDMElementProxy</name><environment>Lens</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>element context </inst-vars><class-inst-vars>Elements </class-inst-vars><imports></imports><category>Lens-Private-Tools-Browsing</category><attributes><package>LDM-Framework</package></attributes></class><comment><class-id>Lens.LDMElementProxy</class-id><body>This class is private to the implementation of the ObjectLens.  Users should not use this class directly and should not subclass it.A proxy is used when it is important not to change the elements to be displayedin a browser or when the elements to be displayed are of several different kinds.There are two ways in which the proxies can be remembered and accessed whena proxy for the same element is needed. The first way is to use the 'Elements' classinstance variable. The second is to use the 'context'.If Using the Elements class instance variable extra care should be taken because by virtue of being in this dictionary they will not be garbage collected. An implementation with weak dictionaries could have been better.Class instance variables:	Elements	&lt;Dictionary&gt; keeps the instances of myself, the		elements are the keysInstance Variables:	element &lt;Object&gt; the element we are wrapping	context  &lt;Dictionary | Object&gt; the context where the proxies are kept associated with the elements so the proxy for a specific element can be found'</body></comment><class><name>LDMReversingElementProxy</name><environment>Lens</environment><super>Lens.LDMElementProxy</super><private>false</private><indexed-type>none</indexed-type><inst-vars>related </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-Tools-Browsing</category><attributes><package>LDM-Framework</package></attributes></class><comment><class-id>Lens.LDMReversingElementProxy</class-id><body>This class is private to the implementation of the ObjectLens.  Users should not use this class directly and should not subclass it.This proxy keeps track of the elements that relate to us, so the reverse relationship can be computed. Note that the reverse relationship will be correct only for those elements for which the forward relationship has already been computed. That is, this will not work to find all the 'callers' on a function, if the calling functions were not asked for the functions they call.Note that the implementation of this class makes use of the 'Elements' dictionary in the class. This is done by virtue of calling 'self class at:'.Instance Variables:	related &lt;Dictionary&gt; indexed by the relationship. Keeps a Set for each relationship. In the set there are all the KNOWN elements that relate to our element through the relationship'</body></comment><class><name>LDMSpecialRel</name><environment>Lens</environment><super>Lens.LDMFirstOrderRel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>evaluationBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-Tools-Browsing</category><attributes><package>LDM-Framework</package></attributes></class><comment><class-id>Lens.LDMSpecialRel</class-id><body>This class is private to the implementation of the ObjectLens.  Users should not use this class directly and should not subclass it.Gives the flexibility of defining a relationship outside the elements themselves. The compuation of the relationship is done in a block which can be arbitrary in its computation.Instance Variables:	evaluationBlock &lt;BlockClosure&gt; performs the computation of the relationship. The single argument is the element for which the relationship is evaluated'</body></comment><class><name>LDMGraphCompositeView</name><environment>Lens</environment><super>Lens.LDMCompositeView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-Tools-Components</category><attributes><package>LDM-Framework</package></attributes></class><comment><class-id>Lens.LDMGraphCompositeView</class-id><body>This class is private to the implementation of the ObjectLens.  Users should not use this class directly and should not subclass it.'</body></comment><class><name>LDMBroomConnection</name><environment>Lens</environment><super>Lens.LDMVisualTreeConnection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder refreshArea model </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-Tools-Components</category><attributes><package>LDM-Framework</package></attributes></class><comment><class-id>Lens.LDMBroomConnection</class-id><body>This class is private to the implementation of the ObjectLens.  Users should not use this class directly and should not subclass it.This class is the visual connection between a parent node and itchildren.  It is represented as a broom shape.  That is, a broomhandle going out to a nexus and the connection to the childrengoinf from here.  Recursion arcs backward.  The implementationis based on the column and highway model.builder 			&lt;LDMGraphBuilder&gt;		For getting highway inforefreshArea 	&lt;Rectangle|nil&gt;		If this rectangle gets damaged 										we want to refresh.  If nil										alway refresh.'</body></comment><class><name>LDMListElementWrapper</name><environment>Lens</environment><super>Lens.LDMAbstractElementWrapper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>reference </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-Tools-Components</category><attributes><package>LDM-Framework</package></attributes></class><comment><class-id>Lens.LDMListElementWrapper</class-id><body>This class is private to the implementation of the ObjectLens.  Users should not use this class directly and should not subclass it.'</body></comment><class><name>LDMGraphElementWrapper</name><environment>Lens</environment><super>Lens.LDMAbstractElementWrapper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-Tools-Components</category><attributes><package>LDM-Framework</package></attributes></class><comment><class-id>Lens.LDMGraphElementWrapper</class-id><body>This class is private to the implementation of the ObjectLens.  Users should not use this class directly and should not subclass it.'</body></comment><class><name>LDMLimitingRel</name><environment>Lens</environment><super>Lens.LDMMonadicRel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>limitingBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-Tools-Browsing</category><attributes><package>LDM-Framework</package></attributes></class><comment><class-id>Lens.LDMLimitingRel</class-id><body>This class is private to the implementation of the ObjectLens.  Users should not use this class directly and should not subclass it.The relationship is defined as a restricted version of a basic relationship.A better implementation would also give the element for whom the relationship is being composed to the limiting block.Instance Variable:	limitingBlock &lt;BlockClosure&gt; the single argument block to be used to determine whether an element should be included in the resulting set or not.'</body></comment><class><name>LDMCompositeViewController</name><environment>Lens</environment><super>UI.ControllerWithMenu</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-Tools-Components</category><attributes><package>LDM-Framework</package></attributes></class><comment><class-id>Lens.LDMCompositeViewController</class-id><body>This class is private to the implementation of the ObjectLens.  Users should not use this class directly and should not subclass it.I add the menu actions '</body></comment><class><name>LDMProtoMapBuilder</name><environment>Lens</environment><super>Lens.LDMGraphBuilder</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-Tools-Browsing</category><attributes><package>LDM-Framework</package></attributes></class><comment><class-id>Lens.LDMProtoMapBuilder</class-id><body>This class is private to the implementation of the ObjectLens.  Users should not use this class directly and should not subclass it.This is a specialized builder, specifically dedicated to displaying graphs with database columns. After the graph is computed and everything built, it reallocates the columns so they are all in one column. This way they look nice in the mapping tool graph.This is a good example of how the graph rendering can be easily modified to suit specific requirements that do not fit into the parameters to the graph rendering algorithms.'</body></comment><class><name>LDMArc</name><environment>Lens</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>varOnSide isRestrictedOnSide relationship activePhases generator </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-Tools-Browsing</category><attributes><package>LDM-Framework</package></attributes></class><comment><class-id>Lens.LDMArc</class-id><body>This class is private to the implementation of the ObjectLens.  Users should not use this class directly and should not subclass it.The class represents an Arc in the perspective definition graph and is used in computing initial displayable graphs as well as updating displayable graphs as the user opens relationships.Instance Variables:	varOnSide &lt;Array of: Variable&gt; By side. The two variables on either side of the arc	isRestrictedOnSide  &lt;Array of: Boolean&gt; By side. Holds for each side whether there is a  restriction on that side. 	relationship &lt;LDMRelationship&gt; Type of relationship that this arc represents.	activePhases &lt;Set of: Symbol&gt; Phases during which this arc operates (initial, userOpens, automatic...)	generator &lt;LDMRelationsGenerator&gt;'</body></comment><shared-variable><name>Perspectives</name><environment>Lens.LDMPerspective</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>LDM-Framework</package></attributes></shared-variable><shared-variable><name>ColumnNames</name><environment>Lens.LDMPerspective</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>LDM-Framework</package></attributes></shared-variable><shared-variable><name>EmptyImage</name><environment>Lens.LDMArrowView</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>LDM-Framework</package></attributes></shared-variable><shared-variable><name>FullImage</name><environment>Lens.LDMArrowView</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>LDM-Framework</package></attributes></shared-variable><shared-variable><name>CachedBounds</name><environment>Lens.LDMArrowView</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>LDM-Framework</package></attributes></shared-variable><shared-variable><name>Relationships</name><environment>Lens.LDMRelationship</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>LDM-Framework</package></attributes></shared-variable><methods><class-id>Lens.LDMRelationship</class-id> <category>initialize release</category><body package="LDM-Framework">reset	"The reverse relationship can be a symbol or the relationship itself. If it is a symbol, then the relationship is searched for and the symbol is replaced. If the relationship is not found, then nil is used instead, the reverse will be computed if needed."	reverse isSymbol ifTrue: [reverse := self class at: reverse ifAbsent: [nil]]</body></methods><methods><class-id>Lens.LDMRelationship</class-id> <category>accessing</category><body package="LDM-Framework">description	^description</body><body package="LDM-Framework">description: aString	description := aString</body><body package="LDM-Framework">name	^name</body><body package="LDM-Framework">name: nm	name := nm.	^self</body><body package="LDM-Framework">r1	"Used only when building perspectives. A more general UI would ask how many relationships the relationship is composed of"	^nil</body><body package="LDM-Framework">r2	"Used only when building perspectives. A more general UI would ask how many relationships the relationship is composed of"	^nil</body><body package="LDM-Framework">reverse	"Returns the reverse relationship. If it is currently nil, then it computes it"	reverse isNil ifTrue: [self computeReverse].	reverse isSymbol ifTrue: [reverse := self class at: reverse].	^reverse</body><body package="LDM-Framework">reverse: rr	"rr is either the reverse relationship itself or its name" 	reverse := rr</body><body package="LDM-Framework">token	"Used only when building perspectives. A more general UI would ask if the relationship has a token"	^nil</body></methods><methods><class-id>Lens.LDMRelationship</class-id> <category>computing</category><body package="LDM-Framework">computeReverse	"Computes the reverse relationship"	^self subclassResponsibility</body><body package="LDM-Framework">relatedTo: el	"returns all the elements related to el through myself. This is the main method	for the computation of a relationship. Subclasses override it to implement their	own computation"	^IdentitySet new</body></methods><methods><class-id>Lens.LDMRelationship</class-id> <category>printing</category><body package="LDM-Framework">printOn: aStream 	"For debugging purposes. Prints the name of the relationship"	aStream nextPutAll: 'Rel'.	aStream nextPut: $&lt;.	aStream nextPutAll: name.	aStream nextPut: $&gt;.</body><body package="LDM-Framework">storeOn: aStream	"Before storing in the stream transform the reference to the reverse relationship into a symbol. Reassign the reverse relationship after storing. This way an infinite loop is avoided and the references to relationships are stored as symbols"	| r |	r := reverse.	r notNil ifTrue: [reverse := r name asSymbol].	super storeOn: aStream.	reverse := r</body></methods><methods><class-id>Lens.LDMRelationship</class-id> <category>private</category><body package="LDM-Framework">fromLiteralArrayEncoding: anArray	"The literal array encoding includes the names of the messages that need to be sent to reconstruct the Relationship. This method would probably make sense in Object"	2 to: anArray size by: 2 do:		 [:i | self perform: (anArray at: i) with: (anArray at: i + 1)].	LDMRelationship at: name asSymbol put: self</body><body package="LDM-Framework">literalArrayEncoding	"encode the name, description and the reverse relationship as a symbol"	| oc |	oc := OrderedCollection new.	oc add: self class fullyQualifiedReference.	oc add: #name:.	oc add: name.	oc add: #description:.	oc add: description.	oc add: #reverse:.	reverse isNil		ifTrue: [oc add: nil]		ifFalse: [oc add: reverse name asSymbol].	^oc</body></methods><methods><class-id>Lens.LDMRelationship class</class-id> <category>class initialization</category><body package="LDM-Framework">initialize	"Relationship initialize"	"Creates the relationships that will be used anywhere in the application. An 	additional class method is provided in order to add relationships to this 	dictionary"	Relationships := IdentityDictionary new.	LDMSpecialRel initialize.</body><body package="LDM-Framework">initializeRelationships	"Creates and returns a list of relationships. The creation of the relationships adds them into the relationships dictionary. Only first order relationships are created here. 	The literal array includes: 		name - the name of the relationship (used in menus)		description - a longer description than the name		token - the symbol sent to the elements to tell them to compute the relationship. By convention it is &lt;name&gt;Rel, the reverse relationship is &lt;name&gt;RRel	Reverse relationships should be created to have their name and description correct."	"self initializeRelationships"	^List new	add: #(#LDMFirstOrderRel #name: 'calls' #description: 'calls' #reverse: nil #token: #callsRel ) decodeAsLiteralArray;	add: #(#LDMFirstOrderRel #name: 'callsR' #description: 'calls' #reverse: nil #token: #callsRRel ) decodeAsLiteralArray;	add: #(#LDMFirstOrderRel #name: 'contains' #description: 'contains' #reverse: nil #token: #containsRel ) decodeAsLiteralArray;	add: #(#LDMFirstOrderRel #name: 'containsR' #description: 'is contained in' #reverse: nil #token: #containsRRel ) decodeAsLiteralArray;	add: #(#LDMFirstOrderRel #name: 'callsR' #description: 'is called by' #reverse: #calls #token: #callsRRel ) decodeAsLiteralArray; yourself</body></methods><methods><class-id>Lens.LDMRelationship class</class-id> <category>instance creation</category><body package="LDM-Framework">complexRelationship: relDef 	"Given the definition of a complex relationship, build and return it. The description of relDef is found in the comments for 'createSingleRelationship:"	| def op newRel |	def := relDef at: 2.	op := def at: 1.	op == #+		ifTrue: [newRel := LDMTransitiveClosureRel newWithRel: (self at: (def at: 2))]		ifFalse: [op == #or				ifTrue: [newRel := LDMOrRel newWithRel: (self at: (def at: 2))								andRel: (self at: (def at: 3))]				ifFalse: [op == #@						ifTrue: [newRel := LDMComposedRel newWithRel: (self at: (def at: 2))										andRel: (self at: (def at: 3))]						ifFalse: [def size == 2								ifTrue: [newRel := op asQualifiedReference value												newWithRel: (self at: (def at: 2))]								ifFalse: [newRel := op asQualifiedReference value												newWithRel: (self at: (def at: 2))												andRel: (self at: (def at: 3))]]]].	Relationships at: (relDef at: 1)		put: newRel.	^newRel</body><body package="LDM-Framework">createRelationships: relsList 	"The parameter is a list of descriptions of relationships, create the 	corresponding relationship for each one of them"	relsList do: [:r | self createSingleRelationship: r]</body><body package="LDM-Framework">createSingleRelationship: rd	"The purpose of this method is to aid in building new relationships programatically"	"rd is the relationship description, as follows:		#(&lt;textual name&gt; &lt;relationship definition&gt; &lt;textual name of reverse relationship&gt;)	where &lt;relationship definition&gt; is:		&lt;simple symbol&gt;	or		(&lt;symbol&gt; &lt;complex relationship definition&gt;)	If &lt;simple symbol&gt; is given then the symbol is used as both, the name of the relationship	and the token for a LDMFirstOrderRel. Otherwise, the &lt;symbol&gt; is the name and the	complex relationship definition is parsed"	"NOTE - we do not check for errors since this method is not open to the users"	| relDef newRel reverseRel |	relDef := rd at: 2.	relDef isSymbol 		ifTrue: [ Relationships at: relDef put: (newRel := LDMFirstOrderRel withToken: (self relify: relDef)) ]		ifFalse: [ newRel := self complexRelationship: relDef ].	newRel name: (rd at: 1).	(rd size == 4)		ifTrue: [ reverseRel := self complexRelationship: (rd at: 4) ]		ifFalse: [ reverseRel := newRel reverse ].	reverseRel name: (rd at: 3)</body><body package="LDM-Framework">new	^super new</body><body package="LDM-Framework">relify: sym	"A utility method to add 'Rel' at the end of a symbol and make it a new symbol"	^(sym, 'Rel') asSymbol</body></methods><methods><class-id>Lens.LDMRelationship class</class-id> <category>accessing</category><body package="LDM-Framework">at: aSymbol	"The symbol represents the name of the wanted relationship. Returns the relationship found in the dictionary of relationships at the symbol key"	^(Relationships at: aSymbol)</body><body package="LDM-Framework">at: aSymbol ifAbsent: aBlock	"The symbol represents the name of the wanted relationship. Returns the relationship found in the dictionary of relationships at the symbol key"	^(Relationships at: aSymbol ifAbsent: aBlock)</body><body package="LDM-Framework">at: aSymbol put: aRel	"Puts the relationship in the dictionary using aSymbol as the key"	^(Relationships at: aSymbol put: aRel)</body><body package="LDM-Framework">relationshipNames	"Returns a collection with the names of the relationships. Note that the symbols used are the keys to the dictionary rather than taking the name from the relationships themselves - they should be consistent"	^Relationships keys collect: [:n | n asString]</body><body package="LDM-Framework">remove: aSymbol	"Available for development tools"	Relationships removeKey: aSymbol</body></methods><methods><class-id>Lens.LDMRelationship class</class-id> <category>private</category><body package="LDM-Framework">decodeFromLiteralArray: anArray	"Return an instance based on the information encoded in anArray."	^self new fromLiteralArrayEncoding: anArray</body></methods><methods><class-id>Lens.LDMMonadicRel</class-id> <category>initialize release</category><body package="LDM-Framework">reset	"After readed references are symbols"		r1 isSymbol ifTrue: [r1 := self class at: r1 ifAbsent: [nil]].</body></methods><methods><class-id>Lens.LDMMonadicRel</class-id> <category>accessing</category><body package="LDM-Framework">r1	^r1</body><body package="LDM-Framework">r1: basicRel	r1 := basicRel.	^self</body></methods><methods><class-id>Lens.LDMMonadicRel</class-id> <category>computing</category><body package="LDM-Framework">computeReverse	"The default is to reverse the basic relationship. This default may or may not be correct for specific subclasses"	reverse := self class newWithRel: r1 reverse</body></methods><methods><class-id>Lens.LDMMonadicRel</class-id> <category>printing</category><body package="LDM-Framework">storeOn: aStream	| q1 |	q1 := r1.	r1 := q1 name asSymbol.	super storeOn: aStream.	r1 := q1.</body></methods><methods><class-id>Lens.LDMMonadicRel class</class-id> <category>instance creation</category><body package="LDM-Framework">new	^self shouldNotImplement</body><body package="LDM-Framework">newWithRel: basicRel 	"create an instance with the basicRel"	^self newWithRel: basicRel named: nil</body><body package="LDM-Framework">newWithRel: basicRel named: nm 	"create an instance with the basicRel"	^(super new r1: basicRel)		name: nm</body></methods><methods><class-id>Lens.LDMNonReflexiveRel</class-id> <category>computing</category><body package="LDM-Framework">relatedTo: el	"Selects only those rels where the acted is different than the actor"	^(r1 relatedTo: el) select: [:e2 | e2 ~~ el ]</body></methods><methods><class-id>Lens.LDMElementView</class-id> <category>initialize-release</category><body package="LDM-Framework">flush	hasIn := nil.	hasOut := nil.</body><body package="LDM-Framework">for: aNode model: aModel	element := aNode.	self model: aModel.	self doLayout</body><body package="LDM-Framework">inButton	"creates the button for opening and closing the incoming 	relationships. cyev is self"	| v pa |	pa := PluggableAdaptor on: self.	pa		getBlock: [:cyev | cyev hasIn == true]		putBlock: self inButtonPutBlock		updateBlock: [:m :a :p | false].	v := LDMArrowView model: pa.	v controller beToggle.	v label: ''.	^v</body><body package="LDM-Framework">inButtonPutBlock	"This block is executed when the arrow to the left of the element 	view is hit."	"If the element has incoming relationships not already open, we open 	them one level. If all the incoming rels are already open then we 	close them all."	^[:cyev :val | Cursor wait showWhile: [cyev hasIn == true			ifTrue: [cyev openAllSide: 2]			ifFalse: [cyev closeAllSide: 2]]]</body><body package="LDM-Framework">initialize	super initialize.	povIcons := OrderedCollection new: 0.	hasIn := hasOut := nil.	selected := ValueHolder with: false.	recycle := false</body><body package="LDM-Framework">outButton	"same as inButton but for outgoing relationships"	| v pa |	pa := PluggableAdaptor on: self.	pa		getBlock: [:cyev | cyev hasOut == true]		putBlock: self outButtonPutBlock		updateBlock: [:m :a :p | false].	v := LDMArrowView model: pa.	v controller beToggle.	v label: ''.	^v</body><body package="LDM-Framework">outButtonPutBlock	"This block is executed when the arrow to the right of the element 	view is hit."	"If the element has outgoing relationships not already open, we open 	them one level. If all the outgoing rels are already open then we 	close them all."	^[:cyev :val | Cursor wait showWhile: [cyev hasOut == true			ifTrue: [cyev openAllSide: 1]			ifFalse: [cyev closeAllSide: 1]]]</body><body package="LDM-Framework">realRelease	"Remove the receiver as a dependent of the model."	model removeDependent: self.	model := nil.	super release</body><body package="LDM-Framework">release	"Do nothing, because we are released only after the cds that created us is finished with us. This is the price of recycling"	recycle == false ifTrue: [self realRelease]</body></methods><methods><class-id>Lens.LDMElementView</class-id> <category>accessing</category><body package="LDM-Framework">bottomRootView    ^self</body><body package="LDM-Framework">hasIn	hasIn == nil ifTrue: [hasIn := model body hasFrom: element side: 2].	^hasIn</body><body package="LDM-Framework">hasOut	hasOut == nil ifTrue: [hasOut := model body hasFrom: element side: 1].	^hasOut</body><body package="LDM-Framework">height	^(self preferredBounds height)</body><body package="LDM-Framework">isElementView	"Am I an CYElementView? - Yep"	^true</body><body package="LDM-Framework">key	^element key</body><body package="LDM-Framework">recycle	recycle := true</body><body package="LDM-Framework">sortKey	^element sortKey</body><body package="LDM-Framework">touchFlag    ^touchFlag</body><body package="LDM-Framework">touchFlag: f    touchFlag := f</body></methods><methods><class-id>Lens.LDMElementView</class-id> <category>actions</category><body package="LDM-Framework">closeAllSide: side 	"Close all the relationships from our element, to side side"	model body closeAllFrom: element side: side</body><body package="LDM-Framework">openAll: trios level: n out: isOut 		^self</body><body package="LDM-Framework">openAllSide: side 	model body openAllFrom: element side: side levels: 1</body></methods><methods><class-id>Lens.LDMElementView</class-id> <category>adding-removing</category><body package="LDM-Framework">addPovIconComponent: wrapper 	"Actually add the POV component onto the element."	"Collapses the actions of:		add:to:		addWrapper:		addComponent:	from CompositePart so that the update code could be	changed.  If there is only one icon we have reserved	space and need not redraw the graph."	"TODO: ASB check this operationally"	^self addComponent: wrapper</body><body package="LDM-Framework">removePovIcon: aPov 	"Find a wrapper containig aPov and remove it from my components. 	The braodcasting scheme is used to detect which wrapper contains 	a perspective icons. When an icon is removed I notify my container 	that my prefered bounds has changed.      Note that aPov has to be removed before remove: message is sent,	this removal does not affect calculation of preferred bounds since	the value is cached, but when the new value is recalculated 	the povIcons collection has to contain only active icons."	|  toBeRemoved |	toBeRemoved := nil.	self components		do: 			[:c | 			| holder |			holder := OrderedCollection new.			c broadcastDown: #cyPovIconView with: holder.			(holder isEmpty not and: [holder first == aPov])				ifTrue: [toBeRemoved := c]].	toBeRemoved isNil		ifFalse: 			[povIcons remove: aPov.			self removePovIconComponent: toBeRemoved]		ifTrue: [self error: (#iconNotFound &lt;&lt; #dialogs &gt;&gt; 'icon not found')].</body><body package="LDM-Framework">removePovIconComponent: aVisualComponent 	"Remove aVisualComponent from the receiver's components. "	"Collapses the actions of:		remove:		removeComponent:	from CompositePart so that the update code could be	changed.  If there is only one icon before the remove,	it is our reserved space and we need not redraw the graph.	Redisplay any now exposed component.	However, the layoutComponentsForBounds:  is necessary to 	recalculate dot view bounds.  If more than one icon, redraw	everything.	Make sure the invalidation stretchs far enough to redraw the		broom handle."	"TODO: ASB check this operationally"	^self removeComponent: aVisualComponent</body></methods><methods><class-id>Lens.LDMElementView</class-id> <category>bounds accessing</category><body package="LDM-Framework">labelBounds	"Answer the part of view used by label" 	^label bounds</body></methods><methods><class-id>Lens.LDMElementView</class-id> <category>broadcasting-events</category><body package="LDM-Framework">broadcastDown: anEvent with: arguments	anEvent = #cySelectableView ifTrue: [arguments add: self]</body></methods><methods><class-id>Lens.LDMElementView</class-id> <category>controller accessing</category><body package="LDM-Framework">defaultController	"Answer an initialized instance of the receiver's default controller.	Subclasses should redefine this message only if the default controller 	instances need to be initialized in a nonstandard way."	^LDMElementViewController new</body></methods><methods><class-id>Lens.LDMElementView</class-id> <category>displaying</category><body package="LDM-Framework">displayOn: aGraphicsContext 	"Display each of the receiver's components. 	If the view is selected then use selection colors."	| clipBox aGC |	"aGraphicsContext class == CYPSGenerator ifTrue: [^self displayOnPs: aGraphicsContext]."	aGC := aGraphicsContext copy.	clipBox := aGC clippingBounds.	aGC paint: self foregroundColor.	1 to: components size		do: 			[:i | 			| component |			component := components at: i.			(component intersects: clipBox)				ifTrue: [component displayOn: aGC copy]]</body><body package="LDM-Framework">displayOnPs: aPSG	| p |	p := 0@0.	self hasIn == 0 ifFalse: [ p := p + (3 @ 0)].	self hasOut == 0 ifFalse: [ p := p + (3 @ 0)].	aPSG displayString: self key at: p</body></methods><methods><class-id>Lens.LDMElementView</class-id> <category>hit detection</category><body package="LDM-Framework">componentsInside: aRectangle 	^Set with: self.</body><body package="LDM-Framework">hitDetect: aPoint	^(self containsPoint: aPoint) ifTrue: [self] ifFalse:[nil]</body></methods><methods><class-id>Lens.LDMElementView</class-id> <category>printing</category><body package="LDM-Framework">printOn: aStream 	aStream nextPutAll: 'cyev'.	aStream nextPut: $&lt;.	element printOn: aStream.	aStream nextPut: $&gt;.</body></methods><methods><class-id>Lens.LDMElementView</class-id> <category>selection</category><body package="LDM-Framework">canBeSelectedWith: anotherView 	"Element views can be selected only with element views"	^anotherView isKindOf: self class</body><body package="LDM-Framework">deselect	selected value: false.</body><body package="LDM-Framework">isSelected	^selected value</body><body package="LDM-Framework">select	selected value: true.</body><body package="LDM-Framework">selectionPerformer	^element</body><body package="LDM-Framework">toggle	self isSelected ifTrue: [self deselect] ifFalse: [self select]</body></methods><methods><class-id>Lens.LDMElementView</class-id> <category>private-model</category><body package="LDM-Framework">myDependents	"Answer the receiver's dependents or nil."	^dependents</body><body package="LDM-Framework">myDependents: dependentsOrNil	"Set the receivers dependents."	dependents := dependentsOrNil</body><body package="LDM-Framework">postCopy	"Do not copy the dependents list."	super postCopy.	self breakDependents</body></methods><methods><class-id>Lens.LDMElementView</class-id> <category>private</category><body package="LDM-Framework">doLayout	| pt  |	pt := 0.	self hasIn == 0		ifFalse: 			[| inBut inLf inWid |			inBut := self inButton.			inWid := inBut preferredBounds width + 2.			inLf := LayoutFrame new.			inLf bottomFraction: 1; topOffset: 1; leftOffset: pt; rightOffset: pt + inWid.			self add: inBut in: inLf.			pt := pt + inWid].	label := self elLabelFor: element at: pt @ 0.	label := self findTopmostWrapperFor: label.	pt := label bounds corner x.	firstPovIconX := pt + 2.	self hasOut == 0		ifFalse: 			[| outBut outLf outWid |			outBut := self outButton.			outWid := outBut preferredBounds width.			outLf := LayoutFrame new.			outLf bottomFraction: 1; topOffset: 1; leftOffset: [self outButtonXPosition]; rightOffset: [self outButtonXPosition + outWid].			self add: outBut in: outLf]</body><body package="LDM-Framework">elLabelFor: aNode at: start 	"The label is given by the element. It can be either a visual component or a 	collection of specs. If it's a visual component, it's put in a reversing 	wrapper"	| w lbl |	lbl := aNode elementLabel: self getLabelHints.	lbl isSequenceable		ifTrue: 			[| b c |			b := model application builder newSubBuilder.			b composite: (c := CompositeView new).			lbl do: [:sp | b add: sp].			c controller: NoController new.			lbl := c].	w := ReversingWrapper on: lbl.	w reverse: selected.	self add: w at: start.	^w</body><body package="LDM-Framework">findTopmostWrapperFor: component	"Start from component and go up in the hierarchy	until myself is found. Return the thing reached in the	iteration just before the last one."		| prev next |	prev := component.	next := component container.	[next notNil and: [next ~~ self]]		whileTrue: 			[prev := next.			next := next container].	^prev</body><body package="LDM-Framework">getLabelHints	^model body getLabelHints</body><body package="LDM-Framework">iconXPosition: icon 	^firstPovIconX + ((povIcons indexOf: icon) - 1 * 18)</body><body package="LDM-Framework">outButtonXPosition	"Return the current position for the	out arrow button."	^firstPovIconX + (povIcons size * 18)</body></methods><methods><class-id>Lens.LDMElementView</class-id> <category>event driven</category><body package="LDM-Framework">handlerForMouseEvent: aMouseEvent	"Give all the components within myself a chance to say they want to handle aMouseEvent first,	then ask my controller whether it wants to handle the event or not."	| o |	o := label handlerForMouseEvent: aMouseEvent.	o notNil ifTrue: [^o].	o := super handlerForMouseEvent: aMouseEvent.	o notNil ifTrue: [^o].	^self controller handlerForMouseEvent: aMouseEvent.</body></methods><methods><class-id>Lens.LDMElementView class</class-id> <category>instance creation</category><body package="LDM-Framework">for: aNode model: aModel		^self new for: aNode model: aModel</body></methods><methods><class-id>Lens.LDMVariable</class-id> <category>initialize-release</category><body package="LDM-Framework">initialize	"Initially, there are no elements and there are 	no arcs on either side."	elements := IdentitySet new.	arcsOnSide := 		Array 			with: OrderedCollection new 			with: OrderedCollection new</body></methods><methods><class-id>Lens.LDMVariable</class-id> <category>accessing</category><body package="LDM-Framework">focusNumber	"A regular variable is not a focus hence it returns 0, meaning no focus"	^0</body><body package="LDM-Framework">setFocus: ignore	"since we are not the focus, do nothing"</body></methods><methods><class-id>Lens.LDMVariable</class-id> <category>computing</category><body package="LDM-Framework">addElements: els phase: phase 	"Add the elements 'els'. Then if there are any new elements, compute their impact of this on the arcs. This is done by notifying each one of our outgoing arcs (for both sides), that there are new elements. The phase is the part of the processing, either #initial or #automatic. Some arcs are only active in some phases, for example, an arc whose purpose is to add relationships once some other relationship is open, will be active on the #automatic phase. Whereas an arc that is used to compute the initial view of the graph is active on the #initial phase. An arc can be active in more than one phase."	| newElems |	newElems := els - elements.	newElems size &gt; 0		ifTrue: 			[elements addAll: newElems.			self arcAndSideDo: [:arc :side | 				(arc isActiveIn: phase)					ifTrue: [arc							addElements: newElems							fromSide: side							phase: phase]]]</body><body package="LDM-Framework">canAddElements: els fromArc: arc phase: phase 	"Returns the set of elements from 'els' that can be added to the 	variable. Checks each one of the arcs whether they accept the 	elements, returns the intersection of all the arcs responses. An	element can be added to the variable if it is accepted by all the	arcs connecting to the variable. An arc may reject a variable if	it requires the relationship to have a corresponding element at the	other side of the arc. This is useful for example to 'Show all the	variables that reference a class', where the restricting arc	would allow in only variables that have a 'reference' relationship with	elements of type class.	There is no need to check for the elements that are already here in	the variable because they are of course 'acceptable' in this variable.	Returns the elements that were already here and all of those that can be	added with regard to ALL the connected arcs."	| retElems alreadyHere |	alreadyHere := els select: [:el | elements includes: el].	retElems := els - alreadyHere.	retElems size &gt; 0 ifTrue: [		self arcAndSideDo: [:anArc :side | 			(anArc ~~ arc and: [anArc isActiveIn: phase])				ifTrue: [retElems := anArc								canAddElements: retElems								fromSide: side								phase: phase]]].	retElems addAll: alreadyHere.	^retElems</body><body package="LDM-Framework">removeNotIn: aSet	"Removes all the elements not present in aSet, and their respective relationships.	The collection toRemove is created because a set should not be modified while	an iteration over it is done"	| toRemove |	toRemove := OrderedCollection new.	elements do: [:e | (aSet includes: e) ifFalse: [toRemove add: e]].	elements removeAll: toRemove.	^toRemove</body><body package="LDM-Framework">reset	"Reset to begin a new graph computation. Initially no elements."	elements := IdentitySet new.</body></methods><methods><class-id>Lens.LDMVariable</class-id> <category>construction</category><body package="LDM-Framework">addArc: arc atSide: side	"Add the arc 'arc' to the 'side'. This method is used during the construction of the	perspective"	(arcsOnSide at: side) add: arc</body></methods><methods><class-id>Lens.LDMVariable</class-id> <category>printing</category><body package="LDM-Framework">printOn: aStream	"For debugging purposes. Prints as V(&lt;elements&gt;)"	aStream nextPutAll: 'V( '.	elements		do: 			[:el | 			el printOn: aStream.			aStream nextPutAll: ' '].	aStream nextPut: $)</body></methods><methods><class-id>Lens.LDMVariable</class-id> <category>private</category><body package="LDM-Framework">arcAndSideDo: aBlock 	"For each side and all the arcs on the side evaluate the block	giving it the arc and the side. The order of the iteration should	not be important"	1 to: 2		do: 			[:side | 			| arcs |			arcs := arcsOnSide at: side.			1 to: arcs size do: [:index | 				aBlock 					value: (arcs at: index)					value: side]]</body></methods><methods><class-id>Lens.LDMVariable class</class-id> <category>instance creation</category><body package="LDM-Framework">new	^super new initialize</body></methods><methods><class-id>Lens.LDMFocusVariable</class-id> <category>accessing</category><body package="LDM-Framework">beNumber: n	"Gives the number of focus to this variable. The tools only support	one focus, but future applications could use more than one (see class	comment)"	focusNumber := n</body><body package="LDM-Framework">focusNumber	"returns the focus number for this variable. In most cases it will be 1"	^focusNumber</body><body package="LDM-Framework">setFocus: aCollection	"Sets aCollection to be the collection of elements we include. We do not just add	them to the elements, but we call addElements because we want the change to be	propagated through the arcs"	self addElements: aCollection phase: #initial</body></methods><methods><class-id>Lens.LDMFocusVariable</class-id> <category>computing</category><body package="LDM-Framework">canAddElements: els fromArc: arc phase: phase 	"Returns the set of elements from 'els' that can be added to the 	variable. A Focus variable can add only what is already there"	^els select: [:el | elements includes: el]</body><body package="LDM-Framework">removeNotIn: aSet 	"Removes all the elements not present in aSet, and their respective 	relationships"	"For Focus Variables we do not remove any elements, because we want 	the focus to stay always there. This may break the premise that the arcs	can reject elements in a variable, but the focus is a special case and the	elements staying there do not harm in general. An element in the focus	needs to be shown even if it is not related to anything, by definition"	^Set new</body></methods><methods><class-id>Lens.LDMFocusVariable</class-id> <category>printing</category><body package="LDM-Framework">printOn: aStream	"Print as 'FV(&lt;elements&gt;)'. This could include the focus number" 	aStream nextPut: $F.	^super printOn: aStream</body></methods><methods><class-id>Lens.LDMFocusVariable class</class-id> <category>instance creation</category><body package="LDM-Framework">newWithNumber: aNumber	^self new beNumber: aNumber</body></methods><methods><class-id>Lens.LensBrowsingToolModel</class-id> <category>actions</category><body package="LDM-Framework">closeIn	self selectionDo: [:e | self browserModel body closeAllFrom: e side: 2]</body><body package="LDM-Framework">closeOut	self selectionDo: [:e | self browserModel body closeAllFrom: e side: 1]</body><body package="LDM-Framework">open2In	self selectionDo: [:e | self browserModel body openAllFrom: e side: 2 levels: 2]</body><body package="LDM-Framework">open2Out	self selectionDo: [:e | self browserModel body openAllFrom: e side: 1 levels: 2]</body><body package="LDM-Framework">open4In	self selectionDo: [:e | self browserModel body openAllFrom: e side: 2 levels: 4]</body><body package="LDM-Framework">open4Out	self selectionDo: [:e | self browserModel body openAllFrom: e side: 1 levels: 4]</body><body package="LDM-Framework">openIn	self selectionDo: [:e | self browserModel body openAllFrom: e side: 2 levels: 1]</body><body package="LDM-Framework">openOneIn	self selectionDo: [:e | self browserModel body openOneRelFrom: e side: 2 ifNone: [nil]]</body><body package="LDM-Framework">openOneOut	self selectionDo: [:e | self browserModel body openOneRelFrom: e side: 1 ifNone: [nil]]</body><body package="LDM-Framework">openOut	self selectionDo: [:e | self browserModel body openAllFrom: e side: 1 levels: 1]</body></methods><methods><class-id>Lens.LensBrowsingToolModel</class-id> <category>actions-support</category><body package="LDM-Framework">browser: bModel selectionDo: aBlock	bModel selectionService selectedPerformers do: aBlock</body><body package="LDM-Framework">browserModel	"Returns the brwsing model the user refers to in the actions"	self subclassResponsibility</body><body package="LDM-Framework">selectionDo: aBlock	self browserModel selectionService selectedPerformers do: aBlock</body></methods><methods><class-id>Lens.LensBrowsingToolModel</class-id> <category>defaults</category><body package="LDM-Framework">defaultFocusHolder	"Default to a statically empty focus, for a static focus	override this method, otherwise use a real focus holder."	^Set new asValue</body><body package="LDM-Framework">defaultPerspectiveHolder	"Usable only for a fixed perspective, for 	changable perspectives provide a real focus holder."		^self perspectiveHolderFor:  self defaultPerspectiveName</body><body package="LDM-Framework">defaultPerspectiveName	"Override with fixed perspective you wish to use, or for 	changable perspectives provide a real focus holder."	^#=</body><body package="LDM-Framework">defaultSelectionService	"A 'nil' selection service means it will be created fresh for this body and not shared."	^nil</body><body package="LDM-Framework">perspectiveHolderFor: aName	"Create a perspective holder initially set to the perspective 	named 'aName'."		^(LDMPerspective at: aName) asValue</body></methods><methods><class-id>Lens.LensBrowsingToolModel class</class-id> <category>private</category><body package="LDM-Framework">isVisualStartable	"Used by UIFinder to divine that the application will respond to Start"	^false</body></methods><methods><class-id>Lens.LDMPerspective</class-id> <category>initialize-release</category><body package="LDM-Framework">initialize	rows := List new.	relDesc := List new.	labelHints := OrderedCollection new.</body><body package="LDM-Framework">upToDate	"Reconciliate the size of the rows and the initialization of new variables"	rows		do: 			[:r | 			r size + 1 to: ColumnNames size do: [:i | r add: nil].			ColumnNames size + 1 to: r size do: [:i | r removeLast]].	labelHints isNil ifTrue: [labelHints := OrderedCollection new].	relDesc isNil ifTrue: [relDesc := List new]</body></methods><methods><class-id>Lens.LDMPerspective</class-id> <category>accessing</category><body package="LDM-Framework">addRow	rows addLast: (List new: ColumnNames size)</body><body package="LDM-Framework">arrLabelHints: arr	labelHints := arr asList</body><body package="LDM-Framework">arrRelDesc: arr	relDesc := List new.	arr do: [:r | relDesc add: r asList]</body><body package="LDM-Framework">arrRows: arr	rows := List new.	arr do: [:r | rows add: r asList]</body><body package="LDM-Framework">at: aPoint	^(rows at: aPoint y) at: aPoint x</body><body package="LDM-Framework">at: aPoint put: value	^(rows at: aPoint y) at: aPoint x put: value</body><body package="LDM-Framework">labelHints	^labelHints</body><body package="LDM-Framework">labelHints: hints	labelHints := hints</body><body package="LDM-Framework">name	^name</body><body package="LDM-Framework">name: aSymbol	name := aSymbol</body><body package="LDM-Framework">relDesc	^relDesc</body><body package="LDM-Framework">relDesc: aList	relDesc := aList</body><body package="LDM-Framework">rows	^rows</body><body package="LDM-Framework">rows: theRows	rows := theRows</body></methods><methods><class-id>Lens.LDMPerspective</class-id> <category>private</category><body package="LDM-Framework">fromLiteralArrayEncoding: anArray	2 to: anArray size by: 2 do:		 [:i | self perform: (anArray at: i) with: (anArray at: i + 1)].	LDMPerspective at: name asSymbol put: self</body><body package="LDM-Framework">literalArrayEncoding	| a arrRows arrRelDesc|	a := Array new: 9.	a at: 1 put: self class fullyQualifiedReference.	a at: 2 put: #arrRows:.	arrRows := rows asArray.	1 to: arrRows size do: [:i | arrRows at: i put: (arrRows at: i) asArray].	a at: 3 put: arrRows.	a at: 4 put: #arrLabelHints:.	a at: 5 put: labelHints asArray.	a at: 6 put: #arrRelDesc:.	arrRelDesc := relDesc asArray.	1 to: arrRelDesc size do: [:i | arrRelDesc at: i put: (arrRelDesc at: i) asArray].	a at: 7 put: arrRelDesc.	a at: 8 put: #name:.	a at: 9 put: name.	^a</body></methods><methods><class-id>Lens.LDMPerspective class</class-id> <category>class initialization</category><body package="LDM-Framework">initialize	"Perspectives holds the known perspectives, the key is the name of the 	perspective, a symbol.	ColumnNames are the names of the columns in each row of the perspective.	V1 - the 'from' variable	V2 - the 'to' variable	REL - the relationship joining the two variables	INIT - whether or not the row should be used when computing the initial graph	AUTO - whether or not the row should be used when looking for relationships that should be opened automatically	OPEN - whether or not the relationship can be opened and closed by the user	R1 - whether the row is restricted or variable 1, which means that an element can be added to V2 if and only if it has a counterpart in V1	R2 - the same for the other variable"	"Perspective initialize"	Perspectives := IdentityDictionary new.	ColumnNames := #('V1' 'V2' 'REL' 'INIT' 'AUTO' 'OPEN' 'R1' 'R2' )</body><body package="LDM-Framework">initializePerspectives	"This is an example to show the structure of a perspective, inspect the result from this method to understand the structure. The mere creation of a perspective will add it to the Perspectives dictionary, therefore, the names of perspectives should be unique in the system"	"self initializePerspectives"	"To create new perspectives copy the lines below to the initialization method of the class that needs the perspective and edit it to fit the required definition. See LDMRelationship class&gt;&gt;initializeRelationships for the way to define new relationships"	^List new add: ((Array new: 9) 	at: 1 put: #LDMPerspective; 	at: 2 put: #arrRows:; 	at: 3 put: #(		"The order here is:		&lt;variable 1&gt; &lt;variable 2&gt; &lt;relationship name&gt; &lt;used on init&gt; &lt;opened automatically&gt; &lt;user can open&gt; &lt;restricted on variable 1&gt; &lt;restricted on variable 2&gt;"		#(#F1 #V1 'calls' true false false false false ) 		#(#V1 #V1 'calls' false true true false false )	); 	at: 4 put: #arrLabelHints:;	"The label hints are passed to the elements, they decide what to do with them"	at: 5 put: #(); 	"Add an array for each different relationship used in the perspective."	at: 6 put: #arrRelDesc:; 	at: 7 put: ((Array new: 1) 		at: 1 put: ((Array new: 5) 			at: 1 put: 'calls';		"name of the relationship"			at: 2 put: true;		"Displayed or not"			at: 3 put: #solid;		"line style - only 'solid' implemented"			at: 4 put: ColorValue green;	"line color"			at: 5 put: #zero; yourself); yourself);	"line width #zero is the special case where the relationship is there, but does not show as a line"	at: 8 put: #name:; 	at: 9 put: #calls; 	"The name of the perspective"	yourself) decodeAsLiteralArray; yourself</body></methods><methods><class-id>Lens.LDMPerspective class</class-id> <category>instance creation</category><body package="LDM-Framework">new	^super new initialize</body></methods><methods><class-id>Lens.LDMPerspective class</class-id> <category>accessing</category><body package="LDM-Framework">any	"Returns a perspective found in the dictionary. If none is there then returns a 	new one. This is used for creating browsers with unknown perspectives"	Perspectives do: [:p | p notNil ifTrue: [^p]].	^self new</body><body package="LDM-Framework">at: aSymbol	^Perspectives at: aSymbol</body><body package="LDM-Framework">at: aSymbol ifAbsent: aBlock	^Perspectives at: aSymbol ifAbsent: aBlock</body><body package="LDM-Framework">at: aSymbol put: pp	Perspectives at: aSymbol put: pp</body><body package="LDM-Framework">columnNames	^ColumnNames</body><body package="LDM-Framework">deletePerspective: nm	"A new dictionary is created and all the perspectives that are not the deleted one are put in it, this way all the memories of the deleted perspective are erased" 	| newP |	newP := IdentityDictionary new.	Perspectives keysAndValuesDo: [:n :p | n ~= nm ifTrue: [newP at: n put: p]].	Perspectives := newP</body><body package="LDM-Framework">perspectiveNames	"This can be used by user interfaces to present a list of all the perspectives"	^Perspectives keys collect: [:n | n asString]</body></methods><methods><class-id>Lens.LDMPerspective class</class-id> <category>private</category><body package="LDM-Framework">decodeFromLiteralArray: anArray	"Return an instance based on the information encoded in anArray.	This or a better mechanism for recreating selves from arrays	should be implemented in Object"	^self new fromLiteralArrayEncoding: anArray</body></methods><methods><class-id>Lens.LensGraphView</class-id> <category>initialize release</category><body package="LDM-Framework">onPerspective: aSymbol	"Initialize using the perspective named by aSymbol"	bm := LDMBrowserModel new.	bm application: self.	focus := (IdentitySet new) asValue.	bm focusHolder: focus.	perspective := (LDMPerspective at: aSymbol) asValue.	bm perspectiveHolder: perspective.</body></methods><methods><class-id>Lens.LensGraphView</class-id> <category>accessing</category><body package="LDM-Framework">bm: aBM	bm := aBM</body><body package="LDM-Framework">perspective: aSymbol 	"Sets the perspective of the graph to be the one named with the given aSymbol. Since this is done 	from the design tools, no checking is done and the LDMPerspective must exist"	perspective value: (LDMPerspective at: aSymbol)</body></methods><methods><class-id>Lens.LensGraphView</class-id> <category>actions</category><body package="LDM-Framework">closeInOf: inSet andOpenOutOf: outSet 	| body | 	body := bm body.	body recomputeUserCanOpen.	inSet do: [:e | bm body closeAllFrom: e side: 2].	outSet do: [:eo | bm body			openAllFrom: eo			side: 1			levels: 1]</body></methods><methods><class-id>Lens.LensGraphView</class-id> <category>actions-support</category><body package="LDM-Framework">browserModel	^bm</body><body package="LDM-Framework">select: anElement 	^self browserModel select: anElement</body></methods><methods><class-id>Lens.LensGraphView</class-id> <category>aspects</category><body package="LDM-Framework">bm	"Return the browser model"	^bm</body><body package="LDM-Framework">focus	^focus</body><body package="LDM-Framework">focus: aSet 	"Change the focus of the graph. We ask to release the visuals because we do not want them to be 	reused"	bm body releaseVisuals.	focus value: aSet</body></methods><methods><class-id>Lens.LensGraphView class</class-id> <category>class initialization</category><body package="LDM-Framework">initialize	"LensGraphView initialize"	self initializeRelationships.	self initializePerspectives.</body><body package="LDM-Framework">initializePerspectives	"self initializePerspectives"	^List new		add: ((Array new: 9)				at: 1 put: #LDMPerspective;				at: 2 put: #arrRows:;				at: 3 put: #(#(#F1 #V1 'related' true false false false false )							#(#F1 #V1 'metaMapped' true false false false false )							#(#V1 #V1 'related' true false false false false )							#(#V1 #V1 'mapped' true false false false false )							#(#V1 #V1 'metaMapped' true false false false false ) );				at: 4 put: #arrLabelHints:;				at: 5 put: #();				at: 6 put: #arrRelDesc:;				at: 7 put: ((Array new: 3)						at: 1 put: ((Array new: 5)							at: 1 put: 'related';							at: 2 put: true;							at: 3 put: #solid;							at: 4 put: ColorValue black;							at: 5 put: 1;							yourself);						at: 2 put: ((Array new: 5)							at: 1 put: 'mapped';							at: 2 put: true;							at: 3 put: #solid;							at: 4 put: ColorValue brown;							at: 5 put: 3;							yourself);						at: 3 put: ((Array new: 5)							at: 1 put: 'metaMapped';							at: 2 put: true;							at: 3 put: #solid;							at: 4 put: ColorValue black;							at: 5 put: 1;							yourself);					yourself);				at: 8 put: #name:;				at: 9 put: #mappings;				yourself) decodeAsLiteralArray; 		add: ((Array new: 9)				at: 1 put: #LDMPerspective;				at: 2 put: #arrRows:;				at: 3 put: #(#(#F1 #V1 '=' true false false false false )							#(#V1 #V1 'containsColumn' false false true false false ) );				at: 4 put: #arrLabelHints:;				at: 5 put: #();				at: 6 put: #arrRelDesc:;				at: 7 put: ((Array new: 2)							at: 1 put: ((Array new: 5)										at: 1 put: 'containsColumn';										at: 2 put: true;										at: 3 put: #solid;										at: 4 put: ColorValue gray;										at: 5 put: 1;										yourself);							at: 2 put: ((Array new: 5)										at: 1 put: '=';										at: 2 put: false;										at: 3 put: #solid;										at: 4 put: ColorValue olive;										at: 5 put: 2;										yourself);							yourself);				at: 8 put: #name:;				at: 9 put: #dbtable;				yourself) decodeAsLiteralArray;		add: ((Array new: 9)				at: 1 put: #LDMPerspective;				at: 2 put: #arrRows:;				at: 3 put: #(#(#F1 #V1 '=' true false false false false )							#(#V1 #V1 'containsColumn' false false true false false ) );				at: 4 put: #arrLabelHints:;				at: 5 put: #(#simple);				at: 6 put: #arrRelDesc:;				at: 7 put: ((Array new: 2)							at: 1 put: ((Array new: 5)										at: 1 put: 'containsColumn';										at: 2 put: true;										at: 3 put: #solid;										at: 4 put: ColorValue gray;										at: 5 put: 1;										yourself);							at: 2 put: ((Array new: 5)										at: 1 put: '=';										at: 2 put: false;										at: 3 put: #solid;										at: 4 put: ColorValue olive;										at: 5 put: 2;										yourself);							yourself);				at: 8 put: #name:;				at: 9 put: #dbtable2;				yourself) decodeAsLiteralArray;		add: ((Array new: 9)				at: 1 put: #LDMPerspective;				at: 2 put: #arrRows:;				at: 3 put: #(#(#V1 #V1 '=' true false false false false ) );				at: 4 put: #arrLabelHints:;				at: 5 put: #(#simple);				at: 6 put: #arrRelDesc:;				at: 7 put: ((Array new: 1)							at: 1 put: ((Array new: 5)										at: 1 put: '=';										at: 2 put: false;										at: 3 put: #solid;										at: 4 put: ColorValue cyan;										at: 5 put: 2;										yourself);							yourself);				at: 8 put: #name:;				at: 9 put: #identity;				yourself) decodeAsLiteralArray;		yourself</body><body package="LDM-Framework">initializeRelationships	"self initializeRelationships"	^List new add: #(#LDMFirstOrderRel #name: 'mapped' #description: '' #reverse: nil #token: #mappedRel ) decodeAsLiteralArray;add: #(#LDMFirstOrderRel #name: 'mappedR' #description: '' #reverse: nil #token: #mappedRRel ) decodeAsLiteralArray;add: #(#LDMFirstOrderRel #name: 'metaMapped' #description: '' #reverse: nil #token: #metaMappedRel ) decodeAsLiteralArray;add: #(#LDMFirstOrderRel #name: 'metaMappedR' #description: '' #reverse: nil #token: #metaMappedRRel ) decodeAsLiteralArray;add: #(#LDMFirstOrderRel #name: 'related' #description: '' #reverse: nil #token: #relatedRel ) decodeAsLiteralArray;add: #(#LDMFirstOrderRel #name: 'relatedR' #description: '' #reverse: nil #token: #relatedRRel ) decodeAsLiteralArray; add: #(#LDMFirstOrderRel #name: 'containsColumn' #description: 'contains column' #reverse: containsColumnR #token: #containsColumnRel ) decodeAsLiteralArray;add: #(#LDMFirstOrderRel #name: 'containsColumnR' #description: 'column is contained in' #reverse: #containsColumn #token: #containsColumnRRel ) decodeAsLiteralArray; yourself</body></methods><methods><class-id>Lens.LensGraphView class</class-id> <category>instance creation</category><body package="LDM-Framework">onPerspective: aSymbol	^self new onPerspective: aSymbol</body></methods><methods><class-id>Lens.LensGraphView class</class-id> <category>fileIn/Out</category><body package="LDM-Framework">prerequisitesForLoading	"List those classes that must be filed or BOSSed into the system 	before I can be loaded."	| oc |	oc := super prerequisitesForLoading.	oc add: LDMRelationship; add: LDMPerspective.	^oc</body></methods><methods><class-id>Lens.LDMDiadicRel</class-id> <category>initialize release</category><body package="LDM-Framework">reset	"The references in r1 and r2 may be symbols, if so, fetch the corresponding relationships. The references are symbols after the relationship is read from external storage"	r1 isSymbol ifTrue: [r1 := self class at: r1 ifAbsent: [nil]].	r2 isSymbol ifTrue: [r2 := self class at: r2 ifAbsent: [nil]]</body></methods><methods><class-id>Lens.LDMDiadicRel</class-id> <category>accessing</category><body package="LDM-Framework">r1	^r1</body><body package="LDM-Framework">r1: firstRel r2: secondRel	r1 := firstRel.	r2 := secondRel.	^self</body><body package="LDM-Framework">r2	^r2</body></methods><methods><class-id>Lens.LDMDiadicRel</class-id> <category>printing</category><body package="LDM-Framework">storeOn: aStream	"Put the names of the referenced relationships instead of the references themselves, store the object into the stream, then reassign the references"	| q1 q2 |	q1 := r1.	q2 := r2.	r1 := q1 name asSymbol.	r2 := q2 name asSymbol.	super storeOn: aStream.	r1 := q1.	r2 := q2</body></methods><methods><class-id>Lens.LDMDiadicRel class</class-id> <category>instance creation</category><body package="LDM-Framework">new	"We do not want undefined diadic relationships hanging arround, 	hence we do not want user of this class and sub-classes to use the 	'new' message, instead we provide the 'newWithRel:andRel:' 	message"	^self shouldNotImplement</body><body package="LDM-Framework">newWithRel: firstRel andRel: secondRel 	"This method creates a new diadic relationship and sets the two 	composing rels."	^super new r1: firstRel r2: secondRel</body><body package="LDM-Framework">newWithRel: firstRel andRel: secondRel named: nm 	"This method creates a new diadic relationship and sets the two composing 	rels."	^(super new r1: firstRel r2: secondRel)		name: nm</body></methods><methods><class-id>Lens.LDMComposedRel</class-id> <category>computing</category><body package="LDM-Framework">computeReverse	"The components are reversed and in reversed order.	Reverse(p @ q) == Reverse(q) @ Reverse(p).	Note that composition is different than AND."	reverse := LDMComposedRel newWithRel: r2 reverse andRel: r1 reverse</body><body package="LDM-Framework">relatedTo: el 	"Calculates the set of elements satisfying r1 with el, returns the 	union of the sets that result when applying r2 over all the elements	of the first set"	| firstSet resultSet |	firstSet := r1 relatedTo: el.	resultSet := Set new.	firstSet do: [:middleEl | resultSet addAll: (r2 relatedTo: middleEl)].	^resultSet</body></methods><methods><class-id>Lens.LDMAbstractVisualBuilder</class-id> <category>initialize-release</category><body package="LDM-Framework">flush	"Cleanup everything and get ready to begin from a clean state"	composite := LDMGraphCompositeView model: self viewModel.	composite builder: self.	builder := UIBuilder new.	builder source: self viewModel.	builder composite: composite</body><body package="LDM-Framework">initialize	"Initialize the nodeDict to an identity dictionary of some big size since we know that it will probably contain a few tens of elements"	nodeDict := IdentityDictionary new: 101.</body><body package="LDM-Framework">initializeVisualComponentAsCFList	"Initialize the visualComponentBlock to produce list element wrappers"	self visualComponentBlock: [:bldr :object | 		LDMListElementWrapper				on: (LDMElementView for: object model: bldr viewModel)				at: 0 @ 0]</body><body package="LDM-Framework">initializeVisualComponentAsCFTree	"Initialize the visual component block to produce graph element browsers. This method would make more sense in the subclasses, but it is present here just in case it needs to be reused by unrelated subclasses"	self		visualComponentBlock: 			[:bldr :object | 			| ev |			ev := LDMElementView for: object model: bldr viewModel.			LDMGraphElementWrapper				on: ev				at: 0 @ 0				builder: bldr]</body><body package="LDM-Framework">initializeVisualConnectionAsBroom	"Initialize the connection block, which is the one that builds the visual components to render relationships in the graph. In this case it is a 'broom' which connects the elements in the typical way"	self		visualConnectionBlock: 			[:bldr :node :children | 			| connections |			connections := LDMBroomConnection						orientation: bldr orientation						parent: node						children: children						builder: bldr.			connections model: viewModel.			Array with: connections]</body><body package="LDM-Framework">initializeVisualConnectionAsListReference	"not used"</body><body package="LDM-Framework">releaseVisuals	"Make sure that all the visuals that are not used are properly released"	| toRemove |	toRemove := OrderedCollection new.	nodeDict keysAndValuesDo: [:el :node | node pass == #defunct			ifTrue: 				[node release.				toRemove add: el]].	toRemove do: [:el | nodeDict removeKey: el]</body><body package="LDM-Framework">visualComponentBlock: aBlock	"Private"	visualComponentBlock := aBlock</body><body package="LDM-Framework">visualConnectionBlock: aBlock	"private"	visualConnectionBlock := aBlock</body></methods><methods><class-id>Lens.LDMAbstractVisualBuilder</class-id> <category>accessing</category><body package="LDM-Framework">childrenFor: element 	"Return all the children for an element. Sorted according to their sortKey"	| unsorted elemKids |	unsorted := graph relationshipsOutFromElement: element.	elemKids := SortedCollection new: unsorted size.	elemKids sortBlock: [:a :b | a node sortKey &lt;= b node sortKey].	unsorted keysAndValuesDo: [:rel :els | (self shouldDisplayRel: rel)			ifTrue: [els do: [:el | elemKids add: (LDMNodeChild node: el rel: rel)]]].	^elemKids asOrderedCollection</body><body package="LDM-Framework">composite	^composite</body><body package="LDM-Framework">graph: aGraph	graph := aGraph</body><body package="LDM-Framework">viewModel	^viewModel</body><body package="LDM-Framework">viewModel: aModel	viewModel := aModel</body><body package="LDM-Framework">visualForElement: anElement 	"Returns the component found in the nodes dictionary under the anElement key. If none is found returns nil"		^(nodeDict at: anElement ifAbsent: [^nil])  component</body></methods><methods><class-id>Lens.LDMAbstractVisualBuilder</class-id> <category>build</category><body package="LDM-Framework">build	"Build graph wrappers around the elements, connecting children, and 	computing depth. Note that internalBuild is implemented in the subclasses"	self buildNodes.	self nodesDo: [:elem | self internalBuild: elem depth: 1]</body><body package="LDM-Framework">buildNodes	"Make sure we have a node for each element. Mark the nodes that we do not have an element for them anymore as #defunct. For each node used update the children of the node"	graph elementsDo: 			[:object | 			| node |			node := nodeDict at: object ifAbsent: [nil].			node ~~ nil				ifTrue: [node flush]				ifFalse: 					[node := visualComponentBlock value: self value: object.					nodeDict at: object put: node].			composite addWrapper: node].	nodeDict keysAndValuesDo: [:object :node | node flushed			ifTrue: 				[| elemKids |				elemKids := self childrenFor: object.				elemKids do: [:kid | kid node: (nodeDict at: kid node)].				node children: elemKids]			ifFalse: [node pass: #defunct]]</body><body package="LDM-Framework">internalBuild: node depth: aDepth	^self subclassResponsibility</body><body package="LDM-Framework">visualForGraph: aGraph viewModel: aModel	"This is the main method for building a graph. Follow these steps to understand the whole process"	self graph: aGraph.	self viewModel: aModel.	self flush.	self build.	self layout.	self releaseVisuals.	^composite</body></methods><methods><class-id>Lens.LDMAbstractVisualBuilder</class-id> <category>private</category><body package="LDM-Framework">horizontalSpacing	"Can be reimplemented by subclasses to do something else, maybe a variable spacing?"	^spacing x</body><body package="LDM-Framework">nodesDo: aBlock 	"Iterate thru all currently active nodes. Non active ones are marked as #defunct"	nodeDict		do: 			[:node |			node pass == #defunct ifFalse: [aBlock value: node]]</body><body package="LDM-Framework">shouldDisplayRel: rel	"Whether or not a relationship should be displayed. The perspective holds a list of attributes for each relationship included in it, the second attribute indicates whether or not the relationship is displayed. For certain perspectives, a relationship can be used to compute the graph but it is actually not displayed"	^(viewModel attributesForRel: rel) at: 2</body><body package="LDM-Framework">verticalSpacing	"Can be reimplemented by subclasses to do something else, maybe a variable spacing?"	^spacing y</body></methods><methods><class-id>Lens.LDMAbstractVisualBuilder</class-id> <category>uilayout</category><body package="LDM-Framework">layout	^self subclassResponsibility</body></methods><methods><class-id>Lens.LDMAbstractVisualBuilder class</class-id> <category>instance creation</category><body package="LDM-Framework">new	^super new initialize</body></methods><methods><class-id>Lens.LDMGraphBuilder</class-id> <category>initialize-release</category><body package="LDM-Framework">flush	"Clear also the positions of the columns"	super flush.	columnPositions := nil.</body><body package="LDM-Framework">initializeForHorizontal	"Initialize the constants for creating n horizontally layed out graph"	orientation := #horizontal.	spacing := 16@0</body><body package="LDM-Framework">initializeForVertical	"Initialize the constants for creatingin vertically layed out graph. The vertical graphs do not work as well as horizontal ones, no vertical graph is used in the system"	orientation := #vertical.	spacing := 10@20</body></methods><methods><class-id>Lens.LDMGraphBuilder</class-id> <category>build</category><body package="LDM-Framework">build	"Build graph wrappers around the elements, connecting children, and 	computing depth. Initialize the buildPath before starting to build"	buildPath := OrderedCollection new.	super build.</body><body package="LDM-Framework">internalBuild: node depth: aDepth 	"We are currently building for depth 	'aDepth'. If the node does not have a depth or its previous depth is 	less, make it 'aDepth' (after checking that this is not recursion). 	Descend any nodes we have not previously encountered or whose 	depths have changed."	| descend |	descend := false.	buildPath		changeSizeTo: (aDepth max: buildPath size);		at: aDepth put: node.	(node depth == nil or: [node depth &lt; aDepth and: [(buildPath indexOf: node)				&gt;= aDepth]])		ifTrue: 			[node depth: aDepth.			descend := true].	node pass == #build ifFalse: [descend := true].	node pass: #build.	descend ifTrue: [node children do: [:kidNode | self internalBuild: kidNode node depth: aDepth + 1]]</body></methods><methods><class-id>Lens.LDMGraphBuilder</class-id> <category>construction-accessing</category><body package="LDM-Framework">channelOffsets	^channelOffsets</body><body package="LDM-Framework">columnPositions	"Return an ordered collection of locations of columns"	^columnPositions</body><body package="LDM-Framework">highwayPositions	"Return an ordered collection of locations of highways"	^hwyPositions</body><body package="LDM-Framework">orientation	^orientation</body></methods><methods><class-id>Lens.LDMGraphBuilder</class-id> <category>private</category><body package="LDM-Framework">isHorizontal	^orientation == #horizontal</body><body package="LDM-Framework">stepNextPositionFor: node	"Assign final position to leaf node."	| bounds |	bounds := node bounds.	mins at: node depth put: ( (self isHorizontal		ifTrue: [bounds bottom + self verticalSpacing]		ifFalse: [bounds right + self horizontalSpacing]) max: (mins at: node depth))</body></methods><methods><class-id>Lens.LDMGraphBuilder</class-id> <category>uilayout</category><body package="LDM-Framework">centerOfKids: myKids 	"Determine the row position which is the center of the newly laid out kids. 	Assume the kids are in row order."	| low high |	self isHorizontal		ifTrue: 			[low := (myKids at: 1) bounds top.			high := (myKids at: myKids size) bounds bottom]		ifFalse: 			[low := (myKids at: 1) bounds left.			high := (myKids at: myKids size) bounds right].	^low + high // 2</body><body package="LDM-Framework">channelThickness	"How much space to leave for a channel"	^8</body><body package="LDM-Framework">computePendingChannelsFrom: node toChildren: children 	"Figure out which recursion channels will be needed later for connections 	out from this 'node' to 'children'."	"Remember pending channels for later when the recursion unwinds towards 	the root."	| ndepth cshallow |	cshallow := nil.	ndepth := node depth.	1 to: children size		do: 			[:i | 			| cdepth |			cdepth := (children at: i) node depth.			(cdepth &lt;= ndepth and: [cshallow == nil or: [cshallow &lt; cdepth]])				ifTrue: [cshallow := cdepth]].	cshallow == nil ifFalse: [(channelsPending at: cshallow)			add: node]</body><body package="LDM-Framework">connectToChildren: node 	"Make graphical connections between node 'node' and all of its children. But 	first figure out which recursion channels will be needed later for connections 	out from this node and reserve channels needed at this depth."	| children |	children := node children.	children size &gt; 0		ifTrue: 			[self computePendingChannelsFrom: node toChildren: children.			self reservePendingChannelsFor: node.			(visualConnectionBlock				value: self				value: node				value: children)				do: [:c | composite add: c]]</body><body package="LDM-Framework">layout	| level1 oneNode |	composite invalidateLayout.	self setColumns.	oneNode := nodeDict detect: [:n | true] ifNone: [nil].	oneNode == nil 		ifFalse: [self isHorizontal			ifTrue: 				[| height |				height := oneNode bounds height.				midPoint := height // 2.				nodeExtent := height + self verticalSpacing]			ifFalse: 				[| width |				width := oneNode bounds width.				midPoint := width // 2.				nodeExtent := width + self horizontalSpacing]].	channelsPending := Array new: columnPositions size.	1 to: columnPositions size do: [:i | channelsPending at: i put: OrderedCollection new].	channelOffsets := IdentityDictionary new.	level1 := SortedCollection sortBlock: [:a :b | a component sortKey &lt;= b component sortKey].	self nodesDo: [:node | node isRoot ifTrue: [level1 add: node]].	level1 do: [:node | self layoutNode: node]</body><body package="LDM-Framework">layoutDeepestDepth: depth kidsOf: node kids: myKids 	"Layout the portion of the subgraph rooted at 'node' 	which has the deepest depth."	"'depth' is the depth of the kids (there are no deeper)."	"'node' is the parent."	"'myKids' are the children of 'node' which are at 	depth 'depth' and have not been laid out already."	| pos currentMin sz |	currentMin := mins at: depth - 1.	sz := myKids size.	sz &gt; 0		ifTrue: 			[self minAt: depth atLeast: currentMin - (sz - 1 * (node bounds height + self verticalSpacing) // 2).			1 to: sz do: [:i | self layoutNode: (myKids at: i)].			pos := (self centerOfKids: myKids) - (node bounds height // 2) max: currentMin]		ifFalse: [pos := currentMin].	self moveNode: node to: pos.	self stepNextPositionFor: node</body><body package="LDM-Framework">layoutDepth: depth kidsOf: node 	"Layout the subgraph rooted at node."	"'depth' is the depth of the kids."	"'node' is the parent."	| myKids deeper children |	myKids := OrderedCollection new.	deeper := false.	children := node children.	children		do: 			[:ch | 			| child |			child := ch node.			child depth = depth				ifTrue: [child pass == #build ifTrue: [myKids add: child]]				ifFalse: [child depth &gt; depth ifTrue: [deeper := true]]].	deeper		ifTrue: [self				layoutNonDeepestDepth: depth				kidsOf: node				kids: myKids]		ifFalse: [self				layoutDeepestDepth: depth				kidsOf: node				kids: myKids]</body><body package="LDM-Framework">layoutNode: node 	"Layout the subgraph rooted at node."	self layoutDepth: node depth + 1 kidsOf: node.	self connectToChildren: node.	node pass: #final</body><body package="LDM-Framework">layoutNonDeepestDepth: depth kidsOf: node kids: myKids 	"Layout the portion of the subgraph rooted at 'node'	which is at depth 'depth'."	"Technique: layout half the kids, then layout the deeper	kids (this causes space to be reserved for the line out	to the deeper kids), then layout the other half of the kids."	"'depth' is the depth of the kids (there are deeper kids of 'node')."	"'node' is the parent."	"'myKids' are the children of 'node' which are at 	depth 'depth' and have not been laid out already."	| midIndex sz |	sz := myKids size.	midIndex := sz // 2. 	self minAt: depth atLeast: (mins at: node depth) - (midIndex * (node bounds height + self verticalSpacing)).	1 to: midIndex do: [:inx | self layoutNode: (myKids at: inx)]. 	self minAt: depth + 1 atLeast: (mins at: depth).	self layoutDepth: depth + 1 kidsOf: node.	self minAt: depth atLeast: ((mins at: depth + 1) max: (mins at: node depth)).	midIndex + 1 to: sz do: [:inx | self layoutNode: (myKids at: inx)].	^self</body><body package="LDM-Framework">minAt: depth atLeast: aMin 	"Make sure the min row position is at least 'aMin'."	mins at: depth put: 		((mins at: depth) max: aMin)</body><body package="LDM-Framework">moveNode: aNode to: anOffset	aNode setOrigin: anOffset@anOffset</body><body package="LDM-Framework">reservePendingChannelsFor: node 	"Reserve channels needed at this depth."	"If the node needing the channel is the current node then it is just direct 	recursion, handle it simply. Otherwise, make sure the channel is far enough 	down for all the depths it will pass through, then adjust the mins for all those 	depths to make room for the channel."	| ndepth chanPend |	ndepth := node depth.	chanPend := channelsPending at: ndepth.	chanPend size &gt; 0		ifTrue: 			[| dmin |			dmin := mins at: ndepth.			1 to: chanPend size				do: 					[:i | 					| pend |					pend := chanPend at: i.					pend == node						ifTrue: 							[| bot |							bot := node bounds bottom.							channelOffsets at: pend put: bot.							dmin &lt; (bot + self channelThickness) ifTrue: [channelsPending at: ndepth put: (dmin := dmin + self channelThickness)]]						ifFalse: 							[ndepth + 1 to: pend depth do: [:dep | dmin := dmin max: (mins at: dep)].							channelOffsets at: pend put: dmin.							dmin := dmin + self channelThickness.							ndepth to: pend depth do: [:dep | mins at: dep put: dmin]]].			channelsPending at: ndepth put: OrderedCollection new.			mins at: ndepth put: dmin]</body><body package="LDM-Framework">setColumns	"Determine where the element columns and	the highways will be.  Do so by determining	the largest element in each column.  Allow	room for one perspective icon.  Highway	width is computed from the number of lines	in the column - this computation should get 	even more sophisticated."	| widths pos counts |	widths := OrderedCollection new.	counts := OrderedCollection new.	self nodesDo:  			[:node | 			| depth w oldW oldCount |			depth := node depth.			w := node preferredBounds width.			(widths size &lt; depth or: [(oldW := widths at: depth) == nil or: [w &gt; oldW]])				ifTrue: [widths							changeSizeTo: (depth max: widths size);							at: depth put: w].			(counts size &lt; depth or: [(oldCount := counts at: depth) == nil]) 				ifTrue: [oldCount := 0].			counts				changeSizeTo: (depth max: counts size);				at: depth put: 1 + oldCount].	columnPositions := Array new: widths size.	hwyPositions := Array new: widths size.	mins := Array new: widths size.	pos := 10.	1 to: widths size		do: 			[:depth | 			mins at: depth put: 10.			columnPositions at: depth put: pos.			pos := pos + (widths at: depth) + 18 "Room for Icon".			hwyPositions at: depth put: pos.			pos := pos + 10 + ((counts at: depth)							+ ((counts size &lt; (depth + 1)) ifTrue: [0] ifFalse: [counts at: depth + 1]) * 2)]</body></methods><methods><class-id>Lens.LDMGraphBuilder class</class-id> <category>instance creation</category><body package="LDM-Framework">newTree	| b |	b := self new.	b initializeForHorizontal.	b initializeVisualConnectionAsBroom.	b initializeVisualComponentAsCFTree.	^b</body></methods><methods><class-id>UI.LDMWidgetController</class-id> <category>event driven</category><body package="LDM-Framework">selectionTracker	^LDMWidgetTracker on: self</body></methods><methods><class-id>Lens.LDMFirstOrderRel</class-id> <category>accessing</category><body package="LDM-Framework">token	^token</body><body package="LDM-Framework">token: newToken	token := newToken.	^self</body></methods><methods><class-id>Lens.LDMFirstOrderRel</class-id> <category>computing</category><body package="LDM-Framework">computeReverse	"This method is called if the reverse relationship has not been defined already. The default for the reverse relationship is to add (or omit if it was originally there) an 'R' at the fourth place from the end. This way, the token for the reverse of callsRel is callsRRel. If a relationship with the constructed token is not found, a new one is added"	| strToken size revSymbol |	strToken := token asString.	size := strToken size.	(strToken at: size - 3)		= $R		ifTrue: [revSymbol := strToken						copyReplaceFrom: size - 3						to: size						with: '']		ifFalse: [revSymbol := strToken						copyReplaceFrom: size - 2						to: size						with: 'R'].	revSymbol := revSymbol asSymbol.	reverse := Relationships at: revSymbol ifAbsent: [Relationships at: revSymbol put: (LDMFirstOrderRel withToken: (self class relify: revSymbol))]</body><body package="LDM-Framework">relatedTo: el 	"Asks the element to give the set of all the elements connected to it by this 	relationship. Many elements implement relatedBy: as sending the 'token' to themselves, checking that it is one of the tokens they understand. The default implementation in Object will return an empty set"	^el relatedBy: token</body></methods><methods><class-id>Lens.LDMFirstOrderRel</class-id> <category>private</category><body package="LDM-Framework">literalArrayEncoding	"Add the token to the literal array encoding"	| oc |	oc := super literalArrayEncoding.	oc add: #token:.	oc add: token.	^oc asArray</body></methods><methods><class-id>Lens.LDMFirstOrderRel class</class-id> <category>instance creation</category><body package="LDM-Framework">withToken: token	^(super new) token: token</body><body package="LDM-Framework">withToken: token named: nm 	^(super new token: token)		name: nm</body></methods><methods><class-id>Lens.LDMRelationsGenerator</class-id> <category>initialize-release</category><body package="LDM-Framework">initialize	variables := OrderedCollection new</body></methods><methods><class-id>Lens.LDMRelationsGenerator</class-id> <category>accessing</category><body package="LDM-Framework">getGraph	self postChange.	^graph</body><body package="LDM-Framework">graph	^graph</body><body package="LDM-Framework">userCanOpen	"returns a Graph of the relationships that can be opened"	^userOpensGraph</body></methods><methods><class-id>Lens.LDMRelationsGenerator</class-id> <category>computing</category><body package="LDM-Framework">checkConnectivity: focus 	"After one or more arcs have been removed from a graph, connectivity is 	checked with the focus, so that any arc not connected to the focus will be 	removed from the graph"	| touched totouch |	touched := IdentitySet new.	totouch := IdentitySet new.	totouch addAll: focus.	[totouch size &gt; 0]		whileTrue: 			[| next |			next := self removeOneFrom: totouch.			touched add: next.			totouch addAll: (graph elementsConnectedTo: next notIn: touched)].	variables do: [:v | graph removeElements: (v removeNotIn: touched)]</body><body package="LDM-Framework">openAllRelatedTo: el side: side	"Opens all the relationships connected to el from side"	userOpensArcs do: [:a | a openAllRelatedTo: el side: side]</body><body package="LDM-Framework">updateGraph	"Checks whether the relationships in the current graph still hold. Remove relationships that do not hold 	any more"	| toDelete |	toDelete := OrderedCollection new.	graph		outRelationshipsDo: 			[:el :related :rel | 			| newRelated bye |			newRelated := rel relatedTo: el.			(bye := related - newRelated) size &gt; 0 ifTrue: [toDelete add: (Array						with: el						with: bye						with: rel)]].	toDelete do: [:trio | graph			removeFromElement: (trio at: 1)			atSide: 1			andRelationship: (trio at: 3)			elements: (trio at: 2)]</body></methods><methods><class-id>Lens.LDMRelationsGenerator</class-id> <category>construction</category><body package="LDM-Framework">addRow: row using: vars 	"interprets a row from a description table. vars contains the variables 	knows so far"	| v1 v2 a |	v1 := self variableFromName: (row at: 1)				using: vars.	v2 := self variableFromName: (row at: 2)				using: vars.	self addVariable: v1.	self addVariable: v2.	a := LDMArc new.	a generator: self.	a relationship: (LDMRelationship at: (row at: 3) asSymbol).	a putVariable: v1 atSide: 1.	a putVariable: v2 atSide: 2.	v1 addArc: a atSide: 1.	v2 addArc: a atSide: 2.	(row at: 4)		ifTrue: [a beActiveIn: #initial].	(row at: 5)		ifTrue: [a beActiveIn: #automatic].	(row at: 6)		ifTrue: 			[a beActiveIn: #userOpens.			userOpensArcs add: a].	(row at: 7)		ifTrue: [a beRestrictedIn: 1].	(row at: 7)		ifTrue: [a beRestrictedIn: 2]</body><body package="LDM-Framework">addVariable: v 	(variables includes: v)		ifFalse: [variables add: v]</body><body package="LDM-Framework">perspective: ppv 	"builds the variables and arcs from the description table given. A 	description table is a collection of rows, each row contains the 	information regarding one arc. A row is a collection of containing the 	following fields: 	V1 - the variable at side 1 	V2 - the variable at side 2 	relationship - the name of the relationship 	initial - true or false 	automatic - true or false 	userOpens - true or false 	restrictedSide1 - true or false 	restrictedSide2 - true or false 		Variables are either Vnumber for regular variables or Fnumber for 	foci"	| vars |	vars := Dictionary new.	userOpensArcs := OrderedCollection new.	ppv rows do: [:row | self addRow: row using: vars]</body><body package="LDM-Framework">variableFromName: name using: vars 	"vars is a dictionary with names and corresponding variables. A 	variable name starting with an F is a Focus variable"	^vars at: name ifAbsent: [vars at: name put: ((name at: 1)				== $F				ifTrue: [LDMFocusVariable newWithNumber: (Number readFrom: (name copyFrom: 2 to: name size) readStream)]				ifFalse: [LDMVariable new])]</body></methods><methods><class-id>Lens.LDMRelationsGenerator</class-id> <category>printing</category><body package="LDM-Framework">printOn: aStream 	aStream nextPutAll: 'RelationsGenerator &lt;'.	variables		do: 			[:v | 			v printOn: aStream.			aStream nextPutAll: '  '].	aStream nextPut: $&gt;</body></methods><methods><class-id>Lens.LDMRelationsGenerator</class-id> <category>private-computing</category><body package="LDM-Framework">addToGraph: fEls 	"Adds the focus elements to the graph so they are always accessible for 	opening and/or closing relationships"	fEls do: [:el | graph addElement: el]</body><body package="LDM-Framework">computeUserCanOpen	"returns a LDMGraph of the relationships that can be opened"	userOpensGraph := LDMGraph new.	userOpensArcs do: [:a | (a isActiveIn: #initial)			ifFalse: [a addUserCanOpenTo: userOpensGraph]].	^userOpensGraph</body><body package="LDM-Framework">postChange	self computeUserCanOpen</body><body package="LDM-Framework">reset	variables do: [:v | v reset].	graph := LDMGraph new.	userOpensGraph := LDMGraph new.</body><body package="LDM-Framework">setFocus: foci 	"foci is an ordered collection of focuses, usually only one focus will be 	used. For each one of the Focus variables set their initial value"	self reset.	foci do: [:foa | self addToGraph: foa].	variables do: [:v | (v focusNumber &gt; 0 and: [v focusNumber &lt;= foci size])			ifTrue: [v setFocus: (foci at: v focusNumber)]]</body><body package="LDM-Framework">userCloseRelationship: rel from: element to: related side: side 	userOpensArcs do: [:arc | 		arc relationship == rel ifTrue: [			arc				userClosedFrom: element				to: related				side: side]]</body><body package="LDM-Framework">userOpenRelationship: rel from: element to: related side: side 	userOpensArcs do: [:arc | 		arc relationship == rel ifTrue: [			arc				userOpenFrom: element				to: related				side: side]]</body></methods><methods><class-id>Lens.LDMRelationsGenerator</class-id> <category>private system</category><body package="LDM-Framework">removeOneFrom: aCollection 	aCollection		do: 			[:e | 			aCollection remove: e.			^e]</body></methods><methods><class-id>Lens.LDMRelationsGenerator class</class-id> <category>instance creation</category><body package="LDM-Framework">new	^super new initialize</body></methods><methods><class-id>Lens.LDMRelationsGenerator class</class-id> <category>testing</category><body package="LDM-Framework">callsDemo	"RelationsGenerator callsDemo"	^self new perspective: (LDMPerspective at: #calls)</body></methods><methods><class-id>Lens.LDMBrowserSpec</class-id> <category>building</category><body package="LDM-Framework">widgetWrapperWrapping: aWrapper decorator: aDecorator component: aComponent	| sw |	sw := SpecWrapper on: aWrapper.	sw spec: self.	sw decorator: aDecorator.	colors == nil ifFalse: [sw setLookPreferences: colors].	sw setOpaque: self isOpaque.	^sw</body></methods><methods><class-id>Lens.LDMBrowserSpec</class-id> <category>private</category><body package="LDM-Framework">defaultFlags	"Default to full scroll bars. The graph will probably grow to need the scrollbars"	^2r1111</body><body package="LDM-Framework">defaultModel	"The default model is used while painting. We take a browserModel with the first Perspective we find. Anyway the model will not be asked to perform any computation"	| dm |	dm := LDMBrowserModel new.	dm focusHolder: IdentitySet new asValue.	dm perspectiveHolder: (LDMPerspective any) asValue.	^dm</body><body package="LDM-Framework">dispatchTo: policy with: builder 	"Off to policy to create the view."	policy browser: self into: builder</body></methods><methods><class-id>Lens.LDMBrowserSpec class</class-id> <category>property slices</category><body package="LDM-Framework">colorSlice	"Empty means NO PAGE!"	^#(1 #())</body><body package="LDM-Framework">detailsSlice	"Empty means NO PAGE!"	^#(1 #())</body><body package="LDM-Framework">dropTargetSlice	"Empty means NO PAGE!"	^#(1 #())</body><body package="LDM-Framework">notificationSlice	"Empty means NO PAGE!"	^#(1 #())</body><body package="LDM-Framework">positionSlice	"Empty means NO PAGE!"	^#(1 #())</body><body package="LDM-Framework">validationSlice	"Empty means NO PAGE!"	^#(1 #())</body></methods><methods><class-id>Lens.LDMSelectionService</class-id> <category>initialize-release</category><body package="LDM-Framework">initialize	"viewsValue is a value holder on a collection of views."	viewsValue := self emptyViews asValue.	performersValue := viewsValue compute: 		[:views| (views collect: [:v | v selectionPerformer])					select: [:o | o notNil]]</body></methods><methods><class-id>Lens.LDMSelectionService</class-id> <category>accessing</category><body package="LDM-Framework">addOne: aView 	"Add a view into the current selection, inform a view that it has 	been selected.  If it is being readded, remove and add to keep 	the order correct."	| selViews |	selViews := self getSelectedViews.	(self isSelected: aView)		ifTrue: 			[selViews remove: aView.			selViews add: aView]		ifFalse: 			[aView select.			selViews add: aView].	self setSelectedViews: selViews</body><body package="LDM-Framework">deselectAll	"Deselect all views and forget about all the views we were holding onto."	self deselectAllViews.	self setSelectedViews: self emptyViews</body><body package="LDM-Framework">newSelection: aCollection 	"Replace a current selection with a new collection of objects"	| newViews |	self deselectAllViews.	newViews := self emptyViews.	aCollection		do: 			[:aView | 			aView select.			newViews add: aView].	self setSelectedViews: newViews</body><body package="LDM-Framework">removeIfSelected: aView 	"Check if a view is in selectedView collection and remove it. 	This message is send when a view is released. Note that 	a view is NOT notified that its status has changed"	(self isSelected: aView)		ifTrue: [self setSelectedViews: (self getSelectedViews remove: aView ifAbsent: [])]</body><body package="LDM-Framework">removeOne: aView 	"remove a view from the current selection, 	inform a view that it has been deselected"	(self isSelected: aView)		ifTrue: 			[| selViews |			aView deselect.			selViews := self getSelectedViews.			selViews remove: aView ifAbsent: [].			self setSelectedViews: selViews]</body><body package="LDM-Framework">selectedPerformers	"Given selected views return a collections of object designated 	by the views to perform actions"	^self value</body><body package="LDM-Framework">selectedViews	"Answer the value for selectedViews"	^self getSelectedViews copy</body><body package="LDM-Framework">value	^performersValue value</body></methods><methods><class-id>Lens.LDMSelectionService</class-id> <category>constructing</category><body package="LDM-Framework">compute: aBlock 	"Answer a BlockValue that computes aBlock with the receiver's value 	as the argument. aBlock will become a dependent of the receiver, 	and will be sent the message value: when the receiver is sent the 	message value:."	^performersValue compute: aBlock</body></methods><methods><class-id>Lens.LDMSelectionService</class-id> <category>testing</category><body package="LDM-Framework">isSelected: aView 	"is aView in the list of selected views?"	self getSelectedViews do: [:v| v == aView ifTrue: [^true]].	^false</body></methods><methods><class-id>Lens.LDMSelectionService</class-id> <category>private</category><body package="LDM-Framework">deselectAllViews	"Deselect all views"	self getSelectedViews do: [:v| v deselect ].</body><body package="LDM-Framework">emptyViews	"Returns an empty ordered list of views."	^OrderedCollection new</body><body package="LDM-Framework">getSelectedViews	"Return the collection of all the selected views"	^viewsValue value</body><body package="LDM-Framework">setSelectedViews: newViews	"Sets newViews as the current collection of selected views"	viewsValue value: newViews</body></methods><methods><class-id>Lens.LDMSelectionService class</class-id> <category>class-initialization</category><body package="LDM-Framework">initialize	"Create an instance of me and store it in a class variable. This instance can 	be used as a global selection service if such thing is required. If using a	global selection service, the window system's selection service should	be considered for possible integration and data translation from the internal	selection service to the external and vice-versa."	"Note that if using the global selection service extra care should be taken to 	remove views from the selection if they are released"	"CYSelectionService initialize"	GlobalInstance := self new</body></methods><methods><class-id>Lens.LDMSelectionService class</class-id> <category>instance-creation</category><body package="LDM-Framework">new	^super new initialize</body></methods><methods><class-id>Lens.LDMSelectionService class</class-id> <category>accessing</category><body package="LDM-Framework">globalSelection	"Return the global selection service"	"Note that if using the global selection service extra care should be taken to 	remove views from the selection if they are released"	^GlobalInstance</body></methods><methods><class-id>Lens.LDMGraph</class-id> <category>initialize-release</category><body package="LDM-Framework">initialize	"Keys are the elements, values are dictionaries holding the relationships for each one of the sides"	relationships := IdentityDictionary new</body></methods><methods><class-id>Lens.LDMGraph</class-id> <category>accessing graph</category><body package="LDM-Framework">anyFromElement: el side: side 	"Returns whether 'el' has children."	(self relationshipsFromElement: el side: side)		do: [:elemSet | elemSet size &gt; 0 ifTrue: [^true]].	^false</body><body package="LDM-Framework">elementsConnectedTo: el notIn: there 	"Returns all the elements connected to el which are not already in there"	| elems |	elems := IdentitySet new.	1 to: 2 do: [:side | (self relationshipsFromElement: el side: side)			do: [:elemSet | elemSet do: [:e | (there includes: e)						ifFalse: [elems add: e]]]].	^elems</body><body package="LDM-Framework">elementsFromElement: el side: side	"Returns the 'children' or 'parents' (according to side) of el in an IdentitySet"	| elems |	elems := IdentitySet new.	(self relationshipsFromElement: el side: side) do: [:elemSet| elems addAll: elemSet].	^elems</body><body package="LDM-Framework">elementsInFromElement: el 	"Returns the 'parents' of el as elements"	^self elementsFromElement: el side: 2</body><body package="LDM-Framework">elementsOutFromElement: el 	"Returns the 'children' of el as elements"	^self elementsFromElement: el side: 1</body><body package="LDM-Framework">relationshipsFromElement: el side: side 	"Returns a dictionary whose keys are relationship types and the values are 	elements related to 'el', where 'el' is at side 'side'."	| sides |	sides := relationships at: el ifAbsent: [nil].	sides isNil ifTrue: [^IdentityDictionary new].	^sides at: side</body><body package="LDM-Framework">relationshipsInFromElement: el 	"Returns the 'children' of el"	"Returns a dictionary whose keys are relationships and the values are 	elements related to el, where el is at side 2"	^self relationshipsFromElement: el side: 2</body><body package="LDM-Framework">relationshipsOutFromElement: el 	"Returns the 'children' of el"	"Returns a dictionary whose keys are relationships and the values are 	elements related to el, where el is at side 1"	^self relationshipsFromElement: el side: 1</body></methods><methods><class-id>Lens.LDMGraph</class-id> <category>accessing internals</category><body package="LDM-Framework">addElement: el 	"The value for the entry in the dictionary is an array of two dictionaries, each one for each side"	relationships at: el put: (Array with: IdentityDictionary new with: IdentityDictionary new)</body><body package="LDM-Framework">addToElement: el atSide: side andRelationship: rel elements: aCollection 	"We take great care to keep the graph consistent, hence if relationships are 	added to one side, we make sure to add them to the other side also"	| otherSide |	(self		elementsAtSide: side		ofElement: el		withRelationship: rel)		addAll: aCollection.	otherSide := self otherSide: side.	aCollection do: [:otherEl | (self			elementsAtSide: otherSide			ofElement: otherEl			withRelationship: rel)			add: el]</body><body package="LDM-Framework">elementsDo: aBlock	^relationships keysDo: aBlock</body><body package="LDM-Framework">outRelationshipsDo: aBlock 	relationships keysAndValuesDo: [:el :arr | (arr at: 1)			keysAndValuesDo: [:rel :related | aBlock					value: el					value: related					value: rel]]</body><body package="LDM-Framework">parentlessElements	"Return all elements which are not connected on the left. They are the ones to start the drawing from"	| orphans |	orphans := OrderedCollection new.	relationships keysAndValuesDo: [:el :rels | rels notNil ifTrue: [(rels at: 1) size = 1 ifTrue: [orphans add: el]]].	^orphans</body><body package="LDM-Framework">removeFromElement: el atSide: side andRelationship: rel elements: related	"Remove the elements in 'related' from the set of elements related to 'el' through relationship 'rel' on side 'side'" 	| bag otherSide |	bag := self				elementsAtSide: side				ofElement: el				withRelationship: rel.	otherSide := self otherSide: side.	related do: [:r | (bag remove: r ifAbsent: [nil]) notNil			ifTrue: 				[| bag2 |				bag2 := self							elementsAtSide: otherSide							ofElement: r							withRelationship: rel.				bag2 remove: el ifAbsent: [nil]]]</body><body package="LDM-Framework">withElement: el atSide: side andRelationship: rel 	"returns the elements related to el without changing the graph but returning an empty collection in case 	nothing is found"	| relDict |	relDict := relationships at: el ifAbsent: [nil].	relDict isNil ifTrue: [^Set new].	relDict := relDict at: side.	^relDict at: rel ifAbsent: [^Set new]</body></methods><methods><class-id>Lens.LDMGraph</class-id> <category>computing</category><body package="LDM-Framework">remove: e from: e2 side: side rel: rel	(((relationships at: e2) at: side) at: rel) remove: e</body><body package="LDM-Framework">removeElements: aSet	"Remove the elements given in aSet from the graph. To do so go through all the relationships and tell all the elements found at the other side that we are removing the element. Since the graph is kept with pointers on both directions, we have to make sure to remove the pointers to the elements as well as the pointers from the elements" 	aSet		do: 			[:e | 			| sides |			sides := relationships at: e ifAbsent: [nil].			sides == nil				ifFalse: 					[1 to: 2 do: [:side | (sides at: side)							keysAndValuesDo: [:rel :els | els do: [:e2 | self										remove: e										from: e2										side: (self otherSide: side)										rel: rel]]].					relationships removeKey: e ifAbsent: []]]</body></methods><methods><class-id>Lens.LDMGraph</class-id> <category>private</category><body package="LDM-Framework">elementsAtSide: side ofElement: el withRelationship: rel 	"Return all the elements connected to 'el' on side 'side' by relationship 'rel'."	| relDict |	relDict := relationships at: el ifAbsent: [nil].	relDict isNil ifTrue: [relDict := relationships at: el put: (Array with: IdentityDictionary new with: IdentityDictionary new)].	relDict := relDict at: side.	^relDict at: rel ifAbsent: [relDict at: rel put: IdentitySet new]</body><body package="LDM-Framework">otherSide: side	"responds the other side of side"	side == 1 ifTrue: [^2].	^1</body></methods><methods><class-id>Lens.LDMGraph class</class-id> <category>instance creation</category><body package="LDM-Framework">new	^super new initialize</body></methods><methods><class-id>Lens.LDMAbstractBody</class-id> <category>initialize-release</category><body package="LDM-Framework">initialize	"We start not locked, and therefore, no update may have been missed"	locked := false.	missedUpdate := nil</body><body package="LDM-Framework">release	"We have to remove our dependency on the foa members"	foa notNil ifTrue: [foa do: [:f | f removeDependent: self]].	super release.</body></methods><methods><class-id>Lens.LDMAbstractBody</class-id> <category>accessing</category><body package="LDM-Framework">foa	"Answer the value for foa"	^foa</body><body package="LDM-Framework">foa: aFoa	"remove the dependency on the old foa, depend on the new one, notify our dependents that the foa changed and also the 'triples' meaning that the whole graph has changed"	self doNotDepend.	self setFoa: aFoa.	self dependOnFoaDataBase.	self changed: #cds with: #(#foa #triples ).	^aFoa</body><body package="LDM-Framework">focus: aFocus	^self subclassResponsibility</body><body package="LDM-Framework">getLabelHints	"The label hints are passed from the perspective to the elements themselves. The hints may be defined in the perspective to affect the way the element is displayed for the specific perspective. For example if it is desired for a perspective that the elements display in a very small space, then the hints may be #small. Of course, the cooperation of the elements is required to pay attention to the hints"	^viewModel perspective labelHints</body><body package="LDM-Framework">isLocked	^locked</body><body package="LDM-Framework">perspective: aPerspective	^self subclassResponsibility</body><body package="LDM-Framework">setFoa: aFoa	^foa := aFoa</body><body package="LDM-Framework">upToDate	"We missed an update if it is not nil, otherwise it is the update that we missed"	^missedUpdate isNil</body><body package="LDM-Framework">viewModel	"What is the model for the created views. The model is the LDMBrowserModel and it is used by the views created for each element"	^viewModel</body><body package="LDM-Framework">viewModel: aModel	"Set the model for the created views."	viewModel := aModel</body></methods><methods><class-id>Lens.LDMAbstractBody</class-id> <category>ors</category><body package="LDM-Framework">addAllToOrs: aCollectionOfRels	"The ors is the Open Relationships Set, i.e. the graph. Subclasses implement this"</body><body package="LDM-Framework">openAll: cfnode level: n out: isOut	"Implemented by subclasses. Open all the relationships going out or in (according to isOut), for n levels"</body></methods><methods><class-id>Lens.LDMAbstractBody</class-id> <category>updating</category><body package="LDM-Framework">lock	locked := true</body><body package="LDM-Framework">lock: bool 	bool		ifTrue: [self lock]		ifFalse: [self unLock]</body><body package="LDM-Framework">makeUpToDate	"This can be used even while remaining locked, so the previous state of locked is saved, and then set to false so the updates are performed. If there was a missed update, then we perform it now. Return the locked flag to its previous state and notify our dependents that we are up to date. This notification can be used by the window displaying the graph to indicate to the user that the view is up to date (when it is not up to date the user should be notified graphically so the user knows not to believe in the graph as if it was the current state of the world)"	| saveLocked |	saveLocked := locked.	locked := false.	missedUpdate notNil		ifTrue: 			[self update: (missedUpdate at: 1)				with: (missedUpdate at: 2).			missedUpdate := nil].	locked := saveLocked.	self changed: #cdsUpToDate with: true</body><body package="LDM-Framework">missUpdate: aspect with: par 	"Record the update message that we are missing and make sure to notify our dependents that we are not up to date. This way the window can graphically show the user that the view is out of date"	missedUpdate isNil		ifTrue: [missedUpdate := OrderedCollection with: aspect with: par]		ifFalse: [(missedUpdate at: 2) isNil ifTrue: [missedUpdate at: 2 put: par]].		self changed: #cdsUpToDate with: false.</body><body package="LDM-Framework">unLock	"Unlock and make sure we update if something happened while locked"	locked := false.	self makeUpToDate.</body><body package="LDM-Framework">update: aspect with: par 	"If the database has changed and the parameter is #clear is an indication that the database does not contain any more information and any open browsers should be closed. Otherwise update the graph to reflect the change in the database"	aspect = #dataBase ifTrue: [par ~~ #clear			ifTrue: [self updateDataBase]			ifFalse: [self changed: #cdsQuit]]</body><body package="LDM-Framework">update: aspect with: par from: aSender	"If the database is the one that changed and we are locked then record that we are missing an update"	aspect == #dataBase ifTrue: [locked			ifTrue: [self missUpdate: aspect with: par]			ifFalse: [^self update: aspect with: par]]</body><body package="LDM-Framework">updateDataBase	"Update the display after a change in the database. Here it is implemented as:	if the foa (Focus Of Attention) changed, then reset the view by resetting the focus"	self updateFoa ifTrue: [self foa: foa]</body><body package="LDM-Framework">updateFoa	"Checks if the foa elements changed. Collect the new ones"	"Elements are asked if they changed, the response may be 	'false' indicating that it has not changes, 'nil' indicating that the element is not there any more,	'true' indicating it changed	'nil' indicating the element is not there any more	'another element' indicating that the element has been replaced by another element" 	| newFoa changed |	changed := false.	newFoa := OrderedCollection new.	foa == nil ifFalse: [foa			do: 				[:element | 				| newElement |				newElement := element changed.				newElement == false					ifTrue: [newFoa addLast: element]					ifFalse: 						[newElement notNil ifTrue: [newElement == true								ifTrue: [newFoa addLast: element]								ifFalse: [newFoa addLast: newElement]].						changed := true]]].	changed		ifTrue: 			[foa := newFoa].	^changed</body></methods><methods><class-id>Lens.LDMAbstractBody</class-id> <category>private</category><body package="LDM-Framework">dependOnFoaDataBase	"Add myself to the dependencies list of all the foa's data bases, so when they 	change I get the signal to update my graphs"	foa size &gt; 0 ifTrue: [foa do: [:f | f removeDependent: self; addDependent: self]]</body><body package="LDM-Framework">doNotDepend	foa size &gt; 0 ifTrue: [foa do: [:f | f removeDependent: self]]</body><body package="LDM-Framework">isNewFoaDifferent: newFoa	"Return true if either foa is nil or if they do not contain the same elements" 	(foa notNil &amp; newFoa notNil) ifTrue: [	| oldS newS |	oldS := foa asSet.	newS := newFoa asSet.	^(oldS - newS) size &gt; 0 or: [(newS - oldS) size &gt; 0]].	^true</body><body package="LDM-Framework">rebuild	^self subclassResponsibility</body></methods><methods><class-id>Lens.LDMAbstractBody class</class-id> <category>instance creation</category><body package="LDM-Framework">new	^super new initialize</body></methods><methods><class-id>Lens.LDMRelationsBody</class-id> <category>initialize-release</category><body package="LDM-Framework">initialize	"By default we use a relations generator"	generator := LDMRelationsGenerator new.	visualBuilder := nil.</body></methods><methods><class-id>Lens.LDMRelationsBody</class-id> <category>accessing</category><body package="LDM-Framework">bodySubView	"Returns just the composite used for building the graph. If it was necessary, a scrolling wrapper or something similar could be added here to the composite"	^self composite</body><body package="LDM-Framework">focus: aFocus	"Set or reset the focus for the browser. The generator supports multiple foci, we do not and therefore we make an array of the single focus. We remember the focus so it can later be used, even though it could be fetched from somewhere in the generator"	generator setFocus: (Array with: aFocus).	foa := aFocus</body><body package="LDM-Framework">hasFrom: anObject side: side	"anObject is an element in the graph. Responds:	0 - if  anObject can not have any relationship for side side	false - if anObject has relationships but they are all opened already	true - if it has and they are not yet open"	"Check in the canOpen graph, if none, then it can not open anyone. Then check in the already open graph, if the difference between the sets returned is 0 then there is nothing new to be opened"	| can current |	can := canOpen elementsFromElement: anObject side: side.	can size == 0 ifTrue: [^0].	current := graph elementsFromElement: anObject side: side.	(can - current) size == 0 ifTrue: [^false].	^true</body><body package="LDM-Framework">perspective: aPerspective	"Set the perspective in the generator"	generator initialize.	generator perspective: aPerspective.	generator reset.</body><body package="LDM-Framework">recomputeUserCanOpen	"delegate to the generator"	canOpen := generator computeUserCanOpen</body><body package="LDM-Framework">releaseVisuals	"Release all the visual components associated with the elements in the graph. This may be important to do in some cases because the visual components are reused when we encounter the same element again"	visualBuilder notNil ifTrue: [visualBuilder initialize]</body><body package="LDM-Framework">visualForElement: anElement	"Returns the visual component associated with anElement" 	^visualBuilder visualForElement: anElement</body></methods><methods><class-id>Lens.LDMRelationsBody</class-id> <category>graph manipulation</category><body package="LDM-Framework">closeAllFrom: element side: side	"Close all the relationships from element for the given side. First get all the open relationships, then let the generator close those relationship. Then remove the relationships that are not connected to the focus (foa) and rebuild the graph view"	| clossable |	clossable := graph relationshipsFromElement: element side: side.	clossable keysAndValuesDo: [:rel :related | 		generator			userCloseRelationship: rel			from: element			to: related copy			side: side].	generator checkConnectivity: self foa. 	self rebuild</body><body package="LDM-Framework">closeOneKindFrom: el side: side ifNone: aBlock 	"Presents the user a menu with the names of relationships that can be 	closed, closes all the relationships of the given type"	"returns true if something was done, false if nothing and 'aBlock value' if 	nothing could have been opened"	| can |	can := graph relationshipsFromElement: el side: side.	can size &gt; 0		ifTrue: 			[| selRel |			selRel := self userSelectMenu: (can keys collect: [:r | Array with: r description with: r]) asArray.			selRel notNil				ifTrue: 					[generator						userCloseRelationship: selRel						from: el						to: (can at: selRel)						side: side.					generator checkConnectivity: self foa.					self rebuild.					^true].			^false].	^aBlock value</body><body package="LDM-Framework">closeOneRelFrom: el side: side ifNone: aBlock 	"Presents the user a menu with the names of relationships that can be 	closes, closes all the relationships of the given type"	| can |	can := graph relationshipsFromElement: el side: side.	can size &gt; 0		ifTrue: 			[| selRel toMenu |			toMenu := OrderedCollection new.			can keysAndValuesDo: [:r :elements | elements do: [:e | toMenu add: (Array with: (el stringKey: #(#menu ))								, ' ' , r description , ' ' , (e stringKey: #(#menu )) with: (Array with: r with: e))]].			selRel := self userSelectMenu: toMenu.			(selRel notNil and: [selRel ~~ 0])				ifTrue: 					[generator						userCloseRelationship: (selRel at: 1)						from: el						to: (IdentitySet with: (selRel at: 2))						side: side.					generator checkConnectivity: self foa.					self rebuild.					^self].			^nil].	^aBlock value</body><body package="LDM-Framework">openAllFrom: element side: side levels: n 	"n indicate the number of levels to open the graph, 1 indicates to open only 	the immediate ones, 0 indicates to open everything"	self privateOpenAllFrom: element side: side levels: n.	self rebuild</body><body package="LDM-Framework">openOneKindFrom: el side: side ifNone: aBlock 	"Presents the user a menu with the names of relationships that can be 	opened, opens all the relationships of the given type"	"returns true if something was done, false if nothing and 'aBlock value' if 	nothing could have been opened"	| can |	can := self getReallyCanOpenFrom: el side: side.	can size &gt; 0		ifTrue: 			[| selRel |			selRel := self userSelectMenu: (can keys collect: [:r | Array with: r description with: r]) asArray.			selRel notNil				ifTrue: 					[generator						userOpenRelationship: selRel						from: el						to: (can at: selRel)						side: side.					self rebuild.					^true].			^false].	^aBlock value</body><body package="LDM-Framework">openOneRelFrom: el side: side ifNone: aBlock 	"Presents the user a menu with the names of relationships that can be 	opened, opens all the relationships of the given type"	| can |	can := self getReallyCanOpenFrom: el side: side.	can size &gt; 0		ifTrue: 			[| selRel toMenu |			toMenu := OrderedCollection new.			can keysAndValuesDo: [:r :elements | elements do: [:e | toMenu add: (Array with: (el stringKey: #(#menu ))								, ' ' , r description , ' ' , (e stringKey: #(#menu )) with: (Array with: r with: e))]].			selRel := self userSelectMenu: toMenu.			(selRel notNil and: [selRel ~~ 0])				ifTrue: 					[generator						userOpenRelationship: (selRel at: 1)						from: el						to: (IdentitySet with: (selRel at: 2))						side: side.					self rebuild.					^self].			^nil].	^aBlock value</body></methods><methods><class-id>Lens.LDMRelationsBody</class-id> <category>private</category><body package="LDM-Framework">buildComposite	"Builds the composite that represents the graph according to the rdms.	Ask the generator to compute the graph and the canOpen graph. Ask the visualBuilder to build the composite for the computed graph"	graph := generator getGraph.	canOpen := generator userCanOpen.	visualBuilder == nil ifTrue: [visualBuilder := self viewModel visualBuilderClass newTree].	composite := visualBuilder visualForGraph: graph viewModel: self viewModel</body><body package="LDM-Framework">composite	"If the composite has not been computed, build it"	composite == nil ifTrue: [self buildComposite].	^composite</body><body package="LDM-Framework">getReallyCanOpenFrom: el side: side 	"Returns an IdentityDictionary whose key are relationships and the vlaues 	are collections of elements related to 'el' with the respective relationship. 	All this for relationships that can be opened and are not already open"	| could current can |	can := IdentityDictionary new.	could := canOpen relationshipsFromElement: el side: side.	could size &gt; 0		ifTrue: 			[current := graph relationshipsFromElement: el side: side.			could				keysAndValuesDo: 					[:rel :els | 					| notThere |					notThere := els - (current at: rel ifAbsent: [IdentitySet new]).					notThere size &gt; 0 ifTrue: [can at: rel put: notThere]]].	^can</body><body package="LDM-Framework">keyboardOrder: aKProc	"Set the TAB order for the element views in the graph. Sort by 'x' and then by 'y'. Setting the tab order doesn't add the element views to the keyboard chain"	aKProc keyboardConsumers: (SequenceableCollectionSorter on: aKProc keyboardConsumers using: 			[:a :b | 			| ap bp |			(ap := a localPointToGlobal: 0 @ 0) y = (bp := b localPointToGlobal: 0 @ 0) y				ifTrue: [ap x &lt; bp x]				ifFalse: [ap y &lt; bp y]]) sort.</body><body package="LDM-Framework">privateOpenAllFrom: element side: side levels: n 	"n indicate the number of levels to open the graph, 1 indicates to open only 	the immediate ones"	"This recursive method opens one level and calls itself for all the elements connected with the current one, with (n-1).	NOTE that we ask the graph for all the relationships, this is good because we will descend the graph even if the relationship was not just now open, so this method will make sure that the n levels relationships are all open, independently of whether there were any already open from before"	generator openAllRelatedTo: element side: side.	n ~~ 1 ifTrue: [(graph relationshipsFromElement: element side: side)			do: [:rels | rels do: [:anEl | self						privateOpenAllFrom: anEl						side: side						levels: n - 1]]]</body><body package="LDM-Framework">rebuild	"Builds the composite that represents the graph."	| container decor ec eb |	( composite notNil and: [(container := composite container) notNil] )		ifTrue: 			[self buildComposite.			container component: composite.			viewModel graphHasChanged.			decor := nil.			decor notNil				ifTrue: 					["never true - kept for reference only"					eb := composite bounds extent.					ec := decor bounds extent.					eb x &gt; ec x						ifTrue: [decor useHorizontalScrollBar]						ifFalse: [decor noHorizontalScrollBar].					eb y &gt; ec y						ifTrue: [decor useVerticalScrollBar]						ifFalse: [decor noVerticalScrollBar].					decor flushCaches.					self keyboardOrder: decor topComponent keyboardProcessor]]</body><body package="LDM-Framework">userSelectMenu: aCollection 	"aCollection is a collection of pairs, each one is composed of a string and a 	value, the strings are presented to the user, the corresponding value is 	returned"	| labels values |	labels := Array new: aCollection size.	values := Array new: aCollection size.	1 to: aCollection size		do: 			[:i | 			labels at: i put: ((aCollection at: i)					at: 1).			values at: i put: ((aCollection at: i)					at: 2)].	^Dialog choose: (#ChooseOne &lt;&lt; #dialogs &gt;&gt; 'Choose one:')		fromList: labels values: values		lines: 10 cancel: [0]</body></methods><methods><class-id>Lens.LDMAbstractElementWrapper</class-id> <category>initialize-release</category><body package="LDM-Framework">flush	depth := nil.	pass := nil.	children := nil.	component == nil ifFalse: [component flush].</body></methods><methods><class-id>Lens.LDMAbstractElementWrapper</class-id> <category>accessing</category><body package="LDM-Framework">children	^children</body><body package="LDM-Framework">children: theChildren	children := theChildren</body><body package="LDM-Framework">depth	^depth</body><body package="LDM-Framework">depth: aDepth	depth := aDepth</body><body package="LDM-Framework">flushed	"Was this node flushed?"	^depth == nil.</body><body package="LDM-Framework">isRoot: bol	isRoot := bol</body><body package="LDM-Framework">object	^component</body><body package="LDM-Framework">pass	^pass</body><body package="LDM-Framework">pass: aPass	pass := aPass</body></methods><methods><class-id>Lens.LDMAbstractElementWrapper</class-id> <category>testing</category><body package="LDM-Framework">isRoot	^isRoot isNil		ifTrue: [depth == 1]		ifFalse: [isRoot]</body></methods><methods><class-id>Lens.LDMTransitiveClosureRel</class-id> <category>computing</category><body package="LDM-Framework">computeReverse	"returns the transitive closure of its component reversed"	reverse := LDMTransitiveClosureRel newWithRel: r1 reverse</body><body package="LDM-Framework">relatedTo: el 	"Starts with the set that results from applying one time the 	basicRelationship. Then applies it to all of the members in the set, 	as many times as required (it stops when the set doesn't grow any 	more elements ). Remember that here we are interested only in the 	relationship between the root and all the tree.	This computation can be quite expensive. The algorithm presented here is	completely general. A more specific solution for specific cases can be	implemented in the elements themselves"	| resultSet incrementSet |	resultSet := r1 relatedTo: el.	incrementSet := resultSet copy.	[incrementSet isEmpty]		whileFalse: 			[| newIncrementSet |			newIncrementSet := IdentitySet new.			incrementSet do: [:newEl | newIncrementSet addAll: (r1 relatedTo: newEl)].			incrementSet := IdentitySet new.			newIncrementSet do: [:newEl2 | (resultSet includes: newEl2)					ifFalse: 						[incrementSet add: newEl2.						resultSet add: newEl2]]].	^resultSet</body></methods><methods><class-id>Lens.LDMOrRel</class-id> <category>computing</category><body package="LDM-Framework">computeReverse	"The OR of the reverses of the components. The order is not important"	reverse := LDMOrRel newWithRel: r1 reverse andRel: r2 reverse</body><body package="LDM-Framework">relatedTo: el 	"Returns the union of the sets returned by each one of the composing 	relationships. The order of the computation is not important"	| aSet |	aSet := r1 relatedTo: el.	aSet addAll: (r2 relatedTo: el).	^aSet</body></methods><methods><class-id>Lens.LDMNodeChild</class-id> <category>accessing</category><body package="LDM-Framework">node	^node</body><body package="LDM-Framework">node: aNode	node := aNode</body><body package="LDM-Framework">rel	^rel</body><body package="LDM-Framework">rel: aRel	rel := aRel</body></methods><methods><class-id>Lens.LDMNodeChild class</class-id> <category>instance creation</category><body package="LDM-Framework">node: aNode rel: aRel	^self new node: aNode; rel: aRel</body></methods><methods><class-id>Lens.LDMElementViewController</class-id> <category>control defaults</category><body package="LDM-Framework">doSelect	"Do the selection according to the symbol in 'charged'"	| code |	code := charged.	charged := nil.	view		upcastEvent: #selectionChange		with: code		from: view		path: nil</body><body package="LDM-Framework">isControlActive	"Answer whether the receiver wants to retain control. Retain control if the cursor 	is inside the label part of the view and the blue button is not pressed. Pressing 	blue button a default to explicitly give up control without moving the cursor. 	It is sent by Controller|controlLoop in order to determine when the receiver's control 	loop should terminate, and should be redefined in a subclass if some other 	condition for terminating the main control loop is needed."	self sensor redButtonPressed		ifTrue: [^self labelViewHasCursor]		ifFalse: 			[charged notNil ifTrue: [self doSelect].			^false]</body><body package="LDM-Framework">isControlWanted	"The test is the same as isControlActive but the sensor has to be inside a view"	^self isControlActive</body></methods><methods><class-id>Lens.LDMElementViewController</class-id> <category>cursor</category><body package="LDM-Framework">labelViewHasCursor	"Answer true if the cursor point of the receiver's sensor lies within 	the display box of the label part of the receiver's view. "	| sen |	sen := self sensor.	^sen isActive and: [view labelBounds containsPoint: sen cursorPoint]</body></methods><methods><class-id>Lens.LDMElementViewController</class-id> <category>event driven</category><body package="LDM-Framework">handlerForMouseEvent: event	"answers self as the handler if the label view bounds contains the event,	otherwise answer nil"	^(self labelViewHasCursorWithEvent: event)		ifTrue: [self]		ifFalse: [nil]</body><body package="LDM-Framework">labelViewHasCursorWithEvent: event	"Answer true if the cursor point of the receiver's sensor lies within 	the display box of the label part of the receiver's view. "	| pt |	pt := self sensor cursorPointFor: event.	^view labelBounds containsPoint: pt</body><body package="LDM-Framework">redButtonPressedEvent: event	"If the control key is pressed then the view is added to the selection instead 	of replacing the old one"	event ctrlDown		ifTrue: [charged := #addSelection]		ifFalse: [charged := #replaceSelection]</body><body package="LDM-Framework">redButtonReleasedEvent: event	"do select when the red button is released"	charged notNil ifTrue: [self doSelect].</body></methods><methods><class-id>Lens.LDMCompositeView</class-id> <category>initialize-release</category><body package="LDM-Framework">scrollOffsetHolder: aValueHolder	aValueHolder grid: 65@25</body></methods><methods><class-id>Lens.LDMCompositeView</class-id> <category>controller accessing</category><body package="LDM-Framework">defaultControllerClass	"Answer the class of the default controller for the receiver."	^LDMCompositeViewController</body></methods><methods><class-id>Lens.LDMCompositeView</class-id> <category>hit detection</category><body package="LDM-Framework">componentsInside: aRectangle 	"Return a collection of components that are inside aRectangle"	^components select: [:c | aRectangle intersects: c bounds]</body></methods><methods><class-id>Lens.LDMCompositeView</class-id> <category>selection</category><body package="LDM-Framework">deselect</body><body package="LDM-Framework">select</body><body package="LDM-Framework">toggle</body></methods><methods><class-id>Lens.LDMCompositeView</class-id> <category>event driven</category><body package="LDM-Framework">handlerForMouseEvent: aMouseEvent	"Answer the first component that answers an object other than nil. Otherwise 	answer nil."	| ctrl  |	ctrl := self getController.	(ctrl isNil or: [(ctrl viewHasCursorWithEvent: aMouseEvent) not])		ifTrue: [^nil].	components size		to: 1		by: -1		do: 			[:i | 			| controlObject  |			controlObject := (components at: i) handlerForMouseEvent: aMouseEvent.			controlObject == nil ifFalse: [^controlObject]].	Object errorSignal handle: [:ex | "Trap errors occurring while searching for 		the object wanting control."		Controller badControllerSignal raiseErrorString: (#BadControllerMouseEvent &lt;&lt; #dialogs &gt;&gt; 'Bad controller in handlerForMouseEvent:')]		do: [^ctrl handlerForMouseEvent: aMouseEvent].	^nil</body></methods><methods><class-id>Lens.LDMVisualTreeConnection</class-id> <category>initialize-release</category><body package="LDM-Framework">flushCaches	preferredBounds := nil</body><body package="LDM-Framework">flushCoordinateCaches	preferredBounds := nil</body><body package="LDM-Framework">initialize	super initialize.	orientation := #horizontal</body></methods><methods><class-id>Lens.LDMVisualTreeConnection</class-id> <category>bounds accessing</category><body package="LDM-Framework">preferredExtent	preferredBounds ifNil: [ self computePreferredBounds ].	^preferredBounds extent</body></methods><methods><class-id>Lens.LDMVisualTreeConnection</class-id> <category>displaying</category><body package="LDM-Framework">displayOn: aGraphicsContext	orientation == #horizontal		ifTrue: [self displayHorizontalOn: aGraphicsContext]		ifFalse: [self displayVerticalOn: aGraphicsContext].</body></methods><methods><class-id>Lens.LDMVisualTreeConnection</class-id> <category>private</category><body package="LDM-Framework">childrenDo: aBlock 	"The block is executed for each one of the children"	children do: [:ch | aBlock value: ch node]</body><body package="LDM-Framework">computePreferredBounds	| left p right first top bottom last |	p := parent preferredBounds.	first := self firstChild preferredBounds.	last := self lastChild preferredBounds. 	orientation = #horizontal		ifTrue: [left := p right.				right := first left.				top := first top min: p top.				bottom := last bottom max: p bottom]		ifFalse: [left := first left min: p left.				right := last right max: p right .				top := p top.				bottom := first top].	preferredBounds := Rectangle left: left right: right top: top bottom: bottom</body><body package="LDM-Framework">displayHorizontalOn: aGraphicsContext 	| p cp |	p := parent bounds rightCenter + (2 @ 0).	self		childrenDo: 			[:c | 			cp := c bounds leftCenter - (2 @ 0).			aGraphicsContext displayLineFrom: p to: cp]</body><body package="LDM-Framework">displayVerticalOn: aGraphicsContext 	| p cp |	p := parent bounds bottomCenter + (0 @ 2).	self		childrenDo: 			[:c | 			cp := c bounds topCenter - (0 @ 2).			aGraphicsContext displayLineFrom: p to: cp]</body><body package="LDM-Framework">firstChild	children do: [:ch | ^ch node]</body><body package="LDM-Framework">lastChild	^children last node</body><body package="LDM-Framework">relsAndChildrenDo: aBlock 	"The block is executed for each NodeChild"	children do: [:ch | aBlock value: ch rel value: ch node]</body><body package="LDM-Framework">setOrientation: o parent: pvc children: childrenCollection	orientation := o.	parent := pvc.	children := childrenCollection</body><body package="LDM-Framework">setParent: pvc children: childrenCollection	parent := pvc.	children := childrenCollection</body></methods><methods><class-id>Lens.LDMVisualTreeConnection class</class-id> <category>instance-creation</category><body package="LDM-Framework">orientation: o parent: p children: c	^self new setOrientation: o parent: p children: c</body><body package="LDM-Framework">parent: p children: c	^self new setParent: p children: c</body></methods><methods><class-id>Lens.LDMArrowView</class-id> <category>display box accessing</category><body package="LDM-Framework">preferredBounds	"Compute the preferredBounds for the receiver"	CachedBounds == nil		ifTrue: 			[| imageOff imageOn labelOff labelOn labelStyle |			imageOff := offImage isNil						ifTrue: [0 @ 0]						ifFalse: [offImage preferredBounds extent].			imageOn := onImage isNil						ifTrue: [0 @ 0]						ifFalse: [onImage preferredBounds extent].			labelStyle := self currentSkin textAttributesForLists.			labelOff := (ComposedText withText: label style: labelStyle) preferredBounds extent.			labelOn := (ComposedText withText: label asText copy allBold style: labelStyle) preferredBounds extent.			CachedBounds := Rectangle origin: 0 @ 0 corner: (imageOff x + labelOff x max: imageOn x + labelOn x)							+ 0 @ ((imageOff y max: labelOff y)								max: (imageOn y max: labelOn y))].	^CachedBounds</body></methods><methods><class-id>Lens.LDMArrowView</class-id> <category>private</category><body package="LDM-Framework">useFilling	" Answer whether to color-invert the image. "	^false</body></methods><methods><class-id>Lens.LDMArrowView</class-id> <category>controller accessing</category><body package="LDM-Framework">defaultControllerClass	^LDMWidgetController</body></methods><methods><class-id>Lens.LDMArrowView class</class-id> <category>class initialization</category><body package="LDM-Framework">initialize	"CYDotView initialize"	| maskPalette |	CachedBounds := nil.	maskPalette := CoveragePalette monoMaskPalette.	EmptyImage := CachedImage on: (Image		extent: 10@9		depth: 1		palette: maskPalette		bits: #[				2r00000000 2r00000000				2r10000000 2r00000000				2r11100000 2r00000000				2r10011000 2r00000000				2r10000110 2r00000000				2r10011000 2r00000000				2r11100000 2r00000000				2r10000000 2r00000000				2r00000000 2r00000000			]		pad: 8).	FullImage := CachedImage on: (Image		extent: 10@9		depth: 1		palette: maskPalette		bits: #[				2r00000000 2r00000000				2r10000000 2r00000000				2r01100000 2r00000000				2r01111000 2r00000000				2r00111110 2r00000000				2r01111000 2r00000000				2r01100000 2r00000000				2r10000000 2r00000000				2r00000000 2r00000000			]		pad: 8).</body></methods><methods><class-id>Lens.LDMArrowView class</class-id> <category>instance creation</category><body package="LDM-Framework">model: mdl 	| dv |	dv := super model: mdl.	dv beVisual: EmptyImage ifTrue: FullImage.	^dv</body></methods><methods><class-id>UI.LDMWidgetTracker</class-id> <category>events</category><body package="LDM-Framework">redButtonPressedEvent: aMouseButtonEvent	"The first line of the super method releases the LDMArrowView on which we just clicked.  We therefore override to capture the location before calling the setUpFor:, not after."	| pt |	pt := self cursorPointFor: aMouseButtonEvent.	self setUpFor: aMouseButtonEvent.	aMouseButtonEvent isBlue ifFalse: [self trackSelectionFor: pt].	aMouseButtonEvent initiator grabMouseEventFor: self.	^nil</body></methods><methods><class-id>Lens.LDMBrowserModel</class-id> <category>initialize-release</category><body package="LDM-Framework">initialize	"The default is to be a graph, it can be changed to be an indented list programatically. If the browsers were added to the palette as specs, this would make sense as a property of the spec"	self beGraph</body></methods><methods><class-id>Lens.LDMBrowserModel</class-id> <category>accessing</category><body package="LDM-Framework">application	^application</body><body package="LDM-Framework">application: app	application := app</body><body package="LDM-Framework">attributesForRel: rel 	"Returns an array of attributes for the relationship rel"	^attributes at: rel</body><body package="LDM-Framework">beGraph	"The builder class is set to be the GraphBuilder. A builder will be created from this class, and it will build a graph to be presented in the view"	visualBuilderClass := LDMGraphBuilder</body><body package="LDM-Framework">beIndentedList 	"The builder class is set to be the IndentedListBuilder. A builder will be created from this class, and it will build an indented list to be presented in the view"	visualBuilderClass := LDMIndentedListBuilder</body><body package="LDM-Framework">body	"Return the body currently associated with this model.  If it 	hasn't been created, create it - this assumes that the body	will not be queried for before the perspective and focus	holders have been specified."	body == nil		ifTrue: 			[body := LDMRelationsBody new.			body viewModel: self.			self updateAttributesFor: perspectiveHolder value.			body perspective: perspectiveHolder value.			body focus: focusHolder value].	^body</body><body package="LDM-Framework">focusHolder	"Return the focusHolder."	^focusHolder</body><body package="LDM-Framework">focusHolder: aValue 	"Set the focusHolder.  Whenever the holder changes the	body needs to be recomputed with the new focus. This	way, whenever the focus changes the correct recomputation	happens"	focusHolder := aValue.	focusHolder		compute: 			[:focus | 			self body focus: focus.			body rebuild]</body><body package="LDM-Framework">perspective	^perspectiveHolder value</body><body package="LDM-Framework">perspectiveHolder: aValue 	"Set the perspectiveHolder.  Whenever the holder changes the	body needs to be recomputed with the new perspective. The	focus needs to be respecified since this information is wiped	out when the new perspective is sent.  The attributes also	need be updated with the settings in the new perspective."	perspectiveHolder := aValue.	perspectiveHolder		compute: 			[:perspective | 			self body perspective: perspective.			self body focus: self focusHolder value.			self updateAttributesFor: perspective.			self body rebuild]</body><body package="LDM-Framework">selectionService	"Return the selection service.  If the selection service is	not specified ('nil') this means the user wants a new one	created on the fly for each browser - so create it. If it is	wanted to share the selectionService, it should be assigned	to the browser model. The selection service can be shared at	all the different levels, for example, an application could chose to	have a selection service per window, but when there is more	than one browser in a window, they share the selection service"	selectionService == nil ifTrue: [selectionService := LDMSelectionService new].	^selectionService</body><body package="LDM-Framework">selectionService: aService	"Set the selection service. This is useful for sharing sel. serv."	selectionService := aService</body><body package="LDM-Framework">visualBuilderClass	^visualBuilderClass</body><body package="LDM-Framework">visualBuilderClass: aClass	visualBuilderClass := aClass</body></methods><methods><class-id>Lens.LDMBrowserModel</class-id> <category>selection service</category><body package="LDM-Framework">select: anElement 	"If anElement is in the graph, select it. This is used to programatically select elements. The selection service keeps the selections as the views that are selected, the model wants to understand them in terms of elements"	| visual |	visual := self body visualForElement: anElement.	visual notNil ifTrue: [self selectionService newSelection: (Array with: visual)]</body></methods><methods><class-id>Lens.LDMBrowserModel</class-id> <category>update</category><body package="LDM-Framework">graphHasChanged	self changed: #graph</body></methods><methods><class-id>Lens.LDMBrowserModel</class-id> <category>private</category><body package="LDM-Framework">updateAttributesFor: perspective 	"Arrange the attributes of the relationships in a dictionary so the access is faster. The attributes in the 	dictionary may be programatically changed, thus overriding the default defined in the perspective"	attributes := IdentityDictionary new.	perspective relDesc		do: 			[:rDesc | 			| rel |			rel := LDMRelationship at: (rDesc at: 1) asSymbol.			attributes at: rel put: rDesc copy]</body></methods><methods><class-id>Lens.LDMBrowserModel class</class-id> <category>instance creation</category><body package="LDM-Framework">focusHolder: aFocusHolder perspectiveHolder: aPerspectiveHolder selectionService: aSelectionService 	"Create a fully specified browser model."	^LDMBrowserModel new focusHolder: aFocusHolder; perspectiveHolder: aPerspectiveHolder; selectionService: aSelectionService</body><body package="LDM-Framework">new	^super new initialize</body></methods><methods><class-id>Lens.LDMBrowserBodyView</class-id> <category>accessing</category><body package="LDM-Framework">decorator	^decorator</body><body package="LDM-Framework">decorator: deco	decorator := deco</body></methods><methods><class-id>Lens.LDMBrowserBodyView</class-id> <category>adding-removing</category><body package="LDM-Framework">body: aBody	self releaseAllComponents.	self add: aBody.</body></methods><methods><class-id>Lens.LDMBrowserBodyView</class-id> <category>updating</category><body package="LDM-Framework">update: aspect	aspect == #graph ifTrue: [		decorator notNil ifTrue: [decorator flushCaches]]</body></methods><methods><class-id>Lens.LDMIndentedListBuilder</class-id> <category>initialize-release</category><body package="LDM-Framework">initialize	super initialize.	self reset.</body><body package="LDM-Framework">reset	bottom := 0.	spacing := 16@4</body></methods><methods><class-id>Lens.LDMIndentedListBuilder</class-id> <category>build</category><body package="LDM-Framework">internalBuild: node depth: aDepth	"Build a node for 'elem'. We are currently building for depth 	'aDepth'. If the node does not have a depth (i.e. has not been 	encountered before), ... 	Descend any nodes we have not previously encountered."	"We do not deal with DAG nor Cyclic graphs right now"	node pass ~~ #build		ifTrue: 			[node depth: aDepth.			node pass: #build.			node children do: [:kidNode | self internalBuild: kidNode node depth: aDepth + 1]]		ifFalse: [(aDepth &gt; 1 and: [node depth == 1])				ifTrue: [self recursivelyReset: node toDepth: aDepth]].	^node</body><body package="LDM-Framework">recursivelyReset: aNode toDepth: aDepth	"When a node is moved (maybe because a new reference was found, pushing the node farther), then itself and all its children have to be moved to deeper depths"	| kids |	aNode depth: aDepth.	kids := aNode children.	kids size &gt; 0 ifTrue: [kids do: [:kid | self recursivelyReset: kid node toDepth: aDepth + 1]]</body><body package="LDM-Framework">visualForGraph: aGraph viewModel: aModel	self reset.	^super visualForGraph: aGraph viewModel: aModel</body></methods><methods><class-id>Lens.LDMIndentedListBuilder</class-id> <category>private</category><body package="LDM-Framework">stepNextPositionFor: node	"Assign final position to leaf node."	| bounds |	bounds := node bounds.	bottom :=  (bounds bottom + self verticalSpacing) max: bottom</body></methods><methods><class-id>Lens.LDMIndentedListBuilder</class-id> <category>uilayout</category><body package="LDM-Framework">layout	| level1 |	composite computePreferredBounds.	referenceConnections := IdentityDictionary new.	level1 := SortedCollection sortBlock: [:a :b | a component sortKey &lt;= b component sortKey].	self nodesDo: [:node | node depth = 1 ifTrue: [level1 add: node]].	level1 do: [:node | self layoutNode: node].	composite computePreferredBounds</body><body package="LDM-Framework">layoutNode: node 	"Layout the subgraph rooted at node. "	node setOrigin: node depth * self horizontalSpacing @ bottom.	self stepNextPositionFor: node.	node children do: [:kid | self layoutNode: kid node].	"node reference == nil		ifFalse: 			[| connect |			connect := referenceConnections at: node object						ifAbsent: 							[| nc |							nc := CYListReferenceConnection new.							nc referent: node reference.							composite add: nc.							referenceConnections at: node object put: nc.							nc].			connect addReference: node]"</body></methods><methods><class-id>Lens.LDMIndentedListBuilder class</class-id> <category>instance creation</category><body package="LDM-Framework">newTree	| b |	b := self new.	b initializeVisualConnectionAsBroom.	b initializeVisualComponentAsCFList.	^b</body></methods><methods><class-id>Lens.LDMElementProxy</class-id> <category>initialize-release</category><body package="LDM-Framework">initialize	"To be used by subclasses"</body><body package="LDM-Framework">on: el	element := el</body></methods><methods><class-id>Lens.LDMElementProxy</class-id> <category>accessing</category><body package="LDM-Framework">context	"The default context is an IdentityDictionary"	context isNil ifTrue: [ context := IdentityDictionary new].	^context</body><body package="LDM-Framework">element	^element</body><body package="LDM-Framework">element: anElement	element := anElement</body></methods><methods><class-id>Lens.LDMElementProxy</class-id> <category>printing</category><body package="LDM-Framework">printOn: aStream	"Add {} to show that this is a wrapper on the element and not the element itself"	aStream nextPut: ${.	element printOn: aStream.	aStream nextPut: $}.	^self</body></methods><methods><class-id>Lens.LDMElementProxy</class-id> <category>relationships</category><body package="LDM-Framework">relatedBy: token	"The default is to let the element respond with the relationship. This is most likely to be changed by subclasses"	^element relatedBy: token</body><body package="LDM-Framework">stringKey: hints	"The key shown in the graphs is the same as the key for the element. Subclasses may redefine this to provide functionality not available in the wrapped element"	^element stringKey: hints</body></methods><methods><class-id>Lens.LDMElementProxy class</class-id> <category>class initialization</category><body package="LDM-Framework">initialize	"Note that 'Elements' is a class instance variable. Therefore each subclass using the global dictionary facility should initialize"	"ReversingElementWrapper initialize"	Elements := IdentityDictionary new</body></methods><methods><class-id>Lens.LDMElementProxy class</class-id> <category>instance creation</category><body package="LDM-Framework">newOn: el	"This method can be redefined in subclasses to add the instance to the 'Elements' dictionary, if so desired"	^self new initialize on: el</body></methods><methods><class-id>Lens.LDMElementProxy class</class-id> <category>accessing</category><body package="LDM-Framework">at: el 	^Elements at: el ifAbsent: [Elements at: el put: (self newOn: el)]</body></methods><methods><class-id>Lens.LDMReversingElementProxy</class-id> <category>initialize-release</category><body package="LDM-Framework">initialize	related := Dictionary new.</body></methods><methods><class-id>Lens.LDMReversingElementProxy</class-id> <category>relationships</category><body package="LDM-Framework">elementLabel: hints	^element elementLabel: hints</body><body package="LDM-Framework">related: other by: aRelationship	"Add other to the set of elements that are related to us by aRelationship"	| bag |	bag := related at: aRelationship ifAbsent: [related at: aRelationship put: Set new].	bag add: other</body><body package="LDM-Framework">relatedBy: rel 	"Compute the relationship. For each one of the related ones notify the other that we are related to them. This way, the other can keep track of the reverse relationship"	^related at: rel		ifAbsent: 			[| bag rltd |			rltd := element relatedBy: rel.			bag := Set new.			rltd do: [:r | (bag add: (self class at: r))					related: self by: (self reverse: rel)].			related at: rel put: bag]</body></methods><methods><class-id>Lens.LDMReversingElementProxy</class-id> <category>private</category><body package="LDM-Framework">reverse: rel 	"Utility for computing the token for the revere relationship"	((rel at: (rel size - 3)) == $R)		ifTrue: [^((rel copyFrom: 1 to: rel size - 4)				, 'Rel') asSymbol]		ifFalse: [^((rel copyFrom: 1 to: rel size - 3)				, 'RRel') asSymbol]</body></methods><methods><class-id>Lens.LDMSpecialRel</class-id> <category>initialize-release</category><body package="LDM-Framework">onBlock: ablk	"Set the evaluation block"	evaluationBlock := ablk</body><body package="LDM-Framework">reset	"These relationships are not readed and can not be saved, the reverse is expected to be set and not computed or named"</body></methods><methods><class-id>Lens.LDMSpecialRel</class-id> <category>computing</category><body package="LDM-Framework">relatedTo: el	"Evaluate the block on the element we are asked to compute the relationship for. This gives the flexibility of implementing relationships in a way external to the elements themselves, thus avoiding changing the elements or having to implement the relationship in  many places"	^evaluationBlock value: el</body></methods><methods><class-id>Lens.LDMSpecialRel</class-id> <category>printing</category><body package="LDM-Framework">storeOn: aStream	"Can not really be stored in a stream"	nil storeOn: aStream</body></methods><methods><class-id>Lens.LDMSpecialRel class</class-id> <category>class initialization</category><body package="LDM-Framework">initialize	"Create the = relationship. When computed it returns the same element it is computed for. Of course, it is the reverse to itself"	"SpecialRel initialize"	| newOne |	newOne := self withToken: #'=Rel'.	newOne name: #=.	newOne onBlock: [:el | IdentitySet with: el].	newOne reverse: newOne.	Relationships at: #= put: newOne</body></methods><methods><class-id>Lens.LDMGraphCompositeView</class-id> <category>accessing</category><body package="LDM-Framework">builder: b    builder := b</body><body package="LDM-Framework">selectionService	^model selectionService</body></methods><methods><class-id>Lens.LDMGraphCompositeView</class-id> <category>broadcast</category><body package="LDM-Framework">upcastEvent: aKey with: aParameter from: anInitiator path: aPathCollection 	"This is a message passed up the view structure through all 	containers. If aPathCollection is not nil then the client desires for 	the containment path to be collected as a side effect."	"If the message is a change in the selection, then we perform the required 	action"	aKey == #selectionChange ifTrue: [aParameter == #replaceSelection			ifTrue: [self selectSubView: anInitiator replace: true]			ifFalse: [aParameter == #addSelection					ifTrue: [self selectSubView: anInitiator replace: false]					ifFalse: [super							upcastEvent: aKey							with: aParameter							from: anInitiator							path: aPathCollection]]]</body></methods><methods><class-id>Lens.LDMGraphCompositeView</class-id> <category>private</category><body package="LDM-Framework">changedPreferredGeometryForComponent: aVisualComponent 	"Do re-layout for the whole tree"	| ct    |	ct := container.	container := nil.	builder layout.	container := ct.	self bounds: self bounds.	self invalidate</body><body package="LDM-Framework">selectSubView: subView replace: replaceCurrentSelection 	"Adds or replaces the current selection with subView"	replaceCurrentSelection		ifTrue: [self selectionService newSelection: (Array with: subView)]		ifFalse: [self selectionService addOne: subView]</body></methods><methods><class-id>Lens.LDMBroomConnection</class-id> <category>accessing</category><body package="LDM-Framework">builder	^builder</body><body package="LDM-Framework">builder: aBuilder	builder := aBuilder</body><body package="LDM-Framework">model	^model</body><body package="LDM-Framework">model: aModel	model := aModel</body></methods><methods><class-id>Lens.LDMBroomConnection</class-id> <category>testing</category><body package="LDM-Framework">intersects: aRectangle 	"Answer whether the receiver intersects aRectangle."	"If we have a known refreshArea see if we intersect it, 	if not assume we intersect everything."	^refreshArea == nil		ifTrue: [true]		ifFalse: [refreshArea intersects: aRectangle]</body></methods><methods><class-id>Lens.LDMBroomConnection</class-id> <category>private</category><body package="LDM-Framework">computePreferredBounds	| left p right top bottom chanOff |	p := parent preferredBounds.	top := p top.	bottom := p bottom.	right := p right.	left := right.	chanOff := builder channelOffsets at: parent ifAbsent: [nil].	self		relsAndChildrenDo: 			[:rel :kid | 			| kidBounds |			kidBounds := kid bounds.			top := top min: kidBounds top.			kid depth &lt;= parent depth				ifTrue: 					[| nextDepth |					chanOff == nil ifFalse: [bottom := bottom max: chanOff + (self lineWidthFor: rel)].					nextDepth := parent depth + 1.					right := right max: (nextDepth &lt;= builder columnPositions size									ifTrue: [builder columnPositions at: nextDepth]									ifFalse: [(builder highwayPositions at: parent depth)											+ 30]).					left := left min: (kid depth &gt; 1									ifTrue: [builder highwayPositions at: kid depth - 1]									ifFalse: [0])]				ifFalse: 					[bottom := bottom max: kidBounds bottom.					right := right max: kidBounds right]].	refreshArea := preferredBounds := Rectangle						left: left						right: right						top: top						bottom: bottom</body><body package="LDM-Framework">displayHorizontalOn: aGraphicsContext 	"Display the broom. Compute a nexus which 	all (non-recursive) connection go thru. For 	each child node draw the line from parent to 	child. In the process compute the refreshArea, 	that is the area that if damaged we need to 	refresh."	| par maxNexus chanOff cpxMin baseNexus oldLineWidth oldColor olw oc |	chanOff := nil.	cpxMin := nil.	par := parent bounds rightCenter.	maxNexus := baseNexus := (builder highwayPositions at: parent depth)						@ par y.	olw := oldLineWidth := aGraphicsContext lineWidth.	oc := oldColor := aGraphicsContext paint.	self		relsAndChildrenDo: 			[:rel :kid | 			| cp cpx nexus nlw nc |			(nlw := self lineWidthFor: rel) ~~ olw ifTrue: [aGraphicsContext lineWidth: (olw := nlw)].			(nc := self lineColorFor: rel) ~~ oc ifTrue: [aGraphicsContext paint: (oc := nc)].			cp := kid bounds leftCenter - (1 @ 0).			kid depth &lt;= parent depth				ifTrue: 					[| firstCol |					chanOff == nil ifTrue: [chanOff := builder channelOffsets at: parent].					cpx := cp x.					(cpxMin == nil or: [cpx &lt; cpxMin])						ifTrue: [cpxMin := cpx].					firstCol := kid depth &gt; 1								ifTrue: [builder highwayPositions at: kid depth - 1]								ifFalse: [0].					self						halfEllipseOn: aGraphicsContext						startPoint: cp						xEnd: firstCol						yEnd: chanOff						startAngle: 90]				ifFalse: 					[nexus := (builder highwayPositions at: kid depth - 1)								@ par y.					nexus &lt;= par ifTrue: [nexus := par].					nexus &gt;= maxNexus ifTrue: [maxNexus := nexus].					aGraphicsContext displayLineFrom: nexus to: cp]].	aGraphicsContext displayLineFrom: par to: maxNexus.	chanOff == nil		ifFalse: 			[| nextCol colPos nextDepth |			colPos := builder columnPositions.			nextDepth := parent depth + 1.			nextCol := nextDepth &lt;= colPos size						ifTrue: [colPos at: nextDepth]						ifFalse: [nil].			self				halfEllipseOn: aGraphicsContext				startPoint: baseNexus				xEnd: nextCol				yEnd: chanOff				startAngle: -90.			aGraphicsContext displayLineFrom: cpxMin @ chanOff to: baseNexus x @ chanOff].	aGraphicsContext lineWidth: oldLineWidth.	aGraphicsContext paint: oldColor</body><body package="LDM-Framework">halfEllipseOn: aGraphicsContext startPoint: startPoint xEnd: xEnd yEnd: yEndParm startAngle: startAngle 	| yStart yArc xhArc rect yEnd |	(aGraphicsContext class == nil"CYPSGenerator") ifTrue: [^self halfEllipsePSOn: aGraphicsContext startPoint: startPoint xEnd: xEnd yEnd: yEndParm startAngle: startAngle ].	startPoint y &lt; yEndParm		ifTrue: 			[yStart := startPoint y.			yEnd := yEndParm]		ifFalse: 			[yStart := yEndParm.			yEnd := startPoint y].	yArc := yEnd - yStart.	xhArc := xEnd == nil				ifTrue: [(yArc // 2) min: 30]				ifFalse: [(xEnd - startPoint x) abs - 2].	xhArc * 2 &gt; yArc ifTrue: [xhArc := yArc // 2].	rect := startPoint x - xhArc @ yStart corner: startPoint x + xhArc @ yEnd.	aGraphicsContext		displayArcBoundedBy: rect		startAngle: startAngle		sweepAngle: 180</body><body package="LDM-Framework">halfEllipsePSOn: aGraphicsContext startPoint: startPoint xEnd: xEnd yEnd: yEndParm startAngle: startAngle 	| yStart yArc xhArc rect yEnd |	startPoint y &lt; yEndParm		ifTrue: 			[yStart := startPoint y.			yEnd := yEndParm]		ifFalse: 			[yStart := yEndParm.			yEnd := startPoint y].	yArc := yEnd - yStart.	xhArc := xEnd == nil				ifTrue: [yArc // 2]				ifFalse: [(xEnd - startPoint x) abs - 2].	xhArc * 2 &gt; yArc ifTrue: [xhArc := yArc // 2].	rect := Rectangle				left: startPoint x				right: startPoint x + (startAngle &lt; 0							ifTrue: [xhArc]							ifFalse: [xhArc negated])				top: yStart				bottom: yEnd.	aGraphicsContext		displayArcBoundedBy: rect		startAngle: startAngle		sweepAngle: 180</body><body package="LDM-Framework">lineColorFor: rel	^(model attributesForRel: rel) at: 4</body><body package="LDM-Framework">lineWidthFor: rel	^(model attributesForRel: rel) at: 5</body><body package="LDM-Framework">setOrientation: o parent: pvc children: childrenCollection builder: aBuilder	self setOrientation: o parent: pvc children: childrenCollection.	self builder: aBuilder</body></methods><methods><class-id>Lens.LDMBroomConnection class</class-id> <category>instance-creation</category><body package="LDM-Framework">orientation: theOrientation parent: theParent children: theChildren builder: theBuilder	^self new setOrientation: theOrientation parent: theParent children: theChildren builder: theBuilder</body></methods><methods><class-id>Lens.LDMListElementWrapper</class-id> <category>accessing</category><body package="LDM-Framework">reference	^reference</body><body package="LDM-Framework">reference: aRef	reference := aRef</body></methods><methods><class-id>Lens.LDMGraphElementWrapper</class-id> <category>accessing</category><body package="LDM-Framework">builder: aBuilder	builder := aBuilder</body></methods><methods><class-id>Lens.LDMGraphElementWrapper</class-id> <category>bounds accessing</category><body package="LDM-Framework">translation	"Answer the receiver's translation."	| cPos |	cPos := builder columnPositions.	^((cPos == nil or: [cPos size &lt; depth])		ifTrue: [0]		ifFalse: [cPos at: depth])		@ origin value y</body></methods><methods><class-id>Lens.LDMGraphElementWrapper class</class-id> <category>instance creation</category><body package="LDM-Framework">on: aVisualComponent at: aPoint builder: aBuilder 	| baby |	baby := self on: aVisualComponent at: aPoint.	baby builder: aBuilder.	^baby</body></methods><methods><class-id>Lens.LDMLimitingRel</class-id> <category>initialize release</category><body package="LDM-Framework">reset	"After readed references are symbols"</body></methods><methods><class-id>Lens.LDMLimitingRel</class-id> <category>accessing</category><body package="LDM-Framework">limitingBlock: aBlock	"aBlock has one parameter"	limitingBlock := aBlock</body></methods><methods><class-id>Lens.LDMLimitingRel</class-id> <category>computing</category><body package="LDM-Framework">computeReverse	"The reverse relationship is formed by using the same limiting block on the reverse of the basic relationship. This works quite well for limiting blocks that are symetric, and it is likely that the block will be symetrical because it is not given the element for which the relationship is being computed"	reverse := self class newWithRel: r1 reverse named: name,' Reverse' limitedBy: limitingBlock</body><body package="LDM-Framework">relatedTo: el	"Computes the basic relationship. Selects only those elements where the limitingBlock returns true"	^(r1 relatedTo: el) select: limitingBlock</body></methods><methods><class-id>Lens.LDMLimitingRel</class-id> <category>printing</category><body package="LDM-Framework">storeOn: aStream	nil storeOn: aStream</body></methods><methods><class-id>Lens.LDMLimitingRel class</class-id> <category>class initialization</category><body package="LDM-Framework">initialize	"Initialize relationships limited by a block"</body></methods><methods><class-id>Lens.LDMLimitingRel class</class-id> <category>instance creation</category><body package="LDM-Framework">newWithRel: r named: nm limitedBy: lmBlck 	^(super newWithRel: r named: nm)		limitingBlock: lmBlck</body></methods><methods><class-id>Lens.LDMCompositeViewController</class-id> <category>actions</category><body package="LDM-Framework">select	"If I got this it means that nobody wanted control so I do my part"	view selectionService deselectAll</body></methods><methods><class-id>Lens.LDMCompositeViewController</class-id> <category>control defaults</category><body package="LDM-Framework">isControlActive	"Answer whether the receiver wants to retain control.  The default is to	retain control if the cursor is inside the view and the blue button is not	pressed.  Pressing blue button will default to explicitly give up control	without moving the cursor."	"It is sent by Controller|controlLoop in order to determine when the	receiver's control loop should terminate, and should be redefined in	a subclass if some other condition for terminating the main control	loop is needed."	^self isControlWanted</body><body package="LDM-Framework">isControlWanted	"Answer true if the cursor is inside the display box of the receiver's view."	"Subclasses may want to enhance this test."	^super isControlWanted and: [self sensor yellowButtonPressed]</body></methods><methods><class-id>Lens.LDMCompositeViewController</class-id> <category>menu processing</category><body package="LDM-Framework">localMenuItem: aSymbol		^#menuSelectAll = aSymbol</body><body package="LDM-Framework">menuSelectAll	"Select all views inside the window"	| set |	set := view componentsInside: nil.	view selectionService newSelection: set.</body></methods><methods><class-id>Lens.LDMProtoMapBuilder</class-id> <category>build</category><body package="LDM-Framework">build	"Reorder the database columns after the graph is built"	super build.	self reorderColumns</body><body package="LDM-Framework">reorderColumns	"Get the maximum depth where database columns are found. Then make sure all the columns are at that depth. This way, the columns will all be shown in one column"	| max colNds |	colNds := OrderedCollection new.	max := 0.	nodeDict do: [:nd | (#{LensDatabaseTableColumn}		ifDefinedDo: [:lensDatabaseTableColumn | (nd component selectionPerformer isKindOf: lensDatabaseTableColumn)]		elseDo: [false])			ifTrue: 				[colNds add: nd.				nd depth &gt; max ifTrue: [max := nd depth]]].	colNds		do: 			[:cnd | 			cnd depth == 1 ifTrue: [cnd isRoot: true].			cnd depth: max]</body></methods><methods><class-id>Lens.LDMArc</class-id> <category>initialize-release</category><body package="LDM-Framework">initialize	"Initially, no active phases, vars not yet specified, 	and unrestricted on both sides."	activePhases := IdentitySet new.	varOnSide := Array new: 2.	isRestrictedOnSide := Array with: false with: false.</body></methods><methods><class-id>Lens.LDMArc</class-id> <category>accessing</category><body package="LDM-Framework">addUserCanOpenTo: openableGraph 	"Add to the Graph 'openableGraph' all the new relationships 	which can be opened from this arc. Whether they are already open or not"	self graph elementsDo: [:el | 1 to: 2			do: 				[:side | 				| want accept |				want := self relatedTo: el fromSide: side.				want size &gt; 0					ifTrue: 						[accept := (varOnSide at: (self otherSide: side))									canAddElements: want									fromArc: self									phase: #automatic.						openableGraph							addToElement: el							atSide: side							andRelationship: relationship							elements: accept]]]</body><body package="LDM-Framework">graph	^generator graph</body><body package="LDM-Framework">isActiveIn: phase	"Is this arc active is phase 'phase'?"	^activePhases includes: phase</body><body package="LDM-Framework">relationship	"Return the kind of relationship this arc handles."	^relationship</body><body package="LDM-Framework">userOpens	"Is this arc active is phase #userOpens?"	^self isActiveIn: #userOpens</body></methods><methods><class-id>Lens.LDMArc</class-id> <category>computing</category><body package="LDM-Framework">addElements: els fromSide: side phase: phase 	"The elements 'els' have been added to the variable on side 'side'. 	See if this means other relationships should be opened on the 	other side. Do this by finding which elements each element can 	connect to and adding these."	| otherSideVar |	otherSideVar := varOnSide at: (self otherSide: side).	els		do: 			[:el | 			| other |			other := self relatedTo: el fromSide: side.			other size &gt; 0				ifTrue: 					[other := otherSideVar								canAddElements: other								fromArc: self								phase: phase.					other size &gt; 0						ifTrue: 							[self								addRelationshipsBetween: el								fromSide: side								and: other.							otherSideVar addElements: other phase: phase]]]</body><body package="LDM-Framework">canAddElements: els fromSide: side phase: phase 	"Returns the subset of 'els' which can be opened."	"If there is no restriction on side 'side' then all the elements can be 	added. Otherwise, each element is checked whether it is related to 	at least one element in the other side"	| retElems |	(isRestrictedOnSide at: side)		ifFalse: [^els].	retElems := IdentitySet new.	els		do: 			[:el | 			| others |			others := self relatedTo: el fromSide: side.			others notNil				ifTrue: 					[others := (varOnSide at: (self otherSide: side))								canAddElements: others								fromArc: self								phase: phase.					others size &gt; 0 ifTrue: [retElems add: el]]].	^retElems</body><body package="LDM-Framework">openAllRelatedTo: el side: side 	"Opens all the elements related to el that can be opened through this arc"	| want accept |	want := self relatedTo: el fromSide: side.	want size == 0 ifTrue: [want := self fromUserOpensRelatedTo: el fromSide: side].	want size &gt; 0		ifTrue: 			[want := want - (self graph elementsFromElement: el side: side).			want size &gt; 0				ifTrue: 					[accept := (varOnSide at: (self otherSide: side))								canAddElements: want								fromArc: self								phase: #automatic.					self						userOpenFrom: el						to: accept						side: side]]</body><body package="LDM-Framework">userClosedFrom: el to: related side: side 	"The user has closed the relationships between 'el' 	and 'related' on this arc. So remove it from the 	list of relationships. We do not check connectivity 	with the focus, as this closing may be a part of a batch of closing, so the 	connectivity will be checked later"	self graph		removeFromElement: el		atSide: side		andRelationship: relationship		elements: related.</body><body package="LDM-Framework">userOpenFrom: el to: related side: side 	"The user has opened the relationships between 'el' 	and 'related' on this arc. So record this in myself and 	open any relationships that should be opened automatically 	as a result."	| elAsSet otherSide |	elAsSet := IdentitySet with: el.	otherSide := self otherSide: side.	self		addRelationshipsBetween: el		fromSide: side		and: related.	related do: [:relEl | self			addRelationshipsBetween: relEl			fromSide: otherSide			and: elAsSet].	(varOnSide at: side)		addElements: elAsSet phase: #automatic.	(varOnSide at: otherSide)		addElements: related phase: #automatic</body></methods><methods><class-id>Lens.LDMArc</class-id> <category>construction</category><body package="LDM-Framework">beActiveIn: phase	"Specifies that this arc is active in phase 'phase'."	^activePhases add: phase</body><body package="LDM-Framework">beRestrictedIn: side	"Specifies that this arc is restricted on side 'side'. Been restricted means it has to have an element on this side for each element in the other side"	isRestrictedOnSide at: side put: true</body><body package="LDM-Framework">generator: aGenerator	generator := aGenerator</body><body package="LDM-Framework">putVariable: var atSide: side	"Specifies that the variable on side 'side' of this arc is 'var' ."	varOnSide at: side put: var</body><body package="LDM-Framework">relationship: rel	"Specifies that this is a 'rel' relationship  arc."	relationship := rel</body></methods><methods><class-id>Lens.LDMArc</class-id> <category>printing</category><body package="LDM-Framework">printOn: aStream	"Mainly for debugging purposes" 	aStream nextPutAll: 'Arc&lt; '.	relationship printOn: aStream.	aStream nextPut: $&gt;</body></methods><methods><class-id>Lens.LDMArc</class-id> <category>private</category><body package="LDM-Framework">addRelationshipsBetween: el fromSide: side and: related 	"Add all the relationships on this arc between 'el' and 'related' 	which are on side 'side' of 'el'."	self graph					addToElement: el					atSide: side					andRelationship: relationship					elements: related.</body><body package="LDM-Framework">fromUserOpensRelatedTo: el fromSide: side 	"This method is used to access the information in the userOpens graph. This is needed in cases where 	the element itself doesn't know who is related to it"	^generator userCanOpen		withElement: el		atSide: side		andRelationship: relationship</body><body package="LDM-Framework">otherSide: side	"responds the other side of side"	side == 1 ifTrue: [^2].	^1</body><body package="LDM-Framework">relatedTo: element fromSide: side 	"The given element is at side 'side', returns the related elements for 	the other side of the relationship."	^side == 1		ifTrue: [relationship relatedTo: element]		ifFalse: [relationship reverse relatedTo: element]</body></methods><methods><class-id>Lens.LDMArc class</class-id> <category>instance creation</category><body package="LDM-Framework">new	^super new initialize</body></methods><methods><class-id>UI.UILookPolicy</class-id> <category>private-object lens</category><body package="LDM-Framework">browser: spec into: builder	| component model menu    | 	model := spec modelInBuilder: builder.	component := LDMBrowserBodyView new.	builder decorator: (component inDefaultEdgeDecorator).	builder wrapper: (BoundedWrapper on: builder decorator).	builder decorator setWidgetFlags: spec scrollingFlags.	component decorator: builder decorator.	component model: model.	component controller: LDMCompositeViewController new.	component controller performer: builder source.	component body: model body bodySubView.	(menu := spec getMenuIn: builder) == nil		ifFalse: [component controller menuHolder: menu]."===	(performer := spec getPerformerIn: builder) == nil		ifFalse: [component controller performer:  performer].==="	builder component: component.	spec decorationType == #bordered		ifTrue: [builder wrapWith: self borderedWrapperClass new.				builder wrapper inset: 0.				builder wrapper border: self inputFieldBorder]		ifFalse: [builder wrapWith: self boundedWrapperClass new].	builder applyLayout: spec layout.	builder wrapWith: (self simpleWidgetWrapperOn: builder spec: spec state: nil)</body></methods><methods><class-id>Core.Object</class-id> <category>relationships</category><body package="LDM-Framework">elementLabel: hints 	"This method returns a visual component used to represent myself in a browser graph.	 The default is to return a Label with my string key."	^Label with: (self stringKey: hints)</body><body package="LDM-Framework">relatedBy: token	token == #isInstanceOfRel ifTrue: [^IdentitySet with: self class].	^IdentitySet new</body><body package="LDM-Framework">sortKey	"Returns a string used for sorting elements in a browser. By default returns the string key"	^self stringKey: #(sort)</body><body package="LDM-Framework">stringKey: hints 	"A string used to represent myself in browsers, for example in a menu. The 	default is to use my displayString"	^self displayString</body></methods><methods><class-id>Lens.LensGraphView class</class-id> <category>interface opening</category><body package="LDM-Framework">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: #(#{Kernel.UserMessage} #key: #DatabaseTables #defaultString: 'Database tables' #catalogID: #labels) 			#min: #(#Point 20 20 ) 			#bounds: #(#Rectangle 396 344 596 544 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#LDMBrowserSpec 					#layout: #(#LayoutFrame 2 0 2 0 -2 1 -2 1 ) 					#name: #ldmBrowser 					#model: #bm ) ) ) )</body></methods><methods><class-id>Lens.LDMBrowserSpec class</class-id> <category>interface specs</category><body package="LDM-Framework">basicsEditSpec	"UIPainter new openOnClass: self andSelector: #basicsEditSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: ' ' 			#min: #(#Point 300 171 ) 			#max: #(#Point 300 171 ) 			#bounds: #(#Rectangle 220 356 520 527 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#InputFieldSpec 					#layout: #(#LayoutFrame 60 0 28 0 -10 1 53 0 ) 					#model: #name 					#menu: #fieldMenu ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 0 0.5 4 0 0.5 0 ) 					#label: #(#{Kernel.UserMessage} #key: #LDMBrowser #defaultString: 'LDMBrowser' #catalogID: #labels) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 10 0 53 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #IDC #defaultString: 'ID:' #catalogID: #labels) ) ) ) )</body></methods><initialize><class-id>Lens.LDMRelationship</class-id></initialize><initialize><class-id>Lens.LDMPerspective</class-id></initialize><initialize><class-id>Lens.LensGraphView</class-id></initialize><initialize><class-id>Lens.LDMSelectionService</class-id></initialize><initialize><class-id>Lens.LDMArrowView</class-id></initialize><initialize><class-id>Lens.LDMElementProxy</class-id></initialize><initialize><class-id>Lens.LDMSpecialRel</class-id></initialize><initialize><class-id>Lens.LDMLimitingRel</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>VisualComponent</name><environment>Graphics</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Visual Objects</category><attributes><package>Graphics-Visual Objects</package></attributes></class><class><name>Model</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dependents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>LabeledBooleanView</name><environment>UI</environment><super>UI.BooleanWidgetView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>label onImage offImage </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category><attributes><package>UIBasics-Components</package></attributes></class><class><name>ControllerWithMenu</name><environment>UI</environment><super>UI.Controller</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuHolder performer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Framework</category><attributes><package>Interface-Framework</package></attributes></class><class><name>CompositeView</name><environment>UI</environment><super>Graphics.DependentComposite</super><private>false</private><indexed-type>none</indexed-type><inst-vars>controller </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Support</category><attributes><package>UIBasics-Support</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>WidgetController</name><environment>UI</environment><super>UI.Controller</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cursor activeAccessor evenIfKeyPressed controlBlock enableYellowButton </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Controllers</category><attributes><package>UIBasics-Controllers</package></attributes></class><class><name>WidgetTracker</name><environment>UI</environment><super>UI.SelectionTracker</super><private>false</private><indexed-type>none</indexed-type><inst-vars>startDelay stepDelay </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Events-Trackers</category><attributes><package>Interface-Events-Trackers</package></attributes></class><class><name>MenuComponentSpec</name><environment>UI</environment><super>UI.WidgetSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menu performer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Specifications</category><attributes><package>UIBuilder-Specifications</package></attributes></class><class><name>TranslatingWrapper</name><environment>Graphics</environment><super>Graphics.Wrapper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>origin </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Visual Objects</category><attributes><package>Graphics-Visual Objects</package></attributes></class><class><name>UILookPolicy</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>systemAttributes systemWidgetAttributes useSystemFontOnWidgets systemMenuAttributes </class-inst-vars><imports></imports><category>UIBuilder-Support</category><attributes><package>UIBuilder-Support</package></attributes></class></st-source>