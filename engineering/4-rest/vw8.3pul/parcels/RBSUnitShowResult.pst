<?xml version="1.0"?><st-source><!-- Name: RBSUnitShowResultNotice: Copyright 2012-2017 Cincom Systems, Inc.  All rights reserved.Comment: I prereq RBSUnitExtensions, so show the overall test suite result on the Refactoring Browser taskbar.  I also display an icon showing the latest result of running each test against its method.  I also add a page ('Testing') to the 'Tools' section of the VisualLauncher's settings.  This page lets users set whatever test run behaviour they want (i.e. over and above the settings that drive my behaviour) by choosing which subclass of TestSuite and/or which subclass of TestResult test runs will use.  On load, I execute	XProgramming.SUnit.TestCase suiteClass:		(XProgramming.SUnit.PluggableSuite resultClass: XProgramming.SUnit.KeepLatestResult).By using my settings page, or by re-executing the above, you may substitute any subclass of PluggableSuite to combine display of the latest results with other test run behaviours.On unload, I execute	XProgramming.SUnit.TestCase suiteClass: XProgramming.SUnit.TestSuite.to end capture of results, and	XProgramming.SUnit.TestCaseOutcomes flush.to flush the results store.  You may do either of these at any time while I am loaded.  (Be aware, if you reset the suiteClass to TestSuite but do not flush the results, the Refactoring Browser will go on displaying the last result before you did for each test (i.e. until you do flush the cache, or else reset the suiteClass to capture results again, or else I am unloaded.)The result for a test is updated when it is rerun, and flushed when its method is recompiled or unloaded.  You may inspect	XProgramming.SUnit.TestCaseOutcomes currentto see the times taken to run specific tests;  these are captured but not displayed individually at the moment, just the total time for the suite.I prereq RBSUnitExtensions merely for simple convenience of loading, since users of me will almost always wish to run tests using RBSUnitExtensions.  It can be unloaded, retaining me;  any mechanism for running SUnit tests that uses a KeepLatestResult will cause me to display the results in the Refactoring Browser.DbIdentifier: bear73DbTrace: 502578DbUsername: nrossDbVersion: 8.3 - 1DevelopmentPrerequisites: #(#(#any 'SUnitToolsIcons' '') #(#any 'SUnitResourcePatterns' '') #(#any 'RBSUnitExtensions' ''))Namespace: XProgramming.SUnitPackageName: RBSUnitShowResultParcel: #('RBSUnitShowResult')ParcelName: RBSUnitShowResultPrerequisiteDescriptions: #(#(#name 'SUnitToolsIcons' #componentType #package) #(#name 'SUnitResourcePatterns' #componentType #package) #(#name 'RBSUnitExtensions' #componentType #package))PrerequisiteParcels: #(#('SUnitToolsIcons' '') #('SUnitResourcePatterns' '') #('RBSUnitExtensions' ''))PrintStringCache: (8.3 - 1,nross)Version: 8.3 - 1Post-Load Block: 	[:package | XProgramming.SUnit.TestCase suiteClass:	(XProgramming.SUnit.PluggableSuite resultClass:		XProgramming.SUnit.KeepLatestResult)]Pre-Unload Block: 	[:package |XProgramming.SUnit.TestCase suiteClass: XProgramming.SUnit.TestSuite.XProgramming.SUnit.TestCaseOutcomes flush]Date: 11:29:11 AM June 16, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (jun17.3) of June 16, 2017 on June 16, 2017 at 11:29:11 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>TestCaseOutcome</name><environment>XProgramming.SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testCase properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit-Base</category><attributes><package>RBSUnitShowResult</package></attributes></class><comment><class-id>XProgramming.SUnit.TestCaseOutcome</class-id><body>Instances of my subclasses represent individual test outcomes in TestCaseOutcomes current.  I represent a test that has not run;  I am mainly an abstract class but an instance of me can be used as a nil object pattern.Instance Variables	properties	&lt;Dictionary&gt;		properties, such as the start and end time of the test, chosen to be recorded	testCase	&lt;TestCase or nil&gt;	the test that had this result, or nil for the not-run result (the nil object pattern)</body></comment><class><name>FailureData</name><environment>XProgramming.SUnit</environment><super>XProgramming.SUnit.TestCaseOutcome</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>RBSUnitShowResult</package></attributes></class><comment><class-id>XProgramming.SUnit.FailureData</class-id><body>Icons and severity for a test that failed.</body></comment><class><name>TestCaseOutcomes</name><environment>XProgramming.SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>results </inst-vars><class-inst-vars>current </class-inst-vars><imports></imports><category></category><attributes><package>RBSUnitShowResult</package></attributes></class><comment><class-id>XProgramming.SUnit.TestCaseOutcomes</class-id><body>I am singleton which holds the results of tests run in this image.  I weakly key the results by the CompiledMethod of the test:  thus, if the method is edited or unloaded my references also expire.  Since a compiled method (representing a test) can be inherited by subclasses that do not override it, the values are small dictionaries of results, keyed by test cases.To reset my singleton, call	self flushor use the button on the Tools &gt; Testing page of the VisualLauncher settings.</body></comment><class><name>PassData</name><environment>XProgramming.SUnit</environment><super>XProgramming.SUnit.TestCaseOutcome</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>RBSUnitShowResult</package></attributes></class><comment><class-id>XProgramming.SUnit.PassData</class-id><body>Icons and severity for a test that passed.</body></comment><class><name>ErrorData</name><environment>XProgramming.SUnit</environment><super>XProgramming.SUnit.TestCaseOutcome</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>RBSUnitShowResult</package></attributes></class><comment><class-id>XProgramming.SUnit.ErrorData</class-id><body>Icons and severity for a test that errored.</body></comment><class><name>OutcomeData</name><environment>XProgramming.SUnit</environment><super>XProgramming.SUnit.TestCaseOutcome</super><private>false</private><indexed-type>none</indexed-type><inst-vars>exception </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>RBSUnitShowResult</package></attributes></class><comment><class-id>XProgramming.SUnit.OutcomeData</class-id><body>OutcomeData holds test outcomes that are not one of the base categories (Pass, Fail, Error and not run).Instance Variables	exception	&lt;Exception&gt;	a specialised outcome (not just Error or TestFailure) is raised by a specific exception</body></comment><class><name>KeepLatestResult</name><environment>XProgramming.SUnit</environment><super>XProgramming.SUnit.ClassifiedTestResult</super><private>false</private><indexed-type>none</indexed-type><inst-vars>latestTestStartTime </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>RBSUnitShowResult</package></attributes></class><comment><class-id>XProgramming.SUnit.KeepLatestResult</class-id><body>I create TestCaseOutcome subclass instances for my results, stored in the TestCaseOutcomes singleton's EphemeronDictionary, so that the latest state of each (not run, passed, failed or errored, or any exception that has a specific icon) is displayed against its method in the Refactoring Browser.  Results are keyed by their test selectors' compiled methods, so changing the test's code resets its result.  Loading this utility sets me as the result class and PluggableTestSuite as the suite class;  see the Tools &gt; Testing settings page of the VisualLauncher.  Unloading it resets these to their defaults.  I can also be used with any subclass of PluggableTestSuite.</body></comment><methods><class-id>XProgramming.SUnit.TestCaseOutcome</class-id> <category>accessing</category><body package="RBSUnitShowResult">endTime	^self propertyAt: #endTime</body><body package="RBSUnitShowResult">endTime: aTimestamp	^self propertyAt: #endTime put: aTimestamp</body><body package="RBSUnitShowResult">method	"Return the CompiledMethod corresponding to this test case in as dialect-neutral a way as possible.  We code on the assumption there must be one. If there isn't and we work up to nil superclass then fail, not bothering with implementor isNil ifTrue: [^nil] as we assume the caller would immediately fail in that case."	| implementor |	implementor := testCase class.	[implementor includesSelector: testCase selector]		whileFalse: [implementor := implementor superclass].	^implementor compiledMethodAt: testCase selector</body><body package="RBSUnitShowResult">propertyAt: aSymbol	^self propertyAt: aSymbol ifAbsent: [nil]</body><body package="RBSUnitShowResult">propertyAt: aSymbol ifAbsent: aBlock	properties isNil ifTrue: [^aBlock value].	^properties at: aSymbol ifAbsent:aBlock.</body><body package="RBSUnitShowResult">propertyAt: aSymbol put: anObject	properties isNil ifTrue: [properties := Dictionary new].	^properties at: aSymbol put: anObject</body><body package="RBSUnitShowResult">startTime	^self propertyAt: #startTime</body><body package="RBSUnitShowResult">startTime: aTimestamp	^self propertyAt: #startTime put: aTimestamp</body><body package="RBSUnitShowResult">testCase	^testCase</body><body package="RBSUnitShowResult">testCase: aTestCase	"Send asNew to avoid the cache holding references to data created during a run until/unless the test is rerun, edited or nloaded, especially as the AT System Analysis path tracer cannot trace through an EphemeronDictionary, so we could not trace why it was being held.  (This choice is debatablle:  if subclasses wish to compare data of repeat runs of the same test, this protection might need to be discarded or the data added to properties.)"	testCase := aTestCase asNew.</body><body package="RBSUnitShowResult">testCaseIcon	^TestIcons caseNotRun</body><body package="RBSUnitShowResult">testMethodIcon	^TestIcons testNotRun</body></methods><methods><class-id>XProgramming.SUnit.TestCaseOutcome</class-id> <category>comparing</category><body package="RBSUnitShowResult">= aTestRunData	^self class = aTestRunData class		and: [testCase = aTestRunData testCase]</body><body package="RBSUnitShowResult">asSevereAs: aResultData	"If I am less severe than a rival result, return the rival result."	aResultData isNil ifTrue: [^self].	"aResultData not run"	^self sunitSeverity &lt; aResultData sunitSeverity		ifTrue: [aResultData]		ifFalse: [self]</body><body package="RBSUnitShowResult">hash    ^self class hash bitXor: testCase hash</body><body package="RBSUnitShowResult">sunitSeverity	"Numerical scale to let tools select the most serious test failure from a group."	^-1	"not run"</body></methods><methods><class-id>XProgramming.SUnit.TestCaseOutcome</class-id> <category>actions</category><body package="RBSUnitShowResult">register	^TestCaseOutcomes current addResult: self</body></methods><methods><class-id>XProgramming.SUnit.TestCaseOutcome class</class-id> <category>instance creation</category><body package="RBSUnitShowResult">testCase: aTestCase startTime: latestTestStartTime	^self new		testCase: aTestCase;		startTime: latestTestStartTime;		endTime: Timestamp now;		register</body></methods><methods><class-id>XProgramming.SUnit.FailureData</class-id> <category>comparing</category><body package="RBSUnitShowResult">sunitSeverity	"Numerical scale to let tools select the most serious test failure from a group."	^50</body></methods><methods><class-id>XProgramming.SUnit.FailureData</class-id> <category>accessing</category><body package="RBSUnitShowResult">testCaseIcon	^TestIcons caseFailure</body><body package="RBSUnitShowResult">testMethodIcon	^TestIcons testFailure</body></methods><methods><class-id>XProgramming.SUnit.TestCaseOutcomes</class-id> <category>accessing</category><body package="RBSUnitShowResult">addResult: aResult	^(results at: aResult method ifAbsentPut: [EphemeronDictionary new]) 		at: aResult testCase class		put: aResult</body><body package="RBSUnitShowResult">statusForMethod: aMethod testCaseClass: aClass ifAbsent: aBlock	"Usually aMethod will be a method of the testCaseClass, but it can be the method of a superclass from which aTestCase' class inherits without redefining."	^(results at: aMethod ifAbsent: [^aBlock value]) at: aClass ifAbsent: aBlock</body></methods><methods><class-id>XProgramming.SUnit.TestCaseOutcomes</class-id> <category>initialize-release</category><body package="RBSUnitShowResult">initialize	results := EphemeronDictionary new.</body></methods><methods><class-id>XProgramming.SUnit.TestCaseOutcomes class</class-id> <category>instance creation</category><body package="RBSUnitShowResult">current	current isNil ifTrue: [current := self new initialize].	^current</body><body package="RBSUnitShowResult">flush	current := nil.</body></methods><methods><class-id>XProgramming.SUnit.PassData</class-id> <category>accessing</category><body package="RBSUnitShowResult">testCaseIcon	^TestIcons casePass</body><body package="RBSUnitShowResult">testMethodIcon	^TestIcons testPass</body></methods><methods><class-id>XProgramming.SUnit.PassData</class-id> <category>comparing</category><body package="RBSUnitShowResult">sunitSeverity	"Numerical scale to let tools select the most serious test failure from a group."	^0</body></methods><methods><class-id>XProgramming.SUnit.ErrorData</class-id> <category>accessing</category><body package="RBSUnitShowResult">testCaseIcon	^TestIcons caseError</body><body package="RBSUnitShowResult">testMethodIcon	^TestIcons testError</body></methods><methods><class-id>XProgramming.SUnit.ErrorData</class-id> <category>comparing</category><body package="RBSUnitShowResult">sunitSeverity	"Numerical scale to let tools select the most serious test failure from a group."	^100</body></methods><methods><class-id>XProgramming.SUnit.OutcomeData</class-id> <category>comparing</category><body package="RBSUnitShowResult">= aResultData	^super = aResultData		and: [exception = aResultData exception]</body><body package="RBSUnitShowResult">hash    ^super hash bitXor: exception hash</body><body package="RBSUnitShowResult">sunitSeverity	"Numerical scale to let tools select the most serious test failure from a group."	^self exception sunitSeverity</body></methods><methods><class-id>XProgramming.SUnit.OutcomeData</class-id> <category>accessing</category><body package="RBSUnitShowResult">exception	^exception</body><body package="RBSUnitShowResult">exception: anException	exception := anException</body><body package="RBSUnitShowResult">testCaseIcon	^self exception testCaseIcon</body><body package="RBSUnitShowResult">testMethodIcon	^self exception testMethodIcon</body></methods><methods><class-id>XProgramming.SUnit.KeepLatestResult</class-id> <category>running</category><body package="RBSUnitShowResult">runCase: aTestCase	latestTestStartTime := Timestamp now.	super runCase: aTestCase.</body></methods><methods><class-id>XProgramming.SUnit.KeepLatestResult</class-id> <category>adding</category><body package="RBSUnitShowResult">addError: aTestCase	ErrorData testCase: aTestCase startTime: latestTestStartTime.	^super addError: aTestCase</body><body package="RBSUnitShowResult">addFailure: aTestCase	FailureData testCase: aTestCase startTime: latestTestStartTime.	^super addFailure: aTestCase</body><body package="RBSUnitShowResult">addOutcome: aTestCase exception: anException	(OutcomeData testCase: aTestCase startTime: latestTestStartTime)		exception: anException.	^super addOutcome: aTestCase exception: anException</body><body package="RBSUnitShowResult">addPass: aTestCase	"If a test raises a resumable test failure, it will be added to failures but the test will then resume and proceed to pass.  Do not overwrite the failure in the ResultsData in that case (and return nil as evidence)."	| passData |	passData := PassData new		testCase: aTestCase;		startTime: latestTestStartTime;		endTime: Timestamp now;		yourself.	^(super addPass: aTestCase) isNil ifFalse: 		[passData register.		aTestCase]</body></methods><methods><class-id>XProgramming.SUnit.TestCase class</class-id> <category>icons</category><body package="RBSUnitShowResult">toolListIcon	"The equivalent SUnitToo implementation examines local selectors - this also examines inherited selectors.  This can mean that the TestCase class is red (from an inherited failure) although all its visible selectors (in the RB, with the class selected) were green."	self isAbstract ifTrue: [^TestIcons caseAbstract].	^(self allTestSelectors		inject: TestCaseOutcome new		into:			[:worstResult :selector |			worstResult asSevereAs:				(TestCaseOutcomes current					statusForMethod: (self findSelector: selector) last					testCaseClass: self					ifAbsent: nil)]) testCaseIcon</body></methods><methods><class-id>XProgramming.SUnit.TestSkip</class-id> <category>comparing</category><body package="RBSUnitShowResult">sunitSeverity	^5</body></methods><methods><class-id>XProgramming.SUnit.TestSkip</class-id> <category>icons</category><body package="RBSUnitShowResult">testCaseIcon	^TestIcons caseSkip</body><body package="RBSUnitShowResult">testMethodIcon	^TestIcons testSkip</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-tools-testing</category><body package="RBSUnitShowResult">testingFlushOutcomes	"Discard the test outcome data: all tests show as 'not run' in the RB"	&lt;setting: #(tools testing flushOutcomes)&gt;	^ExternalSetting new		label: #FlushTestCaseOutcomes &lt;&lt; #labels &gt;&gt; 'Flush test outcome data';		buttonLabel: #FlushTestCaseOutcomesButton &lt;&lt; #labels &gt;&gt; 'Discard results';		editorBlock: [TestCaseOutcomes flush];		helpText: #FlushTestCaseOutcomesHelpText &lt;&lt; #dialogs &gt;&gt; 'Discards the last run state of all SUnit tests in the image (so RBs will show the ''Not Run'' icon for all tests).'</body><body package="RBSUnitShowResult">testingPage	"To avoid assumptions of how we map names, we use the getBlock of the TypeConverter that is the target of the subject of the model of the suiteClassSetting to map suite classes to their keys.  Because the TypeConverter's getBlock expects a value holder, we supply an association that responds to #value by returning the class (its key does not matter)."	&lt;settingsPage: #(tools testing)&gt;	| suiteClassSetting resultClassSetting randomInspectFailedOrderSetting suiteTypeConverter keyedSuiteClasses keyedResultClasses resultTypeConverter |	suiteClassSetting := EnumerationSettingModule on:		(self settingWithId: #(tools testing suiteClass)).	suiteTypeConverter := suiteClassSetting valueHolder subject target.	keyedSuiteClasses := IdentityDictionary withAll:		(TestSuite withAllSubclasses collect:			[:each | (suiteTypeConverter valueUsingSubject: nil-&gt;each)-&gt;each]).	resultClassSetting := EnumerationSettingModule on:		(self settingWithId: #(tools testing resultClass)).	resultTypeConverter := resultClassSetting valueHolder subject target.	keyedResultClasses := IdentityDictionary withAll:		(TestResult withAllSubclasses collect:			[:each | (resultTypeConverter valueUsingSubject: nil-&gt;each)-&gt;each]).	randomInspectFailedOrderSetting := BooleanSettingModule on:		(self settingWithId: #(tools testing randomInspectFailedOrder)).	^ModularSettingsPage new		label: #Testing &lt;&lt; #labels &gt;&gt; 'Testing';		icon: TestIcons testPass;		addModule: suiteClassSetting;		addModule: randomInspectFailedOrderSetting;		addModule: resultClassSetting;		when: suiteClassSetting valueHolder		valueSatisfies: [:v |					((keyedSuiteClasses at: v) includesBehavior: PluggableSuite) or:						[resultClassSetting valueHolder value: (keyedResultClasses keyAtValue: TestResult).						false]]		enable: resultClassSetting;		when: suiteClassSetting valueHolder		valueSatisfies: [:v | (keyedSuiteClasses at: v) == RandomSuite]		enable: randomInspectFailedOrderSetting;		addAllSettings: (self settingsWithPrefix: #(tools testing) except: #(suiteClass resultClass randomInspectFailedOrder))</body><body package="RBSUnitShowResult">testingRandomInspectFailedOrder	"Set whether a randomised test run that fails should open an inspector on its order of running.  This setting is only enabled if RandomSuite is selected - see #testingPage."	&lt;setting: #(tools testing randomInspectFailedOrder)&gt;	^(BooleanSetting on: RandomSuite aspect: #inspectFailedOrder)		default: false;		label: #RandomInspectFailedOrder &lt;&lt; #labels &gt;&gt; 'Inspect Failed Randomised Test Order';		helpText: #RandomInspectFailedOrderHelpText &lt;&lt; #dialogs &gt;&gt; 'If a randomised test run fails, open an inspector on an ordinary test suite containing the tests in the order that failed.'</body><body package="RBSUnitShowResult">testingResultClass	"Set the value of that will be used to create test results when SUnit tests are run.  This setting is only enabled if the chosen suite is not TestSuite - see #testingPage."	&lt;setting: #(tools testing resultClass)&gt;	| enumSetting resultClassHolder resultNameHolder classes keyedClasses classKeys |	classes := TestResult withAllSubclasses.	keyedClasses := classes groupedBy: [:each | each name].	keyedClasses := keyedClasses		inject: (Dictionary new: keyedClasses size)		into: [:all :each |			each do: [:e | each size &gt; 1						ifFalse: [all at: e name put: e]						ifTrue: [all at: e fullName asSymbol put: e]].			all].	classKeys := classes collect: [:each | keyedClasses keyAtValue: each].	resultClassHolder := AspectAdaptor subject: TestCase accessPath: #(#suiteClass).	resultClassHolder forAspect: #resultClass.	resultNameHolder := (TypeConverter on: resultClassHolder)		getBlock: [:m | keyedClasses keyAtValue: m value]		putBlock: [:m :v |				TestCase suiteClass == TestSuite ifFalse:					[m value: (keyedClasses at: v)]]		updateBlock: [:m :a :p | true].	enumSetting := EnumerationSetting		choices: classKeys		labels: (classKeys collect: [:each | each asString]).	^(enumSetting on: resultNameHolder)		default: PluggableSuite name;		label: #TestResultClass &lt;&lt; #labels &gt;&gt; 'Test result class';		helpText: #TestResultClassHelpText &lt;&lt; #dialogs &gt;&gt; '(This option is not available if the suite class is TestSuite.)  Choose the result class to use for running SUnit tests.  See the class comments of subclasses of TestResult or the package comment of SUnitResourcePatterns for details.  (If two classes have the same name, their fullNames are shown.)'</body><body package="RBSUnitShowResult">testingSuiteClass	"Set the value of XProgramming.SUnit.TestCase.SuiteClass that will be used to create suites when SUnit tests are run.  Show fullNames in the unlikely event there are same-name subclasses, otherwise just names.  On changing the value, apply the current result class setting to the new suite class setting."	&lt;setting: #(tools testing suiteClass)&gt;	| classes keyedClasses classKeys enumSetting suiteClassHolder suiteNameHolder |	classes := TestSuite withAllSubclasses.	keyedClasses := classes groupedBy: [:each | each name].	keyedClasses := keyedClasses		inject: (Dictionary new: keyedClasses size)		into: [:all :each |			each do: [:e | each size &gt; 1						ifFalse: [all at: e name put: e]						ifTrue: [all at: e fullName asSymbol put: e]].			all].	classKeys := classes collect: [:each | keyedClasses keyAtValue: each].	suiteClassHolder := AspectAdaptor forAspect: #suiteClass.	suiteClassHolder subject: TestCase.	suiteNameHolder := (TypeConverter on: suiteClassHolder)			getBlock: [:m | keyedClasses keyAtValue: m value]			putBlock: [:m :v || classV | classV := keyedClasses at: v.					classV == TestSuite ifFalse: [classV resultClass: m value resultClass].					m value: classV]			updateBlock: [:m :a :p | true].	enumSetting := EnumerationSetting		choices: classKeys		labels: (classKeys collect: [:each | each asString]).	^(enumSetting on: suiteNameHolder)		default: PluggableSuite name;		label: #TestSuiteClass &lt;&lt; #labels &gt;&gt; 'Test suite class';		helpText: #TestSuiteClassHelpText &lt;&lt; #dialogs &gt;&gt; 'Choose the suite class to use for running SUnit tests.  See the class comments of subclasses of TestSuite or the package comment of SUnitResourcePatterns for details.  (If two classes have the same name, their fullNames are shown.)'</body></methods><methods><class-id>Tools.MethodDefinition</class-id> <category>icons</category><body package="RBSUnitShowResult">sunitTestStatusIcon	&lt;icon: 49&gt;	"A test defined in a test method can be run in the implementing test case class of that method, or in a subclass that inherits the test without redefining it.  The results cache holds a weakly-class-keyed dictionary of results against each method, so we can distinguish the outcoming of running the test in the superclass (if concrete) and in each sibling subclass."	^self method ifNotNil:		[:method |		method isSUnitTestCaseMethod ifFalse: [^nil].		(TestCaseOutcomes current			statusForMethod: method			testCaseClass: self inheritingClass			ifAbsent: [^TestIcons testNotRun]) testMethodIcon]</body></methods><methods><class-id>Kernel.CompiledMethod</class-id> <category>testing</category><body package="RBSUnitShowResult">isSUnitTestCaseMethod	"This package has property #namespace, ensuring we get the right TestCase class here."	^(self mclass inheritsFrom: TestCase)		and: [self selector beginsWith: 'test']</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>CompiledMethod</name><environment>Kernel</environment><super>Kernel.CompiledMainBlock</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>mclass sourceCode </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>ClassifiedTestResult</name><environment>XProgramming.SUnit</environment><super>XProgramming.SUnit.TestResult</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classifiedResults </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SUnitResourcePatterns</package></attributes></class><class><name>MethodDefinition</name><environment>Tools</environment><super>Tools.GeneralMethodDefinition</super><private>false</private><indexed-type>none</indexed-type><inst-vars>inheritingClass implementingClass selector extraText </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Programming</category><attributes><package>Tools-Programming</package></attributes></class><class><name>TestSkip</name><environment>XProgramming.SUnit</environment><super>XProgramming.SUnit.TestFailure</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnitResourcePatternsPreload</category><attributes><package>SUnitResourcePatterns</package></attributes></class></st-source>