<?xml version="1.0"?><st-source><!-- Name: Smalltalk ArchiveNotice: Copyright 2009-2017 Cincom Systems, Inc.  All rights reserved.BinarySave: falseBundleName: Smalltalk ArchiveBundleStructure: a Store.BundleForParcelComment: This new thing is called SmalltalkArchive. It represents Bundles and Packages with full structure in a single file.It gives two file types. First has extension .store and represents the SmalltalkArchive with sources. Second hasextension .star and represents the SmalltalkArchive without sources.Technically a SmalltalkArchive is a tar file with all bundles and packages of a bundle (both with .pcl and/or .pst files)When loading the .pst files are not copied in a directory but they remain in the tar file and the FileManager canhandle files inside tar (i.e. .store or .star) files. The SmalltalkArchive looks like the directory. To handle this there isa new Filename subclass called TarredFilename.Everything else is pretty straight forward. The first parcel in the SmalltalkArchive represents the top bundle (tar fileshave a sequence). SmalltalkArchives can store multiple bundle/package hierarchies in a single file, in this case ashadowed bundle is stored, which is loaded but not registered in the system. The shadowed bundle is automaticallycreated when more than one bundle/package are choosed in the RefactoringBrowser for saving as SmalltalkArchive.DevelopmentPrerequisites: #(#(#any 'StoreBase' '') #(#any 'DLLCC' ''))Parcel: nilParcelName: Smalltalk ArchivePrerequisiteDescriptions: #(#(#name 'StoreBase') #(#name 'DLLCC'))PrerequisiteParcels: #(#('StoreBase' '') #('DLLCC' '') #('StreamWrapping' ''))Version: 8.3 - 2Post-Load Block: 	[:package | Refactory.Browser.BrowserApplicationModel instanceMethodsChanged]Date: 11:31:26 AM January 20, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (jan17.3) of January 20, 2017 on January 20, 2017 at 11:31:26 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>TarredFilename</name><environment>OS</environment><super>OS.Filename</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tarFile tarredFilename </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-PC</category><attributes><package>NewTar</package></attributes></class><comment><class-id>OS.TarredFilename</class-id><body>TarredFilename is used when accessing a tar filenameInstance Variables	tarFile	&lt;TarFile&gt;	description of tarFile	tarredFilename	&lt;SequenceableCollection&gt;	description of tarredFilename</body></comment><class><name>FileTimeAccessWin32</name><environment>OS</environment><super>OS.Win32SystemSupport</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.FileTimeAccessWin32Dictionary.*			</imports><category></category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>MSVCRT.DLL</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>NewTar</package></attributes></class><comment><class-id>OS.FileTimeAccessWin32</class-id><body>FileTimeAccessWin32 implements functions to access file time on Windows used by NewTar.</body></comment><class><name>TarredStream</name><environment>Core</environment><super>Core.PositionableStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>NewTar</category><attributes><package>NewTar</package></attributes></class><comment><class-id>Core.TarredStream</class-id><body>TarredStream is the abstract superclass for TarredReadStream and TarredWriteStreamInstance Variables	properties	&lt;TarPosix2001Header&gt;	description of properties</body></comment><class><name>TarredWriteStream</name><environment>Core</environment><super>Core.TarredStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>NewTar</category><attributes><package>NewTar</package></attributes></class><comment><class-id>Core.TarredWriteStream</class-id><body>TarredWriteStream is the stream used when writing a TarFileInstance Variables	stream	&lt;Stream&gt;	description of stream</body></comment><class><name>FixedLine</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>line </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Structure Access</category><attributes><package>FixedLine</package></attributes></class><comment><class-id>Core.FixedLine</class-id><body>FixedLine is a Class that represents a line of text and subclasses only need to implement accessor methods that return substrings from a given position in the string to another position.see the example below and it's implementation in the ExampleLine class for more details.use #fromStream: to create an OrderedCollection of FixedLines.Instance Variables:	line	&lt;String&gt;	stores the line where it takes the characters from.examle:ExampleLine fromStream: (ReadStream on:'Adam 24 maleEva  23 female')</body></comment><class><name>TarPosix2001Header</name><environment>Core</environment><super>Core.FixedLine</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>NewTar</category><attributes><package>NewTar</package></attributes></class><comment><class-id>Core.TarPosix2001Header</class-id><body>TarPosix2001Header is a special kind of FixedLine read used in NewTar files</body></comment><class><name>FileTimeAccessUnix</name><environment>OS</environment><super>OS.UnixSystemSupport</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			OS.FileTimeAccessorUnixDictionary.*			private OS.FileTimeAccessUnixDictionary.*			</imports><category></category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>NewTar</package></attributes></class><comment><class-id>OS.FileTimeAccessUnix</class-id><body>FileTimeAccessUnix mplements functions to access file time on Unix used by NewTar.</body></comment><class><name>PublishSpecification</name><environment>Store</environment><super>Store.AbstractPublishSpecification</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mergeData binarySave parcelSave bundleStructure databaseLinks parcelDirectory parcelRepublish parcelBackup parcelOverwrite parcelSaveSource parcelHideSource parcelPadded publisher parcelVersionString smalltalkArchive </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			private Store.Glorp.*			private Glorp.*			</imports><category>StoreTags</category><attributes><package>Smalltalk Archive Support</package></attributes></class><comment><class-id>Store.PublishSpecification</class-id><body>PublishSpecification contains all the options used when publishing. #parcelX options are only used when a parcel is also being produced.Instance Variables:	binarySave	&lt;Boolean&gt;	Indicates whether to publish the pundle as binary	bundleStructure	&lt;Boolean&gt;	Indicates if bundle structure should be stored when producing a parcel. 	databaseLinks	&lt;Boolean&gt;	Indicates if trace links to the current database should be stored in the parcel. 	mergeData	&lt;MergeData&gt;	Information collected in the MergeTool	parcelBackup	&lt;Boolean&gt;	Indicates if the parcel (it it exists and we are overwriting it) should be backed up.	parcelDirectory	&lt;String&gt;	The directory to store the parcel in. 	parcelHideSource &lt;Boolean&gt; Indicates if the parcel should have its source hidden. 	parcelOverwrite	&lt;Boolean&gt;	Indicates if the parcel (if it already exists) should be overwritten. 	parcelPadded	&lt;Boolean&gt;	Indicates if the parcel's source file should be padded.  See the class comment for SourceFileManager for futher information on padding source files.	parcelRepublish	&lt;Boolean&gt;	Indicates if the parcel should be republished.  	parcelSave	&lt;Boolean&gt;	Indicates if a parcel should also be created when publishing	parcelSaveSource &lt;Boolean&gt; Indicates if the parcel should have its source file saved.  </body></comment><class><name>ArchiveRecord</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name sourceData blobData pundleID </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Smalltalk Archive Support</category><attributes><package>Smalltalk Archive Support</package></attributes></class><comment><class-id>Store.ArchiveRecord</class-id><body>ArchiveRecord is a stand in for the old store database object ParcelRecord, but since I'm never saved in the Database, I can now be a fakeout objectInstance Variables	blobData	&lt;BinaryStorageBytes.&gt;	name	&lt;String&gt;	sourceData	&lt;BinaryStorageBytes&gt;</body></comment><class><name>PublishAsParcelDialog</name><environment>Store</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pundle bundleStructure databaseLinks parcelDirectory parcelSave parcelSaveSource parcelHideSource parcelPadded parcelRepublish parcelBackup parcelOverwrite parcelVersionString smalltalkArchive </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI</category><attributes><package>Smalltalk Archive UI</package></attributes></class><comment><class-id>Store.PublishAsParcelDialog</class-id><body>The dialog to collect options for publishing a pundle as a parcel.Instance Variables	bundleStructure	&lt;ValueModel: Boolean&gt;	true if we should store the bundle structure in the parcel	databaseLinks	&lt;ValueModel: Boolean&gt;	true if we should store the database links in the parcel	parcelBackup	&lt;ValueModel: Boolean&gt;	true means backup any existing parcel file	parcelDirectory	&lt;ValueModel: String&gt;	the directory to put the parcel	parcelHideSource	&lt;ValueModel: Boolean&gt;&gt;	sets the hideSource flag for the parcel	parcelOverwrite	&lt;ValueModel: Boolean&gt;	flag whether to override existing files.. if true will do so with no warning prompt.	parcelPadded	&lt;ValueModel: Boolean&gt;	sets the padded flag for the parcel	parcelRepublish	&lt;ValueModel: Boolean&gt;	sets the reepublish flag for the parcel	parcelSave	&lt;ValueModel: Boolean&gt;	true to save the parcel	parcelSaveSource	&lt;ValueModel: Boolean&gt;	flag to tell the parcel whether to save the sources	parcelVersionString	&lt;ValueHolder &lt;String&gt;&gt; This is the version string for the Parcel (which can be different than the package/bundle)	pundle	&lt;BundleModel | PackageModel&gt;	that which we are making a parcel from</body></comment><class><name>TarFile</name><environment>Core</environment><super>Core.SequenceableCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>file contents filename </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>NewTar</category><attributes><package>NewTar</package></attributes></class><comment><class-id>Core.TarFile</class-id><body>TarFile is an abstract superclass of TarReadFile and TarWriteFileSubclasses must implement the following messages:	accessing		at:put:Instance Variables	contents	&lt;(Collection of: TarredWriteStream)&gt;	description of contents	file	&lt;BufferedExternalStream | EncodedStream&gt;	description of file	filename	&lt;Object&gt;	description of filename</body></comment><class><name>TarWriteFile</name><environment>Core</environment><super>Core.TarFile</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>NewTar</category><attributes><package>NewTar</package></attributes></class><comment><class-id>Core.TarWriteFile</class-id><body>TarWriteFile is used when writing a TarFile</body></comment><class><name>PublishPundleDialog</name><environment>Store</environment><super>Store.StorePublishDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>items blessingLevel blessingComment publish versionString binarySave parcelSave bundleStructure databaseLinks parcelDirectory parcelSaveSource parcelHideSource parcelPadded parcelRepublish parcelBackup parcelOverwrite parcelWarningMessage labelDict offsets callBackBlock retry files publishFile parcelVersionString pundleModel smalltalkArchive session </inst-vars><class-inst-vars></class-inst-vars><imports>			private Glorp.*			private Store.Glorp.*			</imports><category>Store-UI</category><attributes><package>Smalltalk Archive UI</package></attributes></class><comment><class-id>Store.PublishPundleDialog</class-id><body>Tabbed dialog for all publishing options.Instance Variables	items	&lt;SelectionInList&gt; a collection of user data for each pundle		blessingLevel	&lt;ValueHolder&gt;	current item's blessing level	blessingComment	&lt;ValueHolder &lt;String&gt;	current item's comment	publish	&lt;ValueHolder &lt;Boolean&gt;&gt;	indicates if current selection is to be published	versionString	&lt;ValueHolder &lt;String&gt;&gt;	current item's version string.	binarySave	&lt;ValueHolder &lt;Boolean&gt;&gt; true if to also publish binary	parcelSave	&lt;ValueHolder &lt;Boolean&gt;&gt; true if to also publish as a parcel	bundleStructure	&lt;ValueHolder &lt;Boolean&gt;&gt; if true, save bundle structure in parcel.	databaseLinks	&lt;ValueHolder &lt;Boolean&gt;&gt; if true, save links to current db in parcel.	parcelDirectory	&lt;ValueHolder &lt;Filename&gt;&gt;	directory for parcel	parcelSaveSource	&lt;ValueHolder &lt;Boolean&gt;&gt; flag for parcels.	parcelHideSource	&lt;ValueHolder &lt;Boolean&gt;&gt; flag for parcels	parcelPadded	&lt;ValueHolder &lt;Boolean&gt;&gt; flag for parcels	parcelRepublish	&lt;ValueHolder &lt;Boolean&gt;&gt; flag for parcels	parcelBackup	&lt;ValueHolder &lt;Boolean&gt;&gt; flag for parcels	parcelOverwrite	&lt;ValueHolder &lt;Boolean&gt;&gt; flag for parcels	parcelWarningMessage	&lt;ValueHolder &lt;String&gt;&gt;	message that explains why a parcel cannot be published.	labelDict &lt;Dictionary&gt; Cache of item labels.	offsets	&lt;Array&gt;	 Cache of label offsets	callBackBlock &lt;OneArgumentBlock&gt; Block for post-processing after publish.	retry &lt;Boolean&gt; Flag that indicates wheter to close the dialog, or retry if publish was canceled</body></comment><class><name>CodeReaderForSmalltalkArchive</name><environment>Store</environment><super>Kernel.CodeReader32</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Code Storage</category><attributes><package>Smalltalk Archive Support</package></attributes></class><comment><class-id>Store.CodeReaderForSmalltalkArchive</class-id><body>CodeReaderForSmalltalkArchive overrides those methods which are special for Smalltalk Archives.</body></comment><class><name>TarReadFile</name><environment>Core</environment><super>Core.TarFile</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>NewTar</category><attributes><package>NewTar</package></attributes></class><comment><class-id>Core.TarReadFile</class-id><body>TarReadFile is used when reading a TarFile</body></comment><class><name>TarContentsViewer</name><environment>Tools.FileTools</environment><super>Tools.FileTools.FileBlurbViewer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-File Browser</category><attributes><package>NewTar</package></attributes></class><comment><class-id>Tools.FileTools.TarContentsViewer</class-id><body>TarContentsViewer is the starting point for a TarContents viewer.</body></comment><class><name>SmalltalkArchiveViewer</name><environment>Tools.FileTools</environment><super>Tools.FileTools.ParcelFileViewer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-File Browser</category><attributes><package>Smalltalk Archive UI</package></attributes></class><comment><class-id>Tools.FileTools.SmalltalkArchiveViewer</class-id><body>SmalltalkArchiveViewer displays the basic file information for a SmalltalkArchive file: comment, various properties, as well as whether this file is loaded or not.</body></comment><class><name>FileDates</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>created accessed modified </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>NewTar</package></attributes></class><comment><class-id>Core.FileDates</class-id><body>FileDates instances describe typical file date properties as Smalltalk objectsInstance Variables	accessd	&lt;Timestamp&gt;	describes the last access time as Timestamp in GMT	created		&lt;Timestamp&gt;	describes the creation time as Timestamp in GMT	modified	&lt;Timestamp&gt;	describs the last change time Timestamp in GMT</body></comment><class><name>FileProperties</name><environment>Core</environment><super>Core.FileDates</super><private>false</private><indexed-type>none</indexed-type><inst-vars>filename </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>NewTar</package></attributes></class><comment><class-id>Core.FileProperties</class-id><body>FileProperties - adds the file name to FileDates. It also includes a few utility methodsInstance Variables	filename	&lt;Filename&gt;	...   </body></comment><class><name>SmalltalkArchiveFileItem</name><environment>Tools</environment><super>Tools.ParcelFileItem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Smalltalk Archive Support</category><attributes><package>Smalltalk Archive UI</package></attributes></class><comment><class-id>Tools.SmalltalkArchiveFileItem</class-id><body>SmalltalkArchiveFileItem represents a SmalltalkArchive file on the disk. I am used by various lists in the Parcel Manager to show that file type.</body></comment><class><name>TarredReadStream</name><environment>Core</environment><super>Core.TarredStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tarFile startInTar </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>NewTar</category><attributes><package>NewTar</package></attributes></class><comment><class-id>Core.TarredReadStream</class-id><body>TarredReadStream is the stream used when reading a tar fileInstance Variables	startInTar	&lt;ArithmeticValue&gt;	description of startInTar	tarFile	&lt;TarFile&gt;	description of tarFile</body></comment><shared-variable><name>FileTimeAccessWin32Dictionary</name><environment>OS</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>NewTar</package></attributes></shared-variable><shared-variable><name>FileTimeAccessUnixDictionary</name><environment>OS</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>NewTar</package></attributes></shared-variable><shared-variable><name>UnixZeroTimestamp</name><environment>Core.Timestamp</environment><private>false</private><constant>false</constant><category>Unix</category><initializer>Timestamp new		fromDate: (Date newDay: 1 monthNumber: 1 year: 1970)		andTime: (Time fromSeconds: 0)</initializer><attributes><package>NewTar</package></attributes></shared-variable><shared-variable><name>TARKnownExtensions</name><environment>Core.TarFile</environment><private>false</private><constant>true</constant><category>TAR constants</category><initializer>OrderedCollection new add: '.tar'; yourself</initializer><attributes><package>NewTar</package></attributes></shared-variable><shared-variable><name>TARSecondsOffset</name><environment>Core.TarFile</environment><private>false</private><constant>true</constant><category>TAR constants</category><initializer>	"Answer the difference in seconds from the Unix reference date (1 Jan 1970 00:00:00) to the VisualWorks reference date (1 Jan 1901 00:00:00)."	"(Timestamp fromDate: (Date 				newDay: 1				monthNumber: 1				year: 1970)		andTime: (Time fromSeconds: 0)) asSeconds 		- (Timestamp new fromDate: (Date 						newDay: 1						monthNumber: 1						year: 1901)				andTime: (Time fromSeconds: 0)) asSeconds"	2177452800</initializer><attributes><package>NewTar</package></attributes></shared-variable><shared-variable><name>TARBlockSize</name><environment>Core.TarFile</environment><private>false</private><constant>true</constant><category>TAR constants</category><initializer>512</initializer><attributes><package>NewTar</package></attributes></shared-variable><methods><class-id>OS.FileTimeAccessWin32</class-id> <category>procedures</category><body package="NewTar">FileTimeToSystemTime: lpFileTime systemTime: lpSystemTime	"set time stamps of file"	&lt;C: BOOL FileTimeToSystemTime(FILETIME * lpFileTime,  SYSTEMTIME *lpSystemTime) &gt;	^self externalAccessFailedWith: _errorCode</body><body package="NewTar">GetFileTime: hFile created: lpCreationTime accessed: lpLastAccessTime written: lpLastWriteTime	"set time stamps of file"	&lt;C:  BOOL GetFileTime(  HANDLE hFile,  FILETIME *lpCreationTime,  FILETIME *lpLastAccessTime,  FILETIME *lpLastWriteTime) &gt;	^self externalAccessFailedWith: _errorCode</body><body package="NewTar">SetFileTime: hFile created: lpCreationTime accessed: lpLastAccessTime written: lpLastWriteTime	"set time stamps of file"	&lt;C: BOOL SetFileTime(HANDLE hFile,  FILETIME *lpCreationTime,                                                FILETIME *lpLastAccessTime,  FILETIME *lpLastWriteTime   ) &gt;	^self externalAccessFailedWith: _errorCode</body><body package="NewTar">SystemTimeToFileTime: lpSystemTime fileTime: lpFileTime	&lt;C: BOOL SystemTimeToFileTime( SYSTEMTIME *lpSystemTime,  FILETIME *lpFileTime ) &gt;	^self externalAccessFailedWith: _errorCode</body><body package="NewTar">invokeLocaltime: atime	"convert gmt to local, time in seconds cound from date 1.1.1970 0:00:00"	&lt;C: TM *localtime( const time_t *atime )&gt;	^self externalAccessFailedWith: _errorCode</body><body package="NewTar">time: atime	"get a time"	&lt;C: time_t time( time_t *atime )&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>OS.UnixSystemSupport</class-id> <category>procedures</category><body package="NewTar">errnoLocation	&lt;C: int * __errno_location()&gt;	^self externalAccessFailedWith: _errorCode</body><body package="NewTar">fstat: aFileHandle into: Buffer	&lt;C: int fstat(int aFileHandle, struct stat *Buffer)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="NewTar">strerror: errnum 	&lt;C: char* strerror(int errnum)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="NewTar">utime: fileName with: buf 	&lt;C: int utime(const char *fileName, const struct utimbufStruct *buf)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>Store.PublishAsParcelDialog class</class-id> <category>interface specs</category><body package="Smalltalk Archive UI">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #Publish 				#defaultString: 'Publish' 				#catalogID: #packages ) 			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 900 550 1372 1030 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 4 0 5 0 -4 1 -39 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #ParcelOptions 						#defaultString: 'Parcel options' 						#catalogID: #packages ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 11 80 ) 					#name: #parcelWarningMessage 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #red ) ) 					#label: #parcelWarningMessage ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 11 25 ) 					#name: #parcelSave 					#model: #parcelSave 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #parcelSaveChanged ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #PublishParcel 						#defaultString: 'Publish Parcel' 						#catalogID: #packages ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 0 3 ) 							#label: 							#(#{Kernel.UserMessage} 								#key: #ParcelPathC 								#defaultString: 'Parcel Path:' 								#catalogID: #packages ) ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 100 0 0 0 0 1 25 0 ) 							#name: #parcelDirectory 							#flags: 40 							#model: #parcelDirectory ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 11 0 50 0 -11 1 75 0 ) ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.GroupBoxSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0.0 0 0.0 0 1.0 0 1.0 ) 							#label: 							#(#{Kernel.UserMessage} 								#key: #StoreOptions 								#defaultString: 'Store options' 								#catalogID: #packages ) ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.0787037 0 0.2 ) 							#name: #smalltalkArchive 							#model: #smalltalkArchive 							#callbacksSpec: 							#(#{UI.UIEventCallbackSubSpec} 								#valueChangeSelector: #smalltalkArchiveChanged ) 							#label: 							#(#{Kernel.UserMessage} 								#key: #saveAsSmalltalkArchive 								#defaultString: 'Save as Smalltalk Archive' 								#catalogID: #packages ) ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.175926 0 0.45 ) 							#name: #bundleStructure 							#model: #bundleStructure 							#callbacksSpec: 							#(#{UI.UIEventCallbackSubSpec} 								#valueChangeSelector: #bundleStructureChanged ) 							#label: 							#(#{Kernel.UserMessage} 								#key: #IncludeBundleStructure 								#defaultString: 'Include bundle structure' 								#catalogID: #packages ) ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.273148 0 0.7 ) 							#name: #databaseLinks 							#model: #databaseLinks 							#label: 							#(#{Kernel.UserMessage} 								#key: #WithDatabaseLinks 								#defaultString: 'With database links' 								#catalogID: #packages ) ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 15 0 0 0.333333 -5 0.5 75 0.333333 ) ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.GroupBoxSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0.0 0 0.0 0 1.0 0 1.0 ) 							#label: 							#(#{Kernel.UserMessage} 								#key: #SourceOptions 								#defaultString: 'Source options' 								#catalogID: #packages ) ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.0722892 0 0.198276 ) 							#name: #parcelSaveSource 							#model: #parcelSaveSource 							#callbacksSpec: 							#(#{UI.UIEventCallbackSubSpec} 								#valueChangeSelector: #parcelSaveSourceChanged ) 							#label: 							#(#{Kernel.UserMessage} 								#key: #SaveSourceFile 								#defaultString: 'Save source file' 								#catalogID: #packages ) ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.174699 0 0.422414 ) 							#name: #parcelHideSource 							#model: #parcelHideSource 							#label: 							#(#{Kernel.UserMessage} 								#key: #HideSourceOnLoad 								#defaultString: 'Hide source on load' 								#catalogID: #packages ) ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.174699 0 0.681034 ) 							#name: #parcelPadded 							#model: #parcelPadded 							#label: 							#(#{Kernel.UserMessage} 								#key: #PadSource 								#defaultString: 'Pad source' 								#catalogID: #packages ) ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 15 0 0 0.583333 -5 0.5 80 0.583333 ) ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.GroupBoxSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0.0 0 0.0 0 1.0 0 1.0 ) 							#label: 							#(#{Kernel.UserMessage} 								#key: #MiscellaeonousOptions 								#defaultString: 'Miscellaeonous Options' 								#catalogID: #packages ) ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.0843373 0 0.2 ) 							#name: #parcelRepublish 							#model: #parcelRepublish 							#label: 							#(#{Kernel.UserMessage} 								#key: #Republish 								#defaultString: 'Republish' 								#catalogID: #packages ) ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.0843373 0 0.448 ) 							#name: #parcelBackup 							#model: #parcelBackup 							#label: 							#(#{Kernel.UserMessage} 								#key: #Backup 								#defaultString: 'Backup' 								#catalogID: #packages ) ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.0843373 0 0.712 ) 							#name: #parcelOverwrite 							#model: #parcelOverwrite 							#label: 							#(#{Kernel.UserMessage} 								#key: #OverwriteExistingFiles 								#defaultString: 'Overwrite existing files' 								#catalogID: #packages ) ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 5 0.5 0 0.583333 -15 1 80 0.583333 ) ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 -5 1 0 1 ) 					#model: #accept 					#label: 					#(#{Kernel.UserMessage} 						#key: #Publish 						#defaultString: 'Publish' 						#catalogID: #packages ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 -5 1 0.5 1 ) 					#model: #cancel 					#label: 					#(#{Kernel.UserMessage} 						#key: #Cancel 						#defaultString: 'Cancel' 						#catalogID: #packages ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} -10 1 -5 1 1 1 ) 					#model: #helpAction 					#label: 					#(#{Kernel.UserMessage} 						#key: #Help 						#defaultString: 'Help' 						#catalogID: #packages ) 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 11 0 -55 1 0 1 ) 					#name: #VersionStringLabel 					#label: 					#(#{Kernel.UserMessage} 						#key: #VersionStringColon 						#defaultString: 'Version String:' 						#catalogID: #store ) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 115 0 -77 1 -145 1 -52 1 ) 					#name: #VersionString 					#model: #parcelVersionString ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -135 1 -77 1 -11 1 -52 1 ) 					#name: #CopyFromPackage 					#model: #copyFromPackage 					#label: 					#(#{Kernel.UserMessage} 						#key: #CopyFromPackage 						#defaultString: 'Copy From Package' 						#catalogID: #store ) 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Store.PublishPundleDialog class</class-id> <category>interface specs</category><body package="Smalltalk Archive UI">parcelSpec	"Tools.UIPainter new openOnClass: self andSelector: #parcelSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Publish' 			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 900 550 1372 1030 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 11 80 ) 					#name: #parcelWarningMessage 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #red ) ) 					#label: #parcelWarningMessage ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 25 ) 					#name: #parcelSave 					#model: #parcelSave 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #parcelSaveChanged ) 					#label: 'Publish Parcel' ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 0 3 ) 							#label: 'Parcel Path:' ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 100 0 0 0 0 1 25 0 ) 							#name: #parcelDirectory 							#flags: 40 							#model: #parcelDirectory ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 10 0 50 0 -10 1 75 0 ) ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.GroupBoxSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0.0 0 0.0 0 1.0 0 1.0 ) 							#label: 'Store options' ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.0769231 0 0.2 ) 							#name: #smalltalkArchive 							#model: #smalltalkArchive 							#callbacksSpec: 							#(#{UI.UIEventCallbackSubSpec} 								#valueChangeSelector: #smalltalkArchiveChanged ) 							#label: 'Save as Smalltalk Archive' ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.176471 0 0.45 ) 							#name: #bundleStructure 							#model: #bundleStructure 							#callbacksSpec: 							#(#{UI.UIEventCallbackSubSpec} 								#valueChangeSelector: #bundleStructureChanged ) 							#label: 'Include bundle structure' ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.276018 0 0.7 ) 							#name: #databaseLinks 							#model: #databaseLinks 							#label: 'With database links' ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 10 0 0 0.333333 -5 0.5 75 0.333333 ) ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.GroupBoxSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0.0 0 0.0 0 1.0 0 1.0 ) 							#label: 'Source options' ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.0722892 0 0.198276 ) 							#name: #parcelSaveSource 							#model: #parcelSaveSource 							#callbacksSpec: 							#(#{UI.UIEventCallbackSubSpec} 								#valueChangeSelector: #parcelSaveSourceChanged ) 							#label: 'Save source file' ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.174699 0 0.422414 ) 							#name: #parcelHideSource 							#model: #parcelHideSource 							#label: 'Hide source on load' ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.174699 0 0.681034 ) 							#name: #parcelPadded 							#model: #parcelPadded 							#label: 'Pad source' ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 10 0 0 0.583333 -5 0.5 80 0.583333 ) ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.GroupBoxSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0.0 0 0.0 0 1.0 0 1.0 ) 							#label: 'Miscellaneous Options' ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.0843373 0 0.2 ) 							#name: #parcelRepublish 							#model: #parcelRepublish 							#label: 'Republish' ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.0843373 0 0.448 ) 							#name: #parcelBackup 							#model: #parcelBackup 							#label: 'Backup' ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.0843373 0 0.712 ) 							#name: #parcelOverwrite 							#model: #parcelOverwrite 							#label: 'Overwrite existing files' ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 5 0.5 0 0.583333 -10 1 80 0.583333 ) ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 11 0 -55 1 0 1 ) 					#name: #Label2 					#label: 					#(#{Kernel.UserMessage} 						#key: #VersionStringColon 						#defaultString: 'Version String:' 						#catalogID: #store ) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 115 0 -77 1 -145 1 -52 1 ) 					#name: #VersionString 					#flags: 40 					#model: #parcelVersionString ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -135 1 -77 1 -11 1 -52 1 ) 					#name: #CopyFromPackage 					#flags: 40 					#model: #copyFromPackage 					#label: 					#(#{Kernel.UserMessage} 						#key: #CopyFromPackage 						#defaultString: 'Copy From Package' 						#catalogID: #store ) 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Tools.FileTools.TarContentsViewer class</class-id> <category>interface specs</category><body package="NewTar">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #UnlabeledCanvas 				#defaultString: 'Unlabeled Canvas' 				#catalogID: #labels ) 			#bounds: #(#{Graphics.Rectangle} 640 400 1120 704 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 1 ) 					#name: #text 					#flags: 15 					#model: #textHolder 					#style: #fixed 					#isReadOnly: true 					#tabRequiresControl: true 					#isWrapped: false ) ) ) )</body></methods><methods><class-id>Tools.ToolbarIconLibrary class</class-id> <category>resources</category><body package="Smalltalk Archive Support">loadSmalltalkArchive20x20	"UIMaskEditor new openOnClass: self andSelector: #loadParcel20x20"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 4 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 10) at: 1 put: Graphics.ColorValue black; at: 2 put: (Graphics.ColorValue scaledRed: 5548 scaledGreen: 5548 scaledBlue: 5548); at: 3 put: (Graphics.ColorValue scaledRed: 8191 scaledGreen: 8191 scaledBlue: 6077); at: 4 put: (Graphics.ColorValue scaledRed: 2113 scaledGreen: 2113 scaledBlue: 2113); at: 5 put: (Graphics.ColorValue scaledRed: 3170 scaledGreen: 3170 scaledBlue: 3170); at: 6 put: (Graphics.ColorValue scaledRed: 8191 scaledGreen: 8191 scaledBlue: 5284); at: 7 put: Graphics.ColorValue white; at: 8 put: (Graphics.ColorValue scaledRed: 6605 scaledGreen: 6605 scaledBlue: 4756); at: 9 put: (Graphics.ColorValue scaledRed: 5548 scaledGreen: 5548 scaledBlue: 3963); at: 10 put: (Graphics.ColorValue scaledRed: 4227 scaledGreen: 4227 scaledBlue: 4227); yourself)) usingBits: (ByteArray fromPackedString: 'Y&amp;YDQFY&amp;Y&amp;Y&amp;Y @@Y&amp;YFXFY&amp;Y&amp;Y&amp;Y @@Y&amp;YFTFY&amp;Y&amp;Y&amp;Y @@YDQFUDQFY&amp;Y&amp;Y @@YFY&amp;U&amp;XFY&amp;Y&amp;Y @@YFUUUUTFY&amp;Y&amp;Y @@Y@AFT@@FY&amp;Y&amp;Y @@Y&amp;YFTFY&amp;Y&amp;Y&amp;Y @@Y&amp;YFTFX@@@@@Y @@Y&amp;Y@@FA"H)H"A @@Y&amp;Y&amp;Y ZY&amp;Y$''A @@Y&amp;Y&amp;XFH"$"JXA @@Y&amp;Y&amp;@&amp;Y!Y&amp;]HA @@Y&amp;Y&amp;@'']4]7!HA @@Y&amp;Y&amp;@'']4]7!HA @@Y&amp;Y&amp;@'']4]7!HA @@Y&amp;Y&amp;@'']4]7 0Y @@Y&amp;Y&amp;@("C"H FY @@Y&amp;Y&amp;X@@@@@A&amp;Y @@Y&amp;Y&amp;Y&amp;Y&amp;Y&amp;Y&amp;Y @@'))</body><body package="Smalltalk Archive Support">loadSmalltalkArchive20x20bw	"UIMaskEditor new openOnClass: self andSelector: #loadParcel20x20bw"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[15 0 0 0 9 0 0 0 9 0 0 0 121 224 0 0 64 32 0 0 64 32 0 0 121 224 0 0 9 0 0 0 9 63 192 0 15 66 32 0 0 191 32 0 1 8 160 0 2 16 160 0 2 16 160 0 2 16 160 0 2 16 160 0 2 16 192 0 2 16 128 0 1 255 0 0 0 0 0 0])</body><body package="Smalltalk Archive Support">loadSmalltalkArchive20x20mask	"UIMaskEditor new openOnClass: self andSelector: #loadParcel20x20mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[15 0 0 0 15 0 0 0 15 0 0 0 127 224 0 0 127 224 0 0 127 224 0 0 127 224 0 0 15 0 0 0 15 63 192 0 15 127 224 0 0 255 224 0 1 255 224 0 3 255 224 0 3 255 224 0 3 255 224 0 3 255 224 0 3 255 192 0 3 255 128 0 1 255 0 0 0 0 0 0])</body></methods><methods><class-id>Tools.FileTools.FileBrowser class</class-id> <category>resources</category><body package="Smalltalk Archive UI">smalltalkArchiveExtras	"MenuEditor new openOnClass: self andSelector: #parcelExtras"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Load #defaultString: '&amp;Load' #catalogID: #menus) 				#value: #loadSmalltalkArchive 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #loadSmalltalkArchive ) ) ) #(1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>OS.TarredFilename</class-id> <category>file utilities</category><body package="NewTar">fileSize	"Answer size of file in bytes."	"However, not all files have sizes..."		^(self tarFile construct: tarredFilename) size</body></methods><methods><class-id>OS.TarredFilename</class-id> <category>accessing</category><body package="NewTar">detectTarFile	"I represent a path to a tarred file, which is contained in a tar file that lives on the physical file system.	Walk up my components until you find a file on the physical file system, and answer that, or nil if not."	| path |	path := Filename named: self asString.	"use a defined loop count to be sure the loop terminates on an invalid/non-existent path"	path components size timesRepeat: 			[path exists				ifTrue: 					[path isDirectory						ifTrue: 							["no tar file found"							^nil].					^path].			path := path directory].	^nil</body><body package="NewTar">tarFile	| tarFileFilename |	tarFile		ifNil: 			[tarFileFilename := self detectTarFile.			tarFileFilename isNil ifTrue: [^self errorReporter errorSignal raise].			tarredFilename := (UnixFilename fromComponents: (self components								allButFirst: tarFileFilename components size))						asString.			[tarFile := TarFile filename: tarFileFilename] on: Error				do: [:ex | self errorReporter errorSignal raise]].	^tarFile</body></methods><methods><class-id>OS.TarredFilename class</class-id> <category>constants</category><body package="NewTar">maxLength	"Answer the maximum length for a platform pathname, by default.	Borrowed from NTFS Filename, as a default that will probably be OK	for most other file systems.  Normally this will be overridden by a	primitive call that gives more accurate info."	^100</body></methods><methods><class-id>OS.TarredFilename class</class-id> <category>private</category><body package="NewTar">getSeparator	"Answer the platform's filename component separator."	^Filename getSeparator</body></methods><methods><class-id>OS.FileTimeAccessWin32</class-id> <category>structs</category><body package="NewTar">_FILETIME	&lt;C: struct _FILETIME {			unsigned long dwLowDateTime, dwHighDateTime;		}&gt;</body><body package="NewTar">_SYSTEMTIME	&lt;C: struct _SYSTEMTIME {  		    WORD wYear; 		    WORD wMonth; 		    WORD wDayOfWeek; 		    WORD wDay; 		    WORD wHour; 		    WORD wMinute; 		    WORD wSecond; 		    WORD wMilliseconds; }  &gt;</body><body package="NewTar">_TM	&lt;C: struct _TM {		int tm_sec;     /* seconds after the minute from 0 to 59 */		int tm_min;     /* minutes after the hour from 0 to 59 */		int tm_hour;    /* hours since midnight from 0 to 23 */		int tm_mday;    /* day of the month from 1 to 31 */		int tm_mon;     /* months since January from 0 to 11 */		int tm_year;    /* years since 1900 */		int tm_wday;    /* days since Sunday from 0 to 6 */		int tm_yday;    /* days since January 1 from 0 to 365 */		int tm_isdst;   /* daylight savings time flag */        }  &gt;</body></methods><methods><class-id>OS.FileTimeAccessWin32</class-id> <category>types</category><body package="NewTar">FILETIME	"Describes how we want the process to be started."	&lt;C: typedef struct _FILETIME FILETIME&gt;</body><body package="NewTar">SYSTEMTIME	"Describes how we want the process to be started."	&lt;C: typedef struct _SYSTEMTIME SYSTEMTIME&gt;</body><body package="NewTar">TM	"Describes how we want the process to be started."	&lt;C: typedef struct _TM TM&gt;</body><body package="NewTar">time_t	"Describes how we want the process to be started."	&lt;C: typedef long time_t&gt;</body></methods><methods><class-id>OS.FileTimeAccessWin32</class-id> <category>accessing</category><body package="NewTar">getFileTimeFor: anIOAccessor into: aFileDates		| lpCreationTime lpLastAccessTime lpLastWriteTime result hFile |	hFile := CVoidType void pointerType newOfAddress: anIOAccessor descriptor.	lpCreationTime := FILETIME gcMalloc.	lpLastAccessTime := FILETIME gcMalloc.	lpLastWriteTime := FILETIME gcMalloc.	result := self GetFileTime: hFile created: lpCreationTime accessed:			lpLastAccessTime written: lpLastWriteTime.	result = 0		ifTrue:			[^Error				raiseSignal:					(#GetFileTimeFailed1s &lt;&lt; #dialogs &gt;&gt;							'Reading file time has failed. ErrorCode: &lt;1p&gt;'						expandMacrosWith: self GetLastError)].	aFileDates		created: (self fileTimeToTimestamp: lpCreationTime);		accessed: (self fileTimeToTimestamp: lpLastAccessTime);		modified: (self fileTimeToTimestamp: lpLastWriteTime)</body><body package="NewTar">localTime: aInteger	"self new localTime: (self new time + 2177452800)"		| result param aDate aTime seconds |	param := time_t gcMalloc.	param contents: aInteger - 2177452800.	result := (self invokeLocaltime: param) contents.	aDate := Date		newDay: (result memberAt: #tm_mday)		monthNumber: (result memberAt: #tm_mon) + 1		year: (result memberAt: #tm_year) + 1900.	aTime := Time new		hours: (result memberAt: #tm_hour)		minutes: (result memberAt: #tm_min)		seconds: (result memberAt: #tm_sec) yourself.	seconds := (Timestamp new fromDate: aDate andTime: aTime) asSeconds.	^seconds</body><body package="NewTar">setFileTimeFor: anIOAccessor times: fileDates		| crTime accTime modTime toCrTime toAccTime toModTime aTimestamp |	aTimestamp := Timestamp nowUTC.	toCrTime := fileDates created		ifNil: [aTimestamp].	toAccTime := fileDates accessed		ifNil: [aTimestamp].	toModTime := fileDates modified		ifNil: [aTimestamp].	crTime := FILETIME gcMalloc.	self timestampToFileTime: toCrTime into: crTime.	accTime := FILETIME gcMalloc.	self timestampToFileTime: toAccTime into: accTime.	modTime := FILETIME gcMalloc.	self timestampToFileTime: toModTime into: modTime.	^self		SetFileTime: (CVoidType void pointerType newOfAddress: anIOAccessor descriptor)		created: crTime		accessed: accTime		written: modTime</body><body package="NewTar">time		| newTime result |	newTime := time_t gcMalloc.	result := self time: newTime.	^result</body></methods><methods><class-id>OS.FileTimeAccessWin32</class-id> <category>conversion</category><body package="NewTar">fileTimeToTimestamp: aFILETIME		| sysTime timestamp |	sysTime := SYSTEMTIME gcMalloc.	self FileTimeToSystemTime: aFILETIME systemTime: sysTime.	timestamp := Timestamp new.	timestamp		year: (sysTime memberAt: #wYear);		month: (sysTime memberAt: #wMonth);		day: (sysTime memberAt: #wDay);		hour: (sysTime memberAt: #wHour);		minute: (sysTime memberAt: #wMinute);		second: (sysTime memberAt: #wSecond);		millisecond: (sysTime memberAt: #wMilliseconds).	^timestamp</body><body package="NewTar">timestampToFileTime: aTimestamp into: aFILETIME	| sysTime |	(sysTime := SYSTEMTIME gcMalloc)		memberAt: #wYear put: (aTimestamp year);		memberAt: #wMonth put: (aTimestamp month);		memberAt: #wDayOfWeek put: (aTimestamp asDate weekdayIndex);		memberAt: #wDay put: (aTimestamp day);		memberAt: #wHour put: (aTimestamp hour);		memberAt: #wMinute put: (aTimestamp minute);		memberAt: #wSecond put: (aTimestamp second);		memberAt: #wMilliseconds put: (aTimestamp millisecond).	self SystemTimeToFileTime: sysTime fileTime: aFILETIME.</body></methods><methods><class-id>OS.FileTimeAccessWin32</class-id> <category>obsolete</category><body package="NewTar">privateGetFileTimeFor: anIOAccessor		| crTime accTime modTime result |	crTime := FILETIME gcMalloc.	accTime := FILETIME gcMalloc.	modTime := FILETIME gcMalloc.	result := self		GetFileTime: anIOAccessor descriptor		created: crTime		accessed: accTime		written: modTime.	result = 0		ifTrue: [result := self GetLastError]		ifFalse:			[result := Dictionary new.			result				at: #created					put:						(Array							with: (crTime memberAt: #dwLowDateTime)							with: (crTime memberAt: #dwHighDateTime));				at: #accessed					put:						(Array							with: (accTime memberAt: #dwLowDateTime)							with: (accTime memberAt: #dwHighDateTime));				at: #modified					put:						(Array							with: (modTime memberAt: #dwLowDateTime)							with: (modTime memberAt: #dwHighDateTime))].	^result</body><body package="NewTar">privateSetFileTimeFor: anIOAccessor times: aDictionary		| crTime accTime modTime |	crTime := FILETIME malloc.	accTime := FILETIME malloc.	modTime := FILETIME malloc.	crTime		memberAt: #dwLowDateTime			put: (aDictionary at: #created) first;		memberAt: #dwHighDateTime			put: (aDictionary at: #created) last.	accTime		memberAt: #dwLowDateTime			put: (aDictionary at: #accessed) first;		memberAt: #dwHighDateTime			put: (aDictionary at: #accessed) last.	modTime		memberAt: #dwLowDateTime			put: (aDictionary at: #modified) first;		memberAt: #dwHighDateTime			put: (aDictionary at: #modified) last.	self		SetFileTime: anIOAccessor descriptor		created: crTime		accessed: accTime		written: modTime.	crTime free.	accTime free.	modTime free</body></methods><methods><class-id>Core.TarredStream</class-id> <category>accessing</category><body package="NewTar">defaultPosixHeader	^ TarPosix2001Header blank.</body><body package="NewTar">properties	^properties ifNil: [ properties := self defaultPosixHeader ].</body><body package="NewTar">properties: anObject	properties := anObject</body></methods><methods><class-id>Core.TarredWriteStream</class-id> <category>accessing</category><body package="NewTar">atime: aInteger 	self properties atime: aInteger</body><body package="NewTar">calculateProperties	properties setChecksum</body><body package="NewTar">close	^ stream close</body><body package="NewTar">ctime: aInteger 	self properties ctime: aInteger</body><body package="NewTar">defaultPosixHeader	| header |	header :=super defaultPosixHeader.	self setDefaultPropertyValues: header.	^ header</body><body package="NewTar">flush	"Write any unwritten information. 	This is for compatibility with BufferedExternalStreams."</body><body package="NewTar">gid: aInteger 	self properties gid: aInteger</body><body package="NewTar">isReadable	"Answer whether the stream implements #next."	^stream isReadable</body><body package="NewTar">isWritable	"Answer whether the stream implements #nextPut:."	^stream isWritable</body><body package="NewTar">mode: aInteger 	self properties mode: aInteger</body><body package="NewTar">mtime: aInteger 	self properties mtime: aInteger</body><body package="NewTar">name	^self properties name</body><body package="NewTar">name: aString 	self properties name: aString</body><body package="NewTar">next	"Answer the next object in the receiver."	^stream next</body><body package="NewTar">nextPut: anObject 	"Put the argument, anObject, at the next position in the receiver.	Answer anObject."	stream nextPut: anObject</body><body package="NewTar">properties: anObject	properties := anObject</body><body package="NewTar">stream	^stream</body><body package="NewTar">stream: anObject	stream := anObject.	self properties size: stream size.</body><body package="NewTar">uid: aInteger 	self properties uid: aInteger</body></methods><methods><class-id>Core.TarredWriteStream</class-id> <category>printing</category><body package="NewTar">printOn: aStream 	"Append to the argument aStream a sequence of characters that identifies the receiver."	| connectionName |	connectionName := self name.	super printOn: aStream.	connectionName isNil		ifTrue: [^self].	aStream nextPutAll: ' on '.	connectionName printOn: aStream</body></methods><methods><class-id>Core.TarredWriteStream</class-id> <category>utilities</category><body package="NewTar">saveTo: aTarFile		self calculateProperties.	aTarFile file nextPutAll: self properties line asByteArray.	[aTarFile file nextPutAll: stream] ensure: [stream close].	aTarFile file padTo: TarFile.TARBlockSize put: 0</body><body package="NewTar">setDefaultPropertyValues: aPosixHeader		aPosixHeader		mtime: Timestamp nowUTC asSecondsForUnix;		size: stream size;		setChecksum</body></methods><methods><class-id>Core.TarredWriteStream class</class-id> <category>instance creation</category><body package="NewTar">name: aName		^self properties: (FileProperties fromFilename: aName asFilename)</body><body package="NewTar">on: aStream name: aName 	^(self basicNew)		stream: aStream;		name: aName;		yourself</body><body package="NewTar">on: aStream properties: fileProperties		| tarStream |	tarStream := (self basicNew)		stream: aStream;		name: fileProperties filename asString;		yourself.	fileProperties applyToTarWriteStream: tarStream.	^ tarStream</body><body package="NewTar">properties: fileProperties		^self		on: fileProperties filename readStream binary		properties: fileProperties</body></methods><methods><class-id>Core.FixedLine</class-id> <category>read and write</category><body package="FixedLine">from: from to: to 	| erg |	erg := self primFrom: from to: to.	erg size		to: 1		by: -1		do: [:i | (erg at: i)				== $  ifFalse: [^erg copyFrom: 1 to: i]].	^String new</body><body package="FixedLine">integerFrom: from to: to 	^self 		integerFrom: from		to: to		radix: 10</body><body package="FixedLine">integerFrom: from to: to radix: radix 	^Integer readFrom: (self primFrom: from to: to) readStream skipSeparators radix: radix</body><body package="FixedLine">integerOffset: offset length: length 	^self 		integerOffset: offset		length: length		radix: 10</body><body package="FixedLine">integerOffset: offset length: length radix: radix 	^self 		integerFrom: offset + 1		to: offset + length		radix: radix</body><body package="FixedLine">integerPut: anInteger from: from to: to 	self 		integerPut: anInteger		from: from		to: to		radix: 10</body><body package="FixedLine">integerPut: anInteger from: from to: to radix: radix	| erg s |	anInteger &lt; 0 ifTrue: [self error: anInteger printString , ' is negative.'].	erg := String new: to - from + 1 withAll: $0.	s := anInteger printStringRadix: radix.	s size &gt; erg size ifTrue: [self error: anInteger printString , ' is too large.'].	s size		to: 1		by: -1		do: [:i | erg at: i + erg size - s size put: (s at: i)].	self		primPut: erg		from: from		to: to</body><body package="FixedLine">integerPut: anInteger offset: offset length: length 	self 		integerPut: anInteger		offset: offset		length: length		radix: 10</body><body package="FixedLine">integerPut: anInteger offset: offset length: length radix: radix 	self 		integerPut: anInteger		from: offset + 1		to: offset + length		radix: radix</body><body package="FixedLine">offset: offset length: length 	^self from: offset + 1 to: offset + length</body><body package="FixedLine">put: aString from: from to: to 	self		primPut: aString		from: from		to: to</body><body package="FixedLine">put: aString offset: offset length: length 	self 		put: aString		from: offset + 1		to: offset + length</body></methods><methods><class-id>Core.FixedLine</class-id> <category>printing</category><body package="FixedLine">printOn: aStream 	self elements do: [:e | aStream nextPutAll: e; nextPutAll: ': '; print: (self perform: e asSymbol); cr]</body></methods><methods><class-id>Core.FixedLine</class-id> <category>private</category><body package="FixedLine">elements	^(self class organization listAtCategoryNamed: #accessing) 		select: [:each | each asString last ~= $:]</body><body package="FixedLine">line	^line</body><body package="FixedLine">line: anObject 	line := anObject</body><body package="FixedLine">primFrom: from to: to 	| s |	s := (line species new: to - from + 1) writeStream.	from to: to		do: 			[:i | 			| c |			c := line at: i.			c asInteger = 0 ifTrue: [^s contents].			s nextPut: c].	^s contents</body><body package="FixedLine">primPut: aString from: from to: to 	line		replaceFrom: from		to: (to min: from + aString size - 1)		with: (aString size &gt; (to - from + 1)				ifTrue: [aString copyFrom: 1 to: to - from + 1]				ifFalse: [aString])</body></methods><methods><class-id>Core.FixedLine</class-id> <category>initialization</category><body package="FixedLine">initialize	super initialize.	line := String new: self size withAll: Character space</body></methods><methods><class-id>Core.FixedLine class</class-id> <category>instance creation</category><body package="FixedLine">line: anObject 	^self new line: anObject</body></methods><methods><class-id>Core.FixedLine class</class-id> <category>generation</category><body package="FixedLine">fromStream: aStream 	"ExampleLine fromStream: (ReadStream on:'Adam 24 maleEva  23 female')"	| saetze line |	saetze := OrderedCollection new.	[aStream atEnd] whileFalse: 			[line := aStream upTo: Character cr.			line isEmpty ifFalse: [saetze add: (self line: line)]].	aStream close.	^saetze</body></methods><methods><class-id>Core.TarPosix2001Header</class-id> <category>initialize-release</category><body package="NewTar">setDefaults	self		devmajor: '';		devminor: '';		gid: 100;		gname: 'users';		linkname: '';		magic: 'ustar';		mode: 33188;		typeflag: '0';		uid: 500;		uname: 'user';		version: ''</body></methods><methods><class-id>Core.TarPosix2001Header</class-id> <category>accessing</category><body package="NewTar">atime	^self 		integerOffset: 488		length: 12		radix: 8</body><body package="NewTar">atime: anInteger 	^self 		integerPut: anInteger		offset: 488		length: 12		radix: 8</body><body package="NewTar">chksum	^self 		integerOffset: 148		length: 8		radix: 8</body><body package="NewTar">chksum: anInteger 	^self 		integerPut: anInteger		offset: 148		length: 8		radix: 8</body><body package="NewTar">chksumString: aString 	^self 		put: aString		offset: 148		length: 8</body><body package="NewTar">ctime	^self 		integerOffset: 500		length: 12		radix: 8</body><body package="NewTar">ctime: anInteger 	^self 		integerPut: anInteger		offset: 500		length: 12		radix: 8</body><body package="NewTar">devmajor	^self offset: 329 length: 8</body><body package="NewTar">devmajor: aString 	^self 		put: aString		offset: 329		length: 8</body><body package="NewTar">devminor	^self offset: 337 length: 8</body><body package="NewTar">devminor: aString 	^self 		put: aString		offset: 337		length: 8</body><body package="NewTar">gid	^self 		integerOffset: 116		length: 8		radix: 8</body><body package="NewTar">gid: anInteger 	^self 		integerPut: anInteger		offset: 116		length: 8		radix: 8</body><body package="NewTar">globalModificationTime		^self mtime + Timestamp.UnixZeroTimestamp asSeconds</body><body package="NewTar">gname	^self offset: 297 length: 32</body><body package="NewTar">gname: aString 	^self 		put: aString		offset: 297		length: 32</body><body package="NewTar">linkname	^self offset: 157 length: 100</body><body package="NewTar">linkname: aString 	^self 		put: aString		offset: 157		length: 100</body><body package="NewTar">magic	^self offset: 257 length: 6</body><body package="NewTar">magic: aString 	^self 		put: aString		offset: 257		length: 6</body><body package="NewTar">mode	^self 		integerOffset: 100		length: 8		radix: 8</body><body package="NewTar">mode: anInteger 	^self 		integerPut: anInteger		offset: 100		length: 8		radix: 8</body><body package="NewTar">mtime	^self 		integerOffset: 136		length: 12		radix: 8</body><body package="NewTar">mtime: anInteger 	^self 		integerPut: anInteger		offset: 136		length: 12		radix: 8</body><body package="NewTar">name	^self offset: 0 length: 100</body><body package="NewTar">name: aString 	^self 		put: aString		offset: 0		length: 100</body><body package="NewTar">size	^self 		integerOffset: 124		length: 12		radix: 8</body><body package="NewTar">size: anInteger 	^self 		integerPut: anInteger		offset: 124		length: 12		radix: 8</body><body package="NewTar">typeflag		^self offset: 156 length: 1</body><body package="NewTar">typeflag: aString 	^self 		put: aString		offset: 156		length: 1</body><body package="NewTar">uid	^self 		integerOffset: 108		length: 8		radix: 8</body><body package="NewTar">uid: anInteger 	^self 		integerPut: anInteger		offset: 108		length: 8		radix: 8</body><body package="NewTar">uname	^self offset: 265 length: 32</body><body package="NewTar">uname: aString 	^self 		put: aString		offset: 265		length: 32</body><body package="NewTar">version	^self offset: 263 length: 2</body><body package="NewTar">version: aString 	^self 		put: aString		offset: 263		length: 2</body></methods><methods><class-id>Core.TarPosix2001Header</class-id> <category>read and write</category><body package="NewTar">integerPut: anInteger offset: offset length: length radix: radix 	"ensure to have a trailing Charcter 0 at the end"	super 		integerPut: anInteger		offset: offset		length: length - 1		radix: radix</body><body package="NewTar">setChecksum	| sum |	self chksumString: (String new: 8 withAll: Character space).	sum := 0.	line do: [:c | sum := sum + c asInteger].	self chksum: sum</body></methods><methods><class-id>Core.TarPosix2001Header class</class-id> <category>instance creation</category><body package="NewTar">blank	^(self line: (String new: TarFile.TARBlockSize)) setDefaults</body></methods><methods><class-id>OS.FileTimeAccessUnix</class-id> <category>converting</category><body package="NewTar">fileTimeToTimestamp: seconds		^Timestamp fromUnixSeconds: seconds</body></methods><methods><class-id>OS.FileTimeAccessUnix</class-id> <category>accessing</category><body package="NewTar">getFileTimeFor: aFilename into: aFileDates		| aStatPtr |	aStatPtr := self stat: aFilename.	aFileDates		created: (self fileTimeToTimestamp: (aStatPtr memberAt: #st_ctime));		accessed: (self fileTimeToTimestamp: (aStatPtr memberAt: #st_atime));		modified: (self fileTimeToTimestamp: (aStatPtr memberAt: #st_mtime))</body><body package="NewTar">setFileTime: aDict for: aFilename		self uTime: aFilename with: aDict</body></methods><methods><class-id>Store.PublishSpecification</class-id> <category>accessing</category><body package="Smalltalk Archive UI">publishBinary	self binarySave: true</body><body package="Smalltalk Archive UI">pundle: aPundle	super pundle: aPundle.	aPundle binarySave ifTrue: [self publishBinary]</body><body package="Smalltalk Archive Support">smalltalkArchive	^smalltalkArchive</body><body package="Smalltalk Archive Support">smalltalkArchive: aBoolean	smalltalkArchive := aBoolean</body></methods><methods><class-id>Store.PublishSpecification</class-id> <category>publishing</category><body package="Smalltalk Archive Support">prepareBinary		| packageModel |	self pundle isBundle ifTrue: [^self].	packageModel := self pundle storeModel.	packageModel propertyAt: #packageName put: packageModel name.	self pundle propertyAt: #packageName put: packageModel name.	packageModel binarySave: true.	self pundle binFile: ''</body></methods><methods><class-id>Store.ArchiveRecord</class-id> <category>accessing</category><body package="Smalltalk Archive Support">asString	^name</body><body package="Smalltalk Archive Support">blobData	^blobData</body><body package="Smalltalk Archive Support">blobData: aByteArray	blobData := aByteArray</body><body package="Smalltalk Archive Support">name	^name</body><body package="Smalltalk Archive Support">name: aString	name := aString</body><body package="Smalltalk Archive Support">sourceData	^sourceData</body><body package="Smalltalk Archive Support">sourceData: aByteArray	sourceData := aByteArray</body></methods><methods><class-id>Store.ArchiveRecord class</class-id> <category>instance creation</category><body package="Smalltalk Archive Support">from: aPackage	| instance |	instance := self newNamed: aPackage name.	^instance</body><body package="Smalltalk Archive Support">newNamed: aName 	^(self new)		name: aName asString;		yourself</body></methods><methods><class-id>Store.PublishAsParcelDialog</class-id> <category>interface opening</category><body package="Smalltalk Archive UI">postOpenWith: aBuilder 	"This message is sent by the builder after it has opened a completed window."	self copyFromPackage.	(self builder componentAt: #parcelSave) isEnabled: false.	(self builder componentAt: #parcelDirectory) isEnabled: true.	(self builder componentAt: #smalltalkArchive) 		isEnabled: (pundle propertyAt: #shadowPundle ifAbsent: [false]) not.	self smalltalkArchiveChanged</body></methods><methods><class-id>Store.PublishAsParcelDialog</class-id> <category>aspects</category><body package="Smalltalk Archive UI">bundleStructureChanged	"Enable the database links depending on wheter the structure will be saved."	( self builder componentAt: #databaseLinks ) isEnabled: 		(( self smalltalkArchive value | (self bundleStructure value  &amp;  pundle hasBeenModified not)) &amp; ((self builder componentAt: #smalltalkArchive) isEnabled)).	databaseLinks value: ( self smalltalkArchive value | (databaseLinks value  &amp;  bundleStructure value)).</body><body package="Smalltalk Archive UI">smalltalkArchive	smalltalkArchive == nil		ifTrue: [ smalltalkArchive := true asValue ].	^smalltalkArchive</body><body package="Smalltalk Archive UI">smalltalkArchiveChanged	"Enable the bundleStructure depending on wheter the multi parcel will be saved."	(self builder componentAt: #bundleStructure) isEnabled: self smalltalkArchive value not.	bundleStructure value: smalltalkArchive value not.	self bundleStructureChanged.	self smalltalkArchive value		ifFalse: 			[pundle hasBeenModified &amp; pundle isBundle				ifTrue: 					[self databaseLinks value: false.					Dialog warn: (#PundleHasUnpublishedChanges &lt;&lt; #packages &gt;&gt; '&lt;1s&gt; has unpublished changes. Database links cannot be saved.'								expandMacrosWith: pundle name)]]</body></methods><methods><class-id>Store.PublishAsParcelDialog</class-id> <category>private</category><body package="Smalltalk Archive UI">options	"Answer a dictionary containing all the possible options that are used when 	 saving a parcel.  These properties are instructions that determine how the	 parcel will be saved (for example, with or without source).  One of the 	 options, #padded, is passed along to the newly created parcel and assigned	 into its properties dictionary.  For #padded, we only want to add it to the	 dictionary being returned if the client user this dialog has set it to true.  	 Otherwise, we do not want to add this property because the absence of the 	 #padded conveys the same information to the system as if it is there with	 a value of false.  Also, by only adding this property if the user wants it added	 we prevent unnecessary modifications to the package."	| optionsDictionary |	optionsDictionary := Dictionary new.	optionsDictionary		at: #parcelSave put: self parcelSave value;		at: #databaseLinks put: self databaseLinks value;		at: #bundleStructure put: self bundleStructure value;		at: #smalltalkArchive put: self smalltalkArchive value;		at: #parcelDirectory put: self parcelDirectory value;		at: #parcelRepublish put: self parcelRepublish value;		at: #parcelBackup put: self parcelBackup value;		at: #parcelOverwrite put: self parcelOverwrite value;		at: #parcelSaveSource put: self parcelSaveSource value;		at: #parcelVersionString put: self parcelVersionString value;		at: #parcelHideSource put: self parcelHideSource value.	self parcelPadded value ifTrue:		[pundle propertyAt: #padded put: true].	^optionsDictionary.</body><body package="Smalltalk Archive UI">validateParcelOptions	| filename extension |	extension := self smalltalkArchive value		ifTrue: 			[self parcelSaveSource value				ifTrue: [SmalltalkArchiveFileItem extensionDevelopment]				ifFalse: [SmalltalkArchiveFileItem extensionDeployment]]		ifFalse: [Parcel fileExtension].	((filename := self basePath , extension) asFilename exists 		and: [self parcelOverwrite value not]) 			ifTrue: 				[(Dialog 					confirm: (#OKtoOverwriteParcelQ &lt;&lt; #packages 							&gt;&gt; '&lt;n&gt;&lt;1s&gt; exists: &lt;n&gt;&lt;n&gt;Overwrite files?&lt;n&gt;' expandMacrosWith: filename)) 						ifTrue: [self parcelOverwrite value: true]						ifFalse: [^false]].	^true</body></methods><methods><class-id>Store.PublishAsParcelDialog class</class-id> <category>interface opening</category><body package="Smalltalk Archive UI">publishAsParcel: aPundleCollection 	"Open a dialog for package/bundle parcel publishing."	"self publishAsParcel: ( Registry packageNamed: 'Store-UI' )"	| dialog filename pundles returnCode shadowPundle |	pundles := aPundleCollection.	returnCode := self.	aPundleCollection size &gt; 1 		ifTrue: 			[(Dialog 				confirm: 'Do you want to save all selected pundles into the same smalltalk archive?'				initialAnswer: true) 					ifTrue: 						[shadowPundle := BundleModel new name: 'Smalltalk Archive Unnamed'.						shadowPundle propertyAt: #shadowPundle put: true.						aPundleCollection do: [:each | shadowPundle addItem: each].						pundles := OrderedCollection with: shadowPundle]].	pundles do: 			[:pundle | 			dialog := self new.			dialog pundle: pundle.			dialog open.			dialog accept value 				ifFalse: [returnCode := nil]				ifTrue: 					[filename := Filename named: dialog parcelDirectory value.					(pundle propertyAt: #shadowPundle ifAbsent: [false])						ifTrue: [pundle name: filename].					pundle 						saveAsParcel: filename						saveStructure: dialog bundleStructure value						saveLinks: dialog databaseLinks value						parcelOptions: dialog options]].	^returnCode</body></methods><methods><class-id>Store.PublishAsParcelDialog class</class-id> <category>help</category><body package="Smalltalk Archive UI">parcelHelp	^(#parcelHelpWithSmalltalkArchives &lt;&lt; #packages &gt;&gt; 'Include Bundle Structure if you would like the bundle to be recreated when loading the parcel into a Store image.  Saving Database Links will hook the components to a particular database. This saves the loader from needing to reconcile source before publishing a new version to the same database.The Saving as Smalltalk Archive is selected, the development smalltalk archive will be saved in the Parcel Path + .store, the deployment archive in Parcel Path +.star.Save source file create a development archive (.store) file.The Saving as Smalltalk Archive is not selected, The parcel will be saved in the Parcel Path + .pcl, the sources in Parcel Path +.pst. Save source file will create the parcel sources (.pst) file.Hide sources on load will not effect the current image, but will supress sources when it is loaded into a another image. This is for deployment parcels and should not be used during development.Select republish to save with sources to a parcel that is currently loaded to the same file name.  Republishing does not hide sources. Republishing will invalidate other images that point to the original file.') asString</body></methods><methods><class-id>Core.TarFile</class-id> <category>accessing</category><body package="NewTar">at: index	^contents at: index</body><body package="NewTar">at: index put: newObject	^self subclassResponsibility</body><body package="NewTar">contents	^contents</body><body package="NewTar">contents: anObject	contents := anObject</body><body package="NewTar">file	^file</body><body package="NewTar">file: anObject	file := anObject</body><body package="NewTar">filename	filename ifNil: [filename := file name].	^filename</body><body package="NewTar">filename: anObject	filename := anObject</body><body package="NewTar">indexOfFilename: aString	^self findFirst: [:each | each name = aString].</body><body package="NewTar">size	^contents size</body></methods><methods><class-id>Core.TarFile</class-id> <category>initialize-release</category><body package="NewTar">initialize	"Initialize a newly created instance. This method must answer the receiver."	file := nil.	contents := OrderedCollection new.	^self</body></methods><methods><class-id>Core.TarFile</class-id> <category>converting</category><body package="NewTar">asLogicalFileSpecification	^self filename</body></methods><methods><class-id>Core.TarFile</class-id> <category>instance creation</category><body package="NewTar">construct: aString 	^self detect: [:each | each name = aString] ifNone: [nil]</body></methods><methods><class-id>Core.TarFile</class-id> <category>status</category><body package="NewTar">close	file close</body><body package="NewTar">closeContentsStreams	self contents do: [ :each | each close ]</body></methods><methods><class-id>Core.TarFile class</class-id> <category>instance creation</category><body package="NewTar">filename: aFilename	| readStream |	readStream := aFilename asFilename readStream.	^(TarReadFile new)		file: readStream;		filename: aFilename asLogicalFileSpecification;		getContents;		yourself</body><body package="NewTar">new	"Answer a newly created and initialized instance."	^super new initialize</body><body package="NewTar">newOn: writeStream 	^(TarWriteFile new)		file: writeStream;		yourself</body><body package="NewTar">on: readStream 	^(TarReadFile new)		file: readStream;		getContents;		yourself</body></methods><methods><class-id>Core.TarFile class</class-id> <category>accessing</category><body package="NewTar">addExtension: anExtension	^self knownExtensions add: anExtension</body><body package="NewTar">knownExtensions	^TARKnownExtensions</body><body package="NewTar">knownExtensionsWithPrefix: aPrefix separatedBy: aSeparator		| stream |	stream := WriteStream on: String new.	self knownExtensions		do:			[:each | 			stream				nextPutAll: aPrefix;				nextPutAll: each]		separatedBy: [stream nextPutAll: aSeparator].	^stream contents</body></methods><methods><class-id>Core.TarWriteFile</class-id> <category>adding</category><body package="NewTar">add: aStream 	^self add: aStream name: aStream name</body><body package="NewTar">add: aStream name: aName	^contents add: (TarredWriteStream on: aStream name: aName)</body><body package="NewTar">add: aStream properties: fileProperties		^contents		add: (TarredWriteStream on: aStream properties: fileProperties)</body><body package="NewTar">addCollection: aCollection name: aString 	| foundIndex |	foundIndex := self indexOfFilename: aString.	foundIndex = 0 		ifTrue: [self add: aCollection readStream name: aString]		ifFalse: 			[contents at: foundIndex				put: (TarredWriteStream on: aCollection name: aString)]</body><body package="NewTar">addFilename: aName	^contents add: (TarredWriteStream name: aName)</body></methods><methods><class-id>Core.TarWriteFile</class-id> <category>accessing</category><body package="NewTar">at: index put: newObject	^contents at: index put: (TarredWriteStream on: newObject name: newObject name)</body></methods><methods><class-id>Core.TarWriteFile</class-id> <category>private</category><body package="NewTar">writeContents	file binary.	contents do: [:each | each saveTo: self].	file next: TARBlockSize * 2 put: 0.	file close</body></methods><methods><class-id>Store.PublishPundleDialog</class-id> <category>private-visual blocks</category><body package="Smalltalk Archive UI">binaryLabelForItem: anItem view: view 	| label |	label := Label with: 		(anItem isFileSpecification			ifTrue: ['']			ifFalse: [anItem binarySave ifTrue: ['binary'] ifFalse: ['source']]).	label attributes: view textStyle.	^label</body><body package="Smalltalk Archive UI">computeLabelsForView: aView 	"Compute all the labels right away so that we know 	what offsets to use. Store the labels so that extra 	database accesses are not needed to recompute them."	| max1 max2 max3 max4 |	max1 := max2 := max3 := max4 := 0.	labelDict := Dictionary new: self currentItems list size.	self currentItems list do: 			[:anItem | 			| publishFlag pndl label1 label2 label3 label4 label5 level levelOffset |			publishFlag := anItem publish.			label1 := LabelAndIcon with: ''.			publishFlag ifTrue: [label1 beCheckMark].			levelOffset := 10.			level := levelOffset * anItem level.			pndl := anItem pundle.			label2 := pndl elementLabel: #().			label2 text: pndl name asText.			label2 attributes: aView textStyle.			label3 := Label 						with: (publishFlag ifTrue: [anItem version] ifFalse: [anItem parentVersion]).			label3 attributes: aView textStyle.			label4 := Label with: (publishFlag 								ifTrue: [Policies blessingPolicy blessingName: anItem blessing]								ifFalse: ['']).			label4 attributes: aView textStyle.			label5 := self binaryLabelForItem: anItem view: aView.			labelDict at: anItem				put: (Array 						with: label1						with: (Array with: label2 with: level)						with: label3						with: label4) , (Array with: label5).			max1 := label1 width max: max1.			max2 := label2 width + level max: max2.			max3 := label3 width max: max3.			max4 := label4 width max: max4].	offsets := (Array 				with: 6				with: max1 + 16				with: max2 + max1 + 26				with: max3 + max2 + max1 + 56) 					, (Array with: max4 + max3 + max2 + max1 + 76)</body><body package="Smalltalk Archive UI">labelForItem: anItem view: aView 	| cp labels |	cp := CompositePart new.	(labelDict == nil 		or: [(labelDict at: anItem ifAbsent: nil) == nil or: [offsets isNil]]) 			ifTrue: [self computeLabelsForView: aView].	labels := labelDict at: anItem.	cp add: (labels at: 1) at: (offsets at: 1) @ 0.	cp add: (labels at: 2) first		at: ((offsets at: 2) + (labels at: 2) last) @ 0.	cp add: (labels at: 3) at: (offsets at: 3) @ 0.	cp add: (labels at: 4) at: (offsets at: 4) @ 0.	cp add: (labels at: 5) at: (offsets at: 5) @ 0.	^cp</body></methods><methods><class-id>Store.PublishPundleDialog</class-id> <category>aspects</category><body package="Smalltalk Archive UI">bundleStructureChanged	"Enable the database links depending on wheter the structure will be saved."	self enableComponentAt: #databaseLinks enable: self smalltalkArchive value | self bundleStructure value.	self databaseLinks value: self smalltalkArchive value | ( self databaseLinks value  &amp;  self bundleStructure value ).</body><body package="Smalltalk Archive UI">parcelSaveChanged	"Enable the parcel directory depending on wheter parcel will be published."	| shouldSave |	shouldSave := self parcelSave value.	self parcelDetails do: [:each | self enableComponentAt: each enable: shouldSave].	self enableComponentAt: #smalltalkArchive enable: shouldSave.	self smalltalkArchive value: shouldSave.	self smalltalkArchiveChanged.	self parcelSaveSourceChanged</body><body package="Smalltalk Archive UI">smalltalkArchive	smalltalkArchive == nil		ifTrue: [ smalltalkArchive := true asValue ].	^smalltalkArchive</body><body package="Smalltalk Archive UI">smalltalkArchiveChanged	"Enable the bundleStructure depending on wheter the multi parcel will be saved."	self enableComponentAt: #bundleStructure enable: ( self parcelSave value &amp; self smalltalkArchive value not ).	self bundleStructure value: ( self parcelSave value &amp; self smalltalkArchive value not ).	self bundleStructureChanged.</body></methods><methods><class-id>Store.PublishPundleDialog</class-id> <category>private</category><body package="Smalltalk Archive UI">newDetailState	| sel duplicates |	sel := self currentItems selection.	duplicates := self currentItems list select: 		[ :each | ( each pundle ) == ( sel pundle ) ].	duplicates do:		[ :each | | index sub |		each publish: self publish value.		each comment: self blessingComment value.		each version: self versionString value.		each binarySave: self binarySave value.		index := self currentItems list indexOf: each.		( sub := self subComponentAt: #itemsList ) == nil			ifFalse: [ sub widget updateAt: index ].		( sub := self subComponentAt: #fileList ) == nil			ifFalse: [ sub widget updateAt: index ].		].	labelDict := nil.</body><body package="Smalltalk Archive UI">newGlobalState		"Update the global (belonging to the outer bundle) state."	^self globalOptions		parcelSave: self parcelSave value;		databaseLinks: self databaseLinks value;		bundleStructure: self bundleStructure value;		smalltalkArchive: self smalltalkArchive value;		parcelDirectory: self parcelDirectory value;		parcelRepublish: self parcelRepublish value;		parcelBackup: self parcelBackup value;		parcelOverwrite: self parcelOverwrite value;		parcelSaveSource: self parcelSaveSource value;		parcelHideSource: self parcelHideSource value;		parcelPadded: self parcelPadded value;		parcelVersionString: self parcelVersionString value;		yourself.</body><body package="Smalltalk Archive UI">updateItemModels	self items list do: [:each | each pundle binarySave: each binarySave]</body><body package="Smalltalk Archive UI">validateParcelOptions	| filename extension |	self parcelSave value ifFalse: [^true].	extension := self smalltalkArchive value 		ifTrue: 			[self parcelSaveSource value 				ifTrue: [SmalltalkArchiveFileItem extensionDevelopment]				ifFalse: [SmalltalkArchiveFileItem extensionDeployment]]		ifFalse: [Parcel fileExtension].	((filename := self basePath , extension) asFilename exists 		and: [self parcelOverwrite value not]) 			ifTrue: 				[(Dialog confirm: (#_n1sExistsnnOverwriteFiles &lt;&lt; #store &gt;&gt; '&lt;n&gt;&lt;1s&gt; exists: &lt;n&gt;&lt;n&gt;Overwrite files?&lt;n&gt;' 							expandMacrosWith: filename)) 					ifTrue: [self parcelOverwrite value: true]					ifFalse: [^false]].	self pundle parcelDirectory: filename.	^true</body></methods><methods><class-id>Store.CodeReaderForSmalltalkArchive</class-id> <category>private reading</category><body package="Smalltalk Archive Support">processPrerequisites: aSequence 	"Process the prerequsites in aSequence.	 This defers the processing of prerequisites to Parcel.	See readPrerequsites for the format of each tuple"	aSequence do: 			[:tuple | 			| componentIndex type name |			type := tuple at: 1.			name := tuple at: 2.			type = 'parcel' 				ifTrue: 					[(componentIndex := self streamDirectory indexOfFilename: name , '.b.pcl') 						&gt; 0 							ifTrue: 								[Store.BundleModel readFromTarfile: self streamDirectory at: componentIndex]							ifFalse: 								[(componentIndex := self streamDirectory indexOfFilename: name , '.p.pcl') 									&gt; 0 										ifTrue: 											[Store.PackageModel readFromTarfile: self streamDirectory at: componentIndex]										ifFalse: [Parcel withFileCachesDo: [Parcel handlePrerequisite: tuple]]]]				ifFalse: [CodeReader prerequisiteSignal raiseRequestWith: tuple]]</body><body package="Smalltalk Archive Support">readBundleContents	| myIndex |	(properties at: #bundleContents ifAbsent: [nil]) ifNotNil: 			[:bundleContents | 			myIndex := streamDir indexOfFilename: parcelName , '.b.pcl'.			bundleContents do: 					[:each | 					| componentIndex |					each value = #bundle 						ifTrue: 							[componentIndex := streamDir indexOfFilename: each key , '.b.pcl'.							componentIndex &gt; myIndex 								ifTrue: [Store.BundleModel readFromTarfile: streamDir at: componentIndex]]						ifFalse: 							[componentIndex := streamDir indexOfFilename: each key , '.p.pcl'.							componentIndex &gt; myIndex 								ifTrue: [Store.PackageModel readFromTarfile: streamDir at: componentIndex]]]]</body><body package="Smalltalk Archive Support">readPackage	| organizerStart |	self initializePackageNameSpaces.	self allocateStorage.	self readWellKnownObjects.	self readDependentClasses.	self readKnownLiterals.	self readPackageObjects.	self readPackageClasses.	self readPackageBindings.	self readScopeZones.	organizerStart := pointer.	self readObjects.	self readMethodDictionaries: organizerStart.	self readExtensionMethods.	self readPackageClassesInitializationObjects.	self readNamedObjects</body><body package="Smalltalk Archive Support">readProperties	"Version two starts the support for the postLoadMethod, which is replaced by a block in Version 15."	"Version 4 starts use of the general heap to store userStrings/properties.	 Version 5 stores properties as a Dictionary."	"&lt;Array of: Symbol&gt;  Class name and selector; the message to send after loading"	| timestamp postLoadMethod |	(format between: 2 and: 15) ifTrue: [postLoadMethod := self readObject].	format &gt;= 4 		ifTrue: 			[((properties := self readObject) isKindOf: Dictionary) 				ifTrue: 					[properties rehash]				ifFalse: 					[| userStrings |					userStrings := properties.					properties := Dictionary new.					1 to: userStrings size						by: 2						do: [:i | properties at: (userStrings at: i) asSymbol put: (userStrings at: i + 1)]]].	timestamp := Timestamp 				readFromDateAndTime: (dateString , ' ' , timeString) readStream.	timestamp notNil ifTrue: [properties at: #timestamp put: timestamp].	mustRecompile 		ifTrue: [properties at: #recompile put: true]		ifFalse: [properties removeKey: #recompile ifAbsent: nil].	"Action methods have been replaced by action blocks.	 Convert any old method actions to equivalent block actions."	format &lt;= 15 		ifTrue: 			[postLoadMethod notNil 				ifTrue: [properties at: #postLoadMethod put: postLoadMethod].			self convertOldActions]</body><body package="Smalltalk Archive Support">readPundle: aPundle	self readHeader.	self postReadHeaderAction.	self checkForSourceFile.	(self checkForLoadedVersion: aPundle)		ifTrue: [^true].	format &gt;= 6 		ifTrue: 			[self readActionsAndPrerequisitesInto: 					[:actions :prerequisites | 					self compileActions: actions.					self runPreRead.					self processPrerequisites: prerequisites]]		ifFalse: [self readOldUserStrings].	self readPackage.	self readProperties.	self readBundleContents.	self doLateOperations.	^false</body></methods><methods><class-id>Store.CodeReaderForSmalltalkArchive</class-id> <category>private</category><body package="Smalltalk Archive Support">createStreamFromRecord: aParcelRecord 	^self createTarredStreamFromRecord: aParcelRecord</body><body package="Smalltalk Archive Support">createTarredStreamFromRecord: aParcelRecord 	stream := InternalCodeReaderStream on: aParcelRecord blobData contents.	streamDir := aParcelRecord blobData tarFile.	aParcelRecord sourceData isNil ifFalse: [	tempSourceFile := aParcelRecord sourceData name]</body><body package="Smalltalk Archive Support">pundleModelClass: tarContents	| firstElementName |	tarContents isEmpty ifTrue: [^nil].	firstElementName := tarContents first name.	('*p.pcl' match: firstElementName) ifTrue: [^PackageModel].	('*b.pcl' match: firstElementName) ifTrue: [^BundleModel].	^nil</body><body package="Smalltalk Archive Support">relocateOrReplaceName: symbol from: fromNameSpace to: toNameSpace map: map 	"Handles when the incoming binding exists in the image. Creates the override.	Note this assumes it is called from somewhere that wraps the send in a modifySystem: block."	| newBinding newThing oldThing oldBinding |	(toNameSpace asNameSpace includesKey: symbol) 		ifFalse: 			[^SystemUtils 				relocateName: symbol				from: fromNameSpace				to: toNameSpace].	(fromNameSpace asNameSpace includesKey: symbol) 		ifFalse: 			[self 				error: (#nameSpaceDoesNotIncludeKey &lt;&lt; #dialogs 						&gt;&gt; '&lt;1p&gt; does not include a key &lt;2s&gt;' expandMacrosWith: fromNameSpace							with: symbol)].	oldThing := toNameSpace asNameSpace at: symbol.	newBinding := fromNameSpace asNameSpace localBindingFor: symbol.	newThing := newBinding value.	"Note- extended classes and namespace are marked as statics - so check for nil"	newThing == nil 		ifTrue: 			[Override 				installStaticOverride: (Override forDataKey: newBinding key in: toNameSpace).			toNameSpace asNameSpace replaceStaticBinding: newBinding.			^self].	newThing class = ExternalDictionary 		ifTrue: 			[oldThing isNil 				ifTrue: 					[oldBinding := toNameSpace asNameSpace bindingFor: symbol.					oldBinding setValue: External.ExternalDictionary new.					oldThing := oldBinding value].			^self updateSystemExternalDictionary: oldThing with: newThing].	newBinding isForGeneral 		ifFalse: 			["marks an extension, not a definition"			Override installOverride: (Override forClassOrNameSpace: oldThing)				for: oldThing].	"Install the incoming definition over the oldThing one without disturbing methods/statics."	newThing environment: fromNameSpace.	"is nil for the Smalltalk namespace"	oldThing redefineFrom: newThing map: map.	"Move over the incoming methods/statics"	newThing asNameSpace keys do: 			[:k | 			self 				relocateOrReplaceName: k				from: newThing				to: oldThing				map: map].	newThing isForClass 		ifTrue: 			[newThing removeFromSuper.			"The redefined class must also adopt any subclasses of the new version."			newThing subclasses do: 					[:sc | 					sc assignSuperclass: oldThing.					sc isMeta ifFalse: [sc class assignSuperclass: oldThing class]].			(Array with: newThing with: newThing class) 				with: (Array with: oldThing with: oldThing class)				do: 					[:newBehavior :oldBehavior | 					newBehavior selectorsAndMethodsDo: 							[:selector :cm | 							| over |							(over := Override forSelector: selector class: oldBehavior) == nil 								ifFalse: [Override installMethodOverride: over].							oldBehavior 								addSelector: selector								withMethod: cm								category: (newBehavior organization categoryOfElement: selector).							self fixMClass: cm to: oldBehavior]]].	newThing oneWayBecome: oldThing.	"so  parcel pointers point to the right place"	fromNameSpace asNameSpace simpleRemoveKey: symbol</body></methods><methods><class-id>Store.CodeReaderForSmalltalkArchive</class-id> <category>api</category><body package="Smalltalk Archive Support">readFrom: aSource oldPundle: aPundle	self createTarredStreamFromRecord: aSource.	^[self readPundle: aPundle]		ensure: [stream close]</body><body package="Smalltalk Archive Support">readInfoFromFileNamed: aFilename 	^self readInfoFromTarFileNamed: aFilename</body><body package="Smalltalk Archive Support">readInfoFromRecord: aParcelRecord 	"Answer a Dictionary of useful information from the Parcel named aParcelRecord."	| info timestamp |	info := Dictionary new.	self createStreamFromRecord: aParcelRecord.		[self readHeader.	format &gt;= 6 		ifTrue: 			[info at: #prerequisiteParcels put: OrderedCollection new.			self readActionsAndPrerequisitesInto: 					[:actions :prerequisites | 					self compileActions: actions.					prerequisites do: 							[:tuple | 							(tuple at: 1) = 'parcel' 								ifTrue: [(info at: #prerequisiteParcels) add: (tuple copyFrom: 2 to: 3)]								ifFalse: 									[info at: tuple first asSymbol put: (tuple copyFrom: 2 to: tuple size - 1)]]]].	self readPackage.	self readProperties] 			ensure: [stream close].	parcelName size &gt; 0 ifTrue: [info at: #parcel put: parcelName].	versionString size &gt; 0 ifTrue: [info at: #version put: versionString].	info at: #format put: format.	timestamp := Timestamp 				readFromDateAndTime: (dateString , ' ' , timeString) readStream.	timestamp notNil ifTrue: [info at: #timestamp put: timestamp].	(properties includesKey: #bundleContents) 		ifTrue: [info at: #bundleContents put: (properties at: #bundleContents) asArray].	(properties includesKey: #dbInfo)		ifTrue: [info at: #dbInfo put: (properties at: #dbInfo)].	^info</body><body package="Smalltalk Archive Support">readInfoFromTarFileNamed: aFilename	"Answer aDictionary of useful information from the Parcel named aFilename."	| tarfile tarContents archiveRecord info |	tarfile := TarFile filename: aFilename.	tarContents := tarfile contents.	tarContents isEmpty ifTrue: [self class fileFormatSignal raise].	archiveRecord := Store.ArchiveRecord newNamed: tarContents first name.	archiveRecord blobData: tarContents first.	aFilename isSmalltalkArchiveDevelopment		ifTrue: [archiveRecord sourceData: (tarContents at: 2)].	info := self readInfoFromRecord: archiveRecord.	info at: #pundleModelClass put: (self pundleModelClass: tarContents).	tarfile close.	^info</body></methods><methods><class-id>Store.CodeReaderForSmalltalkArchive</class-id> <category>private updating</category><body package="Smalltalk Archive Support">updateSystemExternalDictionary: systemDictionary with: newDictionary 	"Rather then replace the ExternalDictionary in the system, it appears to be	 simpler to simply update the system version with the values of the incoming	 dictionary.  Note that entries that are in the systemDictionary that are not	 in the newDictionary do not need to be removed, their weakness should	 take care of that if they truly need to disappear."	| newBackup |	systemDictionary class = ExternalDictionary 		ifFalse: 			[self error: #errBogusExternalDictionary &lt;&lt; #dialogs 						&gt;&gt; 'Can not update system''s version of the ExternalDictionary.'].	newBackup := newDictionary backup.	newDictionary backup: OrderedCollection new.	newDictionary 		keysAndValuesDo: [:key :value | value notNil ifTrue: [systemDictionary at: key put: value]].	systemDictionary backup: newBackup</body></methods><methods><class-id>Store.CodeReaderForSmalltalkArchive</class-id> <category>testing</category><body package="Smalltalk Archive Support">checkForLoadedVersion: aPundle 	aPundle isNil ifTrue: [^false].	^(aPundle propertyAt: #timestamp ifAbsent: [nil]) printString = self timestamp printString</body><body package="Smalltalk Archive Support">timestamp	^Timestamp readFromDateAndTime: (dateString, ' ', timeString) readStream</body></methods><methods><class-id>Store.CodeReaderForSmalltalkArchive class</class-id> <category>instance creation</category><body package="Smalltalk Archive Support">new	^self basicNew</body></methods><methods><class-id>Core.TarReadFile</class-id> <category>private</category><body package="NewTar">getContents	contents := OrderedCollection new.	file reset.	file binary.		[| c |	c := file peek.	c = 0 or: [c isNil]] 			whileFalse: [contents add: (TarredReadStream on: self)].	file close</body></methods><methods><class-id>Core.TarReadFile</class-id> <category>accessing</category><body package="NewTar">at: index put: newObject	^self shouldNotImplement</body></methods><methods><class-id>Core.TarReadFile</class-id> <category>adding</category><body package="NewTar">add: aStream 	^self shouldNotImplement</body></methods><methods><class-id>Core.TarReadFile class</class-id> <category>instance creation</category><body package="NewTar">newOn: readStream 	^(self new)		file: readStream;		yourself</body></methods><methods><class-id>Tools.FileTools.TarContentsViewer</class-id> <category>accessing</category><body package="NewTar">printBlurbFor: aFilename on: stream 	(TarFile filename: aFilename) contents do: 			[:taredFile | 			self printFileInformation: taredFile on: stream.			stream cr]</body><body package="NewTar">printFileInformation: taredFile on: stream		stream		nextPutAll:				(taredFile name asFilename tail asString copyFromLeftWithSize: 30);		nextPutAll: (taredFile size printString copyFromRightWithSize: 15);		nextPutAll: (Timestamp fromSeconds: taredFile fileProperties localModified) printString</body></methods><methods><class-id>Tools.FileTools.TarContentsViewer class</class-id> <category>accessing</category><body package="NewTar">isInterestedInFile: aFilename 	^aFilename isTarFile</body><body package="NewTar">tabLabel	^(#TarContens &lt;&lt; #labels &gt;&gt; 'Tarfile contents')</body><body package="NewTar">tabPosition	^5</body></methods><methods><class-id>Tools.FileTools.SmalltalkArchiveViewer</class-id> <category>api</category><body package="Smalltalk Archive UI">isLoaded: propertyDictionary	^(propertyDictionary at: #pundleModelClass ifAbsent: [^false])		isSmalltalkArchiveLoaded: propertyDictionary</body><body package="Smalltalk Archive UI">isSomeVersionLoaded: propertyDictionary	^((propertyDictionary at: #pundleModelClass ifAbsent: [^false])		getPundle: (propertyDictionary at: #parcel ifAbsent: [^false])) notNil</body><body package="Smalltalk Archive UI">printHeaderOn: aStream usingProperties: propertyCollection	| propertyDictionary |	propertyDictionary := Dictionary withAll: propertyCollection.	aStream emphasis: #bold.	(self isSomeVersionLoaded: propertyDictionary)		ifFalse: 			[aStream				nextPutAll: (#ThisSmalltalkArchiveIsNotLoaded &lt;&lt; #dialogs							&gt;&gt; 'This smalltalk archive is not loaded') asString;				cr;				cr]		ifTrue: 			[(self isLoaded: propertyDictionary)				ifTrue: 					[aStream						nextPutAll: (#ThisSmalltalkArchiveIsLoaded &lt;&lt; #dialogs									&gt;&gt; 'This smalltalk archive is loaded') asString;						cr;						cr]				ifFalse: 					[aStream						nextPutAll: (#DifferentVersion1sSmalltalkArchiveIsLoaded &lt;&lt; #dialogs									&gt;&gt; 'A different version of this smalltalk archive is loaded') asString;						cr;						cr]].	aStream emphasis: nil.	(propertyDictionary at: #pundleModelClass ifAbsent: [nil])		= Store.BundleModel			ifTrue: 				[aStream					nextPutAll: (#TopBundleInformation &lt;&lt; #dialogs &gt;&gt; 'Top Bundle Information:')								asString;					cr;					cr]</body></methods><methods><class-id>Tools.FileTools.SmalltalkArchiveViewer</class-id> <category>private</category><body package="Smalltalk Archive UI">propertiesFrom: aFilename 	| properties propertyItems commentItem |	properties := [Store.CodeReaderForSmalltalkArchive new readInfoFromTarFileNamed: aFilename] 				on: OsError , Store.CodeReaderForSmalltalkArchive fileFormatSignal				do: [:ex | ex return: Dictionary new].	propertyItems := SortedCollection sortBlock: [:a :b | a key &lt;= b key].	properties 		keysAndValuesDo: [:key :value | propertyItems add: key -&gt; value].	propertyItems := propertyItems asOrderedCollection.	commentItem := propertyItems detect: [:some | some key = 'comment']				ifNone: [].	commentItem notNil 		ifTrue: 			[propertyItems remove: commentItem.			propertyItems addFirst: commentItem].	^propertyItems</body></methods><methods><class-id>Tools.FileTools.SmalltalkArchiveViewer class</class-id> <category>accessing</category><body package="Smalltalk Archive UI">isInterestedInFile: aFilename 	^aFilename isSmalltalkArchive</body><body package="Smalltalk Archive UI">tabPosition	^6</body></methods><methods><class-id>Core.FileDates</class-id> <category>accessing</category><body package="NewTar">accessed	^accessed</body><body package="NewTar">accessed: anObject	accessed := anObject</body><body package="NewTar">created	^created</body><body package="NewTar">created: anObject	created := anObject</body><body package="NewTar">modified	^modified</body><body package="NewTar">modified: anObject	modified := anObject</body></methods><methods><class-id>Core.FileDates</class-id> <category>utility</category><body package="NewTar">applyToTarWriteStream: aTarWriteStream		aTarWriteStream mtime: self modified asSecondsForUnix.	aTarWriteStream ctime: self created asSecondsForUnix.	aTarWriteStream atime: self accessed asSecondsForUnix.	"userid ifNotNil: [ aTarWriteStream uid: userid].	groupid ifNotNil: [ aTarWriteStream gid: groupid].	mode ifNotNil: [ aTarWriteStream mode: mode]"</body></methods><methods><class-id>Core.FileDates</class-id> <category>printing</category><body package="NewTar">printOn: aStream		super printOn: aStream.	aStream cr;		nextPutAll: 'modified: ';		print: self modified convertGMTtoLocal.	aStream cr;		nextPutAll: 'created: ';		print: self created convertGMTtoLocal.	aStream cr;		nextPutAll: 'accesed: ';		print: self accessed</body></methods><methods><class-id>Core.FileDates class</class-id> <category>instance creation</category><body package="NewTar">fromFilename: aFilename		| newFileDates |	newFileDates := self new.	aFilename getFileTimeInto: newFileDates.	^newFileDates</body></methods><methods><class-id>Core.FileProperties</class-id> <category>utility</category><body package="NewTar">apply	"Apply my information onto the real file on disk"		self filename setFileTime: self</body><body package="NewTar">localAccessed	^TimeZone default convertGMTSecondsToLocal: self accessed</body><body package="NewTar">localCreated	^TimeZone default convertGMTSecondsToLocal: self created</body><body package="NewTar">localModified	^TimeZone default convertGMTSecondsToLocal: self modified</body></methods><methods><class-id>Core.FileProperties</class-id> <category>printing</category><body package="NewTar">printOn: aStream		super printOn: aStream.	aStream cr;		nextPutAll: 'name: ';		print: self filename</body></methods><methods><class-id>Core.FileProperties</class-id> <category>private</category><body package="NewTar">filename	^filename</body><body package="NewTar">filename: anObject	filename := anObject</body></methods><methods><class-id>Core.FileProperties class</class-id> <category>instance creation</category><body package="NewTar">fromFilename: aFilename		| newFileProperties |	newFileProperties := super fromFilename: aFilename.	newFileProperties filename: aFilename.	^newFileProperties</body><body package="NewTar">fromTarredReadStream: aTarredReadStream	^(self new)		modified: aTarredReadStream properties globalModificationTime;		yourself</body></methods><methods><class-id>Tools.SmalltalkArchiveFileItem</class-id> <category>parcel attributes</category><body package="Smalltalk Archive UI">commentOrErrorText	| comment |	^self isAccessible 		ifFalse: 			[(#CannotReadSmalltalkArchiveFile &lt;&lt; #dialogs &gt;&gt; 'Cannot read the Smalltalk archive file') 				asText emphasizeAllWith: #italic]		ifTrue: 			[comment := self property: #comment or: [nil].			comment notNil 				ifTrue: [comment first]				ifFalse: 					[(#ThisSmalltalkArchiveHasNoComment &lt;&lt; #dialogs 						&gt;&gt; 'This Smalltalk archive has no comment') asText 						emphasizeAllWith: #italic]]</body></methods><methods><class-id>Tools.SmalltalkArchiveFileItem</class-id> <category>testing</category><body package="Smalltalk Archive UI">isLoaded	"Answer true if there is a Smalltalk archive loaded by that name."	^(self property: #pundleModelClass or: [^false])		isSmalltalkArchiveLoaded: properties</body><body package="Smalltalk Archive UI">isSmalltalkArchive	^true</body></methods><methods><class-id>Tools.SmalltalkArchiveFileItem</class-id> <category>private</category><body package="Smalltalk Archive UI">retrieveParcelProperties	properties := 			[Store.CodeReaderForSmalltalkArchive new readInfoFromTarFileNamed: filename] 					on: OsError , CodeReader fileFormatSignal					do: [:ex | ex return: nil]</body></methods><methods><class-id>Tools.SmalltalkArchiveFileItem class</class-id> <category>constants access</category><body package="Smalltalk Archive UI">extensionDeployment	^'.star'</body><body package="Smalltalk Archive UI">extensionDevelopment	^'.store'</body><body package="Smalltalk Archive UI">extensions		^Array		with: self extensionDevelopment		with: self extensionDeployment</body></methods><methods><class-id>Tools.SmalltalkArchiveFileItem class</class-id> <category>initialize-release</category><body package="Smalltalk Archive UI">obsolete	"self obsolete"	Store.StorePublishDialog.Announcements unsubscribe: self.	super obsolete</body></methods><methods><class-id>Tools.SmalltalkArchiveFileItem class</class-id> <category>class initialization</category><body package="Smalltalk Archive UI">initialize	"self initialize"	self extensions do: [:each | TarFile addExtension: each].	Store.StorePublishDialog.Announcements		when: Store.StorePrePublish		send: #updateItemModels:		to: self</body><body package="Smalltalk Archive UI">updateItemModels: aStoreDialogPrePublishAnnouncement	aStoreDialogPrePublishAnnouncement publishDialog class = Store.PublishPundleDialog ifTrue:		[aStoreDialogPrePublishAnnouncement publishDialog updateItemModels].</body></methods><methods><class-id>Core.TarredReadStream</class-id> <category>accessing</category><body package="NewTar">atime	^self properties atime</body><body package="NewTar">contents	"Answer with a copy of the receiver's collection from 1 to readLimit."	position := 0.	^self next: readLimit</body><body package="NewTar">ctime	^self properties ctime</body><body package="NewTar">fileProperties		^FileProperties fromTarredReadStream: self</body><body package="NewTar">flush	"Write any unwritten information. 	This is for compatibility with BufferedExternalStreams."</body><body package="NewTar">gid	^self properties gid</body><body package="NewTar">modTime	^self properties modTime</body><body package="NewTar">mode	^self properties mode</body><body package="NewTar">mtime	^self properties mtime</body><body package="NewTar">name	^self properties name</body><body package="NewTar">next	"Answer the next object in the receiver."	| result |	position &gt;= readLimit ifTrue: [^self pastEnd].	tarFile file position: position + startInTar.	result := tarFile file next.	position := tarFile file position - startInTar.	^result</body><body package="NewTar">nextPut: anObject 	"Provide an error notification that the receiver does not	implement this message."	self shouldNotImplement</body><body package="NewTar">size	^readLimit</body><body package="NewTar">tarFile	^tarFile</body><body package="NewTar">uid	^self properties uid</body></methods><methods><class-id>Core.TarredReadStream</class-id> <category>testing</category><body package="NewTar">exists	^true</body><body package="NewTar">isReadable	"Answer whether the stream implements #next."	^true</body><body package="NewTar">isWritable	"Answer whether the stream implements #nextPut:."	^false</body></methods><methods><class-id>Core.TarredReadStream</class-id> <category>initialize-release</category><body package="NewTar">initFromTarFile: aTarFile	position := 0.	tarFile := aTarFile.	self properties: (TarPosix2001Header line: (tarFile file next: TarFile.TARBlockSize) asString).	startInTar := tarFile file position.	readLimit := self properties size.	tarFile file position: startInTar + ((properties size + TarFile.TARBlockSize - 1) truncateTo: TarFile.TARBlockSize)</body></methods><methods><class-id>Core.TarredReadStream</class-id> <category>printing</category><body package="NewTar">printOn: aStream 	"Append to the argument aStream a sequence of characters that identifies the receiver."	| connectionName |	connectionName := self name.	super printOn: aStream.	connectionName isNil		ifTrue: [^self].	aStream nextPutAll: ' on '.	connectionName printOn: aStream</body></methods><methods><class-id>Core.TarredReadStream</class-id> <category>private</category><body package="NewTar">contentsSpecies	^tarFile file contentsSpecies</body><body package="NewTar">next: anInteger into: aSequenceableCollection startingAt: startIndex 	"Store the next anInteger elements of the receiver into aSequenceableCollection 	starting at startIndex in aSequenceableCollection. Answer aSequenceableCollection."	| result |	position &gt;= readLimit ifTrue: [^self pastEnd].	tarFile file position: position + startInTar.	result := tarFile file next: anInteger into: aSequenceableCollection startingAt: startIndex .	position := tarFile file position - startInTar.	^result</body><body package="NewTar">pastEnd	"The receiver has attempted to read past the end, answer nil."	^self class endOfStreamSignal raiseRequestFrom: self</body></methods><methods><class-id>Core.TarredReadStream</class-id> <category>converting</category><body package="NewTar">asFilename	^TarredFilename named: self asLogicalFileSpecification asString</body><body package="NewTar">asLogicalFileSpecification	^tarFile filename construct: self name</body></methods><methods><class-id>Core.TarredReadStream class</class-id> <category>instance creation</category><body package="NewTar">on: aTarFile 	^self basicNew initFromTarFile: aTarFile</body></methods><methods><class-id>OS.Filename</class-id> <category>obsolete</category><body package="NewTar">copyPreservingDatesTo: destName 	"Copy the file whose name is the receiver to a file named destName."	self privateCopyPreservingDatesFrom: (IOAccessor openFileReadOnly: self)		to: (IOAccessor openFileWriteOnly: destName asFilename)</body></methods><methods><class-id>OS.Filename</class-id> <category>file utilities</category><body package="NewTar">fileSize	"Answer size of file in bytes."	"However, not all files have sizes..."	&lt;primitive: 1606 errorCode: error&gt;	error == nil		ifTrue: [^self errorReporter unsupportedOperationSignal raise].	error name = #'io error'		ifTrue: [[^(TarredFilename named: self asString) fileSize]					on: Error					do: [:ex |].				^error handleErrorFor: self].	error name = #'invalid receiver state'		ifTrue: [^self validateNameForPlatform ifTrue: [self fileSize]].	self error: (#UnexpectedError &lt;&lt; #dialogs &gt;&gt; 'Unexpected error')</body><body package="NewTar">getFileTimeInto: aFileDates		| accessor |	accessor := IOAccessor openFileReadOnly: self.	[^accessor getFileTimeFor: self into: aFileDates] ensure: [accessor close]</body></methods><methods><class-id>OS.Filename</class-id> <category>testing</category><body package="NewTar">isTarFile	^TarFile knownExtensions includes: self extension</body></methods><methods><class-id>OS.Filename</class-id> <category>obsolete</category><body package="NewTar">privateCopyPreservingDatesFrom: sourceAccessor to: destinationAccessor 		| sourceDates |	[| buffer bufferSize amountRead |	sourceDates := sourceAccessor privateGetFileTime.	bufferSize := sourceAccessor bufferSize.	buffer := ByteArray new: bufferSize.	"Copy until we read zero bytes"	[(amountRead := sourceAccessor readInto: buffer) &gt; 0] whileTrue: 			[destinationAccessor writeFrom: buffer				startingAt: 1				forSure: amountRead]]			ensure: 				[sourceAccessor close.				destinationAccessor privateSetFileTime: sourceDates; close]</body></methods><methods><class-id>OS.Filename</class-id> <category>file utilities</category><body package="NewTar">setFileTime: fileDates	"set a fileNames file time"	| accessor |	accessor := (IOAccessor openFileWriteOnlyLeaveUntouched: self).	[ ^ accessor setFileTime: fileDates for: self ] ensure:  [accessor close ].</body><body package="NewTar">tarDirectoryContents	^((TarFile filename: self) contents 		collect: [:each | each name asString]) asArray</body></methods><methods><class-id>OS.UnixSystemSupport</class-id> <category>types</category><body package="NewTar">blkcnt_t	&lt;C: typedef long int blkcnt_t&gt;</body><body package="NewTar">blksize_t	&lt;C: typedef long int blksize_t&gt;</body></methods><methods><class-id>OS.UnixSystemSupport</class-id> <category>procedures</category><body package="NewTar">errno	^self errnoLocation contents</body></methods><methods><class-id>OS.UnixSystemSupport</class-id> <category>types</category><body package="NewTar">FILETIME	"Describes how we want the process to be started."	&lt;C: typedef struct utimbufStruct FILETIME&gt;</body></methods><methods><class-id>OS.UnixSystemSupport</class-id> <category>utilities</category><body package="NewTar">fstat: anIOAccessor		| buf result |	buf := self myStatStruct calloc.	result := self		fstat: (anIOAccessor handle asInteger) gcCopyToHeap		into: buf.	[result = 0		ifTrue: [^buf contents]		ifFalse: [^self error: (self strerror: self errno) copyCStringFromHeap]]		ensure: [buf free]</body></methods><methods><class-id>OS.UnixSystemSupport</class-id> <category>structs</category><body package="NewTar">myStatStruct	&lt;C:  struct stat {		unsigned int				st_dev;		/* device */		unsigned int				st_ino;		/* inode */		unsigned short int		st_mode;	/* protection */		unsigned short int		st_nlink;		/* number of hard links */		unsigned short int		st_uid;		/* user ID of owner */		unsigned short int		st_gid;		/* group ID of owner */		unsigned int				st_rdev;		/* device type (if inode device) */		unsigned int				st_size;		/* total size, in bytes */		blksize_t				st_blksize;	/* blocksize for filesystem I/O */		blkcnt_t					st_blocks;	/* number of blocks allocated */		unsigned long int		st_atime;	/* time of last access */		long int					pad0;		unsigned long int		st_mtime;	/* time of last modification */		long int					pad1;		unsigned long int		st_ctime;	/* time of last status change */		long int					pad2;		long int					unused[2];	/* pushed up the size of struct to 64 bytes */	}&gt;</body></methods><methods><class-id>OS.UnixSystemSupport</class-id> <category>utilities</category><body package="NewTar">setModificationTime: aFilename with: aTimestamp		| dict sec |	dict := Dictionary new.	sec := aTimestamp asSecondsForUnix.	dict		at: #accessed put: sec;		at: #modified put: sec.	self uTime: aFilename with: dict</body></methods><methods><class-id>OS.UnixSystemSupport</class-id> <category>unions</category><body package="NewTar">sigval	&lt;C: union sigval {			int sival_int;			void * sival_ptr;		}&gt;</body></methods><methods><class-id>OS.UnixSystemSupport</class-id> <category>utilities</category><body package="NewTar">stat: aFilename	"(UnixSystemSupport new stat: ('/etc/passwd' asFilename)) inspect"		| buf |	buf := self myStatStruct gcCalloc.	self		stat: aFilename asString gcCopyToHeap		into: buf		withVer: 1.	^buf</body><body package="NewTar">timestampsToFiletimes: aDictionary	"The dictionary must contain Timestamps and the symbols #created, #accessed and #modified."		| ftDict |	ftDict := Dictionary new.	1		to: 3		do:			[:i | 			| y |			y := #(#created #accessed #modified).			ftDict				at: (y at: i)				put: (aDictionary at: (y at: i)) asSecondsForUnix].	^ftDict</body></methods><methods><class-id>OS.UnixSystemSupport</class-id> <category>structs</category><body package="NewTar">utimbufStruct	&lt;C: struct utimbufStruct&gt;</body></methods><methods><class-id>OS.UnixSystemSupport</class-id> <category>utilities</category><body package="NewTar">uTime: aFilename with: aDictionary	"The dictionary must contain Filetimes in seconds and the symbols #accessed and #modified."		| fileStat buf result |	fileStat := self stat: aFilename.	(buf := utimbufStruct malloc)		memberAt: #actime			put: (fileStat memberAt: #st_atime);		memberAt: #modtime			put: ((aDictionary at: #modified) asSecondsForUnix).	result := self		utime: (aFilename asString copyWith: (Character value: 0)) gcCopyToHeap		with: buf.	[result = 0		ifFalse: [^self error: (self strerror: self errno) copyCStringFromHeap]]		ensure: [buf free]</body></methods><methods><class-id>Tools.FileTools.FileBrowser</class-id> <category>file list</category><body package="NewTar">isDirectory: aFileItem		^aFileItem asFilename isDirectory</body></methods><methods><class-id>OS.UnixDiskFileAccessor</class-id> <category>accessing</category><body package="NewTar">fileTimeAccessorClass	^FileTimeAccessUnix</body><body package="NewTar">getFileTimeFor: aFilename into: aFileDates	^self fileTimeAccessorClass new getFileTimeFor: aFilename into: aFileDates</body></methods><methods><class-id>OS.UnixDiskFileAccessor</class-id> <category>As yet unclassified</category><body package="NewTar">handle	^handle</body></methods><methods><class-id>OS.UnixDiskFileAccessor</class-id> <category>accessing</category><body package="NewTar">setFileTime: aDict for: aFilename	^self fileTimeAccessorClass new setFileTime: aDict for: aFilename</body></methods><methods><class-id>OS.PCDiskFileAccessor</class-id> <category>stream creation</category><body package="NewTar">fileTimeAccessorClass		^FileTimeAccessWin32</body></methods><methods><class-id>OS.PCDiskFileAccessor</class-id> <category>accessing</category><body package="NewTar">getFileTimeFor: aFilename into: aFileDates	^self fileTimeAccessorClass new getFileTimeFor: self into: aFileDates</body><body package="NewTar">setFileTime: aDictionary for: aFilename	^self fileTimeAccessorClass new setFileTimeFor: self times: aDictionary.</body></methods><methods><class-id>OS.IOAccessor class</class-id> <category>instance creation</category><body package="NewTar">openFileWriteOnlyLeaveUntouched: aString	"Create a new accessor on the named file for writing only."		^self openFileNamed: aString direction: self writeOnly creation: self mayCreate</body></methods><methods><class-id>OS.IOAccessor</class-id> <category>obsolete</category><body package="NewTar">privateGetFileTime	^self fileTimeAccessorClass new privateGetFileTimeFor: self.</body><body package="NewTar">privateSetFileTime: aDictionary	^self fileTimeAccessorClass new privateSetFileTimeFor: self times: aDictionary.</body></methods><methods><class-id>OS.IOAccessor</class-id> <category>accessing</category><body package="NewTar">setFileTime: fileProperties	^self fileTimeAccessorClass new setFileTimeFor: self times: fileProperties.</body></methods><methods><class-id>Core.Timestamp class</class-id> <category>instance creation</category><body package="NewTar">fromGMTSeconds: seconds	"Answer a Timestamp for the local time."	"Timestamp fromGMTSeconds: (Timestamp nowUTC asSeconds)"	^self fromSeconds: (TimeZone default convertGMTSecondsToLocal: seconds)</body><body package="NewTar">fromUnixSeconds: seconds	"Answer a new Timestamp from the number of seconds since 12:00 am, January 1, 1970."		^UnixZeroTimestamp addSeconds: seconds"(TimeZone default convertGMTSecondsToLocal: seconds)".</body></methods><methods><class-id>Core.Timestamp</class-id> <category>conversion</category><body package="NewTar">asSecondsForUnix	"Returns the local time as GMT in secounds."	"Answer the number of seconds since January 1, 1970."		^self asSeconds - UnixZeroTimestamp asSeconds.</body><body package="NewTar">convertGMTtoLocal		| new |	new := Timestamp		fromSeconds: (TimeZone default convertGMTSecondsToLocal: self asSeconds).	new millisecond: self millisecond.	^new</body><body package="NewTar">convertLocaltoGMT		| new |	new := Timestamp		fromSeconds: (TimeZone default convertLocalSecondsToGMT: self asSeconds).	new millisecond: self millisecond.	^new</body></methods><methods><class-id>OS.FileEncodedStreamConstructor</class-id> <category>private</category><body package="NewTar">alwaysAddEncodingTo: aStream	^encoding == #binary		ifTrue: [aStream binary]		ifFalse: 			[| encoder |			encoder := self findEncoding: encoding.			encoder initializeForFiles.			encoder createEncodedStreamOn: aStream]</body></methods><methods><class-id>OS.FileEncodedStreamConstructor</class-id> <category>streams</category><body package="NewTar">readStream	"Answer a read stream connected to the file represented by 	the receiver."	^	[self 		addEncodingTo: (ExternalReadStream on: (FileConnection 						openFileNamed: dataRepository						mode: #readOnly						creationRule: #noCreate))] 			on: OsInaccessibleError, OsIllegalOperation			do: 				[:ex | self readStreamOnTarfile ifNil: [ex pass]]</body><body package="NewTar">readStreamOnTarfile	"Try to resolve the requested filename to a file within a tar file.	Return an (encoded) read stream on this file.	Raise exception OSErrorHolder nonexistentSignal if the tar file exists but does not contain the requested file."	| potentialTarFile filenameInTar separator tarFile potentialDirectory fileInTarFile |	potentialTarFile := dataRepository asLogicalFileSpecification.	filenameInTar := ''.	separator := String with: Filename separator.					[filenameInTar := potentialTarFile tail , separator , filenameInTar.	potentialDirectory := potentialTarFile directory.	potentialTarFile = potentialDirectory ifTrue: [^nil 	"if sending #directory to root directory name"].	potentialTarFile := potentialDirectory.	potentialTarFile asFilename exists] 			whileFalse.	potentialTarFile isDirectory ifTrue: [^nil 	"so this is not a tar file"].	[tarFile := TarFile filename: potentialTarFile] on: Error		do: [:ex2 | ^nil].	"strip off trailing separator"	filenameInTar := filenameInTar copyFrom: 1 to: filenameInTar size - 1.	fileInTarFile := tarFile 				detect: [:taredFile | taredFile name = filenameInTar]				ifNone:					[| msg |					msg := ('File "&lt;1s&gt;" not found in tar file "&lt;2s&gt;"' expandMacrosWith: filenameInTar with: potentialTarFile asString).					OSErrorHolder nonexistentSignal raiseSignal: msg].	^self alwaysAddEncodingTo: fileInTarFile</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>converting</category><body package="NewTar">copyFromLeftWithSize: newSize 	| newString |	newString := (self size &gt; newSize		ifTrue:	[(newSize &gt; 4)					ifTrue:	[self copyReplaceFrom: (newSize - 3 max: 1)								 to: self size								 with: ' ...']					ifFalse: [self copyFrom: 1 to: newSize]]		ifFalse: [self]).	(newString size &lt;= newSize) 		ifTrue:	[^newString , ((String new: newSize - newString size) atAllPut: Character space)]		ifFalse:	[^newString]	"	'12345123451ende' copyWithSizeLeftOrdered: 20 '12345123451ende     '	'12345123451ende' copyWithSizeLeftOrdered: 12 '12345123 ...'	"</body><body package="NewTar">copyFromRightWithSize: newSize 	| newString |	newString := ( newSize &gt;= self size)		ifTrue: [((String new: newSize) atAllPut: Character space) copyReplaceFrom: (newSize - self size + 1)  to: newSize with: self]		ifFalse: [self copyFrom: (self size - newSize + 1) to: self size].	^newString	"	'12345123451ende' copyWithSizeRightOrdered: 17 '  12345123451ende'	'12345123451ende' copyWithSizeRightOrdered: 6 '51ende'	"</body></methods><methods><class-id>OS.LogicalFilename</class-id> <category>testing</category><body package="NewTar">isTarFile	^TarFile knownExtensions includes: self extension</body><body package="Smalltalk Archive Support">isParcel	^self extension = Parcel fileExtension</body><body package="Smalltalk Archive Support">isParcelOrSmalltalkArchive	^self isParcel or: [self isSmalltalkArchive]</body><body package="Smalltalk Archive Support">isSmalltalkArchive		^SmalltalkArchiveFileItem extensions includes: self extension</body><body package="Smalltalk Archive Support">isSmalltalkArchiveDeployment		^SmalltalkArchiveFileItem extensionDeployment = self extension</body><body package="Smalltalk Archive Support">isSmalltalkArchiveDevelopment		^SmalltalkArchiveFileItem extensionDevelopment = self extension</body><body package="Smalltalk Archive Support">parcelsAndSmalltalkArchivesInDirectory	^(self filenamesMatching: '*') 		select: [:each | each isParcelOrSmalltalkArchive]</body></methods><methods><class-id>Tools.ParcelDirectory</class-id> <category>private</category><body package="Smalltalk Archive Support">selectParcelsAmong: aCollection 	| parcelsAndArchives filename |	parcelsAndArchives := OrderedCollection new.	aCollection do: 			[:each | 			filename := each asFilename.			filename isParcel 				ifTrue: [parcelsAndArchives add: (ParcelFileItem fromFileNamed: each in: path)].			filename isSmalltalkArchive 				ifTrue: [parcelsAndArchives add: (SmalltalkArchiveFileItem fromFileNamed: each in: path)]].	^parcelsAndArchives</body></methods><methods><class-id>Tools.ParcelManager</class-id> <category>testing</category><body package="Smalltalk Archive Support">canUnload	"Currently Smalltalk Archives cannot be unloaded from the Parcel Manager,	please use the browser instead"	^selectedParcels isEmpty not and: 			[selectedParcels				allSatisfy: [:each | each isSmalltalkArchive not and: [each isLoaded]]]</body></methods><methods><class-id>Tools.ParcelManager</class-id> <category>actions</category><body package="Smalltalk Archive Support">loadParcelFromFile	| filename parcel parcelHandle |	filename := Dialog requestFileName: #OpenParcel &lt;&lt; #dialogs &gt;&gt; 'Open parcel'				default: '*.pcl'.	filename isEmpty ifTrue: [^self].	Notice		show: (#LoadingParcelFromFileN1S &lt;&lt; #dialogs				&gt;&gt; 'Loading Parcel from file&lt;n&gt;&lt;1s&gt;' expandMacrosWith: filename asString)		while: 			[filename asFilename isSmalltalkArchive				ifTrue: [Store.BundleModel loadSmalltalkArchiveFrom: filename asFilename]				ifFalse: 					[parcel := Parcel loadParcelFrom: filename.					parcel isNil ifTrue: [^self].					self categoryHolder selection: ParcelLoadedTool.					parcelHandle := ParcelInImageItem new parcel: parcel.					parcelHandle isVisualWorksParcel						ifTrue: [categorySubapplication selectVisualWorksFolder]						ifFalse: 							[parcelHandle isGoodie								ifTrue: [categorySubapplication selectGoodiesFolder]								ifFalse: 									[parcelHandle isPreview										ifTrue: [categorySubapplication selectPreviewFolder]										ifFalse: [categorySubapplication selectOtherFolder]]].					parcelSubapplication selections: (Array with: parcelHandle)]].</body><body package="Smalltalk Archive Support">loadParcels: parcelCollection 	Notice 		show: (#LoadingParcelOrParcels &lt;&lt; #dialogs &gt;&gt; 'Loading &lt;1?Parcels:Parcel&gt;' 				expandMacrosWith: parcelCollection size &gt; 1)		while: 			[| paths |			paths := parcelCollection collect: [:each | each filename].			paths do: 					[:each | 										[each asFilename isSmalltalkArchive 						ifTrue: [Store.BundleModel loadSmalltalkArchiveFrom: each asFilename]						ifFalse: [Parcel loadParcelFrom: each]] 							on: OsError							do: 								[:ex | 								Dialog 									report: (#ErrorLoadingParcel1S &lt;&lt; #dialogs &gt;&gt; 'Error loading parcel &lt;1s&gt;' 											expandMacrosWith: each asString)									withTextSignalledBy: ex]]].	self refreshAll</body></methods><methods><class-id>OS.Filename</class-id> <category>testing</category><body package="Smalltalk Archive Support">isParcel	^self extension = Parcel fileExtension</body><body package="Smalltalk Archive Support">isParcelOrSmalltalkArchive	^self isParcel or: [self isSmalltalkArchive]</body><body package="Smalltalk Archive Support">isSmalltalkArchive		^SmalltalkArchiveFileItem extensions includes: self extension</body><body package="Smalltalk Archive Support">isSmalltalkArchiveDeployment		^SmalltalkArchiveFileItem extensionDeployment = self extension</body><body package="Smalltalk Archive Support">isSmalltalkArchiveDevelopment		^SmalltalkArchiveFileItem extensionDevelopment = self extension</body><body package="Smalltalk Archive Support">parcelsAndSmalltalkArchivesInDirectory	^(self filenamesMatching: '*') 		select: [:each | each isParcelOrSmalltalkArchive]</body></methods><methods><class-id>OS.Filename</class-id> <category>primitives</category><body package="Smalltalk Archive Support">privateDirectoryContents	"Receiver is a directory name.  Return an array of strings	naming files contained in this directory."	&lt;primitive: 1690 errorCode: error&gt;	error == nil 		ifTrue: [^self errorReporter unsupportedOperationSignal raise].	error name = #'io error' 		ifTrue: 			[self isTarFile 				ifTrue: [^self tarDirectoryContents]				ifFalse: [^error handleErrorFor: self]].	error name = #'invalid receiver state' 		ifTrue: 			[^self validateNameForPlatform ifTrue: [self privateDirectoryContents]].	error name = #'allocation failed' 		ifTrue: 			[error handleErrorFor: self.			^self privateDirectoryContents].	self error: #UnexpectedError &lt;&lt; #dialogs &gt;&gt; 'Unexpected error'</body></methods><methods><class-id>Store.PublishSpecificationList</class-id> <category>publishing</category><body package="Smalltalk Archive Support">prepareBinaryIn: aStorePackage		| packageModel |	aStorePackage isBundle ifTrue: [^self].	packageModel := aStorePackage storeModel.	packageModel propertyAt: #packageName put: packageModel name.	packageModel binarySave: true.	aStorePackage binFile: ''</body></methods><methods><class-id>Kernel.Parcel class</class-id> <category>private-loading</category><body package="Smalltalk Archive Support">cachedParcelFileInfoIn: aDirectory for: parcelName do: aBlock 	"Evaluate aBlock with the info and filename of every parcel file in aDirectory.	 If the files are not in the cache, compute and cache them.  As an optimization	 always try and look in parcelName.pcl if it exists."	| parcelFiles likelyFile reader |	parcelFiles := self parcelFileDirectoryCache 				at: aDirectory asResolvedString				ifAbsentPut: [aDirectory parcelsAndSmalltalkArchivesInDirectory].	parcelFiles isEmpty ifTrue: [^self].	parcelName notNil 		ifTrue: 			[likelyFile := parcelFiles detect: 							[:aFilename | 							| tail |							tail := aFilename tail.							(tail copyFrom: 1 to: tail size - aFilename extension size) = parcelName]						ifNone: nil].	likelyFile notNil 		ifTrue: 			[parcelFiles := parcelFiles copyWithout: likelyFile.			parcelFiles addFirst: likelyFile].	parcelFiles do: 			[:aFilename | 			| info |			info := self parcelFileInfoCache at: aFilename asResolvedString						ifAbsent: nil.			(info isNil and: [aFilename exists]) 				ifTrue: 					[					[info := self parcelFileInfoCache at: aFilename asResolvedString								ifAbsentPut: [aFilename isSmalltalkArchive												ifTrue: [reader := Store.CodeReaderForSmalltalkArchive new]												ifFalse: [reader := Store.CodeReader new].											reader readInfoFromFileNamed: aFilename]] 							on: CodeReader fileFormatSignal							do: [:ex | ex return]].			info notNil ifTrue: [aBlock value: info value: aFilename]]</body><body package="Smalltalk Archive Support">ensureLoadedParcel: parcelName withVersion: versionString for: codeReaderOrNil 	"Check if a Parcel named parcelName is loaded with an appropriate version.	 If its not then attempt to load it.  If codeReaderOrNil is non-nil then substitute	 codeReaderOrNil streamDirectory for `current directory' in the SearchPath	 directory list."	| aDirectoryOrNil parcelOrPundle dirs found |	aDirectoryOrNil := codeReaderOrNil == nil 				ifFalse: [codeReaderOrNil streamDirectory].	"If the parcel is already loaded check its version and bail if its not acceptable."	nil ~~ (parcelOrPundle := self parcelOrPundleNamed: parcelName) 		ifTrue: 			[(codeReaderOrNil == nil or: 					[codeReaderOrNil 						checkPrerequisiteNamed: parcelName						withVersion: parcelOrPundle traceVersion						requiredVersion: versionString]) 				ifFalse: 					[CodeReader incompatibleVersionIdSignal 						raiseRequestWith: (Array with: parcelName with: versionString)].			^parcelOrPundle].	dirs := OrderedCollection withAll: self searchPathModel value.	dirs := dirs collect: [:each | each asLogicalFileSpecification asFilename].	"If aDirectoryOrNil notNil include it after the list."	aDirectoryOrNil notNil ifTrue: [dirs addLast: aDirectoryOrNil asLogicalFileSpecification asFilename].	Parcel parcelFileDirectoryCache removeKey: dirs last asResolvedString ifAbsent: [nil].	"As a last resort include the current directory."	dirs addLast: Filename currentDirectory asLogicalFileSpecification asFilename.	Parcel parcelFileDirectoryCache removeKey: dirs last asResolvedString ifAbsent: [nil].	found := false.	1 to: dirs size		do: 			[:i | 			| dirName dir |			dirName := dirs at: i.			"map the current directory onto the supplied current directory if dirName is dot		 and we're not searching the current directory."			(dir := (dirName asString = Filename defaultClass currentDirectoryString 						and: [i &lt; dirs size]) ifTrue: [aDirectoryOrNil] ifFalse: [dirName]) 				notNil 					ifTrue: 						[self 							cachedParcelFileInfoIn: dir asLogicalFileSpecification							for: parcelName							do: 								[:info :filename | 								found := found or: [parcelName = (info at: #parcel)].								(parcelName = (info at: #parcel) and: 										[codeReaderOrNil == nil or: 												[codeReaderOrNil 													checkPrerequisiteNamed: parcelName													withVersion: (info at: #version ifAbsent: [''])													requiredVersion: versionString]]) 									ifTrue: 										[Transcript											cr;											show: (#autoloadParcelFrom &lt;&lt; #dialogs &gt;&gt; 'Autoloading &lt;1s&gt; from &lt;2s&gt;' 														expandMacrosWith: parcelName														with: filename asString).										filename isSmalltalkArchive											ifTrue: [^Store.BundleModel loadSmalltalkArchiveFrom: filename]											ifFalse: [^self loadParcelCachedFrom: filename]]]]].	found 		ifTrue: 			[CodeReader incompatibleVersionIdSignal 				raiseRequestWith: (Array with: parcelName with: versionString)].	^Parcel missingParcelSignal raiseRequestWith: parcelName</body></methods><methods><class-id>Kernel.Parcel class</class-id> <category>testing</category><body package="Smalltalk Archive Support">isParcelLoaded: propertyCollection 	| parcelName parcel version |	parcelName := propertyCollection detect: [:some | some key = #parcel]				ifNone: ['' asValue].	version := propertyCollection detect: [:some | some key = #version]				ifNone: ['no version' asValue].	(parcel := Parcel parcelNamed: parcelName value) isNil 		ifTrue: [^false]		ifFalse: [parcel version = version value ifTrue: [^true] ifFalse: [^false]]</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>accessing</category><body package="Smalltalk Archive Support">rawData	^nil</body></methods><methods><class-id>Kernel.CodeComponent</class-id> <category>queries</category><body package="Smalltalk Archive Support">definedClassesDo: aBlock	^self</body><body package="Smalltalk Archive Support">definedObjectsDo: aBlock	^self</body></methods><methods><class-id>Kernel.CodeComponent</class-id> <category>tar support</category><body package="Smalltalk Archive Support">loadPackageFrom: archiveRecord 	"Load and answer a new code component from the fast-loading binary file.	 Answer the receiver."	| aCodeReader |	aCodeReader := CodeReader new.	self class handleCodeReaderSignalsDo: [aCodeReader readFrom: archiveRecord]		for: archiveRecord.	^self 		loadPundleFrom: archiveRecord		oldPundle: (Store.Registry packageNamed: aCodeReader parcelName)		from: aCodeReader</body><body package="Smalltalk Archive Support">loadPundleFrom: archiveRecord	self subclassResponsibility</body><body package="Smalltalk Archive Support">loadPundleFrom: archiveRecord oldPundle: oldPundle from: aCodeReader 	"Load and answer a new code component from the fast-loading binary file.	 Answer the receiver."	"First get the CodeReader to read-in all code objects into shadow namespaces	 internal to the CodeReader, leaving the system unmodified."	[oldPundle isNil ifFalse: 		[^oldPundle 			updateSmalltalkArchiveCodeReadBy: aCodeReader			from: archiveRecord			within: nil].	self doPreInstallActionsFrom: aCodeReader.	"Now install the loaded code into the system after we know the entirety loaded correctly."	self class 		handleCodeReaderSignalsDo: [aCodeReader installInSystem]		for: archiveRecord.	"We must copy the properties after #installInSystem, otherwise	 action blocks do not get compiled correctly if they refer to an	 incoming class or binding."	self startLoad.	self getPropertiesFrom: aCodeReader for: archiveRecord.	self recordPackageContentsFrom: aCodeReader.	self runPostLoadInitializationsUsing: aCodeReader.	self purgeUndeclaredIfRequired: aCodeReader.	self printPackageUndeclaredToTranscript.	self removeTransientProperties.	self endLoad.	self markNotModified.	self doComponentLoadedActions]		ensure: 			[properties				removeKey: #parcelHideSource ifAbsent: [nil];				removeKey: #padded ifAbsent: [nil];				removeKey: #dbInfo ifAbsent: [nil];				removeKey: #smalltalkArchive ifAbsent: [nil];				removeKey: #bundleContents ifAbsent: [nil];				removeKey: #bundleName ifAbsent: [nil];				removeKey: #bundleStructure ifAbsent: [nil]]</body></methods><methods><class-id>Kernel.CodeComponent</class-id> <category>load/unload</category><body package="Smalltalk Archive Support">smalltalkArchiveOutToDb: archiveRecord sourceFilename: sourceFilename	"Convert the parcel to binary and install in dbParcel."	| cWriter |	cWriter := CodeWriter new.	cWriter codeComponent: self.	Cursor wait showWhile: [ self prepareCodeWriter: cWriter].	[ cWriter writeForDb: archiveRecord.	(properties at: #parcelHideSource ifAbsent: [false])		ifFalse: [cWriter republish: sourceFilename dbParcel: archiveRecord]]		on: CodeWriter invalidTraceSignal		do: [ :ex | Parcel invalidNamedObjectSignal raiseWith: ex parameter]</body></methods><methods><class-id>Kernel.CodeComponent</class-id> <category>queries</category><body package="Smalltalk Archive Support">unloadSource	^self</body></methods><methods><class-id>Kernel.CodeComponent</class-id> <category>private-load/unload</category><body package="Smalltalk Archive Support">updateSmalltalkArchiveCodeReadBy: aCodeReader from: aSource within: aBundleOrNil	"Using aCodeReader which has already read in code from aSource update the system with the new code.	 Update the receiver to reflect the new code. Answer the receiver."	self assertSelfIsSameComponentAs: aCodeReader parcelName		ifFail: [:errorValue| ^errorValue].	self runPreUnload: true.	self doPreInstallActionsFrom: aCodeReader.	"Now update the system with what ever has changed in the	 loaded code after we know the entirety loaded correctly."	self class		handleCodeReaderSignalsDo:			[aCodeReader updateCodeInComponent: self from: aSource within: aBundleOrNil]		for: aSource.	self getPropertiesFrom: aCodeReader for: aSource.	self addSpecialItemsFrom: aCodeReader.	self runPostLoadInitializationsUsing: aCodeReader.	self printPackageUndeclaredToTranscript.	self removeTransientProperties.	self markNotModified.	self doComponentUpdatingActions: aCodeReader.	^self</body></methods><methods><class-id>Store.FileModel</class-id> <category>tar support</category><body package="Smalltalk Archive Support">saveToTarfile: aTarfile parcelOptions: options		(aTarfile contains: [:each | each name = self name])		ifTrue: [^self].	aTarfile		addCollection: (self portableFilename readStream contents changeClassTo: BinaryStorageBytes)		name: self name</body></methods><methods><class-id>Kernel.SourceFileManager</class-id> <category>parcel file accessing</category><body package="Smalltalk Archive Support">loadSourceFile: aFilename padded: padded dbParcel: archiveRecord 	"Install aFilename as a new ParcelSourceFile and answer its (new)	 file index.  Attempt to choose an appropriate fileIndex given the	 file's size."	| name size range index |	name := aFilename asLogicalFileSpecification.	size := archiveRecord blobData size.	padded ifTrue: [size := size + Padding - 1 bitShift: PaddingShift negated].	size &gt; 131072 		ifTrue: 			[size &gt; 1048576 ifTrue: [range := 1 to: 16] ifFalse: [range := 17 to: 128]]		ifFalse: 			[size &gt; 16384 				ifTrue: [range := 129 to: 1024]				ifFalse: [range := 1025 to: 8192]].	index := range detect: [:i | (names at: i) == nil] ifNone: nil.	nil == index 		ifTrue: 			[index := (range first to: 1 by: -1) detect: [:i | (names at: i) == nil]						ifNone: nil.			index == nil 				ifTrue: 					[index := (range last to: 8192) detect: [:i | (names at: i) == nil]								ifNone: [^self error: #errNoIndices &lt;&lt; #dialogs &gt;&gt; 'no more file indices']]].	names at: index put: name.	^index</body></methods><methods><class-id>Store.BundleModel class</class-id> <category>tar support</category><body package="Smalltalk Archive Support">getPundle: pundleName	^Store.Registry bundleNamed: pundleName</body><body package="Smalltalk Archive Support">readFromTarfile: tarFile at: i 	Transcript cr.	Transcript show: 'Loading Smalltalk Archive (Sub-Bundle): ' , (tarFile at: i) name.	^super readFromTarfile: tarFile at: i</body></methods><methods><class-id>Store.BundleModel</class-id> <category>properties</category><body package="Smalltalk Archive Support">bundleContents	"returns an ordered collection of associations of subcomponent names to symbols"	| bundleContents |	bundleContents := OrderedCollection new.	self contents do: 			[:each |			each isPackage				ifTrue: [bundleContents add: each name -&gt; #package]				ifFalse: [bundleContents add: each name -&gt; #bundle]].	self fileDescriptions		do: [:each | bundleContents add: each name -&gt; #file].	^bundleContents</body></methods><methods><class-id>Store.BundleModel</class-id> <category>queries</category><body package="Smalltalk Archive Support">definedBindings	"Answer a dictionary of bindings (NameSpace/Class to datakey) contained in the receiver."	"Note- duplicates Parcel format."	| bindings |	self whenPublishingAsSmalltalkArchive ifTrue: [^IdentityDictionary new].	bindings := IdentityDictionary new.	self leafItems do: 			[:pkg |			pkg definedBindings				keysAndValuesDo: [:owner :keys | (bindings at: owner ifAbsentPut: [Set new]) addAll: keys]].	^bindings</body><body package="Smalltalk Archive Support">definedClasses	"Answer a collection of all Classes whose definition is contained in the receiver."	| list |	self whenPublishingAsSmalltalkArchive ifTrue: [^OrderedCollection new].	list := OrderedCollection new.	self leafItems do: [:pkg | list addAll: pkg definedClasses].	^list</body><body package="Smalltalk Archive Support">definedClassesExcludedSelectors	"Answer an IdentityDictionary of Class -&gt; &lt;Set of selectors&gt;"	"Parcel compatibility."	| coll |	self whenPublishingAsSmalltalkArchive ifTrue: [^IdentityDictionary new].	coll := IdentityDictionary new.	self leafItems do:		[ :pkg | 		pkg definedClassesExcludedSelectors keysAndValuesDo:			[ :cls :selectors | | cname |			cname := cls instanceBehavior absoluteName.			selectors do:				[ :selector |					( self includesSelector: selector className: cname meta: cls isMeta )					ifFalse: [ ( coll at: cls ifAbsentPut: [ Set new ] ) add: selector ].				].			].		].	^coll</body></methods><methods><class-id>Store.BundleModel</class-id> <category>private</category><body package="Smalltalk Archive Support">definedClassesIncludingUninstalled	"Answer an OrderedCollection of classes"	^self whenPublishingAsSmalltalkArchive		ifTrue: [OrderedCollection new]		ifFalse: [super definedClassesIncludingUninstalled]</body></methods><methods><class-id>Store.BundleModel</class-id> <category>queries</category><body package="Smalltalk Archive Support">definedNameSpaces	"Answer a collection of all NameSpaces whose definition is contained in the receiver."	| list |	self whenPublishingAsSmalltalkArchive ifTrue: [^OrderedCollection new].	list := OrderedCollection new.	self leafItems do:		[ :pkg | list addAll: pkg  definedNameSpaces ].	^list</body></methods><methods><class-id>Store.BundleModel</class-id> <category>private-load/unload</category><body package="Smalltalk Archive Support">doComponentLoadedActions	super doComponentLoadedActions.	self installContents</body><body package="Smalltalk Archive Support">doComponentUpdatingActions: codeReader	super doComponentUpdatingActions: codeReader.	self installContents</body></methods><methods><class-id>Store.BundleModel</class-id> <category>queries</category><body package="Smalltalk Archive Support">extensionMethods 	"Answer an IdentitySet of CompiledMethods"	"Parcel compatibility."	| list classes |	self whenPublishingAsSmalltalkArchive ifTrue: [^OrderedCollection new].	list := OrderedCollection new.	self leafItems do:		[ :pkg | list addAll: pkg  extensionMethods ].	classes := self definedClasses.	^list reject: [ :cm | classes includes: cm mclass instanceBehavior ].</body></methods><methods><class-id>Store.BundleModel</class-id> <category>private</category><body package="Smalltalk Archive Support">extensionMethodsIncludingUninstalled	"Answer an OrderedCollection of CompiledMethods"	^self whenPublishingAsSmalltalkArchive		ifTrue: [OrderedCollection new]		ifFalse: [super extensionMethodsIncludingUninstalled]</body></methods><methods><class-id>Store.BundleModel</class-id> <category>tar support</category><body package="Smalltalk Archive Support">filenameInTar	(properties at: #shadowPundle ifAbsent: [false]) 		ifTrue: [^self name , '.sb']		ifFalse: [^self name , '.b']</body><body package="Smalltalk Archive Support">installContents	(properties at: #shadowPundle ifAbsent: [false]) 		ifFalse: 			[(properties at: #bundleContents ifAbsent: [#()]) do: 					[:specifier | 					self addItem: (Registry perform: (specifier value , 'Named:') asSymbol								with: specifier key)]].	properties removeKey: #bundleContents ifAbsent: []</body><body package="Smalltalk Archive Support">loadPundleFrom: archiveRecord 	"Load and answer a new code component from the fast-loading binary file.	 Answer the receiver."	| aCodeReader oldBundle isLoaded |	aCodeReader := CodeReaderForSmalltalkArchive new.	oldBundle := Store.Registry 				bundleNamed: (archiveRecord name copyReplaceAll: '.b.pcl' with: '').	self class handleCodeReaderSignalsDo: 			[isLoaded := aCodeReader readFrom: archiveRecord oldPundle: oldBundle]		for: archiveRecord.	isLoaded 		ifTrue: [^oldBundle]		ifFalse: 			[^self 				loadPundleFrom: archiveRecord				oldPundle: oldBundle				from: aCodeReader]</body></methods><methods><class-id>Store.BundleModel</class-id> <category>parcel support</category><body package="Smalltalk Archive Support">saveAsParcel: aFilename saveStructure: saveStructureBoolean saveLinks: saveLinksBoolean parcelOptions: aDictionary	"Save the receiver as a parcel -without creating the parcel in the image.	fullPathName is a directory/parcelName with no extension.	If saveStructure is true, fill in the bundleStructure property with bundle/package contents.	If saveLinks is true and saveStructure is true, then save the db links in the properties."	| parcelDirectory shouldSaveLinks parcelName |	shouldSaveLinks := saveLinksBoolean.	(aDictionary at: #smalltalkArchive ifAbsent: [false]) not		ifTrue: 			[saveLinksBoolean &amp; self hasBeenModified				ifTrue: 					[(Dialog						confirm: (#UnpublishedModificationsMeanNoDBLinks &lt;&lt; #packages								&gt;&gt; '&lt;t&gt;&lt;1s&gt; has unpublished modifications.&lt;n&gt;This means that database links will not be included.&lt;ntttt&gt;Continue?' expandMacrosWith: name))							ifFalse: [^self].					shouldSaveLinks := false]].	parcelName := aFilename tail.	parcelDirectory := aFilename directory.	parcelDirectory exists		ifFalse: 			[(Dialog confirm: (#CreateDirectory1s &lt;&lt; #packages &gt;&gt; 'Create directory &lt;1s&gt;?' expandMacrosWith: parcelDirectory asString))				ifFalse: [^self].			parcelDirectory makeDirectory].	properties at: #bundleName put: self name.	(aDictionary at: #smalltalkArchive ifAbsent: [false])		ifTrue: [properties at: #parcelName put: self name]		ifFalse: [properties at: #parcelName put: parcelName].	properties at: #bundleStructure put: (PundleForParcel from: self saveLinks: shouldSaveLinks).		[(aDictionary at: #smalltalkArchive ifAbsent: [false])		ifTrue: [self saveAsSmalltalkArchiveToDirectory: parcelDirectory name: parcelName parcelOptions: aDictionary]		ifFalse: 			[self				parcelOutTo: (parcelDirectory construct: parcelName , '.pcl') asString				sourceFileName: (parcelDirectory construct: parcelName , '.pst') asString				parcelOptions: aDictionary]]			ensure: 				[properties					removeKey: #bundleStructure ifAbsent: [nil];					removeKey: #bundleName ifAbsent: [nil]]</body><body package="Smalltalk Archive Support">saveAsParcelFromSpecs: publishSpec	"Save the receiver as a parcel -without creating the parcel in the image.	specs fullPathName is a directory/parcelName with no extension.	If specs bundleStructure is true, fill in the bundleStructure property with bundle/package contents.	If specs databaseLinks is true, save the db links for every component."	| dir link pname |	link := publishSpec databaseLinks.	publishSpec smalltalkArchive		ifFalse: 			[link &amp; self hasBeenModified				ifTrue: 					[(BundleHasUnpublisedChangesConfirmation raiseRequestErrorString: name) ifFalse: [^self].					link := false]].	pname := publishSpec basePath asFilename tail.	dir := publishSpec basePath asFilename directory.	dir exists		ifFalse: 			[(CreateParcelDirectoryConfirmation raiseRequestErrorString: dir asString) ifFalse: [^self].			dir makeDirectory].	properties		at: #bundleName put: self name;		at: #parcelName put: pname.	properties at: #bundleStructure put: (PundleForParcel from: self saveLinks: link).	[publishSpec smalltalkArchive		ifTrue: 			[self saveAsSmalltalkArchiveToDirectory: dir name: pname parcelOptions: publishSpec]		ifFalse: 			[self				parcelOutTo: (dir construct: pname , '.pcl') asString				sourceFileName: (dir construct: pname , '.pst') asString				parcelOptions: publishSpec]]			ensure: 				[properties					removeKey: #bundleStructure ifAbsent: [];					removeKey: #bundleName ifAbsent: [];					removeKey: #bundleContents ifAbsent: []]</body></methods><methods><class-id>Store.BundleModel</class-id> <category>tar support</category><body package="Smalltalk Archive Support">saveToTarfile: aTarfile parcelOptions: options		super saveToTarfile: aTarfile parcelOptions: options.	self containedItems , self fileDescriptions		do: [:each | each saveToTarfile: aTarfile parcelOptions: options]</body></methods><methods><class-id>Store.BundleModel</class-id> <category>private-load/unload</category><body package="Smalltalk Archive Support">updateSmalltalkArchiveCodeReadBy: aCodeReader from: aSource within: aBundleOrNil 	"Using aCodeReader which has already read in code from aSource update the system with the new code.	 Update the receiver to reflect the new code. Answer the receiver."	self assertSelfIsSameComponentAs: aCodeReader parcelName		ifFail: [:errorValue | ^errorValue].	self runPreUnload: true.	self getPropertiesFrom: aCodeReader for: aSource.	self addSpecialItemsFrom: aCodeReader.	self runPostLoadInitializationsUsing: aCodeReader.	self printPackageUndeclaredToTranscript.	self removeTransientProperties.	self doComponentUpdatingActions: aCodeReader.	^self</body></methods><methods><class-id>Store.BundleModel</class-id> <category>queries</category><body package="Smalltalk Archive Support">whenPublishingAsSmalltalkArchive	^properties at: #smalltalkArchive ifAbsent: [false]</body></methods><methods><class-id>Kernel.CodeWriter</class-id> <category>api</category><body package="Smalltalk Archive Support">republish: sourceFileName dbParcel: archiveRecord	"Reload the newly-written sourceFileName, set all old sourcePointers to point to	 their new locations in sourceFilename, and answer the new fileIndex."	| sourceFile sfm newSourceIndex |	sourceFile := sourceFileName directory construct: sourceFileName tail.	sfm := SourceFileManager default.	newSourceIndex := sfm loadSourceFile: sourceFile				padded: (properties at: #padded ifAbsent: false) dbParcel: archiveRecord.	self sourcePositionsDo: 			[:thing :get :put :position | 			| key |			thing isOverride 				ifFalse: 					[key := sfm keyForFile: newSourceIndex position: position.					thing perform: put with: key]].	^newSourceIndex</body><body package="Smalltalk Archive Support">writeForDb: archiveRecord 	"Store the parcel to a database record.  Answer true if successful."	| success |	analysisTracer trace: properties.	self traceNamedObjects.	newSourceKeys := IdentityDictionary new: analysisTracer compiledMethodCount * 3 // 2.	self createInternalSourceStreams.	hideOnLoad := (properties at: #parcelHideSource ifAbsent: [false]).	properties removeKey: #parcelHideSource ifAbsent: [].	success := true.	[ self allocate.	self layout.	self storePackage.	stream close.	sourceStream close.	archiveRecord blobData: stream contents.	archiveRecord sourceData: sourceStream targetFile stream contents 	] ifCurtailed: [ success := false ].	^success</body></methods><methods><class-id>Store.PackageModel class</class-id> <category>tar support</category><body package="Smalltalk Archive Support">getPundle: pundleName	^Store.Registry packageNamed: pundleName</body><body package="Smalltalk Archive Support">readFromTarfile: tarFile at: i 	Transcript cr.	Transcript show: 'Loading Smalltalk Archive (Sub-Package): ' , (tarFile at: i) name.	^super readFromTarfile: tarFile at: i.</body></methods><methods><class-id>Store.PackageModel</class-id> <category>tar support</category><body package="Smalltalk Archive Support">filenameInTar	(properties at: #shadowPundle ifAbsent: [false]) 		ifTrue: [^self name , '.sp']		ifFalse: [^self name , '.p']</body><body package="Smalltalk Archive Support">loadPundleFrom: archiveRecord 	"Load and answer a new code component from the fast-loading binary file.	 Answer the receiver."	| aCodeReader oldPackage isLoaded |	aCodeReader := CodeReaderForSmalltalkArchive new.	oldPackage := Store.Registry 				packageNamed: (archiveRecord name copyReplaceAll: '.p.pcl' with: '').	self class handleCodeReaderSignalsDo: 			[isLoaded := aCodeReader readFrom: archiveRecord oldPundle: oldPackage]		for: archiveRecord.	isLoaded 		ifTrue: [^oldPackage]		ifFalse: 			[^self 				loadPundleFrom: archiveRecord				oldPundle: oldPackage				from: aCodeReader]</body><body package="Smalltalk Archive Support">runClassExtensionPostLoadMethods	"Run the #postLoad: method on any classes extended with a class-side initialize method."	| classes |	(properties at: #smalltalkArchive ifAbsent: [false]) 		ifTrue: 			[classes := Set new.			self extensionsDo: 					[:c :s | 					(c isMeta and: [s == #initialize]) ifTrue: [classes add: c soleInstance]].			(SystemUtils sortForLoading: classes) do: [:c | c initialize]]</body></methods><methods><class-id>Store.PackageModel</class-id> <category>parcel support</category><body package="Smalltalk Archive Support">saveAsParcel: aFilename saveStructure: unusedBoolean saveLinks: alsoUnusedBoolean parcelOptions: aDictionary	"Save the receiver as a parcel -without creating the parcel in the image.	fullPathName is a directory/parcelName with no extension.	saveStructure and save links is meaningless for packages with this method"	| parcelDirectory parcelName |	parcelName := aFilename tail.	parcelDirectory := aFilename directory.	parcelDirectory exists		ifFalse: 			[(Dialog confirm: (#CreateDirectory1s &lt;&lt; #packages &gt;&gt; 'Create directory &lt;1s&gt;?'						expandMacrosWith: parcelDirectory asString))				ifFalse: [^self].			parcelDirectory makeDirectory].	properties at: #packageName put: name.	(aDictionary at: #smalltalkArchive ifAbsent: [false])		ifTrue: 			[properties at: #parcel put: (Array with: name).			self				saveAsSmalltalkArchiveToDirectory: parcelDirectory				name: aFilename asString				parcelOptions: aDictionary]		ifFalse: 			[properties at: #parcel put: (Array with: parcelName).			self				parcelOutTo: (parcelDirectory construct: parcelName , '.pcl') asString				sourceFileName: (parcelDirectory construct: parcelName , '.pst') asString				parcelOptions: aDictionary]</body></methods><methods><class-id>Store.Glorp.StorePundle</class-id> <category>accessing</category><body package="Smalltalk Archive Support">parcelDirectory	^self propertyAt: #parcelDirectory ifAbsent: [nil]</body><body package="Smalltalk Archive Support">parcelDirectory: aString	self properties at: #parcelDirectory put: aString</body></methods><methods><class-id>Store.PundleModel class</class-id> <category>tar support</category><body package="Smalltalk Archive Support">getPundle: pundleName	self subclassResponsibility</body></methods><methods><class-id>Store.PundleModel class</class-id> <category>testing</category><body package="Smalltalk Archive Support">isSmalltalkArchiveLoaded: propertyDictionary	| pundleName pundle timestamp |	pundleName := propertyDictionary at: #parcel ifAbsent: [''].	(pundle := self getPundle: pundleName) isNil		ifTrue: [^false]		ifFalse: 			[timestamp := propertyDictionary at: #timestamp ifAbsent: [Time now].			pundle timestamp printString = timestamp printString ifTrue: [^true]].	^false</body></methods><methods><class-id>Store.PundleModel class</class-id> <category>tar support</category><body package="Smalltalk Archive Support">loadFromTar: archiveRecord 	| newPundle isShadowPundle loadedPundle |	('*.p.*' match: archiveRecord name) 		ifTrue: 			[newPundle := PackageModel new.			isShadowPundle := false].	('*.b.*' match: archiveRecord name) 		ifTrue: 			[newPundle := BundleModel new.			isShadowPundle := false].	('*.sp.*' match: archiveRecord name) 		ifTrue: 			[self error: 'shadowed packages in smalltalk archives are not supported at the moment'].	('*.sb.*' match: archiveRecord name) 		ifTrue: 			[newPundle := BundleModel new.			isShadowPundle := true].	loadedPundle := newPundle loadPundleFrom: archiveRecord.	(isShadowPundle or: [loadedPundle ~= newPundle]) 		ifFalse: [Store.Registry privateRegisterPundle: loadedPundle].	^loadedPundle</body><body package="Smalltalk Archive Support">loadSmalltalkArchiveFrom: aName 	| tarFile loadedParcel |	tarFile := TarFile filename: aName.	loadedParcel := self readFromTarfile: tarFile.	tarFile close.	Refactory.Browser.BrowserNavigator allInstancesDo: [:each | each updateNavigator].	^loadedParcel</body><body package="Smalltalk Archive Support">readFromTarfile: tarFile 	^self readFromTarfile: tarFile at: 1.</body><body package="Smalltalk Archive Support">readFromTarfile: tarFile at: index 	| parcel tarContents archiveRecord |	tarContents := tarFile contents.	archiveRecord := ArchiveRecord newNamed: (tarContents at: index) name.	archiveRecord blobData: (tarContents at: index).	(tarContents size &gt; index 		and: [(tarContents at: index + 1) name asFilename extension = '.pst']) 			ifTrue: [archiveRecord sourceData: (tarContents at: index + 1)].	parcel := self loadFromTar: archiveRecord.	^parcel</body></methods><methods><class-id>Store.PundleModel</class-id> <category>private-load/unload</category><body package="Smalltalk Archive Support">doComponentLoadedActions	self restoreLinksFrom: self properties</body><body package="Smalltalk Archive Support">doComponentUpdatingActions: codeReader	self restoreLinksFrom: self properties</body></methods><methods><class-id>Store.PundleModel</class-id> <category>tar support</category><body package="Smalltalk Archive Support">filenameInTar	^self subclassResponsibility</body><body package="Smalltalk Archive Support">pclFilenameInTar	^self filenameInTar , '.pcl'</body><body package="Smalltalk Archive Support">pstFilenameInTar	^self filenameInTar , '.pst'</body></methods><methods><class-id>Store.PundleModel</class-id> <category>parcel support</category><body package="Smalltalk Archive Support">restoreLinksFrom: propertyDictionary	"Called when restoring database links after parcel load."	| identifier dbInfoDict |	dbInfoDict := propertyDictionary at: #dbInfo ifAbsent: [nil].	dbInfoDict isNil		ifFalse: 			[dbInfoDict do: [:each | each pundle: self].			dbInfo := dbInfoDict]		ifTrue: 			[#{Store.DbRegistry} isDefined				ifTrue: 					[identifier := propertyDictionary at: #dbIdentifier ifAbsent: [propertyDictionary at: #databaseId ifAbsent: [nil]].					identifier ifNotNil: 						[(self databaseInformationForOrCreate: identifier)							setDbTrace: (propertyDictionary at: #dbTrace ifAbsent: [nil]);							versionString: (propertyDictionary at: #printStringCache ifAbsent: [nil]);							dbUsername: (propertyDictionary at: #dbUsername ifAbsent: [nil]);							dbVersion: (propertyDictionary at: #dbVersion ifAbsent: [nil]);							emptyChangeSet.						dbInfo removeKey: self noDbSymbol ifAbsent: [nil].						self databaseInformationForOrCreate: self noDbSymbol]]].	self removeLinks: propertyDictionary.	propertyDictionary removeKey: #dbInfo ifAbsent: [nil]</body><body package="Smalltalk Archive Support">saveAsSmalltalkArchiveToDirectory: dir name: pname parcelOptions: aDictionary 	| extension |	extension := (aDictionary at: #parcelSaveSource ifAbsent: [false]) 				ifTrue: [SmalltalkArchiveFileItem extensionDevelopment]				ifFalse: [SmalltalkArchiveFileItem extensionDeployment].	self smalltalkArchiveOutTo: (dir construct: pname , extension) asString		parcelOptions: aDictionary</body></methods><methods><class-id>Store.PundleModel</class-id> <category>tar support</category><body package="Smalltalk Archive Support">saveToTarfile: aTarfile parcelOptions: options	| dbInfoForSave archiveRecord modified |	(aTarfile contains: [:each | each name = self pclFilenameInTar])		ifTrue: [^self].	modified := self hasBeenModified.		[self propertyAt: #hasBeenModified put: modified.	self propertyAt: #parcelHideSource		put: ((options at: #parcelHideSource ifAbsent: [false])				or: [(options at: #parcelSaveSource ifAbsent: [true]) not]).	self propertyAt: #padded put: (options at: #parcelPadded ifAbsent: [nil]).	self propertyAt: #smalltalkArchive		put: (options at: #smalltalkArchive ifAbsent: [nil]).	(options at: #databaseLinks ifAbsent: [false])		ifTrue: 			[dbInfoForSave := IdentityDictionary new.			dbInfo keysAndValuesDo: 					[:key :value |					| dbInfoEntry |					dbInfoEntry := value copy.					dbInfoEntry pundle: nil.					dbInfoForSave at: key put: dbInfoEntry].			self propertyAt: #dbInfo put: dbInfoForSave].	((options at: #smalltalkArchive ifAbsent: [false]) and: [self isBundle])		ifTrue: [self propertyAt: #bundleContents put: self bundleContents].	archiveRecord := ArchiveRecord from: self.	self smalltalkArchiveOutToDb: archiveRecord		sourceFilename: ((options at: #parcelDirectory)				, SmalltalkArchiveFileItem extensionDevelopment					, (String with: Filename separator) , self pstFilenameInTar)				asFilename.	aTarfile addCollection: archiveRecord blobData name: self pclFilenameInTar.	(options at: #parcelSaveSource ifAbsent: true)		ifTrue: 			[aTarfile addCollection: archiveRecord sourceData name: self pstFilenameInTar]]			ensure: 				[properties					removeKey: #parcelHideSource ifAbsent: [];					removeKey: #padded ifAbsent: [];					removeKey: #dbInfo ifAbsent: [];					removeKey: #smalltalkArchive ifAbsent: [];					removeKey: #bundleContents ifAbsent: [];					removeKey: #hasBeenModified ifAbsent: [].				modified ifFalse: [self markNotModified]]</body><body package="Smalltalk Archive Support">smalltalkArchiveOutTo: aFilename parcelOptions: options 	| realFilename tempFilename tempFile |	realFilename := aFilename asFilename.	tempFilename := Time microsecondClock printString asFilename.	tempFile := TarFile newOn: tempFilename writeStream.	self saveToTarfile: tempFile parcelOptions: options.	tempFile writeContents.	realFilename exists 		ifTrue: 			[ExternalStream closeOpenStreamsNamed: realFilename.			realFilename delete].	tempFilename renameTo: realFilename</body></methods><methods><class-id>Tools.ParcelInImageItem</class-id> <category>testing</category><body package="Smalltalk Archive UI">isSmalltalkArchive	^false</body></methods><methods><class-id>Refactory.Browser.BrowserNavigator</class-id> <category>store-packages</category><body package="Smalltalk Archive UI">storePublishAsParcel	self publishAsParcelDialogClass publishAsParcel: self pundles</body></methods><methods><class-id>Tools.FileTools.FileItem</class-id> <category>visuals</category><body package="Smalltalk Archive UI">icon	| tail props |	tail := filename tail.	(#('*.st' '*.pst' '*.cha') anySatisfy: [:pattern | pattern match: tail]) 		ifTrue: [^ListIconLibrary visualFor: #textPage].	('*.pcl' match: tail) 		ifTrue: 			[props := ParcelFileViewer new propertiesFrom: filename.			(Parcel isParcelLoaded: props) 				ifTrue: [^ListIconLibrary visualFor: #loadedParcel]				ifFalse: [^ListIconLibrary visualFor: #unloadedParcel]].	filename isSmalltalkArchive 		ifTrue: 			[props := Store.CodeReaderForSmalltalkArchive new readInfoFromTarFileNamed: filename.			((props at:#pundleModelClass) isSmalltalkArchiveLoaded: props) 				ifTrue: [^ListIconLibrary visualFor: #loadedParcel]				ifFalse: [^ListIconLibrary visualFor: #unloadedParcel]].	^ListIconLibrary visualFor: #blankPage</body></methods><methods><class-id>Tools.FileTools.FileBrowser</class-id> <category>menus</category><body package="Smalltalk Archive UI">augmentFileListMenuForCurrentFile: aMenu	self withSelectedFilenameDo:		[:name |		(self isFileoutFilename: name) ifTrue:			[aMenu addPart: self class fileoutExtras].		(self isParcelFilename: name) ifTrue:			[aMenu addPart: self class parcelExtras].		(name isSmalltalkArchive) ifTrue: 			[aMenu addPart: self class smalltalkArchiveExtras]]</body></methods><methods><class-id>Tools.FileTools.FileBrowser</class-id> <category>pattern box</category><body package="Smalltalk Archive UI">initializePatterns		(self patternChoices value)		add: '*';		add: '*.pcl';		add: '*.st, *.pst, *.cha';		add: '*.txt, *.ws';		add: (TarFile knownExtensionsWithPrefix: '*' separatedBy: ', ').	self patternHolder value: '*'.	self patternHolder onChangeSend: #patternSelected to: self</body></methods><methods><class-id>Tools.FileTools.FileBrowser</class-id> <category>file list</category><body package="Smalltalk Archive UI">loadSmalltalkArchive	self withSelectedFilenameDo: 			[:name | 			(Dialog 				confirm: (#LoadSmalltalkArchive1sQ &lt;&lt; #dialogs 						&gt;&gt; 'Load Smalltalk Archive "&lt;1s&gt;"?' expandMacrosWith: name tail)) 					ifTrue: 						[Notice show: (#LoadingParcelN1S &lt;&lt; #dialogs &gt;&gt; 'Loading Parcel&lt;n&gt;&lt;1s&gt;' 									expandMacrosWith: name asString)							while: [Store.BundleModel loadSmalltalkArchiveFrom: name]]]</body></methods><methods><class-id>Tools.FileDialog</class-id> <category>accessing-configuring</category><body package="Smalltalk Archive UI">addDefaultFilters	self		addFileFilter: #SmalltalkSourceStPstCha &lt;&lt; #dialogs 					&gt;&gt; 'Smalltalk Source (*.st; *.pst; *.cha)'			pattern: '*.st;*.pst;*.cha';		addFileFilter: #ObjectStudioSourceCls &lt;&lt; #dialogs 					&gt;&gt; 'ObjectStudio Source (*.cls)'			pattern: '*.cls';		addFileFilter: #TextAndWorkspacesTxtWs &lt;&lt; #dialogs 					&gt;&gt; 'Text and Workspaces (*.txt; *.ws)'			pattern: '*.txt;*.ws';		addFileFilter: #SmalltalkArchivesStoreStar &lt;&lt; #dialogs 					&gt;&gt; 'Smalltalk Archives (*.store; *.star)'			pattern: '*.store;*.star';		addFileFilter: #ParcelFilesPcl &lt;&lt; #dialogs &gt;&gt; 'Parcel Files (*.pcl)'			pattern: '*.pcl';		addFileFilter: #TarArchivesTar &lt;&lt; #dialogs 					&gt;&gt; 'Tar Archives (.tar)'			pattern: '*.tar';		addFilterForAllFiles</body></methods><methods><class-id>Tools.ParcelSelectionTool</class-id> <category>testing</category><body package="Smalltalk Archive UI">canUnload	"Currently Smalltalk Archives cannot be unloaded from the Parcel Manager,	please use the browser instead"	| selections |	selections := self selections.	^selections isEmpty not and: 			[selections				allSatisfy: [:each | each isSmalltalkArchive not and: [each isLoaded]]]</body></methods><methods><class-id>Store.AbstractPublishSpecification</class-id> <category>testing</category><body package="Smalltalk Archive UI">isFileSpecification	^false</body></methods><methods><class-id>Tools.ParcelFileItem</class-id> <category>printing</category><body package="Smalltalk Archive UI">displayString	"Display string shows up in various lists."	| name version |	name := self nameOr: [filename tail].	version := self versionOr: ['?'].	^name , ' [' , version , '] (' , filename extension , ')'</body></methods><methods><class-id>Tools.ParcelFileItem</class-id> <category>testing</category><body package="Smalltalk Archive UI">isSmalltalkArchive	^false</body></methods><methods><class-id>Store.PublishFileSpecification</class-id> <category>testing</category><body package="Smalltalk Archive UI">isFileSpecification	^true</body></methods><methods><class-id>Store.PundleModel</class-id> <category>accessing</category><body package="Smalltalk Archive UI">binarySave	^properties at: #binarySave ifAbsent: [false]</body><body package="Smalltalk Archive UI">binarySave: aBoolean	properties at: #binarySave put: aBoolean</body></methods><methods><class-id>Store.PublishSpecificationList class</class-id> <category>instance creation</category><body package="Smalltalk Archive UI">fromBundle: aBundleModel		| topLevelSpecification instance |	(topLevelSpecification := self specClass pundle: aBundleModel)		publish: true;		modified: true.	aBundleModel mergeInformation ifNotNil:		[:value | 		topLevelSpecification comment: value blessingComment.		topLevelSpecification blessing: value blessingLevel].	instance := self with: topLevelSpecification.	aBundleModel descriptionsAndLevels do:		[:eachDescriptionAndLevel | 		| pundleModel pundleDescription publishSpecification |		pundleDescription := eachDescriptionAndLevel at: 1.		pundleModel := pundleDescription component.		(Gathering for: pundleModel) started.		publishSpecification := self specClass pundle: pundleModel.		publishSpecification description: pundleDescription.		pundleModel mergeInformation ifNotNil:			[:value | 			publishSpecification comment: value blessingComment.			publishSpecification blessing: value blessingLevel].		publishSpecification level: eachDescriptionAndLevel last.		instance add: publishSpecification.		(Gathering for: pundleModel) finished].	"((instance allButFirst: 1) allSatisfy: [:each | each binarySave]) ifTrue: [instance do: [:each | each binarySave: true]]."	^instance</body></methods><methods><class-id>Store.PublishSpecificationList</class-id> <category>testing</category><body package="Smalltalk Archive UI">canPublish	"Answer true if every item marked for publication can be published."	self reverseDo: 		[ :spec | 		spec publish			ifTrue: 				[ spec canPublish					ifFalse: [ ^false ].				]			].	^true</body></methods><initialize><class-id>Tools.SmalltalkArchiveFileItem</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>UnixSystemSupport</name><environment>OS</environment><super>OS.OSSystemSupport</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.UnixSystemSupportDictionary.*			</imports><category>OS-Unix</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item type="sym">linkedIn</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>OS-Unix</package></attributes></class><class><name>LogicalFilename</name><environment>OS</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>components </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Support</category><attributes><package>OS-Support</package></attributes></class><class><name>SequenceableCollection</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>SourceFileManager</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>files names writableIndices openIndices currentTarget isPadding sourceFormatters sourceToCopy </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Support</category><attributes><package>Kernel-Support</package></attributes></class><class><name>FileBlurbViewer</name><environment>Tools.FileTools</environment><super>Tools.FileTools.FileViewer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>textHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-File Browser</category><attributes><package>Tools-File Browser</package></attributes></class><class><name>ParcelFileViewer</name><environment>Tools.FileTools</environment><super>Tools.FileTools.FileBlurbViewer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-File Browser</category><attributes><package>Tools-File Browser</package></attributes></class><class><name>CodeComponent</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Code Components</category><attributes><package>System-Code Components</package></attributes></class><class><name>PundleModel</name><environment>Store</environment><super>Kernel.CodeComponent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dbInfo readonly </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>PackageModel</name><environment>Store</environment><super>Store.PundleModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>models </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>AbstractPublishSpecification</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>publish modified comment level version parentVersion description blessing object pundleModel </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreTags</category><attributes><package>Store-Publishing Support</package></attributes></class><class><name>FileBrowser</name><environment>Tools.FileTools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>directoryTreeHolder patternChoices fileListHolder patternHolder fileSelectionChannel currentViewer statusTextRightHolder statusTextLeftHolder viewerListHolder menuBarHolder encodingChannel </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-File Browser</category><attributes><package>Tools-File Browser</package></attributes></class><class><name>ParcelManager</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>categoryHolder parcelHolder detailHolder statusTextHolder categorySubapplication parcelSubapplication detailSubapplication selectedGroups displayedParcels selectedParcels </inst-vars><class-inst-vars></class-inst-vars><imports>			private Refactory.Browser.RefactoringBrowser			private Refactory.Browser.NavigatorState			</imports><category>Tools-Parcel Manager</category><attributes><package>Tools-Parcel Manager</package></attributes></class><class><name>ParcelFileItem</name><environment>Tools</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>filename properties </inst-vars><class-inst-vars></class-inst-vars><imports>			XML.Element			</imports><category>Tools-Parcel Manager</category><attributes><package>Tools-Parcel Manager</package></attributes></class><class><name>ParcelInImageItem</name><environment>Tools</environment><super>Tools.ParcelFileItem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parcel </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Parcel Manager</category><attributes><package>Tools-Parcel Manager</package></attributes></class><class><name>SimpleDialog</name><environment>UI</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>close accept cancel preBuildBlock postBuildBlock postOpenBlock escapeIsCancel parentView useParentColors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Dialogs</category><attributes><package>Interface-Dialogs</package></attributes></class><class><name>FileDialog</name><environment>Tools</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>windowTitle acceptButtonLabel defaultExtension volumesMenu directoryHolder fileList filenameEntryHolder showHiddenHolder fileFilters fileFilterHolder sortSelectorHolder fileFiltersMenuHolder fileCondition avoidWriteProtectedFiles </inst-vars><class-inst-vars>lastDirectory </class-inst-vars><imports></imports><category>UIApplications-New</category><attributes><package>Tools-Dialogs</package></attributes></class><class><name>ParcelDirectory</name><environment>Tools</environment><super>Tools.ParcelGroup</super><private>false</private><indexed-type>none</indexed-type><inst-vars>path </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Parcel Manager</category><attributes><package>Tools-Parcel Manager</package></attributes></class><class><name>StorePundle</name><environment>Store.Glorp</environment><super>Store.Glorp.StoreSourceObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>comment properties propertiesBlob propertiesRecordDictionary version blessings currentBlessingLevel storeModel session versionless fullClasses </inst-vars><class-inst-vars>cache </class-inst-vars><imports>			private Store.*			private Store.Glorp.*			</imports><category></category><attributes><package>Store-Database Model</package></attributes></class><class><name>UndefinedObject</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Win32SystemSupport</name><environment>OS</environment><super>OS.OSSystemSupport</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.Win32SystemSupportDictionary.*			</imports><category>OS-Support</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>kernel32.dll</item> <item>gdi32.dll</item> <item>advapi32.dll</item> <item>user32.dll</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>OS-PC</package></attributes></class><class><name>Timestamp</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>year month day hours minutes seconds milliseconds partialNanosecond </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>IOAccessor</name><environment>OS</environment><super>OS.OSHandle</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.IOConstants.*			</imports><category>OS-Support</category><attributes><package>OS-Support</package></attributes></class><class><name>UnixDiskFileAccessor</name><environment>OS</environment><super>OS.UnixIOAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Unix</category><attributes><package>OS-Unix</package></attributes></class><class><name>CharacterArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>PublishSpecificationList</name><environment>Store</environment><super>Core.List</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>publisher notificationQueue </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.*			private Store.Glorp.*			private Glorp.*			</imports><category>Store-IMG-Configurations</category><attributes><package>Store-Publishing Support</package></attributes></class><class><name>CodeReader32</name><environment>Kernel</environment><super>Kernel.CodeReader</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Behavior.*			</imports><category>System-Code Storage</category><attributes><package>System-Code Storage</package></attributes></class><class><name>FileItem</name><environment>Tools.FileTools</environment><super>Tools.FileTools.AbstractFileItem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-File Browser</category><attributes><package>Tools-File Browser</package></attributes></class><class><name>Filename</name><environment>OS</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>osName publicName logicalName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Support</category><attributes><package>OS-Support</package></attributes></class><class><name>BundleModel</name><environment>Store</environment><super>Store.PundleModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>FileModel</name><environment>Store</environment><super>Store.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name dbtrace bundle portableFilename </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreTags</category><attributes><package>Store-Publishing Support</package></attributes></class><class><name>PublishFileSpecification</name><environment>Store</environment><super>Store.AbstractPublishSpecification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-IMG-Configurations</category><attributes><package>Store-Publishing Support</package></attributes></class><class><name>ParcelSelectionTool</name><environment>Tools</environment><super>Tools.ParcelManagerTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Parcel Manager</category><attributes><package>Tools-Parcel Manager</package></attributes></class><class><name>FileEncodedStreamConstructor</name><environment>OS</environment><super>Core.EncodedStreamConstructor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Support</category><attributes><package>OS-Support</package></attributes></class><class><name>PositionableStream</name><environment>Core</environment><super>Core.PeekableStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>collection position readLimit writeLimit policy </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>PCDiskFileAccessor</name><environment>OS</environment><super>OS.PCIOAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-PC</category><attributes><package>OS-PC</package></attributes></class><class><name>BrowserNavigator</name><environment>Refactory.Browser</environment><super>Refactory.Browser.AbstractBrowserNavigator</super><private>false</private><indexed-type>none</indexed-type><inst-vars>history future </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Navigator</category><attributes><package>Browser-BrowserUI</package></attributes></class><class><name>StorePublishDialog</name><environment>Store</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>list disturbed subBuilder </inst-vars><class-inst-vars>developmentTabLabels runtimeTabLabels tabSpecsAndHelpSelectors </class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>Store-UI</package></attributes></class><class><name>CodeWriter</name><environment>Kernel</environment><super>Kernel.ObjectTracer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>definedObjects classes extendedClasses extensionMethods exclusionset definedBindings scopeZones currentClass objectSpace analysisTracer symbolNum stringNum byteArrayNum floatNum doubleNum largePositiveNum largeNegativeNum mclassNum mclassclassNum refNamObjNum scopeZonesNum defObjOrganizerNum classOrganizerNum arbObjectNum arbClassNum stream sourceStream sourceName hideOnLoad pointer currentKey properties prerequisites namedObjects newSourceKeys dateString timeString scratchDictionary codeComponent </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Code Storage</category><attributes><package>System-Code Storage</package></attributes></class></st-source>