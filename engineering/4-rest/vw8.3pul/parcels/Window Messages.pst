<?xml version="1.0"?><st-source><!-- Name: Window MessagesNotice: Copyright 1988-2017 Cincom Systems, Inc.  All rights reserved.Comment: This parcel contains event queue class extensions to support Windows message handling for ActiveX widgetsDbIdentifier: bear73DbTrace: 501000DbUsername: mgrinnellDbVersion: 8.3 - 4DialectVersion: VisualWorks 7.9PackageName: Window MessagesParcel: #('Window Messages')ParcelName: Window MessagesPrintStringCache: (8.3 - 4,mgrinnell)Version: 8.3 - 4Post-Unload Block: 	[  OSSystemSupport installSystemSupportOn: OSSystemSupport currentPlatform]Date: 12:57:12 PM May 5, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (may17.1) of May 5, 2017 on May 5, 2017 at 12:57:12 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>WindowMessage</name><environment>UI</environment><super>UI.Event</super><private>false</private><indexed-type>none</indexed-type><inst-vars>windowHandle messageID </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Window Messages</package></attributes></class><class><name>UnboundWindowManager</name><environment>UI</environment><super>UI.WindowManager</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Window Messages</package></attributes></class><class><name>Win64SystemSupport</name><environment>OS</environment><super>OS.Win32SystemSupport</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.Win64SystemSupportDictionary.*			</imports><category></category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>Window Messages</package></attributes></class><class><name>Win32WindowMessage</name><environment>UI</environment><super>UI.WindowMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parameterW parameterL position </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Window Messages</package></attributes></class><shared-variable><name>WindowMessageCollector</name><environment>UI.InputState</environment><private>false</private><constant>false</constant><category>window message processing</category><initializer>nil</initializer><attributes><package>Window Messages</package></attributes></shared-variable><shared-variable><name>EventDispatchTable</name><environment>UI.InputState</environment><private>true</private><constant>true</constant><category>As yet unclassified</category><initializer>#("0" send:noOp:					"1" send:eventKeyPress:					"2" send:eventKeyRelease:					"3" send:eventButtonPress:					"4" send:eventButtonRelease:					"5" send:eventMouseMoved:					"6" send:eventEnter:					"7" send:eventExit:					"8" send:eventDamage:					"9" send:eventResize:					"10" send:eventQuit:					"11" send:eventCollapse:					"12" send:eventExpand:					"13" send:eventWidgetColorChange:					"14" send:eventDestroy:					"15 menuInput" nil					"16 saveCommand" nil					"17" send:eventMouseWheel:					"18" send:eventQuitSystem:					"19" send:eventButtonDoubleClick:					"20" send:eventInputManager:					"21" send:eventWindowMessage:) copy</initializer><attributes><package>Window Messages</package></attributes></shared-variable><shared-variable><name>UnboundWindowMessageDispatcher</name><environment>UI.InputState</environment><private>false</private><constant>false</constant><category>window message processing</category><attributes><package>Window Messages</package></attributes></shared-variable><shared-variable><name>MessageHandlingClients</name><environment>UI.InputState</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><initializer>IdentitySet new</initializer><attributes><package>Window Messages</package></attributes></shared-variable><shared-variable><name>Current</name><environment>UI.WindowMessage</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Window Messages</package></attributes></shared-variable><shared-variable><name>Win64SystemSupportDictionary</name><environment>OS</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>Window Messages</package></attributes></shared-variable><shared-variable><name>SurfaceListSemaphore</name><environment>UI.Win32WindowMessage</environment><private>false</private><constant>false</constant><category>registration</category><initializer>Semaphore forMutualExclusion</initializer><attributes><package>Window Messages</package></attributes></shared-variable><shared-variable><name>SurfaceList</name><environment>UI.Win32WindowMessage</environment><private>false</private><constant>false</constant><category>registration</category><initializer>WeakArray new</initializer><attributes><package>Window Messages</package></attributes></shared-variable><methods><class-id>UI.WindowMessage</class-id> <category>accessing</category><body package="Window Messages">messageID	^messageID</body><body package="Window Messages">messageID: anInteger	messageID := anInteger</body><body package="Window Messages">priority	^75</body><body package="Window Messages">windowHandle	^windowHandle</body><body package="Window Messages">windowHandle: anInteger	windowHandle := anInteger</body></methods><methods><class-id>UI.WindowMessage</class-id> <category>testing</category><body package="Window Messages">isDamage	^self subclassResponsibility</body><body package="Window Messages">isDebuggerInterrupt	^self subclassResponsibility</body><body package="Window Messages">isEmergencyInterrupt	^self subclassResponsibility</body></methods><methods><class-id>UI.WindowMessage</class-id> <category>dispatching</category><body package="Window Messages">dispatch	(window notNil and: [window canProcessEvent])		ifFalse: [^self dispatchTo: nil].	^self eventDispatcher dispatchEvent: self</body><body package="Window Messages">eventDispatcher	^window windowMessageDispatcher</body></methods><methods><class-id>UI.WindowMessage</class-id> <category>printing</category><body package="Window Messages">printAttributesOn: aStream		aStream nextPutAll: self windowHandle printString.	aStream nextPut: $,.	aStream space.	aStream nextPutAll: self messageID printString.	aStream nextPut: $,.	aStream space.	aStream nextPutAll: self time printString</body><body package="Window Messages">printOn: aStream		aStream nextPutAll: self class name.	aStream nextPut: $(.	self printAttributesOn: aStream.	aStream nextPut: $)</body></methods><methods><class-id>UI.WindowMessage</class-id> <category>private</category><body package="Window Messages">loadFrom: anEventArray	"we cannot call here the super implementation, because there is a Window&gt;&gt;findRegistrant:, which can be blocked	 sometimes in the handle registry semaphore. Please look at InputState&gt;&gt;processWindowMessages for more details"		self setTime: (anEventArray at: 9).	window := anEventArray at: 8</body></methods><methods><class-id>UI.WindowMessage</class-id> <category>comparing</category><body package="Window Messages">sameAs: aWindowMessage		^(super sameAs: aWindowMessage)		and: [self messageID == aWindowMessage messageID]</body></methods><methods><class-id>UI.WindowMessage</class-id> <category>adding/removing</category><body package="Window Messages">addToSensor: aSensor    RuntimeSystem isRuntime        ifFalse:            [self isEmergencyInterrupt                ifTrue: [[EmergencyWindow open] fork]                ifFalse:                    [self isDebuggerInterrupt                        ifTrue:                            [| debugger |                            debugger := #{CraftedSmalltalk.DebuggerService} valueOrDo: [nil].                            debugger notNil ifTrue: [debugger interruptActiveUserProcess]]]].    ^self isDamage        ifTrue: [aSensor addUniqueMetaInput: self]        ifFalse:            [aSensor addMetaInput: self.            true]</body></methods><methods><class-id>UI.WindowMessage class</class-id> <category>instance creation</category><body package="Window Messages">concreteClass	"Answer the specific subclass that interfaces to the OS on the current platform."	Current == nil ifTrue:		[Current := self concreteClassFrom: ExternalInterface currentPlatform].	^Current</body><body package="Window Messages">concreteClass: aWindowMessageClass	Current := aWindowMessageClass</body><body package="Window Messages">concreteClassFrom: aPlatformArray	"Answer the specific subclass that interfaces to the OS described by the supplied platformArray. Subclasses participate in this selection process by implementing matchesPlatform:. Subclasses are matched before superclasses. We filter to only those closes that actually define the matchesPlatform: message, otherwise arbitrary subclasses (searched first) would match."		self subclasses		do:			[:each | (each concreteClassFrom: aPlatformArray) ifNotNil: [:match | ^match]].	^((self class includesSelector: #matchesPlatform:)		and: [self matchesPlatform: aPlatformArray])		ifTrue: [self]		ifFalse: [nil]</body></methods><methods><class-id>UI.WindowMessage class</class-id> <category>private</category><body package="Window Messages">matchesPlatform: aPlatformArray	"aPlatformArray is the result of an ExternalInterface currentPlatform query. Concrete subclasses should return a true or false, indicating whether the reciever is a candidate for the current concreteClass."		^self subclassResponsibility</body><body package="Window Messages">nextEventArray	^self subclassResponsibility</body></methods><methods><class-id>UI.UnboundWindowManager</class-id> <category>testing</category><body package="Window Messages">hasWindows	^true</body></methods><methods><class-id>UI.UnboundWindowManager</class-id> <category>private</category><body package="Window Messages">newProcess	^Process forBlock: 			[			[[Processor activeProcess == baseProcess]				whileTrue: [self processNextEvent]]					on: Process terminateSignal					do: 						[:ex |						self purgeInvalidWindows.						Processor activeProcess == baseProcess ifTrue: [self launchBaseProcess]]]		priority: self class defaultPriority</body><body package="Window Messages">queueDeferredEmptyCheck		^self</body><body package="Window Messages">terminateIfEmpty		^self</body></methods><methods><class-id>UI.UnboundWindowManager</class-id> <category>displaying</category><body package="Window Messages">restore	"If I'm being restored and I have no windows, why am I around? So I sendTerminate."	(baseProcess isNil or: [baseProcess isTerminated])		ifTrue: 			[self launchBaseProcess.			Processor yield].	self addEvent: (DeferrableAction send: #basicRestore to: self)</body></methods><methods><class-id>UI.UnboundWindowManager class</class-id> <category>accessing</category><body package="Window Messages">defaultPriority	"Return the priority at which the unboundWindowManager will run. 	 Note that the priority is higher than normal processes priority"	^Processor userInterruptPriority</body></methods><methods><class-id>OS.Win64SystemSupport class</class-id> <category>private</category><body package="Window Messages">matchesPlatform: aPlatformArray		(super matchesPlatform: aPlatformArray) ifFalse: [^ false ].	^ '*x64*' match: (aPlatformArray at: 2)</body></methods><methods><class-id>UI.Win32WindowMessage</class-id> <category>accessing</category><body package="Window Messages">parameterL	^parameterL</body><body package="Window Messages">parameterL: anInteger	parameterL := anInteger</body><body package="Window Messages">parameterW	^parameterW</body><body package="Window Messages">parameterW: anInteger	parameterW := anInteger</body><body package="Window Messages">position	^position</body><body package="Window Messages">position: aPoint	position := aPoint</body></methods><methods><class-id>UI.Win32WindowMessage</class-id> <category>testing</category><body package="Window Messages">isDamage	^self messageID == self class WM_PAINT</body><body package="Window Messages">isDebuggerInterrupt		^self messageID == self class WM_KEYDOWN		and:			[self parameterW == self class VK_Y and: [InputState default ctrlDown]]</body><body package="Window Messages">isEmergencyInterrupt		^self isDebuggerInterrupt and: [InputState default shiftDown]</body></methods><methods><class-id>UI.Win32WindowMessage</class-id> <category>printing</category><body package="Window Messages">printAttributesOn: aStream		super printAttributesOn: aStream.	aStream nextPut: $,.	aStream space.	aStream nextPutAll: self parameterL printString.	aStream nextPut: $,.	aStream space.	aStream nextPutAll: self parameterW printString.	aStream nextPut: $,.	aStream space.	aStream nextPutAll: self position printString</body></methods><methods><class-id>UI.Win32WindowMessage</class-id> <category>private</category><body package="Window Messages">loadFrom: anEventArray	| msg pos |	super loadFrom: anEventArray.	msg := CComposite newDatum: (anEventArray at: 10)				ofType: OSSystemSupport concreteClass new MSG.	pos := msg memberAt: #pt.	self windowHandle: (msg memberAt: #hwnd) datum.	self messageID: (msg memberAt: #message).	self parameterW: (msg memberAt: #wParam).	self parameterL: (msg memberAt: #lParam).	self position: (pos memberAt: #x) @ (pos memberAt: #y)</body></methods><methods><class-id>UI.Win32WindowMessage</class-id> <category>dispatching</category><body package="Window Messages">dispatchTo: anObject	| support msg pos |	support := OSSystemSupport concreteClass new.	msg := support MSG gcCalloc.	pos := msg refMemberAt: #pt.	msg memberAt: #hwnd put: self windowHandle.	msg memberAt: #message put: self messageID.	msg memberAt: #wParam put: self parameterW.	msg memberAt: #lParam put: self parameterL.	msg memberAt: #time put: self time.	pos memberAt: #x put: self position x.	pos memberAt: #y put: self position y.	support TranslateMessage: msg.	support DispatchMessage: msg</body></methods><methods><class-id>UI.Win32WindowMessage class</class-id> <category>constants</category><body package="Window Messages">VK_Y	^$Y asInteger</body><body package="Window Messages">WM_KEYDOWN	^16r0100</body><body package="Window Messages">WM_PAINT	^16r000F</body><body package="Window Messages">stButtonBitLeft	^16r01</body><body package="Window Messages">stButtonBitMiddle	^16r02</body><body package="Window Messages">stButtonBitRight	^16r04</body><body package="Window Messages">stKeyBitAlt	^self stKeyBitOther</body><body package="Window Messages">stKeyBitCtrl	^16r0200</body><body package="Window Messages">stKeyBitOther	^16r0800</body><body package="Window Messages">stKeyBitShift	^16r0100</body></methods><methods><class-id>UI.Win32WindowMessage class</class-id> <category>private</category><body package="Window Messages">findParent: aWindowHandle	| support hwnd hwndParent |	support := OSSystemSupport concreteClass new.	hwnd := CPointer newDatum: aWindowHandle ofType: support HWND.	hwndParent := OSSystemSupport concreteClass new GetParent: hwnd.	^hwndParent isValid ifTrue: [hwndParent datum] ifFalse: [nil]</body><body package="Window Messages">findRegistrant: aWindowHandle	| window |	window := self findRegistrant: aWindowHandle in: self surfaceList.	^window isUnboundWindow ifTrue: [nil] ifFalse: [window]</body><body package="Window Messages">findRegistrant: aWindowHandle in: aSurfaceList		^aSurfaceList		detect: [:each | each windowHandle == aWindowHandle]		ifNone:			[(self findParent: aWindowHandle)				ifNotNil: [:parent | self findRegistrant: parent in: aSurfaceList]]</body><body package="Window Messages">flushSurfaces	SurfaceListSemaphore critical: [SurfaceList := WeakArray new]</body><body package="Window Messages">getMetaState	"this is a copy of the Visualworks VM function #updateMetaState to retrieve the current states of special keys/mousebuttons"		| support mouseButtonsSwapped vkLeft vkRight gbliMetaBits |	support := OSSystemSupport concreteClass new.	mouseButtonsSwapped := support GetSystemMetrics: support SM_SWAPBUTTON.	mouseButtonsSwapped ~= support FALSE		ifTrue:			[vkLeft := support VK_RBUTTON.			vkRight := support VK_LBUTTON]		ifFalse:			[vkLeft := support VK_LBUTTON.			vkRight := support VK_RBUTTON].	gbliMetaBits := 0.	((support GetAsyncKeyState: support VK_SHIFT) bitAnd: 16r8000) ~= 0		ifTrue: [gbliMetaBits := gbliMetaBits bitOr: self stKeyBitShift].	((support GetAsyncKeyState: support VK_CONTROL) bitAnd: 16r8000) ~= 0		ifTrue: [gbliMetaBits := gbliMetaBits bitOr: self stKeyBitCtrl].	((support GetAsyncKeyState: support VK_MENU) bitAnd: 16r8000) ~= 0		ifTrue: [gbliMetaBits := gbliMetaBits bitOr: self stKeyBitAlt].	((support GetAsyncKeyState: vkLeft) bitAnd: 16r8000) ~= 0		ifTrue: [gbliMetaBits := gbliMetaBits bitOr: self stButtonBitLeft].	((support GetAsyncKeyState: support VK_MBUTTON) bitAnd: 16r8000) ~= 0		ifTrue: [gbliMetaBits := gbliMetaBits bitOr: self stButtonBitMiddle].	((support GetAsyncKeyState: vkRight) bitAnd: 16r8000) ~= 0		ifTrue:			[(gbliMetaBits bitAnd: self stKeyBitCtrl) ~= 0				ifTrue: [gbliMetaBits := gbliMetaBits bitOr: self stButtonBitMiddle]				ifFalse: [gbliMetaBits := gbliMetaBits bitOr: self stButtonBitRight]].	^gbliMetaBits</body><body package="Window Messages">initializeDefaultSurfaces	WindowManager managerRegistry		do: [:wm | wm ifNotNil: [wm scheduledWindows do: [:win | self register: win]]]</body><body package="Window Messages">matchesPlatform: aPlatformArray		^#win32 == (aPlatformArray at: 1)</body><body package="Window Messages">nextEventArray	"we simulate here the primitive in Screen&gt;&gt;primReadEvent:, which returns normally an event array"		| support msg result |	support := OSSystemSupport concreteClass new.	msg := support MSG gcCalloc.	result := support		PeekMessage: msg		window: 0		filterMin: 0		filterMax: 0		flags: support PM_REMOVE | support PM_NOYIELD.	^result = support FALSE		ifTrue: [nil]		ifFalse:			[(Array new: 12)				at: 1 put: 21;				at: 2 put: 0;				at: 7 put: self getMetaState;				at: 8 put: (self findRegistrant: (msg memberAt: #hwnd) datum);				at: 9 put: (msg memberAt: #time);				at: 10 put: msg contents datum;				yourself]</body><body package="Window Messages">register: aSurface	"Add aSurface to SurfaceList.	copyWith: uses (self species), so it will answer an Array.	Use (SurfaceList class) below to make sure I keep only weak references"	SurfaceListSemaphore critical: 			[SurfaceList := SurfaceList class withAll: (SurfaceList copyWith: aSurface)]</body><body package="Window Messages">surfaceList	^SurfaceList</body><body package="Window Messages">unregister: aSurface	"Remove aSurface from SurfaceList.	copyWithout: uses (self species), so it will answer an Array.	Use (SurfaceList class) below to make sure I keep only weak references"	SurfaceListSemaphore critical: 			[SurfaceList := SurfaceList class						withAll: (SurfaceList copyWithout: aSurface)]</body></methods><methods><class-id>UI.EventQueue</class-id> <category>accessing</category><body package="Window Messages">nextPut: value unique: isUnique	"Send value through the receiver. If a Process has been suspended waiting to 	receive a value through the receiver, allow it to proceed. 	isUnique is a boolean indicating whether we should replace	the last matching value in the queue with this one, or just add it."	| doSignal index |	doSignal := true.	[accessProtect critical: 			[(isUnique				and: [(index := contents findLast: [:each | each sameAs: value]) ~= 0])					ifTrue: 						[contents at: index put: value.						doSignal := false]					ifFalse: [self nextPutWithPriority: value]]]			valueUninterruptably.	doSignal ifTrue: [readSynch signal].	^doSignal</body></methods><methods><class-id>UI.EventQueue</class-id> <category>private</category><body package="Window Messages">nextPutWithPriority: value	| index |	index := (SequenceableCollectionSorter on: contents				using: [:x :y | x priority &gt;= y priority]) indexForInserting: value.	index &gt; contents size		ifTrue: [contents addLast: value]		ifFalse: [contents add: value beforeIndex: index]</body></methods><methods><class-id>UI.EventQueue</class-id> <category>accessing</category><body package="Window Messages">removeAllEventsOfType: anEventClass	^self removeAllEventsSatisfying: [:each | each isKindOf: anEventClass]</body><body package="Window Messages">removeAllEventsSatisfying: aBlock	^	[accessProtect critical: 			[| newContents removedElements |			newContents := OrderedCollection new: contents size.			removedElements := OrderedCollection new: contents size.			contents do: 					[:each |					(aBlock value: each)						ifTrue: [removedElements add: each]						ifFalse: [newContents add: each]].			contents := newContents.			removedElements]]			valueUninterruptably</body></methods><methods><class-id>UI.WindowManager class</class-id> <category>class initialization</category><body package="Window Messages">flushInvalidEvents	self allGeneralInstances do: [:each | each flushInvalidEvents]</body></methods><methods><class-id>UI.WindowManager</class-id> <category>event processing</category><body package="Window Messages">addEvent: aMetaEvent unique: aBool	^eventQueue nextPut: aMetaEvent unique: aBool</body></methods><methods><class-id>UI.WindowManager</class-id> <category>initialize-release</category><body package="Window Messages">flushInvalidEvents		self removeAllEventsOfType: WindowMessage.</body><body package="Window Messages">open	"If I'm being opened/installed and I have no windows, why am I around? So I check for terminate"	self hasWindows ifFalse: [^self sendTerminate].	BasicHeadfullGraphicsSystem isActive ifFalse: [^self].	self assureInRegistry.	self flushInvalidEvents.	[openInProgress := true.	self allocateAll: windows.	windows reverseDo:		[:win |		[win finishOpening]			on:Object errorSignal			do: [:ex | ex return]]] 		ensure: [openInProgress := false].</body></methods><methods><class-id>UI.WindowManager</class-id> <category>event processing</category><body package="Window Messages">removeAllEventsOfType: anEventClass		^self eventQueue removeAllEventsOfType: anEventClass</body><body package="Window Messages">removeAllEventsSatisfying: aBlock		^self eventQueue removeAllEventsSatisfying: aBlock</body><body package="Window Messages">removeEventsDestinedFor: aWindow	^self eventQueue removeEventsDestinedFor: aWindow</body></methods><methods><class-id>UI.ExposeEvent</class-id> <category>testing</category><body package="Window Messages">isExposeEvent	^true</body></methods><methods><class-id>UI.InputState class</class-id> <category>system startup</category><body package="Window Messages">flushInputClients	#{MessageHandlingClients} initialize.</body></methods><methods><class-id>UI.InputState class</class-id> <category>class initialization</category><body package="Window Messages">install	"Initialize and connect the receiver to the hardware."	InputSemaphore := Semaphore new.	InputProcess := [DefaultState run] forkAt: Processor lowIOPriority.	InputProcess setIsSystemProcess;		name: 'InputStateIOProcess'.	Screen default isMacOSX ifTrue: [		MacOSXSystemSupport new enableSendCommandKeys: 1.		" This is because the VM sets up the edit menu with shortcuts and event handling		that has to stay for old images, but is no longer desirable "		MacOSXSystemSupport resetEditMenu.		MacOSXSystemSupport disableApplePressAndHold.	].	self flushInputClients.</body></methods><methods><class-id>UI.InputState class</class-id> <category>accessing</category><body package="Window Messages">messageHandlingClients	^ MessageHandlingClients</body><body package="Window Messages">numberOfWindowMessageClients	^self messageHandlingClients size</body><body package="Window Messages">registerMessageHandlingClient: aSymbol	^ (self messageHandlingClients includes: aSymbol)		ifTrue: 			[self error: #ClientAlreadyRegistered &lt;&lt; #messages						&gt;&gt; 'Client is already registered and can not be registered again'.			false]		ifFalse: 			[self messageHandlingClients add: aSymbol.			true]</body><body package="Window Messages">unregisterMessageHandlingClient: aSymbol	^ (self messageHandlingClients includes: aSymbol)		ifFalse: 			[self error: #ClientNotRegistered &lt;&lt; #messages						&gt;&gt; 'Client is not registered and can not be unregistered'. 			false]		ifTrue: [self messageHandlingClients remove: aSymbol.			true]</body></methods><methods><class-id>UI.InputState</class-id> <category>utilities</category><body package="Window Messages">basicStartWindowMessageProcessing	"Inform the VM to start the message processing"		| regNames |	self initializeWindowMessage.	self initializeUnboundWindowMessageDispatcher.	regNames := ObjectMemory registrationNames.	((regNames includes: 'callbackEventClass')		and: [regNames includes: 'callbackEventSelector'])		ifTrue:			[ObjectMemory registerObject: self withEngineFor: 'callbackEventClass'.			ObjectMemory registerObject: #processWindowMessages withEngineFor:					'callbackEventSelector']</body><body package="Window Messages">basicStopWindowMessageProcessing	"Inform the VM to stop the window message processing"		| regNames |	regNames := ObjectMemory registrationNames.	((regNames includes: 'callbackEventClass')		and: [regNames includes: 'callbackEventSelector'])		ifTrue:			[ObjectMemory registerObject: nil withEngineFor: 'callbackEventClass'.			ObjectMemory registerObject: nil withEngineFor: 'callbackEventSelector'].	self flushUnboundWindowMessageDispatcher.	self flushWindowMessage</body></methods><methods><class-id>UI.InputState</class-id> <category>window messages</category><body package="Window Messages">flushUnboundWindowMessageDispatcher	self unboundWindowMessageDispatcher		ifNotNil: 			[:manager |			manager terminate.			self unboundWindowMessageDispatcher: nil]</body><body package="Window Messages">flushWindowMessage	WindowMessage concreteClass flushSurfaces</body><body package="Window Messages">initializeUnboundWindowMessageDispatcher	self flushUnboundWindowMessageDispatcher.	self unboundWindowMessageDispatcher: ((UnboundWindowManager new)				launchBaseProcess;				yourself)</body><body package="Window Messages">initializeWindowMessage	WindowMessage concreteClass initializeDefaultSurfaces</body><body package="Window Messages">processSafeWindowMessagesWhile: aBlock	WindowMessageCollector ifNotNil: [^self].		[WindowMessageCollector := Processor activeProcess.	[[WindowMessageCollector == Processor activeProcess and: [aBlock value]] whileTrue] on: UnhandledException		do: 			[:ex |			WindowMessageCollector := nil.			ex pass]]			ensure: [WindowMessageCollector := nil]</body><body package="Window Messages">processSafeWindowMessagesWhile: aBlock withPriority: aPriority	self processSafeWindowMessagesWhile: 			[| oldPriority |			oldPriority := Processor activeProcess priority.			Processor activeProcess priority: aPriority.			aBlock ensure: [Processor activeProcess priority: oldPriority]]</body><body package="Window Messages">processUnboundWindowMessage: event	"if we have an installed unbound window manager we delegate the window message to that one, else we dispatch	 the window message directly in the current process (normally it is the collector process)"	| windowMessage |	windowMessage := WindowMessage concreteClass withArray: event.	self unboundWindowMessageDispatcher		ifNil: [windowMessage dispatchTo: nil]		ifNotNil: [:dispatcher | dispatcher addEvent: windowMessage].	^true</body><body package="Window Messages">processWindowMessages	"normally we want to use the normal #process: loop in InputState, but we have found that the execution of Window&gt;&gt;findRegistrant:	 blocks sometimes the in handle registry when we are in Window&gt;&gt;primClose primitive. This happens only for window messages, not	 for normal virtual events. I think this is so, because in the primitive a SetActiveWindow is executed, so that other window messages	 occurs, but i dont know why somebody else blocks the handle registry. To avoid an override of InputState&gt;&gt;process: we call here	 directly our #send:eventWindowMessage: method.	 We execute the collector at a priority which is lower than the unbound window manager. This causes that an unbound	 window message is executed immediately, because the unbound window manager becomes active when a window message	 is added to its event queue (semaphore signal). The collector will wait until this window message is processed or the unbound	 event execution runs on a delay/semaphore/debugger.	 All normal window messages are moved to their appropriate window managers without interrupting the collector, because the	 collector priority is higher (&gt; userSchedulingPriority) than a standard window manager.	 Because the collector will wait during execution of unbound window messages such an execution cannot be stopped with Ctrl-Y.	 But on the other hand we cannot break an unbound execution with collector activity, because then the collector can steal other	 unbound window messages from the native queue which are needed by the external code.	 Normally most of the unbound window messages are just C calls without using callbacks to Smalltalk, because they are associated	 to windows that are not known by Smalltalk."	self processSafeWindowMessagesWhile: 			[| eventArray |			eventArray := WindowMessage concreteClass nextEventArray.			eventArray notNil and: [self send: nil eventWindowMessage: eventArray]]		withPriority:			UnboundWindowManager defaultPriority - 1</body></methods><methods><class-id>UI.InputState</class-id> <category>private - dispatching</category><body package="Window Messages">send: aWindow eventWindowMessage: eventDataArray	"our naked event array (compatible with Visualworks VM) has already the right window object, we can use this here directly.	 The next thing is... normally all virtual Visualworks events comes with a meta mask to identify which special key/mouse button	 is pressed. Our native event array contains this, because we have emulated this in Win32WindowMessage&gt;&gt;nextEventArray.	 This mask is needed, so that we can set the state vector here in InputState. When we would not do this, then things like the	 Visualworks treeview do not work, because they wait in a polling loop for releasing the mouse buttons. And our problem is,	 that we dispatch now also the native events. Without setting the state mask, the system would be blocked"	"AR72077"	self setKeyboardStateFromEventDataArray: eventDataArray.	self setButtonStateFromEventDataArray: eventDataArray.	^(eventDataArray at: 8)		ifNil: [self processUnboundWindowMessage: eventDataArray]		ifNotNil: [:window | window sensor eventWindowMessage: eventDataArray]</body></methods><methods><class-id>UI.InputState</class-id> <category>window messages</category><body package="Window Messages">startWindowMessageProcessingFor: aSymbol	"Inform the VM to start the message processing"	^(self class registerMessageHandlingClient: aSymbol)		ifTrue: 			[self class numberOfWindowMessageClients = 1 ifTrue: [self basicStartWindowMessageProcessing].			true]		ifFalse: [false]</body><body package="Window Messages">stopWindowMessageProcessingFor: aSymbol	"Inform the VM to stop the window message processing"	^(self class unregisterMessageHandlingClient: aSymbol)		ifTrue: 			[self class numberOfWindowMessageClients = 0 ifTrue: [self basicStopWindowMessageProcessing].			true]		ifFalse: [false]</body><body package="Window Messages">unboundWindowMessageDispatcher	^UnboundWindowMessageDispatcher</body><body package="Window Messages">unboundWindowMessageDispatcher: aDispatcher	UnboundWindowMessageDispatcher := aDispatcher</body></methods><methods><class-id>UI.EventSensor</class-id> <category>private</category><body package="Window Messages">addUniqueMetaInput: aMetaEvent		| result |	window windowManager ifNil: [^false].	result := window windowManager addEvent: aMetaEvent unique: true.	self wakeUpActiveWindow.	^result</body></methods><methods><class-id>UI.EventSensor</class-id> <category>event processing</category><body package="Window Messages">eventWindowMessage: anEventArray		^(self window windowMessageClass withArray: anEventArray) addToSensor:			self</body></methods><methods><class-id>UI.NullWindowManager</class-id> <category>event processing</category><body package="Window Messages">addEvent: aMetaEvent unique: aBool	"do nothing, just return true to continue event processing"	^true</body><body package="Window Messages">removeAllEventsOfType: anEventClass	"do nothing"</body><body package="Window Messages">removeEventsDestinedFor: aWindow	"do nothing"</body></methods><methods><class-id>UI.Event</class-id> <category>testing</category><body package="Window Messages">isExposeEvent	^false</body></methods><methods><class-id>UI.Event</class-id> <category>accessing</category><body package="Window Messages">priority	^50</body></methods><methods><class-id>UI.Event</class-id> <category>comparing</category><body package="Window Messages">sameAs: anEvent		^self class == anEvent class and: [self window == anEvent window]</body></methods><methods><class-id>UI.EmergencyWindow</class-id> <category>events</category><body package="Window Messages">addEvent: anEvent 	anEvent isKeyboard ifTrue: [^self processKeyboardEvent: anEvent].	(anEvent isKindOf: CloseEvent) ifTrue: [^self close].	(anEvent isKindOf: DestroyEvent) ifTrue: [^self processDestroyEvent: anEvent].	(anEvent isKindOf: ExposeEvent) ifTrue: [^self displayAll].	(anEvent isKindOf: WindowMessage) ifTrue: [anEvent dispatchTo: nil]</body></methods><methods><class-id>OS.Win32SystemSupport</class-id> <category>constants</category><body package="Window Messages">PM_NOYIELD		^2</body><body package="Window Messages">PM_REMOVE		^1</body><body package="Window Messages">SM_SWAPBUTTON	^23</body><body package="Window Messages">SW_MAXIMIZE	^3</body><body package="Window Messages">SW_MINIMIZE	^6</body><body package="Window Messages">SW_RESTORE	^9</body><body package="Window Messages">SW_SHOWMAXIMIZED	^3</body><body package="Window Messages">SW_SHOWMINIMIZED	^2</body><body package="Window Messages">VK_CONTROL	^16r11</body><body package="Window Messages">VK_LBUTTON	^16r01</body><body package="Window Messages">VK_MBUTTON	^16r04</body><body package="Window Messages">VK_MENU	^16r12</body><body package="Window Messages">VK_RBUTTON	^16r02</body><body package="Window Messages">VK_SHIFT	^16r10</body><body package="Window Messages">WINEXTRA_PTR	^0</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="Window Messages">isUnboundWindow	^false</body></methods><methods><class-id>Graphics.Window</class-id> <category>painting</category><body package="Window Messages">maximize	| lib |	lib := OS.Win32SystemSupport new.	lib ShowWindow: self windowHandle as: lib SW_SHOWMAXIMIZED.	lib		InvalidateRect: self windowHandle		rect: 0		erase: 1.	"TRUE"	lib UpdateWindow: self windowHandle.	self setIconic: false</body><body package="Window Messages">minimize	| lib |	lib := OS.Win32SystemSupport new.	lib ShowWindow: self windowHandle as: lib SW_SHOWMINIMIZED.	self setIconic: true</body><body package="Window Messages">restore	| lib |	lib := OS.Win32SystemSupport new.	lib ShowWindow: self windowHandle as: lib SW_RESTORE.	lib		InvalidateRect: self windowHandle		rect: 0		erase: 1.	"TRUE"	lib UpdateWindow: self windowHandle.	self setIconic: false</body></methods><methods><class-id>Graphics.Window</class-id> <category>accessing</category><body package="Window Messages">windowMessageClass	^Win32WindowMessage</body></methods><methods><class-id>Graphics.Window</class-id> <category>event driven</category><body package="Window Messages">windowMessageDispatcher	^self</body></methods><methods><class-id>OS.Win64SystemSupport</class-id> <category>types</category><body package="Window Messages">LPARAM		&lt;C: typedef long long LPARAM&gt;</body><body package="Window Messages">LPMSG		&lt;C: typedef MSG* LPMSG&gt;</body><body package="Window Messages">MSG	&lt;C: typedef struct tagMSG MSG&gt;</body><body package="Window Messages">WPARAM		&lt;C: typedef unsigned long long WPARAM&gt;</body></methods><methods><class-id>OS.Win64SystemSupport</class-id> <category>structs</category><body package="Window Messages">tagMSG	&lt;C: struct tagMSG			{			HWND			hwnd;			UINT			message;			WPARAM		wParam;			LPARAM		lParam;			DWORD		time;			POINT			pt;			}	&gt;</body></methods><methods><class-id>OS.Win32SystemSupport</class-id> <category>types</category><body package="Window Messages">HBRUSH	&lt;C: typedef HANDLE HBRUSH&gt;</body><body package="Window Messages">HICON	&lt;C: typedef HANDLE HICON&gt;</body><body package="Window Messages">HPALETTE	&lt;C: typedef HANDLE HPALETTE&gt;</body><body package="Window Messages">LPARAM		&lt;C: typedef DWORD LPARAM&gt;</body><body package="Window Messages">LPMSG		&lt;C: typedef MSG* LPMSG&gt;</body><body package="Window Messages">LRESULT	&lt;C: typedef LONG LRESULT&gt;</body><body package="Window Messages">MSG	&lt;C: typedef struct tagMSG MSG&gt;</body><body package="Window Messages">POINT	&lt;C: typedef struct tagPOINT POINT&gt;</body><body package="Window Messages">SHORT		&lt;C: typedef short SHORT&gt;</body></methods><methods><class-id>OS.Win32SystemSupport</class-id> <category>structs</category><body package="Window Messages">tagMSG	&lt;C: struct tagMSG			{			HWND			hwnd;			UINT			message;			WPARAM		wParam;			LPARAM		lParam;			DWORD		time;			POINT			pt;			}	&gt;</body><body package="Window Messages">tagPOINT	&lt;C: struct tagPOINT			{			LONG	x;			LONG	y;			} 	&gt;</body></methods><methods><class-id>OS.Win32SystemSupport</class-id> <category>types</category><body package="Window Messages">WPARAM		&lt;C: typedef DWORD WPARAM&gt;</body></methods><methods><class-id>OS.Win32SystemSupport</class-id> <category>procedures</category><body package="Window Messages">DispatchMessage: lpMsg		&lt;C: LRESULT DispatchMessageW(const LPMSG lpMsg)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Window Messages">GetAsyncKeyState: vKey		&lt;C: SHORT GetAsyncKeyState(int vKey)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Window Messages">GetParent: hWnd	&lt;C: HWND GetParent(HWND hWnd)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Window Messages">InvalidateRect: hWnd rect: lpRect erase: bErase		&lt;C: BOOL InvalidateRect(HWND hWnd, UINT lpRect, BOOL bErase)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Window Messages">PeekMessage: lpMsg window: hWnd filterMin: wMsgFilterMin filterMax: wMsgFilterMax flags: wRemoveMsg		&lt;C: BOOL PeekMessageW(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Window Messages">ShowWindow: hWnd as: nCmdShow		&lt;C: BOOL ShowWindow(HWND hWnd, int nCmdShow)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Window Messages">TranslateMessage: lpMsg		&lt;C: BOOL TranslateMessage(const LPMSG lpMsg)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Window Messages">UpdateWindow: hWnd		&lt;C: BOOL UpdateWindow(HWND hWnd)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Win32SystemSupport</name><environment>OS</environment><super>OS.OSSystemSupport</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.Win32SystemSupportDictionary.*			</imports><category>OS-Support</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>kernel32.dll</item> <item>gdi32.dll</item> <item>advapi32.dll</item> <item>user32.dll</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>OS-PC</package></attributes></class><class><name>Window</name><environment>Graphics</environment><super>Graphics.DisplaySurface</super><private>false</private><indexed-type>none</indexed-type><inst-vars>inputOrigin creationOrigin sensor iconic windowType effectiveWindowType statusLineHeight allowsStatusLine mapped eventHandlers windowManager </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Window System</category><attributes><package>OS-Window System</package></attributes></class><class><name>EmergencyWindow</name><environment>UI</environment><super>Graphics.Window</super><private>false</private><indexed-type>none</indexed-type><inst-vars>helpText commandStream leftMargin lastBottom inputLineTop </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Window System</category><attributes><package>OS-Window System</package></attributes></class><class><name>NullWindowManager</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Framework</category><attributes><package>Interface-Framework</package></attributes></class><class><name>InputState</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>x y bitState shiftState ctrlState commandKeyState metaState metaKeyState altKeyState lastClickTimestamp eventDispatcher lastDownPoint lastUpPoint lastUpButton lastWindow keyCaptureBlock isMouseHidden enforceNativeGrabbing </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Window System</category><attributes><package>OS-Window System</package></attributes></class><class><name>Event</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>time initiator window wasHandled </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Events</category><attributes><package>Interface-Events</package></attributes></class><class><name>EventQueue</name><environment>UI</environment><super>Core.SharedQueue</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Events-Support</category><attributes><package>Interface-Events-Support</package></attributes></class><class><name>WindowManager</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>windows activeController interruptLock outstandingMetaOrDamage openInProgress eventQueue baseProcess dontFilterEvents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Framework</category><attributes><package>Interface-Framework</package></attributes></class><class><name>ExposeEvent</name><environment>UI</environment><super>UI.ResizeEvent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>buttonNumber </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Events</category><attributes><package>Interface-Events</package></attributes></class><class><name>EventSensor</name><environment>UI</environment><super>UI.ApplicationWindowSensor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>collapseEvents queueLocked </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Events-Support</category><attributes><package>Interface-Events-Support</package></attributes></class></st-source>