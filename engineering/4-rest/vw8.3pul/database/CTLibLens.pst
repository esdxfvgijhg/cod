<?xml version="1.0"?><st-source><!-- Name: CTLibLensNotice: Copyright 1999-2013 Cincom Systems, Inc.  All rights reserved.Comment: The Lens provides high-level facilities that simplify the task of database access from VisualWorks.  Used in concert with the Lens-Runtime and CTLibEXDI parcel,  this parcel (CTLibLens) provides the facilities to use the Lens on a Sybase Open Client relational database (CTLib).Further information on the EXDI and Lens can be found in the "VisualWorks Database Connect Developer's Guide" (the file dbadg.pdf located in the doc subdirectory of the VisualWorks installation). DbIdentifier: bear73DbTrace: 403643DbUsername: dwallenDbVersion: 7 - 1.3DevelopmentPrerequisites: #(#(#any 'Lens-Runtime' '') #(#any 'CTLibEXDI' ''))PackageName: CTLibLensParcel: #('CTLibLens')ParcelName: CTLibLensPrerequisiteParcels: #(#('Lens-Runtime' '') #('CTLibEXDI' ''))PrintStringCache: (7 - 1.3,dwallen)Version: 7 - 1.3Date: 10:43:37 AM April 19, 2013 --><time-stamp>From VisualWorksÂ®, Pre-Release 7.10 (apr13.3) of April 19, 2013 on April 19, 2013 at 10:43:37 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>CTLibPkeys</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tableQualifier tableOwner tableName columnName keySeq </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-CTLib</category><attributes><package>CTLibLens</package></attributes></class><comment><class-id>CTLibPkeys</class-id><body>This class is private to the implementation of the ObjectLens.  Users should not use this class directly and should not subclass it.The instance variables are populated by the 'sp_pkeys' catalog procedure.Instance variables:	tableQualifier	&lt;String&gt;  The table qualifier	tableOwner	&lt;String&gt;  The table's owner	tableName	&lt;String&gt;  The table name	columnName	&lt;String&gt;  The name of the column	keySeq	&lt;SmallInteger&gt;  The sequence number of the column in the key</body></comment><class><name>CTLibTable</name><environment>Smalltalk</environment><super>Lens.LensDatabaseTable</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tableQualifier tableOwner tableName tableType columns </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-CTLib</category><attributes><package>CTLibLens</package></attributes></class><comment><class-id>CTLibTable</class-id><body>This class is private to the implementation of the ObjectLens.  Users should not use this class directly and should not subclass it.CTLibTable instances represent a table in a SYBASE database.Instance Variables:	tableQualifier	&lt;String | nil&gt;		The database name of the table.  If the table is to be used		without qualification, then this field is nil.	tableOwner	&lt;String | nil&gt;		The name of the owner of the table.  If the table is to be used		without qualification, then this field is nil.	tableName &lt;String&gt;		the table's name	tableType &lt;String&gt;		encodes the type of table (database-specific)	columns &lt;IdentitySet of: LensDatabaseTableColumn&gt;		the set of columns defined on the table</body></comment><class><name>CTLibTransporter</name><environment>Smalltalk</environment><super>Lens.LensSQLTransporter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-CTLib</category><attributes><package>CTLibLens</package></attributes></class><comment><class-id>CTLibTransporter</class-id><body>This class is private to the implementation of the ObjectLens.  Users should not use this class directly and should not subclass it.</body></comment><class><name>CTLibFkeys</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pktableQualifier pktableOwner pktableName pkcolumnName fktableQualifier fktableOwner fktableName fkcolumnName keySeq </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-CTLib</category><attributes><package>CTLibLens</package></attributes></class><comment><class-id>CTLibFkeys</class-id><body>This class is private to the implementation of the ObjectLens.  Users should not use this class directly and should not subclass it.The instance variables are populated via the 'sp_fkeys' catalog procedure.Instance variables:	pktableQualifier	&lt;String&gt;  The primary key table qualifier	pktableOwner	&lt;String&gt;  The primary key table owner	pktableName	&lt;String&gt;  The primary key table name	pkcolumnName	&lt;String&gt; The primary key column name	fktableQualifier	&lt;String&gt;  The foreign key table qualifier	fktableOwner	&lt;String&gt;  The foreign key table owner	fktableName	&lt;String&gt;  The foreign key table name	fkcolumnName	&lt;String&gt;  The foreign key column name	keySeq	&lt;SmallInteger&gt;  The sequence of the column within the primary key</body></comment><class><name>CTLibTableColumn</name><environment>Smalltalk</environment><super>Lens.LensDatabaseTableColumn</super><private>false</private><indexed-type>none</indexed-type><inst-vars>table columnName odbcTypeCode typeName dataPrecision length numericScale numericRadix nullable remarks dataType </inst-vars><class-inst-vars>typeMap </class-inst-vars><imports></imports><category>Lens-Private-CTLib</category><attributes><package>CTLibLens</package></attributes></class><comment><class-id>CTLibTableColumn</class-id><body>This class is private to the implementation of the ObjectLens.  Users should not use this class directly and should not subclass it.The instance variables below, with the exception of colid, are filled in by executing the 'sp_columns' catalog procedure.Instance Variables:	table	&lt;LensDatabaseTable&gt;  the table containing the column	columnName	&lt;String&gt;  the column's name	odbcTypeCode	&lt;Integer&gt;  the ODBC type code for the column	typeName	&lt;String&gt;  data-source dependent data type name (assumption: they match those from the SQLServer)	dataPrecision	&lt;SmallInteger&gt;  the column's precision, if the column is numeric.  the number of characters in the column otherwise	length	&lt;SmallInteger&gt;  the number of bytes required for storage or transfer across the api	numericScale	&lt;SmallInteger&gt;  the column's scale, if the column is numeric	numericRadix	&lt;SmallInteger&gt;  the column's radix, if the column is numeric (typically 10 or 2)	nullable	&lt;SmallInteger&gt;  1 if the column may contain nil, 0 if the column may not contain nil, 2 if the sp_columns procedure didn't know (interpreted as 0)	remarks	&lt;String&gt;  a description of the column	ssDataType	&lt;SmallInteger&gt;  the SQL-Server data type code	dataType	&lt;SmallInteger&gt;  the name of the data type of the column (in a database-specific encoding)Class instance variables:	typeMap	&lt;IdentityDictionary&gt;  Maps sybase type codes to type names</body></comment><class><name>CTLibContext</name><environment>Smalltalk</environment><super>Lens.LensDatabaseContext</super><private>false</private><indexed-type>none</indexed-type><inst-vars>databaseName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-CTLib</category><attributes><package>CTLibLens</package></attributes></class><comment><class-id>CTLibContext</class-id><body>This class is private to the implementation of the ObjectLens.  Users should not use this class directly and should not subclass it.Instance variables:	databaseName	&lt;String&gt;  The name of the database</body></comment><methods><class-id>CTLibPkeys</class-id> <category>accessing</category><body package="CTLibLens">columnName	"Answer the receiver's columnName."	^columnName</body><body package="CTLibLens">keySeq	"Answer the receiver's keySeq."	^keySeq</body><body package="CTLibLens">tableName	"Answer the receiver's tableName."	^tableName</body><body package="CTLibLens">tableOwner	"Answer the receiver's tableOwner."	^tableOwner</body><body package="CTLibLens">tableQualifier	"Answer the receiver's tableQualifier."	^tableQualifier</body></methods><methods><class-id>CTLibTable</class-id> <category>qualifications</category><body package="CTLibLens">qualify: ldm	self owner: ldm databaseContext username.	self qualifier: ldm databaseContext databaseName</body><body package="CTLibLens">unqualify	self owner: nil.	self qualifier: nil</body></methods><methods><class-id>CTLibTable</class-id> <category>accessing</category><body package="CTLibLens">columns	"Answer the receiver's columns."	| lens qryTextStream cols colsAccessor ldm |	(self privateColumns notNil or: [(lens := self lensSession) isNil]) ifTrue:		[ ^self privateColumns ].	"Construct the stored procedure invocation to be used."	(qryTextStream := String new writeStream)		nextPutAll: 'execute sp_columns @table_name="';		nextPutAll: self name;		nextPut: $".	(self owner notNil and: [ self owner isEmpty not ]) ifTrue:		[ qryTextStream			nextPutAll: ', @table_owner="';			nextPutAll: self owner;			nextPut: $" ].	(self qualifier notNil and: [ self qualifier isEmpty not ]) ifTrue:		[ qryTextStream			nextPutAll: ', @table_qualifier="';			nextPutAll: self qualifier;			nextPut: $" ].	"Gather the table object we're looking for."	CTLibConnection unableToExecuteSQLSignal		handle:			[ :ex |			cols := Array new: 0.			ex return ]		do:			[ colsAccessor := (lens containerOf: (ldm := lens dataModel) databaseContext class tableColumnClass) operationAccessor.			colsAccessor operation alternateSQL: qryTextStream contents.			cols := colsAccessor values ].	self columns: cols.	"nil out widths of all fixed-size columns"	self privateColumns do:		[ :column |		(ldm fieldTypeForColumn: column) isVariableSize ifFalse:			[ column maxColumnConstraint: nil ]].	^cols</body><body package="CTLibLens">columns: newColumns	"Set the receiver's columns to newColumns."	columns := newColumns</body><body package="CTLibLens">name	"Answer the receiver's name."	^tableName</body><body package="CTLibLens">name: newName	"Set the receiver's name to newName."	tableName := newName</body><body package="CTLibLens">owner	"Answer the receiver's owner."	^tableOwner</body><body package="CTLibLens">owner: aString	"Set the receiver's owner."	tableOwner := aString</body><body package="CTLibLens">qualifier	"Answer the second level of name qualification (scoped outside of owner)."	^tableQualifier</body><body package="CTLibLens">qualifier: aString	"Set the receiver's qualifier."	tableQualifier := aString</body><body package="CTLibLens">tableType	"Answer the receiver's tableType."	^tableType</body></methods><methods><class-id>CTLibTable</class-id> <category>key detection</category><body package="CTLibLens">getPrimaryKeyIn: aLensSession	"Answer the primary key for this table by looking it up in the database catalogs.  Answer an instance of LensTableKey or nil."	| qryTextStream keysAccessor keyCols |	"Construct the stored procedure invocation to be used."	(qryTextStream := String new writeStream)		nextPutAll: 'execute sp_pkeys @table_name="';		nextPutAll: self name;		nextPut: $".	(self owner notNil and: [self owner isEmpty not]) ifTrue:		[ qryTextStream			nextPutAll: ', @table_owner="';			nextPutAll: self owner;			nextPut: $" ].	(self qualifier notNil and: [self qualifier isEmpty not]) ifTrue:		[ qryTextStream			nextPutAll: ', @table_qualifier="';			nextPutAll: self qualifier;			nextPut: $" ].	"Execute the stored procedure and capture the results."	CTLibConnection unableToExecuteSQLSignal		handle:			[ :ex |			keyCols := Array new: 0.			ex return ]		do:			[ keysAccessor := (aLensSession containerOf: CTLibPkeys) operationAccessor.			keysAccessor operation alternateSQL: qryTextStream contents.			keyCols := keysAccessor values ].	keyCols isEmpty ifFalse:		[ "We found a valid primary key, make a LensTableKey to hold it."		| tabCols |		tabCols := keyCols collect:					[ :pkey |					self columns detect: [ :each | each name = pkey columnName ] ] .		^LensTableKey table: self columns: tabCols keyType: #primary ].	^nil</body><body package="CTLibLens">inferReferencesIn: aLensSession	"We use tables also as non-persistent objects, therefore, aLensSession is passed	to this method and the table's own lens is not used (if it even had one). This method	returns a collection with arrays representing references from the table to other tables"	| qryTextStream fkeysAccessor fkeys res allParts fkeysStream |	"Construct the stored procedure invocation to be used."	(qryTextStream := String new writeStream)		nextPutAll: 'execute sp_fkeys @fktable_name="';		nextPutAll: self name;		nextPut: $".	(self owner notNil and: [self owner isEmpty not]) ifTrue:		[ qryTextStream			nextPutAll: ', @fktable_owner="';			nextPutAll: self owner;			nextPut: $" ].	(self qualifier notNil and: [self qualifier isEmpty not]) ifTrue:		[ qryTextStream			nextPutAll: ', @fktable_qualifier="';			nextPutAll: self qualifier;			nextPut: $" ].	"Gather all of the column references for any foreign key from this table."	CTLibConnection unableToExecuteSQLSignal		handle:			[ :ex |			fkeys := Array new: 0.			ex return ]		do:			[ fkeysAccessor := (aLensSession containerOf: CTLibFkeys) operationAccessor.			fkeysAccessor operation alternateSQL: qryTextStream contents.			fkeys := fkeysAccessor values ].	res := OrderedCollection new.	fkeysStream := fkeys readStream.	[fkeysStream atEnd] whileFalse:		[ | seq |		"The stored procedure gives them back in order so we just need to find the break points."		allParts := OrderedCollection new.		seq := 0.		[fkeysStream atEnd not and: [ seq &lt; fkeysStream peek keySeq ]] whileTrue:			[ seq := (allParts add: fkeysStream next) keySeq ].		res add: (Array				with: self				with: (allParts collect: [ :fkey | fkey fkcolumnName ])				with: (allParts at: 1) pkTableNameArray) ].	^res</body></methods><methods><class-id>CTLibTable</class-id> <category>private-accessing</category><body package="CTLibLens">privateColumns	"Answer the contents of the  instance variable which holds the receiver's columns."	^columns</body></methods><methods><class-id>CTLibTable</class-id> <category>printing</category><body package="CTLibLens">printNameOn: aStream	| emitOwnerSeparator |	emitOwnerSeparator := false.	(self qualifier notNil and: [self qualifier isEmpty not]) ifTrue:		[ aStream			nextPutAll: self qualifier;			nextPut: $..		emitOwnerSeparator := true ].	(self owner notNil and: [self owner isEmpty not]) ifTrue:		[ aStream nextPutAll: self owner.		emitOwnerSeparator := true ].	emitOwnerSeparator ifTrue:		[ aStream nextPut: $.. ].	aStream nextPutAll: self name</body></methods><methods><class-id>CTLibTable</class-id> <category>DDL generation</category><body package="CTLibLens">alterColumnCommand: column operation: operation	"Answer a command to add a column to a table."	| stream |	operation == #add		ifTrue: [			stream := WriteStream on: String new.			stream nextPutAll: 'alter table ', self qualifiedName.			stream nextPutAll: ' add '.			column putDefinitionOn: stream.			^stream contents]		ifFalse: [			LensSession complain: (							(#cannotAlterExistingColumns &lt;&lt; #sybaseDB &gt;&gt; 'SYBASE databases do not support altering existing&lt;n&gt;database columns to conform to data model columns.&lt;n&gt;Please use the Data Modeler to make the database&lt;n&gt;and model columns compatible, or drop the table.&lt;n&gt;Then restart installation.' ) expandMacros )]</body><body package="CTLibLens">removeFrom: container	"Remove table represented by receiver."	container lensSession connection doCommandString: 'drop table ' , self qualifiedName</body></methods><methods><class-id>CTLibTable</class-id> <category>testing</category><body package="CTLibLens">isReferredToBy: tableNameArray	"Answer whether tableNameArray contains a viable reference to this table.  The tableNameArray is composed of name elements ordered from the RIGHT to left in a qualification order (i.e. the simple name comes first and then any qualification)."	| temp1 temp2 |	^(super isReferredToBy: tableNameArray)	and: [ tableNameArray size &lt; 3		or: [ (temp1 := self qualifier) isNil		or: [ temp1 isEmpty		or: [ (temp2 := tableNameArray at: 3) isNil		or: [ temp1 = temp2 ] ] ] ] ]</body></methods><methods><class-id>CTLibTable class</class-id> <category>accessing</category><body package="CTLibLens">contextClass	"Answer the name of the class which provides database context."	^CTLibContext</body></methods><methods><class-id>CTLibTable class</class-id> <category>private</category><body package="CTLibLens">encodedAspects	^#(#owner)</body></methods><methods><class-id>CTLibTransporter</class-id> <category>clause generation</category><body package="CTLibLens">generateExpressionFor: surrogate	"Generate an SQL expression for condition, and put it on commandStream."	surrogate IsOperationSurrogate ifTrue: [		| op |		op := surrogate Operator.		(#(StandardDeviation Variance) includes: op) ifTrue: [			LensContainer invalidAggregateFunctionSignal				raiseWith: (Array with: lensContainer with: op)]].	^super generateExpressionFor: surrogate</body><body package="CTLibLens">generateFromClauseLocking: flag	"Generate the FROM clause. If there is more than one referenced table then	emit aliases for the tables"	| useAlias |	useAlias := referencedObjectSurrogates size &gt; 1.	commandStream nextPutAll: ' FROM '.	referencedObjectSurrogates do: [:surrog |		commandStream nextPutAll: surrog Type tableName.		useAlias ifTrue: [			commandStream				nextPut: $ ;				nextPutAll: (self tableNameFor: surrog)].		(session checkLocking: flag) ifTrue: [			commandStream nextPutAll: ' HOLDLOCK'].		commandStream nextPut: $,].	commandStream skip: -1.</body></methods><methods><class-id>CTLibTransporter</class-id> <category>registration</category><body package="CTLibLens">nextVariableName	"Answer a name to be used for the next variable being created."	^ ':' , (variableIndex := variableIndex + 1) printString</body></methods><methods><class-id>CTLibTransporter class</class-id> <category>class initialization</category><body package="CTLibLens">initialize	"CTLibTransporter initialize"	super initialize</body><body package="CTLibLens">initializeFunctionsTable	"CTLibTransporter initializeFunctionsTable"	| dict |	super initializeFunctionsTable.	dict := functions at: #Number.	dict at: #abs put: 'ABS'.	dict at: #ceil put: 'CEILING'.	dict at: #floor put: 'FLOOR'.	dict at: #power: put: 'POWER'.	dict at: #round: put: 'ROUND'.	dict at: #sign put: 'SIGN'.	dict at: #sqrt put: 'SQRT'.	dict at: #cos put: 'COS'.	dict at: #exp put: 'EXP'.	dict at: #ln put: 'LOG'.	dict at: #sin put: 'SIN'.	dict at: #tan put: 'TAN'.	dict := functions at: #Character.	dict at: #ascii put: 'ASCII'.	dict at: #length put: 'DATALENGTH'.	dict at: #lower put: 'LOWER'.	dict at: #soundex put: 'SOUNDEX'.	dict at: #substringAt:length: put: 'SUBSTRING'.	dict at: #upper put: 'UPPER'.	dict := functions at: #Date.	dict := functions at: #Conversion.	dict at: #toChar put: 'STR'.	dict at: #toChar: put: 'STR'.</body></methods><methods><class-id>CTLibFkeys</class-id> <category>accessing</category><body package="CTLibLens">fkcolumnName	"Answer the receiver's fkcolumnName."	^fkcolumnName</body><body package="CTLibLens">fktableName	"Answer the receiver's fktableName."	^fktableName</body><body package="CTLibLens">fktableOwner	"Answer the receiver's fktableOwner."	^fktableOwner</body><body package="CTLibLens">fktableQualifier	"Answer the receiver's fktableQualifier."	^fktableQualifier</body><body package="CTLibLens">keySeq	"Answer the receiver's keySeq."	^keySeq</body><body package="CTLibLens">pkcolumnName	"Answer the receiver's pkcolumnName."	^pkcolumnName</body><body package="CTLibLens">pktableName	"Answer the receiver's pktableName."	^pktableName</body><body package="CTLibLens">pktableOwner	"Answer the receiver's pktableOwner."	^pktableOwner</body><body package="CTLibLens">pktableQualifier	"Answer the receiver's pktableQualifier."	^pktableQualifier</body></methods><methods><class-id>CTLibFkeys</class-id> <category>private</category><body package="CTLibLens">pkTableNameArray	"Construct a 1-3 element array with the pktableName, pkownerName, and pkqualifierName."	| elems |	elems := OrderedCollection new: 3.	elems add: self pktableName.	(self pktableOwner notNil and: [self pktableOwner isEmpty not]) ifTrue:		[ elems add: self pktableOwner ].	(self pktableQualifier notNil and: [self pktableQualifier isEmpty not]) ifTrue:		[ elems size &lt; 2 ifTrue: [ elems add: self pktableOwner ].		elems add: self pktableQualifier ].	^elems</body></methods><methods><class-id>CTLibTableColumn</class-id> <category>accessing</category><body package="CTLibLens">dataType	"Answer the receiver's dataType."	^dataType</body><body package="CTLibLens">dataType: newDataType	"Set the receiver's dataType to newDataType.	'bit' variables can not be null in SYBASE"	dataType := newDataType.	dataType = 'bit' ifTrue: [self isNotNil: true].</body><body package="CTLibLens">isNotNil	"Answer whether the column described by the receiver cannot store nulls."	^nullable = 0 or: [ nullable == 2 ]</body><body package="CTLibLens">isNotNil: aBoolean	"Set the receiver's isNotNil.	'bit' variables can not be null in SYBASE"	nullable := aBoolean ifTrue: [0] ifFalse: [1].	self dataType = 'bit' ifTrue: [ nullable := 0 ].</body><body package="CTLibLens">maxColumnConstraint	"Answer the receiver's maxColumnConstraint."	^dataPrecision</body><body package="CTLibLens">maxColumnConstraint: newWidth	"Set the receiver's maxColumnConstraint to newWidth."	dataPrecision := newWidth</body><body package="CTLibLens">name	"Answer the receiver's name."	^columnName</body><body package="CTLibLens">name: newName	"Set the receiver's name to newName."	columnName := newName</body><body package="CTLibLens">scale	"Answer the receiver's scale."	^numericScale</body><body package="CTLibLens">scale: newScale	"Set the receiver's scale to newScale."	numericScale := newScale</body><body package="CTLibLens">table	"Answer the receiver's table."	^table</body><body package="CTLibLens">table: newTable	"Set the receiver's table to newTable."	table := newTable</body></methods><methods><class-id>CTLibTableColumn</class-id> <category>private</category><body package="CTLibLens">deriveBaseDataType	"The typeName field must be a user type and so we need to infer the underlying type name to use."	| typeToUse |	"Attempt to translate just by looking up the type code.  If unrecognized, punt."	typeToUse := self class typeMap at: odbcTypeCode ifAbsent: [ ^nil ].	"Check to see which kind of integer we've got."	typeToUse = 'int' ifTrue:		[ length == 2 ifTrue: [ ^'smallint' ].		length == 1 ifTrue: [ ^'tinyint' ].		^typeToUse ].	"Check to see which kind of floating point number we've got."	typeToUse = 'float' ifTrue:		[ length == 4 ifTrue:	[ ^'real' ].		^typeToUse ].	"Check to see which kind of money we've got."	typeToUse = 'money' ifTrue:		[ length == 4 ifTrue:	[ ^'smallmoney' ].		^typeToUse ].	"Check to see which kind of datetime we've got."	typeToUse = 'datetime' ifTrue:		[ length == 4 ifTrue:	[ ^'smalldatetime' ].		^typeToUse ].	^typeToUse</body></methods><methods><class-id>CTLibTableColumn</class-id> <category>initialize-release</category><body package="CTLibLens">postFetchInitialize: ignored	"Decode dataType and zero out width if dataType is long."	| dtm |	"If the dbms gave us a recognizable type name, use it.	Otherwise, derive from the odbcTypeCode field."	dtm := self class contextClass dataTypeMappings		detect:	[ :m | m columnType = typeName ]		ifNone:	[ nil ].	self dataType: (dtm notNil		ifTrue:	[ dtm columnType ]		ifFalse:	[ self deriveBaseDataType ]).	(#('image' 'text') includes: self dataType) ifTrue:		[ self maxColumnConstraint: self defaultBLOBSize ]</body></methods><methods><class-id>CTLibTableColumn class</class-id> <category>class initialization</category><body package="CTLibLens">initialize	"Initialize the class"	"CTLibTableColumn initialize"	self initializeTypeMap</body><body package="CTLibLens">initializeTypeMap	"Initialize the map from type code to type name.  The codes in this table are those returned for	the data_type by the stored procedure sp_columns."	typeMap := IdentityDictionary new.	typeMap		at: 1 put: 'char';		at: 2 put: 'numeric';		at: 3 put: 'money';		at: 4 put: 'int';		at: 5 put: 'smallint';		at: 6 put: 'float';		at: 7 put: 'real';		at: 8 put: 'float';		at: 11 put: 'datetime';		at: 12 put: 'varchar';		at: -1 put: 'text';		at: -2 put: 'binary';		at: -3 put: 'varbinary';		at: -4 put: 'image';		at: -6 put: 'tinyint';		at: -7 put: 'bit'</body></methods><methods><class-id>CTLibTableColumn class</class-id> <category>private</category><body package="CTLibLens">encodedAspects	^#(#name #dataType #maxColumnConstraint #scale		#(#pickledIsNotNil #isNotNil:) )</body></methods><methods><class-id>CTLibTableColumn class</class-id> <category>accessing</category><body package="CTLibLens">contextClass	"Answer the name of the class which provides database context."	^CTLibContext</body><body package="CTLibLens">typeMap	^typeMap</body></methods><methods><class-id>CTLibContext</class-id> <category>private</category><body package="CTLibLens">isColumn: c1 theSameAs: c2	"Since sybase is case-sensitive we compare using ="	^c1 name = c2 name</body></methods><methods><class-id>CTLibContext</class-id> <category>accessing</category><body package="CTLibLens">copyParametersFrom: dbc2	"Copy only the editable parameters of the context."	super copyParametersFrom: dbc2.	self databaseName: dbc2 databaseName</body><body package="CTLibLens">databaseName	"Answer the receiver's databaseName."	^databaseName</body><body package="CTLibLens">databaseName: newName	"Set the receiver's databaseName to newName."	databaseName := newName</body></methods><methods><class-id>CTLibContext</class-id> <category>printing</category><body package="CTLibLens">displayString	| strm |	strm := String new writeStream.	strm		nextPutAll: 'CTLib: '.	username isEmpty not		ifTrue:			[strm				nextPutAll: username].	environment isEmpty not		ifTrue:			[strm				nextPut: Character space;				nextPutAll: environment].	databaseName isEmpty not		ifTrue:			[strm				nextPut: Character space;				nextPutAll: databaseName].	^strm contents</body><body package="CTLibLens">printOn: stream	| elaborated |	elaborated := false.	super printOn: stream.	(username isNil or: [username isEmpty])		ifFalse:			[elaborated := true.			stream				nextPut: $(;				nextPutAll: 'user=';				nextPutAll: username;				nextPut: Character space].	(databaseName isNil or: [databaseName isEmpty])		ifFalse:			[elaborated				ifFalse: [stream nextPut: $(].			stream				nextPutAll: 'db=';				nextPutAll: databaseName;				nextPut: Character space].	elaborated		ifTrue:			[stream skip: -1.			stream nextPut: $)]</body></methods><methods><class-id>CTLibContext</class-id> <category>connection</category><body package="CTLibLens">postConnectIn: aLensSession	"Give the LensDatabaseContext a chance to get control after the connect but before any database access is performed."	| dbName |	((dbName := self databaseName) notNil and: [dbName isEmpty not]) ifTrue:		[ aLensSession connection			doCommandString: 'use ', self databaseName ]</body></methods><methods><class-id>CTLibContext</class-id> <category>initialize-release</category><body package="CTLibLens">initialize	super initialize.	databaseName := ''.</body></methods><methods><class-id>CTLibContext</class-id> <category>data dictionary manipulation</category><body package="CTLibLens">definePrimaryKeyFor: type in: aLensSession	"Define the primary key for type in aLensSession.  It's OK if it already exists."	| definition idv |	self class == (self class environment at: #CTLib10Context ifAbsent: [nil]) ifTrue:		[ "CTLib System 10 does it the standard way."		^super definePrimaryKeyFor: type in: aLensSession ].	"Special handling for CTLib 4.x servers."	definition := WriteStream on: String new.	definition		nextPutAll: 'execute sp_primarykey ';		print: type table qualifiedName.	idv := type idVariable.	idv forLeavesDo:		[:v |		definition			nextPutAll: ', ';			print: v column name ].	aLensSession connection doCommandString: definition contents</body><body package="CTLibLens">getTableNamed: tableName in: aLens	"Answer the table named tableName from the data dictionary.  tableName may	contain an owner to qualify the table name."	| criteria qryTextStream tables tablesAccessor |	"Construct the stored procedure invocation to be used."	criteria := self separateNameQualification: tableName.	(qryTextStream := String new writeStream)		nextPutAll: 'execute sp_tables @table_name="';		nextPutAll: (criteria at: 1);		nextPut: $".	(criteria size &gt; 1 and: [(criteria at: 2) notNil and: [ (criteria at: 2) isEmpty not ]]) ifTrue:		[ qryTextStream			nextPutAll: ', @table_owner="';			nextPutAll: (criteria at: 2);			nextPut: $" ].	(criteria size &gt; 2 and: [(criteria at: 3) notNil and: [ (criteria at: 3) isEmpty not ]]) ifTrue:		[ qryTextStream			nextPutAll: ', @table_qualifier="';			nextPutAll: (criteria at: 3);			nextPut: $" ].	qryTextStream		nextPutAll: ', @table_type = "''TABLE'', ''SYSTEM TABLE'', ''VIEW''"'.	"Gather the table object we're looking for."	self class connectionClass unableToExecuteSQLSignal		handle:			[ :ex |			tables := Array new: 0.			ex return ]		do:			[ tablesAccessor := (aLens containerOf: self class tableClass) operationAccessor.			tablesAccessor operation alternateSQL: qryTextStream contents.			tables := tablesAccessor values ].	^tables isEmpty		ifTrue:	[ nil ]		ifFalse:	[ tables at: 1 ]</body><body package="CTLibLens">listTablesLike: aPattern in: aLens	"Answer a collection of tables which are accessible using aLens.	If aPattern is not nil, limit the search to only those tables with names matching."	| criteria qryTextStream tables tablesAccessor |	"Construct the stored procedure invocation to be used."	criteria := self separateNameQualification: aPattern.	(qryTextStream := String new writeStream)		nextPutAll: 'execute sp_tables @table_name="';		nextPutAll: ((criteria at: 1) copyReplaceAll: '*' with: '%');		nextPut: $".	(criteria size &gt; 1 and: [(criteria at: 2) notNil and: [ (criteria at: 2) isEmpty not ]]) ifTrue:		[ qryTextStream			nextPutAll: ', @table_owner="';			nextPutAll: ((criteria at: 2) copyReplaceAll: '*' with: '%');			nextPut: $" ].	(criteria size &gt; 2 and: [(criteria at: 3) notNil and: [ (criteria at: 3) isEmpty not ]]) ifTrue:		[ qryTextStream			nextPutAll: ', @table_qualifier="';			nextPutAll: (criteria at: 3);			nextPut: $" ].	qryTextStream		nextPutAll: ', @table_type = "''TABLE'', ''SYSTEM TABLE'', ''VIEW''"'.	"Gather the table object we're looking for."	self class connectionClass unableToExecuteSQLSignal		handle:			[ :ex |			tables := Array new: 0.			ex return ]		do:			[ tablesAccessor := (aLens containerOf: self class tableClass) operationAccessor.			tablesAccessor operation alternateSQL: qryTextStream contents.			tables := tablesAccessor values ].	^(tables asSortedCollection: [ :before :after | before owner &lt; after owner or: [ before owner = after owner and: [ before name &lt;= after name ] ] ]) asArray</body></methods><methods><class-id>CTLibContext</class-id> <category>testing</category><body package="CTLibLens">isCTLib	"Answer whether receiver is a CTLib context."	^true</body></methods><methods><class-id>CTLibContext class</class-id> <category>accessing</category><body package="CTLibLens">connectionClass	"Answer the class of connections opened by instances of self."	^(self environment at: #CTLibConnection ifAbsent: [nil])</body><body package="CTLibLens">kind	"Answer user-friendly label for receiver."	^#'SYBASE-CTLib'</body><body package="CTLibLens">tableClass	"Answer the class of tables for the receiver."	^CTLibTable</body><body package="CTLibLens">tableColumnClass	"Answer the class of table columns in receiver's data dictionary."	^CTLibTableColumn</body><body package="CTLibLens">transporterClass	"Answer the class of transporters via which to dynamically access the	receiver's associated database."	^CTLibTransporter</body></methods><methods><class-id>CTLibContext class</class-id> <category>class initialization</category><body package="CTLibLens">initialize	"Initialize class instance variables."	"CTLibContext initialize"	shortSize := 255.	maxColumnSize := SmallInteger maxVal.	maxNameSize := 30.	(transactionPolicies := IdentitySet new)		add: #PessimisticRR.	self initializeBasicTypes.	dataTypeMappings := OrderedCollection new.	(self mapFieldOf: #String to: 'varchar') maxSize: shortSize.	(self mapFieldOf: #String to: 'char') maxSize: shortSize.	(self mapFieldOf: #String to: 'text') maxSize: maxColumnSize; makeLong.	(self mapFieldOf: #ByteArray to: 'varbinary') maxSize: shortSize.	(self mapFieldOf: #ByteArray to: 'binary') maxSize: shortSize.	(self mapFieldOf: #ByteArray to: 'image') maxSize: maxColumnSize; makeLong.	(self mapFieldOf: #Integer to: 'int').	(self mapFieldOf: #Integer to: 'smallint').	(self mapFieldOf: #Integer to: 'tinyint').	(self mapFieldOf: #Float to: 'real').	(self mapFieldOf: #Double to: 'float').	(self mapFieldOf: #SerialNumber to: 'int').	(self mapFieldOf: #Timestamp to: 'datetime').	(self mapFieldOf: #Timestamp to: 'smalldatetime').	(self mapFieldOf: #Boolean to: 'bit').	(self mapFieldOf: #FixedPoint to: 'money').	(self mapFieldOf: #FixedPoint to: 'smallmoney').	(self mapFieldOf: #FixedPoint to: 'numeric').	(self mapFieldOf: #FixedPoint to: 'decimal').	reservedWords := #('add' 'all' 'alter' 'and' 'any' 'as' 'asc' 'avg' 'begin' 'between' 'break' 'browse' 'bulk' 'by' 'checkpoint' 'clustered' 'commit' 'compute' 'confirm' 'continue' 'controlrow' 'convert' 'count' 'create' 'database' 'dbcc' 'declare' 'default' 'delete' 'desc' 'disk' 'distinct' 'drop' 'dummy' 'dump' 'else' 'end' 'errlvl' 'errexit' 'except' 'exec' 'execute' 'exists' 'exit' 'fillfactor' 'for' 'from' 'goto' 'grant' 'group' 'having' 'holdlock' 'if' 'in' 'index' 'insert' 'intersect' 'into' 'is' 'kill' 'like' 'lineno' 'load' 'max' 'min' 'mirrorexit' 'nonclustered' 'not' 'null' 'off' 'offsets' 'on' 'once' 'or' 'order' 'over' 'perm' 'permanent' 'plan' 'prepare' 'print' 'proc' 'procedure' 'processexit' 'public' 'raiserror' 'readtext' 'reconfigure' 'return' 'revoke' 'rollback' 'rowcount' 'rule' 'save' 'select' 'set' 'setuser' 'shutdown' 'statistics' 'sum' 'syb_terminate' 'table' 'tape' 'temp' 'temporary' 'textsize' 'to' 'tran' 'transaction' 'trigger' 'truncate' 'tsequal' 'union' 'unique' 'update' 'use' 'values' 'view' 'waitfor' 'where' 'while' 'with' 'writetext').	self initializeCatalogDataModel.</body><body package="CTLibLens">initializeBasicTypes	"Initialize basicTypes"	"CTLibContext initializeBasicTypes"	super initializeBasicTypes.	self		addBasicType: (LensEncodedType new			memberClass: Symbol;			fieldType: (self typeNamed: #String);			encodeSelector: nil;			decodeSelector: #asSymbol)</body></methods><methods><class-id>CTLibContext class</class-id> <category>private</category><body package="CTLibLens">bindingsForInstance: aContext	"Returns a dictionary whose keys are symbols and values are valueModels. This Dictionary will be used to populate a bindings dictionary when aContext is edited in some ui (probably a dialog)"	| bin |	bin := super bindingsForInstance: aContext.	bin at: #databaseName put: ((AspectAdaptor forAspect: #databaseName)				subject: aContext).	^bin</body><body package="CTLibLens">encodedAspects	^#(#databaseName)</body><body package="CTLibLens">markedAsSystemClass	"This class not to be shown when browsing user classes."</body></methods><methods><class-id>CTLibContext class</class-id> <category>database specs</category><body package="CTLibLens">catalogDataModelSpec	"Answer a literal array encoding of the data model used to access the system catalog."	"LensEditor new openOnClass: self andSelector: #catalogDataModelSpec"	^#(#LensDataModel		#setDatabaseContext:		#(#CTLibContext			#username: ''			#environment: ''			#databaseName: '' )		#structureTypes: #(			#(#LensStructureType				#memberClass: #CTLibTable				#setVariables: #(					#(#LensStructureVariable						#name: 'tableQualifier'						#setValueType: #String						#fieldType: #String						#column:						#(#CTLibTableColumn							#name: 'tableQualifier'							#dataType: 'varchar'							#maxColumnConstraint: 32 )						#generatesAccessor: true						#generatesMutator: false						#isId: true						#privateIsMapped: true )					#(#LensStructureVariable						#name: 'tableOwner'						#setValueType: #String						#fieldType: #String						#column:						#(#CTLibTableColumn							#name: 'tableOwner'							#dataType: 'varchar'							#maxColumnConstraint: 32							#isNotNil: true )						#generatesAccessor: true						#generatesMutator: false						#isId: true						#privateIsMapped: true						#isNotNil: true )					#(#LensStructureVariable						#name: 'tableName'						#setValueType: #String						#fieldType: #String						#column:						#(#CTLibTableColumn							#name: 'tableName'							#dataType: 'varchar'							#maxColumnConstraint: 32							#isNotNil: true )						#generatesAccessor: true						#generatesMutator: false						#isId: true						#privateIsMapped: true						#isNotNil: true )					#(#LensStructureVariable						#name: 'tableType'						#setValueType: #String						#fieldType: #String						#column:						#(#CTLibTableColumn							#name: 'tableType'							#dataType: 'varchar'							#maxColumnConstraint: 32							#isNotNil: true )						#generatesAccessor: true						#generatesMutator: false						#privateIsMapped: true						#isNotNil: true )					#(#LensStructureVariable						#name: 'columns'						#setValueType: #Object						#fieldType: #Object						#generatesAccessor: false						#generatesMutator: false						#privateIsMapped: false ) )				#table:				#(#CTLibTable					#name: 'sp_tables' )				#defersPostingUpdates: true				#idVariable: #('tableQualifier' 'tableOwner' 'tableName' )				#idGeneratorType: #userDefinedId				#indexes: #() )			#(#LensStructureType				#memberClass: #CTLibTableColumn				#setVariables: #(					#(#LensStructureVariable						#name: 'table'						#setValueType: #CTLibTable						#fieldType:						#(#LensStructureType							#memberClass: #Array							#setVariables: #(								#(#LensStructureVariable									#name: 'tableQualifier'									#setValueType: #String									#fieldType: #String									#column:									#(#CTLibTableColumn										#name: 'tableQualifier'										#dataType: 'varchar'										#maxColumnConstraint: 32 )									#generatesAccessor: false									#generatesMutator: false									#isId: true									#privateIsMapped: true )								#(#LensStructureVariable									#name: 'tableOwner'									#setValueType: #String									#fieldType: #String									#column:									#(#CTLibTableColumn										#name: 'tableOwner'										#dataType: 'varchar'										#maxColumnConstraint: 32										#isNotNil: true )									#generatesAccessor: false									#generatesMutator: false									#isId: true									#privateIsMapped: true									#isNotNil: true )								#(#LensStructureVariable									#name: 'tableName'									#setValueType: #String									#fieldType: #String									#column:									#(#CTLibTableColumn										#name: 'tableName'										#dataType: 'varchar'										#maxColumnConstraint: 32										#isNotNil: true )									#generatesAccessor: false									#generatesMutator: false									#isId: true									#privateIsMapped: true									#isNotNil: true ) )							#table:							#(#CTLibTable								#name: 'sp_columns' )							#defersPostingUpdates: true							#indexes: #() )						#generatesAccessor: true						#generatesMutator: false						#isId: true						#privateIsMapped: true )					#(#LensStructureVariable						#name: 'columnName'						#setValueType: #String						#fieldType: #String						#column:						#(#CTLibTableColumn							#name: 'columnName'							#dataType: 'varchar'							#maxColumnConstraint: 32							#isNotNil: true )						#generatesAccessor: true						#generatesMutator: false						#isId: true						#privateIsMapped: true						#isNotNil: true )					#(#LensStructureVariable						#name: 'odbcTypeCode'						#setValueType: #Integer						#fieldType: #Integer						#column:						#(#CTLibTableColumn							#name: 'odbcTypeCode'							#dataType: 'smallint' )						#generatesAccessor: true						#generatesMutator: false						#privateIsMapped: true )					#(#LensStructureVariable						#name: 'typeName'						#setValueType: #String						#fieldType: #String						#column:						#(#CTLibTableColumn							#name: 'typeName'							#dataType: 'varchar'							#maxColumnConstraint: 32 )						#generatesAccessor: true						#generatesMutator: false						#privateIsMapped: true )					#(#LensStructureVariable						#name: 'dataPrecision'						#setValueType: #Integer						#fieldType: #Integer						#column:						#(#CTLibTableColumn							#name: 'dataPrecision'							#dataType: 'smallint' )						#generatesAccessor: true						#generatesMutator: false						#privateIsMapped: true )					#(#LensStructureVariable						#name: 'length'						#setValueType: #Integer						#fieldType: #Integer						#column:						#(#CTLibTableColumn							#name: 'length'							#dataType: 'int' )						#generatesAccessor: true						#generatesMutator: false						#privateIsMapped: true )					#(#LensStructureVariable						#name: 'numericScale'						#setValueType: #Integer						#fieldType: #Integer						#column:						#(#CTLibTableColumn							#name: 'numericScale'							#dataType: 'smallint' )						#generatesAccessor: true						#generatesMutator: false						#privateIsMapped: true )					#(#LensStructureVariable						#name: 'numericRadix'						#setValueType: #Integer						#fieldType: #Integer						#column:						#(#CTLibTableColumn							#name: 'numericRadix'							#dataType: 'smallint' )						#generatesAccessor: true						#generatesMutator: false						#privateIsMapped: true )					#(#LensStructureVariable						#name: 'nullable'						#setValueType: #Integer						#fieldType: #Integer						#column:						#(#CTLibTableColumn							#name: 'nullable'							#dataType: 'smallint' )						#generatesAccessor: true						#generatesMutator: false						#privateIsMapped: true )					#(#LensStructureVariable						#name: 'remarks'						#setValueType: #String						#fieldType: #String						#column:						#(#CTLibTableColumn							#name: 'remarks'							#dataType: 'varchar'							#maxColumnConstraint: 254 )						#generatesAccessor: true						#generatesMutator: false						#privateIsMapped: true )					#(#LensStructureVariable						#name: 'dataType'						#setValueType: #Object						#fieldType: #Object						#generatesAccessor: false						#generatesMutator: false						#privateIsMapped: false ) )				#table:				#(#CTLibTable					#name: 'sp_columns' )				#defersPostingUpdates: true				#idVariable: #('table' 'columnName' )				#idGeneratorType: #userDefinedId				#indexes: #() )			#(#LensStructureType				#memberClass: #CTLibPkeys				#setVariables: #(					#(#LensStructureVariable						#name: 'tableQualifier'						#setValueType: #String						#fieldType: #String						#column:						#(#CTLibTableColumn							#name: 'table_qualifier'							#dataType: 'varchar'							#maxColumnConstraint: 32 )						#generatesAccessor: true						#generatesMutator: false						#isId: true						#privateIsMapped: true )					#(#LensStructureVariable						#name: 'tableOwner'						#setValueType: #String						#fieldType: #String						#column:						#(#CTLibTableColumn							#name: 'table_owner'							#dataType: 'varchar'							#maxColumnConstraint: 32 )						#generatesAccessor: true						#generatesMutator: false						#isId: true						#privateIsMapped: true )					#(#LensStructureVariable						#name: 'tableName'						#setValueType: #String						#fieldType: #String						#column:						#(#CTLibTableColumn							#name: 'table_name'							#dataType: 'varchar'							#maxColumnConstraint: 32							#isNotNil: true )						#generatesAccessor: true						#generatesMutator: false						#isId: true						#privateIsMapped: true						#isNotNil: true )					#(#LensStructureVariable						#name: 'columnName'						#setValueType: #String						#fieldType: #String						#column:						#(#CTLibTableColumn							#name: 'column_name'							#dataType: 'varchar'							#maxColumnConstraint: 32							#isNotNil: true )						#generatesAccessor: true						#generatesMutator: false						#isId: true						#privateIsMapped: true						#isNotNil: true )					#(#LensStructureVariable						#name: 'keySeq'						#setValueType: #Integer						#fieldType: #Integer						#column:						#(#CTLibTableColumn							#name: 'key_seq'							#dataType: 'smallint'							#isNotNil: true )						#generatesAccessor: true						#generatesMutator: false						#privateIsMapped: true						#isNotNil: true ) )				#table:				#(#CTLibTable					#name: 'sp_pkeys' )				#defersPostingUpdates: true				#idVariable: #('tableQualifier' 'tableOwner' 'tableName' 'columnName' )				#idGeneratorType: #userDefinedId				#indexes: #() )			#(#LensStructureType				#memberClass: #CTLibFkeys				#setVariables: #(					#(#LensStructureVariable						#name: 'pktableQualifier'						#setValueType: #String						#fieldType: #String						#column:						#(#CTLibTableColumn							#name: 'pktable_qualifier'							#dataType: 'varchar'							#maxColumnConstraint: 32 )						#generatesAccessor: true						#generatesMutator: false						#isId: true						#privateIsMapped: true )					#(#LensStructureVariable						#name: 'pktableOwner'						#setValueType: #String						#fieldType: #String						#column:						#(#CTLibTableColumn							#name: 'pktable_owner'							#dataType: 'varchar'							#maxColumnConstraint: 32 )						#generatesAccessor: true						#generatesMutator: false						#isId: true						#privateIsMapped: true )					#(#LensStructureVariable						#name: 'pktableName'						#setValueType: #String						#fieldType: #String						#column:						#(#CTLibTableColumn							#name: 'pktable_name'							#dataType: 'varchar'							#maxColumnConstraint: 32							#isNotNil: true )						#generatesAccessor: true						#generatesMutator: false						#isId: true						#privateIsMapped: true						#isNotNil: true )					#(#LensStructureVariable						#name: 'pkcolumnName'						#setValueType: #String						#fieldType: #String						#column:						#(#CTLibTableColumn							#name: 'pkcolumn_name'							#dataType: 'varchar'							#maxColumnConstraint: 32							#isNotNil: true )						#generatesAccessor: true						#generatesMutator: false						#isId: true						#privateIsMapped: true						#isNotNil: true )					#(#LensStructureVariable						#name: 'fktableQualifier'						#setValueType: #String						#fieldType: #String						#column:						#(#CTLibTableColumn							#name: 'fktable_qualifier'							#dataType: 'varchar'							#maxColumnConstraint: 32 )						#generatesAccessor: true						#generatesMutator: false						#isId: true						#privateIsMapped: true )					#(#LensStructureVariable						#name: 'fktableOwner'						#setValueType: #String						#fieldType: #String						#column:						#(#CTLibTableColumn							#name: 'fktable_owner'							#dataType: 'varchar'							#maxColumnConstraint: 32 )						#generatesAccessor: true						#generatesMutator: false						#isId: true						#privateIsMapped: true )					#(#LensStructureVariable						#name: 'fktableName'						#setValueType: #String						#fieldType: #String						#column:						#(#CTLibTableColumn							#name: 'fktable_name'							#dataType: 'varchar'							#maxColumnConstraint: 32							#isNotNil: true )						#generatesAccessor: true						#generatesMutator: false						#isId: true						#privateIsMapped: true						#isNotNil: true )					#(#LensStructureVariable						#name: 'fkcolumnName'						#setValueType: #String						#fieldType: #String						#column:						#(#CTLibTableColumn							#name: 'fkcolumn_name'							#dataType: 'varchar'							#maxColumnConstraint: 32							#isNotNil: true )						#generatesAccessor: true						#generatesMutator: false						#isId: true						#privateIsMapped: true						#isNotNil: true )					#(#LensStructureVariable						#name: 'keySeq'						#setValueType: #Integer						#fieldType: #Integer						#column:						#(#CTLibTableColumn							#name: 'key_seq'							#dataType: 'smallint'							#isNotNil: true )						#generatesAccessor: true						#generatesMutator: false						#isId: true						#privateIsMapped: true						#isNotNil: true ) )				#table:				#(#CTLibTable					#name: 'sp_fkeys' )				#defersPostingUpdates: true				#idVariable: #('pktableQualifier' 'pktableOwner' 'pktableName' 'pkcolumnName' 'fktableQualifier' 'fktableOwner' 'fktableName' 'fkcolumnName' 'keySeq' )				#idGeneratorType: #userDefinedId				#indexes: #() ) )		#lensPolicyName: #Mixed		#lensTransactionPolicyName: #PessimisticRR		#validity: #installed )</body></methods><methods><class-id>CTLibContext class</class-id> <category>converting</category><body package="CTLibLens">internalNameFor: externalName	^externalName copy</body></methods><methods><class-id>CTLibContext class</class-id> <category>interface specs</category><body package="CTLibLens">propertiesSpec	"UIPainter new openOnClass: self andSelector: #propertiesSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec		#window:		#(#WindowSpec			#label: ''			#min: #(#Point 215 107 )			#bounds: #(#Rectangle 324 648 539 755 ) )		#component:		#(#SpecCollection			#collection: #(				#(#InputFieldSpec					#layout: #(#LayoutFrame 140 0 9 0 -6 1 34 0 )					#model: #databaseName )				#(#InputFieldSpec					#layout: #(#LayoutFrame 140 0 41 0 -6 1 66 0 )					#model: #username )				#(#InputFieldSpec					#layout: #(#LayoutFrame 140 0 73 0 -6 1 98 0 )					#model: #environment )				#(#LabelSpec					#layout: #(#AlignmentOrigin 8 0 36 0 0 1 )					#label: #(#{UserMessage} #key: #DatabaseName #catalogID: #sybaseDB #defaultString: 'Database name:' ))				#(#LabelSpec					#layout: #(#AlignmentOrigin 8 0 68 0 0 1 )					#label: #(#{UserMessage} #key: #UserName #catalogID: #sybaseDB #defaultString: 'User name:') )				#(#LabelSpec					#layout: #(#AlignmentOrigin 8 0 100 0 0 1 )					#label: #(#{UserMessage} #key: #Environment #catalogID: #sybaseDB #defaultString: 'Environment:') ) ) ) )</body></methods><initialize><class-id>CTLibTransporter</class-id></initialize><initialize><class-id>CTLibTableColumn</class-id></initialize><initialize><class-id>CTLibContext</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>LensDatabaseTableColumn</name><environment>Lens</environment><super>Lens.LensMetadata</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-Database Context</category><attributes><package>Lens-Runtime</package></attributes></class><class><name>LensDatabaseTable</name><environment>Lens</environment><super>Lens.LensMetadata</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-Database Context</category><attributes><package>Lens-Runtime</package></attributes></class><class><name>LensDatabaseContext</name><environment>Lens</environment><super>Lens.LensMetadata</super><private>false</private><indexed-type>none</indexed-type><inst-vars>username environment </inst-vars><class-inst-vars>catalogDataModel dataTypeMappings maxColumnSize maxNameSize reservedWords basicTypes shortSize transactionPolicies </class-inst-vars><imports></imports><category>Lens-Private-Database Context</category><attributes><package>Lens-Runtime</package></attributes></class><class><name>LensSQLTransporter</name><environment>Lens</environment><super>Lens.LensBasicTransporter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selectFieldList whereCondition commandStream command objectSurrogateIndices joinLinks variableIndex numberOfIdVariables itemSurrogate variableBindings </inst-vars><class-inst-vars>functions </class-inst-vars><imports></imports><category>Lens-Private-Transporter</category><attributes><package>Lens-Runtime</package></attributes></class></st-source>