<?xml version="1.0"?><st-source><!-- Name: DB2EXDINotice: Copyright 2008-2017 Cincom Systems, Inc.  All rights reserved.Comment: Contains the DB2 support code for the VisualWorks External Database Interface (EXDI).OverviewThe DB2EXDI parcel contains the DB2/UDB specfic protocols for the External Database Interface (EXDI). Using this parcel along with a properly configured DB2 client, one can interact with DB2 servers (6.x and higher).  DocumentationComplete information on the EXDI framework can be found in the "Database Application Developer's Guide" (located in the /doc subdirectory of the VisualWorks installation).AuthorAnthony Boris <anthonyvb@yandex.ru> is the original author of this code. Some improvements made by Cincom Systems, Inc.LicenseThe contents of this file are subject to the Cincom Public License (CPL) <http://www.cincomsmalltalk.com/CincomSmalltalkWiki/CPL>; you may not use it except in compliance with the license. Software distributed under the license is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the license for the specific language governing rights and limitations under the license.Portions created by Anthony Boris are copyright (c) 2000-2005. All Rights Reserved.DbIdentifier: bear73DbTrace: 502971DbUsername: nrossDbVersion: 8.3 - 4DevelopmentPrerequisites: #(#(#any 'Database' '') #(#any 'DLLCC' ''))HideSource: falsePackageName: DB2EXDIParcel: #('DB2EXDI')ParcelName: DB2EXDIPrerequisiteParcels: #(#('Database' ''))PrintStringCache: (8.3 - 4,nross)SaveSource: trueVersion: 8.3 - 4Post-Load Block: 	[:pkg| Database.DB2Connection postLoadActionFor: pkg.pkg isParcel ifFalse: [Database.DB2CLIInterface recompileMethods]]Date: 3:32:07 PM June 30, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (jun17.5) of June 30, 2017 on June 30, 2017 at 3:32:07 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>DB2DataType</name><environment>Database</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-DB2</category><attributes><package>DB2EXDI</package></attributes></class><comment><class-id>Database.DB2DataType</class-id><body>DB2DataType is the super class of the classes dealing with special DB2 data types.</body></comment><class><name>DB2DataLink</name><environment>Database</environment><super>Database.DB2DataType</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dlValue comment complete path pathOnly scheme server needBuild </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-DB2</category><attributes><package>DB2EXDI</package></attributes></class><comment><class-id>Database.DB2DataLink</class-id><body>DB2DataLink is the class which handles DB2 data type DATALINK.Instance Variables:	comment	&lt;String&gt;			The DATALINK comment.	complete	&lt;String&gt;			Complete URL to access a file.	dlValue		&lt;String&gt;			DATALINK value (file reference),.	needBuild	&lt;Boolean&gt;			Indicates whether the dlValue needs to be build.	path	&lt;String&gt;			Path to access a file within a file server.	pathOnly	&lt;String&gt;			File path only.	scheme 	&lt;String&gt;			Scheme of the DATALINK ('HTTP', 'FILE', 'UNC', 'DFS').	server	&lt;String&gt;			Server name where the file resides.</body></comment><class><name>DB2LOBType</name><environment>Database</environment><super>Database.DB2DataType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-DB2</category><attributes><package>DB2EXDI</package></attributes></class><comment><class-id>Database.DB2LOBType</class-id><body>DB2LOBType is the super class of the classes dealing with LOB types in DB2.</body></comment><class><name>DB2LOBLocator</name><environment>Database</environment><super>Database.DB2LOBType</super><private>false</private><indexed-type>none</indexed-type><inst-vars>locator connection </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-DB2</category><attributes><package>DB2EXDI</package></attributes></class><comment><class-id>Database.DB2LOBLocator</class-id><body>DB2LOBLocator is the super class of the classes dealing with BlobLocator and ClobLocator types in DB2.Instance Variables:	locator	&lt;CPointer&gt;			Pointer to the LOB locator..</body></comment><class><name>DB2CLIInterface</name><environment>Database</environment><super>External.ExternalInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars>encoding </inst-vars><class-inst-vars>getSelectorMap fSqlTypeToConversionMap fetchBufferSizeBlocks putSelectorMap fCTypeFromConversionMap fSqlTypeFromConversionMap valueSizeBlocks valuePrecisionBlocks dataChunkSize conversionBufferMap </class-inst-vars><imports>			private Database.DB2CLIInterfaceDictionary.*			</imports><category>Database-DB2</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>true</beVirtual><optimizationLevel>full</optimizationLevel><package>DB2EXDI</package></attributes></class><comment><class-id>Database.DB2CLIInterface</class-id><body>DB2CLIInterface defines calling conventions for DB2 CLI.Instance Variables:	encoding	&lt;Symbol&gt;		A symbol remembers the encoding selection.Class instance variables:	getSelectorMap		&lt;IdentityDictionary&gt;		Map of selectors to get values out of the buffer for different data types.	putSelectorMap		&lt;IdentityDictionary&gt;		Map of selectors to put value into the buffer for different data types.	fetchBufferSizeBlocks		&lt;IdentityDictionary&gt;		Map of buffer size for different data types.	fSqlTypeToConversionMap		&lt;IdentityDictionary&gt;		Map of converting Sql types to Smalltalk types.	fCTypeFromConversionMap		&lt;IdentityDictionary&gt;		Map of converting Smalltalk types to Sql types.	fSqlTypeFromConversionMap		&lt;IdentityDictionary&gt;		Map of converting Smalltalk types to Sql types.	valueSizeBlocks		&lt;IdentityDictionary&gt;		Map of value sizes for different data type.	valuePrecisionBlocks		&lt;IdentityDictionary&gt;		Map of precision sizes for different data type.	dataChunkSize		&lt;Integer&gt;		Size of the chunks for LOB data types.	conversionBufferMap		&lt;IdentityDictionary&gt;		Map of buffer type for different data types.</body></comment><class><name>DB2CLI64BitInterface</name><environment>Database</environment><super>Database.DB2CLIInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Database.DB2CLI64BitInterfaceDictionary.*			</imports><category>Database-DB2</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>true</beVirtual><optimizationLevel>full</optimizationLevel><package>DB2EXDI</package></attributes></class><comment><class-id>Database.DB2CLI64BitInterface</class-id><body>DB2CLI64BitInterface defines calling conventions for 64-bit DB2 CLI.</body></comment><class><name>DB2CLIWin64Interface</name><environment>Database</environment><super>Database.DB2CLI64BitInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Database.DB2CLIWin64InterfaceDictionary.*			</imports><category>Database-DB2</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>db2cli64.dll</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>DB2EXDI</package></attributes></class><comment><class-id>Database.DB2CLIWin64Interface</class-id><body>DB2CLIWin64Interface defines calling conventions for DB2 CLI on the 64-bit Windows platform.</body></comment><class><name>DB2CLISolarisInterface</name><environment>Database</environment><super>Database.DB2CLIInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Database.DB2CLISolarisInterfaceDictionary.*			</imports><category>Database-DB2</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>libdb2.so</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>DB2EXDI</package></attributes></class><comment><class-id>Database.DB2CLISolarisInterface</class-id><body>DB2CLISolarisInterface defines calling conventions for DB2 CLI on the Solaris platform.</body></comment><class><name>DB2CLIWinInterface</name><environment>Database</environment><super>Database.DB2CLIInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Database.DB2CLIWinInterfaceDictionary.*			</imports><category>Database-DB2</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>db2cli.dll</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>DB2EXDI</package></attributes></class><comment><class-id>Database.DB2CLIWinInterface</class-id><body>DB2CLIWinInterface defines calling conventions for DB2 CLI on the Windows platform.</body></comment><class><name>DB2APIInterface</name><environment>Database</environment><super>External.ExternalInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Database.DB2APIInterfaceDictionary.*			</imports><category>Database-DB2</category><attributes><includeFiles><item>db2apidf.h</item></includeFiles><includeDirectories><item>d:\sqllib\include</item></includeDirectories><libraryFiles><item>db2sys.dll</item> <item>db2app.dll</item> <item>db2util.dll</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>true</beVirtual><optimizationLevel>full</optimizationLevel><package>DB2EXDI</package></attributes></class><comment><class-id>Database.DB2APIInterface</class-id><body>DB2APIInterface defines calling conventions for DB2 Administrative API.</body></comment><class><name>DB2API64BitInterface</name><environment>Database</environment><super>Database.DB2APIInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Database.DB2API64BitInterfaceDictionary.*			</imports><category>Database-DB2</category><attributes><includeFiles><item>db2apidf.h</item></includeFiles><includeDirectories><item>d:\sqllib\include</item></includeDirectories><libraryFiles><item>db2sys.dll</item> <item>db2app.dll</item> <item>db2util.dll</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>true</beVirtual><optimizationLevel>full</optimizationLevel><package>DB2EXDI</package></attributes></class><comment><class-id>Database.DB2API64BitInterface</class-id><body>DB2API64BitInterface defines calling conventions for 64-bit DB2 Administrative API.</body></comment><class><name>DB2APIWin64Interface</name><environment>Database</environment><super>Database.DB2API64BitInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Database.DB2APIWin64InterfaceDictionary.*			</imports><category>Database-DB2</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>db2sys.dll</item> <item>db2app.dll</item> <item>db2util.dll</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>true</beVirtual><optimizationLevel>full</optimizationLevel><package>DB2EXDI</package></attributes></class><comment><class-id>Database.DB2APIWin64Interface</class-id><body>DB2APIWin64Interface defines calling conventions for DB2 Administrative API on the 64-bit Windows platform.</body></comment><class><name>DB2Connection</name><environment>Database</environment><super>Database.ExternalDatabaseConnection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hdbcHolder supportedFunctions generalInformationCache blobHstmt unicodeEncoding </inst-vars><class-inst-vars>apiXif apiXifMap </class-inst-vars><imports></imports><category>Database-DB2</category><attributes><package>DB2EXDI</package></attributes></class><comment><class-id>Database.DB2Connection</class-id><body>DB2Connection is the concrete class implementation of connection services using the DB2 CLI library.Instance Variables:	blobHstmt	&lt;(CPointer | nil)&gt;			A pointer to the statement handle for LOB handling.		generalInformationCache	&lt;IdentityDictionary&gt;			A dictionary containing the information associated with information type symbols.	hdbcHolder	&lt;ValueHolder on: (CPointer | nil)&gt;			A private value holder which remembers the pointer for the connection handle. 		supportedFunctions	&lt;IdentityDictionary&gt;			A dictionary indicating whether a specific function is supported.Class instance variables:	apiXif	&lt;IdentityDictionary&gt;		Maps a set of error codes to their corresponding signals.	apiXifMap	&lt;IdentityDictionary&gt;		A boolean indicating whether the Oracle OCI library is initialized.</body></comment><class><name>DB2CLISolaris64Interface</name><environment>Database</environment><super>Database.DB2CLI64BitInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Database.DB2CLISolaris64InterfaceDictionary.*			</imports><category>Database-DB2</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>libdb2.so</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>DB2EXDI</package></attributes></class><comment><class-id>Database.DB2CLISolaris64Interface</class-id><body>DB2CLISolaris64Interface defines calling conventions for DB2 CLI on the 64-bit Solaris platform.</body></comment><class><name>DB2CLILinux64Interface</name><environment>Database</environment><super>Database.DB2CLI64BitInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Database.DB2CLILinux64InterfaceDictionary.*			</imports><category>Database-DB2</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>libdb2.so</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>DB2EXDI</package></attributes></class><comment><class-id>Database.DB2CLILinux64Interface</class-id><body>DB2CLILinux64Interface defines calling conventions for DB2 CLI on the 64-bit Linux platform.</body></comment><class><name>DB2CLIAIXInterface</name><environment>Database</environment><super>Database.DB2CLIInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Database.DB2CLIAIXInterfaceDictionary.*			</imports><category>Database-DB2</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>libdb2.a(shr.o)</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>DB2EXDI</package></attributes></class><comment><class-id>Database.DB2CLIAIXInterface</class-id><body>DB2CLIAIXInterface defines calling conventions for DB2 CLI on the AIX platform.</body></comment><class><name>DB2CLILinuxInterface</name><environment>Database</environment><super>Database.DB2CLIInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Database.DB2CLILinuxInterfaceDictionary.*			</imports><category>Database-DB2</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>libdb2.so</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>DB2EXDI</package></attributes></class><comment><class-id>Database.DB2CLILinuxInterface</class-id><body>DB2CLILinuxInterface defines calling conventions for DB2 CLI on the Linux platform.</body></comment><class><name>DB2CLIMacOSXInterface</name><environment>Database</environment><super>Database.DB2CLIInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Database.DB2CLIMacOSXInterfaceDictionary.*			</imports><category>Database-DB2</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>libdb2.dylib</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>DB2EXDI</package></attributes></class><comment><class-id>Database.DB2CLIMacOSXInterface</class-id><body>DB2CLIMacOSXInterface defines calling conventions for DB2 CLI on the Mac OSX platform.</body></comment><class><name>DB2Buffer</name><environment>Database</environment><super>Database.ExternalDatabaseBuffer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>conversionBuffer bufferValue bufferIndex hstmt session fParamType cbColDef ibScale pcbValue getSelector putSelector isUnicodeColumn </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-DB2</category><attributes><package>DB2EXDI</package></attributes></class><comment><class-id>Database.DB2Buffer</class-id><body>DB2Buffer is a private subclass, it extends ExternalDatabaseBuffer to deal with DB2.Instance Variables	bufferIndex	&lt;SmallInteger&gt;			An Integer storing the external bind index.	bufferValue	&lt;Object | nil&gt;		The object to store a bind value.	cbColDef	&lt;SmallInteger&gt;			The precision of the buffer value.	connection	&lt;DB2Connection&gt;			The connection the buffer is used for.	conversionBuffer	&lt;Object | nil&gt;			The buffer type used to store or get the value from.	fParamType	 &lt;SmallInteger&gt;			The type of the parameter. (e.g., SQL_PARAM_INPUT)	getSelector &lt;nil | Symbol&gt;		Selector to perform to get values out of the buffer.	hstmt	&lt;CPointer&gt;			The statement handle.	ibScale	&lt;SmallInteger&gt;			The scale of the parameter.	pcbValue	&lt;CPointer&gt;			 The buffer's count (length) in bytes.	putSelector &lt;nil | Symbol&gt;		Selector to perform to put values into the buffer.	isUnicodeColumn	&lt;Boolean&gt;		For Strings, indicates whether this is a Unicode column or not.</body></comment><class><name>DB2CLOBLocator</name><environment>Database</environment><super>Database.DB2LOBLocator</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-DB2</category><attributes><package>DB2EXDI</package></attributes></class><comment><class-id>Database.DB2CLOBLocator</class-id><body>DB2CLOBLocator is the class which handles DB2 data type ClobLocator.</body></comment><class><name>DB2LargeObjectBuffer</name><environment>Database</environment><super>Database.DB2Buffer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>blobBuffer blobBufferSize maxLongData </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-DB2</category><attributes><package>DB2EXDI</package></attributes></class><comment><class-id>Database.DB2LargeObjectBuffer</class-id><body>DB2LargeObjectBuffer extends DB2Buffer to deal with LOB data types in DB2.Instance Variables:	blobBuffer	&lt;nil | CPointer&gt;		The buffer to hold piece of (or all) of LOB value.	blobBufferSize	&lt;Integer&gt;			Size of the blobBuffer.	maxLongData	&lt;Integer&gt;			The maximum amount of data to be copied from LOB columns.</body></comment><class><name>DB2APISolarisInterface</name><environment>Database</environment><super>Database.DB2APIInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Database.DB2APISolarisInterfaceDictionary.*			</imports><category>Database-DB2</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>libdb2.so</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>DB2EXDI</package></attributes></class><comment><class-id>Database.DB2APISolarisInterface</class-id><body>DB2APISolarisInterface defines calling conventions for DB2 Administrative API on the Solaris platform. </body></comment><class><name>DB2ColumnDescription</name><environment>Database</environment><super>Database.ExternalDatabaseColumnDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fSqlType fileRef isUnicodeColumn </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-DB2</category><attributes><package>DB2EXDI</package></attributes></class><comment><class-id>Database.DB2ColumnDescription</class-id><body>DB2ColumnDescription extends ExternalDatabaseColumnDescription to deal with DB2.Instance Variables	fileRef		&lt;DB2LOBFileReference&gt;			Remembers the DB2LOBFileReference instance used.	fSqlType	&lt;SmallInteger | nil&gt;		SQL datatype code.	isUnicodeColumn &lt;Boolean&gt;		true =&gt; the buffer is for a Unicode column.</body></comment><class><name>DB2DatabaseException</name><environment>Database</environment><super>Database.ExternalDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>DB2EXDI</category><attributes><package>DB2EXDI</package></attributes></class><comment><class-id>Database.DB2DatabaseException</class-id><body>DB2DatabaseException is raised in case of DB2 database errors.</body></comment><class><name>DB2APIWinInterface</name><environment>Database</environment><super>Database.DB2APIInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Database.DB2APIWinInterfaceDictionary.*			</imports><category>Database-DB2</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>db2sys.dll</item> <item>db2app.dll</item> <item>db2util.dll</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>DB2EXDI</package></attributes></class><comment><class-id>Database.DB2APIWinInterface</class-id><body>DB2APIWinInterface defines calling conventions for DB2 Administrative API on the Windows platform. </body></comment><class><name>DB2APIMacOSXInterface</name><environment>Database</environment><super>Database.DB2APIInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Database.DB2APIMacOSXInterfaceDictionary.*			</imports><category>Database-DB2</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>libdb2.dylib</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>DB2EXDI</package></attributes></class><comment><class-id>Database.DB2APIMacOSXInterface</class-id><body>DB2APIMacOSXInterface defines calling conventions for DB2 Administrative API on the Mac OSX platform. </body></comment><class><name>DB2APILinux64Interface</name><environment>Database</environment><super>Database.DB2API64BitInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Database.DB2APILinux64InterfaceDictionary.*			</imports><category>Database-DB2</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>libdb2.so</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>true</beVirtual><optimizationLevel>full</optimizationLevel><package>DB2EXDI</package></attributes></class><comment><class-id>Database.DB2APILinux64Interface</class-id><body>DB2APILinux64Interface defines calling conventions for DB2 Administrative API on the 64-bit Linux platform.</body></comment><class><name>DB2BLOBLocator</name><environment>Database</environment><super>Database.DB2LOBLocator</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-DB2</category><attributes><package>DB2EXDI</package></attributes></class><comment><class-id>Database.DB2BLOBLocator</class-id><body>DB2BLOBLocator is the class which handles DB2 data type BlobLocator.</body></comment><class><name>UnableToQueryStatementAttributes</name><environment>Database</environment><super>Database.DB2DatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>DB2EXDI</category><attributes><package>DB2EXDI</package></attributes></class><comment><class-id>Database.UnableToQueryStatementAttributes</class-id><body>UnableToQueryStatementAttributes is used to indicate that it is unable to get the statement attributes.</body></comment><class><name>DB2DataLinkBuffer</name><environment>Database</environment><super>Database.DB2Buffer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>valuePointer linkTypePointer commentPointer stringLengthPointer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-DB2</category><attributes><package>DB2EXDI</package></attributes></class><comment><class-id>Database.DB2DataLinkBuffer</class-id><body>DB2DataLinkBuffer extends DB2Buffer to deal with DB2 DATALINK types.Instance Variables:	commentPointer	&lt;CPointer&gt;			Buffer to store DataLink comment.	linkTypePointer	&lt;CPointer&gt;			Buffer to store DataLink type.			stringLengthPointer	&lt;CPointer&gt;			Buffer to store the length of a DataLink attribute.		valuePointer	&lt;CPointer&gt;			Buffer to store DataLink data location.</body></comment><class><name>DB2Error</name><environment>Database</environment><super>Database.ExternalDatabaseError</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sqlState </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-DB2</category><attributes><package>DB2EXDI</package></attributes></class><comment><class-id>Database.DB2Error</class-id><body>DB2Error adds information about the error returned from the CLI interface.  Refer to the DB2 documentation for further details.Instance Variables:	sqlState	&lt;String&gt;			Part of DB2's diagnostic information.</body></comment><class><name>DB2DataSource</name><environment>Database</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name description </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-DB2</category><attributes><package>DB2EXDI</package></attributes></class><comment><class-id>Database.DB2DataSource</class-id><body>DB2DataSource is used to represent the DB2 data sources.Instance Variables:	description	&lt;String&gt;			Description of the data source.	name	&lt;String&gt;			Name of the data source.</body></comment><class><name>DB2FileRefBuffer</name><environment>Database</environment><super>Database.DB2Buffer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bufferLengthPointer fileOptionsPointer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-DB2</category><attributes><package>DB2EXDI</package></attributes></class><comment><class-id>Database.DB2FileRefBuffer</class-id><body>DB2FileRefBuffer is a private subclass, it extends DB2Buffer to deal with file reference.Instance Variables:	bufferLengthPointer	&lt;CPointer&gt;			Stores the buffer length.	fileOptionsPointer	&lt;CPointer&gt;			Stores the file options.</body></comment><class><name>DB2LOBFileReference</name><environment>Database</environment><super>Database.DB2LOBType</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fileName fileOptions dataType computeBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-DB2</category><attributes><package>DB2EXDI</package></attributes></class><comment><class-id>Database.DB2LOBFileReference</class-id><body>DB2LOBFileReference is used to handle LOB file references in DB2.Instance Variables:	computeBlock	&lt;BlockClosure&gt;			Used to compute the file name.	dataType	&lt;ByteSymbol&gt;			Data types used (#LargeString or #LargeByteArray).	fileName	&lt;String&gt;			The file name.	fileOptions	&lt;ByteSymbol&gt;			File options</body></comment><class><name>DB2APISolaris64Interface</name><environment>Database</environment><super>Database.DB2API64BitInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Database.DB2APISolaris64InterfaceDictionary.*			</imports><category>Database-DB2</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>libdb2.so</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>true</beVirtual><optimizationLevel>full</optimizationLevel><package>DB2EXDI</package></attributes></class><comment><class-id>Database.DB2APISolaris64Interface</class-id><body>DB2APISolaris64Interface defines calling conventions for DB2 Administrative API on the 64-bit Solaris platform.</body></comment><class><name>DB2DBCLOBLocator</name><environment>Database</environment><super>Database.DB2LOBLocator</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-DB2</category><attributes><package>DB2EXDI</package></attributes></class><class><name>DB2Transaction</name><environment>Database</environment><super>Database.ExternalDatabaseTransaction</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-DB2</category><attributes><package>DB2EXDI</package></attributes></class><comment><class-id>Database.DB2Transaction</class-id><body>DB2Transaction is the concrete implementation of the transaction concept for DB2. </body></comment><class><name>DB2APIAIXInterface</name><environment>Database</environment><super>Database.DB2APIInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Database.DB2APIAIXInterfaceDictionary.*			</imports><category>Database-DB2</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>libdb2.a(shr.o)</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>DB2EXDI</package></attributes></class><comment><class-id>Database.DB2APIAIXInterface</class-id><body>DB2APIAIXInterface defines calling conventions for DB2 Administrative API on the AIX platform. </body></comment><class><name>DB2APILinuxInterface</name><environment>Database</environment><super>Database.DB2APIInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Database.DB2APILinuxInterfaceDictionary.*			</imports><category>Database-DB2</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>libdb2.so</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>DB2EXDI</package></attributes></class><comment><class-id>Database.DB2APILinuxInterface</class-id><body>DB2APILinuxInterface defines calling conventions for DB2 Administrative API on the Linux platform. </body></comment><class><name>DB2Manager</name><environment>Database</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>singleton </class-inst-vars><imports></imports><category>Database-DB2</category><attributes><package>DB2EXDI</package></attributes></class><comment><class-id>Database.DB2Manager</class-id><body>DB2Manager is used to make DB2 Administrative API calls.Class instance variables:	singleton	&lt;DB2Manager&gt;		The only instance of the class used to make the calls.</body></comment><class><name>DB2Session</name><environment>Database</environment><super>Database.ExternalDatabaseSession</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hstmtHolder resultsCache bindValuePointersHolder mustResendQueryHolder maxLongData currentRowIndex rowsInBlock totalRows pRowsFetchedHolder sqlStatementAttributeCache paramSetSize queryIsCALL mustCloseCursorHolder deferCursorClosing answerBlob rowStatus </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-DB2</category><attributes><package>DB2EXDI</package></attributes></class><comment><class-id>Database.DB2Session</class-id><body>DB2Session is the concrete implementation of session services using the DB2 CLI library.Instance Variables:	answerBlob	&lt;Boolean&gt;			Indicates whether LOB locators or LOB values should be returned.	bindValuePointersHolder	  &lt;ValueHolder on: ((IdentityDictionary of: OracleBuffer) | nil)&gt;		Holds the DB2Buffers used to reference externally bound parameter values	currentRowIndex  &lt;SmallInteger&gt;		Part of the support for utilizing the array interface for fetching rows.	deferCursorClosing	&lt;Boolean&gt;			Indicates whether the cursor's closing should be defered until the session is reused.	hstmtHolder &lt;ValueHolder on: (CPointer | nil)&gt;		A private value holder which remembers the pointer for the current CLI statement handle, if any.  The value holder is shared with the executor object.		maxLongData	&lt;Integer&gt;			The maximum amount of data to be copied from BLOB or CLOB columns.	mustCloseCursorHolder	&lt;Boolean&gt;			Indicates whether the cursor should be closed immediately.	mustResendQueryHolder	&lt;ValueHolder on: Boolean&gt;			A private value holder which remembers whether the query text need to be sent to the server again.	paramSetSize	 &lt;SmallInteger&gt;		Indicates number of the parameters.	pRowsFetchedHolder &lt;ValueHolder on: (CPointer | nil)&gt;		Used to remember number of rows fetched from the server.	queryIsCALL	&lt;Boolean&gt;		Indicates that whether the prepared query is a stored procedure call.	resultsCache	&lt;Collection | nil&gt;			Stores a collection of DB2Error(s) associated with the statement handle. Used to tell resultsExternal the outcome of the operation.	rowsInBlock	 &lt;SmallInteger&gt;		Part of the support for utilizing the array interface for fetching rows.	rowStatus	&lt;CPointer&gt;			Used to indicate the status of each row in the rowset.	sqlStatementAttributeCache	&lt;IdentityDictionary&gt;			Used to cache statement attributes.	totalRows	&lt;SmallInteger&gt;		Part of the support for utilizing the array interface for fetching rows.</body></comment><shared-variable><name>DB2CLIAIXInterfaceDictionary</name><environment>Database</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>DB2EXDI</package></attributes></shared-variable><shared-variable><name>DB2CLI64BitInterfaceDictionary</name><environment>Database</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>DB2EXDI</package></attributes></shared-variable><shared-variable><name>DB2APISolaris64InterfaceDictionary</name><environment>Database</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>DB2EXDI</package></attributes></shared-variable><shared-variable><name>DB2APISolarisInterfaceDictionary</name><environment>Database</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>DB2EXDI</package></attributes></shared-variable><shared-variable><name>DB2APILinuxInterfaceDictionary</name><environment>Database</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>DB2EXDI</package></attributes></shared-variable><shared-variable><name>DB2CLIInterfaceDictionary</name><environment>Database</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>DB2EXDI</package></attributes></shared-variable><shared-variable><name>DB2CLISolarisInterfaceDictionary</name><environment>Database</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>DB2EXDI</package></attributes></shared-variable><shared-variable><name>DB2APIWin64InterfaceDictionary</name><environment>Database</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>DB2EXDI</package></attributes></shared-variable><shared-variable><name>DB2API64BitInterfaceDictionary</name><environment>Database</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>DB2EXDI</package></attributes></shared-variable><shared-variable><name>DB2APIMacOSXInterfaceDictionary</name><environment>Database</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>DB2EXDI</package></attributes></shared-variable><shared-variable><name>DB2CLIMacOSXInterfaceDictionary</name><environment>Database</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>DB2EXDI</package></attributes></shared-variable><shared-variable><name>DB2APIAIXInterfaceDictionary</name><environment>Database</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>DB2EXDI</package></attributes></shared-variable><shared-variable><name>DB2APILinux64InterfaceDictionary</name><environment>Database</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>DB2EXDI</package></attributes></shared-variable><shared-variable><name>DB2CLILinux64InterfaceDictionary</name><environment>Database</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>DB2EXDI</package></attributes></shared-variable><shared-variable><name>DB2CLILinuxInterfaceDictionary</name><environment>Database</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>DB2EXDI</package></attributes></shared-variable><shared-variable><name>DB2APIInterfaceDictionary</name><environment>Database</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>DB2EXDI</package></attributes></shared-variable><shared-variable><name>DB2CLIWin64InterfaceDictionary</name><environment>Database</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>DB2EXDI</package></attributes></shared-variable><shared-variable><name>DB2CLIWinInterfaceDictionary</name><environment>Database</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>DB2EXDI</package></attributes></shared-variable><shared-variable><name>DB2APIWinInterfaceDictionary</name><environment>Database</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>DB2EXDI</package></attributes></shared-variable><shared-variable><name>DB2CLISolaris64InterfaceDictionary</name><environment>Database</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>DB2EXDI</package></attributes></shared-variable><shared-variable><name>RegisteredDB2Sessions</name><environment>Database.DB2Session</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DB2EXDI</package></attributes></shared-variable><shared-variable><name>SQLStatementAttributeConversionMap</name><environment>Database.DB2Session</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DB2EXDI</package></attributes></shared-variable><shared-variable><name>HenvLock</name><environment>Database.DB2Connection</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DB2EXDI</package></attributes></shared-variable><shared-variable><name>Henv</name><environment>Database.DB2Connection</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DB2EXDI</package></attributes></shared-variable><shared-variable><name>SupportedIsolationLevels</name><environment>Database.DB2Connection</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DB2EXDI</package></attributes></shared-variable><shared-variable><name>SQLInfoTypeConversionMap</name><environment>Database.DB2Connection</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DB2EXDI</package></attributes></shared-variable><shared-variable><name>RegisteredDB2Connections</name><environment>Database.DB2Connection</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DB2EXDI</package></attributes></shared-variable><shared-variable><name>HenvReferencesCount</name><environment>Database.DB2Connection</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DB2EXDI</package></attributes></shared-variable><shared-variable><name>ValuePrecisionBlocks</name><environment>Database.DB2Buffer</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DB2EXDI</package></attributes></shared-variable><shared-variable><name>ValueSizeBlocks</name><environment>Database.DB2Buffer</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DB2EXDI</package></attributes></shared-variable><shared-variable><name>PutSelectorMap</name><environment>Database.DB2Buffer</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DB2EXDI</package></attributes></shared-variable><shared-variable><name>CTypeFromConversionMap</name><environment>Database.DB2Buffer</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DB2EXDI</package></attributes></shared-variable><shared-variable><name>FetchBufferSizeBlocks</name><environment>Database.DB2Buffer</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DB2EXDI</package></attributes></shared-variable><shared-variable><name>SQLTypeFromConversionMap</name><environment>Database.DB2Buffer</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DB2EXDI</package></attributes></shared-variable><shared-variable><name>GetSelectorMap</name><environment>Database.DB2Buffer</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DB2EXDI</package></attributes></shared-variable><shared-variable><name>ConversionBufferMap</name><environment>Database.DB2Buffer</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DB2EXDI</package></attributes></shared-variable><methods><class-id>Database.DB2DataLink</class-id> <category>comparing</category><body package="DB2EXDI">= aDatalink	^self class = aDatalink class and: 		[self pathOnly = aDatalink pathOnly and: 			[(self scheme sameAs: aDatalink scheme) and: 				[self comment = aDatalink comment and:					[(self server sameAs: aDatalink server)]]]]</body><body package="DB2EXDI">hash	"Modify the hash method to be based on the path and comment combined."	^(((self pathOnly hash bitShift: 3)		bitXor: self comment hash)			bitXor: self server hash)				bitXor: self scheme hash</body></methods><methods><class-id>Database.DB2DataLink</class-id> <category>accessing</category><body package="DB2EXDI">comment	^comment notNil ifTrue: [comment] ifFalse: [comment:=String new]</body><body package="DB2EXDI">comment: aString	comment:= aString</body><body package="DB2EXDI">complete	^complete</body><body package="DB2EXDI">complete: aString	complete:= aString</body><body package="DB2EXDI">dataLocation	^(String new: dlValue size) writeStream		nextPutAll: self schemeAsUrl;		nextPutAll: (server notNil ifTrue: [server] ifFalse: ['']);		nextPutAll: (pathOnly notNil ifTrue: [pathOnly] ifFalse: ['']);		contents</body><body package="DB2EXDI">dlValue	^dlValue</body><body package="DB2EXDI">dlValue: aDataLink	dlValue:= aDataLink</body><body package="DB2EXDI">path	^path</body><body package="DB2EXDI">path: aString	path:= aString</body><body package="DB2EXDI">pathOnly	^pathOnly</body><body package="DB2EXDI">pathOnly: aString	pathOnly:= aString</body><body package="DB2EXDI">scheme	^scheme</body><body package="DB2EXDI">scheme: aString	scheme:=aString</body><body package="DB2EXDI">schemeAsUrl	^scheme notNil ifTrue: [scheme, '://' ] ifFalse: ['']</body><body package="DB2EXDI">server	^server</body><body package="DB2EXDI">server: aString	server:= aString</body></methods><methods><class-id>Database.DB2DataLink</class-id> <category>private-db2</category><body package="DB2EXDI">db2Conversion	^#DataLink</body></methods><methods><class-id>Database.DB2DataLink</class-id> <category>private</category><body package="DB2EXDI">getDLAttributes: aConnection	"Note: SQL_ATTR_DATALINK_LINKTYPE answer always 'URL' ,	may be add SQL_ATTR_DATALINK_URLPATH ?"	self comment: (aConnection getDLAttribute: #SQL_ATTR_DATALINK_COMMENT  for: self);		complete: (aConnection getDLAttribute: #SQL_ATTR_DATALINK_URLCOMPLETE for: self);		pathOnly: (aConnection getDLAttribute: #SQL_ATTR_DATALINK_URLPATHONLY for: self);		server: 	(aConnection getDLAttribute: #SQL_ATTR_DATALINK_URLSERVER for: self);		scheme: (aConnection getDLAttribute: #SQL_ATTR_DATALINK_URLSCHEME for: self).</body><body package="DB2EXDI">initialize	needBuild := true</body><body package="DB2EXDI">printOn: aStream	aStream nextPutAll: 'DL(';		nextPutAll: self dataLocation.		comment notNil ifTrue: [		aStream nextPutAll: ' Comment: ';			nextPutAll: comment].	aStream nextPut: $)</body></methods><methods><class-id>Database.DB2DataLink class</class-id> <category>instance creation</category><body package="DB2EXDI">recordTemplate	^self new</body></methods><methods><class-id>Database.DB2LOBLocator</class-id> <category>private-db2</category><body package="DB2EXDI">db2Conversion	self subclassResponsibility</body><body package="DB2EXDI">locatorCType	self subclassResponsibility</body><body package="DB2EXDI">printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	locator notNil ifTrue: [aStream nextPutAll: locator printString].	aStream nextPut: $).</body><body package="DB2EXDI">targetCType	"need for SQLGetSubString "	self subclassResponsibility</body></methods><methods><class-id>Database.DB2LOBLocator</class-id> <category>accessing</category><body package="DB2EXDI">connection	^connection</body><body package="DB2EXDI">connection: aConnection	connection := aConnection</body><body package="DB2EXDI">getLobLength	^self connection getLOBLength: self.</body><body package="DB2EXDI">locator	^locator</body><body package="DB2EXDI">locator: aValue	locator := aValue</body><body package="DB2EXDI">readAll	^self readFrom: 1 amount: self getLobLength</body><body package="DB2EXDI">readFrom: startingPosition amount: amount	^self connection getLOBSubString: self from: startingPosition length: amount</body><body package="DB2EXDI">search: aStringOrLocator from: aPosition 	^self connection getLOBPosition: self search: aStringOrLocator from: aPosition</body></methods><methods><class-id>Database.DB2LOBLocator class</class-id> <category>instance creation</category><body package="DB2EXDI">asBLOBLocator	^DB2BLOBLocator new</body><body package="DB2EXDI">asCLOBLocator	^DB2CLOBLocator new</body><body package="DB2EXDI">asType: type	^type == #BlobLocator ifTrue: [		DB2BLOBLocator new	] ifFalse: [		type == #ClobLocator ifTrue: [			DB2CLOBLocator new		] ifFalse: [			type == #DBClobLocator ifTrue: [				DB2DBCLOBLocator new			] ifFalse: [				^self halt: 'Bad locator type'			] 		]	 	]</body><body package="DB2EXDI">recordTemplate	^self new</body></methods><methods><class-id>Database.DB2LOBLocator class</class-id> <category>private</category><body package="DB2EXDI">locatorTypeFor: type	^type == #LargeByteArray ifTrue: [#BlobLocator ]		ifFalse: [type == #LargeString ifTrue: [#ClobLocator ] 			ifFalse: [self error: 'bad LOB type']]</body></methods><methods><class-id>Database.DB2CLIInterface</class-id> <category>macros</category><body package="DB2EXDI">SQL_ADD_RECORD: hstmt with: irow	"&lt;C: #define SQL_ADD_RECORD(hstmt, irow) SQLSetPos(hstmt ,irow ,SQL_ADD,SQL_LOCK_NO_CHANGE)	&gt;"	^self SQLSetPos: hstmt with: irow with: self SQL_ADD with: self SQL_LOCK_NO_CHANGE</body><body package="DB2EXDI">SQL_DELETE_RECORD: hstmt with: irow	"&lt;C: #define SQL_DELETE_RECORD(hstmt, irow) SQLSetPos(hstmt ,irow ,SQL_DELETE,SQL_LOCK_NO_CHANGE)	&gt;"	^self SQLSetPos: hstmt with: irow with: self  SQL_DELETE with: self SQL_LOCK_NO_CHANGE</body><body package="DB2EXDI">SQL_FUNC_EXISTS: pfExists with: uwAPI	"This macro appears to depend on function address pointer manipulation, isn't used and doesn't appear to work. The preferred approach in VisualWorks is to use the standard api, as in DB2Connection&gt;&gt;supportsFunction: functionSymbol.  We leave the commented-out C code below for information, and in case work should resume on this function."	"&lt;C: #define SQL_FUNC_EXISTS(pfExists, uwAPI) ((*(((UWORD*)(pfExists ))+((uwAPI )&gt;&gt;4))&amp;(1&lt;&lt;((uwAPI )&amp;0x000F)))?SQL_TRUE:SQL_FALSE)	&gt;"	^self error:  'Macro unsupported:  call DB2Connection&gt;&gt;supportsFunction:'</body><body package="DB2EXDI">SQL_LEN_BINARY_ATTR: length	"&lt;C: #define SQL_LEN_BINARY_ATTR(length) (-(length )+SQL_LEN_BINARY_ATTR_OFFSET)	&gt;"	^length negated + self SQL_LEN_BINARY_ATTR_OFFSET</body><body package="DB2EXDI">SQL_LEN_DATA_AT_EXEC: length	"&lt;C: #define SQL_LEN_DATA_AT_EXEC(length) (-(length )+SQL_LEN_DATA_AT_EXEC_OFFSET)	&gt;"	^length negated + self SQL_LEN_DATA_AT_EXEC_OFFSET</body><body package="DB2EXDI">SQL_LOCK_RECORD: hstmt with: irow with: fLock	"&lt;C: #define SQL_LOCK_RECORD(hstmt, irow, fLock) SQLSetPos(hstmt ,irow ,SQL_POSITION,fLock )	&gt;"	^self SQLSetPos: hstmt with: irow with: self SQL_POSITION with: fLock</body><body package="DB2EXDI">SQL_POSITION_TO: hstmt with: irow	"&lt;C: #define SQL_POSITION_TO(hstmt, irow) SQLSetPos(hstmt ,irow ,SQL_POSITION,SQL_LOCK_NO_CHANGE)	&gt;"	^self SQLSetPos: hstmt with: irow with: self SQL_POSITION with: self SQL_LOCK_NO_CHANGE</body><body package="DB2EXDI">SQL_REFRESH_RECORD: hstmt with: irow with: fLock	"&lt;C: #define SQL_REFRESH_RECORD(hstmt, irow, fLock) SQLSetPos(hstmt ,irow ,SQL_REFRESH,fLock )	&gt;"	^self SQLSetPos: hstmt with: irow with: self SQL_REFRESH with: fLock</body><body package="DB2EXDI">SQL_SUCCEEDED: rc	"&lt;C: #define SQL_SUCCEEDED(rc) (((rc )&amp;(~1))==0)	&gt;"	^( rc bitAnd: 1 bitInvert ) == 0</body><body package="DB2EXDI">SQL_UPDATE_RECORD: hstmt with: irow	"&lt;C: #define SQL_UPDATE_RECORD(hstmt, irow) SQLSetPos(hstmt ,irow ,SQL_UPDATE,SQL_LOCK_NO_CHANGE)	&gt;"	^self SQLSetPos: hstmt with: irow with: self SQL_UPDATE with: self SQL_LOCK_NO_CHANGE</body></methods><methods><class-id>Database.DB2CLIInterface</class-id> <category>accessing</category><body package="DB2EXDI">copyToHeapSelector	^#copyToHeap</body><body package="DB2EXDI">encoding	encoding == nil ifTrue: [encoding := self getEncoding].	^encoding</body><body package="DB2EXDI">getDataChunkSize	^self class getDataChunkSize</body><body package="DB2EXDI">getEncoding	^#default</body><body package="DB2EXDI">mallocSelector	^#malloc:</body><body package="DB2EXDI">setDataChunkSize: anInteger	self class setDataChunkSize: anInteger</body></methods><methods><class-id>Database.DB2CLIInterface class</class-id> <category>fileIn/Out</category><body package="DB2EXDI">binaryInitializationMessagesFor: sourceMode	"Answer a list of message sends used to initialize the receiver."	| list |	list := super binaryInitializationMessagesFor: sourceMode.	list add: (		MessageSend			receiver: self			selector: #deferredInitialize).	^list</body></methods><methods><class-id>Database.DB2CLIInterface class</class-id> <category>private-accessing</category><body package="DB2EXDI">conversionBufferMap	^conversionBufferMap</body><body package="DB2EXDI">fCTypeFromConversionMap	^fCTypeFromConversionMap</body><body package="DB2EXDI">fSqlTypeFromConversionMap	^fSqlTypeFromConversionMap</body><body package="DB2EXDI">fSqlTypeToConversionMap	^fSqlTypeToConversionMap</body><body package="DB2EXDI">fetchBufferSizeBlocks	^fetchBufferSizeBlocks</body><body package="DB2EXDI">getSelectorMap	^getSelectorMap</body><body package="DB2EXDI">putSelectorMap	^putSelectorMap</body><body package="DB2EXDI">valuePrecisionBlocks	^valuePrecisionBlocks</body><body package="DB2EXDI">valueSizeBlocks	^valueSizeBlocks</body></methods><methods><class-id>Database.DB2CLIInterface class</class-id> <category>class initialization</category><body package="DB2EXDI">deferredInitialize	"Used to initialize the class after file-in or BOSS-in."	| db2BufferClass |	self initializeMaps.	(db2BufferClass := self environment at: #DB2Buffer ifAbsent: [nil]) notNil ifTrue: [db2BufferClass install]</body><body package="DB2EXDI">initialize	"DB2CLIInterface withAllSubclasses do: [:class | class initialize]. DB2Buffer install"		self withAllSubclasses do: [:subclass| subclass deferredInitialize]</body><body package="DB2EXDI">initializeDefineCaches	"This should only be done if the DLLCC development environment is present in the image."	"self fillDefineCaches.	self fillDefineCaches"	"Do twice in case there are longer reference chains."</body><body package="DB2EXDI">initializeMaps	"self initializeMapsOld"	self initializeMapsNew.</body><body package="DB2EXDI">initializeMapsNew	| xif |	dataChunkSize := 1048576.  "Set the default chunk size."  "NEED MORE WORK"	xif := self new."=========================================================="	self privateInitializeMaps.		self initializeDateConversions: xif.	self initializeTimeConversions: xif.	self initializeTimestampConversions: xif.	self initializeStringConversions: xif.	"self initializeLongStringConversions: xif."	self initializeClobConversions: xif.	self initializeClobLocatorConversions: xif.	self initializeDBClobConversions: xif.	self initializeDBClobLocatorConversions: xif.	self initializeFileReferenceConversions: xif.	self initializeByteArrayConversions: xif.	"self initializeLongByteArrayConversions: xif."	self initializeBlobConversions: xif.	self initializeBlobLocatorConversions: xif.		self initializeBigIntConversions: xif.	self initializeFloatConversions: xif.	self initializeDoubleConversions: xif.	self initializeIntegerConversions: xif.	self initializeFixedPointConversions: xif.	self initializeDataLinkConversions: xif</body></methods><methods><class-id>Database.DB2CLIInterface class</class-id> <category>accessing</category><body package="DB2EXDI">getDataChunkSize	^dataChunkSize</body><body package="DB2EXDI">setDataChunkSize: anInteger	dataChunkSize := anInteger</body></methods><methods><class-id>Database.DB2CLIInterface class</class-id> <category>private class initialization</category><body package="DB2EXDI">initializeBigIntConversions: xif	"Conversion to/from buffer for BIGINT"	conversionBufferMap add: (#LargeInteger -&gt; UninterpretedBytes).	fSqlTypeToConversionMap add: ( xif SQL_BIGINT -&gt; #LargeInteger ).	getSelectorMap add: ( #LargeInteger -&gt; #getLargeIntegerAt: ).	putSelectorMap add: ( #LargeInteger -&gt; #at:putLargeInteger: ).	fSqlTypeFromConversionMap add: ( #LargeInteger -&gt; xif SQL_BIGINT ).	fCTypeFromConversionMap add: ( #LargeInteger -&gt; xif SQL_C_SBIGINT ). "add mapping for UBIGINT ?"	fetchBufferSizeBlocks add: ( #LargeInteger -&gt; [ :size | 8 ] ).		valueSizeBlocks add: ( #LargeInteger -&gt; [ :ignoredValue | 8 ] ).		valuePrecisionBlocks add: ( #LargeInteger -&gt; [ :ignoredValue | 0 ] ).</body><body package="DB2EXDI">initializeBlobConversions: xif	"Conversion to/from BLOB"	| binVPB |	conversionBufferMap add: (#LargeByteArray -&gt; nil).	getSelectorMap add: ( #LargeByteArray -&gt; #getByteArrayAt: ).	putSelectorMap add: ( #LargeByteArray -&gt; #at:putByteArray: ).	fSqlTypeToConversionMap add: ( xif SQL_BLOB -&gt; #LargeByteArray ).	fSqlTypeFromConversionMap add: ( #LargeByteArray -&gt; xif SQL_BLOB ).	fCTypeFromConversionMap add: ( #LargeByteArray -&gt; xif SQL_C_BINARY  ).	binVPB := [ :ba | | sz |		(sz := ba size) &lt;= 256 			ifTrue: [ 256 ] 			ifFalse: [ "65536" dataChunkSize min: (2 raisedTo: ( (sz floorLog: 2) + 1)) ] ].	fetchBufferSizeBlocks add: ( #LargeByteArray -&gt; [ :size | (self getDataChunkSize min: size)   ] ).	valueSizeBlocks add: ( #LargeByteArray -&gt; binVPB ).	valuePrecisionBlocks add: ( #LargeByteArray -&gt; binVPB ).</body><body package="DB2EXDI">initializeBlobLocatorConversions: xif	"Conversion to/from BLOB Locator"	conversionBufferMap add: (#BlobLocator -&gt; UninterpretedBytes).	getSelectorMap add: ( #BlobLocator -&gt; #getBlobLocatorAt: ).	putSelectorMap add: ( #BlobLocator -&gt; #at:putBlobLocator: ).	fSqlTypeToConversionMap add: ( xif SQL_BLOB_LOCATOR -&gt; #BlobLocator ).	fSqlTypeFromConversionMap add: ( #BlobLocator -&gt; xif SQL_BLOB_LOCATOR ).	fCTypeFromConversionMap add: ( #BlobLocator -&gt; xif SQL_C_BLOB_LOCATOR  ).	fetchBufferSizeBlocks add: ( #BlobLocator -&gt; [ :ignored | 4 ] ).	valueSizeBlocks add: ( #BlobLocator -&gt; [ :ignoredValue | 4 ] ).	valuePrecisionBlocks add: ( #BlobLocator -&gt; [ :ignoredValue | 0 ] ).</body><body package="DB2EXDI">initializeByteArrayConversions: xif"Conversion to/from buffer for ByteArray."	| binVPB |	conversionBufferMap add: (#ByteArray -&gt; nil).	getSelectorMap add: ( #ByteArray -&gt; #getByteArrayAt: ).	putSelectorMap add: ( #ByteArray -&gt; #at:putByteArray: ).	fSqlTypeToConversionMap add: ( xif SQL_BINARY -&gt; #ByteArray ).	fSqlTypeToConversionMap add: ( xif SQL_VARBINARY -&gt; #ByteArray ).	fSqlTypeToConversionMap add: ( xif SQL_LONGVARBINARY -&gt; #ByteArray ).	fSqlTypeFromConversionMap add: ( #ByteArray -&gt; xif SQL_VARBINARY ).	fCTypeFromConversionMap add: ( #ByteArray -&gt; xif SQL_C_BINARY  ).	binVPB := [ :ba | | sz |		(sz := ba size) &lt;= 256 			ifTrue: [ 256 ] 			ifFalse: [32700 min: (2 raisedTo: ( (sz floorLog: 2) + 1)) ] ].	fetchBufferSizeBlocks add: ( #ByteArray -&gt; [ :size | size  ] ).	valueSizeBlocks add: ( #ByteArray -&gt; binVPB ).	valuePrecisionBlocks add: ( #ByteArray -&gt; binVPB ).</body><body package="DB2EXDI">initializeClobConversions: xif	"Conversion to/from CLOB"	| binVPB |	conversionBufferMap add: (#LargeString -&gt; nil).	getSelectorMap add: ( #LargeString -&gt; #getStringAt: ).	putSelectorMap add: ( #LargeString -&gt; #at:putString: ).	fSqlTypeToConversionMap add: ( xif SQL_CLOB -&gt; #LargeString ).	fSqlTypeFromConversionMap add: ( #LargeString -&gt; xif SQL_CLOB ).	fCTypeFromConversionMap add: ( #LargeString -&gt; xif SQL_C_CHAR  ).	binVPB := [ :ba | | sz |		(sz := ba size) &lt;= 256 			ifTrue: [ 256 ] 			ifFalse: [ dataChunkSize min: (2 raisedTo: ( (sz floorLog: 2) + 1)) ] ].	fetchBufferSizeBlocks add: ( #LargeString -&gt; [ :size | (self getDataChunkSize min: size)  + 1  ] ).	valueSizeBlocks add: ( #LargeString -&gt; binVPB ).	valuePrecisionBlocks add: ( #LargeString -&gt; binVPB ).</body><body package="DB2EXDI">initializeClobLocatorConversions: xif"Conversion to/from CLOB Locator"	conversionBufferMap add: (#ClobLocator -&gt; UninterpretedBytes).	getSelectorMap add: ( #ClobLocator -&gt; #getBlobLocatorAt: ).	putSelectorMap add: ( #ClobLocator -&gt; #at:putBlobLocator: ).	fSqlTypeToConversionMap add: ( xif SQL_CLOB_LOCATOR -&gt; #ClobLocator ).	fSqlTypeFromConversionMap add: ( #ClobLocator -&gt; xif SQL_CLOB_LOCATOR ).	fCTypeFromConversionMap add: ( #ClobLocator -&gt; xif SQL_C_CLOB_LOCATOR  ).	fetchBufferSizeBlocks add: ( #ClobLocator -&gt; [ :ignored | 4 ] ).	valueSizeBlocks add: ( #ClobLocator -&gt; [ :ignoredValue | 4 ] ).	valuePrecisionBlocks add: ( #ClobLocator -&gt; [ :ignoredValue | 0 ] ).</body><body package="DB2EXDI">initializeDBClobConversions: xif	"Conversion to/from DBCLOB"	fSqlTypeToConversionMap add: ( xif SQL_DBCLOB -&gt; #LargeString ).</body><body package="DB2EXDI">initializeDBClobLocatorConversions: xif"Conversion to/from DBCLOB Locator"	conversionBufferMap add: (#DBClobLocator -&gt; UninterpretedBytes).	getSelectorMap add: ( #DBClobLocator -&gt; #getBlobLocatorAt: ).	putSelectorMap add: ( #DBClobLocator -&gt; #at:putBlobLocator: ).	fSqlTypeToConversionMap add: ( xif SQL_DBCLOB_LOCATOR -&gt; #DBClobLocator ).	fSqlTypeFromConversionMap add: ( #DBClobLocator -&gt; xif SQL_DBCLOB_LOCATOR ).	fCTypeFromConversionMap add: ( #DBClobLocator -&gt; xif SQL_C_DBCLOB_LOCATOR  ).	fetchBufferSizeBlocks add: ( #DBClobLocator -&gt; [ :ignored | 4 ] ).	valueSizeBlocks add: ( #DBClobLocator -&gt; [ :ignoredValue | 4 ] ).	valuePrecisionBlocks add: ( #DBClobLocator -&gt; [ :ignoredValue | 0 ] ).</body><body package="DB2EXDI">initializeDataLinkConversions: xif"Conversion to/from buffer for DataLink."	conversionBufferMap add: (#DataLink -&gt; ByteString).	fSqlTypeToConversionMap add: ( xif SQL_DATALINK -&gt; #DataLink ).	getSelectorMap add: ( #DataLink -&gt; #getDataLinkAt: ).	putSelectorMap add: ( #DataLink -&gt; #at:putDataLink: ).	fSqlTypeFromConversionMap add: ( #DataLink -&gt; xif SQL_DATALINK ).	fCTypeFromConversionMap add: ( #DataLink -&gt; xif SQL_C_DATALINK ).	fetchBufferSizeBlocks add: ( #DataLink -&gt; [ :size | 255 ] ).		valueSizeBlocks add: ( #DataLink -&gt; [ :ignoredValue | 255 ] ).		valuePrecisionBlocks add: ( #DataLink -&gt; [ :ignoredValue | 255 ] ).</body><body package="DB2EXDI">initializeDateConversions: xif	"Conversions to/from buffer for #Date."	conversionBufferMap add: (#Date -&gt; UninterpretedBytes).	getSelectorMap add: ( #Date -&gt;  #getDateAt: ).	putSelectorMap add: ( #Date -&gt;  #at:putDate: ).	fSqlTypeToConversionMap add: ( xif SQL_DATE -&gt; #Date ).	fSqlTypeToConversionMap add: ( xif SQL_TYPE_DATE -&gt; #Date ).	fSqlTypeFromConversionMap add: ( #Date -&gt; xif SQL_TYPE_DATE ).	fCTypeFromConversionMap add: ( #Date -&gt; xif SQL_C_TYPE_DATE ).	fetchBufferSizeBlocks add: ( #Date -&gt; [ :ignored | 6] ).	valueSizeBlocks add: ( #Date -&gt; [ :ignoredValue | 6 ] ).	valuePrecisionBlocks add: ( #Date -&gt; [ :ignoredValue | 0 ] ).	"Not used by SQLSetParam"</body><body package="DB2EXDI">initializeDoubleConversions: xif"Conversion to/from buffer for Double."	conversionBufferMap add: (#Double -&gt; UninterpretedBytes).	getSelectorMap add: ( #Double -&gt; #getDoubleAt: ).	putSelectorMap add: ( #Double -&gt; #at:putDouble: ).	fSqlTypeToConversionMap add: ( xif SQL_DOUBLE -&gt; #Double ).	fSqlTypeToConversionMap add: ( xif SQL_FLOAT -&gt; #Double ).	fSqlTypeFromConversionMap add: ( #Double -&gt; xif SQL_DOUBLE ).	fCTypeFromConversionMap add: ( #Double -&gt; xif SQL_C_DOUBLE ).	fetchBufferSizeBlocks add: ( #Double -&gt; [ :ignored | 8 ] ).	valueSizeBlocks add: ( #Double -&gt; [ :ignoredValue | 8 ] ).	valuePrecisionBlocks add: ( #Double -&gt; [ :ignoredValue | 0 ] ).</body><body package="DB2EXDI">initializeFileReferenceConversions: xif	"Conversion to/from LOB Reference"	"conversionBufferMap add: (#FileRef -&gt; nil)."	getSelectorMap add: ( #FileRef -&gt; #getFileRefAt: ).	putSelectorMap add: ( #FileRef -&gt; #at:putFileRef: ).	"fSqlTypeToConversionMap add: ( xif SQL_BLOB_LOCATOR -&gt; #BlobLocator ).	fSqlTypeFromConversionMap add: ( #BlobLocator -&gt; xif SQL_BLOB_LOCATOR ).	fCTypeFromConversionMap add: ( #BlobLocator -&gt; xif SQL_C_BLOB_LOCATOR  )."	"fetchBufferSizeBlocks add: ( #BlobLocator -&gt; [ :ignored | 4 ] ).	valueSizeBlocks add: ( #BlobLocator -&gt; [ :ignoredValue | 4 ] ).	valuePrecisionBlocks add: ( #BlobLocator -&gt; [ :ignoredValue | 0 ] )."</body><body package="DB2EXDI">initializeFixedPointConversions: xif"Conversion to/from buffer for FixedPoint."	conversionBufferMap add: (#FixedPoint -&gt; ByteString).	fSqlTypeToConversionMap add: ( xif SQL_DECIMAL -&gt; #FixedPoint ).	fSqlTypeToConversionMap add: ( xif SQL_NUMERIC -&gt; #FixedPoint ).	getSelectorMap add: ( #FixedPoint -&gt; #getFixedPointAt: ).	putSelectorMap add: ( #FixedPoint -&gt; #at:putFixedPoint: ).	fSqlTypeFromConversionMap add: ( #FixedPoint -&gt; xif SQL_DECIMAL ).	fCTypeFromConversionMap add: ( #FixedPoint -&gt; xif SQL_C_CHAR ).	fetchBufferSizeBlocks add: ( #FixedPoint -&gt; [ :size | size + 3 ] ).	"Add room for sign, decimal point, and null byte"	valueSizeBlocks add: ( #FixedPoint -&gt; [ :ignoredValue | 34 ] ).	"Leave room for sign, decimal point, and null byte"	valuePrecisionBlocks add: ( #FixedPoint -&gt; [ :ignoredValue | 31 ] ).	"This be the max."</body><body package="DB2EXDI">initializeFloatConversions: xif"Conversion from buffer for Float."	conversionBufferMap add: (#Float -&gt; UninterpretedBytes).	getSelectorMap add: ( #Float -&gt; #getFloatAt: ).	putSelectorMap add: ( #Float -&gt; #at:putFloat: ).	fSqlTypeToConversionMap add: ( xif SQL_REAL -&gt; #Float ).	fSqlTypeFromConversionMap add: ( #Float -&gt; xif SQL_REAL ).	fCTypeFromConversionMap add: ( #Float -&gt; xif SQL_C_FLOAT ).	fetchBufferSizeBlocks add: ( #Float -&gt; [ :ignored | 4 ] ).	valueSizeBlocks add: ( #Float -&gt; [ :ignoredValue | 4 ] ).	valuePrecisionBlocks add: ( #Float -&gt; [ :ignoredValue | 0 ] ).</body><body package="DB2EXDI">initializeIntegerConversions: xif"Conversion from buffer for Integer."	conversionBufferMap add: (#Integer -&gt; UninterpretedBytes).	getSelectorMap add: ( #Integer -&gt; #getIntegerAt: ).	putSelectorMap add: ( #Integer -&gt; #at:putInteger: ).	fSqlTypeToConversionMap add: ( xif SQL_SMALLINT -&gt; #Integer ).	fSqlTypeToConversionMap add: ( xif SQL_INTEGER -&gt; #Integer ).	fSqlTypeFromConversionMap add: ( #Integer -&gt; xif SQL_INTEGER ).	fCTypeFromConversionMap add: ( #Integer -&gt; xif SQL_C_LONG ).	fetchBufferSizeBlocks add: ( #Integer -&gt; [ :ignored | 4 ] ).	valueSizeBlocks add: ( #Integer -&gt; [ :ignoredValue | 4 ] ).	valuePrecisionBlocks add: ( #Integer -&gt; [ :ignoredValue | 0 ] )</body><body package="DB2EXDI">initializeStringConversions: xif	"Conversion from buffer for String."	| charVPB |	conversionBufferMap add: (#String -&gt; nil).	getSelectorMap add: ( #String -&gt; #getStringAt: ).	putSelectorMap add: ( #String -&gt; #at:putString: ).	fSqlTypeToConversionMap add: ( xif SQL_CHAR -&gt; #String ).	fSqlTypeToConversionMap add: ( xif SQL_WCHAR -&gt; #String ).	fSqlTypeToConversionMap add: ( xif SQL_VARCHAR -&gt; #String ).	fSqlTypeToConversionMap add: ( xif SQL_WVARCHAR -&gt; #String ).	fSqlTypeToConversionMap add: ( xif SQL_LONGVARCHAR -&gt; #LargeString ).	fSqlTypeToConversionMap add: ( xif SQL_WLONGVARCHAR -&gt; #LargeString ).	fSqlTypeToConversionMap add: ( xif SQL_GRAPHIC -&gt; #String ).	fSqlTypeToConversionMap add: ( xif SQL_VARGRAPHIC -&gt; #String ).	fSqlTypeToConversionMap add: ( xif SQL_LONGVARGRAPHIC -&gt; #LargeString ).	fSqlTypeFromConversionMap add: ( #String -&gt; xif SQL_VARCHAR ).	fCTypeFromConversionMap add: ( #String -&gt; xif SQL_C_CHAR ).	charVPB := [ :str | | sz |		(sz := str size) &lt;= 256			ifTrue: [ 256 ]			ifFalse: [ 32700  min: (2 raisedTo: ( (sz floorLog: 2) + 1) ) ] ].	fetchBufferSizeBlocks add: ( #String -&gt; [ :size | size + 1 ] ).	"Leave room for a null."	valueSizeBlocks add: ( #String -&gt; charVPB ).	valuePrecisionBlocks add: ( #String -&gt; charVPB ).</body><body package="DB2EXDI">initializeTimeConversions: xif"Conversion from buffer for Time."	conversionBufferMap add: (#Time -&gt; UninterpretedBytes).	getSelectorMap add: ( #Time -&gt; #getTimeAt: ).	putSelectorMap add: ( #Time -&gt; #at:putTime: ).	fSqlTypeToConversionMap add: ( xif SQL_TIME -&gt; #Time ).	fSqlTypeToConversionMap add: ( xif SQL_TYPE_TIME -&gt; #Time ).	fSqlTypeFromConversionMap add: ( #Time -&gt; xif SQL_TYPE_TIME ).	fCTypeFromConversionMap add: ( #Time -&gt; xif SQL_C_TYPE_TIME ).	fetchBufferSizeBlocks add: ( #Time -&gt; [ :ignored | 6 ] ).	valueSizeBlocks add: ( #Time -&gt; [ :ignoredValue | 6 ] ).	valuePrecisionBlocks add: ( #Time -&gt; [ :ignoredValue | 0 ] ).</body><body package="DB2EXDI">initializeTimestampConversions: xif"Conversion from buffer for Timestamp."	conversionBufferMap add: (#Timestamp -&gt; UninterpretedBytes).	getSelectorMap add: ( #Timestamp -&gt; #getTimestampAt: ).	putSelectorMap add: ( #Timestamp -&gt; #at:putTimestamp: ).	fSqlTypeToConversionMap add: ( xif SQL_TIMESTAMP -&gt; #Timestamp ).	fSqlTypeToConversionMap add: ( xif SQL_TYPE_TIMESTAMP -&gt; #Timestamp ).	fSqlTypeFromConversionMap add: ( #Timestamp -&gt; xif SQL_TYPE_TIMESTAMP ).	fCTypeFromConversionMap add: ( #Timestamp -&gt; xif SQL_C_TYPE_TIMESTAMP ).	fetchBufferSizeBlocks add: ( #Timestamp -&gt; [ :ignored | 16 ] ).	valueSizeBlocks add: ( #Timestamp -&gt; [ :ignoredValue | 16 ] ).	valuePrecisionBlocks add: ( #Timestamp -&gt; [ :ignoredValue | 0 ] ).</body><body package="DB2EXDI">privateInitializeMaps	"initSelectorMap := IdentityDictionary new.	freeSelectorMap := IdentityDictionary new."	getSelectorMap := IdentityDictionary new.	putSelectorMap := IdentityDictionary new.	fSqlTypeToConversionMap := IdentityDictionary new.	fSqlTypeFromConversionMap := IdentityDictionary new.	fCTypeFromConversionMap := IdentityDictionary new.	fetchBufferSizeBlocks := IdentityDictionary new.	valueSizeBlocks := IdentityDictionary new.	valuePrecisionBlocks := IdentityDictionary new.	conversionBufferMap  := IdentityDictionary new.</body></methods><methods><class-id>Database.DB2APIInterface</class-id> <category>procedures</category><body package="DB2EXDI">sqlaintp: msgbuf with: bufsize with: linesize with: sqlcaptr	| pMoFile rc |	[ pMoFile := 'db2sql.mo' copyToHeap.	rc:=self sqlaintp_api: msgbuf with: bufsize with: linesize with: pMoFile with: sqlcaptr]	ensure: [pMoFile notNil ifTrue: [pMoFile free ]].	^rc</body></methods><methods><class-id>Database.DB2APIInterface</class-id> <category>accessing</category><body package="DB2EXDI">db2Version	^self db2Version710</body><body package="DB2EXDI">mallocSelector	^#malloc:</body></methods><methods><class-id>Database.DB2APIInterface class</class-id> <category>initialize</category><body package="DB2EXDI">initialize		self initializeDefineCaches</body><body package="DB2EXDI">initializeDefineCaches	"This should only be done if the DLLCC development environment is present in the image."	"self fillDefineCaches.	self fillDefineCaches"	"Do twice in case there are longer reference chains."</body></methods><methods><class-id>Database.DB2API64BitInterface class</class-id> <category>initialize</category><body package="DB2EXDI">initialize		self initializeDefineCaches</body><body package="DB2EXDI">initializeDefineCaches	"This should only be done if the DLLCC development environment is present in the image."	"self fillDefineCaches.	self fillDefineCaches"	"Do twice in case there are longer reference chains."</body></methods><methods><class-id>Database.DB2Connection</class-id> <category>private-execution</category><body package="DB2EXDI">acquireExternal: aPassword 	" username and password on local instance of DB2 may be empty string, in this case current account is used"	| xif rc name pw env szDSN szUID szAuthStr env1 nm1 pw1 |	xif := self class xif.	name := self username.	[name isString] 		whileFalse: [name := self class requiredUsernameSignal raiseRequest].	pw := aPassword.	[pw isString] 		whileFalse: [pw := self class requiredPasswordSignal raiseRequest].	(env := self environment) isNil 		ifTrue: [env := self class defaultEnvironment].	[env isString] 		whileFalse: [env := self class requiredEnvironmentSignal raiseRequest].	env := self class mapLogical: env.	"Get required handles."	HenvLock critical: [self unprotectedAllocConnect].		["Begin unwind protection (level 1) -- ensure release of connection handle on failure."		["Begin unwind protection (level 2) -- ensure release of pointers on success or failure."	szDSN := (env1 := env asByteArrayEncoding: self encoding) 				perform: xif copyToHeapSelector.	szUID := (nm1 := name asByteArrayEncoding: self encoding) 				perform: xif copyToHeapSelector.	szAuthStr := (pw1 := pw asByteArrayEncoding: self encoding) 				perform: xif copyToHeapSelector.	self isUnicodeEncoding ifTrue: [		rc := xif SQLConnectW: self hdbc				with: szDSN				with: env size				with: szUID				with: name size				with: szAuthStr				with: pw size.	] ifFalse: [		rc := xif SQLConnect: self hdbc				with: szDSN				with: env1 size				with: szUID				with: nm1 size				with: szAuthStr				with: pw1 size.	].	traceLevel &gt;= 1 		ifTrue: 			[(self traceStream)				print: rc;				nextPutAll: ' = SQLConnect( hdbc = ';				nextPutAll: (self hdbc printStringRadix: 16);				nextPutAll: ', szDSN = ';				nextPutAll: env;				nextPutAll: ', szUID = ';				nextPutAll: name;				nextPutAll: ', szAuthStr = ******* )'.			self class trace: self emitTrace]	"End unwind protection (level 2)"] 			ensure: 				[szAuthStr notNil ifTrue: [szAuthStr freePointer].				szUID notNil ifTrue: [szUID freePointer].				szDSN notNil ifTrue: [szDSN freePointer]].	(rc == xif SQL_SUCCESS or: [rc == xif SQL_SUCCESS_WITH_INFO]) 		ifFalse: 			[| errs |			errs := self getConnectionErrors.			^self class unableToConnectToSQLserverSignal raiseWith: errs				errorString: errs first dbmsErrorString]	"End unwind protection (level 1)"] 			ifCurtailed: 				["Some failure is causing unwind, don't keep the handles."				HenvLock critical: [self unprotectedFreeConnect]].	"Enter autocommit mode on the transaction."	self singleStatementTransactions	"Set the correct isolation level for this connect"	"self setIsolationLevel: (SupportedIsolationLevels at: isolationLevel)."</body><body package="DB2EXDI">beginExternal	super beginExternal.	self multiStatementTransactions</body><body package="DB2EXDI">commitExternal	super commitExternal ifFalse: [ ^self ].	self transactExternal: #SQL_COMMIT.	self singleStatementTransactions</body><body package="DB2EXDI">cursorsAreClosed	"Notify each participating session that the cursor was closed by some event (like commit or rollback)."	self participantsDo: [ :each | each cursorIsClosed ]</body><body package="DB2EXDI">cursorsAreDeleted	"Notify each participating session that the cursor was deleted by some event (like commit or rollback)."	self participantsDo: [ :each | each cursorIsDeleted ]</body><body package="DB2EXDI">dismissExternal	"Note: blobHstmt will be automatically dropped on SQLDisconnect() call"	| xif rc |	xif := self class xif.		["Begin unwind protection."	self hdbc isNil ifTrue: [^self].	rc := xif SQLDisconnect: self hdbc.	traceLevel &gt;= 2 		ifTrue: 			[(self traceStream)				print: rc;				nextPutAll: ' = SQLDisconnect( hdbc = ';				nextPutAll: (self hdbc printStringRadix: 16);				nextPutAll: ' )'.			self class trace: self emitTrace].	rc == xif SQL_SUCCESS 		ifFalse: 			[| errs |			errs := self getConnectionErrors.			^self class unableToDisconnectSignal raiseRequestWith: errs]	"End unwind protection."] 			ensure: 				["Whether or not there was a failure, there's no point in hanging			onto the handles."				HenvLock critical: [self unprotectedFreeConnect].				self supportedFunctions: IdentityDictionary new.				self generalInformationCache: IdentityDictionary new]</body><body package="DB2EXDI">getDataSourceExternal: fDirection	"Return the next piece of error or status information, or NULL if none."	| xif cbDSNMax cbDescriptionMax szDSN pcbDSN szDescription pcbDescription rc ds |	xif := self class xif.	cbDSNMax :=  xif SQL_MAX_DSN_LENGTH + 1.	cbDescriptionMax := 254 + 1.	[ "Begin unwind protection."	szDSN := xif SQLCHAR perform: xif mallocSelector with: cbDSNMax.	pcbDSN := xif SQLSMALLINT perform: xif mallocSelector with: 1.	szDescription := xif SQLCHAR perform: xif mallocSelector with: cbDescriptionMax.	pcbDescription := xif SQLSMALLINT perform: xif mallocSelector with: 1.	HenvLock critical:		[ "Begin critical section."		self isUnicodeEncoding ifTrue: [		 	rc := xif SQLDataSourcesW: self class henv				with: fDirection				with: szDSN				with: cbDSNMax				with: pcbDSN				with: szDescription				with: cbDescriptionMax				with: pcbDescription.		] ifFalse: [		 	rc := xif SQLDataSources: self class henv				with: fDirection				with: szDSN				with: cbDSNMax				with: pcbDSN				with: szDescription				with: cbDescriptionMax				with: pcbDescription.	].		(( rc == xif SQL_SUCCESS )		or: [ rc == xif SQL_SUCCESS_WITH_INFO ] ) ifTrue:			[ ds := self class dataSourceClass new.			  ds name: szDSN copyCStringFromHeap.			  ds description: szDescription copyCStringFromHeap.]		"End critical section." ]	"End unwind protection." ]		ensure:			[ szDSN notNil ifTrue: [ szDSN freePointer ].			pcbDSN notNil ifTrue: [ pcbDSN freePointer ].			szDescription notNil ifTrue: [ szDescription freePointer ].		    pcbDescription notNil ifTrue: [ pcbDescription freePointer ] ].	^ds</body><body package="DB2EXDI">getErrorsExternal: handleType handle: aHandle recNumber: aRecNumber	"Return the next piece of error or status information, or nil if none."	| xif szSqlState pfNativeError szErrorMsg cbErrorMsgMax pcbErrorMsg rc error |	xif := self class xif.	[ "Begin unwind protection."	szSqlState := xif SQLCHAR perform: xif mallocSelector with: (self bytesPerCharacter*(xif SQL_SQLSTATE_SIZE + 1)).	pfNativeError := xif SQLINTEGER perform: xif mallocSelector with: 1.	szErrorMsg := xif UCHAR			perform: xif mallocSelector			with: (cbErrorMsgMax := self bytesPerCharacter*(xif SQL_MAX_MESSAGE_LENGTH + 1)).	pcbErrorMsg := xif SQLSMALLINT  perform: xif mallocSelector with: 1.	self isUnicodeEncoding ifTrue: [		rc := xif SQLGetDiagRecW: handleType			with: aHandle			with: aRecNumber			with: szSqlState			with: pfNativeError			with: szErrorMsg			with: cbErrorMsgMax			with: pcbErrorMsg.	] ifFalse: [		rc := xif SQLGetDiagRec: handleType			with: aHandle			with: aRecNumber			with: szSqlState			with: pfNativeError			with: szErrorMsg			with: cbErrorMsgMax			with: pcbErrorMsg.	].	rc == xif SQL_SUCCESS ifTrue:		[ error := self class errorClass new.	     	error dbmsErrorCode: pfNativeError contents.	     	error dbmsErrorString: (szErrorMsg copyCStringFromHeap: self encoding).	     	error sqlState: (szSqlState copyCStringFromHeap: self encoding).		( traceLevel &gt;= 2 ) ifTrue:			[ (self traceStream)				print: rc;  				nextPutAll: ' = SQLGetDiagRec( handleType = *, handle = *, szSqlState = '; 				nextPutAll: error sqlState;				nextPutAll: ', pfNativeError = '; print: error dbmsErrorCode;				nextPutAll: ', szErrorMsg = '; nextPutAll: error dbmsErrorString;				nextPutAll: ', cbErrorMsgMax = '; print: cbErrorMsgMax;				nextPutAll: ', pcbErrorMsg = '; print: pcbErrorMsg contents;				nextPutAll: ' )'; crtab.			self class trace: self emitTrace ] ].	"End unwind protection." ]		ensure:			[ szSqlState notNil ifTrue: [ szSqlState freePointer ].			pfNativeError notNil ifTrue: [ pfNativeError freePointer ].			szErrorMsg notNil ifTrue: [ szErrorMsg freePointer ].			pcbErrorMsg notNil ifTrue: [ pcbErrorMsg freePointer ] ].	^error</body><body package="DB2EXDI">getInformationTypeExternal: fInfoTypeSymbol 	"Answer the information associated with fInfoTypeSymbol.  This information is defined only after connecting."	| xif cbInfoValueMax rgbInfoValue pcbInfoValue rc ub infoValue |	xif := self class xif.	cbInfoValueMax := 256.	"Arbitrary number for a max."		["Begin unwind protection."	rgbInfoValue := xif UCHAR perform: xif mallocSelector with: cbInfoValueMax.	pcbInfoValue := xif SWORD perform: xif mallocSelector with: 1.	self isUnicodeEncoding ifTrue: [		rc := xif SQLGetInfoW: self hdbc				with: (xif perform: fInfoTypeSymbol)				with: rgbInfoValue				with: cbInfoValueMax				with: pcbInfoValue.	] ifFalse: [		rc := xif SQLGetInfo: self hdbc				with: (xif perform: fInfoTypeSymbol)				with: rgbInfoValue				with: cbInfoValueMax				with: pcbInfoValue.	].	(rc == xif SQL_SUCCESS or: [rc == xif SQL_SUCCESS_WITH_INFO]) 		ifFalse: 			[| errs |			errs := self getConnectionErrors.			errs first sqlState = '40003' ifTrue: [^self].			^self class unableToQueryDriverInformationSignal raiseWith: errs				errorString: errs first dbmsErrorString].	ub := UninterpretedBytes new: pcbInfoValue contents.	rgbInfoValue 		copyAt: 0		to: ub		size: ub sizeInBytes		startingAt: 1.	infoValue := ub perform: (SQLInfoTypeConversionMap at: fInfoTypeSymbol)				with: 1	"End unwind protection."] 			ensure: 				[rgbInfoValue notNil ifTrue: [rgbInfoValue freePointer].				pcbInfoValue notNil ifTrue: [pcbInfoValue freePointer]].	^infoValue</body><body package="DB2EXDI">getSupportedFunctionExternal: fFunctionSymbol 	"Answer a boolean indicating whether the function corresponding to the fFunctionSymbol is supported by the driver.  This information is defined only after connecting as the specific driver to use is not defined yet."	| xif rc pfSupportedPointer supported |	xif := self class xif.		["Begin unwind protection."	pfSupportedPointer := xif SQLUSMALLINT perform: xif mallocSelector with: 1.	rc := xif 				SQLGetFunctions: self hdbc				with: (xif perform: fFunctionSymbol)				with: pfSupportedPointer.	traceLevel &gt;= 4 		ifTrue: 			[(self traceStream)				print: rc;				nextPutAll: ' = SQLGetFunctions( hdbc = ';				nextPutAll: (self hdbc printStringRadix: 16);				nextPutAll: ', fFunction = ';				nextPutAll: fFunctionSymbol;				nextPutAll: ', pfSupported =';				print: pfSupportedPointer contents;				nextPutAll: ' )'.			self class trace: self emitTrace].	rc == xif SQL_SUCCESS 		ifFalse: 			[| errs |			errs := self getConnectionErrors.			self class unableToQueryDriverInformationSignal raiseWith: errs				errorString: errs first dbmsErrorString].	supported := pfSupportedPointer contents == 1	"End unwind protection."] 			ensure: [pfSupportedPointer notNil ifTrue: [pfSupportedPointer freePointer]].	^supported</body><body package="DB2EXDI">installExternal	super installExternal.	self hdbc: nil.	self supportedFunctions: IdentityDictionary new.	self generalInformationCache: IdentityDictionary new.</body><body package="DB2EXDI">multiStatementTransactions	"Take the receiver's connection out of auto-commit mode for transaction behavior."	"If receiver is connected to a driver which supports control over the autocommit behavior then this is the preferred mechanism for implementing the transaction behavior defined for the EXDI."	| xif rc |	xif := self class xif.	rc := xif 				SQLSetConnectAttr: self hdbc				with: xif SQL_ATTR_AUTOCOMMIT				with: xif SQL_AUTOCOMMIT_OFF				with: 0.	traceLevel &gt;= 3 		ifTrue: 			[(self traceStream)				print: rc;				nextPutAll: ' = SQLSetConnectAttr( hdbc = ';				nextPutAll: (self hdbc printStringRadix: 16);				nextPutAll: ', SQL_ATTR_AUTOCOMMIT, SQL_AUTOCOMMIT_OFF)'.			self class trace: self emitTrace].	rc == xif SQL_SUCCESS 		ifFalse: 			[| errs |			errs := self getConnectionErrors.			self class transactionExceptionSignal raiseWith: errs				errorString: errs first dbmsErrorString]</body><body package="DB2EXDI">rollbackExternal	super rollbackExternal ifFalse: [ ^self ].	self transactExternal: #SQL_ROLLBACK.	self singleStatementTransactions</body><body package="DB2EXDI">setIsolationLevel: anIsolationLevel 	"Take the receiver's connection out of auto-commit mode for transaction behavior."	| xif rc |	xif := self class xif.	rc := xif 				SQLSetConnectAttr: self hdbc				with: xif SQL_ATTR_TXN_ISOLATION				with: (xif perform: anIsolationLevel)				with: 0.	traceLevel &gt;= 3 		ifTrue: 			[(self traceStream)				print: rc;				nextPutAll: ' = SQLSetConnectAttr( hdbc = ';				nextPutAll: (self hdbc printStringRadix: 16);				nextPutAll: ', SQL_ATTR_TXN_ISOLATION, ';				nextPutAll: isolationLevel;				nextPutAll: ')'.			self class trace: self emitTrace].	rc == xif SQL_SUCCESS 		ifFalse: 			[| errs |			errs := self getConnectionErrors.			self class transactionExceptionSignal raiseWith: errs				errorString: errs first dbmsErrorString]</body><body package="DB2EXDI">singleStatementTransactions	"Put the receiver's connection into auto-commit mode for transaction behavior."	| xif rc |	xif := self class xif.	rc := xif 				SQLSetConnectAttr: self hdbc				with: xif SQL_ATTR_AUTOCOMMIT				with: xif SQL_AUTOCOMMIT_ON				with: 0.	traceLevel &gt;= 3 		ifTrue: 			[(self traceStream)				print: rc;				nextPutAll: ' = SQLSetConnectAttr( hdbc = ';				nextPutAll: (self hdbc printStringRadix: 16);				nextPutAll: ', SQL_ATTR_AUTOCOMMIT, SQL_AUTOCOMMIT_ON)'.			self class trace: self emitTrace].	rc == xif SQL_SUCCESS 		ifFalse: 			[| errs |			errs := self getConnectionErrors.			self class transactionExceptionSignal raiseWith: errs				errorString: errs first dbmsErrorString]</body><body package="DB2EXDI">transactExternal: fTypeSymbol 	| xif rc behavior |	xif := self class xif.	rc := xif 				SQLEndTran: xif SQL_HANDLE_DBC				with: self hdbc				with: (xif perform: fTypeSymbol).	traceLevel &gt;= 1 		ifTrue: 			[(self traceStream)				print: rc;				nextPutAll: ' = SQLEndTran( handleType = SQL_HANDLE_DBC, hdbc = ';				nextPutAll: (self hdbc printStringRadix: 16);				nextPutAll: ', fType = ';				nextPutAll: fTypeSymbol;				nextPutAll: ')'.			self class trace: self emitTrace].	rc == xif SQL_SUCCESS 		ifFalse: 			[| errs |			errs := self getConnectionErrors.			self class transactionExceptionSignal raiseWith: errs				errorString: errs first dbmsErrorString].	"What are the side effects of the end of the transaction."	fTypeSymbol == #SQL_COMMIT 		ifTrue: [behavior := self getInformationType: #SQL_CURSOR_COMMIT_BEHAVIOR].	fTypeSymbol == #SQL_ROLLBACK 		ifTrue: [behavior := self getInformationType: #SQL_CURSOR_ROLLBACK_BEHAVIOR].	behavior == xif SQL_CB_DELETE ifTrue: [self cursorsAreDeleted].	behavior == xif SQL_CB_CLOSE ifTrue: [self cursorsAreClosed]</body></methods><methods><class-id>Database.DB2Connection</class-id> <category>private-accessing</category><body package="DB2EXDI">blobHstmt	blobHstmt isNil ifTrue: [self getBlobHstmt].	^blobHstmt</body><body package="DB2EXDI">bytesPerCharacter	^self isUnicodeEncoding ifTrue: [2] ifFalse: [1]</body><body package="DB2EXDI">generalInformationCache	^generalInformationCache</body><body package="DB2EXDI">generalInformationCache: anIdentityDictionary	generalInformationCache := anIdentityDictionary</body><body package="DB2EXDI">getBlobHstmt	"Acquire statement handle for LOB handling."	| xif phstmt rc |	xif := self class xif.		["Begin unwind protection."	phstmt := xif SQLHSTMT perform: xif mallocSelector with: 1.	rc := xif 				SQLAllocHandle: xif SQL_HANDLE_STMT				with: self hdbc				with: phstmt.	traceLevel &gt;= 3 		ifTrue: 			[(self traceStream)				print: rc;				nextPutAll: ' = SQLAllocStmt( hdbc = ';				nextPutAll: (self hdbc printStringRadix: 16);				nextPutAll: ', hstmt = ';				nextPutAll: (phstmt contents printStringRadix: 16);				nextPutAll: ' )'.			self class trace: self emitTrace].	rc == xif SQL_SUCCESS 		ifFalse: 			[| errs |			errs := self getConnectionErrors.			self class connectionClass unableToAllocateHandleSignal raiseWith: errs				errorString: errs first dbmsErrorString].	blobHstmt := phstmt contents	"End unwind protection."] 			ensure: [phstmt notNil ifTrue: [phstmt freePointer]]</body><body package="DB2EXDI">getConnectionErrors	"Return a collection of DB2Error(s) associated with the connection handle."	| xif errors err num | 	xif := self class xif.	errors := OrderedCollection new.	num:=0.	[ (err := self getErrorsExternal: xif SQL_HANDLE_DBC				handle: self hdbc				recNumber: (num:=num+1)) notNil ]		whileTrue: [ errors add: err ].	^errors</body><body package="DB2EXDI">getEnvironmentErrors	"Answer a collection of DB2Error(s) associated with the environment handle."	| xif errors err num | 	xif := self class xif.	errors := OrderedCollection new.	num:=0.	HenvLock critical:		[ "Begin critical section."		[ (err := self getErrorsExternal: xif SQL_HANDLE_ENV				handle: self class henv				recNumber: (num:=num+1)) notNil ]			whileTrue: [ errors add: err ].		"End critical section." ].	^errors</body><body package="DB2EXDI">getInformationType: anInfoTypeSymbol	"Answer driver sql type information"	| gic |	^(gic := self generalInformationCache) at: anInfoTypeSymbol ifAbsent:		[ | infoType |		infoType := self getInformationTypeExternal: anInfoTypeSymbol.		gic at: anInfoTypeSymbol put: infoType.		infoType ].</body><body package="DB2EXDI">getStatementErrors: hstmt	"Return a collection of DB2Error(s) associated with the statement handle.	This message send by DB2Buffer "	| xif errors err num | 	xif := self class xif.	errors := OrderedCollection new.	num:=0.	[ (err := self getErrorsExternal: xif SQL_HANDLE_STMT				handle: hstmt				recNumber: (num:=num+1)) notNil ]		whileTrue: [ errors add: err ].	^errors</body><body package="DB2EXDI">hdbc	^self hdbcHolder value</body><body package="DB2EXDI">hdbc: aCPointerOrNil	"Now hdbc is Integer"	self hdbcHolder value: aCPointerOrNil</body><body package="DB2EXDI">hdbcHolder	^hdbcHolder</body><body package="DB2EXDI">hdbcHolder: aValueHolder	hdbcHolder := aValueHolder</body><body package="DB2EXDI">isolationLevel: newIsolationLevel 	"Set the current isolation level."	| externalIsolationLevel |	externalIsolationLevel := SupportedIsolationLevels at: newIsolationLevel ifAbsent: [ExternalDatabaseConnection unsupportedIsolationLevelSignal raise].	self isConnected ifTrue: [self setIsolationLevel: externalIsolationLevel].	isolationLevel := newIsolationLevel</body><body package="DB2EXDI">supportedFunctions	^supportedFunctions</body><body package="DB2EXDI">supportedFunctions: anIdentityDictionary	supportedFunctions := anIdentityDictionary</body><body package="DB2EXDI">supportsFunction: functionSymbol	"Answer if the attached driver supports the given function"	^self supportedFunctions at: functionSymbol ifAbsentPut:		[self getSupportedFunctionExternal: functionSymbol]</body><body package="DB2EXDI">traceLevel	^traceLevel</body></methods><methods><class-id>Database.DB2Connection</class-id> <category>accessing</category><body package="DB2EXDI">dataSources	"Return a List of accessible DB2DataSource instances.  The receiver does not need to be connected."	| xif dataSources fDirection ds |	xif := self class xif.	"If we don't have an environment handle allocated, get one now."	HenvLock critical: [ self unprotectedAddHenvReference ].	[ "Begin unwind protection."	dataSources := List new.	fDirection := xif SQL_FETCH_FIRST.	[ (ds := self getDataSourceExternal: fDirection) notNil ] whileTrue:		[ fDirection := xif SQL_FETCH_NEXT.		dataSources add: ds ].	"End unwind protection." ]		ensure:	[ HenvLock critical: [ self unprotectedDropHenvReference ] ].	^dataSources</body><body package="DB2EXDI">dbmsName	"Answer the name of the DBMS product being accessed"	^self getInformationType: #SQL_DBMS_NAME.</body><body package="DB2EXDI">dbmsVersion	"Answer the version of the DBMS product being accessed"	^self getInformationType: #SQL_DBMS_VER.</body><body package="DB2EXDI">delimitedIdentifierCharacter	"Answer the delimiter of the DBMS product being accessed	a space indicates no delimited identifiers supported"	^self getInformationType: #SQL_IDENTIFIER_QUOTE_CHAR.</body><body package="DB2EXDI">encoding	encoding isNil ifTrue: [		encoding := self class xif encoding	].	^encoding</body><body package="DB2EXDI">unicodeEncoding	unicodeEncoding isNil ifTrue: [ unicodeEncoding := #'UCS-2' ].	^unicodeEncoding</body><body package="DB2EXDI">unicodeEncoding: anEncoding	unicodeEncoding := anEncoding</body></methods><methods><class-id>Database.DB2Connection</class-id> <category>private-finalization</category><body package="DB2EXDI">executor 	| ex |	ex := super executor.	ex hdbcHolder: self hdbcHolder.	ex supportedFunctions: IdentityDictionary new.	ex generalInformationCache: IdentityDictionary new.	^ex</body><body package="DB2EXDI">finalizeExternal	self hdbc isNil  ifTrue: [ ^self ].	( traceLevel &gt;= 1 ) ifTrue: [ self class trace: nil ].	super finalizeExternal</body><body package="DB2EXDI">key	"The hdbcHolder is unique to the connection and is constant	across pause/resume."	^self hdbcHolder</body></methods><methods><class-id>Database.DB2Connection</class-id> <category>datalink-functions</category><body package="DB2EXDI">getDLAttribute: attributeName for: aDataLink 	"attributeName from: 	 #SQL_ATTR_DATALINK_COMMENT        #SQL_ATTR_DATALINK_LINKTYPE        #SQL_ATTR_DATALINK_URLCOMPLETE     (complete URL to access a file)        #SQL_ATTR_DATALINK_URLPATH (to access a file within a file server)        #SQL_ATTR_DATALINK_URLPATHONLY (file path only)        #SQL_ATTR_DATALINK_URLSCHEME        #SQL_ATTR_DATALINK_URLSERVER"	| xif attr rc bytes attrString pDataLink pValue pLength |	xif := self class xif.	attr := xif perform: attributeName.		[pDataLink := aDataLink dlValue copyToHeap.	pValue := CIntegerType char malloc: 256.	"max attr size"	pLength := xif SQLINTEGER malloc: 1.	rc := xif 				SQLGetDataLinkAttr: self blobHstmt				with: attr				with: pDataLink				with: aDataLink dlValue size				with: pValue				with: 256				with: pLength.	rc == xif SQL_SUCCESS 		ifFalse: 			[| errs |			errs := self getStatementErrors: self blobHstmt.			^self class unableToFetchDataSignal raiseWith: errs				errorString: errs first dbmsErrorString].	pLength isNull ifTrue: [^nil].	bytes := pLength contents.	attrString := ByteString new: bytes.	pValue 		copyAt: 0		to: attrString		size: bytes		startingAt: 1] 			ensure: 				[pDataLink notNil ifTrue: [pDataLink freePointer].				pValue notNil ifTrue: [pValue freePointer].				pLength notNil ifTrue: [pLength freePointer]].	^attrString</body></methods><methods><class-id>Database.DB2Connection</class-id> <category>blob-private</category><body package="DB2EXDI">getLOBLength: aLocator buffer: aBuffer"Retrieve length of a string/blob value"		^self getLOBLength: aLocator</body><body package="DB2EXDI">getLOBSubString: aLocator from: aPosition length: aLength buffer: aBuffer 	"Retrieve substring of a string/blob value 	Private: for DB2LargeBuffer only"	| xif pIndicatorValue rc |	xif := self class xif.		["Begin unwind protection."	pIndicatorValue := xif SQLINTEGER perform: xif mallocSelector with: 1.	rc := xif 				SQLGetSubString: self blobHstmt				with: aLocator locatorCType				with: aLocator locator				with: aPosition				with: aLength				with: aLocator targetCType				with: aBuffer blobBuffer				with: aBuffer blobBufferSize				with: nil				with: pIndicatorValue.	"dataPtr"	"pStringLength"	traceLevel &gt;= 1 		ifTrue: 			[(self traceStream)				print: rc;				nextPutAll: ' = SQLGetSubString ( hstmt = ';				nextPutAll: (self blobHstmt printStringRadix: 16);				nextPutAll: ', locatorCType = ';				nextPutAll: aLocator locatorCType printString;				nextPutAll: ', targetCType = ';				nextPutAll: aLocator targetCType printString;				nextPutAll: ', aLocator = ';				nextPutAll: (aLocator locator printStringRadix: 16);				nextPutAll: ', dataPtr = ' 							, (aBuffer blobBuffer referentAddress printStringRadix: 16).			self class trace: self emitTrace].	(rc == xif SQL_SUCCESS or: [rc == xif SQL_SUCCESS_WITH_INFO]) 		ifFalse: 			[| errs |			errs := self getStatementErrors: self blobHstmt.			"self resultsCache: errs."			self class unableToFetchDataSignal raiseWith: errs				errorString: errs first dbmsErrorString]	"End unwind protection."] 			ensure: [pIndicatorValue notNil ifTrue: [pIndicatorValue freePointer]].	^self</body><body package="DB2EXDI">getLOBSubString: aLocator from: aPosition length: aLength buffer: aBufferPointer bufferSize: anInteger	"Retrieve substring of a string/blob value. aPosition, aLength, anInteger are all based in Characters,	so the number of bytes is twice this for unicode. Curiously, the return value is actually in Bytes.	Private: for DB2LargeBuffer only"	| xif pIndicatorValue pStringLength rc lengthInBytes |	xif := self class xif.		["Begin unwind protection."	pIndicatorValue := xif SQLINTEGER perform: xif mallocSelector with: 1.	pStringLength := xif SQLINTEGER perform: xif mallocSelector with: 1.	rc := xif 	SQLGetSubString: self blobHstmt				with: aLocator locatorCType				with: aLocator locator				with: aPosition				with: aLength				with: aLocator targetCType				with: aBufferPointer				with: anInteger				with: pStringLength				with: pIndicatorValue.	"dataPtr"	"pStringLength"	traceLevel &gt;= 1 		ifTrue: 			[(self traceStream)				print: rc;				nextPutAll: ' = SQLGetSubString ( hstmt = ';				nextPutAll: (self blobHstmt printStringRadix: 16);				nextPutAll: ', locatorCType = ';				nextPutAll: aLocator locatorCType printString;				nextPutAll: ', targetCType = ';				nextPutAll: aLocator targetCType printString;				nextPutAll: ', aLocator = ';				nextPutAll: (aLocator locator printStringRadix: 16);				nextPutAll: ', dataPtr = ' 							, (aBufferPointer referentAddress printStringRadix: 16).			self class trace: self emitTrace].	(rc == xif SQL_SUCCESS or: [rc == xif SQL_SUCCESS_WITH_INFO]) ifTrue: [		lengthInBytes := pStringLength contents.	] ifFalse: [| errs |		errs := self getStatementErrors: self blobHstmt.		"self resultsCache: errs."		self class unableToFetchDataSignal raiseWith: errs errorString: errs first dbmsErrorString]	"End unwind protection."] ensure: [		pIndicatorValue notNil ifTrue: [pIndicatorValue freePointer].		pStringLength notNil ifTrue: [pStringLength freePointer]	].	^lengthInBytes</body></methods><methods><class-id>Database.DB2Connection</class-id> <category>blob-functions</category><body package="DB2EXDI">getLOBLength: aLocator 	"Retrieve length of a string/blob value"	| xif pStringLength pIndicatorValue rc result |	xif := self class xif.		["Begin unwind protection."	pStringLength := xif SQLINTEGER perform: xif mallocSelector with: 1.	pIndicatorValue := xif SQLINTEGER perform: xif mallocSelector with: 1.	rc := xif 				SQLGetLength: self blobHstmt				with: aLocator locatorCType				with: aLocator locator				with: pStringLength				with: pIndicatorValue.	traceLevel &gt;= 1 		ifTrue: 			[(self traceStream)				print: rc;				nextPutAll: ' = SQLGetLength:( hstmt = ';				nextPutAll: (self blobHstmt printStringRadix: 16);				nextPutAll: ', locatorCType = ';				nextPutAll: aLocator locatorCType printString;				nextPutAll: ', aLocator = ';				nextPutAll: (aLocator locator printStringRadix: 16);				nextPutAll: ', StringLength = ' , pStringLength contents printString.			self class trace: self emitTrace].	(rc == xif SQL_SUCCESS or: [rc == xif SQL_SUCCESS_WITH_INFO]) 		ifTrue: [result := pStringLength contents] 		ifFalse: 			[ | errs |			errs := self getStatementErrors: self blobHstmt.			"self resultsCache: errs."			self class unableToFetchDataSignal raiseWith: errs errorString: errs first dbmsErrorString	]	"End unwind protection."] 			ensure: 				[pStringLength notNil ifTrue: [pStringLength freePointer].				pIndicatorValue notNil ifTrue: [pIndicatorValue freePointer]].	^result</body><body package="DB2EXDI">getLOBPosition: aLocator search: aStringOrLocator from: aPosition 	"Retrieve position  of a sub-string/blob value"	| xif pLocatedAt pIndicatorValue rc result searchLocator searchLiteralLength searchLiteral |	xif := self class xif.		["Begin unwind protection."	pLocatedAt := xif SQLINTEGER perform: xif mallocSelector with: 1.	pIndicatorValue := xif SQLINTEGER perform: xif mallocSelector with: 1.	aStringOrLocator class == DB2LOBLocator 		ifTrue: 			[searchLocator := aStringOrLocator locator.			searchLiteralLength := 0.			searchLiteral := nil]		ifFalse: 			[searchLocator := 0.	"ignored"			searchLiteralLength := aStringOrLocator size.			searchLiteral := aStringOrLocator copyToHeap].	rc := xif 				SQLGetPosition: self blobHstmt				with: aLocator locatorCType				with: aLocator locator				with: searchLocator				with: searchLiteral				with: searchLiteralLength				with: aPosition				with: pLocatedAt				with: pIndicatorValue.	traceLevel &gt;= 1 		ifTrue: 			[(self traceStream)				print: rc;				nextPutAll: ' = SQLGetPosition ( hstmt = ';				nextPutAll: (self blobHstmt printStringRadix: 16);				nextPutAll: ', locatorCType = ';				nextPutAll: aLocator locatorCType printString;				nextPutAll: ', aLocator = ';				nextPutAll: (aLocator locator printStringRadix: 16);				nextPutAll: ', LocatedAt = ' , pLocatedAt contents printString.			self class trace: self emitTrace].	(rc == xif SQL_SUCCESS or: [rc == xif SQL_SUCCESS_WITH_INFO]) 		ifTrue: [result := pLocatedAt contents]		ifFalse: 			[| errs |			errs := self getStatementErrors: self blobHstmt.			"self resultsCache: errs."			self class unableToFetchDataSignal raiseWith: errs				errorString: errs first dbmsErrorString]	"End unwind protection."] 			ensure: 				[pLocatedAt notNil ifTrue: [pLocatedAt freePointer].				pIndicatorValue notNil ifTrue: [pIndicatorValue freePointer].				searchLiteral notNil ifTrue: [searchLiteral freePointer]].	^result</body><body package="DB2EXDI">getLOBSubString: aLocator from: aPosition length: aLength	"Retrieve substring of a string/blob value "	| xif result dataPtr |	xif := self class xif.		["Begin unwind protection." | copyIndex maxBytesToCopy startIndex targetCType bufferLength |		startIndex := 1.		copyIndex:= aPosition.				maxBytesToCopy:= aLength.		result := ByteArray new: maxBytesToCopy.		targetCType := aLocator targetCType.		bufferLength := (xif class fetchBufferSizeBlocks at: 'LargeByteArray' asSymbol) value: aLength.		dataPtr := xif SQLCHAR perform: xif mallocSelector with: (bufferLength + 1).	" string/bytearray value"		[startIndex &gt; maxBytesToCopy ] whileFalse: [ | len |			len := (maxBytesToCopy - startIndex +1) min: bufferLength.			self getLOBSubString: aLocator from: copyIndex length: len buffer: dataPtr bufferSize: (len + 1).			dataPtr copyAt: 0 to: result size: len startingAt: startIndex.			startIndex := startIndex + len.			copyIndex:=copyIndex + len 		]. 		targetCType == xif SQL_C_CHAR ifTrue: [			result := result asStringEncoding: self encoding		]		"End unwind protection."] ensure: [dataPtr notNil ifTrue: [dataPtr freePointer]].	^result</body><body package="DB2EXDI">getLOBSubString: aLocator from: aPosition length: aLength asLocator: aBoolean 	"Retrieve substring of a string/blob value "	| xif pIndicatorValue rc result targetCType dataPtr bufferLength |	xif := self class xif.		["Begin unwind protection."	pIndicatorValue := xif SQLINTEGER perform: xif mallocSelector with: 1.	aBoolean 		ifTrue: 			[targetCType := aLocator locatorCType.			dataPtr := xif SQLINTEGER perform: xif mallocSelector with: 1.	"LOB locator "			bufferLength := 4.			rc := xif 				SQLGetSubString: self blobHstmt				with: aLocator locatorCType				with: aLocator locator				with: aPosition				with: aLength				with: targetCType				with: dataPtr				with: bufferLength				with: nil				with: pIndicatorValue.	"pStringLength"	traceLevel &gt;= 1 		ifTrue: 			[(self traceStream)				print: rc;				nextPutAll: ' = SQLGetSubString ( hstmt = ';				nextPutAll: (self blobHstmt printStringRadix: 16);				nextPutAll: ', locatorCType = ';				nextPutAll: aLocator locatorCType printString;				nextPutAll: ', targetCType = ';				nextPutAll: aLocator targetCType printString;				nextPutAll: ', aLocator = ';				nextPutAll: (aLocator locator printStringRadix: 16);				nextPutAll: ', dataPtr = ' , (dataPtr referentAddress printStringRadix: 16).			self class trace: self emitTrace].			(rc == xif SQL_SUCCESS or: [rc == xif SQL_SUCCESS_WITH_INFO]) ifTrue: [				result := (DB2LOBLocator asType: aLocator db2Conversion) locator: dataPtr contents			] ifFalse: [ | errs |				errs := self getStatementErrors: self blobHstmt.				"self resultsCache: errs."				self class unableToFetchDataSignal raiseWith: errs errorString: errs first dbmsErrorString			].		] ifFalse: [ result := self getLOBSubString: aLocator from: aPosition length: aLength.	].	"End unwind protection."] 			ensure: 				[dataPtr notNil ifTrue: [dataPtr freePointer].				pIndicatorValue notNil ifTrue: [pIndicatorValue freePointer]].	^result</body></methods><methods><class-id>Database.DB2Connection</class-id> <category>initialize-release</category><body package="DB2EXDI">initialize	"Establish initial value for instance variables." 	super initialize.	self hdbcHolder: nil asValue. 	supportedFunctions := IdentityDictionary new.	generalInformationCache := IdentityDictionary new.	"self isolationLevel: #RR"</body></methods><methods><class-id>Database.DB2Connection</class-id> <category>private-testing</category><body package="DB2EXDI">isDbmsVersion6	"Answer the version of the DBMS product being accessed"	^(self dbmsVersion at: 2)  &gt;= $6</body><body package="DB2EXDI">isUnicodeEncoding	| encodingString |	encodingString := self encoding asUppercase.	^((encodingString beginsWith: 'UTF') or: [ encodingString beginsWith: 'UCS' ])</body></methods><methods><class-id>Database.DB2Connection</class-id> <category>printing</category><body package="DB2EXDI">printOn: aStream 	| hdbc |	super printOn: aStream.	(hdbc := self hdbc) isNil ifFalse: [aStream nextPutAll: '( hdbc = '; nextPutAll: (hdbc printStringRadix: 16); nextPutAll: ' )']</body></methods><methods><class-id>Database.DB2Connection</class-id> <category>private-handles</category><body package="DB2EXDI">unprotectedAddHenvReference	"Acquire an environment handle if needed and record a reference.  Senders	must ensure protection using HenvLock.  If this method completes normally,	resources are held that should be released explicitly using #unprotectedDropHenvReference."	| xif phenv rc |	xif := self class xif.	"Not too much to do if environment handle already allocated."	Henv notNil 		ifTrue: 			["One more reference to the Henv."			HenvReferencesCount := HenvReferencesCount + 1.			^self].	"Get the environment handle."		[	["Begin unwind protection"	phenv := xif SQLHENV perform: xif mallocSelector with: 1.	rc := xif 				SQLAllocHandle: xif SQL_HANDLE_ENV				with: xif SQL_NULL_HANDLE				with: phenv.	traceLevel &gt;= 3 		ifTrue: 			[self traceStream				print: rc;				nextPutAll: ' = SQLAllocHandle(), henv = ';				nextPutAll: (phenv contents printStringRadix: 16).			self class trace: self emitTrace].	rc == xif SQL_SUCCESS 		ifFalse: [^self class unableToAllocateHandleSignal raise].	"Save environment handle"	Henv := phenv contents.	HenvReferencesCount := 1	"End unwind protection."] 			ensure: [phenv notNil ifTrue: [phenv freePointer]]] 			on: Object errorSignal			do: [:ex | self class externalDatabaseLibraryInaccessibleSignal raise]</body><body package="DB2EXDI">unprotectedAllocConnect	"Acquire reference to environment handle and then allocate a connection handle.	Senders must ensure protection using HenvLock.  If this method completes normally,	resources are held that should be released explicitly using #unprotectedFreeConnect."	| xif phdbc rc |	xif := self class xif.	"Make sure we have a reference to the environment handle."	self unprotectedAddHenvReference.		["Begin unwind protection (level 1) -- ensure release of environment handle on failure."		["Begin unwind protection (level 2) -- ensure release of pointers on success or failure."	phdbc := xif SQLHDBC perform: xif mallocSelector with: 1.	rc := xif 				SQLAllocHandle: xif SQL_HANDLE_DBC				with: self class henv				with: phdbc.	traceLevel &gt;= 3 		ifTrue: 			[(self traceStream)				print: rc;				nextPutAll: ' = SQLAllocConnect( henv = ';				nextPutAll: (self class henv printStringRadix: 16);				nextPutAll: ', *phdbc = ';				nextPutAll: (phdbc contents printStringRadix: 16);				nextPutAll: ')'.			self class trace: self emitTrace].	rc == xif SQL_SUCCESS 		ifFalse: 			[| errs |			errs := self getEnvironmentErrors.			^self class unableToAllocateHandleSignal raiseWith: errs				errorString: errs first dbmsErrorString].	self hdbc: phdbc contents	"End unwind protection (level 2)"] 			ensure: [phdbc notNil ifTrue: [phdbc freePointer]]	"End unwind protection (level 1)"] 			ifCurtailed: 				["Some failure is causing unwind, don't keep the environment handle reference."				self unprotectedDropHenvReference]</body><body package="DB2EXDI">unprotectedDropHenvReference	"Remove a reference to the environment handle.  If no references left, release the	handle.  Senders must ensure protection using HenvLock."	| xif rc |	xif := self class xif.	"Reduce the reference count."	(HenvReferencesCount := HenvReferencesCount - 1) &gt; 0 		ifTrue: 			["Little to do if other references still remain."			^self].		["Begin unwind protection."	Henv isNil ifTrue: [^self].	rc := xif SQLFreeHandle: xif SQL_HANDLE_ENV with: Henv.	traceLevel &gt;= 3 		ifTrue: 			[(self traceStream)				print: rc;				nextPutAll: ' = SQLFreeEnv( henv = ';				nextPutAll: (Henv printStringRadix: 16);				nextPutAll: ' )'.			self class trace: self emitTrace].	rc == xif SQL_SUCCESS 		ifFalse: 			[| errs |			errs := self getEnvironmentErrors.			^self class unableToFreeResourceSignal raiseWith: errs				errorString: errs first dbmsErrorString]	"End unwind protection."] 			ensure: [Henv := nil]</body><body package="DB2EXDI">unprotectedFreeConnect	"Free the connection handle and then release reference to environment handle.	Senders must ensure protection using HenvLock."	| xif rc |	xif := self class xif.		["Begin unwind protection"	self hdbc isNil ifTrue: [^self].	rc := xif SQLFreeHandle: xif SQL_HANDLE_DBC with: self hdbc.	traceLevel &gt;= 3 		ifTrue: 			[(self traceStream)				print: rc;				nextPutAll: ' = SQLFreeConnect( hdbc = ';				nextPutAll: (self hdbc printStringRadix: 16);				nextPutAll: ' )'.			self class trace: self emitTrace].	rc == xif SQL_SUCCESS 		ifFalse: 			[| errs |			errs := self getEnvironmentErrors.			errs isEmpty ifTrue: [^self].			^self class unableToFreeResourceSignal raiseWith: errs				errorString: errs first dbmsErrorString]	"End unwind protection."] 			ensure: 				["Whether or not there was a failure, there's no point in hanging onto these."				self hdbc: nil.				self unprotectedDropHenvReference]</body></methods><methods><class-id>Database.DB2Connection class</class-id> <category>accessing</category><body package="DB2EXDI">apiInterfaceClass	"Answer the correct interface class" 	| interfaceClassName |  	apiXifMap isNil		ifTrue: [self initializeInterfaceMapping].	interfaceClassName := apiXifMap at: self platformType ifAbsent: [nil].	^interfaceClassName notNil		ifTrue: [ self environment at: interfaceClassName ifAbsent: [nil] ]		ifFalse: [nil]</body><body package="DB2EXDI">apiXif	"Answer the ExternalInterface subclass instance to use." 	apiXif isNil ifTrue:		[ self initializeExternalInterface ].	^apiXif</body><body package="DB2EXDI">apiXif: anExternalInterface	apiXif := anExternalInterface</body><body package="DB2EXDI">bufferClass	"Answer the buffer class for sessions"		^DB2Buffer</body><body package="DB2EXDI">columnDescriptionClass	"Answer the class to use for column description objects associated with receiver."	^DB2ColumnDescription</body><body package="DB2EXDI">dataSourceClass	"Answer the error class for the receiver."		^DB2DataSource</body><body package="DB2EXDI">errorClass	"Answer the error class for the receiver."		^DB2Error</body><body package="DB2EXDI">henv	^Henv</body><body package="DB2EXDI">interfaceClass	"Answer the correct interface class" 	| interfaceClassName |  	xifMap isNil		ifTrue: [self initializeInterfaceMapping].	interfaceClassName := xifMap at: self platformType ifAbsent: [nil].	^interfaceClassName notNil		ifTrue: [ self environment at: interfaceClassName ifAbsent: [nil] ]		ifFalse: [nil]</body><body package="DB2EXDI">kind	"Answer a symbol representing the type of DMBS the receiver provides services for."	^#'DB2/UDB'</body><body package="DB2EXDI">sessionClass	"Answer the class to use for session objects associated with receiver."	^DB2Session</body><body package="DB2EXDI">transactionClass	"Answer the class to use for transaction objects associated with receiver."	^DB2Transaction</body><body package="DB2EXDI">version	^'DB2/UDB Connect - Release 1.4 '</body><body package="DB2EXDI">xif	"Answer the ExternalInterface subclass instance to use." 	xif isNil ifTrue:		[ self initializeExternalInterface ].	^xif</body></methods><methods><class-id>Database.DB2Connection class</class-id> <category>class initialization</category><body package="DB2EXDI">initialize	"DB2Connection initialize"	Henv := nil.	PlatformType:=nil. "!"	HenvLock := RecursionLock new.	HenvReferencesCount := 0.	self initializeInterfaceMapping.	self xif: nil.	self apiXif: nil.	self initRegistry.	SupportedIsolationLevels := IdentityDictionary new.	SupportedIsolationLevels at: #RR put: #SQL_TXN_SERIALIZABLE.  " Repeatable Read "	SupportedIsolationLevels at: #RS put: #SQL_TXN_REPEATABLE_READ.  "Read Stability"	SupportedIsolationLevels at: #RC put: #SQL_TXN_READ_COMMITTED. "Read Commited"	SupportedIsolationLevels at: #CS put: #SQL_TXN_READ_COMMITTED. "Cursor Stability alias"	SupportedIsolationLevels at: #RU put: #SQL_TXN_READ_UNCOMMITED. "Uncommitted Read "	SupportedIsolationLevels at: #NC put: #SQL_TXN_NOCOMMIT. "No Commit"	SupportedIsolationLevels at: #serializable put: #SQL_TXN_SERIALIZABLE.	"SupportedIsolationLevels at: #versioning put: #SQL_TXN_VERSIONING."	self sessionClass initialize.</body><body package="DB2EXDI">initializeExternalInterface	"Reset xif call with the right interface class based on the current platform."	| xifClass |	xifClass := self interfaceClass.	self xif: (xifClass notNil			ifTrue: [xifClass new]			ifFalse: [nil]).	xif isNil ifTrue: [^ExternalDatabaseNotification raiseErrorString: 'The DB2 CLI Driver is not correctly installed.' withCRs].	xifClass := self apiInterfaceClass.	self apiXif: (xifClass notNil			ifTrue: [xifClass new]			ifFalse: [nil]).	self initializeInformationTypeConversionMap.</body><body package="DB2EXDI">initializeInformationTypeConversionMap	"DB2Connection initializeInformationTypeConversionMap"	(SQLInfoTypeConversionMap := IdentityDictionary new)		add: #SQL_MAX_DRIVER_CONNECTIONS-&gt;#stringAt:;		add: #SQL_MAX_CONCURRENT_ACTIVITIES-&gt;#shortAt:;		add: #SQL_DATA_SOURCE_NAME-&gt;#stringAt:;		add: #SQL_DRIVER_HDBC-&gt;#longAt:;		add: #SQL_DRIVER_HENV-&gt;#longAt:;		add: #SQL_DRIVER_HSTMT-&gt;#longAt:;		add: #SQL_DRIVER_NAME-&gt;#stringAt:;		add: #SQL_DRIVER_VER-&gt;#stringAt:;		add: #SQL_FETCH_DIRECTION-&gt;#longAt:;		add: #SQL_ODBC_API_CONFORMANCE-&gt;#shortAt:;		add: #SQL_ODBC_VER-&gt;#stringAt:;		add: #SQL_ROW_UPDATES-&gt;#stringAt:;		add: #SQL_ODBC_SAG_CLI_CONFORMANCE-&gt;#shortAt:;		add: #SQL_SERVER_NAME-&gt;#stringAt:;		add: #SQL_SEARCH_PATTERN_ESCAPE-&gt;#stringAt:;		add: #SQL_ODBC_SQL_CONFORMANCE-&gt;#shortAt:;		add: #SQL_DATABASE_NAME-&gt;#stringAt:;		add: #SQL_DBMS_NAME-&gt;#stringAt:;		add: #SQL_DBMS_VER-&gt;#stringAt:;		add: #SQL_ACCESSIBLE_TABLES-&gt;#stringAt:;		add: #SQL_ACCESSIBLE_PROCEDURES-&gt;#stringAt:;		add: #SQL_PROCEDURES-&gt;#stringAt:;		add: #SQL_CONCAT_NULL_BEHAVIOR-&gt;#shortAt:;		add: #SQL_CURSOR_COMMIT_BEHAVIOR-&gt;#shortAt:;		add: #SQL_CURSOR_ROLLBACK_BEHAVIOR-&gt;#shortAt:;		add: #SQL_DATA_SOURCE_READ_ONLY-&gt;#stringAt:;		add: #SQL_DEFAULT_TXN_ISOLATION-&gt;#longAt:;		add: #SQL_EXPRESSIONS_IN_ORDERBY-&gt;#stringAt:;		add: #SQL_IDENTIFIER_CASE-&gt;#shortAt:;		add: #SQL_IDENTIFIER_QUOTE_CHAR-&gt;#stringAt:;		add: #SQL_MAX_COLUMN_NAME_LEN-&gt;#shortAt:;		add: #SQL_MAX_CURSOR_NAME_LEN-&gt;#shortAt:;		add: #SQL_MAX_SCHEMA_NAME_LEN -&gt;#shortAt:;		add: #SQL_MAX_PROCEDURE_NAME_LEN-&gt;#shortAt:;		add: #SQL_MAX_CATALOG_NAME_LEN -&gt;#shortAt:;		add: #SQL_MAX_TABLE_NAME_LEN-&gt;#shortAt:;		add: #SQL_MULT_RESULT_SETS-&gt;#stringAt:;		add: #SQL_MULTIPLE_ACTIVE_TXN-&gt;#stringAt:;		add: #SQL_OUTER_JOINS-&gt;#stringAt:;		add: #SQL_OWNER_TERM-&gt;#stringAt:;		add: #SQL_PROCEDURE_TERM-&gt;#stringAt:;		add: #SQL_QUALIFIER_NAME_SEPARATOR-&gt;#stringAt:;		add: #SQL_QUALIFIER_TERM-&gt;#stringAt:;		add: #SQL_SCROLL_CONCURRENCY-&gt;#longAt:;		add: #SQL_SCROLL_OPTIONS-&gt;#longAt:;		add: #SQL_TABLE_TERM-&gt;#stringAt:;		add: #SQL_TXN_CAPABLE-&gt;#shortAt:;		add: #SQL_USER_NAME-&gt;#stringAt:;		add: #SQL_CONVERT_FUNCTIONS-&gt;#longAt:;		add: #SQL_NUMERIC_FUNCTIONS-&gt;#longAt:;		add: #SQL_STRING_FUNCTIONS-&gt;#longAt:;		add: #SQL_SYSTEM_FUNCTIONS-&gt;#longAt:;		add: #SQL_TIMEDATE_FUNCTIONS-&gt;#longAt:;		add: #SQL_TXN_ISOLATION_OPTION-&gt;#longAt:;		add: #SQL_INTEGRITY-&gt;#stringAt:;		add: #SQL_GETDATA_EXTENSIONS-&gt;#longAt:.</body><body package="DB2EXDI">initializeInterfaceMapping	"only once interface"	xifMap := IdentityDictionary new.	xifMap at: #nt put: #DB2CLIWinInterface.	xifMap at: #win95 put: #DB2CLIWinInterface.	xifMap at: #linux_i386_unix put: #DB2CLILinuxInterface.	xifMap at: #aix_unix put: #DB2CLIAIXInterface.	xifMap at: #sun5_unix put: #DB2CLISolarisInterface.	xifMap at: #macOSX put: #DB2CLIMacOSXInterface.	xifMap at: #nt64 put: #DB2CLIWin64Interface.	xifMap at: #linux_x86_64_unix put: #DB2CLILinux64Interface.	xifMap at: #unix_sysV_sun_solaris64 put: #DB2CLISolaris64Interface.	xifMap at: #unknown put: #DB2CLILinuxInterface.	apiXifMap := IdentityDictionary new.	apiXifMap at: #nt put: #DB2APIWinInterface.	apiXifMap at: #win95 put: #DB2APIWinInterface.	apiXifMap at: #linux_i386_unix put: #DB2APILinuxInterface.	apiXifMap at: #aix_unix put: #DB2APIAIXInterface.	apiXifMap at: #sun5_unix put: #DB2APISolarisInterface.	apiXifMap at: #macOSX put: #DB2APIMacOSXInterface.	apiXifMap at: #nt64 put: #DB2APIWin64Interface.	apiXifMap at: #linux_x86_64_unix put: #DB2APILinux64Interface.	apiXifMap at: #unix_sysV_sun_solaris64 put: #DB2APISolaris64Interface.	apiXifMap at: #unknown put: #DB2APILinuxInterface.</body><body package="DB2EXDI">postLoadActionFor: aParcel	"If there is no default Database Connect, make this the default."	ExternalDatabaseConnection defaultConnection isNil ifTrue: [ExternalDatabaseConnection defaultConnection: #DB2Connection ].</body></methods><methods><class-id>Database.DB2Connection class</class-id> <category>private-activation</category><body package="DB2EXDI">install	( TraceLevel &gt;= 1 ) ifTrue:		[ self trace: nil ].	Henv := nil.	HenvReferencesCount := 0.	self xif: nil.	self apiXif: nil.	self sessionClass install.	self returnFromSnapshot</body></methods><methods><class-id>Database.DB2Connection class</class-id> <category>activation</category><body package="DB2EXDI">pause	^self quiesce</body><body package="DB2EXDI">resume	^self activate</body></methods><methods><class-id>Database.DB2Connection class</class-id> <category>private-registry</category><body package="DB2EXDI">registry	^RegisteredDB2Connections</body><body package="DB2EXDI">registry: aCollection	RegisteredDB2Connections := aCollection</body></methods><methods><class-id>Database.DB2Connection class</class-id> <category>signal constants</category><body package="DB2EXDI">unableToQueryStatementAttributesSignal	^UnableToQueryStatementAttributes</body></methods><methods><class-id>Database.DB2Buffer</class-id> <category>private-data conversion {put}</category><body package="DB2EXDI">at: index putBlobLocator: aBlobLocator	"Put anInteger into the buffer"	conversionBuffer longAt: 1 put: aBlobLocator locator.	bufferPointer copyAt: ((index-1) * elementSize) from: conversionBuffer size: 4 startingAt: 1.	pcbValue at: (index-1) put: 4.	^aBlobLocator</body><body package="DB2EXDI">at: index putByteArray: aByteArray	"Put aByteArray into the buffer."	| bytes |	(bytes := aByteArray size) &gt; cbColDef ifTrue:		[ self rebind: aByteArray.		  bytes &gt; cbColDef ifTrue: [self connectionClass unableToBindSignal raise] ].	bufferPointer copyAt: ((index-1) * elementSize) from: aByteArray size: bytes startingAt: 1.	pcbValue at: (index-1) put: bytes.	^aByteArray</body><body package="DB2EXDI">at: index putDate: aDate	"Put aDate into the buffer."		conversionBuffer shortAt: 1 put: aDate year.	conversionBuffer unsignedShortAt: 3 put: aDate monthIndex.	conversionBuffer unsignedShortAt: 5 put: aDate dayOfMonth.	bufferPointer copyAt: ((index-1) * elementSize) from: conversionBuffer size: 6 startingAt: 1.	pcbValue at: (index-1) put: 6.	^aDate</body><body package="DB2EXDI">at: index putDouble: aDouble	"Put aDouble into the buffer"		conversionBuffer doubleAt: 1 put: aDouble.	bufferPointer copyAt: ((index-1) * elementSize) from: conversionBuffer size: 8 startingAt: 1.	pcbValue at: (index-1) put: 8.	^aDouble</body><body package="DB2EXDI">at: index putFixedPoint: aFixedPoint	"Put aFixedPoint into the buffer."	| strm str bytes |		strm := (String new: 40) writeStream.	aFixedPoint printOn: strm.	strm skip: -1.	str := strm contents.	"Stick the result into the buffer."	bufferPointer copyAt: ((index-1) * elementSize) from: str size: (bytes := str size) startingAt: 1.	pcbValue at: (index-1) put: bytes.	ibScale := aFixedPoint scale.	^aFixedPoint</body><body package="DB2EXDI">at: index putFloat: aFloat	"Put aFloat into the buffer"	conversionBuffer floatAt: 1 put: aFloat.	bufferPointer copyAt: ((index-1) * elementSize) from: conversionBuffer size: 4 startingAt: 1.	pcbValue at: (index-1) put: 4.	^aFloat</body><body package="DB2EXDI">at: index putInteger: anInteger	"Put anInteger into the buffer"	conversionBuffer isNil ifTrue:[ conversionBuffer := UninterpretedBytes new: 4 ].	conversionBuffer longAt: 1 put: anInteger.	bufferPointer copyAt: ((index-1) * elementSize) from: conversionBuffer size: 4 startingAt: 1.	pcbValue at: (index-1) put: 4.	^anInteger</body><body package="DB2EXDI">at: index putLargeInteger: anInteger	"Put anInteger into the buffer"	conversionBuffer longLongAt: 1 put: anInteger "bigEndian: UninterpretedBytes isBigEndian".	bufferPointer copyAt: ((index-1) * elementSize) from: conversionBuffer size: 8 startingAt: 1.	pcbValue at: (index-1) put: 8.	^anInteger</body><body package="DB2EXDI">at: index putString: aString 	"Put aString into the buffer."	| bytes  ba str |	aString class == Text 		ifTrue: [str := aString string]		ifFalse: 			[aString class == GapString 				ifTrue: [str := aString compress string]				ifFalse: [str := aString]].	aString size &gt; cbColDef 		ifTrue: 			[self rebind: aString.			aString size &gt; cbColDef 				ifTrue: [self connectionClass unableToBindSignal raise]].	ba := ByteArray fromString: str encoding: self encoding.	bufferPointer 		copyAt: (index - 1) * elementSize		from: ba		size: (bytes := ba size)		startingAt: 1.	pcbValue at: index - 1 put: bytes.	^aString</body><body package="DB2EXDI">at: index putTime: aTime	"Put aTime into the buffer"	conversionBuffer unsignedShortAt: 1 put: aTime hours.	conversionBuffer unsignedShortAt: 3 put: aTime minutes.	conversionBuffer unsignedShortAt: 5 put: aTime seconds.	bufferPointer copyAt: ((index-1) * elementSize) from: conversionBuffer size: 6 startingAt: 1.	pcbValue at: (index-1) put: 6.	^aTime</body><body package="DB2EXDI">at: index putTimestamp: aTimestamp	"Put aTimestamp into the buffer"	conversionBuffer shortAt: 1 put: (aTimestamp year max: 1). 	conversionBuffer unsignedShortAt: 3 put: aTimestamp month.	conversionBuffer unsignedShortAt: 5 put: aTimestamp day.	conversionBuffer unsignedShortAt: 7 put: aTimestamp hour.	conversionBuffer unsignedShortAt: 9 put: aTimestamp minute.	conversionBuffer unsignedShortAt: 11 put: aTimestamp second.	conversionBuffer unsignedLongAt: 13 put: (aTimestamp millisecond * 1000000 + aTimestamp partialNanosecond).	bufferPointer copyAt: ((index-1) * elementSize) from: conversionBuffer size: 16 startingAt: 1.	pcbValue at: (index-1) put: 16.	^aTimestamp</body><body package="DB2EXDI">at: index putWordArray: aWordArray	"Put aWordArray into the buffer."	"Currently not yet supported"	| octets |	aWordArray size &gt; cbColDef ifTrue:		[ self  connectionClass unableToBindSignal raise ].	bufferPointer copyAt: (index -1 ) 				from: aWordArray 				size: (octets := aWordArray basicSize) startingAt: 1.	pcbValue at: (index-1) put: octets.	^aWordArray</body></methods><methods><class-id>Database.DB2Buffer</class-id> <category>binding</category><body package="DB2EXDI">bindFor: paramType	"Binding contents of the receiver to the server."		fParamType := self xif perform: paramType.	"We won't re-use pointers."	(bufferPointer isNil) ifFalse: [ self free ].	"Like bindForInput"	self mallocUsingSelector: self xif mallocSelector.	self value: bufferValue.	self bindInputExternal</body><body package="DB2EXDI">bindForInput	"Binding contents of the receiver to the server."	fParamType := self xif SQL_PARAM_INPUT.	"We won't re-use pointers."	(bufferPointer isNil) ifFalse: [ self free ].	self mallocUsingSelector: self xif mallocSelector.	self value: bufferValue.	self bindInputExternal</body><body package="DB2EXDI">bindForInputOutput	"Binding contents of the receiver to the server."		fParamType := self xif SQL_PARAM_INPUT_OUTPUT.	"We won't re-use pointers."	(bufferPointer isNil) ifFalse: [ self free ].	"Like bindForInput"	self mallocUsingSelector: self xif mallocSelector.	self value: bufferValue.	self bindInputExternal</body><body package="DB2EXDI">bindForOutput	"Setup the receiver to hold the contents of a single column."	fParamType := self  xif SQL_PARAM_OUTPUT.	"We won't re-use pointers."	(bufferPointer isNil) ifFalse: [ self free ].	"Allocate external CPointers."	self mallocUsingSelector: self xif mallocSelector.	self bindOutputExternal</body></methods><methods><class-id>Database.DB2Buffer</class-id> <category>accessing</category><body package="DB2EXDI">bufferValue	^bufferValue</body><body package="DB2EXDI">cbColDef	"Answer the precision of the buffer value"	^cbColDef</body><body package="DB2EXDI">cbValueMax	"Answer the receiver's maximum count (length) in bytes."	^elementSize</body><body package="DB2EXDI">encoding	"Answer the encoding"	self isUnicodeColumn ifTrue: [		^self connection unicodeEncoding	].	^encoding</body><body package="DB2EXDI">fCType	"Answer the C data type for the data in this buffer." 	^CTypeFromConversionMap at: databaseType</body><body package="DB2EXDI">fParamType	^fParamType</body><body package="DB2EXDI">fSqlType	"Answer the DB2 SQL data type for the data in this buffer."	^SQLTypeFromConversionMap at: databaseType</body><body package="DB2EXDI">iCol	"Answer the receiver external bind index."	^bufferIndex</body><body package="DB2EXDI">iCol: anInteger	"Set the receiver external bind index."	bufferIndex := anInteger.</body><body package="DB2EXDI">ibScale	^ibScale</body><body package="DB2EXDI">isUnicodeColumn	^isUnicodeColumn</body><body package="DB2EXDI">isUnicodeColumn: aBoolean	isUnicodeColumn := aBoolean</body><body package="DB2EXDI">pcbValue	"Answer the receiver's count (length) in bytes pointer."	^pcbValue</body><body package="DB2EXDI">rebindOrRaiseFor: aValueOrArray 	| type |	((type := aValueOrArray db2Conversion) ~~ databaseType 		and: [aValueOrArray notNil]) 			ifTrue: 				[(type == #FileRef or: [type == #DataLink]) 					ifFalse: [self rebind: aValueOrArray]					ifTrue: [DB2Connection unableToBindSignal raise]]</body><body package="DB2EXDI">rgbValue	"Answer the receiver's buffer pointer."	^bufferPointer</body><body package="DB2EXDI">session	^session</body><body package="DB2EXDI">session: aSession	session := aSession</body><body package="DB2EXDI">value: aValueOrArray 	"Store aValueOrArray into the receiver. Raise an exception if this buffer and the new value are not compatible."	| size val |	(aValueOrArray class name ~= #Array and: [count &gt; 0]) 		ifTrue: [^DB2Connection unableToBindSignal raise].	(aValueOrArray class name = #Array and: [count = 0]) 		ifTrue: [^DB2Connection unableToBindSignal raise].	count == 0 		ifTrue: 			[self rebindOrRaiseFor: aValueOrArray.			^self at: 1 put: aValueOrArray].	size := aValueOrArray size.	size &gt; count ifTrue: [^DB2Connection unableToBindSignal raise].	val := aValueOrArray detect: [:x | x notNil] ifNone: [nil].	self rebindOrRaiseFor: val.	1 to: size do: [:index | self at: index put: (aValueOrArray at: index)]</body></methods><methods><class-id>Database.DB2Buffer</class-id> <category>allocation</category><body package="DB2EXDI">free	"Free the receiver."	pcbValue notNil ifTrue:		[ pcbValue freePointer.		  pcbValue := nil ].	super free.</body><body package="DB2EXDI">mallocUsingSelector: mallocSelector	"Allocate a physical buffer for the receiver. Use mallocSelector to perform the allocation." 	[ "Begin unwind protection."	super mallocUsingSelector: mallocSelector.	pcbValue := CIntegerType int perform: mallocSelector with: (count max: 1).	"End unwind protection." ]		ifCurtailed: [ self free ]</body></methods><methods><class-id>Database.DB2Buffer</class-id> <category>private-data conversion {get}</category><body package="DB2EXDI">getBlobLocatorAt: index	"Answer an BlobLocator populated from the buffer."			bufferPointer copyAt: ((index-1) * elementSize) to: conversionBuffer size: 4 startingAt: 1.	^((DB2LOBLocator asType: self databaseType) locator: (conversionBuffer longAt: 1)) connection: self connection.</body><body package="DB2EXDI">getByteArrayAt: index	"Answer a ByteArray populated from the buffer."	| bytes byteArray | 	bytes := pcbValue at: (index -1).	byteArray := ByteArray new: bytes.	bufferPointer copyAt: ((index-1) * elementSize) to: byteArray size: bytes startingAt: 1.	^byteArray</body><body package="DB2EXDI">getDateAt: index	"Answer a Date populated from the buffer."		|  year month day |	bufferPointer copyAt: ((index-1) * elementSize) to: conversionBuffer size: 6 startingAt: 1.	year := conversionBuffer shortAt: 1.	month := conversionBuffer unsignedShortAt: 3.	day := conversionBuffer unsignedShortAt: 5.	^Date newDay: day monthNumber: month year: year</body><body package="DB2EXDI">getDoubleAt: index	"Answer a Double populated from the buffer"		bufferPointer copyAt: ((index-1) * elementSize) to: conversionBuffer size: 8 startingAt: 1.	^conversionBuffer doubleAt: 1</body><body package="DB2EXDI">getFixedPointAt: index	"Answer a FixedPoint number populated from the buffer"	| bytes |	bytes := pcbValue at: (index -1).	conversionBuffer:=ByteString new: bytes.	bufferPointer copyAt: ((index-1) * elementSize) to: conversionBuffer size: bytes startingAt: 1.	^FixedPoint "readFrom:" readDB2DecimalFrom: conversionBuffer readStream</body><body package="DB2EXDI">getFloatAt: index	"Answer a Float populated from the buffer"	"Assume: bufferPointer points to at least 4 bytes in the heap."	bufferPointer copyAt: ((index-1) * elementSize) to: conversionBuffer size: 4 startingAt: 1.	^conversionBuffer floatAt: 1</body><body package="DB2EXDI">getIntegerAt: index	"Answer an Integer populated from the buffer."		bufferPointer copyAt: ((index-1) * elementSize) to: conversionBuffer size: 4 startingAt: 1.	^conversionBuffer longAt: 1</body><body package="DB2EXDI">getLargeIntegerAt: index	"Answer an Integer populated from the buffer."		bufferPointer copyAt: ((index-1) * elementSize) to: conversionBuffer size: 8 startingAt: 1.	^conversionBuffer longLongAt: 1</body><body package="DB2EXDI">getStringAt: index	"Answer a String populated from the buffer" 	"Restore encoding ?"	| bytes byteArray |	bytes := pcbValue at: (index -1).	byteArray := ByteArray new: bytes.	bufferPointer copyAt: ((index-1) * elementSize) to: byteArray size: bytes startingAt: 1.	^byteArray asStringEncoding: self encoding</body><body package="DB2EXDI">getTimeAt: index	"Answer a Time populated from the buffer"	|  hours minutes seconds |	bufferPointer copyAt: ((index-1) * elementSize) to: conversionBuffer size: 6 startingAt: 1.	hours := conversionBuffer unsignedShortAt: 1.	minutes := conversionBuffer unsignedShortAt: 3.	seconds := conversionBuffer unsignedShortAt: 5.	^Time new hours: hours minutes: minutes seconds: seconds</body><body package="DB2EXDI">getTimestampAt: index	"Answer a Timestamp populated from the buffer"	|  year month day hours minutes seconds millisecond ts fSecond |	bufferPointer copyAt: ((index-1) * elementSize) to: conversionBuffer size: 16 startingAt: 1.	year := conversionBuffer shortAt: 1.	month := conversionBuffer unsignedShortAt: 3.	day := conversionBuffer unsignedShortAt: 5.	hours := conversionBuffer unsignedShortAt: 7.	minutes := conversionBuffer unsignedShortAt: 9.	seconds := conversionBuffer unsignedShortAt: 11.	fSecond := conversionBuffer unsignedLongAt: 13.	millisecond := fSecond//1000000.	(ts := Timestamp new)		year: year;		month: month;		day: day;		hour: hours;		minute: minutes;		second: seconds;		millisecond: millisecond;		partialNanosecond: (fSecond - (millisecond * 1000000)).	^ts</body><body package="DB2EXDI">getWordArrayAt: index	"Answer a WordArray populated from the buffer."	"Currently not yet supported"	| bytes wa |	bytes := pcbValue at: (index -1).	wa := WordArray new: (bytes / 2).	bufferPointer copyAt: ((index-1) * elementSize) to: wa size: bytes startingAt: 1.	^wa</body></methods><methods><class-id>Database.DB2Buffer</class-id> <category>private</category><body package="DB2EXDI">getSelector	^getSelector</body><body package="DB2EXDI">pointerType	"Answer the pointer type to use for buffer allocation."	| refType |	databaseType == #WordArray		ifTrue:	[ refType := CIntegerType unsignedShort ]		ifFalse:	[ refType := CIntegerType char ].	^CArrayType defaultPointer			referentType: refType;			numElements: elementSize.</body><body package="DB2EXDI">putSelector	^putSelector</body></methods><methods><class-id>Database.DB2Buffer</class-id> <category>private-accessing</category><body package="DB2EXDI">at: anIndex	"Answer the object in the buffer at anIndex."	^((pcbValue at: (anIndex-1)) == -1 "self  xif SQL_NULL_DATA")		ifTrue:	 [ nil ]		ifFalse: [ 			getSelector isNil ifTrue: [				^self class connectionClass unsupportedDataTypeSignal raise			] ifFalse: [				self perform: getSelector with: anIndex 			]		]</body><body package="DB2EXDI">at: anIndex put: anObject	"Store anObject into the buffer at anIndex."	anObject isNil		ifTrue: [ pcbValue at: (anIndex-1) put: -1 "self xif SQL_NULL_DATA" ]		ifFalse: [ 			putSelector isNil ifTrue: [				^self class connectionClass unsupportedDataTypeSignal raise			] ifFalse: [				self perform: putSelector with: anIndex with: anObject 			]		].	^anObject</body><body package="DB2EXDI">connection	^session connection</body><body package="DB2EXDI">connectionClass	^self connection class</body><body package="DB2EXDI">findMaxValue: anArray	"Answer nonNil value or the largest value for Strings and ByteArrays."	^self class findMaxValue: anArray</body><body package="DB2EXDI">hstmt	^hstmt</body><body package="DB2EXDI">hstmt: aValue	hstmt := aValue</body><body package="DB2EXDI">traceLevel	^self connection traceLevel</body><body package="DB2EXDI">traceStream	^self connection traceStream</body><body package="DB2EXDI">xif	^self connectionClass xif</body></methods><methods><class-id>Database.DB2Buffer</class-id> <category>testing</category><body package="DB2EXDI">isFileRefObject	^false</body><body package="DB2EXDI">isLargeObject	^false</body><body package="DB2EXDI">isStringBased	^#(#String #LargeString) includes: self databaseType</body><body package="DB2EXDI">isUnicode: aSqlType	^((aSqlType = -8) or: [ aSqlType = -9 ]) or: [ aSqlType = -350 ]</body><body package="DB2EXDI">isUnicodeEncoding	| encodingString |	encodingString := self encoding asUppercase.	^((encodingString beginsWith: 'UTF') or: [ encodingString beginsWith: 'UCS' ])</body></methods><methods><class-id>Database.DB2Buffer</class-id> <category>private-binding</category><body package="DB2EXDI">bindInputExternal	"Bind the contents of the receiver to the server."	| rc xif cType sqlType |	xif := self xif.	cType := self fCType.	self isStringBased ifTrue: [		(self isUnicodeColumn or: [ self connection isUnicodeEncoding ]) ifTrue: [ | type |			type := self fSqlType.			cType := xif SQL_C_WCHAR.			type == xif SQL_CHAR ifTrue: [				sqlType := xif SQL_WCHAR			] ifFalse: [				type == xif SQL_VARCHAR ifTrue: [					sqlType := xif SQL_WVARCHAR				] ifFalse: [ 					sqlType := xif SQL_WLONGVARCHAR				]			]		] ifFalse: [			sqlType := self fSqlType		]	] ifFalse: [		sqlType := self fSqlType	].	count &gt;= 1 ifTrue: [		self session setStatementAttribute: #SQL_ATTR_PARAM_BIND_TYPE value: xif SQL_BIND_BY_COLUMN.		self session setStatementAttribute: #SQL_ATTR_PARAMSET_SIZE value: count.	].	rc := xif 				SQLBindParameter: self hstmt				with: bufferIndex				with: fParamType				with: cType				with: sqlType				with: cbColDef				with: self ibScale				with: bufferPointer				with: elementSize				with: pcbValue.	self traceLevel &gt;= 3 		ifTrue: 			[(self traceStream)				print: rc;				nextPutAll: ' = SQLBindParameter( hstmt = ';				nextPutAll: (self hstmt printStringRadix: 16);				nextPutAll: ', ipar=';				print: bufferIndex;				nextPutAll: ', fParamType=';				print: fParamType;				nextPutAll: ', fCType=';				print: self fCType;				nextPutAll: ', fSqlType=';				print: self fSqlType;				nextPutAll: ', cbParamDef= ';				print: cbColDef;				nextPutAll: ', ibScale= ';				print: ibScale;				nextPutAll: ', *rgbValue=';				print: bufferValue;				nextPutAll: ', cbValueMax=';				print: elementSize;				nextPutAll: ', *pcbValue=';				print: pcbValue contents;				nextPutAll: ' )'.			self connection class trace: self connection emitTrace].	rc == xif SQL_SUCCESS 		ifFalse: 			[| errs |			errs := self connection getStatementErrors: self hstmt.			^self connectionClass unableToBindSignal raiseWith: errs				errorString: errs first dbmsErrorString]</body><body package="DB2EXDI">bindOutputExternal	"Prepare the receiver to automatically receive it's data from the server."	| rc xif cType |	xif := self xif.	cType := self fCType.	(self isStringBased and: [ (self isUnicodeColumn or: [ self connection isUnicodeEncoding ])]) ifTrue: [		cType := xif SQL_C_WCHAR	].	rc := xif 				SQLBindCol: self hstmt				with: bufferIndex				with: cType				with: bufferPointer				with: elementSize				with: pcbValue.	self traceLevel &gt;= 3 		ifTrue: 			[(self traceStream)				print: rc;				nextPutAll: ' = SQLBindCol( hstmt = ';				nextPutAll: (self hstmt printStringRadix: 16);				nextPutAll: ', icol =';				print: bufferIndex;				nextPutAll: ', fCType = ';				print: self fCType;				nextPutAll: ', rgbValue = ';				nextPutAll: (bufferPointer referentAddress printStringRadix: 16);				nextPutAll: ', cbValueMax = ';				print: elementSize;				nextPutAll: ', pcbValue = ';				print: (pcbValue referentAddress printStringRadix: 16);				nextPutAll: ' )'.			self connection class trace: self connection emitTrace].	rc == xif SQL_SUCCESS 		ifFalse: 			[| errs |			errs := self connection getStatementErrors: self hstmt.			^self connectionClass unableToBindSignal raiseWith: errs				errorString: errs first dbmsErrorString]</body><body package="DB2EXDI">rebind: aValue"rebind for a new size"	self traceLevel&gt;=3  ifTrue: [	(self traceStream)		nextPutAll: ' Rebind parameter from: ';		nextPutAll: databaseType printString;		nextPutAll: ' to ';		nextPutAll:  (databaseType:=aValue db2Conversion) printString;		nextPutAll: ' size from: ', elementSize printString;		nextPutAll: ' to: ', ((ValueSizeBlocks at: databaseType) value: aValue) printString.		self  connection class trace: self  connection emitTrace		].	bufferPointer notNil ifTrue: [bufferPointer freePointer. bufferPointer:=nil].	databaseType:= aValue db2Conversion.	elementSize := (ValueSizeBlocks at: databaseType) value: aValue.	cbColDef := (ValuePrecisionBlocks at: databaseType) value: aValue.	bufferPointer := self pointerType perform: self xif mallocSelector with: (count max: 1).	getSelector := GetSelectorMap at: databaseType ifAbsent: [nil].	putSelector := PutSelectorMap at: databaseType ifAbsent: [nil].	conversionBuffer  := (ConversionBufferMap at: databaseType) notNil ifTrue: [(ConversionBufferMap at: databaseType) new: elementSize].	self bindInputExternal</body></methods><methods><class-id>Database.DB2Buffer</class-id> <category>initialize-release</category><body package="DB2EXDI">descriptor: aColDesc position: position session: aSession	"Initialize an instance of receiver which is set up to hold values as described." 	count := aSession blockFactor.	databaseType := aColDesc type.	self isUnicodeColumn: aColDesc isUnicodeColumn.	elementSize := (FetchBufferSizeBlocks at: aColDesc type) value: aColDesc precision .	conversionBuffer  := (ConversionBufferMap at: databaseType) notNil ifTrue: [(ConversionBufferMap at: databaseType) new: elementSize].	cbColDef := aColDesc precision.	bufferIndex := position.	self session: aSession.	hstmt := aSession hstmt.	self encoding: aSession connection encoding.	self isStringBased ifTrue: 		[(self isUnicodeColumn or: [ self connection isUnicodeEncoding ]) ifTrue: [			self encoding == #'UTF-8' ifTrue: [				cbColDef := cbColDef * 3.				elementSize := elementSize * 3.			] ifFalse: [				cbColDef := cbColDef * 2.				elementSize := elementSize * 2.			] 		]	].	getSelector := GetSelectorMap at: databaseType ifAbsent: [nil].	putSelector := PutSelectorMap at: databaseType ifAbsent: [nil].</body><body package="DB2EXDI">on: aValue position: position session: aSession type: type	| maxValue |	(aValue isKindOf: Array) ifTrue: [		count := aValue size	] ifFalse: [		count := 0	].	bufferIndex := position.	self session: aSession. 	hstmt := session hstmt.	bufferValue := aValue.	self isUnicodeColumn: false.	session bindTemplate isNil ifFalse: [		(session bindTemplate at: (session bindMarkerAtPosition: position)) == #UnicodeString ifTrue: [			self isUnicodeColumn: true		]	].		self encoding: self connection encoding.	ibScale := 0.    	type isNil  		ifTrue:  			[databaseType :=  self session conversionFor: aValue at: position.			  elementSize := 0.			  cbColDef := 0 ]		ifFalse: [			maxValue:= aValue.			databaseType := type "(count &gt; 1 ifTrue: [aValue detect: [ :v | v notNil] ifNone: [nil]] ifFalse: [aValue]) db2Conversion".			maxValue:= (count &gt; 0 and: [databaseType == #String or: [databaseType == #ByteArray or: [databaseType == #LargeString or: [databaseType == #LargeByteArray]]]])				ifTrue: [	aValue inject: '' 	into: [ :currentMax :nextValue |					nextValue size &gt; currentMax size ifTrue: [ nextValue ] ifFalse: [ currentMax ] ] ] ifFalse: [aValue].			elementSize := (ValueSizeBlocks at: databaseType) value: maxValue.  			cbColDef := (ValuePrecisionBlocks at: databaseType) value: maxValue ].	(self isStringBased and: [ self isUnicodeEncoding ]) ifTrue: [		elementSize := elementSize * 2.		cbColDef := cbColDef * 2	].	getSelector := GetSelectorMap at: databaseType ifAbsent: [nil].	putSelector := PutSelectorMap at: databaseType ifAbsent: [nil].	conversionBuffer  := (ConversionBufferMap at: databaseType) notNil ifTrue: [(ConversionBufferMap at: databaseType) new: elementSize].</body></methods><methods><class-id>Database.DB2Buffer class</class-id> <category>accessing</category><body package="DB2EXDI">connectionClass	^DB2Connection</body><body package="DB2EXDI">datalinkBufferClass	^DB2DataLinkBuffer</body><body package="DB2EXDI">fileRefBufferClass	^DB2FileRefBuffer</body><body package="DB2EXDI">findMaxValue: aValue	"Answer nonNil value or, if aValue is an Collection, the largest value for Strings and ByteArrays in the collection."	| repValue repType |	(aValue isKindOf: Collection) ifFalse: [ ^aValue ].	repValue := aValue detect: [ :each | each notNil ] ifNone: [ nil ].	repType := repValue db2Conversion.	(#(#ByteArray #LargeByteArray #String #LargeString) includes: repType ) ifTrue:[ 		aValue do: [ :each|			each size &gt; repValue size ifTrue: [ repValue := each ]		]	].	^repValue</body><body package="DB2EXDI">largeObjectBufferClass	^DB2LargeObjectBuffer</body></methods><methods><class-id>Database.DB2Buffer class</class-id> <category>private-instance creation</category><body package="DB2EXDI">descriptor: aColDesc position: position session: session	"Create an appropriate instance of an DB2Buffer which is set up to hold values as described." 	^(aColDesc isLong)		ifTrue: [self largeObjectBufferClass basicNew descriptor: aColDesc position: position session: session]		ifFalse: [aColDesc fileRef notNil ifTrue: [DB2FileRefBuffer basicNew 			descriptor: aColDesc position: position session: session]		ifFalse: [aColDesc type == #DataLink ifTrue: [DB2DataLinkBuffer basicNew 			descriptor: aColDesc position: position session: session]			ifFalse: [self basicNew descriptor: aColDesc position: position session: session ]]].</body><body package="DB2EXDI">on: aValue position: position session: session	"Create an appropriate instance of an DB2Buffer which is set up to hold values as described."	 | db2Conversion bufferClass |	db2Conversion := (aValue isKindOf: Array) 		ifTrue:  [session conversionFor: (self findMaxValue: aValue) at: position]		ifFalse: [session conversionFor: aValue at: position].	bufferClass := ( db2Conversion == #LargeByteArray or: [ db2Conversion == #LargeString ] ) 		ifTrue: [self largeObjectBufferClass] 		ifFalse: [db2Conversion == #FileRef ifTrue: [self fileRefBufferClass ]			ifFalse: [ db2Conversion == #DataLink ifTrue: [self datalinkBufferClass]				ifFalse: [self ]]].	^bufferClass basicNew on: aValue position: position session: session type: db2Conversion</body></methods><methods><class-id>Database.DB2Buffer class</class-id> <category>class initialization</category><body package="DB2EXDI">initialize	"DB2Buffer initialize"	self install</body></methods><methods><class-id>Database.DB2Buffer class</class-id> <category>private-activation</category><body package="DB2EXDI">install	| ifcClass |	(ifcClass := self connectionClass interfaceClass) notNil ifTrue:		[ConversionBufferMap := ifcClass conversionBufferMap. 		GetSelectorMap := ifcClass getSelectorMap.		PutSelectorMap := ifcClass putSelectorMap.		SQLTypeFromConversionMap := ifcClass fSqlTypeFromConversionMap.		CTypeFromConversionMap := ifcClass fCTypeFromConversionMap.		FetchBufferSizeBlocks := ifcClass fetchBufferSizeBlocks.		ValueSizeBlocks := ifcClass valueSizeBlocks.		ValuePrecisionBlocks := ifcClass valuePrecisionBlocks ].</body></methods><methods><class-id>Database.DB2Buffer class</class-id> <category>instance creation</category><body package="DB2EXDI">new	^self error: 'An DB2Buffer is created and privately used by an instance of DB2Session.'</body></methods><methods><class-id>Database.DB2Buffer class</class-id> <category>filein/fileout</category><body package="DB2EXDI">prerequisitesForLoading	"The receiver requires DB2Connection to have initialized	 its interface mapping before it initializes."	^super prerequisitesForLoading		addLast: DB2Connection;		addAll: DB2CLIInterface withAllSubclasses;		yourself</body></methods><methods><class-id>Database.DB2CLOBLocator</class-id> <category>private-db2</category><body package="DB2EXDI">db2Conversion	^#ClobLocator</body><body package="DB2EXDI">locatorCType	^41 "SQL_C_CLOB_LOCATOR"</body><body package="DB2EXDI">targetCType	"need for SQLGetSubString "	self connection isUnicodeEncoding ifTrue: [		^-8 "SQL_C_WCHAR"	] ifFalse: [		^1 "SQL_C_CHAR"	]</body></methods><methods><class-id>Database.DB2LargeObjectBuffer</class-id> <category>accessing</category><body package="DB2EXDI">blobBuffer	^blobBuffer</body><body package="DB2EXDI">blobBufferSize	blobBufferSize isNil ifTrue: [		blobBufferSize := 1048576	].	^blobBufferSize</body><body package="DB2EXDI">value	"Answer the value (or values) held in the buffer"	^bufferValue copy</body><body package="DB2EXDI">value: aValue	"Store aValue into the receiver and reallocate the buffer if the size of aValue is larger."	bufferValue := aValue.	self blobBufferSize &gt;= aValue size ifTrue: [		bufferValue isNil ifTrue: [ self at: 1 put: nil ].		self bindInputExternal	] ifFalse: [		self bindForInput.	]</body></methods><methods><class-id>Database.DB2LargeObjectBuffer</class-id> <category>allocation</category><body package="DB2EXDI">free	"Free the receiver."	blobBuffer notNil ifTrue:		[ blobBuffer freePointer.		  blobBuffer := nil ].	super free.</body><body package="DB2EXDI">mallocUsingSelector: mallocSelector	"Allocate a physical buffer for the receiver. Use mallocSelector to perform the allocation." 	[ "Begin unwind protection."	super mallocUsingSelector: mallocSelector.	self blobBufferSize notNil ifTrue: [	blobBuffer := CIntegerType char perform: mallocSelector with: self blobBufferSize].	"End unwind protection." ]		ifCurtailed: [ self free ]</body></methods><methods><class-id>Database.DB2LargeObjectBuffer</class-id> <category>testing</category><body package="DB2EXDI">isLargeObject	^true</body><body package="DB2EXDI">isStringBased	^#(#LargeString #ClobLocator #DBClobLocator) includes: self databaseType</body></methods><methods><class-id>Database.DB2LargeObjectBuffer</class-id> <category>private-data conversion {put}</category><body package="DB2EXDI">at: index putByteArray: aByteArray	"Put aByteArray into the buffer."	| bytes |	bytes := aByteArray  size.	blobBuffer copyAt: ((index-1) * elementSize) from: aByteArray size: bytes startingAt: 1.	pcbValue at: (index-1) put: bytes.	^aByteArray</body><body package="DB2EXDI">at: index putString: aString	"Put aString into the buffer."	self at: index putByteArray: (aString asByteArrayEncoding: self encoding).	^aString</body></methods><methods><class-id>Database.DB2LargeObjectBuffer</class-id> <category>private-data conversion {get}</category><body package="DB2EXDI">getByteArrayAt: index	"Answer a ByteArray populated from the buffer."	| bytes byteArray | 	bytes := pcbValue at: (index -1).	byteArray := ByteArray new: bytes.	blobBuffer copyAt: 0 to: byteArray size: bytes startingAt: 1.	^byteArray</body><body package="DB2EXDI">getStringAt: index	"Answer a String populated from the buffer."	^(self getByteArrayAt: index) asStringEncoding: self encoding</body></methods><methods><class-id>Database.DB2LargeObjectBuffer</class-id> <category>binding</category><body package="DB2EXDI">bindForInput	"Prepare the receiver to put data for an unbound parameter."	| xif size |	xif := self xif.	fParamType := xif SQL_PARAM_INPUT.	"We won't re-use pointers."	(bufferPointer isNil)		ifFalse:[ self free].	"Allocate CPointers to hold data and the size of the data "	self mallocUsingSelector: xif mallocSelector.	"For unbound buffers the data it represents is sent only when the server requests it. 	To facilitate this process we only bind the receiver's index so that the server can later	specify which instance of the receiver that it wants data for."	(bufferValue isKindOf: Array) ifTrue: [		size := bufferValue size	] ifFalse: [		size := 1	].	1 to: size do: [ :index |		self at: index putInteger: index.		"Assign the size indicator so that the driver can pre-allocate in advance. Preserve this		pointer's value for the duration of the transfer. Not all drivers capture this value at the		same time. Access seems to grab it again, after all the data has been sent."		bufferValue isNil ifTrue: [			pcbValue at: (index - 1) put: xif SQL_NULL_DATA		] ifFalse: [			pcbValue at: (index - 1) put: (self session class xif SQL_LEN_DATA_AT_EXEC: cbColDef). 		]		].		^self bindInputExternalBeforeTransfer</body><body package="DB2EXDI">bindForOutput	"Setup the receiver to hold the contents of a single column."	fParamType := self  xif SQL_PARAM_OUTPUT.	"We won't re-use pointers."	(bufferPointer isNil) ifFalse: [ self free ].	"Allocate external CPointers."	self mallocUsingSelector: self xif mallocSelector.</body></methods><methods><class-id>Database.DB2LargeObjectBuffer</class-id> <category>private-binding</category><body package="DB2EXDI">bindInputExternal	 "Bind the contents of the receiver to the server."	| rc xif  valueStream |	xif := self xif. 	bufferValue isNil ifTrue: [		self at: 1 put: nil.		rc := xif SQLPutData: self hstmt				 		with: blobBuffer				 		with: pcbValue contents.	] ifFalse: [		valueStream := ReadStream on: bufferValue. 		[ valueStream atEnd ]			whileFalse: [ "Ensure that proper conversion takes place." | numOfBytes numOfChars bufferSize |					bufferSize := self blobBufferSize.					(self isStringBased and: [ self isUnicodeEncoding ]) ifTrue: [						numOfBytes := bufferSize min: ((valueStream size - valueStream position)*2).						numOfChars := numOfBytes // 2.					] ifFalse: [						numOfBytes := bufferSize min: (valueStream size - valueStream position).						numOfChars := numOfBytes					].					self at: 1 put: (valueStream nextAvailable: numOfChars).					rc := xif SQLPutData: self hstmt							 		with: blobBuffer							 		with: pcbValue contents.		].	(self traceLevel &gt;= 3 ) ifTrue:	[ (self traceStream)		print: rc;  nextPutAll: ' = SQLPutData( hstmt = ';		nextPutAll: (self hstmt printStringRadix: 16);		nextPutAll: ', rgbValue = ';		nextPutAll: (blobBuffer  referentAddress printStringRadix: 16);		nextPutAll: ', cbValue = '; print: pcbValue contents;		nextPutAll: ' )'.		self connection class trace: self connection emitTrace ].	(rc == xif SQL_ERROR or: [ rc == xif SQL_SUCCESS_WITH_INFO ]) ifTrue:		[| errs |	 		errs := self connection getStatementErrors: self hstmt.			^self connectionClass unableToBindSignal raiseWith: errs errorString: errs first dbmsErrorString]	]</body><body package="DB2EXDI">bindInputExternalBeforeTransfer	"Bind the parameter marker to the server."	| rc bufferSession xif sqlType cType |	bufferSession := self session.	xif := bufferSession class xif.	cType := self fCType.	self isStringBased ifTrue: [		self isUnicodeEncoding ifTrue: [ | type |			type := self fSqlType.			cType := xif SQL_C_WCHAR.			type == xif SQL_CHAR ifTrue: [				sqlType := xif SQL_WCHAR			] ifFalse: [				type == xif SQL_VARCHAR ifTrue: [					sqlType := xif SQL_WVARCHAR				] ifFalse: [ 					sqlType := xif SQL_WLONGVARCHAR				]			]		] ifFalse: [			sqlType := self fSqlType		]	] ifFalse: [		sqlType := self fSqlType	].	count &gt; 1 ifTrue: [		bufferSession setStatementAttribute: #SQL_ATTR_PARAM_BIND_TYPE value: xif SQL_BIND_BY_COLUMN.		bufferSession setStatementAttribute: #SQL_ATTR_PARAMSET_SIZE value: count.	].	1 to: count do: [ :index | | aValue |		aValue := bufferValue at: index.		aValue isNil ifTrue: [			pcbValue at: (index - 1) put: xif SQL_NULL_DATA		] ifFalse: [			pcbValue at: (index - 1) put: (xif SQL_LEN_DATA_AT_EXEC: aValue size)		]		].	rc := xif  SQLBindParameter: bufferSession hstmt					    	     with: bufferIndex						     with: fParamType					    	     with: cType					    	     with: sqlType		 			    	     with: cbColDef		 			    	     with: self ibScale					    	     with: bufferPointer						     with: elementSize					    	     with: pcbValue.		( bufferSession traceLevel &gt;= 3 ) ifTrue:		[ (bufferSession  traceStream)			print: rc;  nextPutAll: ' = SQLSetParam( hstmt = ';			nextPutAll: (bufferSession hstmt printStringRadix: 16);			nextPutAll: ', ipar='; print: bufferIndex;			nextPutAll: ', fCType='; print: cType;			nextPutAll: ', fSqlType=';  print: sqlType;			nextPutAll: ', cbParamDef= '; print: cbColDef;			nextPutAll: ', ibScale= '; print: ibScale;			nextPutAll: ', *rgbValue='; print: bufferValue;			nextPutAll: ', *pcbSizeIndicator ='; print: pcbValue contents;			nextPutAll: ' )'.		bufferSession class trace: bufferSession emitTrace ].	(rc == xif SQL_SUCCESS) ifFalse:		[ | errs |		  errs := bufferSession getStatementErrors.		  ^bufferSession class connectionClass unableToBindSignal raiseWith: errs errorString: errs first dbmsErrorString ].</body><body package="DB2EXDI">bindOutputExternal	 "Retrieve data from unbound result column. We only copy up to maxBytesToCopy"	| rc xif copyIndex cType maxBytesToCopy cbValue dataStream nullTerm chunkSize isDone val |	xif := self xif.	copyIndex := 0.	cType := self fCType.	self isStringBased ifTrue: [		self isUnicodeEncoding ifTrue: [			cType := xif SQL_C_WCHAR.			nullTerm := 2.		]ifFalse: [			cType := xif SQL_C_CHAR.			nullTerm := 1.		]	]ifFalse:[		cType := xif SQL_C_BINARY.		nullTerm := 0.	].		self isStringBased ifTrue: [		dataStream := ReadWriteStream on: String new	] ifFalse: [		dataStream := ReadWriteStream on: ByteArray new	].	maxBytesToCopy := maxLongData min: cbColDef.	isDone := false.	[isDone]		whileFalse: [ cbValue := ((maxBytesToCopy - copyIndex + nullTerm) min: self blobBufferSize).					"Make sure cbValue is an even number in case it is used to handle Unicode strings."					(cbValue odd and: [ self isStringBased and: [ self isUnicodeEncoding ]]) ifTrue: [ cbValue := cbValue -1 ].					rc := xif SQLGetData: hstmt									with: bufferIndex									with: cType									with: blobBuffer									with: cbValue									with: pcbValue.					(self traceLevel &gt;= 3 ) ifTrue: 						[(self  traceStream)						print: rc;  nextPutAll: ' = SQLGetData( hstmt = ';						nextPutAll: (self hstmt printStringRadix: 16);						nextPutAll: ' )'.						self connection class trace: self connection emitTrace ].					chunkSize := cbValue - nullTerm.					((rc == xif SQL_ERROR ) or: [ rc == xif SQL_SUCCESS_WITH_INFO ] )  ifTrue:						[ | errs |	 					errs := self connection getStatementErrors: self hstmt.						(errs at: 1) sqlState = '01004'							ifTrue: ["Data was truncated. Ensure that we don't copy more									than maxBytesToCopy.  Also, exclude null terminator for Strings									for all but last chunk, which isn't null terminated."									pcbValue contents: chunkSize]							ifFalse: [ ^self connection class unableToBindSignal raiseWith: errs errorString: errs first dbmsErrorString ] ].					((rc == xif SQL_SUCCESS ) or: [ rc == xif SQL_NO_DATA_FOUND ])						ifTrue: ["All the data for the receiver has been received. 								There is no null terminator since this is a complete, final chunk.								Ensure that we don't copy more than maxBytesToCopy."								chunkSize := pcbValue contents.								pcbValue contents: (maxBytesToCopy min: chunkSize).								isDone := true. ]						ifFalse: [ copyIndex := copyIndex + chunkSize.									isDone := copyIndex &gt;= maxBytesToCopy].					"Convert the data chunk to an appropriate object using superclass methods, and add it."					(val := super value at: 1)							ifNil: [^nil]							ifNotNil: [dataStream nextPutAll: val]].	^dataStream contents</body><body package="DB2EXDI">putLobValue: aValue	| xif valueStream rc bufferSession |	bufferSession := self session.	xif := bufferSession class xif.	aValue isNil		ifTrue: 			[rc := xif						SQLPutData: bufferSession hstmt						with: 0						with: xif SQL_NULL_DATA]		ifFalse: 			[(aValue isKindOf: Stream)				ifTrue: [valueStream := aValue position: 0]				ifFalse: [valueStream := ReadStream on: aValue].			[valueStream atEnd] whileFalse: 					["Ensure that proper conversion takes place."					self at: 1						put: (valueStream nextAvailable: (self blobBufferSize min: elementSize)).					rc := xif								SQLPutData: bufferSession hstmt								with: blobBuffer								with: pcbValue contents.					bufferSession traceLevel &gt;= 3						ifTrue: 							[(bufferSession traceStream)								print: rc;								nextPutAll: ' = SQLPutData( hstmt = ';								nextPutAll: (bufferSession hstmt referentAddress printStringRadix: 16);								nextPutAll: ', rgbValue = ';								nextPutAll: (bufferPointer referentAddress printStringRadix: 16);								nextPutAll: ', cbValue = ';								print: pcbValue contents;								nextPutAll: ' )'.							bufferSession class trace: bufferSession emitTrace].					(rc == xif SQL_ERROR or: [rc == xif SQL_SUCCESS_WITH_INFO])						ifTrue: 							[| errs |							errs := bufferSession getStatementErrors.							^bufferSession class connectionClass unableToBindSignal raiseWith: errs								errorString: errs first dbmsErrorString]]]</body></methods><methods><class-id>Database.DB2LargeObjectBuffer</class-id> <category>initialize-release</category><body package="DB2EXDI">descriptor: aColDesc position: position session: aSession	"Initialize an instance of receiver for LOB handling with locator"	| valueType |	valueType:=aColDesc type.	self isUnicodeColumn: (self isUnicode: aColDesc fSqlType).	count:=	aSession blockFactor.	maxLongData := aSession maxLongData.	databaseType := (valueType == #LargeString) ifTrue: [		aColDesc fSqlType = -350 ifTrue: [			#DBClobLocator		] ifFalse: [			#ClobLocator		].	] ifFalse: [		#BlobLocator	]. "locator type"	cbColDef := aColDesc precision.	bufferIndex := position.	hstmt := aSession hstmt.	self session: aSession.	elementSize := 4. "4 for locator" 	self encoding: self connection encoding.	getSelector := GetSelectorMap at: valueType ifAbsent: [nil].	putSelector := PutSelectorMap at: valueType ifAbsent: [nil].	conversionBuffer  := (ConversionBufferMap at: databaseType) notNil ifTrue: [(ConversionBufferMap at: databaseType) new: elementSize].</body></methods><methods><class-id>Database.DB2ColumnDescription</class-id> <category>accessing</category><body package="DB2EXDI">fSqlType	"Return the receiver's SQL type"	^fSqlType</body><body package="DB2EXDI">fileRef	"Return the DB2LOBFileReference instance"	^fileRef</body><body package="DB2EXDI">fileRef: aFileRef	fileRef := aFileRef</body><body package="DB2EXDI">isUnicodeColumn	| sqlType |	sqlType := self fSqlType.	isUnicodeColumn isNil ifTrue: [		isUnicodeColumn := ((sqlType = -95) or: [ sqlType = -96 ]) or: [ sqlType = -350 ]	].	^isUnicodeColumn</body><body package="DB2EXDI">isUnicodeColumn: aBoolean	isUnicodeColumn := aBoolean</body></methods><methods><class-id>Database.DB2ColumnDescription</class-id> <category>private-accessing</category><body package="DB2EXDI">fSqlType:	aSmallInteger	"Set the receiver's SQL type."	fSqlType := aSmallInteger</body></methods><methods><class-id>Database.DB2ColumnDescription</class-id> <category>testing</category><body package="DB2EXDI">isLong	"Answer true if the receiver represents a long result column."	| xif |	xif := self class connectionClass xif.	^((fSqlType == xif SQL_CLOB or: [fSqlType == xif SQL_BLOB ]) or: [fSqlType == xif SQL_DBCLOB ])	and: [self maxColumnConstraint &gt; xif getDataChunkSize ]</body></methods><methods><class-id>Database.DB2ColumnDescription class</class-id> <category>accessing</category><body package="DB2EXDI">connectionClass	^DB2Connection</body></methods><methods><class-id>Database.DB2DatabaseException</class-id> <category>printing</category><body package="DB2EXDI">defaultMessageText	^(#db2DatabaseException &lt;&lt; #db2DB &gt;&gt; 'DB2 Database Exception.') asString</body></methods><methods><class-id>Database.DB2BLOBLocator</class-id> <category>private-db2</category><body package="DB2EXDI">db2Conversion	^#BlobLocator</body><body package="DB2EXDI">locatorCType	^31 "SQL_C_BLOB_LOCATOR"</body><body package="DB2EXDI">targetCType	"need for SQLGetSubString "	^-2 "SQL_C_BINARY"</body></methods><methods><class-id>Database.UnableToQueryStatementAttributes</class-id> <category>printing</category><body package="DB2EXDI">defaultMessageText	^(#unableToQueryStatementAttributes &lt;&lt; #db2DB &gt;&gt; 'Unable to query statement attributes.') asString</body></methods><methods><class-id>Database.DB2DataLinkBuffer</class-id> <category>private-data conversion {put}</category><body package="DB2EXDI">at: index putDataLink: aDataLink 	| str bytes |		self makeDataLink: aDataLink at: index.	"Now we have bufferPointer &amp; pcbValue already "	"str := aDataLink asByteArrayEncoding: self encoding.	bufferPointer copyAt: (index -1) from: str size: (bytes := str size) startingAt: 1.	pcbValue contents: bytes."	^aDataLink</body></methods><methods><class-id>Database.DB2DataLinkBuffer</class-id> <category>allocation</category><body package="DB2EXDI">free	"Free the receiver."	valuePointer notNil ifTrue: [ valuePointer freePointer.  valuePointer := nil ].	linkTypePointer notNil ifTrue:	[ linkTypePointer freePointer.  linkTypePointer := nil ].	commentPointer notNil ifTrue: [ commentPointer freePointer. commentPointer := nil ].	stringLengthPointer notNil ifTrue: [ stringLengthPointer freePointer. stringLengthPointer := nil ].	super free.</body><body package="DB2EXDI">mallocUsingSelector: mallocSelector	"Allocate a physical buffer for the receiver. Use mallocSelector to perform the allocation." 	| xif |	[ "Begin unwind protection."	xif := self xif.	super mallocUsingSelector: mallocSelector.	valuePointer := xif SQLCHAR perform: mallocSelector with: elementSize.	stringLengthPointer := xif SQLINTEGER perform: mallocSelector with: 1.	commentPointer := xif SQLCHAR perform: mallocSelector with: elementSize.	linkTypePointer := 'URL' copyToHeap.	"End unwind protection." ]		ifCurtailed: [ self free ]</body></methods><methods><class-id>Database.DB2DataLinkBuffer</class-id> <category>private-data conversion {get}</category><body package="DB2EXDI">getDataLinkAt: index	"Answer a DataLink populated from the buffer"	| bytes byteArray dl |	bytes := pcbValue at: (index -1).	byteArray := ByteString new: bytes.	bufferPointer copyAt: ((index-1) * elementSize) to: byteArray size: bytes startingAt: 1.	(dl:=DB2DataLink new) dlValue: byteArray.	 "asStringEncoding: self encoding"	self getDLAttributes: dl at: index.	^dl</body></methods><methods><class-id>Database.DB2DataLinkBuffer</class-id> <category>private</category><body package="DB2EXDI">getDLAttribute: attributeName for: aDataLink at: index 	| xif attr rc bytes attrString |	xif := self xif.	attr := xif perform: attributeName.	rc := xif 				SQLGetDataLinkAttr: self connection blobHstmt				with: attr				with: (bufferPointer refAt: (index - 1) * elementSize)				with: aDataLink dlValue size				with: valuePointer				with: elementSize				with: stringLengthPointer.	rc == xif SQL_SUCCESS 		ifFalse: 			[| errs |			errs := self connection getStatementErrors: self connection blobHstmt.			^self connectionClass unableToFetchDataSignal raiseWith: errs				errorString: errs first dbmsErrorString].	stringLengthPointer isNull ifTrue: [^nil].	bytes := stringLengthPointer contents.	attrString := ByteString new: bytes.	valuePointer 		copyAt: 0		to: attrString		size: bytes		startingAt: 1.	^attrString</body><body package="DB2EXDI">getDLAttributes: aDataLink at: index	"Note: SQL_ATTR_DATALINK_LINKTYPE answer always 'URL' ,	may be add SQL_ATTR_DATALINK_URLPATH ?"	aDataLink comment: (self getDLAttribute: #SQL_ATTR_DATALINK_COMMENT  for: aDataLink at: index);		complete: (self getDLAttribute: #SQL_ATTR_DATALINK_URLCOMPLETE for: aDataLink at: index);		pathOnly: (self getDLAttribute: #SQL_ATTR_DATALINK_URLPATHONLY for: aDataLink at: index);		server: 	(self getDLAttribute: #SQL_ATTR_DATALINK_URLSERVER for: aDataLink at: index);		scheme: (self getDLAttribute: #SQL_ATTR_DATALINK_URLSCHEME for: aDataLink at: index).</body><body package="DB2EXDI">makeDataLink: aDataLink at: index 	| xif rc bytes dlString |	xif := self xif.	valuePointer 		copyAt: 0		from: aDataLink dataLocation		size: aDataLink dataLocation size		startingAt: 1.	aDataLink comment notNil 		ifTrue: 			[commentPointer 				copyAt: 0				from: aDataLink comment				size: aDataLink comment size				startingAt: 1]		ifFalse: [commentPointer contents: nil].	rc := xif 				SQLBuildDataLink: self connection blobHstmt				with: linkTypePointer				with: 3				with: valuePointer				with: aDataLink dataLocation size				with: commentPointer				with: aDataLink comment size				with: (bufferPointer refAt: (index - 1) * elementSize)				with: elementSize				with: (pcbValue refAt: index - 1).	" 'URL' size"	"DataLinkBuffer"	"stringLengthPointer"	rc == xif SQL_SUCCESS 		ifFalse: 			[| errs |			errs := self connection getStatementErrors: self connection blobHstmt.			^self connectionClass unableToFetchDataSignal raiseWith: errs				errorString: errs first dbmsErrorString].	stringLengthPointer isNull ifTrue: [self halt].	"now set dlValue"	bytes := pcbValue at: index - 1.	dlString := ByteString new: bytes.	bufferPointer 		copyAt: (index - 1) * elementSize		to: dlString		size: bytes		startingAt: 1.	aDataLink dlValue: dlString</body></methods><methods><class-id>Database.DB2DataLinkBuffer</class-id> <category>initialize-release</category><body package="DB2EXDI">descriptorOLD: aColDesc position: position session: aSession	"Initialize an instance of receiver which is set up to hold values as described." 	super descriptor: aColDesc position: position session: session.	true ifTrue: [^self].	count := session blockFactor.	databaseType := aColDesc type.	elementSize := 256. "max file name length"	bufferIndex := position.	self session: aSession. 	hstmt := session hstmt.	self encoding: self connection encoding.	getSelector := GetSelectorMap at: #DataLink ifAbsent: [nil].	putSelector := PutSelectorMap at:  #DataLink ifAbsent: [nil].</body></methods><methods><class-id>Database.DB2Error</class-id> <category>accessing</category><body package="DB2EXDI">sqlState	^sqlState</body><body package="DB2EXDI">sqlState: anInteger	sqlState := anInteger</body></methods><methods><class-id>Database.DB2DataSource</class-id> <category>accessing</category><body package="DB2EXDI">description	^description</body><body package="DB2EXDI">description: aString	description := aString</body><body package="DB2EXDI">name	^name</body><body package="DB2EXDI">name: aString	name  := aString</body></methods><methods><class-id>Database.DB2DataSource</class-id> <category>printing</category><body package="DB2EXDI">printOn: aStream	super printOn: aStream.	aStream		nextPutAll: '( DSN =';		print: self name; nextPutAll: ', Description = ';		print: self description; nextPutAll: ' )'</body></methods><methods><class-id>Database.DB2FileRefBuffer</class-id> <category>private-accessing</category><body package="DB2EXDI">at: anIndex put: anObject	"Store anObject into the buffer at anIndex."	anObject isNil		ifTrue: [ pcbValue contents: self  xif SQL_NULL_DATA ]		ifFalse:[pcbValue contents: 0. "not null data "				self perform: putSelector with: anIndex with: anObject ].	^anObject</body><body package="DB2EXDI">fSqlType	"Answer the DB2 SQL data type for the data in this buffer."	"Assume: all DB2LOBFileRef's instances same dataType "	count == 0 ifTrue: [^SQLTypeFromConversionMap at: bufferValue dataType].	^SQLTypeFromConversionMap at: (bufferValue first ) dataType</body><body package="DB2EXDI">fileReadOption	^self xif SQL_FILE_READ</body></methods><methods><class-id>Database.DB2FileRefBuffer</class-id> <category>private-data conversion {put}</category><body package="DB2EXDI">at: index putFileRef: aFileRef	"Put aString into the buffer."	| str bytes aString |	aString:=aFileRef fileName.		str := aString asByteArrayEncoding: self encoding.	bufferPointer copyAt: (index -1)*elementSize from: str size: (bytes := str size) startingAt: 1.	bufferLengthPointer at: (index-1) put: bytes.	fileOptionsPointer at: (index-1) put: self fileReadOption.	^aFileRef</body></methods><methods><class-id>Database.DB2FileRefBuffer</class-id> <category>private-binding</category><body package="DB2EXDI">bindInputExternal	"Bind the contents of the receiver to the server."	| rc xif |	xif := self xif.	rc := xif 				SQLBindFileToParam: self hstmt				with: bufferIndex				with: self fSqlType				with: bufferPointer				with: bufferLengthPointer				with: fileOptionsPointer				with: elementSize				with: pcbValue.	"dataType"	self traceLevel &gt;= 3 		ifTrue: 			[(self traceStream)				print: rc;				nextPutAll: ' = SQLBindFileToParam( hstmt = ';				nextPutAll: (self hstmt printStringRadix: 16);				nextPutAll: ', ipar=';				print: bufferIndex;				nextPutAll: ', dataType=';				print: self fCType;				nextPutAll: ', bufferLength=';				print: bufferLengthPointer contents;				nextPutAll: ', fileOptions= ';				print: fileOptionsPointer contents;				nextPutAll: ', *rgbValue=';				print: bufferValue;				nextPutAll: ', cbValueMax=';				print: elementSize;				nextPutAll: ', *pcbValue=';				print: pcbValue contents;				nextPutAll: ' )'.			self connection class trace: self connection emitTrace].	rc == xif SQL_SUCCESS 		ifFalse: 			[| errs |			errs := self connection getStatementErrors: self hstmt.			^self connectionClass unableToBindSignal raiseWith: errs				errorString: errs first dbmsErrorString]</body><body package="DB2EXDI">bindOutputExternal	"Prepare the receiver to automatically receive it's data from the server."	| rc xif |	self updateFileRefInfo.	xif := self xif.	rc := xif 								SQLBindFileToCol: self hstmt				with: bufferIndex				with: bufferPointer				with: bufferLengthPointer				with: fileOptionsPointer				with: elementSize				with: nil				with: pcbValue.	self traceLevel &gt;= 3 		ifTrue: 			[(self traceStream)				print: rc;				nextPutAll: ' = SQLBindFileToCol( hstmt = ';				nextPutAll: (self hstmt printStringRadix: 16);				nextPutAll: ', icol =';				print: bufferIndex;				nextPutAll: ', rgbValue = ';				nextPutAll: (bufferPointer referentAddress printStringRadix: 16);				nextPutAll: ', elementSize = ';				print: elementSize;				nextPutAll: ', pcbValue = ';				print: (pcbValue referentAddress printStringRadix: 16);				nextPutAll: ' )'.			self connection class trace: self connection emitTrace].	rc == xif SQL_SUCCESS 		ifFalse: 			[| errs |			errs := self connection getStatementErrors: self hstmt.			^self connectionClass unableToBindSignal raiseWith: errs				errorString: errs first dbmsErrorString]</body><body package="DB2EXDI">updateFileNameInfo: index	|  str  bytes |	bufferValue computeFileName.	str := bufferValue fileName asByteArrayEncoding: self encoding.	bufferPointer copyAt: ((index -1)*elementSize) from: str size: (bytes := str size) startingAt: 1.	bufferLengthPointer at: (index -1) put: bytes.	fileOptionsPointer at: (index -1) put: (self xif perform: bufferValue fileOptions).</body><body package="DB2EXDI">updateFileRefInfo		1 to: count do: [ :index |		self updateFileNameInfo: index ].</body></methods><methods><class-id>Database.DB2FileRefBuffer</class-id> <category>allocation</category><body package="DB2EXDI">free	"Free the receiver."	fileOptionsPointer notNil		ifTrue: 			[fileOptionsPointer freePointer.			fileOptionsPointer := nil].	bufferLengthPointer notNil		ifTrue: 			[bufferLengthPointer freePointer.			bufferLengthPointer := nil].	super free</body><body package="DB2EXDI">mallocUsingSelector: mallocSelector	"Allocate a physical buffer for the receiver. Use mallocSelector to perform the allocation." 	[ "Begin unwind protection."	super mallocUsingSelector: mallocSelector.	bufferLengthPointer := CIntegerType short "SQLSMALLINT" perform: mallocSelector with: (count max: 1).	fileOptionsPointer := CIntegerType unsignedLong "SQLUINTEGER" perform: mallocSelector with: (count max: 1).	"End unwind protection." ]		ifCurtailed: [ self free ]</body></methods><methods><class-id>Database.DB2FileRefBuffer</class-id> <category>private-data conversion {get}</category><body package="DB2EXDI">getFileRefAt: index	^#FileRef</body></methods><methods><class-id>Database.DB2FileRefBuffer</class-id> <category>testing</category><body package="DB2EXDI">isFileRefObject	^true</body></methods><methods><class-id>Database.DB2FileRefBuffer</class-id> <category>initialize-release</category><body package="DB2EXDI">descriptor: aColDesc position: position session: aSession	"Initialize an instance of receiver which is set up to hold values as described."	count := session blockFactor.	"databaseType := aColDesc dataType." "i.e. #Blob or #Clob"	self isUnicodeColumn: (self isUnicode: aColDesc fSqlType).	elementSize := 256. "max file name length"	bufferIndex := position.	self session: aSession.	hstmt := aSession hstmt.	bufferValue := aColDesc fileRef.	self encoding: #default.	getSelector := GetSelectorMap at: #FileRef ifAbsent: [nil].	putSelector := PutSelectorMap at:  #FileRef ifAbsent: [nil].</body><body package="DB2EXDI">on: aValue position: position session: aSession type: type	"Initialize an instance of receiver which is set up to hold aValue." 	count := session paramSetSize.	ibScale := 0.    	databaseType := type. "aValue dataType" "i.e. #Blob or #Clob"	elementSize := 256. "max file name length"	bufferIndex := position.	self session: aSession.	hstmt := aSession hstmt.	bufferValue := aValue.	self encoding: #default.	self isUnicodeColumn: false.	getSelector := GetSelectorMap at: #FileRef ifAbsent: [nil].	putSelector := PutSelectorMap at:  #FileRef ifAbsent: [nil].</body></methods><methods><class-id>Database.DB2LOBFileReference</class-id> <category>accessing</category><body package="DB2EXDI">appendToFile	fileOptions:=#SQL_FILE_APPEND</body><body package="DB2EXDI">compute:  aBlock	computeBlock:=aBlock</body><body package="DB2EXDI">computeFileName	computeBlock notNil ifTrue: [fileName:=computeBlock value: fileName].	^fileName</body><body package="DB2EXDI">createFile	fileOptions:=#SQL_FILE_CREATE</body><body package="DB2EXDI">dataType	^dataType</body><body package="DB2EXDI">dataType: aDb2Conversion	dataType:=aDb2Conversion</body><body package="DB2EXDI">fileName	^fileName</body><body package="DB2EXDI">fileName: aString	fileName:=aString</body><body package="DB2EXDI">fileOptions	^fileOptions</body><body package="DB2EXDI">forBLOB	self dataType: #LargeByteArray</body><body package="DB2EXDI">forCLOB	self dataType: #LargeString</body><body package="DB2EXDI">overwriteFile	fileOptions:=#SQL_FILE_OVERWRITE</body><body package="DB2EXDI">value	^self</body></methods><methods><class-id>Database.DB2LOBFileReference</class-id> <category>private-db2</category><body package="DB2EXDI">db2Conversion	^#FileRef</body></methods><methods><class-id>Database.DB2LOBFileReference</class-id> <category>initialize</category><body package="DB2EXDI">initialize	fileName:='lobfile.bin'.	self createFile</body></methods><methods><class-id>Database.DB2LOBFileReference class</class-id> <category>instance creation</category><body package="DB2EXDI">for: aFileName	^self new 		fileName: aFileName</body><body package="DB2EXDI">forBLOB: aFileName	^self new 		fileName: aFileName;		dataType: #LargeByteArray</body><body package="DB2EXDI">forCLOB: aFileName	^self new 		fileName: aFileName;		dataType: #LargeString</body><body package="DB2EXDI">new	^super new initialize</body></methods><methods><class-id>Database.DB2DBCLOBLocator</class-id> <category>private-db2</category><body package="DB2EXDI">db2Conversion	^#DBClobLocator</body><body package="DB2EXDI">locatorCType	^-351 "SQL_C_DBCLOB_LOCATOR"</body><body package="DB2EXDI">targetCType	"need for SQLGetSubString "	^-8 "SQL_C_WCHAR"</body></methods><methods><class-id>Database.DB2Transaction</class-id> <category>private-finalization</category><body package="DB2EXDI">acquireExternal	^self</body><body package="DB2EXDI">beginExternal	^self</body><body package="DB2EXDI">commitExternal	^self</body><body package="DB2EXDI">dismissExternal	^self</body><body package="DB2EXDI">rollbackExternal	^self</body></methods><methods><class-id>Database.DB2Transaction</class-id> <category>private-execution</category><body package="DB2EXDI">executor	^self shouldNotImplement</body><body package="DB2EXDI">finalizeExternal	^self shouldNotImplement</body><body package="DB2EXDI">key	^self shouldNotImplement</body></methods><methods><class-id>Database.DB2Transaction class</class-id> <category>accessing</category><body package="DB2EXDI">connectionClass	"Answer the class to use for connection objects associated with receiver."	^DB2Connection</body></methods><methods><class-id>Database.DB2Transaction class</class-id> <category>private-registry</category><body package="DB2EXDI">registry: aCollection	^self shouldNotImplement</body></methods><methods><class-id>Database.DB2Manager</class-id> <category>api-calls</category><body package="DB2EXDI">attachTo: aNode username: aUsername password: aPassword	"self attachTo: 'NTSERV00' username: 'avb2' password: 'anton' "	| xif rc pSqlca szUser szPassword szNode |	xif := self xif.	[ "Begin unwind protection."	pSqlca := xif sqlca perform: xif mallocSelector with: 1.	szUser:=aUsername copyToHeap. 	szPassword:=aPassword copyToHeap.	szNode:=aNode copyToHeap.	 rc := xif sqleatin_api: szNode with: szUser with: szPassword with: pSqlca.	self sqlInfoPrint: 'attach to ', aNode, ' user ', aUsername sqlca: pSqlca.	"End unwind protection." ]		ensure:			[ pSqlca notNil ifTrue: [ pSqlca freePointer ].			  szUser notNil ifTrue: [szUser free].			  szPassword notNil ifTrue: [szPassword free].			  szNode notNil ifTrue: [szNode free]]</body><body package="DB2EXDI">closeDDS: aHandle	""	| xif rc pSqlca |	xif := self xif.	[ "Begin unwind protection."	pSqlca := xif sqlca perform: xif mallocSelector with: 1.	 rc := xif sqledcls_api: aHandle with: pSqlca.	self sqlInfoPrint: 'close database directory scan  ', aHandle printString sqlca: pSqlca.	"End unwind protection." ]		ensure:			[ pSqlca notNil ifTrue: [ pSqlca freePointer ]]</body><body package="DB2EXDI">databaseEntryOf: anAlias	"self databaseEntryOf: 'SAMPLE' "	| r handle count i a |	r:=self openDDS: ''.	[	handle := r first. count:=r last.		i:= 0. a:=''. 		[i &lt; count and: [anAlias~= a ] ] 			whileTrue: [a:=((r:=self getNextDBDirectoryEntry: handle) at: #alias)  copyWithout: $ . i:=i+1. ].		anAlias~= a ifTrue: [^nil]. "Alias not found"		^r ] 	ensure: [ self closeDDS: handle ]</body><body package="DB2EXDI">detach	"self detach"	| xif rc pSqlca |	xif := self xif.	[ "Begin unwind protection."	pSqlca := xif sqlca perform: xif mallocSelector with: 1.	 rc := xif sqledtin_api: pSqlca.	self sqlInfoPrint: 'detach ' sqlca: pSqlca.	"End unwind protection." ]		ensure:			[ pSqlca notNil ifTrue: [ pSqlca freePointer ] ]</body><body package="DB2EXDI">errorClass	^DB2Error</body><body package="DB2EXDI">forceApplicationAll"self forceApplicationAll"	| xif pSqlca rc |	xif := self xif.	[ "Begin unwind protection."	pSqlca := xif sqlca perform: xif mallocSelector with: 1.	 rc := xif sqlefrce_api: xif SQL_ALL_USERS		with: nil		with: xif SQL_ASYNCH		with: pSqlca.	self sqlInfoPrint: 'force application all' sqlca: pSqlca.	"End unwind protection." ]		ensure:		[ pSqlca notNil ifTrue: [ pSqlca freePointer ]]</body><body package="DB2EXDI">getNextDBDirectoryEntry: aHandle	""	| xif rc pSqlca resultArray ppDbDirEntry t |	xif := self xif.	[ "Begin unwind protection."	pSqlca := xif sqlca perform: xif mallocSelector with: 1.	ppDbDirEntry:=(CPointerType defaultPointer referentType: xif sqledinfo) malloc: 1.	 rc := xif sqledgne_api: aHandle with: ppDbDirEntry with: pSqlca.	self sqlInfoPrint: 'get next database directory entry' sqlca: pSqlca.	resultArray := Dictionary new: 14.	t:=ppDbDirEntry contents contents.	#(alias dbname drive intname nodename dbtype comment ) 		do: [:x | resultArray at: x put: ((t memberAt: x) datum stringAt: 1)]. " ugly "	#(authentication cat_nodenum nodenum type) 		do: [:x | resultArray at: x put: (t memberAt: x)  ]. 	"End unwind protection." ]		ensure:			[ pSqlca notNil ifTrue: [ pSqlca freePointer ].			ppDbDirEntry notNil ifTrue: [ppDbDirEntry freePointer]].	^resultArray</body><body package="DB2EXDI">instanceNameOf: anAlias	"self instanceNameOf: 'SAMPLE' "	| e |	((e:=self databaseEntryOf: anAlias asUppercase) at: #type) == 48 ifTrue: [^nil]. "local instance"	^e at: #nodename</body><body package="DB2EXDI">openDDS: aPath	""	| xif rc pSqlca szPath pHandle pNumEntries resultArray |	xif := self xif.	[ "Begin unwind protection."	pSqlca := xif sqlca perform: xif mallocSelector with: 1.	szPath:=aPath copyToHeap.	pHandle:=CIntegerType short malloc: 1.	pNumEntries:=CIntegerType short malloc: 1.	 rc := xif sqledosd_api: szPath with: pHandle with: pNumEntries with: pSqlca.	self sqlInfoPrint: 'open database directory scan ' sqlca: pSqlca.	resultArray := Array with: pHandle contents with: pNumEntries contents.	"End unwind protection." ]		ensure:			[ pSqlca notNil ifTrue: [ pSqlca freePointer ].			szPath notNil ifTrue: [ szPath freePointer ].			pHandle notNil ifTrue: [ pHandle freePointer ].			pNumEntries notNil ifTrue: [pNumEntries freePointer]].	^resultArray</body><body package="DB2EXDI">restartDatabase: aDatabase username: aUsername password: aPassword	"self restartDatabase: 'sample' username: 'avb2' password: 'anton' "	| xif rc pSqlca pParamStruct szUser szPassword szDatabase |	xif := self xif.	[ "Begin unwind protection."	pSqlca := xif sqlca perform: xif mallocSelector with: 1.	pParamStruct:= xif db2RestartDbStruct perform: xif mallocSelector with: 1.	szUser:=aUsername copyToHeap. 	szPassword:=aPassword copyToHeap.	szDatabase:=aDatabase copyToHeap.	pParamStruct memberAt: #piDatabaseName put: szDatabase;		memberAt: #piUserId put: szUser;		memberAt: #piPassword put: szPassword;		memberAt: #piTablespaceNames put: nil.	 rc := xif db2DatabaseRestart: xif db2Version with: pParamStruct with: pSqlca.	self sqlInfoPrint: 'restart database ' sqlca: pSqlca.	"End unwind protection." ]		ensure:			[ pSqlca notNil ifTrue: [ pSqlca freePointer ].			  szUser notNil ifTrue: [szUser free].			  szPassword notNil ifTrue: [szPassword free].			  szDatabase notNil ifTrue: [szDatabase free].			  pParamStruct notNil ifTrue: [pParamStruct free]]</body><body package="DB2EXDI">runStats: aTable statsOption: anOption shared: aBoolean indexes: anIndexes"self runStats: 'AVB.EMPLOYEE' statsOption: #SQL_STATS_ALL shared: true indexes: nil"	| xif pSqlca pTableName shareLevel rc |	xif := self xif.	[ "Begin unwind protection."	pSqlca := xif sqlca perform: xif mallocSelector with: 1.	pTableName:= aTable copyToHeap.	shareLevel:= aBoolean ifTrue: [xif SQL_STATS_CHG] ifFalse: [xif SQL_STATS_REF].	 rc := xif sqlustat_api: pTableName 		with: 0 "numIndexes - ALL" 		with: nil		with: (xif perform: anOption)		with: shareLevel		with: pSqlca.	self sqlInfoPrint: 'runstats on ', aTable sqlca: pSqlca.	"End unwind protection." ]		ensure: 	[ pSqlca notNil ifTrue: [ pSqlca freePointer ].		  		pTableName notNil ifTrue: [pTableName free]]</body><body package="DB2EXDI">startDatabaseManager"self startDatabaseManager"	| xif rc pSqlca |	xif := self xif.	[ "Begin unwind protection."	pSqlca := xif sqlca perform: xif mallocSelector with: 1.	 rc := xif sqlepstart_api: nil with: pSqlca.	self sqlInfoPrint: 'start database manager' sqlca: pSqlca.	"End unwind protection." ]		ensure: 	[ pSqlca notNil ifTrue: [ pSqlca freePointer ]]</body><body package="DB2EXDI">stopDatabaseManager	"self stopDatabaseManager"	| xif rc pSqlca |	xif := self xif.	[ "Begin unwind protection."	pSqlca := xif sqlca perform: xif mallocSelector with: 1.	 rc := xif sqlepstp_api: nil with: pSqlca.	self sqlInfoPrint: 'stop database manager' sqlca: pSqlca.	"End unwind protection." ]		ensure: 	[ pSqlca notNil ifTrue: [ pSqlca freePointer ]]</body></methods><methods><class-id>Database.DB2Manager</class-id> <category>private</category><body package="DB2EXDI">sqlInfoPrint: aMessage sqlca: pSqlca	"Converted from util.c"	| rc sqlInfo errorMsg sqlCode sqlstateMsg error xif |	["Begin unwind protection" 	xif := self xif.	sqlstateMsg := CIntegerType char perform: xif mallocSelector with: 1024.	errorMsg := CIntegerType char perform: xif  mallocSelector with: 1024.	((sqlCode:=pSqlca memberAt: #sqlcode) ~= 0 and: [sqlCode~= 100]) 	ifTrue: [ sqlInfo := ReadWriteStream on: (String new: 600).        sqlInfo nextPutAll: '  app. message      = ';			nextPutAll: aMessage; cr.        sqlInfo nextPutAll: (sqlCode &lt; 0 ifTrue: ['\-- error report --\'] ifFalse: ['\---- warning report ----\']) withCRs .	  sqlInfo nextPutAll: 'SQLCODE           = ';			nextPutAll: sqlCode printString; cr.        " get error message "        rc := xif sqlaintp: errorMsg with: 1024 with: 255 with: pSqlca.        "return code is the length of the errorMsg string "        rc &gt; 0 ifTrue: [sqlInfo nextPutAll: (errorMsg copyCStringFromHeap)].        "get SQLSTATE message "        rc := xif sqlogstt: sqlstateMsg with: 1024 with: 255 with: (pSqlca memberAt: #sqlstate).        rc &gt; 0 ifTrue: [sqlInfo nextPutAll: (sqlstateMsg copyCStringFromHeap)].	sqlInfo nextPutAll: (sqlCode &lt; 0 ifTrue: ['-- end error report --'] ifFalse: ['---- end warning report ----'])  ].	sqlInfo notNil ifTrue: [error := self class errorClass new.		error dbmsErrorCode: sqlCode.		error dbmsErrorString: sqlInfo contents.		error sqlState: (pSqlca memberAt: #sqlstate) copyCStringFromHeap.	Transcript show: sqlInfo contents; cr.].	"End unwind protection"] ensure:			[ sqlstateMsg notNil ifTrue: [ sqlstateMsg freePointer ].			errorMsg notNil ifTrue: [ errorMsg freePointer ] ].		^error</body><body package="DB2EXDI">xif	^self class xif</body></methods><methods><class-id>Database.DB2Manager class</class-id> <category>private-accessing</category><body package="DB2EXDI">connectionClass	^DB2Connection</body><body package="DB2EXDI">errorClass	^DB2Error</body><body package="DB2EXDI">xif	"Answer the ExternalInterface subclass instance to use." 	^self connectionClass apiXif</body></methods><methods><class-id>Database.DB2Manager class</class-id> <category>instance-creation</category><body package="DB2EXDI">new	singleton isNil ifTrue: [singleton:=self basicNew].	^singleton</body></methods><methods><class-id>Database.DB2Session</class-id> <category>private-answer set</category><body package="DB2EXDI">aboutToAnswer	"Do last-minute work before fetching data from an answer set"	totalRows := 0.	rowsInBlock := 0.	currentRowIndex := 0.	self checkRowSetSize.</body><body package="DB2EXDI">acquireBuffers	"Acquire buffers for fetching the answer set from the server."	"Set blockFactor to 1 if the select list contains Large OBjects."	self blockFactor ~= 1 ifTrue: [		(self columnDescriptions contains: [ :each|  each isLong ]) ifTrue: [			self blockFactor: 1		]	].	super acquireBuffers</body><body package="DB2EXDI">advanceExternal	"Advance to the next row in the block buffer.  If the buffer is exhausted,	refill it and continue."	(self currentRowIndex between: 0 and: self rowsInBlock) ifTrue: [ self currentRowIndex: (self currentRowIndex + 1) ].	self currentRowIndex &gt; self rowsInBlock		ifTrue:	[ (self rowsInBlock &lt; self blockFactor and: [ self rowsInBlock &gt; 0])					ifTrue:	[ ^nil		"No more rows will be found" ].				"self updateFileRefs."				self getBlockOfRowsExternal.				self rowsInBlock &lt;= 0					ifTrue:	[ ^nil		"No more rows will be found" ].				self currentRowIndex: 1 ].		^self</body><body package="DB2EXDI">advanceExternal: fetchOrientation offset: fetchOffset	"Advance to the next row in the block buffer.  If the buffer is exhausted,	refill it and continue."	fetchOrientation == self fetchNextMode ifTrue: [		self currentRowIndex: (self currentRowIndex + 1).	] ifFalse: [		fetchOrientation == self fetchPriorMode ifTrue: [						self currentRowIndex &gt; 0  ifTrue: [ self currentRowIndex: (self currentRowIndex - 1) ].		] ifFalse: [			fetchOrientation == self fetchAbsoluteMode ifTrue: [				self currentRowIndex: (self blockFactor + 2).				self rowsInBlock: (self blockFactor + 1).			] ifFalse: [				fetchOrientation == self fetchRelativeMode ifTrue: [					self currentRowIndex: (self currentRowIndex + fetchOffset).				].			].		].	].	((self currentRowIndex &gt; self rowsInBlock) or: [ self currentRowIndex &lt;= 0 ])		ifTrue:	[ 				self updateFileRefs.				self getBlockOfRowsExternal: fetchOrientation offset: fetchOffset.				self rowsInBlock &lt;= 0					ifTrue:	[ ^nil		"No more rows will be found" ].				fetchOrientation == self fetchPriorMode ifTrue: [					self currentRowIndex &lt;= 0 ifTrue: [						self currentRowIndex: self rowsInBlock.					]				] ifFalse: [					self currentRowIndex: 1.				].			].		^self</body><body package="DB2EXDI">allocateFetchedPointer	| xif p |		["Begin unwind protection."	xif := self class xif.	self pRowsFetched: (p := xif SQLUINTEGER perform: xif mallocSelector with: 1).	self setStatementAttribute: #SQL_ATTR_ROWS_FETCHED_PTR value: p.	rowStatus := xif SQLUINTEGER perform: xif mallocSelector with: blockFactor.	self setStatementAttribute: #SQL_ATTR_ROW_STATUS_PTR value: rowStatus.	] 			ifCurtailed: [p notNil ifTrue: [p freePointer].				rowStatus notNil ifTrue: [rowStatus freePointer].			]</body><body package="DB2EXDI">allocateRowBufferExternal: aColumn	"Answer a DB2Buffer allocated for holding one column's	worth of information as returned by the DB2 CLI."	| aColDescription buffer | 	aColDescription := columnDescriptions at: aColumn.		"An appropriate buffer class for the result column will be choosen automatically."	buffer := self class bufferClass descriptor: aColDescription  position: aColumn session: self.	buffer bindForOutput.	^buffer</body><body package="DB2EXDI">answerOfClass: anAnswerStreamClass	"Answer an instance of the given subclass of ExternalDatabaseAnswerStream"	"Assert: anAnswerStreamClass isKindOf: ExternalDatabaseAnswerStream"	| initialAnswer |	initialAnswer := ( self state == #ready ).	self state: #validResults.	initialAnswer		ifTrue:	[ "Verify that the query executed without error."				self resultsExternal ]		ifFalse:	[ "If we're still holding on to a prior answer stream, dismiss it."				answerStream notNil					ifTrue:	[ answerStream close ]. "Temporary ! Cursor must be closed in 'moreResultsExternal' "				"Assert: self state == #validResults"				self moreResultsExternal					ifFalse:	[ self state: #prepared.							^#noMoreAnswers ] ].	self hasAnswerSetExternal		ifTrue:	[ | answer |				initialAnswer ifFalse:					[ "Previous descriptions/buffers are no longer valid"					self releaseBuffers.					self releaseAdaptors.					self columnDescriptions: nil ].				self getColumnDescriptions.				self acquireBuffers.				self setupAdaptors.				self aboutToAnswer.				answer := anAnswerStreamClass newForSession: self.				self answerStream: answer.				self state: #fetchingData.				^answer ].	^#noAnswerStream.</body><body package="DB2EXDI">answerStreamDismissed	"Close the cursor and discard pending results."	"self freeStatementExternal: #SQL_CLOSE." " We must defer closing of cursor up to next execute call "	deferCursorClosing ifFalse: [self closeCursor] ifTrue: [ self mustCloseCursor: true].	super answerStreamDismissed.	"self handleAutoCommit"</body><body package="DB2EXDI">cancelAnswerSetExternal	"Nothing more to do here."	^self	"self xif SQLCancel: self hstmt"</body><body package="DB2EXDI">checkRowSetSize"Check and set row set size"	| old |	old:=self  sqlStatementAttributeCache at: #SQL_ATTR_ROW_ARRAY_SIZE ifAbsent: [1].	old = blockFactor ifTrue: [^true] 		ifFalse: [self setStatementAttribute: #SQL_ATTR_ROW_ARRAY_SIZE value: blockFactor].</body><body package="DB2EXDI">describeAnswerColumns	"Fill in the columnDescriptions array."	| xif descrs cbColNameMax columnDescriptionClass szColName pcbColName pfSqlType pcbColDef pibScale pfNullable rc precision colDesc dt |	xif := self class xif.	descrs := Array new: self numColumns.	cbColNameMax := self connection 				getInformationType: #SQL_MAX_COLUMN_NAME_LEN.	columnDescriptionClass := self connection class columnDescriptionClass.		["Begin unwind protection."	szColName := xif UCHAR perform: xif mallocSelector with: (self connection bytesPerCharacter*cbColNameMax).	pcbColName := xif SQLSMALLINT perform: xif mallocSelector with: 1.	pfSqlType := xif SQLSMALLINT perform: xif mallocSelector with: 1.	pcbColDef := xif SQLUINTEGER perform: xif mallocSelector with: 1.	pibScale := xif SQLSMALLINT perform: xif mallocSelector with: 1.	pfNullable := xif SQLSMALLINT perform: xif mallocSelector with: 1.	1 to: self numColumns do: [:aColumn | 		self connection isUnicodeEncoding ifTrue: [			rc := xif SQLDescribeColW: self hstmt						with: aColumn						with: szColName						with: cbColNameMax						with: pcbColName						with: pfSqlType						with: pcbColDef						with: pibScale						with: pfNullable.		] ifFalse: [			rc := xif SQLDescribeCol: self hstmt						with: aColumn						with: szColName						with: cbColNameMax						with: pcbColName						with: pfSqlType						with: pcbColDef						with: pibScale						with: pfNullable.		].			precision := pcbColDef contents.			traceLevel &gt;= 2 				ifTrue: 					[(self traceStream)						print: rc;						nextPutAll: ' = SQLDescribeCol( hstmt=';						nextPutAll: (self hstmt printStringRadix: 16);						nextPutAll: ', icol =';						print: aColumn;						nextPutAll: ', szColName: ';						print: szColName copyCStringFromHeap;						nextPutAll: ', cbColName: ';						print: pcbColName contents;						nextPutAll: ', fSQLType: ';						print: pfSqlType contents;						nextPutAll: ', cbColDef: ';						print: precision;						nextPutAll: ', ibScale: ';						print: pibScale contents;						nextPutAll: ', fNullable: ';						print: pfNullable contents;						nextPutAll: ' )'.					self class trace: self emitTrace].			(rc == xif SQL_SUCCESS or: [rc == xif SQL_SUCCESS_WITH_INFO]) 				ifFalse: 					[| errs |					errs := self getStatementErrors.					^self class connectionClass unableToDescribeSignal raiseWith: errs						errorString: errs first dbmsErrorString].			(colDesc := columnDescriptionClass new)				index: aColumn;				name: (szColName copyCStringFromHeap: self connection encoding);				fSqlType: pfSqlType contents;				nullable: pfNullable contents == xif SQL_NULLABLE.			dt := xif class fSqlTypeToConversionMap at: colDesc fSqlType.			(self answerLOBValues not 				and: [dt == #LargeByteArray or: [dt == #LargeString]]) 					ifTrue: 						[self answerLocators 							ifTrue: 								[colDesc									fSqlType: (xif class fSqlTypeFromConversionMap 												at: (dt := DB2LOBLocator locatorTypeFor: dt));									type: dt;									maxColumnConstraint: 4;									precision: 4;									scale: 0]							ifFalse: 								["answer FileRef"								colDesc									fSqlType: nil;									type: #FileRef;									fileRef: (answerBlob at: aColumn);									maxColumnConstraint: precision;									precision: precision;									scale: 0	"pfSqlType contents"]]					ifFalse: 						[colDesc							type: dt;							maxColumnConstraint: precision;							precision: precision;							scale: pibScale contents].			descrs at: aColumn put: colDesc]	"End unwind protection."] 			ensure: 				[szColName notNil ifTrue: [szColName freePointer].				pcbColName notNil ifTrue: [pcbColName freePointer].				pfSqlType notNil ifTrue: [pfSqlType freePointer].				pcbColDef notNil ifTrue: [pcbColDef freePointer].				pibScale notNil ifTrue: [pibScale freePointer].				pfNullable notNil ifTrue: [pfNullable freePointer]].	self columnDescriptions: descrs</body><body package="DB2EXDI">getBlockOfRowsExternal	"Fetch the next block of rows into the memory allocated for this purpose."	| xif rc p |	xif := self class xif.	"workaround for DB2 v7 client bug"	rc := blockFactor = 1 				ifFalse: 					[pRowsFetchedHolder value isNil ifTrue: [self allocateFetchedPointer].					(p := pRowsFetchedHolder value) contents: 0.					xif 						SQLFetchScroll: self hstmt						with: xif SQL_FETCH_NEXT						with: 0]				ifTrue: [xif SQLFetch: self hstmt].	traceLevel &gt;= 3 		ifTrue: 			[blockFactor &gt; 1 				ifTrue: 					[(self traceStream)						print: rc;						nextPutAll: ' = SQLFetchScroll( hstmt=';						nextPutAll: (self hstmt printStringRadix: 16);						nextPutAll: ', rows_read=';						print: p contents;						nextPutAll: ' )']				ifFalse: 					[(self traceStream)						print: rc;						nextPutAll: ' = SQLFetch( hstmt=';						nextPutAll: (self hstmt printStringRadix: 16);						nextPutAll: ' )'].			self class trace: self emitTrace].	rc == xif SQL_NO_DATA_FOUND 		ifTrue: 			[rowsInBlock := 0.			^nil].	"workaround DB2 v7 client bug"	blockFactor = 1 		ifTrue: [rowsInBlock := 1]		ifFalse: [rowsInBlock := p contents].	(rc == xif SQL_SUCCESS or: [rc == xif SQL_SUCCESS_WITH_INFO]) 		ifFalse: 			[| errs |			errs := self getStatementErrors.			self class connectionClass unableToFetchDataSignal raiseWith: errs				errorString: errs first dbmsErrorString].	totalRows := totalRows + rowsInBlock</body><body package="DB2EXDI">getBlockOfRowsExternal: fetchOrientation offset: fetchOffset	"Fetch the next block of rows into the memory allocated for this purpose."	| xif rc p newFetchMode newOffset rowNumberBeforeFetch |	xif := self class xif.	"workaround for DB2 v7 client bug"	pRowsFetchedHolder value isNil ifTrue: [self allocateFetchedPointer].	(p := pRowsFetchedHolder value) contents: 0.	fetchOrientation == self fetchPriorMode ifTrue: [ 		rowNumberBeforeFetch := [ self rowNumber ] 							on: self connection class externalDatabaseErrorSignal 							do: [:ex| (ex parameter at: 1) sqlState = '24000' ifTrue: [0] ifFalse: [ ex pass ]].		newFetchMode := self fetchRelativeMode.		newOffset := 0 - self blockFactor.	] ifFalse: [		fetchOrientation == self fetchRelativeMode ifTrue: [			newFetchMode := fetchOrientation.			self currentRowIndex: (self currentRowIndex - fetchOffset).			newOffset := fetchOffset + self currentRowIndex - 1.		] ifFalse: [			newFetchMode := fetchOrientation.			newOffset := fetchOffset.		].	].	rc := xif	SQLFetchScroll: self hstmt			with: newFetchMode			with: newOffset.	traceLevel &gt;= 3 		ifTrue: [				(self traceStream)						print: rc;						nextPutAll: ' = SQLFetchScroll( hstmt=';						nextPutAll: (self hstmt printStringRadix: 16);						nextPutAll: ', fetchOrientation='; print: newFetchMode;						nextPutAll: ', fetchOffset='; print: fetchOffset;						nextPutAll: ' )'.			self class trace: self emitTrace		].	rc == xif SQL_NO_DATA_FOUND 		ifTrue: 			[rowsInBlock := 0.			^nil].	"workaround DB2 v7 client bug"	blockFactor = 1 		ifTrue: [rowsInBlock := 1]		ifFalse: [rowsInBlock := p contents].	(rc == xif SQL_ERROR or: [rc == xif SQL_SUCCESS_WITH_INFO]) ifTrue: [| errs |			errs := self getStatementErrors.		(rc == xif SQL_SUCCESS_WITH_INFO and: [ errs first sqlState = '01S06' ]) ifTrue: [			self currentRowIndex: (rowNumberBeforeFetch - 1).		] ifFalse: [			self class connectionClass unableToFetchDataSignal raiseWith: errs errorString: errs first dbmsErrorString		]	].	totalRows := totalRows + rowsInBlock</body><body package="DB2EXDI">getColumnDescriptionExternal: aColumn	"Folded into describeAnswerColumns for efficiency."	^self shouldNotImplement</body><body package="DB2EXDI">getFieldExternal: aColumn"Answer the data for the aColumn-th column in the current row."	| buffer |	buffer := (self rowBuffers) at: aColumn.     "If it is a DB2LargeObjectBuffer, then we must retrieve the data now."	buffer isLargeObject ifTrue: [^buffer bindOutputExternal].	^buffer at: ((self currentRowIndex - 1) \\ self blockFactor) + 1</body><body package="DB2EXDI">handleAutoCommit	"The behavior of the EXDI as regards transactions is that each statement executed is a separate 	transaction unless the connection is sent begin."	| conn xif |	conn := self connection.	xif := self class xif.	conn inTransactionMode		ifFalse: 			[ "We have an autocommit if connection wasn't sent begin"			| behavior |			behavior := conn getInformationType: #SQL_CURSOR_COMMIT_BEHAVIOR.			behavior == xif SQL_CB_CLOSE ifTrue: [conn cursorsAreClosed]]</body><body package="DB2EXDI">hasAnswerSetExternal	| xif rc pccol |	xif := self class xif.	self numColumns: 0.	"default to none"		["Begin unwind protection."	pccol := xif SQLSMALLINT perform: xif mallocSelector with: 1.	rc := xif SQLNumResultCols: self hstmt with: pccol.	traceLevel &gt;= 3 		ifTrue: 			[(self traceStream)				print: rc;				nextPutAll: ' = SQLNumResultCols( hstmt=';				nextPutAll: (self hstmt printStringRadix: 16);				nextPutAll: ', *pccol =';				print: pccol contents;				nextPutAll: ' )'.			self class trace: self emitTrace].	rc == xif SQL_SUCCESS 		ifFalse: 			[| errs |			errs := self getStatementErrors.			^self class connectionClass unableToFetchDataSignal raiseWith: errs				errorString: errs first dbmsErrorString].	self numColumns: pccol contents	"End unwind protection."] 			ensure: [pccol notNil ifTrue: [pccol freePointer]].	self numColumns &gt; 0 ifTrue: [^true].	"Simulate auto-commit transaction behavior?"	self handleAutoCommit.	^false</body><body package="DB2EXDI">releaseBuffers	"Release buffers and their associated resources."	| rbs |	(rbs := self rowBuffers) notNil ifTrue:	[self hstmt isNil ifFalse: [ self freeStatementExternal: #SQL_UNBIND ].  "may be remove, in ODBCEXDI never send :) "		1 to: rbs size do: [ :i | (rbs at: i) free ] ].	super releaseBuffers</body><body package="DB2EXDI">updateFileRefs	self rowBuffers do: [:buf | (buf isFileRefObject ) ifTrue: [ buf updateFileRefInfo]]</body></methods><methods><class-id>Database.DB2Session</class-id> <category>data processing</category><body package="DB2EXDI">answerLOBAsFileRef: anArrayOfFileRefs	answerBlob := anArrayOfFileRefs</body><body package="DB2EXDI">answerLOBAsLocators	answerBlob := false</body><body package="DB2EXDI">answerLOBAsValues	answerBlob := true</body><body package="DB2EXDI">answerLOBValues	^answerBlob == true</body><body package="DB2EXDI">answerLocators	^answerBlob == false</body><body package="DB2EXDI">bindInputArray: anArray	"Transform 'row-wise' array to 'column-wise' presentation"	| columns new columnSize t | 	columnSize := anArray size.		anArray first class isVariable 		ifTrue: [	columns := anArray first size.				new := Array new: columns.				1 to: columns do: [:i | new at: i put: (t:=Array new: columnSize).					1 to: columnSize do: [:x | t at: x put: ((anArray at: x) at: i)]]]		ifFalse: [columns := anArray first class instSize.				new := Array new: columns.				1 to: columns do: [:i | new at: i put: (t:=Array new: columnSize).					1 to: columnSize do: [:x | t at: x put: ((anArray at: x) instVarAt: i)]]].	self bindInputArrayByColumns: new.</body><body package="DB2EXDI">bindInputArrayByColumns: anArray	"check size"	anArray inject: anArray first size into: [:last :x| last ~= x size 		ifTrue: [self connection class unableToBindSignal raise] ifFalse: [last]].	paramSetSize:= anArray first size.		bindInput:=anArray</body><body package="DB2EXDI">bindVariable: name	"Answer the value of a bind variable."	| buffer |	buffer := self bindValuePointers at: name ifAbsent: [ nil ].	buffer isNil ifTrue: [ self error:  'unbound variable' ].	^buffer value</body><body package="DB2EXDI">bindVariable: name value: value	"Set the value of a bind variable."	self bindVariable: name value: value kind: #in</body><body package="DB2EXDI">bindVariable: name value: aValue kind: kind	"Set the value of a bind variable."	| buffer paramType pos |	pos := name isInteger ifTrue: [ name] ifFalse: [(queryFragments indexOf: name ifAbsent: [self connection class unableToBindSignal ] ) // 2 ].	paramType := (kind == #in) ifTrue: [#SQL_PARAM_INPUT] 		ifFalse: [kind == #out ifTrue: [ #SQL_PARAM_OUTPUT] 			ifFalse: [#SQL_PARAM_INPUT_OUTPUT]].	buffer := self bindValuePointers at: name ifAbsent: [ nil ].	buffer notNil ifTrue: [ [buffer value: aValue] 		on: self connection class unableToBindSignal 		do: [:ex | self bindValuePointers removeKey: name.			buffer free.			buffer := nil.			ex return]]. 	buffer isNil ifTrue: [			buffer := self class bufferClass on: aValue position: pos session: self "type: type size: nil".			buffer bindFor: paramType. 			self bindValuePointers at: name put: buffer].	^self</body><body package="DB2EXDI">closeCursor"Really cursor closing"	self freeStatementExternal: #SQL_CLOSE.	self mustCloseCursor: false.	"self immediateCursorClosing."  "don't change defered/immediate closing behavior"	self handleAutoCommit</body><body package="DB2EXDI">cursorName	"Answer the cursor name associated with receiver."	| xif szCursor pcbCursor rc cursorName cbCursorMax bytesPerChar |	xif := self class xif.	self hstmt isNil ifTrue: [^nil].		["Begin unwind protection."	bytesPerChar := self connection bytesPerCharacter.	cbCursorMax := self connection 				getInformationType: #SQL_MAX_CURSOR_NAME_LEN.	szCursor := xif SQLCHAR perform: xif mallocSelector with: cbCursorMax*bytesPerChar.	pcbCursor := xif SQLINTEGER perform: xif mallocSelector with: 1.	self connection isUnicodeEncoding ifTrue: [		rc := xif SQLGetCursorNameW: self hstmt				with: szCursor				with: cbCursorMax				with: pcbCursor.	] ifFalse: [		rc := xif SQLGetCursorName: self hstmt				with: szCursor				with: cbCursorMax				with: pcbCursor.	].	traceLevel &gt;= 2 		ifTrue: 			[(self traceStream)				print: rc;				nextPutAll: ' = SQLGetCursorName( hstmt = ';				nextPutAll: (self hstmt printStringRadix: 16);				nextPutAll: ', szCursor = ';				print: szCursor copyCStringFromHeap;				nextPutAll: ', cbCursorMax = ';				print: cbCursorMax;				nextPutAll: ', *pcbCursor = ';				print: pcbCursor contents;				nextPutAll: ' )'.			self class trace: self emitTrace].	rc == xif SQL_SUCCESS 		ifFalse: 			[| errs |			errs := self getStatementErrors.			(rc == xif SQL_ERROR and: [errs first sqlState = 'S1015']) ifTrue: [^nil].			^self class connectionClass externalDatabaseErrorSignal raiseWith: errs				errorString: errs first dbmsErrorString].	cursorName := szCursor copyCStringFromHeap	"End unwind protection"] 			ensure: 				[szCursor notNil ifTrue: [szCursor freePointer].				pcbCursor notNil ifTrue: [pcbCursor freePointer]].	^cursorName</body><body package="DB2EXDI">cursorName: aString	"Sets the cursor name associated with receiver."	| xif rc |	xif := self class xif.	((self hstmt isNil or: [ aString isString not ]) or: [ aString size &lt;= 0 ]) ifTrue: [^nil].	self connection isUnicodeEncoding ifTrue: [		rc := xif SQLSetCursorNameW: self hstmt				with: aString				with: aString size.	] ifFalse: [		rc := xif SQLSetCursorName: self hstmt				with: aString				with: aString size.	].	traceLevel &gt;= 2 		ifTrue: 			[(self traceStream)				print: rc;				nextPutAll: ' = SQLSetCursorName( hstmt = ';				nextPutAll: (self hstmt printStringRadix: 16);				nextPutAll: ', szCursor = ';				print: aString;				nextPutAll: ', cbCursor = ';				print: aString size;				nextPutAll: ' )'.			self class trace: self emitTrace].	rc == xif SQL_SUCCESS 		ifFalse: 			[| errs |			errs := self getStatementErrors.			(rc == xif SQL_ERROR and: [errs first sqlState = 'S1015']) ifTrue: [^nil].			^self class connectionClass externalDatabaseErrorSignal raiseWith: errs				errorString: errs first dbmsErrorString].</body><body package="DB2EXDI">deferCursorClosing	deferCursorClosing:=true</body><body package="DB2EXDI">deleteAtCursorPosition: anInteger	| rc xif |	xif := self class xif.	rc := xif SQL_DELETE_RECORD: self hstmt with: anInteger.	rc == xif SQL_SUCCESS 		ifFalse: 			[| errs |			errs := self getStatementErrors.			errs isEmpty ifTrue: [^self].			"errs first sqlState =  '40003' ifTrue: [^self]."			self class connectionClass invalidSessionStateSignal raiseWith: errs				errorString: errs first dbmsErrorString]</body><body package="DB2EXDI">getDataChunkSize	"Answer the data transfer size for LOB columns."	^self class xif getDataChunkSize</body><body package="DB2EXDI">immediateCursorClosing	deferCursorClosing:=false</body><body package="DB2EXDI">prepare: aString	queryIsCALL := false.	super prepare: aString</body><body package="DB2EXDI">prepareCall: aString	queryIsCALL := true.	super prepare: aString</body><body package="DB2EXDI">rowCount	"Answer an Integer representing the number of rows affected by the previous query.	Valid only after the query has been answered."	| xif pcrow rc rowCount |	xif := self class xif.	self hstmt isNil ifTrue: [^nil].		["Begin unwind protection."	pcrow := xif SQLINTEGER perform: xif mallocSelector with: 1.	pcrow contents: 0.	rc := xif SQLRowCount: self hstmt with: pcrow.	rowCount := pcrow contents.	traceLevel &gt;= 2 		ifTrue: 			[(self traceStream)				print: rc;				nextPutAll: ' = SQLRowCount( hstmt = ';				nextPutAll: (self hstmt printStringRadix: 16);				nextPutAll: ', pcrow = ';				nextPutAll: (pcrow referentAddress printStringRadix: 16);				nextPutAll: ') = ';				print: rowCount;				nextPutAll: ' )'.			self class trace: self emitTrace].	rc == xif SQL_SUCCESS 		ifFalse: 			[| errs |			errs := self getStatementErrors.			^self class connectionClass externalDatabaseErrorSignal raiseWith: errs				errorString: errs first dbmsErrorString]	"End unwind protection."] 			ensure: [pcrow notNil ifTrue: [pcrow freePointer]].	^rowCount</body><body package="DB2EXDI">setCursorPositionTo: anInteger	| rc xif |	xif := self class xif.	rc := xif SQL_POSITION_TO: self hstmt with: anInteger.	rc == xif SQL_SUCCESS 		ifFalse: 			[| errs |			errs := self getStatementErrors.			errs isEmpty ifTrue: [^self].			"errs first sqlState =  '40003' ifTrue: [^self]."			self class connectionClass invalidSessionStateSignal raiseWith: errs				errorString: errs first dbmsErrorString]</body><body package="DB2EXDI">setDataChunkSize: anInteger	"Specify the data transfer size for BLOB or CLOB columns."	self class xif setDataChunkSize: anInteger.</body><body package="DB2EXDI">updateAtCursorPosition: anInteger	| rc xif |	xif := self class xif.	rc := xif SQL_UPDATE_RECORD: self hstmt with: anInteger.	rc == xif SQL_SUCCESS 		ifFalse: 			[| errs |			errs := self getStatementErrors.			errs isEmpty ifTrue: [^self].			"errs first sqlState =  '40003' ifTrue: [^self]."			self class connectionClass invalidSessionStateSignal raiseWith: errs				errorString: errs first dbmsErrorString]</body></methods><methods><class-id>Database.DB2Session</class-id> <category>private-binding</category><body package="DB2EXDI">bindExecutionParameters	"Retrieve data-at-execution parameters and send them to the server."	| rc xif prgbValue lobBuffers lobCount nonArray |	xif := self class xif.	lobBuffers := self bindValuePointers values select: [ :each| each isKindOf: DB2LargeObjectBuffer ].	lobCount := (lobBuffers at: 1) count.	lobCount =0 ifTrue: [ 		lobCount := 1.		nonArray := true	] ifFalse: [		nonArray := false	].	["Begin unwind protection"		prgbValue := xif PSDWORD perform: xif mallocSelector with: 1.		rc := xif SQLParamData: self hstmt with: prgbValue.		1 to: lobCount do: [ :index|			1 to: lobBuffers size do: [ :index1| | aValue |				nonArray ifTrue: [					aValue := (lobBuffers at: index1) value				] ifFalse: [					aValue := (lobBuffers at: index1) value at: index				].				aValue isNil ifFalse: [					(lobBuffers at: index1) putLobValue: aValue.					rc := xif SQLParamData: self hstmt with: prgbValue.				]			]		]	"End unwind protection"] ensure: [ prgbValue notNil ifTrue:[ prgbValue freePointer]]</body><body package="DB2EXDI">bindExternal	queryIsCALL		ifTrue:  [	self bindSPCall ]		ifFalse: [ self bindValuesExternal ]</body><body package="DB2EXDI">bindInput: aBindObject 	"Supply aBindObject as the object from which input values should be 	obtained for host variable references in the SQL text.  Host variables	may be specified using either a positional or a named notation.  The	driver may limit to only one form.	When using the positional form (a ?), all host variable references (including	the named ones) are implicitly ordered by their position in the SQL-text.	The n-th variable of aBindObject is used for the n-th host variable reference.	If aBindObject has both instance variables and indexed variables, only the	indexed variables will be used. 	When using the named form, the leading colon is removed and the name is	expected to be an accessing method on aBindObject (i.e. aBindObject is sent	perform: with the name converted to a symbol as the argument)."	(aBindObject isKindOf: Array) ifTrue: [		super bindInput: (self validateBindInput: aBindObject)	] ifFalse: [		super bindInput: aBindObject.	]</body><body package="DB2EXDI">bindParamArray"Check and set parameter array size"	| old bvp |	old:=self  sqlStatementAttributeCache at: #SQL_ATTR_PARAMSET_SIZE ifAbsent: [1].	old = (paramSetSize max: 1) ifTrue: [^true] 		ifFalse: [self setStatementAttribute: #SQL_ATTR_PARAMSET_SIZE value: (paramSetSize max: 1).			(old &lt; paramSetSize or: [paramSetSize==0] ) ifTrue: [			(bvp:=self bindValuePointersHolder value) notNil ifTrue: [bvp values do: [:b | b notNil ifTrue: [ b free ] ]].			self bindValuePointers: nil]].</body><body package="DB2EXDI">bindSPCall	"Bind values for a SP CALL query."	| bound position |	position := 0.	bound := IdentitySet new: self bindValuePointers capacity.	2 to: queryFragments size by: 2 do:		[ :index | | bindMarker buffer |		position := position + 1.		bindMarker := queryFragments at: index.		( bound includes: bindMarker ) ifFalse:			[ buffer := self bindValuePointers at: bindMarker ifAbsent: [ nil ].			buffer isNil ifTrue:				[ ^self connection class missingBindVariableSignal raise ].			"buffer bindForInputOutput."			bound add: bindMarker ] ]</body><body package="DB2EXDI">bindValue: aValue at: position	"Bind a value to a parameter position in the query"	| buffer val |	val := (aValue isKindOf: Stream) ifTrue: [aValue contents] ifFalse: [aValue].	(aValue class == Array and: [aValue first isKindOf: Stream ]) ifTrue: [val := aValue collect: [:x | x contents]].	buffer := self bindValuePointers at: position ifAbsent: [ nil ].	buffer notNil ifTrue:  [ 		[buffer value: val ] 			on: self connection class unableToBindSignal 			do: 	[ :ex | self bindValuePointers removeKey: position.				buffer free.				buffer := nil.				ex return ]].	buffer isNil 		ifTrue: [	buffer := self class bufferClass on: val position: position session: self "type: type size: nil".				buffer bindForInput.				self bindValuePointers at: position put: buffer].	^self</body><body package="DB2EXDI">bindValuePointers	"Answer with the receiver's dictionary of bound rgbValue pointers (input parameters)."	| t |	(t:=bindValuePointersHolder value) isNil ifTrue:		[ bindValuePointersHolder value: (t:=IdentityDictionary new) ].	^t</body><body package="DB2EXDI">bindValuePointers: aDictionary	bindValuePointersHolder value: aDictionary.</body><body package="DB2EXDI">bindValuePointersHolder	^bindValuePointersHolder</body><body package="DB2EXDI">bindValuePointersHolder: aValueModel	bindValuePointersHolder:= aValueModel</body><body package="DB2EXDI">bindValuesExternal	"Bind values to parameters in the query, avoiding unnecessary rebinding 	where possible."	"For each bind marker in the query fragments, get the corresponding 	value from the bindInput 	object. If the value isn't already bound, 	bind and remember it."	| leftToRightOrder |	self bindParamArray.	leftToRightOrder := 0.	2 to: queryFragments size by: 2 do:		[ :index | | bindMarker value |		bindMarker := queryFragments at: index.		leftToRightOrder := leftToRightOrder + 1.		value := self inBindInputAt: bindMarker.		self bindValue: value at: leftToRightOrder.		( self boundValueAt: bindMarker is: value )			ifFalse: [ 	self bindValues at: bindMarker put: value. ] ].</body><body package="DB2EXDI">conversionFor: aValue at: aPosition 	| type |	aValue isNil 		ifFalse: 			[aValue class == Array 				ifTrue: 					[(aValue detect: [:v | v notNil] ifNone: [nil]) db2Conversion 						ifNotNil: [:v | ^v]]				ifFalse: [^aValue db2Conversion]].	bindTemplate isNil ifTrue: [^#String].	type := (bindTemplate at: (self bindMarkerAtPosition: aPosition)) ifNil: [#String].	^(type = #UnicodeString) ifTrue: [#String] ifFalse: [type].</body><body package="DB2EXDI">prepareExternal	"Prepare the server to execute a query."	| xif sql sqlBa rc |	self mustCloseCursor ifTrue: [self closeCursor].	xif := self class xif.	"Assemble the query, substituting the correct parameter markers."	queryFragments size == 1 		ifTrue: [sql := queryFragments at: 1]		ifFalse: 			[| sqlStream |			sqlStream := (String new: query size) writeStream.			sqlStream nextPutAll: (queryFragments at: 1).			2 to: queryFragments size				by: 2				do: 					[:index | 					sqlStream						nextPut: $?;						nextPutAll: (queryFragments at: index + 1)].			sql := sqlStream contents].	sqlBa := sql asByteArrayEncoding: self connection encoding.		["Begin unwind protection."		self connection isUnicodeEncoding ifTrue: [			rc := xif SQLPrepareW: self hstmt				with: sqlBa				with: sql size.		] ifFalse: [			rc := xif SQLPrepare: self hstmt				with: sqlBa				with: sqlBa size.		].	traceLevel &gt;= 1 		ifTrue: 			[(self traceStream)				print: rc;				nextPutAll: ' = SQLPrepare( hstmt = ';				nextPutAll: (self hstmt printStringRadix: 16);				nextPutAll: ', szSqlStr = ''';				print: sql asString;				nextPutAll: ''', cbSqlStr = ';				print: sql size;				nextPutAll: ' )'.			self class trace: self emitTrace].	((rc == xif SQL_SUCCESS) or: [ rc == xif SQL_SUCCESS_WITH_INFO ]) 		ifFalse: 			[| errs |			errs := self getStatementErrors.			self class connectionClass unableToPrepareSignal raiseWith: errs				errorString: errs first dbmsErrorString]	"End unwind protection"] 			ifCurtailed: 				[self connection inTransactionMode 					ifFalse: [self connection transactExternal: #SQL_ROLLBACK]]</body><body package="DB2EXDI">releaseBindings	| bvp  bvps  |	"self mustCloseCursor ifTrue: [self closeCursor]."	(bvp:=self bindValuePointersHolder value) notNil ifTrue:		[ self hstmt isNil ifFalse: [ self freeStatementExternal: #SQL_RESET_PARAMS ].		bvps := bvp values.		1 to: bvps size do:			[ :i | | buffer |			(buffer := bvps at: i) notNil ifTrue: [ buffer free ] ].		self bindValuePointers: nil ].	super releaseBindings</body><body package="DB2EXDI">validateBindInput: aBindObject	"Check to see whether anArray contains any Array elements, if yes, make the length of the Arrays the same by filling nils."	| includedArrays |	includedArrays := aBindObject select: [ :each | each isKindOf: Array ].	includedArrays isEmpty ifTrue: [		^aBindObject	] ifFalse: [ | maxBindSize |		maxBindSize := includedArrays inject: 0 into:	[ :currentMax :nextValue | currentMax max: nextValue size ].		(aBindObject size = includedArrays size and: [	(aBindObject detect: [ :each | (each size ~= maxBindSize) ] ifNone: [ nil ]) isNil ]) ifTrue: [				^aBindObject		] ifFalse: [ | newBindObject | 			newBindObject := Array new: aBindObject size.			1 to: aBindObject size do: [ :index | | each |				each := aBindObject at: index.				(each isKindOf: Array) ifTrue: [					each size = maxBindSize ifTrue: [						newBindObject at: index put: each					] ifFalse: [ | newElement |						newElement := Array new: maxBindSize withAll: nil.						1 to: each size do: [ :index1|							newElement at: index1 put: (each at: index1)						].						newBindObject at: index put: newElement					]				] ifFalse: [  | newElement |					newElement := Array new: maxBindSize withAll: nil.					newElement at: 1 put: each.					newBindObject at: index put: newElement				]			].			^newBindObject		]	]</body></methods><methods><class-id>Database.DB2Session</class-id> <category>private-ObjectLens</category><body package="DB2EXDI">bindInput: object template: template to: bindStream	"Recursively flatten a template onto a bindStream"	| class |	( template isInteger ) ifTrue: [ ^bindStream nextPut: object ].	class := template class.	( class == Object ) ifTrue: [ ^self ].	( class == Float	or: [ class == Double	or: [ class == FixedPoint	or: [ class == Timestamp	or: [class == Date	or: [class == Time	or: [class == ByteFieldDescriptor	or: [class == DB2DataLink	or: [class == DB2CLOBLocator	or: [class == DB2BLOBLocator	or: [ object == true	or: [ object == false	or: [ object == nil	or: [ (object isKindOf: CharacterArray)	or: [ object isKindOf: ByteArray ] ] ] ] ] ] ] ] ] ] ] ] ] ]) ifTrue:		[ ^bindStream nextPut: object ].	"turn symbols into strings"	"(object isKindOf: ByteSymbol) ifTrue:		[ ^bindStream nextPut: object asString ]."	( ( template isKindOf: Array ) or: [ template isKindOf: OrderedCollection ] )		ifTrue:	[ 1 to: (object size) do:					[ : index |					self bindInput: (object at: index)						template: (template at: index)						to: bindStream ] ]		ifFalse:	[ "All others are treated as instances"				1 to: (object class instSize) do:					[ : index |					self bindInput: (object instVarAt: index)						template: (template instVarAt: index)						to: bindStream ] ].</body><body package="DB2EXDI">flattenResultTemplate: template onto: descStream	"Recursively flatten an ObjectLens result template."	| class desc |	class := template class.	"Instances of object in the template denote slots to ignore."	( class == Object ) ifTrue: [ ^self ].		( template isInteger ) ifTrue:		[(desc := DB2ColumnDescription new)			type: template db2Conversion;			fSqlType: (DB2CLIInterface  fSqlTypeFromConversionMap at: template db2Conversion );			maxColumnConstraint: 4.		^descStream nextPut: desc ].	class == Float  ifTrue:		[ (desc := DB2ColumnDescription new)			type: #Float;			fSqlType: (DB2CLIInterface  fSqlTypeFromConversionMap at: #Float);			maxColumnConstraint: 4.		^descStream nextPut: desc ].	class == Double ifTrue:		[ (desc := DB2ColumnDescription new)			type: #Double;			fSqlType: (DB2CLIInterface  fSqlTypeFromConversionMap at: #Double);			maxColumnConstraint: 8.		^descStream nextPut: desc ].	 (class == DB2BLOBLocator or: [class == DB2CLOBLocator ]) ifTrue:		[ (desc := DB2ColumnDescription new)			type: template db2Conversion ;			fSqlType: (DB2CLIInterface  fSqlTypeFromConversionMap at: template db2Conversion);			maxColumnConstraint: 4.		^descStream nextPut: desc ].	 (class == DB2DataLink) ifTrue:		[ (desc := DB2ColumnDescription new)			type: template db2Conversion ;			fSqlType: (DB2CLIInterface  fSqlTypeFromConversionMap at: template db2Conversion);			maxColumnConstraint: 254.		^descStream nextPut: desc ].	 (class == DB2LOBFileReference) ifTrue:		[ (desc := DB2ColumnDescription new)			type: template db2Conversion ;			fileRef: template.		^descStream nextPut: desc ].	class == FixedPoint ifTrue:		[ (desc := DB2ColumnDescription new)			type: #FixedPoint;			fSqlType: (DB2CLIInterface  fSqlTypeFromConversionMap at: #FixedPoint);			maxColumnConstraint: 34;			precision: 34.		^descStream nextPut: desc ].	( class == Timestamp ) ifTrue:		[ (desc := DB2ColumnDescription new)			type: #Timestamp;			fSqlType: (DB2CLIInterface  fSqlTypeFromConversionMap at: #Timestamp);			maxColumnConstraint: 16.		^descStream nextPut: desc ].	( class == Date ) ifTrue:		[ (desc := DB2ColumnDescription new)			type: #Date;			fSqlType: (DB2CLIInterface  fSqlTypeFromConversionMap at: #Date);			maxColumnConstraint: 6.		^descStream nextPut: desc ].	( class == Time ) ifTrue:		[ (desc := DB2ColumnDescription new)			type: #Time;			fSqlType: (DB2CLIInterface  fSqlTypeFromConversionMap at: #Time);			maxColumnConstraint: 6.		^descStream nextPut: desc ].	( class == ByteFieldDescriptor ) ifTrue:		[ | temp |		(desc := DB2ColumnDescription new)			maxColumnConstraint: template MaxColumnConstraint;			precision: template MaxColumnConstraint.		temp := template Template.		desc type: temp db2Conversion.		desc fSqlType: (DB2CLIInterface  fSqlTypeFromConversionMap at: temp db2Conversion).		^descStream nextPut: desc ].	( template isString ) ifTrue:		[ (desc := DB2ColumnDescription new)			type: #String;			fSqlType: (DB2CLIInterface  fSqlTypeFromConversionMap at: #String);			precision: ((DB2Buffer.ValuePrecisionBlocks at: #String) value: template);			maxColumnConstraint: ((DB2Buffer.ValueSizeBlocks at: #String) value: template).		^descStream nextPut: desc ].	"Decompose Arrays and Collections."	( ( template isKindOf: Array ) or: [ template isKindOf: OrderedCollection ] ) ifTrue:		[ 1 to: template size do:			[ :index |			self flattenResultTemplate: (template at: index) onto: descStream ].		^self ].	"All others are treated as instances of some entity"	1 to: template class instSize do:		[ :index |		self flattenResultTemplate: (template instVarAt: index) onto: descStream ].</body><body package="DB2EXDI">getColumnsOfTable: aTableName owner: anOwner 	| answer |	self class traceLevel &gt;= 1 ifTrue: [self class trace: 'Looking up columns for table "', aTableName, '" ...'].	self getSQLColumns: nil tableOwner: anOwner tableName: aTableName columnName: nil.	answer := OrderedCollection new.	self answer do: [:t | (answer add: Dictionary new) 			add: #table -&gt; (t at: 3);			add: #name -&gt; (t at: 4);			add: #type -&gt; (t at: 5);			add: #nativeType -&gt; (t at: 6);			add: #maxLength -&gt; (t at: 8);			add: #columnSize -&gt; (t at: 7);			add: #scale -&gt; (t at: 9);			add: #nullable -&gt; (t at: 11)].	^answer</body><body package="DB2EXDI">getForeignKeysFor: aTable owner: anOwner	| answer  |	self class traceLevel &gt;= 1 ifTrue: [self class trace: 'Looking up foreign keys  for table "' , anOwner, '.', aTable , '" ...'].	answer := OrderedCollection new.	self getSQLForeignKeys: nil tableOwner: nil tableName: nil  fkQualifier: nil fkOwner: anOwner  fkTableName: aTable.	self answer do: [:x | answer add: x  ].	^answer</body><body package="DB2EXDI">getPrimaryKeysFor: aTableName owner: anOwner	| answer |	self class traceLevel &gt;= 1 ifTrue: [self class trace: 'Looking up columns for table "', aTableName, '" ...'].	answer := OrderedCollection new.	self getSQLPrimaryKeys: nil  tableOwner: anOwner tableName: aTableName. 	self answer do: [:x | answer add: (x at: 4)]. "column name"	^answer</body><body package="DB2EXDI">listTablesLike: aString 	"Answer a collection of tables available in the receiver's database."	| pattern i owner tableType answer |	owner := ''.	((pattern := aString) isNil or: [aString isEmpty])		ifTrue: [pattern := '%']		ifFalse: [(i := pattern indexOf: $.) &gt; 0				ifTrue: 					[owner := pattern copyFrom: 1 to: i - 1.					pattern := pattern copyFrom: i + 1 to: pattern size]].	owner isEmpty ifTrue: [owner := nil].	tableType := aString first == $+ ifTrue: [pattern:=pattern copyWithout: $+. 'SYSTEM TABLE'] ifFalse: ['TABLE,VIEW']. 	answer := OrderedCollection new.	self getSQLTables: nil tableOwner: owner tableName: pattern tableType: tableType.	self answer do: [:t | (answer add: IdentityDictionary new) 			add: #name -&gt; (t at: 3);			add: #owner -&gt; (t at: 2);			add: #tableType -&gt; (t at: 4)]. 	^answer</body><body package="DB2EXDI">nextViaTemplate: template	"Answer the object formed by reifying the template using a fetched row"	| class object |	( template isInteger ) ifTrue:		[ object := self getFieldExternal: bufferIndex.		bufferIndex := bufferIndex + 1.		^object isNil ifTrue: [ nil ] ifFalse: [ object asInteger ] ].	class := template class.	( class == Float ) ifTrue:		[ object := self getFieldExternal: bufferIndex.		bufferIndex := bufferIndex + 1.		^object isNil ifTrue: [ nil ] ifFalse: [ object asFloat ] ].	( class == Double ) ifTrue:		[ object := self getFieldExternal: bufferIndex.		bufferIndex := bufferIndex + 1.		^object isNil ifTrue: [ nil ] ifFalse: [ object asDouble] ].		( class == DB2CLOBLocator or: [class == DB2BLOBLocator or: [class == DB2LOBFileReference]]) ifTrue:		[ object := self getFieldExternal: bufferIndex.		bufferIndex := bufferIndex + 1.		^object isNil ifTrue: [ nil ] ifFalse: [ object ]].	( class == DB2DataLink) ifTrue:		[ object := self getFieldExternal: bufferIndex.		bufferIndex := bufferIndex + 1.		^object isNil ifTrue: [ nil ] ifFalse: [ object ]].	( class == FixedPoint ) ifTrue:		[ object := self getFieldExternal: bufferIndex.		bufferIndex := bufferIndex + 1.		^object isNil			ifTrue: [ nil ]			ifFalse: [ object isInteger						ifTrue: [ object asFixedPoint: 2 ]						ifFalse: [ object ] ] ].	(  class == Timestamp or: [class == Date or: [class == Time or: [ template == true or: [ template == false ] ] ] ]) ifTrue:		[ object := self getFieldExternal: bufferIndex.		bufferIndex := bufferIndex + 1.		^object ].	( class == ByteFieldDescriptor or: [template isString and: [template isSymbol not]] ) ifTrue:		[ object := self getFieldExternal: bufferIndex.		bufferIndex := bufferIndex + 1.		^object ].	( template isKindOf: Collection ) ifTrue:		[ ( template isKindOf: Array )			ifTrue: [ ^self nextViaArrayTemplate: template ]			ifFalse: [ ^self nextViaCollectionTemplate: template ] ].	( class == Object ) ifTrue: [ ^nil ].	^self nextViaEntityTemplate: template</body></methods><methods><class-id>Database.DB2Session</class-id> <category>private-execution</category><body package="DB2EXDI">acquireExternal	"Acquire external resources."	| xif phstmt rc |	xif := self class xif.		["Begin unwind protection."	phstmt := xif SQLHSTMT perform: xif mallocSelector with: 1.	rc := xif 				SQLAllocHandle: xif SQL_HANDLE_STMT				with: self connection hdbc				with: phstmt.	traceLevel &gt;= 3 		ifTrue: 			[(self traceStream)				print: rc;				nextPutAll: ' = SQLAllocStmt( hdbc = ';				nextPutAll: (self connection hdbc printStringRadix: 16);				nextPutAll: ', hstmt = ';				nextPutAll: (phstmt contents printStringRadix: 16);				nextPutAll: ' )'.			self class trace: self emitTrace].	rc == xif SQL_SUCCESS 		ifFalse: 			[| errs |			errs := self connection getConnectionErrors.			self class connectionClass unableToAllocateHandleSignal raiseWith: errs				errorString: errs first dbmsErrorString].	self hstmt: phstmt contents.	self sqlStatementAttributeCache: IdentityDictionary new.	self setStatementAttributeExternal: #SQL_ATTR_CLOSEOPEN value: 1.	"Chain the close and open statements (DB2 v6)"	self scrollable ifTrue: [		self setStatementAttribute: #SQL_ATTR_CURSOR_TYPE value: xif SQL_CURSOR_KEYSET_DRIVEN.	].	"End unwind protection."] 			ensure: [phstmt notNil ifTrue: [phstmt freePointer]]</body><body package="DB2EXDI">cancelExternal	"Handle cleanup when current query is cancelled."	^self</body><body package="DB2EXDI">cursorIsClosed	"Receiver's cursor was closed and can no longer be used to access rows from the previous query.  Prepared statements can be executed without preparing them again."	"If receiver isn't in an executing state, nothing to do."	self isExecuting ifFalse: 	[ ^self ].	"If there is an extant answer stream, it's dead so mark it as such."	answerStream notNil ifTrue:		[ answerStream session: nil.		  answerStream := nil ].	"We're now back in the prepared state and can execute again without preparing."	self state: #prepared.	( traceLevel &gt;= 3 ) ifTrue:		[ (self traceStream)			nextPutAll: 'hstmt = ';			nextPutAll: (self hstmt printStringRadix: 16); cr; tab;			nextPutAll: 'self mustResendQuery: false. self state: #prepared'.		self class trace: self emitTrace ]</body><body package="DB2EXDI">cursorIsDeleted	"Receiver's cursor was deleted and can no longer be used to access rows from the previous query.  Any prepared statements must be prepared again.  Parameters and bound buffers are still valid."	"If receiver isn't in an executing state, nothing to do."	self isExecuting ifFalse:	[ ^self ].	"If there is an extant answer stream, it's dead so mark it as such."	answerStream notNil ifTrue:		[ answerStream session: nil.		  answerStream := nil ].	"The SQL text must be sent to the server again."	self mustResendQuery: true.	self mustCloseCursor: false.	"We're now back in the prepared state and can execute again without preparing."	self state: #prepared.	( traceLevel &gt;= 3 ) ifTrue:		[ (self traceStream)			nextPutAll: 'hstmt = ';			nextPutAll: (self hstmt printStringRadix: 16); cr; tab;			nextPutAll: 'self mustResendQuery: true. self state: #prepared'.		self class trace: self emitTrace ]</body><body package="DB2EXDI">dismissExternal	pRowsFetchedHolder value == nil ifFalse: [pRowsFetchedHolder value freePointer. pRowsFetchedHolder value:  nil ].	self rowStatus isNil ifFalse: [rowStatus freePointer. self rowStatus: nil ].	self freeStatementExternal: #SQL_DROP.	self hstmt: nil</body><body package="DB2EXDI">executeExternal	"Execute the prepared SQL text."	| xif rc |	xif := self class xif.	"Does the query text need to be sent to the server again?"	self mustResendQuery ifTrue:		[ self prepareExternal.		  self mustResendQuery: false ].	rc := xif SQLExecute: self hstmt.	( traceLevel &gt;= 1 ) ifTrue:		[ (self traceStream)			print: rc;  nextPutAll: ' = SQLExecute( hstmt = ';			nextPutAll: (self hstmt printStringRadix: 16);			nextPutAll: ' )'.		self class trace: self emitTrace ].	(rc == xif SQL_ERROR)	ifTrue: [self resultsCache: self getStatementErrors ].	"Are there any data-at-execution parameters to bind?"	(rc == xif SQL_NEED_DATA) ifTrue: [ self bindExecutionParameters ]</body><body package="DB2EXDI">freeStatementExternal: releaseOption 	"Release resources associated with a session."	| xif rc |	self hstmt isNil ifTrue: [^self].	xif := self class xif.	rc := xif SQLFreeStmt: self hstmt with: (xif perform: releaseOption).	traceLevel &gt;= 3 		ifTrue: 			[(self traceStream)				print: rc;				nextPutAll: ' = SQLFreeStmt( hstmt = ';				nextPutAll: (self hstmt printStringRadix: 16);				nextPutAll: ', ';				print: releaseOption;				nextPutAll: ')'.			self class trace: self emitTrace].	rc == xif SQL_SUCCESS 		ifFalse: 			[| errs |			errs := self getStatementErrors.			errs isEmpty ifTrue: [^self].			"errs first sqlState =  '40003' ifTrue: [^self]."			self class connectionClass unableToFreeResourceSignal raiseWith: errs				errorString: errs first dbmsErrorString]</body><body package="DB2EXDI">getParameterIndexExternal		"Retrieve index of data-at-execution parameter."	| xif rc prgbValue rgbValue paramIndex |	xif := self class xif.    	["Begin unwind protection"		prgbValue := xif PSDWORD perform: xif mallocSelector with: 1.		rc := xif SQLParamData: self hstmt with: prgbValue.		(traceLevel &gt;= 3) ifTrue:			[ (self traceStream)			print: rc;  nextPutAll: ' = SQLParamData( hstmt = ';			nextPutAll: (self hstmt printStringRadix: 16);			nextPutAll: ',  prgbValue= ';			nextPutAll: (prgbValue  referentAddress printStringRadix: 16);			nextPutAll: ' )'.			self class trace: self emitTrace ].	 	(rc == xif SQL_ERROR) ifTrue:			[| errs |		 	errs := self getStatementErrors.		 	^self class connectionClass unableToBindSignal raiseWith: errs errorString: errs first dbmsErrorString ].			((rc  ==  xif SQL_SUCCESS) or: [ rc == xif SQL_SUCCESS_WITH_INFO])			ifTrue: [ ^nil ].		(rc  ==  xif SQL_NEED_DATA) ifTrue: 			[ rgbValue :=  prgbValue contents.			paramIndex := rgbValue contents].		^paramIndex	"End unwind protection"] 		ensure: [ prgbValue notNil 									ifTrue:[ prgbValue freePointer]].</body><body package="DB2EXDI">getStatementAttributeExternal: fOptionSymbol 	"Answer the information associated with fInfoTypeSymbol.  This information is defined only after connecting."	| xif rc ub pvParam vParam paramSize |	xif := self class xif.		["Begin unwind protection."	pvParam := xif SQLPOINTER perform: xif mallocSelector with: 1.	self connection isUnicodeEncoding ifTrue: [		rc := xif SQLGetStmtAttrW: self hstmt				with: (xif perform: fOptionSymbol)				with: pvParam				with: 0				with: nil.	"only integer attributes supported"	] ifFalse: [		rc := xif SQLGetStmtAttr: self hstmt				with: (xif perform: fOptionSymbol)				with: pvParam				with: 0				with: nil.	"only integer attributes supported"	].	(rc == xif SQL_SUCCESS or: [rc == xif SQL_SUCCESS_WITH_INFO]) 		ifFalse: 			[| errs |			errs := self getStatementErrors.			^self connection class unableToQueryStatementAttributesSignal 				raiseWith: errs				errorString: errs first dbmsErrorString].	paramSize := ObjectMemory is64Bit ifTrue: [ 8 ] ifFalse: [ 4 ].	ub := UninterpretedBytes new: paramSize.	pvParam copyAt: 0 to: ub size: paramSize startingAt: 1.	vParam := ub 				perform: (SQLStatementAttributeConversionMap at: fOptionSymbol)				with: 1	"End unwind protection."] 			ensure: [pvParam notNil ifTrue: [pvParam freePointer]].	^vParam</body><body package="DB2EXDI">installExternal	super installExternal.	self hstmt: nil.	self mustResendQuery: false.	self mustCloseCursor: false.	self sqlStatementAttributeCache: IdentityDictionary new.	self maxLongData: self class defaultMaxLongData.</body><body package="DB2EXDI">moreResultsExternal	"^false"	| xif rc |	(deferCursorClosing or: [self paramSetSize &gt; 1]) ifFalse: [^false].	"FP2 trouble w/a ?"	xif := self class xif.	rc := xif SQLMoreResults: self hstmt.	traceLevel &gt;= 1 		ifTrue: 			[(self traceStream)				print: rc;				nextPutAll: ' = SQLMoreResults( hstmt = ';				nextPutAll: (self hstmt printStringRadix: 16);				nextPutAll: ' )'.			self class trace: self emitTrace].	(rc == xif SQL_SUCCESS or: [rc == xif SQL_NO_DATA_FOUND]) 		ifFalse: 			[| errs |			errs := self getStatementErrors.			self class connectionClass externalDatabaseErrorSignal raiseWith: errs				errorString: errs first dbmsErrorString].	"Are there any result sets?"	^(rc == xif SQL_NO_DATA_FOUND) not</body><body package="DB2EXDI">readyExternal	^true</body><body package="DB2EXDI">resultsExternal"extracted from ODBCEXDI: proper handling for multiple results"	| errs sqlState |	(errs := self resultsCache) notNil 		ifTrue: 			[1 to: errs size				do: 					[:position | 					((sqlState := (errs at: position) sqlState asSymbol) == #'01000' 						or: [sqlState == #S1000]) 							ifFalse: 								[^self class connectionClass unableToExecuteSQLSignal raiseWith: errs									errorString: (errs at: position) dbmsErrorString]].			self class connectionClass externalDatabaseInformationSignal 				raiseRequestWith: errs].	^true</body><body package="DB2EXDI">setStatementAttributeExternal: fOptionSymbol value: vOption 	"Set the information associated with fInfoTypeSymbol.  This information is defined only after connecting."	| xif rc valuePtr |		["Begin unwind protection."	xif := self class xif.	self connection isUnicodeEncoding ifTrue: [		rc := xif SQLSetStmtAttrW: self hstmt				with: (xif perform: fOptionSymbol)				with: (vOption isString 						ifTrue: [valuePtr := vOption copyToHeap]						ifFalse: [vOption])				with: (vOption isString ifTrue: [vOption size] ifFalse: [0]).	] ifFalse: [		rc := xif SQLSetStmtAttr: self hstmt				with: (xif perform: fOptionSymbol)				with: (vOption isString 						ifTrue: [valuePtr := vOption copyToHeap]						ifFalse: [vOption])				with: (vOption isString ifTrue: [vOption size] ifFalse: [0]).	].	(rc == xif SQL_SUCCESS or: [rc == xif SQL_SUCCESS_WITH_INFO]) 		ifFalse: 			[| errs |			errs := self getStatementErrors.			^self class connectionClass externalDatabaseErrorSignal raiseWith: errs				errorString: errs first dbmsErrorString]] 			ensure: [valuePtr notNil ifTrue: [valuePtr freePointer]].	^vOption</body></methods><methods><class-id>Database.DB2Session</class-id> <category>private-accessing</category><body package="DB2EXDI">currentRowIndex	^currentRowIndex</body><body package="DB2EXDI">currentRowIndex: aValue	currentRowIndex := aValue</body><body package="DB2EXDI">fetchAbsoluteMode	^self class xif SQL_FETCH_ABSOLUTE</body><body package="DB2EXDI">fetchNextMode	^self class xif SQL_FETCH_NEXT</body><body package="DB2EXDI">fetchPriorMode	^self class xif SQL_FETCH_PRIOR</body><body package="DB2EXDI">fetchRelativeMode	^self class xif SQL_FETCH_RELATIVE</body><body package="DB2EXDI">getStatementAttribute: fOptionTypeSymbol	| ssoc |	^(ssoc := self  sqlStatementAttributeCache) at: fOptionTypeSymbol ifAbsent:		[ | vOption |		vOption := self getStatementAttributeExternal: fOptionTypeSymbol.		ssoc at: fOptionTypeSymbol put: vOption.		vOption ].</body><body package="DB2EXDI">getStatementErrors	"Return a collection of DB2Error(s) associated with the statement handle."	| xif errors err num | 	xif := self class xif.	errors := OrderedCollection new.	num:=0.	[ (err := self connection getErrorsExternal: xif SQL_HANDLE_STMT				handle: self hstmt				recNumber: (num:=num+1)) notNil ]		whileTrue: [ errors add: err ].	^errors</body><body package="DB2EXDI">hstmt	^hstmtHolder value</body><body package="DB2EXDI">hstmt: aCPointerOrNil	hstmtHolder value: aCPointerOrNil</body><body package="DB2EXDI">hstmtHolder	^hstmtHolder</body><body package="DB2EXDI">hstmtHolder: aValueHolder	hstmtHolder := aValueHolder</body><body package="DB2EXDI">mustCloseCursor	^self mustCloseCursorHolder value</body><body package="DB2EXDI">mustCloseCursor: aBoolean	self mustCloseCursorHolder value: aBoolean</body><body package="DB2EXDI">mustCloseCursorHolder	^mustCloseCursorHolder</body><body package="DB2EXDI">mustCloseCursorHolder: aValueHolder	mustCloseCursorHolder:= aValueHolder</body><body package="DB2EXDI">mustResendQuery	^self mustResendQueryHolder value</body><body package="DB2EXDI">mustResendQuery: aBoolean	self mustResendQueryHolder value: aBoolean</body><body package="DB2EXDI">mustResendQueryHolder	^mustResendQueryHolder</body><body package="DB2EXDI">mustResendQueryHolder: aValueHolder	mustResendQueryHolder := aValueHolder</body><body package="DB2EXDI">pRowsFetched	^pRowsFetchedHolder value</body><body package="DB2EXDI">pRowsFetched: aPointer	pRowsFetchedHolder value: aPointer</body><body package="DB2EXDI">pRowsFetchedHolder	^pRowsFetchedHolder</body><body package="DB2EXDI">pRowsFetchedHolder: aHolder	pRowsFetchedHolder := aHolder</body><body package="DB2EXDI">paramSetSize	^paramSetSize</body><body package="DB2EXDI">resultsCache	"Answer the contents of the result cache.  Clear the cache."	| results |	results := resultsCache.	resultsCache := nil.	^results</body><body package="DB2EXDI">resultsCache: results	"Cache results."	resultsCache := results</body><body package="DB2EXDI">rowNumber	^self getStatementAttributeExternal: #SQL_ATTR_ROW_NUMBER.</body><body package="DB2EXDI">rowStatus	^rowStatus</body><body package="DB2EXDI">rowStatus: aPointer	rowStatus := aPointer</body><body package="DB2EXDI">rowsInBlock	^rowsInBlock</body><body package="DB2EXDI">rowsInBlock: aValue	rowsInBlock := aValue</body><body package="DB2EXDI">setStatementAttribute: fOptionTypeSymbol value: vOption	self setStatementAttributeExternal: fOptionTypeSymbol value: vOption.	"don't save pointer's in cache"	vOption class == CPointer ifFalse: [		self sqlStatementAttributeCache at: fOptionTypeSymbol put: vOption].	^vOption</body><body package="DB2EXDI">sqlStatementAttributeCache	^sqlStatementAttributeCache</body><body package="DB2EXDI">sqlStatementAttributeCache: anIdentityDictionary	sqlStatementAttributeCache := anIdentityDictionary</body><body package="DB2EXDI">state: aSymbol	super state: aSymbol.	"traceLevel &gt; 1 ifTrue: [Transcript nextPutAll: 'Current State: ';		nextPutAll: aSymbol;		cr; flush]"</body><body package="DB2EXDI">totalRows	^totalRows</body><body package="DB2EXDI">totalRows: aValue	totalRows := aValue</body></methods><methods><class-id>Database.DB2Session</class-id> <category>private-finalization</category><body package="DB2EXDI">executor	"Answer with an executor for the receiver."	| ex |	ex := super executor.	ex hstmtHolder: self hstmtHolder.	"ex mustResendQueryHolder: self mustResendQueryHolder."	ex bindValuePointersHolder: self bindValuePointersHolder.	ex pRowsFetchedHolder: self pRowsFetchedHolder.	ex rowStatus: self rowStatus.	"ex mustCloseCursorHolder: self mustCloseCursorHolder."	^ex</body><body package="DB2EXDI">finalizeExternal	"Release all external resources"	self releaseBuffersAndAdaptors.	self releaseBindings.	(self hstmt isNil ) ifTrue: [ ^self ].	( traceLevel &gt;= 1 ) ifTrue: [ self class trace: nil ].	super finalizeExternal</body><body package="DB2EXDI">key	"The hstmtHolder is unique to the session and is constant across pause/resume."	^self hstmtHolder</body></methods><methods><class-id>Database.DB2Session</class-id> <category>blob-functions</category><body package="DB2EXDI">freeLocator: aLocator"Free LOB locator "	self connection inTransactionMode ifFalse: [^self connection class invalidTransactionStateSignal raise].  	self prepare: 'FREE LOCATOR ?'.	self	bindInput: (Array with: aLocator );		execute;		answer.</body></methods><methods><class-id>Database.DB2Session</class-id> <category>printing</category><body package="DB2EXDI">printOn: aStream	| hstmt |	super printOn: aStream.	(hstmt := self hstmt) isNil  ifFalse:		[ aStream nextPutAll: '( hstmt = ';			nextPutAll: (hstmt printStringRadix: 16);			nextPutAll: ' )' ]</body></methods><methods><class-id>Database.DB2Session</class-id> <category>private-tracing</category><body package="DB2EXDI">traceLevel	^traceLevel</body></methods><methods><class-id>Database.DB2Session</class-id> <category>initialize-release</category><body package="DB2EXDI">initialize	paramSetSize:=0.	bindValuePointersHolder:=nil asValue.	pRowsFetchedHolder:=nil asValue.	hstmtHolder := nil asValue. 	mustResendQueryHolder := false asValue.	mustCloseCursorHolder := false asValue.	deferCursorClosing := false.	sqlStatementAttributeCache := IdentityDictionary new.	self maxLongData: self class defaultMaxLongData.  	answerBlob:=true.	self rowStatus: nil.	super initialize.</body></methods><methods><class-id>Database.DB2Session</class-id> <category>accessing</category><body package="DB2EXDI">bindTemplate	^bindTemplate</body><body package="DB2EXDI">blockFactor: aSmallInteger	"Specify the blocking factor to use when fetching of row data.  This may improve application	performance at the expense of memory. The blocking factor is optional and will be ignored if	the driver does not support fetching multiple rows at a time.	The application still uses next to obtain a single row at a time.  However, the use of	WHERE CURRENT OF may not be allowed as the database system cannot be sure	of which row the application is referring to."	| newBlockFactor |	newBlockFactor := aSmallInteger min: 10000.	(blockFactor isNil or: [newBlockFactor &gt; blockFactor]) 		ifTrue: [self releaseBuffers].	blockFactor := newBlockFactor</body><body package="DB2EXDI">getMaxLongData	"Answer the maximum amount of data to be copied from BLOB or CLOB columns."	^self maxLongData</body><body package="DB2EXDI">maxLongData	^maxLongData</body><body package="DB2EXDI">maxLongData: anInteger	maxLongData := anInteger</body><body package="DB2EXDI">setMaxLongData: anInteger	"Specify the maximum amount of data to be copied from CLOB or BLOB columns."	self maxLongData: anInteger.</body></methods><methods><class-id>Database.DB2Session</class-id> <category>catalog functions</category><body package="DB2EXDI">getSQLColumns: tableQualifier tableOwner: tableOwner tableName: tableName columnName: columnName 	"If supported on the current platform, call the ODBC function SQLColumns to obtain a list of names of tables stored in the current data source.  Sending the message callSQLColumns:tableOwner:tableName:columnName: is equivalent to preparing and executing a query using the receiver.  After the call completes, the table information is obtained as an answer stream in the normal way (i.e. send the message answer and then use the answer stream to fetch the rows).  Each row is an Array with one element for each column.  	The arguments tableQualifier, tableOwner, tableName, and columnName are directly passed to the function and take their definitions from the function definition.From DB2/CLI documentation:Column 1 TABLE_CAT (VARCHAR(128)) Column 2 TABLE_SCHEM (VARCHAR(128)) Column 3 TABLE_NAME (VARCHAR(128) not NULL) Column 4 COLUMN_NAME (VARCHAR(128) not NULL) Column 5 DATA_TYPE (SMALLINT not NULL) Column 6 TYPE_NAME (VARCHAR(128) not NULL) Column 7 COLUMN_SIZE (INTEGER) Column 8 BUFFER_LENGTH (INTEGER) Column 9 DECIMAL_DIGITS (SMALLINT) Column 10 NUM_PREC_RADIX (SMALLINT) Column 11 NULLABLE (SMALLINT not NULL) Column 12 REMARKS (VARCHAR(254)) Column 13 COLUMN_DEF (VARCHAR(254)) Column 14 SQL_DATA_TYPE (SMALLINT not NULL) Column 15 SQL_DATETIME_SUB (SMALLINT) Column 16 CHAR_OCTET_LENGTH (INTEGER) Column 17 ORDINAL_POSITION (INTEGER not NULL) Column 18 IS_NULLABLE (VARCHAR(254)) "	| xif rc |	xif := self class xif.	self startPrepare.	self state: #executing.	self connection isUnicodeEncoding ifTrue: [ | localEncoding copySelector szTableQualfier szTableOwner szTableName szColumnName |		localEncoding := self connection encoding.		copySelector := xif copyToHeapSelector.		szTableQualfier := szTableOwner := szTableName := szColumnName := nil.		[ "Begin unwind protection."			tableQualifier isNil ifFalse: [ szTableQualfier := (tableQualifier asByteArrayEncoding: localEncoding) perform: copySelector ].			tableOwner isNil ifFalse: [ szTableOwner := (tableOwner asByteArrayEncoding: localEncoding) perform: copySelector ].			tableName isNil ifFalse: [ szTableName := (tableName asByteArrayEncoding: localEncoding) perform: copySelector ].			columnName isNil ifFalse: [ szColumnName := (columnName asByteArrayEncoding: localEncoding) perform: copySelector ].			rc := xif SQLColumnsW: self hstmt				with: szTableQualfier with: tableQualifier size				with: szTableOwner with: tableOwner size				with: szTableName with: tableName size				with: szColumnName with: columnName size.		"End unwind protection." ]		ensure:			[ szTableQualfier notNil ifTrue:	[ szTableQualfier freePointer ].			szTableOwner notNil ifTrue:	[ szTableOwner freePointer ].			szTableName notNil ifTrue:	[ szTableName freePointer ].			szColumnName notNil ifTrue:	[ szColumnName freePointer ] ]	] ifFalse: [		rc := xif SQLColumns: self hstmt				with: tableQualifier with: tableQualifier size				with: tableOwner with: tableOwner size				with: tableName with: tableName size				with: columnName with: columnName size.	].	(rc == xif SQL_SUCCESS	or: [rc == xif SQL_SUCCESS_WITH_INFO]) ifFalse:		[ | errs |		errs := self getStatementErrors.		self resultsCache: errs.		self connection class unableToFetchDataSignal raiseWith: errs				errorString: errs first dbmsErrorString]</body><body package="DB2EXDI">getSQLForeignKeys: tableQualifier tableOwner: tableOwner tableName: tableName fkQualifier: fkTableQualifier fkOwner: fkTableOwner fkTableName: fkTableName 	"The arguments tableQualifier, tableOwner, tableName and fkTableQualifier, fkTableOwner, fkTableName are directly passed to the function and take their definitions from the function definition.	If the foreign keys associated with a primary key are requested, the result set is ordered by FKTABLE_CAT, FKTABLE_SCHEM, FKTABLE_NAME, and  ORDINAL_POSITION. If the primary keys associated with a foreign key are requested, the result set is ordered by PKTABLE_CAT, PKTABLE_SCHEM, PKTABLE_NAME,and ORDINAL_POSITION. "	| xif rc |	xif := self class xif.	self startPrepare.	self state: #executing.	self connection isUnicodeEncoding ifTrue: [ | localEncoding copySelector szTableQualfier szTableOwner szTableName szFkTableQualfier szFkTableOwner szFkTableName |		szTableQualfier := szTableOwner := szTableName := szFkTableQualfier := szFkTableOwner := szFkTableName:= nil.		copySelector := xif copyToHeapSelector.		localEncoding := self connection encoding.		[ "Begin unwind protection." 			tableQualifier isNil ifFalse: [ szTableQualfier := (tableQualifier asByteArrayEncoding: localEncoding) perform: copySelector ].			tableOwner isNil ifFalse: [ szTableOwner := (tableOwner asByteArrayEncoding: localEncoding) perform: copySelector ].			tableName isNil ifFalse: [ szTableName := (tableName asByteArrayEncoding: localEncoding) perform: copySelector ].			fkTableQualifier isNil ifFalse: [ szFkTableQualfier := (fkTableQualifier asByteArrayEncoding: localEncoding) perform: copySelector ].			fkTableOwner isNil ifFalse: [ szFkTableOwner := (fkTableOwner asByteArrayEncoding: localEncoding) perform: copySelector ].			fkTableName isNil ifFalse: [ szFkTableName := (fkTableName asByteArrayEncoding: localEncoding) perform: copySelector ].			rc := xif SQLForeignKeysW: self hstmt 			 		with: szTableQualfier			 		with: tableQualifier size			 		with: szTableOwner			 		with: tableOwner size			 		with: szTableName			 		with: tableName size			 		with: szFkTableQualfier			 		with: fkTableQualifier size			 		with: szFkTableOwner			 		with: fkTableOwner size			 		with: szFkTableName			 		with: fkTableName size.		"End unwind protection." ]		ensure: [ 			szTableQualfier notNil ifTrue: [ szTableQualfier freePointer ].			szTableOwner notNil ifTrue: [ szTableOwner freePointer ].			szTableName notNil ifTrue: [ szTableName freePointer ].			szFkTableQualfier notNil ifTrue: [ szFkTableQualfier freePointer ].			szFkTableOwner notNil ifTrue: [ szFkTableOwner freePointer ].			szFkTableName notNil ifTrue: [ szFkTableName freePointer ]		].	] ifFalse: [		rc := xif SQLForeignKeys: self hstmt 			 		with: tableQualifier			 		with: tableQualifier size			 		with: tableOwner			 		with: tableOwner size			 		with: tableName			 		with: tableName size			 		with: fkTableQualifier			 		with: fkTableQualifier size			 		with: fkTableOwner			 		with: fkTableOwner size			 		with: fkTableName			 		with: fkTableName size.	].	(rc == xif SQL_SUCCESS	or: [rc == xif SQL_SUCCESS_WITH_INFO]) ifFalse:		[ | errs |		errs := self getStatementErrors.		self resultsCache: errs.		self connection class unableToFetchDataSignal raiseWith: errs				errorString: errs first dbmsErrorString]</body><body package="DB2EXDI">getSQLPrimaryKeys: tableQualifier tableOwner: tableOwner tableName: tableName 	"The arguments tableQualifier, tableOwner, tableName are directly passed to the function and take their definitions from the function definition.	Answer:	TABLE_CAT (VARCHAR(128))  This is always null. 			TABLE_SCHEM (VARCHAR(128)) 			TABLE_NAME (VARCHAR(128) not NULL) 			COLUMN_NAME (VARCHAR(128) not NULL) 			ORDINAL_POSITION (SMALLINT not NULL) 			PK_NAME (VARCHAR(128)) 	Columns ordered by TABLE_CAT, TABLE_SCHEM, TABLE_NAME and ORDINAL_POSITION."	| xif rc |	xif := self class xif.	self startPrepare.	self state: #executing.	self connection isUnicodeEncoding ifTrue: [ | localEncoding copySelector szTableQualfier szTableOwner szTableName |		szTableQualfier := szTableOwner := szTableName := nil.		copySelector := xif copyToHeapSelector.		localEncoding := self connection encoding.		szTableQualfier := szTableOwner := szTableName := nil.		[ "Begin unwind protection." 			tableQualifier isNil ifFalse: [ szTableQualfier := (tableQualifier asByteArrayEncoding: localEncoding) perform: copySelector ].			tableOwner isNil ifFalse: [ szTableOwner := (tableOwner asByteArrayEncoding: localEncoding) perform: copySelector ].			tableName isNil ifFalse: [ szTableName := (tableName asByteArrayEncoding: localEncoding) perform: copySelector ].			rc := xif SQLPrimaryKeysW: self hstmt			 		with: szTableQualfier			 		with: tableQualifier size			 		with: szTableOwner			 		with: tableOwner size			 		with: szTableName			 		with: tableName size.		"End unwind protection." ]			ensure:			[ szTableQualfier notNil ifTrue: [ szTableQualfier freePointer ].			szTableOwner notNil ifTrue: [ szTableOwner freePointer ].			szTableName notNil ifTrue: [ szTableName freePointer ]].		] ifFalse: [			rc := xif SQLPrimaryKeys: self hstmt			 		with: tableQualifier			 		with: tableQualifier size			 		with: tableOwner			 		with: tableOwner size			 		with: tableName			 		with: tableName size.		].	(rc == xif SQL_SUCCESS	or: [rc == xif SQL_SUCCESS_WITH_INFO]) ifFalse:		[ | errs |		errs := self getStatementErrors.		self resultsCache: errs.		self connection class unableToFetchDataSignal raiseWith: errs				errorString: errs first dbmsErrorString]</body><body package="DB2EXDI">getSQLSpecialColumns: colTypeSymbol tableQualifier: tableQualifier tableOwner: tableOwner tableName: tableName scope: scopeSymbol nullable: nullableSymbol	"If supported on the current platform, call the ODBC function SQLSpecialColumns to obtain a list of statistics about a single table and the indexes associated with the table.  Sending the message callSQLSpecialColumns:tableQualifier:tableOwner:tableName:scope:nullable: is equivalent to preparing and executing a query using the receiver.  After the call completes, the table information is obtained as an answer stream in the normal way (i.e. send the message answer and then use the answer stream to fetch the rows).  Each row is an Array with one element for each column.  The columns of the answer set are defined in the ODBC documentation as: SCOPE, COLUMN_NAME, DATA_TYPE, PRECISION, LENGTH, SCALE, and PSEUDO_COLUMN.  Refer to the Informix CLI or ODBC documentation for more details.	The arguments tableQualifier, tableOwner, and tableName are directly passed to the function and take their definitions from the function definition.  The argument colTypeSymbol must be either #SQL_BEST_ROWID or #SQL_ROWVER.  The argument scopeSymbol must be one of #SQL_SCOPE_CURROW, #SQL_SCOPE_TRANSACTION, #SQL_SCOPE_SESSION. The argument nullableSymbol must be either #SQL_NO_NULLS or #SQL_NULLABLE."	| xif fColType fScope fNullable rc |	xif := self class xif.	self startPrepare.	self state: #executing.	"Set up the fColType parameter.  colTypeSymbol must be one of #SQL_BEST_ROWID or #SQL_ROWVER."	fColType := xif perform: colTypeSymbol.	"Set up the fScope parameter.  scopeSymbol must be one of #SQL_SCOPE_CURROW, #SQL_SCOPE_TRANSACTION, #SQL_SCOPE_SESSION"	fScope := xif perform: scopeSymbol.	"Set up the fNullable parameter.  nullableSymbol must be one of #SQL_NO_NULLS or #SQL_NULLABLE."	fNullable := xif perform: nullableSymbol.	self connection isUnicodeEncoding ifTrue: [ | localEncoding copySelector szTableQualfier szTableOwner szTableName |		copySelector := xif copyToHeapSelector.		localEncoding := self connection encoding.		szTableQualfier := szTableOwner := szTableName := nil.		[ "Begin unwind protection."			tableQualifier isNil ifFalse: [ szTableQualfier := (tableQualifier asByteArrayEncoding: localEncoding) perform: copySelector ].			tableOwner isNil ifFalse: [ szTableOwner := (tableOwner asByteArrayEncoding: localEncoding) perform: copySelector ].			tableName isNil ifFalse: [ szTableName := (tableName asByteArrayEncoding: localEncoding) perform: copySelector ].			rc := xif SQLSpecialColumnsW: self hstmt				with: fColType				with: szTableQualfier with: tableQualifier size				with: szTableOwner with: tableOwner size				with: szTableName with: tableName size				with: fScope				with: fNullable.		"End unwind protection." ]		ensure:			[ szTableQualfier notNil ifTrue: [ szTableQualfier freePointer ].			szTableOwner notNil ifTrue: [ szTableOwner freePointer ].			szTableName notNil ifTrue: [ szTableName freePointer ] ]	] ifFalse: [		rc := xif SQLSpecialColumns: self hstmt				with: fColType				with: tableQualifier with: tableQualifier size				with: tableOwner with: tableOwner size				with: tableName with: tableName size				with: fScope				with: fNullable.	].	(rc == xif SQL_SUCCESS	or: [rc == xif SQL_SUCCESS_WITH_INFO]) ifFalse:		[ | errs |		errs := self getStatementErrors.		self resultsCache: errs.		self connection class unableToFetchDataSignal raiseWith: errs				errorString: errs first dbmsErrorString]</body><body package="DB2EXDI">getSQLStatistics: tableQualifier tableOwner: tableOwner tableName: tableName unique: uniqueSymbol accuracy: accuracySymbol	"If supported on the current platform, call the ODBC function SQLStatistics to obtain a list of statistics about a single table and the indexes associated with the table.  Sending the message callSQLStatistics:tableOwner:tableName:unique:accuracy: is equivalent to preparing and executing a query using the receiver.  After the call completes, the table information is obtained as an answer stream in the normal way (i.e. send the message answer and then use the answer stream to fetch the rows).  Each row is an Array with one element for each column.  The columns of the answer set are defined in the ODBC documentation as: TABLE_QUALIFIER, TABLE_OWNER, TABLE_NAME, NON_UNIQUE, INDEX_QUALIFIER, INDEX_NAME, and TYPE.  Refer to the Informix CLI or ODBC documentation for more details.	The arguments tableQualifier, tableOwner, and tableName are directly passed to the function and take their definitions from the function definition.  The argument uniqueSymbol must be either #SQL_INDEX_UNIQUE or #SQL_INDEX_ALL.  The argument accuracySymbol must be either #SQL_ENSURE or #SQL_QUICK."	| xif fUnique fAccuracy rc |	xif := self class xif.	self startPrepare.	self state: #executing.	"Set up the fUnique parameter.  uniqueSymbol must be one of #SQL_INDEX_UNIQUE or #SQL_INDEX_ALL."	fUnique := xif perform: uniqueSymbol.	"Set up the fAccuracy parameter.  accuracySymbol must be one of #SQL_ENSURE or #SQL_QUICK."	fAccuracy := xif perform: accuracySymbol.	self connection isUnicodeEncoding ifTrue: [ | localEncoding copySelector szTableQualfier szTableOwner szTableName |		copySelector := xif copyToHeapSelector.		localEncoding := self connection encoding.		szTableQualfier := szTableOwner := szTableName := nil.		[ "Begin unwind protection."			tableQualifier isNil ifFalse: [ szTableQualfier := (tableQualifier asByteArrayEncoding: localEncoding) perform: copySelector ].			tableOwner isNil ifFalse: [ szTableOwner := (tableOwner asByteArrayEncoding: localEncoding) perform: copySelector ].			tableName isNil ifFalse: [ szTableName := (tableName asByteArrayEncoding: localEncoding) perform: copySelector ].		rc := xif SQLStatisticsW: self hstmt				with: szTableQualfier with: tableQualifier size				with: szTableOwner with: tableOwner size				with: szTableName with: tableName size				with: fUnique				with: fAccuracy.		"End unwind protection." ]		ensure:			[ szTableQualfier notNil ifTrue: [ szTableQualfier freePointer ].			szTableOwner notNil ifTrue: [ szTableOwner freePointer ].			szTableName notNil ifTrue: [ szTableName freePointer ] ]	] ifFalse: [		rc := xif SQLStatistics: self hstmt				with: tableQualifier with: tableQualifier size				with: tableOwner with: tableOwner size				with: tableName with: tableName size				with: fUnique				with: fAccuracy.	].	(rc == xif SQL_SUCCESS	or: [rc == xif SQL_SUCCESS_WITH_INFO]) ifFalse:		[ | errs |		errs := self getStatementErrors.		self resultsCache: errs.		self connection class unableToFetchDataSignal raiseWith: errs				errorString: errs first dbmsErrorString]</body><body package="DB2EXDI">getSQLTables: tableQualifier tableOwner: tableOwner tableName: tableName tableType: tableType 	"Answer list of names of tables stored in the current data source.  Sending the message callSQLTables:tableOwner:tableName:tableType: is equivalent to preparing and executing a query using the receiver.  After the call completes, the table information is obtained as an answer stream in the normal way (i.e. send the message answer and then use the answer stream to fetch the rows).  Each row is an Array with one element for each column.  The columns of the answer set are defined in the CLI documentation as: TABLE_QUALIFIER, TABLE_OWNER, TABLE_NAME, TABLE_TYPE, and REMARKS.  Refer to the DB2 CLI or ODBC documentation for more details.	The arguments tableQualifier, tableOwner, tableName, and tableType are directly passed to the function and take their definitions from the function definition."	| xif rc  |	xif := self class xif.	self startPrepare.	self state: #executing.	self connection isUnicodeEncoding ifTrue: [ | localEncoding copySelector szTableQualfier szTableOwner szTableName szTableType |		localEncoding := self connection encoding.		copySelector := xif copyToHeapSelector.		szTableQualfier := szTableOwner := szTableName := szTableType := nil.		[ "Begin unwind protection."			tableQualifier isNil ifFalse: [ szTableQualfier := (tableQualifier asByteArrayEncoding: localEncoding) perform: copySelector ].			tableOwner isNil ifFalse: [ szTableOwner := (tableOwner asByteArrayEncoding: localEncoding) perform: copySelector ].			tableName isNil ifFalse: [ szTableName := (tableName asByteArrayEncoding: localEncoding) perform: copySelector ].			tableType isNil ifFalse: [ szTableType := (tableType asByteArrayEncoding: localEncoding) perform: copySelector ].		rc := xif SQLTablesW: self hstmt				with: szTableQualfier with: tableQualifier size				with: szTableOwner with: tableOwner size				with: szTableName with: tableName size				with: szTableType with: tableType size.			"End unwind protection." ]		ensure:			[ szTableQualfier notNil ifTrue: [ szTableQualfier freePointer ].			szTableOwner notNil ifTrue: [ szTableOwner freePointer ].			szTableName notNil ifTrue: [ szTableName freePointer ].			szTableType notNil ifTrue: [ szTableType freePointer ] ]	] ifFalse: [		rc := xif SQLTables: self hstmt				with: tableQualifier with: tableQualifier size				with: tableOwner with: tableOwner size				with: tableName with: tableName size				with: tableType with: tableType size.	].	(rc == xif SQL_SUCCESS	or: [rc == xif SQL_SUCCESS_WITH_INFO]) ifFalse:		[ | errs |		errs := self getStatementErrors.		self resultsCache: errs.		self connection class unableToFetchDataSignal raiseWith: errs				errorString: errs first dbmsErrorString]</body></methods><methods><class-id>Database.DB2Session class</class-id> <category>accessing</category><body package="DB2EXDI">bufferClass	"Answer the class to use for bindInput/Output objects associated with receiver."	^DB2Buffer</body><body package="DB2EXDI">connectionClass	"Answer the class to use for connection objects associated with receiver."	^DB2Connection</body><body package="DB2EXDI">defaultMaxLongData	"(1 Gig, which is 1/2 of the real DB2 Max for Blobs)"	^2**30</body><body package="DB2EXDI">largeObjectBufferClass	"Answer the class to use for bindInput/Output objects associated with receiver."	^DB2LargeObjectBuffer</body></methods><methods><class-id>Database.DB2Session class</class-id> <category>private-activation</category><body package="DB2EXDI">install	self bufferClass install.</body></methods><methods><class-id>Database.DB2Session class</class-id> <category>private-registry</category><body package="DB2EXDI">registry	^RegisteredDB2Sessions</body><body package="DB2EXDI">registry: aCollection	RegisteredDB2Sessions := aCollection</body></methods><methods><class-id>Database.DB2Session class</class-id> <category>class initialization</category><body package="DB2EXDI">initialize	"DB2Session initialize"	self initRegistry.	self initializeSQLStatementAttributeConversionMap.	self install.</body><body package="DB2EXDI">initializeSQLStatementAttributeConversionMap	"DB2Session initializeSQLStatementAttributeConversionMap"	(SQLStatementAttributeConversionMap := IdentityDictionary new)		add: #SQL_ATTR_ASYNC_ENABLE-&gt;#longAt:;    						add: #SQL_ATTR_ROW_BIND_TYPE-&gt;#longAt:; 				add: #SQL_ATTR_CURSOR_TYPE-&gt;#longAt:;					add: #SQL_ATTR_MAX_LENGTH-&gt;#longAt:;						add: #SQL_ATTR_MAX_ROWS-&gt;#longAt:;					add: #SQL_ATTR_NOSCAN-&gt;#longAt:;							add: #SQL_ATTR_ROWS_FETCHED_PTR-&gt;#longAt:;			add: #SQL_ATTR_ROW_ARRAY_SIZE-&gt;#longAt:;		add: #SQL_ATTR_ROW_NUMBER-&gt;#longAt:;		add: #SQL_ATTR_CLOSEOPEN-&gt;#longAt:</body></methods><methods><class-id>Core.Object</class-id> <category>private-db2</category><body package="DB2EXDI">db2Conversion	"Answer the symbolic conversion name for instances of this 	class or subclasses.  The default is no conversion is defined"	^nil</body></methods><methods><class-id>Core.String</class-id> <category>private-db2</category><body package="DB2EXDI">asBooleanForDB2	"Try to interpret the string as a Boolean using a common Cobol paradigm.  Treat the value as null if it doesn't match the encoded value for true or false."	self size == 1 ifTrue:		[ self = 'Y' ifTrue: [ ^true ].		self = 'N' ifTrue: [ ^false ] ].	^nil</body></methods><methods><class-id>Core.Integer</class-id> <category>private-db2</category><body package="DB2EXDI">db2Conversion	"Answer the symbolic conversion name for instances of this 	class or subclasses."	^ObjectMemory is64Bit		ifTrue: 			[(self &gt;= -536870912 and: [self &lt;= 536870911])				ifTrue: [#Integer]				ifFalse: [#LargeInteger]]		ifFalse: [#Integer]</body></methods><methods><class-id>Core.FixedPoint class</class-id> <category>private-db2</category><body package="DB2EXDI">readDB2DecimalFrom: aStream 	"Answer an instance of me as described on the stream, aStream."	| value neg precision num den digit |	(aStream atEnd or: [aStream peek isLetter]) ifTrue: [^0].	neg := aStream peekFor: $-.	value := self readIntegerFrom: aStream radix: 10.	precision := 0. num := 0. den := 1.	((aStream peekFor: $.) or: [aStream peekFor: $,])		ifTrue: ["&lt;integer&gt;.&lt;fraction&gt;"			(aStream atEnd not and: [aStream peek isDigit])				ifTrue: [ 						[aStream atEnd or: [(digit := aStream next) isDigit not]]						whileFalse: 							[num := num * 10 + digit digitValue.							precision := precision + 1].					den := 10 ** precision]].	value := value + (num / den).	value := self basicNew setNumerator: value numerator denominator: value denominator  scale: precision.	^neg		ifTrue: [value negated]		ifFalse: [value]</body></methods><methods><class-id>Core.FixedPoint</class-id> <category>private-db2</category><body package="DB2EXDI">db2Conversion	"Answer the symbolic conversion name for instances of this 	class or subclasses."	^#FixedPoint</body></methods><methods><class-id>Core.ByteArray</class-id> <category>private-db2</category><body package="DB2EXDI">db2Conversion	"Answer the symbolic conversion name for instances of this 	class or subclasses."	^self size &gt; 32700 ifTrue: [#LargeByteArray] ifFalse: [#ByteArray]</body></methods><methods><class-id>OS.BufferedExternalStream</class-id> <category>private-db2</category><body package="DB2EXDI">db2Conversion	^self isBinary 		  ifTrue: [^#LargeByteArray  ]		  ifFalse: [^#LargeString  ]</body></methods><methods><class-id>Core.LargeInteger class</class-id> <category>type semantics</category><body package="DB2EXDI">recordTemplate	^self new: 8 neg: false</body></methods><methods><class-id>Core.LargeInteger</class-id> <category>private-db2</category><body package="DB2EXDI">db2Conversion	^#LargeInteger</body></methods><methods><class-id>Core.Double</class-id> <category>private-db2</category><body package="DB2EXDI">db2Conversion	"Answer the symbolic conversion name for instances of this 	class or subclasses."	^#Double</body></methods><methods><class-id>Core.Timestamp</class-id> <category>private-db2</category><body package="DB2EXDI">db2Conversion	"Answer the symbolic conversion name for instances of this class 	or subclasses."	^#Timestamp</body></methods><methods><class-id>Core.SmallDouble</class-id> <category>private-db2</category><body package="DB2EXDI">db2Conversion	^#Double</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>private-db2</category><body package="DB2EXDI">printStringForDB2	^' '</body></methods><methods><class-id>Core.Boolean</class-id> <category>private-db2</category><body package="DB2EXDI">printStringForDB2	"Encode receiver in one character ."	^self ifTrue: [ 'Y' ] ifFalse: [ 'N' ]</body></methods><methods><class-id>Core.Time class</class-id> <category>instance creation</category><body package="DB2EXDI">recordTemplate	^self fromSeconds: 0</body><body package="DB2EXDI">zero	^self fromSeconds: 0</body></methods><methods><class-id>Core.Time</class-id> <category>private-db2</category><body package="DB2EXDI">db2Conversion	"Answer the symbolic conversion name for instances of this 	class or subclasses."	^#Time</body></methods><methods><class-id>Core.Float</class-id> <category>private-db2</category><body package="DB2EXDI">db2Conversion	"Answer the symbolic conversion name for instances of this 	class or subclasses."	^#Float</body></methods><methods><class-id>Core.PositionableStream</class-id> <category>private-db2</category><body package="DB2EXDI">db2Conversion	(collection isKindOf: ByteArray ) 	ifTrue: [^#LargeByteArray  ].	(collection isKindOf: CharacterArray ) ifTrue: [^#LargeString ].	self error: 'The receiver does not have an appropriate DB2 conversion type.'</body></methods><methods><class-id>Core.Date class</class-id> <category>instance creation</category><body package="DB2EXDI">recordTemplate	^self newDay: 1 year: 1</body></methods><methods><class-id>Core.Date</class-id> <category>private-db2</category><body package="DB2EXDI">db2Conversion	"Answer the symbolic conversion name for instances of this 	class or subclasses."	^#Date</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>private-db2</category><body package="DB2EXDI">avbTrimBlanks	"Answer a String containing the receiver string with leading and	 trailing blanks removed.	 Sample: ' asdasd sdfsdf sdfdsf      ' trimBlanks  'asdasd sdfsdf sdfdsf'   "	| start end done |	(end := self size) == 0 ifTrue: [^self].	start := 1.	done := false.	[(self at: start) ~~ Character space or: [done := start == end]] 	whileFalse: [start := start + 1].	done ifTrue: [^''].  	[(self at: end) ~~ Character space  or: [done := start == end]] whileFalse: [end := end - 1].	^done ifTrue: [''] ifFalse: [self copyFrom: start to: end]</body><body package="DB2EXDI">db2Conversion	"Answer the symbolic conversion name for instances of this 	class or subclasses."	^self size &gt; 32700 ifTrue: [#LargeString] ifFalse: [#String]</body></methods><methods><class-id>Core.Array</class-id> <category>private-db2</category><body package="DB2EXDI">db2Conversion	^#Array</body></methods><methods><class-id>Database.DB2CLIInterface</class-id> <category>defines</category><body package="DB2EXDI">CLI_MAX_CHAR	&lt;C: #define CLI_MAX_CHAR 1252	&gt;</body><body package="DB2EXDI">CLI_MAX_GRAPHIC	&lt;C: #define CLI_MAX_GRAPHIC 1255	&gt;</body><body package="DB2EXDI">CLI_MAX_LONGVARCHAR	&lt;C: #define CLI_MAX_LONGVARCHAR 1250	&gt;</body><body package="DB2EXDI">CLI_MAX_LONGVARGRAPHIC	&lt;C: #define CLI_MAX_LONGVARGRAPHIC 1253	&gt;</body><body package="DB2EXDI">CLI_MAX_VARCHAR	&lt;C: #define CLI_MAX_VARCHAR 1251	&gt;</body><body package="DB2EXDI">CLI_MAX_VARGRAPHIC	&lt;C: #define CLI_MAX_VARGRAPHIC 1254	&gt;</body><body package="DB2EXDI">DB2CLI_VER	&lt;C: #define DB2CLI_VER 784	&gt;</body><body package="DB2EXDI">DB2NT	&lt;C: #define DB2NT 1	&gt;</body><body package="DB2EXDI">FAR	&lt;C: #define FAR 	&gt;</body><body package="DB2EXDI">ODBCVER	&lt;C: #define ODBCVER 768	&gt;</body><body package="DB2EXDI">PSQL_API_FN	&lt;C: #define PSQL_API_FN __stdcall*	&gt;</body><body package="DB2EXDI">SQLCODE	&lt;C: #define SQLCODE sqlca.sqlcode	&gt;</body><body package="DB2EXDI">SQLConnectW	&lt;C: #define SQLConnectW SQLConnectWInt	&gt;</body><body package="DB2EXDI">SQLWARN0	&lt;C: #define SQLWARN0 sqlca.sqlwarn[0]	&gt;</body><body package="DB2EXDI">SQLWARN1	&lt;C: #define SQLWARN1 sqlca.sqlwarn[1]	&gt;</body><body package="DB2EXDI">SQLWARN2	&lt;C: #define SQLWARN2 sqlca.sqlwarn[2]	&gt;</body><body package="DB2EXDI">SQLWARN3	&lt;C: #define SQLWARN3 sqlca.sqlwarn[3]	&gt;</body><body package="DB2EXDI">SQLWARN4	&lt;C: #define SQLWARN4 sqlca.sqlwarn[4]	&gt;</body><body package="DB2EXDI">SQLWARN5	&lt;C: #define SQLWARN5 sqlca.sqlwarn[5]	&gt;</body><body package="DB2EXDI">SQLWARN6	&lt;C: #define SQLWARN6 sqlca.sqlwarn[6]	&gt;</body><body package="DB2EXDI">SQLWARN7	&lt;C: #define SQLWARN7 sqlca.sqlwarn[7]	&gt;</body><body package="DB2EXDI">SQLWARN8	&lt;C: #define SQLWARN8 sqlca.sqlwarn[8]	&gt;</body><body package="DB2EXDI">SQLWARN9	&lt;C: #define SQLWARN9 sqlca.sqlwarn[9]	&gt;</body><body package="DB2EXDI">SQLWARNA	&lt;C: #define SQLWARNA sqlca.sqlwarn[10]	&gt;</body><body package="DB2EXDI">SQL_ACCESSIBLE_PROCEDURES	&lt;C: #define SQL_ACCESSIBLE_PROCEDURES 20	&gt;</body><body package="DB2EXDI">SQL_ACCESSIBLE_TABLES	&lt;C: #define SQL_ACCESSIBLE_TABLES 19	&gt;</body><body package="DB2EXDI">SQL_ACCESS_MODE	&lt;C: #define SQL_ACCESS_MODE 101	&gt;</body><body package="DB2EXDI">SQL_ACTIVE_CONNECTIONS	&lt;C: #define SQL_ACTIVE_CONNECTIONS 0	&gt;</body><body package="DB2EXDI">SQL_ACTIVE_ENVIRONMENTS	&lt;C: #define SQL_ACTIVE_ENVIRONMENTS 116	&gt;</body><body package="DB2EXDI">SQL_ACTIVE_STATEMENTS	&lt;C: #define SQL_ACTIVE_STATEMENTS 1	&gt;</body><body package="DB2EXDI">SQL_ADD	&lt;C: #define SQL_ADD 4	&gt;</body><body package="DB2EXDI">SQL_AD_ADD_CONSTRAINT_DEFERRABLE	&lt;C: #define SQL_AD_ADD_CONSTRAINT_DEFERRABLE 0x00000080	&gt;</body><body package="DB2EXDI">SQL_AD_ADD_CONSTRAINT_INITIALLY_DEFERRED	&lt;C: #define SQL_AD_ADD_CONSTRAINT_INITIALLY_DEFERRED 0x00000020	&gt;</body><body package="DB2EXDI">SQL_AD_ADD_CONSTRAINT_INITIALLY_IMMEDIATE	&lt;C: #define SQL_AD_ADD_CONSTRAINT_INITIALLY_IMMEDIATE 0x00000040	&gt;</body><body package="DB2EXDI">SQL_AD_ADD_CONSTRAINT_NON_DEFERRABLE	&lt;C: #define SQL_AD_ADD_CONSTRAINT_NON_DEFERRABLE 0x00000100	&gt;</body><body package="DB2EXDI">SQL_AD_ADD_DOMAIN_CONSTRAINT	&lt;C: #define SQL_AD_ADD_DOMAIN_CONSTRAINT 0x00000002	&gt;</body><body package="DB2EXDI">SQL_AD_ADD_DOMAIN_DEFAULT	&lt;C: #define SQL_AD_ADD_DOMAIN_DEFAULT 0x00000008	&gt;</body><body package="DB2EXDI">SQL_AD_CONSTRAINT_NAME_DEFINITION	&lt;C: #define SQL_AD_CONSTRAINT_NAME_DEFINITION 0x00000001	&gt;</body><body package="DB2EXDI">SQL_AD_DROP_DOMAIN_CONSTRAINT	&lt;C: #define SQL_AD_DROP_DOMAIN_CONSTRAINT 0x00000004	&gt;</body><body package="DB2EXDI">SQL_AD_DROP_DOMAIN_DEFAULT	&lt;C: #define SQL_AD_DROP_DOMAIN_DEFAULT 0x00000010	&gt;</body><body package="DB2EXDI">SQL_AF_ALL	&lt;C: #define SQL_AF_ALL 0x00000040	&gt;</body><body package="DB2EXDI">SQL_AF_AVG	&lt;C: #define SQL_AF_AVG 0x00000001	&gt;</body><body package="DB2EXDI">SQL_AF_COUNT	&lt;C: #define SQL_AF_COUNT 0x00000002	&gt;</body><body package="DB2EXDI">SQL_AF_DISTINCT	&lt;C: #define SQL_AF_DISTINCT 0x00000020	&gt;</body><body package="DB2EXDI">SQL_AF_MAX	&lt;C: #define SQL_AF_MAX 0x00000004	&gt;</body><body package="DB2EXDI">SQL_AF_MIN	&lt;C: #define SQL_AF_MIN 0x00000008	&gt;</body><body package="DB2EXDI">SQL_AF_SUM	&lt;C: #define SQL_AF_SUM 0x00000010	&gt;</body><body package="DB2EXDI">SQL_AGGREGATE_FUNCTIONS	&lt;C: #define SQL_AGGREGATE_FUNCTIONS 169	&gt;</body><body package="DB2EXDI">SQL_ALL_CATALOGS	&lt;C: #define SQL_ALL_CATALOGS "%"	&gt;</body><body package="DB2EXDI">SQL_ALL_EXCEPT_LIKE	&lt;C: #define SQL_ALL_EXCEPT_LIKE 2	&gt;</body><body package="DB2EXDI">SQL_ALL_SCHEMAS	&lt;C: #define SQL_ALL_SCHEMAS "%"	&gt;</body><body package="DB2EXDI">SQL_ALL_TABLE_TYPES	&lt;C: #define SQL_ALL_TABLE_TYPES "%"	&gt;</body><body package="DB2EXDI">SQL_ALL_TYPES	&lt;C: #define SQL_ALL_TYPES 0	&gt;</body><body package="DB2EXDI">SQL_ALTER_DOMAIN	&lt;C: #define SQL_ALTER_DOMAIN 117	&gt;</body><body package="DB2EXDI">SQL_ALTER_TABLE	&lt;C: #define SQL_ALTER_TABLE 86	&gt;</body><body package="DB2EXDI">SQL_AM_CONNECTION	&lt;C: #define SQL_AM_CONNECTION 1	&gt;</body><body package="DB2EXDI">SQL_AM_NONE	&lt;C: #define SQL_AM_NONE 0	&gt;</body><body package="DB2EXDI">SQL_AM_STATEMENT	&lt;C: #define SQL_AM_STATEMENT 2	&gt;</body><body package="DB2EXDI">SQL_API	&lt;C: #define SQL_API SQL_API_FN	&gt;</body><body package="DB2EXDI">SQL_API_ALL_FUNCTIONS	&lt;C: #define SQL_API_ALL_FUNCTIONS 0	&gt;</body><body package="DB2EXDI">SQL_API_FN	&lt;C: #define SQL_API_FN __stdcall	&gt;</body><body package="DB2EXDI">SQL_API_INTR	&lt;C: #define SQL_API_INTR __stdcall	&gt;</body><body package="DB2EXDI">SQL_API_LOADBYORDINAL	&lt;C: #define SQL_API_LOADBYORDINAL 199	&gt;</body><body package="DB2EXDI">SQL_API_ODBC3_ALL_FUNCTIONS	&lt;C: #define SQL_API_ODBC3_ALL_FUNCTIONS 999	&gt;</body><body package="DB2EXDI">SQL_API_ODBC3_ALL_FUNCTIONS_SIZE	&lt;C: #define SQL_API_ODBC3_ALL_FUNCTIONS_SIZE 250	&gt;</body><body package="DB2EXDI">SQL_API_RC	&lt;C: #define SQL_API_RC int	&gt;</body><body package="DB2EXDI">SQL_API_SQLALLOCCONNECT	&lt;C: #define SQL_API_SQLALLOCCONNECT 1	&gt;</body><body package="DB2EXDI">SQL_API_SQLALLOCENV	&lt;C: #define SQL_API_SQLALLOCENV 2	&gt;</body><body package="DB2EXDI">SQL_API_SQLALLOCHANDLE	&lt;C: #define SQL_API_SQLALLOCHANDLE 1001	&gt;</body><body package="DB2EXDI">SQL_API_SQLALLOCHANDLESTD	&lt;C: #define SQL_API_SQLALLOCHANDLESTD 73	&gt;</body><body package="DB2EXDI">SQL_API_SQLALLOCSTMT	&lt;C: #define SQL_API_SQLALLOCSTMT 3	&gt;</body><body package="DB2EXDI">SQL_API_SQLBINDCOL	&lt;C: #define SQL_API_SQLBINDCOL 4	&gt;</body><body package="DB2EXDI">SQL_API_SQLBINDFILETOCOL	&lt;C: #define SQL_API_SQLBINDFILETOCOL 1250	&gt;</body><body package="DB2EXDI">SQL_API_SQLBINDFILETOPARAM	&lt;C: #define SQL_API_SQLBINDFILETOPARAM 1251	&gt;</body><body package="DB2EXDI">SQL_API_SQLBINDPARAM	&lt;C: #define SQL_API_SQLBINDPARAM 1002	&gt;</body><body package="DB2EXDI">SQL_API_SQLBINDPARAMETER	&lt;C: #define SQL_API_SQLBINDPARAMETER 72	&gt;</body><body package="DB2EXDI">SQL_API_SQLBROWSECONNECT	&lt;C: #define SQL_API_SQLBROWSECONNECT 55	&gt;</body><body package="DB2EXDI">SQL_API_SQLBUILDDATALINK	&lt;C: #define SQL_API_SQLBUILDDATALINK 1256	&gt;</body><body package="DB2EXDI">SQL_API_SQLBULKOPERATIONS	&lt;C: #define SQL_API_SQLBULKOPERATIONS 24	&gt;</body><body package="DB2EXDI">SQL_API_SQLCANCEL	&lt;C: #define SQL_API_SQLCANCEL 5	&gt;</body><body package="DB2EXDI">SQL_API_SQLCLOSECURSOR	&lt;C: #define SQL_API_SQLCLOSECURSOR 1003	&gt;</body><body package="DB2EXDI">SQL_API_SQLCOLATTRIBUTE	&lt;C: #define SQL_API_SQLCOLATTRIBUTE 6	&gt;</body><body package="DB2EXDI">SQL_API_SQLCOLATTRIBUTES	&lt;C: #define SQL_API_SQLCOLATTRIBUTES 6	&gt;</body><body package="DB2EXDI">SQL_API_SQLCOLUMNPRIVILEGES	&lt;C: #define SQL_API_SQLCOLUMNPRIVILEGES 56	&gt;</body><body package="DB2EXDI">SQL_API_SQLCOLUMNS	&lt;C: #define SQL_API_SQLCOLUMNS 40	&gt;</body><body package="DB2EXDI">SQL_API_SQLCONNECT	&lt;C: #define SQL_API_SQLCONNECT 7	&gt;</body><body package="DB2EXDI">SQL_API_SQLCOPYDESC	&lt;C: #define SQL_API_SQLCOPYDESC 1004	&gt;</body><body package="DB2EXDI">SQL_API_SQLDATASOURCES	&lt;C: #define SQL_API_SQLDATASOURCES 57	&gt;</body><body package="DB2EXDI">SQL_API_SQLDESCRIBECOL	&lt;C: #define SQL_API_SQLDESCRIBECOL 8	&gt;</body><body package="DB2EXDI">SQL_API_SQLDESCRIBEPARAM	&lt;C: #define SQL_API_SQLDESCRIBEPARAM 58	&gt;</body><body package="DB2EXDI">SQL_API_SQLDISCONNECT	&lt;C: #define SQL_API_SQLDISCONNECT 9	&gt;</body><body package="DB2EXDI">SQL_API_SQLDRIVERCONNECT	&lt;C: #define SQL_API_SQLDRIVERCONNECT 41	&gt;</body><body package="DB2EXDI">SQL_API_SQLDRIVERS	&lt;C: #define SQL_API_SQLDRIVERS 71	&gt;</body><body package="DB2EXDI">SQL_API_SQLENDTRAN	&lt;C: #define SQL_API_SQLENDTRAN 1005	&gt;</body><body package="DB2EXDI">SQL_API_SQLERROR	&lt;C: #define SQL_API_SQLERROR 10	&gt;</body><body package="DB2EXDI">SQL_API_SQLEXECDIRECT	&lt;C: #define SQL_API_SQLEXECDIRECT 11	&gt;</body><body package="DB2EXDI">SQL_API_SQLEXECUTE	&lt;C: #define SQL_API_SQLEXECUTE 12	&gt;</body><body package="DB2EXDI">SQL_API_SQLEXTENDEDBIND	&lt;C: #define SQL_API_SQLEXTENDEDBIND 1297	&gt;</body><body package="DB2EXDI">SQL_API_SQLEXTENDEDFETCH	&lt;C: #define SQL_API_SQLEXTENDEDFETCH 59	&gt;</body><body package="DB2EXDI">SQL_API_SQLEXTENDEDPREPARE	&lt;C: #define SQL_API_SQLEXTENDEDPREPARE 1296	&gt;</body><body package="DB2EXDI">SQL_API_SQLFETCH	&lt;C: #define SQL_API_SQLFETCH 13	&gt;</body><body package="DB2EXDI">SQL_API_SQLFETCHSCROLL	&lt;C: #define SQL_API_SQLFETCHSCROLL 1021	&gt;</body><body package="DB2EXDI">SQL_API_SQLFOREIGNKEYS	&lt;C: #define SQL_API_SQLFOREIGNKEYS 60	&gt;</body><body package="DB2EXDI">SQL_API_SQLFREECONNECT	&lt;C: #define SQL_API_SQLFREECONNECT 14	&gt;</body><body package="DB2EXDI">SQL_API_SQLFREEENV	&lt;C: #define SQL_API_SQLFREEENV 15	&gt;</body><body package="DB2EXDI">SQL_API_SQLFREEHANDLE	&lt;C: #define SQL_API_SQLFREEHANDLE 1006	&gt;</body><body package="DB2EXDI">SQL_API_SQLFREESTMT	&lt;C: #define SQL_API_SQLFREESTMT 16	&gt;</body><body package="DB2EXDI">SQL_API_SQLGETCONNECTATTR	&lt;C: #define SQL_API_SQLGETCONNECTATTR 1007	&gt;</body><body package="DB2EXDI">SQL_API_SQLGETCONNECTOPTION	&lt;C: #define SQL_API_SQLGETCONNECTOPTION 42	&gt;</body><body package="DB2EXDI">SQL_API_SQLGETCURSORNAME	&lt;C: #define SQL_API_SQLGETCURSORNAME 17	&gt;</body><body package="DB2EXDI">SQL_API_SQLGETDATA	&lt;C: #define SQL_API_SQLGETDATA 43	&gt;</body><body package="DB2EXDI">SQL_API_SQLGETDATALINKATTR	&lt;C: #define SQL_API_SQLGETDATALINKATTR 1255	&gt;</body><body package="DB2EXDI">SQL_API_SQLGETDESCFIELD	&lt;C: #define SQL_API_SQLGETDESCFIELD 1008	&gt;</body><body package="DB2EXDI">SQL_API_SQLGETDESCREC	&lt;C: #define SQL_API_SQLGETDESCREC 1009	&gt;</body><body package="DB2EXDI">SQL_API_SQLGETDIAGFIELD	&lt;C: #define SQL_API_SQLGETDIAGFIELD 1010	&gt;</body><body package="DB2EXDI">SQL_API_SQLGETDIAGREC	&lt;C: #define SQL_API_SQLGETDIAGREC 1011	&gt;</body><body package="DB2EXDI">SQL_API_SQLGETENVATTR	&lt;C: #define SQL_API_SQLGETENVATTR 1012	&gt;</body><body package="DB2EXDI">SQL_API_SQLGETFUNCTIONS	&lt;C: #define SQL_API_SQLGETFUNCTIONS 44	&gt;</body><body package="DB2EXDI">SQL_API_SQLGETINFO	&lt;C: #define SQL_API_SQLGETINFO 45	&gt;</body><body package="DB2EXDI">SQL_API_SQLGETLENGTH	&lt;C: #define SQL_API_SQLGETLENGTH 1022	&gt;</body><body package="DB2EXDI">SQL_API_SQLGETPOSITION	&lt;C: #define SQL_API_SQLGETPOSITION 1023	&gt;</body><body package="DB2EXDI">SQL_API_SQLGETSQLCA	&lt;C: #define SQL_API_SQLGETSQLCA 1253	&gt;</body><body package="DB2EXDI">SQL_API_SQLGETSTMTATTR	&lt;C: #define SQL_API_SQLGETSTMTATTR 1014	&gt;</body><body package="DB2EXDI">SQL_API_SQLGETSTMTOPTION	&lt;C: #define SQL_API_SQLGETSTMTOPTION 46	&gt;</body><body package="DB2EXDI">SQL_API_SQLGETSUBSTRING	&lt;C: #define SQL_API_SQLGETSUBSTRING 1024	&gt;</body><body package="DB2EXDI">SQL_API_SQLGETTYPEINFO	&lt;C: #define SQL_API_SQLGETTYPEINFO 47	&gt;</body><body package="DB2EXDI">SQL_API_SQLMORERESULTS	&lt;C: #define SQL_API_SQLMORERESULTS 61	&gt;</body><body package="DB2EXDI">SQL_API_SQLNATIVESQL	&lt;C: #define SQL_API_SQLNATIVESQL 62	&gt;</body><body package="DB2EXDI">SQL_API_SQLNUMPARAMS	&lt;C: #define SQL_API_SQLNUMPARAMS 63	&gt;</body><body package="DB2EXDI">SQL_API_SQLNUMRESULTCOLS	&lt;C: #define SQL_API_SQLNUMRESULTCOLS 18	&gt;</body><body package="DB2EXDI">SQL_API_SQLPARAMDATA	&lt;C: #define SQL_API_SQLPARAMDATA 48	&gt;</body><body package="DB2EXDI">SQL_API_SQLPARAMOPTIONS	&lt;C: #define SQL_API_SQLPARAMOPTIONS 64	&gt;</body><body package="DB2EXDI">SQL_API_SQLPREPARE	&lt;C: #define SQL_API_SQLPREPARE 19	&gt;</body><body package="DB2EXDI">SQL_API_SQLPRIMARYKEYS	&lt;C: #define SQL_API_SQLPRIMARYKEYS 65	&gt;</body><body package="DB2EXDI">SQL_API_SQLPROCEDURECOLUMNS	&lt;C: #define SQL_API_SQLPROCEDURECOLUMNS 66	&gt;</body><body package="DB2EXDI">SQL_API_SQLPROCEDURES	&lt;C: #define SQL_API_SQLPROCEDURES 67	&gt;</body><body package="DB2EXDI">SQL_API_SQLPUTDATA	&lt;C: #define SQL_API_SQLPUTDATA 49	&gt;</body><body package="DB2EXDI">SQL_API_SQLROWCOUNT	&lt;C: #define SQL_API_SQLROWCOUNT 20	&gt;</body><body package="DB2EXDI">SQL_API_SQLSETCOLATTRIBUTES	&lt;C: #define SQL_API_SQLSETCOLATTRIBUTES 1252	&gt;</body><body package="DB2EXDI">SQL_API_SQLSETCONNECTATTR	&lt;C: #define SQL_API_SQLSETCONNECTATTR 1016	&gt;</body><body package="DB2EXDI">SQL_API_SQLSETCONNECTION	&lt;C: #define SQL_API_SQLSETCONNECTION 1254	&gt;</body><body package="DB2EXDI">SQL_API_SQLSETCONNECTOPTION	&lt;C: #define SQL_API_SQLSETCONNECTOPTION 50	&gt;</body><body package="DB2EXDI">SQL_API_SQLSETCURSORNAME	&lt;C: #define SQL_API_SQLSETCURSORNAME 21	&gt;</body><body package="DB2EXDI">SQL_API_SQLSETDESCFIELD	&lt;C: #define SQL_API_SQLSETDESCFIELD 1017	&gt;</body><body package="DB2EXDI">SQL_API_SQLSETDESCREC	&lt;C: #define SQL_API_SQLSETDESCREC 1018	&gt;</body><body package="DB2EXDI">SQL_API_SQLSETENVATTR	&lt;C: #define SQL_API_SQLSETENVATTR 1019	&gt;</body><body package="DB2EXDI">SQL_API_SQLSETPARAM	&lt;C: #define SQL_API_SQLSETPARAM 22	&gt;</body><body package="DB2EXDI">SQL_API_SQLSETPOS	&lt;C: #define SQL_API_SQLSETPOS 68	&gt;</body><body package="DB2EXDI">SQL_API_SQLSETSCROLLOPTIONS	&lt;C: #define SQL_API_SQLSETSCROLLOPTIONS 69	&gt;</body><body package="DB2EXDI">SQL_API_SQLSETSTMTATTR	&lt;C: #define SQL_API_SQLSETSTMTATTR 1020	&gt;</body><body package="DB2EXDI">SQL_API_SQLSETSTMTOPTION	&lt;C: #define SQL_API_SQLSETSTMTOPTION 51	&gt;</body><body package="DB2EXDI">SQL_API_SQLSPECIALCOLUMNS	&lt;C: #define SQL_API_SQLSPECIALCOLUMNS 52	&gt;</body><body package="DB2EXDI">SQL_API_SQLSTATISTICS	&lt;C: #define SQL_API_SQLSTATISTICS 53	&gt;</body><body package="DB2EXDI">SQL_API_SQLTABLEPRIVILEGES	&lt;C: #define SQL_API_SQLTABLEPRIVILEGES 70	&gt;</body><body package="DB2EXDI">SQL_API_SQLTABLES	&lt;C: #define SQL_API_SQLTABLES 54	&gt;</body><body package="DB2EXDI">SQL_API_SQLTRANSACT	&lt;C: #define SQL_API_SQLTRANSACT 23	&gt;</body><body package="DB2EXDI">SQL_APP_TYPE_DEFAULT	&lt;C: #define SQL_APP_TYPE_DEFAULT SQL_APP_TYPE_ODBC	&gt;</body><body package="DB2EXDI">SQL_APP_TYPE_JDBC	&lt;C: #define SQL_APP_TYPE_JDBC 3	&gt;</body><body package="DB2EXDI">SQL_APP_TYPE_ODBC	&lt;C: #define SQL_APP_TYPE_ODBC 1	&gt;</body><body package="DB2EXDI">SQL_APP_TYPE_OLEDB	&lt;C: #define SQL_APP_TYPE_OLEDB 2	&gt;</body><body package="DB2EXDI">SQL_ARD_TYPE	&lt;C: #define SQL_ARD_TYPE (-99)	&gt;</body><body package="DB2EXDI">SQL_ASYNC_ENABLE	&lt;C: #define SQL_ASYNC_ENABLE 4	&gt;</body><body package="DB2EXDI">SQL_ASYNC_ENABLE_DEFAULT	&lt;C: #define SQL_ASYNC_ENABLE_DEFAULT SQL_ASYNC_ENABLE_OFF	&gt;</body><body package="DB2EXDI">SQL_ASYNC_ENABLE_OFF	&lt;C: #define SQL_ASYNC_ENABLE_OFF 0	&gt;</body><body package="DB2EXDI">SQL_ASYNC_ENABLE_ON	&lt;C: #define SQL_ASYNC_ENABLE_ON 1	&gt;</body><body package="DB2EXDI">SQL_ASYNC_MODE	&lt;C: #define SQL_ASYNC_MODE 10021	&gt;</body><body package="DB2EXDI">SQL_ATOMIC_DEFAULT	&lt;C: #define SQL_ATOMIC_DEFAULT SQL_ATOMIC_YES	&gt;</body><body package="DB2EXDI">SQL_ATOMIC_NO	&lt;C: #define SQL_ATOMIC_NO 0	&gt;</body><body package="DB2EXDI">SQL_ATOMIC_YES	&lt;C: #define SQL_ATOMIC_YES 1	&gt;</body><body package="DB2EXDI">SQL_ATTR_ACCESS_MODE	&lt;C: #define SQL_ATTR_ACCESS_MODE SQL_ACCESS_MODE	&gt;</body><body package="DB2EXDI">SQL_ATTR_APP_PARAM_DESC	&lt;C: #define SQL_ATTR_APP_PARAM_DESC 10011	&gt;</body><body package="DB2EXDI">SQL_ATTR_APP_ROW_DESC	&lt;C: #define SQL_ATTR_APP_ROW_DESC 10010	&gt;</body><body package="DB2EXDI">SQL_ATTR_APP_TYPE	&lt;C: #define SQL_ATTR_APP_TYPE 2473	&gt;</body><body package="DB2EXDI">SQL_ATTR_ASYNC_ENABLE	&lt;C: #define SQL_ATTR_ASYNC_ENABLE 4	&gt;</body><body package="DB2EXDI">SQL_ATTR_AUTOCOMMIT	&lt;C: #define SQL_ATTR_AUTOCOMMIT SQL_AUTOCOMMIT	&gt;</body><body package="DB2EXDI">SQL_ATTR_AUTOCOMMIT_NOCOMMIT	&lt;C: #define SQL_ATTR_AUTOCOMMIT_NOCOMMIT 2462	&gt;</body><body package="DB2EXDI">SQL_ATTR_AUTO_IPD	&lt;C: #define SQL_ATTR_AUTO_IPD 10001	&gt;</body><body package="DB2EXDI">SQL_ATTR_BLOCK_FOR_NROWS	&lt;C: #define SQL_ATTR_BLOCK_FOR_NROWS 2459	&gt;</body><body package="DB2EXDI">SQL_ATTR_CALL_RETURN	&lt;C: #define SQL_ATTR_CALL_RETURN 2470	&gt;</body><body package="DB2EXDI">SQL_ATTR_CALL_RETVAL_AS_PARM	&lt;C: #define SQL_ATTR_CALL_RETVAL_AS_PARM 2469	&gt;</body><body package="DB2EXDI">SQL_ATTR_CHAINING_BEGIN	&lt;C: #define SQL_ATTR_CHAINING_BEGIN 2464	&gt;</body><body package="DB2EXDI">SQL_ATTR_CHAINING_END	&lt;C: #define SQL_ATTR_CHAINING_END 2465	&gt;</body><body package="DB2EXDI">SQL_ATTR_CLISCHEMA	&lt;C: #define SQL_ATTR_CLISCHEMA 1280	&gt;</body><body package="DB2EXDI">SQL_ATTR_CLOSEOPEN	&lt;C: #define SQL_ATTR_CLOSEOPEN 1265	&gt;</body><body package="DB2EXDI">SQL_ATTR_CLOSE_BEHAVIOR	&lt;C: #define SQL_ATTR_CLOSE_BEHAVIOR 1257	&gt;</body><body package="DB2EXDI">SQL_ATTR_CONCURRENCY	&lt;C: #define SQL_ATTR_CONCURRENCY SQL_CONCURRENCY	&gt;</body><body package="DB2EXDI">SQL_ATTR_CONNECTION_DEAD	&lt;C: #define SQL_ATTR_CONNECTION_DEAD 1209	&gt;</body><body package="DB2EXDI">SQL_ATTR_CONNECTION_POOLING	&lt;C: #define SQL_ATTR_CONNECTION_POOLING 201	&gt;</body><body package="DB2EXDI">SQL_ATTR_CONNECTION_TIMEOUT	&lt;C: #define SQL_ATTR_CONNECTION_TIMEOUT 113	&gt;</body><body package="DB2EXDI">SQL_ATTR_CONNECTTYPE	&lt;C: #define SQL_ATTR_CONNECTTYPE SQL_CONNECTTYPE	&gt;</body><body package="DB2EXDI">SQL_ATTR_CONNECT_NODE	&lt;C: #define SQL_ATTR_CONNECT_NODE 1290	&gt;</body><body package="DB2EXDI">SQL_ATTR_CONNECT_WITH_XA	&lt;C: #define SQL_ATTR_CONNECT_WITH_XA 1291	&gt;</body><body package="DB2EXDI">SQL_ATTR_CONN_CONTEXT	&lt;C: #define SQL_ATTR_CONN_CONTEXT SQL_CONN_CONTEXT	&gt;</body><body package="DB2EXDI">SQL_ATTR_CP_MATCH	&lt;C: #define SQL_ATTR_CP_MATCH 202	&gt;</body><body package="DB2EXDI">SQL_ATTR_CURRENT_CATALOG	&lt;C: #define SQL_ATTR_CURRENT_CATALOG SQL_CURRENT_QUALIFIER	&gt;</body><body package="DB2EXDI">SQL_ATTR_CURRENT_PACKAGE_SET	&lt;C: #define SQL_ATTR_CURRENT_PACKAGE_SET 1276	&gt;</body><body package="DB2EXDI">SQL_ATTR_CURRENT_SCHEMA	&lt;C: #define SQL_ATTR_CURRENT_SCHEMA SQL_CURRENT_SCHEMA	&gt;</body><body package="DB2EXDI">SQL_ATTR_CURSOR_BLOCK_EARLY_CLOSE	&lt;C: #define SQL_ATTR_CURSOR_BLOCK_EARLY_CLOSE 2454	&gt;</body><body package="DB2EXDI">SQL_ATTR_CURSOR_BLOCK_NUM_ROWS	&lt;C: #define SQL_ATTR_CURSOR_BLOCK_NUM_ROWS 2453	&gt;</body><body package="DB2EXDI">SQL_ATTR_CURSOR_HOLD	&lt;C: #define SQL_ATTR_CURSOR_HOLD 1250	&gt;</body><body package="DB2EXDI">SQL_ATTR_CURSOR_SCROLLABLE	&lt;C: #define SQL_ATTR_CURSOR_SCROLLABLE (-1)	&gt;</body><body package="DB2EXDI">SQL_ATTR_CURSOR_SENSITIVITY	&lt;C: #define SQL_ATTR_CURSOR_SENSITIVITY (-2)	&gt;</body><body package="DB2EXDI">SQL_ATTR_CURSOR_TYPE	&lt;C: #define SQL_ATTR_CURSOR_TYPE SQL_CURSOR_TYPE	&gt;</body><body package="DB2EXDI">SQL_ATTR_DATALINK_COMMENT	&lt;C: #define SQL_ATTR_DATALINK_COMMENT 1	&gt;</body><body package="DB2EXDI">SQL_ATTR_DATALINK_LINKTYPE	&lt;C: #define SQL_ATTR_DATALINK_LINKTYPE 2	&gt;</body><body package="DB2EXDI">SQL_ATTR_DATALINK_URLCOMPLETE	&lt;C: #define SQL_ATTR_DATALINK_URLCOMPLETE 3	&gt;</body><body package="DB2EXDI">SQL_ATTR_DATALINK_URLPATH	&lt;C: #define SQL_ATTR_DATALINK_URLPATH 4	&gt;</body><body package="DB2EXDI">SQL_ATTR_DATALINK_URLPATHONLY	&lt;C: #define SQL_ATTR_DATALINK_URLPATHONLY 5	&gt;</body><body package="DB2EXDI">SQL_ATTR_DATALINK_URLSCHEME	&lt;C: #define SQL_ATTR_DATALINK_URLSCHEME 6	&gt;</body><body package="DB2EXDI">SQL_ATTR_DATALINK_URLSERVER	&lt;C: #define SQL_ATTR_DATALINK_URLSERVER 7	&gt;</body><body package="DB2EXDI">SQL_ATTR_DB2ESTIMATE	&lt;C: #define SQL_ATTR_DB2ESTIMATE SQL_DB2ESTIMATE	&gt;</body><body package="DB2EXDI">SQL_ATTR_DB2EXPLAIN	&lt;C: #define SQL_ATTR_DB2EXPLAIN SQL_DB2EXPLAIN	&gt;</body><body package="DB2EXDI">SQL_ATTR_DB2_MESSAGE_PREFIX	&lt;C: #define SQL_ATTR_DB2_MESSAGE_PREFIX 2468	&gt;</body><body package="DB2EXDI">SQL_ATTR_DB2_MESSAGE_PREFIX_DEFAULT	&lt;C: #define SQL_ATTR_DB2_MESSAGE_PREFIX_DEFAULT SQL_ATTR_DB2_MESSAGE_PREFIX_ON	&gt;</body><body package="DB2EXDI">SQL_ATTR_DB2_MESSAGE_PREFIX_OFF	&lt;C: #define SQL_ATTR_DB2_MESSAGE_PREFIX_OFF 0	&gt;</body><body package="DB2EXDI">SQL_ATTR_DB2_MESSAGE_PREFIX_ON	&lt;C: #define SQL_ATTR_DB2_MESSAGE_PREFIX_ON 1	&gt;</body><body package="DB2EXDI">SQL_ATTR_DB2_SQLERRP	&lt;C: #define SQL_ATTR_DB2_SQLERRP 2451	&gt;</body><body package="DB2EXDI">SQL_ATTR_DEFERRED_PREPARE	&lt;C: #define SQL_ATTR_DEFERRED_PREPARE 1277	&gt;</body><body package="DB2EXDI">SQL_ATTR_DISCONNECT_BEHAVIOR	&lt;C: #define SQL_ATTR_DISCONNECT_BEHAVIOR 114	&gt;</body><body package="DB2EXDI">SQL_ATTR_EARLYCLOSE	&lt;C: #define SQL_ATTR_EARLYCLOSE 1268	&gt;</body><body package="DB2EXDI">SQL_ATTR_ENABLE_AUTO_IPD	&lt;C: #define SQL_ATTR_ENABLE_AUTO_IPD 15	&gt;</body><body package="DB2EXDI">SQL_ATTR_ENABLE_EXTENDED_PARAMDATA	&lt;C: #define SQL_ATTR_ENABLE_EXTENDED_PARAMDATA 2472	&gt;</body><body package="DB2EXDI">SQL_ATTR_ENABLE_IPD_SETTING	&lt;C: #define SQL_ATTR_ENABLE_IPD_SETTING 1286	&gt;</body><body package="DB2EXDI">SQL_ATTR_ENLIST_IN_DTC	&lt;C: #define SQL_ATTR_ENLIST_IN_DTC 1207	&gt;</body><body package="DB2EXDI">SQL_ATTR_ENLIST_IN_XA	&lt;C: #define SQL_ATTR_ENLIST_IN_XA 1208	&gt;</body><body package="DB2EXDI">SQL_ATTR_FETCH_BOOKMARK_PTR	&lt;C: #define SQL_ATTR_FETCH_BOOKMARK_PTR 16	&gt;</body><body package="DB2EXDI">SQL_ATTR_FORCE_CONVERSION_ON_CLIENT	&lt;C: #define SQL_ATTR_FORCE_CONVERSION_ON_CLIENT 1275	&gt;</body><body package="DB2EXDI">SQL_ATTR_GET_XA_RESOURCE	&lt;C: #define SQL_ATTR_GET_XA_RESOURCE 1292	&gt;</body><body package="DB2EXDI">SQL_ATTR_IMP_PARAM_DESC	&lt;C: #define SQL_ATTR_IMP_PARAM_DESC 10013	&gt;</body><body package="DB2EXDI">SQL_ATTR_IMP_ROW_DESC	&lt;C: #define SQL_ATTR_IMP_ROW_DESC 10012	&gt;</body><body package="DB2EXDI">SQL_ATTR_INFO_ACCTSTR	&lt;C: #define SQL_ATTR_INFO_ACCTSTR 1284	&gt;</body><body package="DB2EXDI">SQL_ATTR_INFO_APPLNAME	&lt;C: #define SQL_ATTR_INFO_APPLNAME 1283	&gt;</body><body package="DB2EXDI">SQL_ATTR_INFO_USERID	&lt;C: #define SQL_ATTR_INFO_USERID 1281	&gt;</body><body package="DB2EXDI">SQL_ATTR_INFO_WRKSTNNAME	&lt;C: #define SQL_ATTR_INFO_WRKSTNNAME 1282	&gt;</body><body package="DB2EXDI">SQL_ATTR_INHERIT_NULL_CONNECT	&lt;C: #define SQL_ATTR_INHERIT_NULL_CONNECT 1270	&gt;</body><body package="DB2EXDI">SQL_ATTR_KEYSET_SIZE	&lt;C: #define SQL_ATTR_KEYSET_SIZE SQL_KEYSET_SIZE	&gt;</body><body package="DB2EXDI">SQL_ATTR_LITTLE_ENDIAN_UNICODE	&lt;C: #define SQL_ATTR_LITTLE_ENDIAN_UNICODE 2457	&gt;</body><body package="DB2EXDI">SQL_ATTR_LOGIN_TIMEOUT	&lt;C: #define SQL_ATTR_LOGIN_TIMEOUT SQL_LOGIN_TIMEOUT	&gt;</body><body package="DB2EXDI">SQL_ATTR_LONGDATA_COMPAT	&lt;C: #define SQL_ATTR_LONGDATA_COMPAT SQL_LONGDATA_COMPAT	&gt;</body><body package="DB2EXDI">SQL_ATTR_MAXCONN	&lt;C: #define SQL_ATTR_MAXCONN SQL_MAXCONN	&gt;</body><body package="DB2EXDI">SQL_ATTR_MAX_LENGTH	&lt;C: #define SQL_ATTR_MAX_LENGTH SQL_MAX_LENGTH	&gt;</body><body package="DB2EXDI">SQL_ATTR_MAX_ROWS	&lt;C: #define SQL_ATTR_MAX_ROWS SQL_MAX_ROWS	&gt;</body><body package="DB2EXDI">SQL_ATTR_MEM_DEBUG_DUMP	&lt;C: #define SQL_ATTR_MEM_DEBUG_DUMP 1289	&gt;</body><body package="DB2EXDI">SQL_ATTR_METADATA_ID	&lt;C: #define SQL_ATTR_METADATA_ID 10014	&gt;</body><body package="DB2EXDI">SQL_ATTR_MINMEMORY_USAGE	&lt;C: #define SQL_ATTR_MINMEMORY_USAGE SQL_MINMEMORY_USAGE	&gt;</body><body package="DB2EXDI">SQL_ATTR_NODESCRIBE	&lt;C: #define SQL_ATTR_NODESCRIBE SQL_NODESCRIBE_OUTPUT	&gt;</body><body package="DB2EXDI">SQL_ATTR_NODESCRIBE_INPUT	&lt;C: #define SQL_ATTR_NODESCRIBE_INPUT 1264	&gt;</body><body package="DB2EXDI">SQL_ATTR_NODESCRIBE_OUTPUT	&lt;C: #define SQL_ATTR_NODESCRIBE_OUTPUT 1251	&gt;</body><body package="DB2EXDI">SQL_ATTR_NOSCAN	&lt;C: #define SQL_ATTR_NOSCAN SQL_NOSCAN	&gt;</body><body package="DB2EXDI">SQL_ATTR_ODBC_CURSORS	&lt;C: #define SQL_ATTR_ODBC_CURSORS SQL_ODBC_CURSORS	&gt;</body><body package="DB2EXDI">SQL_ATTR_ODBC_VERSION	&lt;C: #define SQL_ATTR_ODBC_VERSION 200	&gt;</body><body package="DB2EXDI">SQL_ATTR_OPTIMIZE_FOR_NROWS	&lt;C: #define SQL_ATTR_OPTIMIZE_FOR_NROWS 2450	&gt;</body><body package="DB2EXDI">SQL_ATTR_OPTIMIZE_ROWS_FOR_BLOCKING	&lt;C: #define SQL_ATTR_OPTIMIZE_ROWS_FOR_BLOCKING 2460	&gt;</body><body package="DB2EXDI">SQL_ATTR_OPTIMIZE_SQLCOLUMNS	&lt;C: #define SQL_ATTR_OPTIMIZE_SQLCOLUMNS 1288	&gt;</body><body package="DB2EXDI">SQL_ATTR_OUTPUT_NTS	&lt;C: #define SQL_ATTR_OUTPUT_NTS 10001	&gt;</body><body package="DB2EXDI">SQL_ATTR_PACKET_SIZE	&lt;C: #define SQL_ATTR_PACKET_SIZE SQL_PACKET_SIZE	&gt;</body><body package="DB2EXDI">SQL_ATTR_PARAMOPT_ATOMIC	&lt;C: #define SQL_ATTR_PARAMOPT_ATOMIC SQL_PARAMOPT_ATOMIC	&gt;</body><body package="DB2EXDI">SQL_ATTR_PARAMSET_SIZE	&lt;C: #define SQL_ATTR_PARAMSET_SIZE 22	&gt;</body><body package="DB2EXDI">SQL_ATTR_PARAMS_PROCESSED_PTR	&lt;C: #define SQL_ATTR_PARAMS_PROCESSED_PTR 21	&gt;</body><body package="DB2EXDI">SQL_ATTR_PARAM_BIND_OFFSET_PTR	&lt;C: #define SQL_ATTR_PARAM_BIND_OFFSET_PTR 17	&gt;</body><body package="DB2EXDI">SQL_ATTR_PARAM_BIND_TYPE	&lt;C: #define SQL_ATTR_PARAM_BIND_TYPE 18	&gt;</body><body package="DB2EXDI">SQL_ATTR_PARAM_OPERATION_PTR	&lt;C: #define SQL_ATTR_PARAM_OPERATION_PTR 19	&gt;</body><body package="DB2EXDI">SQL_ATTR_PARAM_STATUS_PTR	&lt;C: #define SQL_ATTR_PARAM_STATUS_PTR 20	&gt;</body><body package="DB2EXDI">SQL_ATTR_PREFETCH	&lt;C: #define SQL_ATTR_PREFETCH 1285	&gt;</body><body package="DB2EXDI">SQL_ATTR_PROCESSCTL	&lt;C: #define SQL_ATTR_PROCESSCTL 1278	&gt;</body><body package="DB2EXDI">SQL_ATTR_QUERY_OPTIMIZATION_LEVEL	&lt;C: #define SQL_ATTR_QUERY_OPTIMIZATION_LEVEL 1293	&gt;</body><body package="DB2EXDI">SQL_ATTR_QUERY_PATROLLER	&lt;C: #define SQL_ATTR_QUERY_PATROLLER 2466	&gt;</body><body package="DB2EXDI">SQL_ATTR_QUERY_PATROLLER_BYPASS	&lt;C: #define SQL_ATTR_QUERY_PATROLLER_BYPASS 3	&gt;</body><body package="DB2EXDI">SQL_ATTR_QUERY_PATROLLER_DISABLE	&lt;C: #define SQL_ATTR_QUERY_PATROLLER_DISABLE 1	&gt;</body><body package="DB2EXDI">SQL_ATTR_QUERY_PATROLLER_ENABLE	&lt;C: #define SQL_ATTR_QUERY_PATROLLER_ENABLE 2	&gt;</body><body package="DB2EXDI">SQL_ATTR_QUERY_TIMEOUT	&lt;C: #define SQL_ATTR_QUERY_TIMEOUT SQL_QUERY_TIMEOUT	&gt;</body><body package="DB2EXDI">SQL_ATTR_QUIET_MODE	&lt;C: #define SQL_ATTR_QUIET_MODE SQL_QUIET_MODE	&gt;</body><body package="DB2EXDI">SQL_ATTR_READONLY	&lt;C: #define SQL_ATTR_READONLY 0	&gt;</body><body package="DB2EXDI">SQL_ATTR_READWRITE_UNKNOWN	&lt;C: #define SQL_ATTR_READWRITE_UNKNOWN 2	&gt;</body><body package="DB2EXDI">SQL_ATTR_RETRIEVE_DATA	&lt;C: #define SQL_ATTR_RETRIEVE_DATA SQL_RETRIEVE_DATA	&gt;</body><body package="DB2EXDI">SQL_ATTR_RETURN_USER_DEFINED_TYPES	&lt;C: #define SQL_ATTR_RETURN_USER_DEFINED_TYPES 2471	&gt;</body><body package="DB2EXDI">SQL_ATTR_ROWS_FETCHED_PTR	&lt;C: #define SQL_ATTR_ROWS_FETCHED_PTR 26	&gt;</body><body package="DB2EXDI">SQL_ATTR_ROW_ARRAY_SIZE	&lt;C: #define SQL_ATTR_ROW_ARRAY_SIZE 27	&gt;</body><body package="DB2EXDI">SQL_ATTR_ROW_BIND_OFFSET_PTR	&lt;C: #define SQL_ATTR_ROW_BIND_OFFSET_PTR 23	&gt;</body><body package="DB2EXDI">SQL_ATTR_ROW_BIND_TYPE	&lt;C: #define SQL_ATTR_ROW_BIND_TYPE SQL_BIND_TYPE	&gt;</body><body package="DB2EXDI">SQL_ATTR_ROW_NUMBER	&lt;C: #define SQL_ATTR_ROW_NUMBER SQL_ROW_NUMBER	&gt;</body><body package="DB2EXDI">SQL_ATTR_ROW_OPERATION_PTR	&lt;C: #define SQL_ATTR_ROW_OPERATION_PTR 24	&gt;</body><body package="DB2EXDI">SQL_ATTR_ROW_STATUS_PTR	&lt;C: #define SQL_ATTR_ROW_STATUS_PTR 25	&gt;</body><body package="DB2EXDI">SQL_ATTR_SERVER_MSGTXT_MASK	&lt;C: #define SQL_ATTR_SERVER_MSGTXT_MASK 2455	&gt;</body><body package="DB2EXDI">SQL_ATTR_SERVER_MSGTXT_MASK_ALL	&lt;C: #define SQL_ATTR_SERVER_MSGTXT_MASK_ALL 4294967295	&gt;</body><body package="DB2EXDI">SQL_ATTR_SERVER_MSGTXT_MASK_DEFAULT	&lt;C: #define SQL_ATTR_SERVER_MSGTXT_MASK_DEFAULT SQL_ATTR_SERVER_MSGTXT_MASK_LOCAL_FIRST	&gt;</body><body package="DB2EXDI">SQL_ATTR_SERVER_MSGTXT_MASK_ERRORS	&lt;C: #define SQL_ATTR_SERVER_MSGTXT_MASK_ERRORS 4294967294	&gt;</body><body package="DB2EXDI">SQL_ATTR_SERVER_MSGTXT_MASK_LOCAL_FIRST	&lt;C: #define SQL_ATTR_SERVER_MSGTXT_MASK_LOCAL_FIRST 0x00000000	&gt;</body><body package="DB2EXDI">SQL_ATTR_SERVER_MSGTXT_MASK_WARNINGS	&lt;C: #define SQL_ATTR_SERVER_MSGTXT_MASK_WARNINGS 0x00000001	&gt;</body><body package="DB2EXDI">SQL_ATTR_SERVER_MSGTXT_SP	&lt;C: #define SQL_ATTR_SERVER_MSGTXT_SP 2452	&gt;</body><body package="DB2EXDI">SQL_ATTR_SIMULATE_CURSOR	&lt;C: #define SQL_ATTR_SIMULATE_CURSOR SQL_SIMULATE_CURSOR	&gt;</body><body package="DB2EXDI">SQL_ATTR_STATICMODE	&lt;C: #define SQL_ATTR_STATICMODE 2467	&gt;</body><body package="DB2EXDI">SQL_ATTR_STMTTXN_ISOLATION	&lt;C: #define SQL_ATTR_STMTTXN_ISOLATION SQL_STMTTXN_ISOLATION	&gt;</body><body package="DB2EXDI">SQL_ATTR_SYNC_POINT	&lt;C: #define SQL_ATTR_SYNC_POINT SQL_SYNC_POINT	&gt;</body><body package="DB2EXDI">SQL_ATTR_TRACE	&lt;C: #define SQL_ATTR_TRACE SQL_OPT_TRACE	&gt;</body><body package="DB2EXDI">SQL_ATTR_TRACEFILE	&lt;C: #define SQL_ATTR_TRACEFILE SQL_OPT_TRACEFILE	&gt;</body><body package="DB2EXDI">SQL_ATTR_TRANSFORM_GROUP	&lt;C: #define SQL_ATTR_TRANSFORM_GROUP 2474	&gt;</body><body package="DB2EXDI">SQL_ATTR_TRANSLATE_LIB	&lt;C: #define SQL_ATTR_TRANSLATE_LIB SQL_TRANSLATE_DLL	&gt;</body><body package="DB2EXDI">SQL_ATTR_TRANSLATE_OPTION	&lt;C: #define SQL_ATTR_TRANSLATE_OPTION SQL_TRANSLATE_OPTION	&gt;</body><body package="DB2EXDI">SQL_ATTR_TXN_ISOLATION	&lt;C: #define SQL_ATTR_TXN_ISOLATION SQL_TXN_ISOLATION	&gt;</body><body package="DB2EXDI">SQL_ATTR_USE_2BYTES_OCTET_LENGTH	&lt;C: #define SQL_ATTR_USE_2BYTES_OCTET_LENGTH 1299	&gt;</body><body package="DB2EXDI">SQL_ATTR_USE_BOOKMARKS	&lt;C: #define SQL_ATTR_USE_BOOKMARKS SQL_USE_BOOKMARKS	&gt;</body><body package="DB2EXDI">SQL_ATTR_USE_LIGHT_INPUT_SQLDA	&lt;C: #define SQL_ATTR_USE_LIGHT_INPUT_SQLDA 2458	&gt;</body><body package="DB2EXDI">SQL_ATTR_USE_LIGHT_OUTPUT_SQLDA	&lt;C: #define SQL_ATTR_USE_LIGHT_OUTPUT_SQLDA 1298	&gt;</body><body package="DB2EXDI">SQL_ATTR_WCHARTYPE	&lt;C: #define SQL_ATTR_WCHARTYPE SQL_WCHARTYPE	&gt;</body><body package="DB2EXDI">SQL_ATTR_WRITE	&lt;C: #define SQL_ATTR_WRITE 1	&gt;</body><body package="DB2EXDI">SQL_AT_ADD_COLUMN	&lt;C: #define SQL_AT_ADD_COLUMN 0x00000001	&gt;</body><body package="DB2EXDI">SQL_AT_ADD_COLUMN_COLLATION	&lt;C: #define SQL_AT_ADD_COLUMN_COLLATION 0x00000080	&gt;</body><body package="DB2EXDI">SQL_AT_ADD_COLUMN_DEFAULT	&lt;C: #define SQL_AT_ADD_COLUMN_DEFAULT 0x00000040	&gt;</body><body package="DB2EXDI">SQL_AT_ADD_COLUMN_SINGLE	&lt;C: #define SQL_AT_ADD_COLUMN_SINGLE 0x00000020	&gt;</body><body package="DB2EXDI">SQL_AT_ADD_CONSTRAINT	&lt;C: #define SQL_AT_ADD_CONSTRAINT 0x00000008	&gt;</body><body package="DB2EXDI">SQL_AT_ADD_TABLE_CONSTRAINT	&lt;C: #define SQL_AT_ADD_TABLE_CONSTRAINT 0x00001000	&gt;</body><body package="DB2EXDI">SQL_AT_CONSTRAINT_DEFERRABLE	&lt;C: #define SQL_AT_CONSTRAINT_DEFERRABLE 0x00040000	&gt;</body><body package="DB2EXDI">SQL_AT_CONSTRAINT_INITIALLY_DEFERRED	&lt;C: #define SQL_AT_CONSTRAINT_INITIALLY_DEFERRED 0x00010000	&gt;</body><body package="DB2EXDI">SQL_AT_CONSTRAINT_INITIALLY_IMMEDIATE	&lt;C: #define SQL_AT_CONSTRAINT_INITIALLY_IMMEDIATE 0x00020000	&gt;</body><body package="DB2EXDI">SQL_AT_CONSTRAINT_NAME_DEFINITION	&lt;C: #define SQL_AT_CONSTRAINT_NAME_DEFINITION 0x00008000	&gt;</body><body package="DB2EXDI">SQL_AT_CONSTRAINT_NON_DEFERRABLE	&lt;C: #define SQL_AT_CONSTRAINT_NON_DEFERRABLE 0x00080000	&gt;</body><body package="DB2EXDI">SQL_AT_DROP_COLUMN	&lt;C: #define SQL_AT_DROP_COLUMN 0x00000002	&gt;</body><body package="DB2EXDI">SQL_AT_DROP_COLUMN_CASCADE	&lt;C: #define SQL_AT_DROP_COLUMN_CASCADE 0x00000400	&gt;</body><body package="DB2EXDI">SQL_AT_DROP_COLUMN_DEFAULT	&lt;C: #define SQL_AT_DROP_COLUMN_DEFAULT 0x00000200	&gt;</body><body package="DB2EXDI">SQL_AT_DROP_COLUMN_RESTRICT	&lt;C: #define SQL_AT_DROP_COLUMN_RESTRICT 0x00000800	&gt;</body><body package="DB2EXDI">SQL_AT_DROP_TABLE_CONSTRAINT_CASCADE	&lt;C: #define SQL_AT_DROP_TABLE_CONSTRAINT_CASCADE 0x00002000	&gt;</body><body package="DB2EXDI">SQL_AT_DROP_TABLE_CONSTRAINT_RESTRICT	&lt;C: #define SQL_AT_DROP_TABLE_CONSTRAINT_RESTRICT 0x00004000	&gt;</body><body package="DB2EXDI">SQL_AT_SET_COLUMN_DEFAULT	&lt;C: #define SQL_AT_SET_COLUMN_DEFAULT 0x00000100	&gt;</body><body package="DB2EXDI">SQL_AUTOCOMMIT	&lt;C: #define SQL_AUTOCOMMIT 102	&gt;</body><body package="DB2EXDI">SQL_AUTOCOMMIT_DEFAULT	&lt;C: #define SQL_AUTOCOMMIT_DEFAULT SQL_AUTOCOMMIT_ON	&gt;</body><body package="DB2EXDI">SQL_AUTOCOMMIT_OFF	&lt;C: #define SQL_AUTOCOMMIT_OFF 0	&gt;</body><body package="DB2EXDI">SQL_AUTOCOMMIT_ON	&lt;C: #define SQL_AUTOCOMMIT_ON 1	&gt;</body><body package="DB2EXDI">SQL_BATCH_ROW_COUNT	&lt;C: #define SQL_BATCH_ROW_COUNT 120	&gt;</body><body package="DB2EXDI">SQL_BATCH_SUPPORT	&lt;C: #define SQL_BATCH_SUPPORT 121	&gt;</body><body package="DB2EXDI">SQL_BEST_ROWID	&lt;C: #define SQL_BEST_ROWID 1	&gt;</body><body package="DB2EXDI">SQL_BIGINT	&lt;C: #define SQL_BIGINT (-5)	&gt;</body><body package="DB2EXDI">SQL_BIGINT_TYPE	&lt;C: #define SQL_BIGINT_TYPE long long	&gt;</body><body package="DB2EXDI">SQL_BIGUINT_TYPE	&lt;C: #define SQL_BIGUINT_TYPE unsigned long long	&gt;</body><body package="DB2EXDI">SQL_BINARY	&lt;C: #define SQL_BINARY (-2)	&gt;</body><body package="DB2EXDI">SQL_BIND_BY_COLUMN	&lt;C: #define SQL_BIND_BY_COLUMN 0	&gt;</body><body package="DB2EXDI">SQL_BIND_TYPE	&lt;C: #define SQL_BIND_TYPE 5	&gt;</body><body package="DB2EXDI">SQL_BIND_TYPE_DEFAULT	&lt;C: #define SQL_BIND_TYPE_DEFAULT SQL_BIND_BY_COLUMN	&gt;</body><body package="DB2EXDI">SQL_BIT	&lt;C: #define SQL_BIT (-7)	&gt;</body><body package="DB2EXDI">SQL_BLOB	&lt;C: #define SQL_BLOB -98	&gt;</body><body package="DB2EXDI">SQL_BLOB_LOCATOR	&lt;C: #define SQL_BLOB_LOCATOR 31	&gt;</body><body package="DB2EXDI">SQL_BOOKMARK_PERSISTENCE	&lt;C: #define SQL_BOOKMARK_PERSISTENCE 82	&gt;</body><body package="DB2EXDI">SQL_BP_CLOSE	&lt;C: #define SQL_BP_CLOSE 0x00000001	&gt;</body><body package="DB2EXDI">SQL_BP_DELETE	&lt;C: #define SQL_BP_DELETE 0x00000002	&gt;</body><body package="DB2EXDI">SQL_BP_DROP	&lt;C: #define SQL_BP_DROP 0x00000004	&gt;</body><body package="DB2EXDI">SQL_BP_OTHER_HSTMT	&lt;C: #define SQL_BP_OTHER_HSTMT 0x00000020	&gt;</body><body package="DB2EXDI">SQL_BP_SCROLL	&lt;C: #define SQL_BP_SCROLL 0x00000040	&gt;</body><body package="DB2EXDI">SQL_BP_TRANSACTION	&lt;C: #define SQL_BP_TRANSACTION 0x00000008	&gt;</body><body package="DB2EXDI">SQL_BP_UPDATE	&lt;C: #define SQL_BP_UPDATE 0x00000010	&gt;</body><body package="DB2EXDI">SQL_BRC_EXPLICIT	&lt;C: #define SQL_BRC_EXPLICIT 0x00000002	&gt;</body><body package="DB2EXDI">SQL_BRC_PROCEDURES	&lt;C: #define SQL_BRC_PROCEDURES 0x00000001	&gt;</body><body package="DB2EXDI">SQL_BRC_ROLLED_UP	&lt;C: #define SQL_BRC_ROLLED_UP 0x00000004	&gt;</body><body package="DB2EXDI">SQL_BS_ROW_COUNT_EXPLICIT	&lt;C: #define SQL_BS_ROW_COUNT_EXPLICIT 0x00000002	&gt;</body><body package="DB2EXDI">SQL_BS_ROW_COUNT_PROC	&lt;C: #define SQL_BS_ROW_COUNT_PROC 0x00000008	&gt;</body><body package="DB2EXDI">SQL_BS_SELECT_EXPLICIT	&lt;C: #define SQL_BS_SELECT_EXPLICIT 0x00000001	&gt;</body><body package="DB2EXDI">SQL_BS_SELECT_PROC	&lt;C: #define SQL_BS_SELECT_PROC 0x00000004	&gt;</body><body package="DB2EXDI">SQL_CA1_ABSOLUTE	&lt;C: #define SQL_CA1_ABSOLUTE 0x00000002	&gt;</body><body package="DB2EXDI">SQL_CA1_BOOKMARK	&lt;C: #define SQL_CA1_BOOKMARK 0x00000008	&gt;</body><body package="DB2EXDI">SQL_CA1_BULK_ADD	&lt;C: #define SQL_CA1_BULK_ADD 0x00010000	&gt;</body><body package="DB2EXDI">SQL_CA1_BULK_DELETE_BY_BOOKMARK	&lt;C: #define SQL_CA1_BULK_DELETE_BY_BOOKMARK 0x00040000	&gt;</body><body package="DB2EXDI">SQL_CA1_BULK_FETCH_BY_BOOKMARK	&lt;C: #define SQL_CA1_BULK_FETCH_BY_BOOKMARK 0x00080000	&gt;</body><body package="DB2EXDI">SQL_CA1_BULK_UPDATE_BY_BOOKMARK	&lt;C: #define SQL_CA1_BULK_UPDATE_BY_BOOKMARK 0x00020000	&gt;</body><body package="DB2EXDI">SQL_CA1_LOCK_EXCLUSIVE	&lt;C: #define SQL_CA1_LOCK_EXCLUSIVE 0x00000080	&gt;</body><body package="DB2EXDI">SQL_CA1_LOCK_NO_CHANGE	&lt;C: #define SQL_CA1_LOCK_NO_CHANGE 0x00000040	&gt;</body><body package="DB2EXDI">SQL_CA1_LOCK_UNLOCK	&lt;C: #define SQL_CA1_LOCK_UNLOCK 0x00000100	&gt;</body><body package="DB2EXDI">SQL_CA1_NEXT	&lt;C: #define SQL_CA1_NEXT 0x00000001	&gt;</body><body package="DB2EXDI">SQL_CA1_POSITIONED_DELETE	&lt;C: #define SQL_CA1_POSITIONED_DELETE 0x00004000	&gt;</body><body package="DB2EXDI">SQL_CA1_POSITIONED_UPDATE	&lt;C: #define SQL_CA1_POSITIONED_UPDATE 0x00002000	&gt;</body><body package="DB2EXDI">SQL_CA1_POS_DELETE	&lt;C: #define SQL_CA1_POS_DELETE 0x00000800	&gt;</body><body package="DB2EXDI">SQL_CA1_POS_POSITION	&lt;C: #define SQL_CA1_POS_POSITION 0x00000200	&gt;</body><body package="DB2EXDI">SQL_CA1_POS_REFRESH	&lt;C: #define SQL_CA1_POS_REFRESH 0x00001000	&gt;</body><body package="DB2EXDI">SQL_CA1_POS_UPDATE	&lt;C: #define SQL_CA1_POS_UPDATE 0x00000400	&gt;</body><body package="DB2EXDI">SQL_CA1_RELATIVE	&lt;C: #define SQL_CA1_RELATIVE 0x00000004	&gt;</body><body package="DB2EXDI">SQL_CA1_SELECT_FOR_UPDATE	&lt;C: #define SQL_CA1_SELECT_FOR_UPDATE 0x00008000	&gt;</body><body package="DB2EXDI">SQL_CA2_CRC_APPROXIMATE	&lt;C: #define SQL_CA2_CRC_APPROXIMATE 0x00002000	&gt;</body><body package="DB2EXDI">SQL_CA2_CRC_EXACT	&lt;C: #define SQL_CA2_CRC_EXACT 0x00001000	&gt;</body><body package="DB2EXDI">SQL_CA2_LOCK_CONCURRENCY	&lt;C: #define SQL_CA2_LOCK_CONCURRENCY 0x00000002	&gt;</body><body package="DB2EXDI">SQL_CA2_MAX_ROWS_AFFECTS_ALL	&lt;C: #define SQL_CA2_MAX_ROWS_AFFECTS_ALL (SQL_CA2_MAX_ROWS_SELECT | SQL_CA2_MAX_ROWS_INSERT | SQL_CA2_MAX_ROWS_DELETE | SQL_CA2_MAX_ROWS_UPDATE | SQL_CA2_MAX_ROWS_CATALOG)	&gt;</body><body package="DB2EXDI">SQL_CA2_MAX_ROWS_CATALOG	&lt;C: #define SQL_CA2_MAX_ROWS_CATALOG 0x00000800	&gt;</body><body package="DB2EXDI">SQL_CA2_MAX_ROWS_DELETE	&lt;C: #define SQL_CA2_MAX_ROWS_DELETE 0x00000200	&gt;</body><body package="DB2EXDI">SQL_CA2_MAX_ROWS_INSERT	&lt;C: #define SQL_CA2_MAX_ROWS_INSERT 0x00000100	&gt;</body><body package="DB2EXDI">SQL_CA2_MAX_ROWS_SELECT	&lt;C: #define SQL_CA2_MAX_ROWS_SELECT 0x00000080	&gt;</body><body package="DB2EXDI">SQL_CA2_MAX_ROWS_UPDATE	&lt;C: #define SQL_CA2_MAX_ROWS_UPDATE 0x00000400	&gt;</body><body package="DB2EXDI">SQL_CA2_OPT_ROWVER_CONCURRENCY	&lt;C: #define SQL_CA2_OPT_ROWVER_CONCURRENCY 0x00000004	&gt;</body><body package="DB2EXDI">SQL_CA2_OPT_VALUES_CONCURRENCY	&lt;C: #define SQL_CA2_OPT_VALUES_CONCURRENCY 0x00000008	&gt;</body><body package="DB2EXDI">SQL_CA2_READ_ONLY_CONCURRENCY	&lt;C: #define SQL_CA2_READ_ONLY_CONCURRENCY 0x00000001	&gt;</body><body package="DB2EXDI">SQL_CA2_SENSITIVITY_ADDITIONS	&lt;C: #define SQL_CA2_SENSITIVITY_ADDITIONS 0x00000010	&gt;</body><body package="DB2EXDI">SQL_CA2_SENSITIVITY_DELETIONS	&lt;C: #define SQL_CA2_SENSITIVITY_DELETIONS 0x00000020	&gt;</body><body package="DB2EXDI">SQL_CA2_SENSITIVITY_UPDATES	&lt;C: #define SQL_CA2_SENSITIVITY_UPDATES 0x00000040	&gt;</body><body package="DB2EXDI">SQL_CA2_SIMULATE_NON_UNIQUE	&lt;C: #define SQL_CA2_SIMULATE_NON_UNIQUE 0x00004000	&gt;</body><body package="DB2EXDI">SQL_CA2_SIMULATE_TRY_UNIQUE	&lt;C: #define SQL_CA2_SIMULATE_TRY_UNIQUE 0x00008000	&gt;</body><body package="DB2EXDI">SQL_CA2_SIMULATE_UNIQUE	&lt;C: #define SQL_CA2_SIMULATE_UNIQUE 0x00010000	&gt;</body><body package="DB2EXDI">SQL_CASCADE	&lt;C: #define SQL_CASCADE 0	&gt;</body><body package="DB2EXDI">SQL_CATALOG_LOCATION	&lt;C: #define SQL_CATALOG_LOCATION SQL_QUALIFIER_LOCATION	&gt;</body><body package="DB2EXDI">SQL_CATALOG_NAME	&lt;C: #define SQL_CATALOG_NAME 10003	&gt;</body><body package="DB2EXDI">SQL_CATALOG_NAME_SEPARATOR	&lt;C: #define SQL_CATALOG_NAME_SEPARATOR SQL_QUALIFIER_NAME_SEPARATOR	&gt;</body><body package="DB2EXDI">SQL_CATALOG_TERM	&lt;C: #define SQL_CATALOG_TERM SQL_QUALIFIER_TERM	&gt;</body><body package="DB2EXDI">SQL_CATALOG_USAGE	&lt;C: #define SQL_CATALOG_USAGE SQL_QUALIFIER_USAGE	&gt;</body><body package="DB2EXDI">SQL_CA_CONSTRAINT_DEFERRABLE	&lt;C: #define SQL_CA_CONSTRAINT_DEFERRABLE 0x00000040	&gt;</body><body package="DB2EXDI">SQL_CA_CONSTRAINT_INITIALLY_DEFERRED	&lt;C: #define SQL_CA_CONSTRAINT_INITIALLY_DEFERRED 0x00000010	&gt;</body><body package="DB2EXDI">SQL_CA_CONSTRAINT_INITIALLY_IMMEDIATE	&lt;C: #define SQL_CA_CONSTRAINT_INITIALLY_IMMEDIATE 0x00000020	&gt;</body><body package="DB2EXDI">SQL_CA_CONSTRAINT_NON_DEFERRABLE	&lt;C: #define SQL_CA_CONSTRAINT_NON_DEFERRABLE 0x00000080	&gt;</body><body package="DB2EXDI">SQL_CA_CREATE_ASSERTION	&lt;C: #define SQL_CA_CREATE_ASSERTION 0x00000001	&gt;</body><body package="DB2EXDI">SQL_CB_CLOSE	&lt;C: #define SQL_CB_CLOSE 0x0001	&gt;</body><body package="DB2EXDI">SQL_CB_DELETE	&lt;C: #define SQL_CB_DELETE 0x0000	&gt;</body><body package="DB2EXDI">SQL_CB_NON_NULL	&lt;C: #define SQL_CB_NON_NULL 0x0001	&gt;</body><body package="DB2EXDI">SQL_CB_NULL	&lt;C: #define SQL_CB_NULL 0x0000	&gt;</body><body package="DB2EXDI">SQL_CB_PRESERVE	&lt;C: #define SQL_CB_PRESERVE 0x0002	&gt;</body><body package="DB2EXDI">SQL_CCOL_CREATE_COLLATION	&lt;C: #define SQL_CCOL_CREATE_COLLATION 0x00000001	&gt;</body><body package="DB2EXDI">SQL_CCS_COLLATE_CLAUSE	&lt;C: #define SQL_CCS_COLLATE_CLAUSE 0x00000002	&gt;</body><body package="DB2EXDI">SQL_CCS_CREATE_CHARACTER_SET	&lt;C: #define SQL_CCS_CREATE_CHARACTER_SET 0x00000001	&gt;</body><body package="DB2EXDI">SQL_CCS_LIMITED_COLLATION	&lt;C: #define SQL_CCS_LIMITED_COLLATION 0x00000004	&gt;</body><body package="DB2EXDI">SQL_CC_CLOSE	&lt;C: #define SQL_CC_CLOSE SQL_CB_CLOSE	&gt;</body><body package="DB2EXDI">SQL_CC_DEFAULT	&lt;C: #define SQL_CC_DEFAULT SQL_CC_NO_RELEASE	&gt;</body><body package="DB2EXDI">SQL_CC_DELETE	&lt;C: #define SQL_CC_DELETE SQL_CB_DELETE	&gt;</body><body package="DB2EXDI">SQL_CC_NO_RELEASE	&lt;C: #define SQL_CC_NO_RELEASE 0	&gt;</body><body package="DB2EXDI">SQL_CC_PRESERVE	&lt;C: #define SQL_CC_PRESERVE SQL_CB_PRESERVE	&gt;</body><body package="DB2EXDI">SQL_CC_RELEASE	&lt;C: #define SQL_CC_RELEASE 1	&gt;</body><body package="DB2EXDI">SQL_CDO_COLLATION	&lt;C: #define SQL_CDO_COLLATION 0x00000008	&gt;</body><body package="DB2EXDI">SQL_CDO_CONSTRAINT	&lt;C: #define SQL_CDO_CONSTRAINT 0x00000004	&gt;</body><body package="DB2EXDI">SQL_CDO_CONSTRAINT_DEFERRABLE	&lt;C: #define SQL_CDO_CONSTRAINT_DEFERRABLE 0x00000080	&gt;</body><body package="DB2EXDI">SQL_CDO_CONSTRAINT_INITIALLY_DEFERRED	&lt;C: #define SQL_CDO_CONSTRAINT_INITIALLY_DEFERRED 0x00000020	&gt;</body><body package="DB2EXDI">SQL_CDO_CONSTRAINT_INITIALLY_IMMEDIATE	&lt;C: #define SQL_CDO_CONSTRAINT_INITIALLY_IMMEDIATE 0x00000040	&gt;</body><body package="DB2EXDI">SQL_CDO_CONSTRAINT_NAME_DEFINITION	&lt;C: #define SQL_CDO_CONSTRAINT_NAME_DEFINITION 0x00000010	&gt;</body><body package="DB2EXDI">SQL_CDO_CONSTRAINT_NON_DEFERRABLE	&lt;C: #define SQL_CDO_CONSTRAINT_NON_DEFERRABLE 0x00000100	&gt;</body><body package="DB2EXDI">SQL_CDO_CREATE_DOMAIN	&lt;C: #define SQL_CDO_CREATE_DOMAIN 0x00000001	&gt;</body><body package="DB2EXDI">SQL_CDO_DEFAULT	&lt;C: #define SQL_CDO_DEFAULT 0x00000002	&gt;</body><body package="DB2EXDI">SQL_CD_FALSE	&lt;C: #define SQL_CD_FALSE 0	&gt;</body><body package="DB2EXDI">SQL_CD_TRUE	&lt;C: #define SQL_CD_TRUE 1	&gt;</body><body package="DB2EXDI">SQL_CHAR	&lt;C: #define SQL_CHAR 1	&gt;</body><body package="DB2EXDI">SQL_CLI_STMT_ALTER_TABLE	&lt;C: #define SQL_CLI_STMT_ALTER_TABLE 1	&gt;</body><body package="DB2EXDI">SQL_CLI_STMT_CALL	&lt;C: #define SQL_CLI_STMT_CALL 24	&gt;</body><body package="DB2EXDI">SQL_CLI_STMT_CREATE_FUNCTION	&lt;C: #define SQL_CLI_STMT_CREATE_FUNCTION 42	&gt;</body><body package="DB2EXDI">SQL_CLI_STMT_CREATE_INDEX	&lt;C: #define SQL_CLI_STMT_CREATE_INDEX 5	&gt;</body><body package="DB2EXDI">SQL_CLI_STMT_CREATE_PROCEDURE	&lt;C: #define SQL_CLI_STMT_CREATE_PROCEDURE 41	&gt;</body><body package="DB2EXDI">SQL_CLI_STMT_CREATE_TABLE	&lt;C: #define SQL_CLI_STMT_CREATE_TABLE 6	&gt;</body><body package="DB2EXDI">SQL_CLI_STMT_CREATE_TRIGGER	&lt;C: #define SQL_CLI_STMT_CREATE_TRIGGER 34	&gt;</body><body package="DB2EXDI">SQL_CLI_STMT_CREATE_VIEW	&lt;C: #define SQL_CLI_STMT_CREATE_VIEW 7	&gt;</body><body package="DB2EXDI">SQL_CLI_STMT_DELETE_POSITIONED	&lt;C: #define SQL_CLI_STMT_DELETE_POSITIONED 9	&gt;</body><body package="DB2EXDI">SQL_CLI_STMT_DELETE_SEARCHED	&lt;C: #define SQL_CLI_STMT_DELETE_SEARCHED 8	&gt;</body><body package="DB2EXDI">SQL_CLI_STMT_DROP_INDEX	&lt;C: #define SQL_CLI_STMT_DROP_INDEX 11	&gt;</body><body package="DB2EXDI">SQL_CLI_STMT_DROP_PACKAGE	&lt;C: #define SQL_CLI_STMT_DROP_PACKAGE 10	&gt;</body><body package="DB2EXDI">SQL_CLI_STMT_DROP_TABLE	&lt;C: #define SQL_CLI_STMT_DROP_TABLE 12	&gt;</body><body package="DB2EXDI">SQL_CLI_STMT_DROP_VIEW	&lt;C: #define SQL_CLI_STMT_DROP_VIEW 13	&gt;</body><body package="DB2EXDI">SQL_CLI_STMT_GRANT	&lt;C: #define SQL_CLI_STMT_GRANT 14	&gt;</body><body package="DB2EXDI">SQL_CLI_STMT_INSERT	&lt;C: #define SQL_CLI_STMT_INSERT 15	&gt;</body><body package="DB2EXDI">SQL_CLI_STMT_REVOKE	&lt;C: #define SQL_CLI_STMT_REVOKE 16	&gt;</body><body package="DB2EXDI">SQL_CLI_STMT_SELECT	&lt;C: #define SQL_CLI_STMT_SELECT 18	&gt;</body><body package="DB2EXDI">SQL_CLI_STMT_SELECT_FOR_FETCH	&lt;C: #define SQL_CLI_STMT_SELECT_FOR_FETCH 31	&gt;</body><body package="DB2EXDI">SQL_CLI_STMT_SELECT_FOR_UPDATE	&lt;C: #define SQL_CLI_STMT_SELECT_FOR_UPDATE 29	&gt;</body><body package="DB2EXDI">SQL_CLI_STMT_SELECT_INTO	&lt;C: #define SQL_CLI_STMT_SELECT_INTO 40	&gt;</body><body package="DB2EXDI">SQL_CLI_STMT_SELECT_OPTIMIZE_FOR_NROWS	&lt;C: #define SQL_CLI_STMT_SELECT_OPTIMIZE_FOR_NROWS 39	&gt;</body><body package="DB2EXDI">SQL_CLI_STMT_SET_CURRENT_QUERY_OPT	&lt;C: #define SQL_CLI_STMT_SET_CURRENT_QUERY_OPT 46	&gt;</body><body package="DB2EXDI">SQL_CLI_STMT_UNDEFINED	&lt;C: #define SQL_CLI_STMT_UNDEFINED 0	&gt;</body><body package="DB2EXDI">SQL_CLI_STMT_UPDATE_POSITIONED	&lt;C: #define SQL_CLI_STMT_UPDATE_POSITIONED 20	&gt;</body><body package="DB2EXDI">SQL_CLI_STMT_UPDATE_SEARCHED	&lt;C: #define SQL_CLI_STMT_UPDATE_SEARCHED 19	&gt;</body><body package="DB2EXDI">SQL_CLI_STMT_VALUES	&lt;C: #define SQL_CLI_STMT_VALUES 32	&gt;</body><body package="DB2EXDI">SQL_CLI_STMT_WITH	&lt;C: #define SQL_CLI_STMT_WITH 30	&gt;</body><body package="DB2EXDI">SQL_CLOB	&lt;C: #define SQL_CLOB -99	&gt;</body><body package="DB2EXDI">SQL_CLOB_LOCATOR	&lt;C: #define SQL_CLOB_LOCATOR 41	&gt;</body><body package="DB2EXDI">SQL_CLOSE	&lt;C: #define SQL_CLOSE 0	&gt;</body><body package="DB2EXDI">SQL_CLOSE_BEHAVIOR	&lt;C: #define SQL_CLOSE_BEHAVIOR 1257	&gt;</body><body package="DB2EXDI">SQL_CL_END	&lt;C: #define SQL_CL_END SQL_QL_END	&gt;</body><body package="DB2EXDI">SQL_CL_START	&lt;C: #define SQL_CL_START SQL_QL_START	&gt;</body><body package="DB2EXDI">SQL_CMP_NA_ERRORS	&lt;C: #define SQL_CMP_NA_ERRORS 1	&gt;</body><body package="DB2EXDI">SQL_CMP_REF_INT_ROWS	&lt;C: #define SQL_CMP_REF_INT_ROWS 4	&gt;</body><body package="DB2EXDI">SQL_CMP_ROWS_AFFECTED	&lt;C: #define SQL_CMP_ROWS_AFFECTED 2	&gt;</body><body package="DB2EXDI">SQL_CMP_STMTS_COMPLETED	&lt;C: #define SQL_CMP_STMTS_COMPLETED 3	&gt;</body><body package="DB2EXDI">SQL_CN_ANY	&lt;C: #define SQL_CN_ANY 0x0002	&gt;</body><body package="DB2EXDI">SQL_CN_DIFFERENT	&lt;C: #define SQL_CN_DIFFERENT 0x0001	&gt;</body><body package="DB2EXDI">SQL_CN_NONE	&lt;C: #define SQL_CN_NONE 0x0000	&gt;</body><body package="DB2EXDI">SQL_CODE_DATE	&lt;C: #define SQL_CODE_DATE 1	&gt;</body><body package="DB2EXDI">SQL_CODE_DAY	&lt;C: #define SQL_CODE_DAY 3	&gt;</body><body package="DB2EXDI">SQL_CODE_DAY_TO_HOUR	&lt;C: #define SQL_CODE_DAY_TO_HOUR 8	&gt;</body><body package="DB2EXDI">SQL_CODE_DAY_TO_MINUTE	&lt;C: #define SQL_CODE_DAY_TO_MINUTE 9	&gt;</body><body package="DB2EXDI">SQL_CODE_DAY_TO_SECOND	&lt;C: #define SQL_CODE_DAY_TO_SECOND 10	&gt;</body><body package="DB2EXDI">SQL_CODE_HOUR	&lt;C: #define SQL_CODE_HOUR 4	&gt;</body><body package="DB2EXDI">SQL_CODE_HOUR_TO_MINUTE	&lt;C: #define SQL_CODE_HOUR_TO_MINUTE 11	&gt;</body><body package="DB2EXDI">SQL_CODE_HOUR_TO_SECOND	&lt;C: #define SQL_CODE_HOUR_TO_SECOND 12	&gt;</body><body package="DB2EXDI">SQL_CODE_MINUTE	&lt;C: #define SQL_CODE_MINUTE 5	&gt;</body><body package="DB2EXDI">SQL_CODE_MINUTE_TO_SECOND	&lt;C: #define SQL_CODE_MINUTE_TO_SECOND 13	&gt;</body><body package="DB2EXDI">SQL_CODE_MONTH	&lt;C: #define SQL_CODE_MONTH 2	&gt;</body><body package="DB2EXDI">SQL_CODE_SECOND	&lt;C: #define SQL_CODE_SECOND 6	&gt;</body><body package="DB2EXDI">SQL_CODE_TIME	&lt;C: #define SQL_CODE_TIME 2	&gt;</body><body package="DB2EXDI">SQL_CODE_TIMESTAMP	&lt;C: #define SQL_CODE_TIMESTAMP 3	&gt;</body><body package="DB2EXDI">SQL_CODE_YEAR	&lt;C: #define SQL_CODE_YEAR 1	&gt;</body><body package="DB2EXDI">SQL_CODE_YEAR_TO_MONTH	&lt;C: #define SQL_CODE_YEAR_TO_MONTH 7	&gt;</body><body package="DB2EXDI">SQL_COLATT_OPT_MAX	&lt;C: #define SQL_COLATT_OPT_MAX SQL_COLUMN_LABEL	&gt;</body><body package="DB2EXDI">SQL_COLATT_OPT_MIN	&lt;C: #define SQL_COLATT_OPT_MIN SQL_COLUMN_COUNT	&gt;</body><body package="DB2EXDI">SQL_COLLATION_SEQ	&lt;C: #define SQL_COLLATION_SEQ 10004	&gt;</body><body package="DB2EXDI">SQL_COLUMN_ALIAS	&lt;C: #define SQL_COLUMN_ALIAS 87	&gt;</body><body package="DB2EXDI">SQL_COLUMN_AUTO_INCREMENT	&lt;C: #define SQL_COLUMN_AUTO_INCREMENT 11	&gt;</body><body package="DB2EXDI">SQL_COLUMN_CASE_SENSITIVE	&lt;C: #define SQL_COLUMN_CASE_SENSITIVE 12	&gt;</body><body package="DB2EXDI">SQL_COLUMN_CATALOG_NAME	&lt;C: #define SQL_COLUMN_CATALOG_NAME 17	&gt;</body><body package="DB2EXDI">SQL_COLUMN_COUNT	&lt;C: #define SQL_COLUMN_COUNT 0	&gt;</body><body package="DB2EXDI">SQL_COLUMN_DISPLAY_SIZE	&lt;C: #define SQL_COLUMN_DISPLAY_SIZE 6	&gt;</body><body package="DB2EXDI">SQL_COLUMN_DISTINCT_TYPE	&lt;C: #define SQL_COLUMN_DISTINCT_TYPE 1250	&gt;</body><body package="DB2EXDI">SQL_COLUMN_IGNORE	&lt;C: #define SQL_COLUMN_IGNORE SQL_IGNORE	&gt;</body><body package="DB2EXDI">SQL_COLUMN_LABEL	&lt;C: #define SQL_COLUMN_LABEL 18	&gt;</body><body package="DB2EXDI">SQL_COLUMN_LENGTH	&lt;C: #define SQL_COLUMN_LENGTH 3	&gt;</body><body package="DB2EXDI">SQL_COLUMN_MONEY	&lt;C: #define SQL_COLUMN_MONEY 9	&gt;</body><body package="DB2EXDI">SQL_COLUMN_NAME	&lt;C: #define SQL_COLUMN_NAME 1	&gt;</body><body package="DB2EXDI">SQL_COLUMN_NO_COLUMN_NUMBER	&lt;C: #define SQL_COLUMN_NO_COLUMN_NUMBER (-1)	&gt;</body><body package="DB2EXDI">SQL_COLUMN_NULLABLE	&lt;C: #define SQL_COLUMN_NULLABLE 7	&gt;</body><body package="DB2EXDI">SQL_COLUMN_NUMBER_UNKNOWN	&lt;C: #define SQL_COLUMN_NUMBER_UNKNOWN (-2)	&gt;</body><body package="DB2EXDI">SQL_COLUMN_OWNER_NAME	&lt;C: #define SQL_COLUMN_OWNER_NAME 16	&gt;</body><body package="DB2EXDI">SQL_COLUMN_PRECISION	&lt;C: #define SQL_COLUMN_PRECISION 4	&gt;</body><body package="DB2EXDI">SQL_COLUMN_QUALIFIER_NAME	&lt;C: #define SQL_COLUMN_QUALIFIER_NAME 17	&gt;</body><body package="DB2EXDI">SQL_COLUMN_REFERENCE_TYPE	&lt;C: #define SQL_COLUMN_REFERENCE_TYPE 1251	&gt;</body><body package="DB2EXDI">SQL_COLUMN_SCALE	&lt;C: #define SQL_COLUMN_SCALE 5	&gt;</body><body package="DB2EXDI">SQL_COLUMN_SCHEMA_NAME	&lt;C: #define SQL_COLUMN_SCHEMA_NAME 16	&gt;</body><body package="DB2EXDI">SQL_COLUMN_SEARCHABLE	&lt;C: #define SQL_COLUMN_SEARCHABLE 13	&gt;</body><body package="DB2EXDI">SQL_COLUMN_TABLE_NAME	&lt;C: #define SQL_COLUMN_TABLE_NAME 15	&gt;</body><body package="DB2EXDI">SQL_COLUMN_TYPE	&lt;C: #define SQL_COLUMN_TYPE 2	&gt;</body><body package="DB2EXDI">SQL_COLUMN_TYPE_NAME	&lt;C: #define SQL_COLUMN_TYPE_NAME 14	&gt;</body><body package="DB2EXDI">SQL_COLUMN_UNSIGNED	&lt;C: #define SQL_COLUMN_UNSIGNED 8	&gt;</body><body package="DB2EXDI">SQL_COLUMN_UPDATABLE	&lt;C: #define SQL_COLUMN_UPDATABLE 10	&gt;</body><body package="DB2EXDI">SQL_COL_PRED_BASIC	&lt;C: #define SQL_COL_PRED_BASIC SQL_ALL_EXCEPT_LIKE	&gt;</body><body package="DB2EXDI">SQL_COL_PRED_CHAR	&lt;C: #define SQL_COL_PRED_CHAR SQL_LIKE_ONLY	&gt;</body><body package="DB2EXDI">SQL_COMMIT	&lt;C: #define SQL_COMMIT 0	&gt;</body><body package="DB2EXDI">SQL_CONCAT_NULL_BEHAVIOR	&lt;C: #define SQL_CONCAT_NULL_BEHAVIOR 22	&gt;</body><body package="DB2EXDI">SQL_CONCURRENCY	&lt;C: #define SQL_CONCURRENCY 7	&gt;</body><body package="DB2EXDI">SQL_CONCURRENT_TRANS	&lt;C: #define SQL_CONCURRENT_TRANS 1	&gt;</body><body package="DB2EXDI">SQL_CONCUR_DEFAULT	&lt;C: #define SQL_CONCUR_DEFAULT SQL_CONCUR_READ_ONLY	&gt;</body><body package="DB2EXDI">SQL_CONCUR_LOCK	&lt;C: #define SQL_CONCUR_LOCK 2	&gt;</body><body package="DB2EXDI">SQL_CONCUR_READ_ONLY	&lt;C: #define SQL_CONCUR_READ_ONLY 1	&gt;</body><body package="DB2EXDI">SQL_CONCUR_ROWVER	&lt;C: #define SQL_CONCUR_ROWVER 3	&gt;</body><body package="DB2EXDI">SQL_CONCUR_TIMESTAMP	&lt;C: #define SQL_CONCUR_TIMESTAMP SQL_CONCUR_ROWVER	&gt;</body><body package="DB2EXDI">SQL_CONCUR_VALUES	&lt;C: #define SQL_CONCUR_VALUES 4	&gt;</body><body package="DB2EXDI">SQL_CONNECTTYPE	&lt;C: #define SQL_CONNECTTYPE 1255	&gt;</body><body package="DB2EXDI">SQL_CONNECTTYPE_DEFAULT	&lt;C: #define SQL_CONNECTTYPE_DEFAULT SQL_CONCURRENT_TRANS	&gt;</body><body package="DB2EXDI">SQL_CONNECT_DB_APP2DB_CONVFACTOR	&lt;C: #define SQL_CONNECT_DB_APP2DB_CONVFACTOR 0	&gt;</body><body package="DB2EXDI">SQL_CONNECT_DB_COMMIT_TYPE	&lt;C: #define SQL_CONNECT_DB_COMMIT_TYPE 3	&gt;</body><body package="DB2EXDI">SQL_CONNECT_DB_DB2APP_CONVFACTOR	&lt;C: #define SQL_CONNECT_DB_DB2APP_CONVFACTOR 1	&gt;</body><body package="DB2EXDI">SQL_CONNECT_DB_UPDATEABILITY_IN_UOW	&lt;C: #define SQL_CONNECT_DB_UPDATEABILITY_IN_UOW 2	&gt;</body><body package="DB2EXDI">SQL_CONNECT_WITH_XA_DEFAULT	&lt;C: #define SQL_CONNECT_WITH_XA_DEFAULT SQL_CONNECT_WITH_XA_OFF	&gt;</body><body package="DB2EXDI">SQL_CONNECT_WITH_XA_OFF	&lt;C: #define SQL_CONNECT_WITH_XA_OFF 0	&gt;</body><body package="DB2EXDI">SQL_CONNECT_WITH_XA_ON	&lt;C: #define SQL_CONNECT_WITH_XA_ON 1	&gt;</body><body package="DB2EXDI">SQL_CONN_CONTEXT	&lt;C: #define SQL_CONN_CONTEXT 1269	&gt;</body><body package="DB2EXDI">SQL_CONVERT_BIGINT	&lt;C: #define SQL_CONVERT_BIGINT 53	&gt;</body><body package="DB2EXDI">SQL_CONVERT_BINARY	&lt;C: #define SQL_CONVERT_BINARY 54	&gt;</body><body package="DB2EXDI">SQL_CONVERT_BIT	&lt;C: #define SQL_CONVERT_BIT 55	&gt;</body><body package="DB2EXDI">SQL_CONVERT_CHAR	&lt;C: #define SQL_CONVERT_CHAR 56	&gt;</body><body package="DB2EXDI">SQL_CONVERT_DATE	&lt;C: #define SQL_CONVERT_DATE 57	&gt;</body><body package="DB2EXDI">SQL_CONVERT_DECIMAL	&lt;C: #define SQL_CONVERT_DECIMAL 58	&gt;</body><body package="DB2EXDI">SQL_CONVERT_DOUBLE	&lt;C: #define SQL_CONVERT_DOUBLE 59	&gt;</body><body package="DB2EXDI">SQL_CONVERT_FLOAT	&lt;C: #define SQL_CONVERT_FLOAT 60	&gt;</body><body package="DB2EXDI">SQL_CONVERT_FUNCTIONS	&lt;C: #define SQL_CONVERT_FUNCTIONS 48	&gt;</body><body package="DB2EXDI">SQL_CONVERT_INTEGER	&lt;C: #define SQL_CONVERT_INTEGER 61	&gt;</body><body package="DB2EXDI">SQL_CONVERT_INTERVAL_DAY_TIME	&lt;C: #define SQL_CONVERT_INTERVAL_DAY_TIME 123	&gt;</body><body package="DB2EXDI">SQL_CONVERT_INTERVAL_YEAR_MONTH	&lt;C: #define SQL_CONVERT_INTERVAL_YEAR_MONTH 124	&gt;</body><body package="DB2EXDI">SQL_CONVERT_LONGVARBINARY	&lt;C: #define SQL_CONVERT_LONGVARBINARY 71	&gt;</body><body package="DB2EXDI">SQL_CONVERT_LONGVARCHAR	&lt;C: #define SQL_CONVERT_LONGVARCHAR 62	&gt;</body><body package="DB2EXDI">SQL_CONVERT_NUMERIC	&lt;C: #define SQL_CONVERT_NUMERIC 63	&gt;</body><body package="DB2EXDI">SQL_CONVERT_REAL	&lt;C: #define SQL_CONVERT_REAL 64	&gt;</body><body package="DB2EXDI">SQL_CONVERT_SMALLINT	&lt;C: #define SQL_CONVERT_SMALLINT 65	&gt;</body><body package="DB2EXDI">SQL_CONVERT_TIME	&lt;C: #define SQL_CONVERT_TIME 66	&gt;</body><body package="DB2EXDI">SQL_CONVERT_TIMESTAMP	&lt;C: #define SQL_CONVERT_TIMESTAMP 67	&gt;</body><body package="DB2EXDI">SQL_CONVERT_TINYINT	&lt;C: #define SQL_CONVERT_TINYINT 68	&gt;</body><body package="DB2EXDI">SQL_CONVERT_VARBINARY	&lt;C: #define SQL_CONVERT_VARBINARY 69	&gt;</body><body package="DB2EXDI">SQL_CONVERT_VARCHAR	&lt;C: #define SQL_CONVERT_VARCHAR 70	&gt;</body><body package="DB2EXDI">SQL_CONVERT_WCHAR	&lt;C: #define SQL_CONVERT_WCHAR 122	&gt;</body><body package="DB2EXDI">SQL_CONVERT_WLONGVARCHAR	&lt;C: #define SQL_CONVERT_WLONGVARCHAR 125	&gt;</body><body package="DB2EXDI">SQL_CONVERT_WVARCHAR	&lt;C: #define SQL_CONVERT_WVARCHAR 126	&gt;</body><body package="DB2EXDI">SQL_COORDINATED_TRANS	&lt;C: #define SQL_COORDINATED_TRANS 2	&gt;</body><body package="DB2EXDI">SQL_CORRELATION_NAME	&lt;C: #define SQL_CORRELATION_NAME 74	&gt;</body><body package="DB2EXDI">SQL_CP_DEFAULT	&lt;C: #define SQL_CP_DEFAULT SQL_CP_OFF	&gt;</body><body package="DB2EXDI">SQL_CP_MATCH_DEFAULT	&lt;C: #define SQL_CP_MATCH_DEFAULT SQL_CP_STRICT_MATCH	&gt;</body><body package="DB2EXDI">SQL_CP_OFF	&lt;C: #define SQL_CP_OFF 0	&gt;</body><body package="DB2EXDI">SQL_CP_ONE_PER_DRIVER	&lt;C: #define SQL_CP_ONE_PER_DRIVER 1	&gt;</body><body package="DB2EXDI">SQL_CP_ONE_PER_HENV	&lt;C: #define SQL_CP_ONE_PER_HENV 2	&gt;</body><body package="DB2EXDI">SQL_CP_RELAXED_MATCH	&lt;C: #define SQL_CP_RELAXED_MATCH 1	&gt;</body><body package="DB2EXDI">SQL_CP_STRICT_MATCH	&lt;C: #define SQL_CP_STRICT_MATCH 0	&gt;</body><body package="DB2EXDI">SQL_CREATE_ASSERTION	&lt;C: #define SQL_CREATE_ASSERTION 127	&gt;</body><body package="DB2EXDI">SQL_CREATE_CHARACTER_SET	&lt;C: #define SQL_CREATE_CHARACTER_SET 128	&gt;</body><body package="DB2EXDI">SQL_CREATE_COLLATION	&lt;C: #define SQL_CREATE_COLLATION 129	&gt;</body><body package="DB2EXDI">SQL_CREATE_DOMAIN	&lt;C: #define SQL_CREATE_DOMAIN 130	&gt;</body><body package="DB2EXDI">SQL_CREATE_SCHEMA	&lt;C: #define SQL_CREATE_SCHEMA 131	&gt;</body><body package="DB2EXDI">SQL_CREATE_TABLE	&lt;C: #define SQL_CREATE_TABLE 132	&gt;</body><body package="DB2EXDI">SQL_CREATE_TRANSLATION	&lt;C: #define SQL_CREATE_TRANSLATION 133	&gt;</body><body package="DB2EXDI">SQL_CREATE_VIEW	&lt;C: #define SQL_CREATE_VIEW 134	&gt;</body><body package="DB2EXDI">SQL_CR_CLOSE	&lt;C: #define SQL_CR_CLOSE SQL_CB_CLOSE	&gt;</body><body package="DB2EXDI">SQL_CR_DELETE	&lt;C: #define SQL_CR_DELETE SQL_CB_DELETE	&gt;</body><body package="DB2EXDI">SQL_CR_PRESERVE	&lt;C: #define SQL_CR_PRESERVE SQL_CB_PRESERVE	&gt;</body><body package="DB2EXDI">SQL_CS_AUTHORIZATION	&lt;C: #define SQL_CS_AUTHORIZATION 0x00000002	&gt;</body><body package="DB2EXDI">SQL_CS_CREATE_SCHEMA	&lt;C: #define SQL_CS_CREATE_SCHEMA 0x00000001	&gt;</body><body package="DB2EXDI">SQL_CS_DEFAULT_CHARACTER_SET	&lt;C: #define SQL_CS_DEFAULT_CHARACTER_SET 0x00000004	&gt;</body><body package="DB2EXDI">SQL_CTR_CREATE_TRANSLATION	&lt;C: #define SQL_CTR_CREATE_TRANSLATION 0x00000001	&gt;</body><body package="DB2EXDI">SQL_CT_COLUMN_COLLATION	&lt;C: #define SQL_CT_COLUMN_COLLATION 0x00000800	&gt;</body><body package="DB2EXDI">SQL_CT_COLUMN_CONSTRAINT	&lt;C: #define SQL_CT_COLUMN_CONSTRAINT 0x00000200	&gt;</body><body package="DB2EXDI">SQL_CT_COLUMN_DEFAULT	&lt;C: #define SQL_CT_COLUMN_DEFAULT 0x00000400	&gt;</body><body package="DB2EXDI">SQL_CT_COMMIT_DELETE	&lt;C: #define SQL_CT_COMMIT_DELETE 0x00000004	&gt;</body><body package="DB2EXDI">SQL_CT_COMMIT_PRESERVE	&lt;C: #define SQL_CT_COMMIT_PRESERVE 0x00000002	&gt;</body><body package="DB2EXDI">SQL_CT_CONSTRAINT_DEFERRABLE	&lt;C: #define SQL_CT_CONSTRAINT_DEFERRABLE 0x00000080	&gt;</body><body package="DB2EXDI">SQL_CT_CONSTRAINT_INITIALLY_DEFERRED	&lt;C: #define SQL_CT_CONSTRAINT_INITIALLY_DEFERRED 0x00000020	&gt;</body><body package="DB2EXDI">SQL_CT_CONSTRAINT_INITIALLY_IMMEDIATE	&lt;C: #define SQL_CT_CONSTRAINT_INITIALLY_IMMEDIATE 0x00000040	&gt;</body><body package="DB2EXDI">SQL_CT_CONSTRAINT_NAME_DEFINITION	&lt;C: #define SQL_CT_CONSTRAINT_NAME_DEFINITION 0x00002000	&gt;</body><body package="DB2EXDI">SQL_CT_CONSTRAINT_NON_DEFERRABLE	&lt;C: #define SQL_CT_CONSTRAINT_NON_DEFERRABLE 0x00000100	&gt;</body><body package="DB2EXDI">SQL_CT_CREATE_TABLE	&lt;C: #define SQL_CT_CREATE_TABLE 0x00000001	&gt;</body><body package="DB2EXDI">SQL_CT_GLOBAL_TEMPORARY	&lt;C: #define SQL_CT_GLOBAL_TEMPORARY 0x00000008	&gt;</body><body package="DB2EXDI">SQL_CT_LOCAL_TEMPORARY	&lt;C: #define SQL_CT_LOCAL_TEMPORARY 0x00000010	&gt;</body><body package="DB2EXDI">SQL_CT_TABLE_CONSTRAINT	&lt;C: #define SQL_CT_TABLE_CONSTRAINT 0x00001000	&gt;</body><body package="DB2EXDI">SQL_CURRENT_QUALIFIER	&lt;C: #define SQL_CURRENT_QUALIFIER 109	&gt;</body><body package="DB2EXDI">SQL_CURRENT_SCHEMA	&lt;C: #define SQL_CURRENT_SCHEMA 1254	&gt;</body><body package="DB2EXDI">SQL_CURSOR_COMMIT_BEHAVIOR	&lt;C: #define SQL_CURSOR_COMMIT_BEHAVIOR 23	&gt;</body><body package="DB2EXDI">SQL_CURSOR_DYNAMIC	&lt;C: #define SQL_CURSOR_DYNAMIC 2	&gt;</body><body package="DB2EXDI">SQL_CURSOR_FORWARD_ONLY	&lt;C: #define SQL_CURSOR_FORWARD_ONLY 0	&gt;</body><body package="DB2EXDI">SQL_CURSOR_HOLD	&lt;C: #define SQL_CURSOR_HOLD 1250	&gt;</body><body package="DB2EXDI">SQL_CURSOR_HOLD_DEFAULT	&lt;C: #define SQL_CURSOR_HOLD_DEFAULT SQL_CURSOR_HOLD_ON	&gt;</body><body package="DB2EXDI">SQL_CURSOR_HOLD_OFF	&lt;C: #define SQL_CURSOR_HOLD_OFF 0	&gt;</body><body package="DB2EXDI">SQL_CURSOR_HOLD_ON	&lt;C: #define SQL_CURSOR_HOLD_ON 1	&gt;</body><body package="DB2EXDI">SQL_CURSOR_KEYSET_DRIVEN	&lt;C: #define SQL_CURSOR_KEYSET_DRIVEN 1	&gt;</body><body package="DB2EXDI">SQL_CURSOR_ROLLBACK_BEHAVIOR	&lt;C: #define SQL_CURSOR_ROLLBACK_BEHAVIOR 24	&gt;</body><body package="DB2EXDI">SQL_CURSOR_SENSITIVITY	&lt;C: #define SQL_CURSOR_SENSITIVITY 10001	&gt;</body><body package="DB2EXDI">SQL_CURSOR_STATIC	&lt;C: #define SQL_CURSOR_STATIC 3	&gt;</body><body package="DB2EXDI">SQL_CURSOR_TYPE	&lt;C: #define SQL_CURSOR_TYPE 6	&gt;</body><body package="DB2EXDI">SQL_CURSOR_TYPE_DEFAULT	&lt;C: #define SQL_CURSOR_TYPE_DEFAULT SQL_CURSOR_FORWARD_ONLY	&gt;</body><body package="DB2EXDI">SQL_CUR_DEFAULT	&lt;C: #define SQL_CUR_DEFAULT SQL_CUR_USE_DRIVER	&gt;</body><body package="DB2EXDI">SQL_CUR_USE_DRIVER	&lt;C: #define SQL_CUR_USE_DRIVER 2	&gt;</body><body package="DB2EXDI">SQL_CUR_USE_IF_NEEDED	&lt;C: #define SQL_CUR_USE_IF_NEEDED 0	&gt;</body><body package="DB2EXDI">SQL_CUR_USE_ODBC	&lt;C: #define SQL_CUR_USE_ODBC 1	&gt;</body><body package="DB2EXDI">SQL_CU_DML_STATEMENTS	&lt;C: #define SQL_CU_DML_STATEMENTS SQL_QU_DML_STATEMENTS	&gt;</body><body package="DB2EXDI">SQL_CU_INDEX_DEFINITION	&lt;C: #define SQL_CU_INDEX_DEFINITION SQL_QU_INDEX_DEFINITION	&gt;</body><body package="DB2EXDI">SQL_CU_PRIVILEGE_DEFINITION	&lt;C: #define SQL_CU_PRIVILEGE_DEFINITION SQL_QU_PRIVILEGE_DEFINITION	&gt;</body><body package="DB2EXDI">SQL_CU_PROCEDURE_INVOCATION	&lt;C: #define SQL_CU_PROCEDURE_INVOCATION SQL_QU_PROCEDURE_INVOCATION	&gt;</body><body package="DB2EXDI">SQL_CU_TABLE_DEFINITION	&lt;C: #define SQL_CU_TABLE_DEFINITION SQL_QU_TABLE_DEFINITION	&gt;</body><body package="DB2EXDI">SQL_CVT_BIGINT	&lt;C: #define SQL_CVT_BIGINT 0x00004000	&gt;</body><body package="DB2EXDI">SQL_CVT_BINARY	&lt;C: #define SQL_CVT_BINARY 0x00000400	&gt;</body><body package="DB2EXDI">SQL_CVT_BIT	&lt;C: #define SQL_CVT_BIT 0x00001000	&gt;</body><body package="DB2EXDI">SQL_CVT_CHAR	&lt;C: #define SQL_CVT_CHAR 0x00000001	&gt;</body><body package="DB2EXDI">SQL_CVT_DATE	&lt;C: #define SQL_CVT_DATE 0x00008000	&gt;</body><body package="DB2EXDI">SQL_CVT_DECIMAL	&lt;C: #define SQL_CVT_DECIMAL 0x00000004	&gt;</body><body package="DB2EXDI">SQL_CVT_DOUBLE	&lt;C: #define SQL_CVT_DOUBLE 0x00000080	&gt;</body><body package="DB2EXDI">SQL_CVT_FLOAT	&lt;C: #define SQL_CVT_FLOAT 0x00000020	&gt;</body><body package="DB2EXDI">SQL_CVT_INTEGER	&lt;C: #define SQL_CVT_INTEGER 0x00000008	&gt;</body><body package="DB2EXDI">SQL_CVT_INTERVAL_DAY_TIME	&lt;C: #define SQL_CVT_INTERVAL_DAY_TIME 0x00100000	&gt;</body><body package="DB2EXDI">SQL_CVT_INTERVAL_YEAR_MONTH	&lt;C: #define SQL_CVT_INTERVAL_YEAR_MONTH 0x00080000	&gt;</body><body package="DB2EXDI">SQL_CVT_LONGVARBINARY	&lt;C: #define SQL_CVT_LONGVARBINARY 0x00040000	&gt;</body><body package="DB2EXDI">SQL_CVT_LONGVARCHAR	&lt;C: #define SQL_CVT_LONGVARCHAR 0x00000200	&gt;</body><body package="DB2EXDI">SQL_CVT_NUMERIC	&lt;C: #define SQL_CVT_NUMERIC 0x00000002	&gt;</body><body package="DB2EXDI">SQL_CVT_REAL	&lt;C: #define SQL_CVT_REAL 0x00000040	&gt;</body><body package="DB2EXDI">SQL_CVT_SMALLINT	&lt;C: #define SQL_CVT_SMALLINT 0x00000010	&gt;</body><body package="DB2EXDI">SQL_CVT_TIME	&lt;C: #define SQL_CVT_TIME 0x00010000	&gt;</body><body package="DB2EXDI">SQL_CVT_TIMESTAMP	&lt;C: #define SQL_CVT_TIMESTAMP 0x00020000	&gt;</body><body package="DB2EXDI">SQL_CVT_TINYINT	&lt;C: #define SQL_CVT_TINYINT 0x00002000	&gt;</body><body package="DB2EXDI">SQL_CVT_VARBINARY	&lt;C: #define SQL_CVT_VARBINARY 0x00000800	&gt;</body><body package="DB2EXDI">SQL_CVT_VARCHAR	&lt;C: #define SQL_CVT_VARCHAR 0x00000100	&gt;</body><body package="DB2EXDI">SQL_CVT_WCHAR	&lt;C: #define SQL_CVT_WCHAR 0x00200000	&gt;</body><body package="DB2EXDI">SQL_CVT_WLONGVARCHAR	&lt;C: #define SQL_CVT_WLONGVARCHAR 0x00400000	&gt;</body><body package="DB2EXDI">SQL_CVT_WVARCHAR	&lt;C: #define SQL_CVT_WVARCHAR 0x00800000	&gt;</body><body package="DB2EXDI">SQL_CV_CASCADED	&lt;C: #define SQL_CV_CASCADED 0x00000004	&gt;</body><body package="DB2EXDI">SQL_CV_CHECK_OPTION	&lt;C: #define SQL_CV_CHECK_OPTION 0x00000002	&gt;</body><body package="DB2EXDI">SQL_CV_CREATE_VIEW	&lt;C: #define SQL_CV_CREATE_VIEW 0x00000001	&gt;</body><body package="DB2EXDI">SQL_CV_LOCAL	&lt;C: #define SQL_CV_LOCAL 0x00000008	&gt;</body><body package="DB2EXDI">SQL_C_BINARY	&lt;C: #define SQL_C_BINARY SQL_BINARY	&gt;</body><body package="DB2EXDI">SQL_C_BIT	&lt;C: #define SQL_C_BIT SQL_BIT	&gt;</body><body package="DB2EXDI">SQL_C_BLOB_LOCATOR	&lt;C: #define SQL_C_BLOB_LOCATOR SQL_BLOB_LOCATOR	&gt;</body><body package="DB2EXDI">SQL_C_BOOKMARK	&lt;C: #define SQL_C_BOOKMARK SQL_C_ULONG	&gt;</body><body package="DB2EXDI">SQL_C_CHAR	&lt;C: #define SQL_C_CHAR SQL_CHAR	&gt;</body><body package="DB2EXDI">SQL_C_CLOB_LOCATOR	&lt;C: #define SQL_C_CLOB_LOCATOR SQL_CLOB_LOCATOR	&gt;</body><body package="DB2EXDI">SQL_C_DATALINK	&lt;C: #define SQL_C_DATALINK SQL_C_CHAR	&gt;</body><body package="DB2EXDI">SQL_C_DATE	&lt;C: #define SQL_C_DATE SQL_DATE	&gt;</body><body package="DB2EXDI">SQL_C_DBCHAR	&lt;C: #define SQL_C_DBCHAR SQL_DBCLOB	&gt;</body><body package="DB2EXDI">SQL_C_DBCLOB_LOCATOR	&lt;C: #define SQL_C_DBCLOB_LOCATOR SQL_DBCLOB_LOCATOR	&gt;</body><body package="DB2EXDI">SQL_C_DECIMAL_IBM	&lt;C: #define SQL_C_DECIMAL_IBM SQL_DECIMAL	&gt;</body><body package="DB2EXDI">SQL_C_DEFAULT	&lt;C: #define SQL_C_DEFAULT 99	&gt;</body><body package="DB2EXDI">SQL_C_DOUBLE	&lt;C: #define SQL_C_DOUBLE SQL_DOUBLE	&gt;</body><body package="DB2EXDI">SQL_C_FLOAT	&lt;C: #define SQL_C_FLOAT SQL_REAL	&gt;</body><body package="DB2EXDI">SQL_C_INTERVAL_DAY	&lt;C: #define SQL_C_INTERVAL_DAY SQL_INTERVAL_DAY	&gt;</body><body package="DB2EXDI">SQL_C_INTERVAL_DAY_TO_HOUR	&lt;C: #define SQL_C_INTERVAL_DAY_TO_HOUR SQL_INTERVAL_DAY_TO_HOUR	&gt;</body><body package="DB2EXDI">SQL_C_INTERVAL_DAY_TO_MINUTE	&lt;C: #define SQL_C_INTERVAL_DAY_TO_MINUTE SQL_INTERVAL_DAY_TO_MINUTE	&gt;</body><body package="DB2EXDI">SQL_C_INTERVAL_DAY_TO_SECOND	&lt;C: #define SQL_C_INTERVAL_DAY_TO_SECOND SQL_INTERVAL_DAY_TO_SECOND	&gt;</body><body package="DB2EXDI">SQL_C_INTERVAL_HOUR	&lt;C: #define SQL_C_INTERVAL_HOUR SQL_INTERVAL_HOUR	&gt;</body><body package="DB2EXDI">SQL_C_INTERVAL_HOUR_TO_MINUTE	&lt;C: #define SQL_C_INTERVAL_HOUR_TO_MINUTE SQL_INTERVAL_HOUR_TO_MINUTE	&gt;</body><body package="DB2EXDI">SQL_C_INTERVAL_HOUR_TO_SECOND	&lt;C: #define SQL_C_INTERVAL_HOUR_TO_SECOND SQL_INTERVAL_HOUR_TO_SECOND	&gt;</body><body package="DB2EXDI">SQL_C_INTERVAL_MINUTE	&lt;C: #define SQL_C_INTERVAL_MINUTE SQL_INTERVAL_MINUTE	&gt;</body><body package="DB2EXDI">SQL_C_INTERVAL_MINUTE_TO_SECOND	&lt;C: #define SQL_C_INTERVAL_MINUTE_TO_SECOND SQL_INTERVAL_MINUTE_TO_SECOND	&gt;</body><body package="DB2EXDI">SQL_C_INTERVAL_MONTH	&lt;C: #define SQL_C_INTERVAL_MONTH SQL_INTERVAL_MONTH	&gt;</body><body package="DB2EXDI">SQL_C_INTERVAL_SECOND	&lt;C: #define SQL_C_INTERVAL_SECOND SQL_INTERVAL_SECOND	&gt;</body><body package="DB2EXDI">SQL_C_INTERVAL_YEAR	&lt;C: #define SQL_C_INTERVAL_YEAR SQL_INTERVAL_YEAR	&gt;</body><body package="DB2EXDI">SQL_C_INTERVAL_YEAR_TO_MONTH	&lt;C: #define SQL_C_INTERVAL_YEAR_TO_MONTH SQL_INTERVAL_YEAR_TO_MONTH	&gt;</body><body package="DB2EXDI">SQL_C_LONG	&lt;C: #define SQL_C_LONG SQL_INTEGER	&gt;</body><body package="DB2EXDI">SQL_C_NUMERIC	&lt;C: #define SQL_C_NUMERIC SQL_NUMERIC	&gt;</body><body package="DB2EXDI">SQL_C_PTR	&lt;C: #define SQL_C_PTR 2463	&gt;</body><body package="DB2EXDI">SQL_C_SBIGINT	&lt;C: #define SQL_C_SBIGINT (SQL_BIGINT+SQL_SIGNED_OFFSET)	&gt;</body><body package="DB2EXDI">SQL_C_SHORT	&lt;C: #define SQL_C_SHORT SQL_SMALLINT	&gt;</body><body package="DB2EXDI">SQL_C_SLONG	&lt;C: #define SQL_C_SLONG (SQL_C_LONG+SQL_SIGNED_OFFSET)	&gt;</body><body package="DB2EXDI">SQL_C_SSHORT	&lt;C: #define SQL_C_SSHORT (SQL_C_SHORT+SQL_SIGNED_OFFSET)	&gt;</body><body package="DB2EXDI">SQL_C_STINYINT	&lt;C: #define SQL_C_STINYINT (SQL_TINYINT+SQL_SIGNED_OFFSET)	&gt;</body><body package="DB2EXDI">SQL_C_TCHAR	&lt;C: #define SQL_C_TCHAR SQL_C_CHAR	&gt;</body><body package="DB2EXDI">SQL_C_TIME	&lt;C: #define SQL_C_TIME SQL_TIME	&gt;</body><body package="DB2EXDI">SQL_C_TIMESTAMP	&lt;C: #define SQL_C_TIMESTAMP SQL_TIMESTAMP	&gt;</body><body package="DB2EXDI">SQL_C_TINYINT	&lt;C: #define SQL_C_TINYINT SQL_TINYINT	&gt;</body><body package="DB2EXDI">SQL_C_TYPE_DATE	&lt;C: #define SQL_C_TYPE_DATE SQL_TYPE_DATE	&gt;</body><body package="DB2EXDI">SQL_C_TYPE_TIME	&lt;C: #define SQL_C_TYPE_TIME SQL_TYPE_TIME	&gt;</body><body package="DB2EXDI">SQL_C_TYPE_TIMESTAMP	&lt;C: #define SQL_C_TYPE_TIMESTAMP SQL_TYPE_TIMESTAMP	&gt;</body><body package="DB2EXDI">SQL_C_UBIGINT	&lt;C: #define SQL_C_UBIGINT (SQL_BIGINT+SQL_UNSIGNED_OFFSET)	&gt;</body><body package="DB2EXDI">SQL_C_ULONG	&lt;C: #define SQL_C_ULONG (SQL_C_LONG+SQL_UNSIGNED_OFFSET)	&gt;</body><body package="DB2EXDI">SQL_C_USHORT	&lt;C: #define SQL_C_USHORT (SQL_C_SHORT+SQL_UNSIGNED_OFFSET)	&gt;</body><body package="DB2EXDI">SQL_C_UTINYINT	&lt;C: #define SQL_C_UTINYINT (SQL_TINYINT+SQL_UNSIGNED_OFFSET)	&gt;</body><body package="DB2EXDI">SQL_C_VARBOOKMARK	&lt;C: #define SQL_C_VARBOOKMARK SQL_C_BINARY	&gt;</body><body package="DB2EXDI">SQL_C_WCHAR	&lt;C: #define SQL_C_WCHAR SQL_WCHAR	&gt;</body><body package="DB2EXDI">SQL_DATABASE_NAME	&lt;C: #define SQL_DATABASE_NAME 16	&gt;</body><body package="DB2EXDI">SQL_DATALINK	&lt;C: #define SQL_DATALINK -400	&gt;</body><body package="DB2EXDI">SQL_DATALINK_URL	&lt;C: #define SQL_DATALINK_URL "URL"	&gt;</body><body package="DB2EXDI">SQL_DATA_AT_EXEC	&lt;C: #define SQL_DATA_AT_EXEC -2	&gt;</body><body package="DB2EXDI">SQL_DATA_SOURCE_NAME	&lt;C: #define SQL_DATA_SOURCE_NAME 2	&gt;</body><body package="DB2EXDI">SQL_DATA_SOURCE_READ_ONLY	&lt;C: #define SQL_DATA_SOURCE_READ_ONLY 25	&gt;</body><body package="DB2EXDI">SQL_DATE	&lt;C: #define SQL_DATE 9	&gt;</body><body package="DB2EXDI">SQL_DATETIME	&lt;C: #define SQL_DATETIME 9	&gt;</body><body package="DB2EXDI">SQL_DATETIME_LITERALS	&lt;C: #define SQL_DATETIME_LITERALS 119	&gt;</body><body package="DB2EXDI">SQL_DATE_LEN	&lt;C: #define SQL_DATE_LEN 10	&gt;</body><body package="DB2EXDI">SQL_DA_DROP_ASSERTION	&lt;C: #define SQL_DA_DROP_ASSERTION 0x00000001	&gt;</body><body package="DB2EXDI">SQL_DB2ESTIMATE	&lt;C: #define SQL_DB2ESTIMATE 1259	&gt;</body><body package="DB2EXDI">SQL_DB2ESTIMATE_DEFAULT	&lt;C: #define SQL_DB2ESTIMATE_DEFAULT SQL_DB2ESTIMATE_OFF	&gt;</body><body package="DB2EXDI">SQL_DB2ESTIMATE_OFF	&lt;C: #define SQL_DB2ESTIMATE_OFF 0	&gt;</body><body package="DB2EXDI">SQL_DB2ESTIMATE_ON	&lt;C: #define SQL_DB2ESTIMATE_ON 1	&gt;</body><body package="DB2EXDI">SQL_DB2EXPLAIN	&lt;C: #define SQL_DB2EXPLAIN 1258	&gt;</body><body package="DB2EXDI">SQL_DB2EXPLAIN_DEFAULT	&lt;C: #define SQL_DB2EXPLAIN_DEFAULT SQL_DB2EXPLAIN_OFF	&gt;</body><body package="DB2EXDI">SQL_DB2EXPLAIN_MODE_ON	&lt;C: #define SQL_DB2EXPLAIN_MODE_ON 0x00000002	&gt;</body><body package="DB2EXDI">SQL_DB2EXPLAIN_OFF	&lt;C: #define SQL_DB2EXPLAIN_OFF 0x00000000	&gt;</body><body package="DB2EXDI">SQL_DB2EXPLAIN_ON	&lt;C: #define SQL_DB2EXPLAIN_ON SQL_DB2EXPLAIN_SNAPSHOT_ON	&gt;</body><body package="DB2EXDI">SQL_DB2EXPLAIN_SNAPSHOT_MODE_ON	&lt;C: #define SQL_DB2EXPLAIN_SNAPSHOT_MODE_ON SQL_DB2EXPLAIN_SNAPSHOT_ON+SQL_DB2EXPLAIN_MODE_ON	&gt;</body><body package="DB2EXDI">SQL_DB2EXPLAIN_SNAPSHOT_ON	&lt;C: #define SQL_DB2EXPLAIN_SNAPSHOT_ON 0x00000001	&gt;</body><body package="DB2EXDI">SQL_DBCLOB	&lt;C: #define SQL_DBCLOB -350	&gt;</body><body package="DB2EXDI">SQL_DBCLOB_LOCATOR	&lt;C: #define SQL_DBCLOB_LOCATOR -351	&gt;</body><body package="DB2EXDI">SQL_DBMS_NAME	&lt;C: #define SQL_DBMS_NAME 17	&gt;</body><body package="DB2EXDI">SQL_DBMS_VER	&lt;C: #define SQL_DBMS_VER 18	&gt;</body><body package="DB2EXDI">SQL_DB_DEFAULT	&lt;C: #define SQL_DB_DEFAULT SQL_DB_RETURN_TO_POOL	&gt;</body><body package="DB2EXDI">SQL_DB_DISCONNECT	&lt;C: #define SQL_DB_DISCONNECT 1	&gt;</body><body package="DB2EXDI">SQL_DB_ONE_PHASE_COMMIT	&lt;C: #define SQL_DB_ONE_PHASE_COMMIT 1	&gt;</body><body package="DB2EXDI">SQL_DB_ONE_PHASE_READ_ONLY	&lt;C: #define SQL_DB_ONE_PHASE_READ_ONLY 2	&gt;</body><body package="DB2EXDI">SQL_DB_READ_ONLY	&lt;C: #define SQL_DB_READ_ONLY 2	&gt;</body><body package="DB2EXDI">SQL_DB_RETURN_TO_POOL	&lt;C: #define SQL_DB_RETURN_TO_POOL 0	&gt;</body><body package="DB2EXDI">SQL_DB_TWO_PHASE_COMMIT	&lt;C: #define SQL_DB_TWO_PHASE_COMMIT 3	&gt;</body><body package="DB2EXDI">SQL_DB_UPDATEABLE	&lt;C: #define SQL_DB_UPDATEABLE 1	&gt;</body><body package="DB2EXDI">SQL_DCS_DROP_CHARACTER_SET	&lt;C: #define SQL_DCS_DROP_CHARACTER_SET 0x00000001	&gt;</body><body package="DB2EXDI">SQL_DC_DROP_COLLATION	&lt;C: #define SQL_DC_DROP_COLLATION 0x00000001	&gt;</body><body package="DB2EXDI">SQL_DDL_INDEX	&lt;C: #define SQL_DDL_INDEX 170	&gt;</body><body package="DB2EXDI">SQL_DD_CASCADE	&lt;C: #define SQL_DD_CASCADE 0x00000004	&gt;</body><body package="DB2EXDI">SQL_DD_DROP_DOMAIN	&lt;C: #define SQL_DD_DROP_DOMAIN 0x00000001	&gt;</body><body package="DB2EXDI">SQL_DD_RESTRICT	&lt;C: #define SQL_DD_RESTRICT 0x00000002	&gt;</body><body package="DB2EXDI">SQL_DECIMAL	&lt;C: #define SQL_DECIMAL 3	&gt;</body><body package="DB2EXDI">SQL_DEFAULT	&lt;C: #define SQL_DEFAULT 99	&gt;</body><body package="DB2EXDI">SQL_DEFAULT_PARAM	&lt;C: #define SQL_DEFAULT_PARAM (-5)	&gt;</body><body package="DB2EXDI">SQL_DEFAULT_TXN_ISOLATION	&lt;C: #define SQL_DEFAULT_TXN_ISOLATION 26	&gt;</body><body package="DB2EXDI">SQL_DEFERRED_PREPARE_DEFAULT	&lt;C: #define SQL_DEFERRED_PREPARE_DEFAULT SQL_DEFERRED_PREPARE_ON	&gt;</body><body package="DB2EXDI">SQL_DEFERRED_PREPARE_OFF	&lt;C: #define SQL_DEFERRED_PREPARE_OFF 0	&gt;</body><body package="DB2EXDI">SQL_DEFERRED_PREPARE_ON	&lt;C: #define SQL_DEFERRED_PREPARE_ON 1	&gt;</body><body package="DB2EXDI">SQL_DELETE	&lt;C: #define SQL_DELETE 3	&gt;</body><body package="DB2EXDI">SQL_DELETE_BY_BOOKMARK	&lt;C: #define SQL_DELETE_BY_BOOKMARK 6	&gt;</body><body package="DB2EXDI">SQL_DESCRIBE_PARAMETER	&lt;C: #define SQL_DESCRIBE_PARAMETER 10002	&gt;</body><body package="DB2EXDI">SQL_DESC_ALLOC_AUTO	&lt;C: #define SQL_DESC_ALLOC_AUTO 1	&gt;</body><body package="DB2EXDI">SQL_DESC_ALLOC_TYPE	&lt;C: #define SQL_DESC_ALLOC_TYPE 1099	&gt;</body><body package="DB2EXDI">SQL_DESC_ALLOC_USER	&lt;C: #define SQL_DESC_ALLOC_USER 2	&gt;</body><body package="DB2EXDI">SQL_DESC_ARRAY_SIZE	&lt;C: #define SQL_DESC_ARRAY_SIZE 20	&gt;</body><body package="DB2EXDI">SQL_DESC_ARRAY_STATUS_PTR	&lt;C: #define SQL_DESC_ARRAY_STATUS_PTR 21	&gt;</body><body package="DB2EXDI">SQL_DESC_AUTO_UNIQUE_VALUE	&lt;C: #define SQL_DESC_AUTO_UNIQUE_VALUE SQL_COLUMN_AUTO_INCREMENT	&gt;</body><body package="DB2EXDI">SQL_DESC_BASE_COLUMN_NAME	&lt;C: #define SQL_DESC_BASE_COLUMN_NAME 22	&gt;</body><body package="DB2EXDI">SQL_DESC_BASE_TABLE_NAME	&lt;C: #define SQL_DESC_BASE_TABLE_NAME 23	&gt;</body><body package="DB2EXDI">SQL_DESC_BASE_TYPE	&lt;C: #define SQL_DESC_BASE_TYPE 1254	&gt;</body><body package="DB2EXDI">SQL_DESC_BIND_OFFSET_PTR	&lt;C: #define SQL_DESC_BIND_OFFSET_PTR 24	&gt;</body><body package="DB2EXDI">SQL_DESC_BIND_TYPE	&lt;C: #define SQL_DESC_BIND_TYPE 25	&gt;</body><body package="DB2EXDI">SQL_DESC_CASE_SENSITIVE	&lt;C: #define SQL_DESC_CASE_SENSITIVE SQL_COLUMN_CASE_SENSITIVE	&gt;</body><body package="DB2EXDI">SQL_DESC_CATALOG_NAME	&lt;C: #define SQL_DESC_CATALOG_NAME SQL_COLUMN_QUALIFIER_NAME	&gt;</body><body package="DB2EXDI">SQL_DESC_CONCISE_TYPE	&lt;C: #define SQL_DESC_CONCISE_TYPE SQL_COLUMN_TYPE	&gt;</body><body package="DB2EXDI">SQL_DESC_COUNT	&lt;C: #define SQL_DESC_COUNT 1001	&gt;</body><body package="DB2EXDI">SQL_DESC_DATA_PTR	&lt;C: #define SQL_DESC_DATA_PTR 1010	&gt;</body><body package="DB2EXDI">SQL_DESC_DATETIME_INTERVAL_CODE	&lt;C: #define SQL_DESC_DATETIME_INTERVAL_CODE 1007	&gt;</body><body package="DB2EXDI">SQL_DESC_DATETIME_INTERVAL_PRECISION	&lt;C: #define SQL_DESC_DATETIME_INTERVAL_PRECISION 26	&gt;</body><body package="DB2EXDI">SQL_DESC_DESCRIPTOR_TYPE	&lt;C: #define SQL_DESC_DESCRIPTOR_TYPE 1287	&gt;</body><body package="DB2EXDI">SQL_DESC_DISPLAY_SIZE	&lt;C: #define SQL_DESC_DISPLAY_SIZE SQL_COLUMN_DISPLAY_SIZE	&gt;</body><body package="DB2EXDI">SQL_DESC_DISTINCT_TYPE	&lt;C: #define SQL_DESC_DISTINCT_TYPE SQL_COLUMN_DISTINCT_TYPE	&gt;</body><body package="DB2EXDI">SQL_DESC_FIXED_PREC_SCALE	&lt;C: #define SQL_DESC_FIXED_PREC_SCALE SQL_COLUMN_MONEY	&gt;</body><body package="DB2EXDI">SQL_DESC_INDICATOR_PTR	&lt;C: #define SQL_DESC_INDICATOR_PTR 1009	&gt;</body><body package="DB2EXDI">SQL_DESC_LABEL	&lt;C: #define SQL_DESC_LABEL SQL_COLUMN_LABEL	&gt;</body><body package="DB2EXDI">SQL_DESC_LENGTH	&lt;C: #define SQL_DESC_LENGTH 1003	&gt;</body><body package="DB2EXDI">SQL_DESC_LITERAL_PREFIX	&lt;C: #define SQL_DESC_LITERAL_PREFIX 27	&gt;</body><body package="DB2EXDI">SQL_DESC_LITERAL_SUFFIX	&lt;C: #define SQL_DESC_LITERAL_SUFFIX 28	&gt;</body><body package="DB2EXDI">SQL_DESC_LOCAL_TYPE_NAME	&lt;C: #define SQL_DESC_LOCAL_TYPE_NAME 29	&gt;</body><body package="DB2EXDI">SQL_DESC_MAXIMUM_SCALE	&lt;C: #define SQL_DESC_MAXIMUM_SCALE 30	&gt;</body><body package="DB2EXDI">SQL_DESC_MINIMUM_SCALE	&lt;C: #define SQL_DESC_MINIMUM_SCALE 31	&gt;</body><body package="DB2EXDI">SQL_DESC_NAME	&lt;C: #define SQL_DESC_NAME 1011	&gt;</body><body package="DB2EXDI">SQL_DESC_NULLABLE	&lt;C: #define SQL_DESC_NULLABLE 1008	&gt;</body><body package="DB2EXDI">SQL_DESC_NUM_PREC_RADIX	&lt;C: #define SQL_DESC_NUM_PREC_RADIX 32	&gt;</body><body package="DB2EXDI">SQL_DESC_OCTET_LENGTH	&lt;C: #define SQL_DESC_OCTET_LENGTH 1013	&gt;</body><body package="DB2EXDI">SQL_DESC_OCTET_LENGTH_PTR	&lt;C: #define SQL_DESC_OCTET_LENGTH_PTR 1004	&gt;</body><body package="DB2EXDI">SQL_DESC_PARAMETER_TYPE	&lt;C: #define SQL_DESC_PARAMETER_TYPE 33	&gt;</body><body package="DB2EXDI">SQL_DESC_PRECISION	&lt;C: #define SQL_DESC_PRECISION 1005	&gt;</body><body package="DB2EXDI">SQL_DESC_REFERENCE_TYPE	&lt;C: #define SQL_DESC_REFERENCE_TYPE SQL_COLUMN_REFERENCE_TYPE	&gt;</body><body package="DB2EXDI">SQL_DESC_ROWS_PROCESSED_PTR	&lt;C: #define SQL_DESC_ROWS_PROCESSED_PTR 34	&gt;</body><body package="DB2EXDI">SQL_DESC_SCALE	&lt;C: #define SQL_DESC_SCALE 1006	&gt;</body><body package="DB2EXDI">SQL_DESC_SCHEMA_NAME	&lt;C: #define SQL_DESC_SCHEMA_NAME SQL_COLUMN_OWNER_NAME	&gt;</body><body package="DB2EXDI">SQL_DESC_SEARCHABLE	&lt;C: #define SQL_DESC_SEARCHABLE SQL_COLUMN_SEARCHABLE	&gt;</body><body package="DB2EXDI">SQL_DESC_STRUCTURED_TYPE	&lt;C: #define SQL_DESC_STRUCTURED_TYPE 1252	&gt;</body><body package="DB2EXDI">SQL_DESC_TABLE_NAME	&lt;C: #define SQL_DESC_TABLE_NAME SQL_COLUMN_TABLE_NAME	&gt;</body><body package="DB2EXDI">SQL_DESC_TYPE	&lt;C: #define SQL_DESC_TYPE 1002	&gt;</body><body package="DB2EXDI">SQL_DESC_TYPE_NAME	&lt;C: #define SQL_DESC_TYPE_NAME SQL_COLUMN_TYPE_NAME	&gt;</body><body package="DB2EXDI">SQL_DESC_UNNAMED	&lt;C: #define SQL_DESC_UNNAMED 1012	&gt;</body><body package="DB2EXDI">SQL_DESC_UNSIGNED	&lt;C: #define SQL_DESC_UNSIGNED SQL_COLUMN_UNSIGNED	&gt;</body><body package="DB2EXDI">SQL_DESC_UPDATABLE	&lt;C: #define SQL_DESC_UPDATABLE SQL_COLUMN_UPDATABLE	&gt;</body><body package="DB2EXDI">SQL_DESC_USER_DEFINED_TYPE_CODE	&lt;C: #define SQL_DESC_USER_DEFINED_TYPE_CODE 1098	&gt;</body><body package="DB2EXDI">SQL_DESC_USER_TYPE	&lt;C: #define SQL_DESC_USER_TYPE 1253	&gt;</body><body package="DB2EXDI">SQL_DIAG_ALTER_TABLE	&lt;C: #define SQL_DIAG_ALTER_TABLE 4	&gt;</body><body package="DB2EXDI">SQL_DIAG_CALL	&lt;C: #define SQL_DIAG_CALL 7	&gt;</body><body package="DB2EXDI">SQL_DIAG_CLASS_ORIGIN	&lt;C: #define SQL_DIAG_CLASS_ORIGIN 8	&gt;</body><body package="DB2EXDI">SQL_DIAG_COLUMN_NUMBER	&lt;C: #define SQL_DIAG_COLUMN_NUMBER (-1247)	&gt;</body><body package="DB2EXDI">SQL_DIAG_CONNECTION_NAME	&lt;C: #define SQL_DIAG_CONNECTION_NAME 10	&gt;</body><body package="DB2EXDI">SQL_DIAG_CREATE_INDEX	&lt;C: #define SQL_DIAG_CREATE_INDEX (-1)	&gt;</body><body package="DB2EXDI">SQL_DIAG_CREATE_TABLE	&lt;C: #define SQL_DIAG_CREATE_TABLE 77	&gt;</body><body package="DB2EXDI">SQL_DIAG_CREATE_VIEW	&lt;C: #define SQL_DIAG_CREATE_VIEW 84	&gt;</body><body package="DB2EXDI">SQL_DIAG_CURSOR_ROW_COUNT	&lt;C: #define SQL_DIAG_CURSOR_ROW_COUNT (-1249)	&gt;</body><body package="DB2EXDI">SQL_DIAG_DEFERRED_PREPARE_ERROR	&lt;C: #define SQL_DIAG_DEFERRED_PREPARE_ERROR 1279	&gt;</body><body package="DB2EXDI">SQL_DIAG_DELETE_WHERE	&lt;C: #define SQL_DIAG_DELETE_WHERE 19	&gt;</body><body package="DB2EXDI">SQL_DIAG_DROP_INDEX	&lt;C: #define SQL_DIAG_DROP_INDEX (-2)	&gt;</body><body package="DB2EXDI">SQL_DIAG_DROP_TABLE	&lt;C: #define SQL_DIAG_DROP_TABLE 32	&gt;</body><body package="DB2EXDI">SQL_DIAG_DROP_VIEW	&lt;C: #define SQL_DIAG_DROP_VIEW 36	&gt;</body><body package="DB2EXDI">SQL_DIAG_DYNAMIC_DELETE_CURSOR	&lt;C: #define SQL_DIAG_DYNAMIC_DELETE_CURSOR 38	&gt;</body><body package="DB2EXDI">SQL_DIAG_DYNAMIC_FUNCTION	&lt;C: #define SQL_DIAG_DYNAMIC_FUNCTION 7	&gt;</body><body package="DB2EXDI">SQL_DIAG_DYNAMIC_FUNCTION_CODE	&lt;C: #define SQL_DIAG_DYNAMIC_FUNCTION_CODE 12	&gt;</body><body package="DB2EXDI">SQL_DIAG_DYNAMIC_UPDATE_CURSOR	&lt;C: #define SQL_DIAG_DYNAMIC_UPDATE_CURSOR 81	&gt;</body><body package="DB2EXDI">SQL_DIAG_ERRMC	&lt;C: #define SQL_DIAG_ERRMC 2467	&gt;</body><body package="DB2EXDI">SQL_DIAG_GRANT	&lt;C: #define SQL_DIAG_GRANT 48	&gt;</body><body package="DB2EXDI">SQL_DIAG_INSERT	&lt;C: #define SQL_DIAG_INSERT 50	&gt;</body><body package="DB2EXDI">SQL_DIAG_LINE_NUMBER	&lt;C: #define SQL_DIAG_LINE_NUMBER 2461	&gt;</body><body package="DB2EXDI">SQL_DIAG_MESSAGE_TEXT	&lt;C: #define SQL_DIAG_MESSAGE_TEXT 6	&gt;</body><body package="DB2EXDI">SQL_DIAG_MESSAGE_TEXT_PTR	&lt;C: #define SQL_DIAG_MESSAGE_TEXT_PTR 2456	&gt;</body><body package="DB2EXDI">SQL_DIAG_NATIVE	&lt;C: #define SQL_DIAG_NATIVE 5	&gt;</body><body package="DB2EXDI">SQL_DIAG_NUMBER	&lt;C: #define SQL_DIAG_NUMBER 2	&gt;</body><body package="DB2EXDI">SQL_DIAG_RETURNCODE	&lt;C: #define SQL_DIAG_RETURNCODE 1	&gt;</body><body package="DB2EXDI">SQL_DIAG_REVOKE	&lt;C: #define SQL_DIAG_REVOKE 59	&gt;</body><body package="DB2EXDI">SQL_DIAG_ROW_COUNT	&lt;C: #define SQL_DIAG_ROW_COUNT 3	&gt;</body><body package="DB2EXDI">SQL_DIAG_ROW_NUMBER	&lt;C: #define SQL_DIAG_ROW_NUMBER (-1248)	&gt;</body><body package="DB2EXDI">SQL_DIAG_SELECT_CURSOR	&lt;C: #define SQL_DIAG_SELECT_CURSOR 85	&gt;</body><body package="DB2EXDI">SQL_DIAG_SERVER_NAME	&lt;C: #define SQL_DIAG_SERVER_NAME 11	&gt;</body><body package="DB2EXDI">SQL_DIAG_SQLSTATE	&lt;C: #define SQL_DIAG_SQLSTATE 4	&gt;</body><body package="DB2EXDI">SQL_DIAG_SUBCLASS_ORIGIN	&lt;C: #define SQL_DIAG_SUBCLASS_ORIGIN 9	&gt;</body><body package="DB2EXDI">SQL_DIAG_UNKNOWN_STATEMENT	&lt;C: #define SQL_DIAG_UNKNOWN_STATEMENT 0	&gt;</body><body package="DB2EXDI">SQL_DIAG_UPDATE_WHERE	&lt;C: #define SQL_DIAG_UPDATE_WHERE 82	&gt;</body><body package="DB2EXDI">SQL_DI_CREATE_INDEX	&lt;C: #define SQL_DI_CREATE_INDEX 0x00000001	&gt;</body><body package="DB2EXDI">SQL_DI_DROP_INDEX	&lt;C: #define SQL_DI_DROP_INDEX 0x00000002	&gt;</body><body package="DB2EXDI">SQL_DL_SQL92_DATE	&lt;C: #define SQL_DL_SQL92_DATE 0x00000001	&gt;</body><body package="DB2EXDI">SQL_DL_SQL92_INTERVAL_DAY	&lt;C: #define SQL_DL_SQL92_INTERVAL_DAY 0x00000020	&gt;</body><body package="DB2EXDI">SQL_DL_SQL92_INTERVAL_DAY_TO_HOUR	&lt;C: #define SQL_DL_SQL92_INTERVAL_DAY_TO_HOUR 0x00000400	&gt;</body><body package="DB2EXDI">SQL_DL_SQL92_INTERVAL_DAY_TO_MINUTE	&lt;C: #define SQL_DL_SQL92_INTERVAL_DAY_TO_MINUTE 0x00000800	&gt;</body><body package="DB2EXDI">SQL_DL_SQL92_INTERVAL_DAY_TO_SECOND	&lt;C: #define SQL_DL_SQL92_INTERVAL_DAY_TO_SECOND 0x00001000	&gt;</body><body package="DB2EXDI">SQL_DL_SQL92_INTERVAL_HOUR	&lt;C: #define SQL_DL_SQL92_INTERVAL_HOUR 0x00000040	&gt;</body><body package="DB2EXDI">SQL_DL_SQL92_INTERVAL_HOUR_TO_MINUTE	&lt;C: #define SQL_DL_SQL92_INTERVAL_HOUR_TO_MINUTE 0x00002000	&gt;</body><body package="DB2EXDI">SQL_DL_SQL92_INTERVAL_HOUR_TO_SECOND	&lt;C: #define SQL_DL_SQL92_INTERVAL_HOUR_TO_SECOND 0x00004000	&gt;</body><body package="DB2EXDI">SQL_DL_SQL92_INTERVAL_MINUTE	&lt;C: #define SQL_DL_SQL92_INTERVAL_MINUTE 0x00000080	&gt;</body><body package="DB2EXDI">SQL_DL_SQL92_INTERVAL_MINUTE_TO_SECOND	&lt;C: #define SQL_DL_SQL92_INTERVAL_MINUTE_TO_SECOND 0x00008000	&gt;</body><body package="DB2EXDI">SQL_DL_SQL92_INTERVAL_MONTH	&lt;C: #define SQL_DL_SQL92_INTERVAL_MONTH 0x00000010	&gt;</body><body package="DB2EXDI">SQL_DL_SQL92_INTERVAL_SECOND	&lt;C: #define SQL_DL_SQL92_INTERVAL_SECOND 0x00000100	&gt;</body><body package="DB2EXDI">SQL_DL_SQL92_INTERVAL_YEAR	&lt;C: #define SQL_DL_SQL92_INTERVAL_YEAR 0x00000008	&gt;</body><body package="DB2EXDI">SQL_DL_SQL92_INTERVAL_YEAR_TO_MONTH	&lt;C: #define SQL_DL_SQL92_INTERVAL_YEAR_TO_MONTH 0x00000200	&gt;</body><body package="DB2EXDI">SQL_DL_SQL92_TIME	&lt;C: #define SQL_DL_SQL92_TIME 0x00000002	&gt;</body><body package="DB2EXDI">SQL_DL_SQL92_TIMESTAMP	&lt;C: #define SQL_DL_SQL92_TIMESTAMP 0x00000004	&gt;</body><body package="DB2EXDI">SQL_DM_VER	&lt;C: #define SQL_DM_VER 171	&gt;</body><body package="DB2EXDI">SQL_DOUBLE	&lt;C: #define SQL_DOUBLE 8	&gt;</body><body package="DB2EXDI">SQL_DRIVER_COMPLETE	&lt;C: #define SQL_DRIVER_COMPLETE 1	&gt;</body><body package="DB2EXDI">SQL_DRIVER_COMPLETE_REQUIRED	&lt;C: #define SQL_DRIVER_COMPLETE_REQUIRED 3	&gt;</body><body package="DB2EXDI">SQL_DRIVER_HDBC	&lt;C: #define SQL_DRIVER_HDBC 3	&gt;</body><body package="DB2EXDI">SQL_DRIVER_HDESC	&lt;C: #define SQL_DRIVER_HDESC 135	&gt;</body><body package="DB2EXDI">SQL_DRIVER_HENV	&lt;C: #define SQL_DRIVER_HENV 4	&gt;</body><body package="DB2EXDI">SQL_DRIVER_HLIB	&lt;C: #define SQL_DRIVER_HLIB 76	&gt;</body><body package="DB2EXDI">SQL_DRIVER_HSTMT	&lt;C: #define SQL_DRIVER_HSTMT 5	&gt;</body><body package="DB2EXDI">SQL_DRIVER_NAME	&lt;C: #define SQL_DRIVER_NAME 6	&gt;</body><body package="DB2EXDI">SQL_DRIVER_NOPROMPT	&lt;C: #define SQL_DRIVER_NOPROMPT 0	&gt;</body><body package="DB2EXDI">SQL_DRIVER_ODBC_VER	&lt;C: #define SQL_DRIVER_ODBC_VER 77	&gt;</body><body package="DB2EXDI">SQL_DRIVER_PROMPT	&lt;C: #define SQL_DRIVER_PROMPT 2	&gt;</body><body package="DB2EXDI">SQL_DRIVER_VER	&lt;C: #define SQL_DRIVER_VER 7	&gt;</body><body package="DB2EXDI">SQL_DROP	&lt;C: #define SQL_DROP 1	&gt;</body><body package="DB2EXDI">SQL_DROP_ASSERTION	&lt;C: #define SQL_DROP_ASSERTION 136	&gt;</body><body package="DB2EXDI">SQL_DROP_CHARACTER_SET	&lt;C: #define SQL_DROP_CHARACTER_SET 137	&gt;</body><body package="DB2EXDI">SQL_DROP_COLLATION	&lt;C: #define SQL_DROP_COLLATION 138	&gt;</body><body package="DB2EXDI">SQL_DROP_DOMAIN	&lt;C: #define SQL_DROP_DOMAIN 139	&gt;</body><body package="DB2EXDI">SQL_DROP_SCHEMA	&lt;C: #define SQL_DROP_SCHEMA 140	&gt;</body><body package="DB2EXDI">SQL_DROP_TABLE	&lt;C: #define SQL_DROP_TABLE 141	&gt;</body><body package="DB2EXDI">SQL_DROP_TRANSLATION	&lt;C: #define SQL_DROP_TRANSLATION 142	&gt;</body><body package="DB2EXDI">SQL_DROP_VIEW	&lt;C: #define SQL_DROP_VIEW 143	&gt;</body><body package="DB2EXDI">SQL_DS_CASCADE	&lt;C: #define SQL_DS_CASCADE 0x00000004	&gt;</body><body package="DB2EXDI">SQL_DS_DROP_SCHEMA	&lt;C: #define SQL_DS_DROP_SCHEMA 0x00000001	&gt;</body><body package="DB2EXDI">SQL_DS_RESTRICT	&lt;C: #define SQL_DS_RESTRICT 0x00000002	&gt;</body><body package="DB2EXDI">SQL_DTC_DONE	&lt;C: #define SQL_DTC_DONE 0	&gt;</body><body package="DB2EXDI">SQL_DTC_ENLIST_EXPENSIVE	&lt;C: #define SQL_DTC_ENLIST_EXPENSIVE 0x00000001	&gt;</body><body package="DB2EXDI">SQL_DTC_TRANSITION_COST	&lt;C: #define SQL_DTC_TRANSITION_COST 1750	&gt;</body><body package="DB2EXDI">SQL_DTC_UNENLIST_EXPENSIVE	&lt;C: #define SQL_DTC_UNENLIST_EXPENSIVE 0x00000002	&gt;</body><body package="DB2EXDI">SQL_DTR_DROP_TRANSLATION	&lt;C: #define SQL_DTR_DROP_TRANSLATION 0x00000001	&gt;</body><body package="DB2EXDI">SQL_DT_CASCADE	&lt;C: #define SQL_DT_CASCADE 0x00000004	&gt;</body><body package="DB2EXDI">SQL_DT_DROP_TABLE	&lt;C: #define SQL_DT_DROP_TABLE 0x00000001	&gt;</body><body package="DB2EXDI">SQL_DT_RESTRICT	&lt;C: #define SQL_DT_RESTRICT 0x00000002	&gt;</body><body package="DB2EXDI">SQL_DV_CASCADE	&lt;C: #define SQL_DV_CASCADE 0x00000004	&gt;</body><body package="DB2EXDI">SQL_DV_DROP_VIEW	&lt;C: #define SQL_DV_DROP_VIEW 0x00000001	&gt;</body><body package="DB2EXDI">SQL_DV_RESTRICT	&lt;C: #define SQL_DV_RESTRICT 0x00000002	&gt;</body><body package="DB2EXDI">SQL_DYNAMIC_CURSOR_ATTRIBUTES1	&lt;C: #define SQL_DYNAMIC_CURSOR_ATTRIBUTES1 144	&gt;</body><body package="DB2EXDI">SQL_DYNAMIC_CURSOR_ATTRIBUTES2	&lt;C: #define SQL_DYNAMIC_CURSOR_ATTRIBUTES2 145	&gt;</body><body package="DB2EXDI">SQL_EARLYCLOSE_DEFAULT	&lt;C: #define SQL_EARLYCLOSE_DEFAULT SQL_EARLYCLOSE_ON	&gt;</body><body package="DB2EXDI">SQL_EARLYCLOSE_OFF	&lt;C: #define SQL_EARLYCLOSE_OFF 0	&gt;</body><body package="DB2EXDI">SQL_EARLYCLOSE_ON	&lt;C: #define SQL_EARLYCLOSE_ON 1	&gt;</body><body package="DB2EXDI">SQL_ENSURE	&lt;C: #define SQL_ENSURE 1	&gt;</body><body package="DB2EXDI">SQL_ENTIRE_ROWSET	&lt;C: #define SQL_ENTIRE_ROWSET 0	&gt;</body><body package="DB2EXDI">SQL_ERROR	&lt;C: #define SQL_ERROR -1	&gt;</body><body package="DB2EXDI">SQL_EXPRESSIONS_IN_ORDERBY	&lt;C: #define SQL_EXPRESSIONS_IN_ORDERBY 27	&gt;</body><body package="DB2EXDI">SQL_EXT_API_LAST	&lt;C: #define SQL_EXT_API_LAST 72	&gt;</body><body package="DB2EXDI">SQL_FALSE	&lt;C: #define SQL_FALSE 0	&gt;</body><body package="DB2EXDI">SQL_FD_FETCH_ABSOLUTE	&lt;C: #define SQL_FD_FETCH_ABSOLUTE 0x00000010	&gt;</body><body package="DB2EXDI">SQL_FD_FETCH_BOOKMARK	&lt;C: #define SQL_FD_FETCH_BOOKMARK 0x00000080	&gt;</body><body package="DB2EXDI">SQL_FD_FETCH_FIRST	&lt;C: #define SQL_FD_FETCH_FIRST 0x00000002	&gt;</body><body package="DB2EXDI">SQL_FD_FETCH_LAST	&lt;C: #define SQL_FD_FETCH_LAST 0x00000004	&gt;</body><body package="DB2EXDI">SQL_FD_FETCH_NEXT	&lt;C: #define SQL_FD_FETCH_NEXT 0x00000001	&gt;</body><body package="DB2EXDI">SQL_FD_FETCH_PREV	&lt;C: #define SQL_FD_FETCH_PREV SQL_FD_FETCH_PRIOR	&gt;</body><body package="DB2EXDI">SQL_FD_FETCH_PRIOR	&lt;C: #define SQL_FD_FETCH_PRIOR 0x00000008	&gt;</body><body package="DB2EXDI">SQL_FD_FETCH_RELATIVE	&lt;C: #define SQL_FD_FETCH_RELATIVE 0x00000020	&gt;</body><body package="DB2EXDI">SQL_FD_FETCH_RESUME	&lt;C: #define SQL_FD_FETCH_RESUME 0x00000040	&gt;</body><body package="DB2EXDI">SQL_FETCH_ABSOLUTE	&lt;C: #define SQL_FETCH_ABSOLUTE 5	&gt;</body><body package="DB2EXDI">SQL_FETCH_BOOKMARK	&lt;C: #define SQL_FETCH_BOOKMARK 8	&gt;</body><body package="DB2EXDI">SQL_FETCH_BY_BOOKMARK	&lt;C: #define SQL_FETCH_BY_BOOKMARK 7	&gt;</body><body package="DB2EXDI">SQL_FETCH_DIRECTION	&lt;C: #define SQL_FETCH_DIRECTION 8	&gt;</body><body package="DB2EXDI">SQL_FETCH_FIRST	&lt;C: #define SQL_FETCH_FIRST 2	&gt;</body><body package="DB2EXDI">SQL_FETCH_FIRST_SYSTEM	&lt;C: #define SQL_FETCH_FIRST_SYSTEM 32	&gt;</body><body package="DB2EXDI">SQL_FETCH_FIRST_USER	&lt;C: #define SQL_FETCH_FIRST_USER 31	&gt;</body><body package="DB2EXDI">SQL_FETCH_LAST	&lt;C: #define SQL_FETCH_LAST 3	&gt;</body><body package="DB2EXDI">SQL_FETCH_NEXT	&lt;C: #define SQL_FETCH_NEXT 1	&gt;</body><body package="DB2EXDI">SQL_FETCH_PREV	&lt;C: #define SQL_FETCH_PREV SQL_FETCH_PRIOR	&gt;</body><body package="DB2EXDI">SQL_FETCH_PRIOR	&lt;C: #define SQL_FETCH_PRIOR 4	&gt;</body><body package="DB2EXDI">SQL_FETCH_RELATIVE	&lt;C: #define SQL_FETCH_RELATIVE 6	&gt;</body><body package="DB2EXDI">SQL_FILE_APPEND	&lt;C: #define SQL_FILE_APPEND 32	&gt;</body><body package="DB2EXDI">SQL_FILE_CATALOG	&lt;C: #define SQL_FILE_CATALOG SQL_FILE_QUALIFIER	&gt;</body><body package="DB2EXDI">SQL_FILE_CREATE	&lt;C: #define SQL_FILE_CREATE 8	&gt;</body><body package="DB2EXDI">SQL_FILE_NOT_SUPPORTED	&lt;C: #define SQL_FILE_NOT_SUPPORTED 0x0000	&gt;</body><body package="DB2EXDI">SQL_FILE_OVERWRITE	&lt;C: #define SQL_FILE_OVERWRITE 16	&gt;</body><body package="DB2EXDI">SQL_FILE_QUALIFIER	&lt;C: #define SQL_FILE_QUALIFIER 0x0002	&gt;</body><body package="DB2EXDI">SQL_FILE_READ	&lt;C: #define SQL_FILE_READ 2	&gt;</body><body package="DB2EXDI">SQL_FILE_TABLE	&lt;C: #define SQL_FILE_TABLE 0x0001	&gt;</body><body package="DB2EXDI">SQL_FILE_USAGE	&lt;C: #define SQL_FILE_USAGE 84	&gt;</body><body package="DB2EXDI">SQL_FLOAT	&lt;C: #define SQL_FLOAT 6	&gt;</body><body package="DB2EXDI">SQL_FN_CVT_CAST	&lt;C: #define SQL_FN_CVT_CAST 0x00000002	&gt;</body><body package="DB2EXDI">SQL_FN_CVT_CONVERT	&lt;C: #define SQL_FN_CVT_CONVERT 0x00000001	&gt;</body><body package="DB2EXDI">SQL_FN_NUM_ABS	&lt;C: #define SQL_FN_NUM_ABS 0x00000001	&gt;</body><body package="DB2EXDI">SQL_FN_NUM_ACOS	&lt;C: #define SQL_FN_NUM_ACOS 0x00000002	&gt;</body><body package="DB2EXDI">SQL_FN_NUM_ASIN	&lt;C: #define SQL_FN_NUM_ASIN 0x00000004	&gt;</body><body package="DB2EXDI">SQL_FN_NUM_ATAN	&lt;C: #define SQL_FN_NUM_ATAN 0x00000008	&gt;</body><body package="DB2EXDI">SQL_FN_NUM_ATAN2	&lt;C: #define SQL_FN_NUM_ATAN2 0x00000010	&gt;</body><body package="DB2EXDI">SQL_FN_NUM_CEILING	&lt;C: #define SQL_FN_NUM_CEILING 0x00000020	&gt;</body><body package="DB2EXDI">SQL_FN_NUM_COS	&lt;C: #define SQL_FN_NUM_COS 0x00000040	&gt;</body><body package="DB2EXDI">SQL_FN_NUM_COT	&lt;C: #define SQL_FN_NUM_COT 0x00000080	&gt;</body><body package="DB2EXDI">SQL_FN_NUM_DEGREES	&lt;C: #define SQL_FN_NUM_DEGREES 0x00040000	&gt;</body><body package="DB2EXDI">SQL_FN_NUM_EXP	&lt;C: #define SQL_FN_NUM_EXP 0x00000100	&gt;</body><body package="DB2EXDI">SQL_FN_NUM_FLOOR	&lt;C: #define SQL_FN_NUM_FLOOR 0x00000200	&gt;</body><body package="DB2EXDI">SQL_FN_NUM_LOG	&lt;C: #define SQL_FN_NUM_LOG 0x00000400	&gt;</body><body package="DB2EXDI">SQL_FN_NUM_LOG10	&lt;C: #define SQL_FN_NUM_LOG10 0x00080000	&gt;</body><body package="DB2EXDI">SQL_FN_NUM_MOD	&lt;C: #define SQL_FN_NUM_MOD 0x00000800	&gt;</body><body package="DB2EXDI">SQL_FN_NUM_PI	&lt;C: #define SQL_FN_NUM_PI 0x00010000	&gt;</body><body package="DB2EXDI">SQL_FN_NUM_POWER	&lt;C: #define SQL_FN_NUM_POWER 0x00100000	&gt;</body><body package="DB2EXDI">SQL_FN_NUM_RADIANS	&lt;C: #define SQL_FN_NUM_RADIANS 0x00200000	&gt;</body><body package="DB2EXDI">SQL_FN_NUM_RAND	&lt;C: #define SQL_FN_NUM_RAND 0x00020000	&gt;</body><body package="DB2EXDI">SQL_FN_NUM_ROUND	&lt;C: #define SQL_FN_NUM_ROUND 0x00400000	&gt;</body><body package="DB2EXDI">SQL_FN_NUM_SIGN	&lt;C: #define SQL_FN_NUM_SIGN 0x00001000	&gt;</body><body package="DB2EXDI">SQL_FN_NUM_SIN	&lt;C: #define SQL_FN_NUM_SIN 0x00002000	&gt;</body><body package="DB2EXDI">SQL_FN_NUM_SQRT	&lt;C: #define SQL_FN_NUM_SQRT 0x00004000	&gt;</body><body package="DB2EXDI">SQL_FN_NUM_TAN	&lt;C: #define SQL_FN_NUM_TAN 0x00008000	&gt;</body><body package="DB2EXDI">SQL_FN_NUM_TRUNCATE	&lt;C: #define SQL_FN_NUM_TRUNCATE 0x00800000	&gt;</body><body package="DB2EXDI">SQL_FN_STR_ASCII	&lt;C: #define SQL_FN_STR_ASCII 0x00002000	&gt;</body><body package="DB2EXDI">SQL_FN_STR_BIT_LENGTH	&lt;C: #define SQL_FN_STR_BIT_LENGTH 0x00080000	&gt;</body><body package="DB2EXDI">SQL_FN_STR_CHAR	&lt;C: #define SQL_FN_STR_CHAR 0x00004000	&gt;</body><body package="DB2EXDI">SQL_FN_STR_CHARACTER_LENGTH	&lt;C: #define SQL_FN_STR_CHARACTER_LENGTH 0x00200000	&gt;</body><body package="DB2EXDI">SQL_FN_STR_CHAR_LENGTH	&lt;C: #define SQL_FN_STR_CHAR_LENGTH 0x00100000	&gt;</body><body package="DB2EXDI">SQL_FN_STR_CONCAT	&lt;C: #define SQL_FN_STR_CONCAT 0x00000001	&gt;</body><body package="DB2EXDI">SQL_FN_STR_DIFFERENCE	&lt;C: #define SQL_FN_STR_DIFFERENCE 0x00008000	&gt;</body><body package="DB2EXDI">SQL_FN_STR_INSERT	&lt;C: #define SQL_FN_STR_INSERT 0x00000002	&gt;</body><body package="DB2EXDI">SQL_FN_STR_LCASE	&lt;C: #define SQL_FN_STR_LCASE 0x00000040	&gt;</body><body package="DB2EXDI">SQL_FN_STR_LEFT	&lt;C: #define SQL_FN_STR_LEFT 0x00000004	&gt;</body><body package="DB2EXDI">SQL_FN_STR_LENGTH	&lt;C: #define SQL_FN_STR_LENGTH 0x00000010	&gt;</body><body package="DB2EXDI">SQL_FN_STR_LOCATE	&lt;C: #define SQL_FN_STR_LOCATE 0x00000020	&gt;</body><body package="DB2EXDI">SQL_FN_STR_LOCATE_2	&lt;C: #define SQL_FN_STR_LOCATE_2 0x00010000	&gt;</body><body package="DB2EXDI">SQL_FN_STR_LTRIM	&lt;C: #define SQL_FN_STR_LTRIM 0x00000008	&gt;</body><body package="DB2EXDI">SQL_FN_STR_OCTET_LENGTH	&lt;C: #define SQL_FN_STR_OCTET_LENGTH 0x00400000	&gt;</body><body package="DB2EXDI">SQL_FN_STR_POSITION	&lt;C: #define SQL_FN_STR_POSITION 0x00800000	&gt;</body><body package="DB2EXDI">SQL_FN_STR_REPEAT	&lt;C: #define SQL_FN_STR_REPEAT 0x00000080	&gt;</body><body package="DB2EXDI">SQL_FN_STR_REPLACE	&lt;C: #define SQL_FN_STR_REPLACE 0x00000100	&gt;</body><body package="DB2EXDI">SQL_FN_STR_RIGHT	&lt;C: #define SQL_FN_STR_RIGHT 0x00000200	&gt;</body><body package="DB2EXDI">SQL_FN_STR_RTRIM	&lt;C: #define SQL_FN_STR_RTRIM 0x00000400	&gt;</body><body package="DB2EXDI">SQL_FN_STR_SOUNDEX	&lt;C: #define SQL_FN_STR_SOUNDEX 0x00020000	&gt;</body><body package="DB2EXDI">SQL_FN_STR_SPACE	&lt;C: #define SQL_FN_STR_SPACE 0x00040000	&gt;</body><body package="DB2EXDI">SQL_FN_STR_SUBSTRING	&lt;C: #define SQL_FN_STR_SUBSTRING 0x00000800	&gt;</body><body package="DB2EXDI">SQL_FN_STR_UCASE	&lt;C: #define SQL_FN_STR_UCASE 0x00001000	&gt;</body><body package="DB2EXDI">SQL_FN_SYS_DBNAME	&lt;C: #define SQL_FN_SYS_DBNAME 0x00000002	&gt;</body><body package="DB2EXDI">SQL_FN_SYS_IFNULL	&lt;C: #define SQL_FN_SYS_IFNULL 0x00000004	&gt;</body><body package="DB2EXDI">SQL_FN_SYS_USERNAME	&lt;C: #define SQL_FN_SYS_USERNAME 0x00000001	&gt;</body><body package="DB2EXDI">SQL_FN_TD_CURDATE	&lt;C: #define SQL_FN_TD_CURDATE 0x00000002	&gt;</body><body package="DB2EXDI">SQL_FN_TD_CURRENT_DATE	&lt;C: #define SQL_FN_TD_CURRENT_DATE 0x00020000	&gt;</body><body package="DB2EXDI">SQL_FN_TD_CURRENT_TIME	&lt;C: #define SQL_FN_TD_CURRENT_TIME 0x00040000	&gt;</body><body package="DB2EXDI">SQL_FN_TD_CURRENT_TIMESTAMP	&lt;C: #define SQL_FN_TD_CURRENT_TIMESTAMP 0x00080000	&gt;</body><body package="DB2EXDI">SQL_FN_TD_CURTIME	&lt;C: #define SQL_FN_TD_CURTIME 0x00000200	&gt;</body><body package="DB2EXDI">SQL_FN_TD_DAYNAME	&lt;C: #define SQL_FN_TD_DAYNAME 0x00008000	&gt;</body><body package="DB2EXDI">SQL_FN_TD_DAYOFMONTH	&lt;C: #define SQL_FN_TD_DAYOFMONTH 0x00000004	&gt;</body><body package="DB2EXDI">SQL_FN_TD_DAYOFWEEK	&lt;C: #define SQL_FN_TD_DAYOFWEEK 0x00000008	&gt;</body><body package="DB2EXDI">SQL_FN_TD_DAYOFYEAR	&lt;C: #define SQL_FN_TD_DAYOFYEAR 0x00000010	&gt;</body><body package="DB2EXDI">SQL_FN_TD_EXTRACT	&lt;C: #define SQL_FN_TD_EXTRACT 0x00100000	&gt;</body><body package="DB2EXDI">SQL_FN_TD_HOUR	&lt;C: #define SQL_FN_TD_HOUR 0x00000400	&gt;</body><body package="DB2EXDI">SQL_FN_TD_MINUTE	&lt;C: #define SQL_FN_TD_MINUTE 0x00000800	&gt;</body><body package="DB2EXDI">SQL_FN_TD_MONTH	&lt;C: #define SQL_FN_TD_MONTH 0x00000020	&gt;</body><body package="DB2EXDI">SQL_FN_TD_MONTHNAME	&lt;C: #define SQL_FN_TD_MONTHNAME 0x00010000	&gt;</body><body package="DB2EXDI">SQL_FN_TD_NOW	&lt;C: #define SQL_FN_TD_NOW 0x00000001	&gt;</body><body package="DB2EXDI">SQL_FN_TD_QUARTER	&lt;C: #define SQL_FN_TD_QUARTER 0x00000040	&gt;</body><body package="DB2EXDI">SQL_FN_TD_SECOND	&lt;C: #define SQL_FN_TD_SECOND 0x00001000	&gt;</body><body package="DB2EXDI">SQL_FN_TD_TIMESTAMPADD	&lt;C: #define SQL_FN_TD_TIMESTAMPADD 0x00002000	&gt;</body><body package="DB2EXDI">SQL_FN_TD_TIMESTAMPDIFF	&lt;C: #define SQL_FN_TD_TIMESTAMPDIFF 0x00004000	&gt;</body><body package="DB2EXDI">SQL_FN_TD_WEEK	&lt;C: #define SQL_FN_TD_WEEK 0x00000080	&gt;</body><body package="DB2EXDI">SQL_FN_TD_YEAR	&lt;C: #define SQL_FN_TD_YEAR 0x00000100	&gt;</body><body package="DB2EXDI">SQL_FN_TSI_DAY	&lt;C: #define SQL_FN_TSI_DAY 0x00000010	&gt;</body><body package="DB2EXDI">SQL_FN_TSI_FRAC_SECOND	&lt;C: #define SQL_FN_TSI_FRAC_SECOND 0x00000001	&gt;</body><body package="DB2EXDI">SQL_FN_TSI_HOUR	&lt;C: #define SQL_FN_TSI_HOUR 0x00000008	&gt;</body><body package="DB2EXDI">SQL_FN_TSI_MINUTE	&lt;C: #define SQL_FN_TSI_MINUTE 0x00000004	&gt;</body><body package="DB2EXDI">SQL_FN_TSI_MONTH	&lt;C: #define SQL_FN_TSI_MONTH 0x00000040	&gt;</body><body package="DB2EXDI">SQL_FN_TSI_QUARTER	&lt;C: #define SQL_FN_TSI_QUARTER 0x00000080	&gt;</body><body package="DB2EXDI">SQL_FN_TSI_SECOND	&lt;C: #define SQL_FN_TSI_SECOND 0x00000002	&gt;</body><body package="DB2EXDI">SQL_FN_TSI_WEEK	&lt;C: #define SQL_FN_TSI_WEEK 0x00000020	&gt;</body><body package="DB2EXDI">SQL_FN_TSI_YEAR	&lt;C: #define SQL_FN_TSI_YEAR 0x00000100	&gt;</body><body package="DB2EXDI">SQL_FORWARD_ONLY_CURSOR_ATTRIBUTES1	&lt;C: #define SQL_FORWARD_ONLY_CURSOR_ATTRIBUTES1 146	&gt;</body><body package="DB2EXDI">SQL_FORWARD_ONLY_CURSOR_ATTRIBUTES2	&lt;C: #define SQL_FORWARD_ONLY_CURSOR_ATTRIBUTES2 147	&gt;</body><body package="DB2EXDI">SQL_FROM_LITERAL	&lt;C: #define SQL_FROM_LITERAL 3	&gt;</body><body package="DB2EXDI">SQL_FROM_LOCATOR	&lt;C: #define SQL_FROM_LOCATOR 2	&gt;</body><body package="DB2EXDI">SQL_GB_COLLATE	&lt;C: #define SQL_GB_COLLATE 0x0004	&gt;</body><body package="DB2EXDI">SQL_GB_GROUP_BY_CONTAINS_SELECT	&lt;C: #define SQL_GB_GROUP_BY_CONTAINS_SELECT 0x0002	&gt;</body><body package="DB2EXDI">SQL_GB_GROUP_BY_EQUALS_SELECT	&lt;C: #define SQL_GB_GROUP_BY_EQUALS_SELECT 0x0001	&gt;</body><body package="DB2EXDI">SQL_GB_NOT_SUPPORTED	&lt;C: #define SQL_GB_NOT_SUPPORTED 0x0000	&gt;</body><body package="DB2EXDI">SQL_GB_NO_RELATION	&lt;C: #define SQL_GB_NO_RELATION 0x0003	&gt;</body><body package="DB2EXDI">SQL_GD_ANY_COLUMN	&lt;C: #define SQL_GD_ANY_COLUMN 0x00000001	&gt;</body><body package="DB2EXDI">SQL_GD_ANY_ORDER	&lt;C: #define SQL_GD_ANY_ORDER 0x00000002	&gt;</body><body package="DB2EXDI">SQL_GD_BLOCK	&lt;C: #define SQL_GD_BLOCK 0x00000004	&gt;</body><body package="DB2EXDI">SQL_GD_BOUND	&lt;C: #define SQL_GD_BOUND 0x00000008	&gt;</body><body package="DB2EXDI">SQL_GETDATA_EXTENSIONS	&lt;C: #define SQL_GETDATA_EXTENSIONS 81	&gt;</body><body package="DB2EXDI">SQL_GET_BOOKMARK	&lt;C: #define SQL_GET_BOOKMARK 13	&gt;</body><body package="DB2EXDI">SQL_GRAPHIC	&lt;C: #define SQL_GRAPHIC -95	&gt;</body><body package="DB2EXDI">SQL_GROUP_BY	&lt;C: #define SQL_GROUP_BY 88	&gt;</body><body package="DB2EXDI">SQL_HANDLE_DBC	&lt;C: #define SQL_HANDLE_DBC 2	&gt;</body><body package="DB2EXDI">SQL_HANDLE_DESC	&lt;C: #define SQL_HANDLE_DESC 4	&gt;</body><body package="DB2EXDI">SQL_HANDLE_ENV	&lt;C: #define SQL_HANDLE_ENV 1	&gt;</body><body package="DB2EXDI">SQL_HANDLE_SENV	&lt;C: #define SQL_HANDLE_SENV 5	&gt;</body><body package="DB2EXDI">SQL_HANDLE_STMT	&lt;C: #define SQL_HANDLE_STMT 3	&gt;</body><body package="DB2EXDI">SQL_H_SQLCLI	&lt;C: #define SQL_H_SQLCLI 	&gt;</body><body package="DB2EXDI">SQL_H_SQLCLI1	&lt;C: #define SQL_H_SQLCLI1 	&gt;</body><body package="DB2EXDI">SQL_H_SQLSYSTM	&lt;C: #define SQL_H_SQLSYSTM 	&gt;</body><body package="DB2EXDI">SQL_IBM_ALTERTABLEVARCHAR	&lt;C: #define SQL_IBM_ALTERTABLEVARCHAR 1000	&gt;</body><body package="DB2EXDI">SQL_IC_LOWER	&lt;C: #define SQL_IC_LOWER 0x0002	&gt;</body><body package="DB2EXDI">SQL_IC_MIXED	&lt;C: #define SQL_IC_MIXED 0x0004	&gt;</body><body package="DB2EXDI">SQL_IC_SENSITIVE	&lt;C: #define SQL_IC_SENSITIVE 0x0003	&gt;</body><body package="DB2EXDI">SQL_IC_UPPER	&lt;C: #define SQL_IC_UPPER 0x0001	&gt;</body><body package="DB2EXDI">SQL_IDENTIFIER_CASE	&lt;C: #define SQL_IDENTIFIER_CASE 28	&gt;</body><body package="DB2EXDI">SQL_IDENTIFIER_QUOTE_CHAR	&lt;C: #define SQL_IDENTIFIER_QUOTE_CHAR 29	&gt;</body><body package="DB2EXDI">SQL_IGNORE	&lt;C: #define SQL_IGNORE (-6)	&gt;</body><body package="DB2EXDI">SQL_IK_ALL	&lt;C: #define SQL_IK_ALL (SQL_IK_ASC | SQL_IK_DESC)	&gt;</body><body package="DB2EXDI">SQL_IK_ASC	&lt;C: #define SQL_IK_ASC 0x00000001	&gt;</body><body package="DB2EXDI">SQL_IK_DESC	&lt;C: #define SQL_IK_DESC 0x00000002	&gt;</body><body package="DB2EXDI">SQL_IK_NONE	&lt;C: #define SQL_IK_NONE 0x00000000	&gt;</body><body package="DB2EXDI">SQL_INDEX_ALL	&lt;C: #define SQL_INDEX_ALL 1	&gt;</body><body package="DB2EXDI">SQL_INDEX_CLUSTERED	&lt;C: #define SQL_INDEX_CLUSTERED 1	&gt;</body><body package="DB2EXDI">SQL_INDEX_HASHED	&lt;C: #define SQL_INDEX_HASHED 2	&gt;</body><body package="DB2EXDI">SQL_INDEX_KEYWORDS	&lt;C: #define SQL_INDEX_KEYWORDS 148	&gt;</body><body package="DB2EXDI">SQL_INDEX_OTHER	&lt;C: #define SQL_INDEX_OTHER 3	&gt;</body><body package="DB2EXDI">SQL_INDEX_UNIQUE	&lt;C: #define SQL_INDEX_UNIQUE 0	&gt;</body><body package="DB2EXDI">SQL_INFO_DRIVER_START	&lt;C: #define SQL_INFO_DRIVER_START 1000	&gt;</body><body package="DB2EXDI">SQL_INFO_FIRST	&lt;C: #define SQL_INFO_FIRST 0	&gt;</body><body package="DB2EXDI">SQL_INFO_LAST	&lt;C: #define SQL_INFO_LAST 114	&gt;</body><body package="DB2EXDI">SQL_INFO_SCHEMA_VIEWS	&lt;C: #define SQL_INFO_SCHEMA_VIEWS 149	&gt;</body><body package="DB2EXDI">SQL_INITIALLY_DEFERRED	&lt;C: #define SQL_INITIALLY_DEFERRED 5	&gt;</body><body package="DB2EXDI">SQL_INITIALLY_IMMEDIATE	&lt;C: #define SQL_INITIALLY_IMMEDIATE 6	&gt;</body><body package="DB2EXDI">SQL_INSENSITIVE	&lt;C: #define SQL_INSENSITIVE 1	&gt;</body><body package="DB2EXDI">SQL_INSERT_STATEMENT	&lt;C: #define SQL_INSERT_STATEMENT 172	&gt;</body><body package="DB2EXDI">SQL_INTEGER	&lt;C: #define SQL_INTEGER 4	&gt;</body><body package="DB2EXDI">SQL_INTEGRITY	&lt;C: #define SQL_INTEGRITY 73	&gt;</body><body package="DB2EXDI">SQL_INTERVAL	&lt;C: #define SQL_INTERVAL 10	&gt;</body><body package="DB2EXDI">SQL_INTERVAL_DAY	&lt;C: #define SQL_INTERVAL_DAY (100+SQL_CODE_DAY)	&gt;</body><body package="DB2EXDI">SQL_INTERVAL_DAY_TO_HOUR	&lt;C: #define SQL_INTERVAL_DAY_TO_HOUR (100+SQL_CODE_DAY_TO_HOUR)	&gt;</body><body package="DB2EXDI">SQL_INTERVAL_DAY_TO_MINUTE	&lt;C: #define SQL_INTERVAL_DAY_TO_MINUTE (100+SQL_CODE_DAY_TO_MINUTE)	&gt;</body><body package="DB2EXDI">SQL_INTERVAL_DAY_TO_SECOND	&lt;C: #define SQL_INTERVAL_DAY_TO_SECOND (100+SQL_CODE_DAY_TO_SECOND)	&gt;</body><body package="DB2EXDI">SQL_INTERVAL_HOUR	&lt;C: #define SQL_INTERVAL_HOUR (100+SQL_CODE_HOUR)	&gt;</body><body package="DB2EXDI">SQL_INTERVAL_HOUR_TO_MINUTE	&lt;C: #define SQL_INTERVAL_HOUR_TO_MINUTE (100+SQL_CODE_HOUR_TO_MINUTE)	&gt;</body><body package="DB2EXDI">SQL_INTERVAL_HOUR_TO_SECOND	&lt;C: #define SQL_INTERVAL_HOUR_TO_SECOND (100+SQL_CODE_HOUR_TO_SECOND)	&gt;</body><body package="DB2EXDI">SQL_INTERVAL_MINUTE	&lt;C: #define SQL_INTERVAL_MINUTE (100+SQL_CODE_MINUTE)	&gt;</body><body package="DB2EXDI">SQL_INTERVAL_MINUTE_TO_SECOND	&lt;C: #define SQL_INTERVAL_MINUTE_TO_SECOND (100+SQL_CODE_MINUTE_TO_SECOND)	&gt;</body><body package="DB2EXDI">SQL_INTERVAL_MONTH	&lt;C: #define SQL_INTERVAL_MONTH (100+SQL_CODE_MONTH)	&gt;</body><body package="DB2EXDI">SQL_INTERVAL_SECOND	&lt;C: #define SQL_INTERVAL_SECOND (100+SQL_CODE_SECOND)	&gt;</body><body package="DB2EXDI">SQL_INTERVAL_YEAR	&lt;C: #define SQL_INTERVAL_YEAR (100+SQL_CODE_YEAR)	&gt;</body><body package="DB2EXDI">SQL_INTERVAL_YEAR_TO_MONTH	&lt;C: #define SQL_INTERVAL_YEAR_TO_MONTH (100+SQL_CODE_YEAR_TO_MONTH)	&gt;</body><body package="DB2EXDI">SQL_INVALID_HANDLE	&lt;C: #define SQL_INVALID_HANDLE -2	&gt;</body><body package="DB2EXDI">SQL_ISV_ASSERTIONS	&lt;C: #define SQL_ISV_ASSERTIONS 0x00000001	&gt;</body><body package="DB2EXDI">SQL_ISV_CHARACTER_SETS	&lt;C: #define SQL_ISV_CHARACTER_SETS 0x00000002	&gt;</body><body package="DB2EXDI">SQL_ISV_CHECK_CONSTRAINTS	&lt;C: #define SQL_ISV_CHECK_CONSTRAINTS 0x00000004	&gt;</body><body package="DB2EXDI">SQL_ISV_COLLATIONS	&lt;C: #define SQL_ISV_COLLATIONS 0x00000008	&gt;</body><body package="DB2EXDI">SQL_ISV_COLUMNS	&lt;C: #define SQL_ISV_COLUMNS 0x00000040	&gt;</body><body package="DB2EXDI">SQL_ISV_COLUMN_DOMAIN_USAGE	&lt;C: #define SQL_ISV_COLUMN_DOMAIN_USAGE 0x00000010	&gt;</body><body package="DB2EXDI">SQL_ISV_COLUMN_PRIVILEGES	&lt;C: #define SQL_ISV_COLUMN_PRIVILEGES 0x00000020	&gt;</body><body package="DB2EXDI">SQL_ISV_CONSTRAINT_COLUMN_USAGE	&lt;C: #define SQL_ISV_CONSTRAINT_COLUMN_USAGE 0x00000080	&gt;</body><body package="DB2EXDI">SQL_ISV_CONSTRAINT_TABLE_USAGE	&lt;C: #define SQL_ISV_CONSTRAINT_TABLE_USAGE 0x00000100	&gt;</body><body package="DB2EXDI">SQL_ISV_DOMAINS	&lt;C: #define SQL_ISV_DOMAINS 0x00000400	&gt;</body><body package="DB2EXDI">SQL_ISV_DOMAIN_CONSTRAINTS	&lt;C: #define SQL_ISV_DOMAIN_CONSTRAINTS 0x00000200	&gt;</body><body package="DB2EXDI">SQL_ISV_KEY_COLUMN_USAGE	&lt;C: #define SQL_ISV_KEY_COLUMN_USAGE 0x00000800	&gt;</body><body package="DB2EXDI">SQL_ISV_REFERENTIAL_CONSTRAINTS	&lt;C: #define SQL_ISV_REFERENTIAL_CONSTRAINTS 0x00001000	&gt;</body><body package="DB2EXDI">SQL_ISV_SCHEMATA	&lt;C: #define SQL_ISV_SCHEMATA 0x00002000	&gt;</body><body package="DB2EXDI">SQL_ISV_SQL_LANGUAGES	&lt;C: #define SQL_ISV_SQL_LANGUAGES 0x00004000	&gt;</body><body package="DB2EXDI">SQL_ISV_TABLES	&lt;C: #define SQL_ISV_TABLES 0x00020000	&gt;</body><body package="DB2EXDI">SQL_ISV_TABLE_CONSTRAINTS	&lt;C: #define SQL_ISV_TABLE_CONSTRAINTS 0x00008000	&gt;</body><body package="DB2EXDI">SQL_ISV_TABLE_PRIVILEGES	&lt;C: #define SQL_ISV_TABLE_PRIVILEGES 0x00010000	&gt;</body><body package="DB2EXDI">SQL_ISV_TRANSLATIONS	&lt;C: #define SQL_ISV_TRANSLATIONS 0x00040000	&gt;</body><body package="DB2EXDI">SQL_ISV_USAGE_PRIVILEGES	&lt;C: #define SQL_ISV_USAGE_PRIVILEGES 0x00080000	&gt;</body><body package="DB2EXDI">SQL_ISV_VIEWS	&lt;C: #define SQL_ISV_VIEWS 0x00400000	&gt;</body><body package="DB2EXDI">SQL_ISV_VIEW_COLUMN_USAGE	&lt;C: #define SQL_ISV_VIEW_COLUMN_USAGE 0x00100000	&gt;</body><body package="DB2EXDI">SQL_ISV_VIEW_TABLE_USAGE	&lt;C: #define SQL_ISV_VIEW_TABLE_USAGE 0x00200000	&gt;</body><body package="DB2EXDI">SQL_IS_INSERT_LITERALS	&lt;C: #define SQL_IS_INSERT_LITERALS 0x00000001	&gt;</body><body package="DB2EXDI">SQL_IS_INSERT_SEARCHED	&lt;C: #define SQL_IS_INSERT_SEARCHED 0x00000002	&gt;</body><body package="DB2EXDI">SQL_IS_INTEGER	&lt;C: #define SQL_IS_INTEGER (-6)	&gt;</body><body package="DB2EXDI">SQL_IS_POINTER	&lt;C: #define SQL_IS_POINTER (-4)	&gt;</body><body package="DB2EXDI">SQL_IS_SELECT_INTO	&lt;C: #define SQL_IS_SELECT_INTO 0x00000004	&gt;</body><body package="DB2EXDI">SQL_IS_SMALLINT	&lt;C: #define SQL_IS_SMALLINT (-8)	&gt;</body><body package="DB2EXDI">SQL_IS_UINTEGER	&lt;C: #define SQL_IS_UINTEGER (-5)	&gt;</body><body package="DB2EXDI">SQL_IS_USMALLINT	&lt;C: #define SQL_IS_USMALLINT (-7)	&gt;</body><body package="DB2EXDI">SQL_KEYSET_CURSOR_ATTRIBUTES1	&lt;C: #define SQL_KEYSET_CURSOR_ATTRIBUTES1 150	&gt;</body><body package="DB2EXDI">SQL_KEYSET_CURSOR_ATTRIBUTES2	&lt;C: #define SQL_KEYSET_CURSOR_ATTRIBUTES2 151	&gt;</body><body package="DB2EXDI">SQL_KEYSET_SIZE	&lt;C: #define SQL_KEYSET_SIZE 8	&gt;</body><body package="DB2EXDI">SQL_KEYSET_SIZE_DEFAULT	&lt;C: #define SQL_KEYSET_SIZE_DEFAULT 0	&gt;</body><body package="DB2EXDI">SQL_KEYWORDS	&lt;C: #define SQL_KEYWORDS 89	&gt;</body><body package="DB2EXDI">SQL_LCK_EXCLUSIVE	&lt;C: #define SQL_LCK_EXCLUSIVE 0x00000002	&gt;</body><body package="DB2EXDI">SQL_LCK_NO_CHANGE	&lt;C: #define SQL_LCK_NO_CHANGE 0x00000001	&gt;</body><body package="DB2EXDI">SQL_LCK_UNLOCK	&lt;C: #define SQL_LCK_UNLOCK 0x00000004	&gt;</body><body package="DB2EXDI">SQL_LD_COMPAT_DEFAULT	&lt;C: #define SQL_LD_COMPAT_DEFAULT SQL_LD_COMPAT_NO	&gt;</body><body package="DB2EXDI">SQL_LD_COMPAT_NO	&lt;C: #define SQL_LD_COMPAT_NO 0	&gt;</body><body package="DB2EXDI">SQL_LD_COMPAT_YES	&lt;C: #define SQL_LD_COMPAT_YES 1	&gt;</body><body package="DB2EXDI">SQL_LEN_BINARY_ATTR_OFFSET	&lt;C: #define SQL_LEN_BINARY_ATTR_OFFSET (-100)	&gt;</body><body package="DB2EXDI">SQL_LEN_DATA_AT_EXEC_OFFSET	&lt;C: #define SQL_LEN_DATA_AT_EXEC_OFFSET (-100)	&gt;</body><body package="DB2EXDI">SQL_LIKE_ESCAPE_CLAUSE	&lt;C: #define SQL_LIKE_ESCAPE_CLAUSE 113	&gt;</body><body package="DB2EXDI">SQL_LIKE_ONLY	&lt;C: #define SQL_LIKE_ONLY 1	&gt;</body><body package="DB2EXDI">SQL_LOCK_EXCLUSIVE	&lt;C: #define SQL_LOCK_EXCLUSIVE 1	&gt;</body><body package="DB2EXDI">SQL_LOCK_NO_CHANGE	&lt;C: #define SQL_LOCK_NO_CHANGE 0	&gt;</body><body package="DB2EXDI">SQL_LOCK_TYPES	&lt;C: #define SQL_LOCK_TYPES 78	&gt;</body><body package="DB2EXDI">SQL_LOCK_UNLOCK	&lt;C: #define SQL_LOCK_UNLOCK 2	&gt;</body><body package="DB2EXDI">SQL_LOGIN_TIMEOUT	&lt;C: #define SQL_LOGIN_TIMEOUT 103	&gt;</body><body package="DB2EXDI">SQL_LOGIN_TIMEOUT_DEFAULT	&lt;C: #define SQL_LOGIN_TIMEOUT_DEFAULT 15	&gt;</body><body package="DB2EXDI">SQL_LONGDATA_COMPAT	&lt;C: #define SQL_LONGDATA_COMPAT 1253	&gt;</body><body package="DB2EXDI">SQL_LONGVARBINARY	&lt;C: #define SQL_LONGVARBINARY (-4)	&gt;</body><body package="DB2EXDI">SQL_LONGVARCHAR	&lt;C: #define SQL_LONGVARCHAR (-1)	&gt;</body><body package="DB2EXDI">SQL_LONGVARGRAPHIC	&lt;C: #define SQL_LONGVARGRAPHIC -97	&gt;</body><body package="DB2EXDI">SQL_MAXCONN	&lt;C: #define SQL_MAXCONN 1262	&gt;</body><body package="DB2EXDI">SQL_MAXIMUM_CATALOG_NAME_LENGTH	&lt;C: #define SQL_MAXIMUM_CATALOG_NAME_LENGTH SQL_MAX_CATALOG_NAME_LEN	&gt;</body><body package="DB2EXDI">SQL_MAXIMUM_COLUMNS_IN_GROUP_BY	&lt;C: #define SQL_MAXIMUM_COLUMNS_IN_GROUP_BY SQL_MAX_COLUMNS_IN_GROUP_BY	&gt;</body><body package="DB2EXDI">SQL_MAXIMUM_COLUMNS_IN_INDEX	&lt;C: #define SQL_MAXIMUM_COLUMNS_IN_INDEX SQL_MAX_COLUMNS_IN_INDEX	&gt;</body><body package="DB2EXDI">SQL_MAXIMUM_COLUMNS_IN_ORDER_BY	&lt;C: #define SQL_MAXIMUM_COLUMNS_IN_ORDER_BY SQL_MAX_COLUMNS_IN_ORDER_BY	&gt;</body><body package="DB2EXDI">SQL_MAXIMUM_COLUMNS_IN_SELECT	&lt;C: #define SQL_MAXIMUM_COLUMNS_IN_SELECT SQL_MAX_COLUMNS_IN_SELECT	&gt;</body><body package="DB2EXDI">SQL_MAXIMUM_COLUMN_NAME_LENGTH	&lt;C: #define SQL_MAXIMUM_COLUMN_NAME_LENGTH SQL_MAX_COLUMN_NAME_LEN	&gt;</body><body package="DB2EXDI">SQL_MAXIMUM_CONCURRENT_ACTIVITIES	&lt;C: #define SQL_MAXIMUM_CONCURRENT_ACTIVITIES SQL_MAX_CONCURRENT_ACTIVITIES	&gt;</body><body package="DB2EXDI">SQL_MAXIMUM_CURSOR_NAME_LENGTH	&lt;C: #define SQL_MAXIMUM_CURSOR_NAME_LENGTH SQL_MAX_CURSOR_NAME_LEN	&gt;</body><body package="DB2EXDI">SQL_MAXIMUM_DRIVER_CONNECTIONS	&lt;C: #define SQL_MAXIMUM_DRIVER_CONNECTIONS SQL_MAX_DRIVER_CONNECTIONS	&gt;</body><body package="DB2EXDI">SQL_MAXIMUM_IDENTIFIER_LENGTH	&lt;C: #define SQL_MAXIMUM_IDENTIFIER_LENGTH SQL_MAX_IDENTIFIER_LEN	&gt;</body><body package="DB2EXDI">SQL_MAXIMUM_INDEX_SIZE	&lt;C: #define SQL_MAXIMUM_INDEX_SIZE SQL_MAX_INDEX_SIZE	&gt;</body><body package="DB2EXDI">SQL_MAXIMUM_ROW_SIZE	&lt;C: #define SQL_MAXIMUM_ROW_SIZE SQL_MAX_ROW_SIZE	&gt;</body><body package="DB2EXDI">SQL_MAXIMUM_SCHEMA_NAME_LENGTH	&lt;C: #define SQL_MAXIMUM_SCHEMA_NAME_LENGTH SQL_MAX_SCHEMA_NAME_LEN	&gt;</body><body package="DB2EXDI">SQL_MAXIMUM_STATEMENT_LENGTH	&lt;C: #define SQL_MAXIMUM_STATEMENT_LENGTH SQL_MAX_STATEMENT_LEN	&gt;</body><body package="DB2EXDI">SQL_MAXIMUM_TABLES_IN_SELECT	&lt;C: #define SQL_MAXIMUM_TABLES_IN_SELECT SQL_MAX_TABLES_IN_SELECT	&gt;</body><body package="DB2EXDI">SQL_MAXIMUM_USER_NAME_LENGTH	&lt;C: #define SQL_MAXIMUM_USER_NAME_LENGTH SQL_MAX_USER_NAME_LEN	&gt;</body><body package="DB2EXDI">SQL_MAX_ASYNC_CONCURRENT_STATEMENTS	&lt;C: #define SQL_MAX_ASYNC_CONCURRENT_STATEMENTS 10022	&gt;</body><body package="DB2EXDI">SQL_MAX_BINARY_LITERAL_LEN	&lt;C: #define SQL_MAX_BINARY_LITERAL_LEN 112	&gt;</body><body package="DB2EXDI">SQL_MAX_CATALOG_NAME_LEN	&lt;C: #define SQL_MAX_CATALOG_NAME_LEN SQL_MAX_QUALIFIER_NAME_LEN	&gt;</body><body package="DB2EXDI">SQL_MAX_CHAR_LITERAL_LEN	&lt;C: #define SQL_MAX_CHAR_LITERAL_LEN 108	&gt;</body><body package="DB2EXDI">SQL_MAX_COLUMNS_IN_GROUP_BY	&lt;C: #define SQL_MAX_COLUMNS_IN_GROUP_BY 97	&gt;</body><body package="DB2EXDI">SQL_MAX_COLUMNS_IN_INDEX	&lt;C: #define SQL_MAX_COLUMNS_IN_INDEX 98	&gt;</body><body package="DB2EXDI">SQL_MAX_COLUMNS_IN_ORDER_BY	&lt;C: #define SQL_MAX_COLUMNS_IN_ORDER_BY 99	&gt;</body><body package="DB2EXDI">SQL_MAX_COLUMNS_IN_SELECT	&lt;C: #define SQL_MAX_COLUMNS_IN_SELECT 100	&gt;</body><body package="DB2EXDI">SQL_MAX_COLUMNS_IN_TABLE	&lt;C: #define SQL_MAX_COLUMNS_IN_TABLE 101	&gt;</body><body package="DB2EXDI">SQL_MAX_COLUMN_NAME_LEN	&lt;C: #define SQL_MAX_COLUMN_NAME_LEN 30	&gt;</body><body package="DB2EXDI">SQL_MAX_CONCURRENT_ACTIVITIES	&lt;C: #define SQL_MAX_CONCURRENT_ACTIVITIES 1	&gt;</body><body package="DB2EXDI">SQL_MAX_CURSOR_NAME_LEN	&lt;C: #define SQL_MAX_CURSOR_NAME_LEN 31	&gt;</body><body package="DB2EXDI">SQL_MAX_C_NUMERIC_PRECISION	&lt;C: #define SQL_MAX_C_NUMERIC_PRECISION 38	&gt;</body><body package="DB2EXDI">SQL_MAX_DRIVER_CONNECTIONS	&lt;C: #define SQL_MAX_DRIVER_CONNECTIONS 0	&gt;</body><body package="DB2EXDI">SQL_MAX_DSN_LENGTH	&lt;C: #define SQL_MAX_DSN_LENGTH 32	&gt;</body><body package="DB2EXDI">SQL_MAX_IDENTIFIER_LEN	&lt;C: #define SQL_MAX_IDENTIFIER_LEN 10005	&gt;</body><body package="DB2EXDI">SQL_MAX_ID_LENGTH	&lt;C: #define SQL_MAX_ID_LENGTH 128 	&gt;</body><body package="DB2EXDI">SQL_MAX_INDEX_SIZE	&lt;C: #define SQL_MAX_INDEX_SIZE 102	&gt;</body><body package="DB2EXDI">SQL_MAX_LENGTH	&lt;C: #define SQL_MAX_LENGTH 3	&gt;</body><body package="DB2EXDI">SQL_MAX_LENGTH_DEFAULT	&lt;C: #define SQL_MAX_LENGTH_DEFAULT 0	&gt;</body><body package="DB2EXDI">SQL_MAX_MESSAGE_LENGTH	&lt;C: #define SQL_MAX_MESSAGE_LENGTH 1024	&gt;</body><body package="DB2EXDI">SQL_MAX_NUMERIC_LEN	&lt;C: #define SQL_MAX_NUMERIC_LEN 16	&gt;</body><body package="DB2EXDI">SQL_MAX_OPTION_STRING_LENGTH	&lt;C: #define SQL_MAX_OPTION_STRING_LENGTH 256	&gt;</body><body package="DB2EXDI">SQL_MAX_OWNER_NAME_LEN	&lt;C: #define SQL_MAX_OWNER_NAME_LEN 32	&gt;</body><body package="DB2EXDI">SQL_MAX_PROCEDURE_NAME_LEN	&lt;C: #define SQL_MAX_PROCEDURE_NAME_LEN 33	&gt;</body><body package="DB2EXDI">SQL_MAX_QUALIFIER_NAME_LEN	&lt;C: #define SQL_MAX_QUALIFIER_NAME_LEN 34	&gt;</body><body package="DB2EXDI">SQL_MAX_ROWS	&lt;C: #define SQL_MAX_ROWS 1	&gt;</body><body package="DB2EXDI">SQL_MAX_ROWS_DEFAULT	&lt;C: #define SQL_MAX_ROWS_DEFAULT 0	&gt;</body><body package="DB2EXDI">SQL_MAX_ROW_SIZE	&lt;C: #define SQL_MAX_ROW_SIZE 104	&gt;</body><body package="DB2EXDI">SQL_MAX_ROW_SIZE_INCLUDES_LONG	&lt;C: #define SQL_MAX_ROW_SIZE_INCLUDES_LONG 103	&gt;</body><body package="DB2EXDI">SQL_MAX_SCHEMA_NAME_LEN	&lt;C: #define SQL_MAX_SCHEMA_NAME_LEN SQL_MAX_OWNER_NAME_LEN	&gt;</body><body package="DB2EXDI">SQL_MAX_STATEMENT_LEN	&lt;C: #define SQL_MAX_STATEMENT_LEN 105	&gt;</body><body package="DB2EXDI">SQL_MAX_TABLES_IN_SELECT	&lt;C: #define SQL_MAX_TABLES_IN_SELECT 106	&gt;</body><body package="DB2EXDI">SQL_MAX_TABLE_NAME_LEN	&lt;C: #define SQL_MAX_TABLE_NAME_LEN 35	&gt;</body><body package="DB2EXDI">SQL_MAX_USER_NAME_LEN	&lt;C: #define SQL_MAX_USER_NAME_LEN 107	&gt;</body><body package="DB2EXDI">SQL_MINMEMORY_USAGE	&lt;C: #define SQL_MINMEMORY_USAGE 1263	&gt;</body><body package="DB2EXDI">SQL_MODE_DEFAULT	&lt;C: #define SQL_MODE_DEFAULT SQL_MODE_READ_WRITE	&gt;</body><body package="DB2EXDI">SQL_MODE_READ_ONLY	&lt;C: #define SQL_MODE_READ_ONLY 1	&gt;</body><body package="DB2EXDI">SQL_MODE_READ_WRITE	&lt;C: #define SQL_MODE_READ_WRITE 0	&gt;</body><body package="DB2EXDI">SQL_MULTIPLE_ACTIVE_TXN	&lt;C: #define SQL_MULTIPLE_ACTIVE_TXN 37	&gt;</body><body package="DB2EXDI">SQL_MULT_RESULT_SETS	&lt;C: #define SQL_MULT_RESULT_SETS 36	&gt;</body><body package="DB2EXDI">SQL_NAMED	&lt;C: #define SQL_NAMED 0	&gt;</body><body package="DB2EXDI">SQL_NC_END	&lt;C: #define SQL_NC_END 0x0004	&gt;</body><body package="DB2EXDI">SQL_NC_HIGH	&lt;C: #define SQL_NC_HIGH 0	&gt;</body><body package="DB2EXDI">SQL_NC_LOW	&lt;C: #define SQL_NC_LOW 1	&gt;</body><body package="DB2EXDI">SQL_NC_START	&lt;C: #define SQL_NC_START 0x0002	&gt;</body><body package="DB2EXDI">SQL_NEED_DATA	&lt;C: #define SQL_NEED_DATA 99	&gt;</body><body package="DB2EXDI">SQL_NEED_LONG_DATA_LEN	&lt;C: #define SQL_NEED_LONG_DATA_LEN 111	&gt;</body><body package="DB2EXDI">SQL_NNC_NON_NULL	&lt;C: #define SQL_NNC_NON_NULL 0x0001	&gt;</body><body package="DB2EXDI">SQL_NNC_NULL	&lt;C: #define SQL_NNC_NULL 0x0000	&gt;</body><body package="DB2EXDI">SQL_NODESCRIBE	&lt;C: #define SQL_NODESCRIBE SQL_NODESCRIBE_OUTPUT	&gt;</body><body package="DB2EXDI">SQL_NODESCRIBE_DEFAULT	&lt;C: #define SQL_NODESCRIBE_DEFAULT SQL_NODESCRIBE_OFF	&gt;</body><body package="DB2EXDI">SQL_NODESCRIBE_INPUT	&lt;C: #define SQL_NODESCRIBE_INPUT 1264	&gt;</body><body package="DB2EXDI">SQL_NODESCRIBE_OFF	&lt;C: #define SQL_NODESCRIBE_OFF 0	&gt;</body><body package="DB2EXDI">SQL_NODESCRIBE_ON	&lt;C: #define SQL_NODESCRIBE_ON 1	&gt;</body><body package="DB2EXDI">SQL_NODESCRIBE_OUTPUT	&lt;C: #define SQL_NODESCRIBE_OUTPUT 1251	&gt;</body><body package="DB2EXDI">SQL_NONSCROLLABLE	&lt;C: #define SQL_NONSCROLLABLE 0	&gt;</body><body package="DB2EXDI">SQL_NON_NULLABLE_COLUMNS	&lt;C: #define SQL_NON_NULLABLE_COLUMNS 75	&gt;</body><body package="DB2EXDI">SQL_NOSCAN	&lt;C: #define SQL_NOSCAN 2	&gt;</body><body package="DB2EXDI">SQL_NOSCAN_DEFAULT	&lt;C: #define SQL_NOSCAN_DEFAULT SQL_NOSCAN_OFF	&gt;</body><body package="DB2EXDI">SQL_NOSCAN_OFF	&lt;C: #define SQL_NOSCAN_OFF 0	&gt;</body><body package="DB2EXDI">SQL_NOSCAN_ON	&lt;C: #define SQL_NOSCAN_ON 1	&gt;</body><body package="DB2EXDI">SQL_NOT_DEFERRABLE	&lt;C: #define SQL_NOT_DEFERRABLE 7	&gt;</body><body package="DB2EXDI">SQL_NO_ACTION	&lt;C: #define SQL_NO_ACTION 3	&gt;</body><body package="DB2EXDI">SQL_NO_COLUMN_NUMBER	&lt;C: #define SQL_NO_COLUMN_NUMBER (-1)	&gt;</body><body package="DB2EXDI">SQL_NO_DATA	&lt;C: #define SQL_NO_DATA 100	&gt;</body><body package="DB2EXDI">SQL_NO_DATA_FOUND	&lt;C: #define SQL_NO_DATA_FOUND SQL_NO_DATA	&gt;</body><body package="DB2EXDI">SQL_NO_NULLS	&lt;C: #define SQL_NO_NULLS 0	&gt;</body><body package="DB2EXDI">SQL_NO_ROW_NUMBER	&lt;C: #define SQL_NO_ROW_NUMBER (-1)	&gt;</body><body package="DB2EXDI">SQL_NO_TOTAL	&lt;C: #define SQL_NO_TOTAL (-4)	&gt;</body><body package="DB2EXDI">SQL_NTS	&lt;C: #define SQL_NTS -3	&gt;</body><body package="DB2EXDI">SQL_NTSL	&lt;C: #define SQL_NTSL -3	&gt;</body><body package="DB2EXDI">SQL_NULLABLE	&lt;C: #define SQL_NULLABLE 1	&gt;</body><body package="DB2EXDI">SQL_NULLABLE_UNKNOWN	&lt;C: #define SQL_NULLABLE_UNKNOWN 2	&gt;</body><body package="DB2EXDI">SQL_NULL_COLLATION	&lt;C: #define SQL_NULL_COLLATION 85	&gt;</body><body package="DB2EXDI">SQL_NULL_DATA	&lt;C: #define SQL_NULL_DATA -1	&gt;</body><body package="DB2EXDI">SQL_NULL_HANDLE	&lt;C: #define SQL_NULL_HANDLE 0	&gt;</body><body package="DB2EXDI">SQL_NULL_HDBC	&lt;C: #define SQL_NULL_HDBC 0	&gt;</body><body package="DB2EXDI">SQL_NULL_HDESC	&lt;C: #define SQL_NULL_HDESC 0	&gt;</body><body package="DB2EXDI">SQL_NULL_HENV	&lt;C: #define SQL_NULL_HENV 0	&gt;</body><body package="DB2EXDI">SQL_NULL_HSTMT	&lt;C: #define SQL_NULL_HSTMT 0	&gt;</body><body package="DB2EXDI">SQL_NUMERIC	&lt;C: #define SQL_NUMERIC 2	&gt;</body><body package="DB2EXDI">SQL_NUMERIC_FUNCTIONS	&lt;C: #define SQL_NUMERIC_FUNCTIONS 49	&gt;</body><body package="DB2EXDI">SQL_OAC_LEVEL1	&lt;C: #define SQL_OAC_LEVEL1 0x0001	&gt;</body><body package="DB2EXDI">SQL_OAC_LEVEL2	&lt;C: #define SQL_OAC_LEVEL2 0x0002	&gt;</body><body package="DB2EXDI">SQL_OAC_NONE	&lt;C: #define SQL_OAC_NONE 0x0000	&gt;</body><body package="DB2EXDI">SQL_ODBC_API_CONFORMANCE	&lt;C: #define SQL_ODBC_API_CONFORMANCE 9	&gt;</body><body package="DB2EXDI">SQL_ODBC_CURSORS	&lt;C: #define SQL_ODBC_CURSORS 110	&gt;</body><body package="DB2EXDI">SQL_ODBC_INTERFACE_CONFORMANCE	&lt;C: #define SQL_ODBC_INTERFACE_CONFORMANCE 152	&gt;</body><body package="DB2EXDI">SQL_ODBC_KEYWORDS	&lt;C: #define SQL_ODBC_KEYWORDS "ABSOLUTE,ACTION,ADA,ADD,ALL,ALLOCATE,ALTER,AND,ANY,ARE,AS,ASC,ASSERTION,AT,AUTHORIZATION,AVG,BEGIN,BETWEEN,BIT,BIT_LENGTH,BOTH,BY,CASCADE,CASCADED,CASE,CAST,CATALOG,CHAR,CHAR_LENGTH,CHARACTER,CHARACTER_LENGTH,CHECK,CLOSE,COALESCE,COLLATE,COLLATION,COLUMN,COMMIT,CONNECT,CONNECTION,CONSTRAINT,CONSTRAINTS,CONTINUE,CONVERT,CORRESPONDING,COUNT,CREATE,CROSS,CURRENT,CURRENT_DATE,CURRENT_TIME,CURRENT_TIMESTAMP,CURRENT_USER,CURSOR,DATE,DAY,DEALLOCATE,DEC,DECIMAL,DECLARE,DEFAULT,DEFERRABLE,DEFERRED,DELETE,DESC,DESCRIBE,DESCRIPTOR,DIAGNOSTICS,DISCONNECT,DISTINCT,DOMAIN,DOUBLE,DROP,ELSE,END,END-EXEC,ESCAPE,EXCEPT,EXCEPTION,EXEC,EXECUTE,EXISTS,EXTERNAL,EXTRACT,FALSE,FETCH,FIRST,FLOAT,FOR,FOREIGN,FORTRAN,FOUND,FROM,FULL,GET,GLOBAL,GO,GOTO,GRANT,GROUP,HAVING,HOUR,IDENTITY,IMMEDIATE,IN,INCLUDE,INDEX,INDICATOR,INITIALLY,INNER,INPUT,INSENSITIVE,INSERT,INT,INTEGER,INTERSECT,INTERVAL,INTO,IS,ISOLATION,JOIN,KEY,LANGUAGE,LAST,LEADING,LEFT,LEVEL,LIKE,LOCAL,LOWER,MATCH,MAX,MIN,MINUTE,MODULE,MONTH,NAMES,NATIONAL,NATURAL,NCHAR,NEXT,NO,NONE,NOT,NULL,NULLIF,NUMERIC,OCTET_LENGTH,OF,ON,ONLY,OPEN,OPTION,OR,ORDER,OUTER,OUTPUT,OVERLAPS,PAD,PARTIAL,PASCAL,PLI,POSITION,PRECISION,PREPARE,PRESERVE,PRIMARY,PRIOR,PRIVILEGES,PROCEDURE,PUBLIC,READ,REAL,REFERENCES,RELATIVE,RESTRICT,REVOKE,RIGHT,ROLLBACK,ROWSSCHEMA,SCROLL,SECOND,SECTION,SELECT,SESSION,SESSION_USER,SET,SIZE,SMALLINT,SOME,SPACE,SQL,SQLCA,SQLCODE,SQLERROR,SQLSTATE,SQLWARNING,SUBSTRING,SUM,SYSTEM_USER,TABLE,TEMPORARY,THEN,TIME,TIMESTAMP,TIMEZONE_HOUR,TIMEZONE_MINUTE,TO,TRAILING,TRANSACTION,TRANSLATE,TRANSLATION,TRIM,TRUE,UNION,UNIQUE,UNKNOWN,UPDATE,UPPER,USAGE,USER,USING,VALUE,VALUES,VARCHAR,VARYING,VIEW,WHEN,WHENEVER,WHERE,WITH,WORK,WRITE,YEAR,ZONE" SQLRETURN SQL_API SQLBrowseC	&gt;</body><body package="DB2EXDI">SQL_ODBC_SAG_CLI_CONFORMANCE	&lt;C: #define SQL_ODBC_SAG_CLI_CONFORMANCE 12	&gt;</body><body package="DB2EXDI">SQL_ODBC_SQL_CONFORMANCE	&lt;C: #define SQL_ODBC_SQL_CONFORMANCE 15	&gt;</body><body package="DB2EXDI">SQL_ODBC_SQL_OPT_IEF	&lt;C: #define SQL_ODBC_SQL_OPT_IEF 73	&gt;</body><body package="DB2EXDI">SQL_ODBC_VER	&lt;C: #define SQL_ODBC_VER 10	&gt;</body><body package="DB2EXDI">SQL_OIC_CORE	&lt;C: #define SQL_OIC_CORE 1	&gt;</body><body package="DB2EXDI">SQL_OIC_LEVEL1	&lt;C: #define SQL_OIC_LEVEL1 2	&gt;</body><body package="DB2EXDI">SQL_OIC_LEVEL2	&lt;C: #define SQL_OIC_LEVEL2 3	&gt;</body><body package="DB2EXDI">SQL_OJ_ALL_COMPARISON_OPS	&lt;C: #define SQL_OJ_ALL_COMPARISON_OPS 0x00000040	&gt;</body><body package="DB2EXDI">SQL_OJ_CAPABILITIES	&lt;C: #define SQL_OJ_CAPABILITIES 115	&gt;</body><body package="DB2EXDI">SQL_OJ_FULL	&lt;C: #define SQL_OJ_FULL 0x00000004	&gt;</body><body package="DB2EXDI">SQL_OJ_INNER	&lt;C: #define SQL_OJ_INNER 0x00000020	&gt;</body><body package="DB2EXDI">SQL_OJ_LEFT	&lt;C: #define SQL_OJ_LEFT 0x00000001	&gt;</body><body package="DB2EXDI">SQL_OJ_NESTED	&lt;C: #define SQL_OJ_NESTED 0x00000008	&gt;</body><body package="DB2EXDI">SQL_OJ_NOT_ORDERED	&lt;C: #define SQL_OJ_NOT_ORDERED 0x00000010	&gt;</body><body package="DB2EXDI">SQL_OJ_RIGHT	&lt;C: #define SQL_OJ_RIGHT 0x00000002	&gt;</body><body package="DB2EXDI">SQL_ONEPHASE	&lt;C: #define SQL_ONEPHASE 1	&gt;</body><body package="DB2EXDI">SQL_OPTIMIZE_SQLCOLUMNS_DEFAULT	&lt;C: #define SQL_OPTIMIZE_SQLCOLUMNS_DEFAULT SQL_OPTIMIZE_SQLCOLUMNS_OFF	&gt;</body><body package="DB2EXDI">SQL_OPTIMIZE_SQLCOLUMNS_OFF	&lt;C: #define SQL_OPTIMIZE_SQLCOLUMNS_OFF 0	&gt;</body><body package="DB2EXDI">SQL_OPTIMIZE_SQLCOLUMNS_ON	&lt;C: #define SQL_OPTIMIZE_SQLCOLUMNS_ON 1	&gt;</body><body package="DB2EXDI">SQL_OPT_TRACE	&lt;C: #define SQL_OPT_TRACE 104	&gt;</body><body package="DB2EXDI">SQL_OPT_TRACEFILE	&lt;C: #define SQL_OPT_TRACEFILE 105	&gt;</body><body package="DB2EXDI">SQL_OPT_TRACE_DEFAULT	&lt;C: #define SQL_OPT_TRACE_DEFAULT SQL_OPT_TRACE_OFF	&gt;</body><body package="DB2EXDI">SQL_OPT_TRACE_FILE_DEFAULT	&lt;C: #define SQL_OPT_TRACE_FILE_DEFAULT "\\SQL.LOG"	&gt;</body><body package="DB2EXDI">SQL_OPT_TRACE_OFF	&lt;C: #define SQL_OPT_TRACE_OFF 0	&gt;</body><body package="DB2EXDI">SQL_OPT_TRACE_ON	&lt;C: #define SQL_OPT_TRACE_ON 1	&gt;</body><body package="DB2EXDI">SQL_ORDER_BY_COLUMNS_IN_SELECT	&lt;C: #define SQL_ORDER_BY_COLUMNS_IN_SELECT 90	&gt;</body><body package="DB2EXDI">SQL_OSCC_COMPLIANT	&lt;C: #define SQL_OSCC_COMPLIANT 0x0001	&gt;</body><body package="DB2EXDI">SQL_OSCC_NOT_COMPLIANT	&lt;C: #define SQL_OSCC_NOT_COMPLIANT 0x0000	&gt;</body><body package="DB2EXDI">SQL_OSC_CORE	&lt;C: #define SQL_OSC_CORE 0x0001	&gt;</body><body package="DB2EXDI">SQL_OSC_EXTENDED	&lt;C: #define SQL_OSC_EXTENDED 0x0002	&gt;</body><body package="DB2EXDI">SQL_OSC_MINIMUM	&lt;C: #define SQL_OSC_MINIMUM 0x0000	&gt;</body><body package="DB2EXDI">SQL_OUTER_JOINS	&lt;C: #define SQL_OUTER_JOINS 38	&gt;</body><body package="DB2EXDI">SQL_OUTER_JOIN_CAPABILITIES	&lt;C: #define SQL_OUTER_JOIN_CAPABILITIES SQL_OJ_CAPABILITIES	&gt;</body><body package="DB2EXDI">SQL_OU_DML_STATEMENTS	&lt;C: #define SQL_OU_DML_STATEMENTS 0x00000001	&gt;</body><body package="DB2EXDI">SQL_OU_INDEX_DEFINITION	&lt;C: #define SQL_OU_INDEX_DEFINITION 0x00000008	&gt;</body><body package="DB2EXDI">SQL_OU_PRIVILEGE_DEFINITION	&lt;C: #define SQL_OU_PRIVILEGE_DEFINITION 0x00000010	&gt;</body><body package="DB2EXDI">SQL_OU_PROCEDURE_INVOCATION	&lt;C: #define SQL_OU_PROCEDURE_INVOCATION 0x00000002	&gt;</body><body package="DB2EXDI">SQL_OU_TABLE_DEFINITION	&lt;C: #define SQL_OU_TABLE_DEFINITION 0x00000004	&gt;</body><body package="DB2EXDI">SQL_OV_ODBC2	&lt;C: #define SQL_OV_ODBC2 2	&gt;</body><body package="DB2EXDI">SQL_OV_ODBC3	&lt;C: #define SQL_OV_ODBC3 3	&gt;</body><body package="DB2EXDI">SQL_OWNER_TERM	&lt;C: #define SQL_OWNER_TERM 39	&gt;</body><body package="DB2EXDI">SQL_OWNER_USAGE	&lt;C: #define SQL_OWNER_USAGE 91	&gt;</body><body package="DB2EXDI">SQL_PACKET_SIZE	&lt;C: #define SQL_PACKET_SIZE 112	&gt;</body><body package="DB2EXDI">SQL_PARAMOPT_ATOMIC	&lt;C: #define SQL_PARAMOPT_ATOMIC 1260	&gt;</body><body package="DB2EXDI">SQL_PARAM_ARRAY_ROW_COUNTS	&lt;C: #define SQL_PARAM_ARRAY_ROW_COUNTS 153	&gt;</body><body package="DB2EXDI">SQL_PARAM_ARRAY_SELECTS	&lt;C: #define SQL_PARAM_ARRAY_SELECTS 154	&gt;</body><body package="DB2EXDI">SQL_PARAM_BIND_BY_COLUMN	&lt;C: #define SQL_PARAM_BIND_BY_COLUMN 0	&gt;</body><body package="DB2EXDI">SQL_PARAM_BIND_TYPE_DEFAULT	&lt;C: #define SQL_PARAM_BIND_TYPE_DEFAULT SQL_PARAM_BIND_BY_COLUMN	&gt;</body><body package="DB2EXDI">SQL_PARAM_DIAG_UNAVAILABLE	&lt;C: #define SQL_PARAM_DIAG_UNAVAILABLE 1	&gt;</body><body package="DB2EXDI">SQL_PARAM_ERROR	&lt;C: #define SQL_PARAM_ERROR 5	&gt;</body><body package="DB2EXDI">SQL_PARAM_IGNORE	&lt;C: #define SQL_PARAM_IGNORE 1	&gt;</body><body package="DB2EXDI">SQL_PARAM_INPUT	&lt;C: #define SQL_PARAM_INPUT 1	&gt;</body><body package="DB2EXDI">SQL_PARAM_INPUT_OUTPUT	&lt;C: #define SQL_PARAM_INPUT_OUTPUT 2	&gt;</body><body package="DB2EXDI">SQL_PARAM_OUTPUT	&lt;C: #define SQL_PARAM_OUTPUT 4	&gt;</body><body package="DB2EXDI">SQL_PARAM_PROCEED	&lt;C: #define SQL_PARAM_PROCEED 0	&gt;</body><body package="DB2EXDI">SQL_PARAM_SUCCESS	&lt;C: #define SQL_PARAM_SUCCESS 0	&gt;</body><body package="DB2EXDI">SQL_PARAM_SUCCESS_WITH_INFO	&lt;C: #define SQL_PARAM_SUCCESS_WITH_INFO 6	&gt;</body><body package="DB2EXDI">SQL_PARAM_TYPE_DEFAULT	&lt;C: #define SQL_PARAM_TYPE_DEFAULT SQL_PARAM_INPUT_OUTPUT	&gt;</body><body package="DB2EXDI">SQL_PARAM_TYPE_UNKNOWN	&lt;C: #define SQL_PARAM_TYPE_UNKNOWN 0	&gt;</body><body package="DB2EXDI">SQL_PARAM_UNUSED	&lt;C: #define SQL_PARAM_UNUSED 7	&gt;</body><body package="DB2EXDI">SQL_PARC_BATCH	&lt;C: #define SQL_PARC_BATCH 1	&gt;</body><body package="DB2EXDI">SQL_PARC_NO_BATCH	&lt;C: #define SQL_PARC_NO_BATCH 2	&gt;</body><body package="DB2EXDI">SQL_PAS_BATCH	&lt;C: #define SQL_PAS_BATCH 1	&gt;</body><body package="DB2EXDI">SQL_PAS_NO_BATCH	&lt;C: #define SQL_PAS_NO_BATCH 2	&gt;</body><body package="DB2EXDI">SQL_PAS_NO_SELECT	&lt;C: #define SQL_PAS_NO_SELECT 3	&gt;</body><body package="DB2EXDI">SQL_PC_NON_PSEUDO	&lt;C: #define SQL_PC_NON_PSEUDO 1	&gt;</body><body package="DB2EXDI">SQL_PC_NOT_PSEUDO	&lt;C: #define SQL_PC_NOT_PSEUDO 1	&gt;</body><body package="DB2EXDI">SQL_PC_PSEUDO	&lt;C: #define SQL_PC_PSEUDO 2	&gt;</body><body package="DB2EXDI">SQL_PC_UNKNOWN	&lt;C: #define SQL_PC_UNKNOWN 0	&gt;</body><body package="DB2EXDI">SQL_POINTER	&lt;C: #define SQL_POINTER 	&gt;</body><body package="DB2EXDI">SQL_POSITION	&lt;C: #define SQL_POSITION 0	&gt;</body><body package="DB2EXDI">SQL_POSITIONED_STATEMENTS	&lt;C: #define SQL_POSITIONED_STATEMENTS 80	&gt;</body><body package="DB2EXDI">SQL_POS_ADD	&lt;C: #define SQL_POS_ADD 0x00000010	&gt;</body><body package="DB2EXDI">SQL_POS_DELETE	&lt;C: #define SQL_POS_DELETE 0x00000008	&gt;</body><body package="DB2EXDI">SQL_POS_OPERATIONS	&lt;C: #define SQL_POS_OPERATIONS 79	&gt;</body><body package="DB2EXDI">SQL_POS_POSITION	&lt;C: #define SQL_POS_POSITION 0x00000001	&gt;</body><body package="DB2EXDI">SQL_POS_REFRESH	&lt;C: #define SQL_POS_REFRESH 0x00000002	&gt;</body><body package="DB2EXDI">SQL_POS_UPDATE	&lt;C: #define SQL_POS_UPDATE 0x00000004	&gt;</body><body package="DB2EXDI">SQL_PRED_BASIC	&lt;C: #define SQL_PRED_BASIC 2	&gt;</body><body package="DB2EXDI">SQL_PRED_CHAR	&lt;C: #define SQL_PRED_CHAR 1	&gt;</body><body package="DB2EXDI">SQL_PRED_NONE	&lt;C: #define SQL_PRED_NONE 0	&gt;</body><body package="DB2EXDI">SQL_PRED_SEARCHABLE	&lt;C: #define SQL_PRED_SEARCHABLE SQL_SEARCHABLE	&gt;</body><body package="DB2EXDI">SQL_PREFETCH_DEFAULT	&lt;C: #define SQL_PREFETCH_DEFAULT SQL_PREFETCH_OFF	&gt;</body><body package="DB2EXDI">SQL_PREFETCH_OFF	&lt;C: #define SQL_PREFETCH_OFF 0	&gt;</body><body package="DB2EXDI">SQL_PREFETCH_ON	&lt;C: #define SQL_PREFETCH_ON 1	&gt;</body><body package="DB2EXDI">SQL_PROCEDURES	&lt;C: #define SQL_PROCEDURES 21	&gt;</body><body package="DB2EXDI">SQL_PROCEDURE_TERM	&lt;C: #define SQL_PROCEDURE_TERM 40	&gt;</body><body package="DB2EXDI">SQL_PROCESSCTL_NOFORK	&lt;C: #define SQL_PROCESSCTL_NOFORK 0x00000002	&gt;</body><body package="DB2EXDI">SQL_PROCESSCTL_NOTHREAD	&lt;C: #define SQL_PROCESSCTL_NOTHREAD 0x00000001	&gt;</body><body package="DB2EXDI">SQL_PROCESSCTL_SHARESTMTDESC	&lt;C: #define SQL_PROCESSCTL_SHARESTMTDESC 0x00000004	&gt;</body><body package="DB2EXDI">SQL_PS_POSITIONED_DELETE	&lt;C: #define SQL_PS_POSITIONED_DELETE 0x00000001	&gt;</body><body package="DB2EXDI">SQL_PS_POSITIONED_UPDATE	&lt;C: #define SQL_PS_POSITIONED_UPDATE 0x00000002	&gt;</body><body package="DB2EXDI">SQL_PS_SELECT_FOR_UPDATE	&lt;C: #define SQL_PS_SELECT_FOR_UPDATE 0x00000004	&gt;</body><body package="DB2EXDI">SQL_PT_FUNCTION	&lt;C: #define SQL_PT_FUNCTION 2	&gt;</body><body package="DB2EXDI">SQL_PT_PROCEDURE	&lt;C: #define SQL_PT_PROCEDURE 1	&gt;</body><body package="DB2EXDI">SQL_PT_UNKNOWN	&lt;C: #define SQL_PT_UNKNOWN 0	&gt;</body><body package="DB2EXDI">SQL_QL_END	&lt;C: #define SQL_QL_END 0x0002	&gt;</body><body package="DB2EXDI">SQL_QL_START	&lt;C: #define SQL_QL_START 0x0001	&gt;</body><body package="DB2EXDI">SQL_QUALIFIER_LOCATION	&lt;C: #define SQL_QUALIFIER_LOCATION 114	&gt;</body><body package="DB2EXDI">SQL_QUALIFIER_NAME_SEPARATOR	&lt;C: #define SQL_QUALIFIER_NAME_SEPARATOR 41	&gt;</body><body package="DB2EXDI">SQL_QUALIFIER_TERM	&lt;C: #define SQL_QUALIFIER_TERM 42	&gt;</body><body package="DB2EXDI">SQL_QUALIFIER_USAGE	&lt;C: #define SQL_QUALIFIER_USAGE 92	&gt;</body><body package="DB2EXDI">SQL_QUERY_TIMEOUT	&lt;C: #define SQL_QUERY_TIMEOUT 0	&gt;</body><body package="DB2EXDI">SQL_QUERY_TIMEOUT_DEFAULT	&lt;C: #define SQL_QUERY_TIMEOUT_DEFAULT 0	&gt;</body><body package="DB2EXDI">SQL_QUICK	&lt;C: #define SQL_QUICK 0	&gt;</body><body package="DB2EXDI">SQL_QUIET_MODE	&lt;C: #define SQL_QUIET_MODE 111	&gt;</body><body package="DB2EXDI">SQL_QUOTED_IDENTIFIER_CASE	&lt;C: #define SQL_QUOTED_IDENTIFIER_CASE 93	&gt;</body><body package="DB2EXDI">SQL_QU_DML_STATEMENTS	&lt;C: #define SQL_QU_DML_STATEMENTS 0x00000001	&gt;</body><body package="DB2EXDI">SQL_QU_INDEX_DEFINITION	&lt;C: #define SQL_QU_INDEX_DEFINITION 0x00000008	&gt;</body><body package="DB2EXDI">SQL_QU_PRIVILEGE_DEFINITION	&lt;C: #define SQL_QU_PRIVILEGE_DEFINITION 0x00000010	&gt;</body><body package="DB2EXDI">SQL_QU_PROCEDURE_INVOCATION	&lt;C: #define SQL_QU_PROCEDURE_INVOCATION 0x00000002	&gt;</body><body package="DB2EXDI">SQL_QU_TABLE_DEFINITION	&lt;C: #define SQL_QU_TABLE_DEFINITION 0x00000004	&gt;</body><body package="DB2EXDI">SQL_RD_DEFAULT	&lt;C: #define SQL_RD_DEFAULT SQL_RD_ON	&gt;</body><body package="DB2EXDI">SQL_RD_OFF	&lt;C: #define SQL_RD_OFF 0	&gt;</body><body package="DB2EXDI">SQL_RD_ON	&lt;C: #define SQL_RD_ON 1	&gt;</body><body package="DB2EXDI">SQL_REAL	&lt;C: #define SQL_REAL 7	&gt;</body><body package="DB2EXDI">SQL_REFRESH	&lt;C: #define SQL_REFRESH 1	&gt;</body><body package="DB2EXDI">SQL_RESET_PARAMS	&lt;C: #define SQL_RESET_PARAMS 3	&gt;</body><body package="DB2EXDI">SQL_RESTRICT	&lt;C: #define SQL_RESTRICT 1	&gt;</body><body package="DB2EXDI">SQL_RESULT_COL	&lt;C: #define SQL_RESULT_COL 3	&gt;</body><body package="DB2EXDI">SQL_RETRIEVE_DATA	&lt;C: #define SQL_RETRIEVE_DATA 11	&gt;</body><body package="DB2EXDI">SQL_RETURN_VALUE	&lt;C: #define SQL_RETURN_VALUE 5	&gt;</body><body package="DB2EXDI">SQL_ROLLBACK	&lt;C: #define SQL_ROLLBACK 1	&gt;</body><body package="DB2EXDI">SQL_ROWSET_SIZE	&lt;C: #define SQL_ROWSET_SIZE 9	&gt;</body><body package="DB2EXDI">SQL_ROWSET_SIZE_DEFAULT	&lt;C: #define SQL_ROWSET_SIZE_DEFAULT 1	&gt;</body><body package="DB2EXDI">SQL_ROWVER	&lt;C: #define SQL_ROWVER 2	&gt;</body><body package="DB2EXDI">SQL_ROW_ADDED	&lt;C: #define SQL_ROW_ADDED 4	&gt;</body><body package="DB2EXDI">SQL_ROW_DELETED	&lt;C: #define SQL_ROW_DELETED 1	&gt;</body><body package="DB2EXDI">SQL_ROW_ERROR	&lt;C: #define SQL_ROW_ERROR 5	&gt;</body><body package="DB2EXDI">SQL_ROW_IDENTIFIER	&lt;C: #define SQL_ROW_IDENTIFIER 1	&gt;</body><body package="DB2EXDI">SQL_ROW_IGNORE	&lt;C: #define SQL_ROW_IGNORE 1	&gt;</body><body package="DB2EXDI">SQL_ROW_NOROW	&lt;C: #define SQL_ROW_NOROW 3	&gt;</body><body package="DB2EXDI">SQL_ROW_NO_ROW_NUMBER	&lt;C: #define SQL_ROW_NO_ROW_NUMBER (-1)	&gt;</body><body package="DB2EXDI">SQL_ROW_NUMBER	&lt;C: #define SQL_ROW_NUMBER 14	&gt;</body><body package="DB2EXDI">SQL_ROW_NUMBER_UNKNOWN	&lt;C: #define SQL_ROW_NUMBER_UNKNOWN (-2)	&gt;</body><body package="DB2EXDI">SQL_ROW_PROCEED	&lt;C: #define SQL_ROW_PROCEED 0	&gt;</body><body package="DB2EXDI">SQL_ROW_SUCCESS	&lt;C: #define SQL_ROW_SUCCESS 0	&gt;</body><body package="DB2EXDI">SQL_ROW_SUCCESS_WITH_INFO	&lt;C: #define SQL_ROW_SUCCESS_WITH_INFO 6	&gt;</body><body package="DB2EXDI">SQL_ROW_UPDATED	&lt;C: #define SQL_ROW_UPDATED 2	&gt;</body><body package="DB2EXDI">SQL_ROW_UPDATES	&lt;C: #define SQL_ROW_UPDATES 11	&gt;</body><body package="DB2EXDI">SQL_SCCO_LOCK	&lt;C: #define SQL_SCCO_LOCK 0x00000002	&gt;</body><body package="DB2EXDI">SQL_SCCO_OPT_ROWVER	&lt;C: #define SQL_SCCO_OPT_ROWVER 0x00000004	&gt;</body><body package="DB2EXDI">SQL_SCCO_OPT_TIMESTAMP	&lt;C: #define SQL_SCCO_OPT_TIMESTAMP SQL_SCCO_OPT_ROWVER	&gt;</body><body package="DB2EXDI">SQL_SCCO_OPT_VALUES	&lt;C: #define SQL_SCCO_OPT_VALUES 0x00000008	&gt;</body><body package="DB2EXDI">SQL_SCCO_READ_ONLY	&lt;C: #define SQL_SCCO_READ_ONLY 0x00000001	&gt;</body><body package="DB2EXDI">SQL_SCC_ISO92_CLI	&lt;C: #define SQL_SCC_ISO92_CLI 0x00000002	&gt;</body><body package="DB2EXDI">SQL_SCC_XOPEN_CLI_VERSION1	&lt;C: #define SQL_SCC_XOPEN_CLI_VERSION1 0x00000001	&gt;</body><body package="DB2EXDI">SQL_SCHEMA_TERM	&lt;C: #define SQL_SCHEMA_TERM SQL_OWNER_TERM	&gt;</body><body package="DB2EXDI">SQL_SCHEMA_USAGE	&lt;C: #define SQL_SCHEMA_USAGE SQL_OWNER_USAGE	&gt;</body><body package="DB2EXDI">SQL_SCOPE_CURROW	&lt;C: #define SQL_SCOPE_CURROW 0	&gt;</body><body package="DB2EXDI">SQL_SCOPE_SESSION	&lt;C: #define SQL_SCOPE_SESSION 2	&gt;</body><body package="DB2EXDI">SQL_SCOPE_TRANSACTION	&lt;C: #define SQL_SCOPE_TRANSACTION 1	&gt;</body><body package="DB2EXDI">SQL_SCROLLABLE	&lt;C: #define SQL_SCROLLABLE 1	&gt;</body><body package="DB2EXDI">SQL_SCROLL_CONCURRENCY	&lt;C: #define SQL_SCROLL_CONCURRENCY 43	&gt;</body><body package="DB2EXDI">SQL_SCROLL_DYNAMIC	&lt;C: #define SQL_SCROLL_DYNAMIC (-2)	&gt;</body><body package="DB2EXDI">SQL_SCROLL_FORWARD_ONLY	&lt;C: #define SQL_SCROLL_FORWARD_ONLY 0	&gt;</body><body package="DB2EXDI">SQL_SCROLL_KEYSET_DRIVEN	&lt;C: #define SQL_SCROLL_KEYSET_DRIVEN (-1)	&gt;</body><body package="DB2EXDI">SQL_SCROLL_OPTIONS	&lt;C: #define SQL_SCROLL_OPTIONS 44	&gt;</body><body package="DB2EXDI">SQL_SCROLL_STATIC	&lt;C: #define SQL_SCROLL_STATIC (-3)	&gt;</body><body package="DB2EXDI">SQL_SC_FIPS127_2_TRANSITIONAL	&lt;C: #define SQL_SC_FIPS127_2_TRANSITIONAL 0x00000002	&gt;</body><body package="DB2EXDI">SQL_SC_NON_UNIQUE	&lt;C: #define SQL_SC_NON_UNIQUE 0	&gt;</body><body package="DB2EXDI">SQL_SC_SQL92_ENTRY	&lt;C: #define SQL_SC_SQL92_ENTRY 0x00000001	&gt;</body><body package="DB2EXDI">SQL_SC_SQL92_FULL	&lt;C: #define SQL_SC_SQL92_FULL 0x00000008	&gt;</body><body package="DB2EXDI">SQL_SC_SQL92_INTERMEDIATE	&lt;C: #define SQL_SC_SQL92_INTERMEDIATE 0x00000004	&gt;</body><body package="DB2EXDI">SQL_SC_TRY_UNIQUE	&lt;C: #define SQL_SC_TRY_UNIQUE 1	&gt;</body><body package="DB2EXDI">SQL_SC_UNIQUE	&lt;C: #define SQL_SC_UNIQUE 2	&gt;</body><body package="DB2EXDI">SQL_SDF_CURRENT_DATE	&lt;C: #define SQL_SDF_CURRENT_DATE 0x00000001	&gt;</body><body package="DB2EXDI">SQL_SDF_CURRENT_TIME	&lt;C: #define SQL_SDF_CURRENT_TIME 0x00000002	&gt;</body><body package="DB2EXDI">SQL_SDF_CURRENT_TIMESTAMP	&lt;C: #define SQL_SDF_CURRENT_TIMESTAMP 0x00000004	&gt;</body><body package="DB2EXDI">SQL_SEARCHABLE	&lt;C: #define SQL_SEARCHABLE 3	&gt;</body><body package="DB2EXDI">SQL_SEARCH_PATTERN_ESCAPE	&lt;C: #define SQL_SEARCH_PATTERN_ESCAPE 14	&gt;</body><body package="DB2EXDI">SQL_SENSITIVE	&lt;C: #define SQL_SENSITIVE 2	&gt;</body><body package="DB2EXDI">SQL_SERVER_NAME	&lt;C: #define SQL_SERVER_NAME 13	&gt;</body><body package="DB2EXDI">SQL_SETPARAM_VALUE_MAX	&lt;C: #define SQL_SETPARAM_VALUE_MAX (-1)	&gt;</body><body package="DB2EXDI">SQL_SETPOS_MAX_LOCK_VALUE	&lt;C: #define SQL_SETPOS_MAX_LOCK_VALUE SQL_LOCK_UNLOCK	&gt;</body><body package="DB2EXDI">SQL_SETPOS_MAX_OPTION_VALUE	&lt;C: #define SQL_SETPOS_MAX_OPTION_VALUE SQL_ADD	&gt;</body><body package="DB2EXDI">SQL_SET_DEFAULT	&lt;C: #define SQL_SET_DEFAULT 4	&gt;</body><body package="DB2EXDI">SQL_SET_NULL	&lt;C: #define SQL_SET_NULL 2	&gt;</body><body package="DB2EXDI">SQL_SFKD_CASCADE	&lt;C: #define SQL_SFKD_CASCADE 0x00000001	&gt;</body><body package="DB2EXDI">SQL_SFKD_NO_ACTION	&lt;C: #define SQL_SFKD_NO_ACTION 0x00000002	&gt;</body><body package="DB2EXDI">SQL_SFKD_SET_DEFAULT	&lt;C: #define SQL_SFKD_SET_DEFAULT 0x00000004	&gt;</body><body package="DB2EXDI">SQL_SFKD_SET_NULL	&lt;C: #define SQL_SFKD_SET_NULL 0x00000008	&gt;</body><body package="DB2EXDI">SQL_SFKU_CASCADE	&lt;C: #define SQL_SFKU_CASCADE 0x00000001	&gt;</body><body package="DB2EXDI">SQL_SFKU_NO_ACTION	&lt;C: #define SQL_SFKU_NO_ACTION 0x00000002	&gt;</body><body package="DB2EXDI">SQL_SFKU_SET_DEFAULT	&lt;C: #define SQL_SFKU_SET_DEFAULT 0x00000004	&gt;</body><body package="DB2EXDI">SQL_SFKU_SET_NULL	&lt;C: #define SQL_SFKU_SET_NULL 0x00000008	&gt;</body><body package="DB2EXDI">SQL_SG_DELETE_TABLE	&lt;C: #define SQL_SG_DELETE_TABLE 0x00000020	&gt;</body><body package="DB2EXDI">SQL_SG_INSERT_COLUMN	&lt;C: #define SQL_SG_INSERT_COLUMN 0x00000080	&gt;</body><body package="DB2EXDI">SQL_SG_INSERT_TABLE	&lt;C: #define SQL_SG_INSERT_TABLE 0x00000040	&gt;</body><body package="DB2EXDI">SQL_SG_REFERENCES_COLUMN	&lt;C: #define SQL_SG_REFERENCES_COLUMN 0x00000200	&gt;</body><body package="DB2EXDI">SQL_SG_REFERENCES_TABLE	&lt;C: #define SQL_SG_REFERENCES_TABLE 0x00000100	&gt;</body><body package="DB2EXDI">SQL_SG_SELECT_TABLE	&lt;C: #define SQL_SG_SELECT_TABLE 0x00000400	&gt;</body><body package="DB2EXDI">SQL_SG_UPDATE_COLUMN	&lt;C: #define SQL_SG_UPDATE_COLUMN 0x00001000	&gt;</body><body package="DB2EXDI">SQL_SG_UPDATE_TABLE	&lt;C: #define SQL_SG_UPDATE_TABLE 0x00000800	&gt;</body><body package="DB2EXDI">SQL_SG_USAGE_ON_CHARACTER_SET	&lt;C: #define SQL_SG_USAGE_ON_CHARACTER_SET 0x00000002	&gt;</body><body package="DB2EXDI">SQL_SG_USAGE_ON_COLLATION	&lt;C: #define SQL_SG_USAGE_ON_COLLATION 0x00000004	&gt;</body><body package="DB2EXDI">SQL_SG_USAGE_ON_DOMAIN	&lt;C: #define SQL_SG_USAGE_ON_DOMAIN 0x00000001	&gt;</body><body package="DB2EXDI">SQL_SG_USAGE_ON_TRANSLATION	&lt;C: #define SQL_SG_USAGE_ON_TRANSLATION 0x00000008	&gt;</body><body package="DB2EXDI">SQL_SG_WITH_GRANT_OPTION	&lt;C: #define SQL_SG_WITH_GRANT_OPTION 0x00000010	&gt;</body><body package="DB2EXDI">SQL_SIGNED_OFFSET	&lt;C: #define SQL_SIGNED_OFFSET (-20)	&gt;</body><body package="DB2EXDI">SQL_SIMULATE_CURSOR	&lt;C: #define SQL_SIMULATE_CURSOR 10	&gt;</body><body package="DB2EXDI">SQL_SMALLINT	&lt;C: #define SQL_SMALLINT 5	&gt;</body><body package="DB2EXDI">SQL_SNVF_BIT_LENGTH	&lt;C: #define SQL_SNVF_BIT_LENGTH 0x00000001	&gt;</body><body package="DB2EXDI">SQL_SNVF_CHARACTER_LENGTH	&lt;C: #define SQL_SNVF_CHARACTER_LENGTH 0x00000004	&gt;</body><body package="DB2EXDI">SQL_SNVF_CHAR_LENGTH	&lt;C: #define SQL_SNVF_CHAR_LENGTH 0x00000002	&gt;</body><body package="DB2EXDI">SQL_SNVF_EXTRACT	&lt;C: #define SQL_SNVF_EXTRACT 0x00000008	&gt;</body><body package="DB2EXDI">SQL_SNVF_OCTET_LENGTH	&lt;C: #define SQL_SNVF_OCTET_LENGTH 0x00000010	&gt;</body><body package="DB2EXDI">SQL_SNVF_POSITION	&lt;C: #define SQL_SNVF_POSITION 0x00000020	&gt;</body><body package="DB2EXDI">SQL_SO_DYNAMIC	&lt;C: #define SQL_SO_DYNAMIC 0x00000004	&gt;</body><body package="DB2EXDI">SQL_SO_FORWARD_ONLY	&lt;C: #define SQL_SO_FORWARD_ONLY 0x00000001	&gt;</body><body package="DB2EXDI">SQL_SO_KEYSET_DRIVEN	&lt;C: #define SQL_SO_KEYSET_DRIVEN 0x00000002	&gt;</body><body package="DB2EXDI">SQL_SO_MIXED	&lt;C: #define SQL_SO_MIXED 0x00000008	&gt;</body><body package="DB2EXDI">SQL_SO_STATIC	&lt;C: #define SQL_SO_STATIC 0x00000010	&gt;</body><body package="DB2EXDI">SQL_SPECIAL_CHARACTERS	&lt;C: #define SQL_SPECIAL_CHARACTERS 94	&gt;</body><body package="DB2EXDI">SQL_SPEC_MAJOR	&lt;C: #define SQL_SPEC_MAJOR 3	&gt;</body><body package="DB2EXDI">SQL_SPEC_MINOR	&lt;C: #define SQL_SPEC_MINOR 51	&gt;</body><body package="DB2EXDI">SQL_SPEC_STRING	&lt;C: #define SQL_SPEC_STRING "03.51"	&gt;</body><body package="DB2EXDI">SQL_SP_BETWEEN	&lt;C: #define SQL_SP_BETWEEN 0x00000800	&gt;</body><body package="DB2EXDI">SQL_SP_COMPARISON	&lt;C: #define SQL_SP_COMPARISON 0x00001000	&gt;</body><body package="DB2EXDI">SQL_SP_EXISTS	&lt;C: #define SQL_SP_EXISTS 0x00000001	&gt;</body><body package="DB2EXDI">SQL_SP_IN	&lt;C: #define SQL_SP_IN 0x00000400	&gt;</body><body package="DB2EXDI">SQL_SP_ISNOTNULL	&lt;C: #define SQL_SP_ISNOTNULL 0x00000002	&gt;</body><body package="DB2EXDI">SQL_SP_ISNULL	&lt;C: #define SQL_SP_ISNULL 0x00000004	&gt;</body><body package="DB2EXDI">SQL_SP_LIKE	&lt;C: #define SQL_SP_LIKE 0x00000200	&gt;</body><body package="DB2EXDI">SQL_SP_MATCH_FULL	&lt;C: #define SQL_SP_MATCH_FULL 0x00000008	&gt;</body><body package="DB2EXDI">SQL_SP_MATCH_PARTIAL	&lt;C: #define SQL_SP_MATCH_PARTIAL 0x00000010	&gt;</body><body package="DB2EXDI">SQL_SP_MATCH_UNIQUE_FULL	&lt;C: #define SQL_SP_MATCH_UNIQUE_FULL 0x00000020	&gt;</body><body package="DB2EXDI">SQL_SP_MATCH_UNIQUE_PARTIAL	&lt;C: #define SQL_SP_MATCH_UNIQUE_PARTIAL 0x00000040	&gt;</body><body package="DB2EXDI">SQL_SP_OVERLAPS	&lt;C: #define SQL_SP_OVERLAPS 0x00000080	&gt;</body><body package="DB2EXDI">SQL_SP_QUANTIFIED_COMPARISON	&lt;C: #define SQL_SP_QUANTIFIED_COMPARISON 0x00002000	&gt;</body><body package="DB2EXDI">SQL_SP_UNIQUE	&lt;C: #define SQL_SP_UNIQUE 0x00000100	&gt;</body><body package="DB2EXDI">SQL_SQL92_DATETIME_FUNCTIONS	&lt;C: #define SQL_SQL92_DATETIME_FUNCTIONS 155	&gt;</body><body package="DB2EXDI">SQL_SQL92_FOREIGN_KEY_DELETE_RULE	&lt;C: #define SQL_SQL92_FOREIGN_KEY_DELETE_RULE 156	&gt;</body><body package="DB2EXDI">SQL_SQL92_FOREIGN_KEY_UPDATE_RULE	&lt;C: #define SQL_SQL92_FOREIGN_KEY_UPDATE_RULE 157	&gt;</body><body package="DB2EXDI">SQL_SQL92_GRANT	&lt;C: #define SQL_SQL92_GRANT 158	&gt;</body><body package="DB2EXDI">SQL_SQL92_NUMERIC_VALUE_FUNCTIONS	&lt;C: #define SQL_SQL92_NUMERIC_VALUE_FUNCTIONS 159	&gt;</body><body package="DB2EXDI">SQL_SQL92_PREDICATES	&lt;C: #define SQL_SQL92_PREDICATES 160	&gt;</body><body package="DB2EXDI">SQL_SQL92_RELATIONAL_JOIN_OPERATORS	&lt;C: #define SQL_SQL92_RELATIONAL_JOIN_OPERATORS 161	&gt;</body><body package="DB2EXDI">SQL_SQL92_REVOKE	&lt;C: #define SQL_SQL92_REVOKE 162	&gt;</body><body package="DB2EXDI">SQL_SQL92_ROW_VALUE_CONSTRUCTOR	&lt;C: #define SQL_SQL92_ROW_VALUE_CONSTRUCTOR 163	&gt;</body><body package="DB2EXDI">SQL_SQL92_STRING_FUNCTIONS	&lt;C: #define SQL_SQL92_STRING_FUNCTIONS 164	&gt;</body><body package="DB2EXDI">SQL_SQL92_VALUE_EXPRESSIONS	&lt;C: #define SQL_SQL92_VALUE_EXPRESSIONS 165	&gt;</body><body package="DB2EXDI">SQL_SQLSTATE_SIZE	&lt;C: #define SQL_SQLSTATE_SIZE 5	&gt;</body><body package="DB2EXDI">SQL_SQL_CONFORMANCE	&lt;C: #define SQL_SQL_CONFORMANCE 118	&gt;</body><body package="DB2EXDI">SQL_SQ_COMPARISON	&lt;C: #define SQL_SQ_COMPARISON 0x00000001	&gt;</body><body package="DB2EXDI">SQL_SQ_CORRELATED_SUBQUERIES	&lt;C: #define SQL_SQ_CORRELATED_SUBQUERIES 0x00000010	&gt;</body><body package="DB2EXDI">SQL_SQ_EXISTS	&lt;C: #define SQL_SQ_EXISTS 0x00000002	&gt;</body><body package="DB2EXDI">SQL_SQ_IN	&lt;C: #define SQL_SQ_IN 0x00000004	&gt;</body><body package="DB2EXDI">SQL_SQ_QUANTIFIED	&lt;C: #define SQL_SQ_QUANTIFIED 0x00000008	&gt;</body><body package="DB2EXDI">SQL_SRJO_CORRESPONDING_CLAUSE	&lt;C: #define SQL_SRJO_CORRESPONDING_CLAUSE 0x00000001	&gt;</body><body package="DB2EXDI">SQL_SRJO_CROSS_JOIN	&lt;C: #define SQL_SRJO_CROSS_JOIN 0x00000002	&gt;</body><body package="DB2EXDI">SQL_SRJO_EXCEPT_JOIN	&lt;C: #define SQL_SRJO_EXCEPT_JOIN 0x00000004	&gt;</body><body package="DB2EXDI">SQL_SRJO_FULL_OUTER_JOIN	&lt;C: #define SQL_SRJO_FULL_OUTER_JOIN 0x00000008	&gt;</body><body package="DB2EXDI">SQL_SRJO_INNER_JOIN	&lt;C: #define SQL_SRJO_INNER_JOIN 0x00000010	&gt;</body><body package="DB2EXDI">SQL_SRJO_INTERSECT_JOIN	&lt;C: #define SQL_SRJO_INTERSECT_JOIN 0x00000020	&gt;</body><body package="DB2EXDI">SQL_SRJO_LEFT_OUTER_JOIN	&lt;C: #define SQL_SRJO_LEFT_OUTER_JOIN 0x00000040	&gt;</body><body package="DB2EXDI">SQL_SRJO_NATURAL_JOIN	&lt;C: #define SQL_SRJO_NATURAL_JOIN 0x00000080	&gt;</body><body package="DB2EXDI">SQL_SRJO_RIGHT_OUTER_JOIN	&lt;C: #define SQL_SRJO_RIGHT_OUTER_JOIN 0x00000100	&gt;</body><body package="DB2EXDI">SQL_SRJO_UNION_JOIN	&lt;C: #define SQL_SRJO_UNION_JOIN 0x00000200	&gt;</body><body package="DB2EXDI">SQL_SRVC_DEFAULT	&lt;C: #define SQL_SRVC_DEFAULT 0x00000004	&gt;</body><body package="DB2EXDI">SQL_SRVC_NULL	&lt;C: #define SQL_SRVC_NULL 0x00000002	&gt;</body><body package="DB2EXDI">SQL_SRVC_ROW_SUBQUERY	&lt;C: #define SQL_SRVC_ROW_SUBQUERY 0x00000008	&gt;</body><body package="DB2EXDI">SQL_SRVC_VALUE_EXPRESSION	&lt;C: #define SQL_SRVC_VALUE_EXPRESSION 0x00000001	&gt;</body><body package="DB2EXDI">SQL_SR_CASCADE	&lt;C: #define SQL_SR_CASCADE 0x00000020	&gt;</body><body package="DB2EXDI">SQL_SR_DELETE_TABLE	&lt;C: #define SQL_SR_DELETE_TABLE 0x00000080	&gt;</body><body package="DB2EXDI">SQL_SR_GRANT_OPTION_FOR	&lt;C: #define SQL_SR_GRANT_OPTION_FOR 0x00000010	&gt;</body><body package="DB2EXDI">SQL_SR_INSERT_COLUMN	&lt;C: #define SQL_SR_INSERT_COLUMN 0x00000200	&gt;</body><body package="DB2EXDI">SQL_SR_INSERT_TABLE	&lt;C: #define SQL_SR_INSERT_TABLE 0x00000100	&gt;</body><body package="DB2EXDI">SQL_SR_REFERENCES_COLUMN	&lt;C: #define SQL_SR_REFERENCES_COLUMN 0x00000800	&gt;</body><body package="DB2EXDI">SQL_SR_REFERENCES_TABLE	&lt;C: #define SQL_SR_REFERENCES_TABLE 0x00000400	&gt;</body><body package="DB2EXDI">SQL_SR_RESTRICT	&lt;C: #define SQL_SR_RESTRICT 0x00000040	&gt;</body><body package="DB2EXDI">SQL_SR_SELECT_TABLE	&lt;C: #define SQL_SR_SELECT_TABLE 0x00001000	&gt;</body><body package="DB2EXDI">SQL_SR_UPDATE_COLUMN	&lt;C: #define SQL_SR_UPDATE_COLUMN 0x00004000	&gt;</body><body package="DB2EXDI">SQL_SR_UPDATE_TABLE	&lt;C: #define SQL_SR_UPDATE_TABLE 0x00002000	&gt;</body><body package="DB2EXDI">SQL_SR_USAGE_ON_CHARACTER_SET	&lt;C: #define SQL_SR_USAGE_ON_CHARACTER_SET 0x00000002	&gt;</body><body package="DB2EXDI">SQL_SR_USAGE_ON_COLLATION	&lt;C: #define SQL_SR_USAGE_ON_COLLATION 0x00000004	&gt;</body><body package="DB2EXDI">SQL_SR_USAGE_ON_DOMAIN	&lt;C: #define SQL_SR_USAGE_ON_DOMAIN 0x00000001	&gt;</body><body package="DB2EXDI">SQL_SR_USAGE_ON_TRANSLATION	&lt;C: #define SQL_SR_USAGE_ON_TRANSLATION 0x00000008	&gt;</body><body package="DB2EXDI">SQL_SSF_CONVERT	&lt;C: #define SQL_SSF_CONVERT 0x00000001	&gt;</body><body package="DB2EXDI">SQL_SSF_LOWER	&lt;C: #define SQL_SSF_LOWER 0x00000002	&gt;</body><body package="DB2EXDI">SQL_SSF_SUBSTRING	&lt;C: #define SQL_SSF_SUBSTRING 0x00000008	&gt;</body><body package="DB2EXDI">SQL_SSF_TRANSLATE	&lt;C: #define SQL_SSF_TRANSLATE 0x00000010	&gt;</body><body package="DB2EXDI">SQL_SSF_TRIM_BOTH	&lt;C: #define SQL_SSF_TRIM_BOTH 0x00000020	&gt;</body><body package="DB2EXDI">SQL_SSF_TRIM_LEADING	&lt;C: #define SQL_SSF_TRIM_LEADING 0x00000040	&gt;</body><body package="DB2EXDI">SQL_SSF_TRIM_TRAILING	&lt;C: #define SQL_SSF_TRIM_TRAILING 0x00000080	&gt;</body><body package="DB2EXDI">SQL_SSF_UPPER	&lt;C: #define SQL_SSF_UPPER 0x00000004	&gt;</body><body package="DB2EXDI">SQL_SS_ADDITIONS	&lt;C: #define SQL_SS_ADDITIONS 0x00000001	&gt;</body><body package="DB2EXDI">SQL_SS_DELETIONS	&lt;C: #define SQL_SS_DELETIONS 0x00000002	&gt;</body><body package="DB2EXDI">SQL_SS_UPDATES	&lt;C: #define SQL_SS_UPDATES 0x00000004	&gt;</body><body package="DB2EXDI">SQL_STANDARD_CLI_CONFORMANCE	&lt;C: #define SQL_STANDARD_CLI_CONFORMANCE 166	&gt;</body><body package="DB2EXDI">SQL_STATICMODE_CAPTURE	&lt;C: #define SQL_STATICMODE_CAPTURE CLI_CAP_STATICMODE_CAPTURE	&gt;</body><body package="DB2EXDI">SQL_STATICMODE_DISABLED	&lt;C: #define SQL_STATICMODE_DISABLED CLI_CAP_STATICMODE_DISABLED	&gt;</body><body package="DB2EXDI">SQL_STATICMODE_MATCH	&lt;C: #define SQL_STATICMODE_MATCH CLI_CAP_STATICMODE_MATCH	&gt;</body><body package="DB2EXDI">SQL_STATIC_CURSOR_ATTRIBUTES1	&lt;C: #define SQL_STATIC_CURSOR_ATTRIBUTES1 167	&gt;</body><body package="DB2EXDI">SQL_STATIC_CURSOR_ATTRIBUTES2	&lt;C: #define SQL_STATIC_CURSOR_ATTRIBUTES2 168	&gt;</body><body package="DB2EXDI">SQL_STATIC_SENSITIVITY	&lt;C: #define SQL_STATIC_SENSITIVITY 83	&gt;</body><body package="DB2EXDI">SQL_STILL_EXECUTING	&lt;C: #define SQL_STILL_EXECUTING 2	&gt;</body><body package="DB2EXDI">SQL_STMTTXN_ISOLATION	&lt;C: #define SQL_STMTTXN_ISOLATION 1261	&gt;</body><body package="DB2EXDI">SQL_STRING_FUNCTIONS	&lt;C: #define SQL_STRING_FUNCTIONS 50	&gt;</body><body package="DB2EXDI">SQL_STRUCTURE	&lt;C: #define SQL_STRUCTURE struct	&gt;</body><body package="DB2EXDI">SQL_SUBQUERIES	&lt;C: #define SQL_SUBQUERIES 95	&gt;</body><body package="DB2EXDI">SQL_SUCCESS	&lt;C: #define SQL_SUCCESS 0	&gt;</body><body package="DB2EXDI">SQL_SUCCESS_WITH_INFO	&lt;C: #define SQL_SUCCESS_WITH_INFO 1	&gt;</body><body package="DB2EXDI">SQL_SU_DML_STATEMENTS	&lt;C: #define SQL_SU_DML_STATEMENTS SQL_OU_DML_STATEMENTS	&gt;</body><body package="DB2EXDI">SQL_SU_INDEX_DEFINITION	&lt;C: #define SQL_SU_INDEX_DEFINITION SQL_OU_INDEX_DEFINITION	&gt;</body><body package="DB2EXDI">SQL_SU_PRIVILEGE_DEFINITION	&lt;C: #define SQL_SU_PRIVILEGE_DEFINITION SQL_OU_PRIVILEGE_DEFINITION	&gt;</body><body package="DB2EXDI">SQL_SU_PROCEDURE_INVOCATION	&lt;C: #define SQL_SU_PROCEDURE_INVOCATION SQL_OU_PROCEDURE_INVOCATION	&gt;</body><body package="DB2EXDI">SQL_SU_TABLE_DEFINITION	&lt;C: #define SQL_SU_TABLE_DEFINITION SQL_OU_TABLE_DEFINITION	&gt;</body><body package="DB2EXDI">SQL_SVE_CASE	&lt;C: #define SQL_SVE_CASE 0x00000001	&gt;</body><body package="DB2EXDI">SQL_SVE_CAST	&lt;C: #define SQL_SVE_CAST 0x00000002	&gt;</body><body package="DB2EXDI">SQL_SVE_COALESCE	&lt;C: #define SQL_SVE_COALESCE 0x00000004	&gt;</body><body package="DB2EXDI">SQL_SVE_NULLIF	&lt;C: #define SQL_SVE_NULLIF 0x00000008	&gt;</body><body package="DB2EXDI">SQL_SYNCPOINT_DEFAULT	&lt;C: #define SQL_SYNCPOINT_DEFAULT SQL_ONEPHASE	&gt;</body><body package="DB2EXDI">SQL_SYNC_POINT	&lt;C: #define SQL_SYNC_POINT 1256	&gt;</body><body package="DB2EXDI">SQL_SYSTEM_FUNCTIONS	&lt;C: #define SQL_SYSTEM_FUNCTIONS 51	&gt;</body><body package="DB2EXDI">SQL_TABLE_STAT	&lt;C: #define SQL_TABLE_STAT 0	&gt;</body><body package="DB2EXDI">SQL_TABLE_TERM	&lt;C: #define SQL_TABLE_TERM 45	&gt;</body><body package="DB2EXDI">SQL_TC_ALL	&lt;C: #define SQL_TC_ALL 0x0002	&gt;</body><body package="DB2EXDI">SQL_TC_DDL_COMMIT	&lt;C: #define SQL_TC_DDL_COMMIT 0x0003	&gt;</body><body package="DB2EXDI">SQL_TC_DDL_IGNORE	&lt;C: #define SQL_TC_DDL_IGNORE 0x0004	&gt;</body><body package="DB2EXDI">SQL_TC_DML	&lt;C: #define SQL_TC_DML 0x0001	&gt;</body><body package="DB2EXDI">SQL_TC_NONE	&lt;C: #define SQL_TC_NONE 0x0000	&gt;</body><body package="DB2EXDI">SQL_TIME	&lt;C: #define SQL_TIME 10	&gt;</body><body package="DB2EXDI">SQL_TIMEDATE_ADD_INTERVALS	&lt;C: #define SQL_TIMEDATE_ADD_INTERVALS 109	&gt;</body><body package="DB2EXDI">SQL_TIMEDATE_DIFF_INTERVALS	&lt;C: #define SQL_TIMEDATE_DIFF_INTERVALS 110	&gt;</body><body package="DB2EXDI">SQL_TIMEDATE_FUNCTIONS	&lt;C: #define SQL_TIMEDATE_FUNCTIONS 52	&gt;</body><body package="DB2EXDI">SQL_TIMESTAMP	&lt;C: #define SQL_TIMESTAMP 11	&gt;</body><body package="DB2EXDI">SQL_TIMESTAMP_LEN	&lt;C: #define SQL_TIMESTAMP_LEN 19	&gt;</body><body package="DB2EXDI">SQL_TIME_LEN	&lt;C: #define SQL_TIME_LEN 8	&gt;</body><body package="DB2EXDI">SQL_TINYINT	&lt;C: #define SQL_TINYINT (-6)	&gt;</body><body package="DB2EXDI">SQL_TRANSACTION_CAPABLE	&lt;C: #define SQL_TRANSACTION_CAPABLE SQL_TXN_CAPABLE	&gt;</body><body package="DB2EXDI">SQL_TRANSACTION_ISOLATION_OPTION	&lt;C: #define SQL_TRANSACTION_ISOLATION_OPTION SQL_TXN_ISOLATION_OPTION	&gt;</body><body package="DB2EXDI">SQL_TRANSACTION_NOCOMMIT	&lt;C: #define SQL_TRANSACTION_NOCOMMIT SQL_TXN_NOCOMMIT	&gt;</body><body package="DB2EXDI">SQL_TRANSACTION_READ_COMMITTED	&lt;C: #define SQL_TRANSACTION_READ_COMMITTED SQL_TXN_READ_COMMITTED	&gt;</body><body package="DB2EXDI">SQL_TRANSACTION_READ_UNCOMMITTED	&lt;C: #define SQL_TRANSACTION_READ_UNCOMMITTED SQL_TXN_READ_UNCOMMITTED	&gt;</body><body package="DB2EXDI">SQL_TRANSACTION_REPEATABLE_READ	&lt;C: #define SQL_TRANSACTION_REPEATABLE_READ SQL_TXN_REPEATABLE_READ	&gt;</body><body package="DB2EXDI">SQL_TRANSACTION_SERIALIZABLE	&lt;C: #define SQL_TRANSACTION_SERIALIZABLE SQL_TXN_SERIALIZABLE	&gt;</body><body package="DB2EXDI">SQL_TRANSLATE_DLL	&lt;C: #define SQL_TRANSLATE_DLL 106	&gt;</body><body package="DB2EXDI">SQL_TRANSLATE_OPTION	&lt;C: #define SQL_TRANSLATE_OPTION 107	&gt;</body><body package="DB2EXDI">SQL_TRUE	&lt;C: #define SQL_TRUE 1	&gt;</body><body package="DB2EXDI">SQL_TWOPHASE	&lt;C: #define SQL_TWOPHASE 2	&gt;</body><body package="DB2EXDI">SQL_TXN_CAPABLE	&lt;C: #define SQL_TXN_CAPABLE 46	&gt;</body><body package="DB2EXDI">SQL_TXN_ISOLATION	&lt;C: #define SQL_TXN_ISOLATION 108	&gt;</body><body package="DB2EXDI">SQL_TXN_ISOLATION_OPTION	&lt;C: #define SQL_TXN_ISOLATION_OPTION 72	&gt;</body><body package="DB2EXDI">SQL_TXN_NOCOMMIT	&lt;C: #define SQL_TXN_NOCOMMIT 0x00000020	&gt;</body><body package="DB2EXDI">SQL_TXN_READ_COMMITTED	&lt;C: #define SQL_TXN_READ_COMMITTED 0x00000002	&gt;</body><body package="DB2EXDI">SQL_TXN_READ_UNCOMMITTED	&lt;C: #define SQL_TXN_READ_UNCOMMITTED 0x00000001	&gt;</body><body package="DB2EXDI">SQL_TXN_REPEATABLE_READ	&lt;C: #define SQL_TXN_REPEATABLE_READ 0x00000004	&gt;</body><body package="DB2EXDI">SQL_TXN_SERIALIZABLE	&lt;C: #define SQL_TXN_SERIALIZABLE 0x00000008	&gt;</body><body package="DB2EXDI">SQL_TYPE_BASE	&lt;C: #define SQL_TYPE_BASE 0	&gt;</body><body package="DB2EXDI">SQL_TYPE_DATE	&lt;C: #define SQL_TYPE_DATE 91	&gt;</body><body package="DB2EXDI">SQL_TYPE_DISTINCT	&lt;C: #define SQL_TYPE_DISTINCT 1	&gt;</body><body package="DB2EXDI">SQL_TYPE_NULL	&lt;C: #define SQL_TYPE_NULL 0	&gt;</body><body package="DB2EXDI">SQL_TYPE_REFERENCE	&lt;C: #define SQL_TYPE_REFERENCE 3	&gt;</body><body package="DB2EXDI">SQL_TYPE_STRUCTURED	&lt;C: #define SQL_TYPE_STRUCTURED 2	&gt;</body><body package="DB2EXDI">SQL_TYPE_TIME	&lt;C: #define SQL_TYPE_TIME 92	&gt;</body><body package="DB2EXDI">SQL_TYPE_TIMESTAMP	&lt;C: #define SQL_TYPE_TIMESTAMP 93	&gt;</body><body package="DB2EXDI">SQL_UB_DEFAULT	&lt;C: #define SQL_UB_DEFAULT SQL_UB_OFF	&gt;</body><body package="DB2EXDI">SQL_UB_FIXED	&lt;C: #define SQL_UB_FIXED SQL_UB_ON	&gt;</body><body package="DB2EXDI">SQL_UB_OFF	&lt;C: #define SQL_UB_OFF 0	&gt;</body><body package="DB2EXDI">SQL_UB_ON	&lt;C: #define SQL_UB_ON 1	&gt;</body><body package="DB2EXDI">SQL_UB_VARIABLE	&lt;C: #define SQL_UB_VARIABLE 2	&gt;</body><body package="DB2EXDI">SQL_UNBIND	&lt;C: #define SQL_UNBIND 2	&gt;</body><body package="DB2EXDI">SQL_UNICODE	&lt;C: #define SQL_UNICODE (-95)	&gt;</body><body package="DB2EXDI">SQL_UNICODE_CHAR	&lt;C: #define SQL_UNICODE_CHAR SQL_UNICODE	&gt;</body><body package="DB2EXDI">SQL_UNICODE_LONGVARCHAR	&lt;C: #define SQL_UNICODE_LONGVARCHAR (-97)	&gt;</body><body package="DB2EXDI">SQL_UNICODE_VARCHAR	&lt;C: #define SQL_UNICODE_VARCHAR (-96)	&gt;</body><body package="DB2EXDI">SQL_UNION	&lt;C: #define SQL_UNION 96	&gt;</body><body package="DB2EXDI">SQL_UNION_STATEMENT	&lt;C: #define SQL_UNION_STATEMENT SQL_UNION	&gt;</body><body package="DB2EXDI">SQL_UNKNOWN_TYPE	&lt;C: #define SQL_UNKNOWN_TYPE 0	&gt;</body><body package="DB2EXDI">SQL_UNNAMED	&lt;C: #define SQL_UNNAMED 1	&gt;</body><body package="DB2EXDI">SQL_UNSEARCHABLE	&lt;C: #define SQL_UNSEARCHABLE 0	&gt;</body><body package="DB2EXDI">SQL_UNSIGNED_OFFSET	&lt;C: #define SQL_UNSIGNED_OFFSET (-22)	&gt;</body><body package="DB2EXDI">SQL_UNSPECIFIED	&lt;C: #define SQL_UNSPECIFIED 0	&gt;</body><body package="DB2EXDI">SQL_UPDATE	&lt;C: #define SQL_UPDATE 2	&gt;</body><body package="DB2EXDI">SQL_UPDATE_BY_BOOKMARK	&lt;C: #define SQL_UPDATE_BY_BOOKMARK 5	&gt;</body><body package="DB2EXDI">SQL_UPDT_READONLY	&lt;C: #define SQL_UPDT_READONLY 0	&gt;</body><body package="DB2EXDI">SQL_UPDT_READWRITE_UNKNOWN	&lt;C: #define SQL_UPDT_READWRITE_UNKNOWN 2	&gt;</body><body package="DB2EXDI">SQL_UPDT_WRITE	&lt;C: #define SQL_UPDT_WRITE 1	&gt;</body><body package="DB2EXDI">SQL_USER_DEFINED_TYPE	&lt;C: #define SQL_USER_DEFINED_TYPE -450	&gt;</body><body package="DB2EXDI">SQL_USER_NAME	&lt;C: #define SQL_USER_NAME 47	&gt;</body><body package="DB2EXDI">SQL_USE_BOOKMARKS	&lt;C: #define SQL_USE_BOOKMARKS 12	&gt;</body><body package="DB2EXDI">SQL_US_UNION	&lt;C: #define SQL_US_UNION SQL_U_UNION	&gt;</body><body package="DB2EXDI">SQL_US_UNION_ALL	&lt;C: #define SQL_US_UNION_ALL SQL_U_UNION_ALL	&gt;</body><body package="DB2EXDI">SQL_U_UNION	&lt;C: #define SQL_U_UNION 0x00000001	&gt;</body><body package="DB2EXDI">SQL_U_UNION_ALL	&lt;C: #define SQL_U_UNION_ALL 0x00000002	&gt;</body><body package="DB2EXDI">SQL_VARBINARY	&lt;C: #define SQL_VARBINARY (-3)	&gt;</body><body package="DB2EXDI">SQL_VARCHAR	&lt;C: #define SQL_VARCHAR 12	&gt;</body><body package="DB2EXDI">SQL_VARGRAPHIC	&lt;C: #define SQL_VARGRAPHIC -96	&gt;</body><body package="DB2EXDI">SQL_WCHAR	&lt;C: #define SQL_WCHAR (-8)	&gt;</body><body package="DB2EXDI">SQL_WCHARTYPE	&lt;C: #define SQL_WCHARTYPE 1252	&gt;</body><body package="DB2EXDI">SQL_WCHARTYPE_DEFAULT	&lt;C: #define SQL_WCHARTYPE_DEFAULT SQL_WCHARTYPE_NOCONVERT	&gt;</body><body package="DB2EXDI">SQL_WCHARTYPE_NOCONVERT	&lt;C: #define SQL_WCHARTYPE_NOCONVERT 0	&gt;</body><body package="DB2EXDI">SQL_WLONGVARCHAR	&lt;C: #define SQL_WLONGVARCHAR (-10)	&gt;</body><body package="DB2EXDI">SQL_WVARCHAR	&lt;C: #define SQL_WVARCHAR (-9)	&gt;</body><body package="DB2EXDI">SQL_XOPEN_CLI_YEAR	&lt;C: #define SQL_XOPEN_CLI_YEAR 10000	&gt;</body><body package="DB2EXDI">_SQLOLDCHAR	&lt;C: #define _SQLOLDCHAR char	&gt;</body><body package="DB2EXDI">__DATE__	&lt;C: #define __DATE__ "June 5, 2000"	&gt;</body><body package="DB2EXDI">__FILE__	&lt;C: #define __FILE__ 	&gt;</body><body package="DB2EXDI">__LINE__	&lt;C: #define __LINE__ 0	&gt;</body><body package="DB2EXDI">__SQL	&lt;C: #define __SQL 	&gt;</body><body package="DB2EXDI">__SQLEXT	&lt;C: #define __SQLEXT 	&gt;</body><body package="DB2EXDI">__STDC__	&lt;C: #define __STDC__ 1	&gt;</body><body package="DB2EXDI">__TIME__	&lt;C: #define __TIME__ "4:53:53 pm"	&gt;</body></methods><methods><class-id>Database.DB2CLIInterface</class-id> <category>types</category><body package="DB2EXDI">DATE_STRUCT	&lt;C: typedef struct __DATE_STRUCT DATE_STRUCT&gt;</body><body package="DB2EXDI">DWORD	&lt;C: typedef sqlint32 DWORD&gt;</body><body package="DB2EXDI">HDBC	&lt;C: typedef void * HDBC&gt;</body><body package="DB2EXDI">HENV	&lt;C: typedef void * HENV&gt;</body><body package="DB2EXDI">HSTMT	&lt;C: typedef void * HSTMT&gt;</body><body package="DB2EXDI">HWND	&lt;C: typedef void * HWND&gt;</body><body package="DB2EXDI">LDOUBLE	&lt;C: typedef double LDOUBLE&gt;</body><body package="DB2EXDI">LPWSTR	&lt;C: typedef char * LPWSTR&gt;</body><body package="DB2EXDI">PSDWORD	&lt;C: typedef SDWORD * PSDWORD&gt;</body><body package="DB2EXDI">PTR	&lt;C: typedef void * PTR&gt;</body><body package="DB2EXDI">RETCODE	&lt;C: typedef short RETCODE&gt;</body><body package="DB2EXDI">SCHAR	&lt;C: typedef char SCHAR&gt;</body><body package="DB2EXDI">SDOUBLE	&lt;C: typedef double SDOUBLE&gt;</body><body package="DB2EXDI">SDWORD	&lt;C: typedef sqlint32 SDWORD&gt;</body><body package="DB2EXDI">SFLOAT	&lt;C: typedef float SFLOAT&gt;</body><body package="DB2EXDI">SLONG	&lt;C: typedef sqlint32 SLONG&gt;</body><body package="DB2EXDI">SQLBIGINT	&lt;C: typedef long long SQLBIGINT&gt;</body><body package="DB2EXDI">SQLCHAR	&lt;C: typedef UCHAR SQLCHAR&gt;</body><body package="DB2EXDI">SQLDATE	&lt;C: typedef unsigned char SQLDATE&gt;</body><body package="DB2EXDI">SQLDBCHAR	&lt;C: typedef unsigned short SQLDBCHAR&gt;</body><body package="DB2EXDI">SQLDECIMAL	&lt;C: typedef unsigned char SQLDECIMAL&gt;</body><body package="DB2EXDI">SQLDOUBLE	&lt;C: typedef SDOUBLE SQLDOUBLE&gt;</body><body package="DB2EXDI">SQLFLOAT	&lt;C: typedef SDOUBLE SQLFLOAT&gt;</body><body package="DB2EXDI">SQLHANDLE	&lt;C: typedef SQLINTEGER SQLHANDLE&gt;</body><body package="DB2EXDI">SQLHDBC	&lt;C: typedef SQLINTEGER SQLHDBC&gt;</body><body package="DB2EXDI">SQLHDESC	&lt;C: typedef SQLHANDLE SQLHDESC&gt;</body><body package="DB2EXDI">SQLHENV	&lt;C: typedef SQLINTEGER SQLHENV&gt;</body><body package="DB2EXDI">SQLHSTMT	&lt;C: typedef SQLINTEGER SQLHSTMT&gt;</body><body package="DB2EXDI">SQLHWND	&lt;C: typedef HWND SQLHWND&gt;</body><body package="DB2EXDI">SQLINTEGER	&lt;C: typedef SDWORD SQLINTEGER&gt;</body><body package="DB2EXDI">SQLINTERVAL	&lt;C: typedef enum {			SQL_IS_YEAR = 1, 			SQL_IS_MONTH, 			SQL_IS_DAY, 			SQL_IS_HOUR, 			SQL_IS_MINUTE, 			SQL_IS_SECOND, 			SQL_IS_YEAR_TO_MONTH, 			SQL_IS_DAY_TO_HOUR, 			SQL_IS_DAY_TO_MINUTE, 			SQL_IS_DAY_TO_SECOND, 			SQL_IS_HOUR_TO_MINUTE, 			SQL_IS_HOUR_TO_SECOND, 			SQL_IS_MINUTE_TO_SECOND		} SQLINTERVAL&gt;</body><body package="DB2EXDI">SQLNUMERIC	&lt;C: typedef unsigned char SQLNUMERIC&gt;</body><body package="DB2EXDI">SQLPOINTER	&lt;C: typedef PTR SQLPOINTER&gt;</body><body package="DB2EXDI">SQLREAL	&lt;C: typedef SFLOAT SQLREAL&gt;</body><body package="DB2EXDI">SQLRETURN	&lt;C: typedef SQLSMALLINT SQLRETURN&gt;</body><body package="DB2EXDI">SQLSCHAR	&lt;C: typedef SCHAR SQLSCHAR&gt;</body><body package="DB2EXDI">SQLSMALLINT	&lt;C: typedef SWORD SQLSMALLINT&gt;</body><body package="DB2EXDI">SQLTCHAR	&lt;C: typedef SQLCHAR SQLTCHAR&gt;</body><body package="DB2EXDI">SQLTIME	&lt;C: typedef unsigned char SQLTIME&gt;</body><body package="DB2EXDI">SQLTIMESTAMP	&lt;C: typedef unsigned char SQLTIMESTAMP&gt;</body><body package="DB2EXDI">SQLUBIGINT	&lt;C: typedef unsigned long long SQLUBIGINT&gt;</body><body package="DB2EXDI">SQLUINTEGER	&lt;C: typedef UDWORD SQLUINTEGER&gt;</body><body package="DB2EXDI">SQLUSMALLINT	&lt;C: typedef UWORD SQLUSMALLINT&gt;</body><body package="DB2EXDI">SQLVARCHAR	&lt;C: typedef UCHAR SQLVARCHAR&gt;</body><body package="DB2EXDI">SQLWCHAR	&lt;C: typedef unsigned short SQLWCHAR&gt;</body><body package="DB2EXDI">SQL_DATE_STRUCT	&lt;C: typedef DATE_STRUCT SQL_DATE_STRUCT&gt;</body><body package="DB2EXDI">SQL_DAY_SECOND_STRUCT	&lt;C: typedef struct tagSQL_DAY_SECOND SQL_DAY_SECOND_STRUCT&gt;</body><body package="DB2EXDI">SQL_INTERVAL_STRUCT	&lt;C: typedef struct tagSQL_INTERVAL_STRUCT SQL_INTERVAL_STRUCT&gt;</body><body package="DB2EXDI">SQL_NUMERIC_STRUCT	&lt;C: typedef struct tagSQL_NUMERIC_STRUCT SQL_NUMERIC_STRUCT&gt;</body><body package="DB2EXDI">SQL_TIMESTAMP_STRUCT	&lt;C: typedef TIMESTAMP_STRUCT SQL_TIMESTAMP_STRUCT&gt;</body><body package="DB2EXDI">SQL_TIME_STRUCT	&lt;C: typedef TIME_STRUCT SQL_TIME_STRUCT&gt;</body><body package="DB2EXDI">SQL_YEAR_MONTH_STRUCT	&lt;C: typedef struct tagSQL_YEAR_MONTH SQL_YEAR_MONTH_STRUCT&gt;</body><body package="DB2EXDI">SSHORT	&lt;C: typedef short SSHORT&gt;</body><body package="DB2EXDI">SWORD	&lt;C: typedef short SWORD&gt;</body><body package="DB2EXDI">TIMESTAMP_STRUCT	&lt;C: typedef struct __TIMESTAMP_STRUCT TIMESTAMP_STRUCT&gt;</body><body package="DB2EXDI">TIME_STRUCT	&lt;C: typedef struct __TIME_STRUCT TIME_STRUCT&gt;</body><body package="DB2EXDI">UCHAR	&lt;C: typedef unsigned char UCHAR&gt;</body><body package="DB2EXDI">UDWORD	&lt;C: typedef sqluint32 UDWORD&gt;</body><body package="DB2EXDI">ULONG	&lt;C: typedef sqluint32 ULONG&gt;</body><body package="DB2EXDI">USHORT	&lt;C: typedef unsigned short USHORT&gt;</body><body package="DB2EXDI">UWORD	&lt;C: typedef unsigned short UWORD&gt;</body><body package="DB2EXDI">sqlint16	&lt;C: typedef short sqlint16&gt;</body><body package="DB2EXDI">sqlint32	&lt;C: typedef int sqlint32&gt;</body><body package="DB2EXDI">sqlint64	&lt;C: typedef long long sqlint64&gt;</body><body package="DB2EXDI">sqlint8	&lt;C: typedef char sqlint8&gt;</body><body package="DB2EXDI">sqlintptr	&lt;C: typedef sqlint32 sqlintptr&gt;</body><body package="DB2EXDI">sqluint16	&lt;C: typedef unsigned short sqluint16&gt;</body><body package="DB2EXDI">sqluint32	&lt;C: typedef unsigned int sqluint32&gt;</body><body package="DB2EXDI">sqluint64	&lt;C: typedef unsigned long long sqluint64&gt;</body><body package="DB2EXDI">sqluint8	&lt;C: typedef unsigned char sqluint8&gt;</body><body package="DB2EXDI">sqluintptr	&lt;C: typedef sqluint32 sqluintptr&gt;</body></methods><methods><class-id>Database.DB2CLIInterface</class-id> <category>structs</category><body package="DB2EXDI">__DATE_STRUCT	&lt;C: struct __DATE_STRUCT {			SQLSMALLINT year;			SQLUSMALLINT month, day;		}&gt;</body><body package="DB2EXDI">__TIMESTAMP_STRUCT	&lt;C: struct __TIMESTAMP_STRUCT {			SQLSMALLINT year;			SQLUSMALLINT month, day, hour, minute, second;			SQLUINTEGER fraction;		}&gt;</body><body package="DB2EXDI">__TIME_STRUCT	&lt;C: struct __TIME_STRUCT {			SQLUSMALLINT hour, minute, second;		}&gt;</body><body package="DB2EXDI">sqlca	&lt;C: struct sqlca {			char sqlcaid[8];			sqlint32 sqlcabc, sqlcode;			short sqlerrml;			char sqlerrmc[70];			char sqlerrp[8];			sqlint32 sqlerrd[6];			char sqlwarn[11];			char sqlstate[5];		}&gt;</body><body package="DB2EXDI">tagSQL_DAY_SECOND	&lt;C: struct tagSQL_DAY_SECOND {			SQLUINTEGER day, hour, minute, second, fraction;		}&gt;</body><body package="DB2EXDI">tagSQL_INTERVAL_STRUCT	&lt;C: struct tagSQL_INTERVAL_STRUCT {			SQLINTERVAL interval_type;			SQLSMALLINT interval_sign;			union {				SQL_YEAR_MONTH_STRUCT year_month;				SQL_DAY_SECOND_STRUCT day_second;			} intval;		}&gt;</body><body package="DB2EXDI">tagSQL_NUMERIC_STRUCT	&lt;C: struct tagSQL_NUMERIC_STRUCT {			SQLCHAR precision;			SQLSCHAR scale;			SQLCHAR sign;			SQLCHAR val[16];		}&gt;</body><body package="DB2EXDI">tagSQL_YEAR_MONTH	&lt;C: struct tagSQL_YEAR_MONTH {			SQLUINTEGER year, month;		}&gt;</body></methods><methods><class-id>Database.DB2APIInterface</class-id> <category>defines</category><body package="DB2EXDI">SQL_ALL_USERS	&lt;C: #define SQL_ALL_USERS -1	&gt;</body><body package="DB2EXDI">SQL_ASYNCH	&lt;C: #define SQL_ASYNCH 0	&gt;</body><body package="DB2EXDI">SQL_STATS_ALL	&lt;C: #define SQL_STATS_ALL 65	&gt;</body><body package="DB2EXDI">SQL_STATS_BOTH	&lt;C: #define SQL_STATS_BOTH 66	&gt;</body><body package="DB2EXDI">SQL_STATS_CHG	&lt;C: #define SQL_STATS_CHG 67	&gt;</body><body package="DB2EXDI">SQL_STATS_EXTINDEX_ONLY	&lt;C: #define SQL_STATS_EXTINDEX_ONLY 88	&gt;</body><body package="DB2EXDI">SQL_STATS_EXTINDEX_TABLE	&lt;C: #define SQL_STATS_EXTINDEX_TABLE 89	&gt;</body><body package="DB2EXDI">SQL_STATS_EXTTABLE_INDEX	&lt;C: #define SQL_STATS_EXTTABLE_INDEX 69	&gt;</body><body package="DB2EXDI">SQL_STATS_EXTTABLE_ONLY	&lt;C: #define SQL_STATS_EXTTABLE_ONLY 68	&gt;</body><body package="DB2EXDI">SQL_STATS_INDEX	&lt;C: #define SQL_STATS_INDEX 73	&gt;</body><body package="DB2EXDI">SQL_STATS_REF	&lt;C: #define SQL_STATS_REF 82	&gt;</body><body package="DB2EXDI">SQL_STATS_TABLE	&lt;C: #define SQL_STATS_TABLE 84	&gt;</body><body package="DB2EXDI">db2Version710	&lt;C: #define db2Version710 SQL_REL7100	&gt;</body></methods><methods><class-id>Database.DB2APIInterface</class-id> <category>types</category><body package="DB2EXDI">SQL_PDB_NODE_TYPE	&lt;C: typedef short SQL_PDB_NODE_TYPE&gt;</body><body package="DB2EXDI">SQL_PDB_PORT_TYPE	&lt;C: typedef int SQL_PDB_PORT_TYPE&gt;</body><body package="DB2EXDI">db2RestartDbStruct	&lt;C: typedef struct __db2RestartDbStruct db2RestartDbStruct&gt;</body><body package="DB2EXDI">db2Uint32	&lt;C: typedef sqluint32 db2Uint32&gt;</body><body package="DB2EXDI">db2int32	&lt;C: typedef sqlint32 db2int32&gt;</body><body package="DB2EXDI">sqlint32	&lt;C: typedef int sqlint32&gt;</body><body package="DB2EXDI">sqluint32	&lt;C: typedef unsigned int sqluint32&gt;</body></methods><methods><class-id>Database.DB2APIInterface</class-id> <category>structs</category><body package="DB2EXDI">__db2RestartDbStruct	&lt;C: struct __db2RestartDbStruct {			char * piDatabaseName;			char * piUserId;			char * piPassword;			char * piTablespaceNames;			db2int32 iOption;		}&gt;</body><body package="DB2EXDI">sqlca	&lt;C: struct sqlca {			char sqlcaid[8];			sqlint32 sqlcabc, sqlcode;			short sqlerrml;			char sqlerrmc[70];			char sqlerrp[8];			sqlint32 sqlerrd[6];			char sqlwarn[11];			char sqlstate[5];		}&gt;</body><body package="DB2EXDI">sqle_start_options	&lt;C: struct sqle_start_options {			char sqloptid[8];			sqluint32 isprofile;			char profile[236];			sqluint32 isnodenum;			SQL_PDB_NODE_TYPE nodenum;			sqluint32 option, ishostname;			char hostname[256];			sqluint32 isport;			SQL_PDB_PORT_TYPE port;			sqluint32 isnetname;			char netname[256];			sqluint32 tblspace_type;			SQL_PDB_NODE_TYPE tblspace_node;			sqluint32 iscomputer;			char computer[16];			char * pUserName;			char * pPassword;		}&gt;</body><body package="DB2EXDI">sqledbstopopt	&lt;C: struct sqledbstopopt {			sqluint32 isprofile;			char profile[236];			sqluint32 isnodenum;			SQL_PDB_NODE_TYPE nodenum;			sqluint32 option, callerac;		}&gt;</body><body package="DB2EXDI">sqledinfo	&lt;C: struct sqledinfo {			char alias[8];			char dbname[8];			char drive[215];			char intname[8];			char nodename[8];			char dbtype[20];			char comment[30];			short com_codepage;			char type;			unsigned short authentication;			char glbdbname[255];			char dceprincipal[1024];			short cat_nodenum, nodenum;		}&gt;</body></methods><methods><class-id>Database.DB2APIWinInterface</class-id> <category>structs</category><body package="DB2EXDI">sqledinfo"NT version drive[12]"	&lt;C: struct sqledinfo {			char alias[8];			char dbname[8];			char drive[12];			char intname[8];			char nodename[8];			char dbtype[20];			char comment[30];			short com_codepage;			char type;			unsigned short authentication;			char glbdbname[255];			char dceprincipal[1024];			short cat_nodenum, nodenum;		}&gt;</body></methods><methods><class-id>Database.DB2CLIInterface</class-id> <category>procedures</category><body package="DB2EXDI">SQLAllocConnect: henv with: phdbc	&lt;C: SQLRETURN __stdcall  SQLAllocConnect(SQLHENV henv, SQLHDBC * phdbc)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLAllocEnv: phenv	&lt;C: SQLRETURN __stdcall  SQLAllocEnv(SQLHENV * phenv)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLAllocHandle: fHandleType with: hInput with: phOutput	&lt;C: SQLRETURN __stdcall  SQLAllocHandle(SQLSMALLINT fHandleType, SQLHANDLE hInput, SQLHANDLE * phOutput)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLAllocHandleStd: fHandleType with: hInput with: phOutput	&lt;C: SQLRETURN __stdcall  SQLAllocHandleStd(SQLSMALLINT fHandleType, SQLHANDLE hInput, SQLHANDLE * phOutput)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLAllocStmt: hdbc with: phstmt	&lt;C: SQLRETURN __stdcall  SQLAllocStmt(SQLHDBC hdbc, SQLHSTMT * phstmt)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLBindCol: hstmt with: icol with: fCType with: rgbValue with: cbValueMax with: pcbValue	&lt;C: SQLRETURN __stdcall  SQLBindCol(SQLHSTMT hstmt, SQLUSMALLINT icol, SQLSMALLINT fCType, SQLPOINTER rgbValue, SQLINTEGER cbValueMax, SQLINTEGER * pcbValue)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLBindFileToCol: hstmt with: icol with: FileName with: FileNameLength with: FileOptions with: MaxFileNameLength with: StringLength with: IndicatorValue	&lt;C: SQLRETURN __stdcall  SQLBindFileToCol(SQLHSTMT hstmt, SQLUSMALLINT icol, SQLCHAR * FileName, SQLSMALLINT * FileNameLength, SQLUINTEGER * FileOptions, SQLSMALLINT MaxFileNameLength, SQLINTEGER * StringLength, SQLINTEGER * IndicatorValue)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLBindFileToParam: hstmt with: ipar with: fSqlType with: FileName with: FileNameLength with: FileOptions with: MaxFileNameLength with: IndicatorValue	&lt;C: SQLRETURN __stdcall  SQLBindFileToParam(SQLHSTMT hstmt, SQLUSMALLINT ipar, SQLSMALLINT fSqlType, SQLCHAR * FileName, SQLSMALLINT * FileNameLength, SQLUINTEGER * FileOptions, SQLSMALLINT MaxFileNameLength, SQLINTEGER * IndicatorValue)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLBindParam: StatementHandle with: ParameterNumber with: ValueType with: ParameterType with: LengthPrecision with: ParameterScale with: ParameterValue with: StrLen_or_Ind	&lt;C: SQLRETURN __stdcall  SQLBindParam(SQLHSTMT StatementHandle, SQLUSMALLINT ParameterNumber, SQLSMALLINT ValueType, SQLSMALLINT ParameterType, SQLUINTEGER LengthPrecision, SQLSMALLINT ParameterScale, SQLPOINTER ParameterValue, SQLINTEGER * StrLen_or_Ind)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLBindParameter: hstmt with: ipar with: fParamType with: fCType with: fSqlType with: cbColDef with: ibScale with: rgbValue with: cbValueMax with: pcbValue	&lt;C: SQLRETURN __stdcall  SQLBindParameter(SQLHSTMT hstmt, SQLUSMALLINT ipar, SQLSMALLINT fParamType, SQLSMALLINT fCType, SQLSMALLINT fSqlType, SQLUINTEGER cbColDef, SQLSMALLINT ibScale, SQLPOINTER rgbValue, SQLINTEGER cbValueMax, SQLINTEGER * pcbValue)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLBrowseConnect: hdbc with: szConnStrIn with: cbConnStrIn with: szConnStrOut with: cbConnStrOutMax with: pcbConnStrOut	&lt;C: SQLRETURN __stdcall  SQLBrowseConnect(SQLHDBC hdbc, SQLCHAR * szConnStrIn, SQLSMALLINT cbConnStrIn, SQLCHAR * szConnStrOut, SQLSMALLINT cbConnStrOutMax, SQLSMALLINT * pcbConnStrOut)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLBrowseConnectW: hdbc with: szConnStrIn with: cbConnStrIn with: szConnStrOut with: cbConnStrOutMax with: pcbConnStrOut	&lt;C: SQLRETURN __stdcall  SQLBrowseConnectW(SQLHDBC hdbc, SQLWCHAR * szConnStrIn, SQLSMALLINT cbConnStrIn, SQLWCHAR * szConnStrOut, SQLSMALLINT cbConnStrOutMax, SQLSMALLINT * pcbConnStrOut)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLBuildDataLink: hStmt with: pszLinkType with: cbLinkType with: pszDataLocation with: cbDataLocation with: pszComment with: cbComment with: pDataLink with: cbDataLinkMax with: pcbDataLink	&lt;C: SQLRETURN __stdcall  SQLBuildDataLink(SQLHSTMT hStmt, SQLCHAR * pszLinkType, SQLINTEGER cbLinkType, SQLCHAR * pszDataLocation, SQLINTEGER cbDataLocation, SQLCHAR * pszComment, SQLINTEGER cbComment, SQLCHAR * pDataLink, SQLINTEGER cbDataLinkMax, SQLINTEGER * pcbDataLink)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLBulkOperations: StatementHandle with: Operation	&lt;C: SQLRETURN __stdcall  SQLBulkOperations(SQLHSTMT StatementHandle, SQLSMALLINT Operation)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLCancel: hstmt	&lt;C: SQLRETURN __stdcall  SQLCancel(SQLHSTMT hstmt)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLCloseCursor: hStmt	&lt;C: SQLRETURN __stdcall  SQLCloseCursor(SQLHSTMT hStmt)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLColAttribute: hstmt with: icol with: fDescType with: rgbDesc with: cbDescMax with: pcbDesc with: pfDesc	&lt;C: SQLRETURN __stdcall  SQLColAttribute(SQLHSTMT hstmt, SQLUSMALLINT icol, SQLUSMALLINT fDescType, SQLPOINTER rgbDesc, SQLSMALLINT cbDescMax, SQLSMALLINT * pcbDesc, SQLPOINTER pfDesc)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLColAttributeW: hstmt with: iCol with: iField with: pCharAttr with: cbCharAttrMax with: pcbCharAttr with: pNumAttr	&lt;C: SQLRETURN __stdcall  SQLColAttributeW(SQLHSTMT hstmt, SQLUSMALLINT iCol, SQLUSMALLINT iField, SQLPOINTER pCharAttr, SQLSMALLINT cbCharAttrMax, SQLSMALLINT * pcbCharAttr, SQLPOINTER pNumAttr)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLColAttributes: hstmt with: icol with: fDescType with: rgbDesc with: cbDescMax with: pcbDesc with: pfDesc	&lt;C: SQLRETURN __stdcall  SQLColAttributes(SQLHSTMT hstmt, SQLUSMALLINT icol, SQLUSMALLINT fDescType, SQLPOINTER rgbDesc, SQLSMALLINT cbDescMax, SQLSMALLINT * pcbDesc, SQLINTEGER * pfDesc)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLColAttributesW: hstmt with: icol with: fDescType with: rgbDesc with: cbDescMax with: pcbDesc with: pfDesc	&lt;C: SQLRETURN __stdcall  SQLColAttributesW(SQLHSTMT hstmt, SQLUSMALLINT icol, SQLUSMALLINT fDescType, SQLPOINTER rgbDesc, SQLSMALLINT cbDescMax, SQLSMALLINT * pcbDesc, SQLINTEGER * pfDesc)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLColumnPrivileges: hstmt with: szCatalogName with: cbCatalogName with: szSchemaName with: cbSchemaName with: szTableName with: cbTableName with: szColumnName with: cbColumnName	&lt;C: SQLRETURN __stdcall  SQLColumnPrivileges(SQLHSTMT hstmt, SQLCHAR * szCatalogName, SQLSMALLINT cbCatalogName, SQLCHAR * szSchemaName, SQLSMALLINT cbSchemaName, SQLCHAR * szTableName, SQLSMALLINT cbTableName, SQLCHAR * szColumnName, SQLSMALLINT cbColumnName)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLColumnPrivilegesW: hstmt with: szCatalogName with: cbCatalogName with: szSchemaName with: cbSchemaName with: szTableName with: cbTableName with: szColumnName with: cbColumnName	&lt;C: SQLRETURN __stdcall  SQLColumnPrivilegesW(SQLHSTMT hstmt, SQLWCHAR * szCatalogName, SQLSMALLINT cbCatalogName, SQLWCHAR * szSchemaName, SQLSMALLINT cbSchemaName, SQLWCHAR * szTableName, SQLSMALLINT cbTableName, SQLWCHAR * szColumnName, SQLSMALLINT cbColumnName)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLColumns: hstmt with: szCatalogName with: cbCatalogName with: szSchemaName with: cbSchemaName with: szTableName with: cbTableName with: szColumnName with: cbColumnName	&lt;C: SQLRETURN __stdcall  SQLColumns(SQLHSTMT hstmt, SQLCHAR * szCatalogName, SQLSMALLINT cbCatalogName, SQLCHAR * szSchemaName, SQLSMALLINT cbSchemaName, SQLCHAR * szTableName, SQLSMALLINT cbTableName, SQLCHAR * szColumnName, SQLSMALLINT cbColumnName)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLColumnsW: hstmt with: szCatalogName with: cbCatalogName with: szSchemaName with: cbSchemaName with: szTableName with: cbTableName with: szColumnName with: cbColumnName	&lt;C: SQLRETURN __stdcall  SQLColumnsW(SQLHSTMT hstmt, SQLWCHAR * szCatalogName, SQLSMALLINT cbCatalogName, SQLWCHAR * szSchemaName, SQLSMALLINT cbSchemaName, SQLWCHAR * szTableName, SQLSMALLINT cbTableName, SQLWCHAR * szColumnName, SQLSMALLINT cbColumnName)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLConnect: hdbc with: szDSN with: cbDSN with: szUID with: cbUID with: szAuthStr with: cbAuthStr	&lt;C: SQLRETURN __stdcall  SQLConnect(SQLHDBC hdbc, SQLCHAR * szDSN, SQLSMALLINT cbDSN, SQLCHAR * szUID, SQLSMALLINT cbUID, SQLCHAR * szAuthStr, SQLSMALLINT cbAuthStr)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLConnectW: hdbc with: szDSN with: cbDSN with: szUID with: cbUID with: szAuthStr with: cbAuthStr	&lt;C: SQLRETURN __stdcall  SQLConnectWInt(SQLHDBC hdbc, SQLWCHAR * szDSN, SQLSMALLINT cbDSN, SQLWCHAR * szUID, SQLSMALLINT cbUID, SQLWCHAR * szAuthStr, SQLSMALLINT cbAuthStr)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLCopyDesc: hDescSource with: hDescTarget	&lt;C: SQLRETURN __stdcall  SQLCopyDesc(SQLHDESC hDescSource, SQLHDESC hDescTarget)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLDataSources: henv with: fDirection with: szDSN with: cbDSNMax with: pcbDSN with: szDescription with: cbDescriptionMax with: pcbDescription	&lt;C: SQLRETURN __stdcall  SQLDataSources(SQLHENV henv, SQLUSMALLINT fDirection, SQLCHAR * szDSN, SQLSMALLINT cbDSNMax, SQLSMALLINT * pcbDSN, SQLCHAR * szDescription, SQLSMALLINT cbDescriptionMax, SQLSMALLINT * pcbDescription)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLDataSourcesW: henv with: fDirection with: szDSN with: cbDSNMax with: pcbDSN with: szDescription with: cbDescriptionMax with: pcbDescription	&lt;C: SQLRETURN __stdcall  SQLDataSourcesW(SQLHENV henv, SQLUSMALLINT fDirection, SQLWCHAR * szDSN, SQLSMALLINT cbDSNMax, SQLSMALLINT * pcbDSN, SQLWCHAR * szDescription, SQLSMALLINT cbDescriptionMax, SQLSMALLINT * pcbDescription)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLDescribeCol: hstmt with: icol with: szColName with: cbColNameMax with: pcbColName with: pfSqlType with: pcbColDef with: pibScale with: pfNullable	&lt;C: SQLRETURN __stdcall  SQLDescribeCol(SQLHSTMT hstmt, SQLUSMALLINT icol, SQLCHAR * szColName, SQLSMALLINT cbColNameMax, SQLSMALLINT * pcbColName, SQLSMALLINT * pfSqlType, SQLUINTEGER * pcbColDef, SQLSMALLINT * pibScale, SQLSMALLINT * pfNullable)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLDescribeColW: hstmt with: icol with: szColName with: cbColNameMax with: pcbColName with: pfSqlType with: pcbColDef with: pibScale with: pfNullable	&lt;C: SQLRETURN __stdcall  SQLDescribeColW(SQLHSTMT hstmt, SQLUSMALLINT icol, SQLWCHAR * szColName, SQLSMALLINT cbColNameMax, SQLSMALLINT * pcbColName, SQLSMALLINT * pfSqlType, SQLUINTEGER * pcbColDef, SQLSMALLINT * pibScale, SQLSMALLINT * pfNullable)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLDescribeParam: hstmt with: ipar with: pfSqlType with: pcbParamDef with: pibScale with: pfNullable	&lt;C: SQLRETURN __stdcall  SQLDescribeParam(SQLHSTMT hstmt, SQLUSMALLINT ipar, SQLSMALLINT * pfSqlType, SQLUINTEGER * pcbParamDef, SQLSMALLINT * pibScale, SQLSMALLINT * pfNullable)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLDisconnect: hdbc	&lt;C: SQLRETURN __stdcall  SQLDisconnect(SQLHDBC hdbc)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLDriverConnect: hdbc with: hwnd with: szConnStrIn with: cbConnStrIn with: szConnStrOut with: cbConnStrOutMax with: pcbConnStrOut with: fDriverCompletion	&lt;C: SQLRETURN __stdcall  SQLDriverConnect(SQLHDBC hdbc, SQLHWND hwnd, SQLCHAR * szConnStrIn, SQLSMALLINT cbConnStrIn, SQLCHAR * szConnStrOut, SQLSMALLINT cbConnStrOutMax, SQLSMALLINT * pcbConnStrOut, SQLUSMALLINT fDriverCompletion)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLDriverConnectW: hdbc with: hwnd with: szConnStrIn with: cbConnStrIn with: szConnStrOut with: cbConnStrOutMax with: pcbConnStrOut with: fDriverCompletion	&lt;C: SQLRETURN __stdcall  SQLDriverConnectW(SQLHDBC hdbc, SQLHWND hwnd, SQLWCHAR * szConnStrIn, SQLSMALLINT cbConnStrIn, SQLWCHAR * szConnStrOut, SQLSMALLINT cbConnStrOutMax, SQLSMALLINT * pcbConnStrOut, SQLUSMALLINT fDriverCompletion)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLDrivers: henv with: fDirection with: szDriverDesc with: cbDriverDescMax with: pcbDriverDesc with: szDriverAttributes with: cbDrvrAttrMax with: pcbDrvrAttr	&lt;C: SQLRETURN __stdcall  SQLDrivers(SQLHENV henv, SQLUSMALLINT fDirection, SQLCHAR * szDriverDesc, SQLSMALLINT cbDriverDescMax, SQLSMALLINT * pcbDriverDesc, SQLCHAR * szDriverAttributes, SQLSMALLINT cbDrvrAttrMax, SQLSMALLINT * pcbDrvrAttr)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLEndTran: fHandleType with: hHandle with: fType	&lt;C: SQLRETURN __stdcall  SQLEndTran(SQLSMALLINT fHandleType, SQLHANDLE hHandle, SQLSMALLINT fType)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLError: henv with: hdbc with: hstmt with: szSqlState with: pfNativeError with: szErrorMsg with: cbErrorMsgMax with: pcbErrorMsg	&lt;C: SQLRETURN __stdcall  SQLError(SQLHENV henv, SQLHDBC hdbc, SQLHSTMT hstmt, SQLCHAR * szSqlState, SQLINTEGER * pfNativeError, SQLCHAR * szErrorMsg, SQLSMALLINT cbErrorMsgMax, SQLSMALLINT * pcbErrorMsg)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLErrorW: henv with: hdbc with: hstmt with: szSqlState with: pfNativeError with: szErrorMsg with: cbErrorMsgMax with: pcbErrorMsg	&lt;C: SQLRETURN __stdcall  SQLErrorW(SQLHENV henv, SQLHDBC hdbc, SQLHSTMT hstmt, SQLWCHAR * szSqlState, SQLINTEGER * pfNativeError, SQLWCHAR * szErrorMsg, SQLSMALLINT cbErrorMsgMax, SQLSMALLINT * pcbErrorMsg)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLExecDirect: hstmt with: szSqlStr with: cbSqlStr	&lt;C: SQLRETURN __stdcall  SQLExecDirect(SQLHSTMT hstmt, SQLCHAR * szSqlStr, SQLINTEGER cbSqlStr)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLExecDirectW: hstmt with: szSqlStr with: cbSqlStr	&lt;C: SQLRETURN __stdcall  SQLExecDirectW(SQLHSTMT hstmt, SQLWCHAR * szSqlStr, SQLINTEGER cbSqlStr)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLExecute: hstmt	&lt;C: SQLRETURN __stdcall  SQLExecute(SQLHSTMT hstmt)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLExtendedBind: hstmt with: fBindCol with: cRecords with: pfCType with: rgbValue with: cbValueMax with: puiPrecisionCType with: psScaleCType with: pcbValue with: piIndicatorPtr with: pfParamType with: pfSQLType with: pcbColDef with: pibScale	&lt;C: SQLRETURN __stdcall  SQLExtendedBind(SQLHSTMT hstmt, SQLSMALLINT fBindCol, SQLSMALLINT cRecords, SQLSMALLINT * pfCType, SQLPOINTER * rgbValue, SQLINTEGER * cbValueMax, SQLUINTEGER * puiPrecisionCType, SQLSMALLINT * psScaleCType, SQLINTEGER * * pcbValue, SQLINTEGER * * piIndicatorPtr, SQLSMALLINT * pfParamType, SQLSMALLINT * pfSQLType, SQLUINTEGER * pcbColDef, SQLSMALLINT * pibScale)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLExtendedFetch: hstmt with: fFetchType with: irow with: pcrow with: rgfRowStatus	&lt;C: SQLRETURN __stdcall  SQLExtendedFetch(SQLHSTMT hstmt, SQLUSMALLINT fFetchType, SQLINTEGER irow, SQLUINTEGER * pcrow, SQLUSMALLINT * rgfRowStatus)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLExtendedPrepare: hstmt with: pszSqlStmt with: cbSqlStmt with: cPars with: sStmtType with: cStmtAttrs with: piStmtAttr with: pvParams	&lt;C: SQLRETURN __stdcall  SQLExtendedPrepare(SQLHSTMT hstmt, SQLCHAR * pszSqlStmt, SQLINTEGER cbSqlStmt, SQLINTEGER cPars, SQLSMALLINT sStmtType, SQLINTEGER cStmtAttrs, SQLINTEGER * piStmtAttr, SQLINTEGER * pvParams)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLFetch: hstmt	&lt;C: SQLRETURN __stdcall  SQLFetch(SQLHSTMT hstmt)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLFetchScroll: StatementHandle with: FetchOrientation with: FetchOffset	&lt;C: SQLRETURN __stdcall  SQLFetchScroll(SQLHSTMT StatementHandle, SQLSMALLINT FetchOrientation, SQLINTEGER FetchOffset)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLForeignKeys: hstmt with: szPkCatalogName with: cbPkCatalogName with: szPkSchemaName with: cbPkSchemaName with: szPkTableName with: cbPkTableName with: szFkCatalogName with: cbFkCatalogName with: szFkSchemaName with: cbFkSchemaName with: szFkTableName with: cbFkTableName	&lt;C: SQLRETURN __stdcall  SQLForeignKeys(SQLHSTMT hstmt, SQLCHAR * szPkCatalogName, SQLSMALLINT cbPkCatalogName, SQLCHAR * szPkSchemaName, SQLSMALLINT cbPkSchemaName, SQLCHAR * szPkTableName, SQLSMALLINT cbPkTableName, SQLCHAR * szFkCatalogName, SQLSMALLINT cbFkCatalogName, SQLCHAR * szFkSchemaName, SQLSMALLINT cbFkSchemaName, SQLCHAR * szFkTableName, SQLSMALLINT cbFkTableName)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLForeignKeysW: hstmt with: szPkCatalogName with: cbPkCatalogName with: szPkSchemaName with: cbPkSchemaName with: szPkTableName with: cbPkTableName with: szFkCatalogName with: cbFkCatalogName with: szFkSchemaName with: cbFkSchemaName with: szFkTableName with: cbFkTableName	&lt;C: SQLRETURN __stdcall  SQLForeignKeysW(SQLHSTMT hstmt, SQLWCHAR * szPkCatalogName, SQLSMALLINT cbPkCatalogName, SQLWCHAR * szPkSchemaName, SQLSMALLINT cbPkSchemaName, SQLWCHAR * szPkTableName, SQLSMALLINT cbPkTableName, SQLWCHAR * szFkCatalogName, SQLSMALLINT cbFkCatalogName, SQLWCHAR * szFkSchemaName, SQLSMALLINT cbFkSchemaName, SQLWCHAR * szFkTableName, SQLSMALLINT cbFkTableName)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLFreeConnect: hdbc	&lt;C: SQLRETURN __stdcall  SQLFreeConnect(SQLHDBC hdbc)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLFreeEnv: henv	&lt;C: SQLRETURN __stdcall  SQLFreeEnv(SQLHENV henv)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLFreeHandle: fHandleType with: hHandle	&lt;C: SQLRETURN __stdcall  SQLFreeHandle(SQLSMALLINT fHandleType, SQLHANDLE hHandle)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLFreeStmt: hstmt with: fOption	&lt;C: SQLRETURN __stdcall  SQLFreeStmt(SQLHSTMT hstmt, SQLUSMALLINT fOption)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLGetConnectAttr: ConnectionHandle with: Attribute with: Value with: BufferLength with: StringLength	&lt;C: SQLRETURN __stdcall  SQLGetConnectAttr(SQLHDBC ConnectionHandle, SQLINTEGER Attribute, SQLPOINTER Value, SQLINTEGER BufferLength, SQLINTEGER * StringLength)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLGetConnectAttrW: hdbc with: fAttribute with: rgbValue with: cbValueMax with: pcbValue	&lt;C: SQLRETURN __stdcall  SQLGetConnectAttrW(SQLHDBC hdbc, SQLINTEGER fAttribute, SQLPOINTER rgbValue, SQLINTEGER cbValueMax, SQLINTEGER * pcbValue)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLGetConnectOption: hdbc with: fOption with: pvParam	&lt;C: SQLRETURN __stdcall  SQLGetConnectOption(SQLHDBC hdbc, SQLUSMALLINT fOption, SQLPOINTER pvParam)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLGetCursorName: hstmt with: szCursor with: cbCursorMax with: pcbCursor	&lt;C: SQLRETURN __stdcall  SQLGetCursorName(SQLHSTMT hstmt, SQLCHAR * szCursor, SQLSMALLINT cbCursorMax, SQLSMALLINT * pcbCursor)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLGetCursorNameW: hstmt with: szCursor with: cbCursorMax with: pcbCursor	&lt;C: SQLRETURN __stdcall  SQLGetCursorNameW(SQLHSTMT hstmt, SQLWCHAR * szCursor, SQLSMALLINT cbCursorMax, SQLSMALLINT * pcbCursor)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLGetData: hstmt with: icol with: fCType with: rgbValue with: cbValueMax with: pcbValue	&lt;C: SQLRETURN __stdcall  SQLGetData(SQLHSTMT hstmt, SQLUSMALLINT icol, SQLSMALLINT fCType, SQLPOINTER rgbValue, SQLINTEGER cbValueMax, SQLINTEGER * pcbValue)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLGetDataLinkAttr: hStmt with: fAttrType with: pDataLink with: cbDataLink with: pAttribute with: cbAttributeMax with: pcbAttribute	&lt;C: SQLRETURN __stdcall  SQLGetDataLinkAttr(SQLHSTMT hStmt, SQLSMALLINT fAttrType, SQLCHAR * pDataLink, SQLINTEGER cbDataLink, SQLPOINTER pAttribute, SQLINTEGER cbAttributeMax, SQLINTEGER * pcbAttribute)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLGetDescField: DescriptorHandle with: RecNumber with: FieldIdentifier with: Value with: BufferLength with: StringLength	&lt;C: SQLRETURN __stdcall  SQLGetDescField(SQLHDESC DescriptorHandle, SQLSMALLINT RecNumber, SQLSMALLINT FieldIdentifier, SQLPOINTER Value, SQLINTEGER BufferLength, SQLINTEGER * StringLength)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLGetDescFieldW: hdesc with: iRecord with: iField with: rgbValue with: cbValueMax with: pcbValue	&lt;C: SQLRETURN __stdcall  SQLGetDescFieldW(SQLHDESC hdesc, SQLSMALLINT iRecord, SQLSMALLINT iField, SQLPOINTER rgbValue, SQLINTEGER cbValueMax, SQLINTEGER * pcbValue)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLGetDescRec: DescriptorHandle with: RecNumber with: Name with: BufferLength with: StringLength with: Type with: SubType with: Length with: Precision with: Scale with: Nullable	&lt;C: SQLRETURN __stdcall  SQLGetDescRec(SQLHDESC DescriptorHandle, SQLSMALLINT RecNumber, SQLCHAR * Name, SQLSMALLINT BufferLength, SQLSMALLINT * StringLength, SQLSMALLINT * Type, SQLSMALLINT * SubType, SQLINTEGER * Length, SQLSMALLINT * Precision, SQLSMALLINT * Scale, SQLSMALLINT * Nullable)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLGetDescRecW: hdesc with: iRecord with: szName with: cbNameMax with: pcbName with: pfType with: pfSubType with: pLength with: pPrecision with: pScale with: pNullable	&lt;C: SQLRETURN __stdcall  SQLGetDescRecW(SQLHDESC hdesc, SQLSMALLINT iRecord, SQLWCHAR * szName, SQLSMALLINT cbNameMax, SQLSMALLINT * pcbName, SQLSMALLINT * pfType, SQLSMALLINT * pfSubType, SQLINTEGER * pLength, SQLSMALLINT * pPrecision, SQLSMALLINT * pScale, SQLSMALLINT * pNullable)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLGetDiagField: fHandleType with: hHandle with: iRecNumber with: fDiagIdentifier with: pDiagInfo with: cbDiagInfoMax with: pcbDiagInfo	&lt;C: SQLRETURN __stdcall  SQLGetDiagField(SQLSMALLINT fHandleType, SQLHANDLE hHandle, SQLSMALLINT iRecNumber, SQLSMALLINT fDiagIdentifier, SQLPOINTER pDiagInfo, SQLSMALLINT cbDiagInfoMax, SQLSMALLINT * pcbDiagInfo)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLGetDiagFieldW: fHandleType with: handle with: iRecord with: fDiagField with: rgbDiagInfo with: cbDiagInfoMax with: pcbDiagInfo	&lt;C: SQLRETURN __stdcall  SQLGetDiagFieldW(SQLSMALLINT fHandleType, SQLHANDLE handle, SQLSMALLINT iRecord, SQLSMALLINT fDiagField, SQLPOINTER rgbDiagInfo, SQLSMALLINT cbDiagInfoMax, SQLSMALLINT * pcbDiagInfo)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLGetDiagRec: fHandleType with: hHandle with: iRecNumber with: pszSqlState with: pfNativeError with: pszErrorMsg with: cbErrorMsgMax with: pcbErrorMsg	&lt;C: SQLRETURN __stdcall  SQLGetDiagRec(SQLSMALLINT fHandleType, SQLHANDLE hHandle, SQLSMALLINT iRecNumber, SQLCHAR * pszSqlState, SQLINTEGER * pfNativeError, SQLCHAR * pszErrorMsg, SQLSMALLINT cbErrorMsgMax, SQLSMALLINT * pcbErrorMsg)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLGetDiagRecW: fHandleType with: handle with: iRecord with: szSqlState with: pfNativeError with: szErrorMsg with: cbErrorMsgMax with: pcbErrorMsg	&lt;C: SQLRETURN __stdcall  SQLGetDiagRecW(SQLSMALLINT fHandleType, SQLHANDLE handle, SQLSMALLINT iRecord, SQLWCHAR * szSqlState, SQLINTEGER * pfNativeError, SQLWCHAR * szErrorMsg, SQLSMALLINT cbErrorMsgMax, SQLSMALLINT * pcbErrorMsg)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLGetEnvAttr: henv with: Attribute with: Value with: BufferLength with: StringLength	&lt;C: SQLRETURN __stdcall  SQLGetEnvAttr(SQLHENV henv, SQLINTEGER Attribute, SQLPOINTER Value, SQLINTEGER BufferLength, SQLINTEGER * StringLength)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLGetFunctions: hdbc with: fFunction with: pfExists	&lt;C: SQLRETURN __stdcall  SQLGetFunctions(SQLHDBC hdbc, SQLUSMALLINT fFunction, SQLUSMALLINT * pfExists)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLGetInfo: hdbc with: fInfoType with: rgbInfoValue with: cbInfoValueMax with: pcbInfoValue	&lt;C: SQLRETURN __stdcall  SQLGetInfo(SQLHDBC hdbc, SQLUSMALLINT fInfoType, SQLPOINTER rgbInfoValue, SQLSMALLINT cbInfoValueMax, SQLSMALLINT * pcbInfoValue)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLGetInfoW: hdbc with: fInfoType with: rgbInfoValue with: cbInfoValueMax with: pcbInfoValue	&lt;C: SQLRETURN __stdcall  SQLGetInfoW(SQLHDBC hdbc, SQLUSMALLINT fInfoType, SQLPOINTER rgbInfoValue, SQLSMALLINT cbInfoValueMax, SQLSMALLINT * pcbInfoValue)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLGetLength: hstmt with: LocatorCType with: Locator with: StringLength with: IndicatorValue	&lt;C: SQLRETURN __stdcall  SQLGetLength(SQLHSTMT hstmt, SQLSMALLINT LocatorCType, SQLINTEGER Locator, SQLINTEGER * StringLength, SQLINTEGER * IndicatorValue)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLGetPosition: hstmt with: LocatorCType with: SourceLocator with: SearchLocator with: SearchLiteral with: SearchLiteralLength with: FromPosition with: LocatedAt with: IndicatorValue	&lt;C: SQLRETURN __stdcall  SQLGetPosition(SQLHSTMT hstmt, SQLSMALLINT LocatorCType, SQLINTEGER SourceLocator, SQLINTEGER SearchLocator, SQLCHAR * SearchLiteral, SQLINTEGER SearchLiteralLength, SQLUINTEGER FromPosition, SQLUINTEGER * LocatedAt, SQLINTEGER * IndicatorValue)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLGetSQLCA: henv with: hdbc with: hstmt with: pSqlca	&lt;C: SQLRETURN __stdcall  SQLGetSQLCA(SQLHENV henv, SQLHDBC hdbc, SQLHSTMT hstmt, struct sqlca * pSqlca)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLGetStmtAttr: StatementHandle with: Attribute with: Value with: BufferLength with: StringLength	&lt;C: SQLRETURN __stdcall  SQLGetStmtAttr(SQLHSTMT StatementHandle, SQLINTEGER Attribute, SQLPOINTER Value, SQLINTEGER BufferLength, SQLINTEGER * StringLength)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLGetStmtAttrW: hstmt with: fAttribute with: rgbValue with: cbValueMax with: pcbValue	&lt;C: SQLRETURN __stdcall  SQLGetStmtAttrW(SQLHSTMT hstmt, SQLINTEGER fAttribute, SQLPOINTER rgbValue, SQLINTEGER cbValueMax, SQLINTEGER * pcbValue)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLGetStmtOption: hstmt with: fOption with: pvParam	&lt;C: SQLRETURN __stdcall  SQLGetStmtOption(SQLHSTMT hstmt, SQLUSMALLINT fOption, SQLPOINTER pvParam)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLGetSubString: hstmt with: LocatorCType with: SourceLocator with: FromPosition with: ForLength with: TargetCType with: rgbValue with: cbValueMax with: StringLength with: IndicatorValue	&lt;C: SQLRETURN __stdcall  SQLGetSubString(SQLHSTMT hstmt, SQLSMALLINT LocatorCType, SQLINTEGER SourceLocator, SQLUINTEGER FromPosition, SQLUINTEGER ForLength, SQLSMALLINT TargetCType, SQLPOINTER rgbValue, SQLINTEGER cbValueMax, SQLINTEGER * StringLength, SQLINTEGER * IndicatorValue)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLGetTypeInfo: hstmt with: fSqlType	&lt;C: SQLRETURN __stdcall  SQLGetTypeInfo(SQLHSTMT hstmt, SQLSMALLINT fSqlType)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLMoreResults: hstmt	&lt;C: SQLRETURN __stdcall  SQLMoreResults(SQLHSTMT hstmt)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLNativeSql: hdbc with: szSqlStrIn with: cbSqlStrIn with: szSqlStr with: cbSqlStrMax with: pcbSqlStr	&lt;C: SQLRETURN __stdcall  SQLNativeSql(SQLHDBC hdbc, SQLCHAR * szSqlStrIn, SQLINTEGER cbSqlStrIn, SQLCHAR * szSqlStr, SQLINTEGER cbSqlStrMax, SQLINTEGER * pcbSqlStr)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLNativeSqlW: hdbc with: szSqlStrIn with: cbSqlStrIn with: szSqlStr with: cbSqlStrMax with: pcbSqlStr	&lt;C: SQLRETURN __stdcall  SQLNativeSqlW(SQLHDBC hdbc, SQLWCHAR * szSqlStrIn, SQLINTEGER cbSqlStrIn, SQLWCHAR * szSqlStr, SQLINTEGER cbSqlStrMax, SQLINTEGER * pcbSqlStr)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLNumParams: hstmt with: pcpar	&lt;C: SQLRETURN __stdcall  SQLNumParams(SQLHSTMT hstmt, SQLSMALLINT * pcpar)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLNumResultCols: hstmt with: pccol	&lt;C: SQLRETURN __stdcall  SQLNumResultCols(SQLHSTMT hstmt, SQLSMALLINT * pccol)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLParamData: hstmt with: prgbValue	&lt;C: SQLRETURN __stdcall  SQLParamData(SQLHSTMT hstmt, SQLPOINTER * prgbValue)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLParamOptions: hstmt with: crow with: pirow	&lt;C: SQLRETURN __stdcall  SQLParamOptions(SQLHSTMT hstmt, SQLUINTEGER crow, SQLUINTEGER * pirow)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLPrepare: hstmt with: szSqlStr with: cbSqlStr	&lt;C: SQLRETURN __stdcall  SQLPrepare(SQLHSTMT hstmt, SQLCHAR * szSqlStr, SQLINTEGER cbSqlStr)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLPrepareW: hstmt with: szSqlStr with: cbSqlStr	&lt;C: SQLRETURN __stdcall  SQLPrepareW(SQLHSTMT hstmt, SQLWCHAR * szSqlStr, SQLINTEGER cbSqlStr)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLPrimaryKeys: hstmt with: szCatalogName with: cbCatalogName with: szSchemaName with: cbSchemaName with: szTableName with: cbTableName	&lt;C: SQLRETURN __stdcall  SQLPrimaryKeys(SQLHSTMT hstmt, SQLCHAR * szCatalogName, SQLSMALLINT cbCatalogName, SQLCHAR * szSchemaName, SQLSMALLINT cbSchemaName, SQLCHAR * szTableName, SQLSMALLINT cbTableName)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLPrimaryKeysW: hstmt with: szCatalogName with: cbCatalogName with: szSchemaName with: cbSchemaName with: szTableName with: cbTableName	&lt;C: SQLRETURN __stdcall  SQLPrimaryKeysW(SQLHSTMT hstmt, SQLWCHAR * szCatalogName, SQLSMALLINT cbCatalogName, SQLWCHAR * szSchemaName, SQLSMALLINT cbSchemaName, SQLWCHAR * szTableName, SQLSMALLINT cbTableName)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLProcedureColumns: hstmt with: szCatalogName with: cbCatalogName with: szSchemaName with: cbSchemaName with: szProcName with: cbProcName with: szColumnName with: cbColumnName	&lt;C: SQLRETURN __stdcall  SQLProcedureColumns(SQLHSTMT hstmt, SQLCHAR * szCatalogName, SQLSMALLINT cbCatalogName, SQLCHAR * szSchemaName, SQLSMALLINT cbSchemaName, SQLCHAR * szProcName, SQLSMALLINT cbProcName, SQLCHAR * szColumnName, SQLSMALLINT cbColumnName)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLProcedureColumnsW: hstmt with: szCatalogName with: cbCatalogName with: szSchemaName with: cbSchemaName with: szProcName with: cbProcName with: szColumnName with: cbColumnName	&lt;C: SQLRETURN __stdcall  SQLProcedureColumnsW(SQLHSTMT hstmt, SQLWCHAR * szCatalogName, SQLSMALLINT cbCatalogName, SQLWCHAR * szSchemaName, SQLSMALLINT cbSchemaName, SQLWCHAR * szProcName, SQLSMALLINT cbProcName, SQLWCHAR * szColumnName, SQLSMALLINT cbColumnName)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLProcedures: hstmt with: szCatalogName with: cbCatalogName with: szSchemaName with: cbSchemaName with: szProcName with: cbProcName	&lt;C: SQLRETURN __stdcall  SQLProcedures(SQLHSTMT hstmt, SQLCHAR * szCatalogName, SQLSMALLINT cbCatalogName, SQLCHAR * szSchemaName, SQLSMALLINT cbSchemaName, SQLCHAR * szProcName, SQLSMALLINT cbProcName)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLProceduresW: hstmt with: szCatalogName with: cbCatalogName with: szSchemaName with: cbSchemaName with: szProcName with: cbProcName	&lt;C: SQLRETURN __stdcall  SQLProceduresW(SQLHSTMT hstmt, SQLWCHAR * szCatalogName, SQLSMALLINT cbCatalogName, SQLWCHAR * szSchemaName, SQLSMALLINT cbSchemaName, SQLWCHAR * szProcName, SQLSMALLINT cbProcName)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLPutData: hstmt with: rgbValue with: cbValue	&lt;C: SQLRETURN __stdcall  SQLPutData(SQLHSTMT hstmt, SQLPOINTER rgbValue, SQLINTEGER cbValue)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLRowCount: hstmt with: pcrow	&lt;C: SQLRETURN __stdcall  SQLRowCount(SQLHSTMT hstmt, SQLINTEGER * pcrow)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLSetColAttributes: hstmt with: icol with: pszColName with: cbColName with: fSQLType with: cbColDef with: ibScale with: fNullable	&lt;C: SQLRETURN __stdcall  SQLSetColAttributes(SQLHSTMT hstmt, SQLUSMALLINT icol, SQLCHAR * pszColName, SQLSMALLINT cbColName, SQLSMALLINT fSQLType, SQLUINTEGER cbColDef, SQLSMALLINT ibScale, SQLSMALLINT fNullable)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLSetConnectAttr: hdbc with: fOption with: pvParam with: fStrLen	&lt;C: SQLRETURN __stdcall  SQLSetConnectAttr(SQLHDBC hdbc, SQLINTEGER fOption, SQLPOINTER pvParam, SQLINTEGER fStrLen)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLSetConnectAttrW: hdbc with: fAttribute with: rgbValue with: cbValue	&lt;C: SQLRETURN __stdcall  SQLSetConnectAttrW(SQLHDBC hdbc, SQLINTEGER fAttribute, SQLPOINTER rgbValue, SQLINTEGER cbValue)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLSetConnectOption: hdbc with: fOption with: vParam	&lt;C: SQLRETURN __stdcall  SQLSetConnectOption(SQLHDBC hdbc, SQLUSMALLINT fOption, SQLUINTEGER vParam)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLSetConnection: hdbc	&lt;C: SQLRETURN __stdcall  SQLSetConnection(SQLHDBC hdbc)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLSetCursorName: hstmt with: szCursor with: cbCursor	&lt;C: SQLRETURN __stdcall  SQLSetCursorName(SQLHSTMT hstmt, SQLCHAR * szCursor, SQLSMALLINT cbCursor)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLSetCursorNameW: hstmt with: szCursor with: cbCursor	&lt;C: SQLRETURN __stdcall  SQLSetCursorNameW(SQLHSTMT hstmt, SQLWCHAR * szCursor, SQLSMALLINT cbCursor)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLSetDescField: DescriptorHandle with: RecNumber with: FieldIdentifier with: Value with: BufferLength	&lt;C: SQLRETURN __stdcall  SQLSetDescField(SQLHDESC DescriptorHandle, SQLSMALLINT RecNumber, SQLSMALLINT FieldIdentifier, SQLPOINTER Value, SQLINTEGER BufferLength)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLSetDescFieldW: DescriptorHandle with: RecNumber with: FieldIdentifier with: Value with: BufferLength	&lt;C: SQLRETURN __stdcall  SQLSetDescFieldW(SQLHDESC DescriptorHandle, SQLSMALLINT RecNumber, SQLSMALLINT FieldIdentifier, SQLPOINTER Value, SQLINTEGER BufferLength)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLSetDescRec: DescriptorHandle with: RecNumber with: Type with: SubType with: Length with: Precision with: Scale with: Data with: StringLength with: Indicator	&lt;C: SQLRETURN __stdcall  SQLSetDescRec(SQLHDESC DescriptorHandle, SQLSMALLINT RecNumber, SQLSMALLINT Type, SQLSMALLINT SubType, SQLINTEGER Length, SQLSMALLINT Precision, SQLSMALLINT Scale, SQLPOINTER Data, SQLINTEGER * StringLength, SQLINTEGER * Indicator)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLSetEnvAttr: henv with: Attribute with: Value with: StringLength	&lt;C: SQLRETURN __stdcall  SQLSetEnvAttr(SQLHENV henv, SQLINTEGER Attribute, SQLPOINTER Value, SQLINTEGER StringLength)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLSetParam: hstmt with: ipar with: fCType with: fSqlType with: cbParamDef with: ibScale with: rgbValue with: pcbValue	&lt;C: SQLRETURN __stdcall  SQLSetParam(SQLHSTMT hstmt, SQLUSMALLINT ipar, SQLSMALLINT fCType, SQLSMALLINT fSqlType, SQLUINTEGER cbParamDef, SQLSMALLINT ibScale, SQLPOINTER rgbValue, SQLINTEGER * pcbValue)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLSetPos: hstmt with: irow with: fOption with: fLock	&lt;C: SQLRETURN __stdcall  SQLSetPos(SQLHSTMT hstmt, SQLUSMALLINT irow, SQLUSMALLINT fOption, SQLUSMALLINT fLock)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLSetScrollOptions: hstmt with: fConcurrency with: crowKeyset with: crowRowset	&lt;C: SQLRETURN __stdcall  SQLSetScrollOptions(SQLHSTMT hstmt, SQLUSMALLINT fConcurrency, SQLINTEGER crowKeyset, SQLUSMALLINT crowRowset)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLSetStmtAttr: hstmt with: fOption with: pvParam with: fStrLen	&lt;C: SQLRETURN __stdcall  SQLSetStmtAttr(SQLHSTMT hstmt, SQLINTEGER fOption, SQLPOINTER pvParam, SQLINTEGER fStrLen)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLSetStmtAttrW: hstmt with: fAttribute with: rgbValue with: cbValueMax	&lt;C: SQLRETURN __stdcall  SQLSetStmtAttrW(SQLHSTMT hstmt, SQLINTEGER fAttribute, SQLPOINTER rgbValue, SQLINTEGER cbValueMax)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLSetStmtOption: hstmt with: fOption with: vParam	&lt;C: SQLRETURN __stdcall  SQLSetStmtOption(SQLHSTMT hstmt, SQLUSMALLINT fOption, SQLUINTEGER vParam)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLSpecialColumns: hstmt with: fColType with: szCatalogName with: cbCatalogName with: szSchemaName with: cbSchemaName with: szTableName with: cbTableName with: fScope with: fNullable	&lt;C: SQLRETURN __stdcall  SQLSpecialColumns(SQLHSTMT hstmt, SQLUSMALLINT fColType, SQLCHAR * szCatalogName, SQLSMALLINT cbCatalogName, SQLCHAR * szSchemaName, SQLSMALLINT cbSchemaName, SQLCHAR * szTableName, SQLSMALLINT cbTableName, SQLUSMALLINT fScope, SQLUSMALLINT fNullable)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLSpecialColumnsW: hstmt with: fColType with: szCatalogName with: cbCatalogName with: szSchemaName with: cbSchemaName with: szTableName with: cbTableName with: fScope with: fNullable	&lt;C: SQLRETURN __stdcall  SQLSpecialColumnsW(SQLHSTMT hstmt, SQLUSMALLINT fColType, SQLWCHAR * szCatalogName, SQLSMALLINT cbCatalogName, SQLWCHAR * szSchemaName, SQLSMALLINT cbSchemaName, SQLWCHAR * szTableName, SQLSMALLINT cbTableName, SQLUSMALLINT fScope, SQLUSMALLINT fNullable)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLStatistics: hstmt with: szCatalogName with: cbCatalogName with: szSchemaName with: cbSchemaName with: szTableName with: cbTableName with: fUnique with: fAccuracy	&lt;C: SQLRETURN __stdcall  SQLStatistics(SQLHSTMT hstmt, SQLCHAR * szCatalogName, SQLSMALLINT cbCatalogName, SQLCHAR * szSchemaName, SQLSMALLINT cbSchemaName, SQLCHAR * szTableName, SQLSMALLINT cbTableName, SQLUSMALLINT fUnique, SQLUSMALLINT fAccuracy)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLStatisticsW: hstmt with: szCatalogName with: cbCatalogName with: szSchemaName with: cbSchemaName with: szTableName with: cbTableName with: fUnique with: fAccuracy	&lt;C: SQLRETURN __stdcall  SQLStatisticsW(SQLHSTMT hstmt, SQLWCHAR * szCatalogName, SQLSMALLINT cbCatalogName, SQLWCHAR * szSchemaName, SQLSMALLINT cbSchemaName, SQLWCHAR * szTableName, SQLSMALLINT cbTableName, SQLUSMALLINT fUnique, SQLUSMALLINT fAccuracy)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLTablePrivileges: hstmt with: szCatalogName with: cbCatalogName with: szSchemaName with: cbSchemaName with: szTableName with: cbTableName	&lt;C: SQLRETURN __stdcall  SQLTablePrivileges(SQLHSTMT hstmt, SQLCHAR * szCatalogName, SQLSMALLINT cbCatalogName, SQLCHAR * szSchemaName, SQLSMALLINT cbSchemaName, SQLCHAR * szTableName, SQLSMALLINT cbTableName)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLTablePrivilegesW: hstmt with: szCatalogName with: cbCatalogName with: szSchemaName with: cbSchemaName with: szTableName with: cbTableName	&lt;C: SQLRETURN __stdcall  SQLTablePrivilegesW(SQLHSTMT hstmt, SQLWCHAR * szCatalogName, SQLSMALLINT cbCatalogName, SQLWCHAR * szSchemaName, SQLSMALLINT cbSchemaName, SQLWCHAR * szTableName, SQLSMALLINT cbTableName)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLTables: hstmt with: szCatalogName with: cbCatalogName with: szSchemaName with: cbSchemaName with: szTableName with: cbTableName with: szTableType with: cbTableType	&lt;C: SQLRETURN __stdcall  SQLTables(SQLHSTMT hstmt, SQLCHAR * szCatalogName, SQLSMALLINT cbCatalogName, SQLCHAR * szSchemaName, SQLSMALLINT cbSchemaName, SQLCHAR * szTableName, SQLSMALLINT cbTableName, SQLCHAR * szTableType, SQLSMALLINT cbTableType)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLTablesW: hstmt with: szCatalogName with: cbCatalogName with: szSchemaName with: cbSchemaName with: szTableName with: cbTableName with: szTableType with: cbTableType	&lt;C: SQLRETURN __stdcall  SQLTablesW(SQLHSTMT hstmt, SQLWCHAR * szCatalogName, SQLSMALLINT cbCatalogName, SQLWCHAR * szSchemaName, SQLSMALLINT cbSchemaName, SQLWCHAR * szTableName, SQLSMALLINT cbTableName, SQLWCHAR * szTableType, SQLSMALLINT cbTableType)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">SQLTransact: henv with: hdbc with: fType	&lt;C: SQLRETURN __stdcall  SQLTransact(SQLHENV henv, SQLHDBC hdbc, SQLUSMALLINT fType)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>Database.DB2APIInterface</class-id> <category>procedures</category><body package="DB2EXDI">db2DatabaseRestart: versionNumber with: pParmStruct with: pSqlca	&lt;C: int __stdcall  db2DatabaseRestart(db2Uint32 versionNumber, void * pParmStruct, struct sqlca * pSqlca)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">sqlaintp_api: pBuffer with: BufferSize with: LineWidth with: pMsgFileName with: pSqlca	&lt;C: int __stdcall  sqlaintp_api(char * pBuffer, short BufferSize, short LineWidth, char * pMsgFileName, struct sqlca * pSqlca)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">sqleatin_api: pNodeName with: pUserName with: pPassword with: pSqlca	"sqleatin - Attach"	&lt;C: int __stdcall  sqleatin_api(char * pNodeName, char * pUserName, char * pPassword, struct sqlca * pSqlca)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">sqledcls_api: Handle with: pSqlca	"sqledcls - Close Database Directory Scan"	&lt;C: int __stdcall  sqledcls_api(unsigned short Handle, struct sqlca * pSqlca)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">sqledgne_api: Handle with: ppDbDirEntry with: pSqlca"sqledgne - Get Next Database Directory Entry"	&lt;C: int __stdcall  sqledgne_api(unsigned short Handle, struct sqledinfo * * ppDbDirEntry, struct sqlca * pSqlca)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">sqledosd_api: pPath with: pHandle with: pNumEntries with: pSqlca"sqledosd - Open Database Directory Scan"	&lt;C: int __stdcall  sqledosd_api(char * pPath, unsigned short * pHandle, unsigned short * pNumEntries, struct sqlca * pSqlca)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">sqledtin_api: pSqlca	"sqledtin - Detach"	&lt;C: int __stdcall  sqledtin_api(struct sqlca * pSqlca)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">sqlefrce_api: NumAgentIds with: pAgentIds with: ForceMode with: pSqlca	&lt;C: int __stdcall  sqlefrce_api(sqlint32 NumAgentIds, sqluint32 * pAgentIds, unsigned short ForceMode, struct sqlca * pSqlca)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">sqlepstart_api: pStartOptions with: pSqlca	&lt;C: int __stdcall  sqlepstart_api(struct sqle_start_options * pStartOptions, struct sqlca * pSqlca)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">sqlepstp_api: pStopOptions with: pSqlca	&lt;C: int __stdcall  sqlepstp_api(struct sqledbstopopt * pStopOptions, struct sqlca * pSqlca)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">sqlogstt: pBuffer with: BufferSize with: LineWidth with: pSqlstate	&lt;C: int __stdcall  sqlogstt(char * pBuffer, short BufferSize, short LineWidth, char * pSqlstate)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="DB2EXDI">sqlustat_api: pTableName with: NumIndexes with: ppIndexList with: StatsOption with: ShareLevel with: pSqlca	&lt;C: int __stdcall  sqlustat_api(char * pTableName, unsigned short NumIndexes, char * * ppIndexList, unsigned char StatsOption, unsigned char ShareLevel, struct sqlca * pSqlca)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><initialize><class-id>Database.DB2CLIInterface</class-id></initialize><initialize><class-id>Database.DB2APIInterface</class-id></initialize><initialize><class-id>Database.DB2API64BitInterface</class-id></initialize><initialize><class-id>Database.DB2Connection</class-id></initialize><initialize><class-id>Database.DB2Buffer</class-id></initialize><initialize><class-id>Database.DB2Session</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>SmallDouble</name><environment>Core</environment><super>Core.LimitedPrecisionReal</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Array</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>Float</name><environment>Core</environment><super>Core.LimitedPrecisionReal</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Timestamp</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>year month day hours minutes seconds milliseconds partialNanosecond </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>ExternalDatabaseError</name><environment>Database</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dbmsErrorCode dbmsErrorString osErrorCode osErrorString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><class><name>PositionableStream</name><environment>Core</environment><super>Core.PeekableStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>collection position readLimit writeLimit policy </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>ExternalDatabaseColumnDescription</name><environment>Database</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name index type length precision scale nullable </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><class><name>CharacterArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>ExternalInterface</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>includeFiles includeDirectories libraryFiles libraryDirectories virtual optimizationLevel </class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>External-Interface</category><attributes><package>External-Interface</package></attributes></class><class><name>ExternalDatabaseSession</name><environment>Database</environment><super>Database.ExternalDatabaseFramework</super><private>false</private><indexed-type>none</indexed-type><inst-vars>connection query queryFragments bindInput bindTemplate bindOutput useNamedOutputBinding bindValues resultTemplate allocateForEachRow blockFactor numColumns columnDescriptions rowAdaptors rowBuffersHolder bufferIndex answerStream currentRow scrollable needBinding </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><class><name>ExternalDatabaseException</name><environment>Database</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><class><name>Double</name><environment>Core</environment><super>Core.LimitedPrecisionReal</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>UndefinedObject</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Time</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hours minutes seconds milliseconds partialNanosecond </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>Integer</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>LargeInteger</name><environment>Core</environment><super>Core.Integer</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>ByteArray</name><environment>Core</environment><super>Core.IntegerArray</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>ExternalDatabaseConnection</name><environment>Database</environment><super>Database.ExternalDatabaseFramework</super><private>false</private><indexed-type>none</indexed-type><inst-vars>transaction username password environment transactionCoordinator cachedSession isolationLevel encoding </inst-vars><class-inst-vars>environmentMap xif xifMap dependents </class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><class><name>Boolean</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>FixedPoint</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars>numerator denominator scale </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>BufferedExternalStream</name><environment>OS</environment><super>OS.ExternalStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>lineEndCharacter binary lineEndConvention bufferType ioBuffer ioConnection </inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.IOConstants.*			</imports><category>OS-Streaming</category><attributes><package>OS-Streaming</package></attributes></class><class><name>ExternalDatabaseBuffer</name><environment>Database</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>databaseType encoding elementSize count bufferPointer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><class><name>Date</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>day year </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>ExternalDatabaseTransaction</name><environment>Database</environment><super>Database.ExternalDatabaseFramework</super><private>false</private><indexed-type>none</indexed-type><inst-vars>memberCountHolder remainingCountHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class></st-source>