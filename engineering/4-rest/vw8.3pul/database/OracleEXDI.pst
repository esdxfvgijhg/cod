<?xml version="1.0"?><st-source><!-- Name: OracleEXDINotice: Copyright 1999-2016 Cincom Systems, Inc.  All rights reserved.Comment: Contains the Oracle-specfic protocols for the External Database Interface (EXDI).By using this package with a properly-configured Oracle client (8.0.x and later), you can interact with Oracle Database servers.Further information on the EXDI framework can be found in the "Database Application Developer''s Guide" (located in the /doc subdirectory of the VisualWorks installation).DbIdentifier: bear73DbTrace: 495964DbUsername: dwallenDbVersion: 8.2 - 8DevelopmentPrerequisites: #(#(#any 'Database' '') #(#any 'DLLCC' ''))PackageName: OracleEXDIParcel: #('OracleEXDI')ParcelName: OracleEXDIPrerequisiteParcels: #(#('Database' ''))PrintStringCache: (8.2 - 8,dwallen)Version: 8.2 - 8Post-Load Block: 	[:pkg| Database.OracleConnection postLoadActionFor: pkg ]Date: 3:11:18 PM November 18, 2016 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (nov16.2) of November 17, 2016 on November 18, 2016 at 3:11:18 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>OracleDatabaseException</name><environment>Database</environment><super>Database.ExternalDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Oracle</category><attributes><package>OracleEXDI</package></attributes></class><comment><class-id>Database.OracleDatabaseException</class-id><body>OracleDatabaseException is raised in case of the Oracle database errors.</body></comment><class><name>OracleDatabaseResumableException</name><environment>Database</environment><super>Database.OracleDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Oracle</category><attributes><package>OracleEXDI</package></attributes></class><comment><class-id>Database.OracleDatabaseResumableException</class-id><body>OracleDatabaseResumableException is raised in case of the Oracle database resumable exception.</body></comment><class><name>SuccessWithInformation</name><environment>Database</environment><super>Database.OracleDatabaseResumableException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Oracle</category><attributes><package>OracleEXDI</package></attributes></class><comment><class-id>Database.SuccessWithInformation</class-id><body>SuccessWithInformation is used to indicate that the action is success, but there is a warning.</body></comment><class><name>UnableToModifyObjectInfo</name><environment>Database</environment><super>Database.OracleDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Oracle</category><attributes><package>OracleEXDI</package></attributes></class><comment><class-id>Database.UnableToModifyObjectInfo</class-id><body>UnableToModifyObjectInfo is used to indicate that an object information could not be modified.</body></comment><class><name>OracleConnection</name><environment>Database</environment><super>Database.ExternalDatabaseConnection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>henvHolder herrHolder hsvcctxHolder hsrvrHolder hsessHolder htxnHolder executionMode transactionMode authenticationMode useStatementCaching attributeLengthPointerHolder attributePointerHolder parameterPointerHolder descriptorPointerHolder unicodeEncoding oracleEncodingId oracleUnicodeEncodingId </inst-vars><class-inst-vars>signalMap libraryInitialized </class-inst-vars><imports></imports><category>Database-Oracle</category><attributes><package>OracleEXDI</package></attributes></class><comment><class-id>Database.OracleConnection</class-id><body>OracleConnection is the concrete class implementation of connection services using the Oracle OCI library.Instance Variables	henvHolder	&lt;ValueHolder on: (CPointer | nil)&gt;		A private value holder which remembers the pointer for the current OCI environment handle, if any.  The value holder is shared with the executor object.	herrHolder		&lt;ValueHolder on: (CPointer | nil)&gt;		A private value holder which remembers the pointer for the current OCI error handle, if any.  The value holder is shared with the executor object.	hsvcctxHolder	&lt;ValueHolder on: (CPointer | nil)&gt;		A private value holder which remembers the pointer for the current OCI service context handle, if any.  The value holder is shared with the executor object.	hsrvrHolder		&lt;ValueHolder on: (CPointer | nil)&gt;		A private value holder which remembers the pointer for the current OCI server handle, if any.  The value holder is shared with the executor object.	hsessHolder	&lt;ValueHolder on: (CPointer | nil)&gt;		A private value holder which remembers the pointer for the current OCI user session handle, if any.  The value holder is shared with the executor object.	htxnHolder		&lt;ValueHolder on: (CPointer | nil)&gt;		A private value holder which remembers the pointer for the current OCI transaction handle, if any.  The value holder is shared with the executor object.	executionMode	&lt;CMacroDefinition&gt;			An integer which remembers the execution mode.	transactionMode	&lt;ByteSymbol&gt;			A symbol which indicates the transaction mode.	authenticationMode	&lt;CMacroDefinition&gt;			An integer which remembers the authentication mode.	useStatementCaching	&lt;Boolean&gt;		A boolean indicating whether statement caching is needed.	attributeLengthPointerHolder &lt;ValueHolder on: (CPointer | nil)&gt;		A private value holder which remembers the pointer for the attribute length.  The value holder is shared with the executor object.	attributePointerHolder &lt;ValueHolder on: (CPointer | nil)&gt;		A private value holder which remembers the pointer for the attribute.  The value holder is shared with the executor object.	parameterPointerHolder &lt;ValueHolder on: (CPointer | nil)&gt;		A private value holder which remembers the pointer for the parameter.  The value holder is shared with the executor object.	descriptorPointerHolder	&lt;ValueHolder on: (CPointer | nil)&gt;		A private value holder which remembers the pointer for the descriptor.  The value holder is shared with the executor object.	unicodeEncoding 	&lt;Symbol&gt;		A symbol remembers the encoding selection for Unicode columns.	oracleEncodingId &lt;Integer&gt;			An integer which remembers the Oracle client-side character set ID. 	oracleUnicodeEncodingId &lt;Integer&gt;		An integer which remembers the Oracle client-side national character set ID. Class Instance Variables	signalMap	&lt;IdentityDictionary&gt;		Maps a set of error codes to their corresponding signals.	libraryInitialized	&lt;Boolean&gt;		A boolean indicating whether the Oracle OCI library is initialized.Shared Variables	AttributeTypeConversionMap	&lt;IdentityDictionary&gt;			Maps OCI Environment Handle Attributes to Smalltalk data values. 	EncoderMap	&lt;Dictionary&gt;		Maps character encoding names to the StreamEncoder names used		in Smalltalk.	RegisteredOracleConnections	&lt;HandleRegistry&gt;		A private registry of all active OracleConnection instances.	OCIClientVersion &lt;Dictionary | nil&gt;		Cached OCI Client Version.</body></comment><class><name>UnableToAllocateResourceHandle</name><environment>Database</environment><super>Database.OracleDatabaseResumableException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Oracle</category><attributes><package>OracleEXDI</package></attributes></class><comment><class-id>Database.UnableToAllocateResourceHandle</class-id><body>UnableToAllocateResourceHandle is used to indicate that a handle could not be allocated.</body></comment><class><name>OracleInterface</name><environment>Database</environment><super>External.ExternalInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars>encoding </inst-vars><class-inst-vars></class-inst-vars><imports>			private Database.OracleInterfaceDictionary.*			</imports><category>Database-External-Libraries</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>true</beVirtual><optimizationLevel>full</optimizationLevel><package>OracleEXDI</package></attributes></class><comment><class-id>Database.OracleInterface</class-id><body>This class defines calling conventions for the Oracle OCI.Instance Variables:	encoding	&lt;Symbol&gt;		A symbol remembers the encoding selection.</body></comment><class><name>OracleSolarisInterface</name><environment>Database</environment><super>Database.OracleInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Database.OracleSolarisInterfaceDictionary.*			</imports><category>Database-External-Libraries</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>libclntsh.so</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>OracleEXDI</package></attributes></class><comment><class-id>Database.OracleSolarisInterface</class-id><body>This class defines calling conventions for the Oracle OCI on the Solaris platform.  Please refer to the environment variable on your machine for the path containing necessary Oracle library files.</body></comment><class><name>OracleBuffer</name><environment>Database</environment><super>Database.ExternalDatabaseBuffer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>indicatorsPointer lengthsPointer rcodesPointer cursizPointer getSelector setSelector nullsPossible tempArray session isUnicodeColumn position </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Oracle</category><attributes><package>OracleEXDI</package></attributes></class><comment><class-id>Database.OracleBuffer</class-id><body>OracleBuffer is a private subclass, and extends ExternalDatabaseBuffer to deal with Oracle.  Intimate details are shared with OracleSession.All CPointers managed by OracleBuffer are assumed to not be automatically garbage collectable.  Clients are responsible for explicitly freeing the space.Instance Variables	indicatorsPointer &lt;CPointer&gt;		Pointer to vector of indicators.	rcodesPointer &lt;CPointer&gt;		Pointer to vector of return codes. It points into memory actually owned by indicatorsPointer.	lengthsPointer &lt;CPointer&gt;		Pointer to vector of item lengths. Like rcodesPointer, it points into memory actually owned by indicatorsPointer.	cursizPointer &lt;nil | CPointer&gt;		Pointer to the current length of the array.  If scalar, holds nil.	getSelector &lt;nil | Symbol&gt;		Selector to perform to get values out of the buffer.	setSelector &lt;nil | Symbol&gt;		Selector to perform to put values into the buffer.	nullsPossible	&lt;Boolean&gt;		true =&gt; the column allows nulls	tempArray &lt;ByteArray&gt;		A ByteArray used to hold DATE and VARNUM data while processing.	session &lt;OracleSession&gt; 			The session in which the OracleBuffer is used.	isUnicodeColumn &lt;Boolean&gt;		true =&gt; the buffer is for a Unicode column.	position &lt;SmallInteger | nil&gt;		The ordinal position of the column in the answer set or in the table.Class Variables	GetSelectorMap &lt;IdentityDictionary&gt;		Maps from internalType to a data conversion selector.</body></comment><class><name>OracleTimestampBuffer</name><environment>Database</environment><super>Database.OracleBuffer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>yearPointer monthPointer dayPointer hourPointer minPointer secPointer fsecPointer pointerInitialized </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Oracle</category><attributes><package>OracleEXDI</package></attributes></class><comment><class-id>Database.OracleTimestampBuffer</class-id><body>OracleTimestampBuffer extends OracleBuffer to deal with Timestamp data types in Oracle.Instance Variables:	yearPointer	&lt;CPointer | nil&gt;			A private pointer used to hold the year information in the conversion process.		monthPointer	&lt;CPointer | nil&gt;			A private pointer used to hold the month information in the conversion process.		dayPointer	&lt;CPointer | nil&gt;			A private pointer used to hold the day information in the conversion process.	hourPointer	&lt;CPointer | nil&gt;			A private pointer used to hold the hour information in the conversion process.	minPointer	&lt;CPointer | nil&gt;			A private pointer used to hold the minute information in the conversion process.	secPointer	&lt;CPointer | nil&gt;			A private pointer used to hold the second information in the conversion process.	fsecPointer	&lt;CPointer | nil&gt;			A private pointer used to hold the fractional second information in the conversion process.	pointerInitialized	&lt;Boolean&gt;		A boolean indicating whether the pointers are initialized.</body></comment><class><name>Oracle64BitInterface</name><environment>Database</environment><super>Database.OracleInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Database.Oracle64BitInterfaceDictionary.*			</imports><category>Database-External-Libraries</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>OracleEXDI</package></attributes></class><comment><class-id>Database.Oracle64BitInterface</class-id><body>This class defines 64-bit calling conventions for the Oracle OCI. It should only be used in 64-bit images, running on a 64-bit VM.The 64-bit VM regards "long int" as a 64-bit integer, but the Oracle libraries are faithful to the original spec, which uses 32-bit integers. Thus, a few changes were made to the 64-bit classes, almost entirely directed at changing the word "long int" to "int", which is seen by the 64-bit VM as a 32-bit integer.</body></comment><class><name>OracleSolaris64Interface</name><environment>Database</environment><super>Database.Oracle64BitInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Database.OracleSolaris64InterfaceDictionary.*			</imports><category>Database-External-Libraries</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>libclntsh.so</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>OracleEXDI</package></attributes></class><comment><class-id>Database.OracleSolaris64Interface</class-id><body>This class defines calling conventions for the Oracle OCI on the 64-bit Solaris platform.  Please refer to the environment variable on your machine for the path containing necessary Oracle library files.</body></comment><class><name>UnableToGetTimestampTime</name><environment>Database</environment><super>Database.OracleDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Oracle</category><attributes><package>OracleEXDI</package></attributes></class><comment><class-id>Database.UnableToGetTimestampTime</class-id><body>UnableToGetTimestampTime is used to indicate that it is unable to get the time part of a Timestamp.</body></comment><class><name>UnableToRetrieveDescriptorInfo</name><environment>Database</environment><super>Database.OracleDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Oracle</category><attributes><package>OracleEXDI</package></attributes></class><comment><class-id>Database.UnableToRetrieveDescriptorInfo</class-id><body>UnableToRetrieveDescriptorInfo is used to indicate that the information of a descriptor could not be retrieved.</body></comment><class><name>OracleLinux64Interface</name><environment>Database</environment><super>Database.Oracle64BitInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Database.OracleLinux64InterfaceDictionary.*			</imports><category>Database-External-Libraries</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>libclntsh.so</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>OracleEXDI</package></attributes></class><comment><class-id>Database.OracleLinux64Interface</class-id><body>This class defines calling conventions for the Oracle OCI on the 64-bit Linux platform.  Please refer to the environment variable on your machine for the path containing necessary Oracle library files.</body></comment><class><name>UnableToGetStatementCacheSize</name><environment>Database</environment><super>Database.OracleDatabaseResumableException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Oracle</category><attributes><package>OracleEXDI</package></attributes></class><comment><class-id>Database.UnableToGetStatementCacheSize</class-id><body>UnableToGetStatementCacheSize is used to indicate that it is unable to get the size of the client-side statement cache.</body></comment><class><name>OracleLargeObjectBuffer</name><environment>Database</environment><super>Database.OracleBuffer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>lobLocatorHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Oracle</category><attributes><package>OracleEXDI</package></attributes></class><comment><class-id>Database.OracleLargeObjectBuffer</class-id><body>OracleLargeObjectBuffer extends OracleBuffer to deal with CLOB, BLOB and BFILE data types in Oracle.Instance Variables:	lobLocatorHolder &lt;ValueHolder on: (CPointer | nil)&gt;		A private value holder which remembers the locator for the LOB.</body></comment><class><name>UnableToReleaseStatement</name><environment>Database</environment><super>Database.OracleDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Oracle</category><attributes><package>OracleEXDI</package></attributes></class><comment><class-id>Database.UnableToReleaseStatement</class-id><body>UnableToReleaseStatement is used to indicate that it is unable to release the current statement handle from the client side cache.</body></comment><class><name>UnableToInitializeInterfaceLibrary</name><environment>Database</environment><super>Database.OracleDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Oracle</category><attributes><package>OracleEXDI</package></attributes></class><comment><class-id>Database.UnableToInitializeInterfaceLibrary</class-id><body>UnableToInitializeInterfaceLibrary is used to indicate that the interface library could not be initialized.</body></comment><class><name>UnsupportedAttributeGet</name><environment>Database</environment><super>Database.OracleDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Oracle</category><attributes><package>OracleEXDI</package></attributes></class><comment><class-id>Database.UnsupportedAttributeGet</class-id><body>UnsupportedAttributeGet is used to indicate that getting the attribute is currently not supported.</body></comment><class><name>UnableToLockObjectReference</name><environment>Database</environment><super>Database.OracleDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Oracle</category><attributes><package>OracleEXDI</package></attributes></class><comment><class-id>Database.UnableToLockObjectReference</class-id><body>UnableToLockObjectReference is used to indicate that an object reference could not be locked.</body></comment><class><name>OracleMacOSX64Interface</name><environment>Database</environment><super>Database.Oracle64BitInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Database.OracleMacOSX64InterfaceDictionary.*			</imports><category>Database-External-Libraries</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>libclntsh.dylib</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>OracleEXDI</package></attributes></class><comment><class-id>Database.OracleMacOSX64Interface</class-id><body>This class defines calling conventions for the Oracle OCI on the 64-bit MacOSX platform.  Please refer to the environment variable on your machine for the path containing necessary Oracle library files.</body></comment><class><name>UnableToTrimLobData</name><environment>Database</environment><super>Database.OracleDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Oracle</category><attributes><package>OracleEXDI</package></attributes></class><comment><class-id>Database.UnableToTrimLobData</class-id><body>UnableToTrimLobData is used to indicate that the data of a lob could not be trimmed.</body></comment><class><name>UnableToAllocateResource</name><environment>Database</environment><super>Database.OracleDatabaseResumableException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Oracle</category><attributes><package>OracleEXDI</package></attributes></class><comment><class-id>Database.UnableToAllocateResource</class-id><body>UnableToAllocateResource is used to indicate that a resource could not be allocated.</body></comment><class><name>OracleRefCursorBuffer</name><environment>Database</environment><super>Database.OracleBuffer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Oracle</category><attributes><package>OracleEXDI</package></attributes></class><comment><class-id>Database.OracleRefCursorBuffer</class-id><body>OracleRefCursorBuffer extends OracleBuffer to deal with Ref Cursors in Oracle.</body></comment><class><name>OracleMacOSXInterface</name><environment>Database</environment><super>Database.OracleInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Database.OracleMacOSXInterfaceDictionary.*			</imports><category>Database-External-Libraries</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>libclntsh.dylib</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>OracleEXDI</package></attributes></class><comment><class-id>Database.OracleMacOSXInterface</class-id><body>This class defines calling conventions for the Oracle OCI on the MacOSX platform.  Please refer to the environment variable on your machine for the path containing necessary Oracle library files.</body></comment><class><name>UnableToGetTimestampDate</name><environment>Database</environment><super>Database.OracleDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Oracle</category><attributes><package>OracleEXDI</package></attributes></class><comment><class-id>Database.UnableToGetTimestampDate</class-id><body>UnableToGetTimestampDate is used to indicate that it is unable to get the date part of a Timestamp.</body></comment><class><name>OracleLobProxy</name><environment>Database</environment><super>Database.OracleLargeObjectBuffer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Oracle</category><attributes><package>OracleEXDI</package></attributes></class><comment><class-id>Database.OracleLobProxy</class-id><body>OracleLobProxy extends OracleLargeObjectBuffer to deal with CLOB, BLOB and BFILE data types in Oracle. It is associated with relevant LOB methods.</body></comment><class><name>UnableToUnlockObjectReference</name><environment>Database</environment><super>Database.OracleDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Oracle</category><attributes><package>OracleEXDI</package></attributes></class><comment><class-id>Database.UnableToUnlockObjectReference</class-id><body>UnableToUnlockObjectReference is used to indicate that an object reference could not be unlocked.</body></comment><class><name>UnableToReadLobData</name><environment>Database</environment><super>Database.OracleDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Oracle</category><attributes><package>OracleEXDI</package></attributes></class><comment><class-id>Database.UnableToReadLobData</class-id><body>UnableToReadLobData is used to indicate that the data of a lob could not be read.</body></comment><class><name>StatementCachingNotSupported</name><environment>Database</environment><super>Database.OracleDatabaseResumableException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Oracle</category><attributes><package>OracleEXDI</package></attributes></class><comment><class-id>Database.StatementCachingNotSupported</class-id><body>StatementCachingNotSupported is used to indicate that client-side statement caching is not supported by the current version of Oracle client.</body></comment><class><name>OracleTransaction</name><environment>Database</environment><super>Database.ExternalDatabaseTransaction</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Oracle</category><attributes><package>OracleEXDI</package></attributes></class><comment><class-id>Database.OracleTransaction</class-id><body>Class OracleTransaction is the concrete implementation of the transaction concept for the Database Connect for Oracle. </body></comment><class><name>UnableToAllocateDescriptor</name><environment>Database</environment><super>Database.OracleDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Oracle</category><attributes><package>OracleEXDI</package></attributes></class><comment><class-id>Database.UnableToAllocateDescriptor</class-id><body>UnableToAllocateDescriptor is used to indicate that an attempt to allocate descriptor failed..</body></comment><class><name>UnableToWriteLobData</name><environment>Database</environment><super>Database.OracleDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Oracle</category><attributes><package>OracleEXDI</package></attributes></class><comment><class-id>Database.UnableToWriteLobData</class-id><body>UnableToWriteLobData is used to indicate that data could not be written into a lob.</body></comment><class><name>UnableToDescribeSchemaObject</name><environment>Database</environment><super>Database.OracleDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Oracle</category><attributes><package>OracleEXDI</package></attributes></class><comment><class-id>Database.UnableToDescribeSchemaObject</class-id><body>UnableToDescribeSchemaObject is used to indicate that it is unable to describe schema object.</body></comment><class><name>UnableToGetLobLength</name><environment>Database</environment><super>Database.OracleDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Oracle</category><attributes><package>OracleEXDI</package></attributes></class><comment><class-id>Database.UnableToGetLobLength</class-id><body>UnableToGetLobLength is used to indicate that it is unable to get the length of a lob.</body></comment><class><name>InvalidAttributeType</name><environment>Database</environment><super>Database.OracleDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Oracle</category><attributes><package>OracleEXDI</package></attributes></class><comment><class-id>Database.InvalidAttributeType</class-id><body>InvalidAttributeType is used to indicate invalid attribute type.</body></comment><class><name>UnableToGetLobChunkSize</name><environment>Database</environment><super>Database.OracleDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Oracle</category><attributes><package>OracleEXDI</package></attributes></class><comment><class-id>Database.UnableToGetLobChunkSize</class-id><body>UnableToGetLobChunkSize is used to indicate that it is unable to get the chunk size of a lob locator.</body></comment><class><name>OracleNT64Interface</name><environment>Database</environment><super>Database.Oracle64BitInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Database.OracleNT64InterfaceDictionary.*			</imports><category>Database-External-Libraries</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>oci.dll</item> <item>advapi32.dll</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>OracleEXDI</package></attributes></class><comment><class-id>Database.OracleNT64Interface</class-id><body>This class defines calling conventions for the Oracle OCI on the 64-bit Windows (Intel) platform.   Please refer to the environment variable on your machine for the path containing necessary Oracle library files.</body></comment><class><name>UnableToFreeDescriptor</name><environment>Database</environment><super>Database.OracleDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Oracle</category><attributes><package>OracleEXDI</package></attributes></class><comment><class-id>Database.UnableToFreeDescriptor</class-id><body>UnableToFreeDescriptor is used to indicate that a descriptor could noe be freed.</body></comment><class><name>UnableToAssignLobLocator</name><environment>Database</environment><super>Database.OracleDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Oracle</category><attributes><package>OracleEXDI</package></attributes></class><comment><class-id>Database.UnableToAssignLobLocator</class-id><body>UnableToAssignLobLocator is used to indicate that a lob locator could not be assigned.</body></comment><class><name>UnableToInitializeEnvironmentHandle</name><environment>Database</environment><super>Database.OracleDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Oracle</category><attributes><package>OracleEXDI</package></attributes></class><comment><class-id>Database.UnableToInitializeEnvironmentHandle</class-id><body>UnableToInitializeEnvironmentHandle is used to indicate that a environment handle could not be initialized.</body></comment><class><name>UnableToReleaseExternalResource</name><environment>Database</environment><super>Database.OracleDatabaseResumableException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Oracle</category><attributes><package>OracleEXDI</package></attributes></class><comment><class-id>Database.UnableToReleaseExternalResource</class-id><body>UnableToReleaseExternalResource is used to indicate that an external resource lob could not be released.</body></comment><class><name>OracleColumnDescription</name><environment>Database</environment><super>Database.ExternalDatabaseColumnDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dbsize internalType isUnicodeColumn </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Oracle</category><attributes><package>OracleEXDI</package></attributes></class><comment><class-id>Database.OracleColumnDescription</class-id><body>The OracleColumnDescription adds information to ExternalDatabaseColumnDescription which is unique to Oracle.Instance Variables	dbsize &lt;SmallInteger | nil&gt;		Maximum size of column as stored in the Oracle data dictionary,		if known.  Use and definition subject to change as needed to support the OCI.	internalType &lt;SmallInteger | nil&gt;		Internal datatype code, if known.  Use and definition subject to change		as needed to support the OCI.	isUnicodeColumn &lt;Boolean&gt;		true =&gt; the buffer is for a Unicode column.</body></comment><class><name>OracleSession</name><environment>Database</environment><super>Database.ExternalDatabaseSession</super><private>false</private><indexed-type>none</indexed-type><inst-vars>resultsCache hstmtHolder herrHolder bindValuePointersHolder maxLongBytes queryIsPLSQL currentRowIndex totalRows rowsInBlock dependentLobs sqlPointerHolder maxBindSize answerLobProxy defaultDisplayLobSize isReleasedFromCacheHolder lobBufferSize reuseColumnBuffers definePointerHolder bindPointerHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Oracle</category><attributes><package>OracleEXDI</package></attributes></class><comment><class-id>Database.OracleSession</class-id><body>OracleSession is the concrete implementation of session services using the Oracle OCI library.Instance Variables	resultsCache	&lt;SmallInteger&gt;		A private cache of the function value.  Used to tell	resultsExternal the outcome of the operation.	hstmtHolder	&lt;ValueHolder on: (CPointer | nil)&gt;		A private value holder which remembers the pointer for the current OCI statement handle, if any.  The value holder is shared with the executor object.	herrHolder		&lt;ValueHolder on: (CPointer | nil)&gt;		A private value holder which remembers the pointer for the current OCI error handle, if any.  The value holder is shared with the executor object.	bindValuePointersHolder &lt;ValueHolder on: ((IdentityDictionary of: OracleBuffer) | nil)&gt;		Holds the OracleBuffers used to reference externally bound parameter values	maxLongBytes	&lt;SmallInteger&gt;		LONG and LONG RAW fields may be up to 65535 bytes long.  Since not all		applications will use data of this length, an interface is provided to reduce		the amount of memory required to buffer fields of these types.	queryIsPLSQL	&lt;Boolean&gt;		Indicates that whether the prepared query is an anonymous PL/SQL block.	currentRowIndex &lt;SmallInteger&gt;		Part of the support for utilizing the array interface for fetching rows.	totalRows &lt;SmallInteger&gt;		Part of the support for utilizing the array interface for fetching rows.	rowsInBlock &lt;SmallInteger&gt;		Part of the support for utilizing the array interface for fetching rows.	dependentLobs &lt;Bag&gt;		LOBs depending on the current session.	sqlPointerHolder		&lt;ValueHolder on: (CPointer | nil)&gt;		A private value holder which remembers the pointer for the current sql, if any.  The value holder is shared with the executor object.	maxBindSize &lt;SmallInteger&gt;		Length of the buffer needed for binding arrays (the size of the longest array to be binded).	needBinding	&lt;Boolean&gt;		A boolean indicating whether binding is needed for the query it is processing.	answerLobProxy	&lt;Boolean&gt;		true =&gt; the LOBs are returned as LOB proxies.		false =&gt; the LOBs are returned as values.	defaultDisplayLobSize &lt;Integer&gt;		A default value defining the length of the LOB to be retrieved. It can be reset to reflect the LOB length desired.	isReleasedFromCacheHolder &lt;ValueHolder on: Boolean&gt;		A private holder on a boolean indicating whether the statement is released from the statement cache. The value holder is shared with the executor object.	lobBufferSize &lt;Integer&gt;		Size of the buffers used to read/write LOBs.	reuseColumnBuffers &lt;Boolean&gt;		A boolean indicating whether the column information will be reused in subsequent SQL processing.	definePointerHolder &lt;ValueHolder on: (CPointer | nil)&gt;		A private value holder which remembers the pointer for the OCI Define handle, if any.  The value holder is shared with the executor object.	bindPointerHolder &lt;ValueHolder on: (CPointer | nil)&gt;		A private value holder which remembers the pointer for the OCI Bind handle, if any.  The value holder is shared with the executor object.Shared Variables	InternalDatatypeToClassMap	&lt;IdentityDictionary&gt;			Maps Oracle data types to Smalltalk classes. 	RegisteredOracleSessions	&lt;HandleRegistry&gt;		A private registry of all active OracleSession instances.</body></comment><class><name>OracleLinuxInterface</name><environment>Database</environment><super>Database.OracleInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Database.OracleLinuxInterfaceDictionary.*			</imports><category>Database-External-Libraries</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>libclntsh.so</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>OracleEXDI</package></attributes></class><comment><class-id>Database.OracleLinuxInterface</class-id><body>This class defines calling conventions for the Oracle OCI on the Linux (Intel) platform.  Please refer to the environment variable on your machine for the path containing necessary Oracle library files.</body></comment><class><name>InconsistentDataTypesInArrayBinding</name><environment>Database</environment><super>Database.OracleDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Oracle</category><attributes><package>OracleEXDI</package></attributes></class><comment><class-id>Database.InconsistentDataTypesInArrayBinding</class-id><body>InconsistentDataTypesInArrayBinding  is used to indicate inconsistent data types when using array binding.</body></comment><class><name>OracleError</name><environment>Database</environment><super>Database.ExternalDatabaseError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Oracle</category><attributes><package>OracleEXDI</package></attributes></class><comment><class-id>Database.OracleError</class-id><body>Class OracleError adds information about the error returned from the OCI interface.  Refer to the Oracle documentation for further details.</body></comment><class><name>OracleNTInterface</name><environment>Database</environment><super>Database.OracleInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Database.OracleNTInterfaceDictionary.*			</imports><category>Database-External-Libraries</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>oci.dll</item> <item>advapi32.dll</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>true</beVirtual><optimizationLevel>full</optimizationLevel><package>OracleEXDI</package></attributes></class><comment><class-id>Database.OracleNTInterface</class-id><body>This class defines calling conventions for the Oracle OCI on the Windows NT (Intel) platform.  Please refer to the environment variable on your machine for the path containing necessary Oracle library files.</body></comment><class><name>UnableToSetStatementCacheSize</name><environment>Database</environment><super>Database.OracleDatabaseResumableException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Oracle</category><attributes><package>OracleEXDI</package></attributes></class><comment><class-id>Database.UnableToSetStatementCacheSize</class-id><body>UnableToSetStatementCacheSize is used to indicate that it is unable to set the size of the client-side statement cache.</body></comment><class><name>OracleAIXInterface</name><environment>Database</environment><super>Database.OracleInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Database.OracleAIXInterfaceDictionary.*			</imports><category>Database-External-Libraries</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>libclntsh.a(shr.o)</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>OracleEXDI</package></attributes></class><comment><class-id>Database.OracleAIXInterface</class-id><body>This class defines calling conventions for the Oracle OCI on the AIX platform.  Please refer to the environment variable on your machine for the path containing necessary Oracle library files.</body></comment><class><name>UnsupportedTransactionMode</name><environment>Database</environment><super>Database.OracleDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Oracle</category><attributes><package>OracleEXDI</package></attributes></class><comment><class-id>Database.UnsupportedTransactionMode</class-id><body>UnsupportedTransactionMode is used to indicate that an attempt was made to set an unsupported transaction mode.</body></comment><class><name>UnableToConstructTimestamp</name><environment>Database</environment><super>Database.OracleDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Oracle</category><attributes><package>OracleEXDI</package></attributes></class><comment><class-id>Database.UnableToConstructTimestamp</class-id><body>UnableToConstructTimestamp is used to indicate that it is unable to construct a Timestamp.</body></comment><shared-variable><name>RegisteredOracleConnections</name><environment>Database.OracleConnection</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>OracleEXDI</package></attributes></shared-variable><shared-variable><name>AttributeTypeConversionMap</name><environment>Database.OracleConnection</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>OracleEXDI</package></attributes></shared-variable><shared-variable><name>EncoderMap</name><environment>Database.OracleConnection</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>OracleEXDI</package></attributes></shared-variable><shared-variable><name>OCIClientVersion</name><environment>Database.OracleConnection</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>OracleEXDI</package></attributes></shared-variable><shared-variable><name>RegisteredOracleSessions</name><environment>Database.OracleSession</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>OracleEXDI</package></attributes></shared-variable><shared-variable><name>InternalDatatypeToClassMap</name><environment>Database.OracleSession</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>OracleEXDI</package></attributes></shared-variable><shared-variable><name>DefaultUnsignedCharPointerType</name><environment>Database.OracleBuffer</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>OracleEXDI</package></attributes></shared-variable><shared-variable><name>Unsigned32BitIntType</name><environment>Database.OracleBuffer</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>OracleEXDI</package></attributes></shared-variable><shared-variable><name>DefaultUnsignedShortPointerType</name><environment>Database.OracleBuffer</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>OracleEXDI</package></attributes></shared-variable><shared-variable><name>DefaultDoublePointerType</name><environment>Database.OracleBuffer</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>OracleEXDI</package></attributes></shared-variable><shared-variable><name>DefaultFloatPointerType</name><environment>Database.OracleBuffer</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>OracleEXDI</package></attributes></shared-variable><shared-variable><name>DefaultShortPointerType</name><environment>Database.OracleBuffer</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>OracleEXDI</package></attributes></shared-variable><shared-variable><name>DefaultLongPointerType</name><environment>Database.OracleBuffer</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>OracleEXDI</package></attributes></shared-variable><shared-variable><name>SetSelectorMap</name><environment>Database.OracleBuffer</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>OracleEXDI</package></attributes></shared-variable><shared-variable><name>Signed32BitIntType</name><environment>Database.OracleBuffer</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>OracleEXDI</package></attributes></shared-variable><shared-variable><name>GetSelectorMap</name><environment>Database.OracleBuffer</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>OracleEXDI</package></attributes></shared-variable><shared-variable><name>OracleLinux64InterfaceDictionary</name><environment>Database</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>OracleEXDI</package></attributes></shared-variable><shared-variable><name>OracleMacOSXInterfaceDictionary</name><environment>Database</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>OracleEXDI</package></attributes></shared-variable><shared-variable><name>OracleSolaris64InterfaceDictionary</name><environment>Database</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>OracleEXDI</package></attributes></shared-variable><shared-variable><name>OracleInterfaceDictionary</name><environment>Database</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>OracleEXDI</package></attributes></shared-variable><shared-variable><name>Oracle64BitInterfaceDictionary</name><environment>Database</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>OracleEXDI</package></attributes></shared-variable><shared-variable><name>OracleMacOSX64InterfaceDictionary</name><environment>Database</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>OracleEXDI</package></attributes></shared-variable><shared-variable><name>OracleAIXInterfaceDictionary</name><environment>Database</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>OracleEXDI</package></attributes></shared-variable><shared-variable><name>OracleNTInterfaceDictionary</name><environment>Database</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>OracleEXDI</package></attributes></shared-variable><shared-variable><name>OracleLinuxInterfaceDictionary</name><environment>Database</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>OracleEXDI</package></attributes></shared-variable><shared-variable><name>OracleSolarisInterfaceDictionary</name><environment>Database</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>OracleEXDI</package></attributes></shared-variable><shared-variable><name>OracleNT64InterfaceDictionary</name><environment>Database</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>OracleEXDI</package></attributes></shared-variable><methods><class-id>Database.OracleDatabaseException</class-id> <category>printing</category><body package="OracleEXDI">defaultMessageText	^(#oracleDatabaseException &lt;&lt; #oracleDB &gt;&gt; 'Oracle Database Exception.') asString</body></methods><methods><class-id>Database.OracleDatabaseResumableException</class-id> <category>printing</category><body package="OracleEXDI">defaultMessageText	^(#oracleResumableException &lt;&lt; #oracleDB &gt;&gt; 'Oracle resumable exception.') asString</body></methods><methods><class-id>Database.OracleDatabaseResumableException class</class-id> <category>testing</category><body package="OracleEXDI">mayResume	^true</body></methods><methods><class-id>Database.SuccessWithInformation</class-id> <category>printing</category><body package="OracleEXDI">defaultMessageText	^(#successWithInformation &lt;&lt; #oracleDB &gt;&gt; 'Operation succeeded, but with information.') asString</body></methods><methods><class-id>Database.UnableToModifyObjectInfo</class-id> <category>printing</category><body package="OracleEXDI">defaultMessageText	^(#unableToModifyObjectInformation &lt;&lt; #oracleDB &gt;&gt; 'Unable to modify object information.') asString</body></methods><methods><class-id>Database.OracleConnection</class-id> <category>initialize-release</category><body package="OracleEXDI">initialize	"Establish initial value for instance variables.	OracleConnection initialize."	super initialize.	henvHolder := nil asValue. 	herrHolder := nil asValue. 	hsrvrHolder := nil asValue. 	hsessHolder := nil asValue. 	htxnHolder := nil asValue. 	hsvcctxHolder := nil asValue.	attributeLengthPointerHolder := nil asValue.	attributePointerHolder := nil asValue.	parameterPointerHolder := nil asValue.	descriptorPointerHolder := nil asValue.	self transactionMode: #NEW.	useStatementCaching := false.	self oracleEncodingId: 0.	self oracleUnicodeEncodingId: 0.</body><body package="OracleEXDI">initializeFromLogin: aLogin	"Use statement caching if supported.  This is called by Glorp.  The #useStatementCaching: setter also asks if I supportStatementCaching but raises an error if asked to set true when I do not, so this method checks and assigns directly rather than risk raising that error.  (The setter also checks #isConnected but this method is only ever called before we connect so we ignore that check.)"	super initializeFromLogin: aLogin.	self supportStatementCaching ifTrue:		[useStatementCaching := true].</body></methods><methods><class-id>Database.OracleConnection</class-id> <category>printing</category><body package="OracleEXDI">printOn: aStream	| hsvcctx |	hsvcctx := self hsvcctx.	super printOn: aStream.	(hsvcctx isNil or: [hsvcctx referentAddress isNil]) ifFalse:		[ aStream nextPutAll: '( hsvcctx = ';			        nextPutAll: (hsvcctx referentAddress printStringRadix: 16);			        nextPutAll: ' )' ]</body></methods><methods><class-id>Database.OracleConnection</class-id> <category>private-accessing</category><body package="OracleEXDI">attributeLengthPointer	^attributeLengthPointerHolder value</body><body package="OracleEXDI">attributeLengthPointer: aCPointerOrNil	attributeLengthPointerHolder value: aCPointerOrNil</body><body package="OracleEXDI">attributeLengthPointerHolder	^attributeLengthPointerHolder</body><body package="OracleEXDI">attributeLengthPointerHolder: aValueHolder	attributeLengthPointerHolder := aValueHolder</body><body package="OracleEXDI">attributePointer	^attributePointerHolder value</body><body package="OracleEXDI">attributePointer: aCPointerOrNil	attributePointerHolder value: aCPointerOrNil</body><body package="OracleEXDI">attributePointerHolder	^attributePointerHolder</body><body package="OracleEXDI">attributePointerHolder: aValueHolder	attributePointerHolder := aValueHolder</body><body package="OracleEXDI">descriptorPointer	^descriptorPointerHolder value</body><body package="OracleEXDI">descriptorPointer: aCPointerOrNil	descriptorPointerHolder value: aCPointerOrNil</body><body package="OracleEXDI">descriptorPointerHolder	^descriptorPointerHolder</body><body package="OracleEXDI">descriptorPointerHolder: aValueHolder	descriptorPointerHolder := aValueHolder</body><body package="OracleEXDI">freePointers	self attributeLengthPointer notNil ifTrue: [ 		self attributeLengthPointer freePointer.		self attributeLengthPointer: nil 	].	self attributePointer notNil ifTrue: [ 		self attributePointer freePointer.		self attributePointer: nil 	].	self parameterPointer notNil ifTrue: [ 		self parameterPointer freePointer.		self parameterPointer: nil 	].	self descriptorPointer notNil ifTrue: [ 		self descriptorPointer freePointer.		self descriptorPointer: nil 	].</body><body package="OracleEXDI">henv	^henvHolder value</body><body package="OracleEXDI">henv: aCPointerOrNil	henvHolder value: aCPointerOrNil.</body><body package="OracleEXDI">henvHolder	^henvHolder</body><body package="OracleEXDI">henvHolder: aValueHolder	henvHolder := aValueHolder</body><body package="OracleEXDI">herr	^herrHolder value</body><body package="OracleEXDI">herr: aCPointerOrNil	herrHolder value: aCPointerOrNil.</body><body package="OracleEXDI">herrHolder	^herrHolder</body><body package="OracleEXDI">herrHolder: aValueHolder	herrHolder := aValueHolder</body><body package="OracleEXDI">hsess	^hsessHolder value</body><body package="OracleEXDI">hsess: aCPointerOrNil	hsessHolder value: aCPointerOrNil.</body><body package="OracleEXDI">hsessHolder	^hsessHolder</body><body package="OracleEXDI">hsessHolder: aValueHolder	hsessHolder := aValueHolder</body><body package="OracleEXDI">hsrvr	^hsrvrHolder value</body><body package="OracleEXDI">hsrvr: aCPointerOrNil	hsrvrHolder value: aCPointerOrNil.</body><body package="OracleEXDI">hsrvrHolder	^hsrvrHolder</body><body package="OracleEXDI">hsrvrHolder: aValueHolder	hsrvrHolder := aValueHolder</body><body package="OracleEXDI">hsvcctx	^hsvcctxHolder value</body><body package="OracleEXDI">hsvcctx: aCPointerOrNil		hsvcctxHolder value: aCPointerOrNil.</body><body package="OracleEXDI">hsvcctxHolder	^hsvcctxHolder</body><body package="OracleEXDI">hsvcctxHolder: aValueHolder	hsvcctxHolder := aValueHolder</body><body package="OracleEXDI">htxn	^htxnHolder value</body><body package="OracleEXDI">htxn: aCPointerOrNil	htxnHolder value: aCPointerOrNil.</body><body package="OracleEXDI">htxnHolder	^htxnHolder</body><body package="OracleEXDI">htxnHolder: aValueHolder	htxnHolder := aValueHolder</body><body package="OracleEXDI">isolationLevel: newIsolationLevel	"Set the current isolation level."	(#(#RR #RC #S #RO) includes: newIsolationLevel) ifFalse: [self class unsupportedIsolationLevelSignal raise].	isolationLevel := newIsolationLevel.</body><body package="OracleEXDI">parameterPointer	^parameterPointerHolder value</body><body package="OracleEXDI">parameterPointer: aCPointerOrNil	parameterPointerHolder value: aCPointerOrNil</body><body package="OracleEXDI">parameterPointerHolder	^parameterPointerHolder</body><body package="OracleEXDI">parameterPointerHolder: aValueHolder	parameterPointerHolder := aValueHolder</body><body package="OracleEXDI">transactionMode	"Return the current transaction mode."	^transactionMode</body><body package="OracleEXDI">transactionMode: newTransactionMode	"Set the current transaction mode."	(#(#NEW #S #RO) includes: newTransactionMode) ifFalse: [self class unsupportedTransactionModeSignal raise].	transactionMode := newTransactionMode.</body></methods><methods><class-id>Database.OracleConnection</class-id> <category>private-finalization</category><body package="OracleEXDI">executor	| ex |	ex := super executor.	ex henvHolder: self henvHolder.	ex hsvcctxHolder: self hsvcctxHolder.	ex herrHolder: self herrHolder.	ex hsrvrHolder: self hsrvrHolder.	ex hsessHolder: self hsessHolder.	ex htxnHolder: self htxnHolder.	ex attributeLengthPointerHolder: self attributeLengthPointerHolder.	ex attributePointerHolder: self attributePointerHolder.	ex parameterPointerHolder: self parameterPointerHolder.	ex descriptorPointerHolder: self descriptorPointerHolder.	^ex</body><body package="OracleEXDI">finalizeExternal	| henv |	((henv := self henv) isNil or: [henv referentAddress isNil])		ifTrue: [^self].	traceLevel &gt;= 1 ifTrue: [self class trace: nil].	self freePointers.	super finalizeExternal</body><body package="OracleEXDI">key	"The henvHolder is unique to the connection and is constant 	across pause/resume."	^self henvHolder</body></methods><methods><class-id>Database.OracleConnection</class-id> <category>accessing</category><body package="OracleEXDI">authenticationMode	^authenticationMode</body><body package="OracleEXDI">authenticationMode: anInteger	authenticationMode := anInteger</body><body package="OracleEXDI">encoding	"Answer the character set name, and set the encoding in interface class if necessary"	encoding isNil ifTrue: [ | xif |		xif := self class xif.		(encoding := xif encoding) == nil ifTrue: [			encoding := self getEncoding.			encoding isNil ifTrue: [ encoding := xif getEncoding ]. 			xif encoding: encoding. 		]	].	^encoding</body><body package="OracleEXDI">executionMode	^executionMode</body><body package="OracleEXDI">getErrors	"Return a collection of OracleError(s) "	"If we don't have an error handle allocated we can only fetch environment errors."	^(self herr isNil 		ifTrue: [ self getEnvironmentErrors ]		ifFalse: [ self getConnectionErrors ]).</body><body package="OracleEXDI">getServerVersion	| xif rtval hsrvr herr bufp bufSize ub |	self supportGetServerVersion ifFalse: [ ^nil ].	self isConnected ifFalse:		[ ^self class connectionNotOpenSignal raise  ].	xif := self class xif.	hsrvr := self hsrvr.	herr := self herr.	[ "Begin unwind protection (1)"  		bufSize := 512.		bufp := xif OraText perform: xif mallocSelector with: bufSize + 1.		rtval := xif OCIServerVersion: hsrvr			 		with: herr					with: bufp 					with: bufSize 					with: xif OCI_HTYPE_SERVER.	(traceLevel &gt;= 1) ifTrue:		[(self traceStream) 			print: rtval; 			nextPutAll: ' = OCIServerVersion( hndlp = ';			nextPutAll: (hsrvr referentAddress printStringRadix:16);			nextPutAll: ' , errhp = ';			nextPutAll: (herr referentAddress printStringRadix:16);			nextPutAll: ' , bufp = ';			nextPutAll: (bufp referentAddress printStringRadix:16);			nextPutAll: ' , bufsz = '; print: bufSize;			nextPutAll: ' , hndltype = OCI_HTYPE_SERVER ';			nextPutAll: ' )'.		self class trace: self emitTrace].	(rtval == xif OCI_SUCCESS) ifTrue: [		ub := UninterpretedBytes new: bufSize. 		bufp copyAt: 0 to: ub size: bufSize startingAt: 1.	].     "End unwind protection (1)"] 		ensure: [ bufp == nil  ifFalse: [ bufp freePointer ]].	(rtval == xif OCI_SUCCESS) ifFalse: 		[ | errs |		errs := self getErrors.	        ^self class unableToQueryDriverInformationSignal raiseWith: errs errorString: errs first dbmsErrorString  ].	encoding isNil ifTrue: [		^ub stringAt: 1	] ifFalse: [		^ub copyCStringFromHeap: self encoding asUppercase asSymbol.	]</body><body package="OracleEXDI">getStatementCacheSize	(self useStatementCaching and: [ self isConnected ]) ifTrue: [		^self getAttribute: #OCI_ATTR_STMTCACHESIZE			descriptor: self hsvcctx			type: #OCI_HTYPE_SVCCTX	].	^self class unableToGetStatementCacheSizeSignal raiseRequest</body><body package="OracleEXDI">oracleEncodingId	^oracleEncodingId</body><body package="OracleEXDI">oracleEncodingId: anEncodingId	oracleEncodingId := anEncodingId</body><body package="OracleEXDI">oracleUnicodeEncodingId	^oracleUnicodeEncodingId</body><body package="OracleEXDI">oracleUnicodeEncodingId: anEncodingId	oracleUnicodeEncodingId := anEncodingId</body><body package="OracleEXDI">setStatementCacheSize: anInteger 	(self useStatementCaching and: [ self isConnected ]) ifTrue: [		self setAttribute: anInteger			type: #OCI_ATTR_STMTCACHESIZE			descriptor: self hsvcctx			type: #OCI_HTYPE_SVCCTX	] ifFalse: [		^self class unableToSetStatementCacheSizeSignal raiseRequest	].</body><body package="OracleEXDI">unicodeEncoding	"Answer the character set name for Unicode columns."	unicodeEncoding isNil ifTrue: [ 		self unicodeEncoding: self getUnicodeEncoding.	].	^unicodeEncoding</body><body package="OracleEXDI">unicodeEncoding: anEncoding	unicodeEncoding := anEncoding</body><body package="OracleEXDI">useOSAuthentication	self authenticationMode: self class xif OCI_CRED_EXT</body><body package="OracleEXDI">useStatementCaching	useStatementCaching ifNil: [useStatementCaching := false].	^useStatementCaching</body><body package="OracleEXDI">useStatementCaching: aBoolean 	self isConnected ifTrue: [^self class invalidConnectionStateSignal raise].	aBoolean ifTrue: [		self supportStatementCaching ifTrue: [			useStatementCaching := true.		] ifFalse: [			self class statementCachingNotSupportedSignal raiseRequest.			useStatementCaching := false.		].	] ifFalse: [		useStatementCaching := false.	].</body></methods><methods><class-id>Database.OracleConnection</class-id> <category>testing</category><body package="OracleEXDI">hasLocaleSupport	"Answer true is the loaded OCI has Globalization Support."	^self class supportMethod: #OCINlsEnvironmentVariableGet:with:with:with:with:.</body><body package="OracleEXDI">isNonBlocking	^false</body><body package="OracleEXDI">supportEnvNlsCreate	"Answer true is the loaded OCI supports function OCIEnvNlsCreate."	^self class supportMethod: #OCIEnvNlsCreate:with:with:with:with:with:with:with:with:with:.</body><body package="OracleEXDI">supportGetServerVersion	"Answer true is the loaded OCI supports getting Oracle Server Version."	^self class supportMethod: #OCIServerVersion:with:with:with:with:.</body><body package="OracleEXDI">supportStatementCaching	"Answer true is the loaded OCI supports Statement Caching."	^self class supportMethod: #OCIStmtPrepare2:with:with:with:with:with:with:with:with:.</body></methods><methods><class-id>Database.OracleConnection</class-id> <category>private-handle allocation/release</category><body package="OracleEXDI">allocHandlePointerExternal: handle type: handleType	| rtval xif henv |	xif := self class xif.	henv := self henv.	"Should check if pointer to pointer"	rtval := xif OCIHandleAlloc: henv						  with: handle					        with: (xif perform: handleType )						  with: 0						  with: 0.	(traceLevel &gt;= 3) ifTrue:	[ (self traceStream)	print: rtval;  nextPutAll: ' = OCIHandleAlloc( henv = ';	nextPutAll: (henv  referentAddress printStringRadix: 16);	nextPutAll: ',  handle = ';	nextPutAll: (handle contents referentAddress printStringRadix: 16);	nextPutAll: ', type = ';      nextPutAll: handleType printString;	nextPutAll: ', usermemsize = 0, userdata = 0)'.	self class trace: self emitTrace ].	(rtval == xif OCI_SUCCESS) ifFalse: 		[ | errs |		  errs := self getErrors.		  ^self class unableToAllocateResourceHandleSignal raiseRequestWith: errs errorString: errs first dbmsErrorString ]</body><body package="OracleEXDI">freeHandlePointerExternal: handle type: handleType	| rtval xif |	xif := self class xif.		(handle isNil or: [ handle isValid not ] ) ifTrue: [^self ].	rtval := xif OCIHandleFree: handle					       with: (xif perform: handleType ).	(traceLevel &gt;= 3) ifTrue:	[ (self traceStream)		print: rtval;  nextPutAll: ' = OCIHandleFree( handle = ';		nextPutAll: (handle  referentAddress printStringRadix: 16);		nextPutAll: ', type = ';     		nextPutAll: handleType printString;		nextPutAll: ')'.	self class trace: self emitTrace ].	(rtval == xif OCI_SUCCESS) ifFalse: 		[ 	| errs errCode |		 	errs := self getErrors.			(errs isEmpty not 			and: [ ((errCode := (errs at: 1) dbmsErrorCode ) == 1403) not 			and: [ (errCode ==  22303) not ] ] )				ifTrue: [ ^self class unableToReleaseExternalResourceSignal raiseRequestWith: errs errorString: errs first dbmsErrorString  ] ]</body></methods><methods><class-id>Database.OracleConnection</class-id> <category>private-execution</category><body package="OracleEXDI">acquireExternal: aPassword	"Acquire the external resources involved with a connection to the 	SQL-environment."	| xif name pw env |	xif := self class xif.	self authenticationMode == xif OCI_CRED_EXT ifTrue: [		name := ''.		pw := ''.	] ifFalse: [		name := self username.		pw := aPassword.	].	(env := self environment) isNil ifTrue:		[ env := self class defaultEnvironment ].	[ env isString ] whileFalse:		[ env := self class requiredEnvironmentSignal raiseRequest  ].	env := self class mapLogical: env.	[ "Begin unwind protection (1)"	"Allocate necessary handles."		self supportEnvNlsCreate ifTrue: [			self unprotectedAllocHenvWithNls		] ifFalse: [			self unprotectedAllocHenv		]. 		["Begin unwind protection (2)"			self serverAttachEnvironmentExternal: (env asByteArrayEncoding: self encoding).			self setAttribute: self hsrvr type: #OCI_ATTR_SERVER 			descriptor: self hsvcctx type: #OCI_HTYPE_SVCCTX.			( (name size == 0) and: [ pw size == 0 ]) ifTrue: [				self authenticationMode: xif OCI_CRED_EXT.			] ifFalse: [				self authenticationMode: xif OCI_CRED_RDBMS.				self setAttribute: name type: #OCI_ATTR_USERNAME  		  		descriptor: self hsess type: #OCI_HTYPE_SESSION .				self setAttribute: pw type: #OCI_ATTR_PASSWORD 		  		descriptor: self hsess type: #OCI_HTYPE_SESSION.			]. 		self setAttribute: self htxn type: #OCI_ATTR_TRANS               		descriptor: self hsvcctx type: #OCI_HTYPE_SVCCTX.		self setAttribute: self hsess type: #OCI_ATTR_SESSION 	      		descriptor: self hsvcctx type: #OCI_HTYPE_SVCCTX.		[ "Begin unwind protection (3)"			self sessionBeginExternal		"End unwind protection (3)" ]		ifCurtailed:			[self  sessionEndExternal].	"End unwind protection (2)" ]		ifCurtailed:			[self  serverDetachExternal].	"End unwind protection (1)" ]		ifCurtailed:			[	"Something went wrong so we must implicitly free any handles we've allocated."				self  unprotectedFreeHenv ].	self singleStatementTransactions</body><body package="OracleEXDI">beginExternal	"Mark the beginning of receiver's portion of a transaction."	| xif rtval hsvcctx herr mode|	xif := self class xif.	hsvcctx := self hsvcctx.	herr := self herr.	mode := (Array 				with: xif OCI_TRANS_NEW				with: xif OCI_TRANS_SERIALIZABLE				with: xif OCI_TRANS_READONLY) 					at: (#(#NEW #S #RO) indexOf: self transactionMode).	super beginExternal.	rtval := xif OCITransStart: hsvcctx 					      with: herr						with: 1						with: mode.	(traceLevel &gt;= 1) ifTrue:		[(self traceStream) 			print: rtval; 			nextPutAll: ' = OCITransStart( hsvcctx = ';			nextPutAll: (hsvcctx referentAddress printStringRadix:16);			nextPutAll: ', herr = ';			nextPutAll: (herr  referentAddress printStringRadix:16);			nextPutAll: ', timeout = 1';			nextPutAll: ', flag = ';			nextPutAll: (mode printStringRadix:16).		self class trace: self emitTrace].	(rtval == xif OCI_SUCCESS) ifFalse:		[ | errs |		errs := self getErrors.		^self class externalDatabaseTransactionErrorSignal raiseWith: errs errorString: errs first dbmsErrorString ].	self multiStatementTransactions</body><body package="OracleEXDI">commitExternal	| xif rtval hsvcctx herr |	xif := self class xif.	hsvcctx := self hsvcctx.	herr := self herr.	super commitExternal ifFalse: [^self].	rtval := xif OCITransCommit: hsvcctx 						   with: herr						   with: xif  OCI_DEFAULT.	(traceLevel &gt;= 1) ifTrue:		[(self traceStream) 			print: rtval; 			nextPutAll: ' = OCITransCommit( hsvcctx = ';			nextPutAll: (hsvcctx referentAddress printStringRadix:16);			nextPutAll: ', herr = ';			nextPutAll: (herr referentAddress printStringRadix:16);			nextPutAll: ', OCI_DEFAULT )'.		self class trace: self emitTrace].	(rtval == xif OCI_SUCCESS) ifFalse:		[ 	| errs |			errs := self getErrors.			^self class externalDatabaseTransactionErrorSignal raiseWith: errs errorString: errs first dbmsErrorString ].	self singleStatementTransactions</body><body package="OracleEXDI">dismissExternal	"Release the external resources."	[ "Begin unwind protection (1)"	self sessionEndExternal.	self serverDetachExternal.	self freePointers.	"End unwind protection (1)" ] 		ensure: [ 	"Whether or not there was a failure, there's no point in hanging									on to stuff."									self unprotectedFreeHenv ]</body><body package="OracleEXDI">getAttributeExternal: attributePointer type: attributeType length: attributeLengthPointer descriptor: descriptor  type: descriptorType	| xif rtval |	xif := self class xif.		rtval := xif OCIAttrGet: descriptor				    with:  (xif perform: descriptorType  )				    with:  attributePointer 				    with:  attributeLengthPointer				    with: (xif perform: attributeType )				    with: self herr.	(traceLevel &gt;= 3) ifTrue:	[ (self traceStream)	print: rtval;  nextPutAll: ' = OCIAttribGet( descriptor = ';	nextPutAll: (descriptor referentAddress printStringRadix: 16);	nextPutAll: ',  descriptorType = '; 	nextPutAll: descriptorType printString;	nextPutAll: ', attribute  = ';	nextPutAll: (attributePointer referentAddress printStringRadix: 16);	nextPutAll: ', attributeType  = ';      nextPutAll: attributeType  printString;	nextPutAll: ', length  = '; print: attributeLengthPointer contents;	nextPutAll: ', herr = ';	nextPutAll: (self herr referentAddress printStringRadix: 16);	nextPutAll: ')'.	self class trace: self emitTrace ].	(rtval == xif OCI_SUCCESS) ifFalse: 		[ | errs |		errs := self getErrors.	        ^self class unableToRetrieveDescriptorInfoSignal raiseWith: errs errorString: errs first dbmsErrorString  ]</body><body package="OracleEXDI">getErrorsExternal: handleOrNil  type: errorType at: errorIndex	| xif szErrorMsg cbErrorMsgMax rtval error pcbErrorCode |	xif := self class xif.	[ "Begin unwind protection."	cbErrorMsgMax  := 512.	szErrorMsg := xif OraText perform: xif mallocSelector with: cbErrorMsgMax + 1.	pcbErrorCode := CIntegerType long perform: xif mallocSelector with: 1.	pcbErrorCode contents: 0.	rtval := xif OCIErrorGet: handleOrNil 					  with: errorIndex					  with: 0  "SqlState not used in this version"					  with: pcbErrorCode					  with: szErrorMsg					  with: cbErrorMsgMax					  with: (xif perform: errorType ).	(rtval == xif OCI_SUCCESS) ifTrue: [ 		error := self class errorClass new.	    	error dbmsErrorCode: pcbErrorCode contents.		error dbmsErrorString: (szErrorMsg copyCStringFromHeap: self encoding asUppercase asSymbol).		( traceLevel &gt;= 2 ) ifTrue:		[ (self traceStream)		print: rtval; nextPutAll: ' = OCIErrorGet( handle = *';		nextPutAll:  (handleOrNil  referentAddress printStringRadix: 16); 		nextPutAll: ', szSqlState = * , errorCode = '; print: error dbmsErrorCode;		nextPutAll: ', errorMsg = ';		nextPutAll: error dbmsErrorString;		nextPutAll: ', cbErrorMsgMax = '; print: cbErrorMsgMax;		nextPutAll: ', errorType = ';		nextPutAll: errorType printString;		nextPutAll: ' )'; crtab.		self class trace: self emitTrace ] ].	"End unwind protection." ]		ensure:			[ szErrorMsg == nil ifFalse: [ szErrorMsg freePointer ].			  pcbErrorCode == nil ifFalse: [ pcbErrorCode freePointer ] ].	^error</body><body package="OracleEXDI">getSchemaObjectAttributeFromDescriptorExternal: hDescriptor type: descriptorType startingAt: position	"Retrieve parameter descriptor for the ."	| xif  rtval herr schemaObjectAttribute |	xif := self class xif.	herr := self herr.	((self parameterPointer isNil) or: [ self parameterPointer isValid not ]) ifTrue:  [		self parameterPointer: ( xif OCIParam pointerType perform: xif mallocSelector with: 1).		self parameterPointer contents: (xif OCIParam pointerType cast: nil ).	].	rtval := xif OCIParamGet: hDescriptor						with: (xif perform: descriptorType)						with: herr 						with: self parameterPointer						with: position.	(rtval == xif OCI_NO_DATA)		ifTrue: [ ^nil ].	(rtval == xif OCI_SUCCESS)		ifFalse: [ ^nil ].	schemaObjectAttribute := self parameterPointer contents.	^schemaObjectAttribute</body><body package="OracleEXDI">getSchemaObjectDescriptorExternal: objectPointer  size:  describeSize kind: describeKind type: describeType	"Answer a schema object parameter using a describePointer.	A describePointer could be a Qualified String or a REF or a TDO.  The describeKind determines which."	| xif herr rtval hsvcctx descriptor |	xif := self class xif.	hsvcctx  := self hsvcctx.	herr := self herr.	((self descriptorPointer isNil) or: [ self descriptorPointer isValid not ]) ifTrue: [ 		self descriptorPointer: ( xif OCIDescribe pointerType perform: xif mallocSelector with: 1).		self allocHandlePointerExternal: self descriptorPointer type: #OCI_HTYPE_DESCRIBE.	].	["Begin unwind protection"	descriptor := self descriptorPointer contents.		rtval := xif OCIDescribeAny: hsvcctx						   with: herr						   with: objectPointer						   with: describeSize						   with: (xif perform: describeKind )						   with: 1						   with: (xif perform: describeType )						   with: descriptor.	(rtval == xif OCI_SUCCESS)		ifFalse: [ | errs |				 errs := self getErrors.				 self class unableToDescribeSchemaObjectSignal raiseWith: errs errorString: errs first dbmsErrorString  ].	"End unwind protection"] ifCurtailed: 			[ self freeHandlePointerExternal: descriptor type:  #OCI_HTYPE_DESCRIBE ].	^descriptor</body><body package="OracleEXDI">installExternal	"Perform return from snapshot processing."		super installExternal.	self htxn: nil.	self hsrvr: nil.	self hsess: nil.	self hsvcctx: nil.	self herr: nil.</body><body package="OracleEXDI">rollbackExternal	| xif rtval hsvcctx herr |	xif := self class xif.	hsvcctx := self hsvcctx.	herr := self herr.	super rollbackExternal ifFalse: [^self].	rtval := xif OCITransRollback: self hsvcctx 						   with:   self herr						   with:    xif  OCI_DEFAULT.	(traceLevel &gt;= 1) ifTrue:		[(self traceStream) 			print: rtval; 			nextPutAll: ' = OCITransRollback( hsvcctx = ';			nextPutAll: (hsvcctx referentAddress printStringRadix:16);			nextPutAll: ', herr = ';			nextPutAll: (herr referentAddress printStringRadix:16);			nextPutAll: ', OCI_DEFAULT )'.		self class trace: self emitTrace].	(rtval == xif OCI_SUCCESS) ifFalse:		[ | errs |		errs := self getErrors.		^self class externalDatabaseTransactionErrorSignal raiseWith: errs errorString: errs first dbmsErrorString ].	self singleStatementTransactions</body><body package="OracleEXDI">serverAttachEnvironmentExternal: environ	"Create an access path to a data source for OCI operations."	| rtval xif herr hsrvr |		xif := self class xif.	self unprotectedAllocHerr.	self unprotectedAllocHsvcctx.	self unprotectedAllocHsrvr.	self unprotectedAllocHsess.	self unprotectedAllocHtxn.	herr := self herr.	hsrvr := self hsrvr.		rtval := xif OCIServerAttach:hsrvr						   with: herr						   with: environ						   with: environ size						   with: (xif OCI_DEFAULT) .	(traceLevel &gt;= 1) ifTrue:	[(self traceStream) 	print: rtval; 	nextPutAll: ' = OCIAttachServer( hsrvr = ';	nextPutAll: (hsrvr referentAddress printStringRadix:16);	nextPutAll: ', herr = ';	nextPutAll: (herr referentAddress printStringRadix:16);	nextPutAll: ', environment = ';	nextPutAll: environ asString;	nextPutAll: ', size = '; print: environ size;	nextPutAll: ', #OCI_DEFAULT )'.	self class trace: self emitTrace].	(rtval == xif OCI_SUCCESS) ifFalse: 		[ 	| errs |			errs := self getErrors.			^self class unableToConnectToSQLenvironmentSignal raiseWith: errs errorString: errs first dbmsErrorString ].</body><body package="OracleEXDI">serverDetachExternal	| rtval xif hsrvr herr |		xif := self class xif.	hsrvr := self hsrvr.	herr := self herr.	[ "Begin unwind protection (1)"	rtval := xif OCIServerDetach: hsrvr 						    with: herr                                         with: xif OCI_DEFAULT.	(traceLevel &gt;= 1) ifTrue:	[(self traceStream) 	print: rtval; 	nextPutAll: ' = OCIServerDetach( hsrvr = ';	nextPutAll: ( hsrvr referentAddress printStringRadix:16);	nextPutAll: ', herr = ';	nextPutAll: ( herr referentAddress printStringRadix:16);	nextPutAll: ', OCI_DEFAULT )'.	self class trace: self emitTrace].	"End unwind protection (1)" ]		ensure:[ 	self unprotectedFreeHtxn.									self unprotectedFreeHsess.									self unprotectedFreeHsrvr.									self unprotectedFreeHsvcctx.									self unprotectedFreeHerr  ].</body><body package="OracleEXDI">sessionBeginExternal	"Establish a session for a user against a particular server. This call is required for the user to     	be able to execute any operation on the server."	| rtval xif hsvcctx hsess herr |		xif := self class xif.	herr := self herr.	hsvcctx := self hsvcctx.	hsess := self hsess.	rtval := xif OCISessionBegin: hsvcctx						     with: herr						     with: hsess						     with: self authenticationMode 						     with: (self useStatementCaching 	ifTrue: [xif OCI_STMT_CACHE] ifFalse: [xif OCI_DEFAULT]).	(traceLevel &gt;= 1) ifTrue:		[(self traceStream) 			print: rtval; 			nextPutAll: ' = OCISessionBegin( hsvcctx = ';			nextPutAll: (hsvcctx referentAddress printStringRadix:16);			nextPutAll: ', herr = '; 			nextPutAll: (herr referentAddress printStringRadix:16);			nextPutAll: ', hsess = ';			nextPutAll: (hsess referentAddress printStringRadix:16);			nextPutAll: ', credt =  '; print: self authenticationMode;			nextPutAll: ', mode = ';			nextPutAll: (self useStatementCaching ifTrue: ['OCI_STMT_CACHE'] ifFalse: ['OCI_DEFAULT']);			nextPutAll: ')'.		self class trace: self emitTrace].	(rtval == xif OCI_SUCCESS) ifFalse: 		[ 	| errs signal errorMessage |		  	errs := self getErrors.			errorMessage := errs first dbmsErrorString.			rtval == xif OCI_SUCCESS_WITH_INFO ifTrue: [ 				ExternalDatabaseNotification raiseRequestWith: errs errorString: errorMessage			] ifFalse: [ 				signal := self class perform: (self class signalMap							at: errs first dbmsErrorCode abs							ifAbsent: [ #unableToConnectToSQLenvironmentSignal ]).				^signal raiseWith: errs errorString: errorMessage			]		].</body><body package="OracleEXDI">sessionEndExternal	| rtval xif hsvcctx hsess herr |		xif := self class xif.	hsvcctx := self hsvcctx.	hsess := self hsess.	herr := self herr.	rtval := xif OCISessionEnd: hsvcctx 						   with: herr 			                     with: hsess	                                 with: xif OCI_DEFAULT.	(traceLevel &gt;= 1) ifTrue:	[(self traceStream) 	print: rtval; 	nextPutAll: ' = OCISessionEnd( hsvcctx = ';	nextPutAll: (hsvcctx  referentAddress printStringRadix:16);	nextPutAll: ', herr = ';	nextPutAll: (herr  referentAddress printStringRadix:16);	nextPutAll: ', hsess = ';	nextPutAll: (hsess  referentAddress printStringRadix:16);	nextPutAll: ', OCI_DEFAULT )'.	self class trace: self emitTrace].</body><body package="OracleEXDI">setAttributeExternal: attributePointer type: attributeType length: attributeLength descriptor: descriptor type: descriptorType	| xif rtval |	xif := self class xif.		rtval := xif OCIAttrSet: descriptor				    with:  (xif perform: descriptorType )				    with:  attributePointer				    with:  attributeLength				    with: (xif perform: attributeType )				    with: self herr.	(traceLevel &gt;= 3) ifTrue:	[ (self traceStream)	print: rtval;  nextPutAll: ' = OCIAttribSet( descriptor = ';	nextPutAll: (descriptor referentAddress printStringRadix: 16);	nextPutAll: ',  descriptorType = '; 	nextPutAll: descriptorType printString;	nextPutAll: ', attribute  = ';	nextPutAll: (attributePointer referentAddress printStringRadix: 16);	nextPutAll: ', attributeType  = ';      nextPutAll: attributeType printString;	nextPutAll: ', length  = '; print: attributeLength;	nextPutAll: ', herr = ';	nextPutAll: (self herr referentAddress printStringRadix: 16);	nextPutAll: ')'.	self class trace: self emitTrace ].	(rtval == xif OCI_SUCCESS) ifFalse: 		[ 	| errs |			errs := self getErrors.	        	^self class unableToQueryHandleInformationSignal raiseWith: errs errorString: errs first dbmsErrorString ]</body></methods><methods><class-id>Database.OracleConnection</class-id> <category>private-attribute accessing</category><body package="OracleEXDI">getAttribute: attributeType descriptor:  descriptor type: descriptorType 	| attribute getSelector sizeInBytes ub xif |	xif := self class xif.	((self attributeLengthPointer isNil) or: [ self attributeLengthPointer isValid not ]) ifTrue: [		self attributeLengthPointer: (xif ub4 perform: xif mallocSelector with: 1).		self attributeLengthPointer contents: 0.	].	((self attributePointer isNil) or: [ self attributePointer isValid not ]) ifTrue: [ | typePointerType |		typePointerType := CArrayType defaultPointer referentType: CIntegerType char; numElements: 512.		self attributePointer: (typePointerType perform: xif mallocSelector with: 1).	].	self getAttributeExternal: self attributePointer 					    type: attributeType 					  length: self attributeLengthPointer 				  descriptor: descriptor 					    type: descriptorType.	getSelector := AttributeTypeConversionMap at: attributeType 			ifAbsent: [ nil ].	(getSelector isNil) ifTrue: [  ^self class unsupportedAttributeGetSignal raise ].	ub := UninterpretedBytes new: 512.	sizeInBytes := self attributeLengthPointer contents.	getSelector == #copyCStringFromHeap: ifTrue: [ | stringPointer |		stringPointer := (CIntegerType char pointerType pointerType cast: self attributePointer) contents.		stringPointer copyAt: 0 to: ub size: sizeInBytes startingAt: 1.		attribute := ub perform: getSelector with: self encoding asUppercase asSymbol. 	] ifFalse: [ 		self attributePointer copyAt: 0 to: ub size: 4 startingAt: 1.		attribute := ub perform: getSelector with: 1.	].      ^attribute</body><body package="OracleEXDI">setAttribute: attribute type: attributeType descriptor: descriptor type: descriptorType	| attributeLength attributePointer |	[ "Begin unwind protection (1)"	( attribute isString ) ifTrue: [ | encodedAttribute |		encodedAttribute := attribute asByteArrayEncoding: self encoding.		attributePointer := encodedAttribute perform: self class xif copyToHeapSelector.		attributeLength := encodedAttribute size	] ifFalse: [ attributePointer := (attribute isKindOf: Number)					ifTrue: [ attribute perform: self class xif copyToHeapSelector ]					ifFalse: [ attribute "Attribute is Oracle Handle"].				 attributeLength := 0 ].	self setAttributeExternal: attributePointer  					    type: attributeType 					 length: attributeLength 				 descriptor: descriptor 					   type: descriptorType.	"End unwind protection (1)"] 		ensure: [ (attributePointer == nil or: [attributePointer == attribute]) ifFalse: [ attributePointer freePointer ] ]</body></methods><methods><class-id>Database.OracleConnection</class-id> <category>private-handles</category><body package="OracleEXDI">privateIsThreadedConnectionLoaded	^(Smalltalk at: #OracleThreadedConnection ifAbsent: []) notNil</body><body package="OracleEXDI">unprotectedAllocHenv		| xif henvPointerPointer rtval |	xif := self class xif. 	[ "Begin unwind protection (1)"	self unprotectedInitLibrary.							henvPointerPointer := xif OCIEnv pointerType perform: xif mallocSelector with: 1.	rtval := xif OCIEnvInit: henvPointerPointer with: xif OCI_DEFAULT with: 0 with: 0.	(traceLevel &gt;= 3) ifTrue:	[ (self traceStream)	print: rtval;  nextPutAll: ' = OCIEnvInit( *henv = ';	nextPutAll: (henvPointerPointer contents referentAddress printStringRadix: 16);	nextPutAll: ', OCI_DEFAULT, usermemsize = 0, userdata = 0)'.	self class trace: self emitTrace ].	(rtval == xif OCI_SUCCESS) ifFalse:		[ ^self class unableToInitializeInterfaceLibrarySignal raise ].	"Save environment handle"	self henv: henvPointerPointer contents.	"End unwind protection (1)." ]		ensure: [ henvPointerPointer == nil ifFalse: [ henvPointerPointer freePointer ] ]</body><body package="OracleEXDI">unprotectedAllocHenvWithNls		| xif henvPointerPointer rtval mode |	xif := self class xif. 	[ "Begin unwind protection (1)"	mode := (self isNonBlocking or: [self privateIsThreadedConnectionLoaded]) 				ifTrue: [xif OCI_THREADED]				ifFalse: [xif OCI_DEFAULT].							henvPointerPointer := xif OCIEnv pointerType perform: xif mallocSelector with: 1.	rtval := xif OCIEnvNlsCreate: henvPointerPointer 							with: mode 							with: 0 							with: 0 							with: 0 							with: 0 							with: 0 							with: 0 							with: self oracleEncodingId 							with: self oracleUnicodeEncodingId.	(traceLevel &gt;= 3) ifTrue:	[ (self traceStream)	print: rtval;  nextPutAll: ' = OCIEnvNlsCreate( *henv = ';	nextPutAll: (henvPointerPointer contents referentAddress printStringRadix: 16);	nextPutAll: 'mode = ';	nextPutAll: (self isNonBlocking 				ifTrue: [' OCI_DEFAULT']				ifFalse: [' OCI_THREADED']);	nextPutAll: ', ctxp = 0, malocfp = 0, ralocfp = 0, mfreefp = 0, xtramemsz = 0, usrmempp = 0, ';	nextPutAll: ', charset  = ';	nextPutAll: (self encoding printString);	nextPutAll: ', ncharset  = ';	nextPutAll: (unicodeEncoding printString);	nextPutAll: ')'.	self class trace: self emitTrace ].	(rtval == xif OCI_SUCCESS) ifFalse:		[ ^self class unableToInitializeInterfaceLibrarySignal raise ].	"Save environment handle"	self henv: henvPointerPointer contents.	self class libraryInitialized: true.	"End unwind protection (1)." ]		ensure: [ henvPointerPointer == nil ifFalse: [ henvPointerPointer freePointer ] ]</body><body package="OracleEXDI">unprotectedAllocHerr		| xif herrPointerPointer |	xif := self class xif.	["Begin unwind protection (1)"	herrPointerPointer := xif OCIError pointerType perform: xif mallocSelector with: 1.	self allocHandlePointerExternal: herrPointerPointer type: #OCI_HTYPE_ERROR.	self herrHolder value: herrPointerPointer contents.	"End unwind protection (1)"] 		ensure: [ herrPointerPointer == nil ifFalse:  [ herrPointerPointer freePointer ] ]</body><body package="OracleEXDI">unprotectedAllocHsess		| xif  hsessPointerPointer  |	xif := self class xif.	["Begin unwind protection (1)"	hsessPointerPointer := xif OCISession pointerType perform: xif mallocSelector with: 1.	self allocHandlePointerExternal: hsessPointerPointer type: #OCI_HTYPE_SESSION.	self hsessHolder value: hsessPointerPointer contents.	"End unwind protection (1)"] 		ensure: [ 	hsessPointerPointer == nil ifFalse: [ hsessPointerPointer freePointer ] ].</body><body package="OracleEXDI">unprotectedAllocHsrvr		| xif  hsrvrPointerPointer  |	xif := self class xif.	["Begin unwind protection (1)"	hsrvrPointerPointer := xif OCIServer pointerType perform: xif mallocSelector with: 1.	self allocHandlePointerExternal: hsrvrPointerPointer type: #OCI_HTYPE_SERVER.	self hsrvrHolder value: hsrvrPointerPointer contents.	"End unwind protection (1)"] 		ensure: [ 	hsrvrPointerPointer == nil ifFalse: [ hsrvrPointerPointer freePointer ] ].</body><body package="OracleEXDI">unprotectedAllocHsvcctx		| xif hsvcctxPointerPointer  |	xif := self class xif.	["Begin unwind protection (1)"	hsvcctxPointerPointer := xif OCISvcCtx pointerType perform: xif mallocSelector with: 1.	self allocHandlePointerExternal: hsvcctxPointerPointer type: #OCI_HTYPE_SVCCTX.	self hsvcctxHolder value: hsvcctxPointerPointer contents.	"End unwind protection (1)"] 		ensure: [ 	hsvcctxPointerPointer == nil ifFalse: [ hsvcctxPointerPointer freePointer ] ].</body><body package="OracleEXDI">unprotectedAllocHtxn		| xif  htxnPointerPointer  |	xif := self class xif.	["Begin unwind protection (1)"	htxnPointerPointer := xif OCITrans pointerType perform: xif mallocSelector with: 1.	self allocHandlePointerExternal: htxnPointerPointer type: #OCI_HTYPE_TRANS.	self htxnHolder value: htxnPointerPointer contents.	"End unwind protection (1)"] 		ensure: [ 	htxnPointerPointer == nil ifFalse: [ htxnPointerPointer freePointer ] ].</body><body package="OracleEXDI">unprotectedFreeHenv	 	self freeHandlePointerExternal:  self henv type: #OCI_HTYPE_ENV</body><body package="OracleEXDI">unprotectedFreeHerr	 	self freeHandlePointerExternal:  self herr type: #OCI_HTYPE_ERROR</body><body package="OracleEXDI">unprotectedFreeHsess	self freeHandlePointerExternal:  self hsess type: #OCI_HTYPE_SESSION.</body><body package="OracleEXDI">unprotectedFreeHsrvr	self freeHandlePointerExternal:  self hsrvr type: #OCI_HTYPE_SERVER.</body><body package="OracleEXDI">unprotectedFreeHsvcctx	self freeHandlePointerExternal:  self hsvcctx type: #OCI_HTYPE_SVCCTX</body><body package="OracleEXDI">unprotectedFreeHtxn	self freeHandlePointerExternal:  self htxn type: #OCI_HTYPE_TRANS.</body><body package="OracleEXDI">unprotectedInitLibrary	| xif rtval voidPointerToNil mode |	xif := self class xif.	self class libraryInitialized ifTrue: [^self].	mode := (self isNonBlocking or: [self privateIsThreadedConnectionLoaded]) 				ifTrue: [xif OCI_THREADED]				ifFalse: [xif OCI_DEFAULT].		voidPointerToNil := CVoidType void pointerType cast: nil.	rtval := xif 				OCIInitialize: mode				with: voidPointerToNil				with: 0				with: 0				with: 0.	"Issue trace results"	traceLevel &gt;= 3 		ifTrue: 			[(self traceStream)				print: rtval;				nextPutAll: ' = OCIInitialize(mode = ';				nextPutAll: (self isNonBlocking 							ifTrue: [' OCI_DEFAULT']							ifFalse: [' OCI_THREADED']);				nextPutAll: ', usermemsize = 0, userdata = 0)'.			self class trace: self emitTrace].	"Follow-up check that library is initialized for access."	rtval == xif OCI_SUCCESS ifFalse: [ | errs |		errs := self getErrors.		rtval == 1804 ifTrue: [			ExternalDatabaseNotification raiseRequestErrorString: (#errTimezoneInitialization &lt;&lt; #oracleDB &gt;&gt; 'ORA-01804: failure to initialize timezone information') asString.		] ifFalse: [			^self class externalDatabaseLibraryInaccessibleSignal raiseWith: errs errorString: errs first dbmsErrorString.		] 	].	self class libraryInitialized: true</body></methods><methods><class-id>Database.OracleConnection</class-id> <category>private-error accessing</category><body package="OracleEXDI">getConnectionErrors	"Return a collection of OracleOCIError(s) associated with the	connection handle."	| errors err errCount  |	errors := OrderedCollection new.	errCount := 1.	[(err := self getErrorsExternal: self herr type: #OCI_HTYPE_ERROR at: errCount ) notNil]		whileTrue: [	errors add: err.					errCount := errCount + 1 ].	^errors</body><body package="OracleEXDI">getEnvironmentErrors	"Return a collection of OracleOCIError(s) associated with the environment 	handle."	| errors err errCount  |	errors := OrderedCollection new.	errCount := 1.	[(err := self getErrorsExternal: self henv type: #OCI_HTYPE_ENV at: errCount ) notNil]		whileTrue: [ errors add: err.				     errCount := errCount + 1 ].	^errors</body></methods><methods><class-id>Database.OracleConnection</class-id> <category>data processing</category><body package="OracleEXDI">multiStatementTransactions	"Take the receiver's connection out of auto-commit mode for transaction behavior."	executionMode := #OCI_DEFAULT</body><body package="OracleEXDI">singleStatementTransactions	"Put the OCI into autocommit mode to give the effect of single-statement transactions."	executionMode := #OCI_COMMIT_ON_SUCCESS</body></methods><methods><class-id>Database.OracleConnection</class-id> <category>private-encoding</category><body package="OracleEXDI">getEncoding	"Answer the character set name from the encoding map dictionary or nil"	| charSetName charSetId |	self hasLocaleSupport ifTrue: [		self class libraryInitialized ifFalse: [ 			self supportEnvNlsCreate ifTrue: [				self unprotectedAllocHenvWithNls			] ifFalse: [				self unprotectedAllocHenv			]. 		].		self oracleEncodingId = 0 ifTrue: [			charSetId := self getNlsCharSetId.		] ifFalse: [			charSetId := self oracleEncodingId.		].		charSetName := self getNlsCharSetNameFromId: charSetId.		(charSetName isEmpty or: [charSetName = 'NA']) ifTrue: [^#default].		^self class mapEncodings		at: charSetName		ifAbsent: [self error: (#errColumnEncoding &lt;&lt; #oracleDB &gt;&gt; 'Column encoding not yet recognized')]	] ifFalse: [ ^nil ]</body><body package="OracleEXDI">getNlsCharSetId	"Answer the character set ID from NLS_LANG."	^self getNlsCharSetIdFor: self class xif OCI_NLS_CHARSET_ID</body><body package="OracleEXDI">getNlsCharSetIdFor: anIntegerForCharSetOrNCharset	"Answer the character set ID from NLS_LANG."	| xif bufPointer rtval sizePointer ub size |	xif := self class xif.	[ "Begin unwind protection (1)"  	bufPointer := CIntegerType long perform: xif mallocSelector with: 1.	bufPointer contents: 0.	sizePointer := CIntegerType long perform: xif mallocSelector with: 1.	sizePointer contents: 0.	rtval := xif OCINlsEnvironmentVariableGet: bufPointer 			with: xif OCI_NLS_MAXBUFSZ 			with: anIntegerForCharSetOrNCharset			with: 0			with: sizePointer.	(traceLevel &gt;= 1) ifTrue:		[(self traceStream) 			print: rtval; 			nextPutAll: ' = OCINlsEnvironmentVariableGet( val = ';			nextPutAll: (bufPointer referentAddress printStringRadix:16);			nextPutAll: ', OCI_NLS_MAXBUFSZ, ';			nextPutAll: anIntegerForCharSetOrNCharset printString;			nextPutAll: ', 0';			nextPutAll: ' , rsize = ';			nextPutAll: (sizePointer referentAddress printStringRadix:16);			nextPutAll: ' )'.		self class trace: self emitTrace].	(rtval == xif OCI_SUCCESS) ifTrue: [		size := sizePointer contents.		ub := UninterpretedBytes new: size. 		bufPointer copyAt: 0 to: ub size: size startingAt: 1	].     "End unwind protection (1)"] 		ensure: [ bufPointer == nil  ifFalse: [ bufPointer freePointer ].				sizePointer == nil  ifFalse: [ sizePointer freePointer ] ].	(rtval == xif OCI_SUCCESS) ifFalse: 		[ | errs |		errs := self getErrors.	        ^self class unableToQueryDriverInformationSignal raiseWith: errs errorString: errs first dbmsErrorString  ].	^ub perform: #shortAt: with: 1.</body><body package="OracleEXDI">getNlsCharSetNameFromId: charSetId	"Answer the Oracle character set name from the specified character set ID."	| xif bufPointer bufSize rtval envPointer ub |	xif := self class xif.	bufSize := xif OCI_NLS_MAXBUFSZ.	[ "Begin unwind protection (1)"  	bufPointer := xif OraText perform: xif mallocSelector with: bufSize + 1.	(envPointer := self henv) isNil ifTrue: [			self supportEnvNlsCreate ifTrue: [			self unprotectedAllocHenvWithNls		] ifFalse: [			self unprotectedAllocHenv		]. 		envPointer := self henv 	].	rtval := xif OCINlsCharSetIdToName: envPointer with: bufPointer with: bufSize  with: charSetId.	(traceLevel &gt;= 1) ifTrue:		[(self traceStream) 			print: rtval; 			nextPutAll: ' = OCINlsCharSetIdToName( hndl = ';			nextPutAll: (envPointer referentAddress printStringRadix:16);			nextPutAll: ' , buf = ';			nextPutAll: (bufPointer referentAddress printStringRadix:16);			nextPutAll: ', buflen = '; print: bufSize;				nextPutAll: ', id = '; print: charSetId;			nextPutAll: ' )'.						self class trace: self emitTrace].	(rtval == xif OCI_SUCCESS) ifTrue: [		ub := UninterpretedBytes new: bufSize. 		bufPointer copyAt: 0 to: ub size: bufSize startingAt: 1.	].      "End unwind protection (1)"] 		ensure: [ bufPointer == nil  ifFalse: [ bufPointer freePointer ] ].	(rtval == xif OCI_SUCCESS) ifFalse: 		[ | errs |		errs := self getErrors.	        ^self class unableToQueryDriverInformationSignal raiseWith: errs errorString: errs first dbmsErrorString  ].	encoding isNil ifTrue: [		^ub stringAt: 1	] ifFalse: [		^ub copyCStringFromHeap: self encoding asUppercase asSymbol.	]</body><body package="OracleEXDI">getNlsNCharSetId	"Answer the character set ID from NLS_NCHAR."	^self getNlsCharSetIdFor: self class xif OCI_NLS_NCHARSET_ID</body><body package="OracleEXDI">getUnicodeEncoding	"Answer the character set name from the encoding map dictionary or nil"	| charSetName charSetId |	self hasLocaleSupport ifTrue: [		self class libraryInitialized ifFalse: [ 			self supportEnvNlsCreate ifTrue: [				self unprotectedAllocHenvWithNls			] ifFalse: [				self unprotectedAllocHenv			]. 		].		self oracleUnicodeEncodingId = 0 ifTrue: [			charSetId := self getNlsNCharSetId.		] ifFalse: [			charSetId := self oracleUnicodeEncodingId.		].		charSetName := self getNlsCharSetNameFromId: charSetId.		(charSetName isEmpty or: [charSetName = 'NA']) ifTrue: [^#default].		^self class mapEncodings		at: charSetName		ifAbsent: [self error: (#errColumnEncoding &lt;&lt; #oracleDB &gt;&gt; 'Column encoding not yet recognized')]	] ifFalse: [ ^#utf_16]</body></methods><methods><class-id>Database.OracleConnection class</class-id> <category>class initialization</category><body package="OracleEXDI">initialize	"OracleConnection initialize"	self libraryInitialized: false.	self xif: nil.	self initializeExternalInterfaceMap.	self initializeAttributeTypeConversionMap.	self initializeSignalMap.	self initializeEncoderMap.	self initRegistry.</body><body package="OracleEXDI">initializeAttributeTypeConversionMap	"OracleConnection initializeAttributeTypeConversionMap."	(AttributeTypeConversionMap := IdentityDictionary new)	    	add: #OCI_ATTR_FUNCODE-&gt;#unsignedLongAt:;		"Environment Handle Attributes:"   		add: #OCI_ATTR_ENV-&gt;#longAt:;	   	add: #OCI_ATTR_CACHE_MAX_SIZE-&gt;#unsignedLongAt:;	   	add: #OCI_ATTR_CACHE_OPT_SIZE-&gt;#unsignedLongAt:;	   	add: #OCI_ATTR_OBJECT-&gt;#unsignedShortAt:;	   	add: #OCI_ATTR_PINOPTION-&gt;#unsignedLongAt:;	   	add: #OCI_ATTR_ALLOC_DURATION-&gt;#longAt:;	   	add: #OCI_ATTR_PIN_DURATION-&gt;#longAt:;		"Service Context Handle Attributes:"	   	add: #OCI_ATTR_SQLCODE-&gt;#unsignedLongAt:;		add: #OCI_ATTR_SERVER-&gt;#newPointerToAddressAt:;	   	add: #OCI_ATTR_SESSION-&gt;#newPointerToAddressAt:;	   	add: #OCI_ATTR_TRANS-&gt;#newPointerToAddressAt:;		add: #OCI_ATTR_STMTCACHESIZE-&gt;#unsignedLongAt:;		"Sever Handle Attributes:"	   	add: #OCI_ATTR_SERVER_DBNAME-&gt;#copyCStringFromHeap:;	   	add: #OCI_ATTR_CLIENT_DBNAME-&gt;#copyCStringFromHeap:;		"User Session Handle Attributes:"	   	add: #OCI_ATTR_USERNAME-&gt;#copyCStringFromHeap:;	   	add: #OCI_ATTR_PASSWORD-&gt;#copyCStringFromHeap:;		"Transaction Handle Attributes:"	   	add: #OCI_ATTR_INAME-&gt;#copyCStringFromHeap:;	   	add: #OCI_ATTR_XNAME-&gt;#copyCStringFromHeap:;	   	add: #OCI_ATTR_XID-&gt;#unsignedLongAt:;	   	add: #OCI_ATTR_TRANS_LOCK-&gt;#unsignedLongAt:;	   	add: #OCI_ATTR_TRANS_NAME-&gt;#copyCStringFromHeap:;		"Statement Handle Attributes:"	   	add: #OCI_ATTR_ROW_COUNT-&gt;#unsignedLongAt:;	   	add: #OCI_ATTR_ROWS_FETCHED -&gt;#unsignedLongAt:;	   	add: #OCI_ATTR_SQLFNCODE-&gt;#unsignedShortAt:;	   	add: #OCI_ATTR_ROWID-&gt;#longAt:;		add: #OCI_ATTR_CURRENT_POSITION-&gt;#longAt:;	   	add: #OCI_ATTR_PREFETCH_ROWS-&gt;#unsignedLongAt:;	   	add: #OCI_ATTR_STMT_TYPE-&gt;#unsignedShortAt:;	   	add: #OCI_ATTR_PREFETCH_MEMORY-&gt;#unsignedLongAt:;		add: #OCI_ATTR_PARSE_ERROR_OFFSET-&gt;#unsignedShortAt:;		"Type Attributes"	   	add: #OCI_ATTR_REF_TDO-&gt;#newPointerToAddressAt:;	   	add: #OCI_ATTR_COLLECTION_TYPECODE -&gt;#longAt:;	   	add: #OCI_ATTR_VERSION -&gt;#copyCStringFromHeap:;	   	add: #OCI_ATTR_COLLECTION_ELEMENT -&gt;#newPointerToAddressAt:;	   	add: #OCI_ATTR_NUM_TYPE_ATTRS  -&gt;#unsignedShortAt:;	   	add: #OCI_ATTR_LIST_TYPE_ATTRS  -&gt;#newPointerToAddressAt:;	   	add: #OCI_ATTR_NUM_TYPE_METHODS-&gt;#unsignedLongAt:;	   	add: #OCI_ATTR_LIST_TYPE_METHODS -&gt;#longAt:;	   	add: #OCI_ATTR_MAP_METHOD -&gt;#longAt:;	   	add: #OCI_ATTR_ORDER_METHOD-&gt;#longAt:;				"Parameter Attributes"		add: #OCI_ATTR_PTYPE-&gt;#byteAt:;	   	add: #OCI_ATTR_TIMESTAMP-&gt;#copyCStringFromHeap:;	   	add: #OCI_ATTR_NUM_ATTRS-&gt;#unsignedShortAt:;	   	add: #OCI_ATTR_NUM_PARAMS-&gt;#unsignedShortAt:;	   	add: #OCI_ATTR_PARAM_COUNT-&gt;#unsignedLongAt:;	   	add: #OCI_DTYPE_PARAM-&gt;#newPointerToAddressAt:;	   	add: #OCI_ATTR_PARAM-&gt;#newPointerToAddressAt:;		"Type Attribute Attributes"	   	add: #OCI_ATTR_DATA_SIZE-&gt;#unsignedShortAt:;	   	add: #OCI_ATTR_DATA_TYPE-&gt;#unsignedShortAt:;	   	add: #OCI_ATTR_TYPECODE-&gt;#unsignedShortAt:;	   	add: #OCI_ATTR_NCHAR-&gt;#unsignedShortAt:;		"For named collections:"		add: #OCI_ATTR_COLLECTION_TYPECODE	-&gt;#unsignedShortAt:;  		add: #OCI_ATTR_NUM_ELEMS-&gt;#unsignedShortAt:;				"Type Attribute Descriptor:"	   	add: #OCI_ATTR_NAME-&gt;#copyCStringFromHeap:;	   	add: #OCI_ATTR_PRECISION-&gt;#byteAt:;	   	add: #OCI_ATTR_SCALE-&gt;#signedByteAt:;	   	add: #OCI_ATTR_IS_NULL-&gt;#byteAt:;	   	add: #OCI_ATTR_TYPE_NAME-&gt;#copyCStringFromHeap:;	   	add: #OCI_ATTR_SCHEMA_NAME-&gt;#copyCStringFromHeap:;	   	add: #OCI_ATTR_REF_TDO-&gt;#newPointerToAddressAt:;	   	add: #OCI_ATTR_CHARSET_ID -&gt;#unsignedShortAt:;	   	add: #OCI_ATTR_CHARSET_FORM-&gt;#byteAt:</body><body package="OracleEXDI">initializeEncoderMap	"Initialize the Encoder Map"	EncoderMap := Dictionary new.	EncoderMap		at: 'US7ASCII'			put: #ASCII;		at: 'JA16EUC'			put: #JapaneseEUC;		at: 'JA16SJIS'			put: #ShiftJIS;		at: 'WE8ISO8859P1'		put: #ISO8859_1;		at: 'EE8ISO8859P2'		put: #ISO8859_2;		at: 'SE8ISO8859P3'		put: #ISO8859_3;		at: 'NEE8ISO8859P4'	put: #ISO8859_4;		at: 'CL8ISO8859P5'		put: #ISO8859_5;		at: 'AR8ISO8859P6'		put: #ISO8859_6;		at: 'EL8ISO8859P7'		put: #ISO8859_7;		at: 'IW8ISO8859P8'		put: #ISO8859_8;		at: 'WE8ISO8859P9'		put: #ISO8859_9;		at: 'NE8ISO8859P10'	put: #ISO8859_10;		at: 'WE8ISO8859P15'	put: #ISO8859_15;		at: 'WE8ROMAN8'		put: #hp_roman8;		at: 'US8PC437'			put: #ibm437;		at: 'EL8PC737'			put: #ibm737;		at: 'BLT8PC775'			put: #ibm775;		at: 'WE8PC850'			put: #ibm850;		at: 'EE8PC852'			put: #ibm852;		at: 'RU8PC855'			put: #ibm855;		at: 'TR8PC857'			put: #ibm857;		at: 'WE8PC860'			put: #ibm860;		at: 'IS8PC861'			put: #ibm861;		at: 'IW8PC1507'			put: #ibm862;		at: 'CDN8PC863'		put: #ibm863;		at: 'N8PC865'			put: #ibm865;		at: 'RU8PC866'			put: #ibm866;		at: 'EL8PC869'			put: #ibm869;		at: 'AR8ARABICMAC'	put: #macarabic;		at: 'EE8MACCE'			put: #maccenteuro;		at: 'EE8MACCROATIAN'	put: #maccroatian;		at: 'WE8MACROMAN8'	put: #macroman;		at: 'EL8MACGREEK'	put: #macgreek;		at: 'IS8MACICELANDIC'	put: #maciceland;		at: 'CL8MACCYRILLIC'	put: #maccyrillic;		at: 'IW8MACHEBREW'	put: #machebrew;		at: 'TR8MACTURKISH'	put: #macturkish;		at: 'EE8MSWIN1250'	put: #'windows-1250';		at: 'CL8MSWIN1251'		put: #'windows-1251';		at: 'WE8MSWIN1252'	put: #'windows-1252';		at: 'EL8MSWIN1253'		put: #'windows-1253';		at: 'TR8MSWIN1254'	 	put: #'windows-1254';		at: 'IW8MSWIN1255'		put: #'windows-1255';		at: 'AR8MSWIN1256'	put: #'windows-1256';		at: 'BLT8MSWIN1257'	put: #'windows-1257';		at: 'VN8MSWIN1258'	put: #'windows-1258';		at: 'UTF8'				put: #utf_8;		at: 'UTF16'				put: #utf_16;		at: 'AL16UTF16' 		put: #utf_16;		at: 'AL32UTF8' 			put: #utf_8;		at: 'AL24UTFFSS'		put: #utf_8.</body><body package="OracleEXDI">initializeExternalInterface	"Reset Interface with the right interface class based on the current platform."	| xifClass |	xifClass := self interfaceClass.	self xif: (xifClass notNil			ifTrue: [xifClass new]			ifFalse: [nil]).	self privateXif isNil ifTrue: 		[^ExternalDatabaseNotification raiseErrorString: (#unsupportedPlatform &lt;&lt; #oracleDB &gt;&gt; 'Oracle Connect is not supported on this platform.') expandMacros].</body><body package="OracleEXDI">initializeExternalInterfaceMap	"self initializeExternalInterfaceMap"	xifMap := IdentityDictionary new.	self privateNonThreadedInterfaces do: [:each |		xifMap at: (each platformSymbol) put: each name]</body><body package="OracleEXDI">initializeSignalMap	"OracleConnection initializeSignalMap"	signalMap := IdentityDictionary new.	signalMap at: 903 put: #invalidTableNameSignal.	signalMap at: 942 put: #invalidTableNameSignal.	signalMap at: 1408 put: #duplicateIndexesErrorSignal.	signalMap at: 1 put: #indexConflictSignal.	signalMap at: 54 put: #objectLockedSignal.	signalMap at: 1004 put: #authenticationFailureSignal.	signalMap at: 1017 put: #authenticationFailureSignal.	signalMap at: 1321 put: #couldNotResolveServiceNameSignal.	signalMap at: 12154 put: #couldNotResolveServiceNameSignal.	signalMap at: 2292 put: #rowIsReferencedErrorSignal.	signalMap at: 24344 put: #successWithInformationSignal.</body><body package="OracleEXDI">privateNonThreadedInterfaces	"Return collection of loaded unthreaded interfaces	note - this method depends on the naming convention	that threaded interfaces have the word Threaded in them,	and non-threaded do not--	e.g. OracleThreadedNTInterface"	^OracleInterface withAllSubclasses 		select: [:ea |			(ea name indexOfSubCollection: 'Threaded' startingAt: 1) == 0]</body></methods><methods><class-id>Database.OracleConnection class</class-id> <category>accessing</category><body package="OracleEXDI">is64Bit	"Answer true if we are on a 64-bit platform."	^ObjectMemory is64Bit</body><body package="OracleEXDI">kind	"Answer a symbol representing the type of DBMS the receiver provides services for."	^#'Oracle 8'</body><body package="OracleEXDI"> libraryInitialized	 ^libraryInitialized.</body><body package="OracleEXDI"> libraryInitialized: aBoolean	 libraryInitialized := aBoolean.</body><body package="OracleEXDI">mapEncodings	^EncoderMap</body><body package="OracleEXDI">ociClientMajorVersion	| clientVersion |		(clientVersion := self ociClientVersion)	notNil ifTrue: [			^clientVersion at: 'OCI_MAJOR_VERSION'		].		^clientVersion</body><body package="OracleEXDI">ociClientMinorVersion	| clientVersion |		(clientVersion := self ociClientVersion)	notNil ifTrue: [			^clientVersion at: 'OCI_MINOR_VERSION'		].		^clientVersion</body><body package="OracleEXDI">ociClientPatchNum	| clientVersion |		(clientVersion := self ociClientVersion)	notNil ifTrue: [			^clientVersion at:  'OCI_PATCH_NUM'			].		^clientVersion</body><body package="OracleEXDI">ociClientPortUpdateNum	| clientVersion |		(clientVersion := self ociClientVersion)	notNil ifTrue: [			^clientVersion at:  'OCI_PORT_UPDATE_NUM'		].		^clientVersion</body><body package="OracleEXDI">ociClientUpdateNum	| clientVersion |		(clientVersion := self ociClientVersion)	notNil ifTrue: [			^clientVersion at:  'OCI_UPDATE_NUM'		].		^clientVersion</body><body package="OracleEXDI">ociClientVersion	OCIClientVersion isNil ifTrue: [		OCIClientVersion := self getOCIClientVersion 	].	^OCIClientVersion</body><body package="OracleEXDI">version	^(#relationalVersion &lt;&lt; #oracleDB &gt;&gt; 'Oracle Database Interface.') asString</body></methods><methods><class-id>Database.OracleConnection class</class-id> <category>activation</category><body package="OracleEXDI">pause	^self quiesce</body><body package="OracleEXDI">resume	^self activate</body></methods><methods><class-id>Database.OracleConnection class</class-id> <category>signal constants</category><body package="OracleEXDI">inconsistentDataTypesInArrayBindingSignal	"Indicate that inconsistent data types in binding array"	^InconsistentDataTypesInArrayBinding.</body><body package="OracleEXDI">invalidAttributeTypeSignal	"Invalid attribute type."	^InvalidAttributeType</body><body package="OracleEXDI">statementCachingNotSupportedSignal	^StatementCachingNotSupported</body><body package="OracleEXDI">successWithInformationSignal	"Answer the signal to indicate that the action is successful but with a warning."	^SuccessWithInformation.</body><body package="OracleEXDI">unableToAllocateDescriptorSignal	^UnableToAllocateDescriptor</body><body package="OracleEXDI">unableToAllocateResourceHandleSignal	"A handle could not be allocated."	^UnableToAllocateResourceHandle</body><body package="OracleEXDI">unableToAllocateResourceSignal	"A resource could not be allocated."	^UnableToAllocateResource</body><body package="OracleEXDI">unableToAssignLobLocatorSignal	^UnableToAssignLobLocator</body><body package="OracleEXDI">unableToConstructTimestampSignal	^UnableToConstructTimestamp</body><body package="OracleEXDI">unableToDescribeSchemaObjectSignal	"Unable to describe schema object."	^UnableToDescribeSchemaObject</body><body package="OracleEXDI">unableToFreeDescriptorSignal	^UnableToFreeDescriptor</body><body package="OracleEXDI">unableToGetLobChunkSizeSignal	^UnableToGetLobChunkSize</body><body package="OracleEXDI">unableToGetLobLengthSignal	^UnableToGetLobLength</body><body package="OracleEXDI">unableToGetStatementCacheSizeSignal	^UnableToGetStatementCacheSize</body><body package="OracleEXDI">unableToGetTimestampDateSignal	^UnableToGetTimestampDate</body><body package="OracleEXDI">unableToGetTimestampTimeSignal	^UnableToGetTimestampTime</body><body package="OracleEXDI">unableToInitializeEnvironmentHandleSignal	"Indicate that the attempted initialization of the environment handle has failed."	^UnableToInitializeEnvironmentHandle</body><body package="OracleEXDI">unableToInitializeInterfaceLibrarySignal	"Indicate that the attempted initialization of the interface library has failed."	^UnableToInitializeInterfaceLibrary</body><body package="OracleEXDI">unableToLockObjectReferenceSignal	"Unable to lock object reference."	^UnableToLockObjectReference</body><body package="OracleEXDI">unableToModifyObjectInfoSignal	"Unable to modify object information."	^UnableToModifyObjectInfo</body><body package="OracleEXDI">unableToReadLobDataSignal	^UnableToReadLobData</body><body package="OracleEXDI">unableToReleaseExternalResourceSignal	"Unable to free an external resource."	^UnableToReleaseExternalResource</body><body package="OracleEXDI">unableToReleaseStatementSignal	"Unable to release an SQL statement."	^UnableToReleaseStatement</body><body package="OracleEXDI">unableToRetrieveDescriptorInfoSignal	"Unable to retrieve descriptor information."	^UnableToRetrieveDescriptorInfo</body><body package="OracleEXDI">unableToSetStatementCacheSizeSignal	^UnableToSetStatementCacheSize</body><body package="OracleEXDI">unableToTrimLobDataSignal	^UnableToTrimLobData</body><body package="OracleEXDI">unableToUnlockObjectReferenceSignal	"Unable to unlock object reference."	^UnableToUnlockObjectReference</body><body package="OracleEXDI">unableToWriteLobDataSignal	^UnableToWriteLobData</body><body package="OracleEXDI">unsupportedAttributeGetSignal	^UnsupportedAttributeGet</body><body package="OracleEXDI">unsupportedTransactionModeSignal	"Answer the signal used to indicate that that an attempt was made to set an unsupported transaction mode."	^UnsupportedTransactionMode</body></methods><methods><class-id>Database.OracleConnection class</class-id> <category>private-accessing</category><body package="OracleEXDI">bufferClass	"Answer the buffer class for connections/sessions"	^OracleBuffer</body><body package="OracleEXDI">columnDescriptionClass	"Answer the class to use for column description objects associated with receiver."	^OracleColumnDescription</body><body package="OracleEXDI">errorClass	"Answer the error class for connections and sessions"		^OracleError</body><body package="OracleEXDI">getOCIClientVersion	"Returns OCI Client Version as an IdentityDictionary."	| major_versionp minor_versionp update_nump patch_nump port_update_nump rtval ociClientVersion |	self supportGetClientVersion ifFalse: [ ^nil ].	xif := self xif.	[ "Begin unwind protection (1)"  		major_versionp := xif sword perform: xif mallocSelector with: 1.		minor_versionp := xif sword perform: xif mallocSelector with: 1.		update_nump := xif sword perform: xif mallocSelector with: 1.		patch_nump := xif sword perform: xif mallocSelector with: 1.		port_update_nump := xif sword perform: xif mallocSelector with: 1.		rtval := xif OCIClientVersion: major_versionp			 		with: minor_versionp					with: update_nump 					with: patch_nump 					with: port_update_nump.		ociClientVersion := Dictionary new.		ociClientVersion 					at: 'OCI_MAJOR_VERSION'			put: major_versionp contents;			at: 'OCI_MINOR_VERSION'			put: minor_versionp contents;			at: 'OCI_UPDATE_NUM'	 			put: update_nump contents;			at: 'OCI_PATCH_NUM'					put: patch_nump contents;			at: 'OCI_PORT_UPDATE_NUM'		put: port_update_nump contents.     "End unwind protection (1)"] 		ensure: [ major_versionp == nil  ifFalse: [ major_versionp freePointer ].				minor_versionp == nil  ifFalse: [ minor_versionp freePointer ].								update_nump == nil  ifFalse: [ update_nump freePointer ].				patch_nump == nil  ifFalse: [ patch_nump freePointer ].				port_update_nump == nil  ifFalse: [ port_update_nump freePointer ]  ].	^ociClientVersion</body><body package="OracleEXDI">interfaceClass	"Answer the correct interface class"	| interfaceClassName |	interfaceClassName := xifMap at: self platformType ifAbsent: [nil].	^interfaceClassName notNil		ifTrue: [self environment at: interfaceClassName ifAbsent: [nil]]		ifFalse: [nil]</body><body package="OracleEXDI">privateXif	"Answer the xif class instVar without attempting to initialize"	^xif</body><body package="OracleEXDI">sessionClass	"Answer the class to use for session objects associated with receiver."	^OracleSession</body><body package="OracleEXDI">signalMap	"Answer the signal map dictionary"	^signalMap</body><body package="OracleEXDI">transactionClass	"Answer the class to use for transaction objects associated with receiver."	^OracleTransaction</body><body package="OracleEXDI">xif	"Answer the ExternalInterface subclass instance to use."	xif isNil ifTrue: [  self initializeExternalInterfaceMap.					self initializeExternalInterface].	^xif</body></methods><methods><class-id>Database.OracleConnection class</class-id> <category>private-activation</category><body package="OracleEXDI">install	"This method can be inherrited, and will simply pass the install 	directive down the chain for those subclasses that need it."	self subclasses do: [:each | each install].	"Execute initialization code just once, here."	self == OracleConnection ifTrue: [self bufferClass install].	TraceLevel &gt;= 1 ifTrue: [self trace: nil].	self libraryInitialized: false.	self xif: nil.	self returnFromSnapshot</body></methods><methods><class-id>Database.OracleConnection class</class-id> <category>private-registry</category><body package="OracleEXDI">registry	^RegisteredOracleConnections</body><body package="OracleEXDI">registry: aCollection	RegisteredOracleConnections := aCollection</body></methods><methods><class-id>Database.OracleConnection class</class-id> <category>testing</category><body package="OracleEXDI">isThreaded		^false</body><body package="OracleEXDI">supportGetClientVersion	"Answer true is the loaded OCI supports getting OCI Client Version."	^self supportMethod: #OCIClientVersion:with:with:with:with:.</body></methods><methods><class-id>Database.OracleConnection class</class-id> <category>parcel load/unload/save</category><body package="OracleEXDI">postLoadActionFor: aParcel	"A Parcel's post-load action must be a class method taking one	 argument, the Parcel being loaded.  Fill-out this template, and accept.	 Note that you can give the method whatever selector you want.	 You don't have to stay with postLoadActionFrom:.	 Note that all loaded classes are sent the message postLoad: after	 loading.  The default implementation, ClassDescription&gt;postLoad:	 runs the class's initialize method if it has one.  One may override	 this method to add additional loading behavior.  See also	 ClassDescription&gt;preSave: which is intended to be used along	 with ClassDescription&gt;postLoad: for managing class loading.	 The post-load action can then ignore class initialization and can	 instead concentrate on tasks such as opening windows, etc."	"If there is no default Database Connect, make this the default."	ExternalDatabaseConnection defaultConnection isNil ifTrue:		[ ExternalDatabaseConnection defaultConnection: #'Database.OracleConnection' ].</body></methods><methods><class-id>Database.UnableToAllocateResourceHandle</class-id> <category>printing</category><body package="OracleEXDI">defaultMessageText	^(#errAllocateResourceHandle &lt;&lt; #oracleDB &gt;&gt; 'Unable to allocate a resource handle.') asString</body></methods><methods><class-id>Database.OracleInterface</class-id> <category>structs</category><body package="OracleEXDI">__OCIBind	&lt;C: struct __OCIBind&gt;</body><body package="OracleEXDI">__OCIDateTime	&lt;C: struct __OCIDateTime&gt;</body><body package="OracleEXDI">__OCIDefine	&lt;C: struct __OCIDefine&gt;</body><body package="OracleEXDI">__OCIDescribe	&lt;C: struct __OCIDescribe&gt;</body><body package="OracleEXDI">__OCIEnv	&lt;C: struct __OCIEnv&gt;</body><body package="OracleEXDI">__OCIError	&lt;C: struct __OCIError&gt;</body><body package="OracleEXDI">__OCILobLocator	&lt;C: struct __OCILobLocator&gt;</body><body package="OracleEXDI">__OCIParam	&lt;C: struct __OCIParam&gt;</body><body package="OracleEXDI">__OCIServer	&lt;C: struct __OCIServer&gt;</body><body package="OracleEXDI">__OCISession	&lt;C: struct __OCISession&gt;</body><body package="OracleEXDI">__OCISnapshot	&lt;C: struct __OCISnapshot&gt;</body><body package="OracleEXDI">__OCIStmt	&lt;C: struct __OCIStmt&gt;</body><body package="OracleEXDI">__OCISvcCtx	&lt;C: struct __OCISvcCtx&gt;</body><body package="OracleEXDI">__OCITrans	&lt;C: struct __OCITrans&gt;</body></methods><methods><class-id>Database.OracleInterface</class-id> <category>types</category><body package="OracleEXDI">dvoid	&lt;C: typedef void * dvoid&gt;</body><body package="OracleEXDI">OCIBind	&lt;C: typedef struct __OCIBind OCIBind&gt;</body><body package="OracleEXDI">OCIDateTime	&lt;C: typedef struct __OCIDateTime OCIDateTime&gt;</body><body package="OracleEXDI">OCIDefine	&lt;C: typedef struct __OCIDefine OCIDefine&gt;</body><body package="OracleEXDI">OCIDescribe	&lt;C: typedef struct __OCIDescribe OCIDescribe&gt;</body><body package="OracleEXDI">OCIEnv	&lt;C: typedef struct __OCIEnv OCIEnv&gt;</body><body package="OracleEXDI">OCIError	&lt;C: typedef struct __OCIError OCIError&gt;</body><body package="OracleEXDI">OCILobLength	&lt;C: typedef ubig_ora OCILobLength&gt;</body><body package="OracleEXDI">OCILobLocator	&lt;C: typedef struct __OCILobLocator OCILobLocator&gt;</body><body package="OracleEXDI">OCILobMode	&lt;C: typedef enum __OCILobMode OCILobMode&gt;</body><body package="OracleEXDI">OCILobOffset	&lt;C: typedef ubig_ora OCILobOffset&gt;</body><body package="OracleEXDI">OCIParam	&lt;C: typedef struct __OCIParam OCIParam&gt;</body><body package="OracleEXDI">OCIServer	&lt;C: typedef struct __OCIServer OCIServer&gt;</body><body package="OracleEXDI">OCISession	&lt;C: typedef struct __OCISession OCISession&gt;</body><body package="OracleEXDI">OCISnapshot	&lt;C: typedef struct __OCISnapshot OCISnapshot&gt;</body><body package="OracleEXDI">OCIStmt	&lt;C: typedef struct __OCIStmt OCIStmt&gt;</body><body package="OracleEXDI">OCISvcCtx	&lt;C: typedef struct __OCISvcCtx OCISvcCtx&gt;</body><body package="OracleEXDI">OCITrans	&lt;C: typedef struct __OCITrans OCITrans&gt;</body><body package="OracleEXDI">OraText	&lt;C: typedef unsigned char OraText&gt;</body><body package="OracleEXDI">oratext	&lt;C: typedef void * oratext&gt;</body><body package="OracleEXDI">sb1	&lt;C: typedef signed char sb1&gt;</body><body package="OracleEXDI">sb2	&lt;C: typedef signed short sb2&gt;</body><body package="OracleEXDI">sb4	&lt;C: typedef signed long sb4&gt;</body><body package="OracleEXDI">size_t	&lt;C: typedef unsigned int size_t&gt;</body><body package="OracleEXDI">sword	&lt;C: typedef signed int sword&gt;</body><body package="OracleEXDI">text	&lt;C: typedef unsigned char text&gt;</body><body package="OracleEXDI">ub1	&lt;C: typedef unsigned char ub1&gt;</body><body package="OracleEXDI">ub2	&lt;C: typedef unsigned short ub2&gt;</body><body package="OracleEXDI">ub4	&lt;C: typedef unsigned long ub4&gt;</body><body package="OracleEXDI">ubig_ora	&lt;C: typedef void * ubig_ora&gt;</body><body package="OracleEXDI">uword	&lt;C: typedef unsigned int uword&gt;</body></methods><methods><class-id>Database.OracleInterface</class-id> <category>accessing</category><body package="OracleEXDI">copyToHeapSelector	^#copyToHeap</body><body package="OracleEXDI">encoding	^encoding</body><body package="OracleEXDI">encoding: anEncoding	encoding := anEncoding</body><body package="OracleEXDI">getEncoding	| str subStr |	str := self getOracleParameterString: 'NLS_LANG'.	subStr := str copyFrom: (str indexOf: $.) + 1 to: str size.	(subStr isEmpty or: [subStr = 'NA']) ifTrue: [^#default].	^OracleConnection mapEncodings		at: subStr		ifAbsent: [self error: (#errColumnEncoding &lt;&lt; #oracleDB &gt;&gt; 'Column encoding not yet recognized')]</body><body package="OracleEXDI">mallocSelector	^#malloc:</body></methods><methods><class-id>Database.OracleInterface</class-id> <category>defines</category><body package="OracleEXDI">OCI_ATTR_ALLOC_DURATION	&lt;C: #define OCI_ATTR_ALLOC_DURATION 37	&gt;</body><body package="OracleEXDI">OCI_ATTR_CACHE_MAX_SIZE	&lt;C: #define OCI_ATTR_CACHE_MAX_SIZE 35	&gt;</body><body package="OracleEXDI">OCI_ATTR_CACHE_OPT_SIZE	&lt;C: #define OCI_ATTR_CACHE_OPT_SIZE 34	&gt;</body><body package="OracleEXDI">OCI_ATTR_CHARSET_FORM	&lt;C: #define OCI_ATTR_CHARSET_FORM 32	&gt;</body><body package="OracleEXDI">OCI_ATTR_CHARSET_ID	&lt;C: #define OCI_ATTR_CHARSET_ID 31	&gt;</body><body package="OracleEXDI">OCI_ATTR_COLLECTION_ELEMENT	&lt;C: #define OCI_ATTR_COLLECTION_ELEMENT  227	&gt;</body><body package="OracleEXDI">OCI_ATTR_COLLECTION_TYPECODE	&lt;C: #define OCI_ATTR_COLLECTION_TYPECODE  217	&gt;</body><body package="OracleEXDI">OCI_ATTR_CURRENT_POSITION	&lt;C: #define OCI_ATTR_CURRENT_POSITION  164	&gt;</body><body package="OracleEXDI">OCI_ATTR_DATA_SIZE	&lt;C: #define OCI_ATTR_DATA_SIZE 1	&gt;</body><body package="OracleEXDI">OCI_ATTR_DATA_TYPE	&lt;C: #define OCI_ATTR_DATA_TYPE 2	&gt;</body><body package="OracleEXDI">OCI_ATTR_ENV	&lt;C: #define OCI_ATTR_ENV 5	&gt;</body><body package="OracleEXDI">OCI_ATTR_FUNCODE	&lt;C: #define OCI_ATTR_FUNCODE OCI_ATTR_FNCODE	&gt;</body><body package="OracleEXDI">OCI_ATTR_HEAPALLOC	&lt;C: #define OCI_ATTR_HEAPALLOC 30	&gt;</body><body package="OracleEXDI">OCI_ATTR_INAME	&lt;C: #define OCI_ATTR_INAME 25	&gt;</body><body package="OracleEXDI">OCI_ATTR_IS_NULL	&lt;C: #define OCI_ATTR_IS_NULL 7	&gt;</body><body package="OracleEXDI">OCI_ATTR_LIST_TYPE_ATTRS	&lt;C: #define OCI_ATTR_LIST_TYPE_ATTRS  229	&gt;</body><body package="OracleEXDI">OCI_ATTR_NAME	&lt;C: #define OCI_ATTR_NAME 4	&gt;</body><body package="OracleEXDI">OCI_ATTR_NCHAR	&lt;C: #define OCI_ATTR_NCHAR 21	&gt;</body><body package="OracleEXDI">OCI_ATTR_NESTED_PREFETCH_MEMORY	&lt;C: #define OCI_ATTR_NESTED_PREFETCH_MEMORY 14	&gt;</body><body package="OracleEXDI">OCI_ATTR_NESTED_PREFETCH_ROWS	&lt;C: #define OCI_ATTR_NESTED_PREFETCH_ROWS 12	&gt;</body><body package="OracleEXDI">OCI_ATTR_NONBLOCKING_MODE	&lt;C: #define OCI_ATTR_NONBLOCKING_MODE 3	&gt;</body><body package="OracleEXDI">OCI_ATTR_NUM_ATTRS	&lt;C: #define OCI_ATTR_NUM_ATTRS 120	&gt;</body><body package="OracleEXDI">OCI_ATTR_NUM_COLS	&lt;C: #define OCI_ATTR_NUM_COLS 102	&gt;</body><body package="OracleEXDI">OCI_ATTR_NUM_ELEMS	&lt;C: #define OCI_ATTR_NUM_ELEMS  234	&gt;</body><body package="OracleEXDI">OCI_ATTR_NUM_PARAMS	&lt;C: #define OCI_ATTR_NUM_PARAMS 121	&gt;</body><body package="OracleEXDI">OCI_ATTR_NUM_TYPE_ATTRS	&lt;C: #define OCI_ATTR_NUM_TYPE_ATTRS  228 	&gt;</body><body package="OracleEXDI">OCI_ATTR_OBJECT	&lt;C: #define OCI_ATTR_OBJECT 2	&gt;</body><body package="OracleEXDI">OCI_ATTR_PARAM	&lt;C: #define OCI_ATTR_PARAM      124 	&gt;</body><body package="OracleEXDI">OCI_ATTR_PARAM_COUNT	&lt;C: #define OCI_ATTR_PARAM_COUNT 18	&gt;</body><body package="OracleEXDI">OCI_ATTR_PARSE_ERROR_OFFSET	&lt;C: #define OCI_ATTR_PARSE_ERROR_OFFSET 129	&gt;</body><body package="OracleEXDI">OCI_ATTR_PASSWORD	&lt;C: #define OCI_ATTR_PASSWORD 23	&gt;</body><body package="OracleEXDI">OCI_ATTR_PINOPTION	&lt;C: #define OCI_ATTR_PINOPTION 36	&gt;</body><body package="OracleEXDI">OCI_ATTR_PIN_DURATION	&lt;C: #define OCI_ATTR_PIN_DURATION 38	&gt;</body><body package="OracleEXDI">OCI_ATTR_PRECISION	&lt;C: #define OCI_ATTR_PRECISION 5	&gt;</body><body package="OracleEXDI">OCI_ATTR_PREFETCH_MEMORY	&lt;C: #define OCI_ATTR_PREFETCH_MEMORY 13	&gt;</body><body package="OracleEXDI">OCI_ATTR_PREFETCH_ROWS	&lt;C: #define OCI_ATTR_PREFETCH_ROWS 11	&gt;</body><body package="OracleEXDI">OCI_ATTR_PTYPE	&lt;C: #define OCI_ATTR_PTYPE 123	&gt;</body><body package="OracleEXDI">OCI_ATTR_RDBA	&lt;C: #define OCI_ATTR_RDBA 104	&gt;</body><body package="OracleEXDI">OCI_ATTR_REF_TDO	&lt;C: #define OCI_ATTR_REF_TDO 110	&gt;</body><body package="OracleEXDI">OCI_ATTR_ROWID	&lt;C: #define OCI_ATTR_ROWID 19	&gt;</body><body package="OracleEXDI">OCI_ATTR_ROWS_FETCHED	&lt;C: #define OCI_ATTR_ROWS_FETCHED 197	&gt;</body><body package="OracleEXDI">OCI_ATTR_ROW_COUNT	&lt;C: #define OCI_ATTR_ROW_COUNT 9	&gt;</body><body package="OracleEXDI">OCI_ATTR_SCALE	&lt;C: #define OCI_ATTR_SCALE 6	&gt;</body><body package="OracleEXDI">OCI_ATTR_SCHEMA_NAME	&lt;C: #define OCI_ATTR_SCHEMA_NAME 9	&gt;</body><body package="OracleEXDI">OCI_ATTR_SERVER	&lt;C: #define OCI_ATTR_SERVER 6	&gt;</body><body package="OracleEXDI">OCI_ATTR_SESSION	&lt;C: #define OCI_ATTR_SESSION 7	&gt;</body><body package="OracleEXDI">OCI_ATTR_SQLCODE	&lt;C: #define OCI_ATTR_SQLCODE 4	&gt;</body><body package="OracleEXDI">OCI_ATTR_SQLFNCODE	&lt;C: #define OCI_ATTR_SQLFNCODE 10	&gt;</body><body package="OracleEXDI">OCI_ATTR_SRVRCTXT	&lt;C: #define OCI_ATTR_SRVRCTXT OCI_ATTR_SERVER	&gt;</body><body package="OracleEXDI">OCI_ATTR_STMTCACHESIZE	&lt;C: #define OCI_ATTR_STMTCACHESIZE 176	&gt;</body><body package="OracleEXDI">OCI_ATTR_STMT_TYPE	&lt;C: #define OCI_ATTR_STMT_TYPE 24	&gt;</body><body package="OracleEXDI">OCI_ATTR_TIMESTAMP	&lt;C: #define OCI_ATTR_TIMESTAMP 119	&gt;</body><body package="OracleEXDI">OCI_ATTR_TRANS	&lt;C: #define OCI_ATTR_TRANS 8	&gt;</body><body package="OracleEXDI">OCI_ATTR_TRANS_LOCK	&lt;C: #define OCI_ATTR_TRANS_LOCK 28	&gt;</body><body package="OracleEXDI">OCI_ATTR_TRANS_NAME	&lt;C: #define OCI_ATTR_TRANS_NAME 29	&gt;</body><body package="OracleEXDI">OCI_ATTR_TYPECODE	&lt;C: #define OCI_ATTR_TYPECODE  216	&gt;</body><body package="OracleEXDI">OCI_ATTR_TYPE_NAME	&lt;C: #define OCI_ATTR_TYPE_NAME 8	&gt;</body><body package="OracleEXDI">OCI_ATTR_TYPE_SCHEMA	&lt;C: #define OCI_ATTR_TYPE_SCHEMA 118	&gt;</body><body package="OracleEXDI">OCI_ATTR_USERNAME	&lt;C: #define OCI_ATTR_USERNAME 22	&gt;</body><body package="OracleEXDI">OCI_ATTR_VERSION	&lt;C: #define OCI_ATTR_VERSION  218	&gt;</body><body package="OracleEXDI">OCI_ATTR_XID	&lt;C: #define OCI_ATTR_XID 27	&gt;</body><body package="OracleEXDI">OCI_ATTR_XNAME	&lt;C: #define OCI_ATTR_XNAME 26	&gt;</body><body package="OracleEXDI">OCI_COMMIT_ON_SUCCESS	&lt;C: #define OCI_COMMIT_ON_SUCCESS  32	&gt;</body><body package="OracleEXDI">OCI_CONTINUE	&lt;C: #define OCI_CONTINUE -24200	&gt;</body><body package="OracleEXDI">OCI_CRED_EXT	&lt;C: #define OCI_CRED_EXT 2	&gt;</body><body package="OracleEXDI">OCI_CRED_RDBMS	&lt;C: #define OCI_CRED_RDBMS 1	&gt;</body><body package="OracleEXDI">OCI_DEFAULT	&lt;C: #define OCI_DEFAULT 0x00	&gt;</body><body package="OracleEXDI">OCI_DESCRIBE_ONLY	&lt;C: #define OCI_DESCRIBE_ONLY 16	&gt;</body><body package="OracleEXDI">OCI_DTYPE_LOB	&lt;C: #define OCI_DTYPE_LOB 50	&gt;</body><body package="OracleEXDI">OCI_DTYPE_PARAM	&lt;C: #define OCI_DTYPE_PARAM 53	&gt;</body><body package="OracleEXDI">OCI_DTYPE_TIMESTAMP	&lt;C: #define OCI_DTYPE_TIMESTAMP 68  	&gt;</body><body package="OracleEXDI">OCI_ENV_NO_MUTEX	&lt;C: #define OCI_ENV_NO_MUTEX 8	&gt;</body><body package="OracleEXDI">OCI_EV_DEF	&lt;C: #define OCI_EV_DEF 0	&gt;</body><body package="OracleEXDI">OCI_EV_TSF	&lt;C: #define OCI_EV_TSF 1	&gt;</body><body package="OracleEXDI">OCI_EXACT_FETCH	&lt;C: #define OCI_EXACT_FETCH 2	&gt;</body><body package="OracleEXDI">OCI_FETCH_ABSOLUTE	&lt;C: #define OCI_FETCH_ABSOLUTE 32	&gt;</body><body package="OracleEXDI">OCI_FETCH_FIRST	&lt;C: #define OCI_FETCH_FIRST 4	&gt;</body><body package="OracleEXDI">OCI_FETCH_LAST	&lt;C: #define OCI_FETCH_LAST 8	&gt;</body><body package="OracleEXDI">OCI_FETCH_NEXT	&lt;C: #define OCI_FETCH_NEXT 2	&gt;</body><body package="OracleEXDI">OCI_FETCH_PRIOR	&lt;C: #define OCI_FETCH_PRIOR 0x10 	&gt;</body><body package="OracleEXDI">OCI_FETCH_RELATIVE	&lt;C: #define OCI_FETCH_RELATIVE 0x40 	&gt;</body><body package="OracleEXDI">OCI_FIRST_PIECE	&lt;C: #define OCI_FIRST_PIECE 1	&gt;</body><body package="OracleEXDI">OCI_HTYPE_BIND	&lt;C: #define OCI_HTYPE_BIND 5	&gt;</body><body package="OracleEXDI">OCI_HTYPE_DEFINE	&lt;C: #define OCI_HTYPE_DEFINE 6	&gt;</body><body package="OracleEXDI">OCI_HTYPE_DESCRIBE	&lt;C: #define OCI_HTYPE_DESCRIBE 7	&gt;</body><body package="OracleEXDI">OCI_HTYPE_DSC	&lt;C: #define OCI_HTYPE_DSC OCI_HTYPE_DESCRIBE	&gt;</body><body package="OracleEXDI">OCI_HTYPE_ENV	&lt;C: #define OCI_HTYPE_ENV 1	&gt;</body><body package="OracleEXDI">OCI_HTYPE_ERROR	&lt;C: #define OCI_HTYPE_ERROR 2	&gt;</body><body package="OracleEXDI">OCI_HTYPE_SERVER	&lt;C: #define OCI_HTYPE_SERVER 8	&gt;</body><body package="OracleEXDI">OCI_HTYPE_SESSION	&lt;C: #define OCI_HTYPE_SESSION 9	&gt;</body><body package="OracleEXDI">OCI_HTYPE_STM	&lt;C: #define OCI_HTYPE_STM OCI_HTYPE_STMT	&gt;</body><body package="OracleEXDI">OCI_HTYPE_STMT	&lt;C: #define OCI_HTYPE_STMT 4	&gt;</body><body package="OracleEXDI">OCI_HTYPE_SVC	&lt;C: #define OCI_HTYPE_SVC OCI_HTYPE_SVCCTX	&gt;</body><body package="OracleEXDI">OCI_HTYPE_SVCCTX	&lt;C: #define OCI_HTYPE_SVCCTX 3	&gt;</body><body package="OracleEXDI">OCI_HTYPE_TRANS	&lt;C: #define OCI_HTYPE_TRANS 10	&gt;</body><body package="OracleEXDI">OCI_IN_PARAMETER	&lt;C: #define OCI_IN_PARAMETER OCI_PARAM_IN	&gt;</body><body package="OracleEXDI">OCI_LAST_PIECE	&lt;C: #define OCI_LAST_PIECE 3	&gt;</body><body package="OracleEXDI">OCI_NEED_DATA	&lt;C: #define OCI_NEED_DATA 99	&gt;</body><body package="OracleEXDI">OCI_NEXT_PIECE	&lt;C: #define OCI_NEXT_PIECE 2	&gt;</body><body package="OracleEXDI">OCI_NLS_CHARSET_ID	&lt;C: #define OCI_NLS_CHARSET_ID 93 	&gt;</body><body package="OracleEXDI">OCI_NLS_MAXBUFSZ	&lt;C: #define OCI_NLS_MAXBUFSZ   100	&gt;</body><body package="OracleEXDI">OCI_NLS_NCHARSET_ID	&lt;C: #define OCI_NLS_NCHARSET_ID 94 	&gt;</body><body package="OracleEXDI">OCI_NO_DATA	&lt;C: #define OCI_NO_DATA 100	&gt;</body><body package="OracleEXDI">OCI_NTV_SYNTAX	&lt;C: #define OCI_NTV_SYNTAX 1	&gt;</body><body package="OracleEXDI">OCI_ONE_PIECE	&lt;C: #define OCI_ONE_PIECE 0	&gt;</body><body package="OracleEXDI">OCI_STMT_SCROLLABLE_READONLY	&lt;C: #define OCI_STMT_SCROLLABLE_READONLY 0x08	&gt;</body><body package="OracleEXDI">OCI_STMT_SELECT	&lt;C: #define OCI_STMT_SELECT 1	&gt;</body><body package="OracleEXDI">OCI_SUCCESS	&lt;C: #define OCI_SUCCESS 0	&gt;</body><body package="OracleEXDI">OCI_SUCCESS_WITH_INFO	&lt;C: #define OCI_SUCCESS_WITH_INFO 1	&gt;</body><body package="OracleEXDI">OCI_THREADED	&lt;C: #define OCI_THREADED 1	&gt;</body><body package="OracleEXDI">OCI_TRANS_NEW	&lt;C: #define OCI_TRANS_NEW 0x00000001	&gt;</body><body package="OracleEXDI">OCI_TRANS_READONLY	&lt;C: #define OCI_TRANS_READONLY 0x00000100	&gt;</body><body package="OracleEXDI">OCI_TRANS_SERIALIZABLE	&lt;C: #define OCI_TRANS_SERIALIZABLE 0x00000400	&gt;</body><body package="OracleEXDI">OCI_UCS2ID	&lt;C: #define OCI_UCS2ID 1000	&gt;</body><body package="OracleEXDI">OCI_UTF16ID	&lt;C: #define OCI_UTF16ID 1000	&gt;</body><body package="OracleEXDI">SQLCS_IMPLICIT	&lt;C: #define SQLCS_IMPLICIT 1	&gt;</body><body package="OracleEXDI">SQLCS_NCHAR	&lt;C: #define SQLCS_NCHAR 2	&gt;</body><body package="OracleEXDI">SQLT_RSET	&lt;C: #define SQLT_RSET 116	&gt;</body></methods><methods><class-id>Database.OracleInterface</class-id> <category>procedures - statement</category><body package="OracleEXDI">OCI_STMT_CACHE	&lt;C: #define OCI_STMT_CACHE 0x0040	&gt;</body><body package="OracleEXDI">OCI_STRLS_CACHE_DELETE	&lt;C: #define OCI_STRLS_CACHE_DELETE 0x0010	&gt;</body></methods><methods><class-id>Database.OracleInterface</class-id> <category>parameter</category><body package="OracleEXDI">getOracleParameterString: parameterName	"Answer the value of the named Oracle parameter, which must be a string.	If not present, answer the empty string."	^CEnvironment getenv: parameterName</body></methods><methods><class-id>Database.OracleInterface</class-id> <category>enums</category><body package="OracleEXDI">__OCILobMode	&lt;C: enum __OCILobMode&gt;</body></methods><methods><class-id>Database.OracleInterface class</class-id> <category>private-accessing</category><body package="OracleEXDI">connectionClass	^OracleConnection</body></methods><methods><class-id>Database.OracleInterface class</class-id> <category>private</category><body package="OracleEXDI">libraryFilesSearchSignals	"This class is expected to provide a list of exceptions which should be ignored	when the library is not found whilst searching for it under the wrong platfrom name."	^ExternalLibraryHolder libraryNotFoundSignal</body><body package="OracleEXDI">platformSymbol	"this must contain the platform symbol that will	match that returned by determinePlatformType."	"platform symbols known today include:	#nt				Windows/NT	#win95 		Windows95	#hp_unix		HP/UX	#sun5_unix	Solaris	#aix_unix		AIX	#alpha_unix	DEC/Unix	#powermac	Power Mac	#mac			Mac 68K	#linux_i386_unix 	Linux	#linux_x86_64_unix Linux 64-bit	#unix_sysV_sun_solaris64 Solaris 64-bit"		^#unknown</body></methods><methods><class-id>Database.OracleSolarisInterface class</class-id> <category>private</category><body package="OracleEXDI">platformSymbol	"this must contain the platform symbol that will	match that returned by determinePlatformType."	^#sun5_unix</body></methods><methods><class-id>Database.OracleBuffer</class-id> <category>allocation</category><body package="OracleEXDI">free	"Free the external resources held by this buffer."	bufferPointer == nil ifFalse: [ bufferPointer freePointer ].	indicatorsPointer == nil ifFalse: [ indicatorsPointer freePointer ].	cursizPointer == nil ifFalse: [ cursizPointer freePointer ].	bufferPointer := nil.	indicatorsPointer := nil.	lengthsPointer := nil.	rcodesPointer := nil.	cursizPointer := nil</body><body package="OracleEXDI">mallocForParameter	[ "Begin unwind protection"	| allocCount longBuffer numArrays pointerBase |	allocCount := (count == 0 ifTrue: [ 1 ] ifFalse: [ count ]).	longBuffer := databaseType == 94 or: [databaseType == 95].	"Allocate a properly typed buffer pointer."	bufferPointer := (longBuffer		ifTrue:	[ self allocStructuredBuffer: allocCount ]		ifFalse:	[ self allocScalarBuffer: allocCount ]).	"Allocate for all the remaining arrays in one block."	numArrays := longBuffer ifTrue: [2] ifFalse: [3].	indicatorsPointer := self allocShortArray: allocCount * numArrays.	pointerBase := indicatorsPointer referentAddress.	longBuffer ifFalse:		[ lengthsPointer := CPointer new			newDatum: pointerBase + (allocCount * 2)			ofType: DefaultUnsignedShortPointerType.		pointerBase := lengthsPointer referentAddress ].	rcodesPointer := CPointer new		newDatum: pointerBase + (allocCount * 2)		ofType: DefaultUnsignedShortPointerType.	"Allocate the current size holder."	count == 0 ifFalse:		[ cursizPointer := self allocLong ].	"End unwind protection" ]		ifCurtailed:			[ self free ].	getSelector := GetSelectorMap at: databaseType ifAbsent: [nil].	setSelector := SetSelectorMap at: databaseType ifAbsent: [nil]</body><body package="OracleEXDI">mallocForRowBuffer	[ "Begin unwind protection"	| allocCount longBuffer needRcodes numArrays pointerBase |	allocCount := (count == 0 ifTrue: [ 1 ] ifFalse: [ count ]).	longBuffer := databaseType == 94 or: [databaseType == 95].	needRcodes := nullsPossible or: [longBuffer].	"Allocate a properly typed buffer pointer."	bufferPointer := (longBuffer		ifTrue:	[ self allocStructuredBuffer: allocCount ]		ifFalse:	[ self allocScalarBuffer: allocCount ]).	"Allocate for all the remaining arrays in one block."	numArrays := (longBuffer		ifTrue: [ 2 ]		ifFalse: [ nullsPossible ifTrue: [3] ifFalse: [2] ]).	indicatorsPointer := self allocShortArray: allocCount * numArrays.	pointerBase := indicatorsPointer referentAddress.	longBuffer ifFalse:		[ lengthsPointer := CPointer new			newDatum: pointerBase + (allocCount * 2)			ofType: DefaultUnsignedShortPointerType.		pointerBase := lengthsPointer referentAddress ].	needRcodes ifTrue:		[ rcodesPointer := CPointer new			newDatum: pointerBase + (allocCount * 2)			ofType: DefaultUnsignedShortPointerType ].	"End unwind protection" ]		ifCurtailed:			[ self free ].	getSelector := GetSelectorMap at: databaseType ifAbsent: [nil].	setSelector := SetSelectorMap at: databaseType ifAbsent: [nil]</body><body package="OracleEXDI">mallocUsingSelector: mallocSelector	^self shouldNotImplement</body></methods><methods><class-id>Database.OracleBuffer</class-id> <category>accessing</category><body package="OracleEXDI">at: anIndex	"Answer the element in the buffer at anIndex."	| indexMinus1 rcode |	indexMinus1 := anIndex - 1.	"rcodesPointer is only allocated if it might need to be checked."	rcodesPointer == nil ifFalse:		[ rcode := rcodesPointer at: indexMinus1.		rcode == 1405 ifTrue: [ ^nil ].		(rcode == 0 or: [rcode == 1406]) ifFalse:		"Ignore truncation warnings."			[ self class connectionClass unableToFetchDataSignal				raiseWith: (Array with: (OracleError new dbmsErrorCode: rcode)) errorString: (rcode printStringRadix: 10) ] ].	getSelector isNil ifTrue: [		^self class connectionClass unsupportedDataTypeSignal raise	] ifFalse: [		"Nothing went wrong, so fetch the data."		^self perform: getSelector with: anIndex	].</body><body package="OracleEXDI">at: anIndex put: aValue	"Store aValue at anIndex in the receiver."	setSelector isNil ifTrue: [		^self class connectionClass unsupportedDataTypeSignal raise	] ifFalse: [		self perform: setSelector with: anIndex with: aValue	].</body><body package="OracleEXDI">boundedElementSize	^elementSize</body><body package="OracleEXDI">cursizPointer	^cursizPointer</body><body package="OracleEXDI">encoding	"Answer the encoding"	self isUnicodeColumn ifTrue: [		^self session connection unicodeEncoding	] ifFalse: [		^self session connection encoding	]</body><body package="OracleEXDI">indicatorsPointer	^indicatorsPointer</body><body package="OracleEXDI">isUnicodeColumn	^isUnicodeColumn</body><body package="OracleEXDI">isUnicodeColumn: aBoolean	isUnicodeColumn := aBoolean</body><body package="OracleEXDI">lengthsPointer	^lengthsPointer</body><body package="OracleEXDI">position	"Answer the ordinal number of the column, or nil if unknown."	^position</body><body package="OracleEXDI">position: aNumber	position := aNumber</body><body package="OracleEXDI">rcodesPointer	^rcodesPointer</body><body package="OracleEXDI">session	^session first</body><body package="OracleEXDI">session: aSession 	"Use a weak reference to the owning session object so that it can finalize when not in use."	session := WeakArray with: aSession</body><body package="OracleEXDI">value	"Answer the value (or values) held in the buffer"	| array |	(count &lt; 1)		ifTrue: [ ^self at: 1 ].	array := Array new: count.	1 to: count do:		[ :index | array at: index put: (self at: index) ].	^array</body><body package="OracleEXDI">value: aValueOrArray	"Store aValueOrArray into the receiver."	| isArray |	isArray := aValueOrArray oracleConversion == #Array.	(count &lt; 1) ifTrue: [		^self at: 1 put: ( isArray ifTrue: [ aValueOrArray at: 1] ifFalse: [ aValueOrArray ] ).	].	isArray ifTrue: [  | size |		size := aValueOrArray size.		1 to: count do:[ :index |			self at: index put: ( size &gt;= index ifTrue: [ aValueOrArray at: index ] ifFalse: [ nil ]).		]	] ifFalse: [		self at: 1 put: aValueOrArray.		2 to: count do:[ :index |			self at: index put: nil.		]	].	cursizPointer contents: count.</body></methods><methods><class-id>Database.OracleBuffer</class-id> <category>private</category><body package="OracleEXDI">allocLong	| thePointerType address |	thePointerType := DefaultLongPointerType.	address := thePointerType primMalloc: 4 pointerKind: thePointerType kind.	^address == nil		ifTrue:	[ nil ]		ifFalse:	[ CPointer new newDatum: address ofType: thePointerType ]</body><body package="OracleEXDI">allocScalarBuffer: numElements	| thePointerType address |	thePointerType := DefaultUnsignedCharPointerType.	databaseType == 3 ifTrue:		[ thePointerType := DefaultLongPointerType ].	( #(4 21 22) includes: databaseType) ifTrue:		[ elementSize == 4			ifTrue:	[ thePointerType := DefaultFloatPointerType ]			ifFalse:	[ thePointerType := DefaultDoublePointerType ] ].	address := thePointerType primMalloc: elementSize * numElements pointerKind: thePointerType kind.	^address == nil		ifTrue:	[ nil ]		ifFalse:	[ CPointer new newDatum: address ofType: thePointerType ]</body><body package="OracleEXDI">allocShortArray: numElements	| thePointerType address |	thePointerType := DefaultShortPointerType.	address := thePointerType primMalloc: 2 * numElements pointerKind: thePointerType kind.	^address == nil		ifTrue:	[ nil ]		ifFalse:	[ CPointer new newDatum: address ofType: thePointerType ]</body><body package="OracleEXDI">allocStructuredBuffer: numElements	| newStruct thePointerType address ptr |	newStruct := CCompositeType new beStructure.	newStruct at: #length put: 0-&gt;Unsigned32BitIntType.	newStruct at: #array put: 1-&gt;(CArrayType defaultPointer			referentType: CIntegerType unsignedChar;			numElements: elementSize-4).	newStruct align.	thePointerType := newStruct pointerType.	OracleConnection platformType == #win32s ifTrue:		[ thePointerType beFar ].	address := thePointerType primMalloc: elementSize * numElements pointerKind: thePointerType kind.	address == nil		ifTrue:	[ ^nil ]		ifFalse:	[ ptr := CCompositePointer new newDatum: address ofType: thePointerType ].	ptr memberAt: #length put: (elementSize - 4).	^ptr</body><body package="OracleEXDI">allocUnsignedCharArray: numElements	| thePointerType address |	thePointerType := DefaultUnsignedCharPointerType.	address := thePointerType primMalloc: self elementSize * numElements pointerKind: thePointerType kind.	^address == nil		ifTrue:	[ nil ]		ifFalse:	[ CPointer new newDatum: address ofType: thePointerType ]</body><body package="OracleEXDI">getSelector	^getSelector</body><body package="OracleEXDI">needsReallocation: elementsToBind 	"Check whether the actual allocated buffer can store the new element(s) to be bound to a parameter.	 We'll recreate the buffer if the following conditions are met:			(1) Previous bind object was nil, so we should recreate the buffer with correct type.			(2) A number to be bound to a parameter does not fit the buffer i.e LargeInteger into a buffer allocated for a SmallInteger			(3) The binding value is an array with at least 2 elements, and the array's size is greater than the buffer's count.			(4) The type of the previous bound value does not match the type of the actual value"	| bindSize |	(self databaseType == 1 and: [self indicatorsPointer contents == -1]) 		ifTrue: [^true].	elementsToBind isNil ifTrue: [^false].	((bindSize := self session maxBindSize) notNil and: [ (bindSize &gt; 1) and: [ bindSize &gt; self count] ]) ifTrue: [^true].	(elementsToBind oracleConversion == #Array 		and: [elementsToBind size ~= self count]) ifTrue: [^true].	^(self isForNumber and: [ (self canBindNumber: elementsToBind) not ] )</body><body package="OracleEXDI">setSelector	^setSelector</body><body package="OracleEXDI">toVarnum: preShiftedDigits number: number	| exponent value isNegative stack digits aDigit outIndex |	number == 0 ifTrue: [ ^#[1 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ]].	exponent := preShiftedDigits.	stack := ByteArray new: 20.	value := (isNegative := number &lt; 0) ifTrue: [ number negated ] ifFalse: [ number ].	"Trim off trailing zero digits."	[ (value \\ 100 ) == 0 ]		whileTrue:			[ exponent := exponent - 1.			value := value // 100 ].			"Stack the remaining digits up in inverse order."	digits := 0.	[ value == 0 ] whileFalse:		[ aDigit := value \\ 100.		digits := digits + 1.		stack at: digits put: aDigit.		value := value // 100 ].	"Emit the length and exponent bytes."	tempArray at: 1 put: ((digits + (isNegative ifTrue: [ 2 ] ifFalse: [ 1 ])) min: 21).	tempArray at: 2 put: (isNegative						ifTrue: [ 63 - (digits - exponent) ]						ifFalse: [ 192 + (digits - exponent) ]).	"Emit the digits."	outIndex := 3.	[ digits == 0 ] whileFalse:		[ aDigit := stack at: digits.		tempArray at: outIndex put: ( isNegative									ifTrue: [ 101 - aDigit ]									ifFalse: [ aDigit + 1 ] ).		digits := digits - 1.		outIndex := outIndex + 1 ].	"If negative, pad with an a magic negative byte."	( isNegative and: [ outIndex &lt; 21 ] )		ifTrue: [ tempArray at: outIndex put: 102 ].	^tempArray</body></methods><methods><class-id>Database.OracleBuffer</class-id> <category>private-data conversion</category><body package="OracleEXDI">at: index putDate: aValue	"Store a Timestamp in the buffer."	| indexMinus1 ts |	indexMinus1 := index - 1.	aValue isNil ifTrue:		[ ^indicatorsPointer at: indexMinus1 put: -1 ].	indicatorsPointer at: indexMinus1 put: 0.	lengthsPointer at: indexMinus1 put: elementSize.	ts := aValue asTimestamp.	tempArray		at: 1 put: ((ts year // 100) + 100);		at: 2 put: ((ts year \\ 100) + 100);		at: 3 put: ts month;		at: 4 put: ts day;		at: 5 put: ts hour + 1;		at: 6 put: ts minute + 1;		at: 7 put: ts second + 1.	bufferPointer		copyAt: ((index - 1) * elementSize)		from: tempArray		size: 7		startingAt: 1</body><body package="OracleEXDI">at: index putFloat: aValue	"Store a float or double at the bufferPointer."	"Assume that bufferPointer is coerced to array of float or double."	| indexMinus1 |	indexMinus1 := index - 1.	aValue isNil ifTrue:		[ ^indicatorsPointer at: indexMinus1 put: -1 ].	indicatorsPointer at: indexMinus1 put: 0.	lengthsPointer at: indexMinus1 put: elementSize.	(aValue isKindOf: Fraction) ifTrue: [		bufferPointer at: indexMinus1 put: aValue asDouble	] ifFalse: [		bufferPointer at: indexMinus1 put: aValue	]</body><body package="OracleEXDI">at: index putLongVarchar: string	"Answer a string as described in the string pointed to by aCPointer."	| indexMinus1 ba size bp |	indexMinus1 := index - 1.	string isNil ifTrue:		[ ^indicatorsPointer at: indexMinus1 put: -1 ].	indicatorsPointer at: indexMinus1 put: 0.	"The String we get may come pre-encoded."	(string class) == ByteArray		ifTrue:			[ ba := string ]		ifFalse:			[ ba := ByteArray fromString: string encoding: self encoding ].	(size := ba size) &gt; (elementSize-4) ifTrue:		[ OracleConnection unableToBindSignal raise ].	indexMinus1 == 0		ifTrue:	[ bp := bufferPointer ]		ifFalse:	[ bp := bufferPointer refAt: indexMinus1 ].	bp memberAt: #length put: size.	bp		copyAt: 4		from: ba		size: size		startingAt: 1</body><body package="OracleEXDI">at: index putLongVarraw: bytes	"Store the byte array into the proper slot in the buffer."	| indexMinus1 size bp |	indexMinus1 := index - 1.	bytes isNil ifTrue:		[ ^indicatorsPointer at: indexMinus1 put: -1 ].	indicatorsPointer at: indexMinus1 put: 0.	"Check that it will really fit."	(size := bytes size) &gt; (elementSize-4) ifTrue:		[ OracleConnection unableToBindSignal raise ].	indexMinus1 == 0		ifTrue:	[ bp := bufferPointer ]		ifFalse:	[ bp := bufferPointer refAt: indexMinus1 ].	bp memberAt: #length put: size.	bp		copyAt: 4		from: bytes		size: size		startingAt: 1</body><body package="OracleEXDI">at: index putRaw: bytes	"Copy the byte array into the buffer at index."	| indexMinus1 size |	indexMinus1 := index - 1.	bytes isNil		ifTrue:			[ indicatorsPointer at: indexMinus1 put: -1 ]		ifFalse:			[ indicatorsPointer at: indexMinus1 put: 0.			(size := bytes size) &gt; elementSize ifTrue:				[ OracleConnection unableToBindSignal raise ].			lengthsPointer at: indexMinus1 put: size.			bufferPointer copyAt: (indexMinus1 * elementSize) from: bytes size: size startingAt: 1 ]</body><body package="OracleEXDI">at: index putSignedInteger: aValue	"Store a 32-bit signed integer at the bufferPointer."	"Assume that bufferPointer is coerced to array of long."	| indexMinus1 |	indexMinus1 := index - 1.	aValue isNil ifTrue:		[ ^indicatorsPointer at: indexMinus1 put: -1 ].	indicatorsPointer at: indexMinus1 put: 0.	lengthsPointer at: indexMinus1 put: elementSize.	bufferPointer at: indexMinus1 put: aValue</body><body package="OracleEXDI">at: index putVarchar2: string	"Copy string into the buffer at index."	"Take care to ensure that the encoding of the characters (bytes) in the string is	appropriate to the platform."	| indexMinus1 size ba |	indexMinus1 := index - 1.	string isNil ifTrue:		[ ^indicatorsPointer at: indexMinus1 put: -1 ].	indicatorsPointer at: indexMinus1 put: 0.	"The String we get may come pre-encoded."	(string class) == ByteArray		ifTrue:			[ ba := string ]		ifFalse:			[ ba := ByteArray fromString: string encoding: self encoding ].	"Put it into the right slot in the array."	(size := ba size) &gt; elementSize ifTrue:		[ OracleConnection unableToBindSignal raise ].	lengthsPointer at: indexMinus1 put: size.	bufferPointer copyAt: (indexMinus1 * elementSize) from: ba size: size startingAt: 1</body><body package="OracleEXDI">at: index putVarnum: number	"Answer a numeric object."	| indexMinus1 numberBytes |	indexMinus1 := index - 1.	number isNil ifTrue:		[ ^indicatorsPointer at: indexMinus1 put: -1 ].	indicatorsPointer at: indexMinus1 put: 0.	lengthsPointer at: indexMinus1 put: elementSize.	number class == FixedPoint		ifTrue:			[ | power100 multiplier |			power100 := number scale + 1 // 2.			multiplier := 1.			power100 timesRepeat: [ multiplier := multiplier * 100 ].			numberBytes := self toVarnum: power100 number: (number * multiplier) rounded ]		ifFalse:			[ numberBytes := self toVarnum: 0 number: number ].	bufferPointer		copyAt: (indexMinus1 * elementSize)		from: numberBytes		size: 22		startingAt: 1</body><body package="OracleEXDI">getDateAt: index	"Answer a Timestamp as described in the 7 bytes pointed to by aCPointer."	bufferPointer		copyAt: ((index - 1) * elementSize)		to: tempArray		size: 7		startingAt: 1.	^(Timestamp new)		year: (((tempArray at: 1) - 100) * 100) + ((tempArray at: 2) - 100);		month: (tempArray at: 3);		day: (tempArray at: 4);		hour: (tempArray at: 5) - 1;		minute: (tempArray at: 6) - 1;		second: (tempArray at: 7) - 1;		millisecond: 0</body><body package="OracleEXDI">getFloatAt: index	"Answer a Float (or Double) as described in the 4 (or 8) bytes 	pointed to by aCPointer."	"Assume that bufferPointer is coerced to array of float or double."	^bufferPointer at: index - 1</body><body package="OracleEXDI">getLongVarcharAt: index	"Answer a string as described in the string pointed to by aCPointer."	| indexMinus1 bp bytesInString ba |	(indexMinus1 := index - 1) == 0		ifTrue:	[ bp := bufferPointer ]		ifFalse:	[ bp := bufferPointer refAt: indexMinus1 ].	bytesInString := bp memberAt: #length.	ba := String primitiveArgumentClass new: bytesInString.	bp		copyAt: 4		to: ba		size: bytesInString		startingAt: 1.	^ba asStringEncoding: self encoding</body><body package="OracleEXDI">getLongVarrawAt: index	"Answer a string as described in the string pointed to by aCPointer."	| indexMinus1 bp bytes ba |	(indexMinus1 := index - 1) == 0		ifTrue:	[ bp := bufferPointer ]		ifFalse:	[ bp := bufferPointer refAt: indexMinus1 ].	bytes := bp memberAt: #length.	ba := ByteArray new: bytes.	bp		copyAt: 4		to: ba		size: bytes		startingAt: 1.	^ba</body><body package="OracleEXDI">getRawAt: index	"Answer a ByteArray as described in the string pointed to by aCPointer."	| indexMinus1 bytesInField ba |	indexMinus1 := index - 1.	bytesInField := lengthsPointer at: indexMinus1.	ba := ByteArray new: bytesInField.	bufferPointer		copyAt: (indexMinus1 * elementSize)		to: ba		size: bytesInField		startingAt: 1.	^ba</body><body package="OracleEXDI">getSignedIntegerAt: index	"Answer a 32-bit integer value from the array pointed to by aCPointer."	"Assume that bufferPointer is coerced to array of long."	^bufferPointer at: index - 1</body><body package="OracleEXDI">getVarchar2At: index	"Answer a string as described in the string pointed to by aCPointer."	"The implementation herein depends on the implementation of DLLCC."	| bytesInString ba |	bytesInString := lengthsPointer at: (index - 1).	ba := String primitiveArgumentClass new: bytesInString.	bufferPointer		copyAt: ((index - 1) * elementSize)		to: ba		size: bytesInString		startingAt: 1.	^ba asStringEncoding: self encoding</body><body package="OracleEXDI">getVarnumAt: index	"Answer a numeric object."	| signExponentByte bytesInNumber isNegative exponent number alreadyShifted byte shift |	bufferPointer		copyAt: ((index - 1) * elementSize)		to: tempArray		size: 22		startingAt: 1.	"Separate the sign and exponent (they occupy the first 	byte of the array). The first bit of the signExponentByte is 	the sign. The number is positive if this bit is a 1. The 	exponent is the remaining 7 bits and is stored in excess-64 	notation. Just to keep life exciting, for negative numbers, 	the exponent is stored in ones-complement."	signExponentByte := tempArray at: 2.	(isNegative := (signExponentByte bitAnd: 128) == 0) ifTrue:		[ signExponentByte := signExponentByte bitXor: 255 ].	exponent := (signExponentByte bitAnd: 127) - 64.	"Convert the numeric bytes into an integer."	bytesInNumber := (tempArray at: 1) .	1 == bytesInNumber ifTrue: [ ^0 ].	number := 0.	alreadyShifted := 0.	3 to: bytesInNumber + 1 do:		[ :bindex |		byte := tempArray at: bindex.		102 == byte ifFalse:			[ number := 100 * number + (isNegative				ifTrue:	[ 101 - byte ]				ifFalse:	[ byte - 1 ]).			alreadyShifted := alreadyShifted + 1 ] ].	"Shift the integer based on the exponent to get the right magnitude."	shift := exponent - alreadyShifted.	shift &lt; 0 ifTrue:		[ | denominator columnScale finalScale |		denominator := 1.		(0 - shift) timesRepeat: [ denominator := 100 * denominator ].		columnScale := (self session columnDescriptions at: self position) scale.		finalScale := (columnScale &gt;= 0)				ifTrue: [columnScale]				ifFalse: [-2 * shift].		^FixedPoint			numerator: (isNegative ifTrue: [ 0 - number ] ifFalse: [ number ])			denominator: denominator			scale: finalScale ].	shift &gt; 0 ifTrue:		[ shift timesRepeat: [ number := 100 * number ] ].	"Apply the sign if necessary and answer."	^isNegative ifTrue: [ 0 - number ] ifFalse: [ number ]</body></methods><methods><class-id>Database.OracleBuffer</class-id> <category>initialize-release</category><body package="OracleEXDI">columnDescription: colDescr count: allocCount maxLongBytes: maxLongBytes	| internalType externalType elemSize precision |	internalType := colDescr internalType.	"Defaults are to use what given."	externalType := internalType.		elemSize := colDescr dbsize.	nullsPossible := colDescr nullable.	position := colDescr index.		"VARCHAR2"	internalType == 1 ifTrue:		[ "take the default type and size unless too big."		elemSize &gt; 4000 ifTrue: [ internalType := 8	"LONG" ] ].	"NUMBER"	internalType == 2 ifTrue:		[ | scale |		"Default to VARNUM"		externalType := 6.		elemSize := 22.		precision := colDescr precision.		(((scale := colDescr scale) == -127) and: [precision ~= 0])			ifTrue:				["We have a bona fide floating point number.  If the (binary) precision				is small enough to represent in C data types float or double, do so."				precision &lt;= 46 ifTrue:					[ externalType := 4. "FLOAT"					precision &lt;= 26						ifTrue:	[ elemSize := 4 ]						ifFalse:	[ elemSize := 8 ] ] ]			ifFalse:				[ "Not a floating point number."				scale == 0 ifTrue:					[					(precision &lt;= 9 and: [precision &gt; 0]) ifTrue:						[ externalType := 3. "32-bit signed INTEGER"						elemSize := 4 ] ] ].		externalType == 6 ifTrue:			[ tempArray := ByteArray new: 22 ] ].	"BINARY_FLOAT"	internalType == 100 ifTrue:		[externalType := 21.		elemSize := 4 ].	"BINARY_DOUBLE"	internalType == 101 ifTrue:		[externalType := 22.		elemSize := 8 ].	"LONG"	internalType == 8 ifTrue:		[ externalType := 94.	"LONG VARCHAR"		elemSize := 4 + (maxLongBytes + 3 // 4 * 4) ].	"ROWID"	((internalType == 11) or: [internalType == 104])  ifTrue:		[ "ROWID can be as much as 256 bytes in string form."		externalType := 1.		elemSize := 256 ].	"DATE"	internalType == 12 ifTrue:		[ "take the default type and size"		tempArray := ByteArray new: 7 ].			"RAW"	internalType == 23 ifTrue:		[ "take the default type and size unless too big."		elemSize &gt; 2000 ifTrue: [ internalType := 24 "LONG RAW" ] ].	"LONG RAW"	internalType == 24 ifTrue:		[ externalType := 95.	"LONG VARRAW"		elemSize := 4 + (maxLongBytes + 3 // 4 * 4) ].	"CHAR: take the default type and size"	"MLSLABEL"	internalType == 106 ifTrue:		[ elemSize := 255 ].	self isUnicodeColumn: colDescr isUnicodeColumn.	self elementSize: elemSize count: allocCount databaseType: externalType</body><body package="OracleEXDI">for: value conv: convSymbol count: allocCount size: size	| elemSize externalType nextSize |	nullsPossible := true.	(convSymbol == #Array) ifTrue: [ | type |		type := self session findRightBindingType: value.		^self for: value conv: type count: allocCount size: size].	convSymbol isNil ifTrue:		[ externalType := 1. "VARCHAR2"		elemSize := 256 ].	(convSymbol == #String or: [convSymbol == #ByteArray]) ifTrue:		[ "Infer elemSize if size isn't given"		(elemSize := size) isNil			ifTrue:				[ "If it's an array, we want to take the longest one so that the buffer will fit them all."				(allocCount &gt; 1 or: [value oracleConversion == #Array])					ifTrue:						[ elemSize := value inject: 0 into:							[ :currentMax :nextValue |							nextSize := ((nextValue isKindOf: Text) or: [(nextValue isKindOf:String) or: [nextValue isKindOf: ByteArray]] ) 								ifTrue: [									(nextValue isKindOf: ByteArray) ifTrue:[ 										nextValue size									] ifFalse: [ 										(ByteArray fromString: nextValue encoding: self encoding) size ]. 								] ifFalse: [nextValue].							nextValue isNil								ifTrue:	[ currentMax ]								ifFalse:	[  nextSize &gt; currentMax ifTrue: [ nextSize ] ifFalse: [ currentMax ] ] ] ]					ifFalse:						[ elemSize := ((value isKindOf: ByteArray) ifTrue: [							value] ifFalse: [(ByteArray fromString: value encoding: self encoding)]) size						] 					].		convSymbol == #String ifTrue:			[ externalType := 1. "VARCHAR2"			elemSize &gt; 4000 ifTrue:				[ externalType := 94. "LONG VARCHAR"				elemSize := 4 + (elemSize + 3 // 4 * 4) ] ].		convSymbol == #ByteArray ifTrue:			[ externalType := 23. "RAW"			elemSize &gt; 2000 ifTrue:				[ externalType := 95. "LONG VARRAW"				elemSize := 4 + (elemSize + 3 // 4 * 4) ] ] ].	convSymbol == #Char ifTrue:		[ externalType := 96.	"CHAR"		size isNil			ifTrue:	[ elemSize := value size ]			ifFalse:	[ elemSize := size ] ].	((convSymbol == #Date) or: [ convSymbol == #Time ]) ifTrue:		[ externalType := 12.	"DATE"		elemSize := 7.		tempArray := ByteArray new: 7 ].	convSymbol == #Float ifTrue:		[ externalType := 4. "FLOAT"		elemSize := 4 ].	convSymbol == #Double ifTrue:		[ externalType := 4. "FLOAT"		elemSize := 8 ].	convSymbol == #Integer32 ifTrue:		[ externalType := 3. "32-bit signed integer"		elemSize := 4 ].	(convSymbol == #Integer or: [convSymbol == #FixedPoint]) ifTrue:		[ externalType := 6. "VARNUM"		elemSize := 22.		tempArray := ByteArray new: 22 ].	convSymbol == #MLSLABEL ifTrue:		[ externalType := 106. "MLSLABEL"		elemSize := 255 ].	self elementSize: elemSize count: allocCount databaseType: externalType.</body><body package="OracleEXDI">initialize	"Initialize an instance of the receiver."	super initialize.	self isUnicodeColumn: false.</body></methods><methods><class-id>Database.OracleBuffer</class-id> <category>testing</category><body package="OracleEXDI">canBindNumber: aValue	"Answer true or false meaning whether the buffer can be used to bind aValue."	| type dataType dataSize |	self isForNumber ifFalse: [ ^false ].	aValue oracleConversion == #Array 		ifTrue: [type := self session findRightBindingType: aValue]		ifFalse: [type := aValue oracleConversion].	dataType := self databaseType.	dataSize := self elementSize.	"DOUBLE"	(((dataType == 4) or: [dataType==22]) and: [dataSize == 8])		ifTrue: [^#(#Float #Double #Integer32) includes: type].	"FLOAT"	(((dataType == 4) or: [dataType==21]) and: [dataSize == 4]) ifTrue: [^type == #Float].	"VARNUM"	(dataType == 6 and: [dataSize == 22]) 		ifTrue: [^#(#Integer32 #Integer #FixedPoint) includes: type].	"32-bit signed integer"	(dataType == 3 and: [dataSize == 4]) ifTrue: [^type == #Integer32].	^false</body><body package="OracleEXDI">isForNumber	"Answer true or false meaning whether the buffer is used to bind numbers."	^#(3 4 6 21 22) includes: self databaseType</body></methods><methods><class-id>Database.OracleBuffer class</class-id> <category>class initialization</category><body package="OracleEXDI">initialize	"OracleBuffer initialize"	self install.	"Map the Oracle external datatype codes to get functions."	(GetSelectorMap := IdentityDictionary new)		add: ( 1 "VARCHAR2" -&gt; #getVarchar2At: );		add: ( 3 "32-bit signed integer" -&gt; #getSignedIntegerAt: );		add: ( 4 "FLOAT" -&gt; #getFloatAt: );		add: ( 6 "VARNUM" -&gt; #getVarnumAt: );		add: ( 12 "DATE" -&gt; #getDateAt: );		add: ( 21 "BINARY_FLOAT" -&gt; #getFloatAt: );		add: ( 22 "BINARY_DOUBLE" -&gt; #getFloatAt: );		add: ( 23 "RAW" -&gt; #getRawAt: );		add: ( 94 "LONG VARCHAR" -&gt; #getLongVarcharAt: );		add: ( 95 "LONG VARRAW" -&gt; #getLongVarrawAt: );		add: ( 96 "CHAR" -&gt; #getVarchar2At: );		add: ( 106 "MLSLABEL" -&gt; #getVarchar2At: );		add: ( 112 " Character LOB" -&gt; #getClobAt: );		add: ( 113 "Binary LOB" -&gt; #getBlobAt: );		add: ( 116 "Ref Cursor" -&gt; #getRefCursorAt: ); 		add: ( 187 "TIMESTAMP" -&gt; #getTimestampAt: );		add: ( 188 "CURRENT_TIMESTAMP" -&gt; #getTimestampAt: ).	(SetSelectorMap := IdentityDictionary new)		add: ( 1 "VARCHAR2" -&gt; #at:putVarchar2: );		add: ( 3 "32-bit signed integer" -&gt; #at:putSignedInteger: );		add: ( 4 "FLOAT" -&gt; #at:putFloat: );		add: ( 6 "VARNUM" -&gt; #at:putVarnum: );		add: ( 12 "DATE" -&gt; #at:putDate: );		add: ( 21 "BINARY_FLOAT" -&gt; #at:putFloat: );		add: ( 22 "BINARY_DOUBLE" -&gt; #at:putFloat: );		add: ( 23 "RAW" -&gt; #at:putRaw: );		add: ( 94 "LONG VARCHAR" -&gt; #at:putLongVarchar: );		add: ( 95 "LONG VARRAW" -&gt; #at:putLongVarraw: );		add: ( 96 "CHAR" -&gt; #at:putVarchar2: );		add: ( 106 "MLSLABEL" -&gt; #at:putChar: );		add: ( 187 "TIMESTAMP" -&gt; #at:putTimestamp: ).</body></methods><methods><class-id>Database.OracleBuffer class</class-id> <category>private-activation</category><body package="OracleEXDI">install	ObjectMemory is64Bit ifTrue: [		Unsigned32BitIntType := CIntegerType unsignedInt.		Signed32BitIntType := CIntegerType signedInt.	] ifFalse: [		Unsigned32BitIntType := CIntegerType unsignedLong.		Signed32BitIntType := CIntegerType signedLong.	].	DefaultDoublePointerType := CLimitedPrecisionRealType double pointerType.	DefaultFloatPointerType := CLimitedPrecisionRealType float pointerType.	DefaultLongPointerType := Signed32BitIntType pointerType.	DefaultShortPointerType := CIntegerType short pointerType.	DefaultUnsignedCharPointerType := CIntegerType unsignedChar pointerType.	DefaultUnsignedShortPointerType := CIntegerType unsignedShort pointerType.	OracleConnection platformType == #win32s 		ifTrue: 			[DefaultDoublePointerType beFar.			DefaultFloatPointerType beFar.			DefaultLongPointerType beFar.			DefaultShortPointerType beFar.			DefaultUnsignedCharPointerType beFar.			DefaultUnsignedShortPointerType beFar].</body></methods><methods><class-id>Database.OracleBuffer class</class-id> <category>accessing</category><body package="OracleEXDI">connectionClass	^OracleConnection</body></methods><methods><class-id>Database.OracleTimestampBuffer</class-id> <category>initialize-release</category><body package="OracleEXDI">columnDescription: colDescr count: allocCount maxLongBytes: maxLongBytes	| internalType externalType elemSize |	internalType := colDescr internalType.	"Defaults are to use what given."	externalType := internalType.		elemSize := colDescr dbsize.	nullsPossible := colDescr nullable.	self elementSize: elemSize count: allocCount databaseType: externalType</body><body package="OracleEXDI">for: value conv: convSymbol count: allocCount size: size	| elemSize externalType |	nullsPossible := true.	(convSymbol == #Array) ifTrue: [ | representativeElement |		representativeElement := value detect: [:each | each notNil] ifNone: [nil].		^self for: representativeElement conv: representativeElement oracleConversion count: allocCount size: size].	convSymbol isNil ifTrue:		[ externalType := 1. "VARCHAR2"		elemSize := 256 ].	externalType := 187.	"Timestamp"	self elementSize: elemSize count: allocCount databaseType: externalType.</body><body package="OracleEXDI">initialize	"Initialize an instance of the receiver."	super initialize.	"Pointers in the receiver are not allocated yet."	pointerInitialized := false</body></methods><methods><class-id>Database.OracleTimestampBuffer</class-id> <category>private - allocation</category><body package="OracleEXDI">allocateConversionPointers	"Allocate pointers used in the conversion process."	| ub1Type ub4Type sb2Type |	sb2Type := DefaultShortPointerType.	ub1Type := DefaultUnsignedCharPointerType.	ub4Type :=	Unsigned32BitIntType pointerType.      yearPointer := CPointer new newDatum: (sb2Type primMalloc: 1 pointerKind: sb2Type kind) ofType: sb2Type.       monthPointer := CPointer new newDatum: (ub1Type primMalloc: 1 pointerKind: ub1Type kind) ofType: ub1Type.       dayPointer := CPointer new newDatum: (ub1Type primMalloc: 1 pointerKind: ub1Type kind) ofType: ub1Type.       hourPointer := CPointer new newDatum: (ub1Type primMalloc: 1 pointerKind: ub1Type kind) ofType: ub1Type.       minPointer := CPointer new newDatum: (ub1Type primMalloc: 1 pointerKind: ub1Type kind) ofType: ub1Type.       secPointer := CPointer new newDatum: (ub1Type primMalloc: 1 pointerKind: ub1Type kind) ofType: ub1Type.       fsecPointer := CPointer new newDatum: (ub4Type primMalloc: 1 pointerKind: ub4Type kind) ofType: ub4Type.	self pointerInitialized: true</body><body package="OracleEXDI">allocDescriptorForTimestamp: timestampPointer	| xif rtval henv |	xif := self session class xif.	"timestampPointer contents: (xif OCIDateTime pointerType cast: nil)."	henv := self session connection henv.	rtval := xif 	OCIDescriptorAlloc: henv				with: timestampPointer				with: xif OCI_DTYPE_TIMESTAMP				with: 0				with: 0.	self session traceLevel &gt;= 1 		ifTrue: 			[(self session traceStream)				print: rtval;				nextPutAll: ' = OCIDescriptorAlloc( henv =';				nextPutAll: (henv referentAddress printStringRadix: 16);				nextPutAll: ', timestampPointer  = ';				nextPutAll: (timestampPointer referentAddress printStringRadix: 16);				nextPutAll: ', type  = OCI_DTYPE_TIMESTAMP';				nextPutAll: ' xtramem_sz = 0, usrmempp = 0)';				crtab.			self session class trace: self session emitTrace].	rtval == xif OCI_SUCCESS 		ifFalse: 			[| errs |			errs := self session connection getErrors.			^self session connection class unableToAllocateDescriptorSignal raiseWith: errs errorString: errs first dbmsErrorString].</body><body package="OracleEXDI">allocTimestampDescriptor: numElements 	"Initialize Timestamp Desciptor."	| xif timestampPointerPointer timestampPointer numAllocated |	xif := self session connection class xif.	numAllocated := 0.	["Begin unwind protection (1)"	timestampPointerPointer := xif OCIDateTime pointerType perform: xif mallocSelector with: numElements.	1 to: numElements do:		[:index |		timestampPointer := timestampPointerPointer refAt: index - 1.		self allocDescriptorForTimestamp: timestampPointer.		numAllocated := index]]	ifCurtailed:	"End unwind protection (1)"		[timestampPointerPointer notNil ifTrue:			[timestampPointerPointer isValid ifTrue:				[1 to: numAllocated do:					[:index |					timestampPointerPointer datum ifNotNil:						[timestampPointer := timestampPointerPointer refAt: index - 1.						self freeDescriptorForTimestamp: timestampPointer]].			timestampPointerPointer freePointer].		timestampPointerPointer := nil]].	elementSize := timestampPointerPointer sizeof.	^timestampPointerPointer</body><body package="OracleEXDI">freeConversionPointers	"Free pointers used in the conversion process."	yearPointer == nil ifFalse: [ yearPointer freePointer ].	monthPointer == nil ifFalse: [ monthPointer freePointer ].  	dayPointer == nil ifFalse: [ dayPointer freePointer ]. 	hourPointer == nil ifFalse: [ hourPointer freePointer ].  	minPointer == nil ifFalse: [ minPointer freePointer ]. 	secPointer == nil ifFalse: [ secPointer freePointer ].  	fsecPointer == nil ifFalse: [ fsecPointer freePointer ].	self pointerInitialized: false</body><body package="OracleEXDI">freeDescriptorForTimestamp: timestampPointer	| xif rtval |	xif := self session class xif.	rtval := xif OCIDescriptorFree: timestampPointer contents				with: xif OCI_DTYPE_TIMESTAMP.	self session traceLevel &gt;= 1 ifTrue: [ 		(self session traceStream)				print: rtval;				nextPutAll: ' = OCIDescriptorFree( timestampPointer = ';				nextPutAll: (timestampPointer referentAddress printStringRadix: 16);				nextPutAll: ', type  = OCI_DTYPE_TIMESTAMP)';				crtab.			self session class trace: self session emitTrace].	rtval == xif OCI_SUCCESS 		ifFalse: 			[| errs |			errs := self session connection getErrors.			^self session connection class unableToFreeDescriptorSignal raiseWith: errs errorString: errs first dbmsErrorString]</body><body package="OracleEXDI">freeTimestampDescriptor	"Free the Timestamp Desciptors."	| timestampPointerPointer timestampPointer freeCount |	freeCount := count == 0 ifTrue: [1] ifFalse: [count].	timestampPointerPointer := self pointer.	timestampPointerPointer notNil ifTrue: [		timestampPointerPointer isValid ifTrue: [			1 to: freeCount do: [:index |				timestampPointerPointer datum ifNotNil: [					timestampPointer := timestampPointerPointer refAt: index - 1.					self freeDescriptorForTimestamp: timestampPointer				]			]		]	].</body></methods><methods><class-id>Database.OracleTimestampBuffer</class-id> <category>private-data conversion</category><body package="OracleEXDI">at: index putTimestamp: aValue	"Store a Timestamp in the buffer."	| indexMinus1 bufferAtIndex ts |	indexMinus1 := index - 1.	aValue isNil ifTrue:		[ ^indicatorsPointer at: indexMinus1 put: -1 ].	indicatorsPointer at: indexMinus1 put: 0.	lengthsPointer at: indexMinus1 put: elementSize.	bufferAtIndex := bufferPointer refAt: indexMinus1.	ts := aValue asTimestamp.	self constructTimestamp: self session connection hsess			err: self session connection herr 			timestamp: bufferAtIndex			year: ts year 			month: ts month 			day: ts day 			hour: ts hour 			min: ts minute 			sec: ts second 			fsec: (ts millisecond*1000000 + ts partialNanosecond)			timezone: 0 			timezone_length: 0.</body><body package="OracleEXDI">constructTimestamp: hndl err: err timestamp: datetime year: year month: month day: day hour: hour min: min sec: sec fsec: fsec timezone: timezone timezone_length: timezone_length	| rtval conn xif |	conn := self session connection.	xif := conn class xif.	rtval := xif OCIDateTimeConstruct: hndl 			with: err 			with: datetime contents			with: year 			with: month 			with: day 			with: hour 			with: min 			with: sec 			with: fsec 			with: timezone 			with: timezone_length.	(rtval == xif OCI_SUCCESS)		ifFalse: [ | errs |			   	  errs := conn getErrors.				  ^conn class unableToConstructTimestampSignal raiseWith: errs errorString: errs first dbmsErrorString  ].</body><body package="OracleEXDI">getDate: hndl err: err datetime: datetime year: year month: month day: day	| rtval conn xif |	conn := self session connection.	xif := conn class xif.	rtval := xif OCIDateTimeGetDate: hndl						    with: err						    with: datetime contents						    with: year						    with: month						    with: day.	(rtval == xif OCI_SUCCESS)		ifFalse: [ | errs |			   	  errs := conn getErrors.				  ^conn class unableToGetTimestampDateSignal raiseWith: errs errorString: errs first dbmsErrorString  ].</body><body package="OracleEXDI">getTime: hndl err: err datetime: datetime hour: hour min: min sec: sec fsec: fsec	| rtval conn xif |	conn := self session connection.	xif := conn class xif.	rtval := xif OCIDateTimeGetTime: hndl						    with: err						    with: datetime contents						    with: hour						    with: min						    with: sec						    with: fsec.	(rtval == xif OCI_SUCCESS)		ifFalse: [ | errs |			   	  errs := conn getErrors.				  ^conn class unableToGetTimestampTimeSignal raiseWith: errs errorString: errs first dbmsErrorString  ].</body><body package="OracleEXDI">getTimestampAt: index	"Answer a Timestamp pointed to by the OCIDateTime pointer."	| indexMinus1 bp ts hsess herr fSecond mSecond |	(indexMinus1 := index - 1) == 0		ifTrue:	[ bp := bufferPointer ]		ifFalse:	[ bp := bufferPointer refAt: indexMinus1 ].	self pointerInitialized ifFalse: [ self allocateConversionPointers ].	hsess := self session connection hsess.	herr := self session connection herr. 	self getDate: hsess			err: herr 			datetime: bp 			year: yearPointer 			month: monthPointer 			day: dayPointer.	self getTime: hsess			err: herr 			datetime: bp 			hour: hourPointer 			min: minPointer 			sec: secPointer 			fsec: fsecPointer.	fSecond := fsecPointer contents.	mSecond := fSecond//1000000.	ts := (Timestamp new)			year: yearPointer contents;			month: monthPointer contents;			day: dayPointer contents;			hour: hourPointer contents;			minute: minPointer contents;			second: secPointer contents;			millisecond: mSecond;			partialNanosecond: (fSecond - (mSecond * 1000000)).	^ts</body></methods><methods><class-id>Database.OracleTimestampBuffer</class-id> <category>allocation</category><body package="OracleEXDI">free	"Free the external resources held by this buffer."	self pointerInitialized ifTrue: [ self freeConversionPointers ].	self freeTimestampDescriptor.	super free</body><body package="OracleEXDI">mallocForParameter	[ "Begin unwind protection"	| allocCount numArrays pointerBase |	allocCount := (count == 0 ifTrue: [ 1 ] ifFalse: [ count ]).	"Allocate a properly typed buffer pointer."	bufferPointer := self allocTimestampDescriptor: allocCount.	"Allocate for all the remaining arrays in one block."	numArrays := 3.	indicatorsPointer := self allocShortArray: allocCount * numArrays.	pointerBase := indicatorsPointer referentAddress.	lengthsPointer := CPointer new			newDatum: pointerBase + (allocCount * 2)			ofType: DefaultUnsignedShortPointerType.		pointerBase := lengthsPointer referentAddress.	rcodesPointer := CPointer new		newDatum: pointerBase + (allocCount * 2)		ofType: DefaultUnsignedShortPointerType.	"Allocate the current size holder."	count == 0 ifFalse:		[ cursizPointer := self allocLong ].	"End unwind protection" ]		ifCurtailed:			[ self free ].	getSelector := GetSelectorMap at: databaseType ifAbsent: [nil].	setSelector := SetSelectorMap at: databaseType ifAbsent: [nil]</body><body package="OracleEXDI">mallocForRowBuffer	[ "Begin unwind protection"	| allocCount needRcodes numArrays pointerBase |	allocCount := (count == 0 ifTrue: [ 1 ] ifFalse: [ count ]).	needRcodes := nullsPossible.	"Allocate a properly typed buffer pointer."	bufferPointer := self allocTimestampDescriptor: allocCount.	"Allocate for all the remaining arrays in one block."	numArrays := nullsPossible ifTrue: [3] ifFalse: [2].	indicatorsPointer := self allocShortArray: allocCount * numArrays.	pointerBase := indicatorsPointer referentAddress.	lengthsPointer := CPointer new			newDatum: pointerBase + (allocCount * 2)			ofType: DefaultUnsignedShortPointerType.		pointerBase := lengthsPointer referentAddress.	needRcodes ifTrue:		[ rcodesPointer := CPointer new			newDatum: pointerBase + (allocCount * 2)			ofType: DefaultUnsignedShortPointerType ].	"End unwind protection" ]		ifCurtailed:			[ self free ].	getSelector := GetSelectorMap at: databaseType ifAbsent: [nil]</body></methods><methods><class-id>Database.OracleTimestampBuffer</class-id> <category>accessing</category><body package="OracleEXDI">pointerInitialized	^pointerInitialized</body><body package="OracleEXDI">pointerInitialized: aBoolean	pointerInitialized := aBoolean</body></methods><methods><class-id>Database.OracleTimestampBuffer class</class-id> <category>class initialization</category><body package="OracleEXDI">initialize	"OracleTimestampBuffer initialize"	self install.</body></methods><methods><class-id>Database.Oracle64BitInterface</class-id> <category>types</category><body package="OracleEXDI">sb4	&lt;C: typedef signed int sb4&gt;</body><body package="OracleEXDI">ub4	&lt;C: typedef unsigned int ub4&gt;</body></methods><methods><class-id>Database.OracleSolaris64Interface class</class-id> <category>private</category><body package="OracleEXDI">platformSymbol	"this must contain the platform symbol that will	match that returned by determinePlatformType."	^#unix_sysV_sun_solaris64</body></methods><methods><class-id>Database.UnableToGetTimestampTime</class-id> <category>printing</category><body package="OracleEXDI">defaultMessageText	^(#unableToGetTimestampTime &lt;&lt; #oracleDB &gt;&gt; 'Unable to get timestamp time.') asString</body></methods><methods><class-id>Database.UnableToRetrieveDescriptorInfo</class-id> <category>printing</category><body package="OracleEXDI">defaultMessageText	^(#errRetrieveDescriptorInformation &lt;&lt; #oracleDB &gt;&gt; 'Unable to retrieve descriptor information.') asString</body></methods><methods><class-id>Database.OracleLinux64Interface class</class-id> <category>private</category><body package="OracleEXDI">platformSymbol	"this must contain the platform symbol that will	match that returned by determinePlatformType."	^#linux_x86_64_unix</body></methods><methods><class-id>Database.UnableToGetStatementCacheSize</class-id> <category>printing</category><body package="OracleEXDI">defaultMessageText	^(#unableToGetStatementCacheSize &lt;&lt; #oracleDB &gt;&gt; 'Unable to get statement cache size.') asString</body></methods><methods><class-id>Database.OracleLargeObjectBuffer</class-id> <category>private-accessing</category><body package="OracleEXDI">at: anIndex	"Answer the element in the buffer at anIndex."	| indexMinus1 rcode aLobProxy |	self session answerLobProxy ifFalse: [		^super at: anIndex.	].	indexMinus1 := anIndex - 1.	"rcodesPointer is only allocated if it might need to be checked."	rcodesPointer == nil ifFalse:		[ rcode := rcodesPointer at: indexMinus1.		rcode == 1405 ifTrue: [ ^nil ].		(rcode == 0 or: [rcode == 1406]) ifFalse:		"Ignore truncation warnings."			[ self session connection class unableToFetchDataSignal				raiseWith: (Array with: (OracleError new dbmsErrorCode: rcode)) ] ].	"Nothing went wrong, so fetch the lob proxy."	aLobProxy := self getLobProxyAt: anIndex.	^(aLobProxy isUnicodeColumn: self isUnicodeColumn) encoding: self encoding</body><body package="OracleEXDI">bufferPointer	"Answer the receiver's buffer pointer."	^bufferPointer</body><body package="OracleEXDI">pointer	"Answer the receiver's LOB locator."	^self lobLocator</body></methods><methods><class-id>Database.OracleLargeObjectBuffer</class-id> <category>private allocation</category><body package="OracleEXDI">allocDescriptorForLobLocator: lobLocatorPointer	| xif rtval henv |	xif := self session class xif.	lobLocatorPointer contents: (xif OCILobLocator pointerType cast: nil).	henv := self session connection henv.	rtval := xif 	OCIDescriptorAlloc: henv				with: lobLocatorPointer				with: xif OCI_DTYPE_LOB				with: 0				with: 0.	self session traceLevel &gt;= 1 		ifTrue: 			[(self session traceStream)				print: rtval;				nextPutAll: ' = OCIDescriptorAlloc( henv =';				nextPutAll: (henv referentAddress printStringRadix: 16);				nextPutAll: ', lobLocatorPointer  = ';				nextPutAll: (lobLocatorPointer referentAddress printStringRadix: 16);				nextPutAll: ', type  = OCI_DTYPE_LOB';				nextPutAll: ' xtramem_sz = 0, usrmempp = 0)';				crtab.			self session class trace: self session emitTrace].	rtval == xif OCI_SUCCESS 		ifFalse: 			[| errs |			errs := self session connection getErrors.			^self session connection class unableToAllocateDescriptorSignal raiseWith: errs errorString: errs first dbmsErrorString].</body><body package="OracleEXDI">allocLobLocator: numElements 	"Initialize Lob Locators for an Large Objects (BLOB/CLOB)  ."	| xif lobLocatorPointerPointer lobLocatorPointer |	xif := self session class xif.		["Begin unwind protection (1)"		lobLocatorPointerPointer := xif OCILobLocator pointerType perform: xif mallocSelector	with: numElements.		1 to: numElements do:[:index | 			lobLocatorPointer := lobLocatorPointerPointer refAt: index - 1.			self allocDescriptorForLobLocator: lobLocatorPointer		].	"End unwind protection (1)"] ifCurtailed: [		1 to: numElements do: [:index | 			lobLocatorPointer := lobLocatorPointerPointer refAt: index - 1.			self freeDescriptorForLobLocator: lobLocatorPointer		].		lobLocatorPointerPointer freePointer	].	self lobLocator: lobLocatorPointerPointer.	^lobLocatorPointerPointer</body><body package="OracleEXDI">freeDescriptorForLobLocator: lobLocatorPointer	| xif rtval |	xif := self session class xif.	rtval := xif OCIDescriptorFree: lobLocatorPointer contents				with: xif OCI_DTYPE_LOB.	self session traceLevel &gt;= 1 ifTrue: [ 		(self session traceStream)				print: rtval;				nextPutAll: ' = OCIDescriptorFree( locatorPtr (lobLocator) = ';				nextPutAll: (lobLocatorPointer referentAddress printStringRadix: 16);				nextPutAll: ', type  = OCI_DTYPE_LOB)';				crtab.			self session class trace: self session emitTrace].	rtval == xif OCI_SUCCESS 		ifFalse: 			[| errs |			errs := self session connection getErrors.			^self session connection class unableToFreeDescriptorSignal raiseWith: errs errorString: errs first dbmsErrorString]</body></methods><methods><class-id>Database.OracleLargeObjectBuffer</class-id> <category>private-data conversion</category><body package="OracleEXDI">getBlobAt: index	| beginLobLocator resultByteArray readSize |	beginLobLocator := self lobLocator.	self lobLocator: (beginLobLocator refAt: index -1).	readSize := self session defaultDisplayLobSize min: self getLobLength.	resultByteArray := (self readFrom: 1 amount: readSize) contents.	self lobLocator: beginLobLocator.	^resultByteArray</body><body package="OracleEXDI">getClobAt: index	^(self getBlobAt: index) asStringEncoding: self encoding</body><body package="OracleEXDI">getPieceAmount: pieceAmount	"Answer a ByteArray containing the data in the buffer."	| ba |	ba := ByteArray new: pieceAmount.	bufferPointer		copyAt: 0		to: ba		size: pieceAmount		startingAt: 1.	^ba</body><body package="OracleEXDI">setBuffer: aByteArray	"Fill the buffer with the value from aByteArray" 	bufferPointer		copyAt: 0		from: aByteArray		size: aByteArray size		startingAt: 1.</body></methods><methods><class-id>Database.OracleLargeObjectBuffer</class-id> <category>data processing {read}</category><body package="OracleEXDI">getChunkSize      "get the chunk size."	| rtval conn xif herr hsvcctx chunkSizePointer lobLocatorPointer chunkSize |	(conn := self getConnection) isNil ifTrue: [		^nil	].	xif           := conn class xif.      hsvcctx   := conn hsvcctx.	herr        :=  conn herr.	lobLocatorPointer := self lobLocator contents.	["Begin unwind protection (1)"	chunkSizePointer := xif ub4 perform: xif mallocSelector with: 1.	chunkSizePointer contents: 0.      rtval := xif OCILobGetChunkSize: hsvcctx					    with: herr                                  with: lobLocatorPointer 					    with: chunkSizePointer.	self session traceLevel &gt;= 1 		ifTrue: 			[(self session traceStream)				print: rtval;				nextPutAll: ' = OCILobGetChunkSize( hsvcctx =';				nextPutAll: (hsvcctx referentAddress printStringRadix: 16);				nextPutAll: ', herr = ';				nextPutAll: (herr referentAddress printStringRadix: 16);				nextPutAll: ', lobLocator  = ';				nextPutAll: (lobLocatorPointer referentAddress printStringRadix: 16);				nextPutAll: ', chunkSizePointer  = ';				nextPutAll: (chunkSizePointer referentAddress printStringRadix: 16);				crtab.			self session class trace: self session emitTrace].	chunkSize := chunkSizePointer contents.	"End unwind protection (1)"]		ensure: [ chunkSizePointer == nil ifFalse: [ chunkSizePointer freePointer ] ].	(rtval == xif OCI_SUCCESS or: [ rtval == xif OCI_SUCCESS_WITH_INFO ] )		ifFalse: [ | errs |			   	  errs := conn getErrors.				  ^conn class unableToGetLobChunkSizeSignal raiseWith: errs errorString: errs first dbmsErrorString ].	^chunkSize</body><body package="OracleEXDI">getLobLength	| rtval conn xif herr hsvcctx lengthPointer length lobLocatorPointer |	(conn := self getConnection) isNil ifTrue: [		^nil	].	xif           := conn class xif.      hsvcctx   := conn hsvcctx.	herr        :=  conn herr.	lobLocatorPointer := self lobLocator contents.	["Begin unwind protection"	lengthPointer := xif ub4 perform: xif mallocSelector with: 1.	lengthPointer contents: 0.      rtval := xif OCILobGetLength: hsvcctx					    with: herr                                  with: lobLocatorPointer 					    with: lengthPointer.	self session traceLevel &gt;= 1 		ifTrue: 			[(self session traceStream)				print: rtval;				nextPutAll: ' = OCILobGetLength( hsvcctx =';				nextPutAll: (hsvcctx referentAddress printStringRadix: 16);				nextPutAll: ', herr = ';				nextPutAll: (herr referentAddress printStringRadix: 16);				nextPutAll: ', lobLocator  = ';				nextPutAll: (lobLocatorPointer referentAddress printStringRadix: 16);				nextPutAll: ', lengthPointer  = ';				nextPutAll: (lengthPointer referentAddress printStringRadix: 16);				crtab.			self session class trace: self session emitTrace].	length := lengthPointer contents.	"End unwind protection" ]		ensure: [ lengthPointer == nil ifFalse: [ lengthPointer freePointer ] ].	(rtval == xif OCI_SUCCESS or: [ rtval == xif OCI_SUCCESS_WITH_INFO ] )		ifFalse: [ | errs |			   	  errs := conn getErrors.				  ^conn class unableToGetLobLengthSignal raiseWith: errs errorString: errs first dbmsErrorString ].	^length</body><body package="OracleEXDI">readFrom: startingPosition amount: amount	| xif conn rtval resultStream amountPointer  numChars numBytes |	(conn := self getConnection) isNil ifTrue: [		^nil	].	xif := conn class xif.	resultStream := ReadWriteStream on: (ByteArray new: amount).	amountPointer := amount gcCopyToHeap.	[((rtval := self readLobDataExternalFrom: startingPosition amount: amountPointer) == xif OCI_NEED_DATA)] whileTrue: [		numChars := amountPointer contents.		numBytes := self encoding = #utf_16 ifTrue: [numChars *  2] ifFalse: [numChars].		resultStream nextPutAll: (self getPieceAmount: numBytes).	].	(rtval == xif OCI_SUCCESS or: [ rtval == xif OCI_SUCCESS_WITH_INFO ] )		ifFalse: [ | errs |			   	  errs := conn getErrors.				  ^conn class unableToReadLobDataSignal raiseWith: errs errorString: errs first dbmsErrorString ].	numChars := amountPointer contents.	numBytes := self encoding = #utf_16 ifTrue: [numChars *  2] ifFalse: [numChars].	resultStream nextPutAll: (self getPieceAmount: numBytes).	^resultStream</body><body package="OracleEXDI">readLobDataExternalFrom: offset amount: amountPointer      "Read a portion of a LOB/FILE as specified by the amountPointer."	| rtval conn xif herr hsvcctx lobLocatorPointer lobForm csid |	conn := self session connection.	xif           := conn class xif.     hsvcctx   := conn hsvcctx.	herr        :=  conn herr.	lobLocatorPointer := self lobLocator contents.	self isUnicodeColumn ifTrue: [		csid := self session connection oracleUnicodeEncodingId.		lobForm := xif SQLCS_NCHAR	] ifFalse: [		csid := self session connection oracleEncodingId.		lobForm := xif SQLCS_IMPLICIT	].     rtval := xif OCILobRead: hsvcctx					    with: herr                            with: lobLocatorPointer 					    with: amountPointer                            with: offset "absolute offset from beginning of data."					    with: self bufferPointer					    with: self elementSize					    with: 0					    with: 0					    with: csid                            with: lobForm.	self session traceLevel &gt;= 1 		ifTrue: 			[ | tStream |				tStream := (self session traceStream)				print: rtval;				nextPutAll: ' = OCILobRead( hsvcctx =';				nextPutAll: (hsvcctx referentAddress printStringRadix: 16);				nextPutAll: ', herr = ';				nextPutAll: (herr referentAddress printStringRadix: 16);				nextPutAll: ', lobLocator  = ';				nextPutAll: (lobLocatorPointer referentAddress printStringRadix: 16);				nextPutAll: ', amountPointer  = ';				nextPutAll: (amountPointer referentAddress printStringRadix: 16);				nextPutAll: ' , offset = '; print: offset;				nextPutAll: ', bufp  = ';				nextPutAll: (bufferPointer referentAddress printStringRadix: 16);				nextPutAll: ' , bufl = '; print: self elementSize;				nextPutAll: ' , ctxp = 0 '; 				nextPutAll: ' , cbfp = 0 '; 				nextPutAll: ' , csid =  '; print: csid. 				self isUnicodeColumn ifTrue: [					tStream nextPutAll: ' , csfrm = SQLCS_NCHAR '.				] ifFalse: [					tStream nextPutAll: ' , csfrm = SQLCS_IMPLICIT '. 				].				tStream crtab.			self session class trace: self session emitTrace].	((rtval == xif OCI_SUCCESS or: [ rtval == xif OCI_SUCCESS_WITH_INFO ]) or: [ rtval == xif OCI_NEED_DATA]) ifFalse: [ | errs |			   	  errs := conn getErrors.				  ^conn class unableToReadLobDataSignal raiseWith: errs errorString: errs first dbmsErrorString ].	^rtval</body></methods><methods><class-id>Database.OracleLargeObjectBuffer</class-id> <category>accessing</category><body package="OracleEXDI">lobLocator	^lobLocatorHolder value</body><body package="OracleEXDI">lobLocator: aLobLocatorPointer	lobLocatorHolder value: aLobLocatorPointer</body></methods><methods><class-id>Database.OracleLargeObjectBuffer</class-id> <category>private</category><body package="OracleEXDI">getLobProxyAt: index	^self getLobProxyForLocator: (self lobLocator refAt: index -1)</body><body package="OracleEXDI">getLobProxyForLocator: aLobLocatorPointerPointer	"Initialize Lob Proxy for an Large Objects (BLOB/CLOB)  ."	| lobProxy |		lobProxy := self class proxyClass newForLobLocator: aLobLocatorPointerPointer session: self session lobType: self databaseType.	^lobProxy</body></methods><methods><class-id>Database.OracleLargeObjectBuffer</class-id> <category>allocation</category><body package="OracleEXDI">free	"Free the external resources held by this buffer."	| lobLocatorPointer lobLocatorPointerPointer |	lobLocatorPointerPointer := self lobLocator.	lobLocatorPointerPointer notNil ifTrue: [		lobLocatorPointerPointer isValid ifTrue: [			1 to: self count do: [:index | 				lobLocatorPointer := lobLocatorPointerPointer refAt: index - 1.				self freeDescriptorForLobLocator: lobLocatorPointer			].			lobLocatorPointerPointer freePointer.		].		self lobLocator: nil.	].	super free.</body><body package="OracleEXDI">mallocForParameter	[ "Begin unwind protection"	| allocCount pointerBase |	allocCount := (count == 0 ifTrue: [ 1 ] ifFalse: [ count ]).	self allocLobLocator: allocCount.	"Allocate a properly typed buffer pointer."	bufferPointer := self allocUnsignedCharArray: allocCount.	"Allocate for all the remaining arrays in one block."	indicatorsPointer := self allocShortArray: allocCount.	pointerBase := indicatorsPointer referentAddress.	lengthsPointer := CPointer new			newDatum: pointerBase + (allocCount * 2)			ofType: DefaultUnsignedShortPointerType.	pointerBase := lengthsPointer referentAddress.	rcodesPointer := CPointer new		newDatum: pointerBase + (allocCount * 2)		ofType: DefaultUnsignedShortPointerType.	"Allocate the current size holder."	count == 0 ifFalse:		[ cursizPointer := self allocLong ].	"End unwind protection" ]		ifCurtailed:			[ self free ].	getSelector := GetSelectorMap at: databaseType ifAbsent: [nil].	setSelector := SetSelectorMap at: databaseType ifAbsent: [nil]</body><body package="OracleEXDI">mallocForRowBuffer	[ "Begin unwind protection"	| allocCount pointerBase needRcodes |	allocCount := (count == 0 ifTrue: [ 1 ] ifFalse: [ count ]).	needRcodes := nullsPossible.	self allocLobLocator: allocCount.	"Allocate a properly typed buffer pointer."	bufferPointer := self allocUnsignedCharArray: allocCount.	"Allocate for all the remaining arrays in one block."	indicatorsPointer := self allocShortArray: allocCount * ( needRcodes ifTrue: [ 3 ] ifFalse: [ 2 ] ).	pointerBase := indicatorsPointer referentAddress.	lengthsPointer := CPointer new			newDatum: pointerBase + (allocCount * 2)			ofType: DefaultUnsignedShortPointerType.	pointerBase := lengthsPointer referentAddress.	needRcodes ifTrue:		[ rcodesPointer := CPointer new			newDatum: pointerBase + (allocCount * 2)			ofType: DefaultUnsignedShortPointerType ].	"End unwind protection" ]		ifCurtailed:			[ self free ].	getSelector := GetSelectorMap at: databaseType ifAbsent: [nil]</body></methods><methods><class-id>Database.OracleLargeObjectBuffer</class-id> <category>data processing {write}</category><body package="OracleEXDI">writeLobDataExternalFrom: offset amount: amountPointer piece: piece	^self writeLobDataExternalFrom: offset amount: amountPointer piece: piece bufferLength: self elementSize</body><body package="OracleEXDI">writeLobDataExternalFrom: offset amount: amountPointer piece: piece bufferLength: buflen      "Read a portion of a LOB/FILE as specified by the amountPointer."	| rtval conn xif herr hsvcctx lobLocatorPointer lobForm csid |	conn := self session connection.	xif           := conn class xif.     hsvcctx   := conn hsvcctx.	herr        :=  conn herr.	self isUnicodeColumn ifTrue: [		csid := self session connection oracleUnicodeEncodingId.		lobForm := xif SQLCS_NCHAR	] ifFalse: [		csid := self session connection oracleEncodingId.		lobForm := xif SQLCS_IMPLICIT	].	lobLocatorPointer := self lobLocator contents.     rtval := xif OCILobWrite: hsvcctx					    with: herr                            with: self lobLocator contents 					    with: amountPointer                            with: offset "absolute offset from beginning of data."					    with: self bufferPointer					    with: buflen					    with: piece					    with: 0					    with: 0					    with: csid                            with: lobForm.	self session traceLevel &gt;= 1 		ifTrue: 			[ | tStream |				tStream := (self session traceStream) 				print: rtval;				nextPutAll: ' = OCILobWrite( hsvcctx =';				nextPutAll: (hsvcctx referentAddress printStringRadix: 16);				nextPutAll: ', herr = ';				nextPutAll: (herr referentAddress printStringRadix: 16);				nextPutAll: ', lobLocator  = ';				nextPutAll: (lobLocatorPointer referentAddress printStringRadix: 16);				nextPutAll: ', amountPointer  = ';				nextPutAll: (amountPointer referentAddress printStringRadix: 16);				nextPutAll: ' , offset = '; print: offset;				nextPutAll: ', bufp  = ';				nextPutAll: (bufferPointer referentAddress printStringRadix: 16);				nextPutAll: ' , bufl = '; print: self elementSize;				nextPutAll: ' , piece = '; print: piece;				nextPutAll: ' , ctxp = 0 '; 				nextPutAll: ' , cbfp = 0 '; 				nextPutAll: ' , csid =  '; print: csid.				self isUnicodeColumn ifTrue: [					tStream nextPutAll: ' , csfrm = SQLCS_NCHAR '.				] ifFalse: [					tStream nextPutAll: ' , csfrm = SQLCS_IMPLICIT '. 				].				tStream crtab.			self session class trace: self session emitTrace].	((rtval == xif OCI_SUCCESS or: [ rtval == xif OCI_SUCCESS_WITH_INFO ]) or: [ rtval == xif OCI_NEED_DATA]) ifFalse: [ | errs |			   	  errs := conn getErrors.				  ^conn class unableToWriteLobDataSignal raiseWith: errs errorString: errs first dbmsErrorString ].	^rtval</body></methods><methods><class-id>Database.OracleLargeObjectBuffer</class-id> <category>testing</category><body package="OracleEXDI">getConnection	| conn |	conn := self session connection.	conn isConnected ifFalse:[ 		conn class connectionNotOpenSignal raise.		^nil 	].	^conn</body></methods><methods><class-id>Database.OracleLargeObjectBuffer</class-id> <category>printing</category><body package="OracleEXDI">printOn: aStream	super printOn: aStream.</body></methods><methods><class-id>Database.OracleLargeObjectBuffer</class-id> <category>initialize-release</category><body package="OracleEXDI">columnDescription: colDescr count: allocCount session: aSession	| internalType externalType elemSize |	internalType := colDescr internalType.	"Defaults are to use what given."	externalType := internalType.		elemSize := colDescr dbsize.	nullsPossible := colDescr nullable.	self session: aSession.	self isUnicodeColumn: colDescr isUnicodeColumn.	self elementSize: elemSize count: allocCount databaseType: externalType</body><body package="OracleEXDI">initialize	"Initialize an instance of the receiver."	super initialize.	lobLocatorHolder := nil asValue.	self session: nil</body><body package="OracleEXDI">lobFor: value conv: convSymbol count: allocCount	| elemSize externalType |	nullsPossible := true.	elemSize := 4.	convSymbol isNil ifTrue:		[ externalType := 112. "CLOB"].		convSymbol == #String ifTrue:			[ externalType := 112. "CLOB"].		convSymbol == #ByteArray ifTrue:			[ externalType := 113. "BLOB"].	self elementSize: elemSize count: allocCount databaseType: externalType</body></methods><methods><class-id>Database.OracleLargeObjectBuffer class</class-id> <category>accessing</category><body package="OracleEXDI">proxyClass	^OracleLobProxy</body></methods><methods><class-id>Database.OracleLargeObjectBuffer class</class-id> <category>class initialization</category><body package="OracleEXDI">initialize	"OracleLargeObjectBuffer initialize"	self install.</body></methods><methods><class-id>Database.UnableToReleaseStatement</class-id> <category>printing</category><body package="OracleEXDI">defaultMessageText	^(#unableToReleaseStatement &lt;&lt; #oracleDB &gt;&gt; 'Unable to release statement.') asString</body></methods><methods><class-id>Database.UnableToInitializeInterfaceLibrary</class-id> <category>printing</category><body package="OracleEXDI">defaultMessageText	^(#errInitializeInterfaceLibrary &lt;&lt; #oracleDB &gt;&gt; 'Unable to initialize interface library.') asString</body></methods><methods><class-id>Database.UnsupportedAttributeGet</class-id> <category>printing</category><body package="OracleEXDI">defaultMessageText	^(#unsupportedAttributeGet &lt;&lt; #oracleDB &gt;&gt; 'Getting the specified attribute is not supported.') asString</body></methods><methods><class-id>Database.UnableToLockObjectReference</class-id> <category>printing</category><body package="OracleEXDI">defaultMessageText	^(#errLockObjectReference &lt;&lt; #oracleDB &gt;&gt; 'Unable to lock object reference.') asString</body></methods><methods><class-id>Database.OracleMacOSX64Interface class</class-id> <category>private</category><body package="OracleEXDI">platformSymbol	"this must contain the platform symbol that will	match that returned by determinePlatformType."	^#macOSX64</body></methods><methods><class-id>Database.UnableToTrimLobData</class-id> <category>printing</category><body package="OracleEXDI">defaultMessageText	^(#errTrimLobData &lt;&lt; #oracleDB &gt;&gt; 'Unable to trim LOB data.') asString</body></methods><methods><class-id>Database.UnableToAllocateResource</class-id> <category>printing</category><body package="OracleEXDI">defaultMessageText	^(#errAllocateResource &lt;&lt; #oracleDB &gt;&gt; 'Unable to allocate a resource.') asString</body></methods><methods><class-id>Database.OracleRefCursorBuffer</class-id> <category>initialize-release</category><body package="OracleEXDI">columnDescription: colDescr count: allocCount session: aSession	| internalType externalType elemSize |	internalType := colDescr internalType.	externalType := internalType.		elemSize := colDescr dbsize.	nullsPossible := colDescr nullable.	self session: aSession.	self elementSize: elemSize count: allocCount databaseType: externalType</body><body package="OracleEXDI">initialize	"Initialize an instance of the receiver."	super initialize.	self session: nil</body></methods><methods><class-id>Database.OracleRefCursorBuffer</class-id> <category>private-data conversion</category><body package="OracleEXDI">getRefCursorAt: index	| stmtPointerPointer stmtPointer aSession |	stmtPointerPointer := self pointer.	stmtPointer := stmtPointerPointer refAt: index -1.	aSession := self session connection getSession.	aSession hstmt: stmtPointer contents.	aSession herr: self session connection herr.	aSession state: #ready.	^aSession</body></methods><methods><class-id>Database.OracleRefCursorBuffer</class-id> <category>allocation</category><body package="OracleEXDI">free	"Free the external resources held by this buffer."	| stmtPointerPointer stmtPointer |	stmtPointerPointer := self pointer.	stmtPointerPointer notNil ifTrue: [		stmtPointerPointer isValid ifTrue: [			1 to: self count do: [:index |				stmtPointer := stmtPointerPointer refAt: index - 1.				self session connection freeHandlePointerExternal: stmtPointer type: #OCI_HTYPE_STMT.			].		].	].	super free.</body><body package="OracleEXDI">mallocForRowBuffer	[ "Begin unwind protection"	| allocCount pointerBase needRcodes |	allocCount := (count == 0 ifTrue: [ 1 ] ifFalse: [ count ]).	needRcodes := nullsPossible.	"Allocate a properly typed buffer pointer."	bufferPointer := self allocStmtHandle: allocCount.	"Allocate for all the remaining arrays in one block."	indicatorsPointer := self allocShortArray: allocCount * ( needRcodes ifTrue: [ 3 ] ifFalse: [ 2 ] ).	pointerBase := indicatorsPointer referentAddress.	lengthsPointer := CPointer new			newDatum: pointerBase + (allocCount * 2)			ofType: DefaultUnsignedShortPointerType.	pointerBase := lengthsPointer referentAddress.	needRcodes ifTrue:		[ rcodesPointer := CPointer new			newDatum: pointerBase + (allocCount * 2)			ofType: DefaultUnsignedShortPointerType ].	"End unwind protection" ]		ifCurtailed:			[ self free ].	getSelector := GetSelectorMap at: databaseType ifAbsent: [nil]</body></methods><methods><class-id>Database.OracleRefCursorBuffer</class-id> <category>private allocation</category><body package="OracleEXDI">allocStmtHandle: numElements 	"Initialize statement handles for Ref Cursors."	| xif stmtPointerPointer stmtPointer |	xif := self session class xif.		["Begin unwind protection (1)"		stmtPointerPointer := xif OCIStmt pointerType perform: xif mallocSelector with: numElements.		1 to: numElements do:[:index | 			stmtPointer := stmtPointerPointer refAt: index - 1.			self session connection allocHandlePointerExternal: stmtPointer type: #OCI_HTYPE_STMT.		].	"End unwind protection (1)"] ifCurtailed: [		1 to: numElements do: [:index | 			stmtPointer := stmtPointerPointer refAt: index - 1.			self session connection freeHandlePointerExternal: stmtPointer type: #OCI_HTYPE_STMT.		].		stmtPointerPointer freePointer	].	^stmtPointerPointer</body></methods><methods><class-id>Database.OracleMacOSXInterface class</class-id> <category>private</category><body package="OracleEXDI">platformSymbol	^#macOSX</body></methods><methods><class-id>Database.UnableToGetTimestampDate</class-id> <category>printing</category><body package="OracleEXDI">defaultMessageText	^(#unableToGetTimestampDate &lt;&lt; #oracleDB &gt;&gt; 'Unable to get timestamp date.') asString</body></methods><methods><class-id>Database.OracleLobProxy</class-id> <category>accessing</category><body package="OracleEXDI">count: anInteger	count := anInteger</body><body package="OracleEXDI">databaseType: anInteger	databaseType := anInteger</body><body package="OracleEXDI">defaultBufferSize	^32768		"32K, default buffer size for Large Objects."</body><body package="OracleEXDI">elementSize: anInteger	elementSize := anInteger</body><body package="OracleEXDI">session: aSession 	"Use a strong reference to the owning session object, so that it will not finalize before I do.	Note that unlike my superclass(es), I can be GC'd independent of the session's control, as	well as by my session."	session := Array with: aSession</body></methods><methods><class-id>Database.OracleLobProxy</class-id> <category>testing</category><body package="OracleEXDI">isBLOB	^self databaseType == 113.</body><body package="OracleEXDI">isCLOB	^self databaseType == 112.</body></methods><methods><class-id>Database.OracleLobProxy</class-id> <category>connections</category><body package="OracleEXDI">disconnect	self free</body></methods><methods><class-id>Database.OracleLobProxy</class-id> <category>printing</category><body package="OracleEXDI">printOn: aStream	super printOn: aStream.</body></methods><methods><class-id>Database.OracleLobProxy</class-id> <category>data processing {read}</category><body package="OracleEXDI">asText	self databaseType == 112 ifTrue: [			^self readAll asText.	].</body><body package="OracleEXDI">readAll	| bytes |	bytes := (self readFrom: 1 amount: (self getLobLength min: self session defaultDisplayLobSize)) contents.	self databaseType == 112 ifTrue: [			^bytes asStringEncoding: self encoding.	].	^bytes.</body></methods><methods><class-id>Database.OracleLobProxy</class-id> <category>initialize-release</category><body package="OracleEXDI">initialize	"Initialize an instance of the receiver."	super initialize.	elementSize := self defaultBufferSize. "Default buffer size"	count := 1.</body></methods><methods><class-id>Database.OracleLobProxy</class-id> <category>data processing {write}</category><body package="OracleEXDI">trimLobTo: length	| rtval conn xif herr hsvcctx lobLocatorPointer |	(conn := self getConnection) isNil ifTrue: [		^nil	].	xif           := conn class xif.     hsvcctx   := conn hsvcctx.	herr        :=  conn herr.	lobLocatorPointer := self lobLocator contents.     rtval := xif OCILobTrim: hsvcctx					    with: herr                            with: lobLocatorPointer 					    with: length.	self session traceLevel &gt;= 1 		ifTrue: 			[(self session traceStream)				print: rtval;				nextPutAll: ' = OCILobTrim( hsvcctx =';				nextPutAll: (hsvcctx referentAddress printStringRadix: 16);				nextPutAll: ', herr = ';				nextPutAll: (herr referentAddress printStringRadix: 16);				nextPutAll: ', lobLocator  = ';				nextPutAll: (lobLocatorPointer referentAddress printStringRadix: 16);				nextPutAll: ', length  = ';				nextPutAll: (length printStringRadix: 16);				crtab.			self session class trace: self session emitTrace].	(rtval == xif OCI_SUCCESS or: [ rtval == xif OCI_SUCCESS_WITH_INFO ] )		ifFalse: [ | errs |			   	  errs := conn getErrors.				  ^conn class unableToTrimLobDataSignal raiseWith: errs errorString: errs first dbmsErrorString ].	^length</body><body package="OracleEXDI">writeFrom: startingPosition with: aByteArray	| xif conn rtval bufferSize arraySize amountPointer lobEncoding utf16Size |	conn := self session connection.	xif := conn class xif.	arraySize := aByteArray size.	bufferSize := self elementSize.	lobEncoding := self encoding.	lobEncoding = #utf_16 ifTrue: [		utf16Size := (aByteArray asStringEncoding: lobEncoding) size.		amountPointer := utf16Size gcCopyToHeap.			] ifFalse: [		amountPointer := arraySize gcCopyToHeap	].	(arraySize &lt;= bufferSize) ifTrue: [		self setBuffer: (aByteArray copyFrom: 1 to: arraySize).		rtval := self writeLobDataExternalFrom: startingPosition amount: amountPointer piece: xif OCI_ONE_PIECE.	] ifFalse: [		self setBuffer: (aByteArray copyFrom: 1 to: bufferSize).		((rtval := self writeLobDataExternalFrom: startingPosition amount: amountPointer piece: xif OCI_FIRST_PIECE) == xif OCI_NEED_DATA) ifTrue: [ | beginPosition |			beginPosition := bufferSize + 1.			[((arraySize - beginPosition + 1) &gt; bufferSize)] whileTrue: [				self setBuffer: (aByteArray copyFrom: beginPosition to: (beginPosition + bufferSize - 1)).				rtval := self writeLobDataExternalFrom: startingPosition amount: amountPointer piece: xif OCI_NEXT_PIECE.				beginPosition := beginPosition + bufferSize.			].			self setBuffer: (aByteArray copyFrom: beginPosition to: arraySize).			rtval := self writeLobDataExternalFrom: startingPosition amount: amountPointer piece: xif OCI_LAST_PIECE bufferLength: (arraySize - beginPosition + 1).		].	].	(rtval == xif OCI_SUCCESS or: [ rtval == xif OCI_SUCCESS_WITH_INFO ] )		ifFalse: [ | errs |			   	  errs := conn getErrors.				  ^conn class unableToWriteLobDataSignal raiseWith: errs errorString: errs first dbmsErrorString  ].	^rtval</body></methods><methods><class-id>Database.OracleLobProxy</class-id> <category>allocation</category><body package="OracleEXDI">allocBuffer	bufferPointer := self allocStructuredBuffer: 1.</body><body package="OracleEXDI">free	"Free the external resources held by this lob locator. "	self lobLocator isNil 		ifFalse: [ super free ]</body></methods><methods><class-id>Database.OracleLobProxy</class-id> <category>private-finalization</category><body package="OracleEXDI">executor	"Answer with the executor."	| ex |	ex := super executor.	ex lobLocator: self lobLocator.	^ex</body><body package="OracleEXDI">finalize	"Release all external resource."	self free.</body></methods><methods><class-id>Database.OracleLobProxy class</class-id> <category>initialize-release</category><body package="OracleEXDI">newForLobLocator: aLobLocatorPointerPointer session: aSession lobType: anInteger	"Initialize Lob Proxy for an Large Objects (BLOB/CLOB)  ."	| aLobProxy xif conn herr rtval lobLocatorPointerPointer hsvcctx |	aLobProxy := self new.	aLobProxy databaseType: anInteger.	aLobProxy session: aSession.	aLobProxy elementSize: aSession lobBufferSize.	conn := aLobProxy session connection.	xif           := conn class xif.	hsvcctx := conn hsvcctx.	herr        :=  conn herr.	lobLocatorPointerPointer := xif OCILobLocator pointerType perform: xif mallocSelector	with: 1.	aLobProxy allocDescriptorForLobLocator: lobLocatorPointerPointer.	rtval := xif OCILobLocatorAssign: hsvcctx with: herr with: (aLobLocatorPointerPointer contents) with: lobLocatorPointerPointer.	aLobProxy session traceLevel &gt;= 1 ifTrue: [ 		(aLobProxy session traceStream)				print: rtval;				nextPutAll: ' = OCILobLocatorAssign( hsvcctx =';				nextPutAll: (hsvcctx referentAddress printStringRadix: 16);				nextPutAll: ', herr = ';				nextPutAll: (herr referentAddress printStringRadix: 16);				nextPutAll: ', lobLocator1  = ';				nextPutAll: ((aLobLocatorPointerPointer contents) referentAddress printStringRadix: 16);				nextPutAll: ', lobLocator2  = ';				nextPutAll: (lobLocatorPointerPointer referentAddress printStringRadix: 16);				crtab.			aLobProxy session class trace: aLobProxy session emitTrace].	rtval == xif OCI_SUCCESS 		ifFalse: 			[| errs |			errs := conn getErrors.			^conn class unableToAssignLobLocatorSignal raiseWith: errs errorString: errs first dbmsErrorString ].	aLobProxy lobLocator: lobLocatorPointerPointer.	aLobProxy allocBuffer.	aLobProxy session dependentLobs at: aLobProxy lobLocator asInteger put: aLobProxy.	^aLobProxy</body></methods><methods><class-id>Database.UnableToUnlockObjectReference</class-id> <category>printing</category><body package="OracleEXDI">defaultMessageText	^(#errUnlockObjectReference &lt;&lt; #oracleDB &gt;&gt; 'Unable to unlock object reference.') asString</body></methods><methods><class-id>Database.UnableToReadLobData</class-id> <category>printing</category><body package="OracleEXDI">defaultMessageText	^(#errReadLobData &lt;&lt; #oracleDB &gt;&gt; 'Unable to read LOB data.') asString</body></methods><methods><class-id>Database.StatementCachingNotSupported</class-id> <category>printing</category><body package="OracleEXDI">defaultMessageText	^(#statementCachingNotSupported &lt;&lt; #oracleDB &gt;&gt; 'Oracle Statement Caching Not Supported.') asString</body></methods><methods><class-id>Database.OracleTransaction</class-id> <category>private-finalization</category><body package="OracleEXDI">executor	^self shouldNotImplement</body><body package="OracleEXDI">finalizeExternal	^self shouldNotImplement</body><body package="OracleEXDI">key	^self shouldNotImplement</body></methods><methods><class-id>Database.OracleTransaction</class-id> <category>private-library calls</category><body package="OracleEXDI">acquireExternal	^self</body><body package="OracleEXDI">beginExternal	^self</body><body package="OracleEXDI">commitExternal	^self</body><body package="OracleEXDI">dismissExternal	^self</body><body package="OracleEXDI">rollbackExternal	^self</body></methods><methods><class-id>Database.OracleTransaction class</class-id> <category>accessing</category><body package="OracleEXDI">connectionClass	^OracleConnection</body></methods><methods><class-id>Database.UnableToAllocateDescriptor</class-id> <category>printing</category><body package="OracleEXDI">defaultMessageText	^(#errAllocateDescriptor &lt;&lt; #oracleDB &gt;&gt; 'Unable to allocate a descriptor.') asString</body></methods><methods><class-id>Database.UnableToWriteLobData</class-id> <category>printing</category><body package="OracleEXDI">defaultMessageText	^(#errWriteLobData &lt;&lt; #oracleDB &gt;&gt; 'Unable to write LOB data.') asString</body></methods><methods><class-id>Database.UnableToDescribeSchemaObject</class-id> <category>printing</category><body package="OracleEXDI">defaultMessageText	^(#unableToDescribeSchemaObject &lt;&lt; #oracleDB &gt;&gt; 'Unable to describe schema object.') asString</body></methods><methods><class-id>Database.UnableToGetLobLength</class-id> <category>printing</category><body package="OracleEXDI">defaultMessageText	^(#errGetLobLength &lt;&lt; #oracleDB &gt;&gt; 'Unable to get LOB length.') asString</body></methods><methods><class-id>Database.InvalidAttributeType</class-id> <category>printing</category><body package="OracleEXDI">defaultMessageText	^(#inavlidAttributeType &lt;&lt; #oracleDB &gt;&gt; 'Invalid attribute type') asString</body></methods><methods><class-id>Database.UnableToGetLobChunkSize</class-id> <category>printing</category><body package="OracleEXDI">defaultMessageText	^(#errGetLobChunkSize &lt;&lt; #oracleDB &gt;&gt; 'Unable to get lob chunk size.') asString</body></methods><methods><class-id>Database.OracleNT64Interface class</class-id> <category>private</category><body package="OracleEXDI">platformSymbol	"this must contain the platform symbol that will	match that returned by determinePlatformType."	^#nt64</body></methods><methods><class-id>Database.UnableToFreeDescriptor</class-id> <category>printing</category><body package="OracleEXDI">defaultMessageText	^(#errFreeDescriptor &lt;&lt; #oracleDB &gt;&gt; 'Unable to free a descriptor.') asString</body></methods><methods><class-id>Database.UnableToAssignLobLocator</class-id> <category>printing</category><body package="OracleEXDI">defaultMessageText	^(#errAssignLobLocator &lt;&lt; #oracleDB &gt;&gt; 'Unable to assign lob locator.') asString</body></methods><methods><class-id>Database.UnableToInitializeEnvironmentHandle</class-id> <category>printing</category><body package="OracleEXDI">defaultMessageText	^(#errInitializeEnvironmentHandle &lt;&lt; #oracleDB &gt;&gt; 'Unable to initialize environment handle.') asString</body></methods><methods><class-id>Database.UnableToReleaseExternalResource</class-id> <category>printing</category><body package="OracleEXDI">defaultMessageText	^(#errFreeExternalResource &lt;&lt; #oracleDB &gt;&gt; 'Unable to free an external resource.') asString</body></methods><methods><class-id>Database.OracleColumnDescription</class-id> <category>initialize-release</category><body package="OracleEXDI">initialize	precision := 0.	scale := 0.	isUnicodeColumn := false</body></methods><methods><class-id>Database.OracleColumnDescription</class-id> <category>accessing</category><body package="OracleEXDI">oracleInternalType	"Answer the internal type of the column, or nil if unknown"	^internalType</body></methods><methods><class-id>Database.OracleColumnDescription</class-id> <category>private-accessing</category><body package="OracleEXDI">dbsize	^dbsize</body><body package="OracleEXDI">dbsize: anInteger	dbsize := anInteger</body><body package="OracleEXDI">internalType	^internalType</body><body package="OracleEXDI">internalType: anInteger	internalType := anInteger</body><body package="OracleEXDI">isUnicodeColumn	^isUnicodeColumn</body><body package="OracleEXDI">isUnicodeColumn: aBoolean	isUnicodeColumn := aBoolean</body></methods><methods><class-id>Database.OracleColumnDescription</class-id> <category>private-testing</category><body package="OracleEXDI">isCursor	^internalType == 116</body><body package="OracleEXDI">isLargeObject	^((internalType == 112) or: [internalType == 113]) or: [internalType == 114]</body><body package="OracleEXDI">isTimestamp	^internalType == 187 or: [internalType == 188]</body></methods><methods><class-id>Database.OracleColumnDescription class</class-id> <category>instance creation</category><body package="OracleEXDI">new	^super new initialize</body></methods><methods><class-id>Database.OracleSession</class-id> <category>initialize-release</category><body package="OracleEXDI">initialize	super initialize.	hstmtHolder := nil asValue.	herrHolder := nil asValue.	bindValuePointersHolder := nil asValue.	definePointerHolder := nil asValue.	bindPointerHolder := nil asValue.	dependentLobs := WeakDictionary new.	sqlPointerHolder := nil asValue.	isReleasedFromCacheHolder := true asValue.	self maxLongBytes: 32768.		"32K, Default for LONG and LONG RAW buffer size."	self answerLobAsValue.	defaultDisplayLobSize := 32768.  "32768 bytes of data, default size for returned Large Objects, can be reset."	self lobBufferSize: 32768.  "32768 bytes of data, default buffer size for read/write Large Objects."	self reuseColumnBuffers: false</body></methods><methods><class-id>Database.OracleSession</class-id> <category>accessing</category><body package="OracleEXDI">answerLobProxy	^answerLobProxy</body><body package="OracleEXDI">answerLobProxy: aBoolean	answerLobProxy := aBoolean</body><body package="OracleEXDI">bindInput: aBindObject 	super bindInput: aBindObject.	self needBinding: true.</body><body package="OracleEXDI">bindInput: aBindObject template: template	"Supply aBindObject as the object from which input values should be 	obtained for host variable references in the SQL text.  Host variables	may be specified using either a positional or a named notation.  The	driver may limit to only one form.	When using the positional form (a ?), all host variable references (including	the named ones) are implicitly ordered by their position in the SQL-text.	The n-th variable of aBindObject is used for the n-th host variable reference.	If aBindObject has both instance variables and indexed variables, only the	indexed variables will be used. 	When using the named form, the leading colon is removed and the name is	expected to be an accessing method on aBindObject (i.e. aBindObject is sent	perform: with the name converted to a symbol as the argument)."	super bindInput: aBindObject.	bindTemplate := template.</body><body package="OracleEXDI">bindOutput: aBindObject template: template	"Specify the bind object used for returned rows."	super bindOutput: aBindObject.	resultTemplate := template.</body><body package="OracleEXDI">blockFactor: aSmallInteger	| newBlockFactor |	newBlockFactor := aSmallInteger min: 10000.	(blockFactor isNil or: [newBlockFactor &gt; blockFactor]) 		ifTrue: [self releaseBuffers].	blockFactor := newBlockFactor</body><body package="OracleEXDI">defaultDisplayLobSize	^defaultDisplayLobSize</body><body package="OracleEXDI">defaultDisplayLobSize: anInteger	defaultDisplayLobSize := anInteger</body><body package="OracleEXDI">dependentLobs	^dependentLobs</body><body package="OracleEXDI">dependentLobs: aWeakDictionary	dependentLobs := aWeakDictionary.</body><body package="OracleEXDI">encoding	^self connection encoding</body><body package="OracleEXDI">lobBufferSize	^lobBufferSize</body><body package="OracleEXDI">lobBufferSize: anInteger	lobBufferSize := anInteger</body><body package="OracleEXDI">maxBindSize	^maxBindSize ifNil: [ maxBindSize := 1] ifNotNil: [ maxBindSize ]</body><body package="OracleEXDI">maxBindSize: anInteger	maxBindSize := anInteger</body><body package="OracleEXDI">maxLongBytes	"Answer the maximum number of bytes which will be	fetched for a LONG or LONG RAW field."	^maxLongBytes</body><body package="OracleEXDI">maxLongBytes: aSmallInteger	"Set the maximum number of bytes which should be	fetched for a LONG or LONG RAW field.  If the application	expects more than the default number of bytes, this value	should be increased.  If the application expects fewer bytes,	some savings in memory use may be achieved by reducing this	number.  The savings is significant if the blockFactor is set	to a large number."	"2 is the smallest number of bytes which can be bound for a column"	maxLongBytes := 2 max: aSmallInteger</body><body package="OracleEXDI">removeCurrentStatementFromCache	"Releases the current statement handle from statement cache.	The caller is expected to assign a new value (or nil) to hstmt."	| xif rtval |	xif := self class xif.	(self useStatementCaching and: [ self hstmt notNil ]) ifTrue: [ 		self isReleasedFromCache ifTrue: [ 			rtval := xif OCI_SUCCESS. 		] ifFalse: [			rtval := xif OCIStmtRelease: self hstmt				with: self herr				with: nil				with: 0				with: xif OCI_STRLS_CACHE_DELETE.			traceLevel &gt;= 1 				ifTrue: 				[(self traceStream)					print: rtval;					nextPutAll: ' = OCIStmtRelease( hstmt =';					nextPutAll: (self hstmt referentAddress printStringRadix: 16);					nextPutAll: ', herr =';					nextPutAll: (self herr referentAddress printStringRadix: 16);					nextPutAll: ', key = ';					print: nil;					nextPutAll: ', length  = ';					print: 0;					nextPutAll: ', mode = OCI_STRLS_CACHE_DELETE)';					crtab.				self class trace: self emitTrace].			self isReleasedFromCache: true.		].		rtval == xif OCI_SUCCESS ifFalse:		[ | errs | 		errs := self getStatementErrors.		^self class connectionClass unableToReleaseStatementSignal raiseWith: errs errorString: errs first dbmsErrorString].	].</body><body package="OracleEXDI">reuseColumnBuffers	^reuseColumnBuffers</body><body package="OracleEXDI">reuseColumnBuffers: aBoolean	reuseColumnBuffers := aBoolean</body><body package="OracleEXDI">scrollable: aBoolean	"Determines whether the cursor is scrollable or not."	aBoolean ifTrue: [		self hasScrollableCursorSupport ifTrue: [			scrollable := true.		] ifFalse: [			self connection class unsupportedCursorTypeSignal raiseRequest.			scrollable := false.		].	] ifFalse: [		scrollable := false.	].</body><body package="OracleEXDI">traceLevel	^traceLevel</body></methods><methods><class-id>Database.OracleSession</class-id> <category>data processing</category><body package="OracleEXDI">answerLobAsProxy	self answerLobProxy: true</body><body package="OracleEXDI">answerLobAsValue	self answerLobProxy: false</body><body package="OracleEXDI">bindVariable: name	"Answer the value of a PL/SQL variable."	| buffer |	buffer := self bindValuePointers at: name ifAbsent: [ self error: (#errUnboundVariable &lt;&lt; #oracleDB &gt;&gt; 'unbound variable') ].		(buffer isKindOf: self class) ifTrue: [		^buffer	] ifFalse: [		^buffer value	]</body><body package="OracleEXDI">bindVariable: name value: value	"Set the value of a PL/SQL variable."	| type |	(value isKindOf: self class) ifFalse: [		type := (value oracleConversion == #Array)			ifTrue: [ self findRightBindingType: value ]			ifFalse: [ value oracleConversion ].	].	self bindVariable: name value: value type: type size: nil</body><body package="OracleEXDI">bindVariable: name value: value type: type size: size 	"Set the value of a PL/SQL variable.	The  type is restricted to the classes {String, ByteArray, Integer,	Double, Float, Timestamp} or the Symbols {String, ByteArray,	Char (Oracle7's blank padded behavior), Timestamp, Float, Double,	Integer32 (32-bit signed integer), Integer, FixedPoint, MLSLABEL}	If size is nil, use a default."	| conv count buffer |	(value isKindOf: self class) ifTrue: [ 		self bindValuePointers at: name put: value.		self bindExternal: value at: name.		self bindValues at: name put: value.		^self.	].	"Binding an empty array is not allowed."	( (value oracleConversion == #Array) and: [ value size == 0 ]) ifTrue: [ self class connectionClass unableToBindSignal raise]. 	((type isSymbol) or: [type isNil]) ifTrue: [conv := type] ifFalse: [conv := type name].	value oracleConversion == #Array 		ifTrue: [count := value size]		ifFalse: [count := 0	"scalar"].	(buffer := self bindValuePointers at: name ifAbsent: [nil]) notNil ifTrue: [		(buffer needsReallocation: value) ifTrue:		["We'll recreate the buffer"			self bindValuePointers removeKey: name.			buffer free.			buffer := nil]		ifFalse: [			[buffer value: value] 					on: self connection class externalDatabaseErrorSignal					do: 						[:ex | 						self bindValuePointers removeKey: name.						buffer free.						buffer := nil.						ex return]].		].	buffer == nil ifTrue: [ 		buffer := (( type == #Timestamp or: [ self valueIsTimestamp: value ]) ifTrue: [ self class timestampBufferClass ] ifFalse: [self class bufferClass ]) new.		bindTemplate isNil ifFalse: [			(bindTemplate at: name) == #UnicodeString ifTrue: [				buffer isUnicodeColumn: true.			]		].		buffer session: self;			encoding: buffer encoding.		buffer	 for: value				conv: conv				count: count				size: size.		buffer mallocForParameter.		self bindValuePointers at: name put: buffer.		"Bind the buffer first so that LONG VARCHAR/VARRAW max lengths		are still in the first 4 bytes of the buffer."		self bindExternal: buffer at: name.		buffer value: value]</body><body package="OracleEXDI">bindVariableAsLob: name value: value type: type	"Set the value of a PL/SQL LOB variable.	The  type is restricted to the classes {String, ByteArray} or the	Symbols {String, ByteArray}.	If size is nil, use a default."	| conv count buffer |	type isSymbol ifTrue: [conv := type] ifFalse: [conv := type name].	value oracleConversion == #Array 		ifTrue: [count := value size]		ifFalse: [count := 0	"scalar"].	(buffer := self bindValuePointers at: name ifAbsent: [nil]) notNil 		ifTrue: 			[[buffer value: value] 				on: self connection class externalDatabaseErrorSignal				do: 					[:ex | 					self bindValuePointers removeKey: name.					buffer free.					buffer := nil.					ex return]].	buffer == nil 	ifTrue: [		buffer := self class largeObjectBufferClass new					lobFor: value					conv: conv					count: count.		buffer session: self;		encoding: buffer encoding;				mallocForParameter.		self bindValuePointers at: name put: buffer.		"Bind the buffer first so that LONG VARCHAR/VARRAW max lengths		are still in the first 4 bytes of the buffer."		self bindExternal: buffer at: name.	]</body><body package="OracleEXDI">prepare: aString	queryIsPLSQL := false.	super prepare: aString.</body><body package="OracleEXDI">preparePLSQL: aString	queryIsPLSQL := true.	super prepare: aString</body><body package="OracleEXDI">rowCount	"Answer the row(s) affected by the last session transaction."	^self connection getAttribute: #OCI_ATTR_ROW_COUNT descriptor: self hstmt type: #OCI_HTYPE_STMT.</body><body package="OracleEXDI">setDefaultDisplayLobSizeTo: anInteger	self defaultDisplayLobSize: anInteger</body><body package="OracleEXDI">startPrepare	"Get the receiver into a reasonable state to prepare a new SQL statement."	| stateTemp |	"Should we clean up after any previous work?"	self isExecuting ifTrue:		[ self cancel ].	"If not already held, acquire the right to execute SQL statements."	(self state == #new ) ifTrue:		[ self connect ] .	"Enforce: we're in a legal state to prepare new SQL text."	(( stateTemp := self state) == #connected	or: [ stateTemp == #prepared ] ) ifFalse:		[ self class connectionClass invalidSessionStateSignal raise ].	self reuseColumnBuffers ifFalse: [		"Release any previously held buffers and adaptors."		self releaseBuffersAndAdaptors.	].	"Previous bind parameters are now invalid."	self releaseBindings.	"Drop the old query texts."	query := nil.	queryFragments := nil.	(self state == #prepared )		ifTrue: [ "Drop the current hstmt and acquire a new one.				hopefully this will cause the resources associated with				it to be released (i.e. cursors are closed)."				self hstmt: nil.				self acquireExternal ].	"Default to a connected state"	self state: #connected</body></methods><methods><class-id>Database.OracleSession</class-id> <category>printing</category><body package="OracleEXDI">printOn: aStream	| hstmt |	super printOn: aStream.	((hstmt := self hstmt) isNil or: [ hstmt referentAddress isNil ]) ifFalse:		[ aStream 	nextPutAll: '( hstmt = ';					nextPutAll: (hstmt referentAddress printStringRadix: 16);					nextPutAll: ' )' ]</body></methods><methods><class-id>Database.OracleSession</class-id> <category>private-accessing</category><body package="OracleEXDI">bindPointer	^bindPointerHolder value.</body><body package="OracleEXDI">bindPointer: aCPointerOrNil	bindPointerHolder value: aCPointerOrNil</body><body package="OracleEXDI">bindPointerHolder	^bindPointerHolder</body><body package="OracleEXDI">bindPointerHolder: aValueHolder	bindPointerHolder := aValueHolder</body><body package="OracleEXDI">bindValuePointersHolder	^bindValuePointersHolder</body><body package="OracleEXDI">bindValuePointersHolder: aValueHolder	bindValuePointersHolder := aValueHolder</body><body package="OracleEXDI">currentRowIndex	^currentRowIndex</body><body package="OracleEXDI">currentRowIndex: anInteger	currentRowIndex := anInteger</body><body package="OracleEXDI">definePointer	^definePointerHolder value.</body><body package="OracleEXDI">definePointer: aCPointerOrNil	definePointerHolder value: aCPointerOrNil</body><body package="OracleEXDI">definePointerHolder	^definePointerHolder</body><body package="OracleEXDI">definePointerHolder: aValueHolder	definePointerHolder := aValueHolder</body><body package="OracleEXDI">fetchAbsoluteMode	^self class xif OCI_FETCH_ABSOLUTE</body><body package="OracleEXDI">fetchNextMode	^self class xif OCI_FETCH_NEXT</body><body package="OracleEXDI">fetchPriorMode	^self class xif OCI_FETCH_PRIOR</body><body package="OracleEXDI">fetchRelativeMode	^self class xif OCI_FETCH_RELATIVE</body><body package="OracleEXDI">freePointers	self definePointer notNil ifTrue: [		 self definePointer freePointer.		 self definePointer: nil.	].	self bindPointer notNil ifTrue: [		 self bindPointer freePointer.		 self bindPointer: nil.	].</body><body package="OracleEXDI">herr	^herrHolder value</body><body package="OracleEXDI">herr: aCPointerOrNil	herrHolder value: aCPointerOrNil</body><body package="OracleEXDI">herrHolder	^herrHolder</body><body package="OracleEXDI">herrHolder: aValueHolder	herrHolder := aValueHolder</body><body package="OracleEXDI">hstmt	^hstmtHolder value.</body><body package="OracleEXDI">hstmt: aCPointerOrNil	"Release the current statement handle, and accept a new one, or nil.	If using statement caching, the stmt caching api must do the release."		| hstmt |	((hstmt := self hstmt) isNil or: [hstmt referentAddress isNil])		ifFalse:			[self useStatementCaching				ifTrue: [self releaseCurrentStatementFromCache]				ifFalse: [ (hstmt contents = aCPointerOrNil ) ifFalse: [self unprotectedFreeHstmt]]].	hstmtHolder value: aCPointerOrNil</body><body package="OracleEXDI">hstmtHolder	^hstmtHolder</body><body package="OracleEXDI">hstmtHolder: aValueHolder	hstmtHolder := aValueHolder</body><body package="OracleEXDI">hstmtKind	^self connection getAttribute: #OCI_ATTR_STMT_TYPE descriptor: self hstmt type: #OCI_HTYPE_STMT.</body><body package="OracleEXDI">isReleasedFromCache	^isReleasedFromCacheHolder value</body><body package="OracleEXDI">isReleasedFromCache: aBoolean	isReleasedFromCacheHolder value: aBoolean</body><body package="OracleEXDI">isReleasedFromCacheHolder	^isReleasedFromCacheHolder</body><body package="OracleEXDI">isReleasedFromCacheHolder: aValueHolder	isReleasedFromCacheHolder := aValueHolder</body><body package="OracleEXDI">releaseCurrentStatementFromCache	"Releases the current statement handle from statement cache.	The caller is expected to assign a new value (or nil) to hstmt."	| xif rtval |	xif := self class xif.	(self useStatementCaching and: [ self hstmt notNil ]) ifTrue: [ 		self isReleasedFromCache ifTrue: [ 			rtval := xif OCI_SUCCESS. 		] ifFalse: [			rtval := xif OCIStmtRelease: self hstmt				with: self herr				with: nil				with: 0				with: xif OCI_DEFAULT.			traceLevel &gt;= 1 				ifTrue: 				[(self traceStream)					print: rtval;					nextPutAll: ' = OCIStmtRelease( hstmt =';					nextPutAll: (self hstmt referentAddress printStringRadix: 16);					nextPutAll: ', herr =';					nextPutAll: (self herr referentAddress printStringRadix: 16);					nextPutAll: ', key = ';					print: nil;					nextPutAll: ', length  = ';					print: 0;					nextPutAll: ', mode = OCI_DEFAULT)';					crtab.				self class trace: self emitTrace].				self isReleasedFromCache: true.			].		rtval == xif OCI_SUCCESS ifFalse:		[ | errs | 		errs := self getStatementErrors.		^self class connectionClass unableToReleaseStatementSignal raiseWith: errs errorString: errs first dbmsErrorString].	].</body><body package="OracleEXDI">rowsInBlock	"Answer number of rows fetched in current block."	^rowsInBlock</body><body package="OracleEXDI">rowsInBlock: aSmallInteger	"Record number of rows fetched in current block."	rowsInBlock := aSmallInteger</body><body package="OracleEXDI">sqlPointerHolder	^sqlPointerHolder</body><body package="OracleEXDI">sqlPointerHolder: aValueHolder	sqlPointerHolder := aValueHolder</body><body package="OracleEXDI">totalRows	^totalRows</body><body package="OracleEXDI">totalRows: anInteger	totalRows := anInteger</body></methods><methods><class-id>Database.OracleSession</class-id> <category>private-answer set</category><body package="OracleEXDI">aboutToAnswer	"Do last-minute work before fetching data from an answer set"	totalRows := 0.	self rowsInBlock: 0.	self currentRowIndex: 0.</body><body package="OracleEXDI">acquireBuffers	"Acquire buffers for fetching the answer set from the server."	| buffers |	"Buffers will only exist here if they're OK to reuse."	self rowBuffers notNil ifTrue: [ 		self defineRowBuffers. 		^self 	].	buffers := Array new: numColumns.	[ "Begin unwind protection."	1 to: numColumns do:		[ :column |		buffers at: column put: (self allocateRowBufferExternal: column) ].	"End unwind protection." ]		ifCurtailed:			[ "give back any pointers we might have acquired as none will be used."			1 to: numColumns do:				[ :col | | buf |				(buf := buffers at: col) notNil ifTrue:					[ buf free ] ] ].	self rowBuffers: buffers</body><body package="OracleEXDI">advanceExternal	"Advance to the next row in the block buffer.  If the buffer is exhausted, refill it and continue.  Do not let currentRowIndex scroll more than one above the beginning (or be more than one below the end).  If no data was found, rowsInBlock will have been set to 0, making the #between:and: interval empty.  If "	(self currentRowIndex between: 0 and: self rowsInBlock)		ifTrue: [self currentRowIndex: self currentRowIndex + 1].	"Return nil if no more rows will be found ..."	(self rowsInBlock = 0		ifTrue: [self currentRowIndex = 1 ifFalse: [^nil] ifTrue: [true]]		ifFalse: [self currentRowIndex &gt; self rowsInBlock])			ifTrue:				[| rc |				(self rowsInBlock &lt; self blockFactor and: [self rowsInBlock &gt; 0])					ifTrue: [^nil].				rc := self getBlockOfRowsExternal.				(self rowsInBlock &lt;= 0 or: [rc isNil])					ifTrue: [^nil].				self currentRowIndex: 1].	"... otherwise return self."</body><body package="OracleEXDI">advanceExternal: fetchOrientation offset: fetchOffset	"Advance to the next row in the block buffer.  If the buffer is exhausted,	refill it and continue."	self scrollable ifFalse: [		self connection class unsupportedCursorTypeSignal raiseRequest.		^nil	].	fetchOrientation == self fetchNextMode ifTrue: [		self currentRowIndex: (self currentRowIndex + 1).	] ifFalse: [		fetchOrientation == self fetchPriorMode ifTrue: [			(self currentRowIndex = 0 and: [ self rowsInBlock = 0 ]) ifTrue: [ ^nil ].			self currentRowIndex &gt; 0  ifTrue: [ self currentRowIndex: (self currentRowIndex - 1) ].		] ifFalse: [			fetchOrientation == self fetchAbsoluteMode ifTrue: [				self currentRowIndex: (self blockFactor + 2).				self rowsInBlock: (self blockFactor + 1).			] ifFalse: [				fetchOrientation == self fetchRelativeMode ifTrue: [					self currentRowIndex: (self currentRowIndex + fetchOffset).				].			].		].	].	((self currentRowIndex &gt; self rowsInBlock) or: [ self currentRowIndex &lt;= 0 ])		ifTrue:	[ | rc |				rc := self getBlockOfRowsExternal: fetchOrientation offset: fetchOffset.				(rc isNil or: [ self rowsInBlock &lt;= 0 ])					ifTrue:	[ ^nil		"No more rows will be found" ].					fetchOrientation == self fetchPriorMode ifTrue: [						self currentRowIndex: self rowsInBlock .					] ifFalse: [						self currentRowIndex: 1.					].			].	^self</body><body package="OracleEXDI">allocateRowBufferExternal: aColumn 	"Allocate an OracleBuffer to receive data for aColumn.  Answer the buffer."	| colDescr buffer |	colDescr := columnDescriptions at: aColumn.	buffer := colDescr isLargeObject ifFalse: [		colDescr isCursor ifTrue: [			(self class refCursorBufferClass new )				columnDescription: colDescr				count: self blockFactor				session: self		] ifFalse: [			( ( colDescr isTimestamp ifTrue: [ self class timestampBufferClass ] ifFalse: [ self class bufferClass ] ) new ) 					session: self;					columnDescription: colDescr					count: self blockFactor					maxLongBytes: self maxLongBytes		]	] ifTrue: [		(self class largeObjectBufferClass new )			columnDescription: colDescr			count: self blockFactor			session: self	].	buffer encoding: buffer encoding;		mallocForRowBuffer.	self defineRowBufferExternal: aColumn buffer: buffer.	^buffer</body><body package="OracleEXDI">answerOfClass: anAnswerStreamClass	"Answer an instance of the given subclass of ExternalDatabaseAnswerStream"	"Assert: anAnswerStreamClass isKindOf: ExternalDatabaseAnswerStream"	| initialAnswer |	initialAnswer := ( self state == #ready ).	self state: #validResults.	initialAnswer		ifTrue:	[ "Verify that the query executed without error."				self resultsExternal ifFalse: [ ^#noAnswerStream ] ]		ifFalse:	[ "If we're still holding on to a prior answer stream, dismiss it."				answerStream notNil					ifTrue:	[ answerStream close ].				"Assert: self state == #validResults"				self moreResultsExternal					ifFalse:	[ self state: #prepared.							^#noMoreAnswers ] ].	self hasAnswerSetExternal		ifTrue:	[ | answer |				initialAnswer ifFalse:					[ "Previous descriptions/buffers are no longer valid"					self releaseBuffers.					self releaseAdaptors.					self columnDescriptions: nil ].				self getColumnDescriptions.				self acquireBuffers.				self setupAdaptors.				self aboutToAnswer.				answer := anAnswerStreamClass newForSession: self.				self answerStream: answer.				self state: #fetchingData.				^answer ].	^#noAnswerStream.</body><body package="OracleEXDI">answerStreamDismissed	"Close the cursor and discard pending results."	super answerStreamDismissed.</body><body package="OracleEXDI">cancelAnswerSetExternal	"Explicity cancel current or previous query results."	| xif  rtval errs hstmt herr |	xif := self class xif.	hstmt := self hstmt.	herr := self herr.	self useStatementCaching ifTrue: [		rtval := xif OCIStmtFetch2: hstmt				with: herr				with: 0				with: xif OCI_FETCH_NEXT				with: 1				with: xif OCI_DEFAULT.	traceLevel &gt;= 2 		ifTrue: 			[(self traceStream)				print: rtval;				nextPutAll: ' = OCIStmtFetch2( hstmt =';				nextPutAll: (hstmt referentAddress printStringRadix: 16);				nextPutAll: ', herr = ';				nextPutAll: (herr referentAddress printStringRadix: 16);				nextPutAll: ' , nrows = 0 ';				nextPutAll: ' , orientation = OCI_FETCH_NEXT ';				nextPutAll: ' , fetchOffset = 1 ';				nextPutAll: ' , mode = OCI_DEFAULT)'.			self class trace: self emitTrace].	] ifFalse: [		rtval := xif OCIStmtFetch: hstmt 						with: herr 						with: 0						with: xif OCI_FETCH_NEXT					     with: xif OCI_DEFAULT.		(traceLevel &gt;= 2) ifTrue: 			[ (self traceStream)			print: rtval; nextPutAll: ' = OCIStmtFetch( hstmt =';			nextPutAll: (hstmt referentAddress printStringRadix: 16);			nextPutAll: ', herr = ';			nextPutAll: (herr referentAddress printStringRadix: 16);			nextPutAll: ' , nrows = 0 ';			nextPutAll: ' , orientation = OCI_FETCH_NEXT '; 			nextPutAll: ' , mode = OCI_DEFAULT)'.			self class trace: self emitTrace].	].	(rtval == xif OCI_NO_DATA)		ifTrue: [	"Try to flush the server's error list"				self getStatementErrors.			     	^nil.  ].	(rtval == xif OCI_SUCCESS	or: [rtval == xif OCI_SUCCESS_WITH_INFO])		ifFalse: [ errs := self getStatementErrors.			       ^self class connectionClass unableToFetchDataSignal raiseWith: errs errorString: errs first dbmsErrorString ].				 	^self</body><body package="OracleEXDI">defineRowBufferExternal: aColumn buffer: aBuffer	| xif rtval |	xif := self class xif.	self definePointer isNil ifTrue: [		self definePointer: (xif OCIDefine pointerType perform: xif mallocSelector with: 1).		self definePointer contents: (xif OCIDefine pointerType cast: nil). "This is essential!!"	].	rtval := xif 				OCIDefineByPos: self hstmt				with: self definePointer				with: self herr				with: aColumn				with: aBuffer pointer				with: aBuffer elementSize				with: aBuffer databaseType				with: aBuffer indicatorsPointer				with: aBuffer lengthsPointer				with: aBuffer rcodesPointer				with: xif OCI_DEFAULT.	rtval == xif OCI_SUCCESS 		ifFalse: 			[| errs |			errs := connection getErrors.			^self connection class unableToBindSignal raiseWith: errs errorString: errs first dbmsErrorString].	aBuffer isUnicodeColumn ifTrue: [		self connection setAttribute: xif SQLCS_NCHAR type: #OCI_ATTR_CHARSET_FORM 				descriptor: self definePointer contents type: #OCI_HTYPE_DEFINE	] ifFalse: [		self connection setAttribute: xif SQLCS_IMPLICIT type: #OCI_ATTR_CHARSET_FORM 				descriptor: self definePointer contents type: #OCI_HTYPE_DEFINE	].</body><body package="OracleEXDI">defineRowBuffers	| buffers |	buffers := self rowBuffers.	1 to: buffers size do: [ :aColumn | | aBuffer |		aBuffer := buffers at: aColumn.		self defineRowBufferExternal: aColumn buffer: aBuffer	]</body><body package="OracleEXDI">describeAnswerColumns	"Fill in the columnDescriptions array."	| columnCount colDescrStream hdescriptor |	columnCount := 0.	colDescrStream := WriteStream  on: (Array new: 512).	[(hdescriptor := self connection getSchemaObjectAttributeFromDescriptorExternal: self hstmt 										type: #OCI_HTYPE_STMT startingAt: (columnCount := columnCount + 1)) notNil ]		whileTrue: [   | colDescr internalSize internalType charsetForm xif | "Retrieve type from descriptor; describe if necessary."					(colDescr := self class columnDescriptionClass new) 						index: columnCount;						name:  (self connection getAttribute: #OCI_ATTR_NAME 										   descriptor: hdescriptor type: #OCI_DTYPE_PARAM);						dbsize: (internalSize := self connection getAttribute: #OCI_ATTR_DATA_SIZE 											  descriptor: hdescriptor type: #OCI_DTYPE_PARAM);						internalType: (internalType := self connection getAttribute: #OCI_ATTR_DATA_TYPE 											  descriptor: hdescriptor type: #OCI_DTYPE_PARAM);						type: (self class typeFor: internalType);						maxColumnConstraint: internalSize;						precision: (self connection getAttribute: #OCI_ATTR_PRECISION 											   descriptor: hdescriptor type: #OCI_DTYPE_PARAM);						scale: (self connection getAttribute: #OCI_ATTR_SCALE 										    descriptor: hdescriptor type: #OCI_DTYPE_PARAM);						nullable: (self connection getAttribute: #OCI_ATTR_IS_NULL 										   descriptor: hdescriptor type: #OCI_DTYPE_PARAM) == 1.						charsetForm := self connection getAttribute: #OCI_ATTR_CHARSET_FORM 											descriptor: hdescriptor type: #OCI_DTYPE_PARAM.						xif := self class xif.						charsetForm = xif SQLCS_NCHAR ifTrue: [							colDescr isUnicodeColumn: true						].					colDescrStream nextPut: colDescr ].	self numColumns: columnCount - 1.	self columnDescriptions: (columnCount &gt; 0 ifTrue: [ colDescrStream contents ] ifFalse: [ nil ]).</body><body package="OracleEXDI">getBlockOfRowsExternal	"Fetch the next block of rows into the memory allocated for this purpose.  If the block was full but we fetched no data, return nil.  If the block was not full, we are unlikely to be called;  a partially-filled block tells the caller that the previous call had exhausted the answer set's rows."	| xif  rtval errs hstmt herr priorTotal |	priorTotal := self totalRows.	xif := self class xif.	hstmt := self hstmt.	herr := self herr.	self useStatementCaching ifTrue: [		rtval := xif OCIStmtFetch2: hstmt				with: herr				with: blockFactor				with: xif OCI_FETCH_NEXT				with: 1				with: xif OCI_DEFAULT.	traceLevel &gt;= 2 		ifTrue: 			[(self traceStream)				print: rtval;				nextPutAll: ' = OCIStmtFetch2( hstmt =';				nextPutAll: (hstmt referentAddress printStringRadix: 16);				nextPutAll: ', herr = ';				nextPutAll: (herr referentAddress printStringRadix: 16);				nextPutAll: ' , nrows = '; print: blockFactor;				nextPutAll: ' , orientation = OCI_FETCH_NEXT ';				nextPutAll: ' , fetchOffset = 1 ';				nextPutAll: ' , mode = OCI_DEFAULT)'.			self class trace: self emitTrace].	] ifFalse: [		rtval := xif OCIStmtFetch: hstmt 						with: herr 						with: blockFactor						with: xif OCI_FETCH_NEXT					     with: xif OCI_DEFAULT.		(traceLevel &gt;= 2) ifTrue: 			[ (self traceStream)			print: rtval; nextPutAll: ' = OCIStmtFetch( hstmt =';			nextPutAll: (hstmt referentAddress printStringRadix: 16);			nextPutAll: ', herr = ';			nextPutAll: (herr referentAddress printStringRadix: 16);			nextPutAll: ' , nrows = '; print: blockFactor;			nextPutAll: ' , orientation = OCI_FETCH_NEXT '; 			nextPutAll: ' , mode = OCI_DEFAULT)'.			self class trace: self emitTrace].	].	self totalRows: (self connection getAttribute: #OCI_ATTR_ROW_COUNT 							descriptor: hstmt type: #OCI_HTYPE_STMT).	self scrollable ifTrue:			[| fetchedRows |		fetchedRows := self connection getAttribute: #OCI_ATTR_ROWS_FETCHED 								descriptor: hstmt type: #OCI_HTYPE_STMT.		"If we fetched no rows but the block was full, return nil to advise the caller."		(rtval == xif OCI_NO_DATA and: [self blockFactor = self totalRows and: [fetchedRows = 0]]) ifTrue: [^nil].		self rowsInBlock: fetchedRows.	] ifFalse: [		self rowsInBlock: (self totalRows - priorTotal).	].	(rtval == xif OCI_NO_DATA)		ifTrue: [^self].	(rtval == xif OCI_SUCCESS	or: [rtval == xif OCI_SUCCESS_WITH_INFO]) ifFalse:[ 		errs := self getStatementErrors.		^self class connectionClass unableToFetchDataSignal raiseWith: errs errorString: errs first dbmsErrorString 	].	^self</body><body package="OracleEXDI">getBlockOfRowsExternal: fetchOrientation offset: fetchOffset	"Fetch the next block of rows into the memory allocated for this purpose."	| xif  rtval errs hstmt herr newFetchMode newOffset |	xif := self class xif.	hstmt := self hstmt.	herr := self herr.	fetchOrientation == self fetchPriorMode ifTrue: [ | rowNumberBeforeFetch |		rowNumberBeforeFetch := self connection getAttribute: #OCI_ATTR_CURRENT_POSITION descriptor: hstmt type: #OCI_HTYPE_STMT.		(rowNumberBeforeFetch = self blockFactor or: [ self blockFactor &gt; self totalRows and: [rowNumberBeforeFetch = self totalRows]]) ifTrue: [ ^nil ].		newFetchMode := self fetchRelativeMode.		newOffset := 1 - self blockFactor - rowsInBlock.	] ifFalse: [		fetchOrientation == self fetchRelativeMode ifTrue: [			newFetchMode := fetchOrientation.			self currentRowIndex: (self currentRowIndex - fetchOffset).			newOffset := fetchOffset - self rowsInBlock + self currentRowIndex.		] ifFalse: [			newFetchMode := fetchOrientation.			newOffset := fetchOffset.		].	].	rtval := xif OCIStmtFetch2: hstmt 						with: herr 						with: blockFactor						with: newFetchMode						with: newOffset					      with: xif OCI_DEFAULT.	(traceLevel &gt;= 2) ifTrue: 		[ (self traceStream)		print: rtval; nextPutAll: ' = OCIStmtFetch( hstmt =';		nextPutAll: (hstmt referentAddress printStringRadix: 16);		nextPutAll: ', herr = ';		nextPutAll: (herr referentAddress printStringRadix: 16);		nextPutAll: ' , nrows = '; print: blockFactor;		nextPutAll: ' , orientation = OCI_FETCH_NEXT '; 		nextPutAll: ' , mode = OCI_DEFAULT)'.		self class trace: self emitTrace].	self totalRows: (self connection getAttribute: #OCI_ATTR_ROW_COUNT 										   descriptor: hstmt type: #OCI_HTYPE_STMT).	self rowsInBlock: (self connection getAttribute: #OCI_ATTR_ROWS_FETCHED 										   descriptor: hstmt type: #OCI_HTYPE_STMT).	(rtval == xif OCI_NO_DATA)		ifTrue: [	^self.  ].	(rtval == xif OCI_SUCCESS	or: [rtval == xif OCI_SUCCESS_WITH_INFO]) ifFalse:[ 		errs := self getStatementErrors.		^self class connectionClass unableToFetchDataSignal raiseWith: errs errorString: errs first dbmsErrorString 	].	^self</body><body package="OracleEXDI">getColumnDescriptions	"Get descriptions for the columns in the answer set"	"If column descriptions exist, they're safe to re-use."	( columnDescriptions == nil ) ifFalse: [ ^self ].	self describeAnswerColumns."	( resultTemplate == nil )		ifTrue: [ self describeAnswerColumns ]		ifFalse: [ self answerColumnsFromTemplate ]"</body><body package="OracleEXDI">getFieldExternal: aColumn 	| buffer |	buffer := (self rowBuffers) at: aColumn.		^buffer at: ((self currentRowIndex - 1) \\ self blockFactor) + 1</body><body package="OracleEXDI">getFieldExternal: aColumn template: template	| buffer |	buffer := (self rowBuffers) at: aColumn.		^buffer valueViaTemplate: template</body><body package="OracleEXDI">hasAnswerSetExternal	^(self hstmtKind == self class xif OCI_STMT_SELECT )</body><body package="OracleEXDI">releaseBuffers	"Release buffers and their associated resources."	| rbs |	(rbs := self rowBuffers) notNil ifTrue: [1 to: rbs size do: [:aColumn | (rbs at: aColumn) session: self; free]].	super releaseBuffers</body><body package="OracleEXDI">releaseBuffersAndAdaptors	"Release buffers, adaptors, and their associated resources."	"Subclasses may release subclass-specific resources before invoking this method."	"Discard previous buffers, descriptors, and adaptors, but not lob proxies"	self releaseBuffers.	self releaseAdaptors.	self columnDescriptions: nil.	self numColumns: nil.</body><body package="OracleEXDI">releaseDependentLobs	"Release dependent LOB resources."	| depLobs |	(depLobs := self dependentLobs) isEmpty ifFalse: [		depLobs associationsDo: [:ass | | val |				val := ass value.				(val isKindOf: OracleLobProxy) ifTrue: [ val session: self; disconnect ].		]	].	self dependentLobs: WeakDictionary new.</body></methods><methods><class-id>Database.OracleSession</class-id> <category>private-binding</category><body package="OracleEXDI">bindExternal	queryIsPLSQL		ifTrue: [self bindPLSQL]		ifFalse: [self bindInputValues].</body><body package="OracleEXDI">bindExternal: buffer at: position	"Provide a positional binding to the OCI."	| rtval xif hCursor bufferPointer bufferSize bufferDatabaseType indicatorsPointer lengthsPointer rcodesPointer bufferCount bufferCursizPointer |	xif := self class xif.	self bindPointer isNil ifTrue: [		self bindPointer: ( xif OCIBind pointerType perform: xif mallocSelector with: 1).		self bindPointer contents: (xif OCIBind pointerType cast: nil ). "This is essential!!"	].	(buffer isKindOf: self class) ifTrue: [		hCursor := xif OCIStmt pointerType perform: xif mallocSelector with: 1.		self connection allocHandlePointerExternal: hCursor type: #OCI_HTYPE_STMT.		bufferPointer := hCursor.		bufferSize := 0.		bufferDatabaseType := xif SQLT_RSET.		indicatorsPointer := 0.		lengthsPointer := 0.		rcodesPointer := nil.		bufferCount := 0.		bufferCursizPointer := 0.		buffer hstmt: hCursor.	] ifFalse: [		bufferPointer := buffer pointer.		bufferSize := buffer boundedElementSize.		bufferDatabaseType := buffer databaseType.		indicatorsPointer := buffer indicatorsPointer.		lengthsPointer := buffer lengthsPointer.		rcodesPointer := buffer rcodesPointer.		bufferCount := (queryIsPLSQL ifTrue: [buffer count] ifFalse:[0]).		bufferCursizPointer := (queryIsPLSQL ifTrue: [buffer cursizPointer] ifFalse:[0]).	]. 	position isInteger ifTrue: [		rtval := xif OCIBindByPos: self hstmt 					with: self bindPointer					with: self connection herr					with: position					with: bufferPointer					with: bufferSize					with: bufferDatabaseType					with: indicatorsPointer					with: lengthsPointer					with: rcodesPointer					with: bufferCount					with: bufferCursizPointer					with: xif OCI_DEFAULT.	] ifFalse: [ | bindName |		bindName := position asByteArrayEncoding: buffer encoding.		rtval := xif OCIBindByName: self hstmt 					with: self bindPointer					with: self connection herr					with: bindName					with: bindName size					with: bufferPointer					with: bufferSize					with: bufferDatabaseType					with: indicatorsPointer					with: lengthsPointer					with: rcodesPointer					with: bufferCount					with: bufferCursizPointer					with: xif OCI_DEFAULT.	].	(rtval == xif OCI_SUCCESS)		ifFalse: [ | errs |			   		errs := connection getErrors.					^connection class unableToBindSignal raiseWith: errs errorString: errs first dbmsErrorString ].	 buffer isUnicodeColumn ifTrue: [		self connection setAttribute: xif SQLCS_NCHAR type: #OCI_ATTR_CHARSET_FORM 				descriptor: self bindPointer contents type: #OCI_HTYPE_BIND	] ifFalse: [		self connection setAttribute: xif SQLCS_IMPLICIT type: #OCI_ATTR_CHARSET_FORM 				descriptor: self bindPointer contents type: #OCI_HTYPE_BIND	].</body><body package="OracleEXDI">bindInputValues	"Bind input values in bindInput  For each bind marker in the query fragments, get the corresponding value from the bindInput object.  If the value isn't already bound, bind and remember it."	self bindInput isNil ifTrue: [^self].	self bindPrepare.	2 to: queryFragments size by: 2 do:		[:index || bindMarker value |		bindMarker := queryFragments at: index.		value := self inBindInputAt: bindMarker.		bindMarker isInteger			ifTrue:				[| bindPosition | bindPosition := index / 2.				((value isKindOf: self class) not and: [self boundValueAt: bindPosition is: value]) ifFalse:					[self bindValue: value at: bindPosition.					self bindValues at: bindPosition put: value]]			ifFalse:				[((value isKindOf: self class) not and: [self boundValueAt: bindMarker is: value]) ifFalse:					[self bindValue: value at: bindMarker.					self bindValues at: bindMarker put: value]]].</body><body package="OracleEXDI">bindNameFor: position	"Answer the textual name to use as a bind name for the given position."	| strm |	strm := WriteStream on: (String new: 16).	self bindNameFor: position on: strm.	^strm contents</body><body package="OracleEXDI">bindNameFor: position on: aStream	"Put the textual name to use as a bind name for the given position on aStream."	aStream nextPut: $:.	position isSymbol		ifTrue:			[ 	aStream nextPutAll: position ]		ifFalse:			[ 	aStream nextPut: $p.				aStream print: position ]</body><body package="OracleEXDI">bindPLSQL	"Bind values for a PL/SQL query. The officially correct way to bind for plsql is to use bindVariables (see the Database guide). However, we allow binding arrays too, especially for those PL/SQL queries where no OUT variables are used. So we check bind variables first, if they are not present, we will bind input arrays."	self bindValuePointers notEmpty		ifTrue: [self bindVariables]		ifFalse: [self bindInputValues]</body><body package="OracleEXDI">bindPrepare	"Examine the input bound values, and find the largest array,  assign maxBindSize so that all buffers will acquire this capacity."	| bindInputAsArray |	bindInputAsArray := OrderedCollection new.	2 to: queryFragments size by: 2 do: [ :index | | bindMarker value |		bindMarker := queryFragments at: index.		value := self inBindInputAt: bindMarker.		bindInputAsArray add: value.	].	self maxBindSize: ( bindInputAsArray inject: 0 into:							[ :currentMax :nextValue | | nextSize |							nextSize := (nextValue oracleConversion == #Array)								ifTrue: [nextValue size] 								ifFalse: [1].							nextSize max: currentMax]).</body><body package="OracleEXDI">bindValue: aValue at: position 	"Bind aValue to the given position."	| buffer |	(aValue isKindOf: self class) ifFalse: [		(buffer := self bindValuePointers at: position ifAbsent: [nil]) notNil ifTrue: 		[			(buffer needsReallocation: aValue) 			ifTrue:			["We'll recreate the buffer."			self bindValuePointers removeKey: position.			buffer free.			buffer := nil]			ifFalse: 			[				[buffer value: aValue] on: self connection class unableToBindSignal					do: 					[:ex | 						self bindValuePointers removeKey: position.						buffer free.						buffer := nil.						ex return]			]		].		buffer isNil ifTrue: [			buffer := ((self valueIsTimestamp: aValue) ifTrue: [ self class timestampBufferClass ] ifFalse: [self class bufferClass ]) new.			buffer session: self.			bindTemplate isNil ifFalse: [				(bindTemplate at: (self bindMarkerAtPosition: position)) == #UnicodeString ifTrue: [					buffer isUnicodeColumn: true.				]			].			(self maxBindSize &gt; 1) ifTrue: [				buffer for: aValue 				conv: aValue oracleConversion				count: self maxBindSize				size: nil.			] ifFalse: [				buffer for: aValue				conv: aValue oracleConversion				count: 0				size: nil.			].			buffer encoding: buffer encoding.			buffer mallocForParameter.			self bindValuePointers at: position put: buffer.			"Bind the buffer first so that LONG VARCHAR/VARRAW max lengths			are still in the first 4 bytes of the buffer."			buffer value: aValue].					] ifTrue: [				buffer := aValue.			].		self bindExternal: buffer at: position.</body><body package="OracleEXDI">bindValuePointers	"Answer with the receiver's bind pointer array."	| bvph |	(bvph := self bindValuePointersHolder) value isNil		ifTrue: [ bvph value: IdentityDictionary new ].	^bvph value</body><body package="OracleEXDI">bindVariables	"Bind variables for a PL/SQL query."	| bound position |	self bindValuePointers isEmpty ifFalse: [		position := 0.		bound := IdentitySet new: self bindValuePointers capacity.		2 to: queryFragments size by: 2 do:		[ :index | | bindMarker buffer |			position := position + 1.			bindMarker := queryFragments at: index.			( bound includes: bindMarker ) ifFalse:				[ buffer := self bindValuePointers at: bindMarker ifAbsent: [ nil ].			buffer isNil ifTrue:				[ ^self connection class missingBindVariableSignal raise ].			bound add: bindMarker ] ]	]</body><body package="OracleEXDI">findRightBindingType: anArray	"Answer the conversion type fitting all elements of anArray"	| types |	types := OrderedCollection new.	anArray do: [:each |	| type |			(type := each oracleConversion) notNil ifTrue: [ (types includes: type) ifFalse: [ types add: type]]	].	types size = 1 ifTrue: [^types first].	(types includes: #Double) ifTrue: [		( (types includes: #FixedPoint) or: [ types includes: #Integer ]) ifTrue: [			self connection class inconsistentDataTypesInArrayBindingSignal raise.		] ifFalse: [			^#Double		]	].	(types includes: #FixedPoint) ifTrue: [		(types includes: #Float) ifTrue: [			self connection class inconsistentDataTypesInArrayBindingSignal raise.		] ifFalse: [			^#FixedPoint		]	].	(types includes: #Integer) ifTrue: [		(types includes: #Float) ifTrue: [			self connection class inconsistentDataTypesInArrayBindingSignal raise.		] ifFalse: [			^#Integer		]	].	(types includes: #Float) ifTrue: [		(types includes: #Integer32) ifTrue: [			^#Double		] ifFalse: [			^#Float		]	].	(types includes: #Integer32) ifTrue: [		^#Integer	].	^nil</body><body package="OracleEXDI">prepareExternal	"Prepare the query for execution via OCIStatmentPrepare or OCIStmtPrepare2."		| sql xif herr sqlBytes sqlPointer rtval |	herr := self herr.	queryFragments size == 1		ifTrue: [sql := queryFragments at: 1]		ifFalse:			[| sqlStream |			sqlStream := WriteStream on: (String new: query size * 2).			sqlStream nextPutAll: (queryFragments at: 1).			2 to: queryFragments size by: 2 do:				[:index | 				sqlStream					nextPutAll: (self bindNameFor: (queryFragments at: index));					nextPutAll: (queryFragments at: index + 1)].			sql := sqlStream contents].	xif := self class xif.	sqlBytes := ByteArray		fromString: sql		encoding: connection encoding.	sqlPointer := sqlBytes perform: xif copyToHeapSelector.	self sqlPointerHolder value: sqlPointer.	self useStatementCaching		ifTrue:			[| hstmtPointerPointer |			["Begin unwind protection (1)"			hstmtPointerPointer := xif OCIStmt pointerType				perform: xif mallocSelector				with: 1.			rtval := xif				OCIStmtPrepare2: self connection hsvcctx				with: hstmtPointerPointer				with: self herr				with: sqlPointer				with: sqlBytes size				with: nil				with: 0				with: xif OCI_NTV_SYNTAX				with: xif OCI_DEFAULT.			self hstmt: hstmtPointerPointer contents.			self isReleasedFromCache: false.			traceLevel &gt;= 1				ifTrue:					[(self traceStream)						print: rtval;						nextPutAll: ' = OCIStmtPrepare2( hsvcctx =';						nextPutAll:								(self connection hsvcctx referentAddress printStringRadix: 16);						nextPutAll: ', hstmt =';						nextPutAll: (self hstmt referentAddress printStringRadix: 16);						nextPutAll: ', herr =';						nextPutAll: (herr referentAddress printStringRadix: 16);						nextPutAll: ', SQL = ';						nextPutAll: sql;						nextPutAll: ', length  = ';						print: sqlBytes size;						nextPutAll: ', key = ';						print: nil;						nextPutAll: ', length  = ';						print: 0;						nextPutAll: ', syntax = OCI_NTV_SYNTAX,  mode = OCI_DEFAULT)';						crtab.					self class trace: self emitTrace]	"End unwind protection (1)"]				ensure:					[hstmtPointerPointer == nil ifFalse: [hstmtPointerPointer freePointer]]]		ifFalse:			[| hstmt |			hstmt := self hstmt.			rtval := xif				OCIStmtPrepare: hstmt				with: self herr				with: sqlPointer				with: sqlBytes size				with: xif OCI_NTV_SYNTAX				with: xif OCI_DEFAULT.			traceLevel &gt;= 1				ifTrue:					[(self traceStream)						print: rtval;						nextPutAll: ' = OCIStmtPrepare( hstmt =';						nextPutAll: (hstmt referentAddress printStringRadix: 16);						nextPutAll: ', herr =';						nextPutAll: (herr referentAddress printStringRadix: 16);						nextPutAll: ', SQL = ';						nextPutAll: sql;						nextPutAll: ', length  = ';						print: sqlBytes size;						nextPutAll: ', syntax = OCI_NTV_SYNTAX,  mode = OCI_DEFAULT)';						crtab.					self class trace: self emitTrace]].	rtval == xif OCI_SUCCESS		ifFalse:			[| errs |			errs := self getStatementErrors.			^self class connectionClass unableToPrepareSignal				raiseWith: errs				errorString: errs first dbmsErrorString]</body><body package="OracleEXDI">releaseBindings	| bvp sqlPointer bInput |	(sqlPointer := self sqlPointerHolder value) notNil 		ifTrue: 			[sqlPointer freePointer.			self sqlPointerHolder value: nil].	((bvp := self bindValuePointersHolder value) isKindOf: Collection)		ifTrue: 			[bvp do: [:each | each notNil ifTrue: [			(each isKindOf: self class) ifTrue: [				each disconnect			] ifFalse: [				each session: self; free			]]].			self bindValuePointersHolder value: nil].	((bInput := self bindInput) isKindOf: Collection) 		ifTrue: 			[bInput do: [:each | each notNil ifTrue: [			(each isKindOf: self class) ifTrue: [				each disconnect			]]]].	super releaseBindings</body></methods><methods><class-id>Database.OracleSession</class-id> <category>private-execution</category><body package="OracleEXDI">cancelExternal	"Handle cleanup when current query is cancelled."	^self</body><body package="OracleEXDI">dismissExternal	"Release external resources held."		[ (self connection inTransactionMode )		ifFalse: [ self connection commit ].	  "If the connection is in object mode, flush the cache." 	"self connection flushObjectCacheExternal."	] ensure: [	self hstmt: nil.				self herr: nil]</body><body package="OracleEXDI">executeExternal	| rtval xif hsvcctx hstmt herr  iterations rowOffset mode |	xif := self class xif.	hsvcctx := self connection hsvcctx.	hstmt := self hstmt.	herr := self herr.	rowOffset := 0.	self scrollable ifTrue: [		mode := xif OCI_STMT_SCROLLABLE_READONLY.				] ifFalse: [		mode := xif perform: self connection executionMode.	].      iterations := (self isSELECT ) ifTrue: [0 ] ifFalse: [ 			(((self bindValuePointersHolder value) isNil) or: [ queryIsPLSQL ] ) ifTrue: [ 				1 			] ifFalse: [ 				self maxBindSize 			]	].	rtval := xif OCIStmtExecute: hsvcctx					  	    with: hstmt						    with: herr						    with: iterations						    with: rowOffset						    with: 0						    with: 0						    with: mode.	( traceLevel &gt;= 1 ) ifTrue:		[ (self traceStream)			print: rtval;  			nextPutAll: ' = OCIStmtExecute( hsvcctx =';			nextPutAll: (hsvcctx referentAddress printStringRadix: 16);			nextPutAll: ', hstmt ='; 			nextPutAll: (hstmt referentAddress printStringRadix: 16);			nextPutAll: ', herr ='; 			nextPutAll: (herr referentAddress printStringRadix: 16);			nextPutAll: ', iterations ='; print: iterations;			nextPutAll: ', rowOffset ='; print: rowOffset;			nextPutAll: ', snap_shot_in = NULL, snap_shot_out = NULL '; 			nextPutAll: ', mode = '; 			nextPutAll: mode printString;			nextPutAll: ')';crtab.		self class trace: self emitTrace ].	rtval == xif OCI_SUCCESS ifFalse:	[ self resultsCache: self getStatementErrors.	  self resultsExternal ].	( connection inTransactionMode )   		ifFalse: ["If we're not in a multi-statement transaction, then just committed manually iff		  		  the following is true:."		  		  self isSELECT						ifFalse: [ connection commit ] ].	self processRefCursors.</body><body package="OracleEXDI">getError: returnValue	"Take the prevailing error information and prepare it to be	used as the parameter to an exception."	^Array with: returnValue</body><body package="OracleEXDI">installExternal		super installExternal.	self hstmt: nil.	self herr: nil</body><body package="OracleEXDI">moreResultsExternal	"There are never any more results."	^false</body><body package="OracleEXDI">processRefCursors	| bindCursors bindVariables |	bindCursors := OrderedCollection new.	((bindVariables := self bindValuePointers values) isKindOf: Collection) ifTrue: [		bindCursors addAll: (bindVariables select: [ :each | each isKindOf: self class ]).	].	((bindVariables := self bindInput) isKindOf: Collection) ifTrue: [		bindCursors addAll: (bindVariables select: [ :each | each isKindOf: self class ]).	] ifFalse: [ | numOfVars | 		numOfVars := bindVariables class instSize.		numOfVars &gt; 0 ifTrue: [			1 to: numOfVars do: [ :index | | each |				each := bindVariables instVarAt: index. 				(each isKindOf: self class) ifTrue: [				 	bindCursors add: each.				]			]		]	].	bindCursors do: [ :each | | pStmt |		pStmt := each hstmt.		pStmt isNil ifFalse: [			each hstmt: pStmt contents.			each herr: self connection herr.			self connection freeHandlePointerExternal: pStmt type: #OCI_HTYPE_STMT.			pStmt freePointer.			each state: #ready		]	].</body><body package="OracleEXDI">readyExternal	^true</body><body package="OracleEXDI">resultsExternal	| errs |	(errs := self resultsCache) notNil ifTrue: 		[ | errorParameter error signal connClass |		errorParameter := self getError: errs first.		error := errorParameter first.		signal := (connClass := connection class)					perform: (connClass signalMap							at: error dbmsErrorCode abs							ifAbsent: [ #unableToExecuteSQLSignal ]). 		signal mayResume ifTrue: [			signal			raiseRequestWith: errorParameter			errorString: (' \' withCRs, error dbmsErrorString).		] ifFalse: [ 			signal			raiseWith: errorParameter			errorString: (' \' withCRs, error dbmsErrorString).		].		^false ].	^true</body></methods><methods><class-id>Database.OracleSession</class-id> <category>private-finalization</category><body package="OracleEXDI">executor	"Answer with the executor."	| ex |	ex := super executor.	ex hstmtHolder: self hstmtHolder.	ex herrHolder: self herrHolder.	ex bindValuePointersHolder: self bindValuePointersHolder.	ex definePointerHolder: self definePointerHolder.	ex bindPointerHolder: self bindPointerHolder.	ex sqlPointerHolder: self sqlPointerHolder.	ex dependentLobs: self dependentLobs.	ex isReleasedFromCacheHolder: self isReleasedFromCacheHolder.	^ex</body><body package="OracleEXDI">finalizeExternal	"Release all external resource."	| hstmt |	self releaseBuffersAndAdaptors.	self releaseDependentLobs.	self releaseBindings.	self freePointers.	((hstmt := self hstmt) isNil or: [ hstmt referentAddress isNil ])		ifTrue: [ ^self ].	( traceLevel &gt;= 1 ) ifTrue:		[ self class trace: nil ].	super finalizeExternal</body><body package="OracleEXDI">key	"The cursorHolder is unique to the session and is constant	across pause/resume."	^self hstmtHolder</body></methods><methods><class-id>Database.OracleSession</class-id> <category>private-testing</category><body package="OracleEXDI">hasScrollableCursorSupport	"Answer true is the loaded OCI has scrollable cursor support."	^self connection class supportMethod: #OCIStmtFetch2:with:with:with:with:with:.</body><body package="OracleEXDI">isDDL	"Answer true if the SQL statement type indicates that we are processing a 	ALTER , CREATE, DROP."	^#[	7		"self connection class xif OCI_STMT_ALTER"		5		"self connection class xif OCI_STMT_CREATE"		6		"self connection class xif OCI_STMT_DROP"	   ] includes: self hstmtKind</body><body package="OracleEXDI">isDML	"Answer true if the SQL statement type indicates that we are processing a  	INSERT, UPDATE, DELETE."	^#[	4		"self connection class xif OCI_STMT_INSERT"		2		"self connection class xif OCI_STMT_UPDATE"		3		"self connection class xif OCI_STMT_DELETE"	   ] includes: self hstmtKind</body><body package="OracleEXDI">isPLSQL	"Answer true if the SQL statement type indicates that we are processing a  	PL/SQL BEGIN DECLARE operation ."		^#[	8		"self connection class xif OCI_STMT_BEGIN"		9		"self connection class xif OCI_STMT_DECLARE"	   ] includes: self hstmtKind</body><body package="OracleEXDI">isSELECT	"Answer true if the SQL statement type indicates that we are processing a 	QUERY."	^(self hstmtKind == 1 "OCI_STMT_SELECT" )</body><body package="OracleEXDI">isUnicodeColumn	^false</body><body package="OracleEXDI">isUnicodeEncoding	| encodingString |	encodingString := self connection encoding asUppercase.	^((encodingString beginsWith: 'UTF') or: [ encodingString beginsWith: 'UCS' ])</body><body package="OracleEXDI">useStatementCaching	"Answer true if we are using statement caching."	^self connection useStatementCaching</body><body package="OracleEXDI">valueIsTimestamp: aValue	"Answer true if the value is a Timestamp or an Array of Timestamp. "	| convSymbol |	convSymbol := aValue oracleConversion.	((convSymbol == #Timestamp) and: [ aValue year ~~ 0 ]) ifTrue: [ ^true ].	(convSymbol == #Array) ifTrue: [ | representativeElement |		representativeElement := aValue detect: [:each | each notNil] ifNone: [nil].		((representativeElement oracleConversion == #Timestamp) and: [ representativeElement year ~~ 0 ]) ifTrue: [ ^true ]	].	^false</body></methods><methods><class-id>Database.OracleSession</class-id> <category>private-results cache</category><body package="OracleEXDI">resultsCache	"Answer the contents of the results cache. Clear after accessing."	| results |	results := resultsCache.	self resultsCache: nil.	^results</body><body package="OracleEXDI">resultsCache: results	"Cache the results."	resultsCache := results</body></methods><methods><class-id>Database.OracleSession</class-id> <category>private-handles</category><body package="OracleEXDI">unprotectedAllocHstmt	| xif hstmtPointerPointer |	xif := self class xif.	["Begin unwind protection (1)"	hstmtPointerPointer := xif OCIStmt pointerType perform: xif mallocSelector with: 1.	connection allocHandlePointerExternal: hstmtPointerPointer type: #OCI_HTYPE_STMT.	self hstmtHolder value: hstmtPointerPointer contents.	"End unwind protection (1)"] 		ensure: [ hstmtPointerPointer == nil 										ifFalse: [ hstmtPointerPointer freePointer ] ]</body><body package="OracleEXDI">unprotectedFreeHstmt	connection freeHandlePointerExternal:  self hstmt type: #OCI_HTYPE_STMT</body></methods><methods><class-id>Database.OracleSession</class-id> <category>private-error accessing</category><body package="OracleEXDI">getStatementErrors	"Return a collection of OracleOCIError(s) associated with the statement 	handle."	^connection getErrors</body><body package="OracleEXDI">parseErrorOffset	"Answer the location in the query string where the parser says there was an error."	^self connection getAttribute: #OCI_ATTR_PARSE_ERROR_OFFSET descriptor: self hstmt type: #OCI_HTYPE_STMT.</body></methods><methods><class-id>Database.OracleSession</class-id> <category>private-activation</category><body package="OracleEXDI">dismiss	self isExecuting ifTrue:		[ self cancel ].	self releaseBuffersAndAdaptors.	self releaseDependentLobs.	self releaseBindings.	self freePointers.	super dismiss.	connection removeParticipant: self</body><body package="OracleEXDI">quiesce	"Quiesce all connections to external resources."	self state == #paused ifTrue: [ ^self ].	answerStream notNil ifTrue:		[ answerStream dismiss ].	[ self dismiss ]		ensure:			[ self state: #paused ]</body></methods><methods><class-id>Database.OracleSession</class-id> <category>prefetch</category><body package="OracleEXDI">setPrefetchRows: anInteger 	"set the number of prefetched rows (possible only with OCI 8).	a setPrefetchRows: could be nice in OracleSession"	self connection 		setAttribute: anInteger		type: #OCI_ATTR_PREFETCH_ROWS		descriptor: self hstmt		type: #OCI_HTYPE_STMT</body></methods><methods><class-id>Database.OracleSession</class-id> <category>private-library calls</category><body package="OracleEXDI">acquireExternal	"Acquire external resources."		["Begin unwind protection."	self connection useStatementCaching ifFalse: [ self unprotectedAllocHstmt ].	self herr: self connection herr. 	"End unwind protection."]		ifCurtailed: [	self hstmt: nil.					self herr: nil]</body></methods><methods><class-id>Database.OracleSession class</class-id> <category>class initialization</category><body package="OracleEXDI">initialize	"OracleSession initialize"	self initRegistry.	(InternalDatatypeToClassMap := IdentityDictionary new)		add: ( 1 "VARCHAR2" -&gt; #String );		add: ( 2 "NUMBER" -&gt; #Number );		add: ( 8 "LONG" -&gt; #String );		add: ( 11 "ROWID" -&gt; #String );		add: ( 12 "DATE" -&gt; #Timestamp );		add: ( 23 "RAW" -&gt; #ByteArray );		add: ( 24 "LONG RAW" -&gt; #ByteArray );		add: ( 96 "CHAR" -&gt; #String );		add: ( 104 "ROWID" -&gt; #String );		add: ( 106 "MLSLABEL" -&gt; #String );		add: ( 112 "Character LOB" -&gt; #String );		add: ( 113 "Binary LOB" -&gt; #ByteArray );		add: ( 187 "TIMESTAMP" -&gt; #Timestamp ).</body></methods><methods><class-id>Database.OracleSession class</class-id> <category>private-accessing</category><body package="OracleEXDI">typeFor: aDatabaseType	"Answer the class which is equivalent to the database type: aDatabaseType."	^InternalDatatypeToClassMap at: aDatabaseType ifAbsent: [ nil ]</body></methods><methods><class-id>Database.OracleSession class</class-id> <category>private-registry</category><body package="OracleEXDI">registry	^RegisteredOracleSessions</body><body package="OracleEXDI">registry: aCollection	RegisteredOracleSessions := aCollection</body></methods><methods><class-id>Database.OracleSession class</class-id> <category>accessing</category><body package="OracleEXDI">bufferClass	"Answer the class to use for bindInput/Output objects associated with receiver."	^OracleBuffer</body><body package="OracleEXDI">columnDescriptionClass	^OracleColumnDescription</body><body package="OracleEXDI">connectionClass	"Answer the connection class for sessions"		^OracleConnection</body><body package="OracleEXDI">largeObjectBufferClass	"Answer the class to use for bindInput/Output objects associated with receiver."	^OracleLargeObjectBuffer</body><body package="OracleEXDI">refCursorBufferClass	"Answer the class to use for bindInput/Output objects associated with receiver."	^OracleRefCursorBuffer</body><body package="OracleEXDI">timestampBufferClass	"Answer the class to use for bindInput/Output objects associated with receiver."	^OracleTimestampBuffer</body></methods><methods><class-id>Database.OracleSession class</class-id> <category>private-activation</category><body package="OracleEXDI">install	self bufferClass install.</body></methods><methods><class-id>Database.OracleLinuxInterface class</class-id> <category>private</category><body package="OracleEXDI">platformSymbol	"this must contain the platform symbol that will	match that returned by determinePlatformType."	^#linux_i386_unix</body></methods><methods><class-id>Database.InconsistentDataTypesInArrayBinding</class-id> <category>printing</category><body package="OracleEXDI">defaultMessageText	^(#inconsistentDataTypesInArrayBinding &lt;&lt; #oracleDB &gt;&gt; 'Inconsistent data types in binding array.') asString</body></methods><methods><class-id>Database.OracleNTInterface</class-id> <category>constants</category><body package="OracleEXDI">ERROR_SUCCESS	^0</body><body package="OracleEXDI">HKEY_LOCAL_MACHINE	^16r80000002</body><body package="OracleEXDI">REG_EXPAND_SZ	^2</body><body package="OracleEXDI">REG_SZ	^1</body></methods><methods><class-id>Database.OracleNTInterface</class-id> <category>parameter</category><body package="OracleEXDI">getOracleParameterString: parameterName	"Answer the value of the named Oracle parameter, which must be a string.	If not present, answer the empty string."	| storedKey initialKey key buffer bufferSize count type errorCode parameterString environmentVariable |   	environmentVariable := super getOracleParameterString: parameterName.   	(environmentVariable isNil or: [environmentVariable isEmpty]) ifFalse: [^environmentVariable ].	bufferSize := 256.	parameterString := ''.	[buffer := CIntegerType char malloc: bufferSize.	count := CIntegerType long malloc.	type := CIntegerType unsignedLong "dword" malloc.	storedKey := CVoidType void pointerType malloc.	initialKey := CVoidType void pointerType malloc.	initialKey contents: (CVoidType void pointerType cast: self HKEY_LOCAL_MACHINE).	key := initialKey.	#('SOFTWARE' 'ORACLE') do:			[:subKey |			errorCode := self regOpenKey: key contents subKey: subKey result: storedKey.			errorCode = self ERROR_SUCCESS ifFalse: [^''].			key := storedKey].	count contents: bufferSize.	errorCode := self regQueryValueEx: key contents					name: parameterName					reserved: nil					type: type					data: buffer					size: count.	errorCode = self ERROR_SUCCESS ifFalse: [^''].	(type contents = self REG_EXPAND_SZ or: [type contents = self REG_SZ])		ifFalse: [^''].	parameterString := buffer copyCStringFromHeap]			valueNowOrOnUnwindDo:				[initialKey notNil ifTrue: [initialKey freePointer].				storedKey notNil ifTrue: [storedKey freePointer].				buffer notNil ifTrue: [buffer freePointer].				type notNil ifTrue: [type freePointer].				count notNil ifTrue: [count freePointer]].	^parameterString</body></methods><methods><class-id>Database.OracleNTInterface class</class-id> <category>private</category><body package="OracleEXDI">platformSymbol	"this must contain the platform symbol that will	match that returned by determinePlatformType."	^#nt</body></methods><methods><class-id>Database.UnableToSetStatementCacheSize</class-id> <category>printing</category><body package="OracleEXDI">defaultMessageText	^(#unableToSetStatementCacheSize &lt;&lt; #oracleDB &gt;&gt; 'Unable to set statement cache size.') asString</body></methods><methods><class-id>Database.OracleAIXInterface class</class-id> <category>private</category><body package="OracleEXDI">platformSymbol	"this must contain the platform symbol that will	match that returned by determinePlatformType."	^#aix_unix</body></methods><methods><class-id>Database.UnsupportedTransactionMode</class-id> <category>printing</category><body package="OracleEXDI">defaultMessageText	^(#unsupportedTransactionMode &lt;&lt; #oracleDB &gt;&gt; 'An attempt was made to set an unsupported transaction mode.') asString</body></methods><methods><class-id>Database.UnableToConstructTimestamp</class-id> <category>printing</category><body package="OracleEXDI">defaultMessageText	^(#unableToConstructTimestamp &lt;&lt; #oracleDB &gt;&gt; 'Unable to construct timestamp.') asString</body></methods><methods><class-id>Core.Object</class-id> <category>private-oracle</category><body package="OracleEXDI">oracleConversion	^nil</body></methods><methods><class-id>Core.String</class-id> <category>private-oracle</category><body package="OracleEXDI">oracleConversion	^#String</body></methods><methods><class-id>Core.Integer</class-id> <category>private-oracle</category><body package="OracleEXDI">oracleConversion	^#Integer</body></methods><methods><class-id>Core.FixedPoint</class-id> <category>private-oracle</category><body package="OracleEXDI">oracleConversion	^#FixedPoint</body></methods><methods><class-id>Core.ByteArray</class-id> <category>private-oracle</category><body package="OracleEXDI">oracleConversion	^#ByteArray</body></methods><methods><class-id>Core.SmallInteger</class-id> <category>private-oracle</category><body package="OracleEXDI">oracleConversion	"For now, keep the 32-bit image machinery in place, and use it for small values. Defer to the usual FixedPoint api for larger values."	^ObjectMemory is64Bit		ifTrue: 			[(self &gt;= -536870912 and: [self &lt;= 536870911])				ifTrue: [#Integer32]				ifFalse: [#Integer]]		ifFalse: [#Integer32]</body></methods><methods><class-id>Core.Double</class-id> <category>private-oracle</category><body package="OracleEXDI">oracleConversion	^#Double</body></methods><methods><class-id>Core.Timestamp</class-id> <category>private-oracle</category><body package="OracleEXDI">oracleConversion	^#Timestamp</body></methods><methods><class-id>Core.SmallDouble</class-id> <category>private-oracle</category><body package="OracleEXDI">oracleConversion	"Answer the symbolic conversion name for instances of this 	class or subclasses."	^#Double</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>private-oracle</category><body package="OracleEXDI">printStringForOracle	"Encode receiver in one character using a common Cobol paradigm."	^' '</body></methods><methods><class-id>Core.Boolean</class-id> <category>private-oracle</category><body package="OracleEXDI">printStringForOracle	"Encode receiver in one character using a common Cobol paradigm."	^self ifTrue: [ 'Y' ] ifFalse: [ 'N' ]</body></methods><methods><class-id>Core.Time</class-id> <category>private-oracle</category><body package="OracleEXDI">oracleConversion	^#Time</body></methods><methods><class-id>Core.Text</class-id> <category>private-oracle</category><body package="OracleEXDI">oracleConversion	^#String</body></methods><methods><class-id>Core.Float</class-id> <category>private-oracle</category><body package="OracleEXDI">oracleConversion	^#Float</body></methods><methods><class-id>Core.Date</class-id> <category>private-oracle</category><body package="OracleEXDI">oracleConversion	^#Date</body></methods><methods><class-id>Core.OrderedCollection</class-id> <category>private-oracle-or</category><body package="OracleEXDI">oracleConversion	^#Array</body></methods><methods><class-id>Core.Array</class-id> <category>private-oracle-or</category><body package="OracleEXDI">oracleConversion	^#Array</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>private-oracle-or</category><body package="OracleEXDI">oracleConversion	^#String</body></methods><methods><class-id>Core.Fraction</class-id> <category>private-oracle</category><body package="OracleEXDI">oracleConversion	^#Double</body></methods><methods><class-id>Database.OracleInterface</class-id> <category>procedures</category><body package="OracleEXDI">OCIAttrGet: trgthndlp with: trghndltyp with: attributep with: sizep with: attrtype with: errhp	&lt;C: sword OCIAttrGet(const void * trgthndlp, ub4 trghndltyp, void * attributep, ub4 * sizep, ub4 attrtype, OCIError * errhp)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="OracleEXDI">OCIAttrSet: trgthndlp with: trghndltyp with: attributep with: size with: attrtype with: errhp	&lt;C: sword OCIAttrSet(void * trgthndlp, ub4 trghndltyp, void * attributep, ub4 size, ub4 attrtype, OCIError * errhp)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="OracleEXDI">OCIClientVersion: major_version with: minor_version with: update_num with: patch_num with: port_update_num	&lt;C: sword OCIClientVersion( sword *major_version, sword *minor_version, sword *update_num, sword *patch_num, sword *port_update_num )&gt;	^self externalAccessFailedWith: _errorCode</body><body package="OracleEXDI">OCIDescribeAny: svchp with: errhp with: objptr with: objnm_len with: objptr_typ with: info_level with: objtyp  with: dschp 	&lt;C: sword OCIDescribeAny(OCISvcCtx * svchp, OCIError * errhp, const OraText * objptr, ub4 objnm_len, ub1 objptr_typ,  ub1 info_level, ub1 objtyp, OCIDescribe * dschp)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="OracleEXDI">OCIDescriptorAlloc: parenth with: descpp with: type with: xtramem_sz with: usrmempp	&lt;C: sword OCIDescriptorAlloc(const void * parenth, void * * descpp, ub4 type, size_t xtramem_sz, void * * usrmempp)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="OracleEXDI">OCIDescriptorFree: descp with: type	&lt;C: sword OCIDescriptorFree(void * descp, ub4 type)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="OracleEXDI">OCIEnvInit: envp with: mode with: xtramem_sz with: usrmempp	&lt;C: sword OCIEnvInit(OCIEnv * * envp, ub4 mode, size_t xtramem_sz, void * * usrmempp)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="OracleEXDI">OCIEnvNlsCreate: envp with: mode with: ctxp with: malocfp with: ralocfp with: mfreefp with: xtramemsz with: usrmempp with: charset with: ncharset	&lt;C: sword OCIEnvNlsCreate ( OCIEnv** envp, ub4 mode, void *ctxp, void * (*malocfp) (void *ctxp, size_t size), void * ( *ralocfp) (void *ctxp, void *memptr, size_t newsize), void (*mfreefp) (void *ctxp, void *memptr), size_t xtramemsz, void **usrmempp, ub2 charset, ub2 ncharset)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="OracleEXDI">OCIErrorGet: hndlp with: recordno with: sqlstate with: errcodep with: bufp with: bufsiz with: type	&lt;C: sword OCIErrorGet(void * hndlp, ub4 recordno, OraText * sqlstate, sb4 * errcodep, OraText * bufp, ub4 bufsiz, ub4 type)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="OracleEXDI">OCIHandleAlloc: parenth with: hndlpp with: type with: xtramem_sz with: usrmempp	&lt;C: sword OCIHandleAlloc(const void * parenth, void * * hndlpp, ub4 type, size_t xtramem_sz, void * * usrmempp)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="OracleEXDI">OCIHandleFree: hndlp with: type	&lt;C: sword OCIHandleFree(void * hndlp, ub4 type)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="OracleEXDI">OCIInitialize: mode with: ctxp with: malocfp with: ralocfp with: mfreefp	&lt;C: sword OCIInitialize(ub4 mode, void * ctxp, void *  (* malocfp)(void * ctxp, size_t size), void *  (* ralocfp)(void * ctxp, void * memptr, size_t newsize), void (* mfreefp)(void * ctxp, void * memptr))&gt;	^self externalAccessFailedWith: _errorCode</body><body package="OracleEXDI">OCIParamGet: hndlp with: htype with: errhp with: parmdpp with: pos	&lt;C: sword OCIParamGet(const void * hndlp, ub4 htype, OCIError * errhp, void * * parmdpp, ub4 pos)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="OracleEXDI">OCIServerAttach: srvhp with: errhp with: dblink with: dblink_len with: mode	&lt;C: sword OCIServerAttach(OCIServer * srvhp, OCIError * errhp, const OraText * dblink, sb4 dblink_len, ub4 mode)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="OracleEXDI">OCIServerDetach: srvhp with: errhp with: mode	&lt;C: sword OCIServerDetach(OCIServer * srvhp, OCIError * errhp, ub4 mode)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="OracleEXDI">OCIServerVersion: hndlp with: errhp with: bufp with: bufsz with: hndltype	&lt;C: sword OCIServerVersion(void * hndlp, OCIError * errhp, OraText * bufp, ub4 bufsz, ub1 hndltype)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="OracleEXDI">OCISessionBegin: svchp with: errhp with: usrhp with: credt with: mode	&lt;C: sword OCISessionBegin(OCISvcCtx * svchp, OCIError * errhp, OCISession * usrhp, ub4 credt, ub4 mode)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="OracleEXDI">OCISessionEnd: svchp with: errhp with: usrhp with: mode	&lt;C: sword OCISessionEnd(OCISvcCtx * svchp, OCIError * errhp, OCISession * usrhp, ub4 mode)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>Database.OracleInterface</class-id> <category>procedures - transaction</category><body package="OracleEXDI">OCITransCommit: svchp with: errhp with: flags	&lt;C: sword OCITransCommit(OCISvcCtx * svchp, OCIError * errhp, ub4 flags)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="OracleEXDI">OCITransRollback: svchp with: errhp with: flags	&lt;C: sword OCITransRollback(OCISvcCtx * svchp, OCIError * errhp, ub4 flags)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="OracleEXDI">OCITransStart: svchp with: errhp with: timeout with: flags	&lt;C: sword OCITransStart(OCISvcCtx * svchp, OCIError * errhp, uword timeout, ub4 flags)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>Database.OracleInterface</class-id> <category>procedures - defining</category><body package="OracleEXDI">OCIDefineArrayOfStruct: defnp with: errhp with: pvskip with: indskip with: rlskip with: rcskip	&lt;C: sword OCIDefineArrayOfStruct(OCIDefine * defnp, OCIError * errhp, ub4 pvskip, ub4 indskip, ub4 rlskip, ub4 rcskip)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="OracleEXDI">OCIDefineByPos: stmtp with: defnp with: errhp with: position with: valuep with: value_sz with: dty with: indp with: rlenp with: rcodep with: mode	&lt;C: sword OCIDefineByPos(OCIStmt * stmtp, OCIDefine * * defnp, OCIError * errhp, ub4 position, void * valuep, sb4 value_sz, ub2 dty, void * indp, ub2 * rlenp, ub2 * rcodep, ub4 mode)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>Database.OracleInterface</class-id> <category>procedures - binding</category><body package="OracleEXDI">OCIBindByName: stmtp with: bindp with: errhp with: placeholder with: placeh_len with: valuep with: value_sz with: dty with: indp with: alenp with: rcodep with: maxarr_len with: curelep with: mode	&lt;C: sword OCIBindByName(OCIStmt * stmtp, OCIBind * * bindp, OCIError * errhp, const OraText * placeholder, sb4 placeh_len, void * valuep, sb4 value_sz, ub2 dty, void * indp, ub2 * alenp, ub2 * rcodep, ub4 maxarr_len, ub4 * curelep, ub4 mode)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="OracleEXDI">OCIBindByPos: stmtp with: bindp with: errhp with: position with: valuep with: value_sz with: dty with: indp with: alenp with: rcodep with: maxarr_len with: curelep with: mode	&lt;C: sword OCIBindByPos(OCIStmt * stmtp, OCIBind * * bindp, OCIError * errhp, ub4 position, void * valuep, sb4 value_sz, ub2 dty, void * indp, ub2 * alenp, ub2 * rcodep, ub4 maxarr_len, ub4 * curelep, ub4 mode)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>Database.OracleInterface</class-id> <category>procedures - statement</category><body package="OracleEXDI">OCIStmtExecute: svchp with: stmtp with: errhp with: iters with: rowoff with: snap_in with: snap_out with: mode	&lt;C: sword OCIStmtExecute(OCISvcCtx * svchp, OCIStmt * stmtp, OCIError * errhp, ub4 iters, ub4 rowoff, const OCISnapshot * snap_in, OCISnapshot * snap_out, ub4 mode)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="OracleEXDI">OCIStmtFetch2: stmtp with: errhp with: nrows with: orientation with: fetchOffset with: mode	&lt;C: sword OCIStmtFetch2(OCIStmt * stmtp, OCIError * errhp, ub4 nrows, ub2 orientation, sb4 fetchOffset, ub4 mode)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="OracleEXDI">OCIStmtFetch: stmtp with: errhp with: nrows with: orientation with: mode	&lt;C: sword OCIStmtFetch(OCIStmt * stmtp, OCIError * errhp, ub4 nrows, ub2 orientation, ub4 mode)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="OracleEXDI">OCIStmtPrepare2: svchp with: stmthp with: errhp with: stmt with: stmt_len with: key with: key_len with: language with: mode	&lt;C: sword OCIStmtPrepare2(OCISvcCtx * svchp, OCIStmt ** stmthp, OCIError * errhp, const OraText * stmt, ub4 stmt_len, const OraText * key, ub4 key_len, ub4 language, ub4 mode)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="OracleEXDI">OCIStmtPrepare: stmtp with: errhp with: stmt with: stmt_len with: language with: mode	&lt;C: sword OCIStmtPrepare(OCIStmt * stmtp, OCIError * errhp, const OraText * stmt, ub4 stmt_len, ub4 language, ub4 mode)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="OracleEXDI">OCIStmtRelease: stmthp with: errhp with: key with: key_len with: mode	&lt;C: sword OCIStmtRelease(OCIStmt * stmthp, OCIError * errhp, const OraText * key, ub4 key_len, ub4 mode)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>Database.OracleInterface</class-id> <category>procedures - LOB</category><body package="OracleEXDI">OCILobAssign: envp with: errhp with: lobp with: lobpp	&lt;C: sword OCILobAssign(OCIEnv *  envp, OCIError * errhp, OCILobLocator * lobp, OCILobLocator ** lobpp)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="OracleEXDI">OCILobGetChunkSize: svchp with: errhp with: lobp with: chunk_size	&lt;C: sword OCILobGetChunkSize(OCISvcCtx * svchp, OCIError * errhp, OCILobLocator * lobp, ub4 * chunk_size)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="OracleEXDI">OCILobGetLength: svchp with: errhp with: lobp with: lenp	&lt;C: sword OCILobGetLength(OCISvcCtx * svchp, OCIError * errhp, OCILobLocator * lobp, ub4 * lenp)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="OracleEXDI">OCILobLocatorAssign: svchp with: errhp with: lobp with: lobpp	&lt;C: sword OCILobLocatorAssign(OCISvcCtx * svchp, OCIError * errhp, OCILobLocator * lobp, OCILobLocator ** lobpp)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="OracleEXDI">OCILobRead: svchp with: errhp with: lobp with: amtp with: offset with: bufp with: bufl with: ctxp with: cbfp with: csid with: csfrm	&lt;C: sword OCILobRead(OCISvcCtx * svchp, OCIError * errhp, OCILobLocator * lobp, ub4 * amtp, ub4 offset, void * bufp, ub4 bufl, void * ctxp, sb4 (* cbfp)(void * ctxp, const void * bufp, ub4 len, ub1 piece), ub2 csid, ub1 csfrm)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="OracleEXDI">OCILobTrim: svchp with: errhp with: lobp with: newlen 	&lt;C: sword OCILobTrim( OCISvcCtx *svchp, OCIError *errhp, OCILobLocator *lobp, ub4 newlen)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="OracleEXDI">OCILobWrite: svchp with: errhp with: lobp with: amtp with: offset with: bufp with: buflen with: piece with: ctxp with: cbfp with: csid with: csfrm	&lt;C: sword OCILobWrite(OCISvcCtx * svchp, OCIError * errhp, OCILobLocator * lobp, ub4 * amtp, ub4 offset, void * bufp, ub4 buflen, ub1 piece, void * ctxp, sb4 (* cbfp)(void * ctxp, void * bufp, ub4 * len, ub1 * piece), ub2 csid, ub1 csfrm)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>Database.OracleInterface</class-id> <category>procedures - encoding</category><body package="OracleEXDI">OCINlsCharSetIdToName: hndl with: buf with: buflen with: id	&lt;C: sword OCINlsCharSetIdToName( void * hndl, oratext *buf, size_t buflen, ub2 id) &gt;	^self externalAccessFailedWith: _errorCode</body><body package="OracleEXDI">OCINlsEnvironmentVariableGet: val with: size with: item with: charset with: rsize	&lt;C: sword OCINlsEnvironmentVariableGet ( void * val, size_t size, ub2 item, ub2 charset, size_t * rsize )&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>Database.OracleInterface</class-id> <category>procedures - timestamp</category><body package="OracleEXDI">OCIDateTimeConstruct: hndl with: err with: datetime with: year with: month with: day with: hour with: min with: sec with: fsec with: timezone with: timezone_length	&lt;C: sword OCIDateTimeConstruct ( dvoid         *hndl,                             OCIError      *err,                             OCIDateTime   *datetime,                             sb2           year,                             ub1           month,                             ub1           day,                             ub1           hour,                             ub1           min,                             ub1           sec,                             ub4           fsec,                             OraText       *timezone,                             size_t        timezone_length )&gt;	^self externalAccessFailedWith: _errorCode</body><body package="OracleEXDI">OCIDateTimeGetDate: hndl with: err with: datetime with: year with: month with: day	&lt;C: sword OCIDateTimeGetDate( dvoid *hndl, 				OCIError *err, 				const OCIDateTime *datetime, 				sb2 *year, 				ub1 *month, 				ub1 *day )&gt;	^self externalAccessFailedWith: _errorCode</body><body package="OracleEXDI">OCIDateTimeGetTime: hndl with: err with: datetime with: hour with: min with: sec with: fsec	&lt;C: sword OCIDateTimeGetTime ( dvoid         *hndl,                           OCIError      *err,                           OCIDateTime   *datetime,                           ub1           *hour,                          ub1           *min,                           ub1           *sec,                           ub4           *fsec )&gt;	^self externalAccessFailedWith: _errorCode</body><body package="OracleEXDI">OCIDateTimeGetTimeZoneName: hndl with: err with: datetime with: buf with: buflen	&lt;C: sword OCIDateTimeGetTimeZoneName ( dvoid              *hndl,                                   OCIError           *err,                                   const OCIDateTime  *datetime,                                   ub1                *buf,                                  ub4                *buflen)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="OracleEXDI">OCIDateTimeSysTimeStamp: hndl with: err with: datetime	&lt;C: sword OCIDateTimeSysTimeStamp ( dvoid          *hndl,                                OCIError       *err,                                 OCIDateTime    *datetime )&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>Database.OracleNTInterface</class-id> <category>procedures</category><body package="OracleEXDI">regOpenKey: hk subKey: lpszSubKey result: phkResult	&lt;C: long RegOpenKeyA( void *hk,								const char *lpszSubKey,								void **phkResult)&gt;	^self externalAccessFailedSignal raise</body><body package="OracleEXDI">regQueryValueEx: hk name: lpszValueName reserved: lpdwReserved type: lpdwType data: lpbData size: lpcbData	&lt;C: long RegQueryValueExA( void *hk,								char *lpszValueName,								unsigned long *lpdwReserved,								unsigned long *lpdwType,								unsigned char *lpbData,								unsigned long *lpcbData)&gt;	^self externalAccessFailedSignal raise</body></methods><initialize><class-id>Database.OracleConnection</class-id></initialize><initialize><class-id>Database.OracleBuffer</class-id></initialize><initialize><class-id>Database.OracleTimestampBuffer</class-id></initialize><initialize><class-id>Database.OracleLargeObjectBuffer</class-id></initialize><initialize><class-id>Database.OracleSession</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Integer</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>SmallInteger</name><environment>Core</environment><super>Core.Integer</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars>minVal maxVal maxBits maxBytes </class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>SmallDouble</name><environment>Core</environment><super>Core.LimitedPrecisionReal</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Array</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>Float</name><environment>Core</environment><super>Core.LimitedPrecisionReal</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Timestamp</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>year month day hours minutes seconds milliseconds partialNanosecond </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>ExternalDatabaseTransaction</name><environment>Database</environment><super>Database.ExternalDatabaseFramework</super><private>false</private><indexed-type>none</indexed-type><inst-vars>memberCountHolder remainingCountHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><class><name>CharacterArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>ExternalInterface</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>includeFiles includeDirectories libraryFiles libraryDirectories virtual optimizationLevel </class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>External-Interface</category><attributes><package>External-Interface</package></attributes></class><class><name>Double</name><environment>Core</environment><super>Core.LimitedPrecisionReal</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>ExternalDatabaseError</name><environment>Database</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dbmsErrorCode dbmsErrorString osErrorCode osErrorString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><class><name>UndefinedObject</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Fraction</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars>numerator denominator </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>ExternalDatabaseColumnDescription</name><environment>Database</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name index type length precision scale nullable </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><class><name>Time</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hours minutes seconds milliseconds partialNanosecond </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>ExternalDatabaseSession</name><environment>Database</environment><super>Database.ExternalDatabaseFramework</super><private>false</private><indexed-type>none</indexed-type><inst-vars>connection query queryFragments bindInput bindTemplate bindOutput useNamedOutputBinding bindValues resultTemplate allocateForEachRow blockFactor numColumns columnDescriptions rowAdaptors rowBuffersHolder bufferIndex answerStream currentRow scrollable needBinding </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><class><name>ExternalDatabaseException</name><environment>Database</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>ByteArray</name><environment>Core</environment><super>Core.IntegerArray</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>OrderedCollection</name><environment>Core</environment><super>Core.SequenceableCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>firstIndex lastIndex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Sequenceable</category><attributes><package>Collections-Sequenceable</package></attributes></class><class><name>ExternalDatabaseConnection</name><environment>Database</environment><super>Database.ExternalDatabaseFramework</super><private>false</private><indexed-type>none</indexed-type><inst-vars>transaction username password environment transactionCoordinator cachedSession isolationLevel encoding </inst-vars><class-inst-vars>environmentMap xif xifMap dependents </class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><class><name>Boolean</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>FixedPoint</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars>numerator denominator scale </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Text</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars>string runs </inst-vars><class-inst-vars></class-inst-vars><imports>			private Graphics.TextConstants.*			</imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>ExternalDatabaseBuffer</name><environment>Database</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>databaseType encoding elementSize count bufferPointer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><class><name>Date</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>day year </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class></st-source>