<?xml version="1.0"?><st-source><!-- Name: PostgreSQL3EXDINotice: Copyright 2014-2017 Cincom Systems, Inc.  All rights reserved.Comment: This package contains the PostgreSQL protocol 3.0 drivers for the External Database Interface (EXDI) API:	- use PostgreSocketConnection for the socket driver	- use PostgreLibpqConnection for the C API driverSee the PostgreSQL chapter in the DatabaseAppDevGuide.pdf document for details.Using PostgreLibpqConnection requires that the libpq library be visible to the relevant subclass of PostgresInterface, through its location being sufficiently defined in the PATH, and/or in the libraryDirectories and/or libraryFiles of the class definition of the platform-specific subclass of PostgresInterface.DbIdentifier: bear73DbTrace: 497704DbUsername: nrossDbVersion: 8.3 - 3DevelopmentPrerequisites: #(#(#any 'Database' '') #(#any 'Protocols-Common' '') #(#any 'MD5' '') #(#any 'DLLCC' ''))PackageName: PostgreSQL3EXDIParcel: #('PostgreSQL3EXDI')ParcelName: PostgreSQL3EXDIPrerequisiteDescriptions: #(#(#name 'Database' #componentType #package) #(#name 'Protocols-Common' #componentType #package) #(#name 'MD5' #componentType #package) #(#name 'DLLCC' #componentType #package #applicability #store))PrerequisiteParcels: #(#('Database' '') #('Protocols-Common' '') #('MD5' ''))PrintStringCache: (8.3 - 3,nross)Version: 8.3 - 3Post-Load Block: 	[:package | Database.PostgresServerResponse.MessageDictionary := nil]Date: 11:17:54 AM January 27, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (jan17.4) of January 27, 2017 on January 27, 2017 at 11:17:54 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>PostgresServerResponse</name><environment>Database</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream isHandled recipient </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PostgreSQL3EXDI</package></attributes></class><comment><class-id>Database.PostgresServerResponse</class-id><body>I reify a message received from the server as a stream of data.  Each message arrives as a single-letter code, followed by a length integer, and then the remaining contents.  My class side method, #parseMessage:bytes:, maps the code to a subclass of me and creates an instance.  My instance side holds the raw ByteArray which it later wraps in a stream and parses.Instance Variables:	isHandled	&lt;Boolean&gt;	True if this message has been handled by its recipient.  (Possibly obsolete.)	stream	&lt;ByteArray | ReadStream&gt;	At first, the ByteArray of bytes received from server, lazily converted to a Stream on the bytes and parsed.	recipient &lt;PostgresSocketSession | PostgresSocketConnection&gt; The executing session is the intended recipient. If it is nil, then the connection is the intended recipient.</body></comment><class><name>UnsupportedResponse</name><environment>Database</environment><super>Database.PostgresServerResponse</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PostgreSQL3EXDI</package></attributes></class><comment><class-id>Database.UnsupportedResponse</class-id><body>This class serves as a catch all for unsupported Postgres server messages.</body></comment><class><name>ParameterDescription</name><environment>Database</environment><super>Database.UnsupportedResponse</super><private>false</private><indexed-type>none</indexed-type><inst-vars>objectIDs </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PostgreSQL3EXDI</package></attributes></class><comment><class-id>Database.ParameterDescription</class-id><body>The ParameterDescription server message is part of a protocol not implemented here.Instance Variables:	objectIDs	&lt;MessageForwarder | Object | ProtoObject | ProtoObject | ProtoObject&gt;	description of objectIDs</body></comment><class><name>SessionBasedResponse</name><environment>Database</environment><super>Database.PostgresServerResponse</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PostgreSQL3EXDI</package></attributes></class><comment><class-id>Database.SessionBasedResponse</class-id><body>SessionBasedResponse corresponds to a session related message from the Postgres server.These are the generally successive states in the protocol that involved with sending a query and receiving data.#querySent #ParseComplete #BindComplete #DescribeComplete #NoDataCompleted #DataRowComplete #emptyQueryCompleted #CloseComplete #CommandComplete #errorCompleted #ReadyForQuery</body></comment><class><name>PostgresBuffer</name><environment>Database</environment><super>Database.ExternalDatabaseBuffer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bufferIndex getSelector putSelector length bufferSession postgresType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PostgreSQL3EXDI</package></attributes></class><comment><class-id>Database.PostgresBuffer</class-id><body>PostgresBuffer is a private subclass, it extends ExternalDatabaseBuffer to deal with PostgreSQL protocol 3.0.Instance Variables	bufferIndex	&lt;Integer&gt;			Binding position in query.	getSelector	&lt;method&gt;			Method which converts retrieved C data, and returns Smalltalk object.	putSelector	&lt;method&gt;			Method which converts Smalltalk object to C data.	length	&lt;Integer&gt;			Used to store the length of retrieved data.	bufferSession	&lt;PostgresSession&gt;		The session object which owns this buffer	postgresType	&lt;Integer&gt;			PostgreSQL data type number.Shared Variables	PostgreSQLTypeToClassMap &lt;IdentityDictionary&gt; 		A set of associations between PostgreSQL data types and Smalltalk classes (specifically, the symbols returned by their#postgreSQLConversion methods).	PostgreSQLTypeToClassMap &lt;IdentityDictionary&gt; 		A set of associations between Smalltalk classes (specifically, the symbols returned by their#postgreSQLConversion methods) and PostgreSQL data types.	GetSelectorMap &lt;IdentityDictionary&gt; 		A set of associations between Smalltalk classes and getter messages understood by PostgreSQLBuffer for C to Smalltalk conversion.	PutSelectorMap &lt;IdentityDictionary&gt; 		A set of associations between Smalltalk classes and messages understood by PostgreSQLBuffer for Smalltalk to C conversion.</body></comment><class><name>PostgresSocketBuffer</name><environment>Database</environment><super>Database.PostgresBuffer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>blockOfData isNullable isBinary isUnsigned isNull </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PostgreSQL3EXDI</package></attributes></class><comment><class-id>Database.PostgresSocketBuffer</class-id><body>A PostgresSocketBuffer instance holds a ByteArray copy of the data sent to or retrieved from the database. It corresponds to a column in the database, and holds information about the SQL type of the object. The default transmitted format is string. It transmits and receives a ByteArray representation of the data's printString. If the format is binary, then the ByteArray holds the binary encoding of the object.Instance Variables	databaseType		&lt;Integer&gt; 	the PostgresSocket column type	encoding			&lt;Symbol&gt;	the encoding that Strings will use	isNullable			&lt;Boolean&gt;	true if the column is nullable (for INSERTs)	isBinary			&lt;Boolean&gt;	true if the data held is binary, false if character based.	isUnsigned		&lt;Boolean&gt;	true if the integer type of this buffer is unsigned.	isNull			&lt;Boolean&gt;	true if the retrieved column is NULL.	length			&lt;Integer&gt;	size of the current ByteArray.	byteArray			&lt;ByteArray&gt;	the actual data retrieved (nil if column was NULL).	maxDbDatumLength	&lt;Integer&gt;	size of largest datum encountered (before any truncation)Shared Variables	GetSelectorMap	&lt;IdentityDictionary&gt;		A set of associations between Smalltalk classes and getter messages understood by PostgresSocketBuffer for database to Smalltalk conversion.</body></comment><class><name>Authentication</name><environment>Database</environment><super>Database.PostgresServerResponse</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PostgreSQL3EXDI</package></attributes></class><comment><class-id>Database.Authentication</class-id><body>Authentication is the super class of the authentication classes, each of which implements a different login protocol. Subclasses return an AuthenticationOk instance upon successfully authenticating with the server.</body></comment><class><name>AuthenticationUnsupported</name><environment>Database</environment><super>Database.Authentication</super><private>false</private><indexed-type>none</indexed-type><inst-vars>type </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PostgreSQL3EXDI</package></attributes></class><comment><class-id>Database.AuthenticationUnsupported</class-id><body>AuthenticationUnsupported indicates a Postgres authentication technique that hasn't been implemented (by this client) yet.Instance Variables:	type	&lt;String&gt;	 The authentication type required by the server, yet which is not implemented.</body></comment><class><name>DataRow</name><environment>Database</environment><super>Database.SessionBasedResponse</super><private>false</private><indexed-type>none</indexed-type><inst-vars>columnData isFirstRow </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PostgreSQL3EXDI</package></attributes></class><comment><class-id>Database.DataRow</class-id><body>A DataRow server message contains a single row of returned data from a SELECT statement.Instance Variables:	columnData	&lt;Array&gt;	An array of data, one datum for each column retrieved.</body></comment><class><name>PostgresError</name><environment>Database</environment><super>Database.ExternalDatabaseError</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sqlState severity </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PostgreSQL</category><attributes><package>PostgreSQL3EXDI</package></attributes></class><comment><class-id>Database.PostgresError</class-id><body>PostgresError's state adds information about errors returned from the libpq interface (refer to the PostgreSQL documentation for further details).  These are not (yet) used by the socket interface.Instance Variables	sqlState		&lt;String | nil&gt;	SQLSTATE code of the error.	severity		&lt;String | nil&gt;	The error's severity.</body></comment><class><name>IOTimedBuffer</name><environment>Database</environment><super>OS.IOBuffer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>timeoutMS </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PostgreSQL-Sockets</category><attributes><package>PostgreSQL3EXDI</package></attributes></class><comment><class-id>Database.IOTimedBuffer</class-id><body>IOTimedBuffer is an IOBuffer with the additional feature that socket reads are subject to a timer.Instance Variables	timeoutMS	&lt;SmallInteger&gt;	The waiting time (in milliseconds) before giving up on a read attempt.</body></comment><class><name>ReadyForQuery</name><environment>Database</environment><super>Database.SessionBasedResponse</super><private>false</private><indexed-type>none</indexed-type><inst-vars>transactionStatus </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PostgreSQL3EXDI</package></attributes></class><comment><class-id>Database.ReadyForQuery</class-id><body>A ReadyForQuery server message is sent by the server indicating that it is ready for a query from the client. All prior processing protocol has completed.Instance Variables:	status	&lt;Character&gt;	Indicates whether the current connection is: in a transaction, a failed transaction, or no transaction.</body></comment><class><name>AuthenticationMD5</name><environment>Database</environment><super>Database.Authentication</super><private>false</private><indexed-type>none</indexed-type><inst-vars>salt </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PostgreSQL3EXDI</package></attributes></class><comment><class-id>Database.AuthenticationMD5</class-id><body>AuthenticationMD5 transmits the username and passwordscheme encrypted using MD5 authentication.Instance Variables:	salt	&lt;ByteArray&gt;	Four bytes sent by the server, which the client uses to encrypt the password.</body></comment><class><name>CloseComplete</name><environment>Database</environment><super>Database.SessionBasedResponse</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PostgreSQL3EXDI</package></attributes></class><comment><class-id>Database.CloseComplete</class-id><body>A CloseComplete response is sent by the server indicating that a prepared statement has been closed, and can no longer be referenced.</body></comment><class><name>CommandComplete</name><environment>Database</environment><super>Database.SessionBasedResponse</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name rowCount </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PostgreSQL3EXDI</package></attributes></class><comment><class-id>Database.CommandComplete</class-id><body>A CommandComplete message is sent by the server indicating that a Simple or Extended Query answer set has completed.Instance Variables:	name		&lt;String&gt;		The leading characters of the SQL command just executed. Eg., 'SELECT'.	rowCount	&lt;Integer&gt;	The number of rows affected, moved or returned or by the last command, if any.</body></comment><class><name>CopyDone</name><environment>Database</environment><super>Database.UnsupportedResponse</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PostgreSQL3EXDI</package></attributes></class><comment><class-id>Database.CopyDone</class-id><body>The CopyDone server message is part of a protocol not implemented here.</body></comment><class><name>PostgresLibpqBuffer</name><environment>Database</environment><super>Database.PostgresBuffer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>format lengthsPointer bufferValue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PostgreSQL3EXDI</package></attributes></class><comment><class-id>Database.PostgresLibpqBuffer</class-id><body>PostgresLibpqBuffer is a private subclass, it extends ExternalDatabaseBuffer to deal with PostgreSQL.Instance Variables	bufferValue	&lt;Object&gt;			The value held in the buffer.	format	&lt; Integer &gt;			0 means text format, 1 binary.	lengthsPointer	&lt;CPointer&gt;			A pointer used to store the length of data.Shared Variables	GetSelectorMap &lt;IdentityDictionary&gt; 		A set of associations between Smalltalk classes and getter messages understood by PostgreSQLBuffer for C to Smalltalk conversion.</body></comment><class><name>PostgresSession</name><environment>Database</environment><super>Database.ExternalDatabaseSession</super><private>false</private><indexed-type>none</indexed-type><inst-vars>currentRowIndex statementName isPrepared bindInputBuffers </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PostgreSQL3EXDI</package></attributes></class><comment><class-id>Database.PostgresSession</class-id><body>PostgresSession is the abstract protocol 3.0 postgres session class.Instance Variables	bindInputBuffers	&lt;Collection of PostgresBuffer subclass&gt;	a collection of buffers holding the bound values being sent to the server.	currentRowIndex	&lt;Integer&gt;	currentRowIndex is used with blockFactor, and refers to the index into the buffer block that we are currently reading.	statementName	&lt;String | nil&gt;	A String remembers the session's name.	isPrepared			&lt;Boolean&gt;	Indicates whether the query has been prepared.</body></comment><class><name>PostgresLibpqSession</name><environment>Database</environment><super>Database.PostgresSession</super><private>false</private><indexed-type>none</indexed-type><inst-vars>paramFormatsPointerHolder paramLengthsPointerHolder paramNumber paramTypesPointerHolder paramValuesPointerHolder resultFormat sessionStatusHolder totalRows </inst-vars><class-inst-vars>execStatusType </class-inst-vars><imports></imports><category></category><attributes><package>PostgreSQL3EXDI</package></attributes></class><comment><class-id>Database.PostgresLibpqSession</class-id><body>PostgresSession is the concrete implementation of session services using the PostgreSQL libpq library.Instance Variables 	paramNumber &lt;SmallInteger&gt;		Number of binding parameters. 	paramValuesPointerHolder &lt;ValueHolder on: (CPointer | nil)&gt;		A private value holder which remembers the pointers for the binding values, if any.  The value holder 	is shared with the executor object.	paramTypesPointerHolder &lt;ValueHolder on: (CPointer | nil)&gt;		A private value holder which remembers the pointers for the types of  the binding values, if any.  The value holder is shared with the executor object.	paramLengthsPointerHolder &lt;ValueHolder on: (CPointer | nil)&gt;		A private value holder which remembers the length pointers of  the binding values, if any.  The value holder is shared with the executor object.	paramFormatsPointerHolder &lt;ValueHolder on: (CPointer | nil)&gt;		A private value holder which remembers the format pointers of  the binding values, if any.  The value holder is shared with the executor object.	sessionStatus &lt;PGresult pointer&gt;		A variable to remember the PGresult pointer returned by libpq APIs.	totalRows &lt;SmallInteger&gt; 		Number of rows affected by the current query.	currentRowIndex &lt;SmallInteger&gt; 		A integer used to remember the position of current row in result set.	resultFormat &lt;Integer&gt;		An integer to indicate the format of the retrieved result. 0 means text format, 1 binary.Class Instance Variables	execStatusType	 &lt;CEnumerationType&gt;			A CEnumerationType used to indicate the execution status of a SQL command. Shared Variables	RegisteredPostgreSQLSessions	&lt;HandleRegistry&gt;		Unused at present in PostgreSQL - see PostgresConnection</body></comment><class><name>PortalSuspended</name><environment>Database</environment><super>Database.PostgresServerResponse</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PostgreSQL3EXDI</package></attributes></class><comment><class-id>Database.PortalSuspended</class-id><body>If Execute terminates before completing the execution of a portal (due to reaching a specified nonzero result-row count that is less than all the rows the query can return), it will send a PortalSuspended message.  (The appearance of this message tells the frontend that another Execute should be issued against the same portal to complete the operation.)  The CommandComplete message is not sent until the portal's execution is completed.  Therefore, executing a portal is always terminated by the appearance of exactly one of these messages: CommandComplete, EmptyQueryResponse (if the portal was created from an empty query string), ErrorResponse, or PortalSuspended, where this last means there are more results to retrieve.</body></comment><class><name>AsynchronousResponse</name><environment>Database</environment><super>Database.PostgresServerResponse</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PostgreSQL3EXDI</package></attributes></class><comment><class-id>Database.AsynchronousResponse</class-id><body>AsynchronousResponse serves as the superclass for notice, notification, parameterStatus, error and timeout messages. These messages are basically outside of the usual session query protocol and are not returned to the calling session. Instead, they trigger the fetching and return of the next server message.</body></comment><class><name>NoticeResponse</name><environment>Database</environment><super>Database.AsynchronousResponse</super><private>false</private><indexed-type>none</indexed-type><inst-vars>codeAndFieldAssociations </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PostgreSQL3EXDI</package></attributes></class><comment><class-id>Database.NoticeResponse</class-id><body>A NoticeResponse object represents a NoticeResponse message from the server, including a list of code and field associations indicating, for instance that the server may be going down soon, or that logging is on. Since this sort of information is infrequent and important, it is logged to the Transcript if received by a session. If there is no session yet, a Dialog is displayed (this may happen at login).Instance Variables:	codeAndFieldAssociations	&lt;Array&gt;	An Array of code-&gt;field associations.</body></comment><class><name>PostgresInterface</name><environment>Database</environment><super>External.ExternalInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Database.PostgresInterfaceDictionary.*			</imports><category>Database-External-Libraries</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>true</beVirtual><optimizationLevel>full</optimizationLevel><package>PostgreSQL3EXDI</package></attributes></class><comment><class-id>Database.PostgresInterface</class-id><body>This class defines calling conventions for the PostgreSQL libpq.</body></comment><class><name>PostgresLinuxInterface</name><environment>Database</environment><super>Database.PostgresInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Database.PostgresLinuxInterfaceDictionary.*			</imports><category>Database-External-Libraries</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>libpq.so.5</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>PostgreSQL3EXDI</package></attributes></class><comment><class-id>Database.PostgresLinuxInterface</class-id><body>This class defines calling conventions for the PostgreSQL libpq on the Linux (Intel) platform.  Please refer to the environment variable on your machine for the path containing necessary PostgreSQL library files.</body></comment><class><name>TimeoutResponse</name><environment>Database</environment><super>Database.AsynchronousResponse</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PostgreSQL3EXDI</package></attributes></class><comment><class-id>Database.TimeoutResponse</class-id><body>TimeoutResponse is not another kind of server response. Instead it indicates that there has been no server response when one was expected--a time out. When sent &gt;&gt;activate, a TimeoutResponse object throws a ResumeableException, allowing the client to try waiting again, or quit.Timeouts can be handled as follows:	- resume to continue waiting;  the assumption is that the server and query are still good, just on a slow transport layer	- terminate to end the session locally;  the assumption is that the timeout is because the server no longer has anything for this query which is somehow out of sync (unlikely, unless the driver itself is being developed) or connection with the server has been lost such that the rest of the query was dispatched but never arrives.	- send cancelCurrentRequest to the connection to abandon the session on the server;  the assumption is that the query is technically valid but was not the one you intended - you have just realised it will be a long time completing.In the third case, allow a little time for the cancel to reach the server and be processed before resuming.  Postgres cancels the query that is running on that connection when it gets the request, not the one that was running on that connection when the cancel was sent.  (As the cancel is sent on a different connection, it is wholly asynchronous to the connection whose current query you are trying to abort.)</body></comment><class><name>PostgresLOB</name><environment>Database</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>lobOid lobDescriptor connection mode position bufferSize </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL</category><attributes><package>PostgreSQL3EXDI</package></attributes></class><comment><class-id>Database.PostgresLOB</class-id><body>This class is used to process Large OBject (LOB) in PostgreSQL.Instance Variables	lobOid	&lt;Integer&gt;			An integer used to remember the referent address of the latge object's OID pointer.	lobDescriptor	&lt;Integer&gt;			An integer to remember the large object descriptor.	connection	&lt;PGconn pointer&gt;			The connection used to process the large object.	mode	&lt;Integer&gt;			An integer to indicate whether the large object is opened for reading, writting, or both.	position	&lt;Integer&gt;			An integer used to remember the location of the current pointer in the large object.	bufferSize	&lt;Integer&gt;			Size of the buffer used to transfer LOB data.</body></comment><class><name>NoData</name><environment>Database</environment><super>Database.SessionBasedResponse</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PostgreSQL3EXDI</package></attributes></class><comment><class-id>Database.NoData</class-id><body>A NoData message is the server's response when a query doesn't return any data, such as an INSERT statement.</body></comment><class><name>Postgres64BitInterface</name><environment>Database</environment><super>Database.PostgresInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Database.Postgres64BitInterfaceDictionary.*			</imports><category>Database-External-Libraries</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>true</beVirtual><optimizationLevel>full</optimizationLevel><package>PostgreSQL3EXDI</package></attributes></class><comment><class-id>Database.Postgres64BitInterface</class-id><body>This class defines 64-bit calling conventions for the PostgreSQL libpq. It should only be used in 64-bit images, running on a 64-bit VM.</body></comment><class><name>Postgres64SolarisInterface</name><environment>Database</environment><super>Database.Postgres64BitInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Database.Postgres64SolarisInterfaceDictionary.*			</imports><category>Database-External-Libraries</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>libpq.so</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>PostgreSQL3EXDI</package></attributes></class><comment><class-id>Database.Postgres64SolarisInterface</class-id><body>This class defines calling conventions for the PostgreSQL libpq on the 64-bit Solaris platform.   Please refer to the environment variable on your machine for the path containing necessary PostgreSQL library files.</body></comment><class><name>PostgresConnection</name><environment>Database</environment><super>Database.ExternalDatabaseConnection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hostName databaseName preparedStatementNames dynamicClassToPostgreSQLTypeMap dynamicPostgreSQLTypeToClassMap </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PostgreSQL3EXDI</package></attributes></class><comment><class-id>Database.PostgresConnection</class-id><body>Abstract protocol 3.0 postgres connection class.Instance Variables	databaseName		&lt;String&gt; The final part of the environment string:  the specific database	dynamicClassToPostgreSQLTypeMap	&lt;Dictionary&gt; Some type values are unique to a given database	dynamicPostgreSQLTypeToClassMap	&lt;Dictionary&gt; 		"		"		"		"	hostName			&lt;String&gt; The first part of the environment string:  the machine that the is database running on	preparedStatementNames		&lt;Set&gt; names of statements we have prepared on the server, so need not prepare again on this connection</body></comment><class><name>ResumableTimeoutException</name><environment>Database</environment><super>Database.ExternalDatabaseResumableException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PostgreSQL3-Sockets</category><attributes><package>PostgreSQL3EXDI</package></attributes></class><comment><class-id>Database.ResumableTimeoutException</class-id><body>ResumableTimeoutException is a resumable exception triggered by timeouts waiting for a response from the server.</body></comment><class><name>Postgres64NTInterface</name><environment>Database</environment><super>Database.Postgres64BitInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Database.Postgres64NTInterfaceDictionary.*			</imports><category>Database-External-Libraries</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>libpq.dll</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>PostgreSQL3EXDI</package></attributes></class><comment><class-id>Database.Postgres64NTInterface</class-id><body>This class defines calling conventions for the PostgreSQL libpq on the 64-bit Windows (Intel) platform.   Please refer to the environment variable on your machine for the path containing necessary PostgreSQL library files.</body></comment><class><name>CopyData</name><environment>Database</environment><super>Database.UnsupportedResponse</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PostgreSQL3EXDI</package></attributes></class><comment><class-id>Database.CopyData</class-id><body>The CopyData server message is part of a protocol not implemented here.</body></comment><class><name>PostgresSocketConnection</name><environment>Database</environment><super>Database.PostgresConnection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>socketConnection iostream activeParameters timeout isUsingBase64 portNumber answerableSession queuedSessions mutex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PostgreSQL3EXDI</package></attributes></class><comment><class-id>Database.PostgresSocketConnection</class-id><body>PostgresSocketConnection was designed to work with the 9.* Postgres socket API and later (but has been iobserved to work with 8.* and as far back as 7.4.4).  It is a no-frills, sockets-based version of the usual EXDI interface.Instance Variables	activeParameters	&lt;(Dictionary of: )&gt;	description of activeParameters	iostream	&lt;BufferedExternalStream &gt;	The binary encoded iostream that works with our socket object.	isUsingBase64	&lt;Boolean&gt;	Encode in base64 or just as hex?	portNumber &lt;Integer&gt; The i/o port the server is using (#portString: handles it as string)	socketConnection	&lt;ExternalTimedConnection&gt;	The SocketConnection object we're using to handle communications with the server.	timeout &lt;Integer&gt; Timeout in milliseconds on socket reads.	answerableSession	&lt;PostgresSocketSession&gt;	The session that can be asked for its answer, or is answering.	queuedSessions	&lt;OrderedCollection&gt;		Any sessions that have executed but have not yet been asked for their answers and , held in order of execution.Updating answerableSession (and queuedSessions) is protected by the participantsSemaphore.  In response to a queuedSession's request for its first #answer, the answerableSession is forced to buffer its answers (unless it has already read them all), and so on for any queuedSessions before the requesting session.</body></comment><class><name>Postgres64MacOSXInterface</name><environment>Database</environment><super>Database.Postgres64BitInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Database.Postgres64MacOSXInterfaceDictionary.*			</imports><category>Database-External-Libraries</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>libpq.dylib</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>PostgreSQL3EXDI</package></attributes></class><comment><class-id>Database.Postgres64MacOSXInterface</class-id><body>This class defines calling conventions for the PostgreSQL libpq on the 64-bit MacOSX platform.   Please refer to the environment variable on your machine for the path containing necessary PostgreSQL library files.</body></comment><class><name>CopyResponse</name><environment>Database</environment><super>Database.UnsupportedResponse</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mainFormat columnFormats </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PostgreSQL3EXDI</package></attributes></class><comment><class-id>Database.CopyResponse</class-id><body>The CopyResponse server message is part of a protocol not implemented here.Instance Variables:	columnFormats	&lt;Object&gt;	description of columnFormats	mainFormat	&lt;MessageForwarder | Object | ProtoObject | ProtoObject | ProtoObject&gt;	description of mainFormat</body></comment><class><name>CopyOutResponse</name><environment>Database</environment><super>Database.CopyResponse</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PostgreSQL3EXDI</package></attributes></class><comment><class-id>Database.CopyOutResponse</class-id><body>The CopyOutResponse server message is part of a protocol not implemented here.</body></comment><class><name>FunctionCallResponse</name><environment>Database</environment><super>Database.UnsupportedResponse</super><private>false</private><indexed-type>none</indexed-type><inst-vars>messageData </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PostgreSQL3EXDI</package></attributes></class><comment><class-id>Database.FunctionCallResponse</class-id><body>The FunctionCallResponse server message is part of a protocol not implemented here.Instance Variables:	messageData	&lt;Array&gt;	The data received from the server with this message.</body></comment><class><name>UnrecognizedResponse</name><environment>Database</environment><super>Database.PostgresServerResponse</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PostgreSQL3EXDI</package></attributes></class><comment><class-id>Database.UnrecognizedResponse</class-id><body>An UnrecognizedResponse indicates that a server response was not recognized by the client. That is, the server's message could not be parsed, or is a new, unknown server message.</body></comment><class><name>PostgresSolarisInterface</name><environment>Database</environment><super>Database.PostgresInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Database.PostgresSolarisInterfaceDictionary.*			</imports><category>Database-External-Libraries</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>libpq.so</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>PostgreSQL3EXDI</package></attributes></class><comment><class-id>Database.PostgresSolarisInterface</class-id><body>This class defines calling conventions for the PostgreSQL libpq on the Solaris platform.  Please refer to the environment variable on your machine for the path containing necessary PostgreSQL library files.</body></comment><class><name>SocketErrorResponse</name><environment>Database</environment><super>Database.AsynchronousResponse</super><private>false</private><indexed-type>none</indexed-type><inst-vars>socketError </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PostgreSQL3EXDI</package></attributes></class><comment><class-id>Database.SocketErrorResponse</class-id><body>I am not another kind of server response;  I indicate that there has been no server response due to a socket error raised in the image, either a direct error (a subclass of OsError) raised by the socket not returning any response, or an IncompleteNextCountError caused by the socket failing in the midst of a response so the response cannot be parsed, or an OsTransferFault error raised while sending the message over a failed connection, or a raw Error due to meaningless data causing allocation failure or similar.</body></comment><class><name>PostgresTransaction</name><environment>Database</environment><super>Database.ExternalDatabaseTransaction</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-PostgreSQL-EXDI</category><attributes><package>PostgreSQL3EXDI</package></attributes></class><comment><class-id>Database.PostgresTransaction</class-id><body>My superclass models the state of the transaction on the server.  As yet, I have no specific behaviour.</body></comment><class><name>RowDescription</name><environment>Database</environment><super>Database.SessionBasedResponse</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fields </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PostgreSQL3EXDI</package></attributes></class><comment><class-id>Database.RowDescription</class-id><body>A RowDescription server message describes the contents (field types) of the data rows it will send as the answer set.Instance Variables:	fields	&lt;Array&gt;	An array of column descriptions.</body></comment><class><name>BackendKeyData</name><environment>Database</environment><super>Database.PostgresServerResponse</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pid key </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PostgreSQL3EXDI</package></attributes></class><comment><class-id>Database.BackendKeyData</class-id><body>BackendKeyData is a message sent by the server at login. It holds the key and id necessary to cancel an active session using a separate connection.Instance Variables:	key	&lt;Integer&gt;	The server (back end) key for this connection	pid	&lt;Integer&gt;	This server's process ID for this connection.</body></comment><class><name>BindComplete</name><environment>Database</environment><super>Database.SessionBasedResponse</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PostgreSQL3EXDI</package></attributes></class><comment><class-id>Database.BindComplete</class-id><body>A BindComplete message is sent by the server in response to a query using bound values.</body></comment><class><name>Postgres64LinuxInterface</name><environment>Database</environment><super>Database.Postgres64BitInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Database.Postgres64LinuxInterfaceDictionary.*			</imports><category>Database-External-Libraries</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>libpq.so.5</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>PostgreSQL3EXDI</package></attributes></class><comment><class-id>Database.Postgres64LinuxInterface</class-id><body>This class defines calling conventions for the PostgreSQL libpq on the 64-bit Linux platform.   Please refer to the environment variable on your machine for the path containing necessary PostgreSQL library files.</body></comment><class><name>PostgresColumnDescription</name><environment>Database</environment><super>Database.ExternalDatabaseColumnDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>format </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PostgreSQL</category><attributes><package>PostgreSQL3EXDI</package></attributes></class><comment><class-id>Database.PostgresColumnDescription</class-id><body>The PostgresColumnDescription adds information to ExternalDatabaseColumnDescription which is unique to PostgreSQL.Instance Variables	format &lt;SmallInteger&gt;		Used to indicate whether column is in binary (1) or text (0) format. </body></comment><class><name>PostgresSocketConnectionBuffer</name><environment>Database</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>connection session buffer finalResponse writePosition </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PostgreSQL3EXDI</package></attributes></class><comment><class-id>Database.PostgresSocketConnectionBuffer</class-id><body>I wrap a connection in a buffer, to allow my session to empty the connection's socket of all messages into my buffer (so another session can read its answers from the connection).  Messages are buffered unprocessed;  the session processes them when it later reads them from me as if from the connection.If one thread is reading from the socket (i.e. to the answerableSession) at the exact moment when another is requesting answer on a queuedSession, I will be initialized on the answerableSession (thus ensuring the _next_ attempt to read a message will find itself addressing the buffer, and so will wait until buffering completes, while buffering will then wait (in #delayUntilReady) until after the message is read (isolationLevel is true).Instance Variables	buffer		&lt;ReadWriteStream&gt;					Hold the raw messages read from the connection, ready for processing.	connection	&lt;PostgresSocketConnection&gt;			The connection from whom I read my session's answers.	finalResponse	&lt;ReadyForQuery | TimeoutResponse&gt;	The final message that terminated a run of buffering.	session		&lt;PostgresSocketSession&gt;				The session whose answer messages I have read.	writePosition	&lt;Integer&gt;						Where did we write to in the buffer before we reset it for reading.</body></comment><class><name>CopyInResponse</name><environment>Database</environment><super>Database.CopyResponse</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PostgreSQL3EXDI</package></attributes></class><comment><class-id>Database.CopyInResponse</class-id><body>The CopyInResponse server message is part of a protocol not implemented here.</body></comment><class><name>PostgresSocketSession</name><environment>Database</environment><super>Database.PostgresSession</super><private>false</private><indexed-type>none</indexed-type><inst-vars>rowsInBlock rowCount bufferedSendStream protocolState columnsServerMessage </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PostgreSQL3EXDI</package></attributes></class><comment><class-id>Database.PostgresSocketSession</class-id><body>PostgresSocketSession is like the usual ExternalDatabaseSession, except that there is no session handle in the sockets api. Instead, the session objects all share the same connection, using its socket. Postgres offers two separate api-s, called Simple and Extended. A session defaults to #needBinding true, which always invokes the 'Extended Query' api. If #needBinding is false, the session uses the 'Simple Query' api. With extended queries (ie., needBinding is true), the session always uses a 'named statement' and 'portal' on the server. This pair allows for prepared query reuse, eg. you can repeatedly send &gt;&gt;execute to the session object, which is more efficient than having to prepare: the query every time. However, Postgres limits extended queries to only a single command each time.If #needBinding is false, (eg., by sending &gt;&gt;prepareWithoutBinding:), the simple query api is used, which uses the 'unamed statement and portal'. There is only one possible unamed statement and its corresponding unamed portal for a connectionl. Note that on the server, for the current connection object (i.e., socket) all simple queries will update and overwrite that same statement, server side. Simple queries don't offer binding, but the do permit multiple queries in each send.Instance Variables	rowsInBlock	&lt;Integer&gt;	holds the number of rows currently in the block, and can range from 0 to blockFactor.	rowCount &lt;Integer&gt; the number of rows indicated by the most recent operation.	bufferedSendStream &lt;Stream&gt; Holds the series of query component messages to be sent to the server.	protocolState	&lt;Symbol&gt; See the state machines below.	columnsServerMessage &lt;RowDescription&gt; The column descriptions provided by the server.The state machine for Extended Query (which uses Parse, not Query).==================================[State]-&gt;[ClientMessage]-&gt;[#server msg. State ].==================================[connecting]-&gt;[login]-&gt;[#ReadyForQuery : ready].[connecting]-&gt;[login]-&gt;[#ErrorResponse : ERROR].[ready]-&gt;[Parse]-&gt;[#ParseComplete : Prepared Statement exists (lasts until next Parse/Query). parsed].[ready]-&gt;[Parse]-&gt;[#ErrorResponse : ERROR].[parsed]-&gt;[Bind]-&gt;[#BindComplete : Portal now exists, bound].[parsed]-&gt;[Bind]-&gt;[#ErrorResponse : ERROR].[bound]-&gt;[Describe(portal)]-&gt;[#RowDescription : describes columns. described].[bound]-&gt;[Describe(portal)]-&gt;[#NoData : says stment won't return rows. described].[bound]-&gt;[Describe(portal)]-&gt;[#ErrorResponse : ERROR].[described]-&gt;[Execute]-&gt;[#DataRow(s) : execute phase continues until one of the following msgs].[described]-&gt;[Execute]-&gt;[#PortalSuspended : execute needs to be sent again for more data.&lt;But we don't limit rows.&gt;].[described]-&gt;[Execute]-&gt;[#CommandComplete : done].[described]-&gt;[Execute]-&gt;[#EmptyQueryResponse : done].[described]-&gt;[Execute]-&gt;[#ErrorResponse : ERROR].[done]-&gt;[Close]-&gt;[#CloseComplete : the statement and its resources are now history. closed].[done]-&gt;[Sync]-&gt;[#ReadyForQuery : ready].[closed]-&gt;[Sync]-&gt;[#ReadyForQuery : ready].[ERROR]-&gt;[Sync]-&gt;[#ReadyForQuery : the statement was rolledback, enclosing trans (if any) continues. ready].[ready] ...The state machine for Simple Query (which uses Query--no bound variables).==================================[State]-&gt;[ClientMessage]-&gt;[#server msg. State ].==================================[connecting]-&gt;[login]-&gt;[#ReadyForQuery : ready].[connecting]-&gt;[login]-&gt;[#ErrorResponse : ERROR].[ready]-&gt;[Query]-&gt;[#EmptyQueryResponse. more].[ready]-&gt;[Query]-&gt;[#RowDescription : describes columns. executing].[more]-&gt;[peek]-&gt;[#EmptyQueryResponse. more].[more]-&gt;[peek]-&gt;[#RowDescription : describes columns. executing].[more]-&gt;[peek]-&gt;[#ReadyForQuery : ready].[executing]-&gt;[peek]-&gt;[#DataRow(s). executing].[executing]-&gt;[peek]-&gt;[#CommandComplete : more].[ERROR]-&gt;[Sync]-&gt;[#ReadyForQuery : the statement was rolledback, enclosing trans (if any) continues. ready].[ready] ...</body></comment><class><name>AuthenticationOk</name><environment>Database</environment><super>Database.Authentication</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PostgreSQL3EXDI</package></attributes></class><comment><class-id>Database.AuthenticationOk</class-id><body>AuthenticationOk indicates that the user has successfully logged in.</body></comment><class><name>PostgresMacOSXInterface</name><environment>Database</environment><super>Database.PostgresInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Database.PostgresMacOSXInterfaceDictionary.*			</imports><category>Database-External-Libraries</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>libpq.dylib</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>PostgreSQL3EXDI</package></attributes></class><comment><class-id>Database.PostgresMacOSXInterface</class-id><body>This class defines calling conventions for the PostgreSQL libpq on the MacOSX platform. Please refer to the environment variable on your machine for the path containing necessary PostgreSQL library files.</body></comment><class><name>AuthenticationCleartextPassword</name><environment>Database</environment><super>Database.Authentication</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PostgreSQL3EXDI</package></attributes></class><comment><class-id>Database.AuthenticationCleartextPassword</class-id><body>AuthenticationCleartextPassword transmits the username/password information to the server without encrypting it.</body></comment><class><name>NotificationResponse</name><environment>Database</environment><super>Database.AsynchronousResponse</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pid channelName payload </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PostgreSQL3EXDI</package></attributes></class><comment><class-id>Database.NotificationResponse</class-id><body>NotificationResponse is used for communication on "channels". If the client has issued a LISTEN command, and a NOTIFY command has subsequently been issued for that channel name, then the server sends a NotificationResponse to the client. If a NotificationResponse is received, the client raises a Dialog with the message.Instance Variables:	channelName	&lt;String&gt;	 The name of the channel that the NOTIFY was raised on.	payload	&lt;String&gt;	The payload string passed from the process that sent a NOTIFY.	pid	&lt;Integer&gt; The ID of the notifying backend process.</body></comment><class><name>PostgresNTInterface</name><environment>Database</environment><super>Database.PostgresInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Database.PostgresNTInterfaceDictionary.*			</imports><category>Database-External-Libraries</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>libpq.dll</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>PostgreSQL3EXDI</package></attributes></class><comment><class-id>Database.PostgresNTInterface</class-id><body>This class defines calling conventions for the PostgreSQL libpq on the Windows NT (Intel) platform.  Please refer to the environment variable on your machine for the path containing necessary PostgreSQL library files.</body></comment><class><name>ParseComplete</name><environment>Database</environment><super>Database.SessionBasedResponse</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PostgreSQL3EXDI</package></attributes></class><comment><class-id>Database.ParseComplete</class-id><body>A ParseComplete message is returned by the server indicating that it has parsed an Extended Query from the client (ie., a bound query).</body></comment><class><name>ExternalTimedConnection</name><environment>Database</environment><super>OS.ExternalConnection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>timeoutMS currentIoBuffer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PostgreSQL-Sockets</category><attributes><package>PostgreSQL3EXDI</package></attributes></class><comment><class-id>Database.ExternalTimedConnection</class-id><body>ExternalTimedConnection is an ExternalConnection with the additional feature that socket reads are subject to a timer.</body></comment><class><name>PostgresFieldDescription</name><environment>Database</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name tableOID attribute typeOID sizeModifier typeModifier format </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PostgreSQL-Sockets</category><attributes><package>PostgreSQL3EXDI</package></attributes></class><comment><class-id>Database.PostgresFieldDescription</class-id><body>PostgresFieldDescription contains the raw information regarding a field (or column) being returned from the server. This is then converted into a PgsqlColumnDescription.Instance Variables	attribute	&lt;String&gt;	description of attribute	format	&lt;Integer&gt;	String or Binary (0 or 1).	name	&lt;ByteArray &gt;	The name of the column.	sizeModifier	&lt;Integer&gt;	description of sizeModifier	tableOID	&lt;Integer&gt;	The integer ID that Postgres uses to identify the table.	typeModifier	&lt;Integer&gt;	Another attribute indicator.	typeOID		&lt;Integer&gt;	The integer ID that Postgres uses to identify the data type.</body></comment><class><name>EmptyQueryResponse</name><environment>Database</environment><super>Database.SessionBasedResponse</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PostgreSQL3EXDI</package></attributes></class><comment><class-id>Database.EmptyQueryResponse</class-id><body>An EmptyQueryResponse is the message returned by the server after an empty query has been sent to it. This can happen with a Simple Query command that contains two successive semicolons, or a string of spaces for an Extended Query (a bound query).</body></comment><class><name>ParameterStatus</name><environment>Database</environment><super>Database.AsynchronousResponse</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PostgreSQL3EXDI</package></attributes></class><comment><class-id>Database.ParameterStatus</class-id><body>A ParameterStatus from the server indicates the status of the given connection parameter, a sort of attribute. At startup, the server sends a series of ParameterStatus messages indication the encoding, time zone, etc. These are held in a Dictionary by the connection object.Instance Variables:	name	&lt;String&gt;	The name of the parameter. For example, 'encoding', or 'timezone'.	value	&lt;String&gt;	The value of the parameter, like 'utf8', or 'UTC'.</body></comment><class><name>ErrorResponse</name><environment>Database</environment><super>Database.AsynchronousResponse</super><private>false</private><indexed-type>none</indexed-type><inst-vars>codeAndFieldAssociations </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PostgreSQL3EXDI</package></attributes></class><comment><class-id>Database.ErrorResponse</class-id><body>An ErrorResponse from the server includes an array of codeAndFieldAssociations indicating what happend. The entire current query has already been cancelled by the server, and the next server message is a Synch response, signaling that the query has ended.Instance Variables:	codeAndFieldAssociations	&lt;Array&gt;	An Array of code -&gt; Field associations with details about the error.</body></comment><class><name>PostgresException</name><environment>Database</environment><super>Database.ExternalDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PostgreSQL-pqlib</category><attributes><package>PostgreSQL3EXDI</package></attributes></class><comment><class-id>Database.PostgresException</class-id><body>PostgresException is raised in case of the PostgreSQL database errors.</body></comment><class><name>CopyBothResponse</name><environment>Database</environment><super>Database.CopyResponse</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PostgreSQL3EXDI</package></attributes></class><comment><class-id>Database.CopyBothResponse</class-id><body>The CopyBothResponse server message is part of a protocol not implemented here.</body></comment><class><name>PostgresResumableException</name><environment>Database</environment><super>Database.PostgresException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PostgreSQL3-pqlib</category><attributes><package>PostgreSQL3EXDI</package></attributes></class><comment><class-id>Database.PostgresResumableException</class-id><body>PostgresResumableException  is raised in case of the PostgreSQL database warnings or notices.</body></comment><class><name>PostgresLibpqConnection</name><environment>Database</environment><super>Database.PostgresConnection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>connectionHolder portString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PostgreSQL3EXDI</package></attributes></class><comment><class-id>Database.PostgresLibpqConnection</class-id><body>PostgresLibpqConnection is the concrete class implementation of connection services using the PostgreSQL libpq library.Instance Variables	connectionHolder &lt;ValueHolder on (CPointer to PGconn)&gt;		A private value holder which remembers PGconn pointer for the current connection.	portString &lt;String&gt;		The i/o port the server is using (#portNumber: handles it as an integer)Shared Variables	RegisteredPostgreSQLConnections	&lt;HandleRegistry of (ValueHolder on: CCompositePointer(PGconn*) -&gt; PostgreSQLEXDIConnection&gt;		a registry of C-API connectionHolders keying EXDI connection instances</body></comment><shared-variable><name>RegisteredPostgreSQLSessions</name><environment>Database.PostgresLibpqSession</environment><private>false</private><constant>false</constant><category>pqlib</category><attributes><package>PostgreSQL3EXDI</package></attributes></shared-variable><shared-variable><name>ClassToPostgreSQLTypeMap</name><environment>Database.PostgresBuffer</environment><private>false</private><constant>false</constant><category>types</category><attributes><package>PostgreSQL3EXDI</package></attributes></shared-variable><shared-variable><name>PutSelectorMap</name><environment>Database.PostgresBuffer</environment><private>false</private><constant>false</constant><category>types</category><attributes><package>PostgreSQL3EXDI</package></attributes></shared-variable><shared-variable><name>GetSelectorMap</name><environment>Database.PostgresBuffer</environment><private>false</private><constant>false</constant><category>types</category><attributes><package>PostgreSQL3EXDI</package></attributes></shared-variable><shared-variable><name>PostgreSQLTypeToClassMap</name><environment>Database.PostgresBuffer</environment><private>false</private><constant>false</constant><category>types</category><attributes><package>PostgreSQL3EXDI</package></attributes></shared-variable><shared-variable><name>TimeZoneName</name><environment>Database.PostgresConnection</environment><private>false</private><constant>false</constant><category>timezone</category><initializer>''</initializer><attributes><package>PostgreSQL3EXDI</package></attributes></shared-variable><shared-variable><name>EncoderMap</name><environment>Database.PostgresConnection</environment><private>false</private><constant>false</constant><category>encoding</category><attributes><package>PostgreSQL3EXDI</package></attributes></shared-variable><shared-variable><name>ErrorCategories</name><environment>Database.PostgresConnection</environment><private>false</private><constant>false</constant><category>socket</category><attributes><package>PostgreSQL3EXDI</package></attributes></shared-variable><shared-variable><name>RegisteredPostgreSQLConnections</name><environment>Database.PostgresLibpqConnection</environment><private>false</private><constant>false</constant><category>pqlib</category><attributes><package>PostgreSQL3EXDI</package></attributes></shared-variable><shared-variable><name>MessageDictionary</name><environment>Database.PostgresServerResponse</environment><private>false</private><constant>false</constant><category>private-accessing</category><initializer>nil</initializer><attributes><package>PostgreSQL3EXDI</package></attributes></shared-variable><shared-variable><name>Postgres64BitInterfaceDictionary</name><environment>Database</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>PostgreSQL3EXDI</package></attributes></shared-variable><shared-variable><name>PostgresSolarisInterfaceDictionary</name><environment>Database</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>PostgreSQL3EXDI</package></attributes></shared-variable><shared-variable><name>PostgresMacOSXInterfaceDictionary</name><environment>Database</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>PostgreSQL3EXDI</package></attributes></shared-variable><shared-variable><name>Postgres64LinuxInterfaceDictionary</name><environment>Database</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>PostgreSQL3EXDI</package></attributes></shared-variable><shared-variable><name>PostgresLinuxInterfaceDictionary</name><environment>Database</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>PostgreSQL3EXDI</package></attributes></shared-variable><shared-variable><name>PostgresInterfaceDictionary</name><environment>Database</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>PostgreSQL3EXDI</package></attributes></shared-variable><shared-variable><name>Postgres64NTInterfaceDictionary</name><environment>Database</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>PostgreSQL3EXDI</package></attributes></shared-variable><shared-variable><name>PostgresNTInterfaceDictionary</name><environment>Database</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>PostgreSQL3EXDI</package></attributes></shared-variable><shared-variable><name>Postgres64MacOSXInterfaceDictionary</name><environment>Database</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>PostgreSQL3EXDI</package></attributes></shared-variable><shared-variable><name>Postgres64SolarisInterfaceDictionary</name><environment>Database</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>PostgreSQL3EXDI</package></attributes></shared-variable><methods><class-id>Database.PostgresServerResponse</class-id> <category>initialize-release</category><body package="PostgreSQL3EXDI">initialize	self isHandled: false</body></methods><methods><class-id>Database.PostgresServerResponse</class-id> <category>accessing</category><body package="PostgreSQL3EXDI">activate	"Send my message(s) to the session. By default, do nothing."</body><body package="PostgreSQL3EXDI">activateOnRecipient: aSessionOrConnection	"Wrap the raw bytes of the stream's instvar in a stream, then parse them.  Return the parse, which will usually be self but may be another response, set its recipient and activate it."	^(self stream: (ReadStream on: stream))		recipient: aSessionOrConnection;		activate</body><body package="PostgreSQL3EXDI">allowedPriorStateTypes	^self subclassResponsibility</body><body package="PostgreSQL3EXDI">isHandled: anObject	isHandled := anObject</body><body package="PostgreSQL3EXDI">rawBytes: aByteArray	"Store the raw bytes in the stream's instvar, postponing wrapping them in a stream and parsing them."	stream := aByteArray.</body><body package="PostgreSQL3EXDI">recipient	^recipient</body><body package="PostgreSQL3EXDI">recipient: aSessionOrConnection	recipient := aSessionOrConnection</body><body package="PostgreSQL3EXDI">stream	^stream</body><body package="PostgreSQL3EXDI">stream: aStream	stream := aStream.</body><body package="PostgreSQL3EXDI">type	^self class name</body></methods><methods><class-id>Database.PostgresServerResponse</class-id> <category>testing</category><body package="PostgreSQL3EXDI">isHandled	^isHandled</body><body package="PostgreSQL3EXDI">isValid	"By default, assume any message is expected, and therefore valid."	^true</body></methods><methods><class-id>Database.PostgresServerResponse</class-id> <category>parsing</category><body package="PostgreSQL3EXDI">int16From2Bytes	"Convert two bytes into a 16-bit signed integer."	| ub aByteArray |	aByteArray := stream next: 2.	ub := UninterpretedBytes from: aByteArray.	^ub shortAt: 1 bigEndian: true</body><body package="PostgreSQL3EXDI">int32From4Bytes	"Convert a signed integer into a 32-bit, bigEndian byteArray. (LSByte is last.)"	"PostgresServerResponse new int32FromByteArray: #[0 1 2 255]"	"PostgresServerResponse new int32FromByteArray: #[255 0 1 2]"	"PostgresServerResponse new int32FromByteArray: (PgsqlConnection byteArrayFromInt32: (66303))"	"PostgresServerResponse new int32FromByteArray: (PgsqlConnection byteArrayFromInt32: (-16776958))"	| ub aByteArray |	aByteArray := stream next: 4.	ub := UninterpretedBytes from: aByteArray.	^ub longAt: 1 bigEndian: true</body><body package="PostgreSQL3EXDI">int8From1Byte	"Convert a byte into an 8-bit signed integer."	| aByteArray |	aByteArray := stream next: 1.	^aByteArray first asInteger</body><body package="PostgreSQL3EXDI">next4Bytes	| aByteArray |	aByteArray := stream next: 4.	^aByteArray</body><body package="PostgreSQL3EXDI">nextByte	| aByte |	aByte := stream next.	^aByte</body><body package="PostgreSQL3EXDI">nextManyCodeAndFieldStrings	"Each field string is preceded by a byte, which is the field type. The entire list ends with a 0 byte."	| fields fieldType fieldString |	fields := OrderedCollection new.	fieldType := self nextByte.	[fieldType ~= 0] whileTrue:			[fieldString := self nextTerminatedString.			fields add: ((Character value: fieldType) -&gt; fieldString).			fieldType := self nextByte].	^fields asArray</body><body package="PostgreSQL3EXDI">nextNBytes: aNumber	| aByteArray |	aByteArray := stream next: aNumber.	^aByteArray</body><body package="PostgreSQL3EXDI">nextNBytesOrSpecialCode: aNumber	"Return #NULL, #ZERO or a ByteArray, based on value of number."	| result |	result := aNumber = -1				ifTrue: [#NULL]				ifFalse: 					[aNumber = 0						ifTrue: [ #[] ]						ifFalse: 							[aNumber &gt; 0								ifTrue: [self nextNBytes: aNumber]								ifFalse: [self error: 'Negative length for data in #nextNBytesOrSpecialCode:']]].	^result</body><body package="PostgreSQL3EXDI">nextNDataColumns: aNumber	"Each column data is preceded by an Int32, which is either -1 (NULL and no data), 0 (no data) or N (N bytes)."	| columns length data |	columns := Array new: aNumber.	1 to: aNumber		do: 			[:i |			length := self int32From4Bytes.			data := self nextNBytesOrSpecialCode: length.			columns at: i put: data].	^columns</body><body package="PostgreSQL3EXDI">nextNFieldValues: aNumber	" Here's what  each field value looks like:			name              tableOID            attribute      typeOID   sizeModifier   typeModifier  format 			#( #(#STR ?) #(#INT32 ?) #(#INT16 ?) #(#INT32 ?) #(#INT16 ?) #(#INT32 ?) #(#INT16 ?) )"	| nFields field name tableOID attribute typeOID typeModifier format sizeModifier |	nFields := Array new: aNumber.	1 to: aNumber do:		[:i |		name := self nextTerminatedString.		tableOID := self int32From4Bytes.		attribute := self int16From2Bytes.		typeOID := self int32From4Bytes.		sizeModifier := self int16From2Bytes.		typeModifier := self int32From4Bytes.		format := self int16From2Bytes.		field := PostgresFieldDescription new				name: name;				tableOID: tableOID;			"table OID, or zero if not from table."				attribute: attribute;			"if a column, the attribute number of column. else zero."				typeOID: typeOID;			"OID of field's data type."				sizeModifier: sizeModifier;	"pg_type.typlen. size in bytes; -1 if has length word; -2 null term C string."				typeModifier: typeModifier;	"pg_attribute.atttypmod. Eg., max len of varchar; -1 if uneeeded."				format: format;				"0 for text, 1 for binary"				yourself.		nFields at: i put: field].	^nFields</body><body package="PostgreSQL3EXDI">nextNFormatCodes: aNumber	"Each format code is  is an Int16, either a 0 (text) or 1 (binary)."	| codes |	codes := Array new: aNumber.	1 to: aNumber do:		[:i | codes at: i put: self int16From2Bytes].	^codes</body><body package="PostgreSQL3EXDI">nextNint32: aNumber	"Each code (eg., OID) is an Int32."		| codes |	codes := Array new: aNumber.	1 to: aNumber do:		[:i | codes at: i put: (self int32From4Bytes)].	^codes</body><body package="PostgreSQL3EXDI">nextTerminatedString	| aByteArray |	aByteArray := stream through: 0.	aByteArray last = 0 ifFalse: [self error: 'String not terminated--implies not enough data.'].	^(aByteArray allButLast: 1) asString</body></methods><methods><class-id>Database.PostgresServerResponse class</class-id> <category>instance creation</category><body package="PostgreSQL3EXDI">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Database.PostgresServerResponse class</class-id> <category>accessing</category><body package="PostgreSQL3EXDI">buildMessageDictionary	| dict |	dict := Dictionary new.	dict at: $R put: Authentication.	dict at: $S put: ParameterStatus.	dict at: $K put: BackendKeyData.		dict at: $2 put: BindComplete.	dict at: $3 put: CloseComplete.	dict at: $C put: CommandComplete.	dict at: $d put: CopyData.	dict at: $c put: CopyDone.	dict at: $G put: CopyInResponse.	dict at: $H put: CopyOutResponse.	dict at: $W put: CopyBothResponse.	dict at: $D put: DataRow.	dict at: $I put: EmptyQueryResponse.	dict at: $E put: ErrorResponse.	dict at: $V put: FunctionCallResponse.	dict at: $n put: NoData.	dict at: $N put: NoticeResponse.	dict at: $A put: NotificationResponse.	dict at: $1 put: ParseComplete.	dict at: $s put: PortalSuspended.	dict at: $t put: ParameterDescription.	dict at: $Z put: ReadyForQuery.	dict at: $T put: RowDescription.	^dict</body><body package="PostgreSQL3EXDI">messageDictionary	^MessageDictionary ifNil: [MessageDictionary := self buildMessageDictionary]</body><body package="PostgreSQL3EXDI">rawMessage: code bytes: serverMsg	^(self messageDictionary at: code) new rawBytes: serverMsg</body></methods><methods><class-id>Database.ParameterDescription</class-id> <category>accessing</category><body package="PostgreSQL3EXDI">objectIDs	^objectIDs</body><body package="PostgreSQL3EXDI">objectIDs: anObject	objectIDs := anObject</body><body package="PostgreSQL3EXDI">stream: aStream	| numOIDs |	super stream: aStream.	numOIDs := self int16From2Bytes.	objectIDs := self nextNint32: numOIDs.</body></methods><methods><class-id>Database.SessionBasedResponse</class-id> <category>accessing</category><body package="PostgreSQL3EXDI">activate	self isValid ifFalse: [self error: 'Bad protocolState in ' , self class name].	recipient protocolState: self.</body></methods><methods><class-id>Database.SessionBasedResponse</class-id> <category>testing</category><body package="PostgreSQL3EXDI">isValid	"Verify that this message is consistent with the session's current protocol state."	^self allowedPriorStateTypes includes: recipient protocolStateType</body></methods><methods><class-id>Database.PostgresBuffer</class-id> <category>accessing</category><body package="PostgreSQL3EXDI">elementSize: anInteger	elementSize := anInteger</body><body package="PostgreSQL3EXDI">postgresType	^postgresType</body><body package="PostgreSQL3EXDI">postgresType: anInteger	postgresType := anInteger</body><body package="PostgreSQL3EXDI">value: aValueOrArray	"Store aValue into position 1 of the receiver.  Store the slots of an Array into the corresponding slots of the receiver, ensuring any remaining slots are nilled."	aValueOrArray class == Array ifFalse:		[^self at: 1 put: aValueOrArray]."For the rest of this method, aValueOrArray is an Array."	aValueOrArray isEmpty ifTrue:		[^self at: 1 put: aValueOrArray].	aValueOrArray size &gt; (count max: 1) ifTrue:		[^self error: (#errTooBigForBuffer &lt;&lt; #database &gt;&gt; 'too big for buffer')].	1 to: aValueOrArray size do:		[:index | self at: index put: (aValueOrArray at: index)].	aValueOrArray size + 1 to: count do:		[:index | self at: index put: nil].</body></methods><methods><class-id>Database.PostgresBuffer</class-id> <category>private-accessing</category><body package="PostgreSQL3EXDI">bufferPointer: aPointer	bufferPointer := aPointer</body><body package="PostgreSQL3EXDI">length	^length</body><body package="PostgreSQL3EXDI">length: anInteger	length := anInteger</body><body package="PostgreSQL3EXDI">postgresTypeFromDatabaseType	"Get the numeric postgres type number that corresponds to the type symbol we have obtained from the bindTemplate or the value's postgreSQLConversion or from the DB's column description.  If there is an entry in the static type map, use it.  If not, check for a dynamic database type, e.g. #Hstore, whose numeric value is database-specific, updating the connection's dynamic dictionary so we need not check again during the connection's lifetime.	If the database does not know the type, which may occur because it is a dynamic type whose extension is not implemented on that database or merely because the user made a typo in the bindTemplate, String (25) is returned as default - and is added to the dynamic dictionary, so for the remainder of that connection's life, the lookup (of the missing extension or typo bindtemplate) will not be repeated."	^ClassToPostgreSQLTypeMap		at: databaseType		ifAbsent: [bufferSession connection dynamicClassToPostgreSQLTypeMap					at: databaseType					ifAbsentPut: [bufferSession connection getTypeNumberFromDatabase: databaseType]]</body></methods><methods><class-id>Database.PostgresBuffer</class-id> <category>private-data conversion {put}</category><body package="PostgreSQL3EXDI">at: index putBoolean: aBoolean	self subclassResponsibility</body><body package="PostgreSQL3EXDI">at: index putByteArray: aByteArray	self subclassResponsibility</body><body package="PostgreSQL3EXDI">at: index putDate: aDate	self subclassResponsibility</body><body package="PostgreSQL3EXDI">at: index putDouble: aDouble	self subclassResponsibility</body><body package="PostgreSQL3EXDI">at: index putFixedPoint: aFixedPoint	self subclassResponsibility</body><body package="PostgreSQL3EXDI">at: index putFloat: aFloat	self subclassResponsibility</body><body package="PostgreSQL3EXDI">at: index putFraction: aFraction	"Convert Fractions to FixedPoints (more robust over the whole possible range than either asFloat or asDouble) with up to 15 digits of scale beyond their first or second significant digit (similar to Double).	If we wanted the precision of Float, we would preserve 6 digits, not 15.  Changing the precision of the 2 log: 10 value from Float, i.e. 0.30103, to Double does not not seem to be a significant driver, in part because the next couple of digits round to zero."	| num |	num := aFraction.	num := num reduced.	num := num asFixedPoint: (((num denominator highBit - num numerator highBit) max: 0) * 0.30103) floor + 15.	self at: index putFixedPoint: num.</body><body package="PostgreSQL3EXDI">at: index putInteger: anInteger	self subclassResponsibility</body><body package="PostgreSQL3EXDI">at: index putString: aString	self subclassResponsibility</body><body package="PostgreSQL3EXDI">at: index putTime: aTime	| str |	str := (String new: 16) writeStream.	self time: aTime writeTo: str.	self at: index putString: str contents.</body><body package="PostgreSQL3EXDI">at: index putTimestamp: aTimestamp	| str |	str := (String new: 32) writeStream.	self timestamp: aTimestamp writeTo: str.	self at: index putString: str contents.</body><body package="PostgreSQL3EXDI">at: index putTimestamptz: aTimestamp	"Unused;  awaiting hook class to invoke it.  (Meanwhile, ensure timezone data is correctly written by setting PostgresConnection defaultTimeZone to be the image's timezone name whenever an image's timezone is not that of its server.)"	| str |	str := (String new: 32) writeStream.	self timestamp: aTimestamp writeTo: str.	self offset: aTimestamp writeTo: str.	self at: index putString: str contents.</body><body package="PostgreSQL3EXDI">at: index putTimetz: aTime	"Unused;  awaiting hook class to invoke it.  (Meanwhile, ensure timezone data is correctly written by setting PostgresConnection defaultTimeZone to be the image's timezone name whenever an image's timezone is not that of its server.)"	| str |	str := (String new: 16) writeStream.	self time: aTime writeTo: str.	self		offset: (Timestamp				fromDate: Date today				andTime:  aTime)		writeTo: str.	self at: index putString: str contents.</body><body package="PostgreSQL3EXDI">offset: aTimestamp writeTo: aStream	| offset |	offset := (TimeZone default secondsFromUniversalAtLocal: aTimestamp) / 3600.	offset &lt; 0		ifFalse: [aStream nextPut: $+]		ifTrue: [aStream nextPut: $-].	offset abs &lt; 10 ifTrue: [aStream nextPut: $0].	offset abs printOn: aStream.</body><body package="PostgreSQL3EXDI">printDate: aDate	"Write to the database in a locale-independent way (aDate printString is locale-aware)."	| aStream monthString dayString |	aStream := WriteStream on: (String new: 16).	aStream		print: aDate year;		nextPut: $-.	monthString := aDate monthIndex printString.	monthString size = 1 ifTrue: [aStream nextPut: $0].	aStream nextPutAll: monthString.	aStream nextPut: $-.	dayString := aDate dayOfMonth printString.	dayString size = 1 ifTrue: [aStream nextPut: $0].	aStream nextPutAll: dayString.	^aStream contents</body><body package="PostgreSQL3EXDI">time: aTimestampOrTime writeTo: aStream	"Postgres stores time values to a maximum precision of microseconds only."	aStream		print: aTimestampOrTime hours;		nextPut: $:;		print: aTimestampOrTime minutes;		nextPut: $:;		print: aTimestampOrTime seconds;		nextPut: $.;		nextPutAll: ('000000' , aTimestampOrTime microseconds printString last: 6).</body><body package="PostgreSQL3EXDI">timestamp: aTimestamp writeTo: stream	"Postgres stores timestamp values to a maximum precision of microseconds only."	stream		print: aTimestamp year;		nextPut: $-;		print: aTimestamp month;		nextPut: $-;		print: aTimestamp day;		space.	self time: aTimestamp writeTo: stream.</body></methods><methods><class-id>Database.PostgresBuffer</class-id> <category>initialize-release</category><body package="PostgreSQL3EXDI">on: aValue position: position session: session	self subclassResponsibility</body></methods><methods><class-id>Database.PostgresBuffer</class-id> <category>testing</category><body package="PostgreSQL3EXDI">isUnicodeEncoding	| encodingString |	encodingString := (self encoding  first: 3) asUppercase.	^encodingString = 'UTF' or: [encodingString = 'UCS']</body></methods><methods><class-id>Database.PostgresBuffer</class-id> <category>private-data conversion {get}</category><body package="PostgreSQL3EXDI">localFromTimestamp: aTimestamp tzOffsetFrom: aStream	"Apply the postgres-client's offset to get universal time (GMT), then map that to this image's local time."	|  sign offset |	aStream atEnd ifTrue:	"TO REVIEW;  what does absence of offset mean for a tz type?  Should/can it happen? Should universalToLocal: still happen?"		[^aTimestamp].	sign := aStream skip: -1; next.	(sign = $ ) ifTrue: [^self error: 'Postgres returned TimeZone acronym or name, not time offset;  mapping to VisualWorks TimeZones must be plugged in here'].	offset := (Time readFrom: aStream) asSeconds.	sign = $+ ifTrue: [offset := offset negated].	^TimeZone default universalToLocal: (aTimestamp addSeconds: offset)</body><body package="PostgreSQL3EXDI">localFromTimestamptz: aTimestamp tzOffsetFrom: aStream	"If PostgresConnection defaultTimeZone is set, assume it agrees with the image's local timezone so do not convert."	^PostgresConnection defaultTimeZone isEmpty		ifFalse: [aTimestamp]		ifTrue: [self localFromTimestamp: aTimestamp tzOffsetFrom: aStream]</body><body package="PostgreSQL3EXDI">timeReadFrom: stream	"Postgres stores time values to a maximum precision of microseconds only."	| time microseconds |	time := Time readFrom: (stream upTo: $.) readStream.	microseconds := (stream upToEnd , '000000' first: 6) asNumber.	time milliseconds: microseconds // 1000.	time partialNanosecond: microseconds \\ 1000 * 1000.	^time</body><body package="PostgreSQL3EXDI">timetzReadFrom: aStream	"This method allows times and timestamps in 'with timezone' format to be read, respecting the VisualWorks image's timezone."	| timeString |	timeString := self upToTimeZone: aStream.	^self timeReadFrom: timeString readStream"When a TIMESTAMP WITH TIMEZONE value is written, postgres stores it as a universal time.  If the value is provided wih an offset, the universal time indicated by the offset is respected.  Otherwise, the writing postgres client determines the offset and this will be the server's offset unless the client has executed	set timezone to -08	or PST8PDTor	set timezone to PST8PDTor	set timezone to 'NZST-12NZDT'or similar to override it.  The latter two posix examples are better as they handle daylight saving effects.  (Postgres will also accept Olsen strings which can handle historic changes to daylight saving.)  If a user sets	PostgresConnection defaultTimeZone: aStringMatchingTheImageTimeZonethen every connection will set that timezone and, because it agrees with the image's timezone, timestamps will be read and written consistently.	If a local timestamp value is written to a timestamptz column on a remote server without a specified offset and without the postgres client's timezone being set to the local timezone, then the stored value will not be the time expected;  it will be the same local time value but in the server's timezone, e.g. midday in PST (where the server is) instead of midday in EST (where the client is).When  a TIMESTAMP WITH TIMEZONE value is read, postgres converts it to the reading client's timezone, which is the server's timezone unless, as above, the postgres client own timezone has been set.  So if someone whose postgres client's timezone is EST has done this and inserts a timestamp whose time part is 09:25:03, the postgres client offers 09:25:03-05 (or 09:25:03 EST or 09:25:03 America/NewYork, depending on the details of the postgres timezone configuration).  The server holds it as 14:25:03 (i.e. 14:25:03+00 or 14:25:03 UTC or 14:25:03 GMT).  If this value is then read by a client whose timezone is CET, the client provides 15:25:03+01 (or 15:25:03 CET or 15:25:03 France/Paris).	Postgres documentation advises against use of the TIME WITH TIMEZONE type (use TIMESTAMP WITH TIMEZONE instead)  because conversion is less meaningful in the absence of a date (i.e. daylight saving time status)."</body><body package="PostgreSQL3EXDI">upToTimeZone: aStream	"Replace this with upToAny: when that is in the VisualWorks base.  Answer a subcollection from position to the first occurrence (if any, exclusive) of + or - or a space.  The stream is left positioned after the matching member of aCollection.  If none of these are found, answer everything."	| newStream element |	newStream := (aStream contentsSpecies new: 64) writeStream.	[aStream atEnd] whileFalse:		[element := aStream next.		('+- ' includes: element) ifTrue:			[^newStream contents].		newStream nextPut: element].	^newStream contents</body></methods><methods><class-id>Database.PostgresBuffer class</class-id> <category>class initialization</category><body package="PostgreSQL3EXDI">initialize	"Initialize all the shared vars that are shared between both socket and libpq."	self initializeMaps.</body><body package="PostgreSQL3EXDI">initializeMaps	"Initialize the maps. Certain Postgres types, like #Hstore are dynamic and don't have fixed OID values, so their OIDs are instead captured dynamically by the connection on an as needed basis. See the method, PostgresConnection &gt;&gt;dynamicTypeOIDs."	PostgreSQLTypeToClassMap := IdentityDictionary new.	ClassToPostgreSQLTypeMap := IdentityDictionary new.	PutSelectorMap := IdentityDictionary new.	GetSelectorMap := IdentityDictionary new.	"Map PostgreSQL data types to Smalltalk class names."	PostgreSQLTypeToClassMap add: ( 16 -&gt; #Boolean ).	PostgreSQLTypeToClassMap add: ( 17 -&gt; #ByteArray ).	PostgreSQLTypeToClassMap add: ( 18 -&gt; #String ).	PostgreSQLTypeToClassMap add: ( 20 -&gt; #LargeInteger ).	PostgreSQLTypeToClassMap add: ( 21 -&gt; #SmallInteger ).	PostgreSQLTypeToClassMap add: ( 23 -&gt; #Integer ).	PostgreSQLTypeToClassMap add: ( 25 -&gt; #String ).	PostgreSQLTypeToClassMap add: ( 114 -&gt; #String ).  "Json"	PostgreSQLTypeToClassMap add: ( 3802 -&gt; #String ). "Jsonb"	PostgreSQLTypeToClassMap add: ( 700 -&gt; #Float ).	PostgreSQLTypeToClassMap add: ( 701 -&gt; #Double ).	PostgreSQLTypeToClassMap add: ( 790 -&gt; #Float ).	PostgreSQLTypeToClassMap add: ( 1042 -&gt; #String ).	PostgreSQLTypeToClassMap add: ( 1043 -&gt; #String ).	PostgreSQLTypeToClassMap add: ( 1082 -&gt; #Date ).	PostgreSQLTypeToClassMap add: ( 1083 -&gt; #Time ).	PostgreSQLTypeToClassMap add: ( 1266 -&gt; #Timetz ).	PostgreSQLTypeToClassMap add: ( 1114 -&gt; #Timestamp ).	PostgreSQLTypeToClassMap add: ( 1184 -&gt; #Timestamptz ).	PostgreSQLTypeToClassMap add: ( 1560 -&gt; #String ).		"#Bit - fixed length bit string of 0s and 1s"	PostgreSQLTypeToClassMap add: ( 1562 -&gt; #String ).		"#Varbit - variable length bit string of 0s and 1s"	PostgreSQLTypeToClassMap add: ( 1700 -&gt; #FixedPoint ).	PostgreSQLTypeToClassMap add: ( 2249 -&gt; #String ).	"Map Smalltalk classes' #postgreSQLConversion strings to PostgreSQL data types."	ClassToPostgreSQLTypeMap add: ( #Boolean -&gt; 16 ).	ClassToPostgreSQLTypeMap add: ( #ByteArray -&gt; 17 ).	ClassToPostgreSQLTypeMap add: ( #LargeByteArray -&gt; 17 ).	ClassToPostgreSQLTypeMap add: ( #LargeInteger -&gt; 20 ).	ClassToPostgreSQLTypeMap add: ( #Integer -&gt; 23 ).	ClassToPostgreSQLTypeMap add: ( #SmallInteger -&gt; 21 ).	ClassToPostgreSQLTypeMap add: ( #String -&gt; 25 ).	ClassToPostgreSQLTypeMap add: ( #LargeString -&gt; 25 ).	ClassToPostgreSQLTypeMap add: ( #Json -&gt; 114 ).	ClassToPostgreSQLTypeMap add: ( #Jsonb -&gt; 3802).	ClassToPostgreSQLTypeMap add: ( #Bit -&gt; 1560 ).		"How do we get a #Bit type?"	ClassToPostgreSQLTypeMap add: ( #Bit -&gt; 1562 ).		"How do we get a #Varbit type?"	ClassToPostgreSQLTypeMap add: ( #Float -&gt; 1700 ).	"check why not 700 ?"	ClassToPostgreSQLTypeMap add: ( #Double -&gt; 1700 ).	"check why not 701 ?"	ClassToPostgreSQLTypeMap add: ( #Fraction -&gt; 1700 ).	"same as Double"	ClassToPostgreSQLTypeMap add: ( #Date -&gt; 1082 ).	ClassToPostgreSQLTypeMap add: ( #Time -&gt; 1083 ).	ClassToPostgreSQLTypeMap add: ( #Timetz -&gt; 1266 ).	ClassToPostgreSQLTypeMap add: ( #Timestamp -&gt; 1114 ).	ClassToPostgreSQLTypeMap add: ( #Timestamptz -&gt; 1184 ).	ClassToPostgreSQLTypeMap add: ( #FixedPoint -&gt; 1700 ).	"Map the above type names to setter messages understood by PostgreSQLBuffer."	PutSelectorMap add: ( #Date -&gt;  #at:putDate: ).	PutSelectorMap add: ( #Boolean -&gt;  #at:putBoolean: ).	PutSelectorMap add: ( #ByteArray -&gt;  #at:putByteArray: ).	PutSelectorMap add: ( #LargeByteArray -&gt;  #at:putByteArray: ).	PutSelectorMap add: ( #Float -&gt;  #at:putFloat: ).	PutSelectorMap add: ( #Fraction -&gt;  #at:putFraction: ).	PutSelectorMap add: ( #Double -&gt;  #at:putDouble: ).	PutSelectorMap add: ( #Integer -&gt;  #at:putInteger: ).	PutSelectorMap add: ( #LargeInteger -&gt;  #at:putInteger: ).	PutSelectorMap add: ( #SmallInteger -&gt;  #at:putInteger: ).	PutSelectorMap add: ( #String -&gt;  #at:putString: ).	PutSelectorMap add: ( #LargeString -&gt;  #at:putString: ).	PutSelectorMap add: ( #Bit -&gt;  #at:putString: ).	PutSelectorMap add: ( #Time -&gt;  #at:putTime: ).	PutSelectorMap add: ( #Timetz -&gt;  #at:putTime: ).	"defer till we have a TimeTZ class, when we can use #at:putTimetz: "		"We don't need the line above for Glorp because GlorpPGTimeWithTimeZone&gt;&gt;converterForStType:		handles it.  GlorpPGTimestampWithTimeZone does not have this method so we do need the line below."	PutSelectorMap add: ( #Timestamptz -&gt;  #at:putTimestamp: ).	"defer till we have a TimestampTZ class, when we can use #at:putTimestamptz: "	PutSelectorMap add: ( #Timestamp -&gt;  #at:putTimestamp: ).	PutSelectorMap add: ( #FixedPoint -&gt;  #at:putFixedPoint: ).	"Map the type names to getter messages in the shared var."	GetSelectorMap add: ( #Date -&gt;  #getDateAt: ).	GetSelectorMap add: ( #Boolean -&gt;  #getBooleanAt: ).	GetSelectorMap add: ( #ByteArray -&gt;  #getByteArrayAt: ).	GetSelectorMap add: ( #Float -&gt;  #getFloatAt: ).	GetSelectorMap add: ( #Double -&gt;  #getDoubleAt: ).	GetSelectorMap add: ( #Fraction -&gt;  #getDoubleAt: ).	GetSelectorMap add: ( #Integer -&gt;  #getIntegerAt: ).	GetSelectorMap add: ( #LargeInteger -&gt;  #getIntegerAt: ).	GetSelectorMap add: ( #SmallInteger -&gt;  #getIntegerAt: ).	GetSelectorMap add: ( #String -&gt;  #getStringAt: ).	GetSelectorMap add: ( #Bit -&gt;  #getStringAt: ).	GetSelectorMap add: ( #Time -&gt;  #getTimeAt: ).	GetSelectorMap add: ( #Timetz -&gt;  #getTimetzAt: ).		"Note that GlorpPGTimeWithTimeZone&gt;&gt;converterForStType: handles time/timetz conversion.		However we do need the above line to pass the GlorpDBTypeTests for timetz.  By contrast, the		GlorpPGTimestampWithTimeZone type does not have a converter method."	GetSelectorMap add: ( #Timestamptz -&gt;  #getTimestamptzAt: ).	GetSelectorMap add: ( #Timestamp -&gt;  #getTimestampAt: ).	GetSelectorMap add: ( #FixedPoint -&gt;  #getFixedPointAt: )."From the postgres pg_type tableBOOLOID   16 BYTEAOID   17 CHAROID   18 NAMEOID   19 INT8OID   20INT2OID   21 INT4OID   23 TEXTOID   25 FLOAT4OID   700 FLOAT8OID   701 	 ABSTIMEOID   702 	 RELTIMEOID   703 	 TINTERVALOID   704 BPCHAROID   1042 VARCHAROID   1043 DATEOID   1082 TIMEOID   1083 TIMESTAMPOID   1114 	 TIMESTAMPTZOID   1184 	 INTERVALOID   1186 	 TIMETZOID   1266 BITOID   1560 VARBITOID   1562 NUMERICOID   1700"</body></methods><methods><class-id>Database.PostgresSocketBuffer</class-id> <category>accessing</category><body package="PostgreSQL3EXDI">at: anIndex	"Answer the object in the buffer at anIndex. Intervene to return nil if the buffer holds #NULL instead of a ByteArray."	^(self blockOfData at: anIndex) = #NULL	"ifTrue return nil"		ifFalse: [self perform: getSelector with: anIndex]</body><body package="PostgreSQL3EXDI">at: anIndex put: anObject	"Store anObject into the buffer at anIndex."	^anObject		ifNil: [self blockOfData at: anIndex put: #NULL]		ifNotNil: [self perform: putSelector with: anIndex with: anObject]</body><body package="PostgreSQL3EXDI">connection	^bufferSession connection</body><body package="PostgreSQL3EXDI">isBinary	^isBinary</body><body package="PostgreSQL3EXDI">isNull	^isNull</body><body package="PostgreSQL3EXDI">isUnsigned	^isUnsigned</body><body package="PostgreSQL3EXDI">isUsingBase64	^self connection isUsingBase64</body><body package="PostgreSQL3EXDI">usesIntegerDatetimes	| conn |	^(conn := self connection)		ifNotNil: [conn activeParameters at: 'integer_datetimes' ifAbsent: ['']]</body><body package="PostgreSQL3EXDI">valueAsByteArray	^self blockOfData at: 1</body></methods><methods><class-id>Database.PostgresSocketBuffer</class-id> <category>private-accessing</category><body package="PostgreSQL3EXDI">blockOfData	^blockOfData</body><body package="PostgreSQL3EXDI">blockOfData: anObject	blockOfData := anObject</body><body package="PostgreSQL3EXDI">free	"We don't have any allocated memory, but we must implement this method as part of the expected buffer protocol."</body></methods><methods><class-id>Database.PostgresSocketBuffer</class-id> <category>private-data conversion {put}</category><body package="PostgreSQL3EXDI">at: index putBoolean: aBoolean	self at: index putString: (aBoolean ifTrue: ['t'] ifFalse: ['f'])</body><body package="PostgreSQL3EXDI">at: index putByteArray: aByteArray	"Transmit bound ByteArrays in Base64 or raw format. Since our base64 encoder adds CRs for MIME, we need to remove the CRs."	| encodedByteArray |	encodedByteArray := self isUsingBase64		ifTrue: [Base64FastCoder encodeAsBase64ByteArray: aByteArray]		ifFalse: [aByteArray].	self at: index putBytes: encodedByteArray</body><body package="PostgreSQL3EXDI">at: index putBytes: aByteArray	"Transmit these bytes in raw format, binary."	self blockOfData at: index put: aByteArray</body><body package="PostgreSQL3EXDI">at: index putDate: aDate	self at: index putBytes:		((self printDate: aDate)			asByteArrayEncoding: self encoding).</body><body package="PostgreSQL3EXDI">at: index putDouble: aDouble	self at: index putReal: aDouble</body><body package="PostgreSQL3EXDI">at: index putFixedPoint: aFixedPoint	"Put a string version of aFixedPoint, without the trailng $s into the buffer."	| strm str |	strm := (String new: 40) writeStream.	aFixedPoint printOn: strm.	strm skip: -1.	str := strm contents.	self at: index putBytes: (str asByteArrayEncoding: self encoding).</body><body package="PostgreSQL3EXDI">at: index putFloat: aFloat	self at: index putReal: aFloat</body><body package="PostgreSQL3EXDI">at: index putInteger: anInteger	"Hold the string as a ByteArray."	self at: index putBytes: (anInteger printString asByteArrayEncoding: self encoding).</body><body package="PostgreSQL3EXDI">at: index putReal: aFloatingPointValue	"Hold the printed value as a ByteArray."	| str |	str := aFloatingPointValue printString.	str := str last isDigit		ifTrue: [str collect: [:char | char = $d ifFalse: [char] ifTrue: [$e]]]		ifFalse: [str allButLast: 1].	self at: index putBytes: (str asByteArrayEncoding: self encoding).</body><body package="PostgreSQL3EXDI">at: index putString: aString	"Hold the string as a ByteArray."	self at: index putBytes: (aString asByteArrayEncoding: self encoding).</body></methods><methods><class-id>Database.PostgresSocketBuffer</class-id> <category>private-data conversion {get}</category><body package="PostgreSQL3EXDI">getBinaryIntegerAt: index 	"Answer a signed or unsigned Integer populated from the binary buffer.  This method expects the byteArray to be either 2, 4 or 8 bytes long."	| conversionBuffer signedMethods unsignedMethods size method |	signedMethods := Dictionary new at: 2 put: #shortAt:bigEndian:; at: 4 put: #longAt:bigEndian:; at: 8 put: #longLongAt:bigEndian:; yourself.	unsignedMethods := Dictionary new at: 2 put: #unsignedShortAt:bigEndian:; at: 4 put: #unsignedLongAt:bigEndian:; at: 8 put: #unsignedLongLongAt:bigEndian:; yourself.	conversionBuffer := UninterpretedBytes from: (self blockOfData at: index).	size := conversionBuffer size.	method := self isUnsigned		ifTrue: [unsignedMethods at: size]		ifFalse: [signedMethods at: size].	^conversionBuffer perform: method with: 1 with: true.</body><body package="PostgreSQL3EXDI">getBooleanAt: index	"Answer true or false based on the buffer value at index."	| string |	^self isBinary		ifTrue: [self error: 'not yet implemented']		ifFalse: 			[string := self getStringAt: index.			't' = string]</body><body package="PostgreSQL3EXDI">getByteArrayAt: index	"Answer a ByteArray populated from the buffer."	| firstStage |	firstStage := self getBytesAt: index.	^self isUsingBase64		ifTrue: [Base64FastCoder decodeBase64Encoded: firstStage]		ifFalse: [firstStage]</body><body package="PostgreSQL3EXDI">getBytesAt: index	"Answer a ByteArray populated from the buffer. The data can be in hex form (the default for modern postgres) like '\xEA1243' or '\xa00b0210ff00', or base64 the older default."	| aStream bytes |	bytes := self blockOfData at: index.	bytes isNil ifTrue: [^nil].	aStream := bytes asString readStream.	^(aStream size &gt; 1 and: [(aStream next: 2) = '\x'])		ifTrue: [ByteArray fromHexString: aStream upToEnd]		ifFalse: [bytes]</body><body package="PostgreSQL3EXDI">getDateAt: index 	| conversionBuffer str |	^self isBinary		ifTrue: 			[conversionBuffer := UninterpretedBytes from: (self blockOfData at: index).			self error: 'Date conversion from binary format not yet implemented.']		ifFalse: 			[str := self getStringAt: index.			Date readFrom: str readStream]</body><body package="PostgreSQL3EXDI">getDoubleAt: index	"Answer a Double populated from the buffer.  (Assume: buffer has least 8 bytes.)"	| conversionBuffer str |	^self isBinary		ifTrue: 			[conversionBuffer := UninterpretedBytes from: (self blockOfData at: index).			conversionBuffer doubleAt: 1]		ifFalse: 			[str := self getStringAt: index.			"Change E to e to help Fixedpoint conversion."			str := str copyReplaceAll: 'E' with: 'e'.			Double readFrom: str readStream]</body><body package="PostgreSQL3EXDI">getFixedPointAt: index	"Answer a FixedPoint number populated from the buffer."	| str |	str := self getStringAt: index.	"Change E to e to help FixedPoint conversion."	str := str copyReplaceAll: 'E' with: 'e'. 	^FixedPoint readFrom: str readStream</body><body package="PostgreSQL3EXDI">getFloatAt: index	"Answer a float populated from the buffer."	| conversionBuffer str |	^self isBinary		ifTrue: 			[conversionBuffer := UninterpretedBytes from: (self blockOfData at: index).			conversionBuffer floatAt: 1]		ifFalse: 			[str := self getStringAt: index.			"Change E to e to help Float conversion."			str := str copyReplaceAll: 'E' with: 'e'.			Float readFrom: str readStream]</body><body package="PostgreSQL3EXDI">getIntegerAt: index	"Answer an integer pulated from the buffer."	| str |	^self isBinary		ifTrue: [self getBinaryIntegerAt: index]		ifFalse: 			[str := self getStringAt: index.			Integer readFrom: str readStream]</body><body package="PostgreSQL3EXDI">getStringAt: index	| byteArray |	byteArray := self blockOfData at: index.	^byteArray asStringEncoding: self encoding</body><body package="PostgreSQL3EXDI">getTimeAt: index	"Postgres stores timestamp values to a maximum precision of microseconds only."	^self isBinary		ifTrue: [self error: 'Time conversion from binary format not yet implemented.']		ifFalse: [self timeReadFrom: (self getStringAt: index) readStream]</body><body package="PostgreSQL3EXDI">getTimestampAt: index	"Postgres stores timestamp values to a maximum precision of microseconds only."	| stream |	^self isBinary		ifTrue:			[UninterpretedBytes from: (self blockOfData at: index).			self error: 'Timestamp conversion from binary format not yet implemented.']		ifFalse:			[stream := (self getStringAt: index) readStream.			Timestamp				fromDate: (Date readFrom: (stream upTo: $ ) readStream)				andTime: (self timeReadFrom: stream)]</body><body package="PostgreSQL3EXDI">getTimestamptzAt: index	"Assumes the postgres client's timezone and the image's timezone are the same;  see #timetzReadFrom: comment."	| stream |	^self isBinary		ifTrue: [self error: 'Timestamp conversion from binary format not yet implemented.']		ifFalse:			[stream := (self getStringAt: index) readStream.			self				localFromTimestamptz:					(Timestamp						fromDate: (Date readFrom: (stream upTo: $ ) readStream)						andTime: (self timetzReadFrom: stream))				tzOffsetFrom: stream]</body><body package="PostgreSQL3EXDI">getTimetzAt: index	"Assumes the postgres client's timezone and the image's timezone are the same;  see #timetzReadFrom: comment."	| stream|	^self isBinary		ifTrue: [self error: 'Time conversion from binary format not yet implemented.']		ifFalse:			[stream := (self getStringAt: index) readStream.			(self localFromTimestamp:				(Timestamp					fromDate: Date today					andTime: (self timetzReadFrom: stream))				tzOffsetFrom: stream) asTime]</body></methods><methods><class-id>Database.PostgresSocketBuffer</class-id> <category>initialize-release</category><body package="PostgreSQL3EXDI">columnDescription: aColDesc position: position session: aSession	| aDatabaseType smalltalkType |	aDatabaseType := aColDesc type.	self elementSize: nil count: (aSession blockFactor) databaseType: aDatabaseType.	isNullable := aColDesc nullable.	isBinary := aColDesc isBinary.	isUnsigned := aColDesc isUnsigned.	bufferIndex := position.	bufferSession := aSession.	encoding := bufferSession encoding.	self blockOfData: (Array new: (self count max: 1)).	self value: nil.	smalltalkType := PostgreSQLTypeToClassMap		at: databaseType		ifAbsent: [bufferSession connection dynamicPostgreSQLTypeToClassMap					at: databaseType					ifAbsent: [#String]].	getSelector := GetSelectorMap at: smalltalkType ifAbsent: [#getStringAt:].	putSelector := PutSelectorMap at: smalltalkType ifAbsent: [#at:putString:].</body><body package="PostgreSQL3EXDI">on: aValue position: position session: aSession	"Initialize an instance of receiver which is set up to hold aValue.  This method does not remember the actual value, but gets ready for it.  Note: the databaseType is the type of data that we are sending--not necessarily the type of the destination column. The api will translate for us."	bufferIndex := position.	bufferSession := aSession.	self encoding: bufferSession encoding.	databaseType := aSession		bindTemplateAt: position		orUpdateWith: aValue postgreSQLConversion.	"We need the databaseType to be a symbol always for setStatementNameFromQueryAndTypes.  If that is changed, discard this."	databaseType isNil ifTrue: [databaseType := #nil].	isBinary := databaseType = #ByteArray.	self elementSize: 0 count: 0 databaseType: databaseType.	self blockOfData: (Array new: (self count max: 1)).	aValue isNil ifTrue:		[self elementSize: 1.		self postgresType: 0.		^self].	self postgresType: self postgresTypeFromDatabaseType.	putSelector := PutSelectorMap at: aValue postgreSQLConversion ifAbsent: [nil].</body></methods><methods><class-id>Database.Authentication</class-id> <category>accessing</category><body package="PostgreSQL3EXDI">authenticate	^true</body><body package="PostgreSQL3EXDI">authenticateConnection: aConnection username: username password: pw	^self subclassResponsibility</body><body package="PostgreSQL3EXDI">stream: aStream	| code |	stream := aStream.	code := self int32From4Bytes.	code = 0 ifTrue: [^AuthenticationOk new].	code = 3 ifTrue: [^AuthenticationCleartextPassword new stream: aStream].	code = 5 ifTrue: [^AuthenticationMD5 new stream: stream].	"Unsupported as yet"	code = 2 ifTrue: [^AuthenticationUnsupported new type: #AuthenticationKerberosV5].	code = 6 ifTrue: [^AuthenticationUnsupported new type: #AuthenticationSCMCredential].	code = 7 ifTrue: [^AuthenticationUnsupported new type: #AuthenticationGSS].	code = 8 ifTrue: [^AuthenticationUnsupported new type: #AuthenticationGSSContinueData].	code = 9 ifTrue: [^AuthenticationUnsupported new type: #AuthenticationSSPI].</body></methods><methods><class-id>Database.AuthenticationUnsupported</class-id> <category>accessing</category><body package="PostgreSQL3EXDI">authenticateConnection: aConnection username: username password: pw	| dbError |	dbError := PostgresSocketConnection errorClass new.	dbError		dbmsErrorCode: '';		dbmsErrorString: 'Unsupported authentication type, ' , self type asString.	PostgresSocketConnection unableToConnectToSQLserverSignal		raiseWith: (Array with: dbError)		errorString: dbError dbmsErrorString</body><body package="PostgreSQL3EXDI">type	^type</body><body package="PostgreSQL3EXDI">type: anObject	type := anObject</body></methods><methods><class-id>Database.DataRow</class-id> <category>accessing</category><body package="PostgreSQL3EXDI">allowedPriorStateTypes	^#(#RowDescription #DataRow)</body><body package="PostgreSQL3EXDI">columnData	^columnData</body><body package="PostgreSQL3EXDI">columnData: anObject	columnData := anObject</body><body package="PostgreSQL3EXDI">stream: aStream	| numColumns |	stream := aStream.	numColumns := self int16From2Bytes.	columnData := self nextNDataColumns: numColumns.</body></methods><methods><class-id>Database.PostgresError</class-id> <category>pqlib</category><body package="PostgreSQL3EXDI">severity	^severity</body><body package="PostgreSQL3EXDI">severity: aString	severity := aString</body><body package="PostgreSQL3EXDI">sqlState	^sqlState</body><body package="PostgreSQL3EXDI">sqlState: aString	sqlState := aString</body></methods><methods><class-id>Database.PostgresError</class-id> <category>testing</category><body package="PostgreSQL3EXDI">isError	| sev |	sev := self severity.	^sev isNil or: [sev = 'ERROR' or: [sev = 'FATAL' or: [sev = 'PANIC' ]]]"Is the line above faster or slower than	^#(nil 'ERROR' 'FATAL' 'PANIC') includes: self severitynot that it matters much, just asking."</body></methods><methods><class-id>Database.PostgresError</class-id> <category>socket</category><body package="PostgreSQL3EXDI">fromErrorResponse: anErrorResponse	| associations anArray |	anArray :=  anErrorResponse codeAndFieldAssociations.	associations := anArray size &gt; 1				ifTrue: [anArray]				ifFalse: [Array with: $M -&gt; (anArray first)].	self dbmsErrorCode: (associations detect: [:assoc | assoc key = $C]				ifNone: [$C -&gt; 'not found']) value.	self dbmsErrorString: (associations detect: [:assoc | assoc key = $M]				ifNone: [$M -&gt; 'not found']) value.</body></methods><methods><class-id>Database.IOTimedBuffer</class-id> <category>private</category><body package="PostgreSQL3EXDI">readBufferStartingAt: pos	"This method is borrowed from an idea expressed by Martin. It waits until some socket input data is available, or throws an exception.	There is no check that all of expected data has arrived, so the process will nonetheless block if not."	^(input readWaitWithTimeoutMs: timeoutMS)		ifTrue: 			[TimeoutExceeded raiseSignal.			0]		ifFalse: [super readBufferStartingAt: pos]</body></methods><methods><class-id>Database.IOTimedBuffer</class-id> <category>accessing</category><body package="PostgreSQL3EXDI">timeoutMS	^timeoutMS</body><body package="PostgreSQL3EXDI">timeoutMS: anInteger	"Milliseconds I will pass as parameter to #readWaitWithTimeoutMs: calls on the socket."	timeoutMS := anInteger</body></methods><methods><class-id>Database.ReadyForQuery</class-id> <category>convenience</category><body package="PostgreSQL3EXDI">transactionStatusString	self transactionStatus = $I ifTrue: [^'NotInTransaction'].	self transactionStatus = $T ifTrue: [^'InTransaction'].	self transactionStatus = $E ifTrue: [^'InFailedTransaction'].</body></methods><methods><class-id>Database.ReadyForQuery</class-id> <category>accessing</category><body package="PostgreSQL3EXDI">allowedPriorStateTypes	"We allow nil for prior state for both Simple (unbound) and Extended (bound-capable) queries."	^recipient needBinding		ifTrue: [#(nil #EmptyQueryResponse #CommandComplete #CloseComplete #ErrorResponse)]		ifFalse: [#(nil #EmptyQueryResponse #CommandComplete #ErrorResponse)]</body><body package="PostgreSQL3EXDI">stream: aStream	| transactionStatusCode |	stream := aStream.	transactionStatusCode := stream next.	transactionStatus := Character value: transactionStatusCode.	('ITE' includes: transactionStatus) ifFalse:		[self error: 'Invalid byteCode (' , transactionStatus printString , ') byteCode in #ReadyForQuery:'].</body><body package="PostgreSQL3EXDI">transactionStatus	^transactionStatus</body></methods><methods><class-id>Database.ReadyForQuery</class-id> <category>testing</category><body package="PostgreSQL3EXDI">isValid	^recipient class ~~ PostgresSocketSession or: [super isValid]</body></methods><methods><class-id>Database.AuthenticationMD5</class-id> <category>accessing</category><body package="PostgreSQL3EXDI">authenticateConnection: aConnection username: username password: pw	| msg authentication  |	msg := aConnection msgPassword: pw username: username salt: salt.	authentication := aConnection responseForMessage: msg.	^authentication</body><body package="PostgreSQL3EXDI">salt	^salt</body><body package="PostgreSQL3EXDI">salt: anObject	salt := anObject</body><body package="PostgreSQL3EXDI">stream: aStream	stream := aStream.	salt := self next4Bytes.</body></methods><methods><class-id>Database.CloseComplete</class-id> <category>accessing</category><body package="PostgreSQL3EXDI">activate	"A closeStatement message has been acknowledged by the server. Our next two messages are expected to be #parseComplete, then #bindComplete."	super activate.	recipient nextServerMessage</body><body package="PostgreSQL3EXDI">allowedPriorStateTypes	^#(nil)</body></methods><methods><class-id>Database.CommandComplete</class-id> <category>accessing</category><body package="PostgreSQL3EXDI">activate	super activate.	recipient rowCount: self rowCount.</body><body package="PostgreSQL3EXDI">allowedPriorStateTypes	^recipient needBinding		ifTrue: [#(#RowDescription #NoData #DataRow)]		ifFalse: [#(nil #RowDescription #DataRow #CommandComplete)]</body><body package="PostgreSQL3EXDI">name	^name</body><body package="PostgreSQL3EXDI">name: anObject	name := anObject</body><body package="PostgreSQL3EXDI">rowCount	^rowCount</body><body package="PostgreSQL3EXDI">rowCount: anObject	rowCount := anObject</body><body package="PostgreSQL3EXDI">stream: aStream	| backwardsNum |	stream := aStream.	name := self nextTerminatedString.	backwardsNum := name reverse copyUpTo: Character space.	rowCount := Integer readFrom: backwardsNum reverse readStream.</body></methods><methods><class-id>Database.CommandComplete</class-id> <category>testing</category><body package="PostgreSQL3EXDI">isValid	^recipient class ~~ PostgresSocketSession or: [super isValid]</body></methods><methods><class-id>Database.PostgresLibpqBuffer</class-id> <category>private-data conversion {put}</category><body package="PostgreSQL3EXDI">at: anIndex put: anObject	"Store anObject into the buffer at anIndex."	anObject isNil		ifTrue: [ self lengthsPointer at: (anIndex -1) put: -1. ]		ifFalse:[ 			self perform: putSelector with: (anIndex - 1) with: anObject 		].	^anObject</body><body package="PostgreSQL3EXDI">at: index putBoolean: aBoolean	self at: index putString: (aBoolean ifTrue: ['t'] ifFalse: ['f'])</body><body package="PostgreSQL3EXDI">at: index putByteArray: aByteArray	self at: index putString: (Base64FastCoder encodeAsBase64String: aByteArray).</body><body package="PostgreSQL3EXDI">at: index putDate: aDate	self at: index putString: (self printDate: aDate).</body><body package="PostgreSQL3EXDI">at: index putDouble: aDouble	self at: index putFixedPoint: (aDouble asFixedPointOfPrecision: 16).</body><body package="PostgreSQL3EXDI">at: index putFixedPoint: aFixedPoint	| str num |	num := aFixedPoint.	str := num printString.	self at: index putString: (str allButLast: 1).</body><body package="PostgreSQL3EXDI">at: index putFloat: aFloat	self at: index putFixedPoint: (aFloat asFixedPointOfPrecision: 9)</body><body package="PostgreSQL3EXDI">at: index putInteger: anInteger	self at: index putString: anInteger printString</body><body package="PostgreSQL3EXDI">at: index putString: aString	"Put aString into the buffer."	| str bytes stringValue |	aString class name == #Character ifTrue: [		stringValue := String with: aString	] ifFalse: [		stringValue := aString	].	str := stringValue asByteArrayEncoding: self encoding.	bytes := str size.	self pointer isNil ifTrue: [		self elementSize: (bytes + 1).		self mallocUsingSelector: bufferSession xif mallocSelector.	].	bufferPointer copyAt: (index * elementSize) from: str size: bytes startingAt: 1.	bufferPointer at: bytes put: 0.	lengthsPointer at: index put: bytes.</body></methods><methods><class-id>Database.PostgresLibpqBuffer</class-id> <category>testing</category><body package="PostgreSQL3EXDI">isForMoney	^self postgresType == 790</body></methods><methods><class-id>Database.PostgresLibpqBuffer</class-id> <category>private-accessing</category><body package="PostgreSQL3EXDI">bufferValue	^bufferValue</body><body package="PostgreSQL3EXDI">format	^format</body><body package="PostgreSQL3EXDI">format: anInteger	format := anInteger</body><body package="PostgreSQL3EXDI">lengthsPointer	lengthsPointer isNil ifTrue: [		lengthsPointer := CIntegerType long perform: bufferSession xif mallocSelector with: (count max: 1)	].	^lengthsPointer</body></methods><methods><class-id>Database.PostgresLibpqBuffer</class-id> <category>accessing</category><body package="PostgreSQL3EXDI">setValue: aValue	"Store aValueOrArray into the receiver."	bufferValue := aValue</body></methods><methods><class-id>Database.PostgresLibpqBuffer</class-id> <category>binding</category><body package="PostgreSQL3EXDI">bindForInput	"Binding contents of the receiver to the server."	"We won't re-use pointers."	(bufferPointer isNil)		ifFalse: [ self free ].	"self mallocUsingSelector: bufferSession xif mallocSelector."	self value: bufferValue.</body></methods><methods><class-id>Database.PostgresLibpqBuffer</class-id> <category>allocation</category><body package="PostgreSQL3EXDI">free	"Free the receiver."	lengthsPointer notNil ifTrue: [  		lengthsPointer freePointer.		lengthsPointer := nil	].	super free.</body><body package="PostgreSQL3EXDI">mallocUsingSelector: mallocSelector	"Allocate a physical buffer for the receiver. Use mallocSelector to perform the allocation." 	"Assume: the get and put methods will coerce the bufferPointer correctly."	"Assert: mallocSelector is either #malloc: or #malloc16:"	[ "Begin unwind protection."		super mallocUsingSelector: mallocSelector.		lengthsPointer isNil ifTrue: [			lengthsPointer := CIntegerType long perform: mallocSelector with: (count max: 1)		].	"End unwind protection." ]		ifCurtailed: [ self free ]</body></methods><methods><class-id>Database.PostgresLibpqBuffer</class-id> <category>private-data conversion {get}</category><body package="PostgreSQL3EXDI">getBooleanAt: index	"Answer a Boolean as described in the first byte pointed to by the buffer."	^bufferValue = 't'</body><body package="PostgreSQL3EXDI">getByteArrayAt: index	| aStream |	aStream := bufferValue readStream.	^Base64FastCoder decodeBase64Encoded:		((aStream size &gt; 1 and: [(aStream next: 2) = '\x'])			ifFalse: [aStream contents]			ifTrue: [ByteArray fromHexString: aStream upToEnd asUppercase])</body><body package="PostgreSQL3EXDI">getDateAt: index	^Date readFrom: bufferValue readStream</body><body package="PostgreSQL3EXDI">getDoubleAt: index	^Double readFrom: bufferValue readStream</body><body package="PostgreSQL3EXDI">getFixedPointAt: index	^FixedPoint readFrom: bufferValue readStream</body><body package="PostgreSQL3EXDI">getFloatAt: index	self isForMoney ifTrue: [		^bufferValue	] ifFalse: [		^bufferValue asNumber	]</body><body package="PostgreSQL3EXDI">getIntegerAt: index	^bufferValue asNumber</body><body package="PostgreSQL3EXDI">getStringAt: index	^bufferValue</body><body package="PostgreSQL3EXDI">getTimeAt: index	"Postgres stores time values to a maximum precision of microseconds only."	^self timeReadFrom: bufferValue readStream</body><body package="PostgreSQL3EXDI">getTimestampAt: index	"Postgres stores timestamp values to a maximum precision of microseconds only."	| stream |	stream := bufferValue readStream.	^Timestamp		fromDate: (Date readFrom: (stream upTo: $ ) readStream)		andTime: (self timeReadFrom: stream)</body><body package="PostgreSQL3EXDI">getTimestamptzAt: index	"Assumes the postgres client's timezone and the image's timezone are the same;  see #timetzReadFrom: comment."	| stream |	stream := bufferValue readStream.	^self		localFromTimestamptz:			(Timestamp				fromDate: (Date readFrom: (stream upTo: $ ) readStream)				andTime: (self timetzReadFrom: stream))		tzOffsetFrom: stream</body><body package="PostgreSQL3EXDI">getTimetzAt: index	"Assumes the postgres client's timezone and the image's timezone are the same;  see #timetzReadFrom: comment."	| stream |	stream := bufferValue readStream.	^(self localFromTimestamp:		(Timestamp			fromDate: Date today			andTime: (self timetzReadFrom: stream))		tzOffsetFrom: stream) asTime</body><body package="PostgreSQL3EXDI">getValueAt: index	^bufferValue := self perform: getSelector with: index</body></methods><methods><class-id>Database.PostgresLibpqBuffer</class-id> <category>initialize-release</category><body package="PostgreSQL3EXDI">descriptor: aColDesc position: position session: session	"Initialize an instance of receiver which is set up to hold values as described."	bufferIndex := position.	bufferSession := session.	self encoding: session encoding.	self postgresType: aColDesc type.	databaseType := PostgreSQLTypeToClassMap		at: self postgresType		ifAbsent: [bufferSession connection dynamicPostgreSQLTypeToClassMap					at: databaseType					ifAbsent: [#String]]. 	self elementSize: aColDesc maxColumnConstraint.	self format: aColDesc format.	count := 0.	getSelector := GetSelectorMap at: self databaseType ifAbsent: [#getStringAt:].</body><body package="PostgreSQL3EXDI">on: aValue position: position session: session	"Initialize the buffer parameters from the value and session data.  Since we currently always set format 0 not 1 (i.e. string not binary), use the value's type only to choose the putSelector.  (This saves having to make general putSelector's handle more specific types if e.g. an Integer is input to a FixedPoint-accepting field.)  If there is a bindTemplate whose type is as or more general than the value's type, use it.  If it is less general and the statement is prepared, it must be deallocated and reprepared:  the prepared statement held against the supplied name is too specific for the values supplied."	bufferIndex := position.	bufferSession := session.	self encoding: session encoding.	bufferValue := aValue.	self format: 0.	count := 0.		databaseType := session		bindTemplateAt: position		orUpdateWith: aValue postgreSQLConversion.	"We need the databaseType to be a symbol always for setStatementNameFromQueryAndTypes.  If that is changed, discard this."	databaseType isNil ifTrue: [databaseType := #nil].	aValue isNil ifTrue:		[self elementSize: 1.		self postgresType: 0.		^self].	self postgresType: self postgresTypeFromDatabaseType.	putSelector := PutSelectorMap at: aValue postgreSQLConversion ifAbsent: [nil].</body></methods><methods><class-id>Database.PostgresSession</class-id> <category>private-accessing</category><body package="PostgreSQL3EXDI">bindTemplate	^bindTemplate</body><body package="PostgreSQL3EXDI">bindTemplate: anArray	"See bindTemplateAt:orUpdateWith: - we must be able to edit the bind template."	super bindTemplate:		(anArray isImmutable			ifTrue: [anArray copy]			ifFalse: [anArray]).</body><body package="PostgreSQL3EXDI">bindTemplateAt: aPosition orUpdateWith: valueTypeSymbol	"If we have a bind template but it is not type-compatible with our bind values, force renaming and repreparing of the statement;  we cannot reuse the existing statement.  If we have no bind template, or too small a bindTemplate, create or extend it so we can do this check on reuse.  Note that aPosition may exceed the size of the bindInput if we are reusing bind input - see e.g. #testBinding which has SQL ... values(:1, :2, :2) ..."	|  bindMarker |	bindMarker := self bindMarkerAtPosition: aPosition.	bindMarker isInteger		ifFalse:			[bindTemplate isNil ifTrue: [bindTemplate := Dictionary new].			bindTemplate isSequenceable ifTrue:				[| newTemplate | newTemplate := Dictionary new: bindTemplate size.				bindTemplate doWithIndex: [:each :index | newTemplate at: index put: each].				bindTemplate := newTemplate].				^bindTemplate at: bindMarker ifAbsentPut: [valueTypeSymbol]]		ifTrue:			[bindTemplate size &lt; bindMarker ifTrue:	"this statement handles the degenerate case of nil bindTemplate"				[bindTemplate := (Array new: bindInput size) 					replaceElementsFrom: 1					to: bindTemplate size					withArray: bindTemplate					startingAt: 1].			(bindTemplate at: bindMarker) isNil ifTrue:				[^bindTemplate at: bindMarker put: valueTypeSymbol]].	(self		canTemplateType: (self bindTemplate at: bindMarker)		acceptValueOfType: valueTypeSymbol) ifFalse:			[bindTemplate at: bindMarker put: valueTypeSymbol.			statementName := ''.			isPrepared := false].	^bindTemplate at: bindMarker</body><body package="PostgreSQL3EXDI">canTemplateType: templateSymbol acceptValueOfType: valueSymbol	"Is the template type equal to or more generic than the value type."	| numberGenericity |	"Accept a NULL value for any bind type."	valueSymbol isNil ifTrue: [^true].	"Accept if value and bind types agree."	templateSymbol == valueSymbol ifTrue: [^true].	"A number of less generic type will write into a numeric column of more generic type ..."	numberGenericity := #(#SmallInteger #Integer #LargeInteger #FixedPoint #Float #Double).	((numberGenericity indexOf: valueSymbol)		between: 1		and: (numberGenericity indexOf: templateSymbol)) ifTrue: [^true].	"... and likewise for some other types ..."	(valueSymbol == #Timestamp and: [templateSymbol == #Timestamptz]) ifTrue: [^true].	(valueSymbol == #Time and: [templateSymbol == #Timetz]) ifTrue: [^true].	(valueSymbol == #ByteArray and: [templateSymbol == #LargeByteArray]) ifTrue: [^true].	"... and for character data, provided the string's value fits the column's type ..."	valueSymbol == #String ifTrue:		[templateSymbol == #LargeString ifTrue: [^true].		"... which we optimistically assume is so if the user is trying to write it"		templateSymbol == #Bit ifTrue: [^true].		templateSymbol == #Json ifTrue: [^true].		templateSymbol == #Jsonb ifTrue: [^true].		templateSymbol == #Hstore ifTrue: [^true].		(numberGenericity includes: templateSymbol) ifTrue: [^true]].	^false</body><body package="PostgreSQL3EXDI">isPrepared	"Answer true if the receiver has prepared SQL."	^isPrepared</body><body package="PostgreSQL3EXDI">isPrepared: aBoolean	isPrepared := aBoolean</body><body package="PostgreSQL3EXDI">xif  	^self connection xif</body></methods><methods><class-id>Database.PostgresSession</class-id> <category>private-binding</category><body package="PostgreSQL3EXDI">isAlreadyPrepared	^self connection isAlreadyPreparedStatementName: self statementName</body><body package="PostgreSQL3EXDI">prepareExternal	"We do not (or not conveniently) know enough yet to prepare the postgres statement.  Set state here to ensure that we do when we reach the point of naturally having the paramTypesPointer.  If we were prepared and the start of our name is the generation prefix then, as we are now altering the query from which it was generated, empty the name so it can be regenerated."	(self isPrepared and:		[self statementName beginsWith: self generatedStatementNamePrefix])			ifTrue: [statementName := ''].	self isPrepared: false.</body><body package="PostgreSQL3EXDI">setupQuery: aString	"Save the query. Break the query into an Array of fragments, 	isolating each parameter marker. Save the fragmented form."	"The size of the fragment array will always be odd, with parameter 	markers at even positions. Markers of the form '?' and ':number' 	are converted to index-into-bindInput-object form. Markers of 	the form ':name' are converted to #name."	| stream fragmentStream collection markerCount ch prevCh marker cr tab space newQueryStream paramIndex |	query := aString.	stream := query readStream.	fragmentStream := WriteStream on: (aString class new: query size).	collection := OrderedCollection new: 13.	markerCount := 0.	ch := $?.	cr := Character cr.	tab := Character tab.	space := Character space.	[ stream atEnd ] whileFalse:		[ prevCh := ch.		ch := stream next.		( ch == $' or: [ ch == $" ] )			ifTrue:				[ fragmentStream					nextPut: ch;					nextPutAll: (stream through: ch) ]			ifFalse:				[ ( ( (ch == $$ and: [ stream peek isDigit ]) or: [ ch == $? ])				or: [ (ch == $:) and: [ (prevCh isAlphaNumeric not and: [ (prevCh == $:) not ]) and: [ stream atEnd not and: [stream peek isAlphaNumeric ]] ] ] )					ifTrue:						[ markerCount := markerCount + 1.						collection add: fragmentStream contents.						fragmentStream reset.						( ch == $? )							ifTrue:								[ collection add: markerCount ]							ifFalse:								[ marker := self scanMarkerFrom: stream.								"ch does not reflect that last character, but that's O.K."								collection add: marker ] ]					ifFalse:						[ (ch == cr or: [ ch == tab]) ifTrue:							[ ch := space ].						fragmentStream nextPut: ch ] ] ].	collection add: fragmentStream contents.	queryFragments := collection.	newQueryStream := WriteStream on: (String new: query size).	paramIndex := 1.	1 to: collection size do: [ :index|		index even ifTrue: [			newQueryStream nextPut: $$.			newQueryStream nextPutAll: paramIndex printString.			paramIndex := paramIndex + 1.		] ifFalse: [			newQueryStream nextPutAll: (collection at: index)		]	].	query := newQueryStream contents</body><body package="PostgreSQL3EXDI">statementName	^statementName</body></methods><methods><class-id>Database.PostgresSession</class-id> <category>initialize-release</category><body package="PostgreSQL3EXDI">generatedStatementNamePrefix	"It is a bug in Postgres that it accepts a string of only numerical characters as a statement name but later will error if told to unprepare such a statement.  As Postgres has a default limit of 63 characters for statement names, it is desirable to hash long names, but we must preface tham with non-digits if we want to be able to unprepare them later."	^'gen'</body><body package="PostgreSQL3EXDI">initialize	super initialize.	isPrepared := false.</body><body package="PostgreSQL3EXDI">privateStatementName: aString	"Used by the executor (only, at the moment)."	statementName := aString</body></methods><methods><class-id>Database.PostgresSession</class-id> <category>accessing</category><body package="PostgreSQL3EXDI">bindInputBuffers	^bindInputBuffers</body><body package="PostgreSQL3EXDI">encoding	^connection encoding</body><body package="PostgreSQL3EXDI">statementName: aString	"For use by application programmers;  generated statement names are set directly."	(aString beginsWith: self generatedStatementNamePrefix) ifTrue:		[self error: aString, ' is indistinguishable from a generated statement name'].	statementName := aString.</body></methods><methods><class-id>Database.PostgresSession</class-id> <category>private-execution</category><body package="PostgreSQL3EXDI">setStatementNameFromQueryAndTypes	"Compute a suitably-unique statement name from our bound types (if any) and the query.  The logic is similar to that of Glorp uses, but using postgres' type names, not Smalltalk class names, for the types.  Postgres libpq requires this finer-grained type naming, as the C types of its interface cannot tolerate e.g. giving a LargeInteger to a statement that was prepared for type SmallInteger"	| signature |	bindInputBuffers isNil ifTrue: [^statementName := self generatedStatementNamePrefix, query hash printString].	signature := (String new: bindInputBuffers size * 5 + query size) writeStream.	signature nextPutAll: query.	bindInputBuffers do:		[:each | signature nextPutAll: each databaseType].	^statementName := self generatedStatementNamePrefix, signature contents hash printString</body></methods><methods><class-id>Database.PostgresSession class</class-id> <category>accessing</category><body package="PostgreSQL3EXDI">bufferClass	self subclassResponsibility</body></methods><methods><class-id>Database.PostgresLibpqSession</class-id> <category>private-accessing</category><body package="PostgreSQL3EXDI">paramFormatsPointer	^paramFormatsPointerHolder value</body><body package="PostgreSQL3EXDI">paramFormatsPointer: aCPointerOrNil	paramFormatsPointerHolder value: aCPointerOrNil</body><body package="PostgreSQL3EXDI">paramFormatsPointerHolder	^paramFormatsPointerHolder</body><body package="PostgreSQL3EXDI">paramFormatsPointerHolder: aValueHolder	paramFormatsPointerHolder := aValueHolder</body><body package="PostgreSQL3EXDI">paramLengthsPointer	^paramLengthsPointerHolder value</body><body package="PostgreSQL3EXDI">paramLengthsPointer: aCPointerOrNil	paramLengthsPointerHolder value: aCPointerOrNil</body><body package="PostgreSQL3EXDI">paramLengthsPointerHolder	^paramLengthsPointerHolder</body><body package="PostgreSQL3EXDI">paramLengthsPointerHolder: aValueHolder	paramLengthsPointerHolder := aValueHolder</body><body package="PostgreSQL3EXDI">paramNumber	^paramNumber</body><body package="PostgreSQL3EXDI">paramNumber: anInteger	paramNumber := anInteger</body><body package="PostgreSQL3EXDI">paramTypesPointer	^paramTypesPointerHolder value</body><body package="PostgreSQL3EXDI">paramTypesPointer: aCPointerOrNil	paramTypesPointerHolder value: aCPointerOrNil</body><body package="PostgreSQL3EXDI">paramTypesPointerHolder	^paramTypesPointerHolder</body><body package="PostgreSQL3EXDI">paramTypesPointerHolder: aValueHolder	paramTypesPointerHolder := aValueHolder</body><body package="PostgreSQL3EXDI">paramValuesPointer	^paramValuesPointerHolder value</body><body package="PostgreSQL3EXDI">paramValuesPointer: aCPointerOrNil	paramValuesPointerHolder value: aCPointerOrNil</body><body package="PostgreSQL3EXDI">paramValuesPointerHolder	^paramValuesPointerHolder</body><body package="PostgreSQL3EXDI">paramValuesPointerHolder: aValueHolder	paramValuesPointerHolder := aValueHolder</body><body package="PostgreSQL3EXDI">resetSession	self state: #new.	self freeParametersPointer.	bindInputBuffers notNil ifTrue: [		bindInputBuffers do: [ :each | each free ].		bindInputBuffers := nil.		totalRows := nil.		currentRowIndex := nil	].	self clearSessionStatus.</body><body package="PostgreSQL3EXDI">sessionStatus: anObject	^sessionStatusHolder value: anObject</body><body package="PostgreSQL3EXDI">sessionStatusHolder	^sessionStatusHolder</body><body package="PostgreSQL3EXDI">sessionStatusHolder: anObject	sessionStatusHolder := anObject</body></methods><methods><class-id>Database.PostgresLibpqSession</class-id> <category>private-answer set</category><body package="PostgreSQL3EXDI">advanceExternal	currentRowIndex isNil ifTrue: [ 		currentRowIndex := 1 	] ifFalse: [		currentRowIndex := currentRowIndex + 1.	].	totalRows isNil ifTrue: [		totalRows := self xif PQntuples: self sessionStatus.	].	currentRowIndex &gt; totalRows ifTrue: [ ^nil ]</body><body package="PostgreSQL3EXDI">allocateRowBufferExternal: aColumn 	"Answer a buffer allocated for holding one column's worth of information."	| aColDescription bufferClass buffer |	aColDescription := columnDescriptions at: aColumn.	bufferClass :=  self class bufferClass.	buffer := bufferClass basicNew 				descriptor: aColDescription				position: aColumn				session: self.	^buffer</body><body package="PostgreSQL3EXDI">cancelAnswerSetExternal	"Do nothing for now."</body><body package="PostgreSQL3EXDI">describeAnswerColumns	"Fill in the columnDescriptions array."	| xif descrs columnNum status |	xif := self xif.	status := self sessionStatus.	columnNum := (xif PQnfields: status).	self numColumns: columnNum.	descrs := Array new: columnNum.	0 to: (columnNum - 1) do: [ :aColumn | | colDesc |		colDesc := self getColumnDescriptionExternal: aColumn.		descrs at: (aColumn + 1) put: colDesc	].	self columnDescriptions: descrs</body><body package="PostgreSQL3EXDI">getColumnDescriptionExternal: aColumn 	| xif status namePointer nameString type precision length format |	xif := self xif.	status := self sessionStatus.	namePointer := xif PQfname: status with: aColumn.	nameString := namePointer copyCStringFromHeap.	type := (xif PQftype: status with: aColumn) datum.	precision := xif PQfmod: status with: aColumn.	length := xif PQfsize: status with: aColumn.	format := xif PQfformat: status with: aColumn.	^self connection class columnDescriptionClass new		index: aColumn;		name: nameString;		type: type;		maxColumnConstraint: length;		precision: precision;		format: format.</body><body package="PostgreSQL3EXDI">getFieldExternal: aColumn 	| xif field buffer |	buffer := self rowBuffers at: aColumn.	xif := self xif.	field := xif PQgetisnull: self sessionStatus with: currentRowIndex - 1 with: aColumn - 1. 	field = 1 ifTrue:		[buffer setValue: nil.		^nil].	field := xif PQgetvalue: self sessionStatus with: currentRowIndex - 1 with: aColumn - 1. 	buffer length: (xif PQgetlength: self sessionStatus with: currentRowIndex - 1 with: aColumn - 1).	buffer format = 0		ifTrue: [buffer setValue: (field copyCStringFromHeap: self encoding)]		ifFalse: [buffer bufferPointer: (xif PQgetvalue: self sessionStatus with: currentRowIndex - 1 with: aColumn - 1)].	^buffer getValueAt: currentRowIndex</body><body package="PostgreSQL3EXDI">hasAnswerSetExternal	| xif ret |	xif := self xif.	ret := xif PQresultStatus: self sessionStatus.	^ret = (self class execStatusType memberNamed: #PGRES_TUPLES_OK)</body><body package="PostgreSQL3EXDI">moreResultsExternal	^false</body><body package="PostgreSQL3EXDI">releaseBuffers	"Release buffers and their associated resources."	| rbs |	(rbs := self rowBuffers) notNil ifTrue: [ rbs do: [:each| each free]].	bindInputBuffers notNil ifTrue: [ 		bindInputBuffers do: [:each| each free].		bindInputBuffers := nil.	].	super releaseBuffers</body></methods><methods><class-id>Database.PostgresLibpqSession</class-id> <category>private-execution</category><body package="PostgreSQL3EXDI">cancelExternal	"Do nothing for now."</body><body package="PostgreSQL3EXDI">checkResultStatus	| xif status statusType error |	xif := self class xif.	status := xif PQresultStatus: self sessionStatus.	statusType := xif ExecStatusType type.	status = (statusType memberNamed: #PGRES_COMMAND_OK) ifTrue: [^self].	status = (statusType memberNamed: #PGRES_TUPLES_OK) ifTrue: [^self].	error := self getSessionError.	^error isError		ifTrue: [self class connectionClass postgresExceptionSignal				raiseWith: (Array with: error) errorString: error dbmsErrorString]		ifFalse: [self class connectionClass postgresResumableExceptionSignal				raiseRequestWith: (Array with: error) errorString: error dbmsErrorString]</body><body package="PostgreSQL3EXDI">clearSessionStatus	"Release external resources held."	| cmdStatus |	cmdStatus := self sessionStatus.	( cmdStatus notNil and: [ cmdStatus isValid ]) ifTrue: [		self xif PQclear: self sessionStatus.		self sessionStatus: nil	]</body><body package="PostgreSQL3EXDI">dismissExternal	"Release external resources held."	self clearSessionStatus.</body><body package="PostgreSQL3EXDI">executeDirectExternal	| xif |	xif := self xif.	self paramNumber = 0		ifTrue:			[self sessionStatus: (xif PQexec: self connection connection with: (self query asByteArrayEncoding: self encoding))]		ifFalse:			[self mallocForParameters.			self setParameterValues.			self sessionStatus:				(xif PQexecParams: self connection connection					with: (self query asByteArrayEncoding: self encoding)					with: paramNumber					with: self paramTypesPointer					with: self paramValuesPointer					with: self paramLengthsPointer					with: self paramFormatsPointer					with: self resultFormat)].	self checkResultStatus.	"Get ready to receive data."	totalRows := nil.	currentRowIndex := nil.</body><body package="PostgreSQL3EXDI">executeExternal	self paramNumber = 0		ifTrue:			[self sessionStatus:				(self xif					PQexec: self connection connection					with: (self query asByteArrayEncoding: self encoding)).			self checkResultStatus.	"Get ready to receive data."			totalRows := nil.			currentRowIndex := nil]		ifFalse: [self executePreparedExternal].</body><body package="PostgreSQL3EXDI">executePreparedExternal	| xif |	xif := self xif.	"Allocate parameter pointers."	self isPrepared ifFalse: [self mallocForParameters].	"Set parameter values."	self setParameterValues.	self isPrepared		ifFalse: [self prepareExternalDeferred]		ifTrue: [self statementName isEmpty ifTrue: [self error: 'Reusing an unamed statement']].	"Execute the SQL command."	self sessionStatus: (xif PQexecPrepared: self connection connection						with: self statementName						with: self paramNumber						with: self paramValuesPointer						with: self paramLengthsPointer						with: self paramFormatsPointer						with: self resultFormat).	self checkResultStatus.	"Get ready to receive data."	totalRows := nil.	currentRowIndex := nil.</body><body package="PostgreSQL3EXDI">getAlreadyPreparedSession	"The statement name must indeep be the name of a statement alredy prepared via this connection on the server.  If it is not, a fatal error will be raised and any transaction aborted."	| xif |	xif := self xif.	self sessionStatus: (xif PQdescribePrepared: self connection connection with: self statementName).	self checkResultStatus.	(xif PQresultStatus: self sessionStatus) = 1		ifFalse: [isPrepared := false]		ifTrue:			[self paramNumber: (xif PQnparams: self sessionStatus).			self mallocForParameters.			self state: #prepared.			isPrepared := true].</body><body package="PostgreSQL3EXDI">prepareExternalDeferred	"Do the postponed prepareExternal."	| xif |	xif := self xif.		self statementName isEmpty ifTrue: [self setStatementNameFromQueryAndTypes].	self isAlreadyPrepared ifFalse:		[self sessionStatus: (xif PQprepare: self connection connection						with: self statementName						with: (self query asByteArrayEncoding: self encoding)						with: self paramNumber						with: self paramTypesPointer).		self checkResultStatus.		self clearSessionStatus].	isPrepared := true.</body><body package="PostgreSQL3EXDI">readyExternal	^true</body><body package="PostgreSQL3EXDI">resultsExternal	^self checkResultStatus</body></methods><methods><class-id>Database.PostgresLibpqSession</class-id> <category>accessing</category><body package="PostgreSQL3EXDI">resultFormat	^resultFormat</body><body package="PostgreSQL3EXDI">sessionStatus	^sessionStatusHolder value</body></methods><methods><class-id>Database.PostgresLibpqSession</class-id> <category>private-activation</category><body package="PostgreSQL3EXDI">dismiss	self freeParametersPointer.	super dismiss.</body></methods><methods><class-id>Database.PostgresLibpqSession</class-id> <category>data processing</category><body package="PostgreSQL3EXDI">execute	self isPrepared ifTrue:		[self state: #prepared].	super execute.</body><body package="PostgreSQL3EXDI">executeDirect: aString	"Execute the prepared SQL statement without a prior external prepare step."	"Release resources if the receiver is being re-used."	self resetSession.	"The prepare: preps us for prepareExternalDeferred and puts us in state #prepared ..."	self prepare: aString.	"...but now we do not do prepareExternalDeferred, instead running the query directly."	( self state == #prepared ) ifFalse:		[ self class connectionClass invalidSessionStateSignal raise ].	[ "Begin unwind protection."	self bindExternal.	self state: #executing.	self executeDirectExternal.	"End unwind protection." ]		ifCurtailed:			[ self state: #connected ]</body><body package="PostgreSQL3EXDI">prepare: aString	"Release resources if the receiver is being re-used, then prepare aString for processing."	self resetSession.	super prepare: aString.</body><body package="PostgreSQL3EXDI">rowCount	"Answer the row(s) affected by the last session query."	^((self xif PQcmdTuples: self sessionStatus) copyCStringFromHeap: self encoding) asNumber</body></methods><methods><class-id>Database.PostgresLibpqSession</class-id> <category>error handling</category><body package="PostgreSQL3EXDI">getSessionError	| xif severityPointer severity sqlStatePointer sqlState errorStringPointer errorString error |	xif := self class xif.	"Get severity."	severityPointer := xif PQresultErrorField: self sessionStatus with: xif PG_DIAG_SEVERITY.	severity := severityPointer copyCStringFromHeap: self encoding.	"Get SQLSTATE."	sqlStatePointer := xif PQresultErrorField: self sessionStatus with: xif PG_DIAG_SQLSTATE.	sqlState := sqlStatePointer copyCStringFromHeap: self encoding.	"Get error message."	errorStringPointer := xif PQresultErrorField: self sessionStatus with: xif PG_DIAG_MESSAGE_PRIMARY.	errorString := errorStringPointer copyCStringFromHeap: self encoding.	"Create an error."	error := self class connectionClass errorClass new dbmsErrorString: errorString;			sqlState: sqlState;		severity: severity.	^error</body><body package="PostgreSQL3EXDI">reportSessionError	| xif errorMessage errorString |	xif := self class xif.	errorMessage := xif PQresultErrorMessage: self sessionStatus.	errorString := errorMessage copyCStringFromHeap: self encoding.	^self class connectionClass postgresExceptionSignal raiseWith: self errorString: errorString</body></methods><methods><class-id>Database.PostgresLibpqSession</class-id> <category>allocation</category><body package="PostgreSQL3EXDI">freeParametersPointer	self paramTypesPointer notNil ifTrue: [		 self paramTypesPointer freePointer.		 self paramTypesPointer: nil.	].	self paramValuesPointer notNil ifTrue: [		 self paramValuesPointer freePointer.		 self paramValuesPointer: nil.	].	self paramLengthsPointer notNil ifTrue: [		 self paramLengthsPointer freePointer.		 self paramLengthsPointer: nil.	].	self paramFormatsPointer notNil ifTrue: [		 self paramFormatsPointer freePointer.		 self paramFormatsPointer: nil.	].	self paramNumber: 0.</body><body package="PostgreSQL3EXDI">mallocForParameters	| xif nParams |	nParams := self paramNumber.	nParams = 0 ifTrue: [^self].	xif := self xif.	self paramTypesPointer isNil ifTrue: [		self paramTypesPointer: (CIntegerType int perform: xif mallocSelector with: nParams)	].	self paramValuesPointer isNil ifTrue: [		self paramValuesPointer: (CIntegerType unsignedChar pointerType perform: xif mallocSelector with: nParams)	].	self paramLengthsPointer isNil ifTrue: [		self paramLengthsPointer: (CIntegerType int perform: xif mallocSelector with: nParams)	].	self paramFormatsPointer isNil ifTrue: [		self paramFormatsPointer: (CIntegerType int perform: xif mallocSelector with: nParams)	].</body><body package="PostgreSQL3EXDI">setParameterValues	| typesPointer valuesPointer lengthsPointer formatsPointer |	self bindInputBuffers size = 0 ifTrue: [^self].	typesPointer := self paramTypesPointer.	valuesPointer := self paramValuesPointer.	lengthsPointer := self paramLengthsPointer.	formatsPointer := self paramFormatsPointer.	"Set pointers to buffer values."	0 to: (self paramNumber -1) do: [ :index | | buffer |		buffer := bindInputBuffers at: (index + 1). 		typesPointer at: index put: buffer postgresType.		(buffer lengthsPointer at: 0) = -1 ifTrue: [			valuesPointer at: index put: (CPointer newDatum: 0 ofType: CIntegerType unsignedChar pointerType)		] ifFalse: [			valuesPointer at: index put: buffer pointer		].		lengthsPointer at: index put: buffer elementSize.		formatsPointer at: index put: buffer format.	].</body></methods><methods><class-id>Database.PostgresLibpqSession</class-id> <category>private-library calls</category><body package="PostgreSQL3EXDI">acquireExternal	^self</body><body package="PostgreSQL3EXDI">installExternal	"Perform return from snapshot processing."	super installExternal.	self sessionStatus: nil.	self paramTypesPointer: nil.	self paramValuesPointer: nil.	self paramLengthsPointer: nil.	self paramFormatsPointer: nil.	self paramNumber: 0.</body></methods><methods><class-id>Database.PostgresLibpqSession</class-id> <category>private-finalization</category><body package="PostgreSQL3EXDI">executor	"Keep the statement name and prepared status in case finalization wants to deallocate."	| ex |	ex := super executor.	ex isPrepared: self isPrepared.	ex privateStatementName: self statementName.	ex sessionStatusHolder: self sessionStatusHolder.	^ex"The executor (pronounce with stress on 2nd syllable:  'executor' as in wills, probate, etc.) is a finalization copy (a tombstone) of the receiver, distinguished by an apostrophe in an inspector, e.g. you may see	aPostgresLibpqSession'	aPostgresLibpqSessionif you browse all instances while there is one (live) session and an executor."</body><body package="PostgreSQL3EXDI">finalizeExternal	"Release all external resource."	self releaseBuffersAndAdaptors.	self releaseBindings.	self freeParametersPointer.	traceLevel &gt;= 1 ifTrue:		[self class trace: nil].	super finalizeExternal.</body><body package="PostgreSQL3EXDI">key	"The sessionStatusHolder is unique to the session."	^self sessionStatusHolder</body></methods><methods><class-id>Database.PostgresLibpqSession</class-id> <category>initialize-release</category><body package="PostgreSQL3EXDI">initialize	super initialize.	sessionStatusHolder := nil asValue.	self paramNumber: 0.	self paramValuesPointerHolder: nil asValue.	self paramTypesPointerHolder: nil asValue.	self paramLengthsPointerHolder: nil asValue.	self paramFormatsPointerHolder: nil asValue.	"Set default result format to text."	resultFormat := 0.	statementName := ''.</body></methods><methods><class-id>Database.PostgresLibpqSession</class-id> <category>private-binding</category><body package="PostgreSQL3EXDI">bindExternal	"If we have values to bind, release any existing buffers and discover if the statement has markers for any of the values.  (Typically, all bound values provided will be used, but a statement can take only some values from a larger collection of bound values.)  If we have values and some are used, create a buffer and bind them.	If the user has recovered an existing statement by calling #getAlreadyPreparedSession on a user-assigned statementName (i.e. this is not an existing already-prepared session instance that we are reusing with new bindInput, nor is it a new session to which we assigned SQL, generated a digits-only statementName from the SQL and so found that SQL was or was not already prepared) then the user may not have also called #setUpQuery: on the SQL, so we may not have SQL to (re)parse.  In that case (only), if we have parameters, we must assume that the bindInput is a sequenceable collection and holds them in the right order."	| bInput noParsedQueryWithParam qfIndex |	bInput := self bindInput.	bInput isNil ifTrue: [^self].	(bInput isSequenceable and: [bInput isEmpty]) ifTrue: [^self].	self releaseBuffers.		"Release the existing buffers first."	(noParsedQueryWithParam := queryFragments size &lt; 2)		ifTrue: [self paramNumber = 0 ifTrue: [^self]]		ifFalse: [self paramNumber: queryFragments size // 2].	bindInputBuffers := Array new: self paramNumber.	qfIndex := 0.	1 to: self paramNumber do:		[:index || bindMarker value |		bindMarker := noParsedQueryWithParam			ifTrue: [index]			ifFalse:				[qfIndex := qfIndex + 2.				queryFragments at: qfIndex].		value := self inBindInputAt: bindMarker.		self bindValue: value at: index].</body><body package="PostgreSQL3EXDI">bindValue: aValue at: aPosition	"Bind a value to a parameter position in the query by creating a new buffer to hold it."	| buffer |	buffer := self class bufferClass new		on: aValue position: aPosition session: self.	buffer bindForInput.	self bindInputBuffers at: aPosition put: buffer.</body></methods><methods><class-id>Database.PostgresLibpqSession class</class-id> <category>accessing</category><body package="PostgreSQL3EXDI">bufferClass	"Answer the class to use for bindInput/Output objects associated with receiver."	^PostgresLibpqBuffer</body><body package="PostgreSQL3EXDI">connectionClass	"Return the PostgreSQL connection class."	^PostgresLibpqConnection</body><body package="PostgreSQL3EXDI">execStatusType	execStatusType isNil		ifTrue: [self execStatusType: self xif ExecStatusType type].	^execStatusType</body><body package="PostgreSQL3EXDI">execStatusType: anEnumType	execStatusType := anEnumType</body></methods><methods><class-id>Database.PostgresLibpqSession class</class-id> <category>class initialization</category><body package="PostgreSQL3EXDI">initialize	self initRegistry.</body></methods><methods><class-id>Database.PostgresLibpqSession class</class-id> <category>private-registry</category><body package="PostgreSQL3EXDI">registry	^RegisteredPostgreSQLSessions</body><body package="PostgreSQL3EXDI">registry: aCollection	RegisteredPostgreSQLSessions := aCollection.</body></methods><methods><class-id>Database.AsynchronousResponse</class-id> <category>accessing</category><body package="PostgreSQL3EXDI">activate	"Process the response then get the next message and return it to the cycle that (unexpectedly) received this message, so that cycle can continue."	recipient class == PostgresSocketSession		ifTrue: [^recipient nextServerMessage].</body></methods><methods><class-id>Database.NoticeResponse</class-id> <category>accessing</category><body package="PostgreSQL3EXDI">activate	"If the server sends a NoticeResponse, we can show the client if important (the server may be going down, etc.) and/or logging is on. Leave the recipient's protocolState unaltered, since this message doesn't affect the ongoing query processing."	recipient traceLevel &gt;= 1 ifTrue:		[recipient class			trace: 'NOTICE FROM SERVER:';			trace: self codeAndFieldAssociations printString].	ExternalDatabaseNotification raiseRequestWith: self codeAndFieldAssociations printString.	^super activate</body><body package="PostgreSQL3EXDI">codeAndFieldAssociations	^codeAndFieldAssociations</body><body package="PostgreSQL3EXDI">codeAndFieldAssociations: anObject	codeAndFieldAssociations := anObject</body><body package="PostgreSQL3EXDI">stream: aStream	| fieldStrings |	stream := aStream.	fieldStrings := self nextManyCodeAndFieldStrings.	self codeAndFieldAssociations: fieldStrings.</body></methods><methods><class-id>Database.PostgresInterface</class-id> <category>defines</category><body package="PostgreSQL3EXDI">INV_READ	&lt;C: #define INV_READ 0x00040000	&gt;</body><body package="PostgreSQL3EXDI">INV_WRITE	&lt;C: #define INV_WRITE 0x00020000	&gt;</body><body package="PostgreSQL3EXDI">LIBPQ_FE_H	&lt;C: #define LIBPQ_FE_H 	&gt;</body><body package="PostgreSQL3EXDI">OID_MAX	&lt;C: #define OID_MAX UINT_MAX	&gt;</body><body package="PostgreSQL3EXDI">PG_COPYRES_ATTRS	&lt;C: #define PG_COPYRES_ATTRS 1	&gt;</body><body package="PostgreSQL3EXDI">PG_COPYRES_EVENTS	&lt;C: #define PG_COPYRES_EVENTS 4	&gt;</body><body package="PostgreSQL3EXDI">PG_COPYRES_NOTICEHOOKS	&lt;C: #define PG_COPYRES_NOTICEHOOKS 8	&gt;</body><body package="PostgreSQL3EXDI">PG_COPYRES_TUPLES	&lt;C: #define PG_COPYRES_TUPLES 2	&gt;</body><body package="PostgreSQL3EXDI">PG_DIAG_COLUMN_NAME	&lt;C: #define PG_DIAG_COLUMN_NAME 99	&gt;</body><body package="PostgreSQL3EXDI">PG_DIAG_CONSTRAINT_NAME	&lt;C: #define PG_DIAG_CONSTRAINT_NAME 110	&gt;</body><body package="PostgreSQL3EXDI">PG_DIAG_CONTEXT	&lt;C: #define PG_DIAG_CONTEXT 87	&gt;</body><body package="PostgreSQL3EXDI">PG_DIAG_DATATYPE_NAME	&lt;C: #define PG_DIAG_DATATYPE_NAME 100	&gt;</body><body package="PostgreSQL3EXDI">PG_DIAG_INTERNAL_POSITION	&lt;C: #define PG_DIAG_INTERNAL_POSITION 112	&gt;</body><body package="PostgreSQL3EXDI">PG_DIAG_INTERNAL_QUERY	&lt;C: #define PG_DIAG_INTERNAL_QUERY 113	&gt;</body><body package="PostgreSQL3EXDI">PG_DIAG_MESSAGE_DETAIL	&lt;C: #define PG_DIAG_MESSAGE_DETAIL 68	&gt;</body><body package="PostgreSQL3EXDI">PG_DIAG_MESSAGE_HINT	&lt;C: #define PG_DIAG_MESSAGE_HINT 72	&gt;</body><body package="PostgreSQL3EXDI">PG_DIAG_MESSAGE_PRIMARY	&lt;C: #define PG_DIAG_MESSAGE_PRIMARY 77	&gt;</body><body package="PostgreSQL3EXDI">PG_DIAG_SCHEMA_NAME	&lt;C: #define PG_DIAG_SCHEMA_NAME 115	&gt;</body><body package="PostgreSQL3EXDI">PG_DIAG_SEVERITY	&lt;C: #define PG_DIAG_SEVERITY 83	&gt;</body><body package="PostgreSQL3EXDI">PG_DIAG_SOURCE_FILE	&lt;C: #define PG_DIAG_SOURCE_FILE 70	&gt;</body><body package="PostgreSQL3EXDI">PG_DIAG_SOURCE_FUNCTION	&lt;C: #define PG_DIAG_SOURCE_FUNCTION 82	&gt;</body><body package="PostgreSQL3EXDI">PG_DIAG_SOURCE_LINE	&lt;C: #define PG_DIAG_SOURCE_LINE 76	&gt;</body><body package="PostgreSQL3EXDI">PG_DIAG_SQLSTATE	&lt;C: #define PG_DIAG_SQLSTATE 67	&gt;</body><body package="PostgreSQL3EXDI">PG_DIAG_STATEMENT_POSITION	&lt;C: #define PG_DIAG_STATEMENT_POSITION 80	&gt;</body><body package="PostgreSQL3EXDI">PG_DIAG_TABLE_NAME	&lt;C: #define PG_DIAG_TABLE_NAME 116	&gt;</body><body package="PostgreSQL3EXDI">PG_INT64_TYPE	&lt;C: #define PG_INT64_TYPE long long int	&gt;</body><body package="PostgreSQL3EXDI">PQnoPasswordSupplied	&lt;C: #define PQnoPasswordSupplied "fe_sendauth: no password supplied"	&gt;</body><body package="PostgreSQL3EXDI">SEEK_CUR	&lt;C: #define SEEK_CUR 1	&gt;</body><body package="PostgreSQL3EXDI">SEEK_END	&lt;C: #define SEEK_END 2	&gt;</body><body package="PostgreSQL3EXDI">SEEK_SET	&lt;C: #define SEEK_SET 0	&gt;</body><body package="PostgreSQL3EXDI">__DATE__	&lt;C: #define __DATE__ "August 8, 2013"	&gt;</body><body package="PostgreSQL3EXDI">__FILE__	&lt;C: #define __FILE__ d:\Work\VW\AR_Fixes\PostgreSQL\new_Interface\libpq-fe.h	&gt;</body><body package="PostgreSQL3EXDI">__LINE__	&lt;C: #define __LINE__ 0	&gt;</body><body package="PostgreSQL3EXDI">__STDC__	&lt;C: #define __STDC__ 1	&gt;</body><body package="PostgreSQL3EXDI">__TIME__	&lt;C: #define __TIME__ "2:36:38 PM"	&gt;</body></methods><methods><class-id>Database.PostgresInterface</class-id> <category>macros</category><body package="PostgreSQL3EXDI">PQfreeNotify: ptr	&lt;C: #define PQfreeNotify(ptr) PQfreemem(ptr )	&gt;</body><body package="PostgreSQL3EXDI">PQsetdb: M_PGHOST with: M_PGPORT with: M_PGOPT with: M_PGTTY with: M_DBNAME	&lt;C: #define PQsetdb(M_PGHOST, M_PGPORT, M_PGOPT, M_PGTTY, M_DBNAME) PQsetdbLogin(M_PGHOST , M_PGPORT , M_PGOPT , M_PGTTY , M_DBNAME ,NULL,NULL)	&gt;</body></methods><methods><class-id>Database.PostgresInterface</class-id> <category>types</category><body package="PostgreSQL3EXDI">ConnStatusType	&lt;C: typedef enum {			CONNECTION_OK, 			CONNECTION_BAD, 			CONNECTION_STARTED, 			CONNECTION_MADE, 			CONNECTION_AWAITING_RESPONSE, 			CONNECTION_AUTH_OK, 			CONNECTION_SETENV, 			CONNECTION_SSL_STARTUP, 			CONNECTION_NEEDED		} ConnStatusType&gt;</body><body package="PostgreSQL3EXDI">ExecStatusType	&lt;C: typedef enum {			PGRES_EMPTY_QUERY, 			PGRES_COMMAND_OK, 			PGRES_TUPLES_OK, 			PGRES_COPY_OUT, 			PGRES_COPY_IN, 			PGRES_BAD_RESPONSE, 			PGRES_NONFATAL_ERROR, 			PGRES_FATAL_ERROR, 			PGRES_COPY_BOTH, 			PGRES_SINGLE_TUPLE		} ExecStatusType&gt;</body><body package="PostgreSQL3EXDI">FILE	&lt;C: typedef void * FILE&gt;</body><body package="PostgreSQL3EXDI">Oid	&lt;C: typedef void * Oid&gt;</body><body package="PostgreSQL3EXDI">PGPing	&lt;C: typedef enum {			PQPING_OK, 			PQPING_REJECT, 			PQPING_NO_RESPONSE, 			PQPING_NO_ATTEMPT		} PGPing&gt;</body><body package="PostgreSQL3EXDI">PGTransactionStatusType	&lt;C: typedef enum {			PQTRANS_IDLE, 			PQTRANS_ACTIVE, 			PQTRANS_INTRANS, 			PQTRANS_INERROR, 			PQTRANS_UNKNOWN		} PGTransactionStatusType&gt;</body><body package="PostgreSQL3EXDI">PGVerbosity	&lt;C: typedef enum {			PQERRORS_TERSE, 			PQERRORS_DEFAULT, 			PQERRORS_VERBOSE		} PGVerbosity&gt;</body><body package="PostgreSQL3EXDI">PGcancel	&lt;C: typedef struct pg_cancel PGcancel&gt;</body><body package="PostgreSQL3EXDI">PGconn	&lt;C: typedef struct pg_conn PGconn&gt;</body><body package="PostgreSQL3EXDI">PGnotify	&lt;C: typedef struct pgNotify PGnotify&gt;</body><body package="PostgreSQL3EXDI">PGresAttDesc	&lt;C: typedef struct pgresAttDesc PGresAttDesc&gt;</body><body package="PostgreSQL3EXDI">PGresult	&lt;C: typedef struct pg_result PGresult&gt;</body><body package="PostgreSQL3EXDI">PQArgBlock	&lt;C: typedef struct {			int len, isint;			union {				int * ptr;				int integer;			} u;		} PQArgBlock&gt;</body><body package="PostgreSQL3EXDI">PQconninfoOption	&lt;C: typedef struct _PQconninfoOption PQconninfoOption&gt;</body><body package="PostgreSQL3EXDI">PQnoticeProcessor	&lt;C: typedef void (* PQnoticeProcessor)(void * arg, const char * message)&gt;</body><body package="PostgreSQL3EXDI">PQnoticeReceiver	&lt;C: typedef void (* PQnoticeReceiver)(void * arg, const PGresult * res)&gt;</body><body package="PostgreSQL3EXDI">PQprintOpt	&lt;C: typedef struct _PQprintOpt PQprintOpt&gt;</body><body package="PostgreSQL3EXDI">PostgresPollingStatusType	&lt;C: typedef enum {			PGRES_POLLING_FAILED, 			PGRES_POLLING_READING, 			PGRES_POLLING_WRITING, 			PGRES_POLLING_OK, 			PGRES_POLLING_ACTIVE		} PostgresPollingStatusType&gt;</body><body package="PostgreSQL3EXDI">pgthreadlock_t	&lt;C: typedef void (* pgthreadlock_t)(int acquire)&gt;</body><body package="PostgreSQL3EXDI">pqbool	&lt;C: typedef char pqbool&gt;</body><body package="PostgreSQL3EXDI">size_t	&lt;C: typedef void * size_t&gt;</body></methods><methods><class-id>Database.PostgresInterface</class-id> <category>structs</category><body package="PostgreSQL3EXDI">_PQconninfoOption	&lt;C: struct _PQconninfoOption {			char * keyword;			char * envvar;			char * compiled;			char * val;			char * label;			char * dispchar;			int dispsize;		}&gt;</body><body package="PostgreSQL3EXDI">_PQprintOpt	&lt;C: struct _PQprintOpt {			pqbool header, align, standard, html3, expanded, pager;			char * fieldSep;			char * tableOpt;			char * caption;			char * * fieldName;		}&gt;</body><body package="PostgreSQL3EXDI">pgNotify	&lt;C: struct pgNotify {			char * relname;			int be_pid;			char * extra;			struct pgNotify * next;		}&gt;</body><body package="PostgreSQL3EXDI">pg_cancel	&lt;C: struct pg_cancel&gt;</body><body package="PostgreSQL3EXDI">pg_conn	&lt;C: struct pg_conn&gt;</body><body package="PostgreSQL3EXDI">pg_result	&lt;C: struct pg_result&gt;</body><body package="PostgreSQL3EXDI">pgresAttDesc	&lt;C: struct pgresAttDesc {			char * name;			Oid tableid;			int columnid, format;			Oid typid;			int typlen, atttypmod;		}&gt;</body></methods><methods><class-id>Database.PostgresInterface</class-id> <category>accessing</category><body package="PostgreSQL3EXDI">mallocSelector	^#malloc:</body></methods><methods><class-id>Database.PostgresInterface class</class-id> <category>private</category><body package="PostgreSQL3EXDI">libraryFilesSearchSignals	"This class is expected to provide a list of exceptions which should be ignored	when the library is not found whilst searching for it under the wrong platfrom name."	^ExternalLibraryHolder libraryNotFoundSignal</body><body package="PostgreSQL3EXDI">platformSymbol	"Subclasses return the symbol that matches that returned by determinePlatformType for their platform.  Platform symbols known today include:	#nt			32-bit Windows/NT and up	#nt	64		64-bit  Windows/NT and up	#win95 		Windows95 (no interface class provided in this version)	#hp_unix		HP/UX (no interface class provided in this version)	#sun5_unix	Solaris	#aix_unix		AIX	#alpha_unix	DEC/Unix	#powermac	Power Mac	#mac		Mac 68K	#macOSX		MacOSX 64-bit and 32-bit	#linux_i386_unix			Linux	#linux_x86_64_unix		Linux 64-bit	#unix_sysV_sun_solaris64	Solaris 64-bit"		^#unknown</body></methods><methods><class-id>Database.PostgresLinuxInterface class</class-id> <category>private</category><body package="PostgreSQL3EXDI">platformSymbol	^#linux_i386_unix</body></methods><methods><class-id>Database.TimeoutResponse</class-id> <category>accessing</category><body package="PostgreSQL3EXDI">activate	| dbError |	dbError := PostgresSocketConnection errorClass new		dbmsErrorCode: '#timeout';		dbmsErrorString: 'Timeout error:&lt;nt&gt;- resume to continue waiting;&lt;nt&gt;- terminate to end the session locally;&lt;nt&gt;- send cancelCurrentRequest to the connection to abandon the session&lt;nt&gt;on the server (and allow time for the cancel to happen before resuming).' expandMacros.	ResumableTimeoutException		raiseRequestWith: (Array with: dbError)		errorString: dbError dbmsErrorCode , ', ' , dbError dbmsErrorString.	^super activate</body></methods><methods><class-id>Database.PostgresLOB</class-id> <category>lob processing</category><body package="PostgreSQL3EXDI">close	| conn ret |	conn := self connection.	ret := conn xif lo_close: conn connection with: self lobDescriptor.	ret &lt; 0 ifTrue: [		^self connection reportError	]</body><body package="PostgreSQL3EXDI">create	| conn |	conn := self connection.	lobOid := (conn xif lo_creat: conn connection with: self mode) referentAddress.	lobOid = 0 ifTrue: [		^self connection reportError	]</body><body package="PostgreSQL3EXDI">exportToFile: aFilenameString	| conn ret |	conn := self connection.	ret := conn xif lo_export: conn connection with: self lobOid with: aFilenameString.	ret = -1 ifTrue: [		^self connection reportError	]</body><body package="PostgreSQL3EXDI">importFromFile: aFilenameString	| conn |	conn := self connection.	lobOid := (conn xif lo_import: conn connection with: aFilenameString) referentAddress.	lobOid = 0 ifTrue: [		^self connection reportError	]</body><body package="PostgreSQL3EXDI">importFromFile: aFilenameString oid: anOid	| conn |	conn := self connection.	lobOid := (conn xif lo_import_with_oid: conn connection with: aFilenameString with: anOid) referentAddress.	lobOid &lt; 0 ifTrue: [		^self connection reportError	]</body><body package="PostgreSQL3EXDI">moveTo: offset whence: direction	| conn ret |	conn := self connection.	ret := conn xif lo_lseek: conn connection with: self lobDescriptor with: offset with: direction.	ret &lt;= -1 ifTrue: [		^self connection reportError	] ifFalse: [		self position: ret	]</body><body package="PostgreSQL3EXDI">moveToFromCurrentPosition: offset	^self moveTo: offset whence: self connection xif SEEK_CUR</body><body package="PostgreSQL3EXDI">moveToFromEnd: offset	^self moveTo: offset whence: self connection xif SEEK_END</body><body package="PostgreSQL3EXDI">moveToFromStart: offset	^self moveTo: offset whence: self connection xif SEEK_SET</body><body package="PostgreSQL3EXDI">open	| conn |	conn := self connection.	lobDescriptor := conn xif lo_open: conn connection with: self lobOid with: self mode.	lobDescriptor = -1 ifTrue: [		^self connection reportError	]</body><body package="PostgreSQL3EXDI">readFor: numOfBytes	| xif conn buffer stream |	stream := String new readWriteStream.	conn := self connection.	xif := conn xif.	[ | readBytes |		buffer := CIntegerType char perform: xif mallocSelector with: (self bufferSize + 1).		readBytes := 0.		[ numOfBytes - readBytes &gt; 0 ] whileTrue: [ | pieceSize bytes |			pieceSize := (numOfBytes - readBytes) min: self bufferSize.			(bytes :=  conn xif lo_read: conn connection with: self lobDescriptor with: buffer with: pieceSize) &lt; 0 ifTrue: [				^self connection reportError			].			bytes &gt; 0 ifTrue: [ | str |				str := String new: bytes.				buffer copyAt: 0 to: str size: bytes startingAt: 1.				stream nextPutAll: str. 				readBytes := readBytes + bytes.			] ifFalse: [				readBytes := numOfBytes			]		]	] ensure: [			buffer freePointer.	].	^stream contents.</body><body package="PostgreSQL3EXDI">remove	| conn ret |	conn := self connection.	ret := conn xif lo_unlink: conn connection with: self lobOid.	ret = -1 ifTrue: [		^self connection reportError	]</body><body package="PostgreSQL3EXDI">truncate: anInteger	| conn ret |	conn := self connection.	ret := conn xif lo_truncate: conn connection with: self lobDescriptor with: anInteger.	ret &lt; 0 ifTrue: [		^self connection reportError	]</body><body package="PostgreSQL3EXDI">write: aString	| xif conn buffer stream |	stream := ReadStream on: aString.	conn := self connection.	xif := conn xif.	[ 		buffer := CIntegerType char perform: xif mallocSelector with: (self bufferSize + 1).		[ stream atEnd ] whileFalse: [ | piece |			piece := stream nextAvailable: self bufferSize.			buffer copyAt: 0 from: piece size: piece size startingAt: 1.			(conn xif lo_write: conn connection with: self lobDescriptor with: buffer with: piece size) &lt; 0 ifTrue: [				^self connection reportError			].		]	] ensure: [			buffer freePointer.	].</body></methods><methods><class-id>Database.PostgresLOB</class-id> <category>accessing</category><body package="PostgreSQL3EXDI">bufferSize	^bufferSize</body><body package="PostgreSQL3EXDI">bufferSize: anInteger	bufferSize := anInteger</body><body package="PostgreSQL3EXDI">connection	^connection</body><body package="PostgreSQL3EXDI">connection: aConnection	connection := aConnection</body><body package="PostgreSQL3EXDI">forRead	mode := self connection xif  INV_READ</body><body package="PostgreSQL3EXDI">forReadWrite	| xif |	xif := self connection xif.	mode := xif INV_READ bitOr: xif INV_WRITE</body><body package="PostgreSQL3EXDI">forWrite	mode := self connection xif INV_WRITE</body><body package="PostgreSQL3EXDI">lobDescriptor	^lobDescriptor</body><body package="PostgreSQL3EXDI">lobOid	^lobOid</body><body package="PostgreSQL3EXDI">lobOid: anOid	lobOid := anOid</body><body package="PostgreSQL3EXDI">mode	^mode</body><body package="PostgreSQL3EXDI">position	| conn ret |	conn := self connection.	ret := conn xif lo_tell: conn connection with: self lobDescriptor.	ret &lt; 0 ifTrue: [		^self connection reportError	] ifFalse: [		self position: ret.		^ret	]</body><body package="PostgreSQL3EXDI">position: anInteger	position := anInteger</body></methods><methods><class-id>Database.PostgresLOB</class-id> <category>initialize-release</category><body package="PostgreSQL3EXDI">initialize	super initialize.	connection := nil.	lobOid := 0.	bufferSize := self class defaultBufferSize.</body></methods><methods><class-id>Database.PostgresLOB class</class-id> <category>accessing</category><body package="PostgreSQL3EXDI">defaultBufferSize	^1048576</body></methods><methods><class-id>Database.PostgresLOB class</class-id> <category>instance creation</category><body package="PostgreSQL3EXDI">newForConnection: aConnection	| newLOB |	(newLOB := self basicNew) initialize.	newLOB connection: aConnection.	newLOB forReadWrite.	^newLOB</body></methods><methods><class-id>Database.NoData</class-id> <category>accessing</category><body package="PostgreSQL3EXDI">activate	super activate.	recipient releaseBuffers.	recipient releaseAdaptors.	recipient columnDescriptions: #().	recipient numColumns: 0.</body><body package="PostgreSQL3EXDI">allowedPriorStateTypes	^recipient needBinding		ifTrue: [#(#ParseComplete #BindComplete)]		ifFalse: [#(nil #CommandComplete)]</body></methods><methods><class-id>Database.Postgres64SolarisInterface class</class-id> <category>private</category><body package="PostgreSQL3EXDI">platformSymbol	^#unix_sysV_sun_solaris64</body></methods><methods><class-id>Database.PostgresConnection</class-id> <category>private-finalization</category><body package="PostgreSQL3EXDI">finalizeExternal	traceLevel &gt;= 1 ifTrue: [self class trace: nil].	super finalizeExternal</body></methods><methods><class-id>Database.PostgresConnection</class-id> <category>accessing</category><body package="PostgreSQL3EXDI">databaseName	^databaseName</body><body package="PostgreSQL3EXDI">databaseName: aString	databaseName := aString.</body><body package="PostgreSQL3EXDI">dynamicClassToPostgreSQLTypeMap	^dynamicClassToPostgreSQLTypeMap ifNil: [dynamicClassToPostgreSQLTypeMap := Dictionary new]</body><body package="PostgreSQL3EXDI">dynamicPostgreSQLTypeToClassMap	^dynamicPostgreSQLTypeToClassMap ifNil: [dynamicPostgreSQLTypeToClassMap := Dictionary new]</body><body package="PostgreSQL3EXDI">encoding	"If the encoding is not set, return (without setting) #utf8 to allow messages setting it to be sent.  The default encoding for VisualWorks is single-byte but the default encoding for Postgres is UTF8 which is mostly single-byte but can be double, triple or quadruple in rare cases.  We therefore decided to override the super implementation with the safer UTF8."	encoding isNil ifTrue: [^#utf8].	^encoding</body><body package="PostgreSQL3EXDI">environment	"Return the environment."	super environment isNil ifTrue: [self environment: self class defaultEnvironment].	^super environment</body><body package="PostgreSQL3EXDI">environment: aString	"Process the environment string hostName:portNumber_databaseName to get hostName, portNumber and databaseName.  Default values for hostName (localhost), portNumber (5432) and databaseName (postgres) have been set in #initialize;  these will be used if not overwritten here.	The host is everything before the colon;  no colon in string means leave the hostname of this instance unchanged.  The port is an all-digit string between the colon (or start of string if no colon) and the first following underscore;  no such string means leave the port of this instance unchanged. The databaseName is everything after the port's underscore if there is a port, otherwise after the colon and underscore, or colon, or start of string if there are neither;  no such string means leave the databaseName of this instance unchanged.	For backward compatibility with the protocol 2.0 approach, we remove any singlequote characters from host strings."	| colon underscore host port_dbname port db |	super environment: aString.	host := (aString first: (colon := aString indexOf: $:) - 1) copyWithout: $'.	host isEmpty ifFalse: [self hostName: host].	aString size = colon ifTrue: [^self].	port_dbname := aString allButFirst: colon.	port := port_dbname first: (underscore := port_dbname indexOf: $_) - 1.	port isEmpty ifFalse:		[(port allSatisfy: [:each | each isDigit])			ifFalse: [underscore := 0]			ifTrue: [self portString: port]].	db := port_dbname allButFirst: underscore.	db isEmpty ifFalse:		[self databaseName: db].</body><body package="PostgreSQL3EXDI">hostName	^hostName</body><body package="PostgreSQL3EXDI">hostName: aString	hostName := aString.</body><body package="PostgreSQL3EXDI">isAlreadyPreparedStatementName: aString	"This is state-changing, not just testing - it adds a non-empty string to its list if the name is not already there.  Return false if it was indeed new and so was added, true if it was already in the known prepared statements."	aString isEmpty ifTrue: [^false].	(preparedStatementNames includes: aString) ifTrue: [^true].	preparedStatementNames add: aString.	^false</body><body package="PostgreSQL3EXDI">portNumber	"Socket API wants integer ports.  C API wants string ports.  Provide accessors for both."	self subclassResponsibility.</body><body package="PostgreSQL3EXDI">portNumber: anInteger	"Socket API wants integer ports.  C API wants string ports.  Provide accessors for both."	self subclassResponsibility.</body><body package="PostgreSQL3EXDI">portString	"Socket API wants integer ports.  C API wants string ports.  Provide accessors for both."	self subclassResponsibility.</body><body package="PostgreSQL3EXDI">portString: aString	"Socket API wants integer ports.  C API wants string ports.  Provide accessors for both."	self subclassResponsibility.</body></methods><methods><class-id>Database.PostgresConnection</class-id> <category>initialize-release</category><body package="PostgreSQL3EXDI">getTypeNumberFromDatabase: aSymbol	"Ask the database for the type number of this type symbol.  (The assumpton is this is a dynamic type whose numeric value varies between databases;  of course, a static type value could also be obtained by this method.)  The spelling of aSymbol must match that in the pg_type table up to case.  If it's not found, return 25 (String) as default."	| aSession ans result |	aSession := self getSession.	aSession prepareWithoutBinding:		'select oid from pg_type where typname = ''', aSymbol asLowercase , ''''.	ans := aSession execute.	[(ans := aSession answer) = #noMoreAnswers] whileFalse:		[ans = #noAnswerStream ifFalse: [result := ans upToEnd]].	^result first first		ifNil: [25]	"default is String"		ifNotNil:			[:val || dynamicTypeNumber |			dynamicTypeNumber := val asNumber.			self dynamicPostgreSQLTypeToClassMap at: val ifAbsentPut: [aSymbol].			dynamicTypeNumber]</body><body package="PostgreSQL3EXDI">initialize	super initialize.	hostName := 'localhost'.	databaseName := 'postgres'.	preparedStatementNames := Set new.</body><body package="PostgreSQL3EXDI">suggestedDefaultTimeZone	"Guess the timezone name from the image's TimeZone default values for the offset, and whether it is greater in summer or winter."	| winter summer offset timezoneDictionary |	winter := Duration fromSeconds:		(TimeZone default secondsFromUniversalAtLocal:			(Timestamp readFrom: '31-dec-2015 12:00' readStream)).	summer := Duration fromSeconds:		(TimeZone default secondsFromUniversalAtLocal:			(Timestamp readFrom: '30-jun-2015 12:00' readStream)).	timezoneDictionary := summer = winter		ifFalse: [summer &gt; winter		"daylight saving timezone"				ifTrue: [self class dstNorth]	"Northern hemisphere"				ifFalse: [self class dstSouth]]	"Southern hemisphere"		ifTrue: [self isAustralianTimezones				ifFalse: [self class stdMain]				ifTrue: [self class stdSouth]].	offset := summer min: winter.	^timezoneDictionary at: offset		ifAbsent: 'Etc/GMT' , (offset &lt; 0 seconds ifTrue: ['+'] ifFalse: ['-'])				, offset hours abs printString</body></methods><methods><class-id>Database.PostgresConnection</class-id> <category>accessing-server parameters</category><body package="PostgreSQL3EXDI">clientEncoding	"Postgres expects encoding names to be strings but VisualWorks expects them to be lowercase symbols.  The clientEncoding getter and setter therefore convert between lowercase symbols (the parameter and what they return) and strings (what they send to and get from Postgres)."	^self subclassResponsibility</body><body package="PostgreSQL3EXDI">clientEncoding: aSymbol	^self subclassResponsibility</body><body package="PostgreSQL3EXDI">knownClientEncoding	"Get the client encoding.  If VisualWorks can understand it, return it.  Otherwise, set the client to use UTF8 and return that."	| clientEncoding |	clientEncoding := self class postgresToVisualWorksEncoding: self clientEncoding.	^(StreamEncoder encoderDirectory includesKey: clientEncoding)		ifTrue: [clientEncoding]		ifFalse: [self clientEncoding: #utf8]</body><body package="PostgreSQL3EXDI">serverVersion	self subclassResponsibility</body><body package="PostgreSQL3EXDI">timezone	self subclassResponsibility</body><body package="PostgreSQL3EXDI">timezone: aString	self subclassResponsibility</body></methods><methods><class-id>Database.PostgresConnection</class-id> <category>private-execution</category><body package="PostgreSQL3EXDI">dismissExternal	"We are dropping this connection as far as the server is concerned, but could reuse it as an object in VW.  The server will drop the prepared statements along with the connection, so we must do the same."	preparedStatementNames := Set new.	dynamicClassToPostgreSQLTypeMap := nil.	dynamicPostgreSQLTypeToClassMap := nil.</body><body package="PostgreSQL3EXDI">unprepareExternal: aString	"USE WITH CAUTION.  The server holds a prepared statement against this statement name;  deallocate it.  Not usually needed as disconnecting drops all allocated statements held against this connection.  Do not fail if we are locally ignorant of the name as the motive for use of this might be used to clean-up some messy situation.  Not thread-safe.	Except in debugging/recovery situations, the only scenario foreseen for this method is when a very long-running connection has accumulated so many prepared statements as to impact performance.  Further development of this method may await a realistic scenario to study."	^preparedStatementNames remove: aString ifAbsent: [nil]</body></methods><methods><class-id>Database.PostgresConnection</class-id> <category>connections</category><body package="PostgreSQL3EXDI">connect: aPassword 	super connect: aPassword.	self timezone: self class defaultTimeZone</body></methods><methods><class-id>Database.PostgresConnection</class-id> <category>testing</category><body package="PostgreSQL3EXDI">isAustralianTimezones	^self subclassResponsibility</body></methods><methods><class-id>Database.PostgresConnection class</class-id> <category>private-accessing</category><body package="PostgreSQL3EXDI">createTimezoneDictionaryFromString: timezones	"Return a dictionary of time offset -&gt; daylight savings time timezone name, built from the input string."	| dictionary strm negate duration offset timezoneName |	dictionary := Dictionary new.	strm := timezones readStream.	[strm atEnd] whileFalse: 			[negate := strm next = $-.			duration := (Time readFrom: strm) asDuration.			offset := negate ifTrue: [duration negated] ifFalse: [duration].			timezoneName := strm upTo: Character cr.			dictionary at: offset put: timezoneName].	^dictionary</body><body package="PostgreSQL3EXDI">dstNorth	"Return a dictionary of time offset -&gt; daylight savings time timezone name, for the northern hemisphere."	^self		createTimezoneDictionaryFromString: '-10:00:00	US/Aleutian-09:00:00	America/Anchorage-08:00:00	America/Los_Angeles-07:00:00	US/Mountain-06:00:00	America/Chicago-05:00:00	America/New_York-04:00:00	Canada/Atlantic-03:30:00	Canada/Newfoundland-03:00:00	America/Godthab-02:00:00	Atlantic/Cape_Verde+00:00:00	Europe/London+01:00:00	Europe/Berlin+02:00:00	Europe/Athens+03:00:00	Europe/Moscow+03:30:00	Asia/Tehran+04:00:00	Asia/Baku'</body><body package="PostgreSQL3EXDI">dstSouth	"Return a dictionary of time offset -&gt; daylight savings time timeone name, for the southern hemisphere."	^self		createTimezoneDictionaryFromString: '-03:00:00	America/Argentina/San_Luis-03:00:00	America/Sao_Paulo+00:00:00	Atlantic/St_Helena+05:00:00	Antarctica/Mawson+08:00:00	Australia/West+09:00:00	Asia/Dili+10:00:00	Australia/Sydney+10:30:00	Australia/Lord_Howe+11:30:00	Pacific/Norfolk+12:00:00	NZ+12:45:00	Pacific/Chatham+13:00:00	Pacific/Apia'</body><body package="PostgreSQL3EXDI">postgresToVisualWorksEncoding: aSymbol	^EncoderMap at: aSymbol ifAbsent: [aSymbol]</body><body package="PostgreSQL3EXDI">privateXif	"Answer the xif class instVar without attempting to initialize"	^xif</body><body package="PostgreSQL3EXDI">stdMain	"Return a dictionary of time offset -&gt; standard time timeone name, with emphasis on the northern hemisphere."	^self		createTimezoneDictionaryFromString: '-11:00:00	Pacific/Midway-10:00:00	Pacific/Honolulu-09:30:00	Pacific/Marquesas-09:00:00	Pacific/Gambier-08:00:00	Pacific/Pitcairn-07:00:00	America/Phoenix-06:00:00	Chile/EasterIsland-05:00:00	America/Lima-04:30:00	America/Caracas-04:00:00	America/Santiago-04:00:00	Brazil/West-03:00:00	America/Argentina/Buenos_Aires-03:00:00	Brazil/East-02:00:00	Brazil/DeNoronha-01:00:00	Etc/GMT+1+01:00:00	Africa/Kinshasa+02:00:00	Africa/Johannesburg+03:00:00	Africa/Nairobi+04:00:00	Indian/Mauritius+04:30:00	Asia/Kabul+05:00:00	Asia/Karachi+05:30:00	Asia/Calcutta+05:45:00	Asia/Kathmandu+06:00:00	Asia/Dhaka+06:30:00	Asia/Rangoon+07:00:00	Asia/Bangkok+08:00:00	Asia/Shanghai+08:45:00	Australia/Eucla+09:00:00	Asia/Tokyo+09:30:00	Australia/Darwin+10:00:00	Pacific/Guam+11:00:00	Asia/Vladivostok+12:00:00	Asia/Kamchatka+13:00:00	Pacific/Tongatapu+14:00:00	Pacific/Kiritimati'</body><body package="PostgreSQL3EXDI">stdSouth	"Return a dictionary of time offset -&gt; standard time timeone name, with emphasis on the southern hemisphere."	^self		createTimezoneDictionaryFromString: '-11:00:00	Pacific/Pago_Pago-10:00:00	Pacific/Tahiti-09:30:00	Pacific/Marquesas-09:00:00	Pacific/Gambier-08:00:00	Pacific/Pitcairn-07:00:00	America/Phoenix-06:00:00	Chile/EasterIsland-05:00:00	America/Lima-04:30:00	America/Caracas-04:00:00	America/Santiago-04:00:00	Brazil/West-03:00:00	America/Argentina/Buenos_Aires-03:00:00	Brazil/East-02:00:00	Brazil/DeNoronha-01:00:00	Etc/GMT+1+01:00:00	Africa/Kinshasa+02:00:00	Africa/Johannesburg+03:00:00	Africa/Nairobi+04:00:00	Indian/Mauritius+04:30:00	Asia/Kabul+05:00:00	Indian/Maldives+05:30:00	Asia/Calcutta+05:45:00	Asia/Kathmandu+06:00:00	Antarctica/Vostok+06:30:00	Indian/Cocos+07:00:00	Asia/Jakarta+08:00:00	Australia/Perth+08:45:00	Australia/Eucla+09:00:00	Asia/Tokyo+09:30:00	Australia/Darwin+10:00:00	Australia/Brisbane+11:00:00	Pacific/Guadalcanal+12:00:00	Pacific/Auckland+13:00:00	Pacific/Tongatapu+14:00:00	Pacific/Kiritimati'</body><body package="PostgreSQL3EXDI">transactionClass	^PostgresTransaction</body></methods><methods><class-id>Database.PostgresConnection class</class-id> <category>accessing</category><body package="PostgreSQL3EXDI">columnDescriptionClass	^PostgresColumnDescription</body><body package="PostgreSQL3EXDI">defaultTimeZone	^TimeZoneName"Compute value viawinter := TimeZone default secondsFromUniversalAtLocal:	(Timestamp readFrom: '31-dec-2015 12:00' readStream).summer := TimeZone default secondsFromUniversalAtLocal:	(Timestamp readFrom: '30-jun-2015 12:00' readStream).hemisphere := summer &gt; winter	ifTrue: [#northern]	ifFalse: [#southern].summer = winter ifTrue: [hemisphere := #equator].offset := Time fromSeconds: (summer &gt; winter	ifTrue: [winter]	ifFalse:  [summer])."</body><body package="PostgreSQL3EXDI">defaultTimeZone: aString	TimeZoneName := aString.</body><body package="PostgreSQL3EXDI">errorClass	"Use an ExternalDatabaseError as the parameter for exceptions raised by the External Database Interface to describe conditions reported by the dbms api in use.  Other exceptions should have nil for the parameter value."		^PostgresError</body><body package="PostgreSQL3EXDI">version	^(#relationalVersion &lt;&lt; #database &gt;&gt; 'PostgreSQL Database Interface.') asString</body></methods><methods><class-id>Database.PostgresConnection class</class-id> <category>class initialization</category><body package="PostgreSQL3EXDI">initialize	"The error categories are used (at the moment) only by the socket API."	self initializeErrorCategories.	self initializeEncoderMap.</body><body package="PostgreSQL3EXDI">initializeEncoderMap	"Initialize the Encoder Map, whose keys, Postgres encoding names, map to VW encdoing names."	EncoderMap := Dictionary new.	EncoderMap		at: #latin6 put: #'iso8859-10';		at: #win1254 put: #'windows-1254';		at: #latin7 put: #'iso8859-13';		at: #latin1 put: #'iso8859-1';		at: #win1255 put: #'windows-1255';		at: #'iso-8859-5' put: #'iso8859-5';		at: #koi8r put: #'koi8-r';		at: #latin8 put: #'iso8859-14';		at: #latin2 put: #'iso8859-2';		at: #utf8 put: #utf8;		at: #'iso-8859-6' put: #'iso8859-6';		at: #win1250 put: #'windows-1250'; 		at: #win1256 put: #'windows-1256';		at: #latin9 put: #'iso8859-15';		at: #win1257 put: #'windows-1257';		at: #latin3 put: #'iso8859-3';		at: #'iso-8859-7' put: #'iso8859-7';		at: #win1251 put: #'windows-1251';		at: #win1258 put: #'windows-1258';		at: #win1252 put: #'windows-1252';		at: #'iso-8859-8' put: #'iso-8859-8';		at: #koi8u put: #'koi8-u';		at: #latin4 put: #'iso8859-4';		at: #latin5 put: #'iso8859-9';		at: #win1253 put: #'windows-1253'.</body><body package="PostgreSQL3EXDI">initializeErrorCategories	ErrorCategories := IdentityDictionary new.	ErrorCategories		at: '00' put: #success;		at: '01' put: #warning;		at: '02' put: #noData;		at: '03' put: #sqlNotComplete;		at: '08' put: #connectionException;		at: '09' put: #triggeredActionException;		at: '0A' put: #notSupported;		at: '0B' put: #invalidTransactionInit;		at: '0F' put: #locatorException;		at: '0L' put: #invalidGrantor;		at: '0P' put: #invalidRoleSpec;		at: '20' put: #caseNotFound;		at: '21' put: #cardinalityViolation;		at: '22' put: #dataException;		at: '23' put: #integrityConstraintViolation;		at: '24' put: #invalidCursorState;		at: '25' put: #invalidTransactionState;		at: '26' put: #invalidSQLStmtName;		at: '27' put: #triggeredDataChangeViolation;		at: '28' put: #invalidAuthorizationSpec;		at: '2B' put: #dependentPrivilegeDescriptorsExist;		at: '2D' put: #invalidTransactionTermination;		at: '2F' put: #sqlRoutineException;		at: '34' put: #invalidCursorName;		at: '38' put: #externalRoutineException;		at: '39' put: #externalRoutineInvocException;		at: '3B' put: #savePointException;		at: '3D' put: #invalidCatalogName;		at: '3F' put: #invalidSchemaName;		at: '40' put: #transactionRollback;		at: '42' put: #syntaxErrorOrAccessRuleViolation;		at: '44' put: #withCheckOptionViolation;		at: '53' put: #insufficientResources;		at: '54' put: #programLimitExceeded;		at: '55' put: #objectNotInPrereqState;		at: '57' put: #operatorIntervention;		at: '58' put: #systemError;		at: 'F0' put: #configFileError;		at: 'HV' put: #foreignDataWrapperError;		at: 'P0' put: #plpgSQLError;		at: 'XX' put: #internalError</body></methods><methods><class-id>Database.PostgresConnection class</class-id> <category>signal constants</category><body package="PostgreSQL3EXDI">postgresExceptionSignal	^PostgresException</body><body package="PostgreSQL3EXDI">postgresResumableExceptionSignal	^PostgresResumableException</body></methods><methods><class-id>Database.PostgresConnection class</class-id> <category>activation</category><body package="PostgreSQL3EXDI">pause	"This method is called when we save and close an image.  The super impementation sends install to all subclasses, so this abstract postgres class passes the call on to its subclasses, all of whom are concrete and override it."	self subclasses do: [:each | each pause].</body></methods><methods><class-id>Database.PostgresConnection class</class-id> <category>private-activation</category><body package="PostgreSQL3EXDI">install	"This method is called when we return from a snapshot (i.e. open a saved image), unlike initialize which is only called when we are first loaded from parcel or Store.    The super impementation sends install to all subclasses, so this abstract postgres class passes the call on to its subclasses, all of whom are concrete and override it."	self subclasses do: [:each | each install].</body></methods><methods><class-id>Database.Postgres64NTInterface class</class-id> <category>private</category><body package="PostgreSQL3EXDI">platformSymbol	^#nt64</body></methods><methods><class-id>Database.PostgresSocketConnection</class-id> <category>accessing</category><body package="PostgreSQL3EXDI">bufferSessionsBefore: aPostgresSocketSession	"The call assumes we already know the parameter session is either the answerableSession or a queuedSession session."	^answerableSession == aPostgresSocketSession or:		[answerableSession initializeBufferedAnswerStream.		answerableSession bufferAnswerStream and:			[answerableSession := queuedSessions removeFirst.			self bufferSessionsBefore: aPostgresSocketSession]]</body><body package="PostgreSQL3EXDI">cancelAndBuffer: aPostgresSocketSession	"If aPostgresSocketSession is the answerableSession, we must wait till its buffering removes all its messages from the queue.  In that case, the alternative of sending CancelRequest would be performant if this session will still be running on the server when CancelRequest reaches it, but we risk cancelling the _next_ session if this one ends soon.  (There is apparently no way to include with a CancelRequest the id of the specific session to cancel.  We experimented, noting that #isExecuting has to be true for the session to have messages on the queue, and tried  			executingSession state == #validResults ifFalse: [self cancelCurrentRequest].but it was just too dangerously easy to cancel the _next_ request."	mutex critical:		[(queuedSessions includes: aPostgresSocketSession) ifTrue:			[self bufferSessionsBefore: aPostgresSocketSession].		answerableSession == aPostgresSocketSession ifTrue:			[answerableSession initializeBufferedAnswerStream.			answerableSession bufferAnswerStream.			answerableSession := queuedSessions isEmpty ifFalse: [queuedSessions removeFirst]]].	aPostgresSocketSession connection endBufferingOfSession.</body><body package="PostgreSQL3EXDI">executeSession: aPostgresSocketSession	"Send the session's message.  If another session still has messages on the queue, add the new session to the queued sessions, otherwise make it the answerable session.  This lets us have multiple sessions use the same connection simultaneously, either in parallel threads or through one read being triggered by code stepping through the cursor returned by another."	mutex critical:		[[self sendClientMessage: aPostgresSocketSession flushQueue]			on: OsTransferFaultError			do: [:ex |				PostgresSocketConnectionBuffer new					bufferSession: aPostgresSocketSession on: self;					finalResponse: (SocketErrorResponse new socketError: ex)].		answerableSession == nil			ifTrue: [answerableSession := aPostgresSocketSession]			ifFalse: [queuedSessions add: aPostgresSocketSession]].</body><body package="PostgreSQL3EXDI">isBufferedReadyFor: aPostgresSocketSession	"I have been sent #answer for the first time.  I must be the answerableSession or in the queue.  Ensure the connection's queue is able to answer me by buffering any sessions before me."	^self bufferSessionsBefore: aPostgresSocketSession</body><body package="PostgreSQL3EXDI">isUsingBase64	"Answer true if we are converting byteArrays (blobs) to base64 before storage, and deconverting after retrieval."	^isUsingBase64 ifNil: [isUsingBase64 := true]</body><body package="PostgreSQL3EXDI">isUsingBase64: anObject	isUsingBase64 := anObject</body><body package="PostgreSQL3EXDI">portNumber	^portNumber</body><body package="PostgreSQL3EXDI">portNumber: anInteger	portNumber := anInteger</body><body package="PostgreSQL3EXDI">portString	"Socket API wants integer ports.  C API wants string ports.  Provide these methods for commonality between them."	^self portNumber printString</body><body package="PostgreSQL3EXDI">portString: aString	"Socket API wants integer ports.  C API wants string ports.  Provide these methods for commonality between them."	portNumber := Integer readFrom: aString readStream.</body><body package="PostgreSQL3EXDI">protocolState: aSessionBasedResponse	"I've received a message that can be sent to a session;  check it can also be sent to me, and that its data is acceptable in that case.  (The only data check is for a case that should never occur and so - we think - is only here as a development check.)"	aSessionBasedResponse class = ReadyForQuery ifTrue: [^self].	aSessionBasedResponse class = CommandComplete ifTrue:		[^aSessionBasedResponse recipient class = self class ifFalse:			[self error: 'Connection received Session-targetted message.']].	self halt: 'add this case'.</body><body package="PostgreSQL3EXDI">releaseSession: aPostgresSocketSession	self isDisconnecting ifTrue: [^self].	mutex critical:		[answerableSession == aPostgresSocketSession ifTrue:			[answerableSession := queuedSessions isEmpty ifFalse: [queuedSessions removeFirst]]].</body><body package="PostgreSQL3EXDI">timeout	^timeout</body><body package="PostgreSQL3EXDI">timeout: anInteger	"Set my socket's read timeout period in milliseconds.  (If I do not yet have a socket, this is what I will set it to post-connection)."	timeout := anInteger.	socketConnection ifNotNil: [socketConnection timeoutMS: timeout]</body></methods><methods><class-id>Database.PostgresSocketConnection</class-id> <category>accessing-server parameters</category><body package="PostgreSQL3EXDI">activeParameters	^activeParameters</body><body package="PostgreSQL3EXDI">backendKey	^(self activeParameters at: 'backendKey')</body><body package="PostgreSQL3EXDI">backendPID	^self activeParameters at: 'backendPID'</body><body package="PostgreSQL3EXDI">clientEncoding	"This is one of the parameters returned by the server when we connected, affirming what encoding it thinks we're using. If we have not yet connected to the server, client_encoding will be absent, returning nil."	^(self activeParameters at: 'client_encoding' ifAbsent: [^nil]) asLowercase asSymbol</body><body package="PostgreSQL3EXDI">clientEncoding: aSymbol	"Postgres expects encoding names to be strings but VisualWorks expects them to be lowercase symbols.  The clientEncoding getter and setter therefore convert between symbols (the parameter and what they return) and strings (what they send to and get from Postgres).  Return the encoding for use in chains of setters.	The post-processing of messages in the update... will raise an error if the encoding was not accepted by the postgres client."	self updateConnectionParameter: 'client_encoding' to: aSymbol asString.	^aSymbol</body><body package="PostgreSQL3EXDI">serverEncoding	^(self activeParameters at: 'server_encoding') asSymbol</body><body package="PostgreSQL3EXDI">serverVersion	"Return a default (two-digit 0.0 for now, but review this) so compare tools will respond sensibly catiously, i.e. by assuming it's older than any 'does it support this new feature?' check needs."	^activeParameters at: 'server_version' ifAbsent: ['0.0']</body><body package="PostgreSQL3EXDI">standardConformingStrings	^self activeParameters at: 'standard_conforming_strings' ifAbsent: ['off']</body><body package="PostgreSQL3EXDI">timezone	^(self activeParameters at: 'TimeZone' ifAbsent: [^nil])</body><body package="PostgreSQL3EXDI">timezone: aString	"Tell the server what our timezone string is. For example, PST8PDT.	This way, the server will know what time it is, UTC, when we store a Timestamp."	aString isEmpty ifTrue: [^self].	self updateConnectionParameter: 'TimeZone' to: aString.	^aString</body></methods><methods><class-id>Database.PostgresSocketConnection</class-id> <category>private-accessing</category><body package="PostgreSQL3EXDI">cancelCurrentRequest	"Using a separate client, ask the server to cancel an ongoing request.  Note that this is not certain to succeed (since, for example, the remote query might already have finished). A cancel request simply improves the odds that the query will fail soon.  If the cancellation is effective, the current command will terminate early and return an error result.  If the cancellation has no effect (e.g. because the server was already done processing the command), then there will be no visible result at all.	A very serious problem is that this cancels the request that is current on the server for me at the time it arrives.  It does not cancel the request that was current for me at the time this method was invoked;  the protocol has no way of identifying which request is to be cancelled.  As it is an asynchronous call, this means there is no very safe way to use this in ordinary programming;  users who receive timeouts are invited to consider it as one of their options."	self class		cancelCurrentRequestHost: self hostName		port: self portNumber		PID: self backendPID		key: self backendKey.</body><body package="PostgreSQL3EXDI">connection	"For polymorphism with session."	^self</body><body package="PostgreSQL3EXDI">dbExceptionClass	"Connection objects have control during login. After that session objects have control."	^self class unableToConnectToSQLserverSignal</body><body package="PostgreSQL3EXDI">defaultError	"Answer a default error instance for the receiver."	| err |	err := self class errorClass new.	err dbmsErrorCode: 0.	err dbmsErrorString: 'Connection Error'.	err sqlState: String new.	^err</body><body package="PostgreSQL3EXDI">getAllConnectionParameters	"Get all the connection parameters that are not provided by login. (This will also update all those that _are_ provided by login.)"	| sess ans |	sess := self getSession.	sess prepareWithoutBinding: 'SHOW ALL'.	sess execute.	[(ans := sess answer) = #noMoreAnswers] whileFalse:		[ans = #noAnswerStream ifFalse:			[ans upToEnd do: [:row | activeParameters at: (row at: 1) put: (row at: 2)]]].	sess disconnect.</body><body package="PostgreSQL3EXDI">getConnectionErrors	"Return a non-empty collection of PostgreSQL errors associated with the connection handle.  Some senders assume a non-empty collection, so consider using a default if no official error available."	| errors |	errors := OrderedCollection new.	"err := self getErrorsExternal ifNil: [self class defaultError].	errors add: err."	^errors</body><body package="PostgreSQL3EXDI">getConnectionParameter: aString	"Get (and return) the connection parameter's status (i.e. one not provided by login;  this will also update one that _is_ provided by login).  For example, getConnectionParameter: 'bytea_output'."	| sess ans result |	sess := self getSession.	sess prepareWithoutBinding: 'SHOW ', aString.	sess execute.	[(ans := sess answer) = #noMoreAnswers] whileFalse:		[ans = #noAnswerStream ifFalse:			[ans upToEnd do: [:row | activeParameters at: aString put: (result := row first)]]].	sess disconnect.	^result</body><body package="PostgreSQL3EXDI">getConnectionParameters: anArray	"Get the connection parameters (i.e. ones not provided by login;  this will also update any that _are_ provided by login).  For example, getConnectionParameters: #('bytea_output' 'max_connections')."	| sess ans stream results index |	index := 0.	results := Array new: anArray size.	stream := WriteStream on: (String new: anArray size * 20).	anArray do: [:each | stream nextPutAll: 'SHOW '; nextPutAll: each; nextPut: $;].	sess := self getSession.	sess prepareWithoutBinding: stream contents.	sess execute.	[(ans := sess answer) = #noMoreAnswers] whileFalse:		[ans = #noAnswerStream ifFalse:			[ans upToEnd do:				[:row |				results at: (index := index + 1) put:					(activeParameters at: (anArray at: index) put: row first)]]].	sess disconnect.	^results</body><body package="PostgreSQL3EXDI">isolationLevel: anIsolationLevel	"See direct setters fior use of this to guard interruptible (readWaitWithTimeoutMs:) sockets."	self error: 'Subclass responsibility stub not reimplemented'</body><body package="PostgreSQL3EXDI">processPostAuthenticationServerMessages	"After receiving #authenticationOk, the server sends a series of informative messages;  activate any such messages and then continue.  If the server sends a NoticeResponse message, activating raises a signal whose default action is to alert the client (the server may be going down, etc.).  If the server sends an ErrorResponse,we have already been disconnected;  activation will raise an error, so exit from here."	[(self receiveServerMessage activateOnRecipient: self) class == ReadyForQuery] whileFalse.</body><body package="PostgreSQL3EXDI">receiveServerMessage	"Wait for server response, catching timeout and socket errors."	| serverMessage |	serverMessage := [self unprotectedReceiveServerMessage]		on: TimeoutExceeded, Error		do: [:ex |			traceLevel &lt; 1 ifFalse: [self class trace: ex class name].			ex return: (ex class == TimeoutExceeded						ifTrue: [TimeoutResponse new]						ifFalse: [SocketErrorResponse new socketError: ex])].	^serverMessage</body><body package="PostgreSQL3EXDI">responseForMessage: aByteArray	"Send the message bytes to the server, get the server's response, parse the response and return the results in an array.  Postgres is allowed to send a variety of status messages at any time, so the first message from the server may not be the response to our message.  (If we timeout, that will raise a ResumableTimeoutException inside receiveServerMessage;  it's up to the user to resume it or not.)"	self sendClientMessage: aByteArray.	^self receiveServerMessage activateOnRecipient: self</body><body package="PostgreSQL3EXDI">sendClientMessage: aByteArray	"Send the message bytes to the server, get the server's response, parse the response and return the results in an array.	Postgres is allowed to send a variety of status messages at any time, so our message may not be the response to our message."	iostream		nextPutAll: aByteArray;		commit.</body><body package="PostgreSQL3EXDI">unprotectedReceiveServerMessage	"Get the server's response, parse it and return the results in an array. Postgres is allowed to send a variety of status messages at any time, so our message may not be the response to the most recent thing we sent.	(In normal operation, any error in this method will be treated by its callers as showing that the socket is no longer valid;  if refactoring this method. consider commenting out Error in callers while doing so.)"	| length unparsed msgBytes code |	code := Character value: iostream next.	length := self class int32FromByteArray: (iostream next: 4).	msgBytes := iostream next: length - 4.	unparsed := PostgresServerResponse rawMessage: code bytes: msgBytes.	traceLevel &gt;= 3 ifTrue:		[self class trace: 'Server: ', unparsed printString].	^unparsed</body><body package="PostgreSQL3EXDI">updateConnectionParameter: aParameter to: aString	"Update a connection parameter after we have already connected."	| strm queryMsg flushMsg byteStrm |	strm := String new writeStream.	strm		nextPutAll: 'set '; nextPutAll: aParameter; nextPutAll: ' to ';		nextPut: $'; nextPutAll: aString; nextPut: $'. 	queryMsg := self msgQuery: strm contents.	flushMsg := self msgFlush.	byteStrm := ByteArray new writeStream.	byteStrm nextPutAll: queryMsg.	byteStrm nextPutAll: flushMsg.	self sendClientMessage: byteStrm contents.	self processPostAuthenticationServerMessages.</body></methods><methods><class-id>Database.PostgresSocketConnection</class-id> <category>messages client</category><body package="PostgreSQL3EXDI">msgBindStmtName: statementString portalName: portalString buffers: buffers	" '$B' I32&lt;len&gt; S&lt;portal-name&gt; S&lt;stmt-name&gt; I16&lt;(0,1,or numFmts)&gt; I16[n] I16&lt;(numParams)&gt; {I32&lt;-1,0,n&gt; #[..bytes(n)]}* I16&lt;(0,1,m&gt; I16[m] "	"Using an array of buffers, compose a BIND message."	| strm ba len numParameters buffer bufferBytes numResultColumns formatFlag|	strm := WriteStream on: ByteArray new.	strm nextPut: $B asInteger.	strm nextPutAll: (self class byteArrayFromInt32: 0).	strm		nextPutAll: portalString asByteArray;		nextPut: 0.	strm		nextPutAll: statementString asByteArray;		nextPut: 0.	numParameters := buffers size.	"Number of param format codes, followed by the format codes.	Zero num codes means use default, text, for all. One means use that for all. Else, num params.	We default to using an individual code for each parameter."	strm nextPutAll: (self class byteArrayFromUInt16: numParameters).	1 to: numParameters do:		[:i |		buffer := buffers at: i.		formatFlag := buffer isBinary ifTrue: [1] ifFalse: [0].		strm nextPutAll: (self class byteArrayFromInt16: formatFlag)].	"Next, num parameters, followed by their length, value pairs. -1 length means NULL."	strm nextPutAll: (self class byteArrayFromUInt16: numParameters).	1 to: numParameters do:		[:i |		buffer := buffers at: i.		(bufferBytes := buffer valueAsByteArray) = #NULL			ifTrue: [strm nextPutAll: (self class byteArrayFromInt32: -1)]			ifFalse: 				[strm nextPutAll: (self class byteArrayFromInt32: bufferBytes size).				strm nextPutAll: bufferBytes]].	"Number of result column format codes, followed by the format codes.	Zero num codes means use default, text, for all. One means use that for all. Else, num return columns.	We default to retrieving all columns in text form."	numResultColumns := 1.	strm nextPutAll: (self class byteArrayFromInt16: numResultColumns).	1 to: numResultColumns do:		[:i | strm nextPutAll: (self class byteArrayFromInt16: 0)].	ba := strm contents.	len := self class byteArrayFromInt32: ba size - 1.	ba replaceFrom: 2 to: 5 with: len startingAt: 1.	^ba</body><body package="PostgreSQL3EXDI">msgCloseForName: aNameOrNil isStatement: aBoolean	"Describe the current statement name ($S) or a portal name ($P). An empty string selects the default statement or portal."	| strm ba len aChar portalOrStatementName|	strm := WriteStream on: ByteArray new.	strm nextPut: $C asInteger.	strm nextPutAll: (self class byteArrayFromInt32: 0).	aChar := aBoolean ifTrue: [$S] ifFalse: [$P].	strm nextPut: aChar asInteger.	portalOrStatementName := aNameOrNil ifNil: [''].	strm nextPutAll: portalOrStatementName asByteArray.	strm nextPut: 0.	ba := strm contents.	len := self class byteArrayFromInt32: ba size - 1.	ba replaceFrom: 2 to: 5 with: len startingAt: 1.	^ba</body><body package="PostgreSQL3EXDI">msgClosePortal	"Close the default portal."	^self msgCloseForName: nil isStatement: false</body><body package="PostgreSQL3EXDI">msgClosePortal: portalName	"Close the named portal. Nil gets default portal."	^self msgCloseForName: portalName isStatement: false.</body><body package="PostgreSQL3EXDI">msgCloseStatement	"Close the default statement."	^self msgCloseForName: nil isStatement: true.</body><body package="PostgreSQL3EXDI">msgCloseStatement: statementName	"Close the named statement. Nil gets default statement."	^self msgCloseForName: statementName isStatement: true.</body><body package="PostgreSQL3EXDI">msgDescribeForName: aNameOrNil isStatement: aBoolean	"Describe the current statement name ($S) or a portal name ($P). An empty string selects the default statement or portal."	| strm ba len aChar portalOrStatementName |	strm := WriteStream on: ByteArray new.	strm nextPut: $D asInteger.	strm nextPutAll: (self class byteArrayFromInt32: 0).	aChar := aBoolean ifTrue: [$S] ifFalse: [$P].	strm nextPut: aChar asInteger.	portalOrStatementName := aNameOrNil ifNil: [''].	strm nextPutAll: portalOrStatementName asByteArray.	strm nextPut: 0.	ba := strm contents.	len := self class byteArrayFromInt32: ba size - 1.	ba replaceFrom: 2 to: 5 with: len startingAt: 1.	^ba</body><body package="PostgreSQL3EXDI">msgDescribePortal	"Describe the default portal."	^self msgDescribeForName: nil isStatement: false</body><body package="PostgreSQL3EXDI">msgDescribePortal: portalName	"Describe the named portal. Nil gets default portal."	^self msgDescribeForName: portalName isStatement: false.</body><body package="PostgreSQL3EXDI">msgDescribeStatement	"Describe the default statement."	^self msgDescribeForName: nil isStatement: true.</body><body package="PostgreSQL3EXDI">msgDescribeStatement: statementName	"Describe the named statement. Nil gets default statement."	^self msgDescribeForName: statementName isStatement: true.</body><body package="PostgreSQL3EXDI">msgEncryptedPassword: aByteArray	"Like &gt;&gt;password:, but used for encrypted data for GSSAPI and SSPI response messages which expect binary data, not a null-terminated string."	| strm ba len |	strm := WriteStream on: ByteArray new.	strm nextPut: $p asInteger.	strm nextPutAll: (self class byteArrayFromInt32: 0).	strm nextPutAll: aByteArray.	ba := strm contents.	len := self class byteArrayFromInt32: ba size - 1.	ba replaceFrom: 2 to: 5 with: len startingAt: 1.	^ba</body><body package="PostgreSQL3EXDI">msgExecute	"Execute on the default portal, returning all rows."	^self msgExecuteOnPortal: nil</body><body package="PostgreSQL3EXDI">msgExecuteOnPortal: aNameOrNil	"Execute on the named portal (nil means default), returning all rows."	^self msgExecuteOnPortal: aNameOrNil maxRows: 0</body><body package="PostgreSQL3EXDI">msgExecuteOnPortal: aNameOrNil maxRows: maxRows	"Execute the named portal, and set the max number of rows to return. Nil name gets default portal. Zero means unlimited rows."	| strm ba len portalOrStatementName |	strm := WriteStream on: ByteArray new.	strm nextPut: $E asInteger.	strm nextPutAll: (self class byteArrayFromInt32: 0).	portalOrStatementName := aNameOrNil ifNil: [''].	strm nextPutAll: portalOrStatementName asByteArray.	strm nextPut: 0.	strm nextPutAll: (self class byteArrayFromInt32: maxRows).	ba := strm contents.	len := self class byteArrayFromInt32: ba size - 1.	ba replaceFrom: 2 to: 5 with: len startingAt: 1.	^ba</body><body package="PostgreSQL3EXDI">msgFlush	"Execute the Flush command."	| strm ba |	strm := WriteStream on: ByteArray new.	strm nextPut: $H asInteger.	strm nextPutAll: (self class byteArrayFromInt32: 4).	ba := strm contents.	^ba</body><body package="PostgreSQL3EXDI">msgParseBoundQuery: aStringOrNil	"Send a bound query string. For this, use the Parse message."	^self msgParseBoundQuery: aStringOrNil statementName: nil</body><body package="PostgreSQL3EXDI">msgParseBoundQuery: aStringOrNil statementName: aNameOrNil	"Send a bound query string. For this, use the Parse message, with no buffers."	^self msgParseBoundQuery: aStringOrNil statementName: aNameOrNil buffers: nil</body><body package="PostgreSQL3EXDI">msgParseBoundQuery: aStringOrNil statementName: aNameOrNil buffers: buffers	"Send a bound query string. For this, use the Parse message."	| strm ba len query statementName |	strm := WriteStream on: ByteArray new.	strm nextPut: $P asInteger.	strm nextPutAll: (self class byteArrayFromInt32: 0).	"Send the name of the prepared statement. If nil, we use the unamed prepared statement, an empty string."	statementName := aNameOrNil ifNil: [''].	strm nextPutAll: statementName asByteArray.	strm nextPut: 0.	query := aStringOrNil ifNil: [''].	strm nextPutAll: (query asByteArrayEncoding: self encoding).	strm nextPut: 0.	"Send the number of parameters that we want to prespecify types for."	strm nextPutAll: (self class byteArrayFromUInt16: buffers size).	"Send the buffer types (postgres type id)."	buffers ifNotNil:		[buffers do:			[:buffer || pgType |			pgType := self class byteArrayFromInt32: buffer postgresType.			strm nextPutAll: pgType]].	ba := strm contents.	len := self class byteArrayFromInt32: ba size - 1.	ba replaceFrom: 2 to: 5 with: len startingAt: 1.	^ba</body><body package="PostgreSQL3EXDI">msgPassword: aString	| strm ba len |	strm := WriteStream on: ByteArray new.	strm nextPut: $p asInteger.	strm nextPutAll: (self class byteArrayFromInt32: 0).	strm nextPutAll: aString asByteArray.	strm nextPut: 0.	ba := strm contents.	len := self class byteArrayFromInt32: ba size - 1.	ba replaceFrom: 2 to: 5 with: len startingAt: 1.	^ba</body><body package="PostgreSQL3EXDI">msgPassword: aPassword username: aUsername salt: aByteArray	"Encrypt the password using the Postgres MD5 scheme, which also contains the username. Postgres provides the salt bytes.	Here is what is expected, if using postgres functions:		concat('md5', md5( concat( md5( concat(password, username) ),random-salt) ))."	| strm ba len hashedBa1 hashedBa2 hashedBa3 |	strm := WriteStream on: ByteArray new.	strm nextPut: $p asInteger.	strm nextPutAll: (self class byteArrayFromInt32: 0).	hashedBa1 := Security.MD5 hash: aPassword , aUsername.	hashedBa2 := Security.MD5				hash: hashedBa1 asHexString asLowercase asByteArray , aByteArray.	hashedBa3 := 'md5' , hashedBa2 asHexString asLowercase.	strm nextPutAll: hashedBa3 asByteArray.	"Actually, it also works without the null term here."	strm nextPut: 0.	ba := strm contents.	len := self class byteArrayFromInt32: ba size - 1.	ba replaceFrom: 2 to: 5 with: len startingAt: 1.	^ba</body><body package="PostgreSQL3EXDI">msgQuery: aString	"Send a query string. For now, assume it's okay to send an empty query as well."	| strm ba len |	strm := WriteStream on: ByteArray new.	strm nextPut: $Q asInteger.	strm nextPutAll: (self class byteArrayFromInt32: 0).	strm nextPutAll: (aString asByteArrayEncoding: self encoding).	strm nextPut: 0.	ba := strm contents.	len := self class byteArrayFromInt32: ba size - 1.	ba replaceFrom: 2 to: 5 with: len startingAt: 1.	^ba</body><body package="PostgreSQL3EXDI">msgStartup	"If the user has already set an encoding value at this early point, set client encoding to use it (otherwise, the server's encoding will be used)."	| strm ba len |	strm := WriteStream on: ByteArray new.	strm nextPutAll: (self class byteArrayFromInt32: 0).	strm nextPutAll: (self class byteArrayFromInt32: 196608).	strm nextPutAll: 'user' asByteArray.	strm nextPut: 0.	strm nextPutAll: username asByteArray.	strm nextPut: 0.	strm nextPutAll: 'database' asByteArray.	strm nextPut: 0.	strm nextPutAll: databaseName asByteArray.	strm nextPut: 0.	"Insert any additional parameter settings here, as above for user and database. Command line args for backend have been deprecated by Postgres."	encoding isNil ifFalse: 		[strm nextPutAll: 'client_encoding' asByteArray.		strm nextPut: 0.		strm nextPutAll: encoding asString asByteArray.		strm nextPut: 0].	strm nextPut: 0.	ba := strm contents.	len := self class byteArrayFromInt32: ba size.	ba replaceFrom: 1 to: 4 with: len startingAt: 1.	^ba</body><body package="PostgreSQL3EXDI">msgSync	"Execute the Sync command. This closes the current transaction, aka auto-commit, unless we're in a transaction block."	| strm ba |	strm := WriteStream on: ByteArray new.	strm nextPut: $S asInteger.	strm nextPutAll: (self class byteArrayFromInt32: 4).	ba := strm contents.	^ba</body><body package="PostgreSQL3EXDI">msgTerminate	"Execute the Terminate command."	| strm ba |	strm := WriteStream on: ByteArray new.	strm nextPut: $X asInteger.	strm nextPutAll: (self class byteArrayFromInt32: 4).	ba := strm contents.	^ba</body></methods><methods><class-id>Database.PostgresSocketConnection</class-id> <category>private-transaction</category><body package="PostgreSQL3EXDI">beginExternal	"Mark the beginning of receivers portion of a transaction."	super beginExternal.	"self participantsDo: [:each | each disconnect]."	self getSession		prepareWithoutBinding: 'BEGIN TRANSACTION ';		execute;		answer;		answer;		disconnect.</body><body package="PostgreSQL3EXDI">commitExternal	"Commit all changes made by receiver conn."	super commitExternal ifFalse: [^self].	"self participantsDo: [:each | each disconnect]."	self getSession		prepareWithoutBinding: 'COMMIT TRANSACTION';		execute;		answer;		answer;		disconnect</body><body package="PostgreSQL3EXDI">rollbackExternal	"Rollback all changes made by receiver's conn."	super rollbackExternal ifFalse:	[ ^self ].	self state = #disconnecting ifTrue: [^self ].	self getSession		prepareWithoutBinding: 'ROLLBACK TRANSACTION';		execute;		answer;		answer;		disconnect</body></methods><methods><class-id>Database.PostgresSocketConnection</class-id> <category>private-execution</category><body package="PostgreSQL3EXDI">acquireExternal: aPassword	"Create a socket connection to the host, and log in with username/password."	| pw |	pw := aPassword.	[pw isString]		whileFalse: [pw := self class requiredPasswordSignal raiseSignal].		[self acquireSocketHost: self hostName port: self portNumber.	self connectPassword: pw.	encoding isNil ifTrue:		[self encoding: self knownClientEncoding]]			ifCurtailed: [self dismissExternal].</body><body package="PostgreSQL3EXDI">dismissExternal	"Close the stream (which closes the socket). The server may have already disconnected us, so don't try too hard to close the sockets."	| msg |	answerableSession := nil.	queuedSessions := OrderedCollection new.	[[(self isConnected and: [self hasSocket]) ifTrue: 		[msg := self msgTerminate.		self sendClientMessage: msg.		traceLevel &gt;= 3 ifTrue:			[self class trace: 'Terminate:  ', msg printString]].	iostream ifNotNil: [iostream close].	socketConnection ifNotNil: [socketConnection close]]		on: Error do: [:ex | ex return]]			ensure:				[iostream := nil.				socketConnection := nil].	super dismissExternal.</body><body package="PostgreSQL3EXDI">unprepareExternal: aString	"The server holds a prepared statement against this statement name;  deallocate it.  See super comment."	aString isEmpty ifTrue: [^self].	self isConnected ifFalse: [^self].	super unprepareExternal: aString.	self getSession		prepareWithoutBinding: 'DEALLOCATE PREPARE ', aString;		execute;		answer;		answer;		disconnect.</body></methods><methods><class-id>Database.PostgresSocketConnection</class-id> <category>private-library calls</category><body package="PostgreSQL3EXDI">installExternal	"Perform return from snapshot processing."		super installExternal.	socketConnection := nil.	iostream := nil.	preparedStatementNames := Set new.</body></methods><methods><class-id>Database.PostgresSocketConnection</class-id> <category>connections</category><body package="PostgreSQL3EXDI">disconnect	"Since the connection is being closed, discard its individual sessions abruptly, ignoring their state. "	self state == #new ifTrue: [^self].	self state: #disconnecting.	super disconnect</body></methods><methods><class-id>Database.PostgresSocketConnection</class-id> <category>testing</category><body package="PostgreSQL3EXDI">hasSocket	^iostream notNil or: [socketConnection notNil]</body><body package="PostgreSQL3EXDI">isAustralianTimezones	^(self activeParameters at: 'australian_timezones' ifAbsent: [^false]) = 'true'</body><body package="PostgreSQL3EXDI">isDisconnecting	^self state = #disconnecting</body></methods><methods><class-id>Database.PostgresSocketConnection</class-id> <category>session-connection polymorphism</category><body package="PostgreSQL3EXDI">rowCount: aNumber	"Ignore this. The sender is presumably a CommandComplete, in response to a connection-based request, not a session-based request."</body></methods><methods><class-id>Database.PostgresSocketConnection</class-id> <category>private-logging in</category><body package="PostgreSQL3EXDI">acquireSocketHost: host port: portNo	| socket  |	self hasSocket ifTrue: [self error: 'Already has socket.'].	[socket := SocketAccessor newTCPclientToHost: host port: portNo]			on: OsError			do: 				[:ex || dbError |				dbError := self class errorClass new							dbmsErrorCode: 'Could not connect to host, ', environment;							dbmsErrorString: ex messageText;							yourself.				self class connectionNotOpenSignal					raiseWith: (Array with: dbError)					errorString: dbError dbmsErrorCode , ', ' , dbError dbmsErrorString].	"Open a two-way connection on the socket."	socketConnection := ExternalTimedConnection new.	socketConnection timeoutMS: timeout.	socketConnection		input: socket; 		output: socket.	iostream := socketConnection readAppendStream.	iostream binary.</body><body package="PostgreSQL3EXDI">authenticationMessageTypes	^#(AuthenticationOk AuthenticationMD5 AuthenticationCleartextPassword AuthenticationUnsupported)</body><body package="PostgreSQL3EXDI">connectPassword: pw	"Send a startup message to the server, then satisfy authentication requirement, and then accept the short list of connection messages."	| msg msgType authenticationResponse restoreTimeout |	restoreTimeout := self timeout.	self timeout: 15000.		"Temporarily set timeout to 15 seconds during login, to fail quickly if we cannot connect."	msg := self msgStartup.	authenticationResponse := self responseForMessage: msg.	msgType := authenticationResponse class.	(self authenticationMessageTypes includes: msgType name) ifTrue:		[authenticationResponse := authenticationResponse			authenticateConnection: self username: username password: pw].	"Now that we're accepted, retrieve the startup messages from the server."	self hasSocket ifTrue: [self processPostAuthenticationServerMessages].	self timeout: restoreTimeout.	"Restore timeout to previous value."</body></methods><methods><class-id>Database.PostgresSocketConnection</class-id> <category>buffering</category><body package="PostgreSQL3EXDI">endBufferingOfSession	"Not buffering;  do nothing (return self)."</body><body package="PostgreSQL3EXDI">hasCompletedBuffering	"We are not buffering, so can be read from right away."	^true</body><body package="PostgreSQL3EXDI">initializeBufferedAnswerStream	PostgresSocketConnectionBuffer new		bufferSession: answerableSession		on: self</body></methods><methods><class-id>Database.PostgresSocketConnection</class-id> <category>synchronising</category><body package="PostgreSQL3EXDI">waitForSocket: aBlock	"Tell my caller to wait until the socket is not servicing another thread.  If no critical block is running, go ahead."	^mutex critical: aBlock</body><body package="PostgreSQL3EXDI">waitUntilBuffered	"Tell my caller to wait until the #current critical: block has completed. If no critical block is running, go ahead.  Note that the calling session's connection could switch from regular to buffered during this semaphore's critical wait period, so aBlock should be aware of the possible difference between 'self' and 'aPostgresSocketSession connection'."	mutex waitIfCurtailedSignal; signal</body></methods><methods><class-id>Database.PostgresSocketConnection</class-id> <category>initialize-release</category><body package="PostgreSQL3EXDI">initialize	super initialize.	portNumber := 5432.	activeParameters := Dictionary new.	isolationLevel := false.	queuedSessions := OrderedCollection new.	timeout := 900000.	"15 * 60 * 1000"	mutex := Semaphore forMutualExclusion.</body></methods><methods><class-id>Database.PostgresSocketConnection class</class-id> <category>defaults</category><body package="PostgreSQL3EXDI">defaultError	^PostgresError new</body></methods><methods><class-id>Database.PostgresSocketConnection class</class-id> <category>private-accessing</category><body package="PostgreSQL3EXDI">cancelCurrentRequestHost: host port: portNo PID: aBackendPID key: aBackendKey	"This method opens a temporary connection to the server and sends the cancel request.	If the backend process id (PID) and key are correct, the server will try to cancel the currently	ongoing request, and return an error message to client.	Send the CancelRequest message to the server. If it works, there will be no reply, then close the stream (which closes the socket)."	| socket msg socketConnection iostream |	socket := SocketAccessor newTCPclientToHost: host port: portNo.	"Open a two-way connection on the socket."	socketConnection := ExternalConnection new.	socketConnection		input: socket;		output: socket.		iostream := socketConnection readAppendStream.	[iostream binary.	msg := self msgCancelRequestPID: aBackendPID key: aBackendKey.	iostream		nextPutAll: msg;		commit.	self traceLevel &gt; 1 ifTrue: [self trace: 'CANCEL REQUEST: ', msg printString]]		ensure: [iostream close]</body><body package="PostgreSQL3EXDI">msgCancelRequestPID: aBackendPID key: aBackendKey	"Cancel the given process of the target backend, providing the secret key, both 32-bit integers."	| strm ba |	strm := WriteStream on: ByteArray new.	strm nextPutAll: (self byteArrayFromInt32: 16).	strm nextPutAll: (self byteArrayFromInt32: 80877102).	strm nextPutAll: (self byteArrayFromInt32: aBackendPID).	strm nextPutAll: (self byteArrayFromInt32: aBackendKey).	ba := strm contents.	^ba</body><body package="PostgreSQL3EXDI">sessionClass	^PostgresSocketSession</body><body package="PostgreSQL3EXDI">xif	self error: 'Socket driver does not use xif'</body></methods><methods><class-id>Database.PostgresSocketConnection class</class-id> <category>examples</category><body package="PostgreSQL3EXDI">connectionForExamples	"To run the examples, set this to suit your local postgres installation, and ensure visibility of the open repository."	^PostgresSocketConnection new		username: 'tester';		password: 'tester';		environment: 'localhost:5432_testing'"or can write	^PostgresSocketConnection new		username: 'postgres';		password: 'something';		environment: 'localhost';		databaseName: 'postgres';		portNumber: 5432."</body><body package="PostgreSQL3EXDI">createExampleTable	"'CREATE TABLE test1( id INTEGER, name VARCHAR(25), startDate DATE, startTime TIME, startTS TIMESTAMP)'."	"self createExampleTable"	| conn sess ans results |	conn := self connectionForExamples.	conn connect.	"Run a Simple Query (just a string--no binding)."	sess := conn getSession.	sess blockFactor: 3.	sess		prepareWithoutBinding: 'CREATE TABLE test1( id INTEGER, name VARCHAR(25), startDate DATE, startTime TIME, startTS TIMESTAMP)'.	sess execute.	[(ans := sess answer) = #noMoreAnswers]		whileFalse: [ans = #noAnswerStream ifFalse: [results := ans upToEnd]].	sess disconnect.	conn disconnect.	^results</body><body package="PostgreSQL3EXDI">dropExampleTable	"self dropExampleTable"	| conn sess ans results |	conn := self connectionForExamples.	conn connect.	"Run a Simple Query (just a string--no binding)."	sess := conn getSession.	sess blockFactor: 3.	sess prepareWithoutBinding: 'DROP TABLE test1'.	sess execute.	[(ans := sess answer) = #noMoreAnswers]		whileFalse: [ans = #noAnswerStream ifFalse: [results := ans upToEnd]].	sess disconnect.	conn disconnect.	^results</body><body package="PostgreSQL3EXDI">example10	"self example10"	| conn sess ans results |	conn := self connectionForExamples.	results := OrderedCollection new.	conn connect.	"Run a Simple Query (just a string--no binding)."	sess := conn getSession.	sess blockFactor: 3.	sess prepare: 'SELECT * FROM pg_class'.	sess connection cancelCurrentRequest.	sess execute.	[(ans := sess answer) = #noMoreAnswers] whileFalse:		[ans = #noAnswerStream ifFalse: [results addAll: ans upToEnd]].	sess prepare: 'SELECT * FROM test1'.	sess execute.	[(ans := sess answer) = #noMoreAnswers] whileFalse:		[ans = #noAnswerStream ifFalse: [results addAll: ans upToEnd]].	sess disconnect.	conn disconnect.	^results</body><body package="PostgreSQL3EXDI">example11	"Example using the new connect string style, compatible with Libpq. Demonstrates using a cast for bound value arithmetic."	"PostgresSocketConnection example11"		| conn sess ans results |	conn := self connectionForExamples.	conn connect.	sess := conn getSession.		[sess blockFactor: 3.	sess prepare: 'INSERT INTO test1( id ) VALUES ( ? )'.	sess bindInput: #(6).	sess execute.	[(ans := sess answer) = #noMoreAnswers]		whileFalse: [ans = #noAnswerStream ifFalse: [results := ans upToEnd]].	sess := conn getSession.	sess blockFactor: 3.	sess prepare: 'SELECT * FROM test1 WHERE ((startDate + ?::integer) &lt; ?)'.	sess bindInput: (Array with: 1 with: Date today).	sess execute.	[(ans := sess answer) = #noMoreAnswers]		whileFalse: [ans = #noAnswerStream ifFalse: [results := ans upToEnd]]]			ensure: 				[sess disconnect.				conn disconnect].	^results</body><body package="PostgreSQL3EXDI">example6	"self example6"	| conn sess ans results |	conn := self connectionForExamples.	conn encoding: #UTF8.	conn connect.	"Run a Simple Query (just a string--no binding)."	sess := conn getSession.	sess blockFactor: 3.	sess prepare: 'SELECT * FROM INFORMATION_SCHEMA.TABLES'.	sess execute.	[(ans := sess answer) = #noMoreAnswers] whileFalse:		[ans = #noAnswerStream ifFalse: [results := ans upToEnd]].	sess disconnect.	conn disconnect.	^results</body><body package="PostgreSQL3EXDI">example7	"'CREATE TABLE test1( id INTEGER, name VARCHAR(25), startDate DATE, startTime TIME, startTS TIMESTAMP)'."	"self example7"	| conn sess ans results |	conn := self connectionForExamples.	conn connect.	"Run a Simple Query (just a string--no binding)."	sess := conn getSession.	sess blockFactor: 3.	sess prepareWithoutBinding: 'DELETE FROM test1; SELECT * FROM test1; INSERT INTO test1( id, name, startDate, startTime, startTS) VALUES ( 1, ''John Doe'', ''Feb 7, 2001'', ''10:35:49'', ''March 5, 2003 11:21:35'') '.	sess execute.	[(ans := sess answer) = #noMoreAnswers] whileFalse:		[ans = #noAnswerStream ifFalse: [results := ans upToEnd]].	sess needBinding: true.	sess prepare: 'SELECT * FROM test1'.	sess execute.	[(ans := sess answer) = #noMoreAnswers] whileFalse:		[ans = #noAnswerStream ifFalse: [results := ans upToEnd]].	sess disconnect.	conn disconnect.	^results</body><body package="PostgreSQL3EXDI">exampleBadBind	"Test error response and subsequent state when sending Parse command (prepare)."	"self exampleBadBind"	| conn sess |		[conn := self connectionForExamples.	conn connect.	sess := conn getSession.	sess prepare: 'SELECT * FROM pg_database WHERE encoding &gt; ?'.	sess bindInput: #( 'abcd' ).	sess execute.	conn disconnect]			on: Error			do: [:ex | Transcript show: ex printString, '(', ex messageText, ').'; cr]</body><body package="PostgreSQL3EXDI">exampleBadConnect	"Test error response and subsequent state."	"self exampleBadConnect"	[| conn |	conn := PostgresSocketConnection new		username: 'postgres';		password: 'dw37464';		environment: 'localhost';		databaseName: 'postgrxs';		portNumber: 5432.	conn connect.	conn disconnect] on: Error do: [:ex| Transcript show: ex messageText; cr].</body><body package="PostgreSQL3EXDI">exampleBadExecute	"Test error response and subsequent state when sending Parse command (prepare)."	"self exampleBadExecute"	| conn sess |		[conn := self connectionForExamples.	conn connect.	sess := conn getSession.	sess prepare: 'SELECT * FROM pg_database WHERE encoding &gt; ?'.	sess bindInput: #( 5 ).	sess execute.	conn disconnect]			on: Error			do: [:ex | Transcript show: ex printString, '(', ex messageText, ').'; cr]</body><body package="PostgreSQL3EXDI">exampleBadPrepare	"Test error response and subsequent state when sending Parse command (prepare)."	"self exampleBadPrepare"	| conn sess ans results |	results := OrderedCollection new.	[conn := self connectionForExamples.	conn connect.	sess := conn getSession.	sess prepare: 'This is a bad query'.	sess execute.	[(ans := sess answer) = #noMoreAnswers] whileFalse:		[ans = #noAnswerStream ifFalse: [results addAll: ans upToEnd]].	conn disconnect]			on: Error			do: [:ex | Transcript show: ex messageText; cr]</body><body package="PostgreSQL3EXDI">exampleBadPrepareSimpleQuery	"Test error response and subsequent state when sending Parse command (prepare)."	"self exampleBadPrepareSimpleQuery"	| conn sess ans |	[conn := self connectionForExamples.	conn connect.	sess := conn getSession.	sess prepareWithoutBinding: 'Select 0; This is an invalid query so the first will not execute either'.	sess execute.	[(ans := sess answer) = #noMoreAnswers] whileFalse:		[ans = #noAnswerStream ifFalse: [Transcript show: 'query result: ', ans upToEnd; cr]].	conn disconnect]			on: Error			do: [:ex | Transcript show: ex messageText; cr]</body><body package="PostgreSQL3EXDI">exampleOfCancel	"This example creates a delay funtion to simulate a long query. It then forks a process that waits for a little while and then cancels any ongoing query. While that cancelation process sleeps, we continue by calling that new delay function, which simulates our slow query. Finally, the forked process wakes up and sends a parallel query (through a new, different socket) to cancel the query on this process. The query gets canceled, returns an error, and gets retry'd. The second attempt runs, eventually returns results and we continue on to a final query before exit."	"self exampleOfCancel"		| conn sess ans results |	conn := self connectionForExamples.	conn timeout: 20000.	conn connect.	"Run a Simple Query (just a string--no binding)."	sess := conn getSession.	sess blockFactor: 3.	results := OrderedCollection new.	sess prepareWithoutBinding: 'create or replace function delayForSeconds(val integer) returns integer as		$$		begin			perform pg_sleep(1.5+val);			return val + 2;		end;		$$ LANGUAGE PLPGSQL'.	sess execute.	[(ans := sess answer) = #noMoreAnswers] whileFalse:		[ans = #noAnswerStream ifFalse: [results addAll: ans upToEnd]].	" This forked process will cancel the current query, causing an error message to be sent to client (sess)."	conn := sess connection.	[(Delay forSeconds: 4) wait.	conn cancelCurrentRequest] fork.	[Transcript cr; show: 'About to begin a 10 second delay.'; cr.	sess prepare: 'SELECT delayForSeconds(10)'.	sess execute.	[(ans := sess answer) = #noMoreAnswers] whileFalse:		[ans = #noAnswerStream ifFalse: [results addAll: ans upToEnd]]]	on: Error	do: [:ex | ex = TimeoutExceeded			ifTrue: [Dialog warn: 'Timeout exceeded']			ifFalse: [Dialog warn: ex messageText.		ex retry]].	sess prepare: 'SELECT * FROM INFORMATION_SCHEMA.COLUMNS limit 3'.	sess execute.	[(ans := sess answer) = #noMoreAnswers] whileFalse:		[ans = #noAnswerStream ifFalse: [results addAll: ans upToEnd]].	Transcript cr; show: 'About to DISCONNECT session+connection'; cr.	sess disconnect.	conn disconnect.	^results</body><body package="PostgreSQL3EXDI">exampleOfTimeout	"This example sets the timeout value so low that the login and queries time out before completion."	"self exampleOfTimeout"	| conn sess ans results numTimeouts|	conn := PostgresSocketConnection new				username: 'guest';			password: 'guest';			environment: 'store.cincomsmalltalk.com:5432_store_public'.	results := OrderedCollection new.	conn timeout: 10.	[conn connect] on: ResumableTimeoutException do: [:ex| Transcript show: '***** 1. Timeout during connecting caught. *****'; cr.				ex resume].	conn disconnect.	conn timeout: 70.	[conn connect] on: ResumableTimeoutException do: [:ex| Transcript show: '***** 2. Timeout during connecting caught. *****'; cr.				ex resume].	"Run a query (just a string--no binding)."	sess := conn getSession.	numTimeouts := 0.	[sess prepare: 'SELECT * FROM INFORMATION_SCHEMA.TABLES LIMIT 10'.	sess execute.	[(ans := sess answer) = #noMoreAnswers] whileFalse:		[ans = #noAnswerStream ifFalse: [results addAll: ans upToEnd]]]	on: ResumableTimeoutException	do: [:ex|  numTimeouts := numTimeouts + 1.			ex resume].	Transcript show: '***** ', numTimeouts printString, ' Timeouts caught during query during first query. *****'; cr.	numTimeouts := 0.	[sess prepare: 'SELECT * FROM INFORMATION_SCHEMA.COLUMNS LIMIT 10'.	sess execute.	[(ans := sess answer) = #noMoreAnswers] whileFalse:		[ans = #noAnswerStream ifFalse: [results addAll: ans upToEnd]]]	on: ResumableTimeoutException	do: [:ex|  numTimeouts := numTimeouts + 1.			ex resume].	Transcript show: '***** ', numTimeouts printString, ' Timeouts caught during query during second query. *****'; cr.	Transcript cr; show: 'DONE: disconnecting session and connection'; cr.	sess disconnect.	conn disconnect.	^results</body><body package="PostgreSQL3EXDI">examples	"Ensure you can reach the Cincom open repository, then set examplePostgresConnection to suit your local installation.  If appropriate, do	self createExampleTable.after which you can run	self examplesrepeatedly, and/or run example methods individually.  Do	self dropExampleTableto clean-up if desired."	self example1.	self exampleOfConnecting.	self example6.	self example7.	self example10.	self exampleBadBind.	self exampleBadConnect.	self exampleBadPrepare.	self exampleBadExecute.	self exampleOfCancel.	self exampleOfTimeout.</body></methods><methods><class-id>Database.PostgresSocketConnection class</class-id> <category>activation</category><body package="PostgreSQL3EXDI">pause	"My intent is that this driver (or all drivers if receiver is ExternalDatabaseConnection) should indefinitely suspend operations.  Drivers that maintain a registry of external interface resources use it to pause by sending quiesce to each.  This socket interface driver does not need or maintain a registry, so cannot use that approach.  This 'do nothing' method prevents a DNU (that can be resolved by 'Return self' and proceed) when the superclass implementation is called, e.g. on image save."</body></methods><methods><class-id>Database.PostgresSocketConnection class</class-id> <category>private-activation</category><body package="PostgreSQL3EXDI">install	"This method is called when we return from a snapshot (i.e. open a saved image), unlike initialize which is only called when we are first loaded from parcel or Store.  It doesn't need a Registry for library handles, but the Socket API still needs to clear all formerly active connections."	self returnFromSnapshot.</body><body package="PostgreSQL3EXDI">returnFromSnapshot	"The Socket API cannot call #returnFromSnapshot unless it sets a non-nil registry, which it has not (yet) reason to do, so clones the line."		( TraceLevel &gt;= 1 ) ifTrue: [self trace: nil].	self allInstancesDo: [:each | each install].</body></methods><methods><class-id>Database.PostgresSocketConnection class</class-id> <category>examples api-experiments</category><body package="PostgreSQL3EXDI">example1	"self example1"	"Here, we only use an empty PostgresSocketConnection instance for its ability to generate a message."	| password messageGenerator socket connection stream msg serverMsg codeAndLength length code serverResponse |	password := 'public'.	messageGenerator := PostgresSocketConnection new		username: 'postgres';		databaseName: password;		yourself.	socket := SocketAccessor newTCPclientToHost: 'localhost' port: 5432.	"Open a two-way connection on the socket."	connection := ExternalConnection new.	connection		input: socket;		output: socket.	"Open a stream on the socket connection."	stream := connection readAppendStream.	"Since the server and client might be on different	operating systems, choose a neutral line end convention."		[stream binary.	msg := messageGenerator msgStartup.	"Send a message to the server, then get the reply."	stream		nextPutAll: msg;		commit.	"Get the reply."	codeAndLength := stream next: 5.	code := Character value: codeAndLength first.	length := self int32FromByteArray: (codeAndLength allButFirst: 1).	serverMsg := stream next: length - 4.	serverResponse := PostgresServerResponse rawMessage: code bytes: serverMsg.	"Further authentication is typically required."	serverResponse type == #AuthenticationOk ifFalse:		[msg := serverResponse type == #AuthenticationMD5					ifTrue:						[messageGenerator							msgPassword: password							username: 'postgres'							salt: serverResponse salt]					ifFalse:						[serverResponse type == #AuthenticationCleartextPassword							ifTrue: [msg := messageGenerator msgPassword: password]							ifFalse: [self error: 'Unexpected authentication type.']].		stream			nextPutAll: msg;			commit.		codeAndLength := stream next: 5.		code := Character value: codeAndLength first.		length := self int32FromByteArray: (codeAndLength allButFirst: 1).		serverMsg := stream next: length - 4.		serverResponse := PostgresServerResponse rawMessage: code bytes: serverMsg].			serverResponse type == #AuthenticationOk		ifTrue: [Transcript show: 'We are in!'; cr]		ifFalse: [Transcript show: 'We are not logged in.'; cr]	"Close the stream (which closes the socket)."]			ensure: [stream close].</body><body package="PostgreSQL3EXDI">exampleOfConnecting	"self exampleOfConnecting"	| conn |	conn := self connectionForExamples.	conn connect.	conn disconnect</body></methods><methods><class-id>Database.PostgresSocketConnection class</class-id> <category>accessing</category><body package="PostgreSQL3EXDI">kind	^#PostgresSocket</body></methods><methods><class-id>Database.PostgresSocketConnection class</class-id> <category>helpers</category><body package="PostgreSQL3EXDI">byteArrayFromInt16: anInteger	"Convert a signed integer into a 16-bit, bigEndian byteArray. (LSByte is last.)"	| ub |	ub := UninterpretedBytes from: (ByteArray new: 2).	anInteger abs &gt;= (2 ** 15) ifTrue: [self error: 'Not a 16-bit integer.'].	ub shortAt: 1 put: anInteger bigEndian: true.	^ub asByteArray</body><body package="PostgreSQL3EXDI">byteArrayFromInt32: anInteger	"Convert a signed integer into a 32-bit, bigEndian byteArray. (LSByte is last.)"	| ub |	ub := UninterpretedBytes from: (ByteArray new: 8).	(anInteger abs &gt;= (2**31)) ifTrue: [self error: 'Not a 32-bit integer.'].	^(anInteger abs &gt;= (2**30))		ifTrue: 			[ub longLongAt: 1 put: anInteger bigEndian: true.			ub asByteArray copyFrom: 5 to: 8]		ifFalse: 			[ub longAt: 1 put: anInteger bigEndian: true.			ub asByteArray copyFrom: 1 to: 4]</body><body package="PostgreSQL3EXDI">byteArrayFromUInt16: anInteger	"Convert a signed integer into a 16-bit, bigEndian byteArray. (LSByte is last.)"	| ub |	ub := UninterpretedBytes from: (ByteArray new: 2).	anInteger abs &gt;= (2 ** 16) ifTrue: [self error: 'Not a 16-bit unsigned integer.'].	ub unsignedShortAt: 1 put: anInteger bigEndian: true.	^ub asByteArray</body><body package="PostgreSQL3EXDI">int32FromByteArray: aByteArray	"Convert a signed integer into a 32-bit, bigEndian byteArray. (LSByte is last.)"	"PgsqlConnection int32FromByteArray: #[0 1 2 255]"	"PgsqlConnection int32FromByteArray: #[255 0 1 2]"	"PgsqlConnection int32FromByteArray: (PgsqlConnection byteArrayFromInt32: (66303))"	"PgsqlConnection int32FromByteArray: (PgsqlConnection byteArrayFromInt32: (-16776958))"	| ub |	ub := UninterpretedBytes from: aByteArray.	^ub longAt: 1 bigEndian: true.</body></methods><methods><class-id>Database.Postgres64MacOSXInterface class</class-id> <category>private</category><body package="PostgreSQL3EXDI">platformSymbol	^#macOSX64</body></methods><methods><class-id>Database.CopyResponse</class-id> <category>accessing</category><body package="PostgreSQL3EXDI">columnFormats	^columnFormats</body><body package="PostgreSQL3EXDI">columnFormats: anObject	columnFormats := anObject</body><body package="PostgreSQL3EXDI">mainFormat	^mainFormat</body><body package="PostgreSQL3EXDI">mainFormat: anObject	mainFormat := anObject</body><body package="PostgreSQL3EXDI">stream: aStream	| len numFormats |	super stream: aStream.	len := stream size.	mainFormat := self int8From1Byte.	(#(0 1) includes: mainFormat)		ifFalse: [self error: 'Invalid format to ' , self type].	numFormats := self int16From2Bytes.	columnFormats := self nextNFormatCodes: numFormats.	len = (1 + 2 + (columnFormats size * 2))		ifFalse: [self error: 'Invalid length ' , self type].</body></methods><methods><class-id>Database.FunctionCallResponse</class-id> <category>accessing</category><body package="PostgreSQL3EXDI">messageData	^messageData</body><body package="PostgreSQL3EXDI">messageData: anObject	messageData := anObject</body><body package="PostgreSQL3EXDI">stream: aStream	| len  |	super stream: aStream.	len := self int32From4Bytes.	messageData := self nextNBytesOrSpecialCode: len.</body></methods><methods><class-id>Database.UnrecognizedResponse</class-id> <category>accessing</category><body package="PostgreSQL3EXDI">activate	| dbError aPostgresError |	aPostgresError := PostgresSocketConnection defaultError.	aPostgresError dbmsErrorCode: '#Failed'.	aPostgresError dbmsErrorString: 'Failed to parse server message. This may be cautiously resumed.'.	dbError := aPostgresError.	PostgresSocketConnection postgresResumableExceptionSignal		raiseRequestWith: (Array with: dbError)		errorString: dbError dbmsErrorCode , ', ' , dbError dbmsErrorString.</body></methods><methods><class-id>Database.PostgresSolarisInterface class</class-id> <category>private</category><body package="PostgreSQL3EXDI">platformSymbol	^#sun5_unix</body></methods><methods><class-id>Database.SocketErrorResponse</class-id> <category>accessing</category><body package="PostgreSQL3EXDI">activate	PostgresSocketConnection connectionNotOpenSignal		raiseWith: (Array with: socketError)		errorString: socketError description.</body><body package="PostgreSQL3EXDI">socketError	^socketError</body><body package="PostgreSQL3EXDI">socketError: anError	socketError := anError.</body></methods><methods><class-id>Database.PostgresTransaction</class-id> <category>private-library calls</category><body package="PostgreSQL3EXDI">beginExternal	"Do nothing for now."</body><body package="PostgreSQL3EXDI">commitExternal	"Do nothing for now."</body><body package="PostgreSQL3EXDI">rollbackExternal	"Do nothing for now."</body></methods><methods><class-id>Database.PostgresTransaction class</class-id> <category>accessing</category><body package="PostgreSQL3EXDI">connectionClass	"This is used to access error messages, e.g. in calls of self class connectionClass externalDatabaseErrorSignal, that are not coflicting between the two APIs (that I have seen, so far), so the abstract superclass is an acceptable return value."	^PostgresConnection</body></methods><methods><class-id>Database.RowDescription</class-id> <category>accessing</category><body package="PostgreSQL3EXDI">allowedPriorStateTypes	^recipient needBinding		ifTrue: [#(#BindComplete)]		ifFalse: [#(nil #CommandComplete #EmptyQueryResponse)]</body><body package="PostgreSQL3EXDI">fields	^fields</body><body package="PostgreSQL3EXDI">fields: anObject	fields := anObject</body><body package="PostgreSQL3EXDI">stream: aStream	| numFields |	stream := aStream.	numFields := self int16From2Bytes.	fields := self nextNFieldValues: numFields.</body></methods><methods><class-id>Database.BackendKeyData</class-id> <category>accessing</category><body package="PostgreSQL3EXDI">activate	"The recipient is a PostgresSocketConnection just after having connected."	recipient activeParameters at: 'backendPID' put: self pid.	recipient activeParameters at: 'backendKey' put: self key</body><body package="PostgreSQL3EXDI">key	^key</body><body package="PostgreSQL3EXDI">key: anObject	key := anObject</body><body package="PostgreSQL3EXDI">pid	^pid</body><body package="PostgreSQL3EXDI">pid: anObject	pid := anObject</body><body package="PostgreSQL3EXDI">stream: aStream	stream := aStream.	pid := self int32From4Bytes.	key := self int32From4Bytes.</body></methods><methods><class-id>Database.BackendKeyData class</class-id> <category>instance creation</category><body package="PostgreSQL3EXDI">pid: aPid key: aKey	^self new pid: aPid;  key: aKey; yourself</body></methods><methods><class-id>Database.BindComplete</class-id> <category>accessing</category><body package="PostgreSQL3EXDI">activate	"The next messages are expected to be RowDescription, NoData, or CommandComplete."	super activate.	recipient nextServerMessage</body><body package="PostgreSQL3EXDI">allowedPriorStateTypes	"If the query has already been prepared, then nil is an adequate protocol state.  If this is a new query, then #ParseComplete must be the current protocol state (and the isPrepared boolean will just have been set by that message)."	^#(nil #ParseComplete)</body></methods><methods><class-id>Database.BindComplete</class-id> <category>testing</category><body package="PostgreSQL3EXDI">isValid	^recipient needBinding and: [super isValid]</body></methods><methods><class-id>Database.Postgres64LinuxInterface class</class-id> <category>private</category><body package="PostgreSQL3EXDI">platformSymbol	^#linux_x86_64_unix</body></methods><methods><class-id>Database.PostgresColumnDescription</class-id> <category>accessing</category><body package="PostgreSQL3EXDI">format	^format</body><body package="PostgreSQL3EXDI">format: anInteger	format := anInteger</body><body package="PostgreSQL3EXDI">isBinary	^format = 1</body><body package="PostgreSQL3EXDI">isUnsigned	^false</body></methods><methods><class-id>Database.PostgresSocketConnectionBuffer</class-id> <category>private-participation</category><body package="PostgreSQL3EXDI">participantsDo: aBlock	connection participantsDo: aBlock.</body></methods><methods><class-id>Database.PostgresSocketConnectionBuffer</class-id> <category>private-server messaging</category><body package="PostgreSQL3EXDI">bufferExecutingSession	"Block reading, (re)set to writing and get all messages from the server until ReadyForQuery or timeout, returning a boolean showing which of these ended this session of buffering."	| readPosition |	finalResponse := nil.		"block reading"	readPosition := buffer position.	"swap to write stream"	buffer position: writePosition.	self bufferServerMessages.	"get more messages"	buffer position: readPosition.	"swap back to read stream"	^self hasCompletedBuffering</body><body package="PostgreSQL3EXDI">bufferServerMessages	"Our aim is to clear the socket for the upcoming session by reading and buffering the messages my session needs.  Stop on TimeoutResponse or ReadyForQuery (or Error)."	| serverResponse |	[[serverResponse := connection unprotectedReceiveServerMessage.	serverResponse class == ReadyForQuery] whileFalse: [buffer nextPut: serverResponse]]		on: TimeoutExceeded, Error		do: [:ex |			connection class traceLevel &lt; 1 ifFalse: [connection class trace:  'WHILE BUFFERING: ', ex description].			serverResponse := ex class == TimeoutExceeded						ifTrue: [TimeoutResponse new]						ifFalse: [SocketErrorResponse new socketError: ex].			ex return].	writePosition := buffer position.		"store the write position before we begin reading"	finalResponse := serverResponse.	"the buffer is now ready for reading"</body><body package="PostgreSQL3EXDI">cancelCurrentRequest	"Convenience message for the case when an attempt to cancel a session leads to a timeout during buffering."	^connection cancelCurrentRequest</body><body package="PostgreSQL3EXDI">endBufferingOfSession	session connection: connection.</body></methods><methods><class-id>Database.PostgresSocketConnectionBuffer</class-id> <category>testing</category><body package="PostgreSQL3EXDI">cancelAndBuffer: aPostgresSocketSession	"We're already buffering and we would ignore a timeout so do nothing."	^true</body><body package="PostgreSQL3EXDI">hasCompletedBuffering	^finalResponse class == ReadyForQuery</body></methods><methods><class-id>Database.PostgresSocketConnectionBuffer</class-id> <category>connection polymorphism</category><body package="PostgreSQL3EXDI">activeParameters	^connection activeParameters</body><body package="PostgreSQL3EXDI">dynamicPostgreSQLTypeToClassMap	^connection dynamicPostgreSQLTypeToClassMap</body><body package="PostgreSQL3EXDI">encoding	^connection encoding</body><body package="PostgreSQL3EXDI">isConnected	^connection isConnected</body><body package="PostgreSQL3EXDI">isDisconnecting	"If the connection is disconnecting, we revert the session's connection:  clean-up code may call non-polymorphed methods on it."	^connection isDisconnecting and:		[self endBufferingOfSession.		true]</body><body package="PostgreSQL3EXDI">isUsingBase64	^connection isUsingBase64</body><body package="PostgreSQL3EXDI">removeParticipant: aPostgresSocketSession	"If my connection is discarding me as a participant, we revert the session's connection:  clean-up code may call non-polymorphed methods on it."	self endBufferingOfSession.	connection removeParticipant: aPostgresSocketSession</body></methods><methods><class-id>Database.PostgresSocketConnectionBuffer</class-id> <category>initialize-release</category><body package="PostgreSQL3EXDI">bufferSession: aPostgresSocketSession on: aPostgresSocketConnection	"It is just possible that the socket is in use at the exact moment of our wishing to buffer.  In that case, let that ongoing thread do the actual buffering.  As Glorp's default blockFactor is 100, assume we need an order of magnitude larger if buffering is demanded."	aPostgresSocketSession connection: self.	connection := aPostgresSocketConnection.	session := aPostgresSocketSession.	buffer := ReadWriteStream on: (OrderedCollection new: 1024).	writePosition := 0.	"buffer position"</body><body package="PostgreSQL3EXDI">finalResponse: aPostgresServerResponse	"This allows an error message, raised by sending, to be cached for the answer stream to find."	finalResponse := aPostgresServerResponse.</body><body package="PostgreSQL3EXDI">initializeBufferedAnswerStream	"Buffering already initialized, so nothing to do."</body></methods><methods><class-id>Database.PostgresSocketConnectionBuffer</class-id> <category>synchronising</category><body package="PostgreSQL3EXDI">waitForSocket: aBlock	"I am a buffer and I have reached here so either I have completed buffering or I was initialized but my buffering is ongoing in another thread so the critical block is active and I have only to wait till it completes."	finalResponse == nil ifTrue: [connection waitUntilBuffered].	^aBlock value</body></methods><methods><class-id>Database.PostgresSocketConnectionBuffer</class-id> <category>accessing</category><body package="PostgreSQL3EXDI">isBufferedReadyFor: aPostgresSocketSession	"I am a buffer and I have reached here so either I have completed buffering or I was initialized but my buffering is ongoing in another thread so the critical block is active and I have only to wait till it completes."	^finalResponse ~~ nil</body><body package="PostgreSQL3EXDI">receiveServerMessage	"If finalResponse is nil, I am still buffering, but it must be in another thread;  wat till the connection tells me buffering is done."	buffer atEnd ifTrue:	"When the buffered messages have been cleared, drop the buffer."		[self endBufferingOfSession.		^finalResponse].	^buffer next</body></methods><methods><class-id>Database.PostgresSocketSession</class-id> <category>accessing</category><body package="PostgreSQL3EXDI">currentRowIndex	^currentRowIndex</body><body package="PostgreSQL3EXDI">currentRowIndex: anObject	currentRowIndex := anObject</body><body package="PostgreSQL3EXDI">protocolState: aPostgresServerResponse	protocolState := aPostgresServerResponse.</body><body package="PostgreSQL3EXDI">protocolStateClass	^protocolState isNil ifFalse: [protocolState class]</body><body package="PostgreSQL3EXDI">protocolStateType	^protocolState isNil ifFalse: [protocolState type]</body><body package="PostgreSQL3EXDI">rowsInBlock	^rowsInBlock</body><body package="PostgreSQL3EXDI">rowsInBlock: anObject	rowsInBlock := anObject</body></methods><methods><class-id>Database.PostgresSocketSession</class-id> <category>private-answer set</category><body package="PostgreSQL3EXDI">aboutToAnswer	"Do any final work before fetching results from an answer set."	self rowsInBlock: 0.	self currentRowIndex: 0.</body><body package="PostgreSQL3EXDI">advanceExternal	"Advance the current row. If there are no more rows (ie., if rowsInBlock=-1), answer nil. 	Otherwise, answering self is sufficient."	| index |	self rowsInBlock = -1 ifTrue: [^nil	"No more rows will be found"].	index := self currentRowIndex.	(index = 0 or: [index = self rowsInBlock])		ifFalse: [self currentRowIndex: index + 1]		ifTrue: 			[self getBlockOfRowsExternal.			self rowsInBlock = -1				ifTrue: 					[self currentRowIndex: 0.					^nil	"No more rows will be found"].			self currentRowIndex: 1].</body><body package="PostgreSQL3EXDI">allocateRowBufferExternal: aColumn	^self class bufferClass new		columnDescription: (columnDescriptions at: aColumn)		position: aColumn		session: self</body><body package="PostgreSQL3EXDI">answerStreamDismissed	"Extended and Simple Queries end with a ReadyForQuery message, but a Simple query can consist of multiple separate SQL statements, only the last of which ends with ReadyForQuery."	super answerStreamDismissed.	(self needBinding and: [self connection isDisconnecting not]) ifTrue:		"Fetch the expected #ReadyForQuery."		[self nextServerMessage].	"If this errors, what should we do?"	self protocolStateClass == ReadyForQuery ifTrue:		[self state: #prepared].</body><body package="PostgreSQL3EXDI">blockAt: index put: aRawRow	| buffer numBuffers |	numBuffers := self rowBuffers size.	1 to: numBuffers do: [:aColumn|		buffer := (self rowBuffers) at: aColumn.		buffer blockOfData at: index put: (aRawRow at: aColumn)]</body><body package="PostgreSQL3EXDI">cancelAnswerSet	"This is only sent by ExternalAnswerStream&gt;&gt;close.  We cannot cancel the stream so must drain it before calling super."	answerStream upToEnd.	super cancelAnswerSet.</body><body package="PostgreSQL3EXDI">cancelAnswerSetExternal	"There is no way in Postgres to cancel a specific answer stream, as opposed to draining it (see #cancelAnswerSet) or clearing the whole request (see #cancelExternal).  Do nothing here."</body><body package="PostgreSQL3EXDI">describeAnswerColumns	"Fill in the columnDescriptions array."	| descrs  |	descrs := Array new writeStream.	columnsServerMessage fields do: [:field | descrs nextPut: field asColumnDescription].	self columnDescriptions: descrs contents.	self numColumns: columnsServerMessage fields size.	columnsServerMessage := nil.</body><body package="PostgreSQL3EXDI">getBlockOfRowsExternal	"If the block is only partially filled, then there are no more rows. Otherwise, advance to the next block of rows."	| count hasMore row num |	count := 0.	num := self rowsInBlock.	hasMore := (num = 0) or: [ num = self blockFactor].	[hasMore and: [count &lt; self blockFactor]] whileTrue: 			[row := self getNextRow.			row				ifNil: [hasMore := false]				ifNotNil: 					[count := count + 1.					self blockAt: count put: row].	traceLevel &gt;= 3		ifTrue: 			[self traceStream print: row printString.			self class trace: self emitTrace]].	self rowsInBlock: (count &gt; 0 ifTrue: [count] ifFalse: [-1])</body><body package="PostgreSQL3EXDI">getFieldExternal: aColumn	| buffer |	buffer := (self rowBuffers) at: aColumn.	^buffer at: ((self currentRowIndex - 1) \\ self blockFactor) + 1</body><body package="PostgreSQL3EXDI">hasAnswerSetExternal	"Answer true if the SQL-statement being processed returns an answer set.	With ExtendedQuery, there can be a single result set, and the columns have already been described, so we expect either		#dataRowLen:columnData:, #commandCompleteLen:name: or #emptyQueryResponse.	With SimpleQuery, there can be multiple result sets, and the columns have not yet been described, so we expect either		#rowDescriptionLen:fields:, #commandCompleteLen:name: or #emptyQueryResponse.	(If we have rows then #commandCompleteLen:name: is eaten by the last call of getNextRow:, not here, so the fact that we do not look for it here is not a problem.)	The EXDI expects error reports to arrive before the answerStream is read, and this is our chance to do so.	 Here, based on these possible protocolStates, we expect either		#describeCompleted followed by #dataRow, #commandComplete (or #readyForQuery if Postgres returned an error message).		#emptyQueryCompleted followed by (bound: #readyForQuery), unbound: (describe, nodata, empty, readyFQ)	protocolState is either  #dataRowCompleted #emptyQueryCompleted, #CommandComplete or, if there was an error, #readyForQueryCompleted."	self protocolStateType == #RowDescription ifTrue:		[columnsServerMessage := protocolState.		self nextServerMessage.	"preload first DataRow or CommandComplete or (the reason we do this here) ErrorResponse"		^true].	self protocolStateType == #NoData ifTrue:		[self nextServerMessage].		"Fetch the expected CommandComplete."	(#(#CommandComplete #EmptyQueryResponse) includes: self protocolStateType)		ifTrue: [self needBinding ifTrue:	"Fetch the expected ReadyForQuery to complete an Extended Query;  the isValid check will verify"				[self nextServerMessage.				self state: #prepared]]		ifFalse: [self error: 'Unexpected protocol state = ' , self protocolStateType].	^false</body></methods><methods><class-id>Database.PostgresSocketSession</class-id> <category>private-library calls</category><body package="PostgreSQL3EXDI">acquireExternal	^self</body><body package="PostgreSQL3EXDI">dismissExternal	"Release the external resources."	"All activity within this method must function with only the instance	variables defined in the executor object."	^self</body><body package="PostgreSQL3EXDI">installExternal	"Perform return from snapshot processing."	super installExternal.	self resetQueue.	protocolState := ReadyForQuery new.</body></methods><methods><class-id>Database.PostgresSocketSession</class-id> <category>private-accessing</category><body package="PostgreSQL3EXDI">dbExceptionClass	"Session objects try to execute SQL."	^PostgresSocketConnection unableToExecuteSQLSignal</body><body package="PostgreSQL3EXDI">myUniqueId	^self hash</body><body package="PostgreSQL3EXDI">state: aSymbol	| prior |	prior := self isExecuting.	super state: aSymbol.	prior ifFalse: [^self].	self isExecuting ifTrue: [^self].	connection endBufferingOfSession.	connection releaseSession: self.</body></methods><methods><class-id>Database.PostgresSocketSession</class-id> <category>testing</category><body package="PostgreSQL3EXDI">isConnected	^connection notNil and: [connection isConnected]</body><body package="PostgreSQL3EXDI">isExtendedQuery	"Return true if this query is a Postgres ExtendedQuery. That is, there is only one result set, and it offers binding."	^self needBinding</body><body package="PostgreSQL3EXDI">isSimpleQuery	"Return true if this query is a Postgres SimpleQuery which can return multiple result sets,	as opposed to an ExtendedQuery which uses binding and returns up to one result set."	^self needBinding not</body></methods><methods><class-id>Database.PostgresSocketSession</class-id> <category>data processing</category><body package="PostgreSQL3EXDI">rowCount	"Answer an Integer representing the number of rows affected by the previous query.	Valid only after the query has been answered."	^rowCount</body><body package="PostgreSQL3EXDI">rowCount: anObject	rowCount := anObject</body></methods><methods><class-id>Database.PostgresSocketSession</class-id> <category>private-binding</category><body package="PostgreSQL3EXDI">bindExternal	"Bind values to parameters in the query.  For each bind marker in the query fragments, get the corresponding value from the bindInput object. If the value isn't already bound, add it to the bindValues.  Whether it is or not (i.e. whether it is newly encountered or being reused in the query) create a buffer for it."	| indexDiv2 |	indexDiv2 := 1.	2 to: queryFragments size by: 2 do:		[:index || bindMarker value |		bindMarker := queryFragments at: index.		value := self inBindInputAt: bindMarker.		"A bindMarker can be a symbol if the prepared SQL contained :&lt;name&gt;. 		Therefore we use indexDiv2 (i.e. index/2 - the temp is twice as fast) for		parameter positions. The same value can be used at different positions."		self bindValue: value at: indexDiv2.		(self boundValueAt: bindMarker is: value) ifFalse:			[self bindValues at: bindMarker put: value].		indexDiv2 := indexDiv2 + 1].	"Determine what our statementName is. If our statementName is empty	(we clear generated names in prepareExternal), then it is generated here,	and checked against our connection's cache. If it's new, we'll need to sendParse."	self needBinding ifTrue:		[(self statementName beginsWith: self generatedStatementNamePrefix)			ifTrue: [self setStatementNameFromQueryAndTypes].	"We reset only our own generated names."		isPrepared := self isAlreadyPrepared].</body><body package="PostgreSQL3EXDI">bindValue: aValue at: aPosition	"Bind a value to a parameter position in the query by creating a new buffer to hold it."	| buffer val |	val := aValue.	buffer := self class bufferClass new on: val position: aPosition session: self.	self bindInputBuffers at: aPosition put: buffer.	buffer value: aValue.</body><body package="PostgreSQL3EXDI">portalName	^''</body><body package="PostgreSQL3EXDI">releaseBindings	"Release bind values."	bindInputBuffers := nil.	super releaseBindings</body><body package="PostgreSQL3EXDI">setupQuery: aString	"We nil the inputBuffers if there are no bindings, almost certainly needless (startPrepare has almost certainly just been sent) but just possibly we have recovered a prepared statement by name and reparsed the SQL without preparing."	super setupQuery: aString.	bindInputBuffers := queryFragments size &gt; 1		ifTrue: [Array new: queryFragments size // 2].</body><body package="PostgreSQL3EXDI">startPrepare	"It is allowed to close even a nonexistent statement, and we do that here to avoid a conflict.  There cannot be any conflict for unbound queries, because they don't used named statements.  Preparing and executing any number of unbound queries leaves the isPrepared flag unaffected."	self rowCount: 0.	self resetQueue.	super startPrepare.</body></methods><methods><class-id>Database.PostgresSocketSession</class-id> <category>private-server messaging</category><body package="PostgreSQL3EXDI">flushQueue	"Setting the protocol nil means we sent a message to the server and no reply has yet been received."	| message |	message := bufferedSendStream contents.	traceLevel &gt;= 3 ifTrue: [self class trace: 'Emit stream, size= ' , message size printString]."Should we do these after setting the answerableSession and sending the message - can it matter?"	self resetQueue.	self protocolState: nil.	^message</body><body package="PostgreSQL3EXDI">nextServerMessage	"Fetch and return the next server message.  If reading from the answer stream, set state so others attempting to use the socket will be aware.  If buffering, wait till the buffer has been filled."	^(connection waitForSocket: [connection receiveServerMessage])		activateOnRecipient: self"My connection can switch from regular to buffered outside the protected block, so I must get inside it here, before sending #receiveServerMessage to my connection, otherwise I would need code in #receiveServerMessage to manage the possibility of its 'self' and my connection object ceasing to be the same during its operation."</body><body package="PostgreSQL3EXDI">queueClientMessage: aByteArray traceName: aString	bufferedSendStream nextPutAll: aByteArray.	traceLevel &gt;= 3		ifTrue: [self class trace: aString , ': ', aByteArray printString, '(', aByteArray size printString, ')']</body><body package="PostgreSQL3EXDI">resetQueue	bufferedSendStream := bufferedSendStream reset.</body></methods><methods><class-id>Database.PostgresSocketSession</class-id> <category>private-messaging</category><body package="PostgreSQL3EXDI">getNextRow	"The current protocolState is either a DataRow or a CommandComplete. If it is row of data, return it to the sender, but fetch the next row before returning the current one. We always have the next row here because the answer stream pump forces us to ask for the first row earlier than needed, since it might be an ErrorMessage instead, which requires immediate treatment.  Returning nil indicates there are no more rows."	| rowOfData |	^self protocolStateClass == DataRow ifTrue:	"otherwise return nil"		[rowOfData := protocolState columnData.		self nextServerMessage.		rowOfData]</body><body package="PostgreSQL3EXDI">sendBind	"BIND. Send the input bind values to the external DBMS."	| bindMsg |	bindMsg := connection		msgBindStmtName: self statementName		portalName: self portalName	"hardcoded to be always the empty string"		buffers: self bindInputBuffers.	self queueClientMessage: bindMsg traceName: 'Bind'.</body><body package="PostgreSQL3EXDI">sendClosePortal	"Close the current portal. We must do this for all extended queries before creating a new portal with the same name.	Then get the server's response."	| closeMsg |	"CLOSE. Send the portal close message to the external DBMS."	closeMsg := connection msgClosePortal: self portalName.	self queueClientMessage: closeMsg traceName: 'ClosePortal'.</body><body package="PostgreSQL3EXDI">sendCloseStatement	"Close the current statement and its open portals. We must do this for all extended queries.	Then get the server's response."	| closeMsg |	"CLOSE. Send the statement-and-its-portal(s) close message to the external DBMS."	closeMsg := connection msgCloseStatement: self statementName.	self queueClientMessage: closeMsg traceName:  'CloseStatement'.</body><body package="PostgreSQL3EXDI">sendExecute	self needBinding		ifTrue:			[self queueClientMessage:				(connection msgExecuteOnPortal: self portalName) traceName: 'Portal Execute'.			self queueClientMessage: connection msgFlush traceName: 'Flush'.			self queueClientMessage: connection msgSync traceName: 'Sync']		ifFalse:			[self				queueClientMessage: (connection msgQuery: self query)				traceName: ('Query SQL: &lt;1s&gt;&lt;nt&gt;Query Message'							expandMacrosWith: self query)].</body><body package="PostgreSQL3EXDI">sendParse	"PARSE. Send the query text to the external DBMS.  Only bound queries call this method."	| queryMsg fixedUpQuery |	fixedUpQuery := self sqlWithPostgresBindMarkers.	queryMsg := connection		msgParseBoundQuery: fixedUpQuery		statementName: self statementName		buffers: bindInputBuffers.	self queueClientMessage: queryMsg		traceName: ('Parse SQL: &lt;1s&gt;&lt;nt&gt;Parse Message'					expandMacrosWith: fixedUpQuery).</body><body package="PostgreSQL3EXDI">sendPortalDescribe	"This is where we send the Portal Describe request.  Simple queries never call me.  Extended Queries use me to get the fields list from the server and fill in the columnDescriptions array.  The server's response will be available for #describeAnswerColumns."	| describeMsg |	describeMsg := connection msgDescribePortal: self portalName.	self queueClientMessage: describeMsg traceName: 'Portal Describe'.</body><body package="PostgreSQL3EXDI">sqlWithPostgresBindMarkers	"EXDI provides SQL with bound parameters denoted ? or :&lt;number&gt; or :&lt;name&gt;, the latter two being reusable within the query.  Postgres expects $-prefixed parameters.  This method converts between the two.  It is called after #bindExternal "	| sqlStream indexDiv2 |	queryFragments size = 1 ifTrue: [^queryFragments first].	indexDiv2 := 1.		sqlStream := WriteStream on: (String new: query size * 2).	sqlStream nextPutAll: queryFragments first.	2 to: queryFragments size by: 2 do:		[:index | 		sqlStream			nextPut: $$;			nextPutAll: indexDiv2 printString;	"(self bindNameFor: (queryFragments at: index))"			nextPutAll: (queryFragments at: index + 1).			indexDiv2 := indexDiv2 + 1].		"twice as fast as index/2"	^sqlStream contents</body></methods><methods><class-id>Database.PostgresSocketSession</class-id> <category>private-execution</category><body package="PostgreSQL3EXDI">bufferAnswerStream	"The TimeoutResponse is intentionally sent activated _without_ self as recipient, so resume returns here."	[connection bufferExecutingSession]		"connection must now be a connection buffer"		whileFalse: [TimeoutResponse new activate].	^connection hasCompletedBuffering</body><body package="PostgreSQL3EXDI">cancelExternal	"Cancelling an executing session will call this method to clear its messages from the socket.  We can send		self connection cancelCurrentRequestwhich alerts the server on a separate, temporary socket.  However this merely increases the odds that the query will end soon, either with 'ERROR Query cancelled due to user request' or without it, e.g. because the server had completed processing the query.  In either case, we still have to drain the connection's socket of messages for this connection, which we do by buffering, both because it is fastest and because it means the 'ERROR Query cancelled due to user request' is not processed.  We ask the server to cancel only if sure there's more data coming.  (A statement with multiple result sets whose first set has been read can be cached in Glorp with state == #validResults and: [protocolState = CommandComplete] - TBC.)	In EXDI, calling #dismiss on an executing session calls #cancel which calls this method.  However if #dismiss is called because the connection is disconnecting, no cleanup of the socket is needed."	connection isDisconnecting or: 		[connection cancelAndBuffer: self].</body><body package="PostgreSQL3EXDI">executeExternal	self needBinding ifTrue:		[self isPrepared ifFalse: [self sendParse].		self sendBind.		self sendPortalDescribe].	self sendExecute.	self connection executeSession: self.</body><body package="PostgreSQL3EXDI">initializeBufferedAnswerStream	connection initializeBufferedAnswerStream.</body><body package="PostgreSQL3EXDI">moreResultsExternal	"Get next server message. Return true if the server hasn't finished with the current results set yet. For ExtendedQuery, there are no more results, and we have already sent Sync, which acts like autocommit if we're not already in a transaction."	^self needBinding not and:		[self nextServerMessage type ~= #ReadyForQuery]</body><body package="PostgreSQL3EXDI">readyExternal	"Is the socket busy buffering the results of prior sessions?"	^connection waitForSocket:		[connection isBufferedReadyFor: self]</body><body package="PostgreSQL3EXDI">resultsExternal	"Process server responses until RowDescription, NoData, EmptyQueryResponse or CommandComplete.  The first means the server has a result set:  we'll receive zero or more rows next.  The next two mean there is no returned data:  NoData means exactly that whereas EmptyQueryResponse means this query had no answer set(s).  CommandComplete means we're done with the current command.	For extended queries, we will have sent the Portal Describe request and here get the server's responses - CloseComplete, ParseComplete, BindComplete - which will each pull in the next. in #activate., thus reaching the final set of messages described above  Simple queries (needBinding not) ignore this and immediately proceed to the next server message, as described above."	self nextServerMessage.		"RowDescription, NoData, EmptyQueryResponse or CommandComplete"</body></methods><methods><class-id>Database.PostgresSocketSession</class-id> <category>initialize-release</category><body package="PostgreSQL3EXDI">initialize	super initialize.	self currentRowIndex: 0.	self rowsInBlock: 0.	bufferedSendStream := ByteArray new writeStream.	statementName := ''.	protocolState := ReadyForQuery new.</body></methods><methods><class-id>Database.PostgresSocketSession class</class-id> <category>accessing</category><body package="PostgreSQL3EXDI">connectionClass	"Answer the class to use for connection objects associated with receiver."	^PostgresSocketConnection</body></methods><methods><class-id>Database.PostgresSocketSession class</class-id> <category>private-activation</category><body package="PostgreSQL3EXDI">bufferClass	"Answer the class to use for bindInput/Output objects associated with receiver."	^PostgresSocketBuffer</body></methods><methods><class-id>Database.AuthenticationOk</class-id> <category>initialize-release</category><body package="PostgreSQL3EXDI">initialize	self isHandled: true</body></methods><methods><class-id>Database.AuthenticationOk</class-id> <category>accessing</category><body package="PostgreSQL3EXDI">authenticateConnection: aConnection username: username password: pw	^self</body></methods><methods><class-id>Database.PostgresMacOSXInterface class</class-id> <category>private</category><body package="PostgreSQL3EXDI">platformSymbol	^#macOSX</body></methods><methods><class-id>Database.AuthenticationCleartextPassword</class-id> <category>accessing</category><body package="PostgreSQL3EXDI">authenticateConnection: aConnection username: username password: pw	| msg authentication |	msg := aConnection msgPassword: pw.	authentication := aConnection responseForMessage: msg.	^authentication</body><body package="PostgreSQL3EXDI">stream: aStream	stream := aStream</body></methods><methods><class-id>Database.NotificationResponse</class-id> <category>accessing</category><body package="PostgreSQL3EXDI">activate	"A NotificationResponse is sent by the server if the client has issued a LISTEN command, and a NOTIFY command has subsequently been issued for that channel name.  Leave the recipient's protocolState unaltered, since this message doesn't affect the ongoing query processing.  Raise a UserNotification whose defaultAction if unhandled will be to execute Dialog warn: self notificationString."	recipient traceLevel &gt;= 1 ifTrue:		[recipient class			trace: 'NOTIFICATION FROM SERVER:';			trace: self notificationString].	ExternalDatabaseNotification raiseRequestWith: self notificationString.	^super activate</body><body package="PostgreSQL3EXDI">channelName	^channelName</body><body package="PostgreSQL3EXDI">channelName: anObject	channelName := anObject</body><body package="PostgreSQL3EXDI">notificationString	'NOTIFICATION FROM SERVER:&lt;nt&gt;&lt;2p&gt;&lt;nt&gt;&lt;3p&gt;&lt;nt&gt;&lt;4p&gt;'		expandMacrosWithArguments: (Array				with: self pid				with: self channelName				with: self payload)</body><body package="PostgreSQL3EXDI">payload	^payload</body><body package="PostgreSQL3EXDI">payload: anObject	payload := anObject</body><body package="PostgreSQL3EXDI">pid	^pid</body><body package="PostgreSQL3EXDI">pid: anObject	pid := anObject</body><body package="PostgreSQL3EXDI">stream: aStream	stream := aStream.	pid := self int32From4Bytes.	channelName := self nextTerminatedString.	payload := self nextTerminatedString.</body></methods><methods><class-id>Database.NotificationResponse class</class-id> <category>instance creation</category><body package="PostgreSQL3EXDI">pid: pid channelName: aName payload: payload	^self new pid: pid; channelName: aName; payload: payload; yourself</body></methods><methods><class-id>Database.PostgresNTInterface class</class-id> <category>private</category><body package="PostgreSQL3EXDI">platformSymbol	^#nt</body></methods><methods><class-id>Database.ParseComplete</class-id> <category>testing</category><body package="PostgreSQL3EXDI">isValid	^recipient needBinding and: [super isValid]</body></methods><methods><class-id>Database.ParseComplete</class-id> <category>accessing</category><body package="PostgreSQL3EXDI">activate	"A ParseComplete message implies that our query has been prepared. Our next message is expected to be #bindComplete."	super activate.	recipient isPrepared: true.	recipient nextServerMessage.</body><body package="PostgreSQL3EXDI">allowedPriorStateTypes	^#(nil #ReadyForQuery #CloseComplete)</body></methods><methods><class-id>Database.ExternalTimedConnection</class-id> <category>accessing</category><body package="PostgreSQL3EXDI">timeoutMS	^timeoutMS</body><body package="PostgreSQL3EXDI">timeoutMS: anInteger	timeoutMS := anInteger.	currentIoBuffer isNil ifFalse: [currentIoBuffer timeoutMS: timeoutMS].</body></methods><methods><class-id>Database.ExternalTimedConnection</class-id> <category>iobuffer creation</category><body package="PostgreSQL3EXDI">defaultIoBufferInMode: binaryFlag	"Answer a default ioBuffer appropriate to the receiver with either binary or text mode."	currentIoBuffer := IOTimedBuffer on: self mode: binaryFlag.	currentIoBuffer timeoutMS: self timeoutMS.	^currentIoBuffer</body><body package="PostgreSQL3EXDI">ioBufferInMode: binaryFlag	"Answer a default ioBuffer appropriate to the receiver with either binary or text mode."	currentIoBuffer := IOTimedBuffer on: self mode: binaryFlag.	currentIoBuffer timeoutMS: self timeoutMS.	^currentIoBuffer</body></methods><methods><class-id>Database.ExternalTimedConnection class</class-id> <category>instance creation</category><body package="PostgreSQL3EXDI">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Database.PostgresFieldDescription</class-id> <category>accessing</category><body package="PostgreSQL3EXDI">asColumnDescription	"Ignore the #typeModifier for now, since the #typeOID has what we really need."	^PostgresColumnDescription new		name: self name;		index: self attribute;		type:  self typeOID;		maxColumnConstraint: self sizeModifier;		precision: nil;		scale: nil;		nullable: nil;		format: self format;		yourself</body><body package="PostgreSQL3EXDI">attribute	^attribute</body><body package="PostgreSQL3EXDI">attribute: anObject	attribute := anObject</body><body package="PostgreSQL3EXDI">format	^format</body><body package="PostgreSQL3EXDI">format: anObject	format := anObject</body><body package="PostgreSQL3EXDI">name	^name</body><body package="PostgreSQL3EXDI">name: anObject	name := anObject</body><body package="PostgreSQL3EXDI">sizeModifier	^sizeModifier</body><body package="PostgreSQL3EXDI">sizeModifier: anObject	sizeModifier := anObject</body><body package="PostgreSQL3EXDI">tableOID	^tableOID</body><body package="PostgreSQL3EXDI">tableOID: anObject	tableOID := anObject</body><body package="PostgreSQL3EXDI">typeModifier	^typeModifier</body><body package="PostgreSQL3EXDI">typeModifier: anObject	typeModifier := anObject</body><body package="PostgreSQL3EXDI">typeOID	^typeOID</body><body package="PostgreSQL3EXDI">typeOID: anObject	typeOID := anObject</body></methods><methods><class-id>Database.PostgresFieldDescription</class-id> <category>initialize-release</category><body package="PostgreSQL3EXDI">initialize	name := nil.	attribute := nil.	typeOID := nil.	sizeModifier := nil.	typeModifier := nil.	format := nil.</body></methods><methods><class-id>Database.PostgresFieldDescription</class-id> <category>comparing</category><body package="PostgreSQL3EXDI">= aField	self name = aField name ifFalse: [^false].	self tableOID = aField tableOID ifFalse: [^false].	self attribute = aField attribute ifFalse: [^false].	self typeOID = aField typeOID ifFalse: [^false].	self sizeModifier = aField sizeModifier ifFalse: [^false].	self typeModifier = aField typeModifier ifFalse: [^false].	self format = aField format ifFalse: [^false].	^true</body><body package="PostgreSQL3EXDI">hash	"Cobbled-together hash;  does it need improving?"		^(((((self name hash		bitXor: self tableOID hash)		bitXor: self attribute hash)		bitXor: self typeOID hash)		bitXor: self sizeModifier hash)		bitXor: self typeModifier hash)		hashMultiply bitXor: self format hash</body></methods><methods><class-id>Database.PostgresFieldDescription</class-id> <category>printing</category><body package="PostgreSQL3EXDI">asByteArray	| strm |	strm := ByteArray new writeStream.	strm nextPutAll: name asByteArray.	strm nextPut: 0.	strm nextPutAll: (PostgresSocketConnection byteArrayFromInt32: tableOID).	strm nextPutAll: (PostgresSocketConnection byteArrayFromInt16: attribute).	strm nextPutAll: (PostgresSocketConnection byteArrayFromInt32: typeOID).	strm nextPutAll: (PostgresSocketConnection byteArrayFromInt16: sizeModifier).	strm nextPutAll: (PostgresSocketConnection byteArrayFromInt32: typeModifier).	strm nextPutAll: (PostgresSocketConnection byteArrayFromInt16: format).	^strm contents</body><body package="PostgreSQL3EXDI">printOn: strm	strm nextPutAll: name printString, ', '.	strm nextPutAll: tableOID printString, ', '.	strm nextPutAll: attribute printString, ', '.	strm nextPutAll: typeOID printString, ', '.	strm nextPutAll: sizeModifier printString, ', '.	strm nextPutAll: typeModifier printString, ', '.	strm nextPutAll: format printString, ', '.	^strm</body></methods><methods><class-id>Database.PostgresFieldDescription class</class-id> <category>instance creation</category><body package="PostgreSQL3EXDI">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Database.EmptyQueryResponse</class-id> <category>accessing</category><body package="PostgreSQL3EXDI">activate	super activate.	recipient releaseBuffers.	recipient releaseAdaptors.	recipient columnDescriptions: #().	recipient numColumns: 0.</body><body package="PostgreSQL3EXDI">allowedPriorStateTypes	"With both bound and unbound queries, an empty query is declared by the server when the client input string contains only whitespace and/or semicolons. This message takes the place of a CommandComplete."	^recipient needBinding		ifTrue: [#(#NoData)]		ifFalse: [#(nil)]</body></methods><methods><class-id>Database.ParameterStatus</class-id> <category>accessing</category><body package="PostgreSQL3EXDI">activate	"(Since the connection here could be a connection buffer; we ask the recipient for the traceLevel, not the connection.)  An example of a ParameterStatus message is the response to the client's sending		SET CLIENT_ENCODING TO 'UNICODE'The server replies		#('client_encoding' 'UNICODE')."	| connection |	connection := recipient connection.	connection activeParameters at: self name put: self value.	recipient traceLevel &gt;= 3 ifTrue:		[PostgresSocketConnection trace: (self name -&gt; self value) printString].	^super activate</body><body package="PostgreSQL3EXDI">name	^name</body><body package="PostgreSQL3EXDI">name: anObject	name := anObject</body><body package="PostgreSQL3EXDI">stream: aStream	stream := aStream.	name := self nextTerminatedString.	value := self nextTerminatedString.</body><body package="PostgreSQL3EXDI">value	^value</body><body package="PostgreSQL3EXDI">value: anObject	value := anObject</body></methods><methods><class-id>Database.ParameterStatus class</class-id> <category>instance creation</category><body package="PostgreSQL3EXDI">name: aName value:aValue	^self new name: aName value: aValue; yourself</body></methods><methods><class-id>Database.ErrorResponse</class-id> <category>accessing</category><body package="PostgreSQL3EXDI">activate	| dbError |	recipient class == PostgresSocketSession ifTrue:		["Our current query has been abandoned by the server, and the session state variables need to be reset.		Example: code = '57014' means that the query was cancelled externally."		recipient protocolState: self.		recipient nextServerMessage.	"receive the #readyForQuery"		recipient state: #prepared	"we are no longer #executing any query"].	dbError := PostgresSocketConnection errorClass new fromErrorResponse: self.	recipient dbExceptionClass		raiseWith: (Array with: dbError)		errorString: dbError dbmsErrorCode , ', ' , dbError dbmsErrorString.</body><body package="PostgreSQL3EXDI">codeAndFieldAssociations	^codeAndFieldAssociations</body><body package="PostgreSQL3EXDI">codeAndFieldAssociations: anObject	codeAndFieldAssociations := anObject</body><body package="PostgreSQL3EXDI">stream: aStream	| fieldStrings |	stream := aStream.	fieldStrings := self nextManyCodeAndFieldStrings.	self codeAndFieldAssociations: fieldStrings.</body></methods><methods><class-id>Database.PostgresResumableException class</class-id> <category>testing</category><body package="PostgreSQL3EXDI">mayResume	^true</body></methods><methods><class-id>Database.PostgresLibpqConnection</class-id> <category>private-accessing</category><body package="PostgreSQL3EXDI">checkStatus	| xif status statusType |	xif := self class xif.	status := xif PQstatus: self connection.	statusType := xif ConnStatusType type.	status = (statusType memberNamed: #CONNECTION_OK) ifFalse: [		^self reportError	]</body><body package="PostgreSQL3EXDI">connection	^connectionHolder value</body><body package="PostgreSQL3EXDI">connection: aCPointerOrNil	connectionHolder value: aCPointerOrNil.</body><body package="PostgreSQL3EXDI">connectionHolder	^connectionHolder</body><body package="PostgreSQL3EXDI">connectionHolder: aValueHolder	connectionHolder := aValueHolder</body></methods><methods><class-id>Database.PostgresLibpqConnection</class-id> <category>private-execution</category><body package="PostgreSQL3EXDI">acquireExternal	"After connecting (successfully - we check status), if the user has set an encoding value on this connection, set it;  if not, set our encoding to that of the client if known (otherwise set both to UTF8)."	| xif |	(self class supportMethod: #PQsetdbLogin:with:with:with:with:with:with:)		ifFalse: [^self class unableToConnectToSQLenvironmentSignal raise].	xif := self class xif.	self connection: (xif PQsetdbLogin: self hostName with: self portString with: nil with: nil with: self databaseName with: self username with: self password).	self checkStatus.	encoding isNil		ifFalse: [self clientEncoding: encoding]		ifTrue: [self encoding: self knownClientEncoding].</body><body package="PostgreSQL3EXDI">acquireExternal: aPassword	aPassword isNil ifTrue: [		self class requiredPasswordSignal raiseRequest	] ifFalse: [		self password: aPassword.		self acquireExternal	].</body><body package="PostgreSQL3EXDI">dismissExternal	| conn |	conn := self connection.	( conn notNil and: [ conn isValid ]) ifTrue: [		self class xif PQfinish: conn	].	self connection: nil.	super dismissExternal.</body><body package="PostgreSQL3EXDI">unprepareExternal: aString	"The server holds a prepared statement against this statement name;  deallocate it.  See super comment."	aString isEmpty ifTrue: [^self].	self isConnected ifFalse: [^self].	super unprepareExternal: aString.	self getSession		executeDirect: 'DEALLOCATE PREPARE ', aString;		answer;		answer;		disconnect.</body></methods><methods><class-id>Database.PostgresLibpqConnection</class-id> <category>accessing</category><body package="PostgreSQL3EXDI">portNumber	"Socket API wants integer ports.  C API wants string ports.  Provide these methods for commonality between them."	^Integer readFrom: portString readStream</body><body package="PostgreSQL3EXDI">portNumber: anInteger	"Socket API wants integer ports.  C API wants string ports.  Provide these methods for commonality between them."	portString := anInteger printString</body><body package="PostgreSQL3EXDI">portString	^portString</body><body package="PostgreSQL3EXDI">portString: aString	portString := aString.</body><body package="PostgreSQL3EXDI">xif	^self class xif</body></methods><methods><class-id>Database.PostgresLibpqConnection</class-id> <category>initialize-release</category><body package="PostgreSQL3EXDI">initialize	super initialize.	portString := '5432'.	connectionHolder := nil asValue.</body></methods><methods><class-id>Database.PostgresLibpqConnection</class-id> <category>private-finalization</category><body package="PostgreSQL3EXDI">executor 	| ex |	ex := super executor.	ex connectionHolder: self connectionHolder.	^ex</body><body package="PostgreSQL3EXDI">key	^self connectionHolder</body></methods><methods><class-id>Database.PostgresLibpqConnection</class-id> <category>testing</category><body package="PostgreSQL3EXDI">isValidConnection	^self connection notNil and: [self connection isValid]</body></methods><methods><class-id>Database.PostgresLibpqConnection</class-id> <category>accessing-server parameters</category><body package="PostgreSQL3EXDI">clientEncoding	"Postgres expects encoding names to be strings but VisualWorks expects them to be lowercase symbols.  The clientEncoding getter and setter therefore convert between symbols (the parameter and what they return) and strings (what they send to and get from Postgres)."	| encodingIdPointer |	encodingIdPointer := self class xif pg_encoding_to_char: self getClientEncodingID.	^encodingIdPointer isNil ifFalse: [encodingIdPointer copyCStringFromHeap asLowercase asSymbol]</body><body package="PostgreSQL3EXDI">clientEncoding: aSymbol	"Postgres expects encoding names to be strings but VisualWorks expects them to be lowercase symbols.  The clientEncoding getter and setter therefore convert between symbols (the parameter and what they return) and strings (what they send to and get from Postgres).  Return the encoding for use in chains of setters."	| ret |	ret := self class xif PQsetClientEncoding: self connection with: aSymbol asString.	ret == -1 ifTrue:		[ self error: ((#errClientEncoding1s &lt;&lt; #database &gt;&gt; 'Unable to set client encoding to &lt;1p&gt;') expandMacrosWith: aSymbol)].	^aSymbol</body><body package="PostgreSQL3EXDI">getClientEncodingID	"If the connection is invalid, nil is returned."	^self isValidConnection ifTrue:		[self class xif PQclientEncoding: self connection]</body><body package="PostgreSQL3EXDI">isAustralianTimezones	| ptr |	ptr := self class xif PQparameterStatus: self connection with: 'australian_timezones'.	^(ptr ifNotNil: [ptr isValid ifTrue: [ptr copyCStringFromHeap]]) = 'true'</body><body package="PostgreSQL3EXDI">libVersion	^self class xif PQlibVersion</body><body package="PostgreSQL3EXDI">protocolVersion	^self class xif PQprotocolVersion: self connection</body><body package="PostgreSQL3EXDI">serverVersion	"Convert the integer value to a version string. Eg., 90104 becomes '9.1.4' and 10010040 becomes '10.10.40'."	| serverVersionString out |	serverVersionString := (self class xif PQserverVersion: self connection) printString.	out := (String new: serverVersionString size) writeStream.	out nextPut:	"last char is never converted"		(serverVersionString			inject: nil			into: [:eachPrev :eachNext |				eachPrev isNil ifFalse:					[out nextPut:	"change last 0 in any run todot."						((eachPrev = $0 and: [eachNext ~= $0])							ifTrue: [$.]							ifFalse: [eachPrev])].			eachNext]).	^out contents</body><body package="PostgreSQL3EXDI">standardConformingStrings	| ptr |	ptr := self class xif PQparameterStatus: self connection with: 'standard_conforming_strings'.	^ptr		ifNil: ['off']		ifNotNil: [ptr isValid					ifFalse: ['off']					ifTrue: [ptr copyCStringFromHeap]]</body><body package="PostgreSQL3EXDI">timezone	"Return the connection's current timezone parameter."	| ptr |	ptr := self class xif PQparameterStatus: self connection with: 'TimeZone'.	^ptr ifNotNil: [ptr isValid ifTrue: [ptr copyCStringFromHeap]]</body><body package="PostgreSQL3EXDI">timezone: aString	"There does not appear to be an api function to set client timezone, so use a query."	| sess ans |	aString isEmpty ifTrue: [^self].	sess := self getSession.	sess prepare: 'SET TIMEZONE TO ', aString printString.	sess execute.	[(ans := sess answer) = #noMoreAnswers] whileFalse:		[ans = #noAnswerStream ifFalse: [ans upToEnd]].	sess disconnect.</body><body package="PostgreSQL3EXDI">transactionStatus	| xif status statusType |	xif := self class xif.	status := xif PQtransactionStatus: self connection.	statusType := xif PGTransactionStatusType type.	status = (statusType memberNamed: #PQTRANS_INERROR) ifTrue: [		^self reportError	].	^status</body></methods><methods><class-id>Database.PostgresLibpqConnection</class-id> <category>private-transaction</category><body package="PostgreSQL3EXDI">beginExternal	super beginExternal.	self getSession		prepare: 'begin';		execute;		answer;		answer;		disconnect.</body><body package="PostgreSQL3EXDI">commitExternal	super commitExternal ifFalse: [^self].	self getSession		prepare: 'commit';		execute;		answer;		answer;		disconnect.</body><body package="PostgreSQL3EXDI">rollbackExternal	super rollbackExternal ifFalse: [^self].	self getSession		prepare: 'rollback';		execute;		answer;		answer;		disconnect</body></methods><methods><class-id>Database.PostgresLibpqConnection</class-id> <category>error handling</category><body package="PostgreSQL3EXDI">reportError	"The external API has reported a problem.  Create an external database error for it, and assign it to the exception we raise."	| xif errorMessage errorString error |	xif := self class xif.	errorMessage := xif PQerrorMessage: self connection.	errorString := errorMessage copyCStringFromHeap: self encoding.	error := self class errorClass new dbmsErrorString: errorString.	^self class postgresExceptionSignal raiseWith: (Array with: error) errorString: errorString</body></methods><methods><class-id>Database.PostgresLibpqConnection</class-id> <category>private-library calls</category><body package="PostgreSQL3EXDI">installExternal	"Perform return from snapshot processing."		super installExternal.	self connection: nil.	preparedStatementNames := Set new.</body></methods><methods><class-id>Database.PostgresLibpqConnection class</class-id> <category>class initialization</category><body package="PostgreSQL3EXDI">initialize	"The socket interface does not need a registry.  The libpq API does.  Registry-related methods #key and #registry are needed by libpq, not by sockets."	self initRegistry.	super initialize.</body><body package="PostgreSQL3EXDI">initializeExternalInterface	"Reset Interface with the right interface class based on the current platform."	| xifClass |	xifClass := self interfaceClass.	self xif: (xifClass notNil			ifTrue: [xifClass new]			ifFalse: [^ExternalDatabaseNotification raiseErrorString: (#unsupportedPlatform &lt;&lt; #database &gt;&gt; 'PostgreSQL C-API is not supported on this platform.') expandMacros]).</body><body package="PostgreSQL3EXDI">initializeExternalInterfaceMap	"self initializeExternalInterfaceMap"	xifMap := IdentityDictionary new.	self privateNonThreadedInterfaces do: [:each |		xifMap at: (each platformSymbol) put: each name]</body><body package="PostgreSQL3EXDI">privateNonThreadedInterfaces	"Return collection of loaded unthreaded interfaces	note - this method depends on the naming convention	that threaded interfaces have the word Threaded in them,	and non-threaded do not--	e.g. OracleThreadedNTInterface"	^PostgresInterface withAllSubclasses 		select: [:ea |			(ea name indexOfSubCollection: 'Threaded' startingAt: 1) == 0]</body></methods><methods><class-id>Database.PostgresLibpqConnection class</class-id> <category>accessing</category><body package="PostgreSQL3EXDI">kind	"Writing the symbol this way ensures that PostgresSocket appears first in the alphabetically-sorted list.  As libpq is new and requires setting the library on the PATH whereas socket works out-of-the-box and is what people are familiar with, showing it first of the two seems best."	^#PostgresViaLibpq</body><body package="PostgreSQL3EXDI">sessionClass	^PostgresLibpqSession</body></methods><methods><class-id>Database.PostgresLibpqConnection class</class-id> <category>private-registry</category><body package="PostgreSQL3EXDI">registry	^RegisteredPostgreSQLConnections</body><body package="PostgreSQL3EXDI">registry: aCollection	RegisteredPostgreSQLConnections := aCollection.</body></methods><methods><class-id>Database.PostgresLibpqConnection class</class-id> <category>private-accessing</category><body package="PostgreSQL3EXDI">interfaceClass	"Answer the correct interface class"	| interfaceClassName |	xifMap isNil ifTrue: [self initializeExternalInterfaceMap].	interfaceClassName := xifMap at: self platformType ifAbsent: [^nil].	^self environment at: interfaceClassName ifAbsent: [nil]</body><body package="PostgreSQL3EXDI">xif	"Answer the ExternalInterface subclass instance to use."	xif isNil ifTrue:		[self initializeExternalInterfaceMap.		self initializeExternalInterface].	^xif</body></methods><methods><class-id>Database.PostgresLibpqConnection class</class-id> <category>private-activation</category><body package="PostgreSQL3EXDI">install	"This method is called when we return from a snapshot (i.e. open a saved image), unlike initialize which is called when we are first loaded from parcel or Store.  Because we can re-open an image on a different platform, the libpq API must flush the xif and call #returnFromSnapshot to re-install any registry entries it has."	self xif: nil.	self returnFromSnapshot</body></methods><methods><class-id>Database.PostgresLibpqConnection class</class-id> <category>activation</category><body package="PostgreSQL3EXDI">pause	self quiesce.</body></methods><methods><class-id>Core.Object</class-id> <category>private-postgreSQL</category><body package="PostgreSQL3EXDI">postgreSQLConversion	^nil</body></methods><methods><class-id>Core.LargePositiveInteger</class-id> <category>private-postgreSQL</category><body package="PostgreSQL3EXDI">postgreSQLConversion	self &lt;= 2147483647 ifTrue: [^#Integer].	^#LargeInteger</body></methods><methods><class-id>Core.LargeNegativeInteger</class-id> <category>private-postgreSQL</category><body package="PostgreSQL3EXDI">postgreSQLConversion	self &gt;= -2147483648 ifTrue: [^#Integer].	^#LargeInteger</body></methods><methods><class-id>Core.FixedPoint</class-id> <category>private-postgreSQL</category><body package="PostgreSQL3EXDI">postgreSQLConversion	^#FixedPoint</body></methods><methods><class-id>Core.ByteArray</class-id> <category>private-postgreSQL</category><body package="PostgreSQL3EXDI">postgreSQLConversion	^#ByteArray</body></methods><methods><class-id>Core.SmallInteger</class-id> <category>private-postgreSQL</category><body package="PostgreSQL3EXDI">postgreSQLConversion	"Postgres' SmallIntegers are small indeed!  If we are on 64bit, even postgres' Integers can be too small."	(self &gt;= -32768 and: [self &lt;= 32767]) ifTrue: [^#SmallInteger].	ObjectMemory is64Bit ifFalse: [^#Integer].	(self &gt;= -2147483648 and: [self &lt;= 2147483647]) ifTrue: [^#Integer].	^#LargeInteger</body></methods><methods><class-id>Core.Double</class-id> <category>private-postgreSQL</category><body package="PostgreSQL3EXDI">postgreSQLConversion	^#Double</body></methods><methods><class-id>Core.Timestamp</class-id> <category>private-postgreSQL</category><body package="PostgreSQL3EXDI">postgreSQLConversion	^#Timestamp</body></methods><methods><class-id>Core.SmallDouble</class-id> <category>private-postgreSQL</category><body package="PostgreSQL3EXDI">postgreSQLConversion	^#Double</body></methods><methods><class-id>Core.Boolean</class-id> <category>private-postgreSQL</category><body package="PostgreSQL3EXDI">postgreSQLConversion	^#Boolean</body></methods><methods><class-id>Core.Time</class-id> <category>private-postgreSQL</category><body package="PostgreSQL3EXDI">postgreSQLConversion	^#Time</body></methods><methods><class-id>Core.Float</class-id> <category>private-postgreSQL</category><body package="PostgreSQL3EXDI">postgreSQLConversion	^#Float</body></methods><methods><class-id>Core.Date</class-id> <category>private-postgreSQL</category><body package="PostgreSQL3EXDI">postgreSQLConversion	^#Date</body></methods><methods><class-id>Core.OrderedCollection</class-id> <category>private-postgreSQL</category><body package="PostgreSQL3EXDI">postgreSQLConversion	^#Array</body></methods><methods><class-id>Core.Array</class-id> <category>private-postgreSQL</category><body package="PostgreSQL3EXDI">postgreSQLConversion	^#Array</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>private-postgreSQL</category><body package="PostgreSQL3EXDI">postgreSQLConversion	^#String</body></methods><methods><class-id>Core.Fraction</class-id> <category>private-postgreSQL</category><body package="PostgreSQL3EXDI">postgreSQLConversion	^#Fraction</body></methods><methods><class-id>Database.PostgresInterface</class-id> <category>procedures</category><body package="PostgreSQL3EXDI">PQBulkFinish: conn	&lt;C: PGresult *  PQBulkFinish(PGconn * conn)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQBulkStart: conn with: stmtName with: nCols with: paramFormats	&lt;C: PGresult *  PQBulkStart(PGconn * conn, const char * stmtName, unsigned int nCols, const int * paramFormats)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQCursorResult: conn with: res	&lt;C: int PQCursorResult(PGconn * conn, PGresult * res)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQbackendPID: conn	&lt;C: int PQbackendPID(const PGconn * conn)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQbinaryTuples: res	&lt;C: int PQbinaryTuples(const PGresult * res)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQcancel: cancel with: errbuf with: errbufsize	&lt;C: int PQcancel(PGcancel * cancel, char * errbuf, int errbufsize)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQclear: res	&lt;C: void PQclear(PGresult * res)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQclientEncoding: conn	&lt;C: int PQclientEncoding(const PGconn * conn)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQcmdStatus: res	&lt;C: char *  PQcmdStatus(PGresult * res)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQcmdTuples: res	&lt;C: char *  PQcmdTuples(PGresult * res)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQconndefaults	&lt;C: PQconninfoOption *  PQconndefaults(void)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQconnectPoll: conn	&lt;C: PostgresPollingStatusType PQconnectPoll(PGconn * conn)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQconnectStart: conninfo	&lt;C: PGconn *  PQconnectStart(const char * conninfo)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQconnectStartParams: keywords with: values with: expand_dbname	&lt;C: PGconn *  PQconnectStartParams(const char * const * keywords, const char * const * values, int expand_dbname)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQconnectdb: conninfo	&lt;C: PGconn *  PQconnectdb(const char * conninfo)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQconnectdbParams: keywords with: values with: expand_dbname	&lt;C: PGconn *  PQconnectdbParams(const char * const * keywords, const char * const * values, int expand_dbname)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQconnectionNeedsPassword: conn	&lt;C: int PQconnectionNeedsPassword(const PGconn * conn)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQconnectionUsedPassword: conn	&lt;C: int PQconnectionUsedPassword(const PGconn * conn)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQconninfoFree: connOptions	&lt;C: void PQconninfoFree(PQconninfoOption * connOptions)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQconninfoParse: conninfo with: errmsg	&lt;C: PQconninfoOption *  PQconninfoParse(const char * conninfo, char * * errmsg)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQconsumeInput: conn	&lt;C: int PQconsumeInput(PGconn * conn)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQcopyResult: src with: flags	&lt;C: PGresult *  PQcopyResult(const PGresult * src, int flags)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQdb: conn	&lt;C: char *  PQdb(const PGconn * conn)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQdescribePortal: conn with: portal	&lt;C: PGresult *  PQdescribePortal(PGconn * conn, const char * portal)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQdescribePrepared: conn with: stmt	&lt;C: PGresult *  PQdescribePrepared(PGconn * conn, const char * stmt)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQdisplayTuples: res with: fp with: fillAlign with: fieldSep with: printHeader with: quiet	&lt;C: void PQdisplayTuples(const PGresult * res, FILE * fp, int fillAlign, const char * fieldSep, int printHeader, int quiet)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQdsplen: s with: encoding	&lt;C: int PQdsplen(const char * s, int encoding)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQencryptPassword: passwd with: user	&lt;C: char *  PQencryptPassword(const char * passwd, const char * user)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQendcopy: conn	&lt;C: int PQendcopy(PGconn * conn)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQenv2encoding	&lt;C: int PQenv2encoding(void)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQerrorMessage: conn	&lt;C: char *  PQerrorMessage(const PGconn * conn)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQescapeBytea: from with: from_length with: to_length	&lt;C: unsigned char *  PQescapeBytea(const unsigned char * from, size_t from_length, size_t * to_length)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQescapeByteaConn: conn with: from with: from_length with: to_length	&lt;C: unsigned char *  PQescapeByteaConn(PGconn * conn, const unsigned char * from, size_t from_length, size_t * to_length)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQescapeIdentifier: conn with: str with: len	&lt;C: char *  PQescapeIdentifier(PGconn * conn, const char * str, size_t len)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQescapeLiteral: conn with: str with: len	&lt;C: char *  PQescapeLiteral(PGconn * conn, const char * str, size_t len)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQescapeString: to with: from with: length	&lt;C: size_t PQescapeString(char * to, const char * from, size_t length)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQescapeStringConn: conn with: to with: from with: length with: error	&lt;C: size_t PQescapeStringConn(PGconn * conn, char * to, const char * from, size_t length, int * error)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQexec: conn with: query	&lt;C: PGresult *  PQexec(PGconn * conn, const char * query)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQexecBulk: conn with: nRows with: paramValues with: paramLengths	&lt;C: PGresult *  PQexecBulk(PGconn * conn, unsigned int nRows, const char * const * paramValues, int * paramLengths)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQexecBulkPrepared: conn with: stmtName with: nCols with: nRows with: paramValues with: paramLengths with: paramFormats	&lt;C: PGresult *  PQexecBulkPrepared(PGconn * conn, const char * stmtName, unsigned int nCols, unsigned int nRows, const char * const * paramValues, int * paramLengths, const int * paramFormats)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQexecParams: conn with: command with: nParams with: paramTypes with: paramValues with: paramLengths with: paramFormats with: resultFormat	&lt;C: PGresult *  PQexecParams(PGconn * conn, const char * command, int nParams, Oid const * paramTypes, const char * const * paramValues, const int * paramLengths, const int * paramFormats, int resultFormat)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQexecPrepared: conn with: stmtName with: nParams with: paramValues with: paramLengths with: paramFormats with: resultFormat	&lt;C: PGresult *  PQexecPrepared(PGconn * conn, const char * stmtName, int nParams, const char * const * paramValues, const int * paramLengths, const int * paramFormats, int resultFormat)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQfformat: res with: field_num	&lt;C: int PQfformat(const PGresult * res, int field_num)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQfinish: conn	&lt;C: void PQfinish(PGconn * conn)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQflush: conn	&lt;C: int PQflush(PGconn * conn)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQfmod: res with: field_num	&lt;C: int PQfmod(const PGresult * res, int field_num)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQfn: conn with: fnid with: result_buf with: result_len with: result_is_int with: args with: nargs	&lt;C: PGresult *  PQfn(PGconn * conn, int fnid, int * result_buf, int * result_len, int result_is_int, const PQArgBlock * args, int nargs)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQfname: res with: field_num	&lt;C: char *  PQfname(const PGresult * res, int field_num)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQfnumber: res with: field_name	&lt;C: int PQfnumber(const PGresult * res, const char * field_name)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQfreeCancel: cancel	&lt;C: void PQfreeCancel(PGcancel * cancel)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQfreemem: ptr	&lt;C: void PQfreemem(void * ptr)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQfsize: res with: field_num	&lt;C: int PQfsize(const PGresult * res, int field_num)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQftable: res with: field_num	&lt;C: Oid PQftable(const PGresult * res, int field_num)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQftablecol: res with: field_num	&lt;C: int PQftablecol(const PGresult * res, int field_num)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQftype: res with: field_num	&lt;C: Oid PQftype(const PGresult * res, int field_num)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQgetCancel: conn	&lt;C: PGcancel *  PQgetCancel(PGconn * conn)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQgetCopyData: conn with: buffer with: async	&lt;C: int PQgetCopyData(PGconn * conn, char * * buffer, int async)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQgetCursorResult: res with: tup_num with: field_num	&lt;C: PGresult *  PQgetCursorResult(const PGresult * res, int tup_num, int field_num)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQgetOutResult: conn	&lt;C: PGresult *  PQgetOutResult(PGconn * conn)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQgetResult: conn	&lt;C: PGresult *  PQgetResult(PGconn * conn)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQgetisnull: res with: tup_num with: field_num	&lt;C: int PQgetisnull(const PGresult * res, int tup_num, int field_num)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQgetlength: res with: tup_num with: field_num	&lt;C: int PQgetlength(const PGresult * res, int tup_num, int field_num)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQgetline: conn with: string with: length	&lt;C: int PQgetline(PGconn * conn, char * string, int length)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQgetlineAsync: conn with: buffer with: bufsize	&lt;C: int PQgetlineAsync(PGconn * conn, char * buffer, int bufsize)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQgetssl: conn	&lt;C: void *  PQgetssl(PGconn * conn)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQgetvalue: res with: tup_num with: field_num	&lt;C: char *  PQgetvalue(const PGresult * res, int tup_num, int field_num)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQhost: conn	&lt;C: char *  PQhost(const PGconn * conn)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQinitOpenSSL: do_ssl with: do_crypto	&lt;C: void PQinitOpenSSL(int do_ssl, int do_crypto)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQinitSSL: do_init	&lt;C: void PQinitSSL(int do_init)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQisBusy: conn	&lt;C: int PQisBusy(PGconn * conn)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQisnonblocking: conn	&lt;C: int PQisnonblocking(const PGconn * conn)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQisthreadsafe	&lt;C: int PQisthreadsafe(void)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQlibVersion	&lt;C: int PQlibVersion(void)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQmakeEmptyPGresult: conn with: status	&lt;C: PGresult *  PQmakeEmptyPGresult(PGconn * conn, ExecStatusType status)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQmblen: s with: encoding	&lt;C: int PQmblen(const char * s, int encoding)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQnCursor: res	&lt;C: int PQnCursor(const PGresult * res)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQnfields: res	&lt;C: int PQnfields(const PGresult * res)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQnotifies: conn	&lt;C: PGnotify *  PQnotifies(PGconn * conn)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQnparams: res	&lt;C: int PQnparams(const PGresult * res)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQntuples: res	&lt;C: int PQntuples(const PGresult * res)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQoidStatus: res	&lt;C: char *  PQoidStatus(const PGresult * res)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQoidValue: res	&lt;C: Oid PQoidValue(const PGresult * res)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQoptions: conn	&lt;C: char *  PQoptions(const PGconn * conn)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQparameterStatus: conn with: paramName	&lt;C: const char *  PQparameterStatus(const PGconn * conn, const char * paramName)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQparamtype: res with: param_num	&lt;C: Oid PQparamtype(const PGresult * res, int param_num)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQpass: conn	&lt;C: char *  PQpass(const PGconn * conn)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQping: conninfo	&lt;C: PGPing PQping(const char * conninfo)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQpingParams: keywords with: values with: expand_dbname	&lt;C: PGPing PQpingParams(const char * const * keywords, const char * const * values, int expand_dbname)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQport: conn	&lt;C: char *  PQport(const PGconn * conn)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQprepare: conn with: stmtName with: query with: nParams with: paramTypes	&lt;C: PGresult *  PQprepare(PGconn * conn, const char * stmtName, const char * query, int nParams, Oid const * paramTypes)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQprepareOut: conn with: stmtName with: query with: nParams with: paramTypes with: paramDirection	&lt;C: PGresult *  PQprepareOut(PGconn * conn, const char * stmtName, const char * query, int nParams, Oid const * paramTypes, const int * paramDirection)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQprint: fout with: res with: ps	&lt;C: void PQprint(FILE * fout, const PGresult * res, const PQprintOpt * ps)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQprintTuples: res with: fout with: printAttName with: terseOutput with: width	&lt;C: void PQprintTuples(const PGresult * res, FILE * fout, int printAttName, int terseOutput, int width)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQprotocolVersion: conn	&lt;C: int PQprotocolVersion(const PGconn * conn)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQputCopyData: conn with: buffer with: nbytes	&lt;C: int PQputCopyData(PGconn * conn, const char * buffer, int nbytes)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQputCopyEnd: conn with: errormsg	&lt;C: int PQputCopyEnd(PGconn * conn, const char * errormsg)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQputline: conn with: string	&lt;C: int PQputline(PGconn * conn, const char * string)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQputnbytes: conn with: buffer with: nbytes	&lt;C: int PQputnbytes(PGconn * conn, const char * buffer, int nbytes)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQregisterThreadLock: newhandler	&lt;C: pgthreadlock_t  PQregisterThreadLock(pgthreadlock_t newhandler)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQrequestCancel: conn	&lt;C: int PQrequestCancel(PGconn * conn)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQresStatus: status	&lt;C: char *  PQresStatus(ExecStatusType status)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQreset: conn	&lt;C: void PQreset(PGconn * conn)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQresetPoll: conn	&lt;C: PostgresPollingStatusType PQresetPoll(PGconn * conn)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQresetStart: conn	&lt;C: int PQresetStart(PGconn * conn)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQresultAlloc: res with: nBytes	&lt;C: void *  PQresultAlloc(PGresult * res, size_t nBytes)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQresultErrorField: res with: fieldcode	&lt;C: char *  PQresultErrorField(const PGresult * res, int fieldcode)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQresultErrorMessage: res	&lt;C: char *  PQresultErrorMessage(const PGresult * res)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQresultStatus: res	&lt;C: ExecStatusType PQresultStatus(const PGresult * res)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQsendBulk: conn with: nRows with: paramValues with: paramLengths	&lt;C: int PQsendBulk(PGconn * conn, unsigned int nRows, const char * const * paramValues, int * paramLengths)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQsendBulkFinish: conn	&lt;C: int PQsendBulkFinish(PGconn * conn)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQsendBulkStart: conn with: stmtName with: nCols with: paramFormats	&lt;C: int PQsendBulkStart(PGconn * conn, const char * stmtName, unsigned int nCols, const int * paramFormats)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQsendDescribePortal: conn with: portal	&lt;C: int PQsendDescribePortal(PGconn * conn, const char * portal)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQsendDescribePrepared: conn with: stmt	&lt;C: int PQsendDescribePrepared(PGconn * conn, const char * stmt)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQsendPrepare: conn with: stmtName with: query with: nParams with: paramTypes	&lt;C: int PQsendPrepare(PGconn * conn, const char * stmtName, const char * query, int nParams, Oid const * paramTypes)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQsendPrepareOut: conn with: stmtName with: query with: nParams with: paramTypes with: paramDirection	&lt;C: int PQsendPrepareOut(PGconn * conn, const char * stmtName, const char * query, int nParams, Oid const * paramTypes, const int * paramDirection)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQsendQuery: conn with: query	&lt;C: int PQsendQuery(PGconn * conn, const char * query)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQsendQueryParams: conn with: command with: nParams with: paramTypes with: paramValues with: paramLengths with: paramFormats with: resultFormat	&lt;C: int PQsendQueryParams(PGconn * conn, const char * command, int nParams, Oid const * paramTypes, const char * const * paramValues, const int * paramLengths, const int * paramFormats, int resultFormat)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQsendQueryPrepared: conn with: stmtName with: nParams with: paramValues with: paramLengths with: paramFormats with: resultFormat	&lt;C: int PQsendQueryPrepared(PGconn * conn, const char * stmtName, int nParams, const char * const * paramValues, const int * paramLengths, const int * paramFormats, int resultFormat)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQsendQueryPreparedOut: conn with: stmtName with: nParams with: paramValues with: paramLengths with: paramFormats with: resultFormat	&lt;C: int PQsendQueryPreparedOut(PGconn * conn, const char * stmtName, int nParams, const char * const * paramValues, const int * paramLengths, const int * paramFormats, int resultFormat)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQserverVersion: conn	&lt;C: int PQserverVersion(const PGconn * conn)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQsetClientEncoding: conn with: encoding	&lt;C: int PQsetClientEncoding(PGconn * conn, const char * encoding)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQsetErrorVerbosity: conn with: verbosity	&lt;C: PGVerbosity PQsetErrorVerbosity(PGconn * conn, PGVerbosity verbosity)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQsetNoticeProcessor: conn with: proc with: arg	&lt;C: PQnoticeProcessor  PQsetNoticeProcessor(PGconn * conn, PQnoticeProcessor proc, void * arg)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQsetNoticeReceiver: conn with: proc with: arg	&lt;C: PQnoticeReceiver  PQsetNoticeReceiver(PGconn * conn, PQnoticeReceiver proc, void * arg)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQsetResultAttrs: res with: numAttributes with: attDescs	&lt;C: int PQsetResultAttrs(PGresult * res, int numAttributes, PGresAttDesc * attDescs)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQsetSingleRowMode: conn	&lt;C: int PQsetSingleRowMode(PGconn * conn)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQsetdbLogin: pghost with: pgport with: pgoptions with: pgtty with: dbName with: login with: pwd	&lt;C: PGconn *  PQsetdbLogin(const char * pghost, const char * pgport, const char * pgoptions, const char * pgtty, const char * dbName, const char * login, const char * pwd)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQsetnonblocking: conn with: arg	&lt;C: int PQsetnonblocking(PGconn * conn, int arg)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQsetvalue: res with: tup_num with: field_num with: value with: len	&lt;C: int PQsetvalue(PGresult * res, int tup_num, int field_num, char * value, int len)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQsocket: conn	&lt;C: int PQsocket(const PGconn * conn)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQstatus: conn	&lt;C: ConnStatusType PQstatus(const PGconn * conn)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQtrace: conn with: debug_port	&lt;C: void PQtrace(PGconn * conn, FILE * debug_port)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQtransactionStatus: conn	&lt;C: PGTransactionStatusType PQtransactionStatus(const PGconn * conn)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQtty: conn	&lt;C: char *  PQtty(const PGconn * conn)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQunescapeBytea: strtext with: retbuflen	&lt;C: unsigned char *  PQunescapeBytea(const unsigned char * strtext, size_t * retbuflen)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQuntrace: conn	&lt;C: void PQuntrace(PGconn * conn)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">PQuser: conn	&lt;C: char *  PQuser(const PGconn * conn)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">lo_close: conn with: fd	&lt;C: int lo_close(PGconn * conn, int fd)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">lo_creat: conn with: mode	&lt;C: Oid lo_creat(PGconn * conn, int mode)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">lo_create: conn with: lobjId	&lt;C: Oid lo_create(PGconn * conn, Oid lobjId)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">lo_export: conn with: lobjId with: filename	&lt;C: int lo_export(PGconn * conn, Oid lobjId, const char * filename)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">lo_import: conn with: filename	&lt;C: Oid lo_import(PGconn * conn, const char * filename)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">lo_import_with_oid: conn with: filename with: lobjId	&lt;C: Oid lo_import_with_oid(PGconn * conn, const char * filename, Oid lobjId)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">lo_lseek: conn with: fd with: offset with: whence	&lt;C: int lo_lseek(PGconn * conn, int fd, int offset, int whence)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">lo_open: conn with: lobjId with: mode	&lt;C: int lo_open(PGconn * conn, Oid lobjId, int mode)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">lo_read: conn with: fd with: buf with: len	&lt;C: int lo_read(PGconn * conn, int fd, char * buf, size_t len)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">lo_tell: conn with: fd	&lt;C: int lo_tell(PGconn * conn, int fd)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">lo_truncate: conn with: fd with: len	&lt;C: int lo_truncate(PGconn * conn, int fd, size_t len)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">lo_unlink: conn with: lobjId	&lt;C: int lo_unlink(PGconn * conn, Oid lobjId)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">lo_write: conn with: fd with: buf with: len	&lt;C: int lo_write(PGconn * conn, int fd, const char * buf, size_t len)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">pg_char_to_encoding: name	&lt;C: int pg_char_to_encoding(const char * name)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">pg_encoding_to_char: encoding	&lt;C: const char *  pg_encoding_to_char(int encoding)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="PostgreSQL3EXDI">pg_valid_server_encoding_id: encoding	&lt;C: int pg_valid_server_encoding_id(int encoding)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><initialize><class-id>Database.PostgresBuffer</class-id></initialize><initialize><class-id>Database.PostgresLibpqSession</class-id></initialize><initialize><class-id>Database.PostgresConnection</class-id></initialize><initialize><class-id>Database.PostgresLibpqConnection</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>SmallInteger</name><environment>Core</environment><super>Core.Integer</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars>minVal maxVal maxBits maxBytes </class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>SmallDouble</name><environment>Core</environment><super>Core.LimitedPrecisionReal</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Array</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>Float</name><environment>Core</environment><super>Core.LimitedPrecisionReal</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Timestamp</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>year month day hours minutes seconds milliseconds partialNanosecond </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>LargePositiveInteger</name><environment>Core</environment><super>Core.LargeInteger</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>ExternalDatabaseException</name><environment>Database</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><class><name>ExternalDatabaseResumableException</name><environment>Database</environment><super>Database.ExternalDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><class><name>CharacterArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>ExternalDatabaseConnection</name><environment>Database</environment><super>Database.ExternalDatabaseFramework</super><private>false</private><indexed-type>none</indexed-type><inst-vars>transaction username password environment transactionCoordinator cachedSession isolationLevel encoding </inst-vars><class-inst-vars>environmentMap xif xifMap dependents </class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><class><name>ExternalInterface</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>includeFiles includeDirectories libraryFiles libraryDirectories virtual optimizationLevel </class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>External-Interface</category><attributes><package>External-Interface</package></attributes></class><class><name>ExternalDatabaseTransaction</name><environment>Database</environment><super>Database.ExternalDatabaseFramework</super><private>false</private><indexed-type>none</indexed-type><inst-vars>memberCountHolder remainingCountHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><class><name>Double</name><environment>Core</environment><super>Core.LimitedPrecisionReal</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Fraction</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars>numerator denominator </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>ExternalDatabaseError</name><environment>Database</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dbmsErrorCode dbmsErrorString osErrorCode osErrorString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><class><name>ExternalDatabaseColumnDescription</name><environment>Database</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name index type length precision scale nullable </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><class><name>Time</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hours minutes seconds milliseconds partialNanosecond </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>ExternalDatabaseSession</name><environment>Database</environment><super>Database.ExternalDatabaseFramework</super><private>false</private><indexed-type>none</indexed-type><inst-vars>connection query queryFragments bindInput bindTemplate bindOutput useNamedOutputBinding bindValues resultTemplate allocateForEachRow blockFactor numColumns columnDescriptions rowAdaptors rowBuffersHolder bufferIndex answerStream currentRow scrollable needBinding </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><class><name>ByteArray</name><environment>Core</environment><super>Core.IntegerArray</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>OrderedCollection</name><environment>Core</environment><super>Core.SequenceableCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>firstIndex lastIndex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Sequenceable</category><attributes><package>Collections-Sequenceable</package></attributes></class><class><name>Boolean</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>FixedPoint</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars>numerator denominator scale </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>LargeNegativeInteger</name><environment>Core</environment><super>Core.LargeInteger</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>IOBuffer</name><environment>OS</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>input output buffer bufferAmount </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Streaming</category><attributes><package>OS-Streaming</package></attributes></class><class><name>ExternalConnection</name><environment>OS</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>inputDescriptor outputDescriptor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Streaming</category><attributes><package>OS-Streaming</package></attributes></class><class><name>Date</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>day year </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>ExternalDatabaseBuffer</name><environment>Database</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>databaseType encoding elementSize count bufferPointer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class></st-source>