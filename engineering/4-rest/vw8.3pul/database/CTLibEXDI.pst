<?xml version="1.0"?><st-source><!-- Name: CTLibEXDINotice: Copyright 1999-2016 Cincom Systems, Inc.  All rights reserved.Comment: This parcel provides the External database interface (EXDI) code to interact with Sybase Open Client relational databases. After loading this parcel, you will be able to store and retrieve data and run server-based stored procedures using your own Smalltalk programs. Also, the Ad Hoc SQL tool will be available from the Database menu of the VisualLauncher. That interactive tool allows you to run simple text-based queries to verify your database connection and explore your data. Further information on the EXDI can be found in the "VisualWorks Database Connect Developer's Guide" (the file dbadg.pdf located in the doc subdirectory of the VisualWorks installation). The following are required for VisualWorks to successfully connect to a Sybase server. This parcel (CTLibEXDI) must be loaded. 	Properly installed Sybase Open Client software on your computer. For unix installations, the client software must be accessable, typically via a script which has been run in the same environment, prior to starting VisualWorks. 	A hardware network connection to a working Sybase server. 	A valid user name and password to access the Sybase server. 	Before running VisualWorks, a good, quick test to ensure connectivity is to run Sybase's "isql" utility and connect to your server. DbIdentifier: bear73DbTrace: 492519DbUsername: dwallenDbVersion: 8.2 - 3DevelopmentPrerequisites: #(#(#parcel 'Database' '') #(#parcel 'DLLCC' ''))DialectVersion: VisualWorks 7.9HideSource: falsePackageName: CTLibEXDIParcel: #('CTLibEXDI')ParcelName: CTLibEXDIPrerequisiteParcels: #(#('Database' ''))PrintStringCache: (8.2 - 3,dwallen)SaveSource: trueVersion: 8.2 - 3Pre-Load Block: 	[ :pkg |  ]Post-Load Block: 	[:pkg| Database.CTLibInterface postLoadFrom: pkg ]Date: 11:37:12 AM July 1, 2016 --><time-stamp>From VisualWorksÂ®, 8.2 of July 1, 2016 on July 1, 2016 at 11:37:12 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>CTLibColumnDescription</name><environment>Database</environment><super>Database.ExternalDatabaseColumnDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fSqlType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-CTLib</category><attributes><package>CTLibEXDI</package></attributes></class><comment><class-id>Database.CTLibColumnDescription</class-id><body>CTLibColumnDescription extends ExternalDatabaseColumnDescription with information that is unique to CTLib.Instance Variables:	fSqlType	&lt;SmallInteger&gt;		Type code answered from SQLDescribeCol or SQLColAttributes.</body></comment><class><name>CTLibInterface</name><environment>Database</environment><super>External.ExternalInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars>encoding </inst-vars><class-inst-vars>getSelectorMap fSqlTypeToConversionMap fetchBufferSize putSelectorMap fSqlTypeFromConversionMap fSqlTypeToServerTypeConversionMap </class-inst-vars><imports>			private Database.CTLibInterfaceDictionary.*			</imports><category>Database-External-Libraries</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>true</beVirtual><optimizationLevel>full</optimizationLevel><package>CTLibEXDI</package></attributes></class><comment><class-id>Database.CTLibInterface</class-id><body>This class is private to the implementation of External Database Interface services for the CT-Library.CTLibInterface defines calling conventions for the Open Client CT-Library version 10.0.x and later.This is the default adopted by the library. </body></comment><class><name>CTLibAixInterface</name><environment>Database</environment><super>Database.CTLibInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Database.CTLibAixInterfaceDictionary.*			</imports><category>Database-External-Libraries</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>libsybcomn.so.a</item> <item>libsybintl.so.a</item> <item>libsybtcl.so.a</item> <item>libsybct.so.a</item> <item>libsybcs.so.a</item></libraryFiles><libraryDirectories><item>$(SYBASE)/lib</item></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>CTLibEXDI</package></attributes></class><comment><class-id>Database.CTLibAixInterface</class-id><body>This class is private to the implementation of External Database Interface services for the CT-Library. CTLibAixInterface defines calling conventions for the AIX Open Client CT-Library version 10.0.x and later.</body></comment><class><name>CTLibWin16Interface</name><environment>Database</environment><super>Database.CTLibInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Database.CTLibWin16InterfaceDictionary.*			</imports><category>Database-External-Libraries</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>wcssyblib.dll</item> <item>wctsyblib.dll</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>CTLibEXDI</package></attributes></class><comment><class-id>Database.CTLibWin16Interface</class-id><body>This class is private to the implementation of External Database Interface services for the CT-Library.CTLibWin16Interface defines calling conventions for the Windows 3.1 platform, Open Client CT-Library version 10.0.x and later.</body></comment><class><name>CTLibSession</name><environment>Database</environment><super>Database.ExternalDatabaseSession</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cmdHolder returnStatus textLimit reasonPointer currentRowIndex totalRows rowsInBlock pRowsFetched res_type rowCount useCursor cursorName cursorFlag idleStatus </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-CTLib</category><attributes><package>CTLibEXDI</package></attributes></class><comment><class-id>Database.CTLibSession</class-id><body>CTLibSession is the concrete implementation of session services using the CT-Library.Instance Variables:	cmdHolder		&lt;ValueHolder on: (CPointer | nil)&gt;		Holds nil or pointer to the CS_COMMAND structure.	returnStatus	&lt;SmallInteger | nil&gt;		The return status value from executing the stored procedure.  This is valid only after		processing all of the results from the stored procedure and before starting any new		procesing.	textLimit		&lt;SmallInteger | nil&gt;		An application specific value to set a limit on the number of bytes to fetch from a TEXT or IMAGE column.	currentRowIndex		&lt;SmallInteger | nil&gt;		Index of the current row.	totalRows		&lt;SmallInteger | nil&gt;		Total number of fetched rows.	rowsInBlock		&lt;SmallInteger | nil&gt;		Number of rows fetched in current block.	pRowsFetched		&lt;CPointer | nil&gt;		Pointer to a C integer with the number of fetched rows.	res_type 		&lt;SmallInteger | nil&gt;		Type of results from ct_results.	useCursor &lt;Boolean&gt;		Determines whether to use cursors.	cursorName &lt;String&gt;		Cursor name if a cursor is used.		idleStatus &lt;Boolean&gt;		Determines whether the command structure is idle or not.	cursorFlag &lt;String&gt;		Remembers the return code of certain calls.Class variables:	RegisteredCTLibSessions	&lt;HandleRegistry&gt;		A private registry of all connected or paused CTLib sessions.		This registry, unlike the registries on CTLibTransaction and CTLibConnection,		does not exist to release a control block or to disconnect from the server.  A CTLib		session which is executing a query holds the responsibility to finish executing the		query and processing the results so that another query may be executed.  The		executor will cause a cancel to occur if the session, when finalized, has an incompleted		execution in process.</body></comment><class><name>CTLibLinuxInterface</name><environment>Database</environment><super>Database.CTLibInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Database.CTLibLinuxInterfaceDictionary.*			</imports><category>Database-External-Libraries</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>libsybcomn.so</item> <item>libsybintl.so</item> <item>libsybtcl.so</item> <item>libsybct.so</item> <item>libsybcs.so</item></libraryFiles><libraryDirectories><item>$(SYBASE)/lib</item></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>CTLibEXDI</package></attributes></class><comment><class-id>Database.CTLibLinuxInterface</class-id><body>This class is private to the implementation of External Database Interface services for the CT-Library.CTLibLinuxInterface defines calling conventions for the Linux (Intel) Open Client CT-Library version 10.0.x and later.</body></comment><class><name>CTLibDatabaseException</name><environment>Database</environment><super>Database.ExternalDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-CTLib</category><attributes><package>CTLibEXDI</package></attributes></class><comment><class-id>Database.CTLibDatabaseException</class-id><body>CTLibDatabaseException is raised in case of Sybase database errors.</body></comment><class><name>UnableToOpenInterfacesFile</name><environment>Database</environment><super>Database.CTLibDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-CTLib</category><attributes><package>CTLibEXDI</package></attributes></class><comment><class-id>Database.UnableToOpenInterfacesFile</class-id><body>UnableToOpenInterfacesFile is used to indicate that the connection cannot open the interfaces file.</body></comment><class><name>CTLibSolarisInterface</name><environment>Database</environment><super>Database.CTLibInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Database.CTLibSolarisInterfaceDictionary.*			</imports><category>Database-External-Libraries</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>libsybcomn.so</item> <item>libsybintl.so</item> <item>libsybtcl.so</item> <item>libsybct.so</item> <item>libsybcs.so</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>CTLibEXDI</package></attributes></class><comment><class-id>Database.CTLibSolarisInterface</class-id><body>This class is private to the implementation of External Database Interface services for the CT-Library.CTLibSolarisInterface defines calling conventions for the Open Client CT-Library version 10.0.x and later on the Solaris platform.</body></comment><class><name>CTLibConnection</name><environment>Database</environment><super>Database.ExternalDatabaseConnection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>contextHolder connHolder appName hostName interfaceFileName loginTimeoutSeconds clientMsgHandlerCB serverMsgHandlerCB csVersion packetSize </inst-vars><class-inst-vars>signalMap </class-inst-vars><imports></imports><category>Database-CTLib</category><attributes><package>CTLibEXDI</package></attributes></class><comment><class-id>Database.CTLibConnection</class-id><body>CTLibConnection is the concrete implementation of connection services using the CT-Library.Instance Variables	contextHolder		&lt;ValueHolder | nil&gt;		Holds nil or a CPointer to the context structure used by this connection.	connHolder		&lt;ValueHolder | nil&gt;		Holds nil or a CPointer to the CS_CONNECTION structure used by this connection.	appName		&lt;String | nil&gt;		Holds application defined application name.	hostName		&lt;String | nil&gt;		Holds application define host name.	interfaceFileName	&lt;String | nil&gt;		Holds the full name of the interfaces file.	loginTimeoutSeconds	&lt;value | nil&gt;		Holds the login timeout value in secons to be used when calling ct_connect().	clientMsgHandlerCB	&lt;CCallback | nil&gt;		The callback function for receiving messages from the client.	serverMsgHandlerCB	&lt;CCallback | nil&gt;		The callback function for receiving messages from the server.	csVersion		&lt;Integer&gt;		Indicates desired Sybase version's behavior. Default is 10.0. Cursors require 15.x.	packetSize		&lt;Integer&gt;		Indicates desired Tabular Data Stream packet size.Class Instance Variables	signalMap &lt;IdentityDictionary&gt;		Maps a subset of CTLib error codes to specific signalsClass Variables	ErrorQueues	&lt;Dictionary&gt;		A repository for the errors and messages as they arrive and until the driver wants to include		them in a raised exception.	RegisteredCTLibConnections 	&lt;HandleRegistry&gt;		A registry of all active CTLib connections.</body></comment><class><name>CTLibPowerMacInterface</name><environment>Database</environment><super>Database.CTLibInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Database.CTLibPowerMacInterfaceDictionary.*			</imports><category>Database-External-Libraries</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>libsybcs</item> <item>libsybct</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>CTLibEXDI</package></attributes></class><comment><class-id>Database.CTLibPowerMacInterface</class-id><body>This class is private to the implementation of External Database Interface services for the CT-Library.CTLibPowerMacInterface defines calling conventions for the PowerMac Open Client CT-Library version 10.0.x and later.</body></comment><class><name>CTLibBuffer</name><environment>Database</environment><super>Database.ExternalDatabaseBuffer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>indicatorsPointer lengthsPointer dataFmtPointer getSelector putSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-CTLib</category><attributes><package>CTLibEXDI</package></attributes></class><comment><class-id>Database.CTLibBuffer</class-id><body>CTLibBuffer is a private subclass, and extends ExternalDatabaseBuffer to deal with CTLib.  Intimate details are shared with CTLibSession.This implementation assumes in many places that the (inherited) count variable is always 0.Instance variables:	indicatorsPointer &lt;CPointer&gt;		Pointer to vector of indicators.	lengthsPointer &lt;CPointer&gt;		Pointer to vector of item lengths.	dataFmtPointer &lt;CPointer&gt;		Pointer to CS_DATAFMT structure.	getSelector &lt;nil | Symbol&gt;		Selector to perform to get values out of the buffer.	putSelector &lt;nil | Symbol&gt;		Selector to perform to put values into the buffer.Class variables:	GetSelectorMap &lt;IdentityDictionary&gt;		Maps from class name to a data conversion selector.</body></comment><class><name>CTLibNTInterface</name><environment>Database</environment><super>Database.CTLibInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Database.CTLibNTInterfaceDictionary.*			</imports><category>Database-External-Libraries</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>libsybcs.dll</item> <item>libsybct.dll</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>CTLibEXDI</package></attributes></class><comment><class-id>Database.CTLibNTInterface</class-id><body>This class is private to the implementation of External Database Interface services for the CT-Library.CTLibNTInterface defines calling conventions for the Windows NT (Intel) Open Client CT-Library version 10.0.x and later</body></comment><class><name>CTLibTransaction</name><environment>Database</environment><super>Database.ExternalDatabaseTransaction</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-CTLib</category><attributes><package>CTLibEXDI</package></attributes></class><comment><class-id>Database.CTLibTransaction</class-id><body>Class CTLibTransaction is the concrete implementation of the transaction concept using the CTLib CLI.  The implementation is trivial since CTLib doesn't support distributed or coordinated transaction.</body></comment><class><name>CTLibError</name><environment>Database</environment><super>Database.ExternalDatabaseError</super><private>false</private><indexed-type>none</indexed-type><inst-vars>severity msgstate srvname procname line </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-CTLib</category><attributes><package>CTLibEXDI</package></attributes></class><comment><class-id>Database.CTLibError</class-id><body>Class CTLibError holds error or message information received from Client or Server. For more information about the content of any of the variables, refer to the CTLib documentation.If the msgstate variable isNil, the CTLibError is reporting an error from the Client. If notNil, the CTLibError is reporting a message from the Server.  The srvname, procname, &amp; line variables are only defined for the Server messages.  The osErrorCode and osErrorString are only be defined for Client messages.Inherited Instance Variables:	dbmsErrorCode	&lt;SmallInteger&gt;		The error or message number.  Access via the dbmsErrorCode or msgno messages.	dbmsErrorString	&lt;String&gt;		A printable description of the error or message.  Access via the dbmsErrorString		or msgtext messages.	osErrorCode		&lt;SmallInteger | nil&gt;		The operating-system-specific error number that describes the cause of the error.  if		there is no relevant operating-system error this variable will be nil.	osErrorString	&lt;String | nil&gt;		A printable description of osErrorCode or nil.Instance Variables:	severity		&lt;SmallInteger&gt;		The severity of the error or message.	msgstate	&lt;SmallInteger | nil&gt;		The current server error state.	srvname		&lt;String | nil&gt;		The name of the server that generated the message, if known.	procname	&lt;String | nil&gt;		The name of the stored procedure that generated the message, if relevant.	line			&lt;SmallInteger | nil&gt;		The number of the command batch or stored procedure line that generated the message.</body></comment><shared-variable><name>RegisteredCTLibSessions</name><environment>Database.CTLibSession</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>CTLibEXDI</package></attributes></shared-variable><shared-variable><name>ServerEncoding</name><environment>Database.CTLibConnection</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>CTLibEXDI</package></attributes></shared-variable><shared-variable><name>ErrorQueues</name><environment>Database.CTLibConnection</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>CTLibEXDI</package></attributes></shared-variable><shared-variable><name>RegisteredCTLibConnections</name><environment>Database.CTLibConnection</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>CTLibEXDI</package></attributes></shared-variable><shared-variable><name>SQLTypeFromConversionMap</name><environment>Database.CTLibBuffer</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>CTLibEXDI</package></attributes></shared-variable><shared-variable><name>FetchBufferSize</name><environment>Database.CTLibBuffer</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>CTLibEXDI</package></attributes></shared-variable><shared-variable><name>PutSelectorMap</name><environment>Database.CTLibBuffer</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>CTLibEXDI</package></attributes></shared-variable><shared-variable><name>GetSelectorMap</name><environment>Database.CTLibBuffer</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>CTLibEXDI</package></attributes></shared-variable><shared-variable><name>CTLibNTInterfaceDictionary</name><environment>Database</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>CTLibEXDI</package></attributes></shared-variable><shared-variable><name>CTLibPowerMacInterfaceDictionary</name><environment>Database</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>CTLibEXDI</package></attributes></shared-variable><shared-variable><name>CTLibWin16InterfaceDictionary</name><environment>Database</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>CTLibEXDI</package></attributes></shared-variable><shared-variable><name>CTLibLinuxInterfaceDictionary</name><environment>Database</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>CTLibEXDI</package></attributes></shared-variable><shared-variable><name>CTLibAixInterfaceDictionary</name><environment>Database</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>CTLibEXDI</package></attributes></shared-variable><shared-variable><name>CTLibInterfaceDictionary</name><environment>Database</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>CTLibEXDI</package></attributes></shared-variable><shared-variable><name>CTLibSolarisInterfaceDictionary</name><environment>Database</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>CTLibEXDI</package></attributes></shared-variable><methods><class-id>Database.CTLibColumnDescription</class-id> <category>private-accessing</category><body package="CTLibEXDI">fSqlType:	aSmallInteger	"Set the receiver's CTLib SQL type."	fSqlType := aSmallInteger</body></methods><methods><class-id>Database.CTLibColumnDescription</class-id> <category>accessing</category><body package="CTLibEXDI">fSqlType	"Return the receiver's CTLib SQL type"	^fSqlType</body></methods><methods><class-id>Database.CTLibInterface</class-id> <category>defines</category><body package="CTLibEXDI">CS_ABSOLUTE	&lt;C: #define CS_ABSOLUTE (CS_INT)3004	&gt;</body><body package="CTLibEXDI">CS_ALLOC	&lt;C: #define CS_ALLOC (CS_INT)710	&gt;</body><body package="CTLibEXDI">CS_APPNAME	&lt;C: #define CS_APPNAME (CS_INT)9102	&gt;</body><body package="CTLibEXDI">CS_BIGINT_TYPE	&lt;C: #define CS_BIGINT_TYPE		(CS_INT)30	&gt;</body><body package="CTLibEXDI">CS_BINARY_TYPE	&lt;C: #define CS_BINARY_TYPE (CS_INT)1	&gt;</body><body package="CTLibEXDI">CS_BIT_TYPE	&lt;C: #define CS_BIT_TYPE (CS_INT)11	&gt;</body><body package="CTLibEXDI">CS_CANBENULL	&lt;C: #define CS_CANBENULL (CS_INT)32	&gt;</body><body package="CTLibEXDI">CS_CANCELED	&lt;C: #define CS_CANCELED (CS_RETCODE)(CS_EXTERNAL_ERR-2)	&gt;</body><body package="CTLibEXDI">CS_CANCEL_ALL	&lt;C: #define CS_CANCEL_ALL (CS_INT)6001	&gt;</body><body package="CTLibEXDI">CS_CANCEL_ATTN	&lt;C: #define CS_CANCEL_ATTN (CS_INT)6002	&gt;</body><body package="CTLibEXDI">CS_CANCEL_CURRENT	&lt;C: #define CS_CANCEL_CURRENT (CS_INT)6000	&gt;</body><body package="CTLibEXDI">CS_CHAR_TYPE	&lt;C: #define CS_CHAR_TYPE (CS_INT)0	&gt;</body><body package="CTLibEXDI">CS_CLIENTMSG_CB	&lt;C: #define CS_CLIENTMSG_CB (CS_INT)3	&gt;</body><body package="CTLibEXDI">CS_CMD_DONE	&lt;C: #define CS_CMD_DONE (CS_INT)4046	&gt;</body><body package="CTLibEXDI">CS_CMD_FAIL	&lt;C: #define CS_CMD_FAIL (CS_INT)4048	&gt;</body><body package="CTLibEXDI">CS_CMD_SUCCEED	&lt;C: #define CS_CMD_SUCCEED (CS_INT)4047	&gt;</body><body package="CTLibEXDI">CS_COMPUTEFMT_RESULT	&lt;C: #define CS_COMPUTEFMT_RESULT (CS_INT)4050	&gt;</body><body package="CTLibEXDI">CS_COMPUTE_RESULT	&lt;C: #define CS_COMPUTE_RESULT (CS_INT)4045	&gt;</body><body package="CTLibEXDI">CS_CURSOR_AFTER_LAST	&lt;C: #define CS_CURSOR_AFTER_LAST (CS_INT)(CS_RETCODE)(CS_EXTERNAL_ERR - 19)	&gt;</body><body package="CTLibEXDI">CS_CURSOR_BEFORE_FIRST	&lt;C: #define CS_CURSOR_BEFORE_FIRST (CS_INT)(CS_RETCODE)(CS_EXTERNAL_ERR - 18)	&gt;</body><body package="CTLibEXDI">CS_CURSOR_CLOSE	&lt;C: #define CS_CURSOR_CLOSE (CS_INT)706	&gt;</body><body package="CTLibEXDI">CS_CURSOR_DEALLOC	&lt;C: #define CS_CURSOR_DEALLOC (CS_INT)707	&gt;</body><body package="CTLibEXDI">CS_CURSOR_DECLARE	&lt;C: #define CS_CURSOR_DECLARE (CS_INT)700	&gt;</body><body package="CTLibEXDI">CS_CURSOR_DELETE	&lt;C: #define CS_CURSOR_DELETE (CS_INT)705	&gt;</body><body package="CTLibEXDI">CS_CURSOR_OPEN	&lt;C: #define CS_CURSOR_OPEN (CS_INT)701	&gt;</body><body package="CTLibEXDI">CS_CURSOR_OPTION	&lt;C: #define CS_CURSOR_OPTION (CS_INT)725	&gt;</body><body package="CTLibEXDI">CS_CURSOR_RESULT	&lt;C: #define CS_CURSOR_RESULT (CS_INT)4041	&gt;</body><body package="CTLibEXDI">CS_CURSOR_ROWS	&lt;C: #define CS_CURSOR_ROWS (CS_INT)703	&gt;</body><body package="CTLibEXDI">CS_CURSOR_UPDATE	&lt;C: #define CS_CURSOR_UPDATE (CS_INT)704	&gt;</body><body package="CTLibEXDI">CS_CURSTAT_CLOSED	&lt;C: #define CS_CURSTAT_CLOSED (CS_INT)0x0004	&gt;</body><body package="CTLibEXDI">CS_CURSTAT_DECLARED	&lt;C: #define CS_CURSTAT_DECLARED (CS_INT)0x0001	&gt;</body><body package="CTLibEXDI">CS_CURSTAT_IMPLICIT	&lt;C: #define CS_CURSTAT_IMPLICIT (CS_INT)0x0100	&gt;</body><body package="CTLibEXDI">CS_CURSTAT_INSENSITIVE	&lt;C: #define CS_CURSTAT_INSENSITIVE (CS_INT)0x0400	&gt;</body><body package="CTLibEXDI">CS_CURSTAT_KEYSETDRIVEN	&lt;C: #define CS_CURSTAT_KEYSETDRIVEN (CS_INT)0x1000	&gt;</body><body package="CTLibEXDI">CS_CURSTAT_NONE	&lt;C: #define CS_CURSTAT_NONE (CS_INT)0x0000	&gt;</body><body package="CTLibEXDI">CS_CURSTAT_OPEN	&lt;C: #define CS_CURSTAT_OPEN (CS_INT)0x0002	&gt;</body><body package="CTLibEXDI">CS_CURSTAT_RDONLY	&lt;C: #define CS_CURSTAT_RDONLY (CS_INT)0x0008	&gt;</body><body package="CTLibEXDI">CS_CURSTAT_SCROLLABLE	&lt;C: #define CS_CURSTAT_SCROLLABLE (CS_INT)0x0080	&gt;</body><body package="CTLibEXDI">CS_CURSTAT_SEMISENSITIVE	&lt;C: #define CS_CURSTAT_SEMISENSITIVE (CS_INT)0x0800	&gt;</body><body package="CTLibEXDI">CS_CURSTAT_SENSITIVE	&lt;C: #define CS_CURSTAT_SENSITIVE (CS_INT)0x0200	&gt;</body><body package="CTLibEXDI">CS_CURSTAT_UPDATABLE	&lt;C: #define CS_CURSTAT_UPDATABLE (CS_INT)0x0010	&gt;</body><body package="CTLibEXDI">CS_CUR_NAME	&lt;C: #define CS_CUR_NAME (CS_INT)9128	&gt;</body><body package="CTLibEXDI">CS_CUR_STATUS	&lt;C: #define CS_CUR_STATUS (CS_INT)9126	&gt;</body><body package="CTLibEXDI">CS_DATETIME4_TYPE	&lt;C: #define CS_DATETIME4_TYPE (CS_INT)13	&gt;</body><body package="CTLibEXDI">CS_DATETIME_TYPE	&lt;C: #define CS_DATETIME_TYPE (CS_INT)12	&gt;</body><body package="CTLibEXDI">CS_DATE_TYPE	&lt;C: #define CS_DATE_TYPE (CS_INT)27	&gt;</body><body package="CTLibEXDI">CS_DEALLOC	&lt;C: #define CS_DEALLOC (CS_INT)711	&gt;</body><body package="CTLibEXDI">CS_DECIMAL_TYPE	&lt;C: #define CS_DECIMAL_TYPE (CS_INT)17	&gt;</body><body package="CTLibEXDI">CS_DESCRIBE_RESULT	&lt;C: #define CS_DESCRIBE_RESULT (CS_INT)4051	&gt;</body><body package="CTLibEXDI">CS_DYNAMIC	&lt;C: #define CS_DYNAMIC (CS_INT)0x0004	&gt;</body><body package="CTLibEXDI">CS_END_RESULTS	&lt;C: #define CS_END_RESULTS (CS_RETCODE)(CS_EXTERNAL_ERR-5)	&gt;</body><body package="CTLibEXDI">CS_EXTERNAL_ERR	&lt;C: #define CS_EXTERNAL_ERR (CS_RETCODE)(-200)	&gt;</body><body package="CTLibEXDI">CS_FAIL	&lt;C: #define CS_FAIL (CS_RETCODE)0	&gt;</body><body package="CTLibEXDI">CS_FALSE	&lt;C: #define CS_FALSE (CS_INT)0	&gt;</body><body package="CTLibEXDI">CS_FIRST	&lt;C: #define CS_FIRST (CS_INT)3000	&gt;</body><body package="CTLibEXDI">CS_FLOAT_TYPE	&lt;C: #define CS_FLOAT_TYPE (CS_INT)10	&gt;</body><body package="CTLibEXDI">CS_FMT_UNUSED	&lt;C: #define CS_FMT_UNUSED (CS_INT)0x00	&gt;</body><body package="CTLibEXDI">CS_FORCE_CLOSE	&lt;C: #define CS_FORCE_CLOSE (CS_INT)301	&gt;</body><body package="CTLibEXDI">CS_FORCE_EXIT	&lt;C: #define CS_FORCE_EXIT (CS_INT)300	&gt;</body><body package="CTLibEXDI">CS_FOR_UPDATE	&lt;C: #define CS_FOR_UPDATE (CS_INT)0x0001	&gt;</body><body package="CTLibEXDI">CS_GET	&lt;C: #define CS_GET (CS_INT)33	&gt;</body><body package="CTLibEXDI">CS_HOSTNAME	&lt;C: #define CS_HOSTNAME (CS_INT)9103	&gt;</body><body package="CTLibEXDI">CS_IFILE	&lt;C: #define CS_IFILE (CS_INT)9115	&gt;</body><body package="CTLibEXDI">CS_IMAGE_TYPE	&lt;C: #define CS_IMAGE_TYPE (CS_INT)5	&gt;</body><body package="CTLibEXDI">CS_IMPLICIT_CURSOR	&lt;C: #define CS_IMPLICIT_CURSOR (CS_INT)0x0040	&gt;</body><body package="CTLibEXDI">CS_INT_TYPE	&lt;C: #define CS_INT_TYPE (CS_INT)8	&gt;</body><body package="CTLibEXDI">CS_LANG_CMD	&lt;C: #define CS_LANG_CMD (CS_INT)148	&gt;</body><body package="CTLibEXDI">CS_LAST	&lt;C: #define CS_LAST (CS_INT)3003	&gt;</body><body package="CTLibEXDI">CS_LOGIN_TIMEOUT	&lt;C: #define CS_LOGIN_TIMEOUT (CS_INT)9116	&gt;</body><body package="CTLibEXDI">CS_LONGCHAR_TYPE	&lt;C: #define CS_LONGCHAR_TYPE (CS_INT)2	&gt;</body><body package="CTLibEXDI">CS_MAX_NAME	&lt;C: #define CS_MAX_NAME (CS_INT)255	&gt;</body><body package="CTLibEXDI">CS_MONEY4_TYPE	&lt;C: #define CS_MONEY4_TYPE (CS_INT)15	&gt;</body><body package="CTLibEXDI">CS_MONEY_TYPE	&lt;C: #define CS_MONEY_TYPE (CS_INT)14	&gt;</body><body package="CTLibEXDI">CS_MSG_RESULT	&lt;C: #define CS_MSG_RESULT (CS_INT)4044	&gt;</body><body package="CTLibEXDI">CS_NEXT	&lt;C: #define CS_NEXT (CS_INT)3001	&gt;</body><body package="CTLibEXDI">CS_NOSCROLL_INSENSITIVE	&lt;C: #define CS_NOSCROLL_INSENSITIVE (CS_INT)0x1000	&gt;</body><body package="CTLibEXDI">CS_NULLTERM	&lt;C: #define CS_NULLTERM (CS_INT)(-9)	&gt;</body><body package="CTLibEXDI">CS_NUMDATA	&lt;C: #define CS_NUMDATA (CS_INT)803	&gt;</body><body package="CTLibEXDI">CS_NUMERIC_TYPE	&lt;C: #define CS_NUMERIC_TYPE (CS_INT)16	&gt;</body><body package="CTLibEXDI">CS_OPT_TEXTSIZE	&lt;C: #define CS_OPT_TEXTSIZE (CS_INT)5002	&gt;</body><body package="CTLibEXDI">CS_PACKETSIZE	&lt;C: #define CS_PACKETSIZE (CS_INT)9107	&gt;</body><body package="CTLibEXDI">CS_PARAM_RESULT	&lt;C: #define CS_PARAM_RESULT (CS_INT)4042	&gt;</body><body package="CTLibEXDI">CS_PASSWORD	&lt;C: #define CS_PASSWORD (CS_INT)9101	&gt;</body><body package="CTLibEXDI">CS_PREV	&lt;C: #define CS_PREV (CS_INT)3002	&gt;</body><body package="CTLibEXDI">CS_READ_ONLY	&lt;C: #define CS_READ_ONLY (CS_INT)0x0002	&gt;</body><body package="CTLibEXDI">CS_REAL_TYPE	&lt;C: #define CS_REAL_TYPE (CS_INT)9	&gt;</body><body package="CTLibEXDI">CS_RELATIVE	&lt;C: #define CS_RELATIVE (CS_INT)3005	&gt;</body><body package="CTLibEXDI">CS_ROWFMT_RESULT	&lt;C: #define CS_ROWFMT_RESULT (CS_INT)4049	&gt;</body><body package="CTLibEXDI">CS_ROW_COUNT	&lt;C: #define CS_ROW_COUNT (CS_INT)800	&gt;</body><body package="CTLibEXDI">CS_ROW_FAIL	&lt;C: #define CS_ROW_FAIL (CS_RETCODE)(CS_EXTERNAL_ERR-3)	&gt;</body><body package="CTLibEXDI">CS_ROW_RESULT	&lt;C: #define CS_ROW_RESULT (CS_INT)4040	&gt;</body><body package="CTLibEXDI">CS_SCROLL_CURSOR	&lt;C: #define CS_SCROLL_CURSOR (CS_INT)0x0800	&gt;</body><body package="CTLibEXDI">CS_SCROLL_CURSOR_ENDS	&lt;C: #define CS_SCROLL_CURSOR_ENDS (CS_INT)(CS_RETCODE)(CS_EXTERNAL_ERR - 17)	&gt;</body><body package="CTLibEXDI">CS_SCROLL_INSENSITIVE	&lt;C: #define CS_SCROLL_INSENSITIVE (CS_INT)0x0100	&gt;</body><body package="CTLibEXDI">CS_SCROLL_KEYSETDRIVEN	&lt;C: #define CS_SCROLL_KEYSETDRIVEN (CS_INT)0x0400	&gt;</body><body package="CTLibEXDI">CS_SCROLL_SEMISENSITIVE	&lt;C: #define CS_SCROLL_SEMISENSITIVE (CS_INT)0x0200	&gt;</body><body package="CTLibEXDI">CS_SCROLL_SENSITIVE	&lt;C: #define CS_SCROLL_SENSITIVE (CS_INT)0x0080	&gt;</body><body package="CTLibEXDI">CS_SEC_ENCRYPTION	&lt;C: #define CS_SEC_ENCRYPTION (CS_INT)9135	&gt;</body><body package="CTLibEXDI">CS_SERVERMSG_CB	&lt;C: #define CS_SERVERMSG_CB (CS_INT)2	&gt;</body><body package="CTLibEXDI">CS_SET	&lt;C: #define CS_SET (CS_INT)34	&gt;</body><body package="CTLibEXDI">CS_SMALLINT_TYPE	&lt;C: #define CS_SMALLINT_TYPE (CS_INT)7	&gt;</body><body package="CTLibEXDI">CS_STATUS_RESULT	&lt;C: #define CS_STATUS_RESULT (CS_INT)4043	&gt;</body><body package="CTLibEXDI">CS_SUCCEED	&lt;C: #define CS_SUCCEED (CS_RETCODE)1	&gt;</body><body package="CTLibEXDI">CS_TEXTLIMIT	&lt;C: #define CS_TEXTLIMIT (CS_INT)9112	&gt;</body><body package="CTLibEXDI">CS_TEXT_TYPE	&lt;C: #define CS_TEXT_TYPE (CS_INT)4	&gt;</body><body package="CTLibEXDI">CS_TIME_TYPE	&lt;C: #define CS_TIME_TYPE	(CS_INT)28	&gt;</body><body package="CTLibEXDI">CS_TINYINT_TYPE	&lt;C: #define CS_TINYINT_TYPE (CS_INT)6	&gt;</body><body package="CTLibEXDI">CS_TRUE	&lt;C: #define CS_TRUE (CS_INT)1	&gt;</body><body package="CTLibEXDI">CS_UNUSED	&lt;C: #define CS_UNUSED (CS_INT)(-99999)	&gt;</body><body package="CTLibEXDI">CS_USERNAME	&lt;C: #define CS_USERNAME (CS_INT)9100	&gt;</body><body package="CTLibEXDI">CS_VARBINARY_TYPE	&lt;C: #define CS_VARBINARY_TYPE (CS_INT)19	&gt;</body><body package="CTLibEXDI">CS_VARCHAR_TYPE	&lt;C: #define CS_VARCHAR_TYPE (CS_INT)18	&gt;</body><body package="CTLibEXDI">CS_VERSION	&lt;C: #define CS_VERSION (CS_INT)9114	&gt;</body><body package="CTLibEXDI">CS_VERSION_100	&lt;C: #define CS_VERSION_100 (CS_INT)112	&gt;</body><body package="CTLibEXDI">CS_VERSION_110	&lt;C: #define CS_VERSION_110 (CS_INT)1100	&gt;</body><body package="CTLibEXDI">CS_VERSION_125	&lt;C: #define CS_VERSION_125 (CS_INT)12500	&gt;</body><body package="CTLibEXDI">CS_VERSION_150			&lt;C: #define CS_VERSION_150 (CS_INT)15000	&gt;</body><body package="CTLibEXDI">CS_VER_STRING	&lt;C: #define CS_VER_STRING (CS_INT)9144	&gt;</body></methods><methods><class-id>Database.CTLibInterface</class-id> <category>structs</category><body package="CTLibEXDI">_cs_clientmsg	&lt;C: struct _cs_clientmsg {			CS_INT severity;			CS_MSGNUM msgnumber;			CS_CHAR msgstring[1024];			CS_INT msgstringlen, osnumber;			CS_CHAR osstring[1024];			CS_INT osstringlen, status;			CS_BYTE sqlstate[8];			CS_INT sqlstatelen;		}&gt;</body><body package="CTLibEXDI">_cs_datafmt	&lt;C: struct _cs_datafmt {			CS_CHAR name[132];			CS_INT namelen, datatype, format, maxlength, scale, precision, status, count, usertype;			CS_LOCALE * locale;		}&gt;</body><body package="CTLibEXDI">_cs_datetime	&lt;C: struct _cs_datetime {			CS_INT dtdays, dttime;		}&gt;</body><body package="CTLibEXDI">_cs_datetime4	&lt;C: struct _cs_datetime4 {			CS_USHORT days, minutes;		}&gt;</body><body package="CTLibEXDI">_cs_money	&lt;C: struct _cs_money {			CS_INT mnyhigh;			CS_UINT mnylow;		}&gt;</body><body package="CTLibEXDI">_cs_money4	&lt;C: struct _cs_money4 {			CS_INT mny4;		}&gt;</body><body package="CTLibEXDI">_cs_numeric	&lt;C: struct _cs_numeric {			CS_BYTE precision, scale;			CS_BYTE array[33];		}&gt;</body><body package="CTLibEXDI">_cs_servermsg	&lt;C: struct _cs_servermsg {			CS_MSGNUM msgnumber;			CS_INT state, severity;			CS_CHAR text[1024];			CS_INT textlen;			CS_CHAR svrname[132];			CS_INT svrnlen;			CS_CHAR proc[132];			CS_INT proclen, line, status;			CS_BYTE sqlstate[8];			CS_INT sqlstatelen;		}&gt;</body><body package="CTLibEXDI">_cs_thread	&lt;C: struct _cs_thread {			CS_THRDC_FUNC create_mutex_fn;			CS_THRDM_FUNC delete_mutex_fn, take_mutex_fn, release_mutex_fn;			CS_THRDC_FUNC create_event_fn;			CS_THRDE_FUNC delete_event_fn, signal_event_fn, reset_event_fn;			CS_THRDW_FUNC waitfor_event_fn;			CS_THRDID_FUNC thread_id_fn;		}&gt;</body><body package="CTLibEXDI">_cs_varybin	&lt;C: struct _cs_varybin {			CS_SMALLINT len;			CS_BYTE array[256];		}&gt;</body><body package="CTLibEXDI">_cs_varychar	&lt;C: struct _cs_varychar {			CS_SMALLINT len;			CS_CHAR str[256];		}&gt;</body><body package="CTLibEXDI">_cscommand	&lt;C: struct _cscommand&gt;</body><body package="CTLibEXDI">_csconnection	&lt;C: struct _csconnection&gt;</body><body package="CTLibEXDI">_cscontext	&lt;C: struct _cscontext&gt;</body><body package="CTLibEXDI">_cslocale	&lt;C: struct _cslocale&gt;</body><body package="CTLibEXDI">_sqlca	&lt;C: struct _sqlca {			char sqlcaid[8];			long sqlcabc, sqlcode;			struct {				long sqlerrml;				char sqlerrmc[256];			} sqlerrm;			char sqlerrp[8];			long sqlerrd[6];			char sqlwarn[8];			char sqlext[8];		}&gt;</body></methods><methods><class-id>Database.CTLibInterface</class-id> <category>types</category><body package="CTLibEXDI">CS_BINARY	&lt;C: typedef unsigned char CS_BINARY&gt;</body><body package="CTLibEXDI">CS_BIT	&lt;C: typedef unsigned char CS_BIT&gt;</body><body package="CTLibEXDI">CS_BOOL	&lt;C: typedef long CS_BOOL&gt;</body><body package="CTLibEXDI">CS_BYTE	&lt;C: typedef unsigned char CS_BYTE&gt;</body><body package="CTLibEXDI">CS_CHAR	&lt;C: typedef char CS_CHAR&gt;</body><body package="CTLibEXDI">CS_CLIENTMSG	&lt;C: typedef struct _cs_clientmsg CS_CLIENTMSG&gt;</body><body package="CTLibEXDI">CS_COMMAND	&lt;C: typedef struct _cscommand CS_COMMAND&gt;</body><body package="CTLibEXDI">CS_CONNECTION	&lt;C: typedef struct _csconnection CS_CONNECTION&gt;</body><body package="CTLibEXDI">CS_CONTEXT	&lt;C: typedef struct _cscontext CS_CONTEXT&gt;</body><body package="CTLibEXDI">CS_CONV_FUNC	&lt;C: typedef CS_RETCODE (* CS_CONV_FUNC)(CS_CONTEXT * context, CS_DATAFMT * srcfmt, CS_VOID * src, CS_DATAFMT * destfmt, CS_VOID * dest, CS_INT * destlen)&gt;</body><body package="CTLibEXDI">CS_DATAFMT	&lt;C: typedef struct _cs_datafmt CS_DATAFMT&gt;</body><body package="CTLibEXDI">CS_DATETIME	&lt;C: typedef struct _cs_datetime CS_DATETIME&gt;</body><body package="CTLibEXDI">CS_DATETIME4	&lt;C: typedef struct _cs_datetime4 CS_DATETIME4&gt;</body><body package="CTLibEXDI">CS_DECIMAL	&lt;C: typedef CS_NUMERIC CS_DECIMAL&gt;</body><body package="CTLibEXDI">CS_FLOAT	&lt;C: typedef double CS_FLOAT&gt;</body><body package="CTLibEXDI">CS_IMAGE	&lt;C: typedef unsigned char CS_IMAGE&gt;</body><body package="CTLibEXDI">CS_INT	&lt;C: typedef long CS_INT&gt;</body><body package="CTLibEXDI">CS_LOCALE	&lt;C: typedef struct _cslocale CS_LOCALE&gt;</body><body package="CTLibEXDI">CS_LONG	&lt;C: typedef long CS_LONG&gt;</body><body package="CTLibEXDI">CS_LONGBINARY	&lt;C: typedef unsigned char CS_LONGBINARY&gt;</body><body package="CTLibEXDI">CS_LONGCHAR	&lt;C: typedef unsigned char CS_LONGCHAR&gt;</body><body package="CTLibEXDI">CS_MONEY	&lt;C: typedef struct _cs_money CS_MONEY&gt;</body><body package="CTLibEXDI">CS_MONEY4	&lt;C: typedef struct _cs_money4 CS_MONEY4&gt;</body><body package="CTLibEXDI">CS_MSGNUM	&lt;C: typedef long CS_MSGNUM&gt;</body><body package="CTLibEXDI">CS_NUMERIC	&lt;C: typedef struct _cs_numeric CS_NUMERIC&gt;</body><body package="CTLibEXDI">CS_REAL	&lt;C: typedef float CS_REAL&gt;</body><body package="CTLibEXDI">CS_RETCODE	&lt;C: typedef long CS_RETCODE&gt;</body><body package="CTLibEXDI">CS_SERVERMSG	&lt;C: typedef struct _cs_servermsg CS_SERVERMSG&gt;</body><body package="CTLibEXDI">CS_SMALLINT	&lt;C: typedef short CS_SMALLINT&gt;</body><body package="CTLibEXDI">CS_TEXT	&lt;C: typedef unsigned char CS_TEXT&gt;</body><body package="CTLibEXDI">CS_THRDC_FUNC	&lt;C: typedef CS_RETCODE (* CS_THRDC_FUNC)(CS_THRDRES * * resource)&gt;</body><body package="CTLibEXDI">CS_THRDE_FUNC	&lt;C: typedef CS_RETCODE (* CS_THRDE_FUNC)(CS_THRDRES * resource)&gt;</body><body package="CTLibEXDI">CS_THRDID_FUNC	&lt;C: typedef CS_RETCODE (* CS_THRDID_FUNC)(CS_VOID * buffer, CS_INT buflen, CS_INT * outlen)&gt;</body><body package="CTLibEXDI">CS_THRDM_FUNC	&lt;C: typedef CS_RETCODE (* CS_THRDM_FUNC)(CS_THRDRES * resource)&gt;</body><body package="CTLibEXDI">CS_THRDRES	&lt;C: typedef void CS_THRDRES&gt;</body><body package="CTLibEXDI">CS_THRDW_FUNC	&lt;C: typedef CS_RETCODE (* CS_THRDW_FUNC)(CS_THRDRES * resource, CS_INT millisecs)&gt;</body><body package="CTLibEXDI">CS_THREAD	&lt;C: typedef struct _cs_thread CS_THREAD&gt;</body><body package="CTLibEXDI">CS_TINYINT	&lt;C: typedef unsigned char CS_TINYINT&gt;</body><body package="CTLibEXDI">CS_UINT	&lt;C: typedef unsigned long CS_UINT&gt;</body><body package="CTLibEXDI">CS_USHORT	&lt;C: typedef unsigned short CS_USHORT&gt;</body><body package="CTLibEXDI">CS_VARBINARY	&lt;C: typedef struct _cs_varybin CS_VARBINARY&gt;</body><body package="CTLibEXDI">CS_VARCHAR	&lt;C: typedef struct _cs_varychar CS_VARCHAR&gt;</body><body package="CTLibEXDI">CS_VOID	&lt;C: typedef void CS_VOID&gt;</body><body package="CTLibEXDI">SQLCA	&lt;C: typedef struct _sqlca SQLCA&gt;</body></methods><methods><class-id>Database.CTLibInterface</class-id> <category>types-extra</category><body package="CTLibEXDI">PTR	&lt;C: typedef void * PTR&gt;</body><body package="CTLibEXDI">clientMsgHandlerType	&lt;C: typedef CS_RETCODE ( __stdcall  * clientMsgHandlerType)	( CS_CONTEXT * context,		CS_CONNECTION * connection,		CS_CLIENTMSG  * msg )&gt;</body><body package="CTLibEXDI">serverMsgHandlerType	&lt;C: typedef CS_RETCODE ( __stdcall * serverMsgHandlerType)	( CS_CONTEXT * context,		CS_CONNECTION * connection,		CS_SERVERMSG  * msg )&gt;</body></methods><methods><class-id>Database.CTLibInterface</class-id> <category>accessing</category><body package="CTLibEXDI">copyToHeapSelector	^#copyToHeap</body><body package="CTLibEXDI">csVersion	^self CS_VERSION_100</body><body package="CTLibEXDI">encoding	encoding == nil ifTrue: [encoding := self getEncoding].	^encoding</body><body package="CTLibEXDI">getEncoding	^#default</body><body package="CTLibEXDI">mallocSelector        ^#malloc:</body></methods><methods><class-id>Database.CTLibInterface class</class-id> <category>fileIn/Out</category><body package="CTLibEXDI">binaryInitializationMessagesFor: sourceMode	"Answer a list of message sends used to initialize the receiver."	| list |	list := super binaryInitializationMessagesFor: sourceMode.	list add: (		MessageSend			receiver: self			selector: #deferredInitialize).	^list</body></methods><methods><class-id>Database.CTLibInterface class</class-id> <category>private-accessing</category><body package="CTLibEXDI">fSqlTypeFromConversionMap	^fSqlTypeFromConversionMap</body><body package="CTLibEXDI">fSqlTypeToConversionMap	^fSqlTypeToConversionMap</body><body package="CTLibEXDI">fSqlTypeToServerTypeConversionMap	^fSqlTypeToServerTypeConversionMap</body><body package="CTLibEXDI">fetchBufferSize	^fetchBufferSize</body><body package="CTLibEXDI">getSelectorMap	^getSelectorMap</body><body package="CTLibEXDI">putSelectorMap	^putSelectorMap</body></methods><methods><class-id>Database.CTLibInterface class</class-id> <category>class initialization</category><body package="CTLibEXDI">deferredInitialize	"Used to initialize the class after file-in or BOSS-in."	| ctlibBufferClass |	self initializeMaps.	(ctlibBufferClass := self environment at: #CTLibBuffer ifAbsent: [ nil ]) notNil ifTrue:		[ ctlibBufferClass install ]</body><body package="CTLibEXDI">initializeDefineCaches	"This should only be done if the DLLCC development environment is present in the image."	self fillDefineCaches.	self fillDefineCaches	"Do twice in case there are longer reference chains."</body><body package="CTLibEXDI">initializeMaps	| xif |	xif := self new.	"Create the association tables for row buffer and bound parameter encoding...	The getSelectorMap needs to have a message name understood by		CTLibBuffer for each conversion.	The putSelectorMap needs to have a message name understood by		CTLibBuffer for each conversion.	The fSqlTypeToConversionMap associates CTLibBuffer conversion names		with the supported fSqlTypes.  Note, several SQL types may map		to the same conversion name.	The fSqlTypeToServerTypeConversionMap associates the supported fSqlTypes		with the Sybase server data types.	The fetchBufferSize is the size of a buffer to be allocated to fetch data."	getSelectorMap := IdentityDictionary new.	putSelectorMap := IdentityDictionary new.	fSqlTypeToConversionMap := IdentityDictionary new.	fSqlTypeToServerTypeConversionMap := IdentityDictionary new.	fSqlTypeFromConversionMap := IdentityDictionary new.	fetchBufferSize := IdentityDictionary new.		"Conversion from buffer for Integer."	getSelectorMap add: ( #Integer -&gt; #getIntegerAt: ).	putSelectorMap add: ( #Integer -&gt; #at:putInteger: ).	fSqlTypeToConversionMap add: ( xif CS_TINYINT_TYPE -&gt; #Integer ).	fSqlTypeToConversionMap add: ( xif CS_SMALLINT_TYPE -&gt; #Integer ).	fSqlTypeToConversionMap add: ( xif CS_INT_TYPE -&gt; #Integer ).	fSqlTypeToConversionMap add: ( xif CS_BIGINT_TYPE -&gt; #Integer ).	fSqlTypeToServerTypeConversionMap add: ( xif CS_TINYINT_TYPE -&gt; #tinyint ).	fSqlTypeToServerTypeConversionMap add: ( xif CS_SMALLINT_TYPE -&gt; #smallint ).	fSqlTypeToServerTypeConversionMap add: ( xif CS_INT_TYPE -&gt; #int ).	fSqlTypeToServerTypeConversionMap add: ( xif CS_BIGINT_TYPE -&gt; #int ).	fSqlTypeFromConversionMap add: ( #Integer -&gt; xif CS_INT_TYPE ).	fetchBufferSize add: ( #Integer -&gt; [ :ignoredValue | 4 ] ).	"Conversion to/from buffer for FixedPoint."	getSelectorMap add: ( #FixedPoint -&gt; #getFixedPointAt: ).	putSelectorMap add: ( #FixedPoint -&gt; #at:putFixedPoint: ).	fSqlTypeToConversionMap add: ( xif CS_DECIMAL_TYPE -&gt; #FixedPoint ).	fSqlTypeToConversionMap add: ( xif CS_NUMERIC_TYPE -&gt; #FixedPoint ).	fSqlTypeToConversionMap add: ( xif CS_MONEY4_TYPE -&gt; #FixedPoint ).	fSqlTypeToConversionMap add: ( xif CS_MONEY_TYPE -&gt; #FixedPoint ).	fSqlTypeToServerTypeConversionMap add: ( xif CS_DECIMAL_TYPE -&gt; #decimal ).	fSqlTypeToServerTypeConversionMap add: ( xif CS_NUMERIC_TYPE -&gt; #numeric ).	fSqlTypeToServerTypeConversionMap add: ( xif CS_MONEY4_TYPE -&gt; #smallmoney ).	fSqlTypeToServerTypeConversionMap add: ( xif CS_MONEY_TYPE -&gt; #money ).	fSqlTypeFromConversionMap add: ( #FixedPoint -&gt; xif CS_CHAR_TYPE ).	fetchBufferSize add: ( #FixedPoint -&gt; [ :ignoredValue | 38  ] ).	"Conversion to/from buffer for Double."	getSelectorMap add: ( #Double -&gt; #getDoubleAt: ).	putSelectorMap add: ( #Double -&gt; #at:putDouble: ).	fSqlTypeToConversionMap add: ( xif CS_FLOAT_TYPE -&gt; #Double ).	fSqlTypeFromConversionMap add: ( #Double -&gt; xif CS_FLOAT_TYPE ).	fetchBufferSize add: ( #Double -&gt; [ :ignored | 8 ] ).	"Conversion from buffer for Float."	getSelectorMap add: ( #Float -&gt; #getFloatAt: ).	putSelectorMap add: ( #Float -&gt; #at:putFloat: ).	fSqlTypeToConversionMap add: ( xif CS_REAL_TYPE -&gt; #Float ).	fSqlTypeToServerTypeConversionMap add: ( xif CS_FLOAT_TYPE -&gt; #float ).	fSqlTypeToServerTypeConversionMap add: ( xif CS_REAL_TYPE -&gt; #real ).	fSqlTypeFromConversionMap add: ( #Float -&gt; xif CS_REAL_TYPE ).	fetchBufferSize add: ( #Float -&gt; [ :ignored | 4 ] ).	"Conversion to/from buffer for Timestamp."	getSelectorMap add: ( #Timestamp -&gt;  #getTimestampAt: ).	putSelectorMap add: ( #Timestamp -&gt;  #at:putTimestamp: ).	fSqlTypeToConversionMap add: ( xif CS_DATETIME4_TYPE -&gt; #Timestamp ).	fSqlTypeToConversionMap add: ( xif CS_DATETIME_TYPE -&gt; #Timestamp ).	fSqlTypeToConversionMap add: ( xif CS_DATE_TYPE -&gt; #Timestamp ).	fSqlTypeToConversionMap add: ( xif CS_TIME_TYPE -&gt; #Timestamp ).	fSqlTypeToServerTypeConversionMap add: ( xif CS_DATETIME4_TYPE -&gt; #smalldatetime ).	fSqlTypeToServerTypeConversionMap add: ( xif CS_DATETIME_TYPE -&gt; #datetime ).	fSqlTypeToServerTypeConversionMap add: ( xif CS_DATE_TYPE -&gt; #date ).	fSqlTypeToServerTypeConversionMap add: ( xif CS_TIME_TYPE -&gt; #time ).	fSqlTypeFromConversionMap add: ( #Timestamp -&gt; xif CS_DATETIME_TYPE ).	fetchBufferSize add: ( #Timestamp -&gt; [ :ignoredValue | 8 ] ).	"Conversion from buffer for String.	In order to improve the chance that the buffer will hold alternate values	without requiring the application to prepare the SQL again, the	number of characters (and bytes to allocate) is guaranteed to be at least 256	In between that range, the size is rounded up to the next largest power of 2."	getSelectorMap add: ( #String -&gt; #getStringAt: ).	putSelectorMap add: ( #String -&gt; #at:putString: ).	fSqlTypeToConversionMap add: ( xif CS_CHAR_TYPE -&gt; #String ).	fSqlTypeToConversionMap add: ( xif CS_VARCHAR_TYPE -&gt; #String ).	"not used"	fSqlTypeToConversionMap add: ( xif CS_LONGCHAR_TYPE -&gt; #String ).	"not used"	fSqlTypeToConversionMap add: ( xif CS_TEXT_TYPE -&gt; #String ).	fSqlTypeToServerTypeConversionMap add: ( xif CS_CHAR_TYPE -&gt; #char ).	fSqlTypeToServerTypeConversionMap add: ( xif CS_VARCHAR_TYPE -&gt; #varchar ).	"not used"	fSqlTypeToServerTypeConversionMap add: ( xif CS_TEXT_TYPE -&gt; #text ).	fSqlTypeFromConversionMap add: ( #String -&gt; xif CS_CHAR_TYPE ).	fetchBufferSize add: ( #String -&gt; [ :size | size + 1 ] ).	"Leave room for a null."	"Conversion from buffer for ByteArray.	In order to improve the chance that the buffer will hold alternate values	without requiring the application to prepare the SQL again, the	number of characters (and bytes to allocate) is guaranteed to be at least 256.	In between that range, the size is rounded up to the next largest power of 2."	getSelectorMap add: ( #ByteArray -&gt; #getByteArrayAt: ).	putSelectorMap add: ( #ByteArray -&gt; #at:putByteArray: ).	fSqlTypeToConversionMap add: ( xif CS_BINARY_TYPE -&gt; #ByteArray ).	fSqlTypeToConversionMap add: ( xif CS_VARBINARY_TYPE -&gt; #ByteArray ).	fSqlTypeToConversionMap add: ( xif CS_IMAGE_TYPE -&gt; #ByteArray ).	fSqlTypeToServerTypeConversionMap add: ( xif CS_BINARY_TYPE -&gt; #binary ).	fSqlTypeToServerTypeConversionMap add: ( xif CS_VARBINARY_TYPE -&gt; #varbinary ).	fSqlTypeToServerTypeConversionMap add: ( xif CS_IMAGE_TYPE -&gt; #image ).	fSqlTypeFromConversionMap add: ( #ByteArray -&gt; xif CS_BINARY_TYPE ).	fetchBufferSize add: ( #ByteArray -&gt; [ :size | size + 1 ] ).	"Leave room for a null."		"Conversion from buffer for Boolean."	getSelectorMap add: ( #Boolean -&gt; #getBooleanAt: ).	putSelectorMap add: ( #Boolean -&gt; #at:putBoolean: ).	fSqlTypeToConversionMap add: ( xif CS_BIT_TYPE -&gt; #Boolean ).	fSqlTypeToServerTypeConversionMap add: ( xif CS_BIT_TYPE -&gt; #bit ).	fSqlTypeFromConversionMap add: ( #Boolean -&gt; xif CS_BIT_TYPE ).	fetchBufferSize add: ( #Boolean -&gt; [ :ignoredValue | 1 ] )</body></methods><methods><class-id>Database.CTLibInterface class</class-id> <category>parcel load/unload/save</category><body package="CTLibEXDI">obsolete	super obsolete.	#{UISettings} isDefined		ifTrue: [UISettings removePreferenceSection: #addSybaseSectionTo:development:runtime:]</body><body package="CTLibEXDI">postLoadFrom: aParcel	"A Parcel's post-load method must be a class method taking one	 argument, the Parcel being loaded.  Fill-out this template, accept	 and then select 'be post-load method' from the selector menu.	 Note that you can give the method whatever selector you want.	 You don't have to stay with postLoadFrom:.	 Note that all loaded classes are sent the message postLoad: after	 loading.  The default implementation, ClassDescription&gt;postLoad:	 runs the class's initialize method if it has one.  One may override	 this method to add additional loading behavior.  See also	 ClassDescription&gt;preSave: which is intended to be used along	 with ClassDescription&gt;postLoad: for managing class loading.	 The post-load method can then ignore class initialization and can	 instead concentrate on tasks such as opening windows, etc."	self deferredInitialize.	self allSubclassesDo: [:interfaceClass | interfaceClass deferredInitialize].	#{UISettings} isDefined		ifTrue: [UISettings addPreferenceSection: #addSybaseSectionTo:development:runtime:]</body></methods><methods><class-id>Database.CTLibAixInterface</class-id> <category>types</category><body package="CTLibEXDI">CS_BOOL	&lt;C: typedef int CS_BOOL&gt;</body><body package="CTLibEXDI">CS_INT	&lt;C: typedef int CS_INT&gt;</body><body package="CTLibEXDI">CS_RETCODE	&lt;C: typedef int CS_RETCODE&gt;</body><body package="CTLibEXDI">CS_UINT	&lt;C: typedef unsigned int CS_UINT&gt;</body></methods><methods><class-id>Database.CTLibWin16Interface</class-id> <category>types</category><body package="CTLibEXDI">CS_CHAR	&lt;C: typedef void * CS_CHAR&gt;</body><body package="CTLibEXDI">CS_CLIENTMSG	&lt;C: typedef void * CS_CLIENTMSG&gt;</body><body package="CTLibEXDI">CS_COMMAND	&lt;C: typedef void * CS_COMMAND&gt;</body><body package="CTLibEXDI">CS_CONNECTION	&lt;C: typedef void * CS_CONNECTION&gt;</body><body package="CTLibEXDI">CS_CONTEXT	&lt;C: typedef void * CS_CONTEXT&gt;</body><body package="CTLibEXDI">CS_CONV_FUNC	&lt;C: typedef CS_RETCODE ( _pascal _far * CS_CONV_FUNC)(CS_CONTEXT _far * context, CS_DATAFMT _far * srcfmt, CS_VOID _far * src, CS_DATAFMT _far * destfmt, CS_VOID _far * dest, CS_INT _far * destlen)&gt;</body><body package="CTLibEXDI">CS_DATAFMT	&lt;C: typedef void * CS_DATAFMT&gt;</body><body package="CTLibEXDI">CS_INT	&lt;C: typedef void * CS_INT&gt;</body><body package="CTLibEXDI">CS_LOCALE	&lt;C: typedef void * CS_LOCALE&gt;</body><body package="CTLibEXDI">CS_RETCODE	&lt;C: typedef void * CS_RETCODE&gt;</body><body package="CTLibEXDI">CS_SERVERMSG	&lt;C: typedef void * CS_SERVERMSG&gt;</body><body package="CTLibEXDI">CS_SMALLINT	&lt;C: typedef void * CS_SMALLINT&gt;</body><body package="CTLibEXDI">CS_THRDC_FUNC	&lt;C: typedef CS_RETCODE ( _pascal _far * CS_THRDC_FUNC)(CS_THRDRES _far * _far * resource)&gt;</body><body package="CTLibEXDI">CS_THRDE_FUNC	&lt;C: typedef CS_RETCODE ( _pascal _far * CS_THRDE_FUNC)(CS_THRDRES _far * resource)&gt;</body><body package="CTLibEXDI">CS_THRDID_FUNC	&lt;C: typedef CS_RETCODE ( _pascal _far * CS_THRDID_FUNC)(CS_VOID _far * buffer, CS_INT buflen, CS_INT _far * outlen)&gt;</body><body package="CTLibEXDI">CS_THRDM_FUNC	&lt;C: typedef CS_RETCODE ( _pascal _far * CS_THRDM_FUNC)(CS_THRDRES _far * resource)&gt;</body><body package="CTLibEXDI">CS_THRDRES	&lt;C: typedef void * CS_THRDRES&gt;</body><body package="CTLibEXDI">CS_THRDW_FUNC	&lt;C: typedef CS_RETCODE ( _pascal _far * CS_THRDW_FUNC)(CS_THRDRES _far * resource, CS_INT millisecs)&gt;</body><body package="CTLibEXDI">CS_VOID	&lt;C: typedef void * CS_VOID&gt;</body></methods><methods><class-id>Database.CTLibWin16Interface</class-id> <category>types-extra</category><body package="CTLibEXDI">PTR	&lt;C: typedef void _far * PTR&gt;</body><body package="CTLibEXDI">clientMsgHandlerType	&lt;C: typedef int (_pascal _far * clientMsgHandlerType)	( CS_CONTEXT _far * context,		CS_CONNECTION _far * connection,		CS_CLIENTMSG _far * msg )&gt;</body><body package="CTLibEXDI">serverMsgHandlerType	&lt;C: typedef int (_pascal _far * serverMsgHandlerType)	( CS_CONTEXT _far * context,		CS_CONNECTION _far * connection,		CS_SERVERMSG  _far * msg )&gt;</body></methods><methods><class-id>Database.CTLibWin16Interface</class-id> <category>structs</category><body package="CTLibEXDI">_cs_datafmt	&lt;C: struct _cs_datafmt {			CS_CHAR name[132];			CS_INT namelen, datatype, format, maxlength, scale, precision, status, count, usertype;			CS_LOCALE _far * locale;		}&gt;</body></methods><methods><class-id>Database.CTLibWin16Interface</class-id> <category>accessing</category><body package="CTLibEXDI">copyToHeapSelector	^#copyToHeap16</body><body package="CTLibEXDI">mallocSelector	^#malloc16:</body></methods><methods><class-id>Database.CTLibSession</class-id> <category>private-ObjectLens</category><body package="CTLibEXDI">afterOrdinaryAnswerStreamFromCommand	"Check to be sure that all results have been handled"		| haveResults |	self state == #validResults ifFalse:	[ ^self ].		haveResults := true.	[ haveResults ] whileTrue:		[ [ haveResults := self moreResultsExternal ]		ensure: [ self state: #prepared ] ]</body><body package="CTLibEXDI">bindInput: object template: template to: bindStream	"Recursively flatten a template onto a bindStream"	| class |	( object == nil )		ifTrue: [ ^self bindNil: template to: bindStream ].	( template isInteger ) ifTrue:		[ ^bindStream nextPut: object ].	class := template class.	( class == Object ) ifTrue: [ ^self ].	( class == Float	or: [ class == Double	or: [ class == FixedPoint	or: [ class == Timestamp	or: [ object == true	or: [ object == false	or: [ (object isKindOf: CharacterArray)	or: [ object isKindOf: ByteArray ] ] ] ] ] ] ] ) ifTrue:		[ ^bindStream nextPut: object ].	"turn symbols into strings"	(object isKindOf: ByteSymbol) ifTrue:		[ ^bindStream nextPut: object asString ].	( ( template isKindOf: Array ) or: [ template isKindOf: OrderedCollection ] )		ifTrue:	[ 1 to: (object size) do:					[ : index |					self bindInput: (object at: index)						template: (template at: index)						to: bindStream ] ]		ifFalse:	[ "All others are treated as instances"				1 to: (object class instSize) do:					[ : index |					self bindInput: (object instVarAt: index)						template: (template instVarAt: index)						to: bindStream ] ].</body><body package="CTLibEXDI">bindNil: template to: bindStream	"Recursively bind nil against a template."	| class |	template isNil ifTrue: [ ^bindStream nextPut: nil ].	template isInteger ifTrue: [ ^bindStream nextPut: nil ].	class := template class.	class == Object ifTrue: [ ^self ].	( class == Float	or: [ class == Double	or: [ class == FixedPoint	or: [ class == Timestamp	or: [ template == true	or: [ template == false	or: [ class == ByteFieldDescriptor	or: [ (template isKindOf: CharacterArray)	or: [ template isKindOf: ByteArray ] ] ] ] ] ] ] ])		ifTrue: [ ^bindStream nextPut: nil ].	"Recursively bind nil for Arrays, OrderedCollections, and other instances."	( ( template isKindOf: Array ) or: [ template isKindOf: OrderedCollection ] )		ifTrue: [ 1 to: (template size) do:					[ :index |					self bindNil: (template at: index) to: bindStream ] ]		ifFalse: [ 1 to: (template class instSize) do:					[ :index |					self bindNil: (template instVarAt: index) to: bindStream ] ]</body><body package="CTLibEXDI">doCommand: command	"Check to see if we can execute now.  If so, invoke the super implementation	to execute now.  If not, complain."		| executionStates |	executionStates := #( #executing #ready #validResults #fetchingData ).	"We can execute if we're already executing or if no other session for my connection is."	(executionStates includes: self state) ifFalse:		[ | conflict |		"We don't already have the right to execute, ask permission."		conflict := (connection participants			detect:				[ :s | s == 0 ifTrue: [ false ] ifFalse: [ executionStates includes: s state ] ]			ifNone:				[ nil ]).		conflict isNil ifFalse:			[ ^self class connectionClass tooManyActiveSessionsSignal raise ] ].	^super doCommand: command</body><body package="CTLibEXDI">flattenResultTemplate: template onto: descStream	"Recursively flatten an ObjectLens result template."	| class desc |	class := template class.	"Instances of object in the template denote slots to ignore."	( class == Object )		ifTrue: [ ^self ].	( template isInteger ) ifTrue:		[ (desc := CTLibColumnDescription new)			type: #Integer;			maxColumnConstraint: 4.		^descStream nextPut: desc ].	class == Float  ifTrue:		[ (desc := CTLibColumnDescription new)			type: #Float;			maxColumnConstraint: 4.		^descStream nextPut: desc ].	class == Double ifTrue:		[ (desc := CTLibColumnDescription new)			type: #Double;			maxColumnConstraint: 8.		^descStream nextPut: desc ].	class == FixedPoint ifTrue:		[ (desc := CTLibColumnDescription new)			type: #FixedPoint;			maxColumnConstraint: 32.		^descStream nextPut: desc ].	(template == true or: [ template == false]) ifTrue:		[ (desc := CTLibColumnDescription new)			type: #Boolean;			maxColumnConstraint: 1.		^descStream nextPut: desc ].	( class == Timestamp ) ifTrue:		[ (desc := CTLibColumnDescription new)			type: #Timestamp;			maxColumnConstraint: 8.		^descStream nextPut: desc ].	( class == ByteFieldDescriptor ) ifTrue:		[ | temp |		(desc := CTLibColumnDescription new)			maxColumnConstraint: template MaxColumnConstraint.		temp := template Template.		desc type: ( ( temp isString or: [ temp class == ByteSymbol ] )			ifTrue: [ #String ]			ifFalse: [ #ByteArray ] ).		^descStream nextPut: desc ].	( template isString ) ifTrue:		[ (desc := CTLibColumnDescription new)			type: #String;			maxColumnConstraint: self textLimit.		^descStream nextPut: desc ].	"Decompose Arrays and Collections."	( ( template isKindOf: Array ) or: [ template isKindOf: OrderedCollection ] ) ifTrue:		[ 1 to: template size do:			[ :index |			self flattenResultTemplate: (template at: index) onto: descStream ].		^self ].	"All others are treated as instances of some entity"	1 to: template class instSize do:		[ :index |		self flattenResultTemplate: (template instVarAt: index) onto: descStream ].</body><body package="CTLibEXDI">nextViaTemplate: template	"Answer the object formed by recursively reifying the template from fetched data."	| class object |	template == nil ifTrue: [ ^nil ].	( template isInteger ) ifTrue:		[ object := self getFieldExternal: bufferIndex.		bufferIndex := bufferIndex + 1.		^object isNil ifTrue: [ nil ] ifFalse: [ object asInteger ] ].	class := template class.	( class == Object ) ifTrue: [ ^nil ].	( class == Float ) ifTrue:		[ object := self getFieldExternal: bufferIndex.		bufferIndex := bufferIndex + 1.		^object isNil ifTrue: [ nil ] ifFalse: [ object asFloat ] ].	( class == Double ) ifTrue:		[ object := self getFieldExternal: bufferIndex.		bufferIndex := bufferIndex + 1.		^object isNil ifTrue: [ nil ] ifFalse: [ object asDouble ] ].	( class == Timestamp or: [template == true or: [template == false or: [class == FixedPoint]]]) ifTrue:		[ object := self getFieldExternal: bufferIndex.		bufferIndex := bufferIndex + 1.		^object ].	( class == ByteFieldDescriptor or: [ class == String ] ) ifTrue:		[ object := self getFieldExternal: bufferIndex.		bufferIndex := bufferIndex + 1.		^object ].	( template isKindOf: Collection ) ifTrue:		[ ( template isKindOf: Array )			ifTrue:	[ ^self nextViaArrayTemplate: template ]			ifFalse:	[ ^self nextViaCollectionTemplate: template ] ].	^self nextViaEntityTemplate: template</body></methods><methods><class-id>Database.CTLibSession</class-id> <category>private-accessing</category><body package="CTLibEXDI">cmd	^cmdHolder value</body><body package="CTLibEXDI">cmd: aCPointerOrNil        cmdHolder value: aCPointerOrNil</body><body package="CTLibEXDI">cmdHolder	^cmdHolder</body><body package="CTLibEXDI">cmdHolder: aValueHolder	cmdHolder := aValueHolder</body><body package="CTLibEXDI">conn	^connection conn</body><body package="CTLibEXDI">currentRowIndex	^currentRowIndex</body><body package="CTLibEXDI">currentRowIndex: anInteger	currentRowIndex := anInteger</body><body package="CTLibEXDI">cursorFlag	^cursorFlag</body><body package="CTLibEXDI">cursorFlag: anInteger	cursorFlag := anInteger</body><body package="CTLibEXDI">fetchAbsoluteMode	^self class xif CS_ABSOLUTE</body><body package="CTLibEXDI">fetchNextMode	^self class xif CS_NEXT</body><body package="CTLibEXDI">fetchPriorMode	^self class xif CS_PREV</body><body package="CTLibEXDI">fetchRelativeMode	^self class xif CS_RELATIVE</body><body package="CTLibEXDI">ffetchPriorMode	^self class xif CS_PREV</body><body package="CTLibEXDI">idleStatus	^idleStatus</body><body package="CTLibEXDI">idleStatus: aBoolean	idleStatus := aBoolean</body><body package="CTLibEXDI">returnStatus: anInteger	returnStatus := anInteger</body><body package="CTLibEXDI">rowsInBlock	"Answer number of rows fetched in current block."	^rowsInBlock</body><body package="CTLibEXDI">rowsInBlock: aSmallInteger	"Record number of rows fetched in current block."	rowsInBlock := aSmallInteger</body></methods><methods><class-id>Database.CTLibSession</class-id> <category>private-execution</category><body package="CTLibEXDI">acquireExternal	"Acquire external resources."        | xif pCmd rc errs |	xif := self class xif.	[ "Begin unwind protection"	pCmd := xif PTR perform: xif mallocSelector with: 1.	pCmd contents: nil.	rc := xif ct_cmd_alloc: self conn			with: pCmd.	( traceLevel &gt;= 2 ) ifTrue:		[ (self traceStream)                        print: rc;  nextPutAll: ' = ct_cmd_alloc( conn = ';			nextPutAll: (self conn referentAddress printStringRadix: 16);			nextPutAll: ', pCmd = ';			nextPutAll: (pCmd referentAddress printStringRadix: 16);			nextPutAll: ' )'; crtab;			nextPutAll: 'cmd=';			nextPutAll: (pCmd contents referentAddress printStringRadix: 16).		self class trace: self emitTrace ].	self cmd: pCmd contents.	textLimit isNil ifTrue:		[ textLimit := 32768 "default" ].	"End unwind protection" ]		ensure:			[ pCmd notNil ifTrue: [ pCmd freePointer ].			( rc isNil or:			[ rc == xif CS_FAIL ] ) ifTrue:				[ self cmd: nil.				errs := self class connectionClass errorsOnQueue: self conn referentAddress.				self class connectionClass externalDatabaseErrorSignal raiseWith: errs errorString: errs first dbmsErrorString ] ]</body><body package="CTLibEXDI">cancelExternal	"Cancel a command or results of a command"	| xif rc |		"Remove any prior return information."	self releaseBuffersAndAdaptors.	self returnStatus: nil.	self cmd isNil ifTrue:		[ ^self ].	xif := self class xif.	rc := xif ct_cancel: nil			with: self cmd			with: xif CS_CANCEL_ALL.	( traceLevel &gt;= 2 ) ifTrue:		[ self traceStream print: rc;  nextPutAll: ' = ct_cancel( nil, cmd='.		self traceStream nextPutAll: (self cmd referentAddress printStringRadix: 16).		self traceStream nextPutAll: ', type=CS_CANCEL_ALL )'.		self class trace: self emitTrace ].	res_type := 0.	(rc == xif CS_SUCCEED) ifFalse:			[ self class connectionClass errorsOnQueue: self conn referentAddress ].	"Close cursor."	(self useCursor and: [ self isCursorOpen ]) ifTrue: [ self closeCursorExternal ].</body><body package="CTLibEXDI">dismissExternal	"Release the external resources."	| xif rc |	pRowsFetched == nil ifFalse:		[ pRowsFetched freePointer.		pRowsFetched := nil ].	self cmd isNil ifTrue: [ ^self ].	self cancelExternal.	xif := self class xif.	rc := xif ct_cmd_drop: self cmd.	( traceLevel &gt;= 2 ) ifTrue:		[ (self traceStream)			print: rc;  nextPutAll: '= ct_cmd_drop( cmd=';			nextPutAll: (self cmd referentAddress printStringRadix: 16);			nextPutAll: ' )'.		self class trace: self emitTrace ].	self cmd: nil.	rc == xif CS_SUCCEED ifFalse:			[ self class connectionClass errorsOnQueue: self conn referentAddress]</body><body package="CTLibEXDI">executeExternal	"Execute the prepared SQL text."	"Since the Sybase CT-Library does not support the notion of preparing SQL,	the actual prepare is done here together with the execute."	| rc err xif |		xif := self class xif.	"Send the assembled query batch to the server and start it executing."	rc := xif ct_send: self cmd.	( traceLevel &gt;= 1 ) ifTrue:		[ (self traceStream)                        print: rc;  nextPutAll: ' = ct_send( cmd=';			nextPutAll: (self cmd referentAddress printStringRadix: 16);			nextPutAll: ' )'.		self class trace: self emitTrace ].	(rc == xif CS_FAIL) ifTrue:		[ err := self class connectionClass errorsOnQueue: self conn referentAddress.		self class connectionClass unableToExecuteSQLSignal raiseWith: err errorString: err first dbmsErrorString ]</body><body package="CTLibEXDI">getResultsExternal	"Get next set of results for an SQL statement and raise exceptions for any errors."	| xif rc errs pRes signal |	self aboutToAnswer.	xif := self class xif.	self idleStatus ifTrue: [^xif CS_END_RESULTS ].	[ "Begin unwind protection."	pRes := xif CS_INT perform: xif mallocSelector with: 1.	rc := xif ct_results: self cmd			with: pRes.	( traceLevel &gt;= 2 ) ifTrue:		[ (self traceStream)                        print: rc;  nextPutAll: ' = ct_results( cmd=';			nextPutAll: (self cmd referentAddress printStringRadix: 16);			nextPutAll: ', pRes=';			nextPutAll: (pRes referentAddress printStringRadix: 16);			nextPutAll: ' )'; crtab;			nextPutAll: 'pRes contents= '; print: (pRes contents).		self class trace: self emitTrace ].	(rc == xif CS_SUCCEED) ifTrue:		[ res_type := pRes contents ]		ifFalse: [ res_type := 0 ].	"End unwind protection." ]		ensure:			[ pRes == nil ifFalse: [ pRes freePointer ] ].		(rc == xif CS_CANCELED) ifTrue:		[ self releaseBuffersAndAdaptors ].  "results have been cancelled"		rc == xif CS_FAIL ifFalse: [ ^rc ].	"Report the error detected."	errs := self class connectionClass errorsOnQueue: self conn referentAddress.	( errs isNil or: [ errs isEmpty ] )		ifTrue: [ signal := connection class unableToExecuteSQLSignal ]		ifFalse: [ | error connClass |				error := errs first.				signal := (connClass := connection class)						perform: (connClass signalMap						at: error dbmsErrorCode						ifAbsent: [ #unableToExecuteSQLSignal ]).		 ].	signal raiseWith: errs errorString: errs first dbmsErrorString.	^rc</body><body package="CTLibEXDI">getResultsInfoExternal: infoType	"get information about the results, typically get number of columns or a number of affected rows"	| xif rc pResInfo resInfo errs |		xif := self class xif.		[ "Begin unwind protection."	pResInfo := xif CS_INT perform: xif mallocSelector with: 1.	rc := xif ct_res_info: self cmd			with: infoType			with: pResInfo			with: xif CS_UNUSED			with: nil.	resInfo := pResInfo contents.	( traceLevel &gt;= 3 ) ifTrue:		[ (self traceStream)                        print: rc;  nextPutAll: ' = ct_res_info( cmd = ';			nextPutAll: (self cmd referentAddress printStringRadix: 16);			nextPutAll: ', infoType='; print: infoType;			nextPutAll: ', pResInfo=';			nextPutAll: (pResInfo referentAddress printStringRadix: 16);			nextPutAll: ', buflen=CS_UNUSED, outlen=NULL';			nextPutAll: ' )'; crtab;			nextPutAll: 'result= '; print: resInfo.		self class trace: self emitTrace ].	"End unwind protection." ]		ensure:			[ pResInfo == nil ifFalse: [ pResInfo freePointer ] ].		(rc == xif CS_SUCCEED) ifFalse:		[ "Report the error detected."		errs := self class connectionClass errorsOnQueue: self conn referentAddress.		^self class connectionClass externalDatabaseErrorSignal raiseWith: errs errorString: errs first dbmsErrorString.	].	^resInfo</body><body package="CTLibEXDI">moreResultsExternal	"Call getResultsExternal in a loop, ignoring those results which are not in interesting to us.	 Return true if we have results pending.	 Return false in case when have no results pending or in case of errors."	| xif err rc |	xif := self class xif.	rowCount := 0.	[ "repeat block"	rc := self getResultsExternal.	rc ==  xif CS_END_RESULTS  ifTrue: "-205" 		[self cancelExternal.		 err := self class connectionClass errorsOnQueue: self conn referentAddress.		 (err size &gt; 0) ifTrue: 			[^self class connectionClass unableToExecuteSQLSignal raiseWith: err errorString: err first dbmsErrorString]].	(rc == xif CS_SUCCEED) ifFalse: [^false].			"Get number of affected rows if it's available and cach it"	( res_type == xif CS_CMD_SUCCEED or:	[ res_type == xif CS_CMD_DONE ] ) ifTrue:		[ rowCount := (self getResultsInfoExternal: xif CS_ROW_COUNT) ].	"Check the result type"	"server encountered an error, no results available"	(res_type == xif CS_CMD_FAIL) ifTrue:		[self cancelExternal.		err := self class connectionClass errorsOnQueue: self conn referentAddress.		self class connectionClass unableToExecuteSQLSignal raiseWith: err errorString: err first dbmsErrorString.		^false ].		"success of a statement that returns no data when not using a cursor)."	(self useCursor not and: [res_type == xif CS_CMD_SUCCEED]) ifTrue:		[ ^true ].		"fetchable results"	( res_type == xif CS_ROW_RESULT or:	[ res_type == xif CS_COMPUTE_RESULT or:	[ res_type == xif CS_CURSOR_RESULT or:	[ res_type == xif CS_PARAM_RESULT ] ] ]) ifTrue:			[ ^true ].	"status results for a stored procedure: retrive and store it"	(res_type == xif CS_STATUS_RESULT) ifTrue:		[ self getReturnStatusExternal ].			"other information available: for now, just ignore it"	( res_type == xif CS_ROWFMT_RESULT or:	[ res_type == xif CS_COMPUTEFMT_RESULT or:	[ res_type == xif CS_MSG_RESULT or:	[ res_type == xif CS_DESCRIBE_RESULT ] ] ] ) ifTrue:		[ ( traceLevel &gt;= 2 ) ifTrue:			[ (self traceStream) nextPutAll: 'Ignoring some informational results...'.			self class trace: self emitTrace ] ].		] repeat</body><body package="CTLibEXDI">readyExternal	"For now, we are not using asynchrnous query execution."	^true</body><body package="CTLibEXDI">resultsExternal	^self moreResultsExternal</body><body package="CTLibEXDI">setTextLimitExternal	"Set the text limit and execute an empty query so that the values are propagated to the server."	connection setTextLimit: self textLimit.	"Execute an empty query to force the setting to the server."	self		prepare: '/* SET TEXTLIMIT */';		execute;		answer; answer</body></methods><methods><class-id>Database.CTLibSession</class-id> <category>private-binding</category><body package="CTLibEXDI">bindExternal	"Sybase doesn't really have a prepare concept, so the query	assembled here isn't sent to the server until we actually execute."	| xif expandedQuery expandedQuery1 pExpandedQuery rc err |	self useCursor ifTrue: [ ^self createCursorExternal ].	xif := self class xif.	"Remove any prior return information."	self returnStatus: nil.	"Rebuild a query from the query fragments, expanding bind parameters in-line."	queryFragments size == 1		ifTrue:	[ expandedQuery := queryFragments at: 1 ]		ifFalse:	[ | queryStream |				queryStream := WriteStream on: (String new: query size).				queryStream nextPutAll: (queryFragments at: 1).				2 to: queryFragments size by: 2 do:					[ :index | | bindOp value |					bindOp := queryFragments at: index.					(value := self inBindInputAt: bindOp) isNil						ifTrue:	[ queryStream nextPutAll: 'NULL' ]						ifFalse:	[ value printOnForCTLib: queryStream ].					queryStream nextPutAll: (queryFragments at: index + 1) ].				expandedQuery := queryStream contents ].	"Give the expanded query text to the CT-Library."	[ "Begin unwind protection"	expandedQuery1 := expandedQuery asByteArrayEncoding: xif encoding.	pExpandedQuery := expandedQuery1 perform: xif copyToHeapSelector.	rc := xif ct_command: self cmd			with: xif CS_LANG_CMD			with: pExpandedQuery			with: expandedQuery1 size			with: xif CS_UNUSED.	( traceLevel &gt;= 1 ) ifTrue:		[ (self traceStream)                        print: rc;  nextPutAll: ' = ct_command( cmd=';			nextPutAll: (self cmd referentAddress printStringRadix: 16);			nextPutAll: ', query='; nextPutAll: expandedQuery;			nextPutAll: ', buflen='; print: expandedQuery1 size;			nextPutAll: ', option=CS_UNUSED)'.		self class trace: self emitTrace ].	"End unwind protection" ]		ensure:			[ pExpandedQuery notNil ifTrue: [ pExpandedQuery freePointer ] ].	(rc == xif CS_SUCCEED) ifFalse:			[ err := self class connectionClass errorsOnQueue: self conn referentAddress.		self class connectionClass unableToExecuteSQLSignal raiseWith: err errorString: err first dbmsErrorString ]</body><body package="CTLibEXDI">bindExternal: aValue at: position	"CTLib does not implement real binding."	^self shouldNotImplement</body><body package="CTLibEXDI">prepareExternal	"The CT-Library does not really have a prepare concept."	"The query text is not given to the CT-Library until ready to execute	so that host variable references may be substituted into the query text."	self idleStatus: false</body></methods><methods><class-id>Database.CTLibSession</class-id> <category>private-finalization</category><body package="CTLibEXDI">executor	| ex |	ex := super executor.	ex cmdHolder: self cmdHolder.	ex useCursor: self useCursor.	ex scrollable: self scrollable.	ex idleStatus: self idleStatus.	^ex</body><body package="CTLibEXDI">finalizeExternal	(self cmd isNil or: [self cmd referentAddress isNil]) ifTrue:		[ ^self ].	( traceLevel &gt;= 1 ) ifTrue:		[ self class trace: nil ].	super finalizeExternal</body><body package="CTLibEXDI">key	"The cmdHolder is unique to the session and is constant across pause/resume."	^cmdHolder</body></methods><methods><class-id>Database.CTLibSession</class-id> <category>accessing</category><body package="CTLibEXDI">cursorName	"Answer the cursor name associated with receiver."	^cursorName</body><body package="CTLibEXDI">cursorName: aString	"Set the cursor name associated with receiver."	cursorName := aString</body><body package="CTLibEXDI">getCursorName	"Answer the cursor name associated with receiver."	| xif rc curName pCursorName err |	xif := self class xif.		["Begin unwind protection."	pCursorName := xif CS_TEXT perform: xif mallocSelector with: xif CS_MAX_NAME.	rc := xif ct_cmd_props: self cmd			with: xif CS_GET			with: xif CS_CUR_NAME			with: pCursorName			with: xif CS_MAX_NAME			with: nil.	( traceLevel &gt;= 1 ) ifTrue:		[ (self traceStream)                        print: rc;  nextPutAll: ' = ct_cmd_props( cmd=';			nextPutAll: (self cmd referentAddress printStringRadix: 16);			nextPutAll: ', action=CS_GET)';			nextPutAll: ', property=CS_CUR_NAME)';			nextPutAll: ', query='; nextPutAll: (pCursorName referentAddress printStringRadix: 16);			nextPutAll: ', buflen=CS_MAX_NAME)';			nextPutAll: ', outlen=nil)'.		self class trace: self emitTrace ].	(rc == xif CS_SUCCEED) ifFalse:			[ err := self class connectionClass errorsOnQueue: self conn referentAddress.		self class connectionClass unableToExecuteSQLSignal raiseWith: err errorString: err first dbmsErrorString ].	curName := pCursorName copyCStringFromHeap.	"End unwind protection" ]		ensure:			[ pCursorName notNil ifTrue: [ pCursorName freePointer ] ].	^curName</body><body package="CTLibEXDI">getCursorStatus	"Answer the cursor name associated with receiver."	| xif rc curStatus pCursorStatus err |	xif := self class xif.		["Begin unwind protection."	pCursorStatus := xif CS_INT perform: xif mallocSelector with: 1.	rc := xif ct_cmd_props: self cmd			with: xif CS_GET			with: xif CS_CUR_STATUS			with: pCursorStatus			with: xif CS_UNUSED			with: nil.	( traceLevel &gt;= 1 ) ifTrue:		[ (self traceStream)                        print: rc;  nextPutAll: ' = ct_cmd_props( cmd=';			nextPutAll: (self cmd referentAddress printStringRadix: 16);			nextPutAll: ', action=CS_GET)';			nextPutAll: ', property=CS_CUR_STATUS)';			nextPutAll: ', query='; nextPutAll: (pCursorStatus referentAddress printStringRadix: 16);			nextPutAll: ', buflen=CS_MAX_NAME)';			nextPutAll: ', outlen=nil)'.		self class trace: self emitTrace ].	(rc == xif CS_SUCCEED) ifFalse:			[ err := self class connectionClass errorsOnQueue: self conn referentAddress.		self class connectionClass unableToExecuteSQLSignal raiseWith: err errorString: err first dbmsErrorString ].	curStatus := pCursorStatus contents.	"End unwind protection" ]		ensure:			[ pCursorStatus notNil ifTrue: [ pCursorStatus freePointer ] ].	^curStatus</body><body package="CTLibEXDI">isCursorOpen	"Answer whether the cursor associated with the session is open."	| xif updatableFlag |	xif := self class xif.	updatableFlag := xif CS_CURSTAT_OPEN.	^(self getCursorStatus bitAnd: updatableFlag) = updatableFlag</body><body package="CTLibEXDI">isCursorScrollable	"Answer whether the cursor associated with the session is scrollable."	| xif updatableFlag |	xif := self class xif.	updatableFlag := xif CS_CURSTAT_SCROLLABLE.	^(self getCursorStatus bitAnd: updatableFlag) = updatableFlag</body><body package="CTLibEXDI">isCursorUpdatable	"Answer whether the cursor associated with the session is updatable."	| xif updatableFlag |	xif := self class xif.	updatableFlag := xif CS_CURSTAT_UPDATABLE.	^(self getCursorStatus bitAnd: updatableFlag) = updatableFlag</body><body package="CTLibEXDI">returnStatus	"Answer the status of the stored procedure.  This will answer nil	unless the command just executed was a stored procedure."	^returnStatus</body><body package="CTLibEXDI">scrollable: aBoolean	"Determines whether the cursor is scrollable or not."	aBoolean ifTrue: [		self hasScrollableCursorSupport ifTrue: [			self useCursor: true.			scrollable := true.		] ifFalse: [			self connection class unsupportedCursorTypeSignal raiseRequest.			scrollable := false.		].	] ifFalse: [		self useCursor: true.		scrollable := false.	].</body><body package="CTLibEXDI">textLimit	"Answer the current setting of the text limit.  A nil value indicates that the	default limit should be used."	^textLimit</body><body package="CTLibEXDI">textLimit: anInteger	"Set both CS_TEXTLIMIT for client and CS_OPT_TEXTSIZE for server.	They define the largest text/image size to be returned on the connection.	This method prepares and executes a query against the session."	textLimit := anInteger.	self setTextLimitExternal</body><body package="CTLibEXDI">useCursor	^useCursor</body><body package="CTLibEXDI">useCursor: anObject	useCursor := anObject</body></methods><methods><class-id>Database.CTLibSession</class-id> <category>private-answer set</category><body package="CTLibEXDI">aboutToAnswer	"Do last-minute work before fetching data from an answer set"	totalRows := 0.	rowsInBlock := 0.	currentRowIndex := 0</body><body package="CTLibEXDI">advanceExternal	"Advance to the next row in the block buffer.  If the buffer is exhausted, refill it and continue."	| xif |	xif := self class xif.	(cursorFlag == xif CS_CURSOR_AFTER_LAST) ifTrue: [^nil].	(self currentRowIndex between: 0 and: self rowsInBlock)		ifTrue: [self currentRowIndex: self currentRowIndex + 1].	"Return nil if no more rows will be found ..."	(self rowsInBlock = 0		ifTrue: [self currentRowIndex = 1 ifFalse: [^nil] ifTrue: [true]]		ifFalse: [self currentRowIndex &gt; self rowsInBlock])			ifTrue:				[| rc |				(self rowsInBlock &lt; self blockFactor and: [self rowsInBlock &gt; 0])					ifTrue: [^nil].						self scrollable ifTrue: [					rc := self getBlockOfRowsExternal: xif CS_NEXT offset: xif CS_UNUSED				] ifFalse: [					rc := self getBlockOfRowsExternal				].				self cursorFlag: rc. 				((rc == xif CS_CURSOR_BEFORE_FIRST) or: [ rc == xif CS_CURSOR_AFTER_LAST ]) ifTrue: [ 					self rowsInBlock: 0.					self blockFactor == 1 ifTrue: [self currentRowIndex: 1].					^nil 				].				(self rowsInBlock &lt;= 0)					ifTrue: [^nil].				self currentRowIndex: 1].</body><body package="CTLibEXDI">advanceExternal: fetchOrientation offset: fetchOffset	"Advance to the next row in the block buffer.  If the buffer is exhausted,	refill it and continue."	| xif |	self scrollable ifFalse: [		self connection class unsupportedCursorTypeSignal raiseRequest.		^nil	].	xif := self class xif.	((self cursorFlag == xif CS_CURSOR_AFTER_LAST) and: [fetchOrientation == self fetchNextMode ]) ifTrue: [^nil].	((self cursorFlag == xif CS_CURSOR_BEFORE_FIRST) and: [fetchOrientation == self fetchPriorMode ]) ifTrue: [^nil].	fetchOrientation == self fetchNextMode ifTrue: [		self currentRowIndex: (self currentRowIndex + 1).	] ifFalse: [		fetchOrientation == self fetchPriorMode ifTrue: [			self currentRowIndex &gt; 0  ifTrue: [ self currentRowIndex: (self currentRowIndex - 1) ].		] ifFalse: [			fetchOrientation == self fetchAbsoluteMode ifTrue: [				self currentRowIndex: (self blockFactor + 2).				self rowsInBlock: (self blockFactor + 1).			] ifFalse: [				fetchOrientation == self fetchRelativeMode ifTrue: [					self currentRowIndex: (self currentRowIndex + fetchOffset).				].			].		].	].	((self currentRowIndex &gt; self rowsInBlock) or: [ self currentRowIndex &lt;= 0 ])		ifTrue:	[ | rc |				rc := self getBlockOfRowsExternal: fetchOrientation offset: fetchOffset.				cursorFlag := rc.				((rc == xif CS_CURSOR_BEFORE_FIRST) or: [ rc == xif CS_CURSOR_AFTER_LAST ]) ifTrue: [ 					self rowsInBlock: 0.					self blockFactor == 1 ifTrue: [self currentRowIndex: 1].					^nil 				].				self rowsInBlock &lt;= 0					ifTrue:	[ ^nil		"No more rows will be found" ].					fetchOrientation == self fetchPriorMode ifTrue: [						self currentRowIndex: self rowsInBlock.					] ifFalse: [						self currentRowIndex: 1.					].			].	^self</body><body package="CTLibEXDI">allocateRowBufferExternal: aColumn	"Allocate an CTLibBuffer to receive data for aColumn.  Answer the buffer."	| xif colDescr buffer rc err |	xif := self class xif.	colDescr := columnDescriptions at: aColumn.		[ "Begin unwind protection."	"Get a buffer, allocate space for it, and initialize"	buffer := self class bufferClass		elementSize: ( (xif class fetchBufferSize at: colDescr type) value: colDescr maxColumnConstraint )		count: self blockFactor		databaseType: colDescr type.	(buffer mallocUsing: xif mallocSelector) ifFalse:		[ ^self class connectionClass unableToBindSignal raise ].	buffer dataFmtPointer memberAt: #datatype put: (xif class fSqlTypeFromConversionMap at: colDescr type).	buffer dataFmtPointer memberAt: #format put: (xif CS_FMT_UNUSED).	buffer dataFmtPointer memberAt: #maxlength put:		( (xif class fetchBufferSize at: colDescr type) value: colDescr maxColumnConstraint ).	" clear scale and precision (malloc doesn't guarantee they are zero, which Sybase needs)"	((colDescr fSqlType == xif CS_MONEY_TYPE) or: [ colDescr fSqlType == xif CS_MONEY4_TYPE ]) ifTrue: [ 		buffer dataFmtPointer memberAt: #scale put: 4. 		buffer dataFmtPointer memberAt: #precision put: buffer elementSize	] ifFalse:[		buffer dataFmtPointer memberAt: #scale put: 0.		buffer dataFmtPointer memberAt: #precision put: 0	].	buffer dataFmtPointer memberAt: #count put: self blockFactor.	buffer dataFmtPointer memberAt: #locale put: nil.	rc := xif ct_bind: self cmd			with: aColumn			with: buffer dataFmtPointer			with: buffer pointer			with: buffer lengthsPointer			with: buffer indicatorsPointer.			( traceLevel &gt;= 3) ifTrue:		[ (self traceStream)			print: rc;  nextPutAll: ' = ct_bind( cmd=';			nextPutAll: (self cmd referentAddress printStringRadix: 16);			nextPutAll: ', aColumn =';  print: aColumn;			nextPutAll: ', dataFmtPointer =';			nextPutAll: (buffer dataFmtPointer referentAddress printStringRadix: 16);			nextPutAll: ', buffer =';			nextPutAll: (buffer pointer referentAddress printStringRadix: 16);			nextPutAll: ', lengthsPointer =';			nextPutAll: (buffer lengthsPointer referentAddress printStringRadix: 16);			nextPutAll: ', indicatorsPointer =';			nextPutAll: (buffer indicatorsPointer referentAddress printStringRadix: 16);			nextPutAll:  ' )'; cr.		self class trace: self emitTrace ].	(rc == xif CS_SUCCEED) ifFalse:		[ buffer free.		err := self class connectionClass errorsOnQueue: self conn referentAddress.		^self class connectionClass unableToBindSignal raiseWith: err errorString: err first dbmsErrorString ].		"End unwind protection." ]		ifCurtailed:			[ buffer isNil ifFalse:				[ buffer free.				buffer := nil ] ].	^buffer</body><body package="CTLibEXDI">answerStreamDismissed	"Note that the answer stream has dismissed itself."	self idleStatus: true.	self answerStream: nil</body><body package="CTLibEXDI">cancelAnswerSetExternal	"Cancel current answer set from the server."	| xif stateTemp rc err |	stateTemp := self state.	( stateTemp == #new or:	[ stateTemp == #paused or:	[ self cmd  isNil ] ] ) ifTrue:		[ ^self ].     xif := self class xif.	(self useCursor and: [ self isCursorOpen ]) ifTrue: [ self closeCursorExternal ].	"Interrupt the processing of only the current query."	rc := xif ct_cancel: nil			with: self cmd			with: xif CS_CANCEL_CURRENT.	( traceLevel &gt;= 2 ) ifTrue:		[ self traceStream print: rc;  nextPutAll: ' = ct_cancel( nil, cmd='.		self traceStream nextPutAll: (self cmd referentAddress printStringRadix: 16).		self traceStream nextPutAll: ', type=CS_CANCEL_CURRENT )'.		self class trace: self emitTrace ].	res_type := 0.	(rc == xif CS_SUCCEED) ifFalse:			[ err := self class connectionClass errorsOnQueue: self conn referentAddress.		self class connectionClass externalDatabaseErrorSignal raiseWith: err errorString: err first dbmsErrorString ].</body><body package="CTLibEXDI">describeAnswerColumns	"Fill in the columnDescriptions array."	| xif descrs columnDescriptionClass rc colDesc pDataFmt |	xif := self class xif.	self numColumns: (self getResultsInfoExternal: xif CS_NUMDATA).	descrs := Array new: self numColumns.	columnDescriptionClass := self connection class columnDescriptionClass.	[ "Begin unwind protection."	pDataFmt := xif CS_DATAFMT perform: xif mallocSelector with: 1.	1 to: self numColumns do:		[ :aColumn |		rc := xif ct_describe: self cmd				with: aColumn				with: pDataFmt.		( traceLevel &gt;= 3) ifTrue:			[ (self traceStream)				print: rc;  nextPutAll: ' = ct_describe( cmd=';				nextPutAll: (self cmd referentAddress printStringRadix: 16);				nextPutAll: ', aColumn =';  print: aColumn;				nextPutAll: ', pDataFmt =';				nextPutAll: (pDataFmt referentAddress printStringRadix: 16);				nextPutAll:  ' )'; crtab;				nextPutAll:  'name = ';				nextPutAll: (pDataFmt memberAt: #name) copyCStringFromHeap;				nextPutAll:  ', namelen = ';  print: (pDataFmt memberAt: #namelen);				nextPutAll:  ', datatype = ';  print: (pDataFmt memberAt: #datatype);				nextPutAll:  ', maxlength = ';  print: (pDataFmt memberAt: #maxlength);				nextPutAll:  ', scale = '; print: (pDataFmt memberAt: #scale);				nextPutAll:  ', precision ='; print: (pDataFmt memberAt: #precision);				nextPutAll:  ', status ='; print: (pDataFmt memberAt: #status).			self class trace: self emitTrace ].		(rc == xif CS_SUCCEED) ifFalse:			[ | errs |		  	errs := self class connectionClass errorsOnQueue: self conn referentAddress.			^self class connectionClass unableToDescribeSignal raiseWith: errs errorString: errs first dbmsErrorString ].		(colDesc := columnDescriptionClass new)			index: aColumn;			name: ( (pDataFmt memberAt: #namelen) == 0					ifTrue: [ '' ]					ifFalse: [(pDataFmt memberAt: #name) copyCStringFromHeap] );			fSqlType: (pDataFmt memberAt: #datatype);			type: (xif class fSqlTypeToConversionMap at: colDesc fSqlType);			maxColumnConstraint: (pDataFmt memberAt: #maxlength);			scale: (pDataFmt memberAt: #scale);			precision: (pDataFmt memberAt: #precision);			nullable: ( ((pDataFmt memberAt: #status) bitAnd: xif CS_CANBENULL) ~= 0 ).		descrs at: aColumn put: colDesc ]	"End unwind protection." ]		ensure:			[ pDataFmt notNil ifTrue: [ pDataFmt freePointer ] ].	self columnDescriptions: descrs</body><body package="CTLibEXDI">getBlockOfRowsExternal	"Fetch the next block of rows into the memory allocated for this purpose."	| xif rc err |		xif := self class xif.	( pRowsFetched isNil ) ifTrue:		[ pRowsFetched := xif CS_INT perform: xif mallocSelector with: 1 ].	pRowsFetched contents: 0.	rc := xif ct_fetch: self cmd			with: xif CS_UNUSED			with: xif CS_UNUSED			with: xif CS_UNUSED			with: pRowsFetched.	( traceLevel &gt;= 3 ) ifTrue:		[ (self traceStream)			print: rc;  nextPutAll: ' = ct_fetch( cmd = ';			nextPutAll: (self cmd referentAddress printStringRadix: 16);			nextPutAll: ', type=CS_UNUSED, offset=CS_UNUSED, option=CS_UNUSED, ptr_rows_read=';			nextPutAll: (pRowsFetched referentAddress printStringRadix: 16);			nextPutAll: ' )'; crtab;			nextPutAll: 'rows_read='; print: pRowsFetched contents.		self class trace: self emitTrace ].	rowsInBlock := pRowsFetched contents.	( (rc == xif CS_ROW_FAIL) or: [rc == xif CS_FAIL] ) ifTrue:		[ err := self class connectionClass errorsOnQueue: self conn referentAddress.		self class connectionClass unableToFetchDataSignal raiseWith: err errorString: err first dbmsErrorString.		^self ].	totalRows :=  totalRows + rowsInBlock</body><body package="CTLibEXDI">getBlockOfRowsExternal: fetchOrientation offset: fetchOffset	"Fetch the next block of rows into the memory allocated for this purpose."	| xif rc err newFetchMode newOffset |		xif := self class xif.		fetchOrientation == self fetchPriorMode ifTrue: [		newFetchMode := self fetchRelativeMode.		self cursorFlag == xif CS_CURSOR_AFTER_LAST ifTrue: [			newOffset := 0 - self blockFactor		] ifFalse: [			newOffset := self currentRowIndex- self blockFactor		].	] ifFalse: [		fetchOrientation == self fetchRelativeMode ifTrue: [			newFetchMode := fetchOrientation.			self currentRowIndex: (self currentRowIndex - fetchOffset).			newOffset := fetchOffset + self currentRowIndex - 1.		] ifFalse: [			newFetchMode := fetchOrientation.			newOffset := fetchOffset.		].	].	( pRowsFetched isNil ) ifTrue:		[ pRowsFetched := xif CS_INT perform: xif mallocSelector with: 1 ].	pRowsFetched contents: 0.	rc := xif ct_scroll_fetch: self cmd			with: newFetchMode			with: newOffset			with: xif CS_TRUE			with: pRowsFetched.	( traceLevel &gt;= 3 ) ifTrue:		[ (self traceStream)			print: rc;  nextPutAll: ' = ct_scroll_fetch( cmd = ';			nextPutAll: (self cmd referentAddress printStringRadix: 16);			nextPutAll: ', type = '; print: newFetchMode;			nextPutAll: ', offset = '; print: newOffset;			nextPutAll: ', option=CS_TRUE, ptr_rows_read=';			nextPutAll: (pRowsFetched referentAddress printStringRadix: 16);			nextPutAll: ' )'; crtab;			nextPutAll: 'rows_read='; print: pRowsFetched contents.		self class trace: self emitTrace ].	( (rc == xif CS_ROW_FAIL) or: [rc == xif CS_FAIL] ) ifTrue:		[ err := self class connectionClass errorsOnQueue: self conn referentAddress.		self class connectionClass unableToFetchDataSignal raiseWith: err errorString: err first dbmsErrorString.		^self ].		( (rc == xif CS_CURSOR_BEFORE_FIRST) or: [rc == xif CS_CURSOR_AFTER_LAST] ) ifTrue: [ ^rc ].	rowsInBlock := pRowsFetched contents.</body><body package="CTLibEXDI">getColumnDescriptionExternal: aColumn	"Folded into describeAnswerColumns for efficiency."	^self shouldNotImplement</body><body package="CTLibEXDI">getFieldExternal: aColumn	"Answer the data for the aColumn-th column in the current row."	| buffer rowIndex |	buffer := (self rowBuffers) at: aColumn.	rowIndex := (currentRowIndex - 1) \\ self blockFactor.	^buffer at: (rowIndex + 1)</body><body package="CTLibEXDI">getReturnStatusExternal	"Get return status after a stored procedure is been executed.	 Fetch it in the same manner as we fetch regular rows."		| xif err buf descrs colDesc |	xif := self class xif.	"allocate buffer to fetch the return status"	self numColumns: 1.	descrs := Array new: 1.	(colDesc := self connection class columnDescriptionClass  new)		index: 1;		name: '';		fSqlType: xif CS_INT_TYPE;		type: #Integer;		maxColumnConstraint: 4;		scale: 0;		precision: 0;		nullable: false.	descrs at: 1 put: colDesc.	self columnDescriptions: descrs.	buf := self allocateRowBufferExternal: 1.	" begin ensure block to free buffer properly "	[		self getBlockOfRowsExternal.		self returnStatus: (buf at: 1).		"Clear columnDescriptions for next read"		self columnDescriptions: nil.		self numColumns: nil.				"need one extra read as required by CT-Lib"		self getBlockOfRowsExternal.		( traceLevel &gt;= 2 ) ifTrue:		[ (self traceStream) nextPutAll: 'returnStatus = '; print: self returnStatus.		self class trace: self emitTrace ].		"Check if stored procedure executed successfully."		self returnStatus &lt; 0 ifTrue:		[ err := self class connectionClass errorsOnQueue: self conn referentAddress.		self class connectionClass unableToExecuteSQLSignal raiseWith: err errorString: err first dbmsErrorString ]] 		ensure:[ buf isNil ifFalse: [ buf free]].</body><body package="CTLibEXDI">hasAnswerSetExternal	"If the query resulted in an answer set, answer true; else answer false."	| xif |		xif := self class xif.			( res_type == xif CS_ROW_RESULT or:	[ res_type == xif CS_CURSOR_RESULT or:	[ res_type == xif CS_COMPUTE_RESULT or:	[ res_type == xif CS_PARAM_RESULT ] ] ]) ifTrue:		[ ^true ].			^false</body><body package="CTLibEXDI">nextRowExternal	"Answer the next row from the answer stream"	( self advanceExternal == nil ) ifTrue:		[ "We've exhausted the answer set.  No DBMS cancel is necessary."		self state: #validResults.		^nil ].		"If we have a resultTemplate, use it to provide the answer."	( resultTemplate == nil ) ifFalse:		[ bufferIndex := 1.		^self nextViaTemplate: resultTemplate ].	allocateForEachRow ifTrue:		[ currentRow := currentRow copy ].	1 to: (self columnDescriptions size) do:		[ :index |		(rowAdaptors at: index) value: currentRow value: (self getFieldExternal: index) ].	^currentRow</body><body package="CTLibEXDI">releaseBuffers	"Release buffers and their associated resources."	| rbs |	(rbs := self rowBuffers) notNil ifTrue: [1 to: rbs size			do: 				[:i | 				(rbs at: i) notNil ifTrue: [(rbs at: i) free].				rbs at: i put: nil]].	"added for checking"	super releaseBuffers</body></methods><methods><class-id>Database.CTLibSession</class-id> <category>data processing</category><body package="CTLibEXDI">rowCount	"Answer the count of rows that Sybase claims was affected by this query."	^rowCount</body></methods><methods><class-id>Database.CTLibSession</class-id> <category>private-cursor</category><body package="CTLibEXDI">closeCursorExternal	"Sybase doesn't really have a prepare concept, so the query	assembled here isn't sent to the server until we actually execute."	| xif rc err |	self idleStatus ifTrue:[ ^self ].		xif := self class xif.	"Give the expanded query text to the CT-Library."	rc := xif ct_cursor: self cmd			with: xif CS_CURSOR_CLOSE			with: nil			with: xif CS_UNUSED			with: nil			with: xif CS_UNUSED			with: xif CS_DEALLOC.	( traceLevel &gt;= 1 ) ifTrue:		[ (self traceStream)                        print: rc;  nextPutAll: ' = ct_cursor( cmd=';			nextPutAll: (self cmd referentAddress printStringRadix: 16);			nextPutAll: ', type=CS_CURSOR_CLOSE)';			nextPutAll: ', name=NULL';			nextPutAll: ', namelen=CS_UNUSED';			nextPutAll: ', query=NULL';			nextPutAll: ', buflen=CS_UNUSED';			nextPutAll: ', option=CS_DEALLOC)'.		self class trace: self emitTrace ].	(rc == xif CS_SUCCEED) ifFalse:			[ err := self class connectionClass errorsOnQueue: self conn referentAddress.		self class connectionClass unableToExecuteSQLSignal raiseWith: err errorString: err first dbmsErrorString ].	self executeExternal.	self resultsExternal.		self idleStatus: true.</body><body package="CTLibEXDI">createCursorExternal	"Sybase doesn't really have a prepare concept, so the query	assembled here isn't sent to the server until we actually execute."	| xif expandedQuery expandedQuery1 pExpandedQuery rc err curName cursorType |	xif := self class xif.	"Remove any prior return information."	self returnStatus: nil.	"Rebuild a query from the query fragments, expanding bind parameters in-line."	queryFragments size == 1		ifTrue:	[ expandedQuery := queryFragments at: 1 ]		ifFalse:	[ | queryStream |				queryStream := WriteStream on: (String new: query size).				queryStream nextPutAll: (queryFragments at: 1).				2 to: queryFragments size by: 2 do:					[ :index | | bindOp value |					bindOp := queryFragments at: index.					(value := self inBindInputAt: bindOp) isNil						ifTrue:	[ queryStream nextPutAll: 'NULL' ]						ifFalse:	[ value printOnForCTLib: queryStream ].					queryStream nextPutAll: (queryFragments at: index + 1) ].				expandedQuery := queryStream contents ].	self scrollable ifTrue: [ cursorType := xif CS_SCROLL_CURSOR ] ifFalse: [ cursorType := xif CS_FOR_UPDATE ].	(curName := self cursorName) isNil ifTrue: [ 		curName := 'Cursor', (self cmd referentAddress printStringRadix: 16).		self cursorName:  curName.	].	"Give the expanded query text to the CT-Library."	[ "Begin unwind protection"	expandedQuery1 := expandedQuery asByteArrayEncoding: xif encoding.	pExpandedQuery := expandedQuery1 perform: xif copyToHeapSelector.	rc := xif ct_cursor: self cmd			with: xif CS_CURSOR_DECLARE			with: curName			with: curName size			with: pExpandedQuery			with: expandedQuery1 size			with: cursorType.	( traceLevel &gt;= 1 ) ifTrue:		[ (self traceStream)                        print: rc;  nextPutAll: ' = ct_cursor( cmd=';			nextPutAll: (self cmd referentAddress printStringRadix: 16);			nextPutAll: ', type=CS_CURSOR_DECLARE)';			nextPutAll: ', name='; nextPutAll: cursorName;			nextPutAll: ', namelen='; print: cursorName size;			nextPutAll: ', query='; nextPutAll: expandedQuery;			nextPutAll: ', buflen='; print: expandedQuery1 size;			nextPutAll: ', option=)'; print: cursorType;			nextPutAll:  ' )'; cr.		self class trace: self emitTrace ].	(rc == xif CS_SUCCEED) ifFalse:			[ err := self class connectionClass errorsOnQueue: self conn referentAddress.		self class connectionClass unableToExecuteSQLSignal raiseWith: err errorString: err first dbmsErrorString ].	rc := xif ct_cursor: self cmd			with: xif CS_CURSOR_ROWS			with: nil			with: xif CS_UNUSED			with: nil			with: xif CS_UNUSED			with: self blockFactor.	( traceLevel &gt;= 1 ) ifTrue:		[ (self traceStream)                        print: rc;  nextPutAll: ' = ct_cursor( cmd=';			nextPutAll: (self cmd referentAddress printStringRadix: 16);			nextPutAll: ', type=CS_CURSOR_ROWS)';			nextPutAll: ', name=NULL';			nextPutAll: ', namelen=CS_UNUSED';			nextPutAll: ', query=NULL';			nextPutAll: ', buflen=CS_UNUSED';			nextPutAll: ', option=)'; print: self blockFactor;			nextPutAll:  ' )'; cr.		self class trace: self emitTrace ].	(rc == xif CS_SUCCEED) ifFalse:			[ err := self class connectionClass errorsOnQueue: self conn referentAddress.		self class connectionClass unableToExecuteSQLSignal raiseWith: err errorString: err first dbmsErrorString ].	rc := xif ct_cursor: self cmd			with: xif CS_CURSOR_OPEN			with: nil			with: xif CS_UNUSED			with: nil			with: xif CS_UNUSED			with: xif CS_UNUSED.	( traceLevel &gt;= 1 ) ifTrue:		[ (self traceStream)                        print: rc;  nextPutAll: ' = ct_cursor( cmd=';			nextPutAll: (self cmd referentAddress printStringRadix: 16);			nextPutAll: ', type=CS_CURSOR_OPEN)';			nextPutAll: ', name=NULL';			nextPutAll: ', namelen=CS_UNUSED';			nextPutAll: ', query=NULL';			nextPutAll: ', buflen=CS_UNUSED';			nextPutAll: ', option=CS_UNUSED)'.		self class trace: self emitTrace ].	(rc == xif CS_SUCCEED) ifFalse:			[ err := self class connectionClass errorsOnQueue: self conn referentAddress.		self class connectionClass unableToExecuteSQLSignal raiseWith: err errorString: err first dbmsErrorString ].	"End unwind protection" ]		ensure:			[ pExpandedQuery notNil ifTrue: [ pExpandedQuery freePointer ] ].</body></methods><methods><class-id>Database.CTLibSession</class-id> <category>private-testing</category><body package="CTLibEXDI">hasScrollableCursorSupport	"Answer true is the loaded OCI has scrollable cursor support."	| xifClass testMethod aHandle resultHandle |	xifClass := self class xif class.	testMethod := CTLibInterface compiledMethodAt:#ct_scroll_fetch:with:with:with:with:.	resultHandle := xifClass instanceBehavior libraryFiles		detect: [:aLibrary |			aHandle := testMethod class mapAddressFor: testMethod library: aLibrary.			aHandle notNil]		ifNone:			[ aHandle := testMethod class mapStaticFor: testMethod ].	resultHandle isNil ifTrue: [ ^false ] ifFalse: [ ^true ]</body></methods><methods><class-id>Database.CTLibSession</class-id> <category>initialize-release</category><body package="CTLibEXDI">initialize	super initialize.	cmdHolder := nil asValue.	self useCursor: false.	self cursorFlag: 0.	self idleStatus: false.</body></methods><methods><class-id>Database.CTLibSession class</class-id> <category>accessing</category><body package="CTLibEXDI">bufferClass	"Answer the class to use for bindInput/Output objects associated with receiver."	^CTLibBuffer</body><body package="CTLibEXDI">connectionClass	"Answer the class to use for connection objects associated with receiver."	^CTLibConnection</body></methods><methods><class-id>Database.CTLibSession class</class-id> <category>class initialization</category><body package="CTLibEXDI">initialize	"CTLibSession initialize"		self initRegistry</body></methods><methods><class-id>Database.CTLibSession class</class-id> <category>private-registry</category><body package="CTLibEXDI">registry	"Answer with the registry."	^RegisteredCTLibSessions</body><body package="CTLibEXDI">registry: aCollection	"Record aCollection as the registry."	RegisteredCTLibSessions := aCollection</body></methods><methods><class-id>Database.CTLibLinuxInterface class</class-id> <category>installation notes</category><body package="CTLibEXDI">toInstall	"To compile libsybase.so, change to the $SYBASE/lib directory and execute:	#&gt; ld -o libsybase.so -Bdynamic -G --whole-archive \		libct.a libcomn.a /lib/libc-2.0.7.so libintl.a \		libtcl.a  libinsck.a libcs.a	"	^self error: (#commentOnly &lt;&lt; #sybaseDB &gt;&gt; 'Comment only')</body></methods><methods><class-id>Database.UnableToOpenInterfacesFile</class-id> <category>printing</category><body package="CTLibEXDI">defaultMessageText	^(#unableToOpenInterfacesFile &lt;&lt; #sybaseDB &gt;&gt; 'Connection Exception--unable to open interfaces file') asString</body></methods><methods><class-id>Database.CTLibConnection</class-id> <category>private-library calls</category><body package="CTLibEXDI">acquireExternal: aPassword	"Acquire the external resources involved with a connection"	| uid pwd env env1 errs rc xif pEnv |	self conn isNil ifTrue: [	self initializeExternal ].	self setInterfaceFileExternal.	self setLoginTimeoutExternal.	uid := self username.	[ uid isString ] whileFalse:		[ uid := self class requiredUsernameSignal raiseRequest ].	pwd := aPassword.	[ pwd isString ] whileFalse:		[ pwd := self class requiredPasswordSignal raiseRequest  ].	(env := self environment) isNil ifTrue:		[ env := self class defaultEnvironment ].	[ env isString ] whileFalse:		[ env := self class requiredEnvironmentSignal raiseRequest  ].	env := self class mapLogical: env.	xif := self class xif.	"set properties for connecting"	self setPropsExternal: xif CS_USERNAME string: uid.	self setPropsExternal: xif CS_PASSWORD string: pwd.	self setPropsExternal: xif CS_HOSTNAME string: hostName.	self setPropsExternal: xif CS_APPNAME  string: appName.		self setPropsExternal: xif CS_PACKETSIZE value: self packetSize.		[ "Begin unwind protection (level 1)"	[ "Begin unwind protection (level 2)"	env1 := env asByteArrayEncoding: xif encoding.	pEnv := env1 perform: xif copyToHeapSelector.	rc := xif ct_connect: self conn			with: pEnv			with: env1 size.	( traceLevel &gt;= 2 ) ifTrue:		[ (self traceStream)			print: rc; nextPutAll: ' = ct_connect( conn=';			nextPutAll: (self conn referentAddress printStringRadix: 16);			nextPutAll: ', srv_name=', env;			nextPutAll: ', snamelen='; print: env1 size;			nextPutAll: ' )'.		self class trace: self emitTrace ]	"End unwind protection (level 1)" ]		ensure:			[ pEnv notNil ifTrue: [ pEnv freePointer ].			( rc isNil or:			[ rc == xif CS_SUCCEED ] ) ifFalse:				[ errs := self class errorsOnQueue: self conn referentAddress.				self class unableToConnectToSQLserverSignal raiseWith: errs errorString: errs first dbmsErrorString] ]	"End unwind protection (level 2)" ]		ifCurtailed:			[ self dismissExternal ]</body><body package="CTLibEXDI">beginExternal	"Mark the beginning of receivers portion of a transaction."	"We need to make sure that the currently active session disconnects so that we	can acquire the right to process the BEGIN TRANSACTION statement."	super beginExternal.	self participantsDo: [ :each | each disconnect ].	(self getSession)		prepare: 'BEGIN TRANSACTION ';		execute;		answer;		disconnect</body><body package="CTLibEXDI">commitExternal	"Commit all changes made by receiver conn."	"We need to make sure that the currently active session disconnects so that we	can acquire the right to process the COMMIT TRANSACTION statement."	super commitExternal	ifFalse: [ ^self ].	self participantsDo: [ :each | each disconnect ].	(self getSession)		prepare: 'COMMIT TRANSACTION';		execute;		answer;		disconnect</body><body package="CTLibEXDI">dismissConnExternal	"Release the CTLib connection-related resources."	| rc xif |	( self conn isNil or: [ self conn referentAddress isNil ] ) ifTrue:		[ ^self conn: nil ].	"close  the connection, drop the structure"	xif := self class xif.	rc := xif ct_close: self conn			with: xif CS_FORCE_CLOSE.	( traceLevel &gt;= 1 ) ifTrue:		[ (self traceStream)			print: rc; nextPutAll: ' = ct_close( conn=';			nextPutAll: (self conn referentAddress printStringRadix: 16);			nextPutAll: ', opt=CS_FORCE_CLOSE )'.		self class trace: self emitTrace ].	rc := xif ct_con_drop: self conn.	( traceLevel &gt;= 1 ) ifTrue:		[ (self traceStream)			print: rc; nextPutAll: ' = ct_con_drop( conn=';			nextPutAll: (self conn referentAddress printStringRadix: 16);			nextPutAll: ' )'.		self class trace: self emitTrace ].			self class dismissQueue: self conn referentAddress.	self conn: nil</body><body package="CTLibEXDI">dismissContextExternal	"Release the CTLib context-related resources."		| rc xif |	( self context isNil or: [ self context referentAddress isNil ] ) ifTrue:		[ ^self context: nil ].	xif := self class xif.	rc := xif ct_exit: self context			with: xif CS_FORCE_EXIT.	( traceLevel &gt;= 1 ) ifTrue:		[ (self traceStream)			print: rc; nextPutAll: ' = ct_exit( context=';			nextPutAll: (self context referentAddress printStringRadix: 16);			nextPutAll: ' option=CS_FORCE_EXIT )'.		self class trace: self emitTrace ].	rc := xif cs_ctx_drop: self context.	( traceLevel &gt;= 1 ) ifTrue:		[ (self traceStream)			print: rc; nextPutAll: ' = cs_ctx_drop( context=';			nextPutAll: (self context referentAddress printStringRadix: 16);			nextPutAll: ' )'.		self class trace: self emitTrace ].	self context: nil</body><body package="CTLibEXDI">dismissExternal	"Release the external resources."	"All activity within this method must function with only the instance	variables defined in the executor object."	self dismissConnExternal.	self dismissContextExternal</body><body package="CTLibEXDI">getIntegerPropsExternal: property	"Get the value of property."	| pStatus rc err xif size |		xif := self class xif.	[ 		pStatus := xif CS_INT perform: xif mallocSelector with: 1.		self conn isNil ifTrue: [	self initializeExternal ].		rc := xif ct_con_props: self conn			with: xif CS_GET			with: property			with: pStatus			with: xif CS_UNUSED			with: 0.		( traceLevel &gt;= 3 ) ifTrue:[ 			(self traceStream)				print: rc; nextPutAll: ' = ct_con_props( conn=';				nextPutAll: (self conn referentAddress printStringRadix: 16);				nextPutAll: ', action=CS_GET, property= ';  print: property;				nextPutAll: ', value='; print: (pStatus referentAddress printStringRadix: 16);				nextPutAll: ', length=CS_UNUSED';				nextPutAll: ', outlen=NULL)'.		self class trace: self emitTrace ].		rc == xif CS_SUCCEED ifTrue: [ 			^size := pStatus contents 		] ifFalse: [				err := self class connectionClass errorsOnQueue: self conn referentAddress.				self class externalDatabaseErrorSignal raiseWith: err errorString: err first dbmsErrorString		].	] ensure:	[ pStatus == nil ifFalse: [ pStatus freePointer ]].</body><body package="CTLibEXDI">initializeExternal	"Allocate/initialize CTLib context, set callbacks, allocate CTLib connection."	"Note: performance can be slightly improved by moving context and callbacks	 initialization to the class initialization. Doesn't look like a big gain."		| rc xif pPointer |		xif := self class xif.	self contextHolder: nil asValue.	self connHolder: nil asValue.	[ "Begin unwind protection"	pPointer := xif PTR perform: xif mallocSelector with: 1.	pPointer contents: nil.	"allocate and initialize CTLib context"	rc := xif cs_ctx_alloc: self csVersion				with: pPointer.	( traceLevel &gt;= 1 ) ifTrue:		[ (self traceStream)			print: rc; nextPutAll: ' = ct_ctx_alloc( csVersion=';			print: xif csVersion; nextPutAll: ', pPointer=';			nextPutAll: (pPointer referentAddress printStringRadix: 16);			nextPutAll: ' )'; crtab;			nextPutAll: 'context=';			nextPutAll: (pPointer contents referentAddress printStringRadix: 16).		self class trace: self emitTrace ].	self context: pPointer contents.	rc := xif ct_init: self context			with: self csVersion.	( traceLevel &gt;= 1 ) ifTrue:		[ (self traceStream)			print: rc; nextPutAll: ' = ct_init( context=';			nextPutAll: (self context referentAddress printStringRadix: 16);			nextPutAll: ', version=';			print: xif csVersion; nextPutAll: ')'.		self class trace: self emitTrace ].	"set callbacks for error processing"	self setClientMsgHandlerCB.	self setServerMsgHandlerCB.		"allocate CTLib connection"	pPointer contents: nil.	rc := xif ct_con_alloc: self context			with: pPointer.	( traceLevel &gt;= 1 ) ifTrue:		[ (self traceStream)			print: rc; nextPutAll: ' = ct_con_alloc( context=';			nextPutAll: (self context referentAddress printStringRadix: 16);			nextPutAll: ', pPointer=';			nextPutAll: (pPointer referentAddress printStringRadix: 16);			nextPutAll: ' )'; crtab;			nextPutAll: 'conn=';			nextPutAll: (pPointer contents referentAddress printStringRadix: 16).		self class trace: self emitTrace ].		self conn: pPointer contents.	self class acquireQueue: self conn referentAddress.	"End unwind protection." ]		ensure:			[ pPointer notNil ifTrue: [ pPointer freePointer ].			( rc isNil or:			[ rc ~= xif CS_SUCCEED ] ) ifTrue:				[ self dismissExternal ] ]</body><body package="CTLibEXDI">installExternal	"Perform return from snapshot processing for this conn."	super installExternal.	self conn: nil</body><body package="CTLibEXDI">rollbackExternal	"Rollback all changes made by receiver's conn."	"We need to make sure that the currently active session disconnects so that we	can acquire the right to process the ROLLBACK TRANSACTION statement."	super rollbackExternal	ifFalse:	[ ^self ].	self participantsDo: [ :each | each disconnect ].	(self getSession)		prepare: 'ROLLBACK TRANSACTION';		execute;		answer;		disconnect</body><body package="CTLibEXDI">setClientMsgHandlerCB	"define and set a callback for messages coming from the client"		| rc xif |	xif := self class xif.	"define the callback"	clientMsgHandlerCB := CCallback		do: [ :context :conn :msg |			"ignore warnings"			(msg memberAt: #msgnumber) &gt; 0 ifTrue:				[ self class queue: conn newError:					( CTLibError new						severity: (msg memberAt: #severity);						dbmsErrorCode: (msg memberAt: #msgnumber);						dbmsErrorString: ((msg memberAt: #msgstring) copyCStringFromHeap: xif encoding);						osErrorCode: (msg memberAt: #osnumber);						osErrorString: ((msg memberAt: #osstring) copyCStringFromHeap: xif encoding)) ].			xif CS_SUCCEED "return CS_SUCCEED" ]		ofType: xif clientMsgHandlerType.	"set the callback"	rc := xif ct_callback: self context				with: nil				with: xif CS_SET				with: xif CS_CLIENTMSG_CB				with: clientMsgHandlerCB.	( traceLevel &gt;= 2 ) ifTrue:		[ (self traceStream)			print: rc; nextPutAll: ' = ct_callback( context=';			nextPutAll: (self context referentAddress printStringRadix: 16);			nextPutAll: ', NULL, CS_SET, CS_CLIENTMSG_CB, ..)'.		self class trace: self emitTrace ]</body><body package="CTLibEXDI">setInterfaceFileExternal	"Specify the path of the interfaces file that will be	 searched during subsequent calls to ct_connect()."	| rc xif errs fileName pFileName |	interfaceFileName isNil ifTrue:		[ ^self ].	xif := self class xif.	fileName := interfaceFileName asByteArrayEncoding: xif encoding.		[ "Begin unwind protection (level 1)"	[ "Begin unwind protection (level 2)"	pFileName := fileName perform: xif copyToHeapSelector.		rc := xif ct_config: self context			with: xif CS_SET		    	with: xif CS_IFILE			with: pFileName		    	with: fileName size		    	with: nil.	( traceLevel &gt;= 2 ) ifTrue:		[ (self traceStream)			print: rc; nextPutAll: ' = ct_config( context=';			nextPutAll: (self context referentAddress printStringRadix: 16);			nextPutAll: ', action=CS_SET, property=CS_IFILE, fileName=';			nextPutAll: interfaceFileName;			nextPutAll: ', buflen='; print: fileName size;			nextPutAll: ', outlen=NULL'.		self class trace: self emitTrace ].	"End unwind protection (level 1)" ]		ensure:			[ pFileName notNil ifTrue: [ pFileName freePointer ].			 ( rc isNil or:			 [ rc == xif CS_SUCCEED ] ) ifFalse:				[ errs := self class errorsOnQueue: self conn referentAddress.				self class externalDatabaseErrorSignal raiseWith: errs errorString: errs first dbmsErrorString ] ]	"End unwind protection (level 2)" ]		ifCurtailed:			[ self dismissExternal ]</body><body package="CTLibEXDI">setLoginTimeoutExternal	"Set the length of time in seconds that CT-Library will wait for a login response after	calling ct_connect()."	| rc errs xif pSeconds |		loginTimeoutSeconds isNil ifTrue:		[ ^self ].	xif := self class xif.	[ "Begin unwind protection (level 1)"	[ "Begin unwind protection (level 2)"	pSeconds := xif CS_INT perform: xif mallocSelector with: 1.	pSeconds contents: loginTimeoutSeconds.		rc := xif ct_config: self context			    with: xif CS_SET			    with: xif CS_LOGIN_TIMEOUT			    with: pSeconds			    with: xif CS_UNUSED			    with: nil.	( traceLevel &gt;= 2 ) ifTrue:		[ (self traceStream)			print: rc; nextPutAll: ' = ct_config( context=';			nextPutAll: (self context referentAddress printStringRadix: 16);			nextPutAll: ', action=CS_SET, property=CS_LOGIN_TIMEOUT, seconds='; print: loginTimeoutSeconds;			nextPutAll: ', buflen=CS_UNUSED, outlen=NULL'.		self class trace: self emitTrace ].	"End unwind protection (level 1)" ]		ensure:			[ pSeconds notNil ifTrue: [ pSeconds freePointer ].			 ( rc isNil or:			 [ rc == xif CS_SUCCEED ] ) ifFalse:				[ errs := self class errorsOnQueue: self conn referentAddress.				self class externalDatabaseErrorSignal raiseWith: errs errorString: errs first dbmsErrorString ] ]	"End unwind protection (level 2)" ]		ifCurtailed:			[ self dismissExternal ]</body><body package="CTLibEXDI">setPropsExternal: property string: value	"set a specified string property for the connection structure"	self setPropsExternal: property value: value</body><body package="CTLibEXDI">setPropsExternal: property value: value	"set a specified property for the connection structure"		| rc xif value1 pValue errs bufferLength |	value isNil ifTrue:		[ ^self ].	xif := self class xif.	value isString ifTrue: [		value1 := value asByteArrayEncoding: xif encoding.		bufferLength := value1 size	] ifFalse: [		value1 := value.		bufferLength := xif CS_UNUSED	].	[ "Begin unwind protection (level 1)"	[ "Begin unwind protection (level 2)"	pValue := value1 perform: xif copyToHeapSelector.	self conn isNil ifTrue: [	self initializeExternal ].	rc := xif ct_con_props: self conn			with: xif CS_SET			with: property			with: pValue			with: bufferLength			with: nil.	( traceLevel &gt;= 2 ) ifTrue:		[ (self traceStream)			print: rc; nextPutAll: ' = ct_con_props( conn=';			nextPutAll: (self conn referentAddress printStringRadix: 16);			nextPutAll: ', action=CS_SET, property='; print: property;			nextPutAll: ', value=';			nextPutAll: value printString;			nextPutAll: ', length='; print: ( bufferLength&gt;0 ifTrue: [ bufferLength ] ifFalse: [ 'CS_UNUSED']);			nextPutAll: ', outlen=NULL)'.		self class trace: self emitTrace ].	"End unwind protection (level 1)" ]		ensure:			[ pValue notNil ifTrue: [ pValue freePointer ].			( rc isNil or:			[ rc == xif CS_SUCCEED ] ) ifFalse:				[ errs := self class errorsOnQueue: self conn referentAddress.				self class externalDatabaseErrorSignal raiseWith: errs errorString: errs first dbmsErrorString ] ]	"End unwind protection (level 2)" ]		ifCurtailed:			[ self dismissExternal ]</body><body package="CTLibEXDI">setServerMsgHandlerCB	"define and set a callback for messages coming from the server"		| rc xif |		xif := self class xif.		"define the callback"	serverMsgHandlerCB := CCallback		do: [ :context :conn :msg |			"ignore warnings"			(msg memberAt: #severity) &gt; 10 ifTrue:				[ self class queue: conn newError:					( CTLibError new						dbmsErrorCode: (msg memberAt: #msgnumber);						msgstate: (msg memberAt: #state);						severity: (msg memberAt: #severity);						dbmsErrorString: ((msg memberAt: #text) copyCStringFromHeap: xif encoding);						srvname: ((msg memberAt: #svrname) copyCStringFromHeap: xif encoding);						procname: ((msg memberAt: #proc) copyCStringFromHeap: xif encoding);						line: (msg memberAt: #line) ) ].			xif CS_SUCCEED "return CS_SUCCEED" ]		ofType: xif serverMsgHandlerType.	"set the callback"	rc := xif ct_callback: self context				with: nil				with: xif CS_SET				with: xif CS_SERVERMSG_CB				with: serverMsgHandlerCB.	( traceLevel &gt;= 2 ) ifTrue:		[ (self traceStream)			print: rc; nextPutAll: ' = ct_callback( context=';			nextPutAll: (self context referentAddress printStringRadix: 16);			nextPutAll: ', NULL, CS_SET, CS_SERVERMSG_CB, ..)'.		self class trace: self emitTrace ]</body></methods><methods><class-id>Database.CTLibConnection</class-id> <category>printing</category><body package="CTLibEXDI">printOn: aStream	super printOn: aStream.	self conn notNil ifTrue:		[ aStream			nextPutAll: '( conn=';			nextPutAll: ( self conn referentAddress printStringRadix: 16);			nextPutAll: ' )' ]</body></methods><methods><class-id>Database.CTLibConnection</class-id> <category>private-accessing</category><body package="CTLibEXDI">conn        "return pointer to CS_CONNECTION structure."        ^self connHolder value</body><body package="CTLibEXDI">conn: aCPointer        self connHolder value: aCPointer</body><body package="CTLibEXDI">connHolder        "return connHolder"        ^connHolder</body><body package="CTLibEXDI">connHolder: aValueHolder        connHolder := aValueHolder</body><body package="CTLibEXDI">context        "return pointer to CS_CONTEXT structure."        ^self contextHolder value</body><body package="CTLibEXDI">context: aCPointer        "Set the context pointer to the specified value."        self contextHolder value: aCPointer</body><body package="CTLibEXDI">contextHolder        ^contextHolder</body><body package="CTLibEXDI">contextHolder: aValueHolder        contextHolder := aValueHolder</body><body package="CTLibEXDI">isolationLevel: newIsolationLevel	"Set the current isolation level."	newIsolationLevel == #RR ifFalse: [ExternalDatabaseConnection unsupportedIsolationLevelSignal raise].	isolationLevel := newIsolationLevel</body></methods><methods><class-id>Database.CTLibConnection</class-id> <category>accessing</category><body package="CTLibEXDI">appName	"Answer the application-supplied name for itself."	^appName</body><body package="CTLibEXDI">appName: aString	"Set the name of the application to use when communicating with Sybase.	This is an optional parameter."	appName := aString</body><body package="CTLibEXDI">csVersion	csVersion isNil ifTrue: [ self csVersion: self class xif csVersion ].	^csVersion</body><body package="CTLibEXDI">csVersion: anObject	csVersion := anObject</body><body package="CTLibEXDI">getClientVersion	"Get the Client-Library version string."	| rc errs xif pVersionString pOutLen versionString |	xif := self class xif.	self conn isNil ifTrue: [ self initializeExternal ].	[ "Begin unwind protection (level 1)"	[ "Begin unwind protection (level 2)"	pVersionString := xif CS_CHAR perform: xif mallocSelector with: 128.	pOutLen := xif CS_INT perform: xif mallocSelector with: 1.	rc := xif ct_config: self context			    with: xif CS_GET			    with: xif CS_VER_STRING			    with: pVersionString			    with: 128			    with: pOutLen.	( traceLevel &gt;= 2 ) ifTrue:		[ (self traceStream)			print: rc; nextPutAll: ' = ct_config( context=';			nextPutAll: (self context referentAddress printStringRadix: 16);			nextPutAll: ', action=CS_GET, property=CS_VER_STRING, versionString='; 			nextPutAll: (pVersionString referentAddress printStringRadix: 16);			nextPutAll: ', buflen=128, outlen=';			nextPutAll: (pOutLen referentAddress printStringRadix: 16) .		self class trace: self emitTrace ].	versionString := pVersionString copyCStringFromHeap.	"End unwind protection (level 1)" ]		ensure:			[ pVersionString notNil ifTrue: [ pVersionString freePointer ].			  pOutLen notNil ifTrue: [ pOutLen freePointer ].			 ( rc isNil or:			 [ rc == xif CS_SUCCEED ] ) ifFalse:				[ errs := self class errorsOnQueue: self conn referentAddress.				self class externalDatabaseErrorSignal raiseWith: errs errorString: errs first dbmsErrorString ] ]	"End unwind protection (level 2)" ]		ifCurtailed:			[ self dismissExternal ].	^versionString</body><body package="CTLibEXDI">getPacketSize	"Get the TDS packet size."	^self getIntegerPropsExternal: self class xif CS_PACKETSIZE</body><body package="CTLibEXDI">hostName	"Answer the application-supplied name for the client machine."	^hostName</body><body package="CTLibEXDI">hostName: aString	"Set the name of the client machine to use when communicating with Sybase.	This is an optional parameter."	hostName := aString</body><body package="CTLibEXDI">packetSize	^packetSize</body><body package="CTLibEXDI">packetSize: anInteger	packetSize := anInteger</body><body package="CTLibEXDI">setBehaviorToVersion125	self csVersion: self class xif CS_VERSION_125</body><body package="CTLibEXDI">setBehaviorToVersion15	self csVersion: self class xif CS_VERSION_150</body></methods><methods><class-id>Database.CTLibConnection</class-id> <category>private-finalization</category><body package="CTLibEXDI">executor	| ex |	ex := super executor.		"Copy the CTLib specific fields."	ex contextHolder: self contextHolder.	ex connHolder: self connHolder.	^ex</body><body package="CTLibEXDI">finalizeExternal	self context isNil		ifTrue:	[ ^self ].	self dismissExternal.	super finalizeExternal</body><body package="CTLibEXDI">key	"Key value to use when inserting receiver into a handle registry. This value	needs to be unique within the registry."	^self connHolder</body></methods><methods><class-id>Database.CTLibConnection</class-id> <category>control</category><body package="CTLibEXDI">disablePasswordEncryption	"Set the password encryption to be true"	| xif |		xif := self class xif.	self setPropsExternal: xif CS_SEC_ENCRYPTION value: xif CS_FALSE.</body><body package="CTLibEXDI">enablePasswordEncryption	"Set the password encryption to be true"	| xif |		xif := self class xif.	self setPropsExternal: xif CS_SEC_ENCRYPTION value: xif CS_TRUE.</body><body package="CTLibEXDI">getPasswordEncryptionStatus	"Get password encryption status."	^self getIntegerPropsExternal: self class xif CS_SEC_ENCRYPTION</body><body package="CTLibEXDI">setInterfaceFile: fileName	"Specify the name of the interfaces file that will be during subsequent calls to ct_connect()."	interfaceFileName := fileName</body><body package="CTLibEXDI">setLoginTimeout: seconds	"Set the length of time in seconds that CT-Library will wait for a login response after calling ct_connect()."	loginTimeoutSeconds := seconds</body><body package="CTLibEXDI">setTextLimit: textLimit	"Set the text limit and execute an empty query so that the values are propagated to the server."	| pTextLimit rc err xif |		xif := self class xif.	[ "Begin unwind protection (level 1)"	[ "Begin unwind protection (level 2)"	pTextLimit := xif CS_INT perform: xif mallocSelector with: 1.	pTextLimit contents: textLimit.		rc := xif ct_con_props: self conn			with: xif CS_SET			with: xif CS_TEXTLIMIT			with: pTextLimit			with: xif CS_UNUSED			with: nil.	( traceLevel &gt;= 3 ) ifTrue:		[ (self traceStream)                        print: rc;  nextPutAll: ' = ct_con_props( conn = ';			nextPutAll: (self conn referentAddress printStringRadix: 16);			nextPutAll: ', CS_SET, CS_TEXTLIMIT, ';			nextPutAll: 'param=';			nextPutAll: (pTextLimit referentAddress printStringRadix: 16);			nextPutAll: ', CS_UNUSED, NULL )'.		self class trace: self emitTrace ].	rc == xif CS_SUCCEED ifTrue:		[ rc := xif ct_options: self conn				with: xif CS_SET				with: xif CS_OPT_TEXTSIZE				with: pTextLimit				with: xif CS_UNUSED				with: nil.		( traceLevel &gt;= 3 ) ifTrue:			[ (self traceStream)				print: rc;  nextPutAll: ' = ct_options( conn = ';				nextPutAll: (self conn referentAddress printStringRadix: 16);				nextPutAll: ', CS_SET, CS_OPT_TEXTSIZE, ';				nextPutAll: 'param=';				nextPutAll: (pTextLimit referentAddress printStringRadix: 16);				nextPutAll: ', CS_UNUSED, NULL )'.			self class trace: self emitTrace ] ]	"End unwind protection (level 1)" ]		ensure:			[ pTextLimit == nil ifFalse: [ pTextLimit freePointer ].			( rc isNil or:			[ rc ~= xif CS_SUCCEED ] ) ifTrue:				[ err := self class connectionClass errorsOnQueue: self conn referentAddress.				self class externalDatabaseErrorSignal raiseWith: err errorString: err first dbmsErrorString ] ]	"End unwind protection (level 2)" ]		ifCurtailed:			[ self dismissExternal ]</body></methods><methods><class-id>Database.CTLibConnection</class-id> <category>initialize-release</category><body package="CTLibEXDI">initialize	"Establish initial value for instance variables."	super initialize.	self csVersion: self class xif csVersion</body></methods><methods><class-id>Database.CTLibConnection class</class-id> <category>private-error collecting</category><body package="CTLibEXDI">acquireQueue: key	"Create and answer a new queue associated with key."	^ErrorQueues at: key ifAbsent: [ ErrorQueues at: key put: OrderedCollection new ]</body><body package="CTLibEXDI">dismissQueue: key	ErrorQueues removeKey: key ifAbsent: []</body><body package="CTLibEXDI">errorsOnQueue: key	"Answer the collection (of CTLibError) for key."	| queue |		(queue := ErrorQueues at: key ifAbsent: [nil]) isNil		ifTrue:	[ ^nil ].	ErrorQueues at: key put: OrderedCollection new.	^queue</body><body package="CTLibEXDI">queue: conn newError: aCTLibError	"Stick aCTLibError at the end of the queue of errors and messages waiting for the connection."	| key queue |	"The key is the address of the conn if one exists."	key := conn notNil		ifTrue:	 [ conn referentAddress ]		ifFalse: [ 0 ].	"Get the queue.  If one doesn't exist yet, use the 0 (connection not known yet) entry."	queue := ErrorQueues at: key ifAbsent: [ self acquireQueue: 0 ].	queue add: aCTLibError.	( TraceLevel &gt;= 2 ) ifTrue:		[ self trace: aCTLibError printString ]</body></methods><methods><class-id>Database.CTLibConnection class</class-id> <category>accessing</category><body package="CTLibEXDI">bufferClass	"Answer the buffer class for sessions"		^CTLibBuffer</body><body package="CTLibEXDI">columnDescriptionClass	"Answer the class to use for column description objects associated with receiver."	^CTLibColumnDescription</body><body package="CTLibEXDI">connectionClass	"Answer the class to use for connection objects associated with receiver."		^self</body><body package="CTLibEXDI">errorClass	"Answer the class to use for error objects associated with receiver."		^CTLibError</body><body package="CTLibEXDI">kind	"Answer a symbol representing the type of DMBS the receiver provides services for."	^#'SYBASE-CTLib'</body><body package="CTLibEXDI">serverEncoding	"Answer what is believed to be the server's encoding.	Answer #default if the server is the same as us."	^ServerEncoding</body><body package="CTLibEXDI">serverEncoding: encoding	"Set what is believed to be the server's encoding."	ServerEncoding := encoding</body><body package="CTLibEXDI">sessionClass	"Answer the class to use for session objects associated with receiver."	^CTLibSession</body><body package="CTLibEXDI">transactionClass	"Answer the class to use for transaction objects associated with receiver."	^CTLibTransaction</body><body package="CTLibEXDI">version	^(#CTLibversion &lt;&lt; #sybaseDB &gt;&gt; 'Database Connect for CTLib - Release 5i.2') asString</body></methods><methods><class-id>Database.CTLibConnection class</class-id> <category>private-accessing</category><body package="CTLibEXDI">interfaceClass	"Answer the correct interface class"	| interfaceClassName |	interfaceClassName := xifMap at: self platformType ifAbsent: [nil].	^interfaceClassName notNil		ifTrue: [ self environment at: interfaceClassName ifAbsent: [nil] ]		ifFalse: [nil]</body><body package="CTLibEXDI">signalMap	"Answer the signal map dictionary"	^signalMap</body><body package="CTLibEXDI">xif        "Answer the ExternalInterface subclass instance in use."	xif isNil ifTrue:		[ self initializeCTLibInterface ].	^xif</body></methods><methods><class-id>Database.CTLibConnection class</class-id> <category>activation</category><body package="CTLibEXDI">pause	"Direct the suspension of all activity for the CTLib driver."	^self quiesce</body><body package="CTLibEXDI">resume	"Direct the resumption of all suspended activity for the CTLib driver."	self activate</body></methods><methods><class-id>Database.CTLibConnection class</class-id> <category>private-registry</category><body package="CTLibEXDI">registry	"Answer with the registry."	^RegisteredCTLibConnections</body><body package="CTLibEXDI">registry: aCollection	"Record aCollection as the registry."	RegisteredCTLibConnections := aCollection</body></methods><methods><class-id>Database.CTLibConnection class</class-id> <category>signal constants</category><body package="CTLibEXDI">unableToOpenInterfacesFileSignal	"Answer the signal used to indicate that the connection cannot open the interfaces file."	^UnableToOpenInterfacesFile</body></methods><methods><class-id>Database.CTLibConnection class</class-id> <category>private-activation</category><body package="CTLibEXDI">install	"This method can be inherrited, and will simply pass the install 	directive down the chain for those subclasses that need it."	self subclasses do: [:each | each install].	"Execute initialization code just once, here."	self == CTLibConnection 		ifTrue: 			[TraceLevel &gt;= 1 ifTrue: [self trace: nil].			self xif: nil.			ErrorQueues := Dictionary new.			self returnFromSnapshot]</body></methods><methods><class-id>Database.CTLibConnection class</class-id> <category>threading</category><body package="CTLibEXDI">isThreaded	^false</body></methods><methods><class-id>Database.CTLibConnection class</class-id> <category>class initialization</category><body package="CTLibEXDI">initialize	"Make sure that the class variables are properly initialized."	"CTLibConnection initialize"	self serverEncoding: #default.	self xif: nil.	self initializeInterfaceMapping.	ErrorQueues := Dictionary new.	self initRegistry.	signalMap := IdentityDictionary new.	signalMap at: 208 put: #invalidTableNameSignal.	signalMap at: 2601 put: #indexConflictSignal.	signalMap at: 3701 put: #invalidTableNameSignal.</body><body package="CTLibEXDI">initializeCTLibInterface	"Reset CTLibInterface with the right interface class based on our platform."	"This is a support method for the lazy initialization mechanism."	| xifClass |	xifClass := self interfaceClass.	self xif: (xifClass notNil ifTrue: [xifClass new] ifFalse: [nil]).	xif isNil ifTrue: 		[^ExternalDatabaseNotification			raiseErrorString: (#incorrectDriverInstallation &lt;&lt; #sybaseDB					&gt;&gt; 'The CTLib Driver is not correctly installed.&lt;n&gt;Use the ExternalDatabaseInstallation tool to reinstall.')						expandMacros]</body><body package="CTLibEXDI">initializeInterfaceMapping		xifMap := IdentityDictionary new.	xifMap at: #aix_unix put: #CTLibAixInterface.	xifMap at: #sun5_unix put: #CTLibSolarisInterface.	xifMap at: #sun4_unix put: #CTLibInterface.	xifMap at: #linux_i386_unix put: #CTLibLinuxInterface.	xifMap at: #win32s put: #CTLibWin16Interface.	xifMap at: #nt put: #CTLibNTInterface.	xifMap at: #win95 put: #CTLibNTInterface.	xifMap at: #macOSX put: #CTLibPowerMacInterface.	xifMap at: #unknown put: #CTLibInterface.</body></methods><methods><class-id>Database.CTLibBuffer</class-id> <category>private-data conversion</category><body package="CTLibEXDI">at: index putBoolean: aBoolean	"Set the buffer to hold an CTLib encoded bit."	lengthsPointer at: (index-1) put: 1.	aBoolean		ifTrue:	[ bufferPointer at: (index-1) put: 1 ]		ifFalse:	[ bufferPointer at: (index-1) put: 0 ].	^aBoolean</body><body package="CTLibEXDI">at: index putByteArray: aByteArray	"Put aByteArray into the buffer."	| bytes |	(bytes := aByteArray size) &gt; elementSize ifTrue:		[ self class connectionClass unableToBindSignal raise ].	bufferPointer copyAt: ((index-1) * elementSize) from: aByteArray size: bytes startingAt: 1.	lengthsPointer at: (index-1) put: bytes.	^aByteArray</body><body package="CTLibEXDI">at: index putDouble: aDouble	"Put aDouble into the buffer"	| conversionBuffer |	conversionBuffer := UninterpretedBytes new: 8.	conversionBuffer doubleAt: 1 put: aDouble.	bufferPointer copyAt: ((index-1) * elementSize) from: conversionBuffer size: 8 startingAt: 1.	lengthsPointer at: (index-1) put: 8.	^aDouble</body><body package="CTLibEXDI">at: index putFixedPoint: aFixedPoint	"Put aFixedPoint into the buffer."	| strm str bytes |	"Print an CTLib-compatible version of aFixedPoint on strm.	This involves dropping the trailing f of Smalltalk literal syntax.	FixedPoint's never use exponent notation on output so no	need to worry about the exponentCharacter being embedded."		strm := (String defaultPlatformClass new: 40) writeStream.	aFixedPoint printOn: strm.	strm skip: -1.	str := strm contents.	"Stick the result into the buffer."	bufferPointer copyAt: ((index-1) * elementSize) from: str size: (bytes := str size) startingAt: 1.	lengthsPointer at: (index-1) put: bytes.	^aFixedPoint</body><body package="CTLibEXDI">at: index putFloat: aFloat	"Put aFloat into the buffer"	| conversionBuffer |	conversionBuffer := UninterpretedBytes new: 4.	conversionBuffer floatAt: 1 put: aFloat.	bufferPointer copyAt: ((index-1) * elementSize) from: conversionBuffer size: 4 startingAt: 1.	lengthsPointer at: (index-1) put: 4.	^aFloat</body><body package="CTLibEXDI">at: index putInteger: anInteger	"Put anInteger into the buffer"	| conversionBuffer |	conversionBuffer := UninterpretedBytes new: 4.	conversionBuffer longAt: 1 put: anInteger.	bufferPointer copyAt: ((index-1) * elementSize) from: conversionBuffer size: 4 startingAt: 1.	lengthsPointer at: (index-1) put: 4.	^anInteger</body><body package="CTLibEXDI">at: index putString: aString	"Put aString into the buffer."	| str bytes |	aString size &gt; elementSize ifTrue:		[ self class connectionClass unableToBindSignal raise ].	str := String defaultPlatformClass fromString: aString.	bufferPointer copyAt: ((index-1) * elementSize) from: str size: (bytes := str size) startingAt: 1.	lengthsPointer at: (index-1) put: bytes.	^aString</body><body package="CTLibEXDI">at: index putTimestamp: aTimestamp	"Put aTimestamp into the buffer"	"For performance reasons, the implementation of this method embeds	knowledge of the structure of the CTLib typedef cs_datetime."	"Date: CTLib is 1/1/1900 based,  Smalltalk is 1/1/1901 based"	"Time: CTLib is 1/300's of a second based, Smalltalk is seconds based"	| conversionBuffer |	conversionBuffer := UninterpretedBytes new: 8.	conversionBuffer longAt: 1 put: (aTimestamp asDate asDays + 365).	conversionBuffer unsignedShortAt: 5 put: ( (aTimestamp asTime asSeconds * 300) ).	bufferPointer copyAt: ((index-1) * elementSize) from: conversionBuffer size: 8 startingAt: 1.	lengthsPointer at: (index-1) put: 8.	^aTimestamp</body><body package="CTLibEXDI">getBooleanAt: index	"Answer a Boolean as described in the first byte pointed to by the buffer."	^(bufferPointer at: ((index-1) * elementSize) ) ~= 0</body><body package="CTLibEXDI">getByteArrayAt: index	"Answer a ByteArray populated from the buffer."	| bytes ba |	bytes := lengthsPointer at: (index-1).	ba := ByteArray new: bytes.	bufferPointer copyAt: ((index-1) * elementSize) to: ba size: bytes startingAt: 1.	^ba</body><body package="CTLibEXDI">getDoubleAt: index	"Answer a Double populated from the buffer"	"Assume: bufferPointer points to at least 8 bytes in the heap."	| conversionBuffer |	conversionBuffer := UninterpretedBytes new: 8.	bufferPointer copyAt: ((index-1) * elementSize) to: conversionBuffer size: 8 startingAt: 1.	^conversionBuffer doubleAt: 1</body><body package="CTLibEXDI">getFixedPointAt: index	"Answer a FixedPoint number populated from the buffer"	| bytes str |	bytes := lengthsPointer at: (index-1).	str := String new: bytes.	bufferPointer copyAt: ((index-1) * elementSize) to: str size: bytes startingAt: 1.	^FixedPoint readFrom: str readStream</body><body package="CTLibEXDI">getFloatAt: index	"Answer a Float populated from the buffer"	"Assume: bufferPointer points to at least 4 bytes in the heap."	| conversionBuffer |	conversionBuffer := UninterpretedBytes new: 4.	bufferPointer copyAt: ((index-1) * elementSize) to: conversionBuffer size: 4 startingAt: 1.	^conversionBuffer floatAt: 1</body><body package="CTLibEXDI">getIntegerAt: index	"Answer an Integer populated from the buffer."	"Assume: bufferPointer points to at least 4 bytes in the heap."	| conversionBuffer |	conversionBuffer := UninterpretedBytes new: 4.	bufferPointer copyAt: ((index-1) * elementSize) to: conversionBuffer size: 4 startingAt: 1.	^conversionBuffer longAt: 1</body><body package="CTLibEXDI">getStringAt: index	"Answer a String populated from the buffer"	| bytes byteArray |	bytes := lengthsPointer at: (index-1).	byteArray := ByteArray new: bytes.	bufferPointer copyAt: ((index-1) * elementSize) to: byteArray size: bytes startingAt: 1.	^byteArray asStringEncoding: self encoding</body><body package="CTLibEXDI">getTimestampAt: index	"Answer a Timestamp populated from the buffer"	"For performance reasons, the implementation of this method embeds	knowledge of the structure of the CTLib typedef cs_datetime."	"Date: CTLib is 1/1/1900 based,  Smalltalk is 1/1/1901 based"	"Time: CTLib is 1/300's of a second based, Smalltalk is nanoseconds based"	| conversionBuffer date time ts |	conversionBuffer := UninterpretedBytes new: 8.	bufferPointer copyAt: ((index-1) * elementSize) to: conversionBuffer size: 8 startingAt: 1.	date := Date fromDays: (conversionBuffer longAt: 1) - 365.	time := Time fromMilliseconds: ((conversionBuffer longAt: 5) * (10 / 3)) asInteger.	(ts := Timestamp new)		fromDate: date andTime: time.	^ts</body></methods><methods><class-id>Database.CTLibBuffer</class-id> <category>accessing</category><body package="CTLibEXDI">at: anIndex	"Answer the object in the buffer at anIndex."	^(indicatorsPointer at: (anIndex - 1)) == -1		ifTrue:  [ ^nil ]		ifFalse: [ 			getSelector isNil ifTrue: [				^self class connectionClass unsupportedDataTypeSignal raise			] ifFalse: [				self perform: getSelector with: anIndex 			]		]</body><body package="CTLibEXDI">at: anIndex put: anObject	"Store anObject into the buffer at anIndex."	anObject isNil		ifTrue:	 [ lengthsPointer contents: -1	"NULL_DATA" ]		ifFalse: [ 			putSelector isNil ifTrue: [				^self class connectionClass unsupportedDataTypeSignal raise			] ifFalse: [				self perform: putSelector with: anIndex with: anObject 			]		].	^anObject</body><body package="CTLibEXDI">dataFmtPointer	"Answer the receiver's pointer to the dataFmt structure."	^dataFmtPointer</body><body package="CTLibEXDI">fSqlType	"Answer the CTLib data type for the data in this buffer."	^SQLTypeFromConversionMap at: databaseType</body><body package="CTLibEXDI">indicatorsPointer	"Answer the receiver's pointer to the indicators."	^indicatorsPointer</body><body package="CTLibEXDI">lengthsPointer	"Answer the receiver's pointer to the lengths."	^lengthsPointer</body></methods><methods><class-id>Database.CTLibBuffer</class-id> <category>private</category><body package="CTLibEXDI">getSelector	^getSelector</body><body package="CTLibEXDI">pointerType	"Answer the pointer type to use for buffer allocation."	| refType |	refType := CIntegerType char.	^CArrayType defaultPointer			referentType: refType;			numElements: self elementSize.</body><body package="CTLibEXDI">putSelector	^putSelector</body></methods><methods><class-id>Database.CTLibBuffer</class-id> <category>initialize-release</category><body package="CTLibEXDI">elementSize: es count: aCount databaseType: dbType	"Initialize an instance of receiver which is set up to hold values as described."	super elementSize: es count: (aCount max: 1) databaseType: dbType.	getSelector := GetSelectorMap at: databaseType ifAbsent: [nil].	putSelector := PutSelectorMap at: databaseType ifAbsent: [nil]</body></methods><methods><class-id>Database.CTLibBuffer</class-id> <category>allocation</category><body package="CTLibEXDI">free	"Free resources held by the receiver."	lengthsPointer notNil ifTrue:		[ lengthsPointer freePointer. lengthsPointer := nil ].	indicatorsPointer notNil ifTrue:		[ indicatorsPointer freePointer. indicatorsPointer := nil ].	dataFmtPointer notNil ifTrue:		[ dataFmtPointer freePointer. dataFmtPointer := nil ].	super free</body><body package="CTLibEXDI">mallocUsing: mallocSelector	"Allocate a physical buffer for the receiver. Use mallocSelector to perform the allocation."	"Assume: the get and put methods will coerce the bufferPointer correctly."	"Assert: mallocSelector is either #malloc: or #malloc16:"	|success|	success := false.	[ "Begin unwind protection."	super mallocUsingSelector: mallocSelector.	lengthsPointer := self class connectionClass xif CS_INT perform: mallocSelector with: count.	indicatorsPointer := self class connectionClass xif CS_SMALLINT perform: mallocSelector with: count.	dataFmtPointer := self class connectionClass xif CS_DATAFMT perform: mallocSelector with: 1.	success := true.	"End unwind protection." ]		ifCurtailed:			[ self free ].	^success</body></methods><methods><class-id>Database.CTLibBuffer class</class-id> <category>accessing</category><body package="CTLibEXDI">connectionClass	"Answer the class to use for connection objects associated with receiver."	^CTLibConnection</body></methods><methods><class-id>Database.CTLibBuffer class</class-id> <category>instance creation</category><body package="CTLibEXDI">elementSize: es count: aCount databaseType: dbType	"Create an instance of receiver which is set up to hold values as described."	^self new elementSize: es count: aCount databaseType: dbType</body></methods><methods><class-id>Database.CTLibBuffer class</class-id> <category>class initialization</category><body package="CTLibEXDI">initialize	self install</body></methods><methods><class-id>Database.CTLibBuffer class</class-id> <category>private-activation</category><body package="CTLibEXDI">install	| ifcClass |	(ifcClass := self connectionClass interfaceClass) notNil ifTrue:		[ GetSelectorMap := ifcClass getSelectorMap.		PutSelectorMap := ifcClass putSelectorMap.		SQLTypeFromConversionMap := ifcClass fSqlTypeFromConversionMap.		FetchBufferSize := ifcClass fetchBufferSize ]</body></methods><methods><class-id>Database.CTLibBuffer class</class-id> <category>fileIn/Out</category><body package="CTLibEXDI">prerequisitesForLoading	"CTLibBuffer requires CTLibConnection to have initialized	 its interface mapping before it initializes."	^super prerequisitesForLoading		addLast: CTLibConnection;		yourself</body></methods><methods><class-id>Database.CTLibTransaction</class-id> <category>private-library calls</category><body package="CTLibEXDI">acquireExternal	^self</body><body package="CTLibEXDI">beginExternal	^self</body><body package="CTLibEXDI">commitExternal	^self</body><body package="CTLibEXDI">dismissExternal	^self</body><body package="CTLibEXDI">rollbackExternal	^self</body></methods><methods><class-id>Database.CTLibTransaction</class-id> <category>private-finalization</category><body package="CTLibEXDI">executor	^self shouldNotImplement</body><body package="CTLibEXDI">finalizeExternal	^self shouldNotImplement</body><body package="CTLibEXDI">key	^self shouldNotImplement</body></methods><methods><class-id>Database.CTLibTransaction class</class-id> <category>accessing</category><body package="CTLibEXDI">connectionClass	"Answer the class to use for connection objects associated with receiver."	^CTLibConnection</body></methods><methods><class-id>Database.CTLibTransaction class</class-id> <category>private-registry</category><body package="CTLibEXDI">registry: aCollection	^self shouldNotImplement</body></methods><methods><class-id>Database.CTLibError</class-id> <category>private-accessing</category><body package="CTLibEXDI">csLayer	"Corresponds to the CS_LAYER(msgno) C-macro for the client messages"	"#define CS_LAYER(L) (CS_MSGNUM)(((L )&gt;&gt;24)&amp;255"	^(self msgno bitShift: -24) bitAnd: 255</body><body package="CTLibEXDI">csNumber	"Corresponds to the CS_NUMBER(msgno) C-macro for the client messages"	"#define CS_NUMBER(N) (CS_MSGNUM)((N )&amp;255)"	^self msgno bitAnd: 255</body><body package="CTLibEXDI">csOrigin	"Corresponds to the CS_ORIGIN(msgno) C-macro for the client messages"	"#define CS_ORIGIN(O) (CS_MSGNUM)(((O )&gt;&gt;16)&amp;255)"	^(self msgno bitShift: -16) bitAnd: 255</body><body package="CTLibEXDI">csSeverity	"Corresponds to the CS_SEVERITY(msgno) C-macro for the client messages"	"#define CS_SEVERITY(S) (CS_MSGNUM)(((S )&gt;&gt;8)&amp;255)"	^(self msgno bitShift: -8) bitAnd: 255</body><body package="CTLibEXDI">line: aSmallInteger	line := aSmallInteger</body><body package="CTLibEXDI">msgno: aSmallInteger	dbmsErrorCode := aSmallInteger</body><body package="CTLibEXDI">msgstate: aSmallInteger	msgstate := aSmallInteger</body><body package="CTLibEXDI">msgtext: aString	dbmsErrorString := aString</body><body package="CTLibEXDI">procname: aString	procname := aString</body><body package="CTLibEXDI">severity: aSmallInteger	severity := aSmallInteger</body><body package="CTLibEXDI">srvname: aString	srvname := aString</body></methods><methods><class-id>Database.CTLibError</class-id> <category>accessing</category><body package="CTLibEXDI">line	"Answer the number of the command batch or stored procedure line that generated	the message.  Line numbers start at 1.  The line number pertains to the nesting level	at which the message was generated.  This is only defined for CTLibError instances	generated in response to server messages."	^line</body><body package="CTLibEXDI">msgno	"Answer the current message's number.  These numbers are documented	in the SQL Server Reference Supplement."	"This message is an alias for dbmsErroCode.  Since the CTLibError object will hold	either, but not both an error or a message, it saves allocating another variable."	^dbmsErrorCode</body><body package="CTLibEXDI">msgstate	"Answer the current message's error state number.  These numbers provide	Sybase Technical Support with information about the context of the error."	^msgstate</body><body package="CTLibEXDI">msgtext	"Answer the msgstring (client) or text (server) of the current message."	"This message is an alias for dbmsErrorString.  Since the CTLibError object will hold	either, but not both, an error or a message, it saves allocating another variable."	^dbmsErrorString</body><body package="CTLibEXDI">procname	"Answer the name of the stored procedure that generated the message.	If the message was not generated by a stored procedure, the string will be	empty.  This is only defined for CTLibError instances generated in	response to server messages."	^procname</body><body package="CTLibEXDI">severity	"The current message's information class or error severity."	"Note: there are two severities for the client messages: severity as a	member of the cs_clientmsg structure and as the macro CS_SEVERITY(msgno);	This severity corresponds to the first one."	^severity</body><body package="CTLibEXDI">srvname	"Answer the name of the server that generated the message.  If the server has no name,	the string will be empty.  This is only defined for CTLibError instances generated in	response to server messages."	^srvname</body></methods><methods><class-id>Database.CTLibError</class-id> <category>printing</category><body package="CTLibEXDI">printOn: aStream	super printOn: aStream.	self msgstate notNil		ifTrue:			[ aStream				nextPutAll: '( ** Server **'; crtab; tab;				nextPutAll: 'Msgnumber: '; print: self msgno; crtab; tab;				nextPutAll: 'Msgstate: '; print: self msgstate; crtab; tab;				nextPutAll: 'Severity: '; print: self severity; crtab; tab;				nextPutAll: 'Msgtext: '; nextPutAll: self msgtext; tab; tab;				nextPutAll: 'Srvname: '; nextPutAll: self srvname; crtab; tab;				nextPutAll: 'Procname: '; nextPutAll: self procname; crtab; tab;				nextPutAll: 'Line: '; print: line;				nextPutAll: ' )'; crtab ]		ifFalse:			[ aStream				nextPutAll: '( ** Client ** '; crtab; tab;				nextPutAll: 'CS_LAYER='; print: self csLayer;				nextPutAll: ', CS_ORIGIN='; print: self csOrigin;				nextPutAll: ', CS_SEVERITY='; print: self csSeverity;				nextPutAll: ', CS_NUMBER='; print: self csNumber; crtab; tab;				nextPutAll: 'Msgnumber: '; print: self msgno; crtab; tab;				nextPutAll: 'Severity: '; print: self severity; crtab; tab;				nextPutAll: 'Msgtext: '; nextPutAll: self msgtext; crtab; tab;				nextPutAll: 'OS error: '; print: self osErrorCode; crtab; tab;				nextPutAll: 'OS string: '; nextPutAll: self osErrorString;				nextPutAll: ' )'; crtab ]</body></methods><methods><class-id>Core.String</class-id> <category>private-ctlib</category><body package="CTLibEXDI">printOnForCTLib: aStream	"Format a respresentation of the receiver acceptable for input to CTLib."	self printOn: aStream</body></methods><methods><class-id>Core.Character</class-id> <category>private-ctlib</category><body package="CTLibEXDI">printOnForCTLib: aStream	"Format a respresentation of the receiver acceptable for input to CTLib."	aStream nextPut: self</body></methods><methods><class-id>Core.FixedPoint</class-id> <category>private-ctlib</category><body package="CTLibEXDI">printOnForCTLib: aStream	"Print a CTLib-compatible version of the receiver on aStream.	This involves dropping the trailing s from the literal syntax."	aStream print: self.	aStream skip: -1	"FixedPoint's never use exponent notation on output so no need to worry about the exponentCharacter being embedded."</body></methods><methods><class-id>Core.ByteArray</class-id> <category>private-ctlib</category><body package="CTLibEXDI">printOnForCTLib: aStream	"Format a respresentation of the receiver acceptable for input to CTLib."	aStream nextPutAll: '0x'.	1 to: self size do:		[ :index | | byte |		byte := self at: index.		byte &lt; 16 ifTrue: [ aStream nextPut: $0 ].		byte printOn: aStream base: 16 ]</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>private-ctlib</category><body package="CTLibEXDI">printOnForCTLib: aStream	"Format a respresentation of the receiver acceptable for input to CTLib."	"Date and Time is represented as a sequenceable collection	of size 2 with the date first and the time second."	| date time |	(self size == 2	and: [ (date := self at: 1) class == Date	and: [(time := self at: 2) class == Time ] ])		ifTrue:			[ (Timestamp fromDate: date andTime: time)				printOnForCTLib: aStream ]		ifFalse:			[ self shouldNotImplement ]</body></methods><methods><class-id>Core.Double</class-id> <category>private-ctlib</category><body package="CTLibEXDI">printOnForCTLib: aStream	"Print a CTLib-compatible version of the receiver on aStream.	This involves converting the expondent character to 'e', or dropping	it if it appears at the end of the string."	| printString expCharIndex |	printString := self printString.	expCharIndex := printString indexOf: (self class exponentCharacter).	aStream next: (expCharIndex - 1) putAll: printString startingAt: 1.	expCharIndex == printString size ifFalse:		[ aStream nextPut: $e.		aStream next: (printString size - expCharIndex) putAll: printString startingAt: (expCharIndex + 1) ].</body></methods><methods><class-id>Core.Timestamp</class-id> <category>private-ctlib</category><body package="CTLibEXDI">printOnForCTLib: aStream	"Format a representation of the receiver acceptable for input to CTLib."	aStream nextPutAll: 'convert(datetime, '''.	self asDate printOn: aStream format: #(2 1 3 $ 2 1).	aStream space.	hours &gt; 12		ifTrue:	[ hours - 12 printOn: aStream ]		ifFalse:	[ hours &lt; 1					ifTrue:	[ 12 printOn: aStream ]					ifFalse:	[ hours printOn: aStream ] ].	aStream nextPutAll: ( minutes &lt; 10 ifTrue: [ ':0' ] ifFalse: [ ':' ] ).	minutes printOn: aStream.	aStream nextPutAll: ( seconds &lt; 10 ifTrue: [ ':0' ] ifFalse: [ ':' ] ).	seconds printOn: aStream.	aStream nextPut: $..	milliseconds &lt; 10 ifTrue: [ aStream nextPut: $0. ].	milliseconds &lt; 100 ifTrue: [ aStream nextPut: $0 ].	milliseconds printOn: aStream.	aStream nextPutAll: ( hours &lt; 12 ifTrue: [ ' AM' ] ifFalse: [ ' PM' ] ).	aStream nextPutAll: ''', 109)'.</body></methods><methods><class-id>Core.Magnitude</class-id> <category>private-ctlib</category><body package="CTLibEXDI">printOnForCTLib: aStream	"Format a respresentation of the receiver acceptable for input to CTLib."	self printOn: aStream</body></methods><methods><class-id>Core.Boolean</class-id> <category>private-ctlib</category><body package="CTLibEXDI">printOnForCTLib: aStream	"Format a respresentation of the receiver acceptable for input to CTLib."	(self ifTrue: [ 1 ] ifFalse: [ 0 ]) printOn: aStream</body></methods><methods><class-id>Core.Time</class-id> <category>private-ctlib</category><body package="CTLibEXDI">printOnForCTLib: aStream	"Format a respresentation of the receiver acceptable for input to CTLib."	aStream nextPutAll: 'convert(datetime, '''.	hours printOn: aStream.	aStream nextPutAll: ( minutes &lt; 10 ifTrue: [ ':0' ] ifFalse: [ ':' ] ).	minutes printOn: aStream.	aStream nextPutAll: ( seconds &lt; 10 ifTrue: [ ':0' ] ifFalse: [ ':' ] ).	seconds printOn: aStream.	aStream nextPut: $..	milliseconds &lt; 10 ifTrue: [ aStream nextPut: $0. ].	milliseconds &lt; 100 ifTrue: [ aStream nextPut: $0 ].	milliseconds printOn: aStream.	aStream nextPutAll: ( hours &lt; 12 ifTrue: [ ' AM' ] ifFalse: [ ' PM' ] ).	aStream nextPutAll: ''', 108)'.</body></methods><methods><class-id>Core.GapString</class-id> <category>private-ctlib</category><body package="CTLibEXDI">printOnForCTLib: aStream	"Format a respresentation of the receiver acceptable for input to CTLib."	self compress.	string printOnForCTLib: aStream</body></methods><methods><class-id>UI.UISettings class</class-id> <category>user preferences</category><body package="CTLibEXDI">addSybaseSectionTo: aDictionary development: devSpecs runtime: runtimeSpecs	"Add the Sybase set of preferences and settings slices to the arguments."	aDictionary		at: #sybaseSetupAccept put: [self sybaseSetupAccept];		at: #sybaseSetupReset put: [self sybaseSetupReset].	self ensure: aDictionary		hasModelFor: #sybaseEncoding		editing: #sybaseEncodingEditing		default: CTLibConnection serverEncoding.	devSpecs		addLast: 'Sybase'-&gt;#(#sybaseSetupSpec #sybaseSetupHelp)</body></methods><methods><class-id>UI.UISettings class</class-id> <category>resources</category><body package="CTLibEXDI">availableEncodingList	^#(#ISO8859_1 #HP_Roman8)</body><body package="CTLibEXDI">availableEncodings	| mb menu allValues index |	allValues := #(#default) asOrderedCollection.	mb := MenuBuilder new.	mb addLabel: (#Default &lt;&lt; #sybaseDB &gt;&gt; 'Default') value: #default.	mb line.	self availableEncodingList		do: 			[:enc | 			allValues add: enc.			mb addLabel: enc asString value: enc].	menu := mb menu.	index := allValues indexOf: CTLibConnection serverEncoding.	index = 0 ifFalse: [menu selectionMemory: (menu menuItemAt: index)].	^menu</body></methods><methods><class-id>UI.UISettings class</class-id> <category>accessing preferences</category><body package="CTLibEXDI">sybaseSetupAccept	| newValue |	newValue := self preferenceFor: #sybaseEncodingEditing.	(self preferenceModelFor: #sybaseEncoding)		value: newValue.	CTLibConnection serverEncoding: newValue</body><body package="CTLibEXDI">sybaseSetupReset	(self preferenceModelFor: #sybaseEncodingEditing)		value: (self preferenceFor: #sybaseEncoding).</body></methods><methods><class-id>UI.UISettings</class-id> <category>help</category><body package="CTLibEXDI">sybaseSetupHelp	^'Sybase SetupThis setting is only needed for Sybase client library 4.x, which is used on Windows and HP. For other operating systems, set this to ''Default''.'</body></methods><methods><class-id>Core.Text</class-id> <category>private-ctlib</category><body package="CTLibEXDI">printOnForCTLib: aStream	"Format a respresentation of the receiver acceptable for input to CTLib."	self string printOnForCTLib: aStream</body></methods><methods><class-id>Core.Date</class-id> <category>private-ctlib</category><body package="CTLibEXDI">printOnForCTLib: aStream	"Print a reprentation of the receiver acceptable to CTLib."	aStream nextPutAll: 'convert(datetime, '''.	self printOn: aStream format: #(2 1 3 $  2 1).	aStream nextPutAll: ''', 107)'.</body></methods><methods><class-id>Core.ByteSymbol</class-id> <category>private-ctlib</category><body package="CTLibEXDI">printOnForCTLib: aStream	"Format a respresentation of the receiver acceptable for input to CTLib."	| x |	aStream nextPut: $'.	1 to: self size do:		[:i |		aStream nextPut: (x := self at: i).		x == $' ifTrue: [aStream nextPut: x]].	"embedded quotes get doubled"	aStream nextPut: $'</body></methods><methods><class-id>UI.UISettings class</class-id> <category>interface specs</category><body package="CTLibEXDI">sybaseSetupSpec	"UIPainter new openOnClass: self andSelector: #sybaseSetupSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: #(#{UserMessage} #key: #UnlabeledCanvas #catalogID: #sybaseDB #defaultString: 'Unlabeled Canvas' )			#bounds: #(#Rectangle 222 338 508 540 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#LabelSpec 					#layout: #(#Point 39 29 ) 					#label: #(#{UserMessage} #key: #SybaseServerEncoding #catalogID: #sybaseDB #defaultString: 'Sybase Server Encoding' ) )				#(#MenuButtonSpec 					#layout: #(#Rectangle 20 108 200 135 ) 					#name: #SybaseEncoding 					#model: #sybaseEncodingEditing 					#callbacksSpec: 					#(#UIEventCallbackSubSpec 						#valueChangeSelector: #disturb ) 					#menu: #availableEncodings ) 				#(#ActionButtonSpec 					#layout: #(#Point 185 240 ) 					#model: #helpAction 					#label: #(#{UserMessage} #key: #Help #catalogID: #sybaseDB #defaultString: 'Help' )					#isDefault: false 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#Point 101 240 ) 					#name: #resetButton 					#flags: 40 					#model: #sybaseSetupReset 					#callbacksSpec: 					#(#UIEventCallbackSubSpec 						#valueChangeSelector: #undisturb ) 					#label: #(#{UserMessage} #key: #Reset #catalogID: #sybaseDB #defaultString: 'Reset' )					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#Point 10 240 ) 					#name: #acceptButton 					#flags: 40 					#model: #sybaseSetupAccept 					#callbacksSpec: 					#(#UIEventCallbackSubSpec 						#valueChangeSelector: #undisturb ) 					#label: #(#{UserMessage} #key: #Accept #catalogID: #sybaseDB #defaultString: 'Accept' ) 					#isDefault: true 					#defaultable: true ) 				#(#GroupBoxSpec 					#layout: #(#LayoutFrame 10 0 83 0 -10 1 153 0 ) 					#label: #(#{UserMessage} #key: #Encoding #catalogID: #sybaseDB #defaultString: 'Encoding' )) ) ) )</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-database</category><body package="CTLibEXDI">sybase1Encoding	&lt;setting: #(sybase sybaseEncoding)&gt;	^((EnumerationSetting choices: #(#default #ISO8859_1 #HP_Roman8)		labels: (Array 				with: #Default &lt;&lt; #sybaseDB &gt;&gt; 'Default'				with: 'ISO8859-1'				with: 'HP Roman8')) 			onUISetting: #sybaseEncoding)		label: #Encoding &lt;&lt; #sybaseDB &gt;&gt; 'Encoding';		default: #default;		helpText: #SybaseHelpText &lt;&lt; #sybaseDB 					&gt;&gt; 'This setting is only needed for Sybase client library 4.x, which is used on Windows and HP. For other operating systems, set this to ''Default''.'</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>pages</category><body package="CTLibEXDI">sybasePage	&lt;settingsPage: #(tools sybase)&gt;	^ModularSettingsPage new		label: #Sybase &lt;&lt; #sybaseDB &gt;&gt; 'Sybase';		icon: (ListIconLibrary visualFor: #database);		settings: (self settingsWithPrefix: #(sybase))</body></methods><methods><class-id>Database.CTLibInterface</class-id> <category>procedures</category><body package="CTLibEXDI">cs_ctx_alloc: version with: outptr	&lt;C: CS_RETCODE cs_ctx_alloc(CS_INT version, CS_CONTEXT * * outptr)&gt;	^self externalAccessFailed</body><body package="CTLibEXDI">cs_ctx_drop: context	&lt;C: CS_RETCODE cs_ctx_drop(CS_CONTEXT * context)&gt;	^self externalAccessFailed</body><body package="CTLibEXDI">ct_bind: cmd with: item with: datafmt with: buf with: outputlen with: indicator	&lt;C: CS_RETCODE ct_bind(CS_COMMAND * cmd, CS_INT item, CS_DATAFMT * datafmt, CS_VOID * buf, CS_INT * outputlen, CS_SMALLINT * indicator)&gt;	^self externalAccessFailed</body><body package="CTLibEXDI">ct_callback: context with: connection with: action with: type with: func	&lt;C: CS_RETCODE ct_callback(CS_CONTEXT * context, CS_CONNECTION * connection, CS_INT action, CS_INT type, CS_VOID * func)&gt;	^self externalAccessFailed</body><body package="CTLibEXDI">ct_cancel: connection with: cmd with: type	&lt;C: CS_RETCODE ct_cancel(CS_CONNECTION * connection, CS_COMMAND * cmd, CS_INT type)&gt;	^self externalAccessFailed</body><body package="CTLibEXDI">ct_close: connection with: option	&lt;C: CS_RETCODE ct_close(CS_CONNECTION * connection, CS_INT option)&gt;	^self externalAccessFailed</body><body package="CTLibEXDI">ct_cmd_alloc: connection with: cmdptr	&lt;C: CS_RETCODE ct_cmd_alloc(CS_CONNECTION * connection, CS_COMMAND * * cmdptr)&gt;	^self externalAccessFailed</body><body package="CTLibEXDI">ct_cmd_drop: cmd	&lt;C: CS_RETCODE ct_cmd_drop(CS_COMMAND * cmd)&gt;	^self externalAccessFailed</body><body package="CTLibEXDI">ct_cmd_props: cmd with: action with: property with: buffer with: buflen with: outlen	&lt;C: CS_RETCODE ct_cmd_props(CS_COMMAND *cmd, CS_INT action, CS_INT property, CS_VOID *buffer, CS_INT buflen, CS_INT *outlen)&gt;	^self externalAccessFailed</body><body package="CTLibEXDI">ct_command: cmd with: type with: buf with: buflen with: option	&lt;C: CS_RETCODE ct_command(CS_COMMAND * cmd, CS_INT type, CS_CHAR * buf, CS_INT buflen, CS_INT option)&gt;	^self externalAccessFailed</body><body package="CTLibEXDI">ct_con_alloc: context with: connection	&lt;C: CS_RETCODE ct_con_alloc(CS_CONTEXT * context, CS_CONNECTION * * connection)&gt;	^self externalAccessFailed</body><body package="CTLibEXDI">ct_con_drop: connection	&lt;C: CS_RETCODE ct_con_drop(CS_CONNECTION * connection)&gt;	^self externalAccessFailed</body><body package="CTLibEXDI">ct_con_props: connection with: action with: property with: buf with: buflen with: outlen	&lt;C: CS_RETCODE ct_con_props(CS_CONNECTION * connection, CS_INT action, CS_INT property, CS_VOID * buf, CS_INT buflen, CS_INT * outlen)&gt;	^self externalAccessFailed</body><body package="CTLibEXDI">ct_config: context with: action with: property with: buf with: buflen with: outlen	&lt;C: CS_RETCODE ct_config(CS_CONTEXT * context, CS_INT action, CS_INT property, CS_VOID * buf, CS_INT buflen, CS_INT * outlen)&gt;	^self externalAccessFailed</body><body package="CTLibEXDI">ct_connect: connection with: server_name with: snamelen	&lt;C: CS_RETCODE ct_connect(CS_CONNECTION * connection, CS_CHAR * server_name, CS_INT snamelen)&gt;	^self externalAccessFailed</body><body package="CTLibEXDI">ct_cursor: cmd with: type with: name with: namelen with: text with: textlen with: option	&lt;C: CS_RETCODE ct_cursor(CS_COMMAND * cmd, CS_INT type, CS_CHAR * name, CS_INT namelen, CS_CHAR * text, CS_INT textlen, CS_INT option)&gt;	^self externalAccessFailed</body><body package="CTLibEXDI">ct_describe: cmd with: item with: datafmt	&lt;C: CS_RETCODE ct_describe(CS_COMMAND * cmd, CS_INT item, CS_DATAFMT * datafmt)&gt;	^self externalAccessFailed</body><body package="CTLibEXDI">ct_exit: context with: option	&lt;C: CS_RETCODE ct_exit(CS_CONTEXT * context, CS_INT option)&gt;	^self externalAccessFailed</body><body package="CTLibEXDI">ct_fetch: cmd with: type with: offset with: option with: count	&lt;C: CS_RETCODE ct_fetch(CS_COMMAND * cmd, CS_INT type, CS_INT offset, CS_INT option, CS_INT * count)&gt;	^self externalAccessFailed</body><body package="CTLibEXDI">ct_init: context with: version	&lt;C: CS_RETCODE ct_init(CS_CONTEXT * context, CS_INT version)&gt;	^self externalAccessFailed</body><body package="CTLibEXDI">ct_options: connection with: action with: option with: param with: paramlen with: outlen	&lt;C: CS_RETCODE ct_options(CS_CONNECTION * connection, CS_INT action, CS_INT option, CS_VOID * param, CS_INT paramlen, CS_INT * outlen)&gt;	^self externalAccessFailed</body><body package="CTLibEXDI">ct_res_info: cmd with: operation with: buf with: buflen with: outlen	&lt;C: CS_RETCODE ct_res_info(CS_COMMAND * cmd, CS_INT operation, CS_VOID * buf, CS_INT buflen, CS_INT * outlen)&gt;	^self externalAccessFailed</body><body package="CTLibEXDI">ct_results: cmd with: result_type	&lt;C: CS_RETCODE ct_results(CS_COMMAND * cmd, CS_INT * result_type)&gt;	^self externalAccessFailed</body><body package="CTLibEXDI">ct_scroll_fetch: cmd with: type with: offset with: option with: count	&lt;C: CS_RETCODE ct_scroll_fetch(CS_COMMAND * cmd, CS_INT type, CS_INT offset, CS_INT option, CS_INT * count)&gt;	^self externalAccessFailed</body><body package="CTLibEXDI">ct_send: cmd	&lt;C: CS_RETCODE ct_send(CS_COMMAND * cmd)&gt;	^self externalAccessFailed</body></methods><methods><class-id>Database.CTLibWin16Interface</class-id> <category>procedures</category><body package="CTLibEXDI">cs_ctx_alloc: version with: outptr	&lt;C: CS_RETCODE _far  _pascal  cs_ctx_alloc(CS_INT version, CS_CONTEXT _far * _far * outptr)&gt;	^self externalAccessFailed</body><body package="CTLibEXDI">cs_ctx_drop: context	&lt;C: CS_RETCODE _far  _pascal  cs_ctx_drop(CS_CONTEXT _far * context)&gt;	^self externalAccessFailed</body><body package="CTLibEXDI">ct_bind: cmd with: item with: datafmt with: buf with: outputlen with: indicator	&lt;C: CS_RETCODE _far  _pascal  ct_bind(CS_COMMAND _far * cmd, CS_INT item, CS_DATAFMT _far * datafmt, CS_VOID _far * buf, CS_INT _far * outputlen, CS_SMALLINT _far * indicator)&gt;	^self externalAccessFailed</body><body package="CTLibEXDI">ct_callback: context with: connection with: action with: type with: func	&lt;C: CS_RETCODE _far  _pascal  ct_callback(CS_CONTEXT _far * context, CS_CONNECTION _far * connection, CS_INT action, CS_INT type, CS_VOID _far * func)&gt;	^self externalAccessFailed</body><body package="CTLibEXDI">ct_cancel: connection with: cmd with: type	&lt;C: CS_RETCODE _far  _pascal  ct_cancel(CS_CONNECTION _far * connection, CS_COMMAND _far * cmd, CS_INT type)&gt;	^self externalAccessFailed</body><body package="CTLibEXDI">ct_close: connection with: option	&lt;C: CS_RETCODE _far  _pascal  ct_close(CS_CONNECTION _far * connection, CS_INT option)&gt;	^self externalAccessFailed</body><body package="CTLibEXDI">ct_cmd_alloc: connection with: cmdptr	&lt;C: CS_RETCODE _far  _pascal  ct_cmd_alloc(CS_CONNECTION _far * connection, CS_COMMAND _far * _far * cmdptr)&gt;	^self externalAccessFailed</body><body package="CTLibEXDI">ct_cmd_drop: cmd	&lt;C: CS_RETCODE _far  _pascal  ct_cmd_drop(CS_COMMAND _far * cmd)&gt;	^self externalAccessFailed</body><body package="CTLibEXDI">ct_command: cmd with: type with: buf with: buflen with: option	&lt;C: CS_RETCODE _far  _pascal  ct_command(CS_COMMAND _far * cmd, CS_INT type, CS_CHAR _far * buf, CS_INT buflen, CS_INT option)&gt;	^self externalAccessFailed</body><body package="CTLibEXDI">ct_con_alloc: context with: connection	&lt;C: CS_RETCODE _far  _pascal  ct_con_alloc(CS_CONTEXT _far * context, CS_CONNECTION _far * _far * connection)&gt;	^self externalAccessFailed</body><body package="CTLibEXDI">ct_con_drop: connection	&lt;C: CS_RETCODE _far  _pascal  ct_con_drop(CS_CONNECTION _far * connection)&gt;	^self externalAccessFailed</body><body package="CTLibEXDI">ct_con_props: connection with: action with: property with: buf with: buflen with: outlen	&lt;C: CS_RETCODE _far  _pascal  ct_con_props(CS_CONNECTION _far * connection, CS_INT action, CS_INT property, CS_VOID _far * buf, CS_INT buflen, CS_INT _far * outlen)&gt;	^self externalAccessFailed</body><body package="CTLibEXDI">ct_config: context with: action with: property with: buf with: buflen with: outlen	&lt;C: CS_RETCODE _far  _pascal  ct_config(CS_CONTEXT _far * context, CS_INT action, CS_INT property, CS_VOID _far * buf, CS_INT buflen, CS_INT _far * outlen)&gt;	^self externalAccessFailed</body><body package="CTLibEXDI">ct_connect: connection with: server_name with: snamelen	&lt;C: CS_RETCODE _far  _pascal  ct_connect(CS_CONNECTION _far * connection, CS_CHAR _far * server_name, CS_INT snamelen)&gt;	^self externalAccessFailed</body><body package="CTLibEXDI">ct_describe: cmd with: item with: datafmt	&lt;C: CS_RETCODE _far  _pascal  ct_describe(CS_COMMAND _far * cmd, CS_INT item, CS_DATAFMT _far * datafmt)&gt;	^self externalAccessFailed</body><body package="CTLibEXDI">ct_exit: context with: option	&lt;C: CS_RETCODE _far  _pascal  ct_exit(CS_CONTEXT _far * context, CS_INT option)&gt;	^self externalAccessFailed</body><body package="CTLibEXDI">ct_fetch: cmd with: type with: offset with: option with: count	&lt;C: CS_RETCODE _far  _pascal  ct_fetch(CS_COMMAND _far * cmd, CS_INT type, CS_INT offset, CS_INT option, CS_INT _far * count)&gt;	^self externalAccessFailed</body><body package="CTLibEXDI">ct_init: context with: version	&lt;C: CS_RETCODE _far  _pascal  ct_init(CS_CONTEXT _far * context, CS_INT version)&gt;	^self externalAccessFailed</body><body package="CTLibEXDI">ct_options: connection with: action with: option with: param with: paramlen with: outlen	&lt;C: CS_RETCODE _far  _pascal  ct_options(CS_CONNECTION _far * connection, CS_INT action, CS_INT option, CS_VOID _far * param, CS_INT paramlen, CS_INT _far * outlen)&gt;	^self externalAccessFailed</body><body package="CTLibEXDI">ct_res_info: cmd with: operation with: buf with: buflen with: outlen	&lt;C: CS_RETCODE _far  _pascal  ct_res_info(CS_COMMAND _far * cmd, CS_INT operation, CS_VOID _far * buf, CS_INT buflen, CS_INT _far * outlen)&gt;	^self externalAccessFailed</body><body package="CTLibEXDI">ct_results: cmd with: result_type	&lt;C: CS_RETCODE _far  _pascal  ct_results(CS_COMMAND _far * cmd, CS_INT _far * result_type)&gt;	^self externalAccessFailed</body><body package="CTLibEXDI">ct_send: cmd	&lt;C: CS_RETCODE _far  _pascal  ct_send(CS_COMMAND _far * cmd)&gt;	^self externalAccessFailed</body></methods><initialize><class-id>Database.CTLibSession</class-id></initialize><initialize><class-id>Database.CTLibConnection</class-id></initialize><initialize><class-id>Database.CTLibBuffer</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>SequenceableCollection</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>ExternalDatabaseTransaction</name><environment>Database</environment><super>Database.ExternalDatabaseFramework</super><private>false</private><indexed-type>none</indexed-type><inst-vars>memberCountHolder remainingCountHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><class><name>Magnitude</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>ExternalDatabaseError</name><environment>Database</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dbmsErrorCode dbmsErrorString osErrorCode osErrorString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><class><name>ExternalDatabaseConnection</name><environment>Database</environment><super>Database.ExternalDatabaseFramework</super><private>false</private><indexed-type>none</indexed-type><inst-vars>transaction username password environment transactionCoordinator cachedSession isolationLevel encoding </inst-vars><class-inst-vars>environmentMap xif xifMap dependents </class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><class><name>Date</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>day year </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>Character</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>ByteSymbol</name><environment>Core</environment><super>Core.Symbol</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-String Support</category><attributes><package>Collections-String Support</package></attributes></class><class><name>ExternalInterface</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>includeFiles includeDirectories libraryFiles libraryDirectories virtual optimizationLevel </class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>External-Interface</category><attributes><package>External-Interface</package></attributes></class><class><name>UISettings</name><environment>UI</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>list disturbed subBuilder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Support</category><attributes><package>Interface-Support</package></attributes></class><class><name>Timestamp</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>year month day hours minutes seconds milliseconds partialNanosecond </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>GapString</name><environment>Core</environment><super>Core.String</super><private>false</private><indexed-type>none</indexed-type><inst-vars>string gapStart gapSize </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-String Support</category><attributes><package>Collections-String Support</package></attributes></class><class><name>Boolean</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Time</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hours minutes seconds milliseconds partialNanosecond </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>Double</name><environment>Core</environment><super>Core.LimitedPrecisionReal</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>ByteArray</name><environment>Core</environment><super>Core.IntegerArray</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>ExternalDatabaseException</name><environment>Database</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><class><name>ExternalDatabaseColumnDescription</name><environment>Database</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name index type length precision scale nullable </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><class><name>ExternalDatabaseBuffer</name><environment>Database</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>databaseType encoding elementSize count bufferPointer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><class><name>ExternalDatabaseSession</name><environment>Database</environment><super>Database.ExternalDatabaseFramework</super><private>false</private><indexed-type>none</indexed-type><inst-vars>connection query queryFragments bindInput bindTemplate bindOutput useNamedOutputBinding bindValues resultTemplate allocateForEachRow blockFactor numColumns columnDescriptions rowAdaptors rowBuffersHolder bufferIndex answerStream currentRow scrollable needBinding </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><class><name>Text</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars>string runs </inst-vars><class-inst-vars></class-inst-vars><imports>			private Graphics.TextConstants.*			</imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>FixedPoint</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars>numerator denominator scale </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class></st-source>