<?xml version="1.0"?><st-source><!-- Name: ODBCEXDINotice: Copyright 1999-2017 Cincom Systems, Inc.  All rights reserved.Comment: Provides the External database interface (EXDI) code to use Windows ODBC-compliant relational databases.  After loading this package, you can store and retrieve data and run server-based stored procedures using your own Smalltalk programs.  Also, this package enables the Ad Hoc SQL tool on the Database menu of the Launcher window.  This interactive tool allows you to run simple text-based queries to verify your database connection and explore your data.Further information on the EXDI can be found in the "Database Application Developer''s Guide" (located in the /doc subdirectory of the VisualWorks installation).The following are required for VisualWorks to successfully connect to a database server via ODBC:This package (ODBCEXDI) must be loaded.  	ODBC driver software installed properly on your computer. 	A hardware network connection to a working database server. 	A valid user name and password to access the database server.DbIdentifier: bear73DbTrace: 499541DbUsername: dwallenDbVersion: 8.3 - 6DevelopmentPrerequisites: #(#(#any 'Database' '') #(#any 'DLLCC' ''))HideSource: falsePackageName: ODBCEXDIParcel: #('ODBCEXDI')ParcelName: ODBCEXDIPrerequisiteParcels: #(#('Database' ''))PrintStringCache: (8.3 - 6,dwallen)SaveSource: trueVersion: 8.3 - 6Date: 12:15:11 PM March 24, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (mar17.4) of March 24, 2017 on March 24, 2017 at 12:15:11 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>ODBCCLIInterface</name><environment>Database</environment><super>External.ExternalInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars>encoding </inst-vars><class-inst-vars>getSelectorMap fSqlTypeToConversionMap fetchBufferSizeBlocks putSelectorMap fCTypeFromConversionMap fSqlTypeFromConversionMap valueSizeBlocks valuePrecisionBlocks dataChunkSize </class-inst-vars><imports>			private Database.ODBCCLIInterfaceDictionary.*			</imports><category>Database-External-Libraries</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>true</beVirtual><optimizationLevel>full</optimizationLevel><package>ODBCEXDI</package></attributes></class><comment><class-id>Database.ODBCCLIInterface</class-id><body>ODBCCLIInterface defines calling the conventions for the ODBC API.Instance Variables:	encoding	&lt;Symbol&gt;		A symbol remembers the encoding selection.Class Instance Variables:	getSelectorMap &lt;IdentityDictionary&gt;		Map from internal types to get-data conversion selectors.	fSqlTypeToConversionMap &lt;IdentityDictionary&gt;		Map from SQL types to internal types.	fetchBufferSizeBlocks &lt;IdentityDictionary&gt;		Map from internal types to buffer sizes.	putSelectorMap &lt;IdentityDictionary&gt;		Map from internal types to put-data conversion selectors.	fCTypeFromConversionMap &lt;IdentityDictionary&gt;		Map from internal types to SQL C data types.	fSqlTypeFromConversionMap &lt;IdentityDictionary&gt;		Map from internal types to SQL types.	valueSizeBlocks &lt;IdentityDictionary&gt;		Map from internal type to value sizes.	valuePrecisionBlocks &lt;IdentityDictionary&gt;		Map from internal types to precisions.	dataChunkSize &lt;Integer&gt;		Default size of the buffers to tranfer LOB values.</body></comment><class><name>ODBCCLI64BitInterface</name><environment>Database</environment><super>Database.ODBCCLIInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Database.ODBCCLI64BitInterfaceDictionary.*			</imports><category>Database-External-Libraries</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>true</beVirtual><optimizationLevel>full</optimizationLevel><package>ODBCEXDI</package></attributes></class><comment><class-id>Database.ODBCCLI64BitInterface</class-id><body>This class defines 64-bit calling conventions for the ODBC client interface api. It should only be used in 64-bit images, running on a 64-bit VM.The 64-bit VM currently regards "long int" as a 64-bit integer, but the 64-bit ODBC libraries see long as 32-bits, so long has been replaced by int. In addition, the 64-bit ODBC api has updated some functions, upgrading some parameters to 64-bits. Those api changes are reflected here.</body></comment><class><name>ODBCCLINT64Interface</name><environment>Database</environment><super>Database.ODBCCLI64BitInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Database.ODBCCLINT64InterfaceDictionary.*			</imports><category>Database-External-Libraries</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>odbc32.dll</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>ODBCEXDI</package></attributes></class><comment><class-id>Database.ODBCCLINT64Interface</class-id><body>ODBCCLINT64Interface is used with the 64-bit Windows environement. The DLL used is named 'odbc32.dll', because the Windows 64-bit and 32-bit versions share the same name (yet different architecture). On 64-bit Windows, the default system directory, still called 'system32', is actually 64-bits, and the backward-compatible 32-bit directory is named 'sysWOW64'. If your PATH variable mentions sysWOW64 before system32, your image will find and load the older, 32-bit library instead, for which this class is not intended.</body></comment><class><name>ODBCCLIAIXInterface</name><environment>Database</environment><super>Database.ODBCCLIInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Database.ODBCCLIAIXInterfaceDictionary.*			</imports><category>Database-External-Libraries</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>libiodbc.a</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>ODBCEXDI</package></attributes></class><comment><class-id>Database.ODBCCLIAIXInterface</class-id><body>ODBCCLIAIXInterface defines the ODBC calling conventions on the AIX platform.</body></comment><class><name>ODBC2Connection</name><environment>Database</environment><super>Database.ExternalDatabaseConnection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hdbcHolder supportedFunctions generalInformationCache unicodeEncoding sqlConnectionOptionCache </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-ODBC</category><attributes><package>ODBCEXDI</package></attributes></class><comment><class-id>Database.ODBC2Connection</class-id><body>ODBCConnection is the concrete class implementation of connection services using the ODBC library.Instance Variables	generalInformationCache	&lt;IdentityDictionary&gt;	Maps api information id, to info value, e.g., dbms version.	hdbcHolder	&lt;Value&gt;	A value holder for the environment handle which identifies this connection.	supportedFunctions	&lt;IdentityDictionary&gt;	Maps ODBC api functional capability id to True or False.	unicodeEncoding	&lt;Symbol&gt;	A symbol remembers the encoding selection for the Unicode strings.	sqlConnectionOptionCache	&lt;IdentityDictionary&gt;	Maps formal connection options, if supported by db.Shared Variables	Henv		&lt;CPointer | nil&gt;	A pointer for environment handle, if any.	HenvLock 	&lt;RecursionLock&gt; A lock for protecting shared resources	HenvReferencesCount	&lt;Integer&gt;	Indicates number of connections referencing the environment handle.	RegisteredODBCConnections	&lt;Collection&gt;	The collection of active connections..	SQLInfoTypeConversionMap	&lt;IdentityDictionary&gt;	A set of associations between SQL information types and conversion message names.	SupportedIsolationLevels	 &lt;IdentityDictionary&gt; A dictionary of supported isolation levels.	ConnectionPooling	&lt;Boolean&gt;	Indicates whether connection pooling is wanted.	ConnectionsArePooled	&lt;Boolean&gt;	Indicates whether connection pooling is on.	CpStrictMatch	&lt;Boolean&gt;	Indicates whether strict match or relaxed match is wanted for connection pooling. 	SQLConnectionOptionConversionMap &lt;IdentityDictionary&gt; A set of associations between SQL Connection Option types and conversion message names.</body></comment><class><name>ODBCCLINTInterface</name><environment>Database</environment><super>Database.ODBCCLIInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Database.ODBCCLINTInterfaceDictionary.*			</imports><category>Database-External-Libraries</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>odbc32.dll</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>ODBCEXDI</package></attributes></class><comment><class-id>Database.ODBCCLINTInterface</class-id><body>ODBCCLINTInterface defines the ODBC calling conventions on Windows NT.</body></comment><class><name>ODBCCLI95Interface</name><environment>Database</environment><super>Database.ODBCCLINTInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Database.ODBCCLI95InterfaceDictionary.*			</imports><category>Database-External-Libraries</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>odbc32.dll</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>ODBCEXDI</package></attributes></class><comment><class-id>Database.ODBCCLI95Interface</class-id><body>ODBCCLI95Interface defines the ODBC calling conventions on Windows 95 and 98.</body></comment><class><name>ODBC2Buffer</name><environment>Database</environment><super>Database.ExternalDatabaseBuffer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bufferValue bufferIndex bufferSession fParamType cbColDef ibScale cbValueMax pcbValue getSelector putSelector unicode isUnicodeColumn </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Private-ODBC Buffers</category><attributes><package>ODBCEXDI</package></attributes></class><comment><class-id>Database.ODBC2Buffer</class-id><body>ODBCBuffer is a private subclass, and extends ExternalDatabaseBuffer to deal with ODBC.  Intimate details are shared with ODBCSession.All CPointers managed by ODBCBuffer are assumed to not be automatically garbage collectable.  Clients are responsible for explicitly freeing the space.Instance Variables	bufferIndex	&lt;Object&gt;	Bind position in query.	bufferSession	&lt;ODBCSession&gt;	The ODBCSession which owns self (this buffer).	bufferValue	&lt;Object&gt;	Smalltalk object held by this buffer.	cbColDef	&lt;SmallInteger&gt;	How many bytes (or characters) used for variable C data.	cbValueMax	&lt;ArithmeticValue&gt; How many bytes (or characters) used for C data.	fParamType	&lt;SmallInteger&gt;	Flag indicating bound for input (to db) or output, or both.	getSelector	&lt;method&gt;	Method which converts retrieved C data, and returns Smalltalk object.	ibScale		&lt;SmallInteger&gt;	For FixedPoint objects, the scale.	pcbValue	&lt;CPointer&gt;	Pointer to size of C data (cb is like count of bytes).	putSelector	&lt;method&gt;	Method which converts Smalltalk object to C data.	unicode	&lt;Boolean&gt;	For Strings, indicates whether to use unicode for this column or not.	isUnicodeColumn	&lt;Boolean&gt;	For Strings, indicates whether this is a Unicode column or not.</body></comment><class><name>ODBCBuffer</name><environment>Database</environment><super>Database.ODBC2Buffer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Private-ODBC Buffers</category><attributes><package>ODBCEXDI</package></attributes></class><comment><class-id>Database.ODBCBuffer</class-id><body>ODBC3Buffer is a private subclass, and extends ODBCBuffer to use ODBC 3.0 APIs. </body></comment><class><name>ODBCColumnDescription</name><environment>Database</environment><super>Database.ExternalDatabaseColumnDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fSqlType </inst-vars><class-inst-vars>lobDataTypes </class-inst-vars><imports></imports><category>Database-ODBC</category><attributes><package>ODBCEXDI</package></attributes></class><comment><class-id>Database.ODBCColumnDescription</class-id><body>ODBCColumnDescription adds ODBC-specific information to ExternalDatabaseColumnDescription.Instance Variables:	fSqlType	&lt;SmallInteger&gt;			Remembers the SQL type of the column.Class Instance Variables	lobDataTypes	&lt;OrderedCollection&gt;		A collection of large object data types.</body></comment><class><name>ODBCCLIMacOSX64Interface</name><environment>Database</environment><super>Database.ODBCCLI64BitInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Database.ODBCCLIMacOSX64InterfaceDictionary.*			</imports><category>Database-External-Libraries</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>libiodbc.dylib</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>ODBCEXDI</package></attributes></class><comment><class-id>Database.ODBCCLIMacOSX64Interface</class-id><body>ODBCCLIMacOSX64Interface is used with the 64-bit Mac OSX environement.</body></comment><class><name>ODBCCLISolarisInterface</name><environment>Database</environment><super>Database.ODBCCLIInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Database.ODBCCLISolarisInterfaceDictionary.*			</imports><category>Database-External-Libraries</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>libiodbc.so</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>ODBCEXDI</package></attributes></class><comment><class-id>Database.ODBCCLISolarisInterface</class-id><body>ODBCCLISolarisInterface defines the ODBC calling conventions on the Solaris platform.</body></comment><class><name>ODBCCLILinuxInterface</name><environment>Database</environment><super>Database.ODBCCLIInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Database.ODBCCLILinuxInterfaceDictionary.*			</imports><category>Database-External-Libraries</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>libiodbc.so</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>ODBCEXDI</package></attributes></class><comment><class-id>Database.ODBCCLILinuxInterface</class-id><body>ODBCCLILinuxInterface defines the ODBC calling conventions on the Linux (Intel) platforms.</body></comment><class><name>ODBCTransaction</name><environment>Database</environment><super>Database.ExternalDatabaseTransaction</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-ODBC</category><attributes><package>ODBCEXDI</package></attributes></class><comment><class-id>Database.ODBCTransaction</class-id><body>ODBCTransaction is the concrete implementation of the transaction concept for the ODBC Connect. </body></comment><class><name>ODBCCLILinux64Interface</name><environment>Database</environment><super>Database.ODBCCLI64BitInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Database.ODBCCLILinux64InterfaceDictionary.*			</imports><category>Database-External-Libraries</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>libiodbc.so</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>ODBCEXDI</package></attributes></class><comment><class-id>Database.ODBCCLILinux64Interface</class-id><body>ODBCCLILinux64Interface is used with the 64-bit Linux environement.</body></comment><class><name>ODBCException</name><environment>Database</environment><super>Database.ExternalDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-ODBC</category><attributes><package>ODBCEXDI</package></attributes></class><comment><class-id>Database.ODBCException</class-id><body>ODBCException is raised in case of an ODBC error.</body></comment><class><name>UnableToGetConnectionOptions</name><environment>Database</environment><super>Database.ODBCException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-ODBC</category><attributes><package>ODBCEXDI</package></attributes></class><comment><class-id>Database.UnableToGetConnectionOptions</class-id><body>UnableToGetConnectionOptions is used to indicate that error occurs when getting a connection option.</body></comment><class><name>UnableToSetStatementOptions</name><environment>Database</environment><super>Database.ODBCException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-ODBC</category><attributes><package>ODBCEXDI</package></attributes></class><comment><class-id>Database.UnableToSetStatementOptions</class-id><body>UnableToSetStatementOptions is used to indicate that error occurs when setting a statement option.</body></comment><class><name>ODBCDataSource</name><environment>Database</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name description </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Private-ODBC Support</category><attributes><package>ODBCEXDI</package></attributes></class><comment><class-id>Database.ODBCDataSource</class-id><body>ODBCDataSource is a class used to remember ODBC data sources.Instance Variables:	description	&lt;String&gt;	Description of the data source.	name	&lt;String&gt;	Name of the data source.</body></comment><class><name>ODBCCLIMacOSXInterface</name><environment>Database</environment><super>Database.ODBCCLIInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Database.ODBCCLIMacOSXInterfaceDictionary.*			</imports><category>Database-External-Libraries</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>libiodbc.dylib</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>ODBCEXDI</package></attributes></class><comment><class-id>Database.ODBCCLIMacOSXInterface</class-id><body>ODBCCLIMacOSXInterface defines the ODBC calling conventions on the MacOSX platform.</body></comment><class><name>ODBC2Session</name><environment>Database</environment><super>Database.ExternalDatabaseSession</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hstmtHolder resultsCache bindValuePointers mustResendQueryHolder fetchLongResultsAnyOrder maxLongData sqlStatementOptionCache queryIsPROC unicode encoding unicodeEncoding lobBufferSize currentRowIndex rowsInBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-ODBC</category><attributes><package>ODBCEXDI</package></attributes></class><comment><class-id>Database.ODBC2Session</class-id><body>ODBCSession contains the ODBC-specfic protocols for the External Database Interface (EXDI).By using this package with a properly-configured ODBC client, Windows apps can interact with Database servers.Further information on the EXDI framework can be found in the "Database Application Developer''s Guide" (located in the /doc subdirectory of the VisualWorks installation).Instance Variables	bindValuePointers	&lt;Dictionary&gt;	 Maps position (in query) to corresponding bind object, an ODBCBuffer.	fetchLongResultsAnyOrder &lt;Boolean&gt;	Indicates whether all objects positioned after a large object must be fetched after execution.	hstmtHolder	&lt;ValueModel&gt;	Holds ODBC statement handle used to identify this session.	maxLongData	&lt;SmallInteger&gt;	Max number of bytes to read from long columns.	mustResendQueryHolder	&lt;ValueModel&gt;	Indicates whether cursor was dropped and must be prepared again.	resultsCache	&lt;Collection&gt;	Holds statement errors until they are processed.	sqlStatementOptionCache	&lt;IdentityDictionary&gt;	Maps formal statement options, if supported by db.	queryIsPROC	&lt;Boolean&gt;	True if this query calls a stored procedure, else False.	unicode	&lt;Boolean&gt;	 indicates whether the binding strings are unicode or not.	encoding	&lt;Symbol&gt;	A symbol remembers the encoding selection.	unicodeEncoding	&lt;Symbol&gt;	A symbol remembers the encoding selection for the Unicode strings.	lobBufferSize &lt;SmallInteger&gt;	 The size of the buffer used to transfer LOB data between client and server.	currentRowIndex &lt;SmallInteger&gt; Part of the support for utilizing the array interface for fetching rows.	rowsInBlock &lt;SmallInteger&gt; Part of the support for utilizing the array interface for fetching rows.Shared Variables	DefaultMaxLongData &lt;Integer&gt; Default size of long data.	RegisteredODBCSessions &lt;Collection&gt;	The collection of active sessions.	SQLStatementOptionConversionMap &lt;IdentityDictionary&gt; A set of associations between SQL Statement Option types and conversion message names.</body></comment><class><name>ODBCSession</name><environment>Database</environment><super>Database.ODBC2Session</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pNumRowsFetchedHolder pRowStatusArrayHolder pParamsProcessedHolder pParamStatusArrayHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-ODBC</category><attributes><package>ODBCEXDI</package></attributes></class><comment><class-id>Database.ODBCSession</class-id><body>ODBC3Session contains the ODBC 3.0 - specfic protocols for the External Database Interface (EXDI).Instance Variables:	pNumRowsFetchedHolder	&lt;ValueHolder on: (CPointer | nil)&gt;		A private value holder which remembers the pointer to number of rows fetched.	pRowStatusArrayHolder	&lt;ValueHolder on: (CPointer | nil)&gt;		A private value holder which remembers the pointer to array of row status.	pParamsProcessedHolder	&lt;ValueHolder on: (CPointer | nil)&gt;		A private value holder which remembers the pointer to number of parameters processed.	pParamStatusArrayHolder	&lt;ValueHolder on: (CPointer | nil)&gt;		A private value holder which remembers the pointer to array of parameter status.</body></comment><class><name>ODBCConnection</name><environment>Database</environment><super>Database.ODBC2Connection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-ODBC</category><attributes><package>ODBCEXDI</package></attributes></class><comment><class-id>Database.ODBCConnection</class-id><body>ODBC3Connection is the concrete class implementation of connection services using the ODBC 3.0 APIs.</body></comment><class><name>ODBCLargeObjectBuffer</name><environment>Database</environment><super>Database.ODBC2Buffer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pcbSizeIndicator </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Private-ODBC Buffers</category><attributes><package>ODBCEXDI</package></attributes></class><comment><class-id>Database.ODBCLargeObjectBuffer</class-id><body>ODBCLargeObjectBuffer is a private subclass, and extends ODBCBuffer to send and retrieve data by chunks. This is appropriate for large objects like Strings and ByteArrays. Normally, data bound to an ODBC query is transferred automatically when the query is executed. But large objects need to be transferred after execution, in concert with the server. This is called binding at execution, in contrast to the usual binding before execution.This class can be used to hold regular objects or large objects. Sometimes regular objects also need to be bound at execution. For example, there is an optional ODBC implementation which requires all bound objects which appear in the query after a large object to be bound this way. ODBCSession checks for this requirement by the server, and selects this class as appropriate.Instance Variables	pcbSizeIndicator	&lt;CPointer&gt;	Pointer to size of C data in bytes. This value is used for input binding. Some drivers need this value to be available for the entire chunks transfer process.</body></comment><class><name>UnableToGetStatementOptions</name><environment>Database</environment><super>Database.ODBCException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-ODBC</category><attributes><package>ODBCEXDI</package></attributes></class><comment><class-id>Database.UnableToGetStatementOptions</class-id><body>UnableToGetStatementOptions is used to indicate that error occurs when getting a statement option.</body></comment><class><name>ODBCError</name><environment>Database</environment><super>Database.ExternalDatabaseError</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sqlState </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-ODBC</category><attributes><package>ODBCEXDI</package></attributes></class><comment><class-id>Database.ODBCError</class-id><body>ODBCError adds information about the error returned from the ODBC APIs.  Refer to the ODBC documentation for further details.Instance Variables:	sqlState	&lt;String&gt;	Remembers the value of sqlState.</body></comment><class><name>UnableToSetConnectionOptions</name><environment>Database</environment><super>Database.ODBCException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-ODBC</category><attributes><package>ODBCEXDI</package></attributes></class><comment><class-id>Database.UnableToSetConnectionOptions</class-id><body>UnableToSetConnectionOptions is used to indicate that error occurs when setting a connection option.</body></comment><shared-variable><name>ConnectionPooling</name><environment>Database.ODBC2Connection</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>ODBCEXDI</package></attributes></shared-variable><shared-variable><name>SupportedIsolationLevels</name><environment>Database.ODBC2Connection</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>ODBCEXDI</package></attributes></shared-variable><shared-variable><name>Henv</name><environment>Database.ODBC2Connection</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>ODBCEXDI</package></attributes></shared-variable><shared-variable><name>HenvLock</name><environment>Database.ODBC2Connection</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>ODBCEXDI</package></attributes></shared-variable><shared-variable><name>ConnectionsArePooled</name><environment>Database.ODBC2Connection</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>ODBCEXDI</package></attributes></shared-variable><shared-variable><name>RegisteredODBCConnections</name><environment>Database.ODBC2Connection</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>ODBCEXDI</package></attributes></shared-variable><shared-variable><name>CpStrictMatch</name><environment>Database.ODBC2Connection</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>ODBCEXDI</package></attributes></shared-variable><shared-variable><name>SQLInfoTypeConversionMap</name><environment>Database.ODBC2Connection</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>ODBCEXDI</package></attributes></shared-variable><shared-variable><name>HenvReferencesCount</name><environment>Database.ODBC2Connection</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>ODBCEXDI</package></attributes></shared-variable><shared-variable><name>SQLConnectionOptionConversionMap</name><environment>Database.ODBC2Connection</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>ODBCEXDI</package></attributes></shared-variable><shared-variable><name>SQLEnvironmentAttributeConversionMap</name><environment>Database.ODBCConnection</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>ODBCEXDI</package></attributes></shared-variable><shared-variable><name>ODBCCLIMacOSX64InterfaceDictionary</name><environment>Database</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>ODBCEXDI</package></attributes></shared-variable><shared-variable><name>ODBCCLIAIXInterfaceDictionary</name><environment>Database</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>ODBCEXDI</package></attributes></shared-variable><shared-variable><name>ODBCCLINTInterfaceDictionary</name><environment>Database</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>ODBCEXDI</package></attributes></shared-variable><shared-variable><name>ODBCCLIMacOSXInterfaceDictionary</name><environment>Database</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>ODBCEXDI</package></attributes></shared-variable><shared-variable><name>ODBCCLILinuxInterfaceDictionary</name><environment>Database</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>ODBCEXDI</package></attributes></shared-variable><shared-variable><name>ODBCCLINT64InterfaceDictionary</name><environment>Database</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>ODBCEXDI</package></attributes></shared-variable><shared-variable><name>ODBCCLILinux64InterfaceDictionary</name><environment>Database</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>ODBCEXDI</package></attributes></shared-variable><shared-variable><name>ODBCCLISolarisInterfaceDictionary</name><environment>Database</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>ODBCEXDI</package></attributes></shared-variable><shared-variable><name>ODBCCLI64BitInterfaceDictionary</name><environment>Database</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>ODBCEXDI</package></attributes></shared-variable><shared-variable><name>ODBCCLIInterfaceDictionary</name><environment>Database</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>ODBCEXDI</package></attributes></shared-variable><shared-variable><name>ODBCCLI95InterfaceDictionary</name><environment>Database</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>ODBCEXDI</package></attributes></shared-variable><shared-variable><name>PutSelectorMap</name><environment>Database.ODBC2Buffer</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>ODBCEXDI</package></attributes></shared-variable><shared-variable><name>ValuePrecisionBlocks</name><environment>Database.ODBC2Buffer</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>ODBCEXDI</package></attributes></shared-variable><shared-variable><name>ValueSizeBlocks</name><environment>Database.ODBC2Buffer</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>ODBCEXDI</package></attributes></shared-variable><shared-variable><name>GetSelectorMap</name><environment>Database.ODBC2Buffer</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>ODBCEXDI</package></attributes></shared-variable><shared-variable><name>CTypeFromConversionMap</name><environment>Database.ODBC2Buffer</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>ODBCEXDI</package></attributes></shared-variable><shared-variable><name>FetchBufferSizeBlocks</name><environment>Database.ODBC2Buffer</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>ODBCEXDI</package></attributes></shared-variable><shared-variable><name>SQLTypeFromConversionMap</name><environment>Database.ODBC2Buffer</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>ODBCEXDI</package></attributes></shared-variable><shared-variable><name>RegisteredODBCSessions</name><environment>Database.ODBC2Session</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>ODBCEXDI</package></attributes></shared-variable><shared-variable><name>DefaultMaxLongData</name><environment>Database.ODBC2Session</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>ODBCEXDI</package></attributes></shared-variable><shared-variable><name>SQLStatementOptionConversionMap</name><environment>Database.ODBC2Session</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>ODBCEXDI</package></attributes></shared-variable><methods><class-id>Database.ODBCCLIInterface</class-id> <category>accessing</category><body package="ODBCEXDI">charDataTypeUnicode: aBool	^aBool ifTrue: [self WCHAR] ifFalse: [self UCHAR]</body><body package="ODBCEXDI">copyToHeapSelector	^#copyToHeap</body><body package="ODBCEXDI">encoding	encoding == nil ifTrue: [encoding := self getEncoding].	^encoding</body><body package="ODBCEXDI">encoding: anEncoding	encoding := anEncoding</body><body package="ODBCEXDI">getDataChunkSize	^self class getDataChunkSize</body><body package="ODBCEXDI">getDataTransferSize	^self class getDataChunkSize</body><body package="ODBCEXDI">getEncoding	^#default</body><body package="ODBCEXDI">longIntegerType	"This returns the CIntegerType used in some malloc: calls for a long int."	^CIntegerType long</body><body package="ODBCEXDI">mallocSelector	^#malloc:</body><body package="ODBCEXDI">setDataChunkSize: anInteger	self class setDataChunkSize: anInteger</body><body package="ODBCEXDI">setDataTransferSize: anInteger	self class setDataChunkSize: anInteger</body></methods><methods><class-id>Database.ODBCCLIInterface</class-id> <category>macros</category><body package="ODBCEXDI">SQL_ADD_RECORD: hstmt with: irow	"#define SQL_ADD_RECORD(hstmt, irow) SQLSetPos(hstmt ,irow ,SQL_ADD,SQL_LOCK_NO_CHANGE)"	^self SQLSetPos: hstmt with: irow with: self SQL_ADD with: self SQL_LOCK_NO_CHANGE</body><body package="ODBCEXDI">SQL_DELETE_RECORD: hstmt with: irow	"#define SQL_DELETE_RECORD(hstmt, irow) SQLSetPos(hstmt ,irow ,SQL_DELETE,SQL_LOCK_NO_CHANGE)"			^self SQLSetPos: hstmt with: irow with: self  SQL_DELETE with: self SQL_LOCK_NO_CHANGE</body><body package="ODBCEXDI">SQL_LEN_DATA_AT_EXEC: length	"#define SQL_LEN_DATA_AT_EXEC(length) (-length +SQL_LEN_DATA_AT_EXEC_OFFSET)"	^length negated + self SQL_LEN_DATA_AT_EXEC_OFFSET</body><body package="ODBCEXDI">SQL_LOCK_RECORD: hstmt with: irow with: fLock	"#define SQL_LOCK_RECORD(hstmt, irow, fLock) SQLSetPos(hstmt ,irow ,SQL_POSITION,fLock )"	^self SQLSetPos: hstmt with: irow with: self SQL_POSITION with: fLock</body><body package="ODBCEXDI">SQL_POSITION_TO: hstmt with: irow	"#define SQL_POSITION_TO(hstmt, irow) SQLSetPos(hstmt ,irow ,SQL_POSITION,SQL_LOCK_NO_CHANGE)"	^self SQLSetPos: hstmt with: irow with: self SQL_POSITION with: self SQL_LOCK_NO_CHANGE</body><body package="ODBCEXDI">SQL_REFRESH_RECORD: hstmt with: irow with: fLock	"#define SQL_REFRESH_RECORD(hstmt, irow, fLock) SQLSetPos(hstmt ,irow ,SQL_REFRESH,fLock )"	^self SQLSetPos: hstmt with: irow with: self SQL_REFRESH with: fLock</body><body package="ODBCEXDI">SQL_UPDATE_RECORD: hstmt with: irow	"#define SQL_UPDATE_RECORD(hstmt, irow) SQLSetPos(hstmt ,irow ,SQL_UPDATE,SQL_LOCK_NO_CHANGE)"		^self SQLSetPos: hstmt with: irow with: self SQL_UPDATE with: self SQL_LOCK_NO_CHANGE</body></methods><methods><class-id>Database.ODBCCLIInterface class</class-id> <category>fileIn/Out</category><body package="ODBCEXDI">binaryInitializationMessagesFor: sourceMode	"Answer a list of message sends used to initialize the receiver."	| list |	list := super binaryInitializationMessagesFor: sourceMode.	list add: (		MessageSend			receiver: self			selector: #deferredInitialize).	^list</body></methods><methods><class-id>Database.ODBCCLIInterface class</class-id> <category>class initialization</category><body package="ODBCEXDI">deferredInitialize	"Used to initialize the class after file-in or BOSS-in."	^self	"Noop for InformixCLIInterface"</body><body package="ODBCEXDI">initialize	| bufferClass |	self initializeMaps.	(bufferClass := self environment at: #ODBCBuffer ifAbsent: [ nil ]) notNil ifTrue:		[ bufferClass install ]</body><body package="ODBCEXDI">initializeMaps	| xif charVPB binVPB |	dataChunkSize := 1048576.  "Set the default chunk size."	xif := self new.	"Create the association tables for row buffer and bound parameter encoding...	The getSelectorMap needs to have a message name understood by		ODBCBuffer for each conversion.	The putSelectorMap needs to have a message name understood by		ODBCBuffer for each conversion.	The fSqlTypeToConversionMap associates ODBCBuffer conversion names		with the supported fSqlTypes.  Note, several ODBC SQL types may map		to the same conversion name.	The fSqlType and fCType used for each conversion are based on		the structure of the value buffer expected by the putSelector method.	The fetchBufferSizeBlocks are given the length of the column as answered by		SQLDescribeCol and answer the size to allocate to store data for that		conversion name.	The valueSizeBlocks are given an instance of the data to put in the buffer and		answer the number of bytes to allocate.  Since large objects are inserted		as a series of chunks, the buffer size is equal to the chunk size.	The valuePrecisionBlocks are given an instance of the data to put in the buffer and		answer the number of elements which may be stored in the buffer.  Note that		this value is ignored by SQLSetParam unless the fSqlType is one of the CHAR		or GRAPHIC types and the block for any ignored case should answer 0 (this will		improve the chance of early detection if ODBC ceases to ignore them).  For the		CHAR and GRAPHIC types, the answer is the maximum number of characters		(not bytes) to be provided by that parameter."	getSelectorMap := IdentityDictionary new.	putSelectorMap := IdentityDictionary new.	fSqlTypeToConversionMap := IdentityDictionary new.	fSqlTypeFromConversionMap := IdentityDictionary new.	fCTypeFromConversionMap := IdentityDictionary new.	fetchBufferSizeBlocks := IdentityDictionary new.	valueSizeBlocks := IdentityDictionary new.	valuePrecisionBlocks := IdentityDictionary new.	"Conversion to/from buffer for Date."	getSelectorMap add: ( #Date -&gt;  #getDateAt: ).	putSelectorMap add: ( #Date -&gt;  #at:putDate: ).	fSqlTypeToConversionMap add: ( xif SQL_DATE -&gt; #Date ).	fSqlTypeFromConversionMap add: ( #Date -&gt; xif SQL_TIMESTAMP ).	fSqlTypeFromConversionMap add: ( #Date -&gt; xif SQL_DATE ).	fCTypeFromConversionMap add: ( #Date -&gt; xif SQL_C_DATE ).	fetchBufferSizeBlocks add: ( #Date -&gt; [ :ignored | 6 ] ).	valueSizeBlocks add: ( #Date -&gt; [ :ignoredValue | 6 ] ).	valuePrecisionBlocks add: ( #Date -&gt; [ :ignoredValue | 0 ] ).	"Not used by SQLSetParam"	"Conversion to/from buffer for Double."	getSelectorMap add: ( #Double -&gt; #getDoubleAt: ).	putSelectorMap add: ( #Double -&gt; #at:putDouble: ).	fSqlTypeToConversionMap add: ( xif SQL_DOUBLE -&gt; #Double ).	fSqlTypeToConversionMap add: ( xif SQL_FLOAT -&gt; #Double ).	fSqlTypeFromConversionMap add: ( #Double -&gt; xif SQL_DOUBLE ).	fCTypeFromConversionMap add: ( #Double -&gt; xif SQL_C_DOUBLE ).	fetchBufferSizeBlocks add: ( #Double -&gt; [ :ignored | 8 ] ).	valueSizeBlocks add: ( #Double -&gt; [ :ignoredValue | 8 ] ).	valuePrecisionBlocks add: ( #Double -&gt; [ :ignoredValue | 0 ] ).	"Not used by SQLSetParam"	"Conversion to/from buffer for FixedPoint."	fSqlTypeToConversionMap add: ( xif SQL_DECIMAL -&gt; #FixedPoint ).	getSelectorMap add: ( #FixedPoint -&gt; #getFixedPointAt: ).	putSelectorMap add: ( #FixedPoint -&gt; #at:putFixedPoint: ).	fSqlTypeToConversionMap add: ( xif SQL_NUMERIC -&gt; #FixedPoint ).	fSqlTypeFromConversionMap add: ( #FixedPoint -&gt; xif SQL_DECIMAL ).	fCTypeFromConversionMap add: ( #FixedPoint -&gt; xif SQL_C_CHAR ).	fetchBufferSizeBlocks add: ( #FixedPoint -&gt; [ :size | size + 3 ] ).	"Add room for sign, decimal point, and null byte"	valueSizeBlocks add: ( #FixedPoint -&gt; [ :ignoredValue | 34 ] ).	"Leave room for sign, decimal point, and null byte"	valuePrecisionBlocks add: ( #FixedPoint -&gt; [ :ignoredValue | 31 ] ).	"This be the max."	"Conversion from buffer for Float."	getSelectorMap add: ( #Float -&gt; #getFloatAt: ).	putSelectorMap add: ( #Float -&gt; #at:putFloat: ).	fSqlTypeToConversionMap add: ( xif SQL_REAL -&gt; #Float ).	fSqlTypeFromConversionMap add: ( #Float -&gt; xif SQL_DOUBLE ).	fCTypeFromConversionMap add: ( #Float -&gt; xif SQL_C_FLOAT ).	fetchBufferSizeBlocks add: ( #Float -&gt; [ :ignored | 4 ] ).	valueSizeBlocks add: ( #Float -&gt; [ :ignoredValue | 4 ] ).	valuePrecisionBlocks add: ( #Float -&gt; [ :ignoredValue | 0 ] ).	"Not used by SQLSetParam"	"Conversion from buffer for Integer."	getSelectorMap add: ( #Integer -&gt; #getIntegerAt: ).	putSelectorMap add: ( #Integer -&gt; #at:putInteger: ).	fSqlTypeToConversionMap add: ( xif SQL_SMALLINT -&gt; #Integer ).	fSqlTypeToConversionMap add: ( xif SQL_INTEGER -&gt; #Integer ).	fSqlTypeFromConversionMap add: ( #Integer -&gt; xif SQL_INTEGER ).	fCTypeFromConversionMap add: ( #Integer -&gt; xif SQL_C_LONG ).	fetchBufferSizeBlocks add: ( #Integer -&gt; [ :ignored | 4 ] ).	valueSizeBlocks add: ( #Integer -&gt; [ :ignoredValue | 4 ] ).	valuePrecisionBlocks add: ( #Integer -&gt; [ :ignoredValue | 0 ] ).	"Not used by SQLSetParam"	"Conversion to/from buffer for LargeInteger."	getSelectorMap add: ( #LargeInteger -&gt; #getLargeIntegerAt: ).	putSelectorMap add: ( #LargeInteger -&gt; #at:putLargeInteger: ).	fSqlTypeToConversionMap add: ( xif SQL_BIGINT -&gt; #LargeInteger ).	fSqlTypeFromConversionMap add: ( #LargeInteger -&gt; xif SQL_BIGINT ).	fCTypeFromConversionMap add: ( #LargeInteger -&gt; xif SQL_C_CHAR ).	fetchBufferSizeBlocks add: ( #LargeInteger -&gt; [ :size | size + 2 ] ).	"Add room for sign and null byte"	valueSizeBlocks add: ( #LargeInteger -&gt; [ :ignoredValue | 21 ] ).	"Leave room for sign and null byte"	valuePrecisionBlocks add: ( #LargeInteger -&gt; [ :ignoredValue | 19 ] ).	"This be the max."	"Conversion from buffer for String.	In order to improve the chance that the buffer will hold alternate values	without requiring the application to prepare the SQL again, the	number of characters (and bytes to allocate) is guaranteed to be at least	256 and never more than the largest size currently known to be supported	for the CHAR data types.  In between that range, the size is rounded up to	the next largest power of 2."	getSelectorMap add: ( #String -&gt; #getStringAt: ).	putSelectorMap add: ( #String -&gt; #at:putString: ).	getSelectorMap add: ( #LargeString -&gt; #getStringAt: ).	putSelectorMap add: ( #LargeString -&gt; #at:putString: ).	fSqlTypeToConversionMap add: ( xif SQL_CHAR -&gt; #String ).	fSqlTypeToConversionMap add: ( xif SQL_VARCHAR -&gt; #String ).	fSqlTypeToConversionMap add: ( xif SQL_LONGVARCHAR -&gt; #LargeString ).	fSqlTypeToConversionMap add: ( xif SQL_CLOB -&gt; #LargeString ).	fSqlTypeToConversionMap add: ( xif SQL_DBCLOB -&gt; #LargeString ).	fSqlTypeToConversionMap add: ( xif SQL_VARIANT -&gt; #String ).	fSqlTypeToConversionMap add: ( xif SQL_WLONGVARCHAR -&gt; #LargeString ).	fSqlTypeToConversionMap add: ( xif SQL_WVARCHAR -&gt; #String ).	fSqlTypeToConversionMap add: ( xif SQL_WCHAR -&gt; #String ).	fSqlTypeToConversionMap add: ( xif SQL_GRAPHIC -&gt; #String ).	fSqlTypeToConversionMap add: ( xif SQL_VARGRAPHIC -&gt; #String ).	fSqlTypeToConversionMap add: ( xif SQL_LONGVARGRAPHIC -&gt; #LargeString ).	fSqlTypeFromConversionMap add: ( #String -&gt; xif SQL_VARCHAR ).	fSqlTypeFromConversionMap add: ( #LargeString -&gt; xif SQL_LONGVARCHAR ).	fCTypeFromConversionMap add: ( #String -&gt; xif SQL_C_CHAR ).	fCTypeFromConversionMap add: ( #LargeString -&gt; xif SQL_C_CHAR ).	charVPB := [ :str | | sz |		(sz := str size) &lt;= 255			ifTrue: [ sz ]			ifFalse: [ 65536 min: (2 raisedTo: ( (sz floorLog: 2) + 1) ) ] ].	fetchBufferSizeBlocks add: ( #String -&gt; [ :size | size + 1 ] ).	"Leave room for a null."	fetchBufferSizeBlocks add: ( #LargeString -&gt;   [:size | (self getDataChunkSize min: size)  + 1 ]  ).	"Leave room for a null."	valueSizeBlocks add: ( #String -&gt; charVPB ).	valuePrecisionBlocks add: ( #String -&gt; charVPB ).	valuePrecisionBlocks add: ( #LargeString -&gt; [:str | str size] ).	"Conversion from buffer for Time."	getSelectorMap add: ( #Time -&gt; #getTimeAt: ).	getSelectorMap add: ( #Time2 -&gt; #getTimeAt: ).	putSelectorMap add: ( #Time -&gt; #at:putTime: ).	putSelectorMap add: ( #Time2 -&gt; #at:putTime: ).	fSqlTypeToConversionMap add: ( xif SQL_TIME -&gt; #Time ).	fSqlTypeToConversionMap add: ( xif SQL_SS_TIME2 -&gt; #Time2 ).	fSqlTypeToConversionMap add: ( xif SQL_TYPE_DATE -&gt; #Date ). "ODBC 3.0"	fSqlTypeFromConversionMap add: ( #Time -&gt; xif SQL_TIMESTAMP ).	fSqlTypeFromConversionMap add: ( #Time2 -&gt; xif SQL_SS_TIME2 ).	fCTypeFromConversionMap add: ( #Time -&gt; xif SQL_C_TIME ).	fCTypeFromConversionMap add: ( #Time2 -&gt; xif SQL_C_BINARY).	fetchBufferSizeBlocks add: ( #Time -&gt; [ :ignored | 6 ] ).	fetchBufferSizeBlocks add: ( #Time2 -&gt; [ :ignored | 12 ] ).	valueSizeBlocks add: ( #Time -&gt; [ :ignoredValue | 6 ] ).	valueSizeBlocks add: ( #Time2 -&gt; [ :ignoredValue | 12 ] ).	valuePrecisionBlocks add: ( #Time -&gt; [ :ignoredValue | 0 ] ).	"Not used by SQLSetParam"	valuePrecisionBlocks add: ( #Time2 -&gt; [ :ignoredValue | 0 ] ).	"Not used by SQLSetParam"	"Conversion from buffer for Timestamp."	getSelectorMap add: ( #Timestamp -&gt; #getTimestampAt: ).	putSelectorMap add: ( #Timestamp -&gt; #at:putTimestamp: ).	fSqlTypeToConversionMap add: ( xif SQL_TIMESTAMP -&gt; #Timestamp ).	fSqlTypeToConversionMap add: ( xif SQL_TYPE_TIMESTAMP -&gt; #Timestamp ). "ODBC 3.0"	fSqlTypeFromConversionMap add: ( #Timestamp -&gt; xif SQL_TIMESTAMP ).	fCTypeFromConversionMap add: ( #Timestamp -&gt; xif SQL_C_TIMESTAMP ).	fetchBufferSizeBlocks add: ( #Timestamp -&gt; [ :ignored | 16 ] ).	valueSizeBlocks add: ( #Timestamp -&gt; [ :ignoredValue | 16 ] ).	valuePrecisionBlocks add: ( #Timestamp -&gt; [ :ignoredValue | 0 ] ).	"Not used by SQLSetParam"	"Conversion to/from buffer for Boolean."	getSelectorMap add: ( #Boolean -&gt; #getBooleanAt: ).	putSelectorMap add: ( #Boolean -&gt; #at:putBoolean: ).	fSqlTypeToConversionMap add: ( xif SQL_BIT -&gt; #Boolean ).	fSqlTypeFromConversionMap add: ( #Boolean -&gt; xif SQL_BIT ).	fCTypeFromConversionMap add: ( #Boolean -&gt; xif SQL_C_BIT ).	fetchBufferSizeBlocks add: ( #Boolean -&gt; [ :ignored | 1 ] ).	valueSizeBlocks add: ( #Boolean -&gt; [ :ignored | 1 ] ).	valuePrecisionBlocks add: ( #Boolean -&gt; [ :ignored | 0 ] ).	"Not used by SQLSetParam"	"Conversion to/from buffer for ByteArray."	"Only used if ODBC.INI option BITDATA = 1"	getSelectorMap add: ( #ByteArray -&gt; #getByteArrayAt: ).	putSelectorMap add: ( #ByteArray -&gt; #at:putByteArray: ).	getSelectorMap add: ( #LargeByteArray -&gt; #getByteArrayAt: ).	putSelectorMap add: ( #LargeByteArray -&gt; #at:putByteArray: ).	fSqlTypeToConversionMap add: ( xif SQL_BINARY -&gt; #ByteArray ).	fSqlTypeToConversionMap add: ( xif SQL_VARBINARY -&gt; #ByteArray ).	fSqlTypeToConversionMap add: ( xif SQL_LONGVARBINARY -&gt; #LargeByteArray ).	fSqlTypeToConversionMap add: ( xif SQL_BLOB -&gt; #LargeByteArray ).	fSqlTypeToConversionMap add: ( xif SQL_GUID -&gt; #ByteArray ).	fSqlTypeFromConversionMap add: ( #ByteArray -&gt; xif SQL_VARBINARY ).	fSqlTypeFromConversionMap add: ( #LargeByteArray -&gt; xif SQL_LONGVARBINARY ).	fCTypeFromConversionMap add: ( #ByteArray -&gt; xif SQL_C_BINARY  ).	fCTypeFromConversionMap add: ( #LargeByteArray -&gt; xif SQL_C_BINARY  ).	binVPB := [ :ba | | sz |		(sz := ba size) &lt;= 255 			ifTrue: [  sz ] 			ifFalse: [ 65536 min: (2 raisedTo: ( (sz floorLog: 2) + 1)) ] ].	fetchBufferSizeBlocks add: ( #ByteArray -&gt; [ :size | size ] ).	fetchBufferSizeBlocks add: ( #LargeByteArray -&gt; [:size | (self getDataChunkSize min: size) ]  ).	valueSizeBlocks add: ( #ByteArray -&gt; binVPB ).	valuePrecisionBlocks add: ( #ByteArray -&gt; binVPB ).		valuePrecisionBlocks add: ( #LargeByteArray -&gt; [:ba | ba size] ).		"More conversion from buffer for Integer.	Not expected from Informix but the doc says possible."	fSqlTypeToConversionMap add: ( xif SQL_TINYINT -&gt; #Integer ).</body></methods><methods><class-id>Database.ODBCCLIInterface class</class-id> <category>private-accessing</category><body package="ODBCEXDI">fCTypeFromConversionMap	^fCTypeFromConversionMap</body><body package="ODBCEXDI">fSqlTypeFromConversionMap	^fSqlTypeFromConversionMap</body><body package="ODBCEXDI">fSqlTypeToConversionMap	^fSqlTypeToConversionMap</body><body package="ODBCEXDI">fetchBufferSizeBlocks	^fetchBufferSizeBlocks</body><body package="ODBCEXDI">getSQLConnectionOptionConversionMap	^ODBC2Connection.SQLConnectionOptionConversionMap</body><body package="ODBCEXDI">getSQLStatementOptionConversionMap	^ODBC2Session.SQLStatementOptionConversionMap</body><body package="ODBCEXDI">getSelectorMap	^getSelectorMap</body><body package="ODBCEXDI">putSelectorMap	^putSelectorMap</body><body package="ODBCEXDI">valuePrecisionBlocks	^valuePrecisionBlocks</body><body package="ODBCEXDI">valueSizeBlocks	^valueSizeBlocks</body></methods><methods><class-id>Database.ODBCCLIInterface class</class-id> <category>accessing</category><body package="ODBCEXDI">getDataChunkSize	^dataChunkSize</body><body package="ODBCEXDI">setDataChunkSize: anInteger	dataChunkSize := anInteger</body></methods><methods><class-id>Database.ODBCCLIInterface class</class-id> <category>private</category><body package="ODBCEXDI">libraryFilesSearchSignals	"This class is expected to provide a list of exceptions which should be ignored	when the library is not found whilst searching for it under the wrong platfrom name."	^ExternalLibraryHolder libraryNotFoundSignal</body></methods><methods><class-id>Database.ODBCCLI64BitInterface</class-id> <category>accessing</category><body package="ODBCEXDI">longIntegerType	"This returns the CIntegerType used in some malloc: calls for a long int."	^CIntegerType longLong</body></methods><methods><class-id>Database.ODBCCLI64BitInterface class</class-id> <category>class initialization</category><body package="ODBCEXDI">initialize	super initialize</body></methods><methods><class-id>Database.ODBCCLINT64Interface class</class-id> <category>class initialization</category><body package="ODBCEXDI">initialize	super initialize</body></methods><methods><class-id>Database.ODBCCLIAIXInterface class</class-id> <category>class initialization</category><body package="ODBCEXDI">initialize	super initialize.</body></methods><methods><class-id>Database.ODBC2Connection</class-id> <category>private-accessing</category><body package="ODBCEXDI">generalInformationCache	^generalInformationCache</body><body package="ODBCEXDI">generalInformationCache: anIdentityDictionary	generalInformationCache := anIdentityDictionary</body><body package="ODBCEXDI">getConnectionErrors	"Return a non-empty collection of ODBCError(s) associated with the connection handle."	| xif errors err |	xif := self class xif.	errors := OrderedCollection new.		[(err := self getErrorsExternal: xif SQL_NULL_HENV				hdbc: self hdbc				hstmt: xif SQL_NULL_HSTMT) notNil] 			whileTrue: [errors add: err].	"Many senders assume non-empty collection."	errors isEmpty 		ifTrue: 			[err := self class defaultError.			errors add: err].	^errors</body><body package="ODBCEXDI">getConnectionOption: fOptionTypeSymbol	| ssoc |	^(ssoc := self sqlConnectionOptionCache) at: fOptionTypeSymbol ifAbsent:		[ | vOption |		vOption := self getConnectionOptionExternal: fOptionTypeSymbol.		ssoc at: fOptionTypeSymbol put: vOption.		vOption ].</body><body package="ODBCEXDI">getEnvironmentErrors	"Answer a non-empty collection of ODBCError(s) associated with the environment handle."	| xif errors err | 	xif := self class xif.	errors := OrderedCollection new.	HenvLock critical:		[ "Begin critical section."		[ (err := self getErrorsExternal: self class henv				hdbc: xif SQL_NULL_HDBC				hstmt: xif SQL_NULL_HSTMT) notNil ]			whileTrue: [ errors add: err ].		"End critical section." ].	"Many senders assume non-empty collection."	errors isEmpty 		ifTrue: 			[err := self class defaultError.			errors add: err].	^errors</body><body package="ODBCEXDI">getInformationType: anInfoTypeSymbol	"Answer driver sql type information"	| gic |	^(gic := self generalInformationCache) at: anInfoTypeSymbol ifAbsent:		[ | infoType |		infoType := self getInformationTypeExternal: anInfoTypeSymbol.		gic at: anInfoTypeSymbol put: infoType.		infoType ].</body><body package="ODBCEXDI">hdbc	^self hdbcHolder value</body><body package="ODBCEXDI">hdbc: aCPointerOrNil	self hdbcHolder value: aCPointerOrNil</body><body package="ODBCEXDI">hdbcHolder	^hdbcHolder</body><body package="ODBCEXDI">hdbcHolder: aValueHolder	hdbcHolder := aValueHolder</body><body package="ODBCEXDI">isolationLevel	"Get the current isolation level."	self isConnected ifTrue: [ | isoLev |		isoLev := self  getConnectionOption: #SQL_TXN_ISOLATION.		SupportedIsolationLevels keysAndValuesDo: [:aKey :aValue | (self class xif perform: aValue) == isoLev ifTrue: [ isolationLevel := aKey ]].		^isolationLevel	] ifFalse: [ ^self class connectionNotOpenSignal raise ].</body><body package="ODBCEXDI">isolationLevel: newIsolationLevel 	"Set the current isolation level."	| externalIsolationLevel |	externalIsolationLevel := SupportedIsolationLevels at: newIsolationLevel ifAbsent: [ExternalDatabaseConnection unsupportedIsolationLevelSignal raise].	self isConnected ifTrue: [self setIsolationLevel: externalIsolationLevel] ifFalse: [ ^self class connectionNotOpenSignal raise ].	isolationLevel := newIsolationLevel</body><body package="ODBCEXDI">setConnectionOption: fOptionTypeSymbol value: vOption	self setConnectionOptionExternal: fOptionTypeSymbol value: vOption.	^vOption</body><body package="ODBCEXDI">sqlConnectionOptionCache	^sqlConnectionOptionCache</body><body package="ODBCEXDI">sqlConnectionOptionCache: anIdentityDictionary	sqlConnectionOptionCache := anIdentityDictionary</body><body package="ODBCEXDI">supportedFunctions	^supportedFunctions</body><body package="ODBCEXDI">supportedFunctions: anIdentityDictionary	supportedFunctions := anIdentityDictionary</body><body package="ODBCEXDI">supportsFunction: fFunctionSymbol	"Answer if the attached driver supports the given function"	| sf |	^(sf := self supportedFunctions) at: fFunctionSymbol ifAbsent: 		[ | supported |		supported :=  self getSupportedFunctionExternal: fFunctionSymbol.            sf at: fFunctionSymbol put: supported.		supported ]</body><body package="ODBCEXDI">useDriverConnect: anEnvironmentString 	"Returns true if using the connect string to connect."	^(('DRIVER={*' match: anEnvironmentString) or: [ 'DSN=*' match: anEnvironmentString ]) or: [ 'FILEDSN=*' match: anEnvironmentString ]</body></methods><methods><class-id>Database.ODBC2Connection</class-id> <category>private-execution</category><body package="ODBCEXDI">acquireExternal: aPassword 	| xif name pw env rc |	xif := self class xif.	(env := self environment) isNil 		ifTrue: [env := self class defaultEnvironment].	[env isString] 		whileFalse: [env := self class requiredEnvironmentSignal raiseRequest].	env := self class mapLogical: env.	"Get required handles."	self allocConnect.	["Begin unwind protection -- ensure release of connection handle on failure."		rc := (self useDriverConnect: env) 			ifTrue: [ self acquireExternalUsingDriverConnectEnvironment: env ]			ifFalse:	[				name := self username ifNil: [ name := '' ].				pw := aPassword ifNil: [ pw := '' ].				self acquireExternalUsingConnectName: name					password: pw					environment: env].	rc == xif SQL_SUCCESS ifFalse: [ | errs errorMessage |		  	errs :=  self getConnectionErrors.			errorMessage := errs first dbmsErrorString.			rc == xif SQL_SUCCESS_WITH_INFO ifTrue: [ 				ExternalDatabaseNotification raiseRequestWith: errs errorString: errorMessage			] ifFalse: [ 				^self class unableToConnectToSQLserverSignal raiseWith: errs					errorString: errorMessage ]			]	"End unwind protection"] 			ifCurtailed: 				["Some failure is causing unwind, don't keep the handles."				HenvLock critical: [ self unprotectedFreeConnect ] ].	"Enter autocommit mode on the transaction."	self singleStatementTransactions.	"Set the correct isolation level for this connect"	"self setIsolationLevel: (SupportedIsolationLevels at: isolationLevel)."</body><body package="ODBCEXDI">acquireExternalUsingConnectName: aName password: aPassword environment: anEnvironment 	| xif szDSN szUID szAuthStr env1 nm1 pw1 rc |	xif := self class xif.	[ "Begin unwind protection -- ensure release of pointers on success or failure."	szDSN := (env1 := anEnvironment asByteArrayEncoding: self encoding) perform: xif copyToHeapSelector.	szUID := (nm1 := aName asByteArrayEncoding: self encoding) perform: xif copyToHeapSelector.	szAuthStr := (pw1 := aPassword asByteArrayEncoding: self encoding) perform: xif copyToHeapSelector.	self isUnicodeEncoding ifTrue: [		rc := xif SQLConnectW: self hdbc			with: szDSN			with: anEnvironment size			with: szUID			with: aName size			with: szAuthStr			with: aPassword size.	] ifFalse: [		rc := xif SQLConnect: self hdbc			with: szDSN			with: env1 size			with: szUID			with: nm1 size			with: szAuthStr			with: pw1 size.	].	traceLevel &gt;= 1		ifTrue: [			(self traceStream)				print: rc;				nextPutAll: ' = SQLConnect( hdbc = ';				nextPutAll: (self hdbc referentAddress printStringRadix: 16);				nextPutAll: ', szDSN = ';				nextPutAll: anEnvironment;				nextPutAll: ', szUID = ';				nextPutAll: aName;				nextPutAll: ', szAuthStr = ******* )'.			self class trace: self emitTrace]	"End unwind protection"]			ensure: [				szAuthStr notNil ifTrue: [szAuthStr freePointer].				szUID notNil ifTrue: [szUID freePointer].				szDSN notNil ifTrue: [szDSN freePointer] ].	^ rc</body><body package="ODBCEXDI">acquireExternalUsingDriverConnectEnvironment: anEnvironment 	| xif theHwnd encodedEnv szConnStrIn szConnStrOut cbConnStrOutMax pcbConnStrOut fDriverCompletion rc dt env |	xif := self class xif.	"A sample connect string for driver connect could be as the following"	"DRIVER={SQL Server};Database=dbname;UID=username;PWD=password;SERVER=servername;"	[	"Begin unwind protection -- ensure release of pointers on success or failure."		theHwnd := 0.	"Window currentWindow windowHandle"		env := anEnvironment copyWith: (Character value: 0).		szConnStrIn := (encodedEnv := env asByteArrayEncoding: self encoding) perform: xif copyToHeapSelector.		cbConnStrOutMax := 1024.		dt := xif charDataTypeUnicode: self isUnicodeEncoding.		szConnStrOut := dt perform: xif mallocSelector with: cbConnStrOutMax.		pcbConnStrOut := xif SWORD perform: xif mallocSelector with: 1.		fDriverCompletion := xif SQL_DRIVER_NOPROMPT.		self isUnicodeEncoding ifTrue: [			rc := xif SQLDriverConnectW: self hdbc					with: theHwnd					with: szConnStrIn					with: env size					with: szConnStrOut					with: cbConnStrOutMax					with: pcbConnStrOut					with: fDriverCompletion.		] ifFalse: [			rc := xif SQLDriverConnect: self hdbc					with: theHwnd					with: szConnStrIn					with: encodedEnv size					with: szConnStrOut					with: cbConnStrOutMax					with: pcbConnStrOut					with: fDriverCompletion.		].		self class traceLevel &gt;= 1		ifTrue: [			(self traceStream)				print: rc;				nextPutAll: ' = SQLDriverConnect( hdbc = ';				nextPutAll: (self hdbc referentAddress printStringRadix: 16);				nextPutAll: ' hwnd = ';				nextPutAll: (theHwnd printStringRadix: 16);				nextPutAll: ', szConnStrIn = ';				nextPutAll: szConnStrIn printString;				nextPutAll: ', cbConnStrIn = ';				nextPutAll: encodedEnv size printString;				nextPutAll: ', szConnStrOut = ';				nextPutAll: szConnStrOut printString;				nextPutAll: ', cbConnStrOutMax = ';				nextPutAll: cbConnStrOutMax printString;				nextPutAll: ', pcbConnStrOut = ';				nextPutAll: pcbConnStrOut printString;				nextPutAll: ', fDriverCompletion = ';				nextPutAll: (fDriverCompletion printStringRadix: 16);				nextPutAll: ' )'.			self class trace: self emitTrace]	"End unwind protection"]			ensure: [				szConnStrIn freePointer.				szConnStrOut freePointer.				pcbConnStrOut freePointer].	^ rc</body><body package="ODBCEXDI">beginExternal	super beginExternal.	self multiStatementTransactions</body><body package="ODBCEXDI">commitExternal	super commitExternal ifFalse: [ ^self ].	self transactExternal: #SQL_COMMIT.	self singleStatementTransactions</body><body package="ODBCEXDI">cursorsAreClosed	"Notify each participating session that the cursor was closed by some event (like commit or rollback)."	self participantsDo: [ :each | each cursorIsClosed ]</body><body package="ODBCEXDI">cursorsAreDeleted	"Notify each participating session that the cursor was deleted by some event (like commit or rollback)."	self participantsDo: [ :each | each cursorIsDeleted ]</body><body package="ODBCEXDI">dismissExternal	| xif rc |	xif  := self class xif.	[ "Begin unwind protection." 	rc := xif SQLDisconnect: self hdbc .	(traceLevel &gt;= 2) ifTrue:		[ (self traceStream)			print: rc;  			nextPutAll: ' = SQLDisconnect( hdbc = ';			nextPutAll: (self hdbc referentAddress printStringRadix: 16);			nextPutAll: ' )'.		self class trace: self emitTrace ].	(rc == xif SQL_SUCCESS) ifFalse:		[ | errs |		errs := self getConnectionErrors.		^self class unableToDisconnectSignal raiseRequestWith: errs ].	"End unwind protection." ]		ensure:			[ "Whether or not there was a failure, there's no point in hanging			onto the handles."			HenvLock critical: [ self unprotectedFreeConnect ].			self supportedFunctions: IdentityDictionary new.			self generalInformationCache: IdentityDictionary new ]</body><body package="ODBCEXDI">getConnectionOptionExternal: fOptionSymbol	"Answer the information associated with fOptionSymbol.  This information is defined only after connecting."	^self getConnectionOptionNumber: (self class xif perform: fOptionSymbol)</body><body package="ODBCEXDI">getConnectionOptionNumber: fOptionNumber	"Answer the information associated with fOptionNumber, but for the clarity of your code, use option symbols (method ODBCConnection&gt;&gt;getConnectionOptionExternal: fOptionSymbol) will be a better choice.  This information is defined only after connecting. "	| xif  rc ub  pvParam vParam optionConversion bufLen fOptionSymbol |	xif := self class xif.	[ "Begin unwind protection."		fOptionSymbol := SQLConnectionOptionConversionMap keys detect: [ :each | (xif perform: each) = fOptionNumber ] ifNone: [ nil ].		bufLen := fOptionSymbol isNil			ifTrue: [256]			ifFalse: [optionConversion := SQLConnectionOptionConversionMap at: fOptionSymbol.				      (optionConversion == #stringAt:) ifTrue: [ 256 ] ifFalse: [ ObjectMemory is64Bit ifTrue: [ 8 ] ifFalse: [ 4 ] ].		].		pvParam :=  xif SQLULEN perform: xif mallocSelector with: bufLen.		self allocConnect.		self isUnicodeEncoding ifTrue: [			rc := xif SQLGetConnectOptionW: self hdbc 						    		with: fOptionNumber						    		with: pvParam.		] ifFalse: [			rc := xif SQLGetConnectOption: self hdbc 						    		with: fOptionNumber						    		with: pvParam.		].		( traceLevel &gt;= 3 ) ifTrue:			[ (self traceStream)				print: rc; 				nextPutAll: ' = SQLGetConnectionOption( hdbc = ';				nextPutAll: (self hdbc referentAddress printStringRadix:16);				nextPutAll: ', fOption = '; print: fOptionNumber;				nextPutAll: ', pvParam =';				nextPutAll: (pvParam referentAddress printStringRadix:16);				nextPutAll: ' )'.			self class trace: self emitTrace ].		(rc == xif SQL_SUCCESS or: [ rc == xif SQL_SUCCESS_WITH_INFO]) ifFalse: [ | errs |			errs := self getConnectionErrors.			^self class unableToGetConnectionOptionsSignal raiseWith: errs errorString: errs first dbmsErrorString ].		ub := UninterpretedBytes new: bufLen.		pvParam copyAt: 0 to: ub size: bufLen startingAt: 1.		vParam := ub perform: optionConversion with: 1		"End unwind protection." ]		ensure:			[ pvParam notNil ifTrue: [ pvParam freePointer ]].	^vParam</body><body package="ODBCEXDI">getDataSourceExternal: fDirection	"Return the next piece of error or status information, or NULL if none."	| xif cbDSNMax cbDescriptionMax szDSN pcbDSN szDescription pcbDescription rc ds charDT |	xif := self class xif.	cbDSNMax :=  xif SQL_MAX_DSN_LENGTH + 1.	cbDescriptionMax := 254 + 1.	[ "Begin unwind protection."	charDT := xif charDataTypeUnicode: self isUnicodeEncoding.	szDSN := charDT perform: xif mallocSelector with: cbDSNMax.	pcbDSN := xif SWORD perform: xif mallocSelector with: 1.	szDescription := charDT perform: xif mallocSelector with: cbDescriptionMax.	pcbDescription := xif SWORD perform: xif mallocSelector with: 1.	HenvLock critical:		[ "Begin critical section."	self isUnicodeEncoding ifTrue: [		 rc := xif SQLDataSourcesW: self class henv			with: fDirection			with: szDSN			with: cbDSNMax			with: pcbDSN			with: szDescription			with: cbDescriptionMax			with: pcbDescription.	] ifFalse: [		 rc := xif SQLDataSources: self class henv			with: fDirection			with: szDSN			with: cbDSNMax			with: pcbDSN			with: szDescription			with: cbDescriptionMax			with: pcbDescription.	].		(( rc == xif SQL_SUCCESS )		or: [ rc == xif SQL_SUCCESS_WITH_INFO ] ) ifTrue:			[ ds := self class dataSourceClass new.			  ds name: szDSN copyCStringFromHeap.			  ds description: szDescription copyCStringFromHeap.]		"End critical section." ]	"End unwind protection." ]		ensure:			[ szDSN notNil ifTrue: [ szDSN freePointer ].			pcbDSN notNil ifTrue: [ pcbDSN freePointer ].			szDescription notNil ifTrue: [ szDescription freePointer ].		    pcbDescription notNil ifTrue: [ pcbDescription freePointer ] ].	^ds</body><body package="ODBCEXDI">getErrorsExternal: henvOrNull hdbc: hdbcOrNull hstmt: hstmtOrNull	"Return the next piece of error or status information, or nil if none."	| xif szSqlState pfNativeError szErrorMsg cbErrorMsgMax pcbErrorMsg rc error charType |	xif := self class xif.	[ "Begin unwind protection."	charType := xif charDataTypeUnicode: self isUnicodeEncoding.	szSqlState := charType perform: xif mallocSelector with: xif SQL_SQLSTATE_SIZE + 1.	pfNativeError := xif SDWORD perform: xif mallocSelector with: 1.	szErrorMsg := charType			perform: xif mallocSelector			with: (cbErrorMsgMax := xif SQL_MAX_MESSAGE_LENGTH + 1).	pcbErrorMsg := xif SWORD  perform: xif mallocSelector with: 1.	self isUnicodeEncoding ifTrue: [		rc := xif SQLErrorW: henvOrNull			with: hdbcOrNull			with: hstmtOrNull			with: szSqlState			with: pfNativeError			with: szErrorMsg			with: cbErrorMsgMax			with: pcbErrorMsg.	] ifFalse: [		rc := xif SQLError: henvOrNull			with: hdbcOrNull			with: hstmtOrNull			with: szSqlState			with: pfNativeError			with: szErrorMsg			with: cbErrorMsgMax			with: pcbErrorMsg.	].	rc == xif SQL_SUCCESS ifTrue:		[ error := self class errorClass new.	     	error dbmsErrorCode: pfNativeError contents.	     	error dbmsErrorString: (szErrorMsg copyCStringFromHeap: self encoding).	     	error sqlState: (szSqlState copyCStringFromHeap: self encoding).		( traceLevel &gt;= 2 ) ifTrue:			[ (self traceStream)				print: rc;  				nextPutAll: ' = SQLError( henv = *, hdbc = *, hstmt = *, szSqlState = '; 				nextPutAll: error sqlState;				nextPutAll: ', pfNativeError = '; print: error dbmsErrorCode;				nextPutAll: ', szErrorMsg = '; nextPutAll: error dbmsErrorString;				nextPutAll: ', cbErrorMsgMax = '; print: cbErrorMsgMax;				nextPutAll: ', pcbErrorMsg = '; print: pcbErrorMsg contents;				nextPutAll: ' )'; crtab.			self class trace: self emitTrace ] ].	"End unwind protection." ]		ensure:			[ szSqlState notNil ifTrue: [ szSqlState freePointer ].			pfNativeError notNil ifTrue: [ pfNativeError freePointer ].			szErrorMsg notNil ifTrue: [ szErrorMsg freePointer ].			pcbErrorMsg notNil ifTrue: [ pcbErrorMsg freePointer ] ].	^error</body><body package="ODBCEXDI">getInformationTypeExternal: fInfoTypeSymbol	"Answer the information associated with fInfoTypeSymbol.  This information is defined only after connecting."	| xif cbInfoValueMax rgbInfoValue pcbInfoValue rc ub infoValue |	xif := self class xif.	cbInfoValueMax := 256.	"Arbitrary number for a max."	[ "Begin unwind protection." | selector |	rgbInfoValue := xif UCHAR perform: xif mallocSelector with: cbInfoValueMax.	pcbInfoValue :=  xif SWORD perform: xif mallocSelector with: 1.	self isUnicodeEncoding ifTrue: [		rc := xif SQLGetInfoW: self hdbc						with: (xif perform: fInfoTypeSymbol)							with: rgbInfoValue						with: cbInfoValueMax						with: pcbInfoValue. 	] ifFalse: [		rc := xif SQLGetInfo: self hdbc						with: (xif perform: fInfoTypeSymbol)							with: rgbInfoValue						with: cbInfoValueMax						with: pcbInfoValue. 		].	(rc == xif SQL_SUCCESS	or: [ rc == xif SQL_SUCCESS_WITH_INFO]) ifFalse:	     [ | errs |		errs := self getConnectionErrors.		^self class unableToQueryDriverInformationSignal raiseWith: errs errorString: errs first dbmsErrorString ].	ub := UninterpretedBytes new: pcbInfoValue contents.	rgbInfoValue copyAt: 0 to: ub size: ub sizeInBytes startingAt: 1.	selector := SQLInfoTypeConversionMap at: fInfoTypeSymbol.	selector = #stringAt: ifTrue: [ 		infoValue := ub asByteArray asStringEncoding: self encoding.	] ifFalse: [		infoValue := ub perform: selector with: 1	].	"End unwind protection." ]		ensure:			[ rgbInfoValue notNil ifTrue: [ rgbInfoValue freePointer ].			pcbInfoValue notNil ifTrue: [ pcbInfoValue freePointer ] ].	^infoValue</body><body package="ODBCEXDI">getSupportedFunctionExternal: fFunctionSymbol	"Answer a boolean indicating whether the function corresponding to the fFunctionSymbol is supported by the driver.  This information is defined only after connecting as the specific driver to use is not defined yet."	| xif rc pfSupportedPointer supported |	xif := self class xif.	[ "Begin unwind protection."	pfSupportedPointer := xif UWORD perform: xif mallocSelector with: 1.	rc := xif SQLGetFunctions: self hdbc 				with: (xif perform: fFunctionSymbol)				with: pfSupportedPointer.	( traceLevel &gt;= 4 ) ifTrue:		[ (self traceStream)			print: rc; 			nextPutAll: ' = SQLGetFunctions( hdbc = ';			nextPutAll: (self hdbc referentAddress printStringRadix:16);			nextPutAll: ', fFunction = '; nextPutAll: fFunctionSymbol;			nextPutAll: ', pfSupported ='; print: pfSupportedPointer contents;			nextPutAll: ' )'.		self class trace: self emitTrace ].	(rc == xif SQL_SUCCESS) ifFalse:		[ | errs |		errs := self getConnectionErrors.		self class unableToQueryDriverInformationSignal raiseWith: errs errorString: errs first dbmsErrorString ]. 	supported := (pfSupportedPointer contents == 1).	"End unwind protection." ]		ensure:			[ pfSupportedPointer notNil ifTrue: [ pfSupportedPointer freePointer ] ].	^supported</body><body package="ODBCEXDI">installExternal	super installExternal.	self hdbc: nil.	self supportedFunctions: IdentityDictionary new.	self generalInformationCache: IdentityDictionary new.</body><body package="ODBCEXDI">multiStatementTransactions	"Take the receiver's connection out of auto-commit mode for transaction behavior."	"If receiver is connected to a driver which supports control over the autocommit behavior then this is the preferred mechanism for implementing the transaction behavior defined for the EXDI."	| xif |		(self supportsFunction: #SQL_API_SQLSETCONNECTOPTION) ifTrue:		[ xif := self class xif. 			self setConnectionOption: #SQL_AUTOCOMMIT value: xif SQL_AUTOCOMMIT_OFF.	 	]</body><body package="ODBCEXDI">rollbackExternal	super rollbackExternal ifFalse: [ ^self ].	self transactExternal: #SQL_ROLLBACK.	self singleStatementTransactions</body><body package="ODBCEXDI">setConnectionOptionExternal: fOptionSymbol value: vOption	"Set the information associated with fInfoTypeSymbol.  This information is defined only after connecting."	| xif |	xif := self class xif.	self allocConnect.	^self setConnectionOptionNumber: (xif perform: fOptionSymbol) value: vOption</body><body package="ODBCEXDI">setConnectionOptionNumber: fOptionNumber value: vOption	"Set the information associated with fOptionNumber, but for the clarity of your code, use option symbols (method setConnectionOptionExternal: fOptionSymbol value: vOption) will be a better choice.  This information is defined only after connecting."	| xif rc fOptionSymbol |	xif := self class xif.	self isUnicodeEncoding ifTrue: [		rc := xif SQLSetConnectOptionW: self hdbc 						    		with: fOptionNumber						    		with: vOption.	] ifFalse: [		rc := xif SQLSetConnectOption: self hdbc 						    		with: fOptionNumber						    		with: vOption.	].	( traceLevel &gt;= 3 ) ifTrue:		[ (self traceStream)			print: rc; 			nextPutAll: ' = SQLSetConnectionOption( hdbc = ';			nextPutAll: (self hdbc referentAddress printStringRadix:16);			nextPutAll: ', fOption = '; print: fOptionNumber;			nextPutAll: ', vParam ='; print: vOption;			nextPutAll: ' )'.		self class trace: self emitTrace ].	(rc == xif SQL_SUCCESS	or: [ rc == xif SQL_SUCCESS_WITH_INFO]) ifFalse:	     [ | errs |		errs := self getConnectionErrors.		^self class unableToSetConnectionOptionsSignal raiseWith: errs errorString: errs first dbmsErrorString ].	fOptionSymbol := self sqlConnectionOptionCache keys detect: [ :each | (xif perform: each) = fOptionNumber ] ifNone: [ nil ].	fOptionSymbol isNil ifFalse: [ self sqlConnectionOptionCache at: fOptionSymbol put: vOption ].	^vOption</body><body package="ODBCEXDI">setIsolationLevel: anIsolationLevel	"Take the receiver's connection out of auto-commit mode for transaction behavior."	"If receiver is connected to a driver which supports control over the autocommit behavior then this is the preferred mechanism for implementing the transaction behavior defined for the EXDI."	| xif |		(self supportsFunction: #SQL_API_SQLSETCONNECTOPTION) ifTrue:		[ xif := self class xif. 			self setConnectionOption: #SQL_TXN_ISOLATION value: (xif perform:anIsolationLevel).		]</body><body package="ODBCEXDI">singleStatementTransactions	"Put the receiver's connection into auto-commit mode for transaction behavior."	"If receiver is connected to a driver which supports control over the autocommit behavior then this is the preferred mechanism for implementing the transaction behavior defined for the EXDI."	| xif |		(self supportsFunction: #SQL_API_SQLSETCONNECTOPTION) ifTrue:		[ xif := self class xif. 			self setConnectionOption: #SQL_AUTOCOMMIT value: xif SQL_AUTOCOMMIT_ON.	 	]</body><body package="ODBCEXDI">transactExternal: fTypeSymbol	| xif rc behavior |	xif := self class xif. 	rc := xif SQLTransact: xif SQL_NULL_HENV			with: self hdbc			with: (xif perform: fTypeSymbol).	( traceLevel &gt;= 1 ) ifTrue:		[ (self traceStream)			print: rc;			nextPutAll: ' = SQLTransact( henv = SQL_NULL_HENV, hdbc = ';			nextPutAll: (self hdbc referentAddress printStringRadix: 16); 			nextPutAll: ', fType = '; nextPutAll: fTypeSymbol;			nextPutAll:  ')'.		self  class trace: self emitTrace ].	(rc == xif SQL_SUCCESS) ifFalse:		[ | errs |		errs := self getConnectionErrors.		self class transactionExceptionSignal raiseWith: errs errorString: errs first dbmsErrorString ].	"What are the side effects of the end of the transaction."	fTypeSymbol == #SQL_COMMIT ifTrue:		[ behavior := self getInformationType: #SQL_CURSOR_COMMIT_BEHAVIOR ].	fTypeSymbol == #SQL_ROLLBACK ifTrue:		[ behavior := self getInformationType: #SQL_CURSOR_ROLLBACK_BEHAVIOR ].	behavior == xif SQL_CB_DELETE ifTrue:		[ self cursorsAreDeleted ].	behavior == xif SQL_CB_CLOSE ifTrue:		[ self cursorsAreClosed ]</body></methods><methods><class-id>Database.ODBC2Connection</class-id> <category>accessing</category><body package="ODBCEXDI">dataSources	"Return a List of accessible ODBCDataSource instances.  The receiver does not need to be connected."	| xif dataSources fDirection ds |	xif := self class xif.	"If we don't have an environment handle allocated, get one now."	HenvLock critical: [ self unprotectedAddHenvReference ].	[ "Begin unwind protection."	dataSources := List new.	fDirection := xif SQL_FETCH_FIRST.	[ (ds := self getDataSourceExternal: fDirection) notNil ] whileTrue:		[ fDirection := xif SQL_FETCH_NEXT.		dataSources add: ds ].	"End unwind protection." ]		ensure:			[ HenvLock critical: [ self unprotectedDropHenvReference ] ].	^dataSources</body><body package="ODBCEXDI">databaseName	"Answer the name of the database being used."	^self getInformationType: #SQL_DATABASE_NAME.</body><body package="ODBCEXDI">dbmsName	"Answer the name of the DBMS product being accessed"	^self getInformationType: #SQL_DBMS_NAME.</body><body package="ODBCEXDI">dbmsVersion	"Answer the version of the DBMS product being accessed"	^self getInformationType: #SQL_DBMS_VER.</body><body package="ODBCEXDI">delimitedIdentifierCharacter	"Answer the delimiter of the DBMS product being accessed	a space indicates no delimited identifiers supported"	^self getInformationType: #SQL_IDENTIFIER_QUOTE_CHAR.</body><body package="ODBCEXDI">disableMultipleActiveResultSets	"Disable the support of Multiple Active Result Sets (MARS)"	^self setConnectionOption: #SQL_COPT_SS_MARS_ENABLED value: (self class xif SQL_MARS_ENABLED_NO).</body><body package="ODBCEXDI">driverName	"Answer the name of the ODBC driver being used"	^self getInformationType: #SQL_DRIVER_NAME.</body><body package="ODBCEXDI">driverVersion	"Answer the version of the ODBC driver being used."	^self getInformationType: #SQL_DRIVER_VER.</body><body package="ODBCEXDI">enableMultipleActiveResultSets	"Enable the support of Multiple Active Result Sets (MARS)"	^self setConnectionOption: #SQL_COPT_SS_MARS_ENABLED value: (self class xif SQL_MARS_ENABLED_YES).</body><body package="ODBCEXDI">encoding	encoding isNil ifTrue: [ encoding := self class xif encoding ].	^encoding</body><body package="ODBCEXDI">odbcVersion	^2</body><body package="ODBCEXDI">serverName	"Answer the name of the server being used."	^self getInformationType: #SQL_SERVER_NAME.</body><body package="ODBCEXDI">supportsDelimitedIdentifiers	"Answer whether the DBMS product being accessed	supports double quoted identifiers"	^((self getInformationType: #SQL_IDENTIFIER_QUOTE_CHAR) = '"').</body><body package="ODBCEXDI">traceFile	"Answer the name of the trace file."	^self getConnectionOption: #SQL_OPT_TRACEFILE.</body><body package="ODBCEXDI">unicodeEncoding	unicodeEncoding isNil ifTrue: [ unicodeEncoding := #'UCS-2' ].	^unicodeEncoding</body><body package="ODBCEXDI">unicodeEncoding: anEncoding	unicodeEncoding := anEncoding</body><body package="ODBCEXDI">userName	"Answer the name of the database user."	^self getInformationType: #SQL_USER_NAME.</body></methods><methods><class-id>Database.ODBC2Connection</class-id> <category>private-testing</category><body package="ODBCEXDI">isODBC3	^self odbcVersion = 3</body><body package="ODBCEXDI">isUnicodeEncoding	| encodingString |	encodingString := self encoding asUppercase.	^((encodingString beginsWith: 'UTF') or: [ encodingString beginsWith: 'UCS' ])</body></methods><methods><class-id>Database.ODBC2Connection</class-id> <category>private-handles</category><body package="ODBCEXDI">allocConnect	"Acquire reference to environment handle and then allocate a connection handle."	self hdbc isNil ifTrue: [		HenvLock critical: [self unprotectedAllocConnect].	].</body><body package="ODBCEXDI">setCPToRelaxedMatch	"Set Connection Pooling to Strict Match."	| xif  rc |	xif := self class xif.	rc := xif SQLSetEnvAttr: self class henv with: xif SQL_ATTR_CP_MATCH with: xif SQL_CP_RELAXED_MATCH with: xif SQL_IS_INTEGER.	traceLevel &gt;= 3 		ifTrue: 			[(self traceStream)				print: rc;				nextPutAll: ' = SQLSetEnvAttr( *henv = ';				nextPutAll: (self class henv referentAddress printStringRadix: 16);				nextPutAll: ',  SQL_ATTR_CP_MATCH';				nextPutAll: ',  SQL_CP_RELAXED_MATCH';				nextPutAll: ',  SQL_IS_INTEGER';				nextPutAll: ' )'.			self class trace: self emitTrace].	rc == xif SQL_SUCCESS 		ifFalse: [^self class unableToSetEnvironmentAttributeSignal raise].</body><body package="ODBCEXDI">setCPToStrictMatch	"Set Connection Pooling to Strict Match."	| xif  rc |	xif := self class xif.	rc := xif SQLSetEnvAttr: self class henv  with: xif SQL_ATTR_CP_MATCH with: xif SQL_CP_STRICT_MATCH with: xif SQL_IS_INTEGER.	traceLevel &gt;= 3 		ifTrue: 			[(self traceStream)				print: rc;				nextPutAll: ' = SQLSetEnvAttr( *henv = ';				nextPutAll: (self class henv referentAddress printStringRadix: 16);				nextPutAll: ',  SQL_ATTR_CP_MATCH';				nextPutAll: ',  SQL_CP_STRICT_MATCH';				nextPutAll: ',  SQL_IS_INTEGER';				nextPutAll: ' )'.			self class trace: self emitTrace].	rc == xif SQL_SUCCESS 		ifFalse: [^self class unableToSetEnvironmentAttributeSignal raise].</body><body package="ODBCEXDI">setConnectionPoolingOff	"Set Connection Pooling to Strict Match."	| xif  rc |	xif := self class xif.	rc := xif SQLSetEnvAttr: xif SQL_NULL_HENV with: xif SQL_ATTR_CONNECTION_POOLING with: xif SQL_CP_OFF with: xif SQL_IS_INTEGER.	traceLevel &gt;= 3 		ifTrue: 			[(self traceStream)				print: rc;				nextPutAll: ' = SQLSetEnvAttr( SQL_NULL_HENV';				nextPutAll: ',  SQL_ATTR_CONNECTION_POOLING';				nextPutAll: ',  SQL_CP_OFF';				nextPutAll: ',  SQL_IS_INTEGER';				nextPutAll: ' )'.			self class trace: self emitTrace].	rc == xif SQL_SUCCESS 		ifFalse: [^self class unableToSetEnvironmentAttributeSignal raise].	self class connectionsArePooled: false</body><body package="ODBCEXDI">setConnectionPoolingOn	"Set Connection Pooling to Strict Match."	| xif  rc |	xif := self class xif.	rc := xif SQLSetEnvAttr: xif SQL_NULL_HENV with: xif SQL_ATTR_CONNECTION_POOLING with: xif SQL_CP_ONE_PER_HENV with: xif SQL_IS_INTEGER.	traceLevel &gt;= 3 		ifTrue: 			[(self traceStream)				print: rc;				nextPutAll: ' = SQLSetEnvAttr( SQL_NULL_HENV';				nextPutAll: ',  SQL_ATTR_CONNECTION_POOLING';				nextPutAll: ',  SQL_CP_ONE_PER_HENV';				nextPutAll: ',  SQL_IS_INTEGER';				nextPutAll: ' )'.			self class trace: self emitTrace].	rc == xif SQL_SUCCESS 		ifFalse: [^self class unableToSetEnvironmentAttributeSignal raise].	self class connectionsArePooled: true</body><body package="ODBCEXDI">unprotectedAddHenvReference	"Acquire an environment handle if needed and record a reference.  Senders	must ensure protection using HenvLock.  If this method completes normally,	resources are held that should be released explicitly using #unprotectedDropHenvReference."	| xif phenv rc |	xif := self class xif.	"Not too much to do if environment handle already allocated."	Henv notNil 		ifTrue: 			["One more reference to the Henv."			HenvReferencesCount := HenvReferencesCount + 1.			^self].	"Get the environment handle."		[	["Begin unwind protection"	self class connectionPooling ifTrue: [		self setConnectionPoolingOn.	].	phenv := xif HENV perform: xif mallocSelector with: 1.	rc := xif SQLAllocEnv: phenv.	traceLevel &gt;= 3 		ifTrue: 			[(self traceStream)				print: rc;				nextPutAll: ' = SQLAllocEnv(), *phenv = ';				nextPutAll: (phenv contents referentAddress printStringRadix: 16).			self class trace: self emitTrace].	rc == xif SQL_SUCCESS 		ifFalse: [^self class unableToAllocateHandleSignal raise].	"Save environment handle"	Henv := phenv contents.	self class connectionPooling ifTrue: [		self class cpStrictMatch ifTrue: [			self setCPToStrictMatch.		] ifFalse: [			self setCPToRelaxedMatch.		].	].	HenvReferencesCount := 1.	"End unwind protection."] 			ensure: [phenv notNil ifTrue: [phenv freePointer]]] 			on: Object errorSignal			do: [:ex | self class externalDatabaseLibraryInaccessibleSignal raise]</body><body package="ODBCEXDI">unprotectedAllocConnect	"Acquire reference to environment handle and then allocate a connection handle.	Senders must ensure protection using HenvLock.  If this method completes normally,	resources are held that should be released explicitly using #unprotectedFreeConnect."	| xif phdbc rc |	xif := self class xif.	"Make sure we have a reference to the environment handle."	self unprotectedAddHenvReference.	[ "Begin unwind protection (level 1) -- ensure release of environment handle on failure."	[ "Begin unwind protection (level 2) -- ensure release of pointers on success or failure."	phdbc := xif  HDBC perform: xif mallocSelector with: 1.	rc := xif SQLAllocConnect: self class henv with: phdbc.	(traceLevel &gt;= 3) ifTrue:		[(self traceStream) 			print: rc; 			nextPutAll: ' = SQLAllocConnect( henv = ';			nextPutAll: (self class henv referentAddress printStringRadix: 16 );			nextPutAll: ', *phdbc = '; 			nextPutAll: (phdbc contents referentAddress  printStringRadix: 16);			nextPutAll: ')'.		self class trace: self emitTrace].	(rc == xif SQL_SUCCESS) ifFalse:		[ | errs |		errs := self getEnvironmentErrors.		^self class unableToAllocateHandleSignal raiseWith: errs errorString: errs first dbmsErrorString].	self hdbc: phdbc contents.	"End unwind protection (level 2)" ]		ensure:			[ phdbc notNil ifTrue: [ phdbc freePointer ] ].	"End unwind protection (level 1)" ]		ifCurtailed:			[ "Some failure is causing unwind, don't keep the environment handle reference."			self unprotectedDropHenvReference ]</body><body package="ODBCEXDI">unprotectedDropHenvReference	"Remove a reference to the environment handle.  If no references left, release the	handle.  Senders must ensure protection using HenvLock."	| xif rc |	xif := self class xif.	"Reduce the reference count."	(HenvReferencesCount := HenvReferencesCount - 1) &gt; 0 ifTrue:		[ "Little to do if other references still remain."		^self ].	[ "Begin unwind protection."	rc := xif SQLFreeEnv: Henv.	(traceLevel &gt;= 3) ifTrue:		[ (self traceStream)			print: rc;  nextPutAll: ' = SQLFreeEnv( henv = ';			nextPutAll: (Henv referentAddress printStringRadix: 16);			nextPutAll: ' )'.		self class trace: self emitTrace ].	(rc == xif SQL_SUCCESS) ifFalse:		[ | errs |		errs := self getEnvironmentErrors.		^self class unableToFreeResourceSignal raiseRequestWith: errs errorString: errs first dbmsErrorString ].	"End connection pooling if it is active."	self class connectionsArePooled ifTrue: [		self setConnectionPoolingOff	].	"End unwind protection." ]		ensure:			[ Henv := nil ]</body><body package="ODBCEXDI">unprotectedFreeConnect	"Free the connection handle and then release reference to environment handle.	Senders must ensure protection using HenvLock."	| xif rc |	xif := self class xif.	[ "Begin unwind protection"	rc := xif SQLFreeConnect: self hdbc.	(traceLevel &gt;= 3) ifTrue:		[ (self traceStream)			print: rc;  			nextPutAll: ' = SQLFreeConnect( hdbc = ';			nextPutAll: (self hdbc referentAddress printStringRadix: 16);			nextPutAll: ' )'.		self class trace: self emitTrace ].	(rc == xif SQL_SUCCESS ) ifFalse:		[ | errs |		errs := self getEnvironmentErrors.		^self class unableToFreeResourceSignal raiseRequestWith: errs errorString: errs first dbmsErrorString ].	"End unwind protection." ]		ensure:			[ "Whether or not there was a failure, there's no point in hanging onto these."			self hdbc: nil.			self unprotectedDropHenvReference ]</body></methods><methods><class-id>Database.ODBC2Connection</class-id> <category>printing</category><body package="ODBCEXDI">printOn: aStream	| hdbc |	super printOn: aStream.	((hdbc := self hdbc) isNil or: [hdbc referentAddress isNil]) ifFalse:		[ aStream nextPutAll: '( hdbc = ';			nextPutAll: (hdbc referentAddress printStringRadix: 16);			nextPutAll: ' )' ]</body></methods><methods><class-id>Database.ODBC2Connection</class-id> <category>private-finalization</category><body package="ODBCEXDI">executor 	| ex |	ex := super executor.	ex hdbcHolder: self hdbcHolder.	ex supportedFunctions: IdentityDictionary new.	ex generalInformationCache: IdentityDictionary new.	^ex</body><body package="ODBCEXDI">finalizeExternal	(self hdbc isNil or: [self hdbc referentAddress isNil]) ifTrue:		[ ^self ].	( traceLevel &gt;= 1 ) ifTrue:		[ self class trace: nil ].	super finalizeExternal</body><body package="ODBCEXDI">key	"The hdbcHolder is unique to the connection and is constant	across pause/resume."	^self hdbcHolder</body></methods><methods><class-id>Database.ODBC2Connection</class-id> <category>initialize-release</category><body package="ODBCEXDI">initialize	"Establish initial value for instance variables." 	super initialize.	self hdbcHolder: nil asValue. 	supportedFunctions := IdentityDictionary new.	generalInformationCache := IdentityDictionary new.		sqlConnectionOptionCache := IdentityDictionary new.</body><body package="ODBCEXDI">initializeFromLogin: aLogin	"Initialize this ODBC Connection for multiple result sets.  This is called by Glorp."	| xif |	super initializeFromLogin: aLogin.	xif := self class xif.	self		setConnectionOption: #SQL_COPT_SS_MARS_ENABLED		value: xif SQL_MARS_ENABLED_YES.</body></methods><methods><class-id>Database.ODBC2Connection class</class-id> <category>private-registry</category><body package="ODBCEXDI">registry	^RegisteredODBCConnections</body><body package="ODBCEXDI">registry: aCollection	RegisteredODBCConnections := aCollection</body></methods><methods><class-id>Database.ODBC2Connection class</class-id> <category>accessing</category><body package="ODBCEXDI">bufferClass	"Answer the buffer class for sessions"		^ODBC2Buffer</body><body package="ODBCEXDI">columnDescriptionClass	"Answer the class to use for column description objects associated with receiver."	^ODBCColumnDescription</body><body package="ODBCEXDI">connectionPooling	^ConnectionPooling</body><body package="ODBCEXDI">connectionPooling: aBoolean	ConnectionPooling := aBoolean</body><body package="ODBCEXDI">connectionsArePooled	^ConnectionsArePooled</body><body package="ODBCEXDI">connectionsArePooled: aBoolean 	"This is a private method, called when pooling gets activated or deactivated."	^ConnectionsArePooled := aBoolean</body><body package="ODBCEXDI">cpStrictMatch	^CpStrictMatch</body><body package="ODBCEXDI">cpStrictMatch: aBoolean	CpStrictMatch := aBoolean</body><body package="ODBCEXDI">dataSourceClass	"Answer the error class for the receiver."		^ODBCDataSource</body><body package="ODBCEXDI">defaultError	"Answer a default error instance for the receiver."	| err |	err := self errorClass new.	err dbmsErrorCode: 0.	err dbmsErrorString: 'Connection Error'.	err sqlState: String new.	^err</body><body package="ODBCEXDI">errorClass	"Answer the error class for the receiver."		^ODBCError</body><body package="ODBCEXDI">henv	^Henv</body><body package="ODBCEXDI">interfaceClass	"Answer the correct interface class" 	| interfaceClassName |  	xifMap isNil		ifTrue: [self initializeInterfaceMapping].	interfaceClassName := xifMap at: self platformType ifAbsent: [nil].	^interfaceClassName notNil		ifTrue: [ self environment at: interfaceClassName ifAbsent: [nil] ]		ifFalse: [nil]</body><body package="ODBCEXDI">kind	"Answer a symbol representing the type of DMBS the receiver provides services for."	^#'ODBC 3.0 (Generic)'</body><body package="ODBCEXDI">sessionClass	"Answer the class to use for session objects associated with receiver."	^ODBC2Session</body><body package="ODBCEXDI">transactionClass	"Answer the class to use for transaction objects associated with receiver."	^ODBCTransaction</body><body package="ODBCEXDI">version	^'Database Connect for ODBC - Release 3.5'</body><body package="ODBCEXDI">xif	"Answer the ExternalInterface subclass instance to use." 	xif isNil ifTrue:		[ self initializeExternalInterface ].	^xif</body></methods><methods><class-id>Database.ODBC2Connection class</class-id> <category>class initialization</category><body package="ODBCEXDI">initialize	"ODBC2Connection initialize"	Henv := nil.	HenvLock := RecursionLock new.	HenvReferencesCount := 0.	self initializeInterfaceMapping.	self initializeSQLConnectionOptionConversionMap.	self xif: nil.	self initRegistry.	self connectionPooling: false.	self cpStrictMatch: true.	self connectionsArePooled: false.	SupportedIsolationLevels := IdentityDictionary new.	SupportedIsolationLevels at: #RR put: #SQL_TXN_REPEATABLE_READ.	SupportedIsolationLevels at: #RC put: #SQL_TXN_READ_COMMITTED.	SupportedIsolationLevels at: #RU put: #SQL_TXN_READ_UNCOMMITTED.	SupportedIsolationLevels at: #serializable put: #SQL_TXN_SERIALIZABLE.	SupportedIsolationLevels at: #versioning put: #SQL_TXN_VERSIONING.	self sessionClass initialize.</body><body package="ODBCEXDI">initializeExternalInterface	"Reset xif call with the right interface class based on the current platform."	| xifClass |	xifClass := self interfaceClass.	self xif: (xifClass notNil			ifTrue: [xifClass new]			ifFalse: [nil]).	xif isNil ifTrue: [^ExternalDatabaseNotification raiseErrorString: 'The ODBC CLI Driver is not correctly installed.' withCRs].	self initializeInformationTypeConversionMap.</body><body package="ODBCEXDI">initializeInformationTypeConversionMap	"ODBCConnection initializeInformationTypeConversionMap"	(SQLInfoTypeConversionMap := IdentityDictionary new)		add: #SQL_ACTIVE_CONNECTIONS-&gt;#stringAt:;		add: #SQL_ACTIVE_STATEMENTS-&gt;#shortAt:;		add: #SQL_DATA_SOURCE_NAME-&gt;#stringAt:;		add: #SQL_DRIVER_HDBC-&gt;#longAt:;		add: #SQL_DRIVER_HENV-&gt;#longAt:;		add: #SQL_DRIVER_HSTMT-&gt;#longAt:;		add: #SQL_DRIVER_NAME-&gt;#stringAt:;		add: #SQL_DRIVER_VER-&gt;#stringAt:;		add: #SQL_FETCH_DIRECTION-&gt;#longAt:;		add: #SQL_ODBC_API_CONFORMANCE-&gt;#shortAt:;		add: #SQL_ODBC_VER-&gt;#stringAt:;		add: #SQL_ROW_UPDATES-&gt;#stringAt:;		add: #SQL_ODBC_SAG_CLI_CONFORMANCE-&gt;#shortAt:;		add: #SQL_SERVER_NAME-&gt;#stringAt:;		add: #SQL_SEARCH_PATTERN_ESCAPE-&gt;#stringAt:;		add: #SQL_ODBC_SQL_CONFORMANCE-&gt;#shortAt:;		add: #SQL_DATABASE_NAME-&gt;#stringAt:;		add: #SQL_DBMS_NAME-&gt;#stringAt:;		add: #SQL_DBMS_VER-&gt;#stringAt:;		add: #SQL_ACCESSIBLE_TABLES-&gt;#stringAt:;		add: #SQL_ACCESSIBLE_PROCEDURES-&gt;#stringAt:;		add: #SQL_PROCEDURES-&gt;#stringAt:;		add: #SQL_CONCAT_NULL_BEHAVIOR-&gt;#shortAt:;		add: #SQL_CURSOR_COMMIT_BEHAVIOR-&gt;#shortAt:;		add: #SQL_CURSOR_ROLLBACK_BEHAVIOR-&gt;#shortAt:;		add: #SQL_DATA_SOURCE_READ_ONLY-&gt;#stringAt:;		add: #SQL_DEFAULT_TXN_ISOLATION-&gt;#longAt:;		add: #SQL_EXPRESSIONS_IN_ORDERBY-&gt;#stringAt:;		add: #SQL_IDENTIFIER_CASE-&gt;#shortAt:;		add: #SQL_IDENTIFIER_QUOTE_CHAR-&gt;#stringAt:;		add: #SQL_MAX_COLUMN_NAME_LEN-&gt;#shortAt:;		add: #SQL_MAX_CURSOR_NAME_LEN-&gt;#shortAt:;		add: #SQL_MAX_OWNER_NAME_LEN-&gt;#shortAt:;		add: #SQL_MAX_PROCEDURE_NAME_LEN-&gt;#shortAt:;		add: #SQL_MAX_QUALIFIER_NAME_LEN-&gt;#shortAt:;		add: #SQL_MAX_TABLE_NAME_LEN-&gt;#shortAt:;		add: #SQL_MULT_RESULT_SETS-&gt;#stringAt:;		add: #SQL_MULTIPLE_ACTIVE_TXN-&gt;#stringAt:;		add: #SQL_OUTER_JOINS-&gt;#stringAt:;		add: #SQL_OWNER_TERM-&gt;#stringAt:;		add: #SQL_PROCEDURE_TERM-&gt;#stringAt:;		add: #SQL_QUALIFIER_NAME_SEPARATOR-&gt;#stringAt:;		add: #SQL_QUALIFIER_TERM-&gt;#stringAt:;		add: #SQL_SCROLL_CONCURRENCY-&gt;#longAt:;		add: #SQL_SCROLL_OPTIONS-&gt;#longAt:;		add: #SQL_TABLE_TERM-&gt;#stringAt:;		add: #SQL_TXN_CAPABLE-&gt;#shortAt:;		add: #SQL_NON_NULLABLE_COLUMNS-&gt;#shortAt:;		add: #SQL_USER_NAME-&gt;#stringAt:;		add: #SQL_CONVERT_FUNCTIONS-&gt;#longAt:;		add: #SQL_NUMERIC_FUNCTIONS-&gt;#longAt:;		add: #SQL_STRING_FUNCTIONS-&gt;#longAt:;		add: #SQL_SYSTEM_FUNCTIONS-&gt;#longAt:;		add: #SQL_TIMEDATE_FUNCTIONS-&gt;#longAt:;		add: #SQL_TXN_ISOLATION_OPTION-&gt;#longAt:;		add: #SQL_ODBC_SQL_OPT_IEF-&gt;#stringAt:;		add: #SQL_GETDATA_EXTENSIONS-&gt;#longAt:.</body><body package="ODBCEXDI">initializeInterfaceMapping	xifMap := IdentityDictionary new.	xifMap at: #nt put: #ODBCCLINTInterface.	xifMap at: #nt64 put: #ODBCCLINT64Interface.	xifMap at: #win95 put: #ODBCCLINTInterface.	xifMap at: #macOSX put: #ODBCCLIMacOSXInterface.	xifMap at: #macOSX64 put: #ODBCCLIMacOSX64Interface.	xifMap at: #linux_i386_unix put: #ODBCCLILinuxInterface.	xifMap at: #linux_x86_64_unix put: #ODBCCLILinux64Interface.	xifMap at: #aix_unix put: #ODBCCLIAIXInterface.	xifMap at: #sun5_unix put: #ODBCCLISolarisInterface.	xifMap at: #unknown put: #ODBCCLIInterface</body><body package="ODBCEXDI">initializeSQLConnectionOptionConversionMap	"Initialize SQLConnectionOptionConversionMap"	(SQLConnectionOptionConversionMap := IdentityDictionary new)		add: #SQL_OPT_TRACEFILE-&gt;#stringAt:;		add: #SQL_TRANSLATE_DLL-&gt;#stringAt:; 		add: #SQL_TRANSLATE_OPTION-&gt;#longAt:;			add: #SQL_ACCESS_MODE-&gt;#longAt:;			add: #SQL_AUTOCOMMIT-&gt;#longAt:;			add: #SQL_LOGIN_TIMEOUT-&gt;#longAt:;			add: #SQL_OPT_TRACE-&gt;#longAt:;				add: #SQL_TXN_ISOLATION-&gt;#longAt:;			add: #SQL_COPT_SS_MARS_ENABLED-&gt;#longAt:;			add: #SQL_PRESERVE_CURSORS-&gt;#longAt:.</body></methods><methods><class-id>Database.ODBC2Connection class</class-id> <category>signal constants</category><body package="ODBCEXDI">unableToGetConnectionOptionsSignal	^UnableToGetConnectionOptions</body><body package="ODBCEXDI">unableToSetConnectionOptionsSignal	^UnableToSetConnectionOptions</body></methods><methods><class-id>Database.ODBC2Connection class</class-id> <category>activation</category><body package="ODBCEXDI">pause	^self quiesce</body><body package="ODBCEXDI">resume	^self activate</body></methods><methods><class-id>Database.ODBC2Connection class</class-id> <category>testing</category><body package="ODBCEXDI">supportAllocateHandle	"Answer true is the loaded library supports function SQLAllocHandle."	^self supportMethod: #SQLAllocHandle:with:with:</body></methods><methods><class-id>Database.ODBC2Connection class</class-id> <category>private-activation</category><body package="ODBCEXDI">install	"This method can be inherrited, and will simply pass the install 	directive down the chain for those subclasses that need it."	self subclasses do: [:each | each install].	"Execute initialization code just once, here."	self == ODBC2Connection 		ifTrue: 			[TraceLevel &gt;= 1 ifTrue: [self trace: nil].			Henv := nil.			HenvReferencesCount := 0.			self xif: nil.			self sessionClass install.			self returnFromSnapshot]</body></methods><methods><class-id>Database.ODBCCLINTInterface class</class-id> <category>class initialization</category><body package="ODBCEXDI">initialize	super initialize</body></methods><methods><class-id>Database.ODBCCLI95Interface class</class-id> <category>class initialization</category><body package="ODBCEXDI">initialize	super initialize</body></methods><methods><class-id>Database.ODBC2Buffer</class-id> <category>private-binding</category><body package="ODBCEXDI">bindForOutputParameter	"Setup the receiver to hold the contents of return value and OUTPUT parameters of a stored procedure."	fParamType := bufferSession class xif SQL_PARAM_OUTPUT.	self describeParameter.	"We won't re-use pointers."	(bufferPointer isNil)		ifFalse: [ self free ].	"Allocate external CPointers."	self mallocUsingSelector: bufferSession class xif mallocSelector.	self bindInputExternal</body><body package="ODBCEXDI">bindInputExternal	"Bind the contents of the receiver to the server."	| rc xif sqlType cType collength |	xif := bufferSession class xif.	cType := self fCType.	collength := cbColDef.	self isStringBased ifTrue: [		self unicode ifTrue: [ | type |			type := self fSqlType.			cType := xif SQL_C_WCHAR.			type == xif SQL_CHAR ifTrue: [				sqlType := xif SQL_WCHAR			] ifFalse: [				type == xif SQL_VARCHAR ifTrue: [					sqlType := xif SQL_WVARCHAR				] ifFalse: [ 					sqlType := xif SQL_WLONGVARCHAR				]			]		] ifFalse: [			sqlType := self fSqlType		].	] ifFalse: [		sqlType := self fSqlType.	].	(self isStringBased  or: [ self isArrayBased ] ) ifTrue: [		collength := (bufferValue notNil and: [bufferValue isEmpty]) ifTrue: [ 1 ] ifFalse: [collength].	].			(bufferValue isNil or: [(bufferValue odbcConversion = #Array) and: [(self findMaxValue: bufferValue) isNil]]) ifTrue:[	"This used to be required only for MS Access, but now it appears to work in general."		databaseType := bufferSession connection dbmsName = 'PostgreSQL' ifTrue: [#String] ifFalse: [#Integer].		cType := self fCType.		sqlType := self fSqlType	].	count &gt;= 1 ifTrue: [		bufferSession setStatementOption: #SQL_ATTR_PARAM_BIND_TYPE value: xif SQL_BIND_BY_COLUMN.		bufferSession setStatementOption: #SQL_ATTR_PARAMSET_SIZE value: count.	].	rc := xif  SQLBindParameter: bufferSession hstmt					    	     with: bufferIndex						     with: fParamType					    	     with: cType					    	     with: sqlType		 			    	     with: collength		 			    	     with: self ibScale					    	     with: bufferPointer						     with: cbValueMax					    	     with: pcbValue.		( bufferSession traceLevel &gt;= 3 ) ifTrue:		[ (bufferSession  traceStream)			print: rc;  nextPutAll: ' = SQLBindParameter( hstmt = ';			nextPutAll: (bufferSession hstmt referentAddress printStringRadix: 16);			nextPutAll: ', ipar='; print: bufferIndex;			nextPutAll: ', fParamType='; print: fParamType;			nextPutAll: ', fCType='; print: cType;			nextPutAll: ', fSqlType=';  print: sqlType;			nextPutAll: ', cbParamDef= '; print: cbColDef;			nextPutAll: ', ibScale= '; print: ibScale;			nextPutAll: ', *rgbValue='; print: bufferValue;			nextPutAll: ', cbValueMax='; print: cbValueMax;			nextPutAll: ', *pcbValue='; print: pcbValue contents;			nextPutAll: ' )'.		bufferSession class trace: bufferSession emitTrace ].	(rc == xif SQL_SUCCESS) ifFalse:		[ | errs |		  errs := bufferSession getStatementErrors.		  ^bufferSession class connectionClass unableToBindSignal raiseWith: errs errorString: errs first dbmsErrorString ].</body><body package="ODBCEXDI">bindOutputExternal	"Prepare the receiver to automatically receive it's data from the server."	| rc xif cType rowSetSize |	xif := bufferSession class xif.	cType := self fCType.	(self isStringBased and: [ self unicode ]) ifTrue: [		cType := xif SQL_C_WCHAR	].	cType = xif SQL_SS_TIME2 ifTrue: [		cType := xif SQL_C_DEFAULT	].	count &gt;= 1 ifTrue: [		rowSetSize := count	] ifFalse: [		rowSetSize := 1	].	bufferSession setStatementOption: #SQL_ATTR_ROW_BIND_TYPE value: xif SQL_BIND_BY_COLUMN.	bufferSession setStatementOption: #SQL_ROWSET_SIZE value: rowSetSize.	rc := xif SQLBindCol: bufferSession hstmt					with: bufferIndex					with: cType					with: bufferPointer					with: cbValueMax					with: pcbValue.		( bufferSession traceLevel &gt;= 3 ) ifTrue:		[ (bufferSession  traceStream)			print: rc;  nextPutAll: ' = SQLBindCol( hstmt = ';			nextPutAll: (bufferSession hstmt referentAddress printStringRadix: 16);			nextPutAll: ', icol =';  print: bufferIndex;			nextPutAll: ', fCType = '; print: self fCType;			nextPutAll: ', rgbValue = '; 			nextPutAll: (bufferPointer referentAddress printStringRadix: 16);			nextPutAll: ', cbValueMax = ';  print: cbValueMax;			nextPutAll: ', pcbValue = '; print: (pcbValue referentAddress printStringRadix: 16);			nextPutAll: ' )'.		bufferSession class trace: bufferSession emitTrace ].	(rc == xif SQL_SUCCESS) ifFalse:		[ | errs |		errs := bufferSession getStatementErrors.		^bufferSession class connectionClass unableToBindSignal raiseWith: errs errorString: errs first dbmsErrorString ].</body><body package="ODBCEXDI">describeParameter	| rc xif pfSqlType pcbColDef pibScale pfNullable |	xif := bufferSession class xif.	[ "Begin unwind protection."		pfSqlType := xif SWORD perform: xif mallocSelector with: 1.		pcbColDef := xif SQLULEN perform: xif mallocSelector with: 1.		pibScale := xif SWORD perform: xif mallocSelector with: 1.		pfNullable := xif SWORD perform: xif mallocSelector with: 1.		rc := xif SQLDescribeParam: bufferSession hstmt			 	with: bufferIndex			 	with: pfSqlType			 	with: pcbColDef			 	with: pibScale			 	with: pfNullable.		( bufferSession traceLevel &gt;= 3 ) ifTrue:		[ (bufferSession  traceStream)			print: rc;  nextPutAll: ' = SQLDescribeParam( hstmt = ';			nextPutAll: (bufferSession hstmt referentAddress printStringRadix: 16);			nextPutAll: ', ipar='; print: bufferIndex;			nextPutAll: ', pfSqlType='; 			nextPutAll: (pfSqlType referentAddress printStringRadix: 16);			nextPutAll: ', pcbColDef=';			nextPutAll: (pcbColDef referentAddress printStringRadix: 16);			nextPutAll: ', pibScale='; 			nextPutAll: (pibScale referentAddress printStringRadix: 16);			nextPutAll: ', pfNullable= ';			nextPutAll: (pfNullable referentAddress printStringRadix: 16);			nextPutAll: ' )'.		bufferSession class trace: bufferSession emitTrace ].	(rc == xif SQL_SUCCESS) ifFalse:		[ | errs |		  errs := bufferSession getStatementErrors.		  ^bufferSession class connectionClass unableToBindSignal raiseWith: errs errorString: errs first dbmsErrorString ].		self databaseType == #String ifTrue: [			cbColDef := pcbColDef contents + 1.			cbValueMax := cbColDef.		] ifFalse: [			cbColDef := pcbColDef contents.		].		ibScale := pibScale contents.	"End unwind protection."]		ensure:			[ pfSqlType notNil ifTrue: [ pfSqlType freePointer ].			pcbColDef notNil ifTrue: [ pcbColDef freePointer ].			pibScale notNil ifTrue: [ pibScale freePointer ].			pfNullable notNil ifTrue: [ pfNullable freePointer ] ].</body></methods><methods><class-id>Database.ODBC2Buffer</class-id> <category>private-data conversion {get}</category><body package="ODBCEXDI">getBooleanAt: index	"Answer a Boolean as described in the first byte pointed to by the buffer."	^(bufferPointer at: (index -1)) ~= 0</body><body package="ODBCEXDI">getByteArrayAt: index	"Answer a ByteArray populated from the buffer."	| bytes byteArray | 	bytes := pcbValue at: (index -1).	bytes = bufferSession class xif SQL_NULL_DATA ifTrue: [ ^nil	].	elementSize := cbValueMax.		byteArray := ByteArray new: bytes.	bufferPointer copyAt: ((index -1) * elementSize) to: byteArray size: bytes startingAt: 1.	^byteArray</body><body package="ODBCEXDI">getDateAt: index	"Answer a Date populated from the buffer."	"For performance reasons, the implementation of this method embeds	knowledge of the structure of the Informix typedef DATE_STRUCT.	Assume: bufferPointer points to at least 6 bytes in the heap."	| conversionBuffer year month day |	elementSize := 6.	conversionBuffer := UninterpretedBytes new: elementSize.	bufferPointer copyAt: ((index -1) * elementSize) to: conversionBuffer size: elementSize startingAt: 1.	year := conversionBuffer shortAt: 1.	month := conversionBuffer unsignedShortAt: 3.	day := conversionBuffer unsignedShortAt: 5.	^Date newDay: day month: (Date nameOfMonth: month) year: year</body><body package="ODBCEXDI">getDoubleAt: index	"Answer a Double populated from the buffer"	"Assume: bufferPointer points to at least 8 bytes in the heap."	| conversionBuffer |	elementSize := 8.	conversionBuffer := UninterpretedBytes new: elementSize.	bufferPointer copyAt: ((index -1) * elementSize) to: conversionBuffer size: elementSize startingAt: 1.	^conversionBuffer doubleAt: 1</body><body package="ODBCEXDI">getFixedPointAt: index	"Answer a FixedPoint number populated from the buffer"	| bytes str |	bytes := pcbValue at: (index -1).	elementSize := cbValueMax.	str := ByteString new: bytes.	bufferPointer copyAt: ((index -1) * elementSize) to: str size: bytes startingAt: 1.	"Change E to e to help Fixedpoint conversion."	str := str copyReplaceAll: 'E' with: 'e'. 	^FixedPoint readFrom: str readStream</body><body package="ODBCEXDI">getFloatAt: index	"Answer a Float populated from the buffer"	"Assume: bufferPointer points to at least 4 bytes in the heap."	| conversionBuffer |	elementSize := 4.	conversionBuffer := UninterpretedBytes new: elementSize.	bufferPointer copyAt: ((index -1) *elementSize) to: conversionBuffer size: elementSize startingAt: 1.	^conversionBuffer floatAt: 1</body><body package="ODBCEXDI">getIntegerAt: index	"Answer an Integer populated from the buffer."	"Assume: bufferPointer points to at least 4 bytes in the heap."	| conversionBuffer |	elementSize := cbValueMax.	conversionBuffer := UninterpretedBytes new: elementSize.	bufferPointer copyAt: ((index -1) * elementSize) to: conversionBuffer size: elementSize startingAt: 1.	^conversionBuffer longAt: 1</body><body package="ODBCEXDI">getLargeIntegerAt: index	"Answer a LargeInteger number populated from the buffer"	| bytes str |	bytes := pcbValue at: (index -1).	elementSize := cbValueMax.	str := ByteString new: bytes.	bufferPointer copyAt: ((index -1) * elementSize) to: str size: bytes startingAt: 1.	^Integer readFrom: str readStream</body><body package="ODBCEXDI">getStringAt: index	"Answer a String populated from the buffer" 	| bytes byteArray |	bytes := pcbValue at: (index -1).	bytes = bufferSession class xif SQL_NULL_DATA ifTrue: [ ^nil	].	elementSize := cbValueMax.	byteArray := ByteArray new: bytes.	bufferPointer copyAt: ((index -1) * elementSize) to: byteArray size: bytes startingAt: 1.	^byteArray asStringEncoding: self encoding</body><body package="ODBCEXDI">getTimeAt: index	"Answer a Time populated from the buffer"	"For performance reasons, the implementation of this method embeds	knowledge of the structure of the Informix typedef TIME_STRUCT.	Assume: bufferPointer points to at least 6 bytes in the heap"	| conversionBuffer hours minutes seconds fSeconds milliseconds |	elementSize := pcbValue at: (index -1).	conversionBuffer := UninterpretedBytes new: elementSize.	bufferPointer copyAt: ((index -1) * elementSize) to: conversionBuffer size: elementSize startingAt: 1.	hours := conversionBuffer unsignedShortAt: 1.	minutes := conversionBuffer unsignedShortAt: 3.	seconds := conversionBuffer unsignedShortAt: 5.	elementSize &gt; 9 ifTrue: [		fSeconds := conversionBuffer unsignedLongAt: 9.		milliseconds := fSeconds//1000000	] ifFalse: [		fSeconds := 0.		milliseconds := 0	].	^Time new 		hours: hours 		minutes: minutes 		seconds: seconds 		milliseconds: milliseconds		partialNanosecond: (fSeconds - (milliseconds * 1000000)).</body><body package="ODBCEXDI">getTimestampAt: index	"Answer a Timestamp populated from the buffer"	"For performance reasons, the implementation of this method embeds	knowledge of the structure of the Informix typedef TIMESTAMP_STRUCT.	Assume: bufferPointer points to at least 16 bytes in the heap."	| conversionBuffer year month day hours minutes seconds fSecond millisecond ts |	elementSize := 16.	conversionBuffer := UninterpretedBytes new: elementSize.	bufferPointer copyAt: ((index -1) * elementSize) to: conversionBuffer size: elementSize startingAt: 1.	year := conversionBuffer shortAt: 1.	month := conversionBuffer unsignedShortAt: 3.	day := conversionBuffer unsignedShortAt: 5.	hours := conversionBuffer unsignedShortAt: 7.	minutes := conversionBuffer unsignedShortAt: 9.	seconds := conversionBuffer unsignedShortAt: 11.	fSecond := conversionBuffer unsignedLongAt: 13.	millisecond := fSecond//1000000.	(ts := Timestamp new)		year: year;		month: month;		day: day;		hour: hours;		minute: minutes;		second: seconds;		millisecond: millisecond;		partialNanosecond: (fSecond - (millisecond * 1000000)).	^ts</body><body package="ODBCEXDI">getWordArrayAt: index	"Answer a WordArray populated from the buffer."	| bytes wa |	bytes := pcbValue at: (index -1).	elementSize := cbValueMax.	wa := WordArray new: (bytes / 2).	bufferPointer copyAt: ((index -1) * elementSize) to: wa size: bytes startingAt: 1.	^wa</body></methods><methods><class-id>Database.ODBC2Buffer</class-id> <category>accessing</category><body package="ODBCEXDI">bufferValue	^bufferValue</body><body package="ODBCEXDI">cbColDef	"Answer the precision of the buffer value"	^cbColDef</body><body package="ODBCEXDI">cbValueMax	"Answer the receiver's maximum count (length) in bytes."	^cbValueMax</body><body package="ODBCEXDI">encoding	"Answer the encoding"	self isUnicodeColumn ifTrue: [		^self session unicodeEncoding	].	^encoding</body><body package="ODBCEXDI">fCType	"Answer the C data type for the data in this buffer." 	^CTypeFromConversionMap at: databaseType</body><body package="ODBCEXDI">fParamType	^fParamType</body><body package="ODBCEXDI">fSqlType	"Answer the Informix SQL data type for the data in this buffer."	^SQLTypeFromConversionMap at: databaseType</body><body package="ODBCEXDI">iCol	"Answer the receiver external bind index."	^bufferIndex</body><body package="ODBCEXDI">iCol: anInteger	"Set the receiver external bind index."	bufferIndex := anInteger.</body><body package="ODBCEXDI">ibScale	^ibScale</body><body package="ODBCEXDI">isUnicodeColumn	^isUnicodeColumn</body><body package="ODBCEXDI">isUnicodeColumn: aBoolean	isUnicodeColumn := aBoolean</body><body package="ODBCEXDI">pcbValue	"Answer the receiver's count (length) in bytes pointer."	^pcbValue</body><body package="ODBCEXDI">rgbValue	"Answer the receiver's buffer pointer."	^bufferPointer</body><body package="ODBCEXDI">unicode	^unicode</body><body package="ODBCEXDI">unicode: aBoolean	unicode := aBoolean</body><body package="ODBCEXDI">value: aValueOrArray	"Store aValueOrArray into the receiver."	| size |	(aValueOrArray isKindOf: Array) ifTrue: [		size := aValueOrArray size	] ifFalse: [		size := 0 	].	count &lt;= 1 ifTrue: [ 		size = 1 ifTrue: [			^self at: 1 put: (aValueOrArray at: 1)		] ifFalse: [			^self at: 1 put: aValueOrArray		] 	].	size &gt; count ifTrue: [ ^self error: (#errTooBigForBuffer &lt;&lt; #database &gt;&gt; 'too big for buffer') ].	1 to: size do: [ :index |		self at: index put: (aValueOrArray at: index) ].	size &lt; count		ifTrue: [ (size + 1) to: count do: [ :index |					self at: index put: nil ] ]</body></methods><methods><class-id>Database.ODBC2Buffer</class-id> <category>private-data conversion {put}</category><body package="ODBCEXDI">at: index putBoolean: aBoolean	"Set the buffer to hold an encoded bit."	pcbValue at: (index -1) put: 1.	aBoolean		ifTrue:	[ bufferPointer at: index-1 put: 1 ]		ifFalse:	[ bufferPointer at: index-1 put: 0 ].	^aBoolean</body><body package="ODBCEXDI">at: index putByteArray: aByteArray	"Put aByteArray into the buffer."	| bytes |	elementSize := cbValueMax.	(bytes := aByteArray size) &gt; cbColDef ifTrue:		[ self class connectionClass unableToBindSignal raise ].	bufferPointer copyAt: ((index -1) * elementSize) from: aByteArray size: bytes startingAt: 1.	pcbValue at: (index -1) put: bytes.	^aByteArray</body><body package="ODBCEXDI">at: index putDate: aDate	"Put aDate into the buffer."	"For performance reasons, the implementation of this method embeds	knowledge of the structure of the Informix typedef DATE_STRUCT."	| conversionBuffer |	elementSize := 6.	conversionBuffer := UninterpretedBytes new: elementSize.	conversionBuffer shortAt: 1 put: aDate year.	conversionBuffer unsignedShortAt: 3 put: aDate monthIndex.	conversionBuffer unsignedShortAt: 5 put: aDate dayOfMonth.	bufferPointer copyAt: ((index -1) * elementSize) from: conversionBuffer size: elementSize startingAt: 1.	pcbValue at: (index -1) put: elementSize.	^aDate</body><body package="ODBCEXDI">at: index putDouble: aDouble	"Put aDouble into the buffer"	| conversionBuffer |	elementSize := 8.	conversionBuffer := UninterpretedBytes new: elementSize.	conversionBuffer doubleAt: 1 put: aDouble.	bufferPointer copyAt: ((index -1) * elementSize) from: conversionBuffer size: elementSize startingAt: 1.	pcbValue at: (index -1) put: elementSize.	^aDouble</body><body package="ODBCEXDI">at: index putFixedPoint: aFixedPoint	"Put aFixedPoint into the buffer."	| strm str bytes |	elementSize := cbValueMax.	strm := (String new: elementSize) writeStream.	aFixedPoint printOn: strm.	strm skip: -1.	str := strm contents.	"Stick the result into the buffer."	bufferPointer copyAt: ((index -1) * elementSize) from: str size: (bytes := str size) startingAt: 1.	pcbValue at: (index -1) put: bytes.	ibScale := aFixedPoint scale.	^aFixedPoint</body><body package="ODBCEXDI">at: index putFloat: aFloat	"Put aFloat into the buffer"	| conversionBuffer |	elementSize := 4.	conversionBuffer := UninterpretedBytes new: elementSize.	conversionBuffer floatAt: 1 put: aFloat.	bufferPointer copyAt: ((index -1) * elementSize) from: conversionBuffer size: elementSize startingAt: 1.	pcbValue at: (index -1) put: elementSize.	^aFloat</body><body package="ODBCEXDI">at: index putInteger: anInteger	"Put anInteger into the buffer"	| conversionBuffer |	elementSize := 4.	conversionBuffer := UninterpretedBytes new: elementSize.	conversionBuffer longAt: 1 put: anInteger.	bufferPointer copyAt: ((index -1) * elementSize) from: conversionBuffer size: elementSize startingAt: 1.	pcbValue at: (index -1) put: elementSize.	^anInteger</body><body package="ODBCEXDI">at: index putLargeInteger: aLargeInteger	"Put aLargeInteger into the buffer"	| strm str bytes |	elementSize := cbValueMax.	"Print aLargeInteger on strm."	strm := (String new: elementSize) writeStream.	aLargeInteger printOn: strm.	str := strm contents.	"Stick the result into the buffer."	bufferPointer copyAt: ((index -1) * elementSize) from: str size: (bytes := str size) startingAt: 1.	pcbValue at: (index -1) put: bytes.	^aLargeInteger</body><body package="ODBCEXDI">at: index putString: aString	"Put aString into the buffer."	| str bytes stringValue |	elementSize := cbValueMax.	aString class name == #Character ifTrue: [		stringValue := String with: aString	] ifFalse: [		stringValue := aString	].	str := stringValue asByteArrayEncoding: self encoding.	bytes := str size.	bytes &gt; cbColDef ifTrue:		[ self class connectionClass unableToBindSignal raise ].	bufferPointer copyAt: ((index -1) * elementSize) from: str size: bytes startingAt: 1.	pcbValue at: (index -1) put: bytes.	^aString</body><body package="ODBCEXDI">at: index putTime: aTime	"Put aTime into the buffer"	"For performance reasons, the implementation of this method embeds	knowledge of the structure of TIME_STRUCT."	| conversionBuffer nanoSecond |	elementSize := cbValueMax.	conversionBuffer := UninterpretedBytes new: elementSize.	conversionBuffer unsignedShortAt: 1 put: aTime hours.	conversionBuffer unsignedShortAt: 3 put: aTime minutes.	conversionBuffer unsignedShortAt: 5 put: aTime seconds.	nanoSecond := aTime partialNanosecond.	self databaseType = #Time2 ifTrue: [		nanoSecond := nanoSecond//100*100.		cbColDef := 16.		ibScale := 7.		conversionBuffer unsignedLongAt: 9 put: ((aTime milliseconds * 1000000 + nanoSecond)//100*100).	] ifFalse: [		ibScale := 3.	].	bufferPointer copyAt: ((index -1) * elementSize) from: conversionBuffer size: elementSize startingAt: 1.	pcbValue at: (index -1) put: elementSize.	^aTime</body><body package="ODBCEXDI">at: index putTimestamp: aTimestamp	"Put aTimestamp into the buffer"	"For performance reasons, the implementation of this method embeds	knowledge of the structure of the Informix typedef TIMESTAMP_STRUCT."	| conversionBuffer nanoSecond |	elementSize := 16.	conversionBuffer := UninterpretedBytes new: elementSize.	conversionBuffer shortAt: 1 put: (aTimestamp year max: 1). " max: 1 is for visigenics problem "	conversionBuffer unsignedShortAt: 3 put: aTimestamp month.	conversionBuffer unsignedShortAt: 5 put: aTimestamp day.	conversionBuffer unsignedShortAt: 7 put: aTimestamp hour.	conversionBuffer unsignedShortAt: 9 put: aTimestamp minute.	conversionBuffer unsignedShortAt: 11 put: aTimestamp second.	nanoSecond := aTimestamp partialNanosecond.	((self session connection dbmsName = 'Microsoft SQL Server') and: [ nanoSecond  &gt; 0 ]) ifTrue: [		nanoSecond := nanoSecond//100*100.		cbColDef := 27.		ibScale := 7.	] ifFalse: [		ibScale := 3.	].	conversionBuffer unsignedLongAt: 13 put: (aTimestamp millisecond * 1000000 + nanoSecond).	bufferPointer copyAt: ((index -1) * elementSize) from: conversionBuffer size: elementSize startingAt: 1.	pcbValue at: (index -1) put: elementSize.	^aTimestamp</body><body package="ODBCEXDI">at: index putWordArray: aWordArray	"Put aWordArray into the buffer."	| octets |	aWordArray size &gt; cbColDef ifTrue:		[ self class connectionClass unableToBindSignal raise ].	bufferPointer copyAt: (index -1 ) 				from: aWordArray 				size: (octets := aWordArray basicSize) startingAt: 1.	pcbValue at: (index -1) put: octets.	^aWordArray</body></methods><methods><class-id>Database.ODBC2Buffer</class-id> <category>private-accessing</category><body package="ODBCEXDI">at: anIndex	"Answer the object in the buffer at anIndex."	^((pcbValue at: (anIndex -1)) == self class connectionClass xif SQL_NULL_DATA)		ifTrue:	 [ nil ]		ifFalse: [ 			getSelector isNil ifTrue: [				^self class connectionClass unsupportedDataTypeSignal raise			] ifFalse: [				self perform: getSelector with: anIndex 			]		].</body><body package="ODBCEXDI">at: anIndex put: anObject	"Store anObject into the buffer at anIndex."	anObject isNil		ifTrue: [ pcbValue at: (anIndex -1) put: self class connectionClass xif SQL_NULL_DATA ]		ifFalse:[ 			putSelector isNil ifTrue: [				^self class connectionClass unsupportedDataTypeSignal raise			] ifFalse: [				self perform: putSelector with: anIndex with: anObject 			]		].	^anObject</body><body package="ODBCEXDI">reUse: aValue 	"Re-use this buffer for an object of the same type, and 	same or smaller size. Update cbColDef (object size). 	Don't update maxColDef (bufferPointer memory size)."	| maxValue arraySize |	(aValue isKindOf: Array) ifTrue: [		arraySize := aValue size.		maxValue := self findMaxValue: aValue.	] ifFalse: [		arraySize := 0.		maxValue := aValue.	].	(self canHold: aValue) ifTrue: [		arraySize &lt; self count ifTrue: [			arraySize = 0 ifTrue: [				count := 1			] ifFalse: [	 				count := arraySize			] 		]	] ifFalse: [		self class connectionClass unableToBindSignal raise	].	bufferValue := aValue.	cbColDef := self isStringBased 					ifTrue: [ (ValuePrecisionBlocks at: databaseType) value: (maxValue asByteArrayEncoding: self encoding) ] 					ifFalse: [  (ValuePrecisionBlocks at: databaseType) value: maxValue].	self value: aValue.	self rebindForInput</body><body package="ODBCEXDI">session	"Answer the database session in which the receiver is being bound."	^bufferSession</body><body package="ODBCEXDI">session: anExternalDatabaseSession	"Associate a database session which the receiver will use to bind itself."	bufferSession := anExternalDatabaseSession.</body></methods><methods><class-id>Database.ODBC2Buffer</class-id> <category>binding</category><body package="ODBCEXDI">bindForInput	"Binding contents of the receiver to the server."	fParamType := bufferSession class xif SQL_PARAM_INPUT.	"We won't re-use pointers."	(bufferPointer isNil)		ifFalse: [ self free ].	self mallocUsingSelector: bufferSession class xif mallocSelector.	self value: bufferValue.	self bindInputExternal</body><body package="ODBCEXDI">bindForInputOutput	"Binding contents of the receiver to the server."	fParamType := bufferSession xif SQL_PARAM_INPUT_OUTPUT.</body><body package="ODBCEXDI">bindForOutput	"Setup the receiver to hold the contents of a single column."	fParamType := bufferSession class xif SQL_PARAM_OUTPUT.	"We won't re-use pointers."	(bufferPointer isNil)		ifFalse: [ self free ].	"Allocate external CPointers."	self mallocUsingSelector: bufferSession class xif mallocSelector.	self bindOutputExternal</body><body package="ODBCEXDI">rebindForInput	"Binding contents of the receiver to the server."	self bindInputExternal.</body></methods><methods><class-id>Database.ODBC2Buffer</class-id> <category>testing</category><body package="ODBCEXDI">canHold: aValue 	"Can we re-use this buffer? Return true if this buffer 	has the correct type and is big enough to hold 	aValue."	| dataType arraySize maxValue |	(aValue isKindOf: Array) ifTrue: [		maxValue := self findMaxValue: aValue.		dataType := maxValue odbcConversion.		arraySize := aValue size	] ifFalse: [		maxValue := aValue.		dataType := aValue odbcConversion.		arraySize := 0	].	^(self databaseType == dataType and: [ (count &gt;= arraySize) or: [ count &lt;= 1 and: [ arraySize &lt;= 1]]]) ifFalse: [false]		ifTrue: [(self isStringBased or: [self isArrayBased])				ifTrue: [ self isStringBased ifTrue: [ self cbValueMax &gt;= (maxValue asByteArrayEncoding: self encoding) size] ifFalse: [ self cbValueMax &gt;= aValue size ] ]				ifFalse: [true]]</body><body package="ODBCEXDI">isArrayBased	^#(#ByteArray #LargeByteArray) includes: self databaseType</body><body package="ODBCEXDI">isLargeObject	^false</body><body package="ODBCEXDI">isStringBased	^#(#String #LargeString) includes: self databaseType</body><body package="ODBCEXDI">isTime2: aValue	^(self databaseType == #Time	and: [(self session connection dbmsName = 'Microsoft SQL Server')	and: [aValue notNil	and: [aValue partialNanosecond &gt; 0]]])</body><body package="ODBCEXDI">isUnicode: aSqlType	^#( -8 -9 -10 -95 -96 -350) includes: aSqlType</body><body package="ODBCEXDI">isUnicodeEncoding	| encodingString |	encodingString := self encoding asUppercase.	^((encodingString beginsWith: 'UTF') or: [ encodingString beginsWith: 'UCS' ])</body></methods><methods><class-id>Database.ODBC2Buffer</class-id> <category>private</category><body package="ODBCEXDI">findMaxValue: anArray	"Answer nonNil value or the largest value for Strings and ByteArrays."	^self class findMaxValue: anArray</body><body package="ODBCEXDI">getSelector	^getSelector</body><body package="ODBCEXDI">pointerType	"Answer the pointer type to use for buffer allocation."	| refType |	databaseType == #WordArray		ifTrue:	[ refType := CIntegerType unsignedShort ]		ifFalse:	[ refType := CIntegerType char ].	^CArrayType defaultPointer			referentType: refType;			numElements: cbValueMax.</body><body package="ODBCEXDI">putSelector	^putSelector</body></methods><methods><class-id>Database.ODBC2Buffer</class-id> <category>allocation</category><body package="ODBCEXDI">free	"Free the receiver."	bufferSession :=  nil.	pcbValue notNil ifTrue:		[ pcbValue freePointer.		  pcbValue := nil ].	super free.</body><body package="ODBCEXDI">mallocUsingSelector: mallocSelector	"Allocate a physical buffer for the receiver. Use mallocSelector to perform the allocation." 	"Assume: the get and put methods will coerce the bufferPointer correctly."	"Assert: mallocSelector is either #malloc: or #malloc16:"	[ "Begin unwind protection."	super mallocUsingSelector: mallocSelector.	pcbValue := self session class xif longIntegerType perform: mallocSelector with: (count max: 1).	"End unwind protection." ]		ifCurtailed: [ self free ]</body></methods><methods><class-id>Database.ODBC2Buffer</class-id> <category>initialize-release</category><body package="ODBCEXDI">descriptor: aColDesc position: position session: session	"Initialize an instance of receiver which is set up to hold values as described."	cbColDef := aColDesc precision.	bufferIndex := position.	bufferSession := session.	self encoding: bufferSession encoding.	(count := bufferSession blockFactor) &gt; 1 ifFalse: [		count := 0	].	databaseType := aColDesc type.	self isUnicodeColumn: (self isUnicode: aColDesc fSqlType).	self unicode: (session unicode or: [ self isUnicodeColumn ]).	aColDesc isLong ifTrue: [		cbValueMax := (FetchBufferSizeBlocks at: aColDesc type) value: self session lobBufferSize.	] ifFalse: [		cbValueMax := (FetchBufferSizeBlocks at: aColDesc type) value: aColDesc precision.	].	self isStringBased ifTrue: 		[self unicode ifTrue: [			self encoding == #'UTF-8' ifTrue: [				cbColDef := cbColDef * 3.				cbValueMax := cbValueMax * 3.			] ifFalse: [				cbColDef := cbColDef * 2.				cbValueMax := cbValueMax * 2.			] 		]	].	getSelector := GetSelectorMap at: databaseType ifAbsent: [nil].	putSelector := PutSelectorMap at: databaseType ifAbsent: [nil].</body><body package="ODBCEXDI">on: aValue position: position session: session	"Initialize an instance of receiver which is set up to hold aValue."	| maxValue |	ibScale := 0.	bufferIndex := position.	bufferSession := session.	bufferValue := aValue.	self encoding: bufferSession encoding.	self isUnicodeColumn: false.	self unicode: false.	bufferSession unicode		ifTrue: [self unicode: bufferSession unicode]		ifFalse:			[bufferSession bindTemplate isNil ifFalse:				[(bufferSession bindTemplate at: (bufferSession bindMarkerAtPosition: position))					== #UnicodeString ifTrue:						[self isUnicodeColumn: true.						self unicode: true]]].	databaseType := session conversionFor: aValue at: position.	databaseType == #Array		ifTrue: 			[maxValue := self findMaxValue: aValue.			databaseType := session conversionFor: maxValue at: position.			count := aValue size]		ifFalse: 			[maxValue := aValue.			count := 0].	(self isTime2: maxValue) ifTrue: [databaseType := #Time2].	(aValue isNil or: [ (aValue odbcConversion = #Array) and: [maxValue isNil] ])		ifTrue: 			[cbValueMax := 0.			cbColDef := -1]		ifFalse: 			[self isStringBased				ifTrue: 					[| stringValue |					stringValue := maxValue class name == #Character								ifFalse: [maxValue]								ifTrue: [String with: maxValue].					cbValueMax := (ValueSizeBlocks at: databaseType)								value: (stringValue asByteArrayEncoding: self encoding).					cbColDef := (ValuePrecisionBlocks at: databaseType)								value: (stringValue asByteArrayEncoding: self encoding)]				ifFalse: 					[cbValueMax := (ValueSizeBlocks at: databaseType) value: maxValue.					cbColDef := (ValuePrecisionBlocks at: databaseType) value: maxValue]].	getSelector := GetSelectorMap at: databaseType ifAbsent: [nil].	putSelector := PutSelectorMap at: databaseType ifAbsent: [nil]</body></methods><methods><class-id>Database.ODBC2Buffer class</class-id> <category>private</category><body package="ODBCEXDI">findMaxValue: anArray	"Answer nonNil value or the largest value for Strings and ByteArrays."	| repValue repType |	repValue := anArray detect: [ :each | each notNil ] ifNone: [ nil ].	repType := repValue odbcConversion.	(#(#ByteArray #LargeByteArray #String #LargeString) includes: repType ) ifTrue:[ 		anArray do: [ :each|			each size &gt; repValue size ifTrue: [ repValue := each ]		]	].	repValue respondsToArithmetic ifTrue: [		anArray do: [ :each|			each notNil ifTrue: [				each abs &gt; repValue abs ifTrue: [ repValue := each ]			]		]	].	^repValue</body></methods><methods><class-id>Database.ODBC2Buffer class</class-id> <category>instance creation</category><body package="ODBCEXDI">new	^self error: 'An ODBCBuffer is created and privately used by an instance of ODBCSession.'</body></methods><methods><class-id>Database.ODBC2Buffer class</class-id> <category>private-instance creation</category><body package="ODBCEXDI">descriptor: aColDesc position: position session: session	"Create an appropriate instance of an ODBCBuffer which is set up to hold values as described." 	^(aColDesc isLong)		ifTrue: [self largeObjectBufferClass basicNew descriptor: aColDesc position: position session: session]		ifFalse: [self basicNew descriptor: aColDesc position: position session: session ].</body><body package="ODBCEXDI">on: aValue position: position session: session 	"Create an appropriate instance of an ODBCBuffer which is set up to hold values as described."	| valueType |	valueType := aValue odbcConversion.	valueType == #Array ifTrue: [ 		valueType := (self findMaxValue: aValue) odbcConversion.	].	^(#(#LargeString #LargeByteArray #Stream) includes: valueType )		ifTrue: [self largeObjectBufferClass basicNew				on: aValue				position: position				session: session]		ifFalse: [self basicNew				on: aValue				position: position				session: session]</body></methods><methods><class-id>Database.ODBC2Buffer class</class-id> <category>accessing</category><body package="ODBCEXDI">connectionClass	^ODBC2Connection</body><body package="ODBCEXDI">largeObjectBufferClass	^ODBCLargeObjectBuffer</body></methods><methods><class-id>Database.ODBC2Buffer class</class-id> <category>private-activation</category><body package="ODBCEXDI">install	| ifcClass |	(ifcClass := self connectionClass interfaceClass) notNil ifTrue:		[ GetSelectorMap := ifcClass getSelectorMap.		PutSelectorMap := ifcClass putSelectorMap.		SQLTypeFromConversionMap := ifcClass fSqlTypeFromConversionMap.		CTypeFromConversionMap := ifcClass fCTypeFromConversionMap.		FetchBufferSizeBlocks := ifcClass fetchBufferSizeBlocks.		ValueSizeBlocks := ifcClass valueSizeBlocks.		ValuePrecisionBlocks := ifcClass valuePrecisionBlocks ].</body></methods><methods><class-id>Database.ODBC2Buffer class</class-id> <category>class initialization</category><body package="ODBCEXDI">initialize	"ODBCBuffer initialize"	self install</body></methods><methods><class-id>Database.ODBC2Buffer class</class-id> <category>filein/fileout</category><body package="ODBCEXDI">prerequisitesForLoading	"The receiver requires ODBCConnection to have initialized	 its interface mapping before it initializes."	^super prerequisitesForLoading		addLast: ODBC2Connection;		addLast: ODBCCLI95Interface;		yourself</body></methods><methods><class-id>Database.ODBCBuffer</class-id> <category>private-binding</category><body package="ODBCEXDI">bindOutputExternal	"Prepare the receiver to automatically receive it's data from the server."	| rc xif cType rowSetSize |	xif := bufferSession class xif.	cType := self fCType.	(self isStringBased and: [ self unicode ]) ifTrue: [		cType := xif SQL_C_WCHAR	].	cType = xif SQL_SS_TIME2 ifTrue: [		cType := xif SQL_C_DEFAULT	].	count &gt;= 1 ifTrue: [		rowSetSize := count	] ifFalse: [		rowSetSize := 1	].	bufferSession pRowStatusArray isNil ifFalse: [ bufferSession pRowStatusArray freePointer ].	bufferSession pRowStatusArray: (xif SQLUINTEGER perform: xif mallocSelector with: rowSetSize).	bufferSession setStatementOption: #SQL_ATTR_ROW_STATUS_PTR value: bufferSession pRowStatusArray.		bufferSession setStatementOption: #SQL_ATTR_ROW_ARRAY_SIZE value: rowSetSize.		rc := xif SQLBindCol: bufferSession hstmt					with: bufferIndex					with: cType					with: bufferPointer					with: cbValueMax					with: pcbValue.		( bufferSession traceLevel &gt;= 3 ) ifTrue:		[ (bufferSession  traceStream)			print: rc;  nextPutAll: ' = SQLBindCol( hstmt = ';			nextPutAll: (bufferSession hstmt referentAddress printStringRadix: 16);			nextPutAll: ', icol =';  print: bufferIndex;			nextPutAll: ', fCType = '; print: self fCType;			nextPutAll: ', rgbValue = '; 			nextPutAll: (bufferPointer referentAddress printStringRadix: 16);			nextPutAll: ', cbValueMax = ';  print: cbValueMax;			nextPutAll: ', pcbValue = '; print: (pcbValue referentAddress printStringRadix: 16);			nextPutAll: ' )'.		bufferSession class trace: bufferSession emitTrace ].	(rc == xif SQL_SUCCESS) ifFalse:		[ | errs |		errs := bufferSession getStatementErrors.		^bufferSession class connectionClass unableToBindSignal raiseWith: errs errorString: errs first dbmsErrorString ].</body></methods><methods><class-id>Database.ODBCColumnDescription</class-id> <category>accessing</category><body package="ODBCEXDI">fSqlType	"Return the receiver's SQL type"	^fSqlType</body></methods><methods><class-id>Database.ODBCColumnDescription</class-id> <category>private-accessing</category><body package="ODBCEXDI">fSqlType:	aSmallInteger	"Set the receiver's SQL type."	fSqlType := aSmallInteger</body></methods><methods><class-id>Database.ODBCColumnDescription</class-id> <category>testing</category><body package="ODBCEXDI">isLong	"Answer true if the receiver represents a long result column."	^self class lobDataTypes includes: fSqlType</body></methods><methods><class-id>Database.ODBCColumnDescription class</class-id> <category>accessing</category><body package="ODBCEXDI">connectionClass	^ODBC2Connection</body><body package="ODBCEXDI">lobDataTypes	^lobDataTypes</body></methods><methods><class-id>Database.ODBCColumnDescription class</class-id> <category>class initialization</category><body package="ODBCEXDI">initialize	| xif |	xif := self connectionClass xif.	lobDataTypes := OrderedCollection with: xif SQL_LONGVARCHAR with: xif SQL_LONGVARBINARY with: xif SQL_WLONGVARCHAR with: xif SQL_BLOB.	lobDataTypes add: xif SQL_CLOB.	lobDataTypes add: xif SQL_DBCLOB.</body></methods><methods><class-id>Database.ODBCCLISolarisInterface class</class-id> <category>class initialization</category><body package="ODBCEXDI">initialize	super initialize.</body></methods><methods><class-id>Database.ODBCCLILinuxInterface class</class-id> <category>class initialization</category><body package="ODBCEXDI">initialize	super initialize.</body></methods><methods><class-id>Database.ODBCTransaction</class-id> <category>private-finalization</category><body package="ODBCEXDI">acquireExternal	^self</body><body package="ODBCEXDI">beginExternal	^self</body><body package="ODBCEXDI">commitExternal	^self</body><body package="ODBCEXDI">dismissExternal	^self</body><body package="ODBCEXDI">rollbackExternal	^self</body></methods><methods><class-id>Database.ODBCTransaction</class-id> <category>private-execution</category><body package="ODBCEXDI">executor	^self shouldNotImplement</body><body package="ODBCEXDI">finalizeExternal	^self shouldNotImplement</body><body package="ODBCEXDI">key	^self shouldNotImplement</body></methods><methods><class-id>Database.ODBCTransaction class</class-id> <category>private-registry</category><body package="ODBCEXDI">registry: aCollection	^self shouldNotImplement</body></methods><methods><class-id>Database.ODBCTransaction class</class-id> <category>accessing</category><body package="ODBCEXDI">connectionClass	"Answer the class to use for connection objects associated with receiver."	^ODBC2Connection</body></methods><methods><class-id>Database.UnableToGetConnectionOptions</class-id> <category>printing</category><body package="ODBCEXDI">defaultMessageText	^(#errGetConnectionOptions &lt;&lt; #odbcDB &gt;&gt; 'Unable to get the connection option') asString</body></methods><methods><class-id>Database.UnableToSetStatementOptions</class-id> <category>printing</category><body package="ODBCEXDI">defaultMessageText	^(#errSetStatementOptions &lt;&lt; #odbcDB &gt;&gt; 'Unable to set the statement option') asString</body></methods><methods><class-id>Database.ODBCDataSource</class-id> <category>printing</category><body package="ODBCEXDI">printOn: aStream	super printOn: aStream.	aStream		nextPutAll: '( DSN =';		print: self name; nextPutAll: ', Description = ';		print: self description; nextPutAll: ' )'</body></methods><methods><class-id>Database.ODBCDataSource</class-id> <category>accessing</category><body package="ODBCEXDI">description	^description</body><body package="ODBCEXDI">description: aString	description := aString</body><body package="ODBCEXDI">name	^name</body><body package="ODBCEXDI">name: aString	name  := aString</body></methods><methods><class-id>Database.ODBCCLIMacOSXInterface class</class-id> <category>class initialization</category><body package="ODBCEXDI">initialize	super initialize.</body></methods><methods><class-id>Database.ODBC2Session</class-id> <category>private-binding</category><body package="ODBCEXDI">bindExecutionParameters	"Retrieve data-at-execution parameters and send them to the server."	| lobBuffers lobCount nonArray |	lobBuffers := self bindValuePointers values select: [ :each| each isKindOf: ODBCLargeObjectBuffer ].	lobBuffers isEmpty ifTrue: [ ^self ].	lobCount := (lobBuffers at: 1) count.	lobCount =0 ifTrue: [ 		lobCount := 1.		nonArray := true	] ifFalse: [		nonArray := false	].	self getParameterIndexExternal.	(self connection dbmsName beginsWith: 'Oracle') ifTrue: [		1 to: lobBuffers size do: [ :index| | aBuffer |			aBuffer := lobBuffers at: index.			1 to: lobCount do: [ :index1| | aValue |				nonArray ifTrue: [					aValue := aBuffer value				] ifFalse: [					aValue := aBuffer value at: index1				].				aBuffer putLobValue: aValue.				self getParameterIndexExternal.			]		]	] ifFalse: [		1 to: lobCount do: [ :index|			1 to: lobBuffers size do: [ :index1| | aValue |				nonArray ifTrue: [					aValue := (lobBuffers at: index1) value				] ifFalse: [					aValue := (lobBuffers at: index1) value at: index				]. 				aValue isNil ifFalse: [					(lobBuffers at: index1) putLobValue: aValue.					self getParameterIndexExternal.				]			]		]	]</body><body package="ODBCEXDI">bindExternal	"Bind values to parameters in the query, avoiding unnecessary rebinding where possible.  For each bind marker in the query fragments, get the corresponding value from the bindInput object. If the value isn't already bound, bind and remember it."	| leftToRightIndex |	leftToRightIndex := 1.	2 to: queryFragments size by: 2 do:		[:index || bindMarker value |		bindMarker := queryFragments at: index.		value := self inBindInputAt: bindMarker.		"A bindMarker can be a symbol if the prepared SQL contained &lt;:name&gt;. 		Therefore we will have to manually specify a left-to-right index for our 		parameter positions. The same value can be used at different positions." 		self bindValue: value at: leftToRightIndex.		(self boundValueAt: bindMarker is: value) ifFalse:			[self bindValues at: bindMarker put: value].		leftToRightIndex := leftToRightIndex + 1].</body><body package="ODBCEXDI">bindValue: aValue at: position 	"Bind a value to a parameter position in the query. 	Re-use an existing buffer only if it is big enough.	An existing buffer can be too small if it holds a #String,	but the new value is a #LargeString, for example."	| buffer val |	val := (aValue isKindOf: Stream) ifTrue: [aValue contents] ifFalse: [aValue].	buffer := self bindValuePointers at: position ifAbsent: [nil].	buffer isNil ifFalse: [(buffer canHold: val)			ifFalse: 				[buffer free.				buffer := nil]].	buffer isNil		ifTrue: [			buffer := self class bufferClass						on: val						position: position						session: self.			buffer bindForInput.			self bindValuePointers at: position put: buffer]		ifFalse: 			[buffer reUse: val]</body><body package="ODBCEXDI">bindValuePointers	"Answer with the receiver's dictionary of bound rgbValue pointers (input parameters)."	bindValuePointers isNil ifTrue:		[ bindValuePointers := IdentityDictionary new ].	^bindValuePointers</body><body package="ODBCEXDI">conversionFor: aValue at: aPosition	aValue ifNotNil: [^aValue odbcConversion].     ^bindTemplate ifNil: [#String] ifNotNil: [(bindTemplate at: aPosition) ifNil: [#String]].</body><body package="ODBCEXDI">prepareExternal	"Prepare the server to execute a query."	| xif sql sqlBa rc sqlBaPtr |	xif := self class xif.	"Assemble the query, substituting the correct parameter markers."	queryFragments size == 1		ifTrue:			[ sql := queryFragments at: 1 ]		ifFalse:			[ | sqlStream |			sqlStream := (String new: query size) writeStream.			sqlStream nextPutAll: (queryFragments at: 1).			2 to: queryFragments size by: 2 do:				[ :index |				sqlStream					nextPut: $?;					nextPutAll: (queryFragments at: index + 1) ].			sql := sqlStream contents ].	sqlBa := sql asByteArrayEncoding: self encoding.	[ "Begin unwind protection."	sqlBaPtr := sqlBa gcCopyToHeap.	self isUnicodeEncoding ifTrue: [		rc := xif SQLPrepareW: self hstmt			                with: sqlBaPtr			                with: sql size.	] ifFalse: [		rc := xif SQLPrepare: self hstmt			                with: sqlBaPtr			                with: sqlBa size.	].	( traceLevel &gt;= 1 ) ifTrue:		[ (self traceStream)			print: rc;  nextPutAll: ' = SQLPrepare( hstmt = ';			nextPutAll: (self hstmt referentAddress printStringRadix: 16);			nextPutAll: ', szSqlStr = '''; print: sql asString;			nextPutAll: ''', cbSqlStr = '; print: sql size;			nextPutAll: ' )'.		self class trace: self emitTrace ].	(rc == xif SQL_ERROR) ifTrue:		[ | errs |		errs := self getStatementErrors.		self class connectionClass unableToPrepareSignal raiseWith: errs errorString: errs first dbmsErrorString ].	"End unwind protection" ]		ifCurtailed:			[ self connection inTransactionMode ifFalse:				[ self connection transactExternal: #SQL_ROLLBACK ] ]</body><body package="ODBCEXDI">releaseBindings	bindValuePointers notNil ifTrue:		[ | bvps hstmt |		((hstmt := self hstmt) isNil or: [hstmt referentAddress isNil]) ifFalse:			[ self freeStatementExternal: #SQL_RESET_PARAMS ].		bvps := bindValuePointers values.		1 to: bvps size do:			[ :i | | buffer |			(buffer := bvps at: i) notNil ifTrue: [ buffer free ] ].		bindValuePointers := nil ].	super releaseBindings</body><body package="ODBCEXDI">setParamSetSizeTo: anInteger	"Set the parameter set size to anInteger."	self setStatementOption: #SQL_ATTR_PARAMSET_SIZE value: anInteger.</body><body package="ODBCEXDI">startPrepare	super startPrepare.	self setParamSetSizeTo: 1</body></methods><methods><class-id>Database.ODBC2Session</class-id> <category>accessing</category><body package="ODBCEXDI">bindInput: aBindObject 	"Supply aBindObject as the object from which input values should be 	obtained for host variable references in the SQL text.  Host variables	may be specified using either a positional or a named notation.  The	driver may limit to only one form.	When using the positional form (a ?), all host variable references (including	the named ones) are implicitly ordered by their position in the SQL-text.	The n-th variable of aBindObject is used for the n-th host variable reference.	If aBindObject has both instance variables and indexed variables, only the	indexed variables will be used. 	When using the named form, the leading colon is removed and the name is	expected to be an accessing method on aBindObject (i.e. aBindObject is sent	perform: with the name converted to a symbol as the argument)."	(aBindObject isKindOf: Array) ifTrue: [		super bindInput: (self validateBindInput: aBindObject)	] ifFalse: [		super bindInput: aBindObject.	]</body><body package="ODBCEXDI">bindInput: aBindObject template: aBindTemplate	"Supply aBindObject as the object from which input values should be 	obtained for host variable references in the SQL text.  Host variables	may be specified using either a positional or a named notation.  The	driver may limit to only one form.	When using the positional form (a ?), all host variable references (including	the named ones) are implicitly ordered by their position in the SQL-text.	The n-th variable of aBindObject is used for the n-th host variable reference.	If aBindObject has both instance variables and indexed variables, only the	indexed variables will be used. 	When using the named form, the leading colon is removed and the name is	expected to be an accessing method on aBindObject (i.e. aBindObject is sent	perform: with the name converted to a symbol as the argument)."	(aBindObject isKindOf: Array) ifTrue: [		super bindInput: (self validateBindInput: aBindObject)	] ifFalse: [		super bindInput: aBindObject.	].	bindTemplate := aBindTemplate</body><body package="ODBCEXDI">encoding	encoding isNil ifTrue: [ encoding := self connection encoding ].	^encoding</body><body package="ODBCEXDI">encoding: anEncoding	encoding := anEncoding</body><body package="ODBCEXDI">lobBufferSize	^lobBufferSize</body><body package="ODBCEXDI">lobBufferSize: anInteger	lobBufferSize := anInteger</body><body package="ODBCEXDI">queryIsPROC	^queryIsPROC</body><body package="ODBCEXDI">unicode	^unicode</body><body package="ODBCEXDI">unicode: aBoolean	unicode := aBoolean.	aBoolean ifTrue: [		self isUnicodeEncoding ifFalse: [			self encoding: #UCS_2		]	].</body><body package="ODBCEXDI">unicodeEncoding	unicodeEncoding isNil ifTrue: [ unicodeEncoding := self connection unicodeEncoding ].	^unicodeEncoding</body><body package="ODBCEXDI">unicodeEncoding: anEncoding	unicodeEncoding := anEncoding</body></methods><methods><class-id>Database.ODBC2Session</class-id> <category>private-answer set</category><body package="ODBCEXDI">aboutToAnswer	"Do last-minute work before fetching data from an answer set"	self rowsInBlock: 0.	self currentRowIndex: 0.</body><body package="ODBCEXDI">acquireBuffers	"Acquire buffers for fetching the answer set from the server."	"Set blockFactor to 1 if the select list contains Large OBjects."	self blockFactor ~= 1 ifTrue: [		(self columnDescriptions contains: [ :each|  each isLong ]) ifTrue: [			self blockFactor: 1		]	].	super acquireBuffers</body><body package="ODBCEXDI">advanceExternal	"Advance to the next row in the block buffer.  If the buffer is exhausted, refill it and continue.  Do not let currentRowIndex scroll more than one above the beginning (or be more than one below the end).  If no data was found, rowsInBlock will have been set to -1, making the #between:and: interval empty."	(self currentRowIndex between: 0 and: self rowsInBlock)		ifTrue: [self currentRowIndex: self currentRowIndex + 1].	"Return nil if no more rows will be found ..."	self currentRowIndex &gt; self rowsInBlock ifTrue:		[(self rowsInBlock &lt; self blockFactor and: [self rowsInBlock &gt; 0]) ifTrue: [^nil].		self getBlockOfRowsExternal isNil ifTrue: [^nil].		self rowsInBlock &lt;= 0 ifTrue:	[^nil].		self currentRowIndex: 1].	"... otherwise return self."</body><body package="ODBCEXDI">advanceExternal: fetchOrientation offset: fetchOffset	"Advance to the next row in the block buffer.  If the buffer is exhausted,	refill it and continue."	self scrollable ifFalse: [		self connection class unsupportedCursorTypeSignal raiseRequest.		^nil	].	fetchOrientation == self fetchNextMode ifTrue: [		self currentRowIndex: (self currentRowIndex + 1).	] ifFalse: [		fetchOrientation == self fetchPriorMode ifTrue: [			self currentRowIndex &gt; 0  ifTrue: [ self currentRowIndex: (self currentRowIndex - 1) ].		] ifFalse: [			fetchOrientation == self fetchAbsoluteMode ifTrue: [				self currentRowIndex: (self blockFactor + 2).				self rowsInBlock: (self blockFactor + 1).			] ifFalse: [				fetchOrientation == self fetchRelativeMode ifTrue: [					self currentRowIndex: (self currentRowIndex + fetchOffset).				].			].		].	].	((self currentRowIndex &gt; self rowsInBlock) or: [ self currentRowIndex &lt;= 0 ])		ifTrue:	[ 				(self getBlockOfRowsExternal: fetchOrientation offset: fetchOffset) isNil ifTrue: [ ^nil ].				self rowsInBlock &lt;= 0					ifTrue:	[ ^nil		"No more rows will be found" ].					fetchOrientation == self fetchPriorMode ifTrue: [						self currentRowIndex &lt;= 0 ifTrue: [							self currentRowIndex: self rowsInBlock.						]					] ifFalse: [						self currentRowIndex: 1.					].			].	^self</body><body package="ODBCEXDI">allocateRowBufferExternal: aColumn 	"Answer an odbc buffer allocated for holding one column's worth of information 	as returned by the ODBC CLI. An appropriate buffer class for the result column 	will be choosen automatically."	| aColDescription bufferClass buffer |	aColDescription := columnDescriptions at: aColumn.	bufferClass := (self isAnswerColumnBound: aColumn)				ifTrue: [self class bufferClass]				ifFalse: [self class largeObjectBufferClass].	buffer := bufferClass				descriptor: aColDescription				position: aColumn				session: self.	buffer bindForOutput.	^buffer</body><body package="ODBCEXDI">cancelAnswerSetExternal	"Cancel current answer set from the server."	| stateTemp |	stateTemp := self state.	(stateTemp == #new or: [stateTemp == #paused or: [self hstmt isNil]]) 		ifTrue: [^self].	self freeStatementExternal: #SQL_CLOSE.	self handleAutoCommit</body><body package="ODBCEXDI">describeAnswerColumns	"Fill in the columnDescriptions array."	| xif descrs cbColNameMax columnDescriptionClass szColName pcbColName pfSqlType pcbColDef pibScale pfNullable rc precision colDesc fSqlType longType |	xif := self class xif.	descrs := Array new: self numColumns.	cbColNameMax := (self connection getInformationType: #SQL_MAX_COLUMN_NAME_LEN) + 1.	columnDescriptionClass := self connection class columnDescriptionClass.	[ "Begin unwind protection."	szColName := (xif charDataTypeUnicode: self isUnicodeEncoding) perform: xif mallocSelector with: cbColNameMax.	pcbColName := xif SWORD perform: xif mallocSelector with: 1.	pfSqlType := xif SWORD perform: xif mallocSelector with: 1.	pcbColDef := xif SQLULEN perform: xif mallocSelector with: 1.	pibScale := xif SWORD perform: xif mallocSelector with: 1.	pfNullable := xif SWORD perform: xif mallocSelector with: 1.	1 to: self numColumns do:		[ :aColumn |		self isUnicodeEncoding ifTrue: [			rc := xif SQLDescribeColW: self hstmt					with: aColumn					with: szColName					with: cbColNameMax					with: pcbColName					with: pfSqlType					with: pcbColDef					with: pibScale					with: pfNullable.		] ifFalse: [			rc := xif SQLDescribeCol: self hstmt					with: aColumn					with: szColName					with: cbColNameMax					with: pcbColName					with: pfSqlType					with: pcbColDef					with: pibScale					with: pfNullable.		].		precision := pcbColDef contents.		( traceLevel &gt;= 2) ifTrue:			[ (self traceStream)				print: rc;  nextPutAll: ' = SQLDescribeCol( hstmt=';				nextPutAll: (self  hstmt referentAddress printStringRadix: 16);				nextPutAll: ', icol =';  print: aColumn;				nextPutAll:  ', szColName: '; print: szColName copyCStringFromHeap;				nextPutAll:  ', cbColName: '; print: pcbColName contents;				nextPutAll:  ', fSQLType: '; print: pfSqlType contents;				nextPutAll:  ', cbColDef: '; print: precision;				nextPutAll:  ', ibScale: ';  print: pibScale contents;				nextPutAll:  ', fNullable: ';  print: pfNullable contents;				nextPutAll:  ' )'.			self class trace: self emitTrace ].		( rc == xif SQL_SUCCESS		or: [ rc == xif SQL_SUCCESS_WITH_INFO] ) ifFalse:			[ | errs |		  	errs := self getStatementErrors.			^self class connectionClass unableToDescribeSignal raiseWith: errs errorString: errs first dbmsErrorString ].		"If this is a SQL Native client, a varchar(max), varbinary(max), or nvarchar(max) column has precision = 0.		If so, then reset its precision and sql type to make this column appear to be a LONG."		fSqlType := pfSqlType contents.		(precision = 0 and: [self isSQLNativeClient])			ifTrue: [(longType := self getLongTypeFor: fSqlType) notNil				ifTrue: [precision := self getMaxLongData.						fSqlType := longType]].		(colDesc := columnDescriptionClass new) 			index: aColumn;			name: (szColName copyCStringFromHeap: self encoding);			fSqlType: fSqlType;			type: (xif class fSqlTypeToConversionMap at: colDesc fSqlType);			maxColumnConstraint: precision;			precision: precision;			scale: pibScale contents;			nullable: (pfNullable contents == xif SQL_NULLABLE).		descrs at: aColumn put: colDesc ]	"End unwind protection." ]		ensure:			[ szColName notNil ifTrue: [ szColName freePointer ].			pcbColName notNil ifTrue: [ pcbColName freePointer ].			pfSqlType notNil ifTrue: [ pfSqlType freePointer ].			pcbColDef notNil ifTrue: [ pcbColDef freePointer ].			pibScale notNil ifTrue: [ pibScale freePointer ].			pfNullable notNil ifTrue: [ pfNullable freePointer ] ].	self columnDescriptions: descrs</body><body package="ODBCEXDI">getBlockOfRowsExternal	"Advance to the next row.  If now more rows, answer nil."	^self getBlockOfRowsExternal: self fetchNextMode offset: 0</body><body package="ODBCEXDI">getBlockOfRowsExternal: fetchOrientation offset: fetchOffset	"Fetch the next block of rows into the memory allocated for this purpose."	| xif rc rowCountPtr newFetchMode newOffset rowNumberBeforeFetch |	xif := self class xif.	fetchOrientation == self fetchPriorMode ifTrue: [		rowNumberBeforeFetch := [self rowNumber]			on: self class connectionClass externalDatabaseErrorSignal			do: [:ex| (ex parameter at: 1) sqlState = '24000'						ifTrue: [0]		"cursor has been scrolled back past the start; rowNumber is zero"						ifFalse: [ex pass]].		newFetchMode := self fetchRelativeMode.		newOffset := 0 - self blockFactor.	] ifFalse: [		fetchOrientation == self fetchRelativeMode ifTrue: [			newFetchMode := fetchOrientation.			self currentRowIndex: (self currentRowIndex - fetchOffset).			newOffset := fetchOffset - self rowsInBlock + self currentRowIndex.		] ifFalse: [			newFetchMode := fetchOrientation.			newOffset := fetchOffset.		].	].		["Begin unwind protection"	rowCountPtr := xif SQLULEN perform: xif mallocSelector with: 1.	rc := xif SQLExtendedFetch: self hstmt				with: newFetchMode				with: newOffset				with: rowCountPtr				with: 0.	traceLevel &gt;= 3		ifTrue: 			[(self traceStream)				print: rc;				nextPutAll: ' = SQLExtendedFetch( hstmt=';				nextPutAll: (self hstmt referentAddress printStringRadix: 16);				nextPutAll: ', fFetchType = '; print: newFetchMode;				nextPutAll: ', irow = ';  print: newOffset;				nextPutAll: ', pcrow = ';				nextPutAll: (rowCountPtr referentAddress printStringRadix: 16);				nextPutAll: ', rgfRowStatus = 0 ';				nextPutAll: ' )'.			self class trace: self emitTrace].	rc == xif SQL_NO_DATA_FOUND ifTrue: [ self rowsInBlock: -1. ^nil].	(rc == xif SQL_ERROR or: [rc == xif SQL_SUCCESS_WITH_INFO]) ifTrue: [| errs |		errs := self getStatementErrors.		(rc == xif SQL_SUCCESS_WITH_INFO and: [ errs first sqlState = '01S06' ]) ifTrue: [			self currentRowIndex: (rowNumberBeforeFetch - 1).		] ifFalse: [			self class connectionClass unableToFetchDataSignal raiseWith: errs	errorString: errs first dbmsErrorString		]		].	self rowsInBlock: rowCountPtr contents.	"End unwind protection"]			ensure: [rowCountPtr notNil ifTrue: [rowCountPtr freePointer]]</body><body package="ODBCEXDI">getColumnDescriptionExternal: aColumn	"Folded into describeAnswerColumns for efficiency."	^self shouldNotImplement</body><body package="ODBCEXDI">getFieldExternal: aColumn 	| buffer |  	buffer := (self rowBuffers) at: aColumn.     "If it is an ODBCLargeObjectBuffer, then we must retrieve the data now."	buffer isLargeObject ifTrue: [^buffer bindOutputExternal].	^buffer at: ((self currentRowIndex - 1) \\ self blockFactor) + 1</body><body package="ODBCEXDI">handleAutoCommit	"The behavior of the EXDI as regards transactions is that each statement executed is a separate 	transaction unless the connection is sent begin."	| conn xif |	conn := self connection.	xif := self class xif.	conn inTransactionMode		ifFalse: 			[ "We have an autocommit if connection wasn't sent begin"			| behavior |			behavior := conn getInformationType: #SQL_CURSOR_COMMIT_BEHAVIOR.			behavior == xif SQL_CB_CLOSE ifTrue: [conn cursorsAreClosed]]</body><body package="ODBCEXDI">hasAnswerSetExternal	| xif rc pccol |	xif := self class xif.	self numColumns: 0. "default to none"	[ "Begin unwind protection."	pccol := xif SWORD perform: xif mallocSelector with: 1.	rc := xif SQLNumResultCols: self hstmt with: pccol.	( traceLevel &gt;= 3 ) ifTrue:		[ (self traceStream)			print: rc;  nextPutAll: ' = SQLNumResultCols( hstmt=';			nextPutAll: (self hstmt referentAddress printStringRadix: 16);			nextPutAll: ', *pccol =';  print: pccol contents;			nextPutAll: ' )'.		self class trace: self emitTrace ].	rc == xif SQL_SUCCESS ifFalse:		[ | errs |		errs := self getStatementErrors.		^self class connectionClass unableToFetchDataSignal raiseWith: errs errorString: errs first dbmsErrorString ].	self numColumns: pccol contents.	"End unwind protection." ]		ensure: 			[ pccol notNil ifTrue: [ pccol freePointer ] ].	self numColumns &gt; 0 ifTrue:		[ ^true ].	"Simulate auto-commit transaction behavior?"	self handleAutoCommit.	^false</body><body package="ODBCEXDI">isAnswerColumnBound: aColumn 	"If the data source does not support the retrieval of long result columns in 	any order then conditionally use unbound buffers to retreive result columns. 	So, a buffer is bound unless: 	(a) it is Long, or 	(b) our ODBC driver is 'order-limited' AND any preceeding column is Long. 	In case (b), if long result columns exist and do not occur at the end then 	conditionally bind result columns up to the first long result column. 	Thereafter all columns will be unbound whether or not they represent 	long results."	| prevLongCol isBound |	self canFetchLongResultsAnyOrder		ifTrue: [isBound := (columnDescriptions at: aColumn) isLong not]		ifFalse: 			[prevLongCol := columnDescriptions detect: [:each | ((each index) &lt;= aColumn)							and: [each isLong]]						ifNone: [nil].			isBound := prevLongCol isNil].	^isBound</body><body package="ODBCEXDI">releaseBuffers	"Release buffers and their associated resources."	| rbs |	(rbs := self rowBuffers) notNil ifTrue:		[ | hstmt |		((hstmt := self hstmt) isNil or: [hstmt referentAddress isNil]) ifFalse:			[ self freeStatementExternal: #SQL_UNBIND ].		1 to: rbs size do:			[ :i | (rbs at: i) free ] ].	super releaseBuffers</body></methods><methods><class-id>Database.ODBC2Session</class-id> <category>private-accessing</category><body package="ODBCEXDI">bindTemplate	^bindTemplate</body><body package="ODBCEXDI">currentRowIndex	^currentRowIndex</body><body package="ODBCEXDI">currentRowIndex: anInteger	currentRowIndex := anInteger.</body><body package="ODBCEXDI">fetchAbsoluteMode	^self class xif SQL_FETCH_ABSOLUTE</body><body package="ODBCEXDI">fetchNextMode	^self class xif SQL_FETCH_NEXT</body><body package="ODBCEXDI">fetchPriorMode	^self class xif SQL_FETCH_PRIOR</body><body package="ODBCEXDI">fetchRelativeMode	^self class xif SQL_FETCH_RELATIVE</body><body package="ODBCEXDI">getLongTypeFor: fSqlType	"Return the LONG version of fSqlType's (a varchar, nvarchar, or varbinary) numeric value.	If fSqlType is not one of the above, return nil. This method is intended to be called only	when a SQL_Native driver indicates varchar(max), nvarchar(max), or varbinary(max).	In this case, assign the equivalent LONG type, so we can retrieve by chunks."		^self class varcharToLongConversionMap at: fSqlType ifAbsent: []</body><body package="ODBCEXDI">getStatementErrors	"Return a collection of ODBCError(s) associated with the statement handle."	| xif errors err | 	xif := self class xif.	errors := OrderedCollection new.	[ (err := self connection getErrorsExternal: xif SQL_NULL_HENV				hdbc: xif SQL_NULL_HDBC				hstmt: self hstmt) notNil ]		whileTrue: [ errors add: err ].	"Many senders assume non-empty collection."	errors isEmpty 		ifTrue: 			[err := self connection class defaultError.			errors add: err].	^errors</body><body package="ODBCEXDI">getStatementOption: fOptionTypeSymbol	| ssoc |	(connection supportsFunction: #SQL_API_SQLGETSTMTOPTION) ifFalse:		[ self class connectionClass unsupportedDriverFunctionalitySignal raise ].	^(ssoc := self  sqlStatementOptionCache) at: fOptionTypeSymbol ifAbsent:		[ | vOption |		vOption := self getStatementOptionExternal: fOptionTypeSymbol.		ssoc at: fOptionTypeSymbol put: vOption.		vOption ].</body><body package="ODBCEXDI">hstmt	^hstmtHolder value</body><body package="ODBCEXDI">hstmt: aCPointerOrNil	hstmtHolder value: aCPointerOrNil</body><body package="ODBCEXDI">hstmtHolder	^hstmtHolder</body><body package="ODBCEXDI">hstmtHolder: aValueHolder	hstmtHolder := aValueHolder</body><body package="ODBCEXDI">isSQLNativeClient	"Return true if this is a SQL Server client using the SQL Native DLL.	SQL Native clients indicate varchar(max) types by claimng their precision is 0."	^'Microsoft SQL Server' = connection dbmsName		and: [ (connection driverName asLowercase beginsWith: 'sqlncli') or: [connection driverName asLowercase beginsWith: 'msodbcsql11'] ]</body><body package="ODBCEXDI">mustResendQuery	^self mustResendQueryHolder value</body><body package="ODBCEXDI">mustResendQuery: aBoolean	self mustResendQueryHolder value: aBoolean</body><body package="ODBCEXDI">mustResendQueryHolder	^mustResendQueryHolder</body><body package="ODBCEXDI">mustResendQueryHolder: aValueHolder	mustResendQueryHolder := aValueHolder</body><body package="ODBCEXDI">resultsCache	"Answer the contents of the result cache.  Clear the cache."	| results |	results := resultsCache.	resultsCache := nil.	^results</body><body package="ODBCEXDI">resultsCache: results	"Cache results."	resultsCache := results</body><body package="ODBCEXDI">rowNumber	^self getStatementOptionExternal: #SQL_ROW_NUMBER.</body><body package="ODBCEXDI">rowsInBlock	^rowsInBlock</body><body package="ODBCEXDI">rowsInBlock: anObject	rowsInBlock := anObject</body><body package="ODBCEXDI">setStatementOption: fOptionTypeSymbol value: vOption	(connection supportsFunction: #SQL_API_SQLSETSTMTOPTION) ifFalse:		[ self class connectionClass unsupportedDriverFunctionalitySignal raise ].	self setStatementOptionExternal: fOptionTypeSymbol value: vOption.	self sqlStatementOptionCache at: fOptionTypeSymbol put: vOption.	^vOption</body><body package="ODBCEXDI">sqlStatementOptionCache	^sqlStatementOptionCache</body><body package="ODBCEXDI">sqlStatementOptionCache: anIdentityDictionary	sqlStatementOptionCache := anIdentityDictionary</body></methods><methods><class-id>Database.ODBC2Session</class-id> <category>data processing</category><body package="ODBCEXDI">bindVariable: aValue at: position 	"Bind a value to a parameter position in the query. 	Re-use an existing buffer only if it is big enough.	An existing buffer can be too small if it holds a #String,	but the new value is a #LargeString, for example."	| buffer val |	val := (aValue isKindOf: Stream) ifTrue: [aValue contents] ifFalse: [aValue].	buffer := self bindValuePointers at: position ifAbsent: [nil].	buffer isNil ifFalse: [(buffer canHold: val)			ifFalse: 				[buffer free.				buffer := nil]].	buffer isNil ifTrue: [			buffer := self class bufferClass						on: val						position: position						session: self.			self unicode				ifTrue: [buffer unicode: self unicode]				ifFalse: [self bindTemplate isNil ifFalse:					[(self bindTemplate at: (self bindMarkerAtPosition: position))						== #UnicodeString ifTrue:							[buffer isUnicodeColumn: true.							buffer unicode: true]]].					buffer bindForOutputParameter.			self bindValuePointers at: position put: buffer]		ifFalse: 			[buffer reUse: val]</body><body package="ODBCEXDI">bindVariableAt: position	"Answer the value of a Stored Procedure variable."	| buffer |	buffer := self bindValuePointers at: position ifAbsent: [ self error: (#errUnboundVariable &lt;&lt; #odbcDB &gt;&gt; 'unbound variable') ].	^buffer value</body><body package="ODBCEXDI">cursorName	"Answer the cursor name associated with receiver.  If not supported, a nil is returned."	| xif szCursor pcbCursor rc cursorName cbCursorMax |	xif := self class xif.	self hstmt isNil ifTrue: [ ^nil ].	[ "Begin unwind protection."	cbCursorMax := self connection getInformationType: #SQL_MAX_CURSOR_NAME_LEN.	szCursor := (xif charDataTypeUnicode: self isUnicodeEncoding) perform: xif mallocSelector with: cbCursorMax.	pcbCursor := xif SWORD perform: xif mallocSelector with: 1.	self isUnicodeEncoding ifTrue: [		rc := xif SQLGetCursorNameW: self hstmt			with: szCursor			with: cbCursorMax			with: pcbCursor.	] ifFalse: [		rc := xif SQLGetCursorName: self hstmt			with: szCursor			with: cbCursorMax			with: pcbCursor.	].	( traceLevel &gt;= 2 ) ifTrue:		[ (self traceStream)			print: rc;  nextPutAll: ' = SQLGetCursorName( hstmt = ';			nextPutAll: (self hstmt referentAddress printStringRadix: 16);			nextPutAll: ', szCursor = '; print: szCursor copyCStringFromHeap;			nextPutAll: ', cbCursorMax = '; print: cbCursorMax;			nextPutAll: ', *pcbCursor = '; print: pcbCursor contents;			nextPutAll: ' )'.		self class trace: self emitTrace ].	 (rc == xif SQL_SUCCESS) ifFalse:		[ | errs |		errs := self getStatementErrors.		(rc == xif SQL_ERROR and: [errs first sqlState = 'S1015']) ifTrue:			[ ^nil ].		^self class connectionClass externalDatabaseErrorSignal raiseWith: errs errorString: errs first dbmsErrorString ].	cursorName := self isUnicodeEncoding ifTrue: [ 		szCursor copyCStringFromHeap: self encoding	] ifFalse: [ 		szCursor copyCStringFromHeap 	].	 "End unwind protection" ]		ensure:			[ szCursor notNil ifTrue: [ szCursor freePointer ].			  pcbCursor notNil ifTrue: [ pcbCursor freePointer ] ].	^cursorName</body><body package="ODBCEXDI">cursorName: aString	"Set the cursor name associated with receiver.  If not supported, quietly do nothing."	| xif szCursor rc bytes |	xif := self class xif.	self hstmt isNil ifTrue: [ ^nil ].	[ "Begin unwind protection."	szCursor := (bytes := aString asByteArrayEncoding: self encoding)			perform: xif copyToHeapSelector.	self isUnicodeEncoding ifTrue: [		rc := xif SQLSetCursorNameW: self hstmt			with: szCursor			with: aString size.	] ifFalse: [		rc := xif SQLSetCursorName: self hstmt			with: szCursor			with: aString size.	].	( traceLevel &gt;= 2 ) ifTrue:		[ (self traceStream)			print: rc; nextPutAll: ' = SQLSetCursorName( hstmt = ';			nextPutAll: (self hstmt referentAddress printStringRadix: 16);			nextPutAll: ', *szCursor = '; print: aString;			nextPutAll: ', cbCursor = '; print: bytes size;			nextPutAll: ' )'.		self class trace: self emitTrace ].	 (rc == xif  SQL_SUCCESS) ifFalse:		[ | errs |		  errs := self getStatementErrors.		  ^self class connectionClass externalDatabaseErrorSignal raiseWith: errs errorString: errs first dbmsErrorString ]        "End unwind protection." ]		ensure:			[ szCursor notNil ifTrue: [ szCursor freePointer ] ]</body><body package="ODBCEXDI">execute	"Execute the SQL statement."	"Should we clean up after any previous work?"	self isExecuting ifTrue:		[ self cancel ].	( self state == #prepared ) ifFalse:		[ self class connectionClass invalidSessionStateSignal raise ].	[ "Begin unwind protection."		queryIsPROC ifFalse: [			self bindExternal.		].		self state: #executing.		self executeExternal.	"End unwind protection." ]		ifCurtailed:			[ self state: #prepared ]</body><body package="ODBCEXDI">executeDirect: aString	"Execute the prepared SQL statement without a prior external prepare step."	self startPrepare.	"Save the query, and prepare it for parameter binding."	self setupQuery: aString.	( self state == #connected ) ifFalse:		[ self class connectionClass invalidSessionStateSignal raise ].	[ "Begin unwind protection."	self bindExternal.	self state: #executing.	self executeDirectExternal.	"End unwind protection." ]		ifCurtailed:			[ self state: #connected ]</body><body package="ODBCEXDI">getDataChunkSize	"Answer the data transfer size for LONGVARCHAR or LONGVARBINARY columns."	^self lobBufferSize</body><body package="ODBCEXDI">getMaxLongData	"Answer the maximum amount of data to be copied from LONGVARCHAR or LONGVARBINARY columns."	^maxLongData</body><body package="ODBCEXDI">prepare: aString	"Prepare a query string for processing. Use preparePROC: if calling a stored procedure."	queryIsPROC := false.	super prepare: aString</body><body package="ODBCEXDI">preparePROC: aString	"Prepare a query which calls a stored procedure. A stored procedure can return multiple row sets and have input, output and return parameters."	queryIsPROC := true.	super prepare: aString</body><body package="ODBCEXDI">rowCount	"Answer an Integer representing the number of rows affected by the previous query.	Valid only after the query has been answered."	| xif pcrow rc rowCount |	xif := self class xif.	self hstmt isNil ifTrue: [ ^nil ].	[ "Begin unwind protection."	pcrow := xif SQLLEN perform: xif mallocSelector with: 1.	pcrow contents: 0.	rc := xif SQLRowCount: self hstmt with: pcrow.	rowCount := pcrow contents.	( traceLevel &gt;= 2 ) ifTrue:		[ (self traceStream)			print: rc; nextPutAll: ' = SQLRowCount( hstmt = ';			nextPutAll: (self hstmt referentAddress printStringRadix: 16);			nextPutAll: ', pcrow = ';			nextPutAll: (pcrow referentAddress printStringRadix: 16);			nextPutAll: ') = '; print: rowCount;			nextPutAll: ' )'.		self class trace: self emitTrace ].	 (rc == xif SQL_SUCCESS) ifFalse:		[ | errs |		errs := self getStatementErrors.		^self class connectionClass externalDatabaseErrorSignal raiseWith: errs errorString: errs first dbmsErrorString ]	"End unwind protection." ]		ensure:			[ pcrow notNil ifTrue: [ pcrow freePointer ] ].	^rowCount</body><body package="ODBCEXDI">setDataChunkSize: anInteger	"Specify the data transfer size for LONGVARCHAR or LONGVARBINARY columns."	self class xif setDataChunkSize: anInteger.</body><body package="ODBCEXDI">setMaxLongData: anInteger	"Specify the maximum amount of data to be copied from LONGVARCHAR or LONGVARBINARY columns."	(anInteger isInteger and: [anInteger&gt;=0]) ifTrue: 		[ maxLongData := anInteger ]</body></methods><methods><class-id>Database.ODBC2Session</class-id> <category>private-execution</category><body package="ODBCEXDI">acquireExternal	"Acquire external resources."	| xif phstmt rc |	xif := self class xif.	[ "Begin unwind protection."	phstmt := xif HSTMT perform: xif mallocSelector with: 1.	rc := xif SQLAllocStmt: self connection hdbc with: phstmt.	( traceLevel &gt;= 3 ) ifTrue:		[ (self traceStream)			print: rc;  nextPutAll: ' = SQLAllocStmt( hdbc = ';			nextPutAll: (self connection hdbc referentAddress printStringRadix: 16);			nextPutAll: ', hstmt = ';			nextPutAll: (phstmt contents referentAddress printStringRadix: 16);			nextPutAll: ' )'.		self class trace: self emitTrace ].	(rc == xif SQL_SUCCESS) ifFalse:		[ | errs |		errs := self getStatementErrors.		self class connectionClass unableToAllocateHandleSignal raiseWith: errs errorString: errs first dbmsErrorString ].	self hstmt: phstmt contents.	self scrollable ifTrue: [		self setScrollOptions: #SQL_CONCUR_READ_ONLY keyset: xif SQL_SCROLL_KEYSET_DRIVEN rowset: self blockFactor.	].	"Determine if driver support feature.?"	"End unwind protection." ]		ensure:			[ phstmt notNil ifTrue: [ phstmt freePointer ] ]</body><body package="ODBCEXDI">cancelExternal	"Handle cleanup when current query is cancelled."	^self</body><body package="ODBCEXDI">cursorIsClosed	"Receiver's cursor was closed and can no longer be used to access rows from the previous query.  Prepared statements can be executed without preparing them again."	"If receiver isn't in an executing state, nothing to do."	self isExecuting ifFalse:		[ ^self ].	"If there is an extant answer stream, it's dead so mark it as such."	answerStream notNil ifTrue:		[ answerStream session: nil.		  answerStream := nil ].	"We're now back in the prepared state and can execute again without preparing."	self state: #prepared.	( traceLevel &gt;= 3 ) ifTrue:		[ (self traceStream)			nextPutAll: 'hstmt = ';			nextPutAll: (self hstmt referentAddress printStringRadix: 16); cr; tab;			nextPutAll: 'self mustResendQuery: false. self state: #prepared'.		self class trace: self emitTrace ]</body><body package="ODBCEXDI">cursorIsDeleted	"Receiver's cursor was deleted and can no longer be used to access rows from the previous query.  Any prepared statements must be prepared again.  Parameters and bound buffers are still valid."	"If receiver isn't in an executing state, nothing to do."	self isExecuting ifFalse:		[ ^self ].	"If there is an extant answer stream, it's dead so mark it as such."	answerStream notNil ifTrue:		[ answerStream session: nil.		  answerStream := nil ].	"The SQL text must be sent to the server again."	self mustResendQuery: true.	"We're now back in the prepared state and can execute again without preparing."	self state: #prepared.	( traceLevel &gt;= 3 ) ifTrue:		[ (self traceStream)			nextPutAll: 'hstmt = ';			nextPutAll: (self hstmt referentAddress printStringRadix: 16); cr; tab;			nextPutAll: 'self mustResendQuery: true. self state: #prepared'.		self class trace: self emitTrace ]</body><body package="ODBCEXDI">dismissExternal	self freeStatementExternal: #SQL_DROP.	self hstmt: nil</body><body package="ODBCEXDI">executeDirectExternal	"Execute the SQL text directly without preparing it first."	| xif rc sql sqlBa |	xif := self class xif.	"Assemble the query, substituting the correct parameter markers."	queryFragments size == 1		ifTrue:			[ sql := queryFragments at: 1 ]		ifFalse:			[ | sqlStream |			sqlStream := (String new: query size) writeStream.			sqlStream nextPutAll: (queryFragments at: 1).			2 to: queryFragments size by: 2 do:				[ :index |				sqlStream					nextPut: $?;					nextPutAll: (queryFragments at: index + 1) ].			sql := sqlStream contents ].	sqlBa := sql asByteArrayEncoding: self encoding.	self isUnicodeEncoding ifTrue: [		rc := xif SQLExecDirectW: self hstmt with: sqlBa with: sql size.	] ifFalse: [		rc := xif SQLExecDirect: self hstmt with: sqlBa with: sqlBa size.	].	( traceLevel &gt;= 1 ) ifTrue:		[ (self traceStream)			print: rc;  nextPutAll: ' = SQLExecDirect:( hstmt = ';			nextPutAll: (self hstmt referentAddress printStringRadix: 16);			nextPutAll: ', szSqlStr = '''; print: sql asString;			nextPutAll: ''', cbSqlStr = '; print: sql size;			nextPutAll: ' )'.		self class trace: self emitTrace ].	(rc == xif SQL_ERROR)		ifTrue: [ self resultsCache: self getStatementErrors ].	"Are there any data-at-execution parameters to bind?"	(rc == xif SQL_NEED_DATA)		ifTrue: [ self bindExecutionParameters ]</body><body package="ODBCEXDI">executeExternal	"Execute the prepared SQL text."	| xif rc |	xif := self class xif.	"Does the query text need to be sent to the server again?"	self mustResendQuery ifTrue:		[ self prepareExternal.		  self mustResendQuery: false ].	rc := xif SQLExecute: self hstmt.	( traceLevel &gt;= 1 ) ifTrue:		[ (self traceStream)			print: rc;  nextPutAll: ' = SQLExecute( hstmt = ';			nextPutAll: (self hstmt referentAddress printStringRadix: 16);			nextPutAll: ' )'.		self class trace: self emitTrace ].	(rc == xif SQL_ERROR)		ifTrue: [ self resultsCache: self getStatementErrors ].	"Are there any data-at-execution parameters to bind?"	(rc == xif SQL_NEED_DATA)		ifTrue: [ self bindExecutionParameters ]</body><body package="ODBCEXDI">freeStatementExternal: releaseOption	"Release resources associated with a session."	| xif rc |	(self hstmt isNil or: [self hstmt isValid not]) ifTrue: [^self].	xif := self class xif.	rc := xif SQLFreeStmt: self hstmt with: (xif perform: releaseOption).	traceLevel &gt;= 3		ifTrue: 			[(self traceStream)				print: rc;				nextPutAll: ' = SQLFreeStmt( hstmt = ';				nextPutAll: (self hstmt referentAddress printStringRadix: 16);				nextPutAll: ', ';				print: releaseOption;				nextPutAll: ')'.			self class trace: self emitTrace].	rc == xif SQL_SUCCESS		ifFalse: 			[| errs |			errs := self getStatementErrors.			self class connectionClass unableToFreeResourceSignal raiseRequestWith: errs				errorString: errs first dbmsErrorString]</body><body package="ODBCEXDI">getParameterIndexExternal		"Retrieve index of data-at-execution parameter."	| xif rc prgbValue |	xif := self class xif.    	["Begin unwind protection"		prgbValue := xif PSDWORD perform: xif mallocSelector with: 1.		rc := xif SQLParamData: self hstmt with: prgbValue.		(traceLevel &gt;= 3) ifTrue:			[ (self traceStream)			print: rc;  nextPutAll: ' = SQLParamData( hstmt = ';			nextPutAll: (self hstmt referentAddress printStringRadix: 16);			nextPutAll: ',  prgbValue= ';			nextPutAll: (prgbValue  referentAddress printStringRadix: 16);			nextPutAll: ' )'.			self class trace: self emitTrace ].	 	(rc == xif SQL_ERROR) ifTrue:			[| errs |		 	errs := self getStatementErrors.		 	^self class connectionClass unableToBindSignal raiseWith: errs errorString: errs first dbmsErrorString ].			((rc  ==  xif SQL_SUCCESS) or: [ rc == xif SQL_SUCCESS_WITH_INFO])			ifTrue: [ ^nil ].	"End unwind protection"] 		ensure: [ prgbValue notNil 									ifTrue:[ prgbValue freePointer]].</body><body package="ODBCEXDI">getStatementOptionExternal: fOptionSymbol	"Answer the information associated with fInfoTypeSymbol.  This information is defined only after connecting."	| xif  rc ub  pvParam vParam optionConversion bufLen |	xif := self class xif.	[ "Begin unwind protection."	pvParam :=  xif PTR perform: xif mallocSelector with: 1.	self isUnicodeEncoding ifTrue: [		rc := xif SQLGetStmtOptionW: self  hstmt 						    		with:(xif perform: fOptionSymbol)						    		with: pvParam.	] ifFalse: [		rc := xif SQLGetStmtOption: self  hstmt 						    		with:(xif perform: fOptionSymbol)						    		with: pvParam.	].	(rc == xif SQL_SUCCESS	or: [ rc == xif SQL_SUCCESS_WITH_INFO]) ifFalse:	     [ | errs |		errs := self getStatementErrors.		^self class unableToGetStatementOptionsSignal raiseWith: errs errorString: errs first dbmsErrorString ].	optionConversion := SQLStatementOptionConversionMap at: fOptionSymbol.	(optionConversion == #stringAt:) ifTrue: [ bufLen := 100 ] ifFalse: [ bufLen := ObjectMemory is64Bit ifTrue: [ 8 ] ifFalse: [ 4 ] ].	ub := UninterpretedBytes new: bufLen.	pvParam copyAt: 0 to: ub size: bufLen startingAt: 1.	vParam := ub perform: optionConversion with: 1	"End unwind protection." ]		ensure:			[ pvParam notNil ifTrue: [ pvParam freePointer ]].	^vParam</body><body package="ODBCEXDI">installExternal	super installExternal.	self hstmt: nil.	self mustResendQuery: false.	self sqlStatementOptionCache: IdentityDictionary new.	self setMaxLongData: DefaultMaxLongData.</body><body package="ODBCEXDI">moreResultsExternal	"Return true if there are more results."	| xif rc hasMoreResults |	xif := self class xif.	rc := xif SQLMoreResults: self hstmt.	traceLevel &gt;= 1 		ifTrue: 			[(self traceStream)				print: rc;				nextPutAll: ' = SQLMoreResults( hstmt = ';				nextPutAll: (self hstmt referentAddress printStringRadix: 16);				nextPutAll: ' )'.			self class trace: self emitTrace].	hasMoreResults := rc == xif SQL_NO_DATA_FOUND 				ifTrue: [false]				ifFalse: 					[rc == xif SQL_ERROR 						ifTrue: 							[self resultsCache: self getStatementErrors.							false]						ifFalse: [true]].	hasMoreResults 		ifFalse: 			["These two lines executed after all answer streams retrieved."			self freeStatementExternal: #SQL_CLOSE.			self handleAutoCommit].	^hasMoreResults</body><body package="ODBCEXDI">readyExternal	^true</body><body package="ODBCEXDI">resultsExternal	| errs errsSize |	errs := self resultsCache.	errsSize := errs size.	errsSize &gt; 0 ifTrue: [ | realErrors |		"Filter out warnings."		realErrors := errs select: [ :each| | sqlState | ((sqlState := each sqlState) = '01000' or: [ sqlState  = 'S1000' ]) not ].		"Report the error."		realErrors size &gt; 0 ifTrue: [  			^self class connectionClass unableToExecuteSQLSignal raiseWith: realErrors errorString: (realErrors at: 1) dbmsErrorString		].	].	^true</body><body package="ODBCEXDI">setScrollOptions: fConcurrencySymbol keyset: keysetValue rowset: rowsetValue	| xif  rc |	xif := self class xif.	rc := xif SQLSetScrollOptions: self hstmt 						    		with: (xif perform: fConcurrencySymbol)						    		with: keysetValue						    		with: rowsetValue.	(rc == xif SQL_SUCCESS	or: [ rc == xif SQL_SUCCESS_WITH_INFO]) ifFalse:	     [ | errs |		errs := self getStatementErrors.		^self class unableToSetStatementOptionsSignal raiseWith: errs errorString: errs first dbmsErrorString ].</body><body package="ODBCEXDI">setStatementOptionExternal: fOptionSymbol value: vOption	"Set the information associated with fInfoTypeSymbol.  This information is defined only after connecting."	| xif  rc |	xif := self class xif.	rc := xif SQLSetStmtOption: self  hstmt 						    		with: (xif perform: fOptionSymbol)						    		with: vOption.	(rc == xif SQL_SUCCESS	or: [ rc == xif SQL_SUCCESS_WITH_INFO]) ifFalse:	     [ | errs |		errs := self getStatementErrors.		^self class unableToSetStatementOptionsSignal raiseWith: errs errorString: errs first dbmsErrorString ].	^vOption</body></methods><methods><class-id>Database.ODBC2Session</class-id> <category>catalog functions</category><body package="ODBCEXDI">getSQLColumns: tableQualifier tableOwner: tableOwner tableName: tableName columnName: columnName	"If supported on the current platform, call the ODBC function SQLColumns to obtain a list of names of tables stored in the current data source.  Sending the message callSQLColumns:tableOwner:tableName:columnName: is equivalent to preparing and executing a query using the receiver.  After the call completes, the table information is obtained as an answer stream in the normal way (i.e. send the message answer and then use the answer stream to fetch the rows).  Each row is an Array with one element for each column.  The columns of the answer set are defined in the ODBC documentation as: TABLE_QUALIFIER, TABLE_OWNER, TABLE_NAME, COLUMN_NAME, DATA_TYPE, TYPE_NAME, PRECISION, LENGTH, SCALE, RADIX, NULLABLE, and REMARKS.  Refer to the Informix CLI or ODBC documentation for more details.	The arguments tableQualifier, tableOwner, tableName, and columnName are directly passed to the function and take their definitions from the function definition."	| xif rc |	xif := self class xif.	"Check first that the driver supports functionality."	(connection supportsFunction: #SQL_API_SQLCOLUMNS) ifFalse:		[ self class connectionClass unsupportedDriverFunctionalitySignal raise ].	self startPrepare.	self state: #executing.	self isUnicodeEncoding ifTrue: [ | localEncoding copySelector szTableQualfier szTableOwner szTableName szColumnName |		localEncoding := self encoding.		copySelector := xif copyToHeapSelector.		szTableQualfier := szTableOwner := szTableName := szColumnName := nil.		[ "Begin unwind protection."			tableQualifier isNil ifFalse: [ szTableQualfier := (tableQualifier asByteArrayEncoding: localEncoding) perform: copySelector ].			tableOwner isNil ifFalse: [ szTableOwner := (tableOwner asByteArrayEncoding: localEncoding) perform: copySelector ].			tableName isNil ifFalse: [ szTableName := (tableName asByteArrayEncoding: localEncoding) perform: copySelector ].			columnName isNil ifFalse: [ szColumnName := (columnName asByteArrayEncoding: localEncoding) perform: copySelector ].			rc := xif SQLColumnsW: self hstmt				with: szTableQualfier with: tableQualifier size				with: szTableOwner with: tableOwner size				with: szTableName with: tableName size				with: szColumnName with: columnName size.		"End unwind protection." ]		ensure:			[ szTableQualfier notNil ifTrue:	[ szTableQualfier freePointer ].			szTableOwner notNil ifTrue:	[ szTableOwner freePointer ].			szTableName notNil ifTrue:	[ szTableName freePointer ].			szColumnName notNil ifTrue:	[ szColumnName freePointer ] ]	] ifFalse: [		rc := xif SQLColumns: self hstmt				with: tableQualifier with: tableQualifier size				with: tableOwner with: tableOwner size				with: tableName with: tableName size				with: columnName with: columnName size.	].	(rc == xif SQL_SUCCESS	or: [rc == xif SQL_SUCCESS_WITH_INFO]) ifFalse:		[ | errs |		errs := self getStatementErrors.		self resultsCache: errs ].</body><body package="ODBCEXDI">getSQLForeignKeys: pkTableQualifier with: pkTableOwner with: pkTableName with: fkTableQualifier with: fkTableOwner with: fkTableName	| xif rc |	xif := self class xif.	"Check first that the driver supports functionality."	(connection supportsFunction: #SQL_API_SQLFOREIGNKEYS) ifFalse:		[ self class connectionClass unsupportedDriverFunctionalitySignal raise ].	self startPrepare.	self state: #executing.	self isUnicodeEncoding ifTrue: [ | localEncoding copySelector szTableQualfier szTableOwner szTableName szFkTableQualfier szFkTableOwner szFkTableName |		szTableQualfier := szTableOwner := szTableName := szFkTableQualfier := szFkTableOwner := szFkTableName:= nil.		copySelector := xif copyToHeapSelector.		localEncoding := self encoding.		[ "Begin unwind protection." 			pkTableQualifier isNil ifFalse: [ szTableQualfier := (pkTableQualifier asByteArrayEncoding: localEncoding) perform: copySelector ].			pkTableOwner isNil ifFalse: [ szTableOwner := (pkTableOwner asByteArrayEncoding: localEncoding) perform: copySelector ].			pkTableName isNil ifFalse: [ szTableName := (pkTableName asByteArrayEncoding: localEncoding) perform: copySelector ].			fkTableQualifier isNil ifFalse: [ szFkTableQualfier := (fkTableQualifier asByteArrayEncoding: localEncoding) perform: copySelector ].			fkTableOwner isNil ifFalse: [ szFkTableOwner := (fkTableOwner asByteArrayEncoding: localEncoding) perform: copySelector ].			fkTableName isNil ifFalse: [ szFkTableName := (fkTableName asByteArrayEncoding: localEncoding) perform: copySelector ].			rc := xif SQLForeignKeysW: self hstmt 			 		with: szTableQualfier			 		with: pkTableQualifier size			 		with: szTableOwner			 		with: pkTableOwner size			 		with: szTableName			 		with: pkTableName size			 		with: szFkTableQualfier			 		with: fkTableQualifier size			 		with: szFkTableOwner			 		with: fkTableOwner size			 		with: szFkTableName			 		with: fkTableName size.		"End unwind protection." ]		ensure: [ 			szTableQualfier notNil ifTrue: [ szTableQualfier freePointer ].			szTableOwner notNil ifTrue: [ szTableOwner freePointer ].			szTableName notNil ifTrue: [ szTableName freePointer ].			szFkTableQualfier notNil ifTrue: [ szFkTableQualfier freePointer ].			szFkTableOwner notNil ifTrue: [ szFkTableOwner freePointer ].			szFkTableName notNil ifTrue: [ szFkTableName freePointer ]		].	] ifFalse: [		rc := xif SQLForeignKeys: self hstmt 			 		with: pkTableQualifier			 		with: pkTableQualifier size			 		with: pkTableOwner			 		with: pkTableOwner size			 		with: pkTableName			 		with: pkTableName size			 		with: fkTableQualifier			 		with: fkTableQualifier size			 		with: fkTableOwner			 		with: fkTableOwner size			 		with: fkTableName			 		with: fkTableName size.	].	(rc == xif SQL_SUCCESS	or: [rc == xif SQL_SUCCESS_WITH_INFO]) ifFalse:		[ | errs |		errs := self getStatementErrors.		self resultsCache: errs ].</body><body package="ODBCEXDI">getSQLPrimaryKeys: tableQualifier tableOwner: tableOwner tableName: tableName 	| xif rc |	xif := self class xif.	"Check first that the driver supports functionality."	(connection supportsFunction: #SQL_API_SQLPRIMARYKEYS) ifFalse:		[ self class connectionClass unsupportedDriverFunctionalitySignal raise ].	self startPrepare.	self state: #executing.	self isUnicodeEncoding ifTrue: [ | localEncoding copySelector szTableQualfier szTableOwner szTableName |		szTableQualfier := szTableOwner := szTableName := nil.		copySelector := xif copyToHeapSelector.		localEncoding := self encoding.		szTableQualfier := szTableOwner := szTableName := nil.		[ "Begin unwind protection." 			tableQualifier isNil ifFalse: [ szTableQualfier := (tableQualifier asByteArrayEncoding: localEncoding) perform: copySelector ].			tableOwner isNil ifFalse: [ szTableOwner := (tableOwner asByteArrayEncoding: localEncoding) perform: copySelector ].			tableName isNil ifFalse: [ szTableName := (tableName asByteArrayEncoding: localEncoding) perform: copySelector ].			rc := xif SQLPrimaryKeysW: self hstmt			 		with: szTableQualfier			 		with: tableQualifier size			 		with: szTableOwner			 		with: tableOwner size			 		with: szTableName			 		with: tableName size.		"End unwind protection." ]			ensure:			[ szTableQualfier notNil ifTrue: [ szTableQualfier freePointer ].			szTableOwner notNil ifTrue: [ szTableOwner freePointer ].			szTableName notNil ifTrue: [ szTableName freePointer ]].		] ifFalse: [			rc := xif SQLPrimaryKeys: self hstmt			 		with: tableQualifier			 		with: tableQualifier size			 		with: tableOwner			 		with: tableOwner size			 		with: tableName			 		with: tableName size.		].	(rc == xif SQL_SUCCESS	or: [rc == xif SQL_SUCCESS_WITH_INFO]) ifFalse:		[ | errs |		errs := self getStatementErrors.		self resultsCache: errs ].</body><body package="ODBCEXDI">getSQLSpecialColumns: colTypeSymbol tableQualifier: tableQualifier tableOwner: tableOwner tableName: tableName scope: scopeSymbol nullable: nullableSymbol	"If supported on the current platform, call the ODBC function SQLSpecialColumns to obtain a list of statistics about a single table and the indexes associated with the table.  Sending the message callSQLSpecialColumns:tableQualifier:tableOwner:tableName:scope:nullable: is equivalent to preparing and executing a query using the receiver.  After the call completes, the table information is obtained as an answer stream in the normal way (i.e. send the message answer and then use the answer stream to fetch the rows).  Each row is an Array with one element for each column.  The columns of the answer set are defined in the ODBC documentation as: SCOPE, COLUMN_NAME, DATA_TYPE, PRECISION, LENGTH, SCALE, and PSEUDO_COLUMN.  Refer to the Informix CLI or ODBC documentation for more details.	The arguments tableQualifier, tableOwner, and tableName are directly passed to the function and take their definitions from the function definition.  The argument colTypeSymbol must be either #SQL_BEST_ROWID or #SQL_ROWVER.  The argument scopeSymbol must be one of #SQL_SCOPE_CURROW, #SQL_SCOPE_TRANSACTION, #SQL_SCOPE_SESSION. The argument nullableSymbol must be either #SQL_NO_NULLS or #SQL_NULLABLE."	| xif fColType fScope fNullable rc |	xif := self class xif.	"Check first that the driver supports functionality."	(connection supportsFunction: #SQL_API_SQLSPECIALCOLUMNS) ifFalse:		[ self class connectionClass unsupportedDriverFunctionalitySignal raise ].	self startPrepare.	self state: #executing.	"Set up the fColType parameter.  colTypeSymbol must be one of #SQL_BEST_ROWID or #SQL_ROWVER."	fColType := xif perform: colTypeSymbol.	"Set up the fScope parameter.  scopeSymbol must be one of #SQL_SCOPE_CURROW, #SQL_SCOPE_TRANSACTION, #SQL_SCOPE_SESSION"	fScope := xif perform: scopeSymbol.	"Set up the fNullable parameter.  nullableSymbol must be one of #SQL_NO_NULLS or #SQL_NULLABLE."	fNullable := xif perform: nullableSymbol.	self isUnicodeEncoding ifTrue: [ | localEncoding copySelector szTableQualfier szTableOwner szTableName |		copySelector := xif copyToHeapSelector.		localEncoding := self encoding.		szTableQualfier := szTableOwner := szTableName := nil.		[ "Begin unwind protection."			tableQualifier isNil ifFalse: [ szTableQualfier := (tableQualifier asByteArrayEncoding: localEncoding) perform: copySelector ].			tableOwner isNil ifFalse: [ szTableOwner := (tableOwner asByteArrayEncoding: localEncoding) perform: copySelector ].			tableName isNil ifFalse: [ szTableName := (tableName asByteArrayEncoding: localEncoding) perform: copySelector ].			rc := xif SQLSpecialColumnsW: self hstmt				with: fColType				with: szTableQualfier with: tableQualifier size				with: szTableOwner with: tableOwner size				with: szTableName with: tableName size				with: fScope				with: fNullable.		"End unwind protection." ]		ensure:			[ szTableQualfier notNil ifTrue: [ szTableQualfier freePointer ].			szTableOwner notNil ifTrue: [ szTableOwner freePointer ].			szTableName notNil ifTrue: [ szTableName freePointer ] ]	] ifFalse: [		rc := xif SQLSpecialColumns: self hstmt				with: fColType				with: tableQualifier with: tableQualifier size				with: tableOwner with: tableOwner size				with: tableName with: tableName size				with: fScope				with: fNullable.	].	(rc == xif SQL_SUCCESS	or: [rc == xif SQL_SUCCESS_WITH_INFO]) ifFalse:		[ | errs |		errs := self getStatementErrors.		self resultsCache: errs ].</body><body package="ODBCEXDI">getSQLStatistics: tableQualifier tableOwner: tableOwner tableName: tableName unique: uniqueSymbol accuracy: accuracySymbol	"If supported on the current platform, call the ODBC function SQLStatistics to obtain a list of statistics about a single table and the indexes associated with the table.  Sending the message callSQLStatistics:tableOwner:tableName:unique:accuracy: is equivalent to preparing and executing a query using the receiver.  After the call completes, the table information is obtained as an answer stream in the normal way (i.e. send the message answer and then use the answer stream to fetch the rows).  Each row is an Array with one element for each column.  The columns of the answer set are defined in the ODBC documentation as: TABLE_QUALIFIER, TABLE_OWNER, TABLE_NAME, NON_UNIQUE, INDEX_QUALIFIER, INDEX_NAME, and TYPE.  Refer to the Informix CLI or ODBC documentation for more details.	The arguments tableQualifier, tableOwner, and tableName are directly passed to the function and take their definitions from the function definition.  The argument uniqueSymbol must be either #SQL_INDEX_UNIQUE or #SQL_INDEX_ALL.  The argument accuracySymbol must be either #SQL_ENSURE or #SQL_QUICK."	| xif fUnique fAccuracy rc |	xif := self class xif.	"Check first that the driver supports functionality."	(connection supportsFunction: #SQL_API_SQLSTATISTICS) ifFalse:		[ self class connectionClass unsupportedDriverFunctionalitySignal raise ].	self startPrepare.	self state: #executing.	"Set up the fUnique parameter.  uniqueSymbol must be one of #SQL_INDEX_UNIQUE or #SQL_INDEX_ALL."	fUnique := xif perform: uniqueSymbol.	"Set up the fAccuracy parameter.  accuracySymbol must be one of #SQL_ENSURE or #SQL_QUICK."	fAccuracy := xif perform: accuracySymbol.	self isUnicodeEncoding ifTrue: [ | localEncoding copySelector szTableQualfier szTableOwner szTableName |		copySelector := xif copyToHeapSelector.		localEncoding := self encoding.		szTableQualfier := szTableOwner := szTableName := nil.		[ "Begin unwind protection."			tableQualifier isNil ifFalse: [ szTableQualfier := (tableQualifier asByteArrayEncoding: localEncoding) perform: copySelector ].			tableOwner isNil ifFalse: [ szTableOwner := (tableOwner asByteArrayEncoding: localEncoding) perform: copySelector ].			tableName isNil ifFalse: [ szTableName := (tableName asByteArrayEncoding: localEncoding) perform: copySelector ].		rc := xif SQLStatisticsW: self hstmt				with: szTableQualfier with: tableQualifier size				with: szTableOwner with: tableOwner size				with: szTableName with: tableName size				with: fUnique				with: fAccuracy.		"End unwind protection." ]		ensure:			[ szTableQualfier notNil ifTrue: [ szTableQualfier freePointer ].			szTableOwner notNil ifTrue: [ szTableOwner freePointer ].			szTableName notNil ifTrue: [ szTableName freePointer ] ]	] ifFalse: [		rc := xif SQLStatistics: self hstmt				with: tableQualifier with: tableQualifier size				with: tableOwner with: tableOwner size				with: tableName with: tableName size				with: fUnique				with: fAccuracy.	].	(rc == xif SQL_SUCCESS	or: [rc == xif SQL_SUCCESS_WITH_INFO]) ifFalse:		[ | errs |		errs := self getStatementErrors.		self resultsCache: errs ].</body><body package="ODBCEXDI">getSQLTables: tableQualifier tableOwner: tableOwner tableName: tableName tableType: tableType	"If supported on the current platform, call the ODBC function SQLTables to obtain a list of names of tables stored in the current data source.  Sending the message callSQLTables:tableOwner:tableName:tableType: is equivalent to preparing and executing a query using the receiver.  After the call completes, the table information is obtained as an answer stream in the normal way (i.e. send the message answer and then use the answer stream to fetch the rows).  Each row is an Array with one element for each column.  The columns of the answer set are defined in the ODBC documentation as: TABLE_QUALIFIER, TABLE_OWNER, TABLE_NAME, TABLE_TYPE, and REMARKS.  Refer to the Informix CLI or ODBC documentation for more details.	The arguments tableQualifier, tableOwner, tableName, and tableType are directly passed to the function and take their definitions from the function definition."	| xif rc  |	xif := self class xif.	"Check first that the driver supports functionality."	(connection supportsFunction: #SQL_API_SQLTABLES) ifFalse:		[ self class connectionClass unsupportedDriverFunctionalitySignal raise ].	self startPrepare.	self state: #executing.	self isUnicodeEncoding ifTrue: [ | localEncoding copySelector szTableQualfier szTableOwner szTableName szTableType |		localEncoding := self encoding.		copySelector := xif copyToHeapSelector.		szTableQualfier := szTableOwner := szTableName := szTableType := nil.		[ "Begin unwind protection."			tableQualifier isNil ifFalse: [ szTableQualfier := (tableQualifier asByteArrayEncoding: localEncoding) perform: copySelector ].			tableOwner isNil ifFalse: [ szTableOwner := (tableOwner asByteArrayEncoding: localEncoding) perform: copySelector ].			tableName isNil ifFalse: [ szTableName := (tableName asByteArrayEncoding: localEncoding) perform: copySelector ].			tableType isNil ifFalse: [ szTableType := (tableType asByteArrayEncoding: localEncoding) perform: copySelector ].		rc := xif SQLTablesW: self hstmt				with: szTableQualfier with: tableQualifier size				with: szTableOwner with: tableOwner size				with: szTableName with: tableName size				with: szTableType with: tableType size.			"End unwind protection." ]		ensure:			[ szTableQualfier notNil ifTrue: [ szTableQualfier freePointer ].			szTableOwner notNil ifTrue: [ szTableOwner freePointer ].			szTableName notNil ifTrue: [ szTableName freePointer ].			szTableType notNil ifTrue: [ szTableType freePointer ] ]	] ifFalse: [		rc := xif SQLTables: self hstmt				with: tableQualifier with: tableQualifier size				with: tableOwner with: tableOwner size				with: tableName with: tableName size				with: tableType with: tableType size.	].	(rc == xif SQL_SUCCESS	or: [rc == xif SQL_SUCCESS_WITH_INFO]) ifFalse:		[ | errs |		errs := self getStatementErrors.		self resultsCache: errs ].</body><body package="ODBCEXDI">getSQLTypeInfo: sqlTypeSymbol	| xif rc |	xif := self class xif.	"Check first that the driver supports functionality."	(connection supportsFunction: #SQL_API_SQLGETTYPEINFO) ifFalse:		[ self class connectionClass unsupportedDriverFunctionalitySignal raise ].	self startPrepare.	self state: #executing.	rc := xif SQLGetTypeInfo: self hstmt		with: (xif perform: sqlTypeSymbol).	(rc == xif SQL_SUCCESS or: [rc == xif SQL_SUCCESS_WITH_INFO]) ifFalse:		[ | errs |		errs := self getStatementErrors.		self resultsCache: errs ].</body></methods><methods><class-id>Database.ODBC2Session</class-id> <category>private-testing</category><body package="ODBCEXDI">canFetchLongResultsAnyOrder	"Answer aBoolean indicating whether or not long results can be fetched in any order"	fetchLongResultsAnyOrder isNil		ifTrue:[ 	| getDataMask xif |				xif := self class xif.			     	getDataMask := connection getInformationType: #SQL_GETDATA_EXTENSIONS.				fetchLongResultsAnyOrder := (((getDataMask bitAnd: xif SQL_GD_ANY_COLUMN) == 1) and: 						[((getDataMask bitAnd: xif SQL_GD_ANY_ORDER) == 1)])].	^fetchLongResultsAnyOrder</body><body package="ODBCEXDI">isUnicodeEncoding	| encodingString |	encodingString := self encoding asUppercase.	^((encodingString beginsWith: 'UTF') or: [ encodingString beginsWith: 'UCS' ])</body><body package="ODBCEXDI">validateBindInput: aBindObject	"Check to see whether anArray contains any Array elements, if yes, make the length of the Arrays the same by filling nils."	| includedArrays |	(aBindObject notNil and: [aBindObject isKindOf: Collection]) ifFalse: [^aBindObject].	includedArrays := aBindObject select: [ :each | each isKindOf: Array ].	includedArrays isEmpty ifTrue: [		^aBindObject	] ifFalse: [ | maxBindSize |		maxBindSize := includedArrays inject: 0 into:	[ :currentMax :nextValue | currentMax max: nextValue size ].		(aBindObject size = includedArrays size and: [	(aBindObject detect: [ :each | (each size ~= maxBindSize) ] ifNone: [ nil ]) isNil ]) ifTrue: [				^aBindObject		] ifFalse: [ | newBindObject | 			newBindObject := Array new: aBindObject size.			1 to: aBindObject size do: [ :index | | each |				each := aBindObject at: index.				(each isKindOf: Array) ifTrue: [					each size = maxBindSize ifTrue: [						newBindObject at: index put: each					] ifFalse: [ | newElement |						newElement := Array new: maxBindSize withAll: nil.						1 to: each size do: [ :index1|							newElement at: index1 put: (each at: index1)						].						newBindObject at: index put: newElement					]				] ifFalse: [  | newElement |					newElement := Array new: maxBindSize withAll: nil.					newElement at: 1 put: each.					newBindObject at: index put: newElement				]			].			^newBindObject		]	]</body></methods><methods><class-id>Database.ODBC2Session</class-id> <category>printing</category><body package="ODBCEXDI">printOn: aStream	| hstmt |	super printOn: aStream.	((hstmt := self hstmt) isNil or: [ hstmt referentAddress isNil ] ) ifFalse:		[ aStream nextPutAll: '( hstmt = ';			nextPutAll: (hstmt referentAddress printStringRadix: 16);			nextPutAll: ' )' ]</body></methods><methods><class-id>Database.ODBC2Session</class-id> <category>private-finalization</category><body package="ODBCEXDI">executor	"Answer with an executor for the receiver."	| ex |	ex := super executor.	ex hstmtHolder: self hstmtHolder.	ex mustResendQueryHolder: self mustResendQueryHolder.	^ex</body><body package="ODBCEXDI">finalizeExternal	"Release all external resources"	self releaseBuffersAndAdaptors.	self releaseBindings.	(self hstmt isNil or: [self hstmt referentAddress isNil]) ifTrue:		[ ^self ].	( traceLevel &gt;= 1 ) ifTrue:		[ self class trace: nil ].	super finalizeExternal</body><body package="ODBCEXDI">key	"The hstmtHolder is unique to the session and is constant across pause/resume."	^self hstmtHolder</body></methods><methods><class-id>Database.ODBC2Session</class-id> <category>initialize-release</category><body package="ODBCEXDI">initialize	super initialize.	hstmtHolder := nil asValue. 	mustResendQueryHolder := false asValue.	sqlStatementOptionCache := IdentityDictionary new.	self setMaxLongData: DefaultMaxLongData.	self unicode: false.	self lobBufferSize: self class xif getDataChunkSize</body></methods><methods><class-id>Database.ODBC2Session</class-id> <category>private-tracing</category><body package="ODBCEXDI">traceLevel	^traceLevel</body></methods><methods><class-id>Database.ODBC2Session class</class-id> <category>accessing</category><body package="ODBCEXDI">bufferClass	"Answer the class to use for bindInput/Output objects associated with receiver."	^ODBC2Buffer</body><body package="ODBCEXDI">connectionClass	"Answer the class to use for connection objects associated with receiver."	^ODBC2Connection</body><body package="ODBCEXDI">defaultMaxLongData	^DefaultMaxLongData</body><body package="ODBCEXDI">defaultMaxLongData: anInteger	DefaultMaxLongData := anInteger</body><body package="ODBCEXDI">largeObjectBufferClass	"Answer the class to use for bindInput/Output objects associated with receiver."	^ODBCLargeObjectBuffer</body><body package="ODBCEXDI">varcharToLongConversionMap	"Return a Dictionary of the varchar and varbinary and nvarchar type -&gt; Long type numeric values."		| xif |	xif := self xif.	^Dictionary new		at: (xif SQL_VARCHAR) put: (xif SQL_LONGVARCHAR);		at: (xif SQL_WVARCHAR) put: (xif SQL_WLONGVARCHAR);		at: (xif SQL_VARBINARY) put: (xif SQL_LONGVARBINARY);		yourself.</body></methods><methods><class-id>Database.ODBC2Session class</class-id> <category>private-activation</category><body package="ODBCEXDI">install	self bufferClass install.</body></methods><methods><class-id>Database.ODBC2Session class</class-id> <category>private-instance creation</category><body package="ODBCEXDI">newForConnection: aConnection	"Answer a new ExternalDatabaseSession associated with aConnection."	| req |	(req := self basicNew) initialize.	req connection: aConnection.	req unicode: aConnection isUnicodeEncoding.	req encoding: aConnection encoding.	req unicodeEncoding: aConnection unicodeEncoding.	^req</body></methods><methods><class-id>Database.ODBC2Session class</class-id> <category>private-registry</category><body package="ODBCEXDI">registry	^RegisteredODBCSessions</body><body package="ODBCEXDI">registry: aCollection	RegisteredODBCSessions := aCollection</body></methods><methods><class-id>Database.ODBC2Session class</class-id> <category>signal constants</category><body package="ODBCEXDI">unableToGetStatementOptionsSignal	^UnableToGetStatementOptions</body><body package="ODBCEXDI">unableToSetStatementOptionsSignal	^UnableToSetStatementOptions</body></methods><methods><class-id>Database.ODBC2Session class</class-id> <category>class initialization</category><body package="ODBCEXDI">initialize	"ODBCSession initialize"	self initRegistry.	DefaultMaxLongData := 16777216.  "Default to 16 megs of long data"		self initializeSQLStatementOptionConversionMap.	self install.</body><body package="ODBCEXDI">initializeSQLStatementOptionConversionMap	"ODBCConnection initializeSQLStatementOptionConversionMap"	(SQLStatementOptionConversionMap := IdentityDictionary new)		add: #SQL_ASYNC_ENABLE-&gt;#longAt:;    				"(ODBC 1.0)"		add: #SQL_BIND_TYPE-&gt;#longAt:; 						"(ODBC 1.0)"		add: #SQL_CONCURRENCY-&gt;#longAt:;					"(ODBC 2.0)"		add: #SQL_CURSOR_TYPE-&gt;#longAt:;					"(ODBC 2.0)"			add: #SQL_KEYSET_SIZE-&gt;#longAt:;					"(ODBC 2.0)"				add: #SQL_MAX_LENGTH-&gt;#longAt:;					"(ODBC 1.0)"		add: #SQL_MAX_ROWS-&gt;#longAt:;						"(ODBC 1.0)"		add: #SQL_NOSCAN-&gt;#longAt:;							"(ODBC 1.0)"		add: #SQL_QUERY_TIMEOUT-&gt;#longAt:;				"(ODBC 1.0)"		add: #SQL_RETRIEVE_DATA-&gt;#longAt:;					"(ODBC 2.0)"		add: #SQL_ROWSET_SIZE-&gt;#longAt:;					"(ODBC 2.0)"		add: #SQL_ROW_NUMBER-&gt;#longAt:;					"(ODBC 2.0)"		add: #SQL_SIMULATE_CURSOR-&gt;#longAt:;				"(ODBC 2.0)"		add: #SQL_USE_BOOKMARKS-&gt;#longAt:.				"(ODBC 2.0)"</body></methods><methods><class-id>Database.ODBCSession</class-id> <category>private-accessing</category><body package="ODBCEXDI">freePointers	"Release buffers and their associated resources."	self pNumRowsFetched notNil ifTrue:		[ self pNumRowsFetched freePointer.		  self pNumRowsFetched: nil ].		self pRowStatusArray notNil ifTrue:		[ self pRowStatusArray freePointer.		  self pRowStatusArray: nil ].		self pParamsProcessed notNil ifTrue:		[ self pParamsProcessed freePointer.		  self pParamsProcessed: nil ].		self pParamStatusArray notNil ifTrue:		[ self pParamStatusArray freePointer.		  self pParamStatusArray: nil ].</body><body package="ODBCEXDI">getStatementErrors	"Return a collection of ODBCError(s) associated with the statement handle."	| xif errors err recNumber | 	xif := self class xif.	errors := OrderedCollection new.	recNumber := 0.	[ recNumber := recNumber + 1.		(err := self connection getErrorsExternal: xif SQL_HANDLE_STMT				handle: self hstmt				recNumber: recNumber) notNil ]		whileTrue: [ errors add: err ].	"Many senders assume non-empty collection."	errors isEmpty 		ifTrue: 			[err := self connection class defaultError.			errors add: err].	^errors</body><body package="ODBCEXDI">pNumRowsFetched	^pNumRowsFetchedHolder value</body><body package="ODBCEXDI">pNumRowsFetched: aCPointerOrNil	pNumRowsFetchedHolder value: aCPointerOrNil</body><body package="ODBCEXDI">pNumRowsFetchedHolder	^pNumRowsFetchedHolder</body><body package="ODBCEXDI">pNumRowsFetchedHolder: aValueHolder	pNumRowsFetchedHolder := aValueHolder</body><body package="ODBCEXDI">pParamStatusArray	^pParamStatusArrayHolder value</body><body package="ODBCEXDI">pParamStatusArray: aCPointerOrNil	pParamStatusArrayHolder value: aCPointerOrNil</body><body package="ODBCEXDI">pParamsProcessed	^pParamsProcessedHolder value</body><body package="ODBCEXDI">pParamsProcessed: aCPointerOrNil	pParamsProcessedHolder value: aCPointerOrNil</body><body package="ODBCEXDI">pParamsProcessedHolder	^pParamsProcessedHolder</body><body package="ODBCEXDI">pParamsProcessedHolder: aValueHolder	pParamsProcessedHolder := aValueHolder</body><body package="ODBCEXDI">pRowStatusArray	^pRowStatusArrayHolder value</body><body package="ODBCEXDI">pRowStatusArray: aCPointerOrNil	pRowStatusArrayHolder value: aCPointerOrNil</body><body package="ODBCEXDI">pRowStatusArrayHolder	^pRowStatusArrayHolder</body><body package="ODBCEXDI">pRowStatusArrayHolder: aValueHolder	pRowStatusArrayHolder := aValueHolder</body></methods><methods><class-id>Database.ODBCSession</class-id> <category>private-finalization</category><body package="ODBCEXDI">finalizeExternal	"Release all external resources"	self freePointers.	super finalizeExternal</body></methods><methods><class-id>Database.ODBCSession</class-id> <category>private-execution</category><body package="ODBCEXDI">acquireExternal	"Acquire external resources."	| xif phstmt rc |	xif := self class xif.	[ "Begin unwind protection."	phstmt := xif HSTMT perform: xif mallocSelector with: 1.	rc := xif SQLAllocHandle: xif SQL_HANDLE_STMT with: self connection hdbc with: phstmt.	( traceLevel &gt;= 3 ) ifTrue:		[ (self traceStream)			print: rc; 			nextPutAll: ' = SQLAllocHandle( handleType = SQL_HANDLE_STMT, inputHandle = ';			nextPutAll: (self connection hdbc referentAddress printStringRadix: 16 );			nextPutAll: ', *outputHandlePtr = '; 			nextPutAll: (phstmt contents referentAddress  printStringRadix: 16);			nextPutAll: ')'.		self class trace: self emitTrace ].	(rc == xif SQL_SUCCESS) ifFalse:		[ | errs |		errs := self getStatementErrors.		self class connectionClass unableToAllocateHandleSignal raiseWith: errs errorString: errs first dbmsErrorString ].	self hstmt: phstmt contents.	self scrollable ifTrue: [		self setScrollOptions: #SQL_CONCUR_READ_ONLY keyset: xif SQL_SCROLL_KEYSET_DRIVEN rowset: self blockFactor.	].		"Determine if driver support feature.?"	"End unwind protection." ]		ensure:			[ phstmt notNil ifTrue: [ phstmt freePointer ] ]</body><body package="ODBCEXDI">dismissExternal	self freePointers.	super dismissExternal.</body><body package="ODBCEXDI">executeDirectExternal	"Execute the SQL text directly without preparing it first."			self setStatementAttributes.		^super executeDirectExternal</body><body package="ODBCEXDI">executeExternal	"Execute the prepared SQL text."	self setStatementAttributes.		^super executeExternal</body><body package="ODBCEXDI">freeStatementExternal: releaseOption	"Release resources associated with a session."	| xif rc |	releaseOption = #SQL_DROP ifFalse:		[^super freeStatementExternal: releaseOption ].			(self hstmt isNil or: [self hstmt isValid not]) ifTrue: [^self].	xif := self class xif.	rc := xif SQLFreeHandle: xif SQL_HANDLE_STMT with: self hstmt.	traceLevel &gt;= 3		ifTrue: 			[(self traceStream)				print: rc;  				nextPutAll: ' = SQLFreeHandle( handleType = SQL_HANDLE_STMT';				nextPutAll: ', handle = '; 				nextPutAll: (self hstmt referentAddress  printStringRadix: 16);				nextPutAll: ')'.			self class trace: self emitTrace].	rc == xif SQL_SUCCESS		ifFalse: 			[| errs |			errs := self getStatementErrors.			self class connectionClass unableToFreeResourceSignal raiseRequestWith: errs				errorString: errs first dbmsErrorString]</body><body package="ODBCEXDI">getStatementOptionExternal: attributeSymbol	"Answer the information associated with fInfoTypeSymbol.  This information is defined only after connecting."	| xif  rc ub  pvParam vParam attributeConversion bufLen stringLengthPtr|	xif := self class xif.	[ "Begin unwind protection."	stringLengthPtr :=  xif SQLINTEGER perform: xif mallocSelector with: 1.	attributeConversion := SQLStatementOptionConversionMap at: attributeSymbol.	(attributeConversion == #stringAt:) ifTrue: [ bufLen := 100 ] ifFalse: [ bufLen := xif SQL_IS_UINTEGER ].	pvParam :=  xif SQLULEN perform: xif mallocSelector with: ((bufLen = xif SQL_IS_UINTEGER) ifTrue:[ 1 ] ifFalse: [ bufLen]).	pvParam contents: 0.	pvParam :=  xif PTR perform: xif mallocSelector with: 1.	self isUnicodeEncoding ifTrue: [		rc := xif SQLGetStmtAttrW: self  hstmt 						    		with:(xif perform: attributeSymbol)						    		with: pvParam						    		with: bufLen						    		with: stringLengthPtr.	] ifFalse: [		rc := xif SQLGetStmtAttr: self  hstmt 						    		with:(xif perform: attributeSymbol)						    		with: pvParam						    		with: bufLen						    		with: stringLengthPtr.	].	( traceLevel &gt;= 3 ) ifTrue:		[ (self traceStream)			print: rc; 			nextPutAll: ' = SQLGetStmtAttr( hstmt = ';			nextPutAll: (self hstmt referentAddress printStringRadix:16);			 nextPutAll: ', attributeSymbol = '; 			nextPutAll: attributeSymbol;			nextPutAll: ', pvParam =';			nextPutAll: (pvParam referentAddress printStringRadix: 16);			nextPutAll: ', bufLen = '; print: bufLen;			nextPutAll: ', stringLengthPtr =';			nextPutAll: (stringLengthPtr referentAddress printStringRadix: 16);			nextPutAll: ' )'.		self class trace: self emitTrace ].		(rc == xif SQL_SUCCESS	or: [ rc == xif SQL_SUCCESS_WITH_INFO]) ifFalse:	     [ | errs |		errs := self getStatementErrors.		^self class unableToGetStatementOptionsSignal raiseWith: errs errorString: errs first dbmsErrorString ].	bufLen := stringLengthPtr contents.	ub := UninterpretedBytes new: bufLen.	pvParam copyAt: 0 to: ub size: bufLen startingAt: 1.	vParam := ub perform: attributeConversion with: 1	"End unwind protection." ]		ensure:			[ pvParam notNil ifTrue: [ pvParam freePointer ].			stringLengthPtr notNil ifTrue: [ stringLengthPtr freePointer ]].	^vParam</body><body package="ODBCEXDI">setStatementAttributes	| xif paramNumber |	xif := self class xif.	self pNumRowsFetched isNil		ifTrue: 			[self	pNumRowsFetched: (xif SQLUINTEGER perform: xif mallocSelector with: 1).			self setStatementOption: #SQL_ATTR_ROWS_FETCHED_PTR	value: self pNumRowsFetched].		paramNumber := 1 max: (self bindValuePointers isEmpty ifTrue: [ 1 ] ifFalse: [(self bindValuePointers at: 1) count]).		self pParamStatusArray isNil ifFalse: [ self pParamStatusArray freePointer ].	self pParamStatusArray: (xif SQLUINTEGER perform: xif mallocSelector with: paramNumber).	self setStatementOption: #SQL_ATTR_PARAM_STATUS_PTR	value: self pParamStatusArray.			self pParamsProcessed isNil		ifTrue: 			[self	pParamsProcessed: (xif SQLUINTEGER perform: xif mallocSelector with: 1).			self setStatementOption: #SQL_ATTR_PARAMS_PROCESSED_PTR	value: self pParamsProcessed].			self setStatementOption: #SQL_ATTR_ROW_BIND_TYPE value: xif SQL_BIND_BY_COLUMN.</body><body package="ODBCEXDI">setStatementOptionExternal: attributeSymbol value: attributeValue	"Set the information associated with fInfoTypeSymbol.  This information is defined only after connecting."	| xif rc valueLength |	xif := self class xif.	valueLength := xif SQL_IS_INTEGER.	attributeValue isString ifTrue: [valueLength := xif SQL_NTS].	attributeValue class name = #CPointer ifTrue: [valueLength := xif SQL_IS_POINTER].	rc := xif				SQLSetStmtAttr: self hstmt				with: (xif perform: attributeSymbol)				with: attributeValue				with: valueLength.					( traceLevel &gt;= 1 ) ifTrue:		[ (self traceStream)			print: rc;			nextPutAll: ' = SQLSetStmtAttr( hstmt = '; 			nextPutAll: (self hstmt referentAddress printStringRadix: 16); 			nextPutAll: ', attributeSymbol = '; 			nextPutAll: attributeSymbol;			nextPutAll: ', attributeValue = '; print: attributeValue;			nextPutAll: ', valueLength ='; print: valueLength;			nextPutAll:  ')'.		self  class trace: self emitTrace ].		(rc == xif SQL_SUCCESS or: [rc == xif SQL_SUCCESS_WITH_INFO])		ifFalse: 			[| errs |			errs := self getStatementErrors.			^self class unableToSetStatementOptionsSignal raiseWith: errs				errorString: errs first dbmsErrorString].	^attributeValue</body></methods><methods><class-id>Database.ODBCSession</class-id> <category>initialize-release</category><body package="ODBCEXDI">initialize	super initialize.		pNumRowsFetchedHolder := nil asValue.	pRowStatusArrayHolder := nil asValue.		pParamsProcessedHolder := nil asValue.	pParamStatusArrayHolder := nil asValue.</body></methods><methods><class-id>Database.ODBCSession</class-id> <category>private-answer set</category><body package="ODBCEXDI">getBlockOfRowsExternal: fetchOrientation offset: fetchOffset	"Fetch the next block of rows into the memory allocated for this purpose."	| xif rc newFetchMode newOffset rowNumberBeforeFetch |	xif := self class xif.	fetchOrientation == self fetchPriorMode ifTrue: [		rowNumberBeforeFetch := [self rowNumber]			on: self class connectionClass externalDatabaseErrorSignal			do: [:ex| (ex parameter at: 1) sqlState = '24000'						ifTrue: [0]		"cursor has been scrolled back past the start; rowNumber is zero"						ifFalse: [ex pass]].		newFetchMode := self fetchRelativeMode.		newOffset := 0 - self blockFactor.	] ifFalse: [		fetchOrientation == self fetchRelativeMode ifTrue: [			newFetchMode := fetchOrientation.			self currentRowIndex: (self currentRowIndex - fetchOffset).			newOffset := fetchOffset - self rowsInBlock + self currentRowIndex.		] ifFalse: [			newFetchMode := fetchOrientation.			newOffset := fetchOffset.		].	].		rc := xif SQLFetchScroll: self hstmt				with: newFetchMode				with: newOffset.	traceLevel &gt;= 3		ifTrue: 			[(self traceStream)				print: rc;				nextPutAll: ' = SQLFetchScroll( hstmt=';				nextPutAll: (self hstmt referentAddress printStringRadix: 16);				nextPutAll: ', fetchOrientation = '; print: newFetchMode;				nextPutAll: ', fetchOffset = ';  print: newOffset;				nextPutAll: ' )'.			self class trace: self emitTrace].	rc == xif SQL_NO_DATA_FOUND ifTrue: [ self rowsInBlock: -1. ^nil].	(rc == xif SQL_ERROR or: [rc == xif SQL_SUCCESS_WITH_INFO]) ifTrue: [| errs |		errs := self getStatementErrors.		(rc == xif SQL_SUCCESS_WITH_INFO and: [ errs first sqlState = '01S06' ]) ifTrue: [			self currentRowIndex: (rowNumberBeforeFetch - 1).		] ifFalse: [			self class connectionClass unableToFetchDataSignal raiseWith: errs	errorString: errs first dbmsErrorString		]		].	self rowsInBlock: self rowsFetched.</body></methods><methods><class-id>Database.ODBCSession</class-id> <category>data processing</category><body package="ODBCEXDI">rowsFetched	self pNumRowsFetched notNil		ifTrue: [^self pNumRowsFetched contents]		ifFalse: [^1]</body></methods><methods><class-id>Database.ODBCSession class</class-id> <category>accessing</category><body package="ODBCEXDI">bufferClass	"Answer the class to use for bindInput/Output objects associated with receiver."	^ODBCBuffer</body><body package="ODBCEXDI">connectionClass	^ODBCConnection</body></methods><methods><class-id>Database.ODBCSession class</class-id> <category>class initialization</category><body package="ODBCEXDI">initialize	"ODBC3Session initialize"	self initializeSQLStatementOptionConversionMap.</body><body package="ODBCEXDI">initializeSQLStatementOptionConversionMap	"ODBC3Session initializeSQLStatementOptionConversionMap"	SQLStatementOptionConversionMap add: #SQL_ATTR_PARAMSET_SIZE-&gt;#longAt:.			"(ODBC 3.0)"</body></methods><methods><class-id>Database.ODBCConnection</class-id> <category>private-execution</category><body package="ODBCEXDI">getConnectionOptionNumber: attributeNumber	"Answer the information associated with fOptionNumber, but for the clarity of your code, use option symbols (method ODBCConnection&gt;&gt;getConnectionOptionExternal: fOptionSymbol) will be a better choice.  This information is defined only after connecting. "	| xif  rc ub  pvParam vParam attributeConversion bufLen attributeSymbol stringLengthPtr |	xif := self class xif.	[ "Begin unwind protection."	stringLengthPtr :=  xif SQLINTEGER perform: xif mallocSelector with: 1.	attributeSymbol := SQLConnectionOptionConversionMap keys detect: [ :each | (xif perform: each) = attributeNumber ] ifNone: [ nil ].	attributeSymbol isNil ifFalse: [		attributeConversion := SQLConnectionOptionConversionMap at: attributeSymbol.		(attributeConversion == #stringAt:) ifTrue: [ bufLen := 100 ] ifFalse: [ bufLen := xif SQL_IS_UINTEGER ].	].	pvParam :=  xif SQLULEN perform: xif mallocSelector with: ((bufLen = xif SQL_IS_UINTEGER) ifTrue:[ 1 ] ifFalse: [ bufLen]).	pvParam contents: 0.	self allocConnect.	self isUnicodeEncoding ifTrue: [		rc := xif SQLGetConnectAttrW: self hdbc 						    		with: attributeNumber						    		with: pvParam						    		with: bufLen						    		with: stringLengthPtr.	] ifFalse: [		rc := xif SQLGetConnectAttr: self hdbc 						    		with: attributeNumber						    		with: pvParam						    		with: bufLen						    		with: stringLengthPtr.	].		( traceLevel &gt;= 3 ) ifTrue:			[ (self traceStream)				print: rc; 				nextPutAll: ' = SQLGetConnectAttr( hdbc = ';				nextPutAll: (self hdbc referentAddress printStringRadix:16);				nextPutAll: ', attrName = '; print: attributeNumber;				nextPutAll: ', pvParam =';				nextPutAll: (pvParam referentAddress printStringRadix:16);				nextPutAll: ', bufLen = '; print: bufLen;				nextPutAll: ', stringLengthPtr =';				nextPutAll: (stringLengthPtr referentAddress printStringRadix:16);				nextPutAll: ' )'.			self class trace: self emitTrace ].	(rc == xif SQL_SUCCESS	or: [ rc == xif SQL_SUCCESS_WITH_INFO]) ifFalse:	     [ | errs |		errs := self getConnectionErrors.		^self class unableToGetConnectionOptionsSignal raiseWith: errs errorString: errs first dbmsErrorString ].		bufLen := stringLengthPtr contents.		ub := UninterpretedBytes new: bufLen.		pvParam copyAt: 0 to: ub size: bufLen startingAt: 1.		vParam := ub perform: attributeConversion with: 1	"End unwind protection." ]		ensure:			[ pvParam notNil ifTrue: [ pvParam freePointer ].			stringLengthPtr notNil ifTrue: [ stringLengthPtr freePointer ]].	^vParam</body><body package="ODBCEXDI">getEnvironmentAttributeExternal: attributeNumber	"Answer the information associated with attributeNumber, but for the clarity of your code, use option symbols (method ODBCConnection&gt;&gt;getConnectionOptionExternal: attributeNumber) will be a better choice.  This information is defined only after connecting. "	| xif  rc ub  pvParam vParam attributeConversion bufLen attributeSymbol stringLengthPtr|	xif := self class xif.	[ "Begin unwind protection."	pvParam :=  xif PTR perform: xif mallocSelector with: 1.	stringLengthPtr :=  xif SQLINTEGER perform: xif mallocSelector with: 1.	attributeSymbol := SQLEnvironmentAttributeConversionMap keys detect: [ :each | (xif perform: each) = attributeNumber ] ifNone: [ nil ].	attributeSymbol isNil ifFalse: [		attributeConversion := SQLEnvironmentAttributeConversionMap at: attributeSymbol.		(attributeConversion == #stringAt:) ifTrue: [ bufLen := 100 ] ifFalse: [ bufLen := ObjectMemory is64Bit ifTrue: [ 8 ] ifFalse: [ 4 ] ].	].	pvParam contents: 0.	self allocConnect.	rc := xif SQLGetEnvAttr: self class henv 				with: attributeNumber				with: pvParam				with: bufLen				with: stringLengthPtr.	( traceLevel &gt;= 3 ) ifTrue:		[ (self traceStream)			print: rc; 			nextPutAll: ' = SQLGetEnvAttr( hdbc = ';			nextPutAll: (self hdbc referentAddress printStringRadix:16);			nextPutAll: ', attrName = '; print: attributeNumber;			nextPutAll: ', pvParam =';			nextPutAll: (pvParam referentAddress printStringRadix:16);			nextPutAll: ', bufLen = '; print: bufLen;			nextPutAll: ', stringLengthPtr =';			nextPutAll: (stringLengthPtr referentAddress printStringRadix:16);			nextPutAll: ' )'.		self class trace: self emitTrace ].	(rc == xif SQL_SUCCESS	or: [ rc == xif SQL_SUCCESS_WITH_INFO]) ifFalse:	     [ | errs |		errs := self getConnectionErrors.		^self class unableToGetConnectionOptionsSignal raiseWith: errs errorString: errs first dbmsErrorString ].		(attributeConversion == #stringAt:) ifTrue: [ bufLen := stringLengthPtr contents ].		ub := UninterpretedBytes new: bufLen.		pvParam copyAt: 0 to: ub size: bufLen startingAt: 1.		vParam := ub perform: attributeConversion with: 1	"End unwind protection." ]		ensure:			[ pvParam notNil ifTrue: [ pvParam freePointer ].			stringLengthPtr notNil ifTrue: [ stringLengthPtr freePointer ]].	^vParam</body><body package="ODBCEXDI">getErrorsExternal: handleType handle: handle recNumber: recNumber	"Return the next piece of error or status information, or nil if none."	| xif szSqlState pfNativeError szErrorMsg cbErrorMsgMax pcbErrorMsg rc error charType |	xif := self class xif.		["Begin unwind protection."	charType := xif charDataTypeUnicode: self isUnicodeEncoding.	szSqlState := charType perform: xif mallocSelector				with: xif SQL_SQLSTATE_SIZE + 1.	pfNativeError := xif SDWORD perform: xif mallocSelector with: 1.	szErrorMsg := charType perform: xif mallocSelector				with: (cbErrorMsgMax := xif SQL_MAX_MESSAGE_LENGTH + 1).	pcbErrorMsg := xif SWORD perform: xif mallocSelector with: 1.	self isUnicodeEncoding		ifTrue: 			[rc := xif						SQLGetDiagRecW: handleType						with: handle						with: recNumber						with: szSqlState						with: pfNativeError						with: szErrorMsg						with: cbErrorMsgMax						with: pcbErrorMsg]		ifFalse: 			[rc := xif						SQLGetDiagRec: handleType						with: handle						with: recNumber						with: szSqlState						with: pfNativeError						with: szErrorMsg						with: cbErrorMsgMax						with: pcbErrorMsg].	traceLevel &gt;= 2		ifTrue: 			[(self traceStream)				print: rc;				nextPutAll: ' = SQLGetDiagRec( handleType = '; print: handleType;				nextPutAll: ', handle = ';				nextPutAll: (handle referentAddress printStringRadix: 16);				nextPutAll: ', recNumber = '; print: recNumber;				nextPutAll: ', szSqlState =';				nextPutAll: (szSqlState referentAddress printStringRadix: 16);				nextPutAll: ', pfNativeError =';				nextPutAll: (pfNativeError referentAddress printStringRadix: 16);				nextPutAll: ', szErrorMsg =';				nextPutAll: (szErrorMsg referentAddress printStringRadix: 16);				nextPutAll: ', cbErrorMsgMax = ';	print: cbErrorMsgMax;				nextPutAll: ', pcbErrorMsg =';				nextPutAll: (pcbErrorMsg referentAddress printStringRadix: 16);				nextPutAll: ' )';				crtab.			self class trace: self emitTrace].	rc == xif SQL_SUCCESS		ifTrue: 			[error := self class errorClass new.			error dbmsErrorCode: pfNativeError contents.			error dbmsErrorString: (szErrorMsg copyCStringFromHeap: self encoding).			error sqlState: (szSqlState copyCStringFromHeap: self encoding)]	"End unwind protection."]			ensure: 				[szSqlState notNil ifTrue: [szSqlState freePointer].				pfNativeError notNil ifTrue: [pfNativeError freePointer].				szErrorMsg notNil ifTrue: [szErrorMsg freePointer].				pcbErrorMsg notNil ifTrue: [pcbErrorMsg freePointer]].	^error</body><body package="ODBCEXDI">setConnectionOptionNumber: attributeNumber value: attributeValue	"Set the information associated with fOptionNumber, but for the clarity of your code, use option symbols (method setConnectionOptionExternal: fOptionSymbol value: vOption) will be a better choice.  This information is defined only after connecting."	| xif rc attributeSymbol valueLength |	xif := self class xif.		attributeValue isString ifTrue: [ valueLength := xif SQL_NTS ] ifFalse: [ valueLength := xif SQL_IS_INTEGER  ].		self isUnicodeEncoding ifTrue: [		rc := xif SQLSetConnectAttrW: self hdbc 						    		with: attributeNumber						    		with: attributeValue						    		with: valueLength.	] ifFalse: [		rc := xif SQLSetConnectAttr: self hdbc 						    		with: attributeNumber						    		with: attributeValue						    		with: valueLength.	].	( traceLevel &gt;= 3 ) ifTrue:		[ (self traceStream)			print: rc; 			nextPutAll: ' = SQLSetConnectAttr( hdbc = ';			nextPutAll: (self hdbc referentAddress printStringRadix:16);			nextPutAll: ', attributeNumber = '; print: attributeNumber;			nextPutAll: ', attributeValue ='; print: attributeValue;			nextPutAll: ', valueLength ='; print: valueLength;			nextPutAll: ' )'.		self class trace: self emitTrace ].	(rc == xif SQL_SUCCESS	or: [ rc == xif SQL_SUCCESS_WITH_INFO]) ifFalse:	     [ | errs |		errs := self getConnectionErrors.		^self class unableToSetConnectionOptionsSignal raiseWith: errs errorString: errs first dbmsErrorString ].	attributeSymbol := self sqlConnectionOptionCache keys detect: [ :each | (xif perform: each) = attributeNumber ] ifNone: [ nil ].	attributeSymbol isNil ifFalse: [ self sqlConnectionOptionCache at: attributeSymbol put: attributeValue ].	^attributeValue</body><body package="ODBCEXDI">transactExternal: completionTypeSymbol	| xif behavior |	xif := self class xif. 	self transactExternal: #SQL_HANDLE_DBC			handle: self hdbc			completionType: completionTypeSymbol.	"What are the side effects of the end of the transaction."	completionTypeSymbol == #SQL_COMMIT ifTrue:		[ behavior := self getInformationType: #SQL_CURSOR_COMMIT_BEHAVIOR ].	completionTypeSymbol == #SQL_ROLLBACK ifTrue:		[ behavior := self getInformationType: #SQL_CURSOR_ROLLBACK_BEHAVIOR ].	behavior == xif SQL_CB_DELETE ifTrue:		[ self cursorsAreDeleted ].	behavior == xif SQL_CB_CLOSE ifTrue:		[ self cursorsAreClosed ]</body><body package="ODBCEXDI">transactExternal: handleTypeSymbol handle: aHandle completionType: completionTypeSymbol	| xif rc |	xif := self class xif. 	rc := xif SQLEndTran: (xif perform: handleTypeSymbol) 			with: aHandle			with: (xif perform: completionTypeSymbol).	( traceLevel &gt;= 1 ) ifTrue:		[ (self traceStream)			print: rc;			nextPutAll: ' = SQLEndTran( handleType = '; 			nextPutAll: handleTypeSymbol;			nextPutAll: ', handle = ';			nextPutAll: (aHandle referentAddress printStringRadix: 16); 			nextPutAll: ', completionType = '; 			nextPutAll: completionTypeSymbol;			nextPutAll:  ')'.		self  class trace: self emitTrace ].	(rc == xif SQL_SUCCESS) ifFalse:		[ | errs |		errs := self getConnectionErrors.		self class transactionExceptionSignal raiseWith: errs errorString: errs first dbmsErrorString ].</body></methods><methods><class-id>Database.ODBCConnection</class-id> <category>initialize-release</category><body package="ODBCEXDI">initialize	"Establish initial value for instance variables."	super initialize.</body></methods><methods><class-id>Database.ODBCConnection</class-id> <category>private-accessing</category><body package="ODBCEXDI">getConnectionErrors	"Return a non-empty collection of ODBCError(s) associated with the connection handle."	| xif errors err recNumber|	xif := self class xif.	errors := OrderedCollection new.	recNumber := 0.	[ recNumber := recNumber + 1. 		(err := self getErrorsExternal: xif SQL_HANDLE_DBC				handle: self hdbc				recNumber: recNumber) notNil] 			whileTrue: [errors add: err].	"Many senders assume non-empty collection."	errors isEmpty 		ifTrue: 			[err := self class defaultError.			errors add: err].	^errors</body><body package="ODBCEXDI">getEnvironmentAttribute: attributeSymbol	^self getEnvironmentAttributeExternal: (self class xif perform: attributeSymbol)</body><body package="ODBCEXDI">getEnvironmentErrors	"Answer a non-empty collection of ODBCError(s) associated with the environment handle."	| xif errors err recNumber | 	xif := self class xif.	errors := OrderedCollection new.	recNumber := 0.	HenvLock critical:		[ "Begin critical section."		[ recNumber := recNumber + 1.			(err := self getErrorsExternal: xif SQL_HANDLE_ENV				handle: self class henv				recNumber: recNumber) notNil] 			whileTrue: [ errors add: err ].		"End critical section." ].	"Many senders assume non-empty collection."	errors isEmpty 		ifTrue: 			[err := self class defaultError.			errors add: err].	^errors</body></methods><methods><class-id>Database.ODBCConnection</class-id> <category>accessing</category><body package="ODBCEXDI">odbcVersion	^self getEnvironmentAttribute: #SQL_ATTR_ODBC_VERSION.</body></methods><methods><class-id>Database.ODBCConnection</class-id> <category>private-handles</category><body package="ODBCEXDI">unprotectedAddHenvReference	"Acquire an environment handle if needed and record a reference.  Senders	must ensure protection using HenvLock.  If this method completes normally,	resources are held that should be released explicitly using #unprotectedDropHenvReference."	| xif phenv rc |	xif := self class xif.	"Not too much to do if environment handle already allocated."	Henv notNil 		ifTrue: 			["One more reference to the Henv."			HenvReferencesCount := HenvReferencesCount + 1.			^self].	"Get the environment handle."		[	["Begin unwind protection"	self class connectionPooling ifTrue: [		self setConnectionPoolingOn.	].	self class supportAllocateHandle ifTrue: [		phenv := xif SQLHANDLE perform: xif mallocSelector with: 1.		rc := xif SQLAllocHandle: xif SQL_HANDLE_ENV with: xif SQL_NULL_HANDLE with: phenv	].	traceLevel &gt;= 3 	ifTrue: [		(self traceStream)			print: rc; 			nextPutAll: ' = SQLAllocHandle( handleType = SQL_HANDLE_ENV, inputHandle = SQL_NULL_HANDLE';			nextPutAll: ', *outputHandlePtr = '; 			nextPutAll: (phenv contents referentAddress  printStringRadix: 16);			nextPutAll: ')'.		self class trace: self emitTrace].	rc == xif SQL_SUCCESS ifFalse: [^self class unableToAllocateHandleSignal raise].	"Save environment handle"	Henv := phenv contents.		rc := xif SQLSetEnvAttr: self class henv with: xif SQL_ATTR_ODBC_VERSION with: xif SQL_OV_ODBC3 with: 0.	rc == xif SQL_SUCCESS ifFalse: [^self class unableToSetEnvironmentAttributeSignal raise].	self class connectionPooling ifTrue: [		self class cpStrictMatch ifTrue: [			self setCPToStrictMatch.		] ifFalse: [			self setCPToRelaxedMatch.		].	].	HenvReferencesCount := 1.	"End unwind protection."] 			ensure: [phenv notNil ifTrue: [phenv freePointer]]] 			on: Object errorSignal			do: [:ex | self class externalDatabaseLibraryInaccessibleSignal raise]</body><body package="ODBCEXDI">unprotectedAllocConnect	"Acquire reference to environment handle and then allocate a connection handle.	Senders must ensure protection using HenvLock.  If this method completes normally,	resources are held that should be released explicitly using #unprotectedFreeConnect."	| xif phdbc rc |	xif := self class xif.	"Make sure we have a reference to the environment handle."	self unprotectedAddHenvReference.	[ "Begin unwind protection (level 1) -- ensure release of environment handle on failure."	[ "Begin unwind protection (level 2) -- ensure release of pointers on success or failure."		phdbc := xif  HDBC perform: xif mallocSelector with: 1.		rc := xif SQLAllocHandle: xif SQL_HANDLE_DBC with: self class henv with: phdbc.		(traceLevel &gt;= 3) ifTrue:			[(self traceStream) 				print: rc; 				nextPutAll: ' = SQLAllocHandle( handleType = SQL_HANDLE_DBC, inputHandle = ';				nextPutAll: (self class henv referentAddress printStringRadix: 16 );				nextPutAll: ', *outputHandlePtr = '; 				nextPutAll: (phdbc contents referentAddress  printStringRadix: 16);				nextPutAll: ')'.		self class trace: self emitTrace].		(rc == xif SQL_SUCCESS) ifFalse:			[ | errs |			errs := self getEnvironmentErrors.			^self class unableToAllocateHandleSignal raiseWith: errs errorString: errs first dbmsErrorString].		self hdbc: phdbc contents.	"End unwind protection (level 2)" ]		ensure:			[ phdbc notNil ifTrue: [ phdbc freePointer ] ].	"End unwind protection (level 1)" ]		ifCurtailed:			[ "Some failure is causing unwind, don't keep the environment handle reference."			self unprotectedDropHenvReference ]</body><body package="ODBCEXDI">unprotectedDropHenvReference	"Remove a reference to the environment handle.  If no references left, release the	handle.  Senders must ensure protection using HenvLock."	| xif rc |	xif := self class xif.	"Reduce the reference count."	(HenvReferencesCount := HenvReferencesCount - 1) &gt; 0 ifTrue:		[ "Little to do if other references still remain."		^self ].	[ "Begin unwind protection."		rc := xif SQLFreeHandle: xif SQL_HANDLE_ENV with: Henv.		(traceLevel &gt;= 3) ifTrue: [ 			(self traceStream)			print: rc;  			nextPutAll: ' = SQLFreeHandle( handleType = SQL_HANDLE_ENV';			nextPutAll: ', handle = '; 			nextPutAll: (Henv referentAddress  printStringRadix: 16);			nextPutAll: ')'.		self class trace: self emitTrace ].		(rc == xif SQL_SUCCESS) ifFalse:			[ | errs |			errs := self getEnvironmentErrors.			^self class unableToFreeResourceSignal raiseRequestWith: errs errorString: errs first dbmsErrorString ].	"End connection pooling if it is active."	self class connectionsArePooled ifTrue: [		self setConnectionPoolingOff	].	"End unwind protection." ]		ensure:			[ Henv := nil ]</body><body package="ODBCEXDI">unprotectedFreeConnect	"Free the connection handle and then release reference to environment handle.	Senders must ensure protection using HenvLock."	| xif rc |	xif := self class xif.	[ "Begin unwind protection"		rc := xif SQLFreeHandle: xif SQL_HANDLE_DBC with: self hdbc.		(traceLevel &gt;= 3) ifTrue:			[ (self traceStream)				print: rc;  				nextPutAll: ' = SQLFreeHandle( handleType = SQL_HANDLE_DBC';				nextPutAll: ', handle = '; 				nextPutAll: (self hdbc referentAddress  printStringRadix: 16);				nextPutAll: ')'.			self class trace: self emitTrace ].		(rc == xif SQL_SUCCESS ) ifFalse:			[ | errs |			errs := self getEnvironmentErrors.			^self class unableToFreeResourceSignal raiseRequestWith: errs errorString: errs first dbmsErrorString ].	"End unwind protection." ]		ensure:			[ "Whether or not there was a failure, there's no point in hanging onto these."			self hdbc: nil.			self unprotectedDropHenvReference ]</body></methods><methods><class-id>Database.ODBCConnection class</class-id> <category>accessing</category><body package="ODBCEXDI">bufferClass	"Answer the buffer class for sessions"		^ODBCBuffer</body><body package="ODBCEXDI">sessionClass	"Answer the class to use for session objects associated with receiver."	^ODBCSession</body></methods><methods><class-id>Database.ODBCConnection class</class-id> <category>class initialization</category><body package="ODBCEXDI">initialize	"ODBCConnection initialize"	self initializeSQLEnvironmentAttributeConversionMap.</body><body package="ODBCEXDI">initializeSQLEnvironmentAttributeConversionMap	"ODBCConnection initializeSQLEnvironmentAttributeConversionMap"	(SQLEnvironmentAttributeConversionMap := IdentityDictionary new)		add: #SQL_ATTR_OUTPUT_NTS-&gt;#longAt:;				add: #SQL_ATTR_ODBC_VERSION-&gt;#longAt:;			add: #SQL_ATTR_CP_MATCH-&gt;#longAt:;			add: #SQL_ATTR_CONNECTION_POOLING -&gt;#longAt:.</body></methods><methods><class-id>Database.ODBCLargeObjectBuffer</class-id> <category>testing</category><body package="ODBCEXDI">canHold: aValue 	"Return true if this buffer has the correct type. Since 	this is a large object buffer, the buffer has infinite 	capacity."	^self databaseType == aValue odbcConversion</body><body package="ODBCEXDI">isBLOB	^false</body><body package="ODBCEXDI">isCLOB	^false</body><body package="ODBCEXDI">isLargeObject	^true</body></methods><methods><class-id>Database.ODBCLargeObjectBuffer</class-id> <category>binding</category><body package="ODBCEXDI">bindForInput	"Prepare the receiver to put data for an unbound parameter."	| size |	fParamType := bufferSession class xif SQL_PARAM_INPUT.	"We won't re-use pointers."	(bufferPointer isNil)		ifFalse:[ self free].	"Allocate CPointers to hold data and the size of the data "	self mallocUsingSelector: bufferSession class xif mallocSelector.	"For unbound buffers the data it represents is sent only when the server requests it. 	To facilitate this process we only bind the receiver's index so that the server can later	specify which instance of the receiver that it wants data for."	(bufferValue isKindOf: Array) ifTrue: [		size := bufferValue size	] ifFalse: [		size := 1	].	1 to: size do: [ :index |		"Assign the size indicator so that the driver can pre-allocate in advance. Preserve this		pointer's value for the duration of the transfer. Not all drivers capture this value at the		same time. Access seems to grab it again, after all the data has been sent."		pcbSizeIndicator at: (index - 1) put: (bufferSession class xif SQL_LEN_DATA_AT_EXEC: 0). 	].		^self bindInputExternalBeforeTransfer</body><body package="ODBCEXDI">bindForOutput 	"Prepare the receiver to get data from an unbound result column."	"We won't re-use pointers."	(bufferPointer isNil)		ifFalse: [ self free ]. 	"Allocate CPointers to hold data and the size of the data "	self mallocUsingSelector: bufferSession class xif mallocSelector.</body><body package="ODBCEXDI">rebindForInput	"Prepare the receiver to put data for an unbound parameter."	"For unbound buffers the data it represents is sent only when the server requests it. 	To facilitate this process we only bind the receiver's index so that the server can later	specify which instance of the receiver that it wants data for."	self at: 1 putInteger: bufferIndex.	pcbSizeIndicator contents: (bufferSession class xif SQL_LEN_DATA_AT_EXEC: 0).		^self bindInputExternalBeforeTransfer</body></methods><methods><class-id>Database.ODBCLargeObjectBuffer</class-id> <category>accessing</category><body package="ODBCEXDI">value	"Answer the value (or values) held in the buffer"	^bufferValue copy</body></methods><methods><class-id>Database.ODBCLargeObjectBuffer</class-id> <category>private</category><body package="ODBCEXDI">coalesce: chunkCollection 	"This method converts the collection of segments held by chunkCollection 	into a single object, reassigned to bufferValue. 	Assumes very last segment of data is the smallest."	| firstSegSize lastSegSize allocationSize copyIndex nSlots largeSegment |	nSlots := chunkCollection size.	firstSegSize := (chunkCollection at: 1) size.	lastSegSize := (chunkCollection at: nSlots) size.	"Create an appropriate object to hold combined chunks."	allocationSize := (nSlots - 1) * firstSegSize + lastSegSize.	largeSegment := (chunkCollection at: 1) species new: allocationSize.	copyIndex := 0.	chunkCollection		do: 			[:segment | 			largeSegment				replaceFrom: copyIndex + 1				to: copyIndex + segment size				with: segment				startingAt: 1.			copyIndex := copyIndex + segment size].	bufferValue := largeSegment.	^bufferValue</body></methods><methods><class-id>Database.ODBCLargeObjectBuffer</class-id> <category>private-data conversion {put}</category><body package="ODBCEXDI">at: index putByteArray: aByteArray	"Put aByteArray into the buffer."	| bytes |	(bytes := aByteArray size) &gt; cbValueMax ifTrue:		[ self class connectionClass unableToBindSignal raise ].	bufferPointer copyAt: (index -1) from: aByteArray size: bytes startingAt: 1.	pcbValue contents: bytes.	^aByteArray</body><body package="ODBCEXDI">at: index putString: aString	"Put aString into the buffer."	| str bytes |	str := aString asByteArrayEncoding: self encoding.	(bytes := str size) &gt; cbValueMax ifTrue:		[ self class connectionClass unableToBindSignal raise ].	bufferPointer copyAt: (index -1) from: str size: bytes startingAt: 1.	pcbValue contents: bytes.	^aString</body><body package="ODBCEXDI">putLobValue: aValue	| xif valueStream rc atLeastOnce |	xif := bufferSession class xif.  	aValue isNil ifTrue: [		rc := xif SQLPutData: bufferSession hstmt					with: 0					with: xif SQL_NULL_DATA	] ifFalse: [		(aValue isKindOf: Stream) ifTrue: [			valueStream := aValue position: 0.		] ifFalse: [			valueStream := ReadStream on: aValue		].		"Ensure that an empty String/ByteArray gets handled."		atLeastOnce := false.		[valueStream atEnd and: [atLeastOnce]]			whileFalse: [ "Ensure that proper conversion takes place." | numOfBytes numOfChars bufferSize |					atLeastOnce := true.					bufferSize := bufferSession lobBufferSize.					(self isStringBased and: [ self isUnicodeEncoding ]) ifTrue: [						numOfBytes := bufferSize min: ((valueStream size - valueStream position)*2).						numOfChars := numOfBytes // 2.					] ifFalse: [						numOfBytes := bufferSize min: (valueStream size - valueStream position).						numOfChars := numOfBytes					].					self at: 1 put: (valueStream nextAvailable: numOfChars).					rc := xif SQLPutData: bufferSession hstmt							 		with: bufferPointer							 		with: pcbValue contents.					 (bufferSession traceLevel &gt;= 3 ) ifTrue:						[ (bufferSession  traceStream)					 	print: rc;  nextPutAll: ' = SQLPutData( hstmt = ';					 	nextPutAll: (bufferSession hstmt referentAddress printStringRadix: 16);					 	nextPutAll: ', rgbValue = ';					 	nextPutAll: (bufferPointer  referentAddress printStringRadix: 16);					 	nextPutAll: ', cbValue = '; print: pcbValue contents;					 	nextPutAll: ' )'.						bufferSession class trace: bufferSession emitTrace ].					 (rc == xif SQL_ERROR or: [ rc == xif SQL_SUCCESS_WITH_INFO ]) ifTrue:					 	[| errs |					 	errs := bufferSession getStatementErrors.							^bufferSession class connectionClass unableToBindSignal raiseWith: errs errorString: errs first dbmsErrorString ] ]		]</body></methods><methods><class-id>Database.ODBCLargeObjectBuffer</class-id> <category>private-accessing</category><body package="ODBCEXDI">reUse: aValue 	"Re-use this buffer for an object of the same type, and 	same or smaller size. Update cbColDef (object size). 	Don't update maxColDef (bufferPointer memory size)."	(self canHold: aValue)		ifFalse: [self class connectionClass unableToBindSignal raise].	bufferValue := aValue.	cbColDef := self isStringBased 					ifTrue: [ (ValuePrecisionBlocks at: databaseType) value: (aValue asByteArrayEncoding: self encoding) ] 					ifFalse: [  (ValuePrecisionBlocks at: databaseType) value: aValue].	self rebindForInput</body></methods><methods><class-id>Database.ODBCLargeObjectBuffer</class-id> <category>allocation</category><body package="ODBCEXDI">free	"Free the receiver."	pcbSizeIndicator notNil ifTrue:		[ pcbSizeIndicator freePointer.		  pcbSizeIndicator := nil ].	super free.</body><body package="ODBCEXDI">mallocUsingSelector: mallocSelector	"Allocate a physical buffer for the receiver. Use mallocSelector to perform the allocation."	["Begin unwind protection."		pcbSizeIndicator := self session class xif longIntegerType perform: mallocSelector with: (count max: 1).		pcbValue := self session class xif longIntegerType perform: mallocSelector with: 1.		bufferPointer := self pointerType perform: mallocSelector with: 1.	"End unwind protection."]			ifCurtailed: [self free].</body></methods><methods><class-id>Database.ODBCLargeObjectBuffer</class-id> <category>private-binding</category><body package="ODBCEXDI">bindInputExternalBeforeTransfer	"Bind the contents of the receiver to the server."	| rc xif sqlType cType isDB2 |	xif := bufferSession class xif.	isDB2 := (self session connection dbmsName findString: 'DB2' startingAt: 1) &gt; 0.	cType := self fCType.	self isStringBased ifTrue: [		self unicode ifTrue: [ | type |			type := self fSqlType.			cType := xif SQL_C_WCHAR.			type == xif SQL_CHAR ifTrue: [				sqlType := xif SQL_WCHAR			] ifFalse: [				type == xif SQL_VARCHAR ifTrue: [					sqlType := xif SQL_WVARCHAR				] ifFalse: [ 					isDB2 ifTrue: [						sqlType := xif SQL_DBCLOB					] ifFalse: [						sqlType := xif SQL_WLONGVARCHAR					]				]			]		] ifFalse: [			isDB2 ifTrue: [				sqlType := xif SQL_CLOB			] ifFalse: [				sqlType := self fSqlType			]		]	] ifFalse: [			isDB2 ifTrue: [				sqlType := xif SQL_BLOB			] ifFalse: [				sqlType := self fSqlType			]	].	((bufferValue isNil) and: [ self session connection dbmsName = 'ACCESS' ]) ifTrue:[		databaseType := #Integer.		cType := self fCType.		sqlType := self fSqlType	].	count &gt; 1 ifTrue: [		bufferSession setStatementOption: #SQL_ATTR_PARAM_BIND_TYPE value: xif SQL_BIND_BY_COLUMN.		bufferSession setParamSetSizeTo: count.	].	1 to: count do: [ :index | | aValue |		aValue := bufferValue at: index.		aValue isNil ifTrue: [			pcbSizeIndicator at: (index - 1) put: xif SQL_NULL_DATA		] ifFalse: [			pcbSizeIndicator at: (index - 1) put: (xif SQL_LEN_DATA_AT_EXEC: 0)		]		].	rc := xif  SQLBindParameter: bufferSession hstmt					    	     with: bufferIndex						     with: fParamType					    	     with: cType					    	     with: sqlType		 			    	     with: cbColDef		 			    	     with: self ibScale					    	     with: bufferPointer						     with: cbValueMax					    	     with: pcbSizeIndicator.		( bufferSession traceLevel &gt;= 3 ) ifTrue:		[ (bufferSession  traceStream)			print: rc;  nextPutAll: ' = SQLSetParam( hstmt = ';			nextPutAll: (bufferSession hstmt referentAddress printStringRadix: 16);			nextPutAll: ', ipar='; print: bufferIndex;			nextPutAll: ', fCType='; print: cType;			nextPutAll: ', fSqlType=';  print: sqlType;			nextPutAll: ', cbParamDef= '; print: cbColDef;			nextPutAll: ', ibScale= '; print: ibScale;			nextPutAll: ', *rgbValue='; print: bufferValue;			nextPutAll: ', *pcbSizeIndicator ='; print: pcbSizeIndicator contents;			nextPutAll: ' )'.		bufferSession class trace: bufferSession emitTrace ].	(rc == xif SQL_SUCCESS) ifFalse:		[ | errs |		  errs := bufferSession getStatementErrors.		  ^bufferSession class connectionClass unableToBindSignal raiseWith: errs errorString: errs first dbmsErrorString ].</body><body package="ODBCEXDI">bindOutputExternal	 "Retrieve data from unbound result column. We only copy up to maxBytesToCopy"	| rc xif copyIndex cType maxBytesToCopy cbValue chunkCollection nullTerm chunkSize isDone|	xif := bufferSession class xif.	copyIndex := 0.	cType := self fCType.	self isStringBased ifTrue: [		self unicode 	ifTrue: [			cType := xif SQL_C_WCHAR.			self encoding == #'UTF-8' ifTrue: [				nullTerm := 3.			] ifFalse: [				nullTerm := 2.			]. 		]ifFalse: [			nullTerm := 1.		]	]ifFalse:[		nullTerm := 0.	].		chunkCollection := OrderedCollection new: 0.	maxBytesToCopy := (bufferSession getMaxLongData min: cbColDef ).	isDone := false.	[isDone]		whileFalse: [ cbValue := ((maxBytesToCopy - copyIndex + nullTerm) min: cbValueMax).					rc := xif SQLGetData: bufferSession hstmt									with: bufferIndex									with: cType									with: bufferPointer									with: cbValueMax									with: pcbValue.					(bufferSession traceLevel &gt;= 3 ) ifTrue: 						[(bufferSession  traceStream)						print: rc;  nextPutAll: ' = SQLGetData( hstmt = ';						nextPutAll: (bufferSession hstmt referentAddress printStringRadix: 16);						nextPutAll: ' )'.						bufferSession class trace: bufferSession emitTrace ].					chunkSize := cbValue - nullTerm.					((rc == xif SQL_ERROR ) or: [ rc == xif SQL_SUCCESS_WITH_INFO ] )  ifTrue:						[ | errs |						errs := bufferSession getStatementErrors.						(errs at: 1) sqlState = '01004'							ifTrue: ["Data was truncated. Ensure that we don't copy more									than maxBytesToCopy.  Also, exclude null terminator for Strings									for all but last chunk, which isn't null terminated."									pcbValue contents: chunkSize]							ifFalse: [ ^bufferSession class connectionClass unableToBindSignal raiseWith: errs errorString: errs first dbmsErrorString ] ].					((rc == xif SQL_SUCCESS ) or: [ rc == xif SQL_NO_DATA_FOUND ])						ifTrue: ["All the data for the receiver has been received. 								There is no null terminator since this is a complete, final chunk.								Ensure that we don't copy more than maxBytesToCopy."								chunkSize := pcbValue contents.								pcbValue contents: (maxBytesToCopy min: chunkSize).								isDone := true. ]						ifFalse: [ copyIndex := copyIndex + chunkSize.									isDone := copyIndex &gt;= maxBytesToCopy].					"Convert the data chunk to an appropriate object using superclass methods, and add it."					chunkCollection add: super value].	chunkCollection size &gt; 1		ifTrue: ["if more than one chunk, merge all the chunks into one large object"			self coalesce: chunkCollection]		ifFalse: [bufferValue := chunkCollection at: 1].	^bufferValue</body></methods><methods><class-id>Database.ODBCLargeObjectBuffer</class-id> <category>initialize-release</category><body package="ODBCEXDI">on: aLargeObjectHolder position: position session: session	"Initialize an instance of receiver which is set up to hold aValue." 	| maxValue |	count := 0.	ibScale := 0.     	databaseType := session conversionFor: aLargeObjectHolder  at: position.	databaseType == #Array ifTrue: [ 		maxValue := self findMaxValue: aLargeObjectHolder.		databaseType := session conversionFor: maxValue at: position.		count := aLargeObjectHolder size	] ifFalse: [		maxValue := aLargeObjectHolder.		count := 0.	].	bufferIndex := position.	bufferSession := session.	bufferValue := aLargeObjectHolder.	self encoding: session encoding.	self isUnicodeColumn: false.	self unicode: false.	bufferSession unicode		ifTrue: [self unicode: bufferSession unicode]		ifFalse: [bufferSession bindTemplate isNil ifFalse:			[(bufferSession bindTemplate at: (bufferSession bindMarkerAtPosition: position))				== #UnicodeString ifTrue:					[self isUnicodeColumn: true.					self unicode: true]]].			((databaseType == #String) or: [ databaseType == #LargeString ])		ifTrue: [ | encodedString |					encodedString := maxValue asByteArrayEncoding: self encoding.					cbValueMax := (self session lobBufferSize min: encodedString size) + 1.					cbColDef := (ValuePrecisionBlocks at: databaseType) value: encodedString ] 		ifFalse: [					cbValueMax := self session lobBufferSize min: maxValue size.					cbColDef := (ValuePrecisionBlocks at: databaseType) value: maxValue ].	getSelector := GetSelectorMap at: databaseType ifAbsent: [nil].	putSelector := PutSelectorMap at: databaseType ifAbsent: [nil].</body></methods><methods><class-id>Database.UnableToGetStatementOptions</class-id> <category>printing</category><body package="ODBCEXDI">defaultMessageText	^(#errGetStatementOptions &lt;&lt; #odbcDB &gt;&gt; 'Unable to get the statement option') asString</body></methods><methods><class-id>Database.ODBCError</class-id> <category>accessing</category><body package="ODBCEXDI">sqlState	^sqlState</body><body package="ODBCEXDI">sqlState: anInteger	sqlState := anInteger</body></methods><methods><class-id>Database.UnableToSetConnectionOptions</class-id> <category>printing</category><body package="ODBCEXDI">defaultMessageText	^(#errSetConnectionOptions &lt;&lt; #odbcDB &gt;&gt; 'Unable to set the connection option') asString</body></methods><methods><class-id>Core.Integer</class-id> <category>private-odbc</category><body package="ODBCEXDI">odbcConversion	"Answer the symbolic conversion name for instances of this 	class or subclasses."	^ObjectMemory is64Bit		ifTrue: 			[(self &gt;= -536870912 and: [self &lt;= 536870911])				ifTrue: [#Integer]				ifFalse: [#LargeInteger]]		ifFalse: [#Integer]</body></methods><methods><class-id>Core.WordArray</class-id> <category>private-odbc</category><body package="ODBCEXDI">odbcConversion	"Answer the symbolic conversion name for instances of this 	class or subclasses."	^#WordArray</body></methods><methods><class-id>Core.Object</class-id> <category>private-odbc</category><body package="ODBCEXDI">odbcConversion	"Answer the symbolic conversion name for instances of this 	class or subclasses.  The default is no conversion is defined"	^nil</body></methods><methods><class-id>Core.String</class-id> <category>private-odbc</category><body package="ODBCEXDI">asBooleanForODBC	"Try to interpret the string as a Boolean using a common Cobol paradigm.  Treat the value as null if it doesn't match the encoded value for true or false."	self size == 1 ifTrue:		[ self = 'Y' ifTrue: [ ^true ].		self = 'N' ifTrue: [ ^false ] ].	^nil</body></methods><methods><class-id>Core.Character</class-id> <category>private-odbc</category><body package="ODBCEXDI">odbcConversion	^#String</body></methods><methods><class-id>Core.FixedPoint</class-id> <category>private-odbc</category><body package="ODBCEXDI">odbcConversion	"Answer the symbolic conversion name for instances of this 	class or subclasses."	^#FixedPoint</body></methods><methods><class-id>Core.ByteArray</class-id> <category>private-odbc</category><body package="ODBCEXDI">odbcConversion	"Answer the symbolic conversion name for instances of this 	class or subclasses."	self size &gt; 255 ifTrue: [^#LargeByteArray].	^#ByteArray</body></methods><methods><class-id>OS.BufferedExternalStream</class-id> <category>private-odbc</category><body package="ODBCEXDI">odbcConversion	^self isBinary 		  ifTrue: [^#LargeByteArray  ]		  ifFalse: [^#LargeString  ]</body></methods><methods><class-id>Core.LargeInteger</class-id> <category>private-odbc</category><body package="ODBCEXDI">odbcConversion	"Answer the symbolic conversion name for instances of this 	class or subclasses."	^#LargeInteger</body></methods><methods><class-id>Core.EncodedStream</class-id> <category>private-odbc</category><body package="ODBCEXDI">odbcConversion	^((self binary )		ifTrue: [ #BinaryStream ]		ifFalse: [ #CharacterStream ])</body></methods><methods><class-id>Core.Double</class-id> <category>private-odbc</category><body package="ODBCEXDI">odbcConversion	"Answer the symbolic conversion name for instances of this 	class or subclasses."	^#Double</body></methods><methods><class-id>Core.Timestamp</class-id> <category>private-odbc</category><body package="ODBCEXDI">odbcConversion	"Answer the symbolic conversion name for instances of this class 	or subclasses."	^#Timestamp</body></methods><methods><class-id>Core.SmallDouble</class-id> <category>private-odbc</category><body package="ODBCEXDI">odbcConversion	"Answer the symbolic conversion name for instances of this 	class or subclasses."	^#Double</body></methods><methods><class-id>Core.Boolean</class-id> <category>private-odbc</category><body package="ODBCEXDI">odbcConversion	"Answer the symbolic conversion name for instances of this 	class or subclasses."	^#Boolean</body><body package="ODBCEXDI">printStringForODBC	"Encode receiver in one character using a common Cobol paradigm."	^self ifTrue: [ 'Y' ] ifFalse: [ 'N' ]</body></methods><methods><class-id>Core.Time</class-id> <category>private-odbc</category><body package="ODBCEXDI">odbcConversion	"Answer the symbolic conversion name for instances of this 	class or subclasses."	^#Time</body></methods><methods><class-id>Core.Random</class-id> <category>private-odbc</category><body package="ODBCEXDI">odbcConversion	^#BinaryStream</body></methods><methods><class-id>Core.Float</class-id> <category>private-odbc</category><body package="ODBCEXDI">odbcConversion	"Answer the symbolic conversion name for instances of this 	class or subclasses."	^#Float</body></methods><methods><class-id>Core.PositionableStream</class-id> <category>private-odbc</category><body package="ODBCEXDI">odbcConversion	(collection isKindOf: ByteArray )		ifTrue: [^#LargeByteArray  ].	(collection isKindOf: CharacterArray )		ifTrue: [^#LargeString ].	self error: 'The receiver does not have an appropriate ODBC conversion type.'</body></methods><methods><class-id>Core.Date</class-id> <category>private-odbc</category><body package="ODBCEXDI">odbcConversion	"Answer the symbolic conversion name for instances of this 	class or subclasses."	^#Date</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>private-odbc</category><body package="ODBCEXDI">odbcConversion	"Answer the symbolic conversion name for instances of this 	class or subclasses."	self size &gt; 255 ifTrue: [^#LargeString].	^#String</body></methods><methods><class-id>Core.Array</class-id> <category>private-odbc</category><body package="ODBCEXDI">odbcConversion	^#Array</body></methods><methods><class-id>Database.ODBCCLIInterface</class-id> <category>defines</category><body package="ODBCEXDI">EXPORT	&lt;C: #define EXPORT _export	&gt;</body><body package="ODBCEXDI">FAR	&lt;C: #define FAR 	&gt;</body><body package="ODBCEXDI">ODBCVER	&lt;C: #define ODBCVER 528	&gt;</body><body package="ODBCEXDI">SQL_AA_FALSE	&lt;C: #define SQL_AA_FALSE 0	&gt;</body><body package="ODBCEXDI">SQL_AA_TRUE	&lt;C: #define SQL_AA_TRUE 1	&gt;</body><body package="ODBCEXDI">SQL_ACCESSIBLE_PROCEDURES	&lt;C: #define SQL_ACCESSIBLE_PROCEDURES 20	&gt;</body><body package="ODBCEXDI">SQL_ACCESSIBLE_TABLES	&lt;C: #define SQL_ACCESSIBLE_TABLES 19	&gt;</body><body package="ODBCEXDI">SQL_ACCESS_MODE	&lt;C: #define SQL_ACCESS_MODE 101	&gt;</body><body package="ODBCEXDI">SQL_ACTIVE_CONNECTIONS	&lt;C: #define SQL_ACTIVE_CONNECTIONS 0	&gt;</body><body package="ODBCEXDI">SQL_ACTIVE_STATEMENTS	&lt;C: #define SQL_ACTIVE_STATEMENTS 1	&gt;</body><body package="ODBCEXDI">SQL_ADD	&lt;C: #define SQL_ADD 4	&gt;</body><body package="ODBCEXDI">SQL_ALL_EXCEPT_LIKE	&lt;C: #define SQL_ALL_EXCEPT_LIKE 2	&gt;</body><body package="ODBCEXDI">SQL_ALL_TYPES	&lt;C: #define SQL_ALL_TYPES 0	&gt;</body><body package="ODBCEXDI">SQL_ALTER_TABLE	&lt;C: #define SQL_ALTER_TABLE 86	&gt;</body><body package="ODBCEXDI">SQL_API	&lt;C: #define SQL_API 	&gt;</body><body package="ODBCEXDI">SQL_API_ALL_FUNCTIONS	&lt;C: #define SQL_API_ALL_FUNCTIONS 0	&gt;</body><body package="ODBCEXDI">SQL_API_LOADBYORDINAL	&lt;C: #define SQL_API_LOADBYORDINAL 199	&gt;</body><body package="ODBCEXDI">SQL_API_SQLALLOCCONNECT	&lt;C: #define SQL_API_SQLALLOCCONNECT 1	&gt;</body><body package="ODBCEXDI">SQL_API_SQLALLOCENV	&lt;C: #define SQL_API_SQLALLOCENV 2	&gt;</body><body package="ODBCEXDI">SQL_API_SQLALLOCSTMT	&lt;C: #define SQL_API_SQLALLOCSTMT 3	&gt;</body><body package="ODBCEXDI">SQL_API_SQLBINDCOL	&lt;C: #define SQL_API_SQLBINDCOL 4	&gt;</body><body package="ODBCEXDI">SQL_API_SQLBINDPARAMETER	&lt;C: #define SQL_API_SQLBINDPARAMETER 72	&gt;</body><body package="ODBCEXDI">SQL_API_SQLBROWSECONNECT	&lt;C: #define SQL_API_SQLBROWSECONNECT 55	&gt;</body><body package="ODBCEXDI">SQL_API_SQLCANCEL	&lt;C: #define SQL_API_SQLCANCEL 5	&gt;</body><body package="ODBCEXDI">SQL_API_SQLCOLATTRIBUTES	&lt;C: #define SQL_API_SQLCOLATTRIBUTES 6	&gt;</body><body package="ODBCEXDI">SQL_API_SQLCOLUMNPRIVILEGES	&lt;C: #define SQL_API_SQLCOLUMNPRIVILEGES 56	&gt;</body><body package="ODBCEXDI">SQL_API_SQLCOLUMNS	&lt;C: #define SQL_API_SQLCOLUMNS 40	&gt;</body><body package="ODBCEXDI">SQL_API_SQLCONNECT	&lt;C: #define SQL_API_SQLCONNECT 7	&gt;</body><body package="ODBCEXDI">SQL_API_SQLDATASOURCES	&lt;C: #define SQL_API_SQLDATASOURCES 57	&gt;</body><body package="ODBCEXDI">SQL_API_SQLDESCRIBECOL	&lt;C: #define SQL_API_SQLDESCRIBECOL 8	&gt;</body><body package="ODBCEXDI">SQL_API_SQLDESCRIBEPARAM	&lt;C: #define SQL_API_SQLDESCRIBEPARAM 58	&gt;</body><body package="ODBCEXDI">SQL_API_SQLDISCONNECT	&lt;C: #define SQL_API_SQLDISCONNECT 9	&gt;</body><body package="ODBCEXDI">SQL_API_SQLDRIVERCONNECT	&lt;C: #define SQL_API_SQLDRIVERCONNECT 41	&gt;</body><body package="ODBCEXDI">SQL_API_SQLDRIVERS	&lt;C: #define SQL_API_SQLDRIVERS 71	&gt;</body><body package="ODBCEXDI">SQL_API_SQLERROR	&lt;C: #define SQL_API_SQLERROR 10	&gt;</body><body package="ODBCEXDI">SQL_API_SQLEXECDIRECT	&lt;C: #define SQL_API_SQLEXECDIRECT 11	&gt;</body><body package="ODBCEXDI">SQL_API_SQLEXECUTE	&lt;C: #define SQL_API_SQLEXECUTE 12	&gt;</body><body package="ODBCEXDI">SQL_API_SQLEXTENDEDFETCH	&lt;C: #define SQL_API_SQLEXTENDEDFETCH 59	&gt;</body><body package="ODBCEXDI">SQL_API_SQLFETCH	&lt;C: #define SQL_API_SQLFETCH 13	&gt;</body><body package="ODBCEXDI">SQL_API_SQLFOREIGNKEYS	&lt;C: #define SQL_API_SQLFOREIGNKEYS 60	&gt;</body><body package="ODBCEXDI">SQL_API_SQLFREECONNECT	&lt;C: #define SQL_API_SQLFREECONNECT 14	&gt;</body><body package="ODBCEXDI">SQL_API_SQLFREEENV	&lt;C: #define SQL_API_SQLFREEENV 15	&gt;</body><body package="ODBCEXDI">SQL_API_SQLFREESTMT	&lt;C: #define SQL_API_SQLFREESTMT 16	&gt;</body><body package="ODBCEXDI">SQL_API_SQLGETCONNECTOPTION	&lt;C: #define SQL_API_SQLGETCONNECTOPTION 42	&gt;</body><body package="ODBCEXDI">SQL_API_SQLGETCURSORNAME	&lt;C: #define SQL_API_SQLGETCURSORNAME 17	&gt;</body><body package="ODBCEXDI">SQL_API_SQLGETDATA	&lt;C: #define SQL_API_SQLGETDATA 43	&gt;</body><body package="ODBCEXDI">SQL_API_SQLGETFUNCTIONS	&lt;C: #define SQL_API_SQLGETFUNCTIONS 44	&gt;</body><body package="ODBCEXDI">SQL_API_SQLGETINFO	&lt;C: #define SQL_API_SQLGETINFO 45	&gt;</body><body package="ODBCEXDI">SQL_API_SQLGETSTMTOPTION	&lt;C: #define SQL_API_SQLGETSTMTOPTION 46	&gt;</body><body package="ODBCEXDI">SQL_API_SQLGETTYPEINFO	&lt;C: #define SQL_API_SQLGETTYPEINFO 47	&gt;</body><body package="ODBCEXDI">SQL_API_SQLMORERESULTS	&lt;C: #define SQL_API_SQLMORERESULTS 61	&gt;</body><body package="ODBCEXDI">SQL_API_SQLNATIVESQL	&lt;C: #define SQL_API_SQLNATIVESQL 62	&gt;</body><body package="ODBCEXDI">SQL_API_SQLNUMPARAMS	&lt;C: #define SQL_API_SQLNUMPARAMS 63	&gt;</body><body package="ODBCEXDI">SQL_API_SQLNUMRESULTCOLS	&lt;C: #define SQL_API_SQLNUMRESULTCOLS 18	&gt;</body><body package="ODBCEXDI">SQL_API_SQLPARAMDATA	&lt;C: #define SQL_API_SQLPARAMDATA 48	&gt;</body><body package="ODBCEXDI">SQL_API_SQLPARAMOPTIONS	&lt;C: #define SQL_API_SQLPARAMOPTIONS 64	&gt;</body><body package="ODBCEXDI">SQL_API_SQLPREPARE	&lt;C: #define SQL_API_SQLPREPARE 19	&gt;</body><body package="ODBCEXDI">SQL_API_SQLPRIMARYKEYS	&lt;C: #define SQL_API_SQLPRIMARYKEYS 65	&gt;</body><body package="ODBCEXDI">SQL_API_SQLPROCEDURECOLUMNS	&lt;C: #define SQL_API_SQLPROCEDURECOLUMNS 66	&gt;</body><body package="ODBCEXDI">SQL_API_SQLPROCEDURES	&lt;C: #define SQL_API_SQLPROCEDURES 67	&gt;</body><body package="ODBCEXDI">SQL_API_SQLPUTDATA	&lt;C: #define SQL_API_SQLPUTDATA 49	&gt;</body><body package="ODBCEXDI">SQL_API_SQLROWCOUNT	&lt;C: #define SQL_API_SQLROWCOUNT 20	&gt;</body><body package="ODBCEXDI">SQL_API_SQLSETCONNECTOPTION	&lt;C: #define SQL_API_SQLSETCONNECTOPTION 50	&gt;</body><body package="ODBCEXDI">SQL_API_SQLSETCURSORNAME	&lt;C: #define SQL_API_SQLSETCURSORNAME 21	&gt;</body><body package="ODBCEXDI">SQL_API_SQLSETPARAM	&lt;C: #define SQL_API_SQLSETPARAM 22	&gt;</body><body package="ODBCEXDI">SQL_API_SQLSETPOS	&lt;C: #define SQL_API_SQLSETPOS 68	&gt;</body><body package="ODBCEXDI">SQL_API_SQLSETSCROLLOPTIONS	&lt;C: #define SQL_API_SQLSETSCROLLOPTIONS 69	&gt;</body><body package="ODBCEXDI">SQL_API_SQLSETSTMTOPTION	&lt;C: #define SQL_API_SQLSETSTMTOPTION 51	&gt;</body><body package="ODBCEXDI">SQL_API_SQLSPECIALCOLUMNS	&lt;C: #define SQL_API_SQLSPECIALCOLUMNS 52	&gt;</body><body package="ODBCEXDI">SQL_API_SQLSTATISTICS	&lt;C: #define SQL_API_SQLSTATISTICS 53	&gt;</body><body package="ODBCEXDI">SQL_API_SQLTABLEPRIVILEGES	&lt;C: #define SQL_API_SQLTABLEPRIVILEGES 70	&gt;</body><body package="ODBCEXDI">SQL_API_SQLTABLES	&lt;C: #define SQL_API_SQLTABLES 54	&gt;</body><body package="ODBCEXDI">SQL_API_SQLTRANSACT	&lt;C: #define SQL_API_SQLTRANSACT 23	&gt;</body><body package="ODBCEXDI">SQL_ASYNC_ENABLE	&lt;C: #define SQL_ASYNC_ENABLE 4	&gt;</body><body package="ODBCEXDI">SQL_ASYNC_ENABLE_DEFAULT	&lt;C: #define SQL_ASYNC_ENABLE_DEFAULT SQL_ASYNC_ENABLE_OFF	&gt;</body><body package="ODBCEXDI">SQL_ASYNC_ENABLE_OFF	&lt;C: #define SQL_ASYNC_ENABLE_OFF 0L	&gt;</body><body package="ODBCEXDI">SQL_ASYNC_ENABLE_ON	&lt;C: #define SQL_ASYNC_ENABLE_ON 1L	&gt;</body><body package="ODBCEXDI">SQL_ATTR_ANSI_APP	&lt;C: #define SQL_ATTR_ANSI_APP 115	&gt;</body><body package="ODBCEXDI">SQL_ATTR_CONNECTION_POOLING	&lt;C: #define SQL_ATTR_CONNECTION_POOLING 201	&gt;</body><body package="ODBCEXDI">SQL_ATTR_CP_MATCH	&lt;C: #define SQL_ATTR_CP_MATCH 202	&gt;</body><body package="ODBCEXDI">SQL_ATTR_ODBC_VERSION	&lt;C: #define SQL_ATTR_ODBC_VERSION 200	&gt;</body><body package="ODBCEXDI">SQL_ATTR_PARAMSET_SIZE	&lt;C: #define SQL_ATTR_PARAMSET_SIZE 22	&gt;</body><body package="ODBCEXDI">SQL_ATTR_PARAMS_PROCESSED_PTR	&lt;C: #define SQL_ATTR_PARAMS_PROCESSED_PTR 21	&gt;</body><body package="ODBCEXDI">SQL_ATTR_PARAM_BIND_TYPE	&lt;C: #define SQL_ATTR_PARAM_BIND_TYPE 18	&gt;</body><body package="ODBCEXDI">SQL_ATTR_PARAM_OPERATION_PTR	&lt;C: #define SQL_ATTR_PARAM_OPERATION_PTR 19	&gt;</body><body package="ODBCEXDI">SQL_ATTR_PARAM_STATUS_PTR	&lt;C: #define SQL_ATTR_PARAM_STATUS_PTR 20	&gt;</body><body package="ODBCEXDI">SQL_ATTR_READONLY	&lt;C: #define SQL_ATTR_READONLY 0	&gt;</body><body package="ODBCEXDI">SQL_ATTR_READWRITE_UNKNOWN	&lt;C: #define SQL_ATTR_READWRITE_UNKNOWN 2	&gt;</body><body package="ODBCEXDI">SQL_ATTR_ROW_ARRAY_SIZE	&lt;C: #define SQL_ATTR_ROW_ARRAY_SIZE 27	&gt;</body><body package="ODBCEXDI">SQL_ATTR_ROW_BIND_TYPE	&lt;C: #define SQL_ATTR_ROW_BIND_TYPE SQL_BIND_TYPE	&gt;</body><body package="ODBCEXDI">SQL_ATTR_WRITE	&lt;C: #define SQL_ATTR_WRITE 1	&gt;</body><body package="ODBCEXDI">SQL_AT_ADD_COLUMN	&lt;C: #define SQL_AT_ADD_COLUMN 0x00000001	&gt;</body><body package="ODBCEXDI">SQL_AT_DROP_COLUMN	&lt;C: #define SQL_AT_DROP_COLUMN 0x00000002	&gt;</body><body package="ODBCEXDI">SQL_AUTOCOMMIT	&lt;C: #define SQL_AUTOCOMMIT 102	&gt;</body><body package="ODBCEXDI">SQL_AUTOCOMMIT_DEFAULT	&lt;C: #define SQL_AUTOCOMMIT_DEFAULT SQL_AUTOCOMMIT_ON	&gt;</body><body package="ODBCEXDI">SQL_AUTOCOMMIT_OFF	&lt;C: #define SQL_AUTOCOMMIT_OFF 0L	&gt;</body><body package="ODBCEXDI">SQL_AUTOCOMMIT_ON	&lt;C: #define SQL_AUTOCOMMIT_ON 1L	&gt;</body><body package="ODBCEXDI">SQL_BEST_ROWID	&lt;C: #define SQL_BEST_ROWID 1	&gt;</body><body package="ODBCEXDI">SQL_BIGINT	&lt;C: #define SQL_BIGINT (-5)	&gt;</body><body package="ODBCEXDI">SQL_BINARY	&lt;C: #define SQL_BINARY (-2)	&gt;</body><body package="ODBCEXDI">SQL_BIND_BY_COLUMN	&lt;C: #define SQL_BIND_BY_COLUMN 0L	&gt;</body><body package="ODBCEXDI">SQL_BIND_TYPE	&lt;C: #define SQL_BIND_TYPE 5	&gt;</body><body package="ODBCEXDI">SQL_BIND_TYPE_DEFAULT	&lt;C: #define SQL_BIND_TYPE_DEFAULT SQL_BIND_BY_COLUMN	&gt;</body><body package="ODBCEXDI">SQL_BIT	&lt;C: #define SQL_BIT (-7)	&gt;</body><body package="ODBCEXDI">SQL_BLOB	&lt;C: #define SQL_BLOB -98	&gt;</body><body package="ODBCEXDI">SQL_BOOKMARK_PERSISTENCE	&lt;C: #define SQL_BOOKMARK_PERSISTENCE 82	&gt;</body><body package="ODBCEXDI">SQL_BP_CLOSE	&lt;C: #define SQL_BP_CLOSE 0x00000001	&gt;</body><body package="ODBCEXDI">SQL_BP_DELETE	&lt;C: #define SQL_BP_DELETE 0x00000002	&gt;</body><body package="ODBCEXDI">SQL_BP_DROP	&lt;C: #define SQL_BP_DROP 0x00000004	&gt;</body><body package="ODBCEXDI">SQL_BP_OTHER_HSTMT	&lt;C: #define SQL_BP_OTHER_HSTMT 0x00000020	&gt;</body><body package="ODBCEXDI">SQL_BP_SCROLL	&lt;C: #define SQL_BP_SCROLL 0x00000040	&gt;</body><body package="ODBCEXDI">SQL_BP_TRANSACTION	&lt;C: #define SQL_BP_TRANSACTION 0x00000008	&gt;</body><body package="ODBCEXDI">SQL_BP_UPDATE	&lt;C: #define SQL_BP_UPDATE 0x00000010	&gt;</body><body package="ODBCEXDI">SQL_CASCADE	&lt;C: #define SQL_CASCADE 0	&gt;</body><body package="ODBCEXDI">SQL_CB_CLOSE	&lt;C: #define SQL_CB_CLOSE 0x0001	&gt;</body><body package="ODBCEXDI">SQL_CB_DELETE	&lt;C: #define SQL_CB_DELETE 0x0000	&gt;</body><body package="ODBCEXDI">SQL_CB_NON_NULL	&lt;C: #define SQL_CB_NON_NULL 0x0001	&gt;</body><body package="ODBCEXDI">SQL_CB_NULL	&lt;C: #define SQL_CB_NULL 0x0000	&gt;</body><body package="ODBCEXDI">SQL_CB_PRESERVE	&lt;C: #define SQL_CB_PRESERVE 0x0002	&gt;</body><body package="ODBCEXDI">SQL_CC_CLOSE	&lt;C: #define SQL_CC_CLOSE SQL_CB_CLOSE	&gt;</body><body package="ODBCEXDI">SQL_CC_DELETE	&lt;C: #define SQL_CC_DELETE SQL_CB_DELETE	&gt;</body><body package="ODBCEXDI">SQL_CC_PRESERVE	&lt;C: #define SQL_CC_PRESERVE SQL_CB_PRESERVE	&gt;</body><body package="ODBCEXDI">SQL_CHAR	&lt;C: #define SQL_CHAR 1	&gt;</body><body package="ODBCEXDI">SQL_CLOB	&lt;C: #define SQL_CLOB -99	&gt;</body><body package="ODBCEXDI">SQL_CLOSE	&lt;C: #define SQL_CLOSE 0	&gt;</body><body package="ODBCEXDI">SQL_CN_ANY	&lt;C: #define SQL_CN_ANY 0x0002	&gt;</body><body package="ODBCEXDI">SQL_CN_DIFFERENT	&lt;C: #define SQL_CN_DIFFERENT 0x0001	&gt;</body><body package="ODBCEXDI">SQL_CN_NONE	&lt;C: #define SQL_CN_NONE 0x0000	&gt;</body><body package="ODBCEXDI">SQL_COLATT_OPT_MAX	&lt;C: #define SQL_COLATT_OPT_MAX SQL_COLUMN_LABEL	&gt;</body><body package="ODBCEXDI">SQL_COLATT_OPT_MIN	&lt;C: #define SQL_COLATT_OPT_MIN SQL_COLUMN_COUNT	&gt;</body><body package="ODBCEXDI">SQL_COLUMN_ALIAS	&lt;C: #define SQL_COLUMN_ALIAS 87	&gt;</body><body package="ODBCEXDI">SQL_COLUMN_AUTO_INCREMENT	&lt;C: #define SQL_COLUMN_AUTO_INCREMENT 11	&gt;</body><body package="ODBCEXDI">SQL_COLUMN_CASE_SENSITIVE	&lt;C: #define SQL_COLUMN_CASE_SENSITIVE 12	&gt;</body><body package="ODBCEXDI">SQL_COLUMN_COUNT	&lt;C: #define SQL_COLUMN_COUNT 0	&gt;</body><body package="ODBCEXDI">SQL_COLUMN_DISPLAY_SIZE	&lt;C: #define SQL_COLUMN_DISPLAY_SIZE 6	&gt;</body><body package="ODBCEXDI">SQL_COLUMN_DRIVER_START	&lt;C: #define SQL_COLUMN_DRIVER_START 1000	&gt;</body><body package="ODBCEXDI">SQL_COLUMN_LABEL	&lt;C: #define SQL_COLUMN_LABEL 18	&gt;</body><body package="ODBCEXDI">SQL_COLUMN_LENGTH	&lt;C: #define SQL_COLUMN_LENGTH 3	&gt;</body><body package="ODBCEXDI">SQL_COLUMN_MONEY	&lt;C: #define SQL_COLUMN_MONEY 9	&gt;</body><body package="ODBCEXDI">SQL_COLUMN_NAME	&lt;C: #define SQL_COLUMN_NAME 1	&gt;</body><body package="ODBCEXDI">SQL_COLUMN_NULLABLE	&lt;C: #define SQL_COLUMN_NULLABLE 7	&gt;</body><body package="ODBCEXDI">SQL_COLUMN_OWNER_NAME	&lt;C: #define SQL_COLUMN_OWNER_NAME 16	&gt;</body><body package="ODBCEXDI">SQL_COLUMN_PRECISION	&lt;C: #define SQL_COLUMN_PRECISION 4	&gt;</body><body package="ODBCEXDI">SQL_COLUMN_QUALIFIER_NAME	&lt;C: #define SQL_COLUMN_QUALIFIER_NAME 17	&gt;</body><body package="ODBCEXDI">SQL_COLUMN_SCALE	&lt;C: #define SQL_COLUMN_SCALE 5	&gt;</body><body package="ODBCEXDI">SQL_COLUMN_SEARCHABLE	&lt;C: #define SQL_COLUMN_SEARCHABLE 13	&gt;</body><body package="ODBCEXDI">SQL_COLUMN_TABLE_NAME	&lt;C: #define SQL_COLUMN_TABLE_NAME 15	&gt;</body><body package="ODBCEXDI">SQL_COLUMN_TYPE	&lt;C: #define SQL_COLUMN_TYPE 2	&gt;</body><body package="ODBCEXDI">SQL_COLUMN_TYPE_NAME	&lt;C: #define SQL_COLUMN_TYPE_NAME 14	&gt;</body><body package="ODBCEXDI">SQL_COLUMN_UNSIGNED	&lt;C: #define SQL_COLUMN_UNSIGNED 8	&gt;</body><body package="ODBCEXDI">SQL_COLUMN_UPDATABLE	&lt;C: #define SQL_COLUMN_UPDATABLE 10	&gt;</body><body package="ODBCEXDI">SQL_COMMIT	&lt;C: #define SQL_COMMIT 0	&gt;</body><body package="ODBCEXDI">SQL_CONCAT_NULL_BEHAVIOR	&lt;C: #define SQL_CONCAT_NULL_BEHAVIOR 22	&gt;</body><body package="ODBCEXDI">SQL_CONCURRENCY	&lt;C: #define SQL_CONCURRENCY 7	&gt;</body><body package="ODBCEXDI">SQL_CONCUR_DEFAULT	&lt;C: #define SQL_CONCUR_DEFAULT SQL_CONCUR_READ_ONLY	&gt;</body><body package="ODBCEXDI">SQL_CONCUR_LOCK	&lt;C: #define SQL_CONCUR_LOCK 2	&gt;</body><body package="ODBCEXDI">SQL_CONCUR_READ_ONLY	&lt;C: #define SQL_CONCUR_READ_ONLY 1	&gt;</body><body package="ODBCEXDI">SQL_CONCUR_ROWVER	&lt;C: #define SQL_CONCUR_ROWVER 3	&gt;</body><body package="ODBCEXDI">SQL_CONCUR_TIMESTAMP	&lt;C: #define SQL_CONCUR_TIMESTAMP SQL_CONCUR_ROWVER	&gt;</body><body package="ODBCEXDI">SQL_CONCUR_VALUES	&lt;C: #define SQL_CONCUR_VALUES 4	&gt;</body><body package="ODBCEXDI">SQL_CONNECT_OPT_DRVR_START	&lt;C: #define SQL_CONNECT_OPT_DRVR_START 1000	&gt;</body><body package="ODBCEXDI">SQL_CONN_OPT_MAX	&lt;C: #define SQL_CONN_OPT_MAX SQL_PACKET_SIZE	&gt;</body><body package="ODBCEXDI">SQL_CONN_OPT_MIN	&lt;C: #define SQL_CONN_OPT_MIN SQL_ACCESS_MODE	&gt;</body><body package="ODBCEXDI">SQL_CONVERT_BIGINT	&lt;C: #define SQL_CONVERT_BIGINT 53	&gt;</body><body package="ODBCEXDI">SQL_CONVERT_BINARY	&lt;C: #define SQL_CONVERT_BINARY 54	&gt;</body><body package="ODBCEXDI">SQL_CONVERT_BIT	&lt;C: #define SQL_CONVERT_BIT 55	&gt;</body><body package="ODBCEXDI">SQL_CONVERT_CHAR	&lt;C: #define SQL_CONVERT_CHAR 56	&gt;</body><body package="ODBCEXDI">SQL_CONVERT_DATE	&lt;C: #define SQL_CONVERT_DATE 57	&gt;</body><body package="ODBCEXDI">SQL_CONVERT_DECIMAL	&lt;C: #define SQL_CONVERT_DECIMAL 58	&gt;</body><body package="ODBCEXDI">SQL_CONVERT_DOUBLE	&lt;C: #define SQL_CONVERT_DOUBLE 59	&gt;</body><body package="ODBCEXDI">SQL_CONVERT_FLOAT	&lt;C: #define SQL_CONVERT_FLOAT 60	&gt;</body><body package="ODBCEXDI">SQL_CONVERT_FUNCTIONS	&lt;C: #define SQL_CONVERT_FUNCTIONS 48	&gt;</body><body package="ODBCEXDI">SQL_CONVERT_INTEGER	&lt;C: #define SQL_CONVERT_INTEGER 61	&gt;</body><body package="ODBCEXDI">SQL_CONVERT_LONGVARBINARY	&lt;C: #define SQL_CONVERT_LONGVARBINARY 71	&gt;</body><body package="ODBCEXDI">SQL_CONVERT_LONGVARCHAR	&lt;C: #define SQL_CONVERT_LONGVARCHAR 62	&gt;</body><body package="ODBCEXDI">SQL_CONVERT_NUMERIC	&lt;C: #define SQL_CONVERT_NUMERIC 63	&gt;</body><body package="ODBCEXDI">SQL_CONVERT_REAL	&lt;C: #define SQL_CONVERT_REAL 64	&gt;</body><body package="ODBCEXDI">SQL_CONVERT_SMALLINT	&lt;C: #define SQL_CONVERT_SMALLINT 65	&gt;</body><body package="ODBCEXDI">SQL_CONVERT_TIME	&lt;C: #define SQL_CONVERT_TIME 66	&gt;</body><body package="ODBCEXDI">SQL_CONVERT_TIMESTAMP	&lt;C: #define SQL_CONVERT_TIMESTAMP 67	&gt;</body><body package="ODBCEXDI">SQL_CONVERT_TINYINT	&lt;C: #define SQL_CONVERT_TINYINT 68	&gt;</body><body package="ODBCEXDI">SQL_CONVERT_VARBINARY	&lt;C: #define SQL_CONVERT_VARBINARY 69	&gt;</body><body package="ODBCEXDI">SQL_CONVERT_VARCHAR	&lt;C: #define SQL_CONVERT_VARCHAR 70	&gt;</body><body package="ODBCEXDI">SQL_COPT_SS_BASE	&lt;C: #define SQL_COPT_SS_BASE 1200	&gt;</body><body package="ODBCEXDI">SQL_COPT_SS_MARS_ENABLED	&lt;C: #define SQL_COPT_SS_MARS_ENABLED (SQL_COPT_SS_BASE+24)	&gt;</body><body package="ODBCEXDI">SQL_COPT_SS_TRANSLATE	&lt;C: #define SQL_COPT_SS_TRANSLATE (SQL_COPT_SS_BASE+20)	&gt;</body><body package="ODBCEXDI">SQL_CORRELATION_NAME	&lt;C: #define SQL_CORRELATION_NAME 74	&gt;</body><body package="ODBCEXDI">SQL_CP_DEFAULT	&lt;C: #define SQL_CP_DEFAULT SQL_CP_OFF	&gt;</body><body package="ODBCEXDI">SQL_CP_MATCH_DEFAULT	&lt;C: #define SQL_CP_MATCH_DEFAULT SQL_CP_STRICT_MATCH	&gt;</body><body package="ODBCEXDI">SQL_CP_OFF	&lt;C: #define SQL_CP_OFF 0UL	&gt;</body><body package="ODBCEXDI">SQL_CP_ONE_PER_DRIVER	&lt;C: #define SQL_CP_ONE_PER_DRIVER 1UL	&gt;</body><body package="ODBCEXDI">SQL_CP_ONE_PER_HENV	&lt;C: #define SQL_CP_ONE_PER_HENV 2UL	&gt;</body><body package="ODBCEXDI">SQL_CP_RELAXED_MATCH	&lt;C: #define SQL_CP_RELAXED_MATCH 1UL	&gt;</body><body package="ODBCEXDI">SQL_CP_STRICT_MATCH	&lt;C: #define SQL_CP_STRICT_MATCH 0UL	&gt;</body><body package="ODBCEXDI">SQL_CR_CLOSE	&lt;C: #define SQL_CR_CLOSE SQL_CB_CLOSE	&gt;</body><body package="ODBCEXDI">SQL_CR_DELETE	&lt;C: #define SQL_CR_DELETE SQL_CB_DELETE	&gt;</body><body package="ODBCEXDI">SQL_CR_PRESERVE	&lt;C: #define SQL_CR_PRESERVE SQL_CB_PRESERVE	&gt;</body><body package="ODBCEXDI">SQL_CURRENT_QUALIFIER	&lt;C: #define SQL_CURRENT_QUALIFIER 109	&gt;</body><body package="ODBCEXDI">SQL_CURSOR_COMMIT_BEHAVIOR	&lt;C: #define SQL_CURSOR_COMMIT_BEHAVIOR 23	&gt;</body><body package="ODBCEXDI">SQL_CURSOR_DYNAMIC	&lt;C: #define SQL_CURSOR_DYNAMIC 2L	&gt;</body><body package="ODBCEXDI">SQL_CURSOR_FORWARD_ONLY	&lt;C: #define SQL_CURSOR_FORWARD_ONLY 0L	&gt;</body><body package="ODBCEXDI">SQL_CURSOR_KEYSET_DRIVEN	&lt;C: #define SQL_CURSOR_KEYSET_DRIVEN 1L	&gt;</body><body package="ODBCEXDI">SQL_CURSOR_ROLLBACK_BEHAVIOR	&lt;C: #define SQL_CURSOR_ROLLBACK_BEHAVIOR 24	&gt;</body><body package="ODBCEXDI">SQL_CURSOR_STATIC	&lt;C: #define SQL_CURSOR_STATIC 3L	&gt;</body><body package="ODBCEXDI">SQL_CURSOR_TYPE	&lt;C: #define SQL_CURSOR_TYPE 6	&gt;</body><body package="ODBCEXDI">SQL_CURSOR_TYPE_DEFAULT	&lt;C: #define SQL_CURSOR_TYPE_DEFAULT SQL_CURSOR_FORWARD_ONLY	&gt;</body><body package="ODBCEXDI">SQL_CUR_DEFAULT	&lt;C: #define SQL_CUR_DEFAULT SQL_CUR_USE_DRIVER	&gt;</body><body package="ODBCEXDI">SQL_CUR_USE_DRIVER	&lt;C: #define SQL_CUR_USE_DRIVER 2L	&gt;</body><body package="ODBCEXDI">SQL_CUR_USE_IF_NEEDED	&lt;C: #define SQL_CUR_USE_IF_NEEDED 0L	&gt;</body><body package="ODBCEXDI">SQL_CUR_USE_ODBC	&lt;C: #define SQL_CUR_USE_ODBC 1L	&gt;</body><body package="ODBCEXDI">SQL_CVT_BIGINT	&lt;C: #define SQL_CVT_BIGINT 0x00004000	&gt;</body><body package="ODBCEXDI">SQL_CVT_BINARY	&lt;C: #define SQL_CVT_BINARY 0x00000400	&gt;</body><body package="ODBCEXDI">SQL_CVT_BIT	&lt;C: #define SQL_CVT_BIT 0x00001000	&gt;</body><body package="ODBCEXDI">SQL_CVT_CHAR	&lt;C: #define SQL_CVT_CHAR 0x00000001	&gt;</body><body package="ODBCEXDI">SQL_CVT_DATE	&lt;C: #define SQL_CVT_DATE 0x00008000	&gt;</body><body package="ODBCEXDI">SQL_CVT_DECIMAL	&lt;C: #define SQL_CVT_DECIMAL 0x00000004	&gt;</body><body package="ODBCEXDI">SQL_CVT_DOUBLE	&lt;C: #define SQL_CVT_DOUBLE 0x00000080	&gt;</body><body package="ODBCEXDI">SQL_CVT_FLOAT	&lt;C: #define SQL_CVT_FLOAT 0x00000020	&gt;</body><body package="ODBCEXDI">SQL_CVT_INTEGER	&lt;C: #define SQL_CVT_INTEGER 0x00000008	&gt;</body><body package="ODBCEXDI">SQL_CVT_LONGVARBINARY	&lt;C: #define SQL_CVT_LONGVARBINARY 0x00040000	&gt;</body><body package="ODBCEXDI">SQL_CVT_LONGVARCHAR	&lt;C: #define SQL_CVT_LONGVARCHAR 0x00000200	&gt;</body><body package="ODBCEXDI">SQL_CVT_NUMERIC	&lt;C: #define SQL_CVT_NUMERIC 0x00000002	&gt;</body><body package="ODBCEXDI">SQL_CVT_REAL	&lt;C: #define SQL_CVT_REAL 0x00000040	&gt;</body><body package="ODBCEXDI">SQL_CVT_SMALLINT	&lt;C: #define SQL_CVT_SMALLINT 0x00000010	&gt;</body><body package="ODBCEXDI">SQL_CVT_TIME	&lt;C: #define SQL_CVT_TIME 0x00010000	&gt;</body><body package="ODBCEXDI">SQL_CVT_TIMESTAMP	&lt;C: #define SQL_CVT_TIMESTAMP 0x00020000	&gt;</body><body package="ODBCEXDI">SQL_CVT_TINYINT	&lt;C: #define SQL_CVT_TINYINT 0x00002000	&gt;</body><body package="ODBCEXDI">SQL_CVT_VARBINARY	&lt;C: #define SQL_CVT_VARBINARY 0x00000800	&gt;</body><body package="ODBCEXDI">SQL_CVT_VARCHAR	&lt;C: #define SQL_CVT_VARCHAR 0x00000100	&gt;</body><body package="ODBCEXDI">SQL_C_BINARY	&lt;C: #define SQL_C_BINARY SQL_BINARY	&gt;</body><body package="ODBCEXDI">SQL_C_BIT	&lt;C: #define SQL_C_BIT SQL_BIT	&gt;</body><body package="ODBCEXDI">SQL_C_BOOKMARK	&lt;C: #define SQL_C_BOOKMARK SQL_C_ULONG	&gt;</body><body package="ODBCEXDI">SQL_C_CHAR	&lt;C: #define SQL_C_CHAR SQL_CHAR	&gt;</body><body package="ODBCEXDI">SQL_C_DATE	&lt;C: #define SQL_C_DATE SQL_DATE	&gt;</body><body package="ODBCEXDI">SQL_C_DEFAULT	&lt;C: #define SQL_C_DEFAULT 99	&gt;</body><body package="ODBCEXDI">SQL_C_DOUBLE	&lt;C: #define SQL_C_DOUBLE SQL_DOUBLE	&gt;</body><body package="ODBCEXDI">SQL_C_FLOAT	&lt;C: #define SQL_C_FLOAT SQL_REAL	&gt;</body><body package="ODBCEXDI">SQL_C_GUID	&lt;C: #define SQL_C_GUID SQL_GUID	&gt;</body><body package="ODBCEXDI">SQL_C_LONG	&lt;C: #define SQL_C_LONG SQL_INTEGER	&gt;</body><body package="ODBCEXDI">SQL_C_SHORT	&lt;C: #define SQL_C_SHORT SQL_SMALLINT	&gt;</body><body package="ODBCEXDI">SQL_C_SLONG	&lt;C: #define SQL_C_SLONG SQL_C_LONG+SQL_SIGNED_OFFSET	&gt;</body><body package="ODBCEXDI">SQL_C_SSHORT	&lt;C: #define SQL_C_SSHORT SQL_C_SHORT+SQL_SIGNED_OFFSET	&gt;</body><body package="ODBCEXDI">SQL_C_STINYINT	&lt;C: #define SQL_C_STINYINT SQL_TINYINT+SQL_SIGNED_OFFSET	&gt;</body><body package="ODBCEXDI">SQL_C_TIME	&lt;C: #define SQL_C_TIME SQL_TIME	&gt;</body><body package="ODBCEXDI">SQL_C_TIMESTAMP	&lt;C: #define SQL_C_TIMESTAMP SQL_TIMESTAMP	&gt;</body><body package="ODBCEXDI">SQL_C_TINYINT	&lt;C: #define SQL_C_TINYINT SQL_TINYINT	&gt;</body><body package="ODBCEXDI">SQL_C_ULONG	&lt;C: #define SQL_C_ULONG SQL_C_LONG+SQL_UNSIGNED_OFFSET	&gt;</body><body package="ODBCEXDI">SQL_C_USHORT	&lt;C: #define SQL_C_USHORT SQL_C_SHORT+SQL_UNSIGNED_OFFSET	&gt;</body><body package="ODBCEXDI">SQL_C_UTINYINT	&lt;C: #define SQL_C_UTINYINT SQL_TINYINT+SQL_UNSIGNED_OFFSET	&gt;</body><body package="ODBCEXDI">SQL_C_WCHAR	&lt;C: #define SQL_C_WCHAR SQL_WCHAR	&gt;</body><body package="ODBCEXDI">SQL_DATABASE_NAME	&lt;C: #define SQL_DATABASE_NAME 16	&gt;</body><body package="ODBCEXDI">SQL_DATA_AT_EXEC	&lt;C: #define SQL_DATA_AT_EXEC (-2)	&gt;</body><body package="ODBCEXDI">SQL_DATA_SOURCE_NAME	&lt;C: #define SQL_DATA_SOURCE_NAME 2	&gt;</body><body package="ODBCEXDI">SQL_DATA_SOURCE_READ_ONLY	&lt;C: #define SQL_DATA_SOURCE_READ_ONLY 25	&gt;</body><body package="ODBCEXDI">SQL_DATE	&lt;C: #define SQL_DATE 9	&gt;</body><body package="ODBCEXDI">SQL_DBCLOB	&lt;C: #define SQL_DBCLOB -350	&gt;</body><body package="ODBCEXDI">SQL_DBMS_NAME	&lt;C: #define SQL_DBMS_NAME 17	&gt;</body><body package="ODBCEXDI">SQL_DBMS_VER	&lt;C: #define SQL_DBMS_VER 18	&gt;</body><body package="ODBCEXDI">SQL_DECIMAL	&lt;C: #define SQL_DECIMAL 3	&gt;</body><body package="ODBCEXDI">SQL_DEFAULT_PARAM	&lt;C: #define SQL_DEFAULT_PARAM (-5)	&gt;</body><body package="ODBCEXDI">SQL_DEFAULT_TXN_ISOLATION	&lt;C: #define SQL_DEFAULT_TXN_ISOLATION 26	&gt;</body><body package="ODBCEXDI">SQL_DELETE	&lt;C: #define SQL_DELETE 3	&gt;</body><body package="ODBCEXDI">SQL_DOUBLE	&lt;C: #define SQL_DOUBLE 8	&gt;</body><body package="ODBCEXDI">SQL_DRIVER_COMPLETE	&lt;C: #define SQL_DRIVER_COMPLETE 1	&gt;</body><body package="ODBCEXDI">SQL_DRIVER_COMPLETE_REQUIRED	&lt;C: #define SQL_DRIVER_COMPLETE_REQUIRED 3	&gt;</body><body package="ODBCEXDI">SQL_DRIVER_HDBC	&lt;C: #define SQL_DRIVER_HDBC 3	&gt;</body><body package="ODBCEXDI">SQL_DRIVER_HENV	&lt;C: #define SQL_DRIVER_HENV 4	&gt;</body><body package="ODBCEXDI">SQL_DRIVER_HLIB	&lt;C: #define SQL_DRIVER_HLIB 76	&gt;</body><body package="ODBCEXDI">SQL_DRIVER_HSTMT	&lt;C: #define SQL_DRIVER_HSTMT 5	&gt;</body><body package="ODBCEXDI">SQL_DRIVER_NAME	&lt;C: #define SQL_DRIVER_NAME 6	&gt;</body><body package="ODBCEXDI">SQL_DRIVER_NOPROMPT	&lt;C: #define SQL_DRIVER_NOPROMPT 0	&gt;</body><body package="ODBCEXDI">SQL_DRIVER_ODBC_VER	&lt;C: #define SQL_DRIVER_ODBC_VER 77	&gt;</body><body package="ODBCEXDI">SQL_DRIVER_PROMPT	&lt;C: #define SQL_DRIVER_PROMPT 2	&gt;</body><body package="ODBCEXDI">SQL_DRIVER_VER	&lt;C: #define SQL_DRIVER_VER 7	&gt;</body><body package="ODBCEXDI">SQL_DROP	&lt;C: #define SQL_DROP 1	&gt;</body><body package="ODBCEXDI">SQL_ENSURE	&lt;C: #define SQL_ENSURE 1	&gt;</body><body package="ODBCEXDI">SQL_ENTIRE_ROWSET	&lt;C: #define SQL_ENTIRE_ROWSET 0	&gt;</body><body package="ODBCEXDI">SQL_ERROR	&lt;C: #define SQL_ERROR (-1)	&gt;</body><body package="ODBCEXDI">SQL_EXPRESSIONS_IN_ORDERBY	&lt;C: #define SQL_EXPRESSIONS_IN_ORDERBY 27	&gt;</body><body package="ODBCEXDI">SQL_EXT_API_LAST	&lt;C: #define SQL_EXT_API_LAST SQL_API_SQLBINDPARAMETER	&gt;</body><body package="ODBCEXDI">SQL_EXT_API_START	&lt;C: #define SQL_EXT_API_START 40	&gt;</body><body package="ODBCEXDI">SQL_FD_FETCH_ABSOLUTE	&lt;C: #define SQL_FD_FETCH_ABSOLUTE 0x00000010	&gt;</body><body package="ODBCEXDI">SQL_FD_FETCH_BOOKMARK	&lt;C: #define SQL_FD_FETCH_BOOKMARK 0x00000080	&gt;</body><body package="ODBCEXDI">SQL_FD_FETCH_FIRST	&lt;C: #define SQL_FD_FETCH_FIRST 0x00000002	&gt;</body><body package="ODBCEXDI">SQL_FD_FETCH_LAST	&lt;C: #define SQL_FD_FETCH_LAST 0x00000004	&gt;</body><body package="ODBCEXDI">SQL_FD_FETCH_NEXT	&lt;C: #define SQL_FD_FETCH_NEXT 0x00000001	&gt;</body><body package="ODBCEXDI">SQL_FD_FETCH_PREV	&lt;C: #define SQL_FD_FETCH_PREV SQL_FD_FETCH_PRIOR	&gt;</body><body package="ODBCEXDI">SQL_FD_FETCH_PRIOR	&lt;C: #define SQL_FD_FETCH_PRIOR 0x00000008	&gt;</body><body package="ODBCEXDI">SQL_FD_FETCH_RELATIVE	&lt;C: #define SQL_FD_FETCH_RELATIVE 0x00000020	&gt;</body><body package="ODBCEXDI">SQL_FD_FETCH_RESUME	&lt;C: #define SQL_FD_FETCH_RESUME 0x00000040	&gt;</body><body package="ODBCEXDI">SQL_FETCH_ABSOLUTE	&lt;C: #define SQL_FETCH_ABSOLUTE 5	&gt;</body><body package="ODBCEXDI">SQL_FETCH_BOOKMARK	&lt;C: #define SQL_FETCH_BOOKMARK 8	&gt;</body><body package="ODBCEXDI">SQL_FETCH_DIRECTION	&lt;C: #define SQL_FETCH_DIRECTION 8	&gt;</body><body package="ODBCEXDI">SQL_FETCH_FIRST	&lt;C: #define SQL_FETCH_FIRST 2	&gt;</body><body package="ODBCEXDI">SQL_FETCH_LAST	&lt;C: #define SQL_FETCH_LAST 3	&gt;</body><body package="ODBCEXDI">SQL_FETCH_NEXT	&lt;C: #define SQL_FETCH_NEXT 1	&gt;</body><body package="ODBCEXDI">SQL_FETCH_PREV	&lt;C: #define SQL_FETCH_PREV SQL_FETCH_PRIOR	&gt;</body><body package="ODBCEXDI">SQL_FETCH_PRIOR	&lt;C: #define SQL_FETCH_PRIOR 4	&gt;</body><body package="ODBCEXDI">SQL_FETCH_RELATIVE	&lt;C: #define SQL_FETCH_RELATIVE 6	&gt;</body><body package="ODBCEXDI">SQL_FETCH_RESUME	&lt;C: #define SQL_FETCH_RESUME 7	&gt;</body><body package="ODBCEXDI">SQL_FILE_NOT_SUPPORTED	&lt;C: #define SQL_FILE_NOT_SUPPORTED 0x0000	&gt;</body><body package="ODBCEXDI">SQL_FILE_QUALIFIER	&lt;C: #define SQL_FILE_QUALIFIER 0x0002	&gt;</body><body package="ODBCEXDI">SQL_FILE_TABLE	&lt;C: #define SQL_FILE_TABLE 0x0001	&gt;</body><body package="ODBCEXDI">SQL_FILE_USAGE	&lt;C: #define SQL_FILE_USAGE 84	&gt;</body><body package="ODBCEXDI">SQL_FLOAT	&lt;C: #define SQL_FLOAT 6	&gt;</body><body package="ODBCEXDI">SQL_FN_CVT_CONVERT	&lt;C: #define SQL_FN_CVT_CONVERT 0x00000001	&gt;</body><body package="ODBCEXDI">SQL_FN_NUM_ABS	&lt;C: #define SQL_FN_NUM_ABS 0x00000001	&gt;</body><body package="ODBCEXDI">SQL_FN_NUM_ACOS	&lt;C: #define SQL_FN_NUM_ACOS 0x00000002	&gt;</body><body package="ODBCEXDI">SQL_FN_NUM_ASIN	&lt;C: #define SQL_FN_NUM_ASIN 0x00000004	&gt;</body><body package="ODBCEXDI">SQL_FN_NUM_ATAN	&lt;C: #define SQL_FN_NUM_ATAN 0x00000008	&gt;</body><body package="ODBCEXDI">SQL_FN_NUM_ATAN2	&lt;C: #define SQL_FN_NUM_ATAN2 0x00000010	&gt;</body><body package="ODBCEXDI">SQL_FN_NUM_CEILING	&lt;C: #define SQL_FN_NUM_CEILING 0x00000020	&gt;</body><body package="ODBCEXDI">SQL_FN_NUM_COS	&lt;C: #define SQL_FN_NUM_COS 0x00000040	&gt;</body><body package="ODBCEXDI">SQL_FN_NUM_COT	&lt;C: #define SQL_FN_NUM_COT 0x00000080	&gt;</body><body package="ODBCEXDI">SQL_FN_NUM_DEGREES	&lt;C: #define SQL_FN_NUM_DEGREES 0x00040000	&gt;</body><body package="ODBCEXDI">SQL_FN_NUM_EXP	&lt;C: #define SQL_FN_NUM_EXP 0x00000100	&gt;</body><body package="ODBCEXDI">SQL_FN_NUM_FLOOR	&lt;C: #define SQL_FN_NUM_FLOOR 0x00000200	&gt;</body><body package="ODBCEXDI">SQL_FN_NUM_LOG	&lt;C: #define SQL_FN_NUM_LOG 0x00000400	&gt;</body><body package="ODBCEXDI">SQL_FN_NUM_LOG10	&lt;C: #define SQL_FN_NUM_LOG10 0x00080000	&gt;</body><body package="ODBCEXDI">SQL_FN_NUM_MOD	&lt;C: #define SQL_FN_NUM_MOD 0x00000800	&gt;</body><body package="ODBCEXDI">SQL_FN_NUM_PI	&lt;C: #define SQL_FN_NUM_PI 0x00010000	&gt;</body><body package="ODBCEXDI">SQL_FN_NUM_POWER	&lt;C: #define SQL_FN_NUM_POWER 0x00100000	&gt;</body><body package="ODBCEXDI">SQL_FN_NUM_RADIANS	&lt;C: #define SQL_FN_NUM_RADIANS 0x00200000	&gt;</body><body package="ODBCEXDI">SQL_FN_NUM_RAND	&lt;C: #define SQL_FN_NUM_RAND 0x00020000	&gt;</body><body package="ODBCEXDI">SQL_FN_NUM_ROUND	&lt;C: #define SQL_FN_NUM_ROUND 0x00400000	&gt;</body><body package="ODBCEXDI">SQL_FN_NUM_SIGN	&lt;C: #define SQL_FN_NUM_SIGN 0x00001000	&gt;</body><body package="ODBCEXDI">SQL_FN_NUM_SIN	&lt;C: #define SQL_FN_NUM_SIN 0x00002000	&gt;</body><body package="ODBCEXDI">SQL_FN_NUM_SQRT	&lt;C: #define SQL_FN_NUM_SQRT 0x00004000	&gt;</body><body package="ODBCEXDI">SQL_FN_NUM_TAN	&lt;C: #define SQL_FN_NUM_TAN 0x00008000	&gt;</body><body package="ODBCEXDI">SQL_FN_NUM_TRUNCATE	&lt;C: #define SQL_FN_NUM_TRUNCATE 0x00800000	&gt;</body><body package="ODBCEXDI">SQL_FN_STR_ASCII	&lt;C: #define SQL_FN_STR_ASCII 0x00002000	&gt;</body><body package="ODBCEXDI">SQL_FN_STR_CHAR	&lt;C: #define SQL_FN_STR_CHAR 0x00004000	&gt;</body><body package="ODBCEXDI">SQL_FN_STR_CONCAT	&lt;C: #define SQL_FN_STR_CONCAT 0x00000001	&gt;</body><body package="ODBCEXDI">SQL_FN_STR_DIFFERENCE	&lt;C: #define SQL_FN_STR_DIFFERENCE 0x00008000	&gt;</body><body package="ODBCEXDI">SQL_FN_STR_INSERT	&lt;C: #define SQL_FN_STR_INSERT 0x00000002	&gt;</body><body package="ODBCEXDI">SQL_FN_STR_LCASE	&lt;C: #define SQL_FN_STR_LCASE 0x00000040	&gt;</body><body package="ODBCEXDI">SQL_FN_STR_LEFT	&lt;C: #define SQL_FN_STR_LEFT 0x00000004	&gt;</body><body package="ODBCEXDI">SQL_FN_STR_LENGTH	&lt;C: #define SQL_FN_STR_LENGTH 0x00000010	&gt;</body><body package="ODBCEXDI">SQL_FN_STR_LOCATE	&lt;C: #define SQL_FN_STR_LOCATE 0x00000020	&gt;</body><body package="ODBCEXDI">SQL_FN_STR_LOCATE_2	&lt;C: #define SQL_FN_STR_LOCATE_2 0x00010000	&gt;</body><body package="ODBCEXDI">SQL_FN_STR_LTRIM	&lt;C: #define SQL_FN_STR_LTRIM 0x00000008	&gt;</body><body package="ODBCEXDI">SQL_FN_STR_REPEAT	&lt;C: #define SQL_FN_STR_REPEAT 0x00000080	&gt;</body><body package="ODBCEXDI">SQL_FN_STR_REPLACE	&lt;C: #define SQL_FN_STR_REPLACE 0x00000100	&gt;</body><body package="ODBCEXDI">SQL_FN_STR_RIGHT	&lt;C: #define SQL_FN_STR_RIGHT 0x00000200	&gt;</body><body package="ODBCEXDI">SQL_FN_STR_RTRIM	&lt;C: #define SQL_FN_STR_RTRIM 0x00000400	&gt;</body><body package="ODBCEXDI">SQL_FN_STR_SOUNDEX	&lt;C: #define SQL_FN_STR_SOUNDEX 0x00020000	&gt;</body><body package="ODBCEXDI">SQL_FN_STR_SPACE	&lt;C: #define SQL_FN_STR_SPACE 0x00040000	&gt;</body><body package="ODBCEXDI">SQL_FN_STR_SUBSTRING	&lt;C: #define SQL_FN_STR_SUBSTRING 0x00000800	&gt;</body><body package="ODBCEXDI">SQL_FN_STR_UCASE	&lt;C: #define SQL_FN_STR_UCASE 0x00001000	&gt;</body><body package="ODBCEXDI">SQL_FN_SYS_DBNAME	&lt;C: #define SQL_FN_SYS_DBNAME 0x00000002	&gt;</body><body package="ODBCEXDI">SQL_FN_SYS_IFNULL	&lt;C: #define SQL_FN_SYS_IFNULL 0x00000004	&gt;</body><body package="ODBCEXDI">SQL_FN_SYS_USERNAME	&lt;C: #define SQL_FN_SYS_USERNAME 0x00000001	&gt;</body><body package="ODBCEXDI">SQL_FN_TD_CURDATE	&lt;C: #define SQL_FN_TD_CURDATE 0x00000002	&gt;</body><body package="ODBCEXDI">SQL_FN_TD_CURTIME	&lt;C: #define SQL_FN_TD_CURTIME 0x00000200	&gt;</body><body package="ODBCEXDI">SQL_FN_TD_DAYNAME	&lt;C: #define SQL_FN_TD_DAYNAME 0x00008000	&gt;</body><body package="ODBCEXDI">SQL_FN_TD_DAYOFMONTH	&lt;C: #define SQL_FN_TD_DAYOFMONTH 0x00000004	&gt;</body><body package="ODBCEXDI">SQL_FN_TD_DAYOFWEEK	&lt;C: #define SQL_FN_TD_DAYOFWEEK 0x00000008	&gt;</body><body package="ODBCEXDI">SQL_FN_TD_DAYOFYEAR	&lt;C: #define SQL_FN_TD_DAYOFYEAR 0x00000010	&gt;</body><body package="ODBCEXDI">SQL_FN_TD_HOUR	&lt;C: #define SQL_FN_TD_HOUR 0x00000400	&gt;</body><body package="ODBCEXDI">SQL_FN_TD_MINUTE	&lt;C: #define SQL_FN_TD_MINUTE 0x00000800	&gt;</body><body package="ODBCEXDI">SQL_FN_TD_MONTH	&lt;C: #define SQL_FN_TD_MONTH 0x00000020	&gt;</body><body package="ODBCEXDI">SQL_FN_TD_MONTHNAME	&lt;C: #define SQL_FN_TD_MONTHNAME 0x00010000	&gt;</body><body package="ODBCEXDI">SQL_FN_TD_NOW	&lt;C: #define SQL_FN_TD_NOW 0x00000001	&gt;</body><body package="ODBCEXDI">SQL_FN_TD_QUARTER	&lt;C: #define SQL_FN_TD_QUARTER 0x00000040	&gt;</body><body package="ODBCEXDI">SQL_FN_TD_SECOND	&lt;C: #define SQL_FN_TD_SECOND 0x00001000	&gt;</body><body package="ODBCEXDI">SQL_FN_TD_TIMESTAMPADD	&lt;C: #define SQL_FN_TD_TIMESTAMPADD 0x00002000	&gt;</body><body package="ODBCEXDI">SQL_FN_TD_TIMESTAMPDIFF	&lt;C: #define SQL_FN_TD_TIMESTAMPDIFF 0x00004000	&gt;</body><body package="ODBCEXDI">SQL_FN_TD_WEEK	&lt;C: #define SQL_FN_TD_WEEK 0x00000080	&gt;</body><body package="ODBCEXDI">SQL_FN_TD_YEAR	&lt;C: #define SQL_FN_TD_YEAR 0x00000100	&gt;</body><body package="ODBCEXDI">SQL_FN_TSI_DAY	&lt;C: #define SQL_FN_TSI_DAY 0x00000010	&gt;</body><body package="ODBCEXDI">SQL_FN_TSI_FRAC_SECOND	&lt;C: #define SQL_FN_TSI_FRAC_SECOND 0x00000001	&gt;</body><body package="ODBCEXDI">SQL_FN_TSI_HOUR	&lt;C: #define SQL_FN_TSI_HOUR 0x00000008	&gt;</body><body package="ODBCEXDI">SQL_FN_TSI_MINUTE	&lt;C: #define SQL_FN_TSI_MINUTE 0x00000004	&gt;</body><body package="ODBCEXDI">SQL_FN_TSI_MONTH	&lt;C: #define SQL_FN_TSI_MONTH 0x00000040	&gt;</body><body package="ODBCEXDI">SQL_FN_TSI_QUARTER	&lt;C: #define SQL_FN_TSI_QUARTER 0x00000080	&gt;</body><body package="ODBCEXDI">SQL_FN_TSI_SECOND	&lt;C: #define SQL_FN_TSI_SECOND 0x00000002	&gt;</body><body package="ODBCEXDI">SQL_FN_TSI_WEEK	&lt;C: #define SQL_FN_TSI_WEEK 0x00000020	&gt;</body><body package="ODBCEXDI">SQL_FN_TSI_YEAR	&lt;C: #define SQL_FN_TSI_YEAR 0x00000100	&gt;</body><body package="ODBCEXDI">SQL_GB_GROUP_BY_CONTAINS_SELECT	&lt;C: #define SQL_GB_GROUP_BY_CONTAINS_SELECT 0x0002	&gt;</body><body package="ODBCEXDI">SQL_GB_GROUP_BY_EQUALS_SELECT	&lt;C: #define SQL_GB_GROUP_BY_EQUALS_SELECT 0x0001	&gt;</body><body package="ODBCEXDI">SQL_GB_NOT_SUPPORTED	&lt;C: #define SQL_GB_NOT_SUPPORTED 0x0000	&gt;</body><body package="ODBCEXDI">SQL_GB_NO_RELATION	&lt;C: #define SQL_GB_NO_RELATION 0x0003	&gt;</body><body package="ODBCEXDI">SQL_GD_ANY_COLUMN	&lt;C: #define SQL_GD_ANY_COLUMN 0x00000001	&gt;</body><body package="ODBCEXDI">SQL_GD_ANY_ORDER	&lt;C: #define SQL_GD_ANY_ORDER 0x00000002	&gt;</body><body package="ODBCEXDI">SQL_GD_BLOCK	&lt;C: #define SQL_GD_BLOCK 0x00000004	&gt;</body><body package="ODBCEXDI">SQL_GD_BOUND	&lt;C: #define SQL_GD_BOUND 0x00000008	&gt;</body><body package="ODBCEXDI">SQL_GETDATA_EXTENSIONS	&lt;C: #define SQL_GETDATA_EXTENSIONS 81	&gt;</body><body package="ODBCEXDI">SQL_GET_BOOKMARK	&lt;C: #define SQL_GET_BOOKMARK 13	&gt;</body><body package="ODBCEXDI">SQL_GRAPHIC	&lt;C: #define SQL_GRAPHIC -95	&gt;</body><body package="ODBCEXDI">SQL_GROUP_BY	&lt;C: #define SQL_GROUP_BY 88	&gt;</body><body package="ODBCEXDI">SQL_GUID	&lt;C: #define SQL_GUID -11	&gt;</body><body package="ODBCEXDI">SQL_IC_LOWER	&lt;C: #define SQL_IC_LOWER 0x0002	&gt;</body><body package="ODBCEXDI">SQL_IC_MIXED	&lt;C: #define SQL_IC_MIXED 0x0004	&gt;</body><body package="ODBCEXDI">SQL_IC_SENSITIVE	&lt;C: #define SQL_IC_SENSITIVE 0x0003	&gt;</body><body package="ODBCEXDI">SQL_IC_UPPER	&lt;C: #define SQL_IC_UPPER 0x0001	&gt;</body><body package="ODBCEXDI">SQL_IDENTIFIER_CASE	&lt;C: #define SQL_IDENTIFIER_CASE 28	&gt;</body><body package="ODBCEXDI">SQL_IDENTIFIER_QUOTE_CHAR	&lt;C: #define SQL_IDENTIFIER_QUOTE_CHAR 29	&gt;</body><body package="ODBCEXDI">SQL_IGNORE	&lt;C: #define SQL_IGNORE (-6)	&gt;</body><body package="ODBCEXDI">SQL_INDEX_ALL	&lt;C: #define SQL_INDEX_ALL 1	&gt;</body><body package="ODBCEXDI">SQL_INDEX_CLUSTERED	&lt;C: #define SQL_INDEX_CLUSTERED 1	&gt;</body><body package="ODBCEXDI">SQL_INDEX_HASHED	&lt;C: #define SQL_INDEX_HASHED 2	&gt;</body><body package="ODBCEXDI">SQL_INDEX_OTHER	&lt;C: #define SQL_INDEX_OTHER 3	&gt;</body><body package="ODBCEXDI">SQL_INDEX_UNIQUE	&lt;C: #define SQL_INDEX_UNIQUE 0	&gt;</body><body package="ODBCEXDI">SQL_INFO_DRIVER_START	&lt;C: #define SQL_INFO_DRIVER_START 1000	&gt;</body><body package="ODBCEXDI">SQL_INFO_FIRST	&lt;C: #define SQL_INFO_FIRST 0	&gt;</body><body package="ODBCEXDI">SQL_INFO_LAST	&lt;C: #define SQL_INFO_LAST SQL_QUALIFIER_LOCATION	&gt;</body><body package="ODBCEXDI">SQL_INTEGER	&lt;C: #define SQL_INTEGER 4	&gt;</body><body package="ODBCEXDI">SQL_INTERVAL_DAY	&lt;C: #define SQL_INTERVAL_DAY (-83)	&gt;</body><body package="ODBCEXDI">SQL_INTERVAL_DAY_TO_HOUR	&lt;C: #define SQL_INTERVAL_DAY_TO_HOUR (-87)	&gt;</body><body package="ODBCEXDI">SQL_INTERVAL_DAY_TO_MINUTE	&lt;C: #define SQL_INTERVAL_DAY_TO_MINUTE (-88)	&gt;</body><body package="ODBCEXDI">SQL_INTERVAL_DAY_TO_SECOND	&lt;C: #define SQL_INTERVAL_DAY_TO_SECOND (-89)	&gt;</body><body package="ODBCEXDI">SQL_INTERVAL_HOUR	&lt;C: #define SQL_INTERVAL_HOUR (-84)	&gt;</body><body package="ODBCEXDI">SQL_INTERVAL_HOUR_TO_MINUTE	&lt;C: #define SQL_INTERVAL_HOUR_TO_MINUTE (-90)	&gt;</body><body package="ODBCEXDI">SQL_INTERVAL_HOUR_TO_SECOND	&lt;C: #define SQL_INTERVAL_HOUR_TO_SECOND (-91)	&gt;</body><body package="ODBCEXDI">SQL_INTERVAL_MINUTE	&lt;C: #define SQL_INTERVAL_MINUTE (-85)	&gt;</body><body package="ODBCEXDI">SQL_INTERVAL_MINUTE_TO_SECOND	&lt;C: #define SQL_INTERVAL_MINUTE_TO_SECOND (-92)	&gt;</body><body package="ODBCEXDI">SQL_INTERVAL_MONTH	&lt;C: #define SQL_INTERVAL_MONTH (-81)	&gt;</body><body package="ODBCEXDI">SQL_INTERVAL_SECOND	&lt;C: #define SQL_INTERVAL_SECOND (-86)	&gt;</body><body package="ODBCEXDI">SQL_INTERVAL_YEAR	&lt;C: #define SQL_INTERVAL_YEAR (-80)	&gt;</body><body package="ODBCEXDI">SQL_INTERVAL_YEAR_TO_MONTH	&lt;C: #define SQL_INTERVAL_YEAR_TO_MONTH (-82)	&gt;</body><body package="ODBCEXDI">SQL_INVALID_HANDLE	&lt;C: #define SQL_INVALID_HANDLE (-2)	&gt;</body><body package="ODBCEXDI">SQL_IS_INTEGER	&lt;C: #define SQL_IS_INTEGER (-6)	&gt;</body><body package="ODBCEXDI">SQL_IS_POINTER	&lt;C: #define SQL_IS_POINTER (-4)	&gt;</body><body package="ODBCEXDI">SQL_IS_UINTEGER	&lt;C: #define SQL_IS_UINTEGER (-5)	&gt;</body><body package="ODBCEXDI">SQL_KEYSET_SIZE	&lt;C: #define SQL_KEYSET_SIZE 8	&gt;</body><body package="ODBCEXDI">SQL_KEYSET_SIZE_DEFAULT	&lt;C: #define SQL_KEYSET_SIZE_DEFAULT 0L	&gt;</body><body package="ODBCEXDI">SQL_KEYWORDS	&lt;C: #define SQL_KEYWORDS 89	&gt;</body><body package="ODBCEXDI">SQL_LCK_EXCLUSIVE	&lt;C: #define SQL_LCK_EXCLUSIVE 0x00000002	&gt;</body><body package="ODBCEXDI">SQL_LCK_NO_CHANGE	&lt;C: #define SQL_LCK_NO_CHANGE 0x00000001	&gt;</body><body package="ODBCEXDI">SQL_LCK_UNLOCK	&lt;C: #define SQL_LCK_UNLOCK 0x00000004	&gt;</body><body package="ODBCEXDI">SQL_LEN_DATA_AT_EXEC_OFFSET	&lt;C: #define SQL_LEN_DATA_AT_EXEC_OFFSET (-100)	&gt;</body><body package="ODBCEXDI">SQL_LIKE_ESCAPE_CLAUSE	&lt;C: #define SQL_LIKE_ESCAPE_CLAUSE 113	&gt;</body><body package="ODBCEXDI">SQL_LIKE_ONLY	&lt;C: #define SQL_LIKE_ONLY 1	&gt;</body><body package="ODBCEXDI">SQL_LOCK_EXCLUSIVE	&lt;C: #define SQL_LOCK_EXCLUSIVE 1	&gt;</body><body package="ODBCEXDI">SQL_LOCK_NO_CHANGE	&lt;C: #define SQL_LOCK_NO_CHANGE 0	&gt;</body><body package="ODBCEXDI">SQL_LOCK_TYPES	&lt;C: #define SQL_LOCK_TYPES 78	&gt;</body><body package="ODBCEXDI">SQL_LOCK_UNLOCK	&lt;C: #define SQL_LOCK_UNLOCK 2	&gt;</body><body package="ODBCEXDI">SQL_LOGIN_TIMEOUT	&lt;C: #define SQL_LOGIN_TIMEOUT 103	&gt;</body><body package="ODBCEXDI">SQL_LOGIN_TIMEOUT_DEFAULT	&lt;C: #define SQL_LOGIN_TIMEOUT_DEFAULT 15L	&gt;</body><body package="ODBCEXDI">SQL_LONGVARBINARY	&lt;C: #define SQL_LONGVARBINARY (-4)	&gt;</body><body package="ODBCEXDI">SQL_LONGVARCHAR	&lt;C: #define SQL_LONGVARCHAR (-1)	&gt;</body><body package="ODBCEXDI">SQL_LONGVARGRAPHIC	&lt;C: #define SQL_LONGVARGRAPHIC -97	&gt;</body><body package="ODBCEXDI">SQL_MARS_ENABLED_NO	&lt;C: #define SQL_MARS_ENABLED_NO 0L	&gt;</body><body package="ODBCEXDI">SQL_MARS_ENABLED_YES	&lt;C: #define SQL_MARS_ENABLED_YES 1L	&gt;</body><body package="ODBCEXDI">SQL_MAX_BINARY_LITERAL_LEN	&lt;C: #define SQL_MAX_BINARY_LITERAL_LEN 112	&gt;</body><body package="ODBCEXDI">SQL_MAX_CHAR_LITERAL_LEN	&lt;C: #define SQL_MAX_CHAR_LITERAL_LEN 108	&gt;</body><body package="ODBCEXDI">SQL_MAX_COLUMNS_IN_GROUP_BY	&lt;C: #define SQL_MAX_COLUMNS_IN_GROUP_BY 97	&gt;</body><body package="ODBCEXDI">SQL_MAX_COLUMNS_IN_INDEX	&lt;C: #define SQL_MAX_COLUMNS_IN_INDEX 98	&gt;</body><body package="ODBCEXDI">SQL_MAX_COLUMNS_IN_ORDER_BY	&lt;C: #define SQL_MAX_COLUMNS_IN_ORDER_BY 99	&gt;</body><body package="ODBCEXDI">SQL_MAX_COLUMNS_IN_SELECT	&lt;C: #define SQL_MAX_COLUMNS_IN_SELECT 100	&gt;</body><body package="ODBCEXDI">SQL_MAX_COLUMNS_IN_TABLE	&lt;C: #define SQL_MAX_COLUMNS_IN_TABLE 101	&gt;</body><body package="ODBCEXDI">SQL_MAX_COLUMN_NAME_LEN	&lt;C: #define SQL_MAX_COLUMN_NAME_LEN 30	&gt;</body><body package="ODBCEXDI">SQL_MAX_CURSOR_NAME_LEN	&lt;C: #define SQL_MAX_CURSOR_NAME_LEN 31	&gt;</body><body package="ODBCEXDI">SQL_MAX_DSN_LENGTH	&lt;C: #define SQL_MAX_DSN_LENGTH 32	&gt;</body><body package="ODBCEXDI">SQL_MAX_INDEX_SIZE	&lt;C: #define SQL_MAX_INDEX_SIZE 102	&gt;</body><body package="ODBCEXDI">SQL_MAX_LENGTH	&lt;C: #define SQL_MAX_LENGTH 3	&gt;</body><body package="ODBCEXDI">SQL_MAX_LENGTH_DEFAULT	&lt;C: #define SQL_MAX_LENGTH_DEFAULT 0L	&gt;</body><body package="ODBCEXDI">SQL_MAX_MESSAGE_LENGTH	&lt;C: #define SQL_MAX_MESSAGE_LENGTH 512	&gt;</body><body package="ODBCEXDI">SQL_MAX_OPTION_STRING_LENGTH	&lt;C: #define SQL_MAX_OPTION_STRING_LENGTH 256	&gt;</body><body package="ODBCEXDI">SQL_MAX_OWNER_NAME_LEN	&lt;C: #define SQL_MAX_OWNER_NAME_LEN 32	&gt;</body><body package="ODBCEXDI">SQL_MAX_PROCEDURE_NAME_LEN	&lt;C: #define SQL_MAX_PROCEDURE_NAME_LEN 33	&gt;</body><body package="ODBCEXDI">SQL_MAX_QUALIFIER_NAME_LEN	&lt;C: #define SQL_MAX_QUALIFIER_NAME_LEN 34	&gt;</body><body package="ODBCEXDI">SQL_MAX_ROWS	&lt;C: #define SQL_MAX_ROWS 1	&gt;</body><body package="ODBCEXDI">SQL_MAX_ROWS_DEFAULT	&lt;C: #define SQL_MAX_ROWS_DEFAULT 0L	&gt;</body><body package="ODBCEXDI">SQL_MAX_ROW_SIZE	&lt;C: #define SQL_MAX_ROW_SIZE 104	&gt;</body><body package="ODBCEXDI">SQL_MAX_ROW_SIZE_INCLUDES_LONG	&lt;C: #define SQL_MAX_ROW_SIZE_INCLUDES_LONG 103	&gt;</body><body package="ODBCEXDI">SQL_MAX_STATEMENT_LEN	&lt;C: #define SQL_MAX_STATEMENT_LEN 105	&gt;</body><body package="ODBCEXDI">SQL_MAX_TABLES_IN_SELECT	&lt;C: #define SQL_MAX_TABLES_IN_SELECT 106	&gt;</body><body package="ODBCEXDI">SQL_MAX_TABLE_NAME_LEN	&lt;C: #define SQL_MAX_TABLE_NAME_LEN 35	&gt;</body><body package="ODBCEXDI">SQL_MAX_USER_NAME_LEN	&lt;C: #define SQL_MAX_USER_NAME_LEN 107	&gt;</body><body package="ODBCEXDI">SQL_MODE_DEFAULT	&lt;C: #define SQL_MODE_DEFAULT SQL_MODE_READ_WRITE	&gt;</body><body package="ODBCEXDI">SQL_MODE_READ_ONLY	&lt;C: #define SQL_MODE_READ_ONLY 1L	&gt;</body><body package="ODBCEXDI">SQL_MODE_READ_WRITE	&lt;C: #define SQL_MODE_READ_WRITE 0L	&gt;</body><body package="ODBCEXDI">SQL_MULTIPLE_ACTIVE_TXN	&lt;C: #define SQL_MULTIPLE_ACTIVE_TXN 37	&gt;</body><body package="ODBCEXDI">SQL_MULT_RESULT_SETS	&lt;C: #define SQL_MULT_RESULT_SETS 36	&gt;</body><body package="ODBCEXDI">SQL_NC_END	&lt;C: #define SQL_NC_END 0x0004	&gt;</body><body package="ODBCEXDI">SQL_NC_HIGH	&lt;C: #define SQL_NC_HIGH 0x0000	&gt;</body><body package="ODBCEXDI">SQL_NC_LOW	&lt;C: #define SQL_NC_LOW 0x0001	&gt;</body><body package="ODBCEXDI">SQL_NC_START	&lt;C: #define SQL_NC_START 0x0002	&gt;</body><body package="ODBCEXDI">SQL_NEED_DATA	&lt;C: #define SQL_NEED_DATA 99	&gt;</body><body package="ODBCEXDI">SQL_NEED_LONG_DATA_LEN	&lt;C: #define SQL_NEED_LONG_DATA_LEN 111	&gt;</body><body package="ODBCEXDI">SQL_NNC_NON_NULL	&lt;C: #define SQL_NNC_NON_NULL 0x0001	&gt;</body><body package="ODBCEXDI">SQL_NNC_NULL	&lt;C: #define SQL_NNC_NULL 0x0000	&gt;</body><body package="ODBCEXDI">SQL_NON_NULLABLE_COLUMNS	&lt;C: #define SQL_NON_NULLABLE_COLUMNS 75	&gt;</body><body package="ODBCEXDI">SQL_NOSCAN	&lt;C: #define SQL_NOSCAN 2	&gt;</body><body package="ODBCEXDI">SQL_NOSCAN_DEFAULT	&lt;C: #define SQL_NOSCAN_DEFAULT SQL_NOSCAN_OFF	&gt;</body><body package="ODBCEXDI">SQL_NOSCAN_OFF	&lt;C: #define SQL_NOSCAN_OFF 0L	&gt;</body><body package="ODBCEXDI">SQL_NOSCAN_ON	&lt;C: #define SQL_NOSCAN_ON 1L	&gt;</body><body package="ODBCEXDI">SQL_NO_DATA_FOUND	&lt;C: #define SQL_NO_DATA_FOUND 100	&gt;</body><body package="ODBCEXDI">SQL_NO_NULLS	&lt;C: #define SQL_NO_NULLS 0	&gt;</body><body package="ODBCEXDI">SQL_NO_TOTAL	&lt;C: #define SQL_NO_TOTAL (-4)	&gt;</body><body package="ODBCEXDI">SQL_NTS	&lt;C: #define SQL_NTS (-3)	&gt;</body><body package="ODBCEXDI">SQL_NULLABLE	&lt;C: #define SQL_NULLABLE 1	&gt;</body><body package="ODBCEXDI">SQL_NULLABLE_UNKNOWN	&lt;C: #define SQL_NULLABLE_UNKNOWN 2	&gt;</body><body package="ODBCEXDI">SQL_NULL_COLLATION	&lt;C: #define SQL_NULL_COLLATION 85	&gt;</body><body package="ODBCEXDI">SQL_NULL_DATA	&lt;C: #define SQL_NULL_DATA (-1)	&gt;</body><body package="ODBCEXDI">SQL_NULL_HDBC	&lt;C: #define SQL_NULL_HDBC 0	&gt;</body><body package="ODBCEXDI">SQL_NULL_HENV	&lt;C: #define SQL_NULL_HENV 0	&gt;</body><body package="ODBCEXDI">SQL_NULL_HSTMT	&lt;C: #define SQL_NULL_HSTMT 0	&gt;</body><body package="ODBCEXDI">SQL_NUMERIC	&lt;C: #define SQL_NUMERIC 2	&gt;</body><body package="ODBCEXDI">SQL_NUMERIC_FUNCTIONS	&lt;C: #define SQL_NUMERIC_FUNCTIONS 49	&gt;</body><body package="ODBCEXDI">SQL_NUM_EXTENSIONS	&lt;C: #define SQL_NUM_EXTENSIONS (SQL_EXT_API_LAST-SQL_EXT_API_START+1)	&gt;</body><body package="ODBCEXDI">SQL_NUM_FUNCTIONS	&lt;C: #define SQL_NUM_FUNCTIONS 23	&gt;</body><body package="ODBCEXDI">SQL_OAC_LEVEL1	&lt;C: #define SQL_OAC_LEVEL1 0x0001	&gt;</body><body package="ODBCEXDI">SQL_OAC_LEVEL2	&lt;C: #define SQL_OAC_LEVEL2 0x0002	&gt;</body><body package="ODBCEXDI">SQL_OAC_NONE	&lt;C: #define SQL_OAC_NONE 0x0000	&gt;</body><body package="ODBCEXDI">SQL_ODBC_API_CONFORMANCE	&lt;C: #define SQL_ODBC_API_CONFORMANCE 9	&gt;</body><body package="ODBCEXDI">SQL_ODBC_CURSORS	&lt;C: #define SQL_ODBC_CURSORS 110	&gt;</body><body package="ODBCEXDI">SQL_ODBC_SAG_CLI_CONFORMANCE	&lt;C: #define SQL_ODBC_SAG_CLI_CONFORMANCE 12	&gt;</body><body package="ODBCEXDI">SQL_ODBC_SQL_CONFORMANCE	&lt;C: #define SQL_ODBC_SQL_CONFORMANCE 15	&gt;</body><body package="ODBCEXDI">SQL_ODBC_SQL_OPT_IEF	&lt;C: #define SQL_ODBC_SQL_OPT_IEF 73	&gt;</body><body package="ODBCEXDI">SQL_ODBC_VER	&lt;C: #define SQL_ODBC_VER 10	&gt;</body><body package="ODBCEXDI">SQL_OJ_ALL_COMPARISON_OPS	&lt;C: #define SQL_OJ_ALL_COMPARISON_OPS 0x00000040	&gt;</body><body package="ODBCEXDI">SQL_OJ_CAPABILITIES	&lt;C: #define SQL_OJ_CAPABILITIES 65003	&gt;</body><body package="ODBCEXDI">SQL_OJ_FULL	&lt;C: #define SQL_OJ_FULL 0x00000004	&gt;</body><body package="ODBCEXDI">SQL_OJ_INNER	&lt;C: #define SQL_OJ_INNER 0x00000020	&gt;</body><body package="ODBCEXDI">SQL_OJ_LEFT	&lt;C: #define SQL_OJ_LEFT 0x00000001	&gt;</body><body package="ODBCEXDI">SQL_OJ_NESTED	&lt;C: #define SQL_OJ_NESTED 0x00000008	&gt;</body><body package="ODBCEXDI">SQL_OJ_NOT_ORDERED	&lt;C: #define SQL_OJ_NOT_ORDERED 0x00000010	&gt;</body><body package="ODBCEXDI">SQL_OJ_RIGHT	&lt;C: #define SQL_OJ_RIGHT 0x00000002	&gt;</body><body package="ODBCEXDI">SQL_OPT_TRACE	&lt;C: #define SQL_OPT_TRACE 104	&gt;</body><body package="ODBCEXDI">SQL_OPT_TRACEFILE	&lt;C: #define SQL_OPT_TRACEFILE 105	&gt;</body><body package="ODBCEXDI">SQL_OPT_TRACE_DEFAULT	&lt;C: #define SQL_OPT_TRACE_DEFAULT SQL_OPT_TRACE_OFF	&gt;</body><body package="ODBCEXDI">SQL_OPT_TRACE_FILE_DEFAULT	&lt;C: #define SQL_OPT_TRACE_FILE_DEFAULT "SQL.LOG"	&gt;</body><body package="ODBCEXDI">SQL_OPT_TRACE_OFF	&lt;C: #define SQL_OPT_TRACE_OFF 0L	&gt;</body><body package="ODBCEXDI">SQL_OPT_TRACE_ON	&lt;C: #define SQL_OPT_TRACE_ON 1L	&gt;</body><body package="ODBCEXDI">SQL_ORDER_BY_COLUMNS_IN_SELECT	&lt;C: #define SQL_ORDER_BY_COLUMNS_IN_SELECT 90	&gt;</body><body package="ODBCEXDI">SQL_OSCC_COMPLIANT	&lt;C: #define SQL_OSCC_COMPLIANT 0x0001	&gt;</body><body package="ODBCEXDI">SQL_OSCC_NOT_COMPLIANT	&lt;C: #define SQL_OSCC_NOT_COMPLIANT 0x0000	&gt;</body><body package="ODBCEXDI">SQL_OSC_CORE	&lt;C: #define SQL_OSC_CORE 0x0001	&gt;</body><body package="ODBCEXDI">SQL_OSC_EXTENDED	&lt;C: #define SQL_OSC_EXTENDED 0x0002	&gt;</body><body package="ODBCEXDI">SQL_OSC_MINIMUM	&lt;C: #define SQL_OSC_MINIMUM 0x0000	&gt;</body><body package="ODBCEXDI">SQL_OUTER_JOINS	&lt;C: #define SQL_OUTER_JOINS 38	&gt;</body><body package="ODBCEXDI">SQL_OU_DML_STATEMENTS	&lt;C: #define SQL_OU_DML_STATEMENTS 0x00000001	&gt;</body><body package="ODBCEXDI">SQL_OU_INDEX_DEFINITION	&lt;C: #define SQL_OU_INDEX_DEFINITION 0x00000008	&gt;</body><body package="ODBCEXDI">SQL_OU_PRIVILEGE_DEFINITION	&lt;C: #define SQL_OU_PRIVILEGE_DEFINITION 0x00000010	&gt;</body><body package="ODBCEXDI">SQL_OU_PROCEDURE_INVOCATION	&lt;C: #define SQL_OU_PROCEDURE_INVOCATION 0x00000002	&gt;</body><body package="ODBCEXDI">SQL_OU_TABLE_DEFINITION	&lt;C: #define SQL_OU_TABLE_DEFINITION 0x00000004	&gt;</body><body package="ODBCEXDI">SQL_OV_ODBC2	&lt;C: #define SQL_OV_ODBC2 2UL	&gt;</body><body package="ODBCEXDI">SQL_OV_ODBC3	&lt;C: #define SQL_OV_ODBC3 3UL	&gt;</body><body package="ODBCEXDI">SQL_OWNER_TERM	&lt;C: #define SQL_OWNER_TERM 39	&gt;</body><body package="ODBCEXDI">SQL_OWNER_USAGE	&lt;C: #define SQL_OWNER_USAGE 91	&gt;</body><body package="ODBCEXDI">SQL_PACKET_SIZE	&lt;C: #define SQL_PACKET_SIZE 112	&gt;</body><body package="ODBCEXDI">SQL_PARAM_DIAG_UNAVAILABLE	&lt;C: #define SQL_PARAM_DIAG_UNAVAILABLE 1	&gt;</body><body package="ODBCEXDI">SQL_PARAM_ERROR	&lt;C: #define SQL_PARAM_ERROR 5	&gt;</body><body package="ODBCEXDI">SQL_PARAM_IGNORE	&lt;C: #define SQL_PARAM_IGNORE 1	&gt;</body><body package="ODBCEXDI">SQL_PARAM_INPUT	&lt;C: #define SQL_PARAM_INPUT 1	&gt;</body><body package="ODBCEXDI">SQL_PARAM_INPUT_OUTPUT	&lt;C: #define SQL_PARAM_INPUT_OUTPUT 2	&gt;</body><body package="ODBCEXDI">SQL_PARAM_OUTPUT	&lt;C: #define SQL_PARAM_OUTPUT 4	&gt;</body><body package="ODBCEXDI">SQL_PARAM_PROCEED	&lt;C: #define SQL_PARAM_PROCEED 0	&gt;</body><body package="ODBCEXDI">SQL_PARAM_SUCCESS	&lt;C: #define SQL_PARAM_SUCCESS 0	&gt;</body><body package="ODBCEXDI">SQL_PARAM_SUCCESS_WITH_INFO	&lt;C: #define SQL_PARAM_SUCCESS_WITH_INFO 6	&gt;</body><body package="ODBCEXDI">SQL_PARAM_TYPE_DEFAULT	&lt;C: #define SQL_PARAM_TYPE_DEFAULT SQL_PARAM_INPUT_OUTPUT	&gt;</body><body package="ODBCEXDI">SQL_PARAM_TYPE_UNKNOWN	&lt;C: #define SQL_PARAM_TYPE_UNKNOWN 0	&gt;</body><body package="ODBCEXDI">SQL_PARAM_UNUSED	&lt;C: #define SQL_PARAM_UNUSED 7	&gt;</body><body package="ODBCEXDI">SQL_PC_DEFAULT	&lt;C: #define SQL_PC_DEFAULT	SQL_PC_OFF	&gt;</body><body package="ODBCEXDI">SQL_PC_NON_PSEUDO	&lt;C: #define SQL_PC_NON_PSEUDO SQL_PC_NOT_PSEUDO	&gt;</body><body package="ODBCEXDI">SQL_PC_NOT_PSEUDO	&lt;C: #define SQL_PC_NOT_PSEUDO 1	&gt;</body><body package="ODBCEXDI">SQL_PC_OFF	&lt;C: #define SQL_PC_OFF 0L	&gt;</body><body package="ODBCEXDI">SQL_PC_ON	&lt;C: #define SQL_PC_ON 1L	&gt;</body><body package="ODBCEXDI">SQL_PC_PSEUDO	&lt;C: #define SQL_PC_PSEUDO 2	&gt;</body><body package="ODBCEXDI">SQL_PC_UNKNOWN	&lt;C: #define SQL_PC_UNKNOWN 0	&gt;</body><body package="ODBCEXDI">SQL_POSITION	&lt;C: #define SQL_POSITION 0	&gt;</body><body package="ODBCEXDI">SQL_POSITIONED_STATEMENTS	&lt;C: #define SQL_POSITIONED_STATEMENTS 80	&gt;</body><body package="ODBCEXDI">SQL_POS_ADD	&lt;C: #define SQL_POS_ADD 0x00000010	&gt;</body><body package="ODBCEXDI">SQL_POS_DELETE	&lt;C: #define SQL_POS_DELETE 0x00000008	&gt;</body><body package="ODBCEXDI">SQL_POS_OPERATIONS	&lt;C: #define SQL_POS_OPERATIONS 79	&gt;</body><body package="ODBCEXDI">SQL_POS_POSITION	&lt;C: #define SQL_POS_POSITION 0x00000001	&gt;</body><body package="ODBCEXDI">SQL_POS_REFRESH	&lt;C: #define SQL_POS_REFRESH 0x00000002	&gt;</body><body package="ODBCEXDI">SQL_POS_UPDATE	&lt;C: #define SQL_POS_UPDATE 0x00000004	&gt;</body><body package="ODBCEXDI">SQL_PRESERVE_CURSORS	&lt;C: #define SQL_PRESERVE_CURSORS (SQL_COPT_SS_BASE+4)	&gt;</body><body package="ODBCEXDI">SQL_PROCEDURES	&lt;C: #define SQL_PROCEDURES 21	&gt;</body><body package="ODBCEXDI">SQL_PROCEDURE_TERM	&lt;C: #define SQL_PROCEDURE_TERM 40	&gt;</body><body package="ODBCEXDI">SQL_PS_POSITIONED_DELETE	&lt;C: #define SQL_PS_POSITIONED_DELETE 0x00000001	&gt;</body><body package="ODBCEXDI">SQL_PS_POSITIONED_UPDATE	&lt;C: #define SQL_PS_POSITIONED_UPDATE 0x00000002	&gt;</body><body package="ODBCEXDI">SQL_PS_SELECT_FOR_UPDATE	&lt;C: #define SQL_PS_SELECT_FOR_UPDATE 0x00000004	&gt;</body><body package="ODBCEXDI">SQL_PT_FUNCTION	&lt;C: #define SQL_PT_FUNCTION 2	&gt;</body><body package="ODBCEXDI">SQL_PT_PROCEDURE	&lt;C: #define SQL_PT_PROCEDURE 1	&gt;</body><body package="ODBCEXDI">SQL_PT_UNKNOWN	&lt;C: #define SQL_PT_UNKNOWN 0	&gt;</body><body package="ODBCEXDI">SQL_QL_END	&lt;C: #define SQL_QL_END 0x0002	&gt;</body><body package="ODBCEXDI">SQL_QL_START	&lt;C: #define SQL_QL_START 0x0001	&gt;</body><body package="ODBCEXDI">SQL_QUALIFIER_LOCATION	&lt;C: #define SQL_QUALIFIER_LOCATION 114	&gt;</body><body package="ODBCEXDI">SQL_QUALIFIER_NAME_SEPARATOR	&lt;C: #define SQL_QUALIFIER_NAME_SEPARATOR 41	&gt;</body><body package="ODBCEXDI">SQL_QUALIFIER_TERM	&lt;C: #define SQL_QUALIFIER_TERM 42	&gt;</body><body package="ODBCEXDI">SQL_QUALIFIER_USAGE	&lt;C: #define SQL_QUALIFIER_USAGE 92	&gt;</body><body package="ODBCEXDI">SQL_QUERY_TIMEOUT	&lt;C: #define SQL_QUERY_TIMEOUT 0	&gt;</body><body package="ODBCEXDI">SQL_QUERY_TIMEOUT_DEFAULT	&lt;C: #define SQL_QUERY_TIMEOUT_DEFAULT 0L	&gt;</body><body package="ODBCEXDI">SQL_QUICK	&lt;C: #define SQL_QUICK 0	&gt;</body><body package="ODBCEXDI">SQL_QUIET_MODE	&lt;C: #define SQL_QUIET_MODE 111	&gt;</body><body package="ODBCEXDI">SQL_QUOTED_IDENTIFIER_CASE	&lt;C: #define SQL_QUOTED_IDENTIFIER_CASE 93	&gt;</body><body package="ODBCEXDI">SQL_QU_DML_STATEMENTS	&lt;C: #define SQL_QU_DML_STATEMENTS 0x00000001	&gt;</body><body package="ODBCEXDI">SQL_QU_INDEX_DEFINITION	&lt;C: #define SQL_QU_INDEX_DEFINITION 0x00000008	&gt;</body><body package="ODBCEXDI">SQL_QU_PRIVILEGE_DEFINITION	&lt;C: #define SQL_QU_PRIVILEGE_DEFINITION 0x00000010	&gt;</body><body package="ODBCEXDI">SQL_QU_PROCEDURE_INVOCATION	&lt;C: #define SQL_QU_PROCEDURE_INVOCATION 0x00000002	&gt;</body><body package="ODBCEXDI">SQL_QU_TABLE_DEFINITION	&lt;C: #define SQL_QU_TABLE_DEFINITION 0x00000004	&gt;</body><body package="ODBCEXDI">SQL_RD_DEFAULT	&lt;C: #define SQL_RD_DEFAULT SQL_RD_ON	&gt;</body><body package="ODBCEXDI">SQL_RD_OFF	&lt;C: #define SQL_RD_OFF 0L	&gt;</body><body package="ODBCEXDI">SQL_RD_ON	&lt;C: #define SQL_RD_ON 1L	&gt;</body><body package="ODBCEXDI">SQL_REAL	&lt;C: #define SQL_REAL 7	&gt;</body><body package="ODBCEXDI">SQL_REFRESH	&lt;C: #define SQL_REFRESH 1	&gt;</body><body package="ODBCEXDI">SQL_RESET_PARAMS	&lt;C: #define SQL_RESET_PARAMS 3	&gt;</body><body package="ODBCEXDI">SQL_RESTRICT	&lt;C: #define SQL_RESTRICT 1	&gt;</body><body package="ODBCEXDI">SQL_RESULT_COL	&lt;C: #define SQL_RESULT_COL 3	&gt;</body><body package="ODBCEXDI">SQL_RETRIEVE_DATA	&lt;C: #define SQL_RETRIEVE_DATA 11	&gt;</body><body package="ODBCEXDI">SQL_RETURN_VALUE	&lt;C: #define SQL_RETURN_VALUE 5	&gt;</body><body package="ODBCEXDI">SQL_ROLLBACK	&lt;C: #define SQL_ROLLBACK 1	&gt;</body><body package="ODBCEXDI">SQL_ROWSET_SIZE	&lt;C: #define SQL_ROWSET_SIZE 9	&gt;</body><body package="ODBCEXDI">SQL_ROWSET_SIZE_DEFAULT	&lt;C: #define SQL_ROWSET_SIZE_DEFAULT 1L	&gt;</body><body package="ODBCEXDI">SQL_ROWVER	&lt;C: #define SQL_ROWVER 2	&gt;</body><body package="ODBCEXDI">SQL_ROW_ADDED	&lt;C: #define SQL_ROW_ADDED 4	&gt;</body><body package="ODBCEXDI">SQL_ROW_DELETED	&lt;C: #define SQL_ROW_DELETED 1	&gt;</body><body package="ODBCEXDI">SQL_ROW_ERROR	&lt;C: #define SQL_ROW_ERROR 5	&gt;</body><body package="ODBCEXDI">SQL_ROW_NOROW	&lt;C: #define SQL_ROW_NOROW 3	&gt;</body><body package="ODBCEXDI">SQL_ROW_NUMBER	&lt;C: #define SQL_ROW_NUMBER 14	&gt;</body><body package="ODBCEXDI">SQL_ROW_SUCCESS	&lt;C: #define SQL_ROW_SUCCESS 0	&gt;</body><body package="ODBCEXDI">SQL_ROW_UPDATED	&lt;C: #define SQL_ROW_UPDATED 2	&gt;</body><body package="ODBCEXDI">SQL_ROW_UPDATES	&lt;C: #define SQL_ROW_UPDATES 11	&gt;</body><body package="ODBCEXDI">SQL_SCCO_LOCK	&lt;C: #define SQL_SCCO_LOCK 0x00000002	&gt;</body><body package="ODBCEXDI">SQL_SCCO_OPT_ROWVER	&lt;C: #define SQL_SCCO_OPT_ROWVER 0x00000004	&gt;</body><body package="ODBCEXDI">SQL_SCCO_OPT_TIMESTAMP	&lt;C: #define SQL_SCCO_OPT_TIMESTAMP SQL_SCCO_OPT_ROWVER	&gt;</body><body package="ODBCEXDI">SQL_SCCO_OPT_VALUES	&lt;C: #define SQL_SCCO_OPT_VALUES 0x00000008	&gt;</body><body package="ODBCEXDI">SQL_SCCO_READ_ONLY	&lt;C: #define SQL_SCCO_READ_ONLY 0x00000001	&gt;</body><body package="ODBCEXDI">SQL_SCOPE_CURROW	&lt;C: #define SQL_SCOPE_CURROW 0	&gt;</body><body package="ODBCEXDI">SQL_SCOPE_SESSION	&lt;C: #define SQL_SCOPE_SESSION 2	&gt;</body><body package="ODBCEXDI">SQL_SCOPE_TRANSACTION	&lt;C: #define SQL_SCOPE_TRANSACTION 1	&gt;</body><body package="ODBCEXDI">SQL_SCROLL_CONCURRENCY	&lt;C: #define SQL_SCROLL_CONCURRENCY 43	&gt;</body><body package="ODBCEXDI">SQL_SCROLL_DYNAMIC	&lt;C: #define SQL_SCROLL_DYNAMIC (-2)	&gt;</body><body package="ODBCEXDI">SQL_SCROLL_FORWARD_ONLY	&lt;C: #define SQL_SCROLL_FORWARD_ONLY 0	&gt;</body><body package="ODBCEXDI">SQL_SCROLL_KEYSET_DRIVEN	&lt;C: #define SQL_SCROLL_KEYSET_DRIVEN (-1)	&gt;</body><body package="ODBCEXDI">SQL_SCROLL_OPTIONS	&lt;C: #define SQL_SCROLL_OPTIONS 44	&gt;</body><body package="ODBCEXDI">SQL_SCROLL_STATIC	&lt;C: #define SQL_SCROLL_STATIC (-3)	&gt;</body><body package="ODBCEXDI">SQL_SC_NON_UNIQUE	&lt;C: #define SQL_SC_NON_UNIQUE 0L	&gt;</body><body package="ODBCEXDI">SQL_SC_TRY_UNIQUE	&lt;C: #define SQL_SC_TRY_UNIQUE 1L	&gt;</body><body package="ODBCEXDI">SQL_SC_UNIQUE	&lt;C: #define SQL_SC_UNIQUE 2L	&gt;</body><body package="ODBCEXDI">SQL_SEARCHABLE	&lt;C: #define SQL_SEARCHABLE 3	&gt;</body><body package="ODBCEXDI">SQL_SEARCH_PATTERN_ESCAPE	&lt;C: #define SQL_SEARCH_PATTERN_ESCAPE 14	&gt;</body><body package="ODBCEXDI">SQL_SERVER_NAME	&lt;C: #define SQL_SERVER_NAME 13	&gt;</body><body package="ODBCEXDI">SQL_SETPARAM_VALUE_MAX	&lt;C: #define SQL_SETPARAM_VALUE_MAX (-1)	&gt;</body><body package="ODBCEXDI">SQL_SET_NULL	&lt;C: #define SQL_SET_NULL 2	&gt;</body><body package="ODBCEXDI">SQL_SIGNED_OFFSET	&lt;C: #define SQL_SIGNED_OFFSET (-20)	&gt;</body><body package="ODBCEXDI">SQL_SIMULATE_CURSOR	&lt;C: #define SQL_SIMULATE_CURSOR 10	&gt;</body><body package="ODBCEXDI">SQL_SMALLINT	&lt;C: #define SQL_SMALLINT 5	&gt;</body><body package="ODBCEXDI">SQL_SO_DYNAMIC	&lt;C: #define SQL_SO_DYNAMIC 0x00000004	&gt;</body><body package="ODBCEXDI">SQL_SO_FORWARD_ONLY	&lt;C: #define SQL_SO_FORWARD_ONLY 0x00000001	&gt;</body><body package="ODBCEXDI">SQL_SO_KEYSET_DRIVEN	&lt;C: #define SQL_SO_KEYSET_DRIVEN 0x00000002	&gt;</body><body package="ODBCEXDI">SQL_SO_MIXED	&lt;C: #define SQL_SO_MIXED 0x00000008	&gt;</body><body package="ODBCEXDI">SQL_SO_STATIC	&lt;C: #define SQL_SO_STATIC 0x00000010	&gt;</body><body package="ODBCEXDI">SQL_SPECIAL_CHARACTERS	&lt;C: #define SQL_SPECIAL_CHARACTERS 94	&gt;</body><body package="ODBCEXDI">SQL_SPEC_MAJOR	&lt;C: #define SQL_SPEC_MAJOR 2	&gt;</body><body package="ODBCEXDI">SQL_SPEC_MINOR	&lt;C: #define SQL_SPEC_MINOR 10	&gt;</body><body package="ODBCEXDI">SQL_SPEC_STRING	&lt;C: #define SQL_SPEC_STRING "02.10"	&gt;</body><body package="ODBCEXDI">SQL_SQLSTATE_SIZE	&lt;C: #define SQL_SQLSTATE_SIZE 5	&gt;</body><body package="ODBCEXDI">SQL_SQ_COMPARISON	&lt;C: #define SQL_SQ_COMPARISON 0x00000001	&gt;</body><body package="ODBCEXDI">SQL_SQ_CORRELATED_SUBQUERIES	&lt;C: #define SQL_SQ_CORRELATED_SUBQUERIES 0x00000010	&gt;</body><body package="ODBCEXDI">SQL_SQ_EXISTS	&lt;C: #define SQL_SQ_EXISTS 0x00000002	&gt;</body><body package="ODBCEXDI">SQL_SQ_IN	&lt;C: #define SQL_SQ_IN 0x00000004	&gt;</body><body package="ODBCEXDI">SQL_SQ_QUANTIFIED	&lt;C: #define SQL_SQ_QUANTIFIED 0x00000008	&gt;</body><body package="ODBCEXDI">SQL_SS_ADDITIONS	&lt;C: #define SQL_SS_ADDITIONS 0x00000001	&gt;</body><body package="ODBCEXDI">SQL_SS_DELETIONS	&lt;C: #define SQL_SS_DELETIONS 0x00000002	&gt;</body><body package="ODBCEXDI">SQL_SS_TIME2	&lt;C: #define SQL_SS_TIME2 -154	&gt;</body><body package="ODBCEXDI">SQL_SS_UPDATES	&lt;C: #define SQL_SS_UPDATES 0x00000004	&gt;</body><body package="ODBCEXDI">SQL_STATIC_SENSITIVITY	&lt;C: #define SQL_STATIC_SENSITIVITY 83	&gt;</body><body package="ODBCEXDI">SQL_STILL_EXECUTING	&lt;C: #define SQL_STILL_EXECUTING 2	&gt;</body><body package="ODBCEXDI">SQL_STMT_OPT_MAX	&lt;C: #define SQL_STMT_OPT_MAX SQL_ROW_NUMBER	&gt;</body><body package="ODBCEXDI">SQL_STMT_OPT_MIN	&lt;C: #define SQL_STMT_OPT_MIN SQL_QUERY_TIMEOUT	&gt;</body><body package="ODBCEXDI">SQL_STRING_FUNCTIONS	&lt;C: #define SQL_STRING_FUNCTIONS 50	&gt;</body><body package="ODBCEXDI">SQL_SUBQUERIES	&lt;C: #define SQL_SUBQUERIES 95	&gt;</body><body package="ODBCEXDI">SQL_SUCCESS	&lt;C: #define SQL_SUCCESS 0	&gt;</body><body package="ODBCEXDI">SQL_SUCCESS_WITH_INFO	&lt;C: #define SQL_SUCCESS_WITH_INFO 1	&gt;</body><body package="ODBCEXDI">SQL_SYSTEM_FUNCTIONS	&lt;C: #define SQL_SYSTEM_FUNCTIONS 51	&gt;</body><body package="ODBCEXDI">SQL_TABLE_STAT	&lt;C: #define SQL_TABLE_STAT 0	&gt;</body><body package="ODBCEXDI">SQL_TABLE_TERM	&lt;C: #define SQL_TABLE_TERM 45	&gt;</body><body package="ODBCEXDI">SQL_TC_ALL	&lt;C: #define SQL_TC_ALL 0x0002	&gt;</body><body package="ODBCEXDI">SQL_TC_DDL_COMMIT	&lt;C: #define SQL_TC_DDL_COMMIT 0x0003	&gt;</body><body package="ODBCEXDI">SQL_TC_DDL_IGNORE	&lt;C: #define SQL_TC_DDL_IGNORE 0x0004	&gt;</body><body package="ODBCEXDI">SQL_TC_DML	&lt;C: #define SQL_TC_DML 0x0001	&gt;</body><body package="ODBCEXDI">SQL_TC_NONE	&lt;C: #define SQL_TC_NONE 0x0000	&gt;</body><body package="ODBCEXDI">SQL_TIME	&lt;C: #define SQL_TIME 10	&gt;</body><body package="ODBCEXDI">SQL_TIMEDATE_ADD_INTERVALS	&lt;C: #define SQL_TIMEDATE_ADD_INTERVALS 109	&gt;</body><body package="ODBCEXDI">SQL_TIMEDATE_DIFF_INTERVALS	&lt;C: #define SQL_TIMEDATE_DIFF_INTERVALS 110	&gt;</body><body package="ODBCEXDI">SQL_TIMEDATE_FUNCTIONS	&lt;C: #define SQL_TIMEDATE_FUNCTIONS 52	&gt;</body><body package="ODBCEXDI">SQL_TIMESTAMP	&lt;C: #define SQL_TIMESTAMP 11	&gt;</body><body package="ODBCEXDI">SQL_TINYINT	&lt;C: #define SQL_TINYINT (-6)	&gt;</body><body package="ODBCEXDI">SQL_TRANSLATE_DLL	&lt;C: #define SQL_TRANSLATE_DLL 106	&gt;</body><body package="ODBCEXDI">SQL_TRANSLATE_OPTION	&lt;C: #define SQL_TRANSLATE_OPTION 107	&gt;</body><body package="ODBCEXDI">SQL_TXN_CAPABLE	&lt;C: #define SQL_TXN_CAPABLE 46	&gt;</body><body package="ODBCEXDI">SQL_TXN_ISOLATION	&lt;C: #define SQL_TXN_ISOLATION 108	&gt;</body><body package="ODBCEXDI">SQL_TXN_ISOLATION_OPTION	&lt;C: #define SQL_TXN_ISOLATION_OPTION 72	&gt;</body><body package="ODBCEXDI">SQL_TXN_READ_COMMITTED	&lt;C: #define SQL_TXN_READ_COMMITTED 0x00000002	&gt;</body><body package="ODBCEXDI">SQL_TXN_READ_UNCOMMITTED	&lt;C: #define SQL_TXN_READ_UNCOMMITTED 0x00000001	&gt;</body><body package="ODBCEXDI">SQL_TXN_REPEATABLE_READ	&lt;C: #define SQL_TXN_REPEATABLE_READ 0x00000004	&gt;</body><body package="ODBCEXDI">SQL_TXN_SERIALIZABLE	&lt;C: #define SQL_TXN_SERIALIZABLE 0x00000008	&gt;</body><body package="ODBCEXDI">SQL_TXN_VERSIONING	&lt;C: #define SQL_TXN_VERSIONING 0x00000010	&gt;</body><body package="ODBCEXDI">SQL_TYPE_DRIVER_END	&lt;C: #define SQL_TYPE_DRIVER_END SQL_UNICODE	&gt;</body><body package="ODBCEXDI">SQL_TYPE_DRIVER_START	&lt;C: #define SQL_TYPE_DRIVER_START SQL_INTERVAL_YEAR	&gt;</body><body package="ODBCEXDI">SQL_TYPE_MAX	&lt;C: #define SQL_TYPE_MAX SQL_VARCHAR	&gt;</body><body package="ODBCEXDI">SQL_TYPE_MIN	&lt;C: #define SQL_TYPE_MIN SQL_BIT	&gt;</body><body package="ODBCEXDI">SQL_TYPE_NULL	&lt;C: #define SQL_TYPE_NULL 0	&gt;</body><body package="ODBCEXDI">SQL_UB_DEFAULT	&lt;C: #define SQL_UB_DEFAULT SQL_UB_OFF	&gt;</body><body package="ODBCEXDI">SQL_UB_OFF	&lt;C: #define SQL_UB_OFF 0L	&gt;</body><body package="ODBCEXDI">SQL_UB_ON	&lt;C: #define SQL_UB_ON 1L	&gt;</body><body package="ODBCEXDI">SQL_UNBIND	&lt;C: #define SQL_UNBIND 2	&gt;</body><body package="ODBCEXDI">SQL_UNICODE	&lt;C: #define SQL_UNICODE (-95)	&gt;</body><body package="ODBCEXDI">SQL_UNION	&lt;C: #define SQL_UNION 96	&gt;</body><body package="ODBCEXDI">SQL_UNSEARCHABLE	&lt;C: #define SQL_UNSEARCHABLE 0	&gt;</body><body package="ODBCEXDI">SQL_UNSIGNED_OFFSET	&lt;C: #define SQL_UNSIGNED_OFFSET (-22)	&gt;</body><body package="ODBCEXDI">SQL_UPDATE	&lt;C: #define SQL_UPDATE 2	&gt;</body><body package="ODBCEXDI">SQL_USER_NAME	&lt;C: #define SQL_USER_NAME 47	&gt;</body><body package="ODBCEXDI">SQL_USE_BOOKMARKS	&lt;C: #define SQL_USE_BOOKMARKS 12	&gt;</body><body package="ODBCEXDI">SQL_U_UNION	&lt;C: #define SQL_U_UNION 0x00000001	&gt;</body><body package="ODBCEXDI">SQL_U_UNION_ALL	&lt;C: #define SQL_U_UNION_ALL 0x00000002	&gt;</body><body package="ODBCEXDI">SQL_VARBINARY	&lt;C: #define SQL_VARBINARY (-3)	&gt;</body><body package="ODBCEXDI">SQL_VARCHAR	&lt;C: #define SQL_VARCHAR 12	&gt;</body><body package="ODBCEXDI">SQL_VARGRAPHIC	&lt;C: #define SQL_VARGRAPHIC -96	&gt;</body><body package="ODBCEXDI">SQL_VARIANT	&lt;C: #define SQL_VARIANT -150	&gt;</body><body package="ODBCEXDI">SQL_WCHAR	&lt;C: #define SQL_WCHAR -8	&gt;</body><body package="ODBCEXDI">SQL_WLONGVARCHAR	&lt;C: #define SQL_WLONGVARCHAR -10	&gt;</body><body package="ODBCEXDI">SQL_WVARCHAR	&lt;C: #define SQL_WVARCHAR -9	&gt;</body><body package="ODBCEXDI">SQL_XL_OFF	&lt;C: #define SQL_XL_OFF 0	&gt;</body><body package="ODBCEXDI">SQL_XL_ON	&lt;C: #define SQL_XL_OFF 1	&gt;</body><body package="ODBCEXDI">__DATE__	&lt;C: #define __DATE__ "April 17, 1996"	&gt;</body><body package="ODBCEXDI">__FILE__	&lt;C: #define __FILE__ 	&gt;</body><body package="ODBCEXDI">__LINE__	&lt;C: #define __LINE__ 0	&gt;</body><body package="ODBCEXDI">__SQL	&lt;C: #define __SQL 	&gt;</body><body package="ODBCEXDI">__SQLEXT	&lt;C: #define __SQLEXT 	&gt;</body><body package="ODBCEXDI">__STDC__	&lt;C: #define __STDC__ 1	&gt;</body><body package="ODBCEXDI">__TIME__	&lt;C: #define __TIME__ "8:51:38 pm"	&gt;</body></methods><methods><class-id>Database.ODBCCLIInterface</class-id> <category>defines 3.0</category><body package="ODBCEXDI">SQL_ATTR_OUTPUT_NTS	&lt;C: #define	SQL_ATTR_OUTPUT_NTS 10001	&gt;</body><body package="ODBCEXDI">SQL_ATTR_ROWS_FETCHED_PTR	&lt;C: #define	SQL_ATTR_ROWS_FETCHED_PTR 26	&gt;</body><body package="ODBCEXDI">SQL_ATTR_ROW_STATUS_PTR	&lt;C: #define	SQL_ATTR_ROW_STATUS_PTR 25	&gt;</body><body package="ODBCEXDI">SQL_HANDLE_DBC	&lt;C: #define SQL_HANDLE_DBC            2	&gt;</body><body package="ODBCEXDI">SQL_HANDLE_DESC	&lt;C: #define SQL_HANDLE_DESC            4	&gt;</body><body package="ODBCEXDI">SQL_HANDLE_ENV	&lt;C: #define SQL_HANDLE_ENV            1	&gt;</body><body package="ODBCEXDI">SQL_HANDLE_STMT	&lt;C: #define SQL_HANDLE_STMT            3	&gt;</body><body package="ODBCEXDI">SQL_NULL_HANDLE	&lt;C: #define SQL_NULL_HANDLE     0	&gt;</body><body package="ODBCEXDI">SQL_TYPE_DATE	&lt;C: #define SQL_TYPE_DATE 91	&gt;</body><body package="ODBCEXDI">SQL_TYPE_TIMESTAMP	&lt;C: #define SQL_TYPE_TIMESTAMP 93	&gt;</body></methods><methods><class-id>Database.ODBCCLIInterface</class-id> <category>types</category><body package="ODBCEXDI">BOOKMARK	&lt;C: typedef unsigned int BOOKMARK&gt;</body><body package="ODBCEXDI">DATE_STRUCT	&lt;C: typedef struct tagDATE_STRUCT DATE_STRUCT&gt;</body><body package="ODBCEXDI">HDBC	&lt;C: typedef void * HDBC&gt;</body><body package="ODBCEXDI">HENV	&lt;C: typedef void * HENV&gt;</body><body package="ODBCEXDI">HSTMT	&lt;C: typedef void * HSTMT&gt;</body><body package="ODBCEXDI">HWND	&lt;C: typedef void * HWND&gt;</body><body package="ODBCEXDI">LDOUBLE	&lt;C: typedef double LDOUBLE&gt;</body><body package="ODBCEXDI">PSDWORD	&lt;C: typedef int * PSDWORD&gt;</body><body package="ODBCEXDI">PSWORD	&lt;C: typedef int * PSWORD&gt;</body><body package="ODBCEXDI">PTR	&lt;C: typedef void * PTR&gt;</body><body package="ODBCEXDI">PUSDWORD	&lt;C: typedef unsigned int * PUSDWORD&gt;</body><body package="ODBCEXDI">PUSWORD	&lt;C: typedef unsigned int * PUSWORD&gt;</body><body package="ODBCEXDI">RETCODE	&lt;C: typedef short RETCODE&gt;</body><body package="ODBCEXDI">SCHAR	&lt;C: typedef char SCHAR&gt;</body><body package="ODBCEXDI">SDOUBLE	&lt;C: typedef double SDOUBLE&gt;</body><body package="ODBCEXDI">SDWORD	&lt;C: typedef int SDWORD&gt;</body><body package="ODBCEXDI">SFLOAT	&lt;C: typedef float SFLOAT&gt;</body><body package="ODBCEXDI">SLONG	&lt;C: typedef int SLONG&gt;</body><body package="ODBCEXDI">SQLHANDLE	&lt;C: typedef void * SQLHANDLE&gt;</body><body package="ODBCEXDI">SQLINTEGER	&lt;C: typedef int SQLINTEGER&gt;</body><body package="ODBCEXDI">SQLLEN	&lt;C: typedef int SQLLEN&gt;</body><body package="ODBCEXDI">SQLUINTEGER	&lt;C: typedef unsigned int SQLUINTEGER&gt;</body><body package="ODBCEXDI">SQLULEN	&lt;C: typedef unsigned int SQLULEN&gt;</body><body package="ODBCEXDI">SSHORT	&lt;C: typedef short SSHORT&gt;</body><body package="ODBCEXDI">SWORD	&lt;C: typedef short SWORD&gt;</body><body package="ODBCEXDI">TIMESTAMP_STRUCT	&lt;C: typedef struct tagTIMESTAMP_STRUCT TIMESTAMP_STRUCT&gt;</body><body package="ODBCEXDI">TIME_STRUCT	&lt;C: typedef struct tagTIME_STRUCT TIME_STRUCT&gt;</body><body package="ODBCEXDI">UCHAR	&lt;C: typedef unsigned char UCHAR&gt;</body><body package="ODBCEXDI">UDWORD	&lt;C: typedef unsigned int UDWORD&gt;</body><body package="ODBCEXDI">ULONG	&lt;C: typedef unsigned int ULONG&gt;</body><body package="ODBCEXDI">USHORT	&lt;C: typedef unsigned short USHORT&gt;</body><body package="ODBCEXDI">UWORD	&lt;C: typedef unsigned short UWORD&gt;</body><body package="ODBCEXDI">WCHAR	&lt;C: typedef unsigned short WCHAR&gt;</body></methods><methods><class-id>Database.ODBCCLIInterface</class-id> <category>structs</category><body package="ODBCEXDI">tagDATE_STRUCT	&lt;C: struct tagDATE_STRUCT {			SWORD year;			UWORD month, day;		}&gt;</body><body package="ODBCEXDI">tagTIMESTAMP_STRUCT	&lt;C: struct tagTIMESTAMP_STRUCT {			SWORD year;			UWORD month, day, hour, minute, second;			UDWORD fraction;		}&gt;</body><body package="ODBCEXDI">tagTIME_STRUCT	&lt;C: struct tagTIME_STRUCT {			UWORD hour, minute, second;		}&gt;</body></methods><methods><class-id>Database.ODBCCLI64BitInterface</class-id> <category>types</category><body package="ODBCEXDI">SQLLEN	&lt;C: typedef long SQLLEN&gt;</body><body package="ODBCEXDI">SQLULEN	&lt;C: typedef unsigned long SQLULEN&gt;</body><body package="ODBCEXDI">UINT64	&lt;C: typedef unsigned long UINT64&gt;</body></methods><methods><class-id>Database.ODBCCLIInterface</class-id> <category>procedures</category><body package="ODBCEXDI">SQLAllocConnect: henv with: phdbc	&lt;C: RETCODE SQLAllocConnect(HENV henv, HDBC * phdbc)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLAllocEnv: phenv	&lt;C: RETCODE SQLAllocEnv(HENV * phenv)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLAllocStmt: hdbc with: phstmt	&lt;C: RETCODE SQLAllocStmt(HDBC hdbc, HSTMT * phstmt)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLBindCol: hstmt with: icol with: fCType with: rgbValue with: cbValueMax with: pcbValue	&lt;C: RETCODE SQLBindCol(HSTMT hstmt, UWORD icol, SWORD fCType, PTR rgbValue, SDWORD cbValueMax, SDWORD * pcbValue)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLBindParameter: hstmt with: ipar with: fParamType with: fCType with: fSqlType with: cbColDef with: ibScale with: rgbValue with: cbValueMax with: pcbValue	&lt;C: RETCODE SQLBindParameter(HSTMT hstmt, UWORD ipar, SWORD fParamType, SWORD fCType, SWORD fSqlType, UDWORD cbColDef, SWORD ibScale, PTR rgbValue, SDWORD cbValueMax, SDWORD * pcbValue)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLBrowseConnect: hdbc with: szConnStrIn with: cbConnStrIn with: szConnStrOut with: cbConnStrOutMax with: pcbConnStrOut	&lt;C: RETCODE SQLBrowseConnect(HDBC hdbc, UCHAR * szConnStrIn, SWORD cbConnStrIn, UCHAR * szConnStrOut, SWORD cbConnStrOutMax, SWORD * pcbConnStrOut)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLBrowseConnectW: hdbc with: szConnStrIn with: cbConnStrIn with: szConnStrOut with: cbConnStrOutMax with: pcbConnStrOut	&lt;C: RETCODE SQLBrowseConnectW(HDBC hdbc, UCHAR * szConnStrIn, SWORD cbConnStrIn, UCHAR * szConnStrOut, SWORD cbConnStrOutMax, SWORD * pcbConnStrOut)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLCancel: hstmt	&lt;C: RETCODE SQLCancel(HSTMT hstmt)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLColAttributes: hstmt with: icol with: fDescType with: rgbDesc with: cbDescMax with: pcbDesc with: pfDesc	&lt;C: RETCODE SQLColAttributes(HSTMT hstmt, UWORD icol, UWORD fDescType, PTR rgbDesc, SWORD cbDescMax, SWORD * pcbDesc, SDWORD * pfDesc)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLColAttributesW: hstmt with: icol with: fDescType with: rgbDesc with: cbDescMax with: pcbDesc with: pfDesc	&lt;C: RETCODE SQLColAttributesW(HSTMT hstmt, UWORD icol, UWORD fDescType, PTR rgbDesc, SWORD cbDescMax, SWORD * pcbDesc, SDWORD * pfDesc)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLColumnPrivileges: hstmt with: szTableQualifier with: cbTableQualifier with: szTableOwner with: cbTableOwner with: szTableName with: cbTableName with: szColumnName with: cbColumnName	&lt;C: RETCODE SQLColumnPrivileges(HSTMT hstmt, UCHAR * szTableQualifier, SWORD cbTableQualifier, UCHAR * szTableOwner, SWORD cbTableOwner, UCHAR * szTableName, SWORD cbTableName, UCHAR * szColumnName, SWORD cbColumnName)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLColumnPrivilegesW: hstmt with: szTableQualifier with: cbTableQualifier with: szTableOwner with: cbTableOwner with: szTableName with: cbTableName with: szColumnName with: cbColumnName	&lt;C: RETCODE SQLColumnPrivilegesW(HSTMT hstmt, UCHAR * szTableQualifier, SWORD cbTableQualifier, UCHAR * szTableOwner, SWORD cbTableOwner, UCHAR * szTableName, SWORD cbTableName, UCHAR * szColumnName, SWORD cbColumnName)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLColumns: hstmt with: szTableQualifier with: cbTableQualifier with: szTableOwner with: cbTableOwner with: szTableName with: cbTableName with: szColumnName with: cbColumnName	&lt;C: RETCODE SQLColumns(HSTMT hstmt, UCHAR * szTableQualifier, SWORD cbTableQualifier, UCHAR * szTableOwner, SWORD cbTableOwner, UCHAR * szTableName, SWORD cbTableName, UCHAR * szColumnName, SWORD cbColumnName)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLColumnsW: hstmt with: szTableQualifier with: cbTableQualifier with: szTableOwner with: cbTableOwner with: szTableName with: cbTableName with: szColumnName with: cbColumnName	&lt;C: RETCODE SQLColumnsW(HSTMT hstmt, UCHAR * szTableQualifier, SWORD cbTableQualifier, UCHAR * szTableOwner, SWORD cbTableOwner, UCHAR * szTableName, SWORD cbTableName, UCHAR * szColumnName, SWORD cbColumnName)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLConnect: hdbc with: szDSN with: cbDSN with: szUID with: cbUID with: szAuthStr with: cbAuthStr	&lt;C: RETCODE SQLConnect(HDBC hdbc, UCHAR * szDSN, SWORD cbDSN, UCHAR * szUID, SWORD cbUID, UCHAR * szAuthStr, SWORD cbAuthStr)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLConnectW: hdbc with: szDSN with: cbDSN with: szUID with: cbUID with: szAuthStr with: cbAuthStr	&lt;C: RETCODE SQLConnectW(HDBC hdbc, UCHAR * szDSN, SWORD cbDSN, UCHAR * szUID, SWORD cbUID, UCHAR * szAuthStr, SWORD cbAuthStr)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLDataSources: henv with: fDirection with: szDSN with: cbDSNMax with: pcbDSN with: szDescription with: cbDescriptionMax with: pcbDescription	&lt;C: RETCODE SQLDataSources(HENV henv, UWORD fDirection, UCHAR * szDSN, SWORD cbDSNMax, SWORD * pcbDSN, UCHAR * szDescription, SWORD cbDescriptionMax, SWORD * pcbDescription)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLDataSourcesW: henv with: fDirection with: szDSN with: cbDSNMax with: pcbDSN with: szDescription with: cbDescriptionMax with: pcbDescription	&lt;C: RETCODE SQLDataSourcesW(HENV henv, UWORD fDirection, UCHAR * szDSN, SWORD cbDSNMax, SWORD * pcbDSN, UCHAR * szDescription, SWORD cbDescriptionMax, SWORD * pcbDescription)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLDescribeCol: hstmt with: icol with: szColName with: cbColNameMax with: pcbColName with: pfSqlType with: pcbColDef with: pibScale with: pfNullable	&lt;C: RETCODE SQLDescribeCol(HSTMT hstmt, UWORD icol, UCHAR * szColName, SWORD cbColNameMax, SWORD * pcbColName, SWORD * pfSqlType, UDWORD * pcbColDef, SWORD * pibScale, SWORD * pfNullable)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLDescribeColW: hstmt with: icol with: szColName with: cbColNameMax with: pcbColName with: pfSqlType with: pcbColDef with: pibScale with: pfNullable	&lt;C: RETCODE SQLDescribeColW(HSTMT hstmt, UWORD icol, UCHAR * szColName, SWORD cbColNameMax, SWORD * pcbColName, SWORD * pfSqlType, UDWORD * pcbColDef, SWORD * pibScale, SWORD * pfNullable)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLDescribeParam: hstmt with: ipar with: pfSqlType with: pcbColDef with: pibScale with: pfNullable	&lt;C: RETCODE SQLDescribeParam(HSTMT hstmt, UWORD ipar, SWORD * pfSqlType, UDWORD * pcbColDef, SWORD * pibScale, SWORD * pfNullable)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLDisconnect: hdbc	&lt;C: RETCODE SQLDisconnect(HDBC hdbc)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLDriverConnect: hdbc with: hwnd with: szConnStrIn with: cbConnStrIn with: szConnStrOut with: cbConnStrOutMax with: pcbConnStrOut with: fDriverCompletion	&lt;C: RETCODE SQLDriverConnect(HDBC hdbc, HWND hwnd, UCHAR * szConnStrIn, SWORD cbConnStrIn, UCHAR * szConnStrOut, SWORD cbConnStrOutMax, SWORD * pcbConnStrOut, UWORD fDriverCompletion)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLDriverConnectW: hdbc with: hwnd with: szConnStrIn with: cbConnStrIn with: szConnStrOut with: cbConnStrOutMax with: pcbConnStrOut with: fDriverCompletion	&lt;C: RETCODE SQLDriverConnectW(HDBC hdbc, HWND hwnd, UCHAR * szConnStrIn, SWORD cbConnStrIn, UCHAR * szConnStrOut, SWORD cbConnStrOutMax, SWORD * pcbConnStrOut, UWORD fDriverCompletion)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLDrivers: henv with: fDirection with: szDriverDesc with: cbDriverDescMax with: pcbDriverDesc with: szDriverAttributes with: cbDrvrAttrMax with: pcbDrvrAttr	&lt;C: RETCODE SQLDrivers(HENV henv, UWORD fDirection, UCHAR * szDriverDesc, SWORD cbDriverDescMax, SWORD * pcbDriverDesc, UCHAR * szDriverAttributes, SWORD cbDrvrAttrMax, SWORD * pcbDrvrAttr)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLDriversW: henv with: fDirection with: szDriverDesc with: cbDriverDescMax with: pcbDriverDesc with: szDriverAttributes with: cbDrvrAttrMax with: pcbDrvrAttr	&lt;C: RETCODE SQLDriversW(HENV henv, UWORD fDirection, UCHAR * szDriverDesc, SWORD cbDriverDescMax, SWORD * pcbDriverDesc, UCHAR * szDriverAttributes, SWORD cbDrvrAttrMax, SWORD * pcbDrvrAttr)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLError: henv with: hdbc with: hstmt with: szSqlState with: pfNativeError with: szErrorMsg with: cbErrorMsgMax with: pcbErrorMsg	&lt;C: RETCODE SQLError(HENV henv, HDBC hdbc, HSTMT hstmt, UCHAR * szSqlState, SDWORD * pfNativeError, UCHAR * szErrorMsg, SWORD cbErrorMsgMax, SWORD * pcbErrorMsg)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLErrorW: henv with: hdbc with: hstmt with: szSqlState with: pfNativeError with: szErrorMsg with: cbErrorMsgMax with: pcbErrorMsg	&lt;C: RETCODE SQLErrorW(HENV henv, HDBC hdbc, HSTMT hstmt, UCHAR * szSqlState, SDWORD * pfNativeError, UCHAR * szErrorMsg, SWORD cbErrorMsgMax, SWORD * pcbErrorMsg)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLExecDirect: hstmt with: szSqlStr with: cbSqlStr	&lt;C: RETCODE SQLExecDirect(HSTMT hstmt, UCHAR * szSqlStr, SDWORD cbSqlStr)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLExecDirectW: hstmt with: szSqlStr with: cbSqlStr	&lt;C: RETCODE SQLExecDirectW(HSTMT hstmt, UCHAR * szSqlStr, SDWORD cbSqlStr)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLExecute: hstmt	&lt;C: RETCODE SQLExecute(HSTMT hstmt)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLExtendedFetch: hstmt with: fFetchType with: irow with: pcrow with: rgfRowStatus	&lt;C: RETCODE SQLExtendedFetch(HSTMT hstmt, UWORD fFetchType, SDWORD irow, UDWORD * pcrow, UWORD * rgfRowStatus)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLFetch: hstmt	&lt;C: RETCODE SQLFetch(HSTMT hstmt)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLForeignKeys: hstmt with: szPkTableQualifier with: cbPkTableQualifier with: szPkTableOwner with: cbPkTableOwner with: szPkTableName with: cbPkTableName with: szFkTableQualifier with: cbFkTableQualifier with: szFkTableOwner with: cbFkTableOwner with: szFkTableName with: cbFkTableName	&lt;C: RETCODE SQLForeignKeys(HSTMT hstmt, UCHAR * szPkTableQualifier, SWORD cbPkTableQualifier, UCHAR * szPkTableOwner, SWORD cbPkTableOwner, UCHAR * szPkTableName, SWORD cbPkTableName, UCHAR * szFkTableQualifier, SWORD cbFkTableQualifier, UCHAR * szFkTableOwner, SWORD cbFkTableOwner, UCHAR * szFkTableName, SWORD cbFkTableName)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLForeignKeysW: hstmt with: szPkTableQualifier with: cbPkTableQualifier with: szPkTableOwner with: cbPkTableOwner with: szPkTableName with: cbPkTableName with: szFkTableQualifier with: cbFkTableQualifier with: szFkTableOwner with: cbFkTableOwner with: szFkTableName with: cbFkTableName	&lt;C: RETCODE SQLForeignKeysW(HSTMT hstmt, UCHAR * szPkTableQualifier, SWORD cbPkTableQualifier, UCHAR * szPkTableOwner, SWORD cbPkTableOwner, UCHAR * szPkTableName, SWORD cbPkTableName, UCHAR * szFkTableQualifier, SWORD cbFkTableQualifier, UCHAR * szFkTableOwner, SWORD cbFkTableOwner, UCHAR * szFkTableName, SWORD cbFkTableName)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLFreeConnect: hdbc	&lt;C: RETCODE SQLFreeConnect(HDBC hdbc)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLFreeEnv: henv	&lt;C: RETCODE SQLFreeEnv(HENV henv)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLFreeStmt: hstmt with: fOption	&lt;C: RETCODE SQLFreeStmt(HSTMT hstmt, UWORD fOption)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLGetConnectOption: hdbc with: fOption with: pvParam	&lt;C: RETCODE SQLGetConnectOption(HDBC hdbc, UWORD fOption, PTR pvParam)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLGetConnectOptionW: hdbc with: fOption with: pvParam	&lt;C: RETCODE SQLGetConnectOptionW(HDBC hdbc, UWORD fOption, PTR pvParam)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLGetCursorName: hstmt with: szCursor with: cbCursorMax with: pcbCursor	&lt;C: RETCODE SQLGetCursorName(HSTMT hstmt, UCHAR * szCursor, SWORD cbCursorMax, SWORD * pcbCursor)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLGetCursorNameW: hstmt with: szCursor with: cbCursorMax with: pcbCursor	&lt;C: RETCODE SQLGetCursorNameW(HSTMT hstmt, UCHAR * szCursor, SWORD cbCursorMax, SWORD * pcbCursor)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLGetData: hstmt with: icol with: fCType with: rgbValue with: cbValueMax with: pcbValue	&lt;C: RETCODE SQLGetData(HSTMT hstmt, UWORD icol, SWORD fCType, PTR rgbValue, SDWORD cbValueMax, SDWORD * pcbValue)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLGetFunctions: hdbc with: fFunction with: pfExists	&lt;C: RETCODE SQLGetFunctions(HDBC hdbc, UWORD fFunction, UWORD * pfExists)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLGetInfo: hdbc with: fInfoType with: rgbInfoValue with: cbInfoValueMax with: pcbInfoValue	&lt;C: RETCODE SQLGetInfo(HDBC hdbc, UWORD fInfoType, PTR rgbInfoValue, SWORD cbInfoValueMax, SWORD * pcbInfoValue)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLGetInfoW: hdbc with: fInfoType with: rgbInfoValue with: cbInfoValueMax with: pcbInfoValue	&lt;C: RETCODE SQLGetInfoW(HDBC hdbc, UWORD fInfoType, PTR rgbInfoValue, SWORD cbInfoValueMax, SWORD * pcbInfoValue)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLGetStmtOption: hstmt with: fOption with: pvParam	&lt;C: RETCODE SQLGetStmtOption(HSTMT hstmt, UWORD fOption, PTR pvParam)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLGetStmtOptionW: hstmt with: fOption with: pvParam	&lt;C: RETCODE SQLGetStmtOptionW(HSTMT hstmt, UWORD fOption, PTR pvParam)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLGetTypeInfo: hstmt with: fSqlType	&lt;C: RETCODE SQLGetTypeInfo(HSTMT hstmt, SWORD fSqlType)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLMoreResults: hstmt	&lt;C: RETCODE SQLMoreResults(HSTMT hstmt)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLNativeSql: hdbc with: szSqlStrIn with: cbSqlStrIn with: szSqlStr with: cbSqlStrMax with: pcbSqlStr	&lt;C: RETCODE SQLNativeSql(HDBC hdbc, UCHAR * szSqlStrIn, SDWORD cbSqlStrIn, UCHAR * szSqlStr, SDWORD cbSqlStrMax, SDWORD * pcbSqlStr)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLNumParams: hstmt with: pcpar	&lt;C: RETCODE SQLNumParams(HSTMT hstmt, SWORD * pcpar)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLNumResultCols: hstmt with: pccol	&lt;C: RETCODE SQLNumResultCols(HSTMT hstmt, SWORD * pccol)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLParamData: hstmt with: prgbValue	&lt;C: RETCODE SQLParamData(HSTMT hstmt, PTR * prgbValue)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLParamOptions: hstmt with: crow with: pirow	&lt;C: RETCODE SQLParamOptions(HSTMT hstmt, UDWORD crow, UDWORD * pirow)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLPrepare: hstmt with: szSqlStr with: cbSqlStr	&lt;C: RETCODE SQLPrepare(HSTMT hstmt, UCHAR * szSqlStr, SDWORD cbSqlStr)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLPrepareW: hstmt with: szSqlStr with: cbSqlStr	&lt;C: RETCODE SQLPrepareW(HSTMT hstmt, UCHAR * szSqlStr, SDWORD cbSqlStr)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLPrimaryKeys: hstmt with: szTableQualifier with: cbTableQualifier with: szTableOwner with: cbTableOwner with: szTableName with: cbTableName	&lt;C: RETCODE SQLPrimaryKeys(HSTMT hstmt, UCHAR * szTableQualifier, SWORD cbTableQualifier, UCHAR * szTableOwner, SWORD cbTableOwner, UCHAR * szTableName, SWORD cbTableName)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLPrimaryKeysW: hstmt with: szTableQualifier with: cbTableQualifier with: szTableOwner with: cbTableOwner with: szTableName with: cbTableName	&lt;C: RETCODE SQLPrimaryKeysW(HSTMT hstmt, UCHAR * szTableQualifier, SWORD cbTableQualifier, UCHAR * szTableOwner, SWORD cbTableOwner, UCHAR * szTableName, SWORD cbTableName)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLProcedureColumns: hstmt with: szProcQualifier with: cbProcQualifier with: szProcOwner with: cbProcOwner with: szProcName with: cbProcName with: szColumnName with: cbColumnName	&lt;C: RETCODE SQLProcedureColumns(HSTMT hstmt, UCHAR * szProcQualifier, SWORD cbProcQualifier, UCHAR * szProcOwner, SWORD cbProcOwner, UCHAR * szProcName, SWORD cbProcName, UCHAR * szColumnName, SWORD cbColumnName)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLProcedureColumnsW: hstmt with: szProcQualifier with: cbProcQualifier with: szProcOwner with: cbProcOwner with: szProcName with: cbProcName with: szColumnName with: cbColumnName	&lt;C: RETCODE SQLProcedureColumnsW(HSTMT hstmt, UCHAR * szProcQualifier, SWORD cbProcQualifier, UCHAR * szProcOwner, SWORD cbProcOwner, UCHAR * szProcName, SWORD cbProcName, UCHAR * szColumnName, SWORD cbColumnName)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLProcedures: hstmt with: szProcQualifier with: cbProcQualifier with: szProcOwner with: cbProcOwner with: szProcName with: cbProcName	&lt;C: RETCODE SQLProcedures(HSTMT hstmt, UCHAR * szProcQualifier, SWORD cbProcQualifier, UCHAR * szProcOwner, SWORD cbProcOwner, UCHAR * szProcName, SWORD cbProcName)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLProceduresW: hstmt with: szProcQualifier with: cbProcQualifier with: szProcOwner with: cbProcOwner with: szProcName with: cbProcName	&lt;C: RETCODE SQLProceduresW(HSTMT hstmt, UCHAR * szProcQualifier, SWORD cbProcQualifier, UCHAR * szProcOwner, SWORD cbProcOwner, UCHAR * szProcName, SWORD cbProcName)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLPutData: hstmt with: rgbValue with: cbValue	&lt;C: RETCODE SQLPutData(HSTMT hstmt, PTR rgbValue, SDWORD cbValue)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLRowCount: hstmt with: pcrow	&lt;C: RETCODE SQLRowCount(HSTMT hstmt, SDWORD * pcrow)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLSetConnectOption: hdbc with: fOption with: vParam	&lt;C: RETCODE SQLSetConnectOption(HDBC hdbc, UWORD fOption, UDWORD vParam)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLSetConnectOptionW: hdbc with: fOption with: vParam	&lt;C: RETCODE SQLSetConnectOptionW(HDBC hdbc, UWORD fOption, UDWORD vParam)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLSetCursorName: hstmt with: szCursor with: cbCursor	&lt;C: RETCODE SQLSetCursorName(HSTMT hstmt, UCHAR * szCursor, SWORD cbCursor)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLSetCursorNameW: hstmt with: szCursor with: cbCursor	&lt;C: RETCODE SQLSetCursorNameW(HSTMT hstmt, UCHAR * szCursor, SWORD cbCursor)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLSetEnvAttr: henv with: attrName with: valuePointer with: attrType	&lt;C: RETCODE SQLSetEnvAttr(HENV henv, SDWORD attrName, PTR valuePointer, SDWORD attrType)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLSetParam: hstmt with: ipar with: fCType with: fSqlType with: cbColDef with: ibScale with: rgbValue with: pcbValue	&lt;C: RETCODE SQLSetParam(HSTMT hstmt, UWORD ipar, SWORD fCType, SWORD fSqlType, UDWORD cbColDef, SWORD ibScale, PTR rgbValue, SDWORD * pcbValue)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLSetPos: hstmt with: irow with: fOption with: fLock	&lt;C: RETCODE SQLSetPos(HSTMT hstmt, UWORD irow, UWORD fOption, UWORD fLock)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLSetScrollOptions: hstmt with: fConcurrency with: crowKeyset with: crowRowset	&lt;C: RETCODE SQLSetScrollOptions(HSTMT hstmt, UWORD fConcurrency, SDWORD crowKeyset, UWORD crowRowset)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLSetStmtOption: hstmt with: fOption with: vParam	&lt;C: RETCODE SQLSetStmtOption(HSTMT hstmt, UWORD fOption, UDWORD vParam)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLSetStmtOptionW: hstmt with: fOption with: vParam	&lt;C: RETCODE SQLSetStmtOptionW(HSTMT hstmt, UWORD fOption, UDWORD vParam)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLSpecialColumns: hstmt with: fColType with: szTableQualifier with: cbTableQualifier with: szTableOwner with: cbTableOwner with: szTableName with: cbTableName with: fScope with: fNullable	&lt;C: RETCODE SQLSpecialColumns(HSTMT hstmt, UWORD fColType, UCHAR * szTableQualifier, SWORD cbTableQualifier, UCHAR * szTableOwner, SWORD cbTableOwner, UCHAR * szTableName, SWORD cbTableName, UWORD fScope, UWORD fNullable)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLSpecialColumnsW: hstmt with: fColType with: szTableQualifier with: cbTableQualifier with: szTableOwner with: cbTableOwner with: szTableName with: cbTableName with: fScope with: fNullable	&lt;C: RETCODE SQLSpecialColumnsW(HSTMT hstmt, UWORD fColType, UCHAR * szTableQualifier, SWORD cbTableQualifier, UCHAR * szTableOwner, SWORD cbTableOwner, UCHAR * szTableName, SWORD cbTableName, UWORD fScope, UWORD fNullable)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLStatistics: hstmt with: szTableQualifier with: cbTableQualifier with: szTableOwner with: cbTableOwner with: szTableName with: cbTableName with: fUnique with: fAccuracy	&lt;C: RETCODE SQLStatistics(HSTMT hstmt, UCHAR * szTableQualifier, SWORD cbTableQualifier, UCHAR * szTableOwner, SWORD cbTableOwner, UCHAR * szTableName, SWORD cbTableName, UWORD fUnique, UWORD fAccuracy)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLStatisticsW: hstmt with: szTableQualifier with: cbTableQualifier with: szTableOwner with: cbTableOwner with: szTableName with: cbTableName with: fUnique with: fAccuracy	&lt;C: RETCODE SQLStatisticsW(HSTMT hstmt, UCHAR * szTableQualifier, SWORD cbTableQualifier, UCHAR * szTableOwner, SWORD cbTableOwner, UCHAR * szTableName, SWORD cbTableName, UWORD fUnique, UWORD fAccuracy)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLTablePrivileges: hstmt with: szTableQualifier with: cbTableQualifier with: szTableOwner with: cbTableOwner with: szTableName with: cbTableName	&lt;C: RETCODE SQLTablePrivileges(HSTMT hstmt, UCHAR * szTableQualifier, SWORD cbTableQualifier, UCHAR * szTableOwner, SWORD cbTableOwner, UCHAR * szTableName, SWORD cbTableName)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLTablePrivilegesW: hstmt with: szTableQualifier with: cbTableQualifier with: szTableOwner with: cbTableOwner with: szTableName with: cbTableName	&lt;C: RETCODE SQLTablePrivilegesW(HSTMT hstmt, UCHAR * szTableQualifier, SWORD cbTableQualifier, UCHAR * szTableOwner, SWORD cbTableOwner, UCHAR * szTableName, SWORD cbTableName)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLTables: hstmt with: szTableQualifier with: cbTableQualifier with: szTableOwner with: cbTableOwner with: szTableName with: cbTableName with: szTableType with: cbTableType	&lt;C: RETCODE SQLTables(HSTMT hstmt, UCHAR * szTableQualifier, SWORD cbTableQualifier, UCHAR * szTableOwner, SWORD cbTableOwner, UCHAR * szTableName, SWORD cbTableName, UCHAR * szTableType, SWORD cbTableType)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLTablesW: hstmt with: szTableQualifier with: cbTableQualifier with: szTableOwner with: cbTableOwner with: szTableName with: cbTableName with: szTableType with: cbTableType	&lt;C: RETCODE SQLTablesW(HSTMT hstmt, UCHAR * szTableQualifier, SWORD cbTableQualifier, UCHAR * szTableOwner, SWORD cbTableOwner, UCHAR * szTableName, SWORD cbTableName, UCHAR * szTableType, SWORD cbTableType)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLTransact: henv with: hdbc with: fType	&lt;C: RETCODE SQLTransact(HENV henv, HDBC hdbc, UWORD fType)&gt;	^self externalAccessFailed</body></methods><methods><class-id>Database.ODBCCLIInterface</class-id> <category>procedures 3.0</category><body package="ODBCEXDI">SQLAllocHandle: handleType with: inputHandle with: outputHandlePtr	&lt;C: RETCODE SQLAllocHandle(      SWORD   handleType,      SQLHANDLE     inputHandle,      SQLHANDLE *   outputHandlePtr)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLCloseCursor: statementHandle	&lt;C: RETCODE SQLCloseCursor(     SQLHSTMT     statementHandle)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLColAttribute: statementHandle with: columnNumber with: fieldIdentifier with: characterAttributePtr with: bufferLength with: stringLengthPtr with: numericAttributePtr	&lt;C: RETCODE SQLColAttribute (      SQLHSTMT        statementHandle,      SQLUSMALLINT    columnNumber,      SQLUSMALLINT    fieldIdentifier,      SQLPOINTER      characterAttributePtr,      SQLSMALLINT     bufferLength,      SQLSMALLINT *   stringLengthPtr,      SQLLEN *        numericAttributePtr)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLEndTran: handleType with: handle with: completionType	&lt;C: RETCODE SQLEndTran(     SQLSMALLINT   handleType,     SQLHANDLE     handle,     SQLSMALLINT   completionType)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLFetchScroll: statementHandle with: fetchOrientation with: fetchOffset	&lt;C: RETCODE SQLFetchScroll(      SQLHSTMT      statementHandle,      SQLSMALLINT   fetchOrientation,      SQLLEN        fetchOffset)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLFreeHandle: handleType with: handle	&lt;C: RETCODE SQLFreeHandle(     SQLSMALLINT   handleType,     SQLHANDLE     handle)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLGetConnectAttr: connectionHandle with: attribute with: valuePtr with: bufferLength with: stringLengthPtr	&lt;C: RETCODE SQLGetConnectAttr(     SQLHDBC        connectionHandle,     SQLINTEGER     attribute,     SQLPOINTER     valuePtr,     SQLINTEGER     bufferLength,     SQLINTEGER *   stringLengthPtr)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLGetConnectAttrW: connectionHandle with: attribute with: valuePtr with: bufferLength with: stringLengthPtr	&lt;C: RETCODE SQLGetConnectAttrW(     SQLHDBC        connectionHandle,     SQLINTEGER     attribute,     SQLPOINTER     valuePtr,     SQLINTEGER     bufferLength,     SQLINTEGER *   stringLengthPtr)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLGetDescField: descriptorHandle with: recNumber with: fieldIdentifier with: valuePtr with: bufferLength with: stringLengthPtr	&lt;C: RETCODE SQLGetDescField(     SQLHDESC        descriptorHandle,     SQLSMALLINT     recNumber,     SQLSMALLINT     fieldIdentifier,     SQLPOINTER      valuePtr,     SQLINTEGER      bufferLength,     SQLINTEGER *    stringLengthPtr)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLGetDescFieldW: descriptorHandle with: recNumber with: fieldIdentifier with: valuePtr with: bufferLength with: stringLengthPtr	&lt;C: RETCODE SQLGetDescFieldW(     SQLHDESC        descriptorHandle,     SQLSMALLINT     recNumber,     SQLSMALLINT     fieldIdentifier,     SQLPOINTER      valuePtr,     SQLINTEGER      bufferLength,     SQLINTEGER *    stringLengthPtr)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLGetDescRec: descriptorHandle with: recNumber with: name with: bufferLength with: stringLengthPtr with: typePtr with: subTypePtr with: lengthPtr with: precisionPtr with: scalePtr with: nullablePtr	&lt;C: RETCODE SQLGetDescRec(      SQLHDESC        descriptorHandle,      SQLSMALLINT     recNumber,      SQLCHAR *       name,      SQLSMALLINT     bufferLength,      SQLSMALLINT *   stringLengthPtr,      SQLSMALLINT *   typePtr,      SQLSMALLINT *   subTypePtr,      SQLLEN *        lengthPtr,      SQLSMALLINT *   precisionPtr,      SQLSMALLINT *   scalePtr,      SQLSMALLINT *   nullablePtr)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLGetDescRecW: descriptorHandle with: recNumber with: name with: bufferLength with: stringLengthPtr with: typePtr with: subTypePtr with: lengthPtr with: precisionPtr with: scalePtr with: nullablePtr	&lt;C: RETCODE SQLGetDescRecW(      SQLHDESC        descriptorHandle,      SQLSMALLINT     recNumber,      SQLCHAR *       name,      SQLSMALLINT     bufferLength,      SQLSMALLINT *   stringLengthPtr,      SQLSMALLINT *   typePtr,      SQLSMALLINT *   subTypePtr,      SQLLEN *        lengthPtr,      SQLSMALLINT *   precisionPtr,      SQLSMALLINT *   scalePtr,      SQLSMALLINT *   nullablePtr)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLGetDiagField: handleType with: handle with: recNumber with: diagIdentifier with: diagInfoPtr with: bufferLength with: stringLengthPtr	&lt;C: RETCODE SQLGetDiagField(     SQLSMALLINT     handleType,     SQLHANDLE       handle,     SQLSMALLINT     recNumber,     SQLSMALLINT     diagIdentifier,     SQLPOINTER      diagInfoPtr,     SQLSMALLINT     bufferLength,     SQLSMALLINT *   stringLengthPtr)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLGetDiagFieldW: handleType with: handle with: recNumber with: diagIdentifier with: diagInfoPtr with: bufferLength with: stringLengthPtr	&lt;C: RETCODE SQLGetDiagFieldW(     SQLSMALLINT     handleType,     SQLHANDLE       handle,     SQLSMALLINT     recNumber,     SQLSMALLINT     diagIdentifier,     SQLPOINTER      diagInfoPtr,     SQLSMALLINT     bufferLength,     SQLSMALLINT *   stringLengthPtr)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLGetDiagRec: handleType with: handle with: recNumber with: sqlState with: nativeErrorPtr with: messageText with: bufferLength with: textLengthPtr	&lt;C: RETCODE SQLGetDiagRec(     SQLSMALLINT     handleType,     SQLHANDLE       handle,     SQLSMALLINT     recNumber,     SQLCHAR *       sqlState,     SQLINTEGER *    nativeErrorPtr,     SQLCHAR *       messageText,     SQLSMALLINT     bufferLength,     SQLSMALLINT *   textLengthPtr)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLGetDiagRecW: handleType with: handle with: recNumber with: sqlState with: nativeErrorPtr with: messageText with: bufferLength with: textLengthPtr	&lt;C: RETCODE SQLGetDiagRecW(     SQLSMALLINT     handleType,     SQLHANDLE       handle,     SQLSMALLINT     recNumber,     SQLCHAR *       sqlState,     SQLINTEGER *    nativeErrorPtr,     SQLCHAR *       messageText,     SQLSMALLINT     bufferLength,     SQLSMALLINT *   textLengthPtr)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLGetEnvAttr: environmentHandle with: attribute with: valuePtr with: bufferLength with: stringLengthPtr	&lt;C: RETCODE SQLGetEnvAttr(     SQLHENV        environmentHandle,     SQLINTEGER     attribute,     SQLPOINTER     valuePtr,     SQLINTEGER     bufferLength,     SQLINTEGER *   stringLengthPtr)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLGetStmtAttr: statementHandle with: attribute with: valuePtr with: bufferLength with: stringLength	&lt;C: RETCODE SQLGetStmtAttr(     SQLHSTMT        statementHandle,     SQLINTEGER      attribute,     SQLPOINTER      valuePtr,     SQLINTEGER      bufferLength,     SQLINTEGER *    stringLength)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLGetStmtAttrW: statementHandle with: attribute with: valuePtr with: bufferLength with: stringLength	&lt;C: RETCODE SQLGetStmtAttrW(     SQLHSTMT        statementHandle,     SQLINTEGER      attribute,     SQLPOINTER      valuePtr,     SQLINTEGER      bufferLength,     SQLINTEGER *    stringLength)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLSetConnectAttr: connectionHandle with: attribute with: valuePtr with: stringLength	&lt;C: RETCODE SQLSetConnectAttr(	SQLHDBC connectionHandle, 	SQLINTEGER attribute, 	SQLPOINTER valuePtr, 	SQLINTEGER stringLength)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLSetConnectAttrW: connectionHandle with: attribute with: valuePtr with: stringLength	&lt;C: RETCODE SQLSetConnectAttrW(SQLHDBC connectionHandle, SQLINTEGER attribute, SQLPOINTER valuePtr, SQLINTEGER stringLength)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLSetDescField: descriptorHandle with: recNumber with: fieldIdentifier with: valuePtr with: bufferLength	&lt;C: RETCODE SQLSetDescField (     SQLHDESC      descriptorHandle,     SQLSMALLINT   recNumber,     SQLSMALLINT   fieldIdentifier,     SQLPOINTER    valuePtr,     SQLINTEGER    bufferLength)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLSetDescFieldW: descriptorHandle with: recNumber with: fieldIdentifier with: valuePtr with: bufferLength	&lt;C: RETCODE SQLSetDescFieldW(     SQLHDESC      descriptorHandle,     SQLSMALLINT   recNumber,     SQLSMALLINT   fieldIdentifier,     SQLPOINTER    valuePtr,     SQLINTEGER    bufferLength)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLSetDescRec: descriptorHandle with: recNumber with: type with: subType with: length with: precision with: scale with: dataPtr with: stringLengthPtr with: indicatorPtr	&lt;C: RETCODE SQLSetDescRec(      SQLHDESC      descriptorHandle,      SQLSMALLINT   recNumber,      SQLSMALLINT   type,      SQLSMALLINT   subType,      SQLLEN        length,      SQLSMALLINT   precision,      SQLSMALLINT   scale,      SQLPOINTER    dataPtr,      SQLLEN *      stringLengthPtr,      SQLLEN *      indicatorPtr)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLSetDescRecW: descriptorHandle with: recNumber with: type with: subType with: length with: precision with: scale with: dataPtr with: stringLengthPtr with: indicatorPtr	&lt;C: RETCODE SQLSetDescRecW(      SQLHDESC      descriptorHandle,      SQLSMALLINT   recNumber,      SQLSMALLINT   type,      SQLSMALLINT   subType,      SQLLEN        length,      SQLSMALLINT   precision,      SQLSMALLINT   scale,      SQLPOINTER    dataPtr,      SQLLEN *      stringLengthPtr,      SQLLEN *      indicatorPtr)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLSetEnvAttrW: henv with: attrName with: valuePointer with: attrType	&lt;C: RETCODE SQLSetEnvAttrW(HENV henv, SDWORD attrName, PTR valuePointer, SDWORD attrType)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLSetStmtAttr: statementHandle with: attribute with: valuePtr with: stringLength	&lt;C: RETCODE SQLSetStmtAttr(SQLHSTMT statementHandle, SQLINTEGER attribute, SQLPOINTER valuePtr, SQLINTEGER stringLength)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLSetStmtAttrW: statementHandle with: attribute with: valuePtr with: stringLength	&lt;C: RETCODE SQLSetStmtAttrW(SQLHSTMT statementHandle, SQLINTEGER attribute, SQLPOINTER valuePtr, SQLINTEGER stringLength)&gt;	^self externalAccessFailed</body></methods><methods><class-id>Database.ODBCCLI64BitInterface</class-id> <category>procedures</category><body package="ODBCEXDI">SQLBindCol: hstmt with: icol with: fCType with: rgbValue with: cbValueMax with: pcbValue	&lt;C: RETCODE SQLBindCol(HSTMT hstmt, UWORD icol, SWORD fCType, PTR rgbValue, SQLLEN cbValueMax, SQLLEN * pcbValue)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLBindParameter: hstmt with: ipar with: fParamType with: fCType with: fSqlType with: cbColDef with: ibScale with: rgbValue with: cbValueMax with: pcbValue	&lt;C: RETCODE SQLBindParameter(HSTMT hstmt, UWORD ipar, SWORD fParamType, SWORD fCType, SWORD fSqlType, SQLULEN cbColDef, SWORD ibScale, PTR rgbValue, SQLLEN cbValueMax, SQLLEN * pcbValue)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLColAttributes: hstmt with: icol with: fDescType with: rgbDesc with: cbDescMax with: pcbDesc with: pfDesc	&lt;C: RETCODE SQLColAttributes(HSTMT hstmt, UWORD icol, UWORD fDescType, PTR rgbDesc, SWORD cbDescMax, SWORD * pcbDesc, SQLLEN * pfDesc)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLDescribeCol: hstmt with: icol with: szColName with: cbColNameMax with: pcbColName with: pfSqlType with: pcbColDef with: pibScale with: pfNullable	&lt;C: RETCODE SQLDescribeCol(HSTMT hstmt, UWORD icol, UCHAR * szColName, SWORD cbColNameMax, SWORD * pcbColName, SWORD * pfSqlType, SQLULEN * pcbColDef, SWORD * pibScale, SWORD * pfNullable)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLDescribeParam: hstmt with: ipar with: pfSqlType with: pcbColDef with: pibScale with: pfNullable	&lt;C: RETCODE SQLDescribeParam(HSTMT hstmt, UWORD ipar, SWORD * pfSqlType, SQLULEN * pcbColDef, SWORD * pibScale, SWORD * pfNullable)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLExtendedFetch: hstmt with: fFetchType with: irow with: pcrow with: rgfRowStatus	&lt;C: RETCODE SQLExtendedFetch(HSTMT hstmt, UWORD fFetchType, SQLLEN irow, SQLULEN * pcrow, UWORD * rgfRowStatus)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLGetData: hstmt with: icol with: fCType with: rgbValue with: cbValueMax with: pcbValue	&lt;C: RETCODE SQLGetData(HSTMT hstmt, UWORD icol, SWORD fCType, PTR rgbValue, SQLLEN cbValueMax, SQLLEN * pcbValue)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLParamOptions: hstmt with: crow with: pirow	&lt;C: RETCODE SQLParamOptions(HSTMT hstmt, SQLULEN crow, SQLULEN * pirow)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLPutData: hstmt with: rgbValue with: cbValue	&lt;C: RETCODE SQLPutData(HSTMT hstmt, PTR rgbValue, SQLLEN cbValue)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLRowCount: hstmt with: pcrow	&lt;C: RETCODE SQLRowCount(HSTMT hstmt, SQLLEN * pcrow)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLSetConnectOption: hdbc with: fOption with: vParam	&lt;C: RETCODE SQLSetConnectOption(HDBC hdbc, UWORD fOption, SQLULEN vParam)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLSetParam: hstmt with: ipar with: fCType with: fSqlType with: cbColDef with: ibScale with: rgbValue with: pcbValue	&lt;C: RETCODE SQLSetParam(HSTMT hstmt, UWORD ipar, SWORD fCType, SWORD fSqlType, SQLULEN cbColDef, SWORD ibScale, PTR rgbValue, SQLLEN * pcbValue)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLSetPos: hstmt with: irow with: fOption with: fLock	&lt;C: RETCODE SQLSetPos(HSTMT hstmt, UINT64 irow, UWORD fOption, UWORD fLock)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLSetScrollOptions: hstmt with: fConcurrency with: crowKeyset with: crowRowset	&lt;C: RETCODE SQLSetScrollOptions(HSTMT hstmt, UWORD fConcurrency, SQLLEN crowKeyset, UWORD crowRowset)&gt;	^self externalAccessFailed</body><body package="ODBCEXDI">SQLSetStmtOption: hstmt with: fOption with: vParam	&lt;C: RETCODE SQLSetStmtOption(HSTMT hstmt, UWORD fOption, SQLULEN vParam)&gt;	^self externalAccessFailed</body></methods><initialize><class-id>Database.ODBCCLIInterface</class-id></initialize><initialize><class-id>Database.ODBCCLI64BitInterface</class-id></initialize><initialize><class-id>Database.ODBCCLINT64Interface</class-id></initialize><initialize><class-id>Database.ODBCCLIAIXInterface</class-id></initialize><initialize><class-id>Database.ODBC2Connection</class-id></initialize><initialize><class-id>Database.ODBCCLINTInterface</class-id></initialize><initialize><class-id>Database.ODBCCLI95Interface</class-id></initialize><initialize><class-id>Database.ODBC2Buffer</class-id></initialize><initialize><class-id>Database.ODBCColumnDescription</class-id></initialize><initialize><class-id>Database.ODBCCLISolarisInterface</class-id></initialize><initialize><class-id>Database.ODBCCLILinuxInterface</class-id></initialize><initialize><class-id>Database.ODBCCLIMacOSXInterface</class-id></initialize><initialize><class-id>Database.ODBC2Session</class-id></initialize><initialize><class-id>Database.ODBCSession</class-id></initialize><initialize><class-id>Database.ODBCConnection</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>ExternalDatabaseSession</name><environment>Database</environment><super>Database.ExternalDatabaseFramework</super><private>false</private><indexed-type>none</indexed-type><inst-vars>connection query queryFragments bindInput bindTemplate bindOutput useNamedOutputBinding bindValues resultTemplate allocateForEachRow blockFactor numColumns columnDescriptions rowAdaptors rowBuffersHolder bufferIndex answerStream currentRow scrollable needBinding </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><class><name>SmallDouble</name><environment>Core</environment><super>Core.LimitedPrecisionReal</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Array</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>Float</name><environment>Core</environment><super>Core.LimitedPrecisionReal</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Timestamp</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>year month day hours minutes seconds milliseconds partialNanosecond </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>ExternalDatabaseException</name><environment>Database</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><class><name>PositionableStream</name><environment>Core</environment><super>Core.PeekableStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>collection position readLimit writeLimit policy </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>Character</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>CharacterArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>ExternalInterface</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>includeFiles includeDirectories libraryFiles libraryDirectories virtual optimizationLevel </class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>External-Interface</category><attributes><package>External-Interface</package></attributes></class><class><name>Double</name><environment>Core</environment><super>Core.LimitedPrecisionReal</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Time</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hours minutes seconds milliseconds partialNanosecond </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>ExternalDatabaseConnection</name><environment>Database</environment><super>Database.ExternalDatabaseFramework</super><private>false</private><indexed-type>none</indexed-type><inst-vars>transaction username password environment transactionCoordinator cachedSession isolationLevel encoding </inst-vars><class-inst-vars>environmentMap xif xifMap dependents </class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><class><name>Random</name><environment>Core</environment><super>Core.Stream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>seed </inst-vars><class-inst-vars>defaultGeneratorClass </class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>EncodedStream</name><environment>Core</environment><super>Core.PeekableStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>binary stream encoder policy lineEndConvention lineEndCharacter skipSize </inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.IOConstants.*			</imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>Integer</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>LargeInteger</name><environment>Core</environment><super>Core.Integer</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>ByteArray</name><environment>Core</environment><super>Core.IntegerArray</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>WordArray</name><environment>Core</environment><super>Core.IntegerArray</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>Boolean</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>FixedPoint</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars>numerator denominator scale </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>ExternalDatabaseBuffer</name><environment>Database</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>databaseType encoding elementSize count bufferPointer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><class><name>BufferedExternalStream</name><environment>OS</environment><super>OS.ExternalStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>lineEndCharacter binary lineEndConvention bufferType ioBuffer ioConnection </inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.IOConstants.*			</imports><category>OS-Streaming</category><attributes><package>OS-Streaming</package></attributes></class><class><name>ExternalDatabaseTransaction</name><environment>Database</environment><super>Database.ExternalDatabaseFramework</super><private>false</private><indexed-type>none</indexed-type><inst-vars>memberCountHolder remainingCountHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><class><name>Date</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>day year </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>ExternalDatabaseError</name><environment>Database</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dbmsErrorCode dbmsErrorString osErrorCode osErrorString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><class><name>ExternalDatabaseColumnDescription</name><environment>Database</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name index type length precision scale nullable </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class></st-source>