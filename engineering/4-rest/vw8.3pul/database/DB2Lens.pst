<?xml version="1.0"?><st-source><!-- Name: DB2LensNotice: Copyright 1999-2013 Cincom Systems, Inc.  All rights reserved.Comment: The DB2/UDB Connect, originally written by Anthony Boris <anthonyvb@yandex.ru>.Copyright: The contents of this file are subject to the ParcPlace Public License Version 1.0 (the "License"); you may not use this file except incompliance with the License. You may obtain a copy of the License at http://www.parcplace.com/support/opensource/PPL-1.0.htmlSoftware distributed under the License is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. Seethe License for the specific language governing rights and limitations under the License.The Original Code is the DB2/UDB Connect.The Initial Developer of the Original Code is Anthony Boris.Portions created by Anthony Boris are Copyright (C) 2000-2003. All Rights Reserved.Contributor(s): Anthony BorisDbIdentifier: bear73DbTrace: 400813DbUsername: nrossDbVersion: 1.2DevelopmentPrerequisites: #(#(#any 'Lens-Runtime' '') #(#any 'DB2EXDI' ''))PackageName: DB2LensParcel: #('DB2Lens')ParcelName: DB2LensPrerequisiteParcels: #(#('Lens-Runtime' '') #('DB2EXDI' ''))PrintStringCache: (1.2,nross)Version: 1.2Date: 7:29:26 AM April 3, 2013 --><time-stamp>From VisualWorksÂ®, Pre-Release 7.10 (mar13.5) of April 3, 2013 on April 3, 2013 at 7:29:26 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>DB2LensTable</name><environment>Smalltalk</environment><super>Lens.LensDatabaseTable</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name owner tableType columns </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-DB2</category><attributes><package>DB2Lens</package></attributes></class><class><name>DB2LensTransporter</name><environment>Smalltalk</environment><super>Lens.LensSQLTransporter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-DB2</category><attributes><package>DB2Lens</package></attributes></class><class><name>DB2LensContext</name><environment>Smalltalk</environment><super>Lens.LensDatabaseContext</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-DB2</category><attributes><package>DB2Lens</package></attributes></class><class><name>DB2LensTableColumn</name><environment>Smalltalk</environment><super>Lens.LensDatabaseTableColumn</super><private>false</private><indexed-type>none</indexed-type><inst-vars>table notNil type name maxColumnConstraint isKey dataType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-DB2</category><attributes><package>DB2Lens</package></attributes></class><methods><class-id>DB2LensTable</class-id> <category>comparing</category><body package="DB2Lens">&lt;= aDB2Table	"Answer whether aDB2Table collates after the receiver."	| so oo |	^(so := self owner) &lt; (oo := aDB2Table owner)		or: [ so = oo and: [ self name &lt;= aDB2Table name ] ]</body><body package="DB2Lens">= aDB2Table	"Answer whether aDB2Table has the same owner and name as the receiver."	^self species == aDB2Table species	and: [ self owner = aDB2Table owner		and: [ self name = aDB2Table name ] ]</body><body package="DB2Lens">hash	"Modify the hash method to be based on the owner and name combined."	^(self owner hash bitShift: 3)		bitXor: self name hash</body></methods><methods><class-id>DB2LensTable</class-id> <category>DDL generation</category><body package="DB2Lens">alterColumnCommand: column operation: operation	"Answer a command to add a column to a table."	LensSession complain: 'Currently doesn''t supported'</body></methods><methods><class-id>DB2LensTable</class-id> <category>accessing</category><body package="DB2Lens">columns	^columns</body><body package="DB2Lens">columns: aValue	columns := aValue</body><body package="DB2Lens">name	^name</body><body package="DB2Lens">name: aValue	name := aValue</body><body package="DB2Lens">owner	^owner</body><body package="DB2Lens">owner: aValue	owner := aValue</body><body package="DB2Lens">qualify: ldm	owner := ldm databaseContext username asUppercase</body><body package="DB2Lens">tableType	^tableType</body><body package="DB2Lens">tableType: aValue	tableType := aValue</body><body package="DB2Lens">unqualify	owner:=nil</body></methods><methods><class-id>DB2LensTable</class-id> <category>printing</category><body package="DB2Lens">displayString	^self qualifiedName</body></methods><methods><class-id>DB2LensTable</class-id> <category>key detection</category><body package="DB2Lens">getPrimaryKeyIn: aLensSession	"Answer the primary key for this table by looking it up in the database catalogs.  Answer an instance of LensTableKey or nil."	| keys |	keys := (aLensSession connection getSession getPrimaryKeysFor: self name owner: self owner) collect: [:s | self columns detect: [:c | c name = s]].		^keys isEmpty ifFalse: [LensTableKey table: self columns: keys keyType: #primary]</body><body package="DB2Lens">inferReferencesIn: aLensSession 	| cons res |	cons := aLensSession connection getSession getForeignKeysFor: self name owner:  self owner.	res := OrderedCollection new.	[cons size &gt; 0]		whileTrue: 			[| others con |			con := cons first.			others := SortedCollection sortBlock: [:c1 :c2 | (c1 at: 9) "position" &lt;= (c2 at: 9) "position"].			cons do: [:c | (c at: 12) "constraint" = (con at: 12) "constraint" ifTrue: [others add: c]].			res add: (Array					with: self					with: (others collect: [ :c | c at: 8 "columnName" ])					with: (Array with: (con at: 3) with: (con at: 2 )   ) "constraint referencedConstraint table tableNameArray").			cons removeAll: others].	^res</body></methods><methods><class-id>DB2LensTable</class-id> <category>initialize-release</category><body package="DB2Lens">initializeFrom: aDictionary 	name := aDictionary at: #name.	owner := aDictionary at: #owner.	tableType := aDictionary at: #tableType.</body></methods><methods><class-id>DB2LensTable class</class-id> <category>accessing</category><body package="DB2Lens">contextClass	^DB2LensContext</body></methods><methods><class-id>DB2LensTable class</class-id> <category>private</category><body package="DB2Lens">encodedAspects	^#(#owner)</body></methods><methods><class-id>DB2LensTransporter</class-id> <category>accessing</category><body package="DB2Lens">nextVariableName	^'?'</body><body package="DB2Lens">update: object withId: externalId andMask: updatedInstVarsMask withOldObject: oldObject	"Update the record associated with object with externalId. If oldObject notNil check for optimistic lock conflicts using oldObject as the reference."	| dbSession rc cmd cmdStream extBindTemplate |	updateCommand == nil ifTrue:		[ self initUpdateCommand ].	self startCommand.	cmd := updateCommand copy.			"copy the command as template"	cmdStream := commandStream.	variableIndex := numberOfIdVariables.	cmdStream nextPutAll: 'UPDATE '.	type tableNameOn: cmdStream.	cmdStream nextPutAll: ' SET '.	extBindTemplate:= cmd bindTemplate.	cmd bindTemplate: nil. "add later, fix improper order of bind var"	"cmd addBinding: externalId."	type mappedVariablesDo:		[ :var | | index value modified|		index := var instVarIndex.		modified := (updatedInstVarsMask bitAnd: (1 bitShift: index - 1)) &gt; 0.		"Check for versionNumber field. If this is one and it has not been modified - increment it."		(var valueType isRowVersion and: [modified not]) ifTrue:			[object globalDescriptor update: object instVarAt: index put: ((object instVarAt: index) + 1).			modified := true].		modified ifTrue:			[ value := object instVarAt: index.			var checkShallowIncludes: value.			(self bindVariable: var tableName: nil withUpdateMask: updatedInstVarsMask) ifTrue: 				[cmd 					addTemplate: (var fieldTemplateForUpdate: true withUpdateMask: updatedInstVarsMask);			 		addBinding: (var encodeVariableOf: object in: session withUpdateMask: updatedInstVarsMask).				cmdStream nextPut: $,]]].	cmdStream skip: -1.	cmdStream nextPutAll: cmd body.	"append where clause"	cmd addBinding: externalId.  "restore externalId part"	cmd bindTemplate addAll: extBindTemplate. "restore externalId part"	oldObject notNil ifTrue:		[self addOptimisticConflictCheckOn: cmd against: oldObject andMask: updatedInstVarsMask].	cmd commandString: cmdStream contents.	(dbSession := self doCommand: cmd) answerAfterCommand.	(rc := dbSession rowCount) == 0 ifTrue:		[ oldObject notNil			ifTrue: [LensSession optimisticConflictDetectedSignal raise ]			ifFalse: [LensSession rowForObjectNotFoundSignal raise ] ].	rc &gt; 1 ifTrue:		[ LensSession objectNotUniquelyIdentifiedSignal raise ]</body></methods><methods><class-id>DB2LensTransporter class</class-id> <category>class initialization</category><body package="DB2Lens">initialize	super initialize</body></methods><methods><class-id>DB2LensContext</class-id> <category>data dictionary manipulation</category><body package="DB2Lens">getTableNamed: tableName in: session 	| t |	^(t := self listTablesLike: tableName in: session) isEmpty ifFalse: [t first]</body><body package="DB2Lens">listTablesLike: aPattern in: aLens 	"Answer a collection of tables which are accessible using aLens. 	If aPattern is not nil, limit the search to only those tables with names matching."	| exdiSession tables |	exdiSession := aLens connection getSession.	tables := (exdiSession listTablesLike: aPattern)				collect: [:each | self class tableClass new initializeFrom: each].	tables do: [:each | each columns: ((exdiSession getColumnsOfTable: each name owner: each owner )  				collect: [:c | self class tableColumnClass new initializeFrom: c])].	exdiSession dismiss.	^tables</body></methods><methods><class-id>DB2LensContext class</class-id> <category>lens data model specs</category><body package="DB2Lens">catalogDataModelSpec	"LensEditor new openOnClass: self andSelector: #catalogDataModelSpec"		^#(#LensDataModel 		#setDatabaseContext: 		#(#DB2LensContext			#username: '' 			#environment: '') 		#structureTypes: #() 		#lensPolicyName: #Mixed 		#lensTransactionPolicyName: #PessimisticRR 		#validity: #installed )</body></methods><methods><class-id>DB2LensContext class</class-id> <category>accessing</category><body package="DB2Lens">connectionClass	"Answer the class of connections opened by instances of self."	^DB2Connection</body><body package="DB2Lens">kind	"symbol representing the type of the d'ase  "	^#DB2</body><body package="DB2Lens">tableClass	"Answer the class of tables for the receiver."	^DB2LensTable</body><body package="DB2Lens">tableColumnClass	"Answer the class of table columns in receiver's data dictionary."	^DB2LensTableColumn</body><body package="DB2Lens">transporterClass	^DB2LensTransporter</body></methods><methods><class-id>DB2LensContext class</class-id> <category>private</category><body package="DB2Lens">encodedAspects	^#()</body></methods><methods><class-id>DB2LensContext class</class-id> <category>class initialization</category><body package="DB2Lens">initialize	"self initialize"	self initializeBasicTypes.	self initializeDataTypeMappings.	maxNameSize := 30. "column name size -30, table name size -128, schema - 18 "	maxColumnSize := 2 ** 20 - 1.	reservedWords := #().	shortSize := 32700. "for 32K page/ long varchar"	transactionPolicies := IdentitySet new.	LensCompiler isNil ifFalse: [self initializeCatalogDataModel].</body><body package="DB2Lens">initializeBasicTypes	"self initializeBasicTypes"basicTypes := IdentityDictionary new.	#(Object SmallInteger Integer LargeInteger Character Float Double ByteArray String Timestamp Date Time Symbol FixedPoint  ) do:		[ :className | 		self addBasicType: ((LensDataType new)							name: className;							memberClass: (className asQualifiedReference valueOrDo: [nil])) ].	self		addBasicType: (LensDataType new memberClass: Integer; name: #RowVersion);		addBasicType: (LensDataType new memberClass: Integer; name: #SerialNumber);		addBasicType: (LensDataType new memberClass: DB2BLOBLocator; name: #BlobLocator);		addBasicType: (LensDataType new memberClass: DB2CLOBLocator; name: #ClobLocator);		addBasicType: (LensDataType new memberClass: DB2DataLink; name: #Datalink);		addBasicType: (LensEncodedType new 			memberClass: String;			name: #TrimString;			fieldType: (self typeNamed: #String); 			encodeSelector: #asString;			decodeSelector: #avbTrimBlanks);		"addBasicType: (LensEncodedType new   			memberClass: FixedPoint;			name: #ScaledDecimal;			fieldType: (self typeNamed: #String); 			encodeSelector: #avbAsString;			decodeSelector: #avbAsFixedPoint);"		addBasicType: (LensEncodedType new			name: #Boolean;			memberClass: Boolean;			fieldType: ((self typeNamed: #String) copy maxColumnConstraint: 1); 			encodeSelector: #printStringForDB2;			decodeSelector: #asBooleanForDB2).	^self</body><body package="DB2Lens">initializeDataTypeMappings	"self initializeDataTypeMappings"	dataTypeMappings := OrderedCollection new.	(self mapFieldOf: #String to: #varchar) maxSize: 32672.	(self mapFieldOf: #String to: #'long varchar') maxSize: 32700.	(self mapFieldOf: #String to: #character) maxSize: 254.	(self mapFieldOf: #Boolean to: #character) maxSize: 1.	(self mapFieldOf: #TrimString to: #varchar) maxSize: 32672.	(self mapFieldOf: #TrimString to: #'long varchar') maxSize: 32700.	(self mapFieldOf: #TrimString to: #character) maxSize: 254.	(self mapFieldOf: #ClobLocator to: #clob) makeLong.		(self mapFieldOf: #BlobLocator to: #blob ) makeLong .	(self mapFieldOf: #ByteArray  to: #'varchar () for bit data') maxSize: 32672.	(self mapFieldOf: #ByteArray  to: #'character () for bit data') maxSize: 254.	(self mapFieldOf: #ByteArray  to: #'long varchar for bit data') maxSize: 32700.	self mapFieldOf: #Integer to: #'smallint'.	self mapFieldOf: #Integer to: #'integer'.	self mapFieldOf: #LargeInteger to: #'bigint'.	self mapFieldOf: #SmallInteger to: #'smallint'.	self mapFieldOf: #SmallInteger to: #'integer'.	self mapFieldOf: #Float to: #'float'.	self mapFieldOf: #Double to: #'double'.	self mapFieldOf: #SerialNumber to: #'integer'.	self mapFieldOf: #Timestamp to: #'timestamp'.	self mapFieldOf: #Date to: #'date'.	self mapFieldOf: #Time to: #'time'.	self mapFieldOf: #FixedPoint to: #'decimal'.	self mapFieldOf: #Datalink to: #'datalink'.</body></methods><methods><class-id>DB2LensTableColumn</class-id> <category>accessing</category><body package="DB2Lens">dataType	^dataType asSymbol</body><body package="DB2Lens">dataType: aValue	dataType := aValue</body><body package="DB2Lens">isKey	^isKey</body><body package="DB2Lens">isKey: aValue	isKey := aValue</body><body package="DB2Lens">isNotNil	^notNil</body><body package="DB2Lens">isNotNil: aValue	notNil := aValue</body><body package="DB2Lens">maxColumnConstraint	^maxColumnConstraint</body><body package="DB2Lens">maxColumnConstraint: aValue	maxColumnConstraint := aValue</body><body package="DB2Lens">name	^name</body><body package="DB2Lens">name: aValue	name := aValue</body><body package="DB2Lens">table	^table</body><body package="DB2Lens">table: aValue	table := aValue</body><body package="DB2Lens">type	^type</body><body package="DB2Lens">type: aValue	type := aValue</body></methods><methods><class-id>DB2LensTableColumn</class-id> <category>initialize-release</category><body package="DB2Lens">initializeFrom: aDictionary	name := aDictionary at: #name. 	type := DB2CLIInterface fSqlTypeToConversionMap at: (aDictionary at: #type).	dataType := (aDictionary at: #nativeType) asLowercase "asSymbol".	notNil := ((aDictionary at: #nullable) == 1) not.	maxColumnConstraint := (#('character' 'varchar' 'long varchar' 'varchar () for bit data' 'long varchar for bit data' 'character () for bit data'  " 'clob' 'blob' ") includes: dataType) ifTrue:[ aDictionary at: #maxLength].	table := aDictionary at: #table.</body></methods><methods><class-id>DB2LensTableColumn class</class-id> <category>accessing</category><body package="DB2Lens">contextClass	^DB2LensContext</body></methods><methods><class-id>DB2LensTableColumn class</class-id> <category>private</category><body package="DB2Lens">encodedAspects	^#(isNotNil dataType name maxColumnConstraint )</body></methods><methods><class-id>Core.LargeInteger class</class-id> <category>type semantics</category><body package="DB2Lens">isVariableSize	"Answer whether the receiver has variable-sized members."	^false</body></methods><initialize><class-id>DB2LensTransporter</class-id></initialize><initialize><class-id>DB2LensContext</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>LensDatabaseTable</name><environment>Lens</environment><super>Lens.LensMetadata</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-Database Context</category><attributes><package>Lens-Runtime</package></attributes></class><class><name>LensDatabaseTableColumn</name><environment>Lens</environment><super>Lens.LensMetadata</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-Database Context</category><attributes><package>Lens-Runtime</package></attributes></class><class><name>LensSQLTransporter</name><environment>Lens</environment><super>Lens.LensBasicTransporter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selectFieldList whereCondition commandStream command objectSurrogateIndices joinLinks variableIndex numberOfIdVariables itemSurrogate variableBindings </inst-vars><class-inst-vars>functions </class-inst-vars><imports></imports><category>Lens-Private-Transporter</category><attributes><package>Lens-Runtime</package></attributes></class><class><name>LensDatabaseContext</name><environment>Lens</environment><super>Lens.LensMetadata</super><private>false</private><indexed-type>none</indexed-type><inst-vars>username environment </inst-vars><class-inst-vars>catalogDataModel dataTypeMappings maxColumnSize maxNameSize reservedWords basicTypes shortSize transactionPolicies </class-inst-vars><imports></imports><category>Lens-Private-Database Context</category><attributes><package>Lens-Runtime</package></attributes></class></st-source>