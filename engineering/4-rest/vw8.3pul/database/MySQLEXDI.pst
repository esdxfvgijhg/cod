<?xml version="1.0"?><st-source><!-- Name: MySQLEXDINotice: Copyright 1999-2017 Cincom Systems, Inc.  All rights reserved.Comment: MySQLEXDI provides the External database interface (EXDI) code to use MySQL relational databases.(EXDI provides complete support for storing and retrieving data from your Smalltalk applications. In addition, it enables the Ad Hoc SQL tool on the Database menu of the Launcher window. This interactive tool allows you to run simple text-based queries to verify your database connection and explore your data. Further information on the EXDI can be found in the "Database Application Developer's Guide", located in the /doc subdirectory of the VisualWorks installation.)

This package requires the following to connect to a MySQL database server:

* a MySQL client library (DLL), installed properly on your computer (the client library suitable for your platform may be obtained from: http://dev.mysql.com/downloads/connector/c/)

* a hardware connection to a running MySQL database server

* a valid user name and password to access the database server

The MySQL client library on your workstation may be configured using the file my.cnf. It is not always necessary to edit this file. It provides sections for server- and client-specific configuration (i.e., [mysqld] and [client]). The my.cnf file may be located in a variety of established locations in your file system, which depend upon the platform you are using (e.g., on OS X, these are: /etc/my.cnf, /etc/mysql/my.cnf, /usr/local/opt/mysql/my.cnf, or ~/.my.cnf).

The MySQL EXDI includes a number of ExternalInterface classes, all subclasses of class MySQLInterface. The #libraryFiles attribute in the definitions of these classes specifies the expected name of the client library on your workstation. The #libraryDirectories attribute gives the location of the client library on your workstation (or the #libraryFiles attribute can be set to a full pathname). A location is necessary if your client library is not found in a default directory, or in the PATH on Windows, or in LD_LIBRARY_PATH on Linux and Solaris.

Implementation
Although MySQL servers can support socket-based communication, this VisualWorks implementation uses the C API. Thus, a client library must be installed on your workstation. Although the EXDI communicates via a C API, it may also be necessary to specify a port number when you create an instance of MySQLConnection (the default MySQL port is 3306).

To establish a connection with the database server, MySQL on Linux needs a physical file called /tmp/mysql.sock. The location of this file can be specified in the my.cnf file, in both the [client] and [mysqld] sections of the file. For correct operation, the mysql.sock file and/or the /var/lib/mysql/ directory may need execute permissions (i.e., "chmod -R 755"). Note that if your connection parameters are incorrect, the client library may also report that this file does not exist, and once you provide correct parameters the error will disappear.

Troubleshooting
If the client library is unable to connect to the database server, you can check the status of the server using mysqladmin from the command line (e.g., "mysqladmin -u root -p status"). If the server is not running, you can start it with: "sudo mysqld start". 

If you are running a MySQL server on the same workstation (e.g., using MAMP), the mysql.sock file may be created in a different directory. To temporarily resolve this, you can create a symlink from the default location. For example, on OS X, this would be: "sudo ln -s /Applications/MAMP/tmp/mysql/mysql.sock /tmp/mysql.sock".
DbIdentifier: bear73DbTrace: 497857DbUsername: dwallenDbVersion: 8.2 - 4DevelopmentPrerequisites: #(#(#any 'Database' '') #(#any 'DLLCC' ''))PackageName: MySQLEXDIParcel: #('MySQLEXDI')ParcelName: MySQLEXDIPrerequisiteParcels: #(#('Database' ''))PrintStringCache: (8.2 - 4,dwallen)Version: 8.2 - 4Date: 9:56:51 AM February 3, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (feb17.1) of February 3, 2017 on February 3, 2017 at 9:56:51 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>MySQLInterface</name><environment>Database</environment><super>External.ExternalInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Database.MySQLInterfaceDictionary.*			</imports><category>Database-External-Libraries</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>true</beVirtual><optimizationLevel>full</optimizationLevel><package>MySQLEXDI</package></attributes></class><comment><class-id>Database.MySQLInterface</class-id><body>MySQLInterface defines calling the conventions for the MySQL database client API.</body></comment><class><name>MySQLLinux64Interface</name><environment>Database</environment><super>Database.MySQLInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Database.MySQLLinux64InterfaceDictionary.*			</imports><category>Database-External-Libraries</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>libmysqlclient.so</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>true</beVirtual><optimizationLevel>full</optimizationLevel><package>MySQLEXDI</package></attributes></class><comment><class-id>Database.MySQLLinux64Interface</class-id><body>This class defines calling conventions for the MySQL client library on the I386 64-bit Linux platform.  Please refer to the environment variable on your machine for the path containing necessary MySQL library files.</body></comment><class><name>MySQLBitfield</name><environment>Database</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-MySQL</category><attributes><package>MySQLEXDI</package></attributes></class><comment><class-id>Database.MySQLBitfield</class-id><body>MySQLBitfield, derived from Set, is a helper class for those who use the BITFIELD MySQL column type. At the server, this column is stored as a 64-bit value. It can be inserted as a ByteArrray, with 8 bytes. The leading bytes correspond to the most significant bits. If you set the class-side flag of MySQLBuffer, BITFIELD columns will be retrieved to instances of MySQLBitfield. Otherwise, they are retrieved as ByteArrays. For example,	MySQLBuffer useSetsFor64Bits: truewill convert the retrieved ByteArrays to MySQLBitfield objects, and	MySQLBuffer useSetsFor64Bits: falsewill retrieve them as ByteArrays.</body></comment><class><name>MySQLSolaris64Interface</name><environment>Database</environment><super>Database.MySQLInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Database.MySQLSolaris64InterfaceDictionary.*			</imports><category>Database-External-Libraries</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>libmysqlclient.so</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>true</beVirtual><optimizationLevel>full</optimizationLevel><package>MySQLEXDI</package></attributes></class><comment><class-id>Database.MySQLSolaris64Interface</class-id><body>This class defines calling conventions for the MySQL client library on the 64-bit Solaris platform.  Please refer to the environment variable on your machine for the path containing necessary MySQL library files.</body></comment><class><name>MySQLDatabaseException</name><environment>Database</environment><super>Database.ExternalDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-MySQL</category><attributes><package>MySQLEXDI</package></attributes></class><comment><class-id>Database.MySQLDatabaseException</class-id><body>MySQLDatabaseException is raised in case of the MySQL database errors.</body></comment><class><name>MySQLConnection</name><environment>Database</environment><super>Database.ExternalDatabaseConnection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hConnHolder database port useEncodingApi </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-MySQL</category><attributes><package>MySQLEXDI</package></attributes></class><comment><class-id>Database.MySQLConnection</class-id><body>MySQLConnection is the concrete class implementation of connection services using the MySQL library. See the MySQLSession class for more information.Instance Variables	database	&lt;String&gt; the name of the database database in use (see USE command).	hConnHolder	&lt;ValueHolder&gt;	Holder for the connection handle.	port			&lt;Integer&gt; Which port the server is listening on.	useEncodingApi  &lt;Boolean&gt; True means, by default, use the MySQL encoding api. See comments			in (class) defaultUseEncodingApi.</body></comment><class><name>MySQLI386MacOSXInterface</name><environment>Database</environment><super>Database.MySQLInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Database.MySQLI386MacOSXInterfaceDictionary.*			</imports><category>Database-External-Libraries</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>libmysqlclient.dylib</item></libraryFiles><libraryDirectories><item>/usr/local/mysql/lib</item></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>MySQLEXDI</package></attributes></class><comment><class-id>Database.MySQLI386MacOSXInterface</class-id><body>This class defines calling conventions for the MySQL client library on the I386 MacOSX platform.  Please refer to the environment variable on your machine for the path containing necessary MySQL library files.</body></comment><class><name>MySQLNTInterface</name><environment>Database</environment><super>Database.MySQLInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Database.MySQLNTInterfaceDictionary.*			</imports><category>Database-External-Libraries</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>libmySQL.dll</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>MySQLEXDI</package></attributes></class><comment><class-id>Database.MySQLNTInterface</class-id><body>This class defines calling conventions for the MySQL client library on the Windows NT/2K/XP platform.  Please refer to the environment variable on your machine for the path containing necessary MySQL library files.</body></comment><class><name>UnableToReadOptions</name><environment>Database</environment><super>Database.ExternalDatabaseResumableException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-MySQL</category><attributes><package>MySQLEXDI</package></attributes></class><comment><class-id>Database.UnableToReadOptions</class-id><body>UnableToReadOptions is raised when the attempt to get the client library to read my.cnf/my.ini options file fails. Currently, only the encoding is sought from the [client] group of the options file. This exception is considered resumable because the user is presumably able to set the encoding directly.</body></comment><class><name>MySQLLinuxInterface</name><environment>Database</environment><super>Database.MySQLInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Database.MySQLLinuxInterfaceDictionary.*			</imports><category>Database-External-Libraries</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>libmysqlclient.so</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>true</beVirtual><optimizationLevel>full</optimizationLevel><package>MySQLEXDI</package></attributes></class><comment><class-id>Database.MySQLLinuxInterface</class-id><body>This class defines calling conventions for the MySQL client library on the Linux platform.  Please refer to the environment variable on your machine for the path containing necessary MySQL library files.</body></comment><class><name>MySQLError</name><environment>Database</environment><super>Database.ExternalDatabaseError</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sqlState </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-MySQL</category><attributes><package>MySQLEXDI</package></attributes></class><comment><class-id>Database.MySQLError</class-id><body>MySQLError is the error holder class for MySQL.Instance Variables:	sqlState	&lt;Integer&gt; indicates the current connection state.</body></comment><class><name>UnableToSetConnectionEncoding</name><environment>Database</environment><super>Database.MySQLDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-MySQL</category><attributes><package>MySQLEXDI</package></attributes></class><comment><class-id>Database.UnableToSetConnectionEncoding</class-id><body>UnableToSetConnectionEncoding is raised when an attempt to set the connection's encoding through the mysql api fails.</body></comment><class><name>MySQLNT64Interface</name><environment>Database</environment><super>Database.MySQLInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Database.MySQLNT64InterfaceDictionary.*			</imports><category>Database-External-Libraries</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>libmysql.dll</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>true</beVirtual><optimizationLevel>full</optimizationLevel><package>MySQLEXDI</package></attributes></class><comment><class-id>Database.MySQLNT64Interface</class-id><body>This class defines calling conventions for the MySQL client library on the Windows NT 64-bit platform.  Please refer to the environment variable on your machine for the path containing necessary MySQL library files.</body></comment><class><name>UnableToGetConnectionEncoding</name><environment>Database</environment><super>Database.ExternalDatabaseResumableException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-MySQL</category><attributes><package>MySQLEXDI</package></attributes></class><comment><class-id>Database.UnableToGetConnectionEncoding</class-id><body>UnableToGetConnectionEncoding is raised when the connection encoding is unrecognized, or when the attempt to get the encoding otherwise fails.This exception is considered resumable because the user is presumably able to manually set the encoding to a known type, eg., #utf8.</body></comment><class><name>MySQLMacOSX64Interface</name><environment>Database</environment><super>Database.MySQLInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Database.MySQLMacOSX64InterfaceDictionary.*			</imports><category>Database-External-Libraries</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>libmysqlclient.dylib</item></libraryFiles><libraryDirectories><item>/usr/local/mysql/lib</item></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>MySQLEXDI</package></attributes></class><comment><class-id>Database.MySQLMacOSX64Interface</class-id><body>MySQLMacOSX64Interface defines calling conventions for the MySQL client library on the 64-bit MacOSX platform.  Please refer to the environment variable on your machine for the path containing necessary MySQL library files.</body></comment><class><name>MySQLBuffer</name><environment>Database</environment><super>Database.ExternalDatabaseBuffer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>smalltalkType bufferIndex isNullable isBinary isUnsigned getSelector putSelector session pIsNull pLength pError maxDbDatumLength </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-MySQL</category><attributes><package>MySQLEXDI</package></attributes></class><comment><class-id>Database.MySQLBuffer</class-id><body>A MySQLBuffer instance holds a CPointer to the data traveling to or from the database. It also holds information about the SQL type of the object, and its Smalltalk type, so it knows how to convert between the SQL type and Smalltalk. For the architecturally inclined, there is one difference between the way a MySQLBuffer works, as opposed to the way, say, Oracle and ODBC buffers work. With these, each buffer is responsible for making an api call to transfer the data. In MySQL's case, its api was designed to transfer all buffered row data in a single call. MySQL require's an array of structs, each struct holding the data and info for a single bound object (ie., the material held by a single MySQLBuffer object). To bend the inherrited class structure to accomodate the MySQL requirements, the buffer still holds the pointers, but instead of sending them to the api, it sends them to the session object, which holds array of structs. After all buffers have checked in, the session hands the entire array of data to the api. The api uses the same arrangement of pointers to fetch or insert data. It either copies data to or from the pointers.Instance Variables:            bufferIndex         &lt;Integer&gt;          index in the query of this buffer.            bufferValue        &lt;Object&gt;           Smalltalk value to be bound.            getSelector        &lt;Object&gt;           method (based on SQL type returned) to decode the CPointer's contents.            isBinary            &lt;Boolean&gt;		true if the data held is binary, false if character based.            isNullable          &lt;Boolean&gt;        true if the column is nullable (for INSERTs).            isUnsigned        &lt;Boolean&gt;        true if the integer type of this buffer is unsigned.            maxDbDatumLength       &lt;Integer&gt; storage size of the pBuffer's data.            pBuffer  &lt;CPointer (byte)&gt;          pointer allocated buffer, meant to hold the data to be transfered.            pError   &lt;CPointer (integer)&gt;       pointer to api's error indicator.            pIsNull  &lt;CPointer (boolean)&gt; pointer to C integer- (0 if the data at pBuffer should be ignored, else 1).            pLength &lt;CPointer&gt;        pointer to the number of characters intended to be sent within pBuffer.            putSelector        &lt;Object&gt;           method (based on Smalltalk type sent) to encode the buffer's contents to C.            session &lt;MySQLSession&gt;         the session object which owns this buffer.</body></comment><class><name>MySQLAdminBuffer</name><environment>Database</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>databaseType encoding bufferIndex isNullable isBinary isUnsigned isNull length byteArray maxDbDatumLength session </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-MySQL</category><attributes><package>MySQLEXDI</package></attributes></class><comment><class-id>Database.MySQLAdminBuffer</class-id><body>A MySQLAdminBuffer instance holds a string or bytearray copy of the data retrieved from the database. It corresponds to a column in the database, and holds information about the SQL type of the object. It receives a string (or byte array) representation of the data, and leaves the data in that form. No conversion is made to a corresponding Smalltalk type. This buffer is a very simplified version of the ExternalDatabaseBuffer, but uses only strings, and only receives data. It has no INSERT or UPDATE capability.Instance Variables:		databaseType 	&lt;Integer&gt; 		the MySQL column type.		encoding 		&lt;Symbol&gt;		The encoding that Strings will be subjected to.            bufferIndex         &lt;Integer&gt;          index in the query of this buffer.            isNullable          &lt;Boolean&gt;        true if the column is nullable (for INSERTs).            isBinary            &lt;Boolean&gt;		true if the data held is binary, false if character based.            isUnsigned        &lt;Boolean&gt;        true if the integer type of this buffer is unsigned.		isNull			&lt;Boolean&gt;		true if the retrieved column is NULL.		length			&lt;Integer&gt;		size of the current ByteArray.		byteArray		&lt;ByteArray&gt;	the actual data retrieved (nil if column was NULL).            maxDbDatumLength       &lt;Integer&gt; size of largest datum encountered (before any truncation).            session &lt;MySQLSession&gt;         the session object which owns this buffer.</body></comment><class><name>MySQLColumnDescription</name><environment>Database</environment><super>Database.ExternalDatabaseColumnDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>org_name table org_table db catalog def mysqlType charsetnr isBinaryCollation isUnsigned </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-MySQL</category><attributes><package>MySQLEXDI</package></attributes></class><comment><class-id>Database.MySQLColumnDescription</class-id><body>MySQLColumnDescription adds information to the generic ExternalDatabaseColumnDescription which is unique to MySQL. This class is inflated with information about the column being SELECTed. It is populated by the MySQL api, and used for making a MySQLBuffer instance to receive the data when it is fetched. Instance Variables:            catalog  &lt;Object&gt;           not used currently.            charsetnr &lt;Integer&gt;	character set indicator. eg., 63 means binary (number, varbinary or blob or bit).            db         &lt;String&gt; the name of the database which owns the table holding this column.            def        &lt;Object&gt; description of def.            isBinaryCollation&lt;Boolean&gt;	true if the object was created with a binary collation (ordering is based on byte value).            isUnsigned        &lt;Boolean&gt;	true if the datum is an unsigned numeric type.            mysqlType        &lt;Integer&gt;	the database type indicator of the object.            org_name          &lt;String&gt;	actual column name, not necessarily the alias name.            org_table           &lt;String&gt;	actual table name, not necessarily the alias name.            table     		&lt;String&gt;	table name, or an alias for it.</body></comment><class><name>MySQLSession</name><environment>Database</environment><super>Database.ExternalDatabaseSession</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hstmtHolder resultsCache maxLongData numParameters boundValueBuffersHolder inputBufferPtrsArrayHolder outputBufferPtrsArrayHolder rowCount isRowCountKnown hResultHolder useStatementHandle </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-MySQL</category><attributes><package>MySQLEXDI</package></attributes></class><comment><class-id>Database.MySQLSession</class-id><body>MySQLSession contains the MySQL-specfic protocols for the External Database Interface (EXDI).The following technical details serve to explain some of the instance variables described below.As of VW 7.7, this class automatically works with both the "prepared statement" api of MySQL and the older style "admin" api which doesn't offer input binding, and is text based. The admin api is required by MySQL for administrative queries like: CREATE DATABASE, CREATE PROCEDURE, CREATE FUNCTION, CALL, USE. These queries are not offered as prepared statements, and do not use input binding. Their output columns are text representations of the data. These restrictions make it fairly cumbersome.Due to these limitations, MySQLSession automatically uses the prepared statement api whenever possible. For example, CREATE TABLE, DELETE, DO, INSERT, REPLACE, SELECT, SET, UPDATE, and most SHOW statements are sent via the prepared interface, which does allow bound values on input and output.Instance Variables	hstmtHolder	&lt;ValueModel&gt;	holds the statement handle.	inputBufferPtrsArray	&lt;CPointer&gt;	Array of MSQL_BIND structs, used for sending (binding) input parameters.	maxLongData	&lt;Integer&gt;	Maximum number of bytes to retrieve for long colums.	numParameters	&lt;Integer&gt;	The number of bound inputs (?) used by the query.	outputBufferPtrsArray &lt;CPointer&gt;	Array of MSQL_BIND structs, used for retrieving (binding) output columns.	resultsCache	&lt;Object&gt;	description of resultsCache	boundValueBuffersHolder &lt;ValueModel&gt; Similar to #bindValuePointers, holds the bound values for prepared statements.	rowCount	&lt;Integer&gt;	The number of rows affected by the last query.	isRowCountKnown	&lt;Boolean&gt;	True if rowCount is valid, False if rowCount hasn't been updated yet.	hResultHolder	&lt;ValueModel&gt;	Holds the ongoing results handle for non-statement-based queries (admin).	useStatementHandle	&lt;Boolean&gt;	True if the most recently prepared query uses a statement handle (not admin).Shared Variables	DefaultMaxLongData	&lt;Integer&gt; Default maximum size for large String and ByteArray objects.	RegisteredMySQLSessions &lt;Dictionary&gt; Keeps track of active session objects.</body></comment><class><name>MySQLSolarisInterface</name><environment>Database</environment><super>Database.MySQLInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Database.MySQLSolarisInterfaceDictionary.*			</imports><category>Database-External-Libraries</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>libmysqlclient.so</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>MySQLEXDI</package></attributes></class><comment><class-id>Database.MySQLSolarisInterface</class-id><body>This class defines calling conventions for the MySQL client library on the Solaris platform.  Please refer to the environment variable on your machine for the path containing necessary MySQL library files.</body></comment><class><name>MySQLTransaction</name><environment>Database</environment><super>Database.ExternalDatabaseTransaction</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-MySQL</category><attributes><package>MySQLEXDI</package></attributes></class><comment><class-id>Database.MySQLTransaction</class-id><body>Class MySQLTransaction is the concrete implementation of the transaction concept for the Database Connect for MySQL. </body></comment><shared-variable><name>StringTypes</name><environment>Database.MySQLInterface</environment><private>false</private><constant>false</constant><category>Shared Data</category><attributes><package>MySQLEXDI</package></attributes></shared-variable><shared-variable><name>BlobTypes</name><environment>Database.MySQLInterface</environment><private>false</private><constant>false</constant><category>Shared Data</category><attributes><package>MySQLEXDI</package></attributes></shared-variable><shared-variable><name>CharacterTypes</name><environment>Database.MySQLInterface</environment><private>false</private><constant>false</constant><category>Shared Data</category><attributes><package>MySQLEXDI</package></attributes></shared-variable><shared-variable><name>LibraryMajorVersionString</name><environment>Database.MySQLInterface</environment><private>false</private><constant>false</constant><category>Shared Data</category><attributes><package>MySQLEXDI</package></attributes></shared-variable><shared-variable><name>FieldTypesToTypenamesMap</name><environment>Database.MySQLInterface</environment><private>false</private><constant>false</constant><category>Shared Data</category><attributes><package>MySQLEXDI</package></attributes></shared-variable><shared-variable><name>FieldTypenamesToTypesMap</name><environment>Database.MySQLInterface</environment><private>false</private><constant>false</constant><category>Shared Data</category><attributes><package>MySQLEXDI</package></attributes></shared-variable><shared-variable><name>LongTypes</name><environment>Database.MySQLInterface</environment><private>false</private><constant>false</constant><category>Shared Data</category><attributes><package>MySQLEXDI</package></attributes></shared-variable><shared-variable><name>IntegerTypes</name><environment>Database.MySQLInterface</environment><private>false</private><constant>false</constant><category>Shared Data</category><attributes><package>MySQLEXDI</package></attributes></shared-variable><shared-variable><name>TimeTypes</name><environment>Database.MySQLInterface</environment><private>false</private><constant>false</constant><category>Shared Data</category><attributes><package>MySQLEXDI</package></attributes></shared-variable><shared-variable><name>MySQLSolaris64InterfaceDictionary</name><environment>Database</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>MySQLEXDI</package></attributes></shared-variable><shared-variable><name>MySQLLinuxInterfaceDictionary</name><environment>Database</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>MySQLEXDI</package></attributes></shared-variable><shared-variable><name>MySQLInterfaceDictionary</name><environment>Database</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>MySQLEXDI</package></attributes></shared-variable><shared-variable><name>MySQLSolarisInterfaceDictionary</name><environment>Database</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>MySQLEXDI</package></attributes></shared-variable><shared-variable><name>MySQLLinux64InterfaceDictionary</name><environment>Database</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>MySQLEXDI</package></attributes></shared-variable><shared-variable><name>MySQLI386MacOSXInterfaceDictionary</name><environment>Database</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>MySQLEXDI</package></attributes></shared-variable><shared-variable><name>MySQLNT64InterfaceDictionary</name><environment>Database</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>MySQLEXDI</package></attributes></shared-variable><shared-variable><name>MySQLNTInterfaceDictionary</name><environment>Database</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>MySQLEXDI</package></attributes></shared-variable><shared-variable><name>MySQLMacOSX64InterfaceDictionary</name><environment>Database</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>MySQLEXDI</package></attributes></shared-variable><shared-variable><name>RegisteredMySQLSessions</name><environment>Database.MySQLSession</environment><private>false</private><constant>false</constant><category>Shared Variables</category><attributes><package>MySQLEXDI</package></attributes></shared-variable><shared-variable><name>DefaultMaxLongData</name><environment>Database.MySQLSession</environment><private>false</private><constant>false</constant><category>Shared Variables</category><attributes><package>MySQLEXDI</package></attributes></shared-variable><shared-variable><name>SizesOfFixedDatabaseTypes</name><environment>Database.MySQLBuffer</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>MySQLEXDI</package></attributes></shared-variable><shared-variable><name>SmalltalkToMySQLTypesMap</name><environment>Database.MySQLBuffer</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>MySQLEXDI</package></attributes></shared-variable><shared-variable><name>DefaultTypesPutSelectorMap</name><environment>Database.MySQLBuffer</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>MySQLEXDI</package></attributes></shared-variable><shared-variable><name>DefaultTypesGetSelectorMap</name><environment>Database.MySQLBuffer</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>MySQLEXDI</package></attributes></shared-variable><shared-variable><name>UseSetsForMySQL64BitSets</name><environment>Database.MySQLBuffer</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>MySQLEXDI</package></attributes></shared-variable><shared-variable><name>SizesOfFixedSmalltalkTypes</name><environment>Database.MySQLBuffer</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>MySQLEXDI</package></attributes></shared-variable><shared-variable><name>MySQLToSmalltalkTypesMap</name><environment>Database.MySQLBuffer</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>MySQLEXDI</package></attributes></shared-variable><shared-variable><name>InitializeLibraryLock</name><environment>Database.MySQLConnection</environment><private>false</private><constant>false</constant><category>Shared Information</category><attributes><package>MySQLEXDI</package></attributes></shared-variable><shared-variable><name>IsLibraryInitialized</name><environment>Database.MySQLConnection</environment><private>false</private><constant>false</constant><category>Shared Information</category><attributes><package>MySQLEXDI</package></attributes></shared-variable><shared-variable><name>EncoderMap</name><environment>Database.MySQLConnection</environment><private>false</private><constant>false</constant><category>Shared Information</category><attributes><package>MySQLEXDI</package></attributes></shared-variable><shared-variable><name>RegisteredMySQLConnections</name><environment>Database.MySQLConnection</environment><private>false</private><constant>false</constant><category>Shared Information</category><attributes><package>MySQLEXDI</package></attributes></shared-variable><shared-variable><name>SignalMap</name><environment>Database.MySQLConnection</environment><private>false</private><constant>false</constant><category>Shared Information</category><attributes><package>MySQLEXDI</package></attributes></shared-variable><methods><class-id>Database.MySQLInterface</class-id> <category>procedures</category><body package="MySQLEXDI">my_connect: s with: name with: namelen with: timeout	&lt;C: int my_connect(my_socket s, const struct sockaddr * name, unsigned int namelen, unsigned int timeout)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">my_init	&lt;C: my_bool my_init(void)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">my_net_init: net with: vio	&lt;C: my_bool my_net_init(NET * net, Vio * vio)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">my_net_local_init: net	&lt;C: void my_net_local_init(NET * net)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">my_net_read: net	&lt;C: ULONG my_net_read(NET * net)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">my_net_write: net with: packet with: len	&lt;C: my_bool my_net_write(NET * net, const char * packet, ULONG len)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">my_rnd: arg	&lt;C: double my_rnd(struct rand_struct * )&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">my_thread_end	&lt;C: void my_thread_end(void)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">my_thread_init	&lt;C: my_bool my_thread_init(void)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">myodbc_remove_escape: mysql with: name	&lt;C: void __stdcall  myodbc_remove_escape(MYSQL * mysql, char * name)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysqlLibraryEnd	"This call is #defined as _server_end, even for client programs."	&lt;C: void __stdcall  mysql_server_end(void)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysqlLibraryInitArgc: argc argv: argv groups: groups	"This is #defined as a call to server_init, even for client programs."	&lt;C: int __stdcall  mysql_server_init(int argc, char * * argv, char * * groups)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_add_slave: mysql with: host with: port with: user with: passwd	&lt;C: int __stdcall  mysql_add_slave(MYSQL * mysql, const char * host, unsigned int port, const char * user, const char * passwd)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_affected_rows: mysql	&lt;C: my_ulonglong __stdcall  mysql_affected_rows(MYSQL * mysql)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_autocommit: mysql with: auto_mode	&lt;C: my_bool __stdcall  mysql_autocommit(MYSQL * mysql, my_bool auto_mode)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_change_user: mysql with: user with: passwd with: db	&lt;C: my_bool __stdcall  mysql_change_user(MYSQL * mysql, const char * user, const char * passwd, const char * db)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_character_set_name: mysql	&lt;C: const char *  __stdcall  mysql_character_set_name(MYSQL * mysql)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_close: sock	&lt;C: void __stdcall  mysql_close(MYSQL * sock)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_commit: mysql	&lt;C: my_bool __stdcall  mysql_commit(MYSQL * mysql)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_data_seek: result with: offset	&lt;C: void __stdcall  mysql_data_seek(MYSQL_RES * result, my_ulonglong offset)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_debug: debug	&lt;C: void __stdcall  mysql_debug(const char * debug)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_disable_reads_from_master: mysql	&lt;C: void __stdcall  mysql_disable_reads_from_master(MYSQL * mysql)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_disable_rpl_parse: mysql	&lt;C: void __stdcall  mysql_disable_rpl_parse(MYSQL * mysql)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_dump_debug_info: mysql	&lt;C: int __stdcall  mysql_dump_debug_info(MYSQL * mysql)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_embedded	&lt;C: my_bool __stdcall  mysql_embedded(void)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_enable_reads_from_master: mysql	&lt;C: void __stdcall  mysql_enable_reads_from_master(MYSQL * mysql)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_enable_rpl_parse: mysql	&lt;C: void __stdcall  mysql_enable_rpl_parse(MYSQL * mysql)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_eof: res	&lt;C: my_bool __stdcall  mysql_eof(MYSQL_RES * res)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_errno: mysql	&lt;C: unsigned int __stdcall  mysql_errno(MYSQL * mysql)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_errno_to_sqlstate: mysql_errorNo	&lt;C: const char *  mysql_errno_to_sqlstate(unsigned int mysql_errorNo)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_error: mysql	&lt;C: const char *  __stdcall  mysql_error(MYSQL * mysql)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_escape_string: to with: from with: from_length	&lt;C: ULONG __stdcall  mysql_escape_string(char * to, const char * from, ULONG from_length)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_fetch_field: result	&lt;C: MYSQL_FIELD *  __stdcall  mysql_fetch_field(MYSQL_RES * result)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_fetch_field_direct: res with: fieldnr	&lt;C: MYSQL_FIELD *  __stdcall  mysql_fetch_field_direct(MYSQL_RES * res, unsigned int fieldnr)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_fetch_fields50: res	&lt;C: MYSQL_FIELD50 *  __stdcall  mysql_fetch_fields(MYSQL_RES * res)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_fetch_fields51: res	&lt;C: MYSQL_FIELD51 *  __stdcall  mysql_fetch_fields(MYSQL_RES * res)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_fetch_lengths: result	&lt;C: ULONG *  __stdcall  mysql_fetch_lengths(MYSQL_RES * result)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_fetch_row: result	&lt;C: MYSQL_ROW __stdcall  mysql_fetch_row(MYSQL_RES * result)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_field_count: mysql	&lt;C: unsigned int __stdcall  mysql_field_count(MYSQL * mysql)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_field_seek: result with: offset	&lt;C: MYSQL_FIELD_OFFSET __stdcall  mysql_field_seek(MYSQL_RES * result, MYSQL_FIELD_OFFSET offset)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_field_tell: res	&lt;C: MYSQL_FIELD_OFFSET __stdcall  mysql_field_tell(MYSQL_RES * res)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_free_result: result	&lt;C: void __stdcall  mysql_free_result(MYSQL_RES * result)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_get_character_set_info: mysql with: charset	&lt;C: void __stdcall  mysql_get_character_set_info(MYSQL * mysql, MY_CHARSET_INFO * charset)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_get_client_info	&lt;C: const char *  __stdcall  mysql_get_client_info(void)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_get_client_version	&lt;C: ULONG __stdcall  mysql_get_client_version(void)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_get_host_info: mysql	&lt;C: const char *  __stdcall  mysql_get_host_info(MYSQL * mysql)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_get_parameters	&lt;C: MYSQL_PARAMETERS *  __stdcall  mysql_get_parameters(void)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_get_proto_info: mysql	&lt;C: unsigned int __stdcall  mysql_get_proto_info(MYSQL * mysql)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_get_server_info: mysql	&lt;C: const char *  __stdcall  mysql_get_server_info(MYSQL * mysql)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_get_server_version: mysql	&lt;C: ULONG __stdcall  mysql_get_server_version(MYSQL * mysql)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_hex_string: to with: from with: from_length	&lt;C: ULONG __stdcall  mysql_hex_string(char * to, const char * from, ULONG from_length)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_info: mysql	&lt;C: const char *  __stdcall  mysql_info(MYSQL * mysql)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_init: mysql	&lt;C: MYSQL *  __stdcall  mysql_init(MYSQL * mysql)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_insert_id: mysql	&lt;C: my_ulonglong __stdcall  mysql_insert_id(MYSQL * mysql)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_kill: mysql with: pid	&lt;C: int __stdcall  mysql_kill(MYSQL * mysql, ULONG pid)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_list_dbs: mysql with: wild	&lt;C: MYSQL_RES *  __stdcall  mysql_list_dbs(MYSQL * mysql, const char * wild)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_list_fields: mysql with: table with: wild	&lt;C: MYSQL_RES *  __stdcall  mysql_list_fields(MYSQL * mysql, const char * table, const char * wild)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_list_processes: mysql	&lt;C: MYSQL_RES *  __stdcall  mysql_list_processes(MYSQL * mysql)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_list_tables: mysql with: wild	&lt;C: MYSQL_RES *  __stdcall  mysql_list_tables(MYSQL * mysql, const char * wild)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_manager_close: con	&lt;C: void __stdcall  mysql_manager_close(MYSQL_MANAGER * con)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_manager_command: con with: cmd with: cmd_len	&lt;C: int __stdcall  mysql_manager_command(MYSQL_MANAGER * con, const char * cmd, int cmd_len)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_manager_connect: con with: host with: user with: passwd with: port	&lt;C: MYSQL_MANAGER *  __stdcall  mysql_manager_connect(MYSQL_MANAGER * con, const char * host, const char * user, const char * passwd, unsigned int port)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_manager_fetch_line: con with: res_buf with: res_buf_size	&lt;C: int __stdcall  mysql_manager_fetch_line(MYSQL_MANAGER * con, char * res_buf, int res_buf_size)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_manager_init: con	&lt;C: MYSQL_MANAGER *  __stdcall  mysql_manager_init(MYSQL_MANAGER * con)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_master_query: mysql with: q with: length	&lt;C: my_bool __stdcall  mysql_master_query(MYSQL * mysql, const char * q, ULONG length)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_master_send_query: mysql with: q with: length	&lt;C: my_bool __stdcall  mysql_master_send_query(MYSQL * mysql, const char * q, ULONG length)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_more_results: mysql	&lt;C: my_bool __stdcall  mysql_more_results(MYSQL * mysql)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_next_result: mysql	&lt;C: int __stdcall  mysql_next_result(MYSQL * mysql)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_num_fields: res	&lt;C: unsigned int __stdcall  mysql_num_fields(MYSQL_RES * res)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_num_rows: res	&lt;C: my_ulonglong __stdcall  mysql_num_rows(MYSQL_RES * res)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_odbc_escape_string: mysql with: to with: to_length with: from with: from_length with: param with: extend_buffer	&lt;C: char *  __stdcall  mysql_odbc_escape_string(MYSQL * mysql, char * to, ULONG to_length, const char * from, ULONG from_length, void * param, char *  (* extend_buffer)(void * _arg1, char * to, ULONG * length))&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_options: mysql with: option with: arg	&lt;C: int __stdcall  mysql_options(MYSQL * mysql, enum mysql_option option, const char * arg)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_ping: mysql	&lt;C: int __stdcall  mysql_ping(MYSQL * mysql)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_query: mysql with: q	&lt;C: int __stdcall  mysql_query(MYSQL * mysql, const char * q)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_read_query_result: mysql	&lt;C: my_bool __stdcall  mysql_read_query_result(MYSQL * mysql)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_reads_from_master_enabled: mysql	&lt;C: my_bool __stdcall  mysql_reads_from_master_enabled(MYSQL * mysql)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_real_connect: mysql host: host user: user passwd: passwd db: db port: port unix_socket: unix_socket clientflag: clientflag	&lt;C: MYSQL *  __stdcall  mysql_real_connect(MYSQL * mysql, const char * host, const char * user, const char * passwd, const char * db, unsigned int port, const char * unix_socket, ULONG clientflag)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_real_escape_string: mysql with: to with: from with: length	&lt;C: ULONG __stdcall  mysql_real_escape_string(MYSQL * mysql, char * to, const char * from, ULONG length)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_real_query: mysql query: q length: length	&lt;C: int __stdcall  mysql_real_query(MYSQL * mysql, const char * q, ULONG length)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_refresh: mysql with: refresh_options	&lt;C: int __stdcall  mysql_refresh(MYSQL * mysql, unsigned int refresh_options)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_rollback: mysql	&lt;C: my_bool __stdcall  mysql_rollback(MYSQL * mysql)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_row_seek: result with: offset	&lt;C: MYSQL_ROW_OFFSET __stdcall  mysql_row_seek(MYSQL_RES * result, MYSQL_ROW_OFFSET offset)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_row_tell: res	&lt;C: MYSQL_ROW_OFFSET __stdcall  mysql_row_tell(MYSQL_RES * res)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_rpl_parse_enabled: mysql	&lt;C: int __stdcall  mysql_rpl_parse_enabled(MYSQL * mysql)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_rpl_probe: mysql	&lt;C: my_bool __stdcall  mysql_rpl_probe(MYSQL * mysql)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_rpl_query_type: q with: len	&lt;C: enum mysql_rpl_type __stdcall  mysql_rpl_query_type(const char * q, int len)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_select_db: mysql with: db	&lt;C: int __stdcall  mysql_select_db(MYSQL * mysql, const char * db)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_send_query: mysql with: q with: length	&lt;C: int __stdcall  mysql_send_query(MYSQL * mysql, const char * q, ULONG length)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_server_end	&lt;C: void __stdcall  mysql_server_end(void)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_server_init: argc with: argv with: groups	&lt;C: int __stdcall  mysql_server_init(int argc, char * * argv, char * * groups)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_set_character_set: mysql with: csname	&lt;C: int __stdcall  mysql_set_character_set(MYSQL * mysql, const char * csname)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_set_local_infile_default: mysql	&lt;C: void mysql_set_local_infile_default(MYSQL * mysql)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_set_local_infile_handler: mysql with: local_infile_init with: local_infile_read with: local_infile_end with: local_infile_error with: _arg1	&lt;C: void mysql_set_local_infile_handler(MYSQL * mysql, int (* local_infile_init)(void * * , const char * , void * ), int (* local_infile_read)(void * , char * , unsigned int), void (* local_infile_end)(void * ), int (* local_infile_error)(void * , char * , unsigned int), void * _arg1)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_set_master: mysql with: host with: port with: user with: passwd	&lt;C: int __stdcall  mysql_set_master(MYSQL * mysql, const char * host, unsigned int port, const char * user, const char * passwd)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_set_server_option: mysql with: option	&lt;C: int __stdcall  mysql_set_server_option(MYSQL * mysql, enum enum_mysql_set_option option)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_shutdown: mysql with: shutdown_level	&lt;C: int __stdcall  mysql_shutdown(MYSQL * mysql, enum mysql_enum_shutdown_level shutdown_level)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_slave_query: mysql with: q with: length	&lt;C: my_bool __stdcall  mysql_slave_query(MYSQL * mysql, const char * q, ULONG length)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_slave_send_query: mysql with: q with: length	&lt;C: my_bool __stdcall  mysql_slave_send_query(MYSQL * mysql, const char * q, ULONG length)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_sqlstate: mysql	&lt;C: const char *  __stdcall  mysql_sqlstate(MYSQL * mysql)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_ssl_set: mysql with: key with: cert with: ca with: capath with: cipher	&lt;C: my_bool __stdcall  mysql_ssl_set(MYSQL * mysql, const char * key, const char * cert, const char * ca, const char * capath, const char * cipher)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_stat: mysql	&lt;C: const char *  __stdcall  mysql_stat(MYSQL * mysql)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_stmt_affected_rows: stmt	&lt;C: my_ulonglong __stdcall  mysql_stmt_affected_rows(MYSQL_STMT * stmt)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_stmt_attr_get: stmt with: attr_type with: attr	&lt;C: my_bool __stdcall  mysql_stmt_attr_get(MYSQL_STMT * stmt, enum enum_stmt_attr_type attr_type, void * attr)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_stmt_attr_set: stmt attr_type: attr_type attr: attr	&lt;C: my_bool __stdcall  mysql_stmt_attr_set(MYSQL_STMT * stmt, enum enum_stmt_attr_type attr_type, const void * attr)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_stmt_bind_param: stmt bind: bnd	&lt;C: my_bool __stdcall  mysql_stmt_bind_param(MYSQL_STMT * stmt, MYSQL_BIND * bnd)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_stmt_bind_result: stmt bind: bnd	&lt;C: my_bool __stdcall  mysql_stmt_bind_result(MYSQL_STMT * stmt, MYSQL_BIND * bnd)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_stmt_close: stmt	&lt;C: my_bool __stdcall  mysql_stmt_close(MYSQL_STMT * stmt)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_stmt_data_seek: stmt with: offset	&lt;C: void __stdcall  mysql_stmt_data_seek(MYSQL_STMT * stmt, my_ulonglong offset)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_stmt_errno: stmt	&lt;C: unsigned int __stdcall  mysql_stmt_errno(MYSQL_STMT * stmt)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_stmt_error: stmt	&lt;C: const char *  __stdcall  mysql_stmt_error(MYSQL_STMT * stmt)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_stmt_execute: stmt	&lt;C: int __stdcall  mysql_stmt_execute(MYSQL_STMT * stmt)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_stmt_fetch: stmt	&lt;C: int __stdcall  mysql_stmt_fetch(MYSQL_STMT * stmt)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_stmt_fetch_column: stmt with: bind with: column with: offset	&lt;C: int __stdcall  mysql_stmt_fetch_column(MYSQL_STMT * stmt, MYSQL_BIND * bind, unsigned int column, ULONG offset)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_stmt_field_count: stmt	&lt;C: unsigned int __stdcall  mysql_stmt_field_count(MYSQL_STMT * stmt)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_stmt_free_result: stmt	&lt;C: my_bool __stdcall  mysql_stmt_free_result(MYSQL_STMT * stmt)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_stmt_init: mysql	&lt;C: MYSQL_STMT *  __stdcall  mysql_stmt_init(MYSQL * mysql)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_stmt_insert_id: stmt	&lt;C: my_ulonglong __stdcall  mysql_stmt_insert_id(MYSQL_STMT * stmt)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_stmt_num_rows: stmt	&lt;C: my_ulonglong __stdcall  mysql_stmt_num_rows(MYSQL_STMT * stmt)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_stmt_param_count: stmt	&lt;C: ULONG __stdcall  mysql_stmt_param_count(MYSQL_STMT * stmt)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_stmt_param_metadata: stmt	&lt;C: MYSQL_RES *  __stdcall  mysql_stmt_param_metadata(MYSQL_STMT * stmt)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_stmt_prepare: stmt query: query length: length	&lt;C: int __stdcall  mysql_stmt_prepare(MYSQL_STMT * stmt, const char * query, ULONG length)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_stmt_reset: stmt	&lt;C: my_bool __stdcall  mysql_stmt_reset(MYSQL_STMT * stmt)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_stmt_result_metadata: stmt	&lt;C: MYSQL_RES *  __stdcall  mysql_stmt_result_metadata(MYSQL_STMT * stmt)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_stmt_row_seek: stmt with: offset	&lt;C: MYSQL_ROW_OFFSET __stdcall  mysql_stmt_row_seek(MYSQL_STMT * stmt, MYSQL_ROW_OFFSET offset)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_stmt_row_tell: stmt	&lt;C: MYSQL_ROW_OFFSET __stdcall  mysql_stmt_row_tell(MYSQL_STMT * stmt)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_stmt_send_long_data: stmt with: param_number with: data with: length	&lt;C: my_bool __stdcall  mysql_stmt_send_long_data(MYSQL_STMT * stmt, unsigned int param_number, const char * data, ULONG length)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_stmt_sqlstate: stmt	&lt;C: const char *  __stdcall  mysql_stmt_sqlstate(MYSQL_STMT * stmt)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_stmt_store_result: stmt	&lt;C: int __stdcall  mysql_stmt_store_result(MYSQL_STMT * stmt)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_store_result: mysql	&lt;C: MYSQL_RES *  __stdcall  mysql_store_result(MYSQL * mysql)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_thread_end	&lt;C: void __stdcall  mysql_thread_end(void)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_thread_id: mysql	&lt;C: ULONG __stdcall  mysql_thread_id(MYSQL * mysql)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_thread_init	&lt;C: my_bool __stdcall  mysql_thread_init(void)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_thread_safe	&lt;C: unsigned int __stdcall  mysql_thread_safe(void)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_use_result: mysql	&lt;C: MYSQL_RES *  __stdcall  mysql_use_result(MYSQL * mysql)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="MySQLEXDI">mysql_warning_count: mysql	&lt;C: unsigned int __stdcall  mysql_warning_count(MYSQL * mysql)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>Database.MySQLInterface</class-id> <category>defines</category><body package="MySQLEXDI">ALLOC_MAX_BLOCK_TO_DROP	&lt;C: #define ALLOC_MAX_BLOCK_TO_DROP 4096	&gt;</body><body package="MySQLEXDI">ALLOC_MAX_BLOCK_USAGE_BEFORE_DROP	&lt;C: #define ALLOC_MAX_BLOCK_USAGE_BEFORE_DROP 10	&gt;</body><body package="MySQLEXDI">ASCII_BITS_USED	&lt;C: #define ASCII_BITS_USED 8	&gt;</body><body package="MySQLEXDI">AUTO_INCREMENT_FLAG	&lt;C: #define AUTO_INCREMENT_FLAG 512	&gt;</body><body package="MySQLEXDI">BINARY_FLAG	&lt;C: #define BINARY_FLAG 128	&gt;</body><body package="MySQLEXDI">BINCMP_FLAG	&lt;C: #define BINCMP_FLAG 131072	&gt;</body><body package="MySQLEXDI">BLOB_FLAG	&lt;C: #define BLOB_FLAG 16	&gt;</body><body package="MySQLEXDI">BUFSIZ	&lt;C: #define BUFSIZ 512	&gt;</body><body package="MySQLEXDI">CLIENT_COMPRESS	&lt;C: #define CLIENT_COMPRESS 32	&gt;</body><body package="MySQLEXDI">CLIENT_CONNECT_WITH_DB	&lt;C: #define CLIENT_CONNECT_WITH_DB 8	&gt;</body><body package="MySQLEXDI">CLIENT_FOUND_ROWS	&lt;C: #define CLIENT_FOUND_ROWS 2	&gt;</body><body package="MySQLEXDI">CLIENT_IGNORE_SIGPIPE	&lt;C: #define CLIENT_IGNORE_SIGPIPE 4096	&gt;</body><body package="MySQLEXDI">CLIENT_IGNORE_SPACE	&lt;C: #define CLIENT_IGNORE_SPACE 256	&gt;</body><body package="MySQLEXDI">CLIENT_INTERACTIVE	&lt;C: #define CLIENT_INTERACTIVE 1024	&gt;</body><body package="MySQLEXDI">CLIENT_LOCAL_FILES	&lt;C: #define CLIENT_LOCAL_FILES 128	&gt;</body><body package="MySQLEXDI">CLIENT_LONG_FLAG	&lt;C: #define CLIENT_LONG_FLAG 4	&gt;</body><body package="MySQLEXDI">CLIENT_LONG_PASSWORD	&lt;C: #define CLIENT_LONG_PASSWORD 1	&gt;</body><body package="MySQLEXDI">CLIENT_MULTI_QUERIES	&lt;C: #define CLIENT_MULTI_QUERIES CLIENT_MULTI_STATEMENTS	&gt;</body><body package="MySQLEXDI">CLIENT_MULTI_RESULTS	&lt;C: #define CLIENT_MULTI_RESULTS 131072	&gt;</body><body package="MySQLEXDI">CLIENT_MULTI_STATEMENTS	&lt;C: #define CLIENT_MULTI_STATEMENTS 65536	&gt;</body><body package="MySQLEXDI">CLIENT_NET_READ_TIMEOUT	&lt;C: #define CLIENT_NET_READ_TIMEOUT 365*24*3600	&gt;</body><body package="MySQLEXDI">CLIENT_NET_WRITE_TIMEOUT	&lt;C: #define CLIENT_NET_WRITE_TIMEOUT 365*24*3600	&gt;</body><body package="MySQLEXDI">CLIENT_NO_SCHEMA	&lt;C: #define CLIENT_NO_SCHEMA 16	&gt;</body><body package="MySQLEXDI">CLIENT_ODBC	&lt;C: #define CLIENT_ODBC 64	&gt;</body><body package="MySQLEXDI">CLIENT_PROTOCOL_41	&lt;C: #define CLIENT_PROTOCOL_41 512	&gt;</body><body package="MySQLEXDI">CLIENT_REMEMBER_OPTIONS	&lt;C: #define CLIENT_REMEMBER_OPTIONS (((ulong)1)&lt;&lt;31)	&gt;</body><body package="MySQLEXDI">CLIENT_RESERVED	&lt;C: #define CLIENT_RESERVED 16384	&gt;</body><body package="MySQLEXDI">CLIENT_SECURE_CONNECTION	&lt;C: #define CLIENT_SECURE_CONNECTION 32768	&gt;</body><body package="MySQLEXDI">CLIENT_SSL	&lt;C: #define CLIENT_SSL 2048	&gt;</body><body package="MySQLEXDI">CLIENT_TRANSACTIONS	&lt;C: #define CLIENT_TRANSACTIONS 8192	&gt;</body><body package="MySQLEXDI">CLOCKS_PER_SEC	&lt;C: #define CLOCKS_PER_SEC 1000	&gt;</body><body package="MySQLEXDI">COMP_HEADER_SIZE	&lt;C: #define COMP_HEADER_SIZE 3	&gt;</body><body package="MySQLEXDI">CR_SERVER_GONE_ERROR	&lt;C: #define CR_SERVER_GONE_ERROR 2006	&gt;</body><body package="MySQLEXDI">C_MODE_END	&lt;C: #define C_MODE_END 	&gt;</body><body package="MySQLEXDI">C_MODE_START	&lt;C: #define C_MODE_START 	&gt;</body><body package="MySQLEXDI">DBL_MAX	&lt;C: #define DBL_MAX 1.7976931348623d308	&gt;</body><body package="MySQLEXDI">DBL_MIN	&lt;C: #define DBL_MIN 0.0d	&gt;</body><body package="MySQLEXDI">DBUG_FILE	&lt;C: #define DBUG_FILE (_db_fp_)	&gt;</body><body package="MySQLEXDI">DBUG_IN_USE	&lt;C: #define DBUG_IN_USE (_db_fp_&amp;&amp;_db_fp_!=stderr)	&gt;</body><body package="MySQLEXDI">DBUG_LEAVE	&lt;C: #define DBUG_LEAVE (_db_return_(__LINE__,&amp;_db_func_,&amp;_db_file_,&amp;_db_level_))	&gt;</body><body package="MySQLEXDI">DBUG_LOCK_FILE	&lt;C: #define DBUG_LOCK_FILE {_db_lock_file();}	&gt;</body><body package="MySQLEXDI">DBUG_UNLOCK_FILE	&lt;C: #define DBUG_UNLOCK_FILE {_db_unlock_file();}	&gt;</body><body package="MySQLEXDI">DBUG_VOID_RETURN	&lt;C: #define DBUG_VOID_RETURN {DBUG_LEAVE;return;}	&gt;</body><body package="MySQLEXDI">DEBUGGER_OFF	&lt;C: #define DEBUGGER_OFF _no_db_=1;_db_on_=0;	&gt;</body><body package="MySQLEXDI">DEBUGGER_ON	&lt;C: #define DEBUGGER_ON _no_db_=0	&gt;</body><body package="MySQLEXDI">DONT_REMEMBER_SIGNAL	&lt;C: #define DONT_REMEMBER_SIGNAL 	&gt;</body><body package="MySQLEXDI">E2BIG	&lt;C: #define E2BIG 7	&gt;</body><body package="MySQLEXDI">EACCES	&lt;C: #define EACCES 13	&gt;</body><body package="MySQLEXDI">EAGAIN	&lt;C: #define EAGAIN 11	&gt;</body><body package="MySQLEXDI">EBADF	&lt;C: #define EBADF 9	&gt;</body><body package="MySQLEXDI">EBUSY	&lt;C: #define EBUSY 16	&gt;</body><body package="MySQLEXDI">ECHILD	&lt;C: #define ECHILD 10	&gt;</body><body package="MySQLEXDI">EDEADLK	&lt;C: #define EDEADLK 36	&gt;</body><body package="MySQLEXDI">EDEADLOCK	&lt;C: #define EDEADLOCK EDEADLK	&gt;</body><body package="MySQLEXDI">EDOM	&lt;C: #define EDOM 33	&gt;</body><body package="MySQLEXDI">EEXIST	&lt;C: #define EEXIST 17	&gt;</body><body package="MySQLEXDI">EFAULT	&lt;C: #define EFAULT 14	&gt;</body><body package="MySQLEXDI">EFBIG	&lt;C: #define EFBIG 27	&gt;</body><body package="MySQLEXDI">EILSEQ	&lt;C: #define EILSEQ 42	&gt;</body><body package="MySQLEXDI">EINTR	&lt;C: #define EINTR 4	&gt;</body><body package="MySQLEXDI">EINVAL	&lt;C: #define EINVAL 22	&gt;</body><body package="MySQLEXDI">EIO	&lt;C: #define EIO 5	&gt;</body><body package="MySQLEXDI">EISDIR	&lt;C: #define EISDIR 21	&gt;</body><body package="MySQLEXDI">EMFILE	&lt;C: #define EMFILE 24	&gt;</body><body package="MySQLEXDI">EMLINK	&lt;C: #define EMLINK 31	&gt;</body><body package="MySQLEXDI">ENAMETOOLONG	&lt;C: #define ENAMETOOLONG 38	&gt;</body><body package="MySQLEXDI">ENFILE	&lt;C: #define ENFILE 23	&gt;</body><body package="MySQLEXDI">ENGLISH	&lt;C: #define ENGLISH 1	&gt;</body><body package="MySQLEXDI">ENODEV	&lt;C: #define ENODEV 19	&gt;</body><body package="MySQLEXDI">ENOENT	&lt;C: #define ENOENT 2	&gt;</body><body package="MySQLEXDI">ENOEXEC	&lt;C: #define ENOEXEC 8	&gt;</body><body package="MySQLEXDI">ENOLCK	&lt;C: #define ENOLCK 39	&gt;</body><body package="MySQLEXDI">ENOMEM	&lt;C: #define ENOMEM 12	&gt;</body><body package="MySQLEXDI">ENOSPC	&lt;C: #define ENOSPC 28	&gt;</body><body package="MySQLEXDI">ENOSYS	&lt;C: #define ENOSYS 40	&gt;</body><body package="MySQLEXDI">ENOTDIR	&lt;C: #define ENOTDIR 20	&gt;</body><body package="MySQLEXDI">ENOTEMPTY	&lt;C: #define ENOTEMPTY 41	&gt;</body><body package="MySQLEXDI">ENOTTY	&lt;C: #define ENOTTY 25	&gt;</body><body package="MySQLEXDI">ENUM_FLAG	&lt;C: #define ENUM_FLAG 256	&gt;</body><body package="MySQLEXDI">ENXIO	&lt;C: #define ENXIO 6	&gt;</body><body package="MySQLEXDI">EOF	&lt;C: #define EOF (-1)	&gt;</body><body package="MySQLEXDI">EPERM	&lt;C: #define EPERM 1	&gt;</body><body package="MySQLEXDI">EPIPE	&lt;C: #define EPIPE 32	&gt;</body><body package="MySQLEXDI">ERANGE	&lt;C: #define ERANGE 34	&gt;</body><body package="MySQLEXDI">EROFS	&lt;C: #define EROFS 30	&gt;</body><body package="MySQLEXDI">ER_WARN_DATA_TRUNCATED	&lt;C: #define ER_WARN_DATA_TRUNCATED WARN_DATA_TRUNCATED	&gt;</body><body package="MySQLEXDI">ESPIPE	&lt;C: #define ESPIPE 29	&gt;</body><body package="MySQLEXDI">ESRCH	&lt;C: #define ESRCH 3	&gt;</body><body package="MySQLEXDI">EXDEV	&lt;C: #define EXDEV 18	&gt;</body><body package="MySQLEXDI">FALSE	&lt;C: #define FALSE (0)	&gt;</body><body package="MySQLEXDI">FAR	&lt;C: #define FAR 	&gt;</body><body package="MySQLEXDI">FIELD_TYPE_BIT	&lt;C: #define FIELD_TYPE_BIT MYSQL_TYPE_BIT	&gt;</body><body package="MySQLEXDI">FIELD_TYPE_BLOB	&lt;C: #define FIELD_TYPE_BLOB MYSQL_TYPE_BLOB	&gt;</body><body package="MySQLEXDI">FIELD_TYPE_CHAR	&lt;C: #define FIELD_TYPE_CHAR MYSQL_TYPE_TINY	&gt;</body><body package="MySQLEXDI">FIELD_TYPE_DATE	&lt;C: #define FIELD_TYPE_DATE MYSQL_TYPE_DATE	&gt;</body><body package="MySQLEXDI">FIELD_TYPE_DATETIME	&lt;C: #define FIELD_TYPE_DATETIME MYSQL_TYPE_DATETIME	&gt;</body><body package="MySQLEXDI">FIELD_TYPE_DECIMAL	&lt;C: #define FIELD_TYPE_DECIMAL MYSQL_TYPE_DECIMAL	&gt;</body><body package="MySQLEXDI">FIELD_TYPE_DOUBLE	&lt;C: #define FIELD_TYPE_DOUBLE MYSQL_TYPE_DOUBLE	&gt;</body><body package="MySQLEXDI">FIELD_TYPE_ENUM	&lt;C: #define FIELD_TYPE_ENUM MYSQL_TYPE_ENUM	&gt;</body><body package="MySQLEXDI">FIELD_TYPE_FLOAT	&lt;C: #define FIELD_TYPE_FLOAT MYSQL_TYPE_FLOAT	&gt;</body><body package="MySQLEXDI">FIELD_TYPE_GEOMETRY	&lt;C: #define FIELD_TYPE_GEOMETRY MYSQL_TYPE_GEOMETRY	&gt;</body><body package="MySQLEXDI">FIELD_TYPE_INT24	&lt;C: #define FIELD_TYPE_INT24 MYSQL_TYPE_INT24	&gt;</body><body package="MySQLEXDI">FIELD_TYPE_INTERVAL	&lt;C: #define FIELD_TYPE_INTERVAL MYSQL_TYPE_ENUM	&gt;</body><body package="MySQLEXDI">FIELD_TYPE_LONG	&lt;C: #define FIELD_TYPE_LONG MYSQL_TYPE_LONG	&gt;</body><body package="MySQLEXDI">FIELD_TYPE_LONGLONG	&lt;C: #define FIELD_TYPE_LONGLONG MYSQL_TYPE_LONGLONG	&gt;</body><body package="MySQLEXDI">FIELD_TYPE_LONG_BLOB	&lt;C: #define FIELD_TYPE_LONG_BLOB MYSQL_TYPE_LONG_BLOB	&gt;</body><body package="MySQLEXDI">FIELD_TYPE_MEDIUM_BLOB	&lt;C: #define FIELD_TYPE_MEDIUM_BLOB MYSQL_TYPE_MEDIUM_BLOB	&gt;</body><body package="MySQLEXDI">FIELD_TYPE_NEWDATE	&lt;C: #define FIELD_TYPE_NEWDATE MYSQL_TYPE_NEWDATE	&gt;</body><body package="MySQLEXDI">FIELD_TYPE_NEWDECIMAL	&lt;C: #define FIELD_TYPE_NEWDECIMAL MYSQL_TYPE_NEWDECIMAL	&gt;</body><body package="MySQLEXDI">FIELD_TYPE_NULL	&lt;C: #define FIELD_TYPE_NULL MYSQL_TYPE_NULL	&gt;</body><body package="MySQLEXDI">FIELD_TYPE_SET	&lt;C: #define FIELD_TYPE_SET MYSQL_TYPE_SET	&gt;</body><body package="MySQLEXDI">FIELD_TYPE_SHORT	&lt;C: #define FIELD_TYPE_SHORT MYSQL_TYPE_SHORT	&gt;</body><body package="MySQLEXDI">FIELD_TYPE_STRING	&lt;C: #define FIELD_TYPE_STRING MYSQL_TYPE_STRING	&gt;</body><body package="MySQLEXDI">FIELD_TYPE_TIME	&lt;C: #define FIELD_TYPE_TIME MYSQL_TYPE_TIME	&gt;</body><body package="MySQLEXDI">FIELD_TYPE_TIMESTAMP	&lt;C: #define FIELD_TYPE_TIMESTAMP MYSQL_TYPE_TIMESTAMP	&gt;</body><body package="MySQLEXDI">FIELD_TYPE_TINY	&lt;C: #define FIELD_TYPE_TINY MYSQL_TYPE_TINY	&gt;</body><body package="MySQLEXDI">FIELD_TYPE_TINY_BLOB	&lt;C: #define FIELD_TYPE_TINY_BLOB MYSQL_TYPE_TINY_BLOB	&gt;</body><body package="MySQLEXDI">FIELD_TYPE_VAR_STRING	&lt;C: #define FIELD_TYPE_VAR_STRING MYSQL_TYPE_VAR_STRING	&gt;</body><body package="MySQLEXDI">FIELD_TYPE_YEAR	&lt;C: #define FIELD_TYPE_YEAR MYSQL_TYPE_YEAR	&gt;</body><body package="MySQLEXDI">FILENAME_MAX	&lt;C: #define FILENAME_MAX 260	&gt;</body><body package="MySQLEXDI">FILE_BINARY	&lt;C: #define FILE_BINARY O_BINARY	&gt;</body><body package="MySQLEXDI">FLT_MAX	&lt;C: #define FLT_MAX ((float)3.4028234663853d38)	&gt;</body><body package="MySQLEXDI">FLT_MIN	&lt;C: #define FLT_MIN ((float)1.4012984643248d-45)	&gt;</body><body package="MySQLEXDI">FN_CURLIB	&lt;C: #define FN_CURLIB 46	&gt;</body><body package="MySQLEXDI">FN_DEVCHAR	&lt;C: #define FN_DEVCHAR 58	&gt;</body><body package="MySQLEXDI">FN_EXTCHAR	&lt;C: #define FN_EXTCHAR 46	&gt;</body><body package="MySQLEXDI">FN_EXTLEN	&lt;C: #define FN_EXTLEN 20	&gt;</body><body package="MySQLEXDI">FN_HEADLEN	&lt;C: #define FN_HEADLEN 253	&gt;</body><body package="MySQLEXDI">FN_HOMELIB	&lt;C: #define FN_HOMELIB 126	&gt;</body><body package="MySQLEXDI">FN_LEN	&lt;C: #define FN_LEN 256	&gt;</body><body package="MySQLEXDI">FN_LIBCHAR	&lt;C: #define FN_LIBCHAR 47	&gt;</body><body package="MySQLEXDI">FN_PARENTDIR	&lt;C: #define FN_PARENTDIR ".."	&gt;</body><body package="MySQLEXDI">FN_REFLEN	&lt;C: #define FN_REFLEN 512	&gt;</body><body package="MySQLEXDI">FN_ROOTDIR	&lt;C: #define FN_ROOTDIR "/"	&gt;</body><body package="MySQLEXDI">FOPEN_MAX	&lt;C: #define FOPEN_MAX 20	&gt;</body><body package="MySQLEXDI">FRM_VER	&lt;C: #define FRM_VER 6	&gt;</body><body package="MySQLEXDI">GROUP_FLAG	&lt;C: #define GROUP_FLAG 32768	&gt;</body><body package="MySQLEXDI">HAVE_EXTERNAL_CLIENT	&lt;C: #define HAVE_EXTERNAL_CLIENT 	&gt;</body><body package="MySQLEXDI">HAVE_MYSQL_REAL_CONNECT	&lt;C: #define HAVE_MYSQL_REAL_CONNECT 	&gt;</body><body package="MySQLEXDI">HAVE_REPLICATION	&lt;C: #define HAVE_REPLICATION 	&gt;</body><body package="MySQLEXDI">HAVE_UINT	&lt;C: #define HAVE_UINT 	&gt;</body><body package="MySQLEXDI">HOSTNAME_LENGTH	&lt;C: #define HOSTNAME_LENGTH 60	&gt;</body><body package="MySQLEXDI">HUGE_PTR	&lt;C: #define HUGE_PTR 	&gt;</body><body package="MySQLEXDI">HUGE_VAL	&lt;C: #define HUGE_VAL _HUGE	&gt;</body><body package="MySQLEXDI">INT_MAX16	&lt;C: #define INT_MAX16 32767	&gt;</body><body package="MySQLEXDI">INT_MAX24	&lt;C: #define INT_MAX24 0x007FFFFF	&gt;</body><body package="MySQLEXDI">INT_MAX32	&lt;C: #define INT_MAX32 2147483647	&gt;</body><body package="MySQLEXDI">INT_MAX8	&lt;C: #define INT_MAX8 127	&gt;</body><body package="MySQLEXDI">INT_MIN16	&lt;C: #define INT_MIN16 (~32767)	&gt;</body><body package="MySQLEXDI">INT_MIN24	&lt;C: #define INT_MIN24 (~0x007FFFFF)	&gt;</body><body package="MySQLEXDI">INT_MIN32	&lt;C: #define INT_MIN32 (~2147483647)	&gt;</body><body package="MySQLEXDI">INT_MIN8	&lt;C: #define INT_MIN8 (~127)	&gt;</body><body package="MySQLEXDI">INVALID_SOCKET	&lt;C: #define INVALID_SOCKET -1	&gt;</body><body package="MySQLEXDI">IO_SIZE	&lt;C: #define IO_SIZE 4096	&gt;</body><body package="MySQLEXDI">KEY_CACHE_BLOCK_SIZE	&lt;C: #define KEY_CACHE_BLOCK_SIZE (uint)1024	&gt;</body><body package="MySQLEXDI">KEY_CACHE_SIZE	&lt;C: #define KEY_CACHE_SIZE (uint)(8*1024*1024-MALLOC_OVERHEAD)	&gt;</body><body package="MySQLEXDI">LICENSE	&lt;C: #define LICENSE GPL	&gt;</body><body package="MySQLEXDI">LOCAL_HOST	&lt;C: #define LOCAL_HOST "localhost"	&gt;</body><body package="MySQLEXDI">LOCAL_HOST_NAMEDPIPE	&lt;C: #define LOCAL_HOST_NAMEDPIPE "."	&gt;</body><body package="MySQLEXDI">LOCAL_INFILE_ERROR_LEN	&lt;C: #define LOCAL_INFILE_ERROR_LEN 512	&gt;</body><body package="MySQLEXDI">L_tmpnam	&lt;C: #define L_tmpnam sizeof(_P_tmpdir)+12	&gt;</body><body package="MySQLEXDI">MALLOC_OVERHEAD	&lt;C: #define MALLOC_OVERHEAD 8	&gt;</body><body package="MySQLEXDI">MANAGER_ACCESS	&lt;C: #define MANAGER_ACCESS 401	&gt;</body><body package="MySQLEXDI">MANAGER_CLIENT_ERR	&lt;C: #define MANAGER_CLIENT_ERR 450	&gt;</body><body package="MySQLEXDI">MANAGER_INFO	&lt;C: #define MANAGER_INFO 250	&gt;</body><body package="MySQLEXDI">MANAGER_INTERNAL_ERR	&lt;C: #define MANAGER_INTERNAL_ERR 500	&gt;</body><body package="MySQLEXDI">MANAGER_OK	&lt;C: #define MANAGER_OK 200	&gt;</body><body package="MySQLEXDI">MASTER	&lt;C: #define MASTER 1	&gt;</body><body package="MySQLEXDI">MAX_BIGINT_WIDTH	&lt;C: #define MAX_BIGINT_WIDTH 20	&gt;</body><body package="MySQLEXDI">MAX_BLOB_WIDTH	&lt;C: #define MAX_BLOB_WIDTH 8192	&gt;</body><body package="MySQLEXDI">MAX_CHAR_WIDTH	&lt;C: #define MAX_CHAR_WIDTH 255	&gt;</body><body package="MySQLEXDI">MAX_INT_WIDTH	&lt;C: #define MAX_INT_WIDTH 10	&gt;</body><body package="MySQLEXDI">MAX_MEDIUMINT_WIDTH	&lt;C: #define MAX_MEDIUMINT_WIDTH 8	&gt;</body><body package="MySQLEXDI">MAX_MYSQL_MANAGER_ERR	&lt;C: #define MAX_MYSQL_MANAGER_ERR 256	&gt;</body><body package="MySQLEXDI">MAX_MYSQL_MANAGER_MSG	&lt;C: #define MAX_MYSQL_MANAGER_MSG 256	&gt;</body><body package="MySQLEXDI">MAX_SMALLINT_WIDTH	&lt;C: #define MAX_SMALLINT_WIDTH 5	&gt;</body><body package="MySQLEXDI">MAX_TINYINT_WIDTH	&lt;C: #define MAX_TINYINT_WIDTH 3	&gt;</body><body package="MySQLEXDI">MIN_ARRAY_SIZE	&lt;C: #define MIN_ARRAY_SIZE 0	&gt;</body><body package="MySQLEXDI">MULTIPLE_KEY_FLAG	&lt;C: #define MULTIPLE_KEY_FLAG 8	&gt;</body><body package="MySQLEXDI">MYSQL_BASE_VERSION	&lt;C: #define MYSQL_BASE_VERSION "mysqld-5.0"	&gt;</body><body package="MySQLEXDI">MYSQL_CLIENT	&lt;C: #define MYSQL_CLIENT 	&gt;</body><body package="MySQLEXDI">MYSQL_COMPILATION_COMMENT	&lt;C: #define MYSQL_COMPILATION_COMMENT "MySQL Community Edition - Max (GPL)"	&gt;</body><body package="MySQLEXDI">MYSQL_CONFIG_NAME	&lt;C: #define MYSQL_CONFIG_NAME "my"	&gt;</body><body package="MySQLEXDI">MYSQL_COUNT_ERROR	&lt;C: #define MYSQL_COUNT_ERROR (~(my_ulonglong)0)	&gt;</body><body package="MySQLEXDI">MYSQL_DATA_TRUNCATED	&lt;C: #define MYSQL_DATA_TRUNCATED 101	&gt;</body><body package="MySQLEXDI">MYSQL_ERRMSG_SIZE	&lt;C: #define MYSQL_ERRMSG_SIZE 512	&gt;</body><body package="MySQLEXDI">MYSQL_LONG_DATA_HEADER	&lt;C: #define MYSQL_LONG_DATA_HEADER 6	&gt;</body><body package="MySQLEXDI">MYSQL_NAMEDPIPE	&lt;C: #define MYSQL_NAMEDPIPE "MySQL"	&gt;</body><body package="MySQLEXDI">MYSQL_NO_DATA	&lt;C: #define MYSQL_NO_DATA 100	&gt;</body><body package="MySQLEXDI">MYSQL_PORT	&lt;C: #define MYSQL_PORT 3306	&gt;</body><body package="MySQLEXDI">MYSQL_SERVER_SUFFIX_DEF	&lt;C: #define MYSQL_SERVER_SUFFIX_DEF "-community-max-nt"	&gt;</body><body package="MySQLEXDI">MYSQL_SERVER_VERSION	&lt;C: #define MYSQL_SERVER_VERSION "5.0.22"	&gt;</body><body package="MySQLEXDI">MYSQL_SERVICENAME	&lt;C: #define MYSQL_SERVICENAME "MySQL"	&gt;</body><body package="MySQLEXDI">MYSQL_SHUTDOWN_KILLABLE_CONNECT	&lt;C: #define MYSQL_SHUTDOWN_KILLABLE_CONNECT (unsigned char)(1&lt;&lt;0)	&gt;</body><body package="MySQLEXDI">MYSQL_SHUTDOWN_KILLABLE_LOCK_TABLE	&lt;C: #define MYSQL_SHUTDOWN_KILLABLE_LOCK_TABLE (unsigned char)(1&lt;&lt;2)	&gt;</body><body package="MySQLEXDI">MYSQL_SHUTDOWN_KILLABLE_TRANS	&lt;C: #define MYSQL_SHUTDOWN_KILLABLE_TRANS (unsigned char)(1&lt;&lt;1)	&gt;</body><body package="MySQLEXDI">MYSQL_SHUTDOWN_KILLABLE_UPDATE	&lt;C: #define MYSQL_SHUTDOWN_KILLABLE_UPDATE (unsigned char)(1&lt;&lt;3)	&gt;</body><body package="MySQLEXDI">MYSQL_STMT_HEADER	&lt;C: #define MYSQL_STMT_HEADER 4	&gt;</body><body package="MySQLEXDI">MYSQL_UNIVERSAL_CLIENT_CHARSET	&lt;C: #define MYSQL_UNIVERSAL_CLIENT_CHARSET MYSQL_DEFAULT_CHARSET_NAME	&gt;</body><body package="MySQLEXDI">MYSQL_UNIX_ADDR	&lt;C: #define MYSQL_UNIX_ADDR "/tmp/mysql.sock"	&gt;</body><body package="MySQLEXDI">MYSQL_VERSION_ID	&lt;C: #define MYSQL_VERSION_ID 50022	&gt;</body><body package="MySQLEXDI">MY_FILEPOS_ERROR	&lt;C: #define MY_FILEPOS_ERROR (~(my_off_t)0)	&gt;</body><body package="MySQLEXDI">MY_HOW_OFTEN_TO_ALARM	&lt;C: #define MY_HOW_OFTEN_TO_ALARM 2	&gt;</body><body package="MySQLEXDI">MY_HOW_OFTEN_TO_WRITE	&lt;C: #define MY_HOW_OFTEN_TO_WRITE 1000	&gt;</body><body package="MySQLEXDI">MY_NFILE	&lt;C: #define MY_NFILE 64	&gt;</body><body package="MySQLEXDI">M_E	&lt;C: #define M_E 2.718281828459d	&gt;</body><body package="MySQLEXDI">M_LN2	&lt;C: #define M_LN2 0.69314718055995d	&gt;</body><body package="MySQLEXDI">M_PI	&lt;C: #define M_PI 3.1415926535898d	&gt;</body><body package="MySQLEXDI">NAME_LEN	&lt;C: #define NAME_LEN 64	&gt;</body><body package="MySQLEXDI">NEAR	&lt;C: #define NEAR 	&gt;</body><body package="MySQLEXDI">NEAR_F	&lt;C: #define NEAR_F 	&gt;</body><body package="MySQLEXDI">NETWARE_YIELD	&lt;C: #define NETWARE_YIELD 	&gt;</body><body package="MySQLEXDI">NET_HEADER_SIZE	&lt;C: #define NET_HEADER_SIZE 4	&gt;</body><body package="MySQLEXDI">NET_READ_TIMEOUT	&lt;C: #define NET_READ_TIMEOUT 30	&gt;</body><body package="MySQLEXDI">NET_WAIT_TIMEOUT	&lt;C: #define NET_WAIT_TIMEOUT 8*60*60	&gt;</body><body package="MySQLEXDI">NET_WRITE_TIMEOUT	&lt;C: #define NET_WRITE_TIMEOUT 60	&gt;</body><body package="MySQLEXDI">NOT_NULL_FLAG	&lt;C: #define NOT_NULL_FLAG 1	&gt;</body><body package="MySQLEXDI">NO_DEFAULT_VALUE_FLAG	&lt;C: #define NO_DEFAULT_VALUE_FLAG 4096	&gt;</body><body package="MySQLEXDI">NO_HASH	&lt;C: #define NO_HASH 	&gt;</body><body package="MySQLEXDI">NULL	&lt;C: #define NULL ((void*)0)	&gt;</body><body package="MySQLEXDI">NULL_LENGTH	&lt;C: #define NULL_LENGTH ((ULONG)~0)	&gt;</body><body package="MySQLEXDI">NUM_FLAG	&lt;C: #define NUM_FLAG 32768	&gt;</body><body package="MySQLEXDI">NullS	&lt;C: #define NullS (char*)0	&gt;</body><body package="MySQLEXDI">ONCE_ALLOC_INIT	&lt;C: #define ONCE_ALLOC_INIT (uint)(4096-MALLOC_OVERHEAD)	&gt;</body><body package="MySQLEXDI">ONLY_KILL_QUERY	&lt;C: #define ONLY_KILL_QUERY 1	&gt;</body><body package="MySQLEXDI">OS_FILE_LIMIT	&lt;C: #define OS_FILE_LIMIT 65535	&gt;</body><body package="MySQLEXDI">O_BINARY	&lt;C: #define O_BINARY 0	&gt;</body><body package="MySQLEXDI">O_NOFOLLOW	&lt;C: #define O_NOFOLLOW 0	&gt;</body><body package="MySQLEXDI">O_SHARE	&lt;C: #define O_SHARE 0	&gt;</body><body package="MySQLEXDI">O_SHORT_LIVED	&lt;C: #define O_SHORT_LIVED 0	&gt;</body><body package="MySQLEXDI">O_TEMPORARY	&lt;C: #define O_TEMPORARY 0	&gt;</body><body package="MySQLEXDI">PART_KEY_FLAG	&lt;C: #define PART_KEY_FLAG 16384	&gt;</body><body package="MySQLEXDI">POSIX_MISTAKE	&lt;C: #define POSIX_MISTAKE 1	&gt;</body><body package="MySQLEXDI">PRI_KEY_FLAG	&lt;C: #define PRI_KEY_FLAG 2	&gt;</body><body package="MySQLEXDI">PROTOCOL_VERSION	&lt;C: #define PROTOCOL_VERSION 10	&gt;</body><body package="MySQLEXDI">RECORD_CACHE_SIZE	&lt;C: #define RECORD_CACHE_SIZE (uint)(64*1024-MALLOC_OVERHEAD)	&gt;</body><body package="MySQLEXDI">REFRESH_DES_KEY_FILE	&lt;C: #define REFRESH_DES_KEY_FILE 262144	&gt;</body><body package="MySQLEXDI">REFRESH_FAST	&lt;C: #define REFRESH_FAST 32768	&gt;</body><body package="MySQLEXDI">REFRESH_GRANT	&lt;C: #define REFRESH_GRANT 1	&gt;</body><body package="MySQLEXDI">REFRESH_HOSTS	&lt;C: #define REFRESH_HOSTS 8	&gt;</body><body package="MySQLEXDI">REFRESH_LOG	&lt;C: #define REFRESH_LOG 2	&gt;</body><body package="MySQLEXDI">REFRESH_MASTER	&lt;C: #define REFRESH_MASTER 128	&gt;</body><body package="MySQLEXDI">REFRESH_QUERY_CACHE	&lt;C: #define REFRESH_QUERY_CACHE 65536	&gt;</body><body package="MySQLEXDI">REFRESH_QUERY_CACHE_FREE	&lt;C: #define REFRESH_QUERY_CACHE_FREE 131072	&gt;</body><body package="MySQLEXDI">REFRESH_READ_LOCK	&lt;C: #define REFRESH_READ_LOCK 16384	&gt;</body><body package="MySQLEXDI">REFRESH_SLAVE	&lt;C: #define REFRESH_SLAVE 64	&gt;</body><body package="MySQLEXDI">REFRESH_STATUS	&lt;C: #define REFRESH_STATUS 16	&gt;</body><body package="MySQLEXDI">REFRESH_TABLES	&lt;C: #define REFRESH_TABLES 4	&gt;</body><body package="MySQLEXDI">REFRESH_THREADS	&lt;C: #define REFRESH_THREADS 32	&gt;</body><body package="MySQLEXDI">REFRESH_USER_RESOURCES	&lt;C: #define REFRESH_USER_RESOURCES 524288	&gt;</body><body package="MySQLEXDI">SCALE_SEC	&lt;C: #define SCALE_SEC 100	&gt;</body><body package="MySQLEXDI">SCALE_USEC	&lt;C: #define SCALE_USEC 10000	&gt;</body><body package="MySQLEXDI">SCRAMBLED_PASSWORD_CHAR_LENGTH	&lt;C: #define SCRAMBLED_PASSWORD_CHAR_LENGTH (SCRAMBLE_LENGTH*2+1)	&gt;</body><body package="MySQLEXDI">SCRAMBLED_PASSWORD_CHAR_LENGTH_323	&lt;C: #define SCRAMBLED_PASSWORD_CHAR_LENGTH_323 (SCRAMBLE_LENGTH_323*2)	&gt;</body><body package="MySQLEXDI">SCRAMBLE_LENGTH	&lt;C: #define SCRAMBLE_LENGTH 20	&gt;</body><body package="MySQLEXDI">SCRAMBLE_LENGTH_323	&lt;C: #define SCRAMBLE_LENGTH_323 8	&gt;</body><body package="MySQLEXDI">SC_MAXWIDTH	&lt;C: #define SC_MAXWIDTH 256	&gt;</body><body package="MySQLEXDI">SEEK_CUR	&lt;C: #define SEEK_CUR 1	&gt;</body><body package="MySQLEXDI">SEEK_END	&lt;C: #define SEEK_END 2	&gt;</body><body package="MySQLEXDI">SEEK_SET	&lt;C: #define SEEK_SET 0	&gt;</body><body package="MySQLEXDI">SERVER_MORE_RESULTS_EXISTS	&lt;C: #define SERVER_MORE_RESULTS_EXISTS 8	&gt;</body><body package="MySQLEXDI">SERVER_QUERY_NO_GOOD_INDEX_USED	&lt;C: #define SERVER_QUERY_NO_GOOD_INDEX_USED 16	&gt;</body><body package="MySQLEXDI">SERVER_QUERY_NO_INDEX_USED	&lt;C: #define SERVER_QUERY_NO_INDEX_USED 32	&gt;</body><body package="MySQLEXDI">SERVER_STATUS_AUTOCOMMIT	&lt;C: #define SERVER_STATUS_AUTOCOMMIT 2	&gt;</body><body package="MySQLEXDI">SERVER_STATUS_CURSOR_EXISTS	&lt;C: #define SERVER_STATUS_CURSOR_EXISTS 64	&gt;</body><body package="MySQLEXDI">SERVER_STATUS_DB_DROPPED	&lt;C: #define SERVER_STATUS_DB_DROPPED 256	&gt;</body><body package="MySQLEXDI">SERVER_STATUS_IN_TRANS	&lt;C: #define SERVER_STATUS_IN_TRANS 1	&gt;</body><body package="MySQLEXDI">SERVER_STATUS_LAST_ROW_SENT	&lt;C: #define SERVER_STATUS_LAST_ROW_SENT 128	&gt;</body><body package="MySQLEXDI">SERVER_STATUS_MORE_RESULTS	&lt;C: #define SERVER_STATUS_MORE_RESULTS 4	&gt;</body><body package="MySQLEXDI">SERVER_STATUS_NO_BACKSLASH_ESCAPES	&lt;C: #define SERVER_STATUS_NO_BACKSLASH_ESCAPES 512	&gt;</body><body package="MySQLEXDI">SERVER_VERSION_LENGTH	&lt;C: #define SERVER_VERSION_LENGTH 60	&gt;</body><body package="MySQLEXDI">SET_FLAG	&lt;C: #define SET_FLAG 2048	&gt;</body><body package="MySQLEXDI">SOCKET_EADDRINUSE	&lt;C: #define SOCKET_EADDRINUSE EADDRINUSE	&gt;</body><body package="MySQLEXDI">SOCKET_EAGAIN	&lt;C: #define SOCKET_EAGAIN EAGAIN	&gt;</body><body package="MySQLEXDI">SOCKET_EINTR	&lt;C: #define SOCKET_EINTR EINTR	&gt;</body><body package="MySQLEXDI">SOCKET_EMFILE	&lt;C: #define SOCKET_EMFILE EMFILE	&gt;</body><body package="MySQLEXDI">SOCKET_ENFILE	&lt;C: #define SOCKET_ENFILE ENFILE	&gt;</body><body package="MySQLEXDI">SOCKET_ETIMEDOUT	&lt;C: #define SOCKET_ETIMEDOUT SOCKET_EINTR	&gt;</body><body package="MySQLEXDI">SOCKET_EWOULDBLOCK	&lt;C: #define SOCKET_EWOULDBLOCK EWOULDBLOCK	&gt;</body><body package="MySQLEXDI">SOCKOPT_OPTLEN_TYPE	&lt;C: #define SOCKOPT_OPTLEN_TYPE size_socket	&gt;</body><body package="MySQLEXDI">SQLSTATE_LENGTH	&lt;C: #define SQLSTATE_LENGTH 5	&gt;</body><body package="MySQLEXDI">STDCALL	&lt;C: #define STDCALL __stdcall	&gt;</body><body package="MySQLEXDI">SUCCESS	&lt;C: #define SUCCESS 0	&gt;</body><body package="MySQLEXDI">SYSTEM_SIZEOF_OFF_T	&lt;C: #define SYSTEM_SIZEOF_OFF_T SIZEOF_OFF_T	&gt;</body><body package="MySQLEXDI">TIMESTAMP_FLAG	&lt;C: #define TIMESTAMP_FLAG 1024	&gt;</body><body package="MySQLEXDI">TMP_MAX	&lt;C: #define TMP_MAX 32767	&gt;</body><body package="MySQLEXDI">TRUE	&lt;C: #define TRUE (1)	&gt;</body><body package="MySQLEXDI">UINT_MAX16	&lt;C: #define UINT_MAX16 65535	&gt;</body><body package="MySQLEXDI">UINT_MAX24	&lt;C: #define UINT_MAX24 0x00FFFFFF	&gt;</body><body package="MySQLEXDI">UINT_MAX32	&lt;C: #define UINT_MAX32 4294967295	&gt;</body><body package="MySQLEXDI">UINT_MAX8	&lt;C: #define UINT_MAX8 255	&gt;</body><body package="MySQLEXDI">UNIQUE_FLAG	&lt;C: #define UNIQUE_FLAG 65536	&gt;</body><body package="MySQLEXDI">UNIQUE_KEY_FLAG	&lt;C: #define UNIQUE_KEY_FLAG 4	&gt;</body><body package="MySQLEXDI">UNSIGNED_FLAG	&lt;C: #define UNSIGNED_FLAG 32	&gt;</body><body package="MySQLEXDI">UNSINT16	&lt;C: #define UNSINT16 	&gt;</body><body package="MySQLEXDI">UNSINT32	&lt;C: #define UNSINT32 	&gt;</body><body package="MySQLEXDI">UNSINT8	&lt;C: #define UNSINT8 	&gt;</body><body package="MySQLEXDI">USERNAME_LENGTH	&lt;C: #define USERNAME_LENGTH 16	&gt;</body><body package="MySQLEXDI">USER_HOST_BUFF_SIZE	&lt;C: #define USER_HOST_BUFF_SIZE HOSTNAME_LENGTH+USERNAME_LENGTH+2	&gt;</body><body package="MySQLEXDI">USE_BMOVE512	&lt;C: #define USE_BMOVE512 1	&gt;</body><body package="MySQLEXDI">USE_MYFUNC	&lt;C: #define USE_MYFUNC 1	&gt;</body><body package="MySQLEXDI">USE_REGEX	&lt;C: #define USE_REGEX 1	&gt;</body><body package="MySQLEXDI">WEOF	&lt;C: #define WEOF (wint_t)(65535)	&gt;</body><body package="MySQLEXDI">ZEROFILL_FLAG	&lt;C: #define ZEROFILL_FLAG 64	&gt;</body><body package="MySQLEXDI">_CLOCK_T_DEFINED	&lt;C: #define _CLOCK_T_DEFINED 	&gt;</body><body package="MySQLEXDI">_COMPLEX_DEFINED	&lt;C: #define _COMPLEX_DEFINED 	&gt;</body><body package="MySQLEXDI">_CRTAPI1	&lt;C: #define _CRTAPI1 	&gt;</body><body package="MySQLEXDI">_CRTIMP	&lt;C: #define _CRTIMP 	&gt;</body><body package="MySQLEXDI">_DOMAIN	&lt;C: #define _DOMAIN 1	&gt;</body><body package="MySQLEXDI">_EXCEPTION_DEFINED	&lt;C: #define _EXCEPTION_DEFINED 	&gt;</body><body package="MySQLEXDI">_FILE_DEFINED	&lt;C: #define _FILE_DEFINED 	&gt;</body><body package="MySQLEXDI">_FPOS_T_DEFINED	&lt;C: #define _FPOS_T_DEFINED 	&gt;</body><body package="MySQLEXDI">_INC_ERRNO	&lt;C: #define _INC_ERRNO 	&gt;</body><body package="MySQLEXDI">_INC_MATH	&lt;C: #define _INC_MATH 	&gt;</body><body package="MySQLEXDI">_INC_STDIO	&lt;C: #define _INC_STDIO 	&gt;</body><body package="MySQLEXDI">_INC_TIME	&lt;C: #define _INC_TIME 	&gt;</body><body package="MySQLEXDI">_IOEOF	&lt;C: #define _IOEOF 0x0010	&gt;</body><body package="MySQLEXDI">_IOERR	&lt;C: #define _IOERR 0x0020	&gt;</body><body package="MySQLEXDI">_IOFBF	&lt;C: #define _IOFBF 0x0000	&gt;</body><body package="MySQLEXDI">_IOLBF	&lt;C: #define _IOLBF 0x0040	&gt;</body><body package="MySQLEXDI">_IOMYBUF	&lt;C: #define _IOMYBUF 0x0008	&gt;</body><body package="MySQLEXDI">_IONBF	&lt;C: #define _IONBF 0x0004	&gt;</body><body package="MySQLEXDI">_IOREAD	&lt;C: #define _IOREAD 0x0001	&gt;</body><body package="MySQLEXDI">_IORW	&lt;C: #define _IORW 0x0080	&gt;</body><body package="MySQLEXDI">_IOSTRG	&lt;C: #define _IOSTRG 0x0040	&gt;</body><body package="MySQLEXDI">_IOWRT	&lt;C: #define _IOWRT 0x0002	&gt;</body><body package="MySQLEXDI">_MYSQL_READ_DEFAULT_FILE	&lt;C: #define _MYSQL_READ_DEFAULT_FILE 4	&gt;</body><body package="MySQLEXDI">_MYSQL_READ_DEFAULT_GROUP	&lt;C: #define _MYSQL_READ_DEFAULT_GROUP 5	&gt;</body><body package="MySQLEXDI">_NFILE	&lt;C: #define _NFILE _NSTREAM_	&gt;</body><body package="MySQLEXDI">_NSTREAM_	&lt;C: #define _NSTREAM_ 20	&gt;</body><body package="MySQLEXDI">_OVERFLOW	&lt;C: #define _OVERFLOW 3	&gt;</body><body package="MySQLEXDI">_PLOSS	&lt;C: #define _PLOSS 6	&gt;</body><body package="MySQLEXDI">_P_tmpdir	&lt;C: #define _P_tmpdir "\\"	&gt;</body><body package="MySQLEXDI">_SING	&lt;C: #define _SING 2	&gt;</body><body package="MySQLEXDI">_SIZE_T_DEFINED	&lt;C: #define _SIZE_T_DEFINED 	&gt;</body><body package="MySQLEXDI">_STDIO_DEFINED	&lt;C: #define _STDIO_DEFINED 	&gt;</body><body package="MySQLEXDI">_SYS_OPEN	&lt;C: #define _SYS_OPEN 20	&gt;</body><body package="MySQLEXDI">_TIME_T_DEFINED	&lt;C: #define _TIME_T_DEFINED 	&gt;</body><body package="MySQLEXDI">_TLOSS	&lt;C: #define _TLOSS 5	&gt;</body><body package="MySQLEXDI">_TM_DEFINED	&lt;C: #define _TM_DEFINED 	&gt;</body><body package="MySQLEXDI">_UNDERFLOW	&lt;C: #define _UNDERFLOW 4	&gt;</body><body package="MySQLEXDI">_VA_LIST_DEFINED	&lt;C: #define _VA_LIST_DEFINED 	&gt;</body><body package="MySQLEXDI">_WCHAR_T_DEFINED	&lt;C: #define _WCHAR_T_DEFINED 	&gt;</body><body package="MySQLEXDI">_WCTYPE_T_DEFINED	&lt;C: #define _WCTYPE_T_DEFINED 	&gt;</body><body package="MySQLEXDI">_WIN32	&lt;C: #define _WIN32 	&gt;</body><body package="MySQLEXDI">_WSTDIO_DEFINED	&lt;C: #define _WSTDIO_DEFINED 	&gt;</body><body package="MySQLEXDI">_WTIME_DEFINED	&lt;C: #define _WTIME_DEFINED 	&gt;</body><body package="MySQLEXDI">__DATE__	&lt;C: #define __DATE__ "June 26, 2006"	&gt;</body><body package="MySQLEXDI">__EXTENSIONS__	&lt;C: #define __EXTENSIONS__ 1	&gt;</body><body package="MySQLEXDI">__FILE__	&lt;C: #define __FILE__ 	&gt;</body><body package="MySQLEXDI">__LINE__	&lt;C: #define __LINE__ 0	&gt;</body><body package="MySQLEXDI">__STDC_EXT__	&lt;C: #define __STDC_EXT__ 1	&gt;</body><body package="MySQLEXDI">__STDC__	&lt;C: #define __STDC__ 1	&gt;</body><body package="MySQLEXDI">__TIME__	&lt;C: #define __TIME__ "9:20:02 pm"	&gt;</body><body package="MySQLEXDI">__WIN__	&lt;C: #define __WIN__ 	&gt;</body><body package="MySQLEXDI">__cdecl	&lt;C: #define __cdecl 	&gt;</body><body package="MySQLEXDI">_cabsl	&lt;C: #define _cabsl _cabs	&gt;</body><body package="MySQLEXDI">_dbug_h	&lt;C: #define _dbug_h 	&gt;</body><body package="MySQLEXDI">_global_h	&lt;C: #define _global_h 	&gt;</body><body package="MySQLEXDI">_list_h_	&lt;C: #define _list_h_ 	&gt;</body><body package="MySQLEXDI">_matherrl	&lt;C: #define _matherrl _matherr	&gt;</body><body package="MySQLEXDI">_my_alloc_h	&lt;C: #define _my_alloc_h 	&gt;</body><body package="MySQLEXDI">_mysql_com_h	&lt;C: #define _mysql_com_h 	&gt;</body><body package="MySQLEXDI">_mysql_h	&lt;C: #define _mysql_h 	&gt;</body><body package="MySQLEXDI">_mysql_time_h_	&lt;C: #define _mysql_time_h_ 	&gt;</body><body package="MySQLEXDI">_mysql_version_h	&lt;C: #define _mysql_version_h 	&gt;</body><body package="MySQLEXDI">_typelib_h	&lt;C: #define _typelib_h 	&gt;</body><body package="MySQLEXDI">_wP_tmpdir	&lt;C: #define _wP_tmpdir L "\\"	&gt;</body><body package="MySQLEXDI">dbug_volatile	&lt;C: #define dbug_volatile volatile	&gt;</body><body package="MySQLEXDI">max_allowed_packet	&lt;C: #define max_allowed_packet (*mysql_get_parameters()-&gt;p_max_allowed_packet)	&gt;</body><body package="MySQLEXDI">mysql_library_end	&lt;C: #define mysql_library_end mysql_server_end	&gt;</body><body package="MySQLEXDI">mysql_library_init	&lt;C: #define mysql_library_init mysql_server_init	&gt;</body><body package="MySQLEXDI">net_buffer_length	&lt;C: #define net_buffer_length (*mysql_get_parameters()-&gt;p_net_buffer_length)	&gt;</body><body package="MySQLEXDI">packet_error	&lt;C: #define packet_error (~(ULONG)0)	&gt;</body><body package="MySQLEXDI">qsort_t	&lt;C: #define qsort_t RETQSORTTYPE	&gt;</body><body package="MySQLEXDI">reg1	&lt;C: #define reg1 register	&gt;</body><body package="MySQLEXDI">reg10	&lt;C: #define reg10 register	&gt;</body><body package="MySQLEXDI">reg11	&lt;C: #define reg11 register	&gt;</body><body package="MySQLEXDI">reg12	&lt;C: #define reg12 register	&gt;</body><body package="MySQLEXDI">reg13	&lt;C: #define reg13 register	&gt;</body><body package="MySQLEXDI">reg14	&lt;C: #define reg14 register	&gt;</body><body package="MySQLEXDI">reg15	&lt;C: #define reg15 register	&gt;</body><body package="MySQLEXDI">reg16	&lt;C: #define reg16 register	&gt;</body><body package="MySQLEXDI">reg2	&lt;C: #define reg2 register	&gt;</body><body package="MySQLEXDI">reg3	&lt;C: #define reg3 register	&gt;</body><body package="MySQLEXDI">reg4	&lt;C: #define reg4 register	&gt;</body><body package="MySQLEXDI">reg5	&lt;C: #define reg5 register	&gt;</body><body package="MySQLEXDI">reg6	&lt;C: #define reg6 register	&gt;</body><body package="MySQLEXDI">reg7	&lt;C: #define reg7 register	&gt;</body><body package="MySQLEXDI">reg8	&lt;C: #define reg8 register	&gt;</body><body package="MySQLEXDI">reg9	&lt;C: #define reg9 register	&gt;</body><body package="MySQLEXDI">sig_handler	&lt;C: #define sig_handler RETSIGTYPE	&gt;</body><body package="MySQLEXDI">socket_errno	&lt;C: #define socket_errno errno	&gt;</body><body package="MySQLEXDI">stderr	&lt;C: #define stderr (&amp;_iob[2])	&gt;</body><body package="MySQLEXDI">stdin	&lt;C: #define stdin (&amp;_iob[0])	&gt;</body><body package="MySQLEXDI">stdout	&lt;C: #define stdout (&amp;_iob[1])	&gt;</body></methods><methods><class-id>Database.MySQLInterface</class-id> <category>variables</category><body package="MySQLEXDI">_HUGE	&lt;C: double _HUGE&gt;</body><body package="MySQLEXDI">_HUGE: aValue	&lt;C: double _HUGE&gt;</body><body package="MySQLEXDI">_daylight	&lt;C: int _daylight&gt;</body><body package="MySQLEXDI">_daylight: aValue	&lt;C: int _daylight&gt;</body><body package="MySQLEXDI">_db_fp_	&lt;C: FILE * _db_fp_&gt;</body><body package="MySQLEXDI">_db_fp_: aValue	&lt;C: FILE * _db_fp_&gt;</body><body package="MySQLEXDI">_db_on_	&lt;C: int _db_on_&gt;</body><body package="MySQLEXDI">_db_on_: aValue	&lt;C: int _db_on_&gt;</body><body package="MySQLEXDI">_db_process_	&lt;C: char * _db_process_&gt;</body><body package="MySQLEXDI">_db_process_: aValue	&lt;C: char * _db_process_&gt;</body><body package="MySQLEXDI">_dstbias	&lt;C: LONG _dstbias&gt;</body><body package="MySQLEXDI">_dstbias: aValue	&lt;C: LONG _dstbias&gt;</body><body package="MySQLEXDI">_iob	&lt;C: FILE _iob[]&gt;</body><body package="MySQLEXDI">_iob: aValue	&lt;C: FILE _iob[]&gt;</body><body package="MySQLEXDI">_no_db_	&lt;C: int _no_db_&gt;</body><body package="MySQLEXDI">_no_db_: aValue	&lt;C: int _no_db_&gt;</body><body package="MySQLEXDI">_timezone	&lt;C: LONG _timezone&gt;</body><body package="MySQLEXDI">_timezone: aValue	&lt;C: LONG _timezone&gt;</body><body package="MySQLEXDI">_tzname	&lt;C: char * _tzname[2]&gt;</body><body package="MySQLEXDI">_tzname: aValue	&lt;C: char * _tzname[2]&gt;</body><body package="MySQLEXDI">errno	&lt;C: int errno&gt;</body><body package="MySQLEXDI">errno: aValue	&lt;C: int errno&gt;</body><body package="MySQLEXDI">mysql_port	&lt;C: unsigned int mysql_port&gt;</body><body package="MySQLEXDI">mysql_port: aValue	&lt;C: unsigned int mysql_port&gt;</body><body package="MySQLEXDI">mysql_unix_port	&lt;C: char * mysql_unix_port&gt;</body><body package="MySQLEXDI">mysql_unix_port: aValue	&lt;C: char * mysql_unix_port&gt;</body><body package="MySQLEXDI">sql_protocol_typelib	&lt;C: TYPELIB sql_protocol_typelib&gt;</body><body package="MySQLEXDI">sql_protocol_typelib: aValue	&lt;C: TYPELIB sql_protocol_typelib&gt;</body></methods><methods><class-id>Database.MySQLInterface</class-id> <category>types</category><body package="MySQLEXDI">EMBEDDED_QUERY_RESULT	&lt;C: typedef struct embedded_query_result EMBEDDED_QUERY_RESULT&gt;</body><body package="MySQLEXDI">FILE	&lt;C: typedef void * FILE&gt;</body><body package="MySQLEXDI">LIST	&lt;C: typedef struct st_list LIST&gt;</body><body package="MySQLEXDI">LONG	&lt;C: typedef long LONG&gt;</body><body package="MySQLEXDI">MEM_ROOT	&lt;C: typedef struct st_mem_root MEM_ROOT&gt;</body><body package="MySQLEXDI">MYSQL	&lt;C: typedef struct st_mysql MYSQL&gt;</body><body package="MySQLEXDI">MYSQL_BIND50	&lt;C: typedef struct st_mysql_bind50 MYSQL_BIND50&gt;</body><body package="MySQLEXDI">MYSQL_BIND51	&lt;C: typedef struct st_mysql_bind51 MYSQL_BIND51&gt;</body><body package="MySQLEXDI">MYSQL_DATA	&lt;C: typedef struct st_mysql_data MYSQL_DATA&gt;</body><body package="MySQLEXDI">MYSQL_FIELD	&lt;C: typedef struct st_mysql_field MYSQL_FIELD&gt;</body><body package="MySQLEXDI">MYSQL_FIELD50	&lt;C: typedef struct st_mysql_field50 MYSQL_FIELD50&gt;</body><body package="MySQLEXDI">MYSQL_FIELD51	&lt;C: typedef struct st_mysql_field51 MYSQL_FIELD51&gt;</body><body package="MySQLEXDI">MYSQL_FIELD_OFFSET	&lt;C: typedef unsigned int MYSQL_FIELD_OFFSET&gt;</body><body package="MySQLEXDI">MYSQL_MANAGER	&lt;C: typedef struct st_mysql_manager MYSQL_MANAGER&gt;</body><body package="MySQLEXDI">MYSQL_METHODS	&lt;C: typedef struct st_mysql_methods MYSQL_METHODS&gt;</body><body package="MySQLEXDI">MYSQL_PARAMETERS	&lt;C: typedef struct st_mysql_parameters MYSQL_PARAMETERS&gt;</body><body package="MySQLEXDI">MYSQL_RES	&lt;C: typedef struct st_mysql_res MYSQL_RES&gt;</body><body package="MySQLEXDI">MYSQL_ROW	&lt;C: typedef char * * MYSQL_ROW&gt;</body><body package="MySQLEXDI">MYSQL_ROWS	&lt;C: typedef struct st_mysql_rows MYSQL_ROWS&gt;</body><body package="MySQLEXDI">MYSQL_ROW_OFFSET	&lt;C: typedef MYSQL_ROWS * MYSQL_ROW_OFFSET&gt;</body><body package="MySQLEXDI">MYSQL_STMT	&lt;C: typedef struct st_mysql_stmt MYSQL_STMT&gt;</body><body package="MySQLEXDI">MYSQL_TIME	&lt;C: typedef struct st_mysql_time MYSQL_TIME&gt;</body><body package="MySQLEXDI">MY_CHARSET_INFO	&lt;C: typedef struct character_set MY_CHARSET_INFO&gt;</body><body package="MySQLEXDI">NET	&lt;C: typedef struct st_net NET&gt;</body><body package="MySQLEXDI">SOCKET_SIZE_TYPE	&lt;C: typedef void * SOCKET_SIZE_TYPE&gt;</body><body package="MySQLEXDI">TYPELIB	&lt;C: typedef struct st_typelib TYPELIB&gt;</body><body package="MySQLEXDI">UDF_ARGS	&lt;C: typedef struct st_udf_args UDF_ARGS&gt;</body><body package="MySQLEXDI">UDF_INIT	&lt;C: typedef struct st_udf_init UDF_INIT&gt;</body><body package="MySQLEXDI">ULONG	&lt;C: typedef unsigned long ULONG&gt;</body><body package="MySQLEXDI">USED_MEM	&lt;C: typedef struct st_used_mem USED_MEM&gt;</body><body package="MySQLEXDI">Vio	&lt;C: typedef struct st_vio Vio&gt;</body><body package="MySQLEXDI">bool	&lt;C: typedef char bool&gt;</body><body package="MySQLEXDI">byte	&lt;C: typedef char byte&gt;</body><body package="MySQLEXDI">clock_t	&lt;C: typedef LONG clock_t&gt;</body><body package="MySQLEXDI">fpos_t	&lt;C: typedef struct __fpos_t fpos_t&gt;</body><body package="MySQLEXDI">gptr	&lt;C: typedef char * gptr&gt;</body><body package="MySQLEXDI">int15	&lt;C: typedef short int15&gt;</body><body package="MySQLEXDI">int16	&lt;C: typedef short int16&gt;</body><body package="MySQLEXDI">int7	&lt;C: typedef uint8 int7&gt;</body><body package="MySQLEXDI">int8	&lt;C: typedef char int8&gt;</body><body package="MySQLEXDI">list_walk_action	&lt;C: typedef int (* list_walk_action)(void * , void * )&gt;</body><body package="MySQLEXDI">longlong	&lt;C: typedef long long longlong&gt;</body><body package="MySQLEXDI">my_bool	&lt;C: typedef char my_bool&gt;</body><body package="MySQLEXDI">my_off_t	&lt;C: typedef ULONG my_off_t&gt;</body><body package="MySQLEXDI">my_ptrdiff_t	&lt;C: typedef long long my_ptrdiff_t&gt;</body><body package="MySQLEXDI">my_socket	&lt;C: typedef int my_socket&gt;</body><body package="MySQLEXDI">my_string	&lt;C: typedef char * my_string&gt;</body><body package="MySQLEXDI">my_ulonglong	&lt;C: typedef unsigned long long my_ulonglong&gt;</body><body package="MySQLEXDI">myf	&lt;C: typedef int myf&gt;</body><body package="MySQLEXDI">off_t	&lt;C: typedef void * off_t&gt;</body><body package="MySQLEXDI">os_off_t	&lt;C: typedef off_t os_off_t&gt;</body><body package="MySQLEXDI">pbool	&lt;C: typedef int pbool&gt;</body><body package="MySQLEXDI">pchar	&lt;C: typedef int pchar&gt;</body><body package="MySQLEXDI">pfloat	&lt;C: typedef double pfloat&gt;</body><body package="MySQLEXDI">pshort	&lt;C: typedef int pshort&gt;</body><body package="MySQLEXDI">puchar	&lt;C: typedef uint puchar&gt;</body><body package="MySQLEXDI">qsort_cmp	&lt;C: typedef int (* qsort_cmp)(const void * , const void * )&gt;</body><body package="MySQLEXDI">qsort_cmp2	&lt;C: typedef int (* qsort_cmp2)(void * , const void * , const void * )&gt;</body><body package="MySQLEXDI">sig_return	&lt;C: typedef void (* sig_return)(...)&gt;</body><body package="MySQLEXDI">size_s	&lt;C: typedef ULONG size_s&gt;</body><body package="MySQLEXDI">size_socket	&lt;C: typedef SOCKET_SIZE_TYPE size_socket&gt;</body><body package="MySQLEXDI">size_t	&lt;C: typedef unsigned int size_t&gt;</body><body package="MySQLEXDI">time_t	&lt;C: typedef LONG time_t&gt;</body><body package="MySQLEXDI">uchar	&lt;C: typedef unsigned char uchar&gt;</body><body package="MySQLEXDI">uint	&lt;C: typedef unsigned int uint&gt;</body><body package="MySQLEXDI">uint16	&lt;C: typedef unsigned short uint16&gt;</body><body package="MySQLEXDI">uint8	&lt;C: typedef unsigned char uint8&gt;</body><body package="MySQLEXDI">ulong	&lt;C: typedef unsigned long ulong&gt;</body><body package="MySQLEXDI">ulonglong	&lt;C: typedef unsigned long long ulonglong&gt;</body><body package="MySQLEXDI">ushort	&lt;C: typedef unsigned short ushort&gt;</body><body package="MySQLEXDI">va_list	&lt;C: typedef char * va_list&gt;</body><body package="MySQLEXDI">wchar_t	&lt;C: typedef unsigned short wchar_t&gt;</body><body package="MySQLEXDI">wctype_t	&lt;C: typedef wchar_t wctype_t&gt;</body><body package="MySQLEXDI">wint_t	&lt;C: typedef wchar_t wint_t&gt;</body></methods><methods><class-id>Database.MySQLInterface</class-id> <category>enums</category><body package="MySQLEXDI">Item_result	&lt;C: enum Item_result {			STRING_RESULT, 			REAL_RESULT, 			INT_RESULT, 			ROW_RESULT, 			DECIMAL_RESULT		}&gt;</body><body package="MySQLEXDI">enum_cursor_type	&lt;C: enum enum_cursor_type {			CURSOR_TYPE_NO_CURSOR, 			CURSOR_TYPE_READ_ONLY, 			CURSOR_TYPE_FOR_UPDATE, 			CURSOR_TYPE_SCROLLABLE = 4		}&gt;</body><body package="MySQLEXDI">enum_field_types	&lt;C: enum enum_field_types {			MYSQL_TYPE_DECIMAL, 			MYSQL_TYPE_TINY, 			MYSQL_TYPE_SHORT, 			MYSQL_TYPE_LONG, 			MYSQL_TYPE_FLOAT, 			MYSQL_TYPE_DOUBLE, 			MYSQL_TYPE_NULL, 			MYSQL_TYPE_TIMESTAMP, 			MYSQL_TYPE_LONGLONG, 			MYSQL_TYPE_INT24, 			MYSQL_TYPE_DATE, 			MYSQL_TYPE_TIME, 			MYSQL_TYPE_DATETIME, 			MYSQL_TYPE_YEAR, 			MYSQL_TYPE_NEWDATE, 			MYSQL_TYPE_VARCHAR, 			MYSQL_TYPE_BIT, 			MYSQL_TYPE_NEWDECIMAL = 246, 			MYSQL_TYPE_ENUM, 			MYSQL_TYPE_SET, 			MYSQL_TYPE_TINY_BLOB, 			MYSQL_TYPE_MEDIUM_BLOB, 			MYSQL_TYPE_LONG_BLOB, 			MYSQL_TYPE_BLOB, 			MYSQL_TYPE_VAR_STRING, 			MYSQL_TYPE_STRING, 			MYSQL_TYPE_GEOMETRY		}&gt;</body><body package="MySQLEXDI">enum_mysql_set_option	&lt;C: enum enum_mysql_set_option {			MYSQL_OPTION_MULTI_STATEMENTS_ON, 			MYSQL_OPTION_MULTI_STATEMENTS_OFF		}&gt;</body><body package="MySQLEXDI">enum_mysql_stmt_state	&lt;C: enum enum_mysql_stmt_state {			MYSQL_STMT_INIT_DONE = 1, 			MYSQL_STMT_PREPARE_DONE, 			MYSQL_STMT_EXECUTE_DONE, 			MYSQL_STMT_FETCH_DONE		}&gt;</body><body package="MySQLEXDI">enum_mysql_timestamp_type	&lt;C: enum enum_mysql_timestamp_type {			MYSQL_TIMESTAMP_NONE = -2, 			MYSQL_TIMESTAMP_ERROR, 			MYSQL_TIMESTAMP_DATE, 			MYSQL_TIMESTAMP_DATETIME, 			MYSQL_TIMESTAMP_TIME		}&gt;</body><body package="MySQLEXDI">enum_server_command	&lt;C: enum enum_server_command {			COM_SLEEP, 			COM_QUIT, 			COM_INIT_DB, 			COM_QUERY, 			COM_FIELD_LIST, 			COM_CREATE_DB, 			COM_DROP_DB, 			COM_REFRESH, 			COM_SHUTDOWN, 			COM_STATISTICS, 			COM_PROCESS_INFO, 			COM_CONNECT, 			COM_PROCESS_KILL, 			COM_DEBUG, 			COM_PING, 			COM_TIME, 			COM_DELAYED_INSERT, 			COM_CHANGE_USER, 			COM_BINLOG_DUMP, 			COM_TABLE_DUMP, 			COM_CONNECT_OUT, 			COM_REGISTER_SLAVE, 			COM_STMT_PREPARE, 			COM_STMT_EXECUTE, 			COM_STMT_SEND_LONG_DATA, 			COM_STMT_CLOSE, 			COM_STMT_RESET, 			COM_SET_OPTION, 			COM_STMT_FETCH, 			COM_END		}&gt;</body><body package="MySQLEXDI">enum_stmt_attr_type	&lt;C: enum enum_stmt_attr_type {			STMT_ATTR_UPDATE_MAX_LENGTH, 			STMT_ATTR_CURSOR_TYPE, 			STMT_ATTR_PREFETCH_ROWS		}&gt;</body><body package="MySQLEXDI">mysql_enum_shutdown_level	&lt;C: enum mysql_enum_shutdown_level {			SHUTDOWN_DEFAULT, 			SHUTDOWN_WAIT_CONNECTIONS, 			SHUTDOWN_WAIT_TRANSACTIONS, 			SHUTDOWN_WAIT_UPDATES = 8, 			SHUTDOWN_WAIT_ALL_BUFFERS = 16, 			SHUTDOWN_WAIT_CRITICAL_BUFFERS, 			KILL_CONNECTION = 255		}&gt;</body><body package="MySQLEXDI">mysql_option	&lt;C: enum mysql_option {			MYSQL_OPT_CONNECT_TIMEOUT, 			MYSQL_OPT_COMPRESS, 			MYSQL_OPT_NAMED_PIPE, 			MYSQL_INIT_COMMAND, 			MYSQL_READ_DEFAULT_FILE, 			MYSQL_READ_DEFAULT_GROUP, 			MYSQL_SET_CHARSET_DIR, 			MYSQL_SET_CHARSET_NAME, 			MYSQL_OPT_LOCAL_INFILE, 			MYSQL_OPT_PROTOCOL, 			MYSQL_SHARED_MEMORY_BASE_NAME, 			MYSQL_OPT_READ_TIMEOUT, 			MYSQL_OPT_WRITE_TIMEOUT, 			MYSQL_OPT_USE_RESULT, 			MYSQL_OPT_USE_REMOTE_CONNECTION, 			MYSQL_OPT_USE_EMBEDDED_CONNECTION, 			MYSQL_OPT_GUESS_CONNECTION, 			MYSQL_SET_CLIENT_IP, 			MYSQL_SECURE_AUTH, 			MYSQL_REPORT_DATA_TRUNCATION, 			MYSQL_OPT_RECONNECT		}&gt;</body><body package="MySQLEXDI">mysql_protocol_type	&lt;C: enum mysql_protocol_type {			MYSQL_PROTOCOL_DEFAULT, 			MYSQL_PROTOCOL_TCP, 			MYSQL_PROTOCOL_SOCKET, 			MYSQL_PROTOCOL_PIPE, 			MYSQL_PROTOCOL_MEMORY		}&gt;</body><body package="MySQLEXDI">mysql_rpl_type	&lt;C: enum mysql_rpl_type {			MYSQL_RPL_MASTER, 			MYSQL_RPL_SLAVE, 			MYSQL_RPL_ADMIN		}&gt;</body><body package="MySQLEXDI">mysql_status	&lt;C: enum mysql_status {			MYSQL_STATUS_READY, 			MYSQL_STATUS_GET_RESULT, 			MYSQL_STATUS_USE_RESULT		}&gt;</body></methods><methods><class-id>Database.MySQLInterface</class-id> <category>structs</category><body package="MySQLEXDI">__fpos_t	&lt;C: struct __fpos_t {			unsigned int lopart;			int hipart;		}&gt;</body><body package="MySQLEXDI">_complex	&lt;C: struct _complex {			double x, y;		}&gt;</body><body package="MySQLEXDI">_exception	&lt;C: struct _exception {			int type;			char * name;			double arg1, arg2, retval;		}&gt;</body><body package="MySQLEXDI">_iobuf	&lt;C: struct _iobuf {			char * _ptr;			int _cnt;			char * _base;			int _flag, _file, _charbuf, _bufsiz;			char * _tmpfname;		}&gt;</body><body package="MySQLEXDI">character_set	&lt;C: struct character_set {			unsigned int number, state;			const char * csname;			const char * name;			const char * comment;			const char * dir;			unsigned int mbminlen, mbmaxlen;		}&gt;</body><body package="MySQLEXDI">charset_info_st	&lt;C: struct charset_info_st&gt;</body><body package="MySQLEXDI">embedded_query_result	&lt;C: struct embedded_query_result&gt;</body><body package="MySQLEXDI">rand_struct	&lt;C: struct rand_struct {			ULONG seed1, seed2, max_value;			double max_value_dbl;		}&gt;</body><body package="MySQLEXDI">sockaddr	&lt;C: struct sockaddr&gt;</body><body package="MySQLEXDI">st_dynamic_array	&lt;C: struct st_dynamic_array&gt;</body><body package="MySQLEXDI">st_list	&lt;C: struct st_list {			struct st_list * prev;			struct st_list * next;			void * data;		}&gt;</body><body package="MySQLEXDI">st_mem_root	&lt;C: struct st_mem_root {			USED_MEM * free;			USED_MEM * used;			USED_MEM * pre_alloc;			unsigned int min_malloc, block_size, block_num, first_block_usage;			void (* error_handler)(void);		}&gt;</body><body package="MySQLEXDI">st_mysql	&lt;C: struct st_mysql {			NET net;			gptr connector_fd;			char * host;			char * user;			char * passwd;			char * unix_socket;			char * server_version;			char * host_info;			char * info;			char * db;			struct charset_info_st * charset;			MYSQL_FIELD * fields;			MEM_ROOT field_alloc;			my_ulonglong affected_rows, insert_id, extra_info;			ULONG thread_id, packet_length;			unsigned int port;			ULONG client_flag, server_capabilities;			unsigned int protocol_version, field_count, server_status, server_language, warning_count;			struct st_mysql_options options;			enum mysql_status status;			my_bool free_me, reconnect;			char scramble[21];			my_bool rpl_pivot;			struct st_mysql * master;			struct st_mysql * next_slave;			struct st_mysql * last_used_slave;			struct st_mysql * last_used_con;			LIST * stmts;			const struct st_mysql_methods * methods;			void * thd;			my_bool * unbuffered_fetch_owner;		}&gt;</body><body package="MySQLEXDI">st_mysql_bind	&lt;C: struct st_mysql_bind&gt;</body><body package="MySQLEXDI">st_mysql_bind50	&lt;C: struct st_mysql_bind50 {			ULONG * length;			my_bool * is_null;			void * buffer;			my_bool * error;			enum enum_field_types buffer_type;			ULONG buffer_length;			unsigned char * row_ptr;			ULONG offset, length_value;			unsigned int param_number, pack_length;			my_bool error_value, is_unsigned, long_data_used, is_null_value;			void (* store_param_func)(NET * net, struct st_mysql_bind * param);			void (* fetch_result)(struct st_mysql_bind * _arg1, MYSQL_FIELD * _arg2, unsigned char * * row);			void (* skip_result)(struct st_mysql_bind * _arg1, MYSQL_FIELD * _arg2, unsigned char * * row);		}&gt;</body><body package="MySQLEXDI">st_mysql_bind51	&lt;C: struct st_mysql_bind51 {			ULONG	*length;			my_bool       *is_null;			void		*buffer;			my_bool       *error;			unsigned char *row_ptr;			void (*store_param_func)(NET *net, struct st_mysql_bind *param);			void (*fetch_result)(struct st_mysql_bind *, MYSQL_FIELD *,					unsigned char **row);			void (*skip_result)(struct st_mysql_bind *, MYSQL_FIELD *,					unsigned char **row);			ULONG buffer_length;			ULONG offset;			ULONG	length_value;			unsigned int	param_number;			unsigned int  pack_length;			enum enum_field_types buffer_type;			my_bool       error_value;			my_bool       is_unsigned;			my_bool	long_data_used;			my_bool	is_null_value;			void *extension;}&gt;</body><body package="MySQLEXDI">st_mysql_data	&lt;C: struct st_mysql_data {			my_ulonglong rows;			unsigned int fields;			MYSQL_ROWS * data;			MEM_ROOT alloc;			struct embedded_query_result * embedded_info;		}&gt;</body><body package="MySQLEXDI">st_mysql_field	&lt;C: struct st_mysql_field&gt;</body><body package="MySQLEXDI">st_mysql_field50	&lt;C: struct st_mysql_field50 {			char * name;			char * org_name;			char * table;			char * org_table;			char * db;			char * catalog;			char * def;			ULONG length, max_length;			unsigned int name_length, org_name_length, table_length, org_table_length, db_length, catalog_length, def_length, flags, decimals, charsetnr;			enum enum_field_types type;		}&gt;</body><body package="MySQLEXDI">st_mysql_field51	&lt;C: struct st_mysql_field51 {			char *name;			char *org_name;			char *table;			char *org_table;			char *db;			char *catalog;			char *def;			ULONG length;			ULONG max_length;			unsigned int name_length;			unsigned int org_name_length;			unsigned int table_length;			unsigned int org_table_length;			unsigned int db_length;			unsigned int catalog_length;			unsigned int def_length;			unsigned int flags;			unsigned int decimals;			unsigned int charsetnr;			enum enum_field_types type;			void *extension;}&gt;</body><body package="MySQLEXDI">st_mysql_manager	&lt;C: struct st_mysql_manager {			NET net;			char * host;			char * user;			char * passwd;			unsigned int port;			my_bool free_me, eof;			int cmd_status, last_errno;			char * net_buf;			char * net_buf_pos;			char * net_data_end;			int net_buf_size;			char last_error[256];		}&gt;</body><body package="MySQLEXDI">st_mysql_methods	&lt;C: struct st_mysql_methods {			my_bool (* read_query_result)(MYSQL * mysql);			my_bool (* advanced_command)(MYSQL * mysql, enum enum_server_command command, const char * header, ULONG header_length, const char * arg, ULONG arg_length, my_bool skip_check);			MYSQL_DATA *  (* read_rows)(MYSQL * mysql, MYSQL_FIELD * mysql_fields, unsigned int fields);			MYSQL_RES *  (* use_result)(MYSQL * mysql);			void (* fetch_lengths)(ULONG * to, MYSQL_ROW column, unsigned int field_count);			void (* flush_use_result)(MYSQL * mysql);			MYSQL_FIELD *  (* list_fields)(MYSQL * mysql);			my_bool (* read_prepare_result)(MYSQL * mysql, MYSQL_STMT * stmt);			int (* stmt_execute)(MYSQL_STMT * stmt);			int (* read_binary_rows)(MYSQL_STMT * stmt);			int (* unbuffered_fetch)(MYSQL * mysql, char * * row);			void (* free_embedded_thd)(MYSQL * mysql);			const char *  (* read_statistics)(MYSQL * mysql);			my_bool (* next_result)(MYSQL * mysql);			int (* read_change_user_result)(MYSQL * mysql, char * buff, const char * passwd);			int (* read_rows_from_cursor)(MYSQL_STMT * stmt);		}&gt;</body><body package="MySQLEXDI">st_mysql_options	&lt;C: struct st_mysql_options {			unsigned int connect_timeout, read_timeout, write_timeout, port, protocol;			ULONG client_flag;			char * host;			char * user;			char * password;			char * unix_socket;			char * db;			struct st_dynamic_array * init_commands;			char * my_cnf_file;			char * my_cnf_group;			char * charset_dir;			char * charset_name;			char * ssl_key;			char * ssl_cert;			char * ssl_ca;			char * ssl_capath;			char * ssl_cipher;			char * shared_memory_base_name;			ULONG max_allowed_packet;			my_bool use_ssl, compress, named_pipe, rpl_probe, rpl_parse, no_master_reads, separate_thread;			enum mysql_option methods_to_use;			char * client_ip;			my_bool secure_auth, report_data_truncation;			int (* local_infile_init)(void * * , const char * , void * );			int (* local_infile_read)(void * , char * , unsigned int);			void (* local_infile_end)(void * );			int (* local_infile_error)(void * , char * , unsigned int);			void * local_infile_userdata;		}&gt;</body><body package="MySQLEXDI">st_mysql_parameters	&lt;C: struct st_mysql_parameters {			ULONG * p_max_allowed_packet;			ULONG * p_net_buffer_length;		}&gt;</body><body package="MySQLEXDI">st_mysql_res	&lt;C: struct st_mysql_res {			my_ulonglong row_count;			MYSQL_FIELD * fields;			MYSQL_DATA * data;			MYSQL_ROWS * data_cursor;			ULONG * lengths;			MYSQL * handle;			MEM_ROOT field_alloc;			unsigned int field_count, current_field;			MYSQL_ROW row, current_row;			my_bool eof, unbuffered_fetch_cancelled;			const struct st_mysql_methods * methods;		}&gt;</body><body package="MySQLEXDI">st_mysql_rows	&lt;C: struct st_mysql_rows {			struct st_mysql_rows * next;			MYSQL_ROW data;			ULONG length;		}&gt;</body><body package="MySQLEXDI">st_mysql_stmt	&lt;C: struct st_mysql_stmt {			MEM_ROOT mem_root;			LIST list;			MYSQL * mysql;			MYSQL_BIND * params;			MYSQL_BIND * bind;			MYSQL_FIELD * fields;			MYSQL_DATA result;			MYSQL_ROWS * data_cursor;			my_ulonglong affected_rows, insert_id;			int (* read_row_func)(struct st_mysql_stmt * stmt, unsigned char * * row);			ULONG stmt_id, flags, prefetch_rows;			unsigned int server_status, last_errno, param_count, field_count;			enum enum_mysql_stmt_state state;			char last_error[512];			char sqlstate[6];			my_bool send_types_to_server, bind_param_done;			unsigned char bind_result_done;			my_bool unbuffered_fetch_cancelled, update_max_length;		}&gt;</body><body package="MySQLEXDI">st_mysql_time	&lt;C: struct st_mysql_time {			unsigned int year, month, day, hour, minute, second;			ULONG second_part;			my_bool neg;			enum enum_mysql_timestamp_type time_type;		}&gt;</body><body package="MySQLEXDI">st_net	&lt;C: struct st_net {			Vio * vio;			unsigned char * buff;			unsigned char * buff_end;			unsigned char * write_pos;			unsigned char * read_pos;			my_socket fd;			ULONG max_packet, max_packet_size;			unsigned int pkt_nr, compress_pkt_nr, write_timeout, read_timeout, retry_count;			int fcntl;			my_bool compress;			ULONG remain_in_buf, length, buf_length, where_b;			unsigned int * return_status;			unsigned char reading_or_writing;			char save_char;			my_bool no_send_ok, no_send_eof, no_send_error;			char last_error[512];			char sqlstate[6];			unsigned int last_errno;			unsigned char error;			gptr query_cache_query;			my_bool report_error, return_errno;		}&gt;</body><body package="MySQLEXDI">st_typelib	&lt;C: struct st_typelib {			unsigned int count;			const char * name;			const char * * type_names;			unsigned int * type_lengths;		}&gt;</body><body package="MySQLEXDI">st_udf_args	&lt;C: struct st_udf_args {			unsigned int arg_count;			enum Item_result * arg_type;			char * * args;			ULONG * lengths;			char * maybe_null;			char * * attributes;			ULONG * attribute_lengths;		}&gt;</body><body package="MySQLEXDI">st_udf_init	&lt;C: struct st_udf_init {			my_bool maybe_null;			unsigned int decimals;			ULONG max_length;			char * ptr;			my_bool const_item;		}&gt;</body><body package="MySQLEXDI">st_used_mem	&lt;C: struct st_used_mem {			struct st_used_mem * next;			unsigned int left, size;		}&gt;</body><body package="MySQLEXDI">st_vio	&lt;C: struct st_vio&gt;</body><body package="MySQLEXDI">tm	&lt;C: struct tm {			int tm_sec, tm_min, tm_hour, tm_mday, tm_mon, tm_year, tm_wday, tm_yday, tm_isdst;		}&gt;</body></methods><methods><class-id>Database.MySQLInterface</class-id> <category>accessing</category><body package="MySQLEXDI">decimalSize"65 digits, plus a sign and decimal makes 67."	^67</body><body package="MySQLEXDI">isBlobType: aMySQLType 	^self class blobTypes includes: aMySQLType</body><body package="MySQLEXDI">isCharacterType: aMySQLType 	"The type is based on character (byte) arrays."	^self class characterTypes includes: aMySQLType</body><body package="MySQLEXDI">isIntegerType: aMySQLType 	^self class integerTypes includes: aMySQLType</body><body package="MySQLEXDI">isLongType: aMySQLType 	^self class longTypes includes: aMySQLType</body><body package="MySQLEXDI">isStringType: aMySQLType 	^self class stringTypes includes: aMySQLType</body><body package="MySQLEXDI">isTimeType: aMySQLType 	^self class timeTypes includes: aMySQLType</body><body package="MySQLEXDI">isValidCPointer: aCPointerOrNil 	"Return true only if aCPointerOrNil is a valid pointer."	^(aCPointerOrNil notNil) and: [aCPointerOrNil isValid]</body><body package="MySQLEXDI">mallocSelector	^#gcMalloc:</body><body package="MySQLEXDI">signedFromUnsignedLong: anUnsignedLong 	"Convert an unsigned long long value to a signed value."	| pUnsignedLong pSignedLong |	pUnsignedLong := anUnsignedLong gcCopyToHeap.	pSignedLong := CIntegerType signedLong pointerType 				cast: pUnsignedLong.	^pSignedLong contents</body><body package="MySQLEXDI">signedFromUnsignedLongLong: anUnsignedLongLong 	"Convert an unsigned long long value to a signed value."	| pUnsignedLongLong pSignedLongLong |	pUnsignedLongLong := anUnsignedLongLong gcCopyToHeap.	pSignedLongLong := CIntegerType signedLongLong pointerType 				cast: pUnsignedLongLong.	^pSignedLongLong contents</body><body package="MySQLEXDI">typeNameFor: aTypenumber	self error: 'This should not be used.'.	^self class fieldTypesToTypenamesMap at: aTypenumber</body><body package="MySQLEXDI">typeNumberFor: aTypenameSymbol"	^self class fieldTypenamesToTypesMap at: aTypenameSymbol"	| fieldTypes |	fieldTypes := self enum_field_types.	^fieldTypes memberNamed: aTypenameSymbol</body></methods><methods><class-id>Database.MySQLInterface</class-id> <category>accessing-enums</category><body package="MySQLEXDI">timeType: aSymbol" Valid symbols are those contained in the enum:		MYSQL_TIMESTAMP_NONE = -2, 		MYSQL_TIMESTAMP_ERROR, 		MYSQL_TIMESTAMP_DATE, 		MYSQL_TIMESTAMP_DATETIME, 		MYSQL_TIMESTAMP_TIME		MYSQL_TIMESTAMP_DATE"	^enum_mysql_timestamp_type memberNamed: aSymbol</body></methods><methods><class-id>Database.MySQLInterface</class-id> <category>version-dependent defs</category><body package="MySQLEXDI">MYSQL_BIND	"This particular struct is used by VisualWorks, and its shape depends on which library is loaded."		^self clientLibraryMajorVersionString = '5.0'		ifTrue: [self MYSQL_BIND50]		ifFalse: [self MYSQL_BIND51]</body><body package="MySQLEXDI">mysql_fetch_fields: res	"This particular procedure is used by VisualWorks, and its result depends on which library is loaded."		^self clientLibraryMajorVersionString = '5.0'		ifTrue: [self mysql_fetch_fields50: res]		ifFalse: [self mysql_fetch_fields51: res]</body></methods><methods><class-id>Database.MySQLInterface</class-id> <category>accessing-version info</category><body package="MySQLEXDI">clientLibraryMajorVersionString	"Answer the major version of the mysql shared library (DLL) client.	If nil, determine the value and set the shared variable."		| verNo |	^self class libraryMajorVersionString		ifNil:			[verNo := self clientLibraryVersionNumber.			self class libraryMajorVersionString: (self majorVersionStringFromNumber: verNo)]</body><body package="MySQLEXDI">clientLibraryVersionNumber	"Answer the version of the mysql shared library (DLL) client.	This value is exported by the MySQL api. Eg., 50131 means 5.1.31." 	^self mysql_get_client_version</body><body package="MySQLEXDI">majorVersionStringFromNumber: versionNumber	"Answer the major version of the mysql shared library (DLL) client.	This value is exported by the MySQL api. Eg., 50131 means 5.1.31.	VisualWorks supports versions 5.0 and 5.1."		^versionNumber &lt; 50100		ifTrue: ['5.0']		ifFalse:			[versionNumber &lt; 50200				ifTrue: ['5.1']				ifFalse: ['6.0']]</body></methods><methods><class-id>Database.MySQLInterface class</class-id> <category>private - accessing</category><body package="MySQLEXDI">blobTypes	"Return a Set of databaseType numbers for BLOB types.	Note that for MYSQL, a BLOB or String column, if not binary, represents TEXT data.	Therefore, one needs to check the type and the binary flag to see if a buffer holds byte or char data."	^BlobTypes</body><body package="MySQLEXDI">characterTypes	"Return the set of all StringTypes and all BlobTypes.	If a column type is in CharacterTypes, it can be either binary or not."	^CharacterTypes</body><body package="MySQLEXDI">integerTypes	"Return a Set of databaseType numbers for Integer types."	^IntegerTypes</body><body package="MySQLEXDI">longTypes	^LongTypes</body><body package="MySQLEXDI">stringTypes	"Return a Set of databaseType numbers for VARCHAR and String types.	Note that for MYSQL, a BLOB or String column, if not binary, represents TEXT data.	Therefore, one needs to check the type and the binary flag to see if a buffer holds byte or char data."	^StringTypes</body><body package="MySQLEXDI">timeTypes	^TimeTypes</body></methods><methods><class-id>Database.MySQLInterface class</class-id> <category>accessing</category><body package="MySQLEXDI">fieldTypenamesToTypesMap	FieldTypenamesToTypesMap isNil ifTrue: [self initializeMaps].	^FieldTypenamesToTypesMap</body><body package="MySQLEXDI">fieldTypesToTypenamesMap	FieldTypesToTypenamesMap isNil ifTrue: [self initializeMaps].	^FieldTypesToTypenamesMap</body></methods><methods><class-id>Database.MySQLInterface class</class-id> <category>class initialization</category><body package="MySQLEXDI">initialize	"MySQLInterface initialize"	self initializeMaps.	"Reset the version info, to be discovered lazily after the library is loaded."	self libraryMajorVersionString: nil</body><body package="MySQLEXDI">initializeMaps	"MySQLInterface initializeMaps"	| xif |	xif := self new.	"Build dictionary of type-name -&gt; enum value. (The xif gave us an enum instead of #defines.)	Eg., #MYSQL_TYPE_TINY_BLOB -&gt; 249"	FieldTypenamesToTypesMap := IdentityDictionary new.	xif enum_field_types 		keysAndValuesDo: [:key :value | FieldTypenamesToTypesMap at: key put: value].	"Build dictionary of enum value -&gt; type-name. (The xif gave us an enum instead of #defines.)	Eg.,  249 -&gt; #MYSQL_TYPE_TINY_BLOB"	FieldTypesToTypenamesMap := IdentityDictionary new.	xif enum_field_types 		keysAndValuesDo: [:key :value | FieldTypesToTypenamesMap at: value put: key].	"TINYBLOB is 2^8-1, BLOB is 2^16-1, MEDIUMBLOB is 2^24-1, LONGBLOB is 2^32-1.	TEXT types have same mysqlType as BLOBs, but isBinary is false for TEXT."	LongTypes := (Set new)				add: (xif typeNumberFor: #MYSQL_TYPE_MEDIUM_BLOB);				add: (xif typeNumberFor: #MYSQL_TYPE_LONG_BLOB);				yourself.	"These are the Integer types 8-, 16-, 32- and 64-bits."	IntegerTypes := (Set new)			add: (xif typeNumberFor: #MYSQL_TYPE_TINY);			add: (xif typeNumberFor: #MYSQL_TYPE_SHORT);			add: (xif typeNumberFor: #MYSQL_TYPE_INT24);			add: (xif typeNumberFor: #MYSQL_TYPE_LONG);			add: (xif typeNumberFor: #MYSQL_TYPE_LONGLONG);			yourself.	"These are the time column types."	TimeTypes := (Set new)				add: (xif typeNumberFor: #MYSQL_TYPE_TIME);				add: (xif typeNumberFor: #MYSQL_TYPE_DATE);				add: (xif typeNumberFor: #MYSQL_TYPE_DATETIME);				add: (xif typeNumberFor: #MYSQL_TYPE_TIMESTAMP);				add: (xif typeNumberFor: #MYSQL_TYPE_YEAR);				yourself.	"These are the String types, but BLOB types can also have TEXT data."	StringTypes := (Set new)				add: (xif typeNumberFor: #MYSQL_TYPE_STRING);				add: (xif typeNumberFor: #MYSQL_TYPE_VAR_STRING);				yourself.	"These are the Blob types, but String types can also have binary data."	BlobTypes := (Set new)				add: (xif typeNumberFor: #MYSQL_TYPE_TINY_BLOB);				add: (xif typeNumberFor: #MYSQL_TYPE_BLOB);				add: (xif typeNumberFor: #MYSQL_TYPE_MEDIUM_BLOB);				add: (xif typeNumberFor: #MYSQL_TYPE_LONG_BLOB);				yourself.	CharacterTypes := (Set new)					addAll: StringTypes;					addAll: BlobTypes;					yourself.</body></methods><methods><class-id>Database.MySQLInterface class</class-id> <category>private</category><body package="MySQLEXDI">platformSymbol	"this must contain the platform symbol that will	match that returned by determinePlatformType."	"platform symbols known today include:	#nt				Windows/NT	#win95 		Windows95	#hp_unix		HP/UX	#sun5_unix	Solaris	#aix_unix		AIX	#alpha_unix	DEC/Unix	#os2			OS/2	#powermac	Power Mac	#mac			Mac 68K	#linux_i386_unix 	Linux	#linux_x86_64_unix Linux 64-bit	#unix_sysV_sun_solaris64 Solaris 64-bit"		^#unknown</body></methods><methods><class-id>Database.MySQLInterface class</class-id> <category>api-version accessing</category><body package="MySQLEXDI">libraryMajorVersionString	^LibraryMajorVersionString</body><body package="MySQLEXDI">libraryMajorVersionString: aString	^LibraryMajorVersionString := aString</body></methods><methods><class-id>Database.MySQLBitfield</class-id> <category>adding</category><body package="MySQLEXDI">add: newObject 	"If newObject is an integer in [1..64], then add it."	^(newObject class == SmallInteger 		and: [1 &lt;= newObject and: [newObject &lt;= 64]]) 			ifTrue: [super add: newObject]			ifFalse: [self error: 'Added element must be an integer in 1..64']</body></methods><methods><class-id>Database.MySQLBitfield</class-id> <category>private</category><body package="MySQLEXDI">asByteArray	"MySQL 64-bit Set data type is retrieved as an 8-byte ByteArray.	Note that the MySQL object is limited to the bits 0..63 (ints 1..64).	The convention used here is that lowest order bit of the lowest order	byte comes first (Corresponds to self add: 1)"	| byteArray byteNum bitNum byte mask zeroBasedItem |	byteArray := ByteArray new: 8 withAll: 0.	self do: 			[:item | 			zeroBasedItem := item - 1.			byteNum := zeroBasedItem // 8 + 1.			bitNum := zeroBasedItem \\ 8.			byte := byteArray at: byteNum.			mask := 2r00000001 bitShift: bitNum.			byteArray at: byteNum put: (byte bitOr: mask)].	^byteArray</body><body package="MySQLEXDI">asMySQLByteArray	"Reverse the array, since MySQL wants high order bits at the beginning of the array."	^self asByteArray reverse.</body><body package="MySQLEXDI">asSet	^(Set new)		addAll: self;		yourself</body></methods><methods><class-id>Database.MySQLBitfield</class-id> <category>private-mysql</category><body package="MySQLEXDI">mysqlConversion	^#MySQLBitfield</body></methods><methods><class-id>Database.MySQLBitfield class</class-id> <category>converting</category><body package="MySQLEXDI">leftPaddArray: aByteArray 	"Padd the input with 0s up to length 8."	^aByteArray size &lt; 8 		ifTrue: 			[(#[0 0 0 0 0 0 0 0] copyFrom: 1 to: 8 - aByteArray size), aByteArray]		ifFalse: [aByteArray]</body><body package="MySQLEXDI">paddArray: aByteArray 	"Padd the input with 0s up to length 8."	^aByteArray size &lt; 8 		ifTrue: 			[(#[0 0 0 0 0 0 0 0] copyFrom: 1 to: 8 - aByteArray size), aByteArray]		ifFalse: [aByteArray]</body></methods><methods><class-id>Database.MySQLBitfield class</class-id> <category>instance creation</category><body package="MySQLEXDI">newFrom8ByteArray: aByteArray 	"MySQL 64-bit Set data type is retrieved as an 8-byte ByteArray.	Note that the closest Smalltalk type is Set, but the MySQL object is	limited to the integers 1..64 (or perhaps 0..63).	The convention used here is that lowest order bit of the lowest order	byte comes first (Corresponds to Set new add: 1)"	| mySet byte mask |	mySet := MySQLBitfield new.	1 to: (aByteArray size min: 8)		do: 			[:byteNum | 			byte := aByteArray at: byteNum.			1 to: 8				do: 					[:bitNum | 					mask := 2r00000001 bitShift: bitNum - 1.					(byte bitAnd: mask) = 0 ifFalse: [mySet add: (byteNum - 1) * 8 + bitNum]]].	^mySet</body><body package="MySQLEXDI">newFromMySQLByteArray: aByteArray 	"The convention used by MySQL is to reverse byte ordering.	So, #[0 1 2 3 4 5 6 7 8] has low-order byte value = 8."	^MySQLBitfield newFrom8ByteArray: (aByteArray reverse).</body></methods><methods><class-id>Database.MySQLDatabaseException</class-id> <category>printing</category><body package="MySQLEXDI">defaultMessageText	^(#mysqlDatabaseException &lt;&lt; #mysql &gt;&gt; 'MySQL Database Exception.') asString</body></methods><methods><class-id>Database.MySQLConnection</class-id> <category>accessing</category><body package="MySQLEXDI">database	database ifNil: [self database: self class defaultDatabase].	^database</body><body package="MySQLEXDI">database: aDbName 	"Assign me a new default database. If I'm connected, select this db right away."	database := aDbName.	self isConnected ifTrue: [self useDatabaseExternal]</body><body package="MySQLEXDI">dbmsVersion	"Return the server's version string, eg., '5.5.21'. This will raise an exception if not connected to server."	^self hasValidConnectionHandle		ifTrue: [(self xif mysql_get_server_info: self hConn) copyCStringFromHeap]		ifFalse: [InvalidConnectionState raiseWith: 'Not connected to server']</body><body package="MySQLEXDI">dbmsVersionNo	"Version string, '5.5.21' returns versionNo, 50521.This will raise an exception if not connected to server."	^self hasValidConnectionHandle		ifTrue: [self xif mysql_get_server_version: self hConn]		ifFalse: [InvalidConnectionState raiseWith: 'Not connected to server']</body><body package="MySQLEXDI">encoding	"Answer the character set name. If it's nil, determine the default encoding from the api.	If that's nil, then set the encoding to #default so that we don't repeat this process."	| encodingSymbol |	self useEncodingApi		ifTrue: [encoding isNil				ifTrue: [encodingSymbol := self getEncoding ifNil: [#default].					super encoding: encodingSymbol]].	^super encoding</body><body package="MySQLEXDI">encoding: aSymbol	"Set my encoding and tell the api that this is the encoding being used.	nil means let the accessors determine the encoding when it's needed."	aSymbol		ifNotNil: [self useEncodingApi ifTrue: [self setEncoding: aSymbol]].	super encoding: aSymbol</body><body package="MySQLEXDI">port	"Return the port number. This value can be changed while connected, but will not go into effect until the next connection is made."	port ifNil: [self port: self class defaultPort].	^port</body><body package="MySQLEXDI">port: aNumber 	"Assign me a new port number. This port will be used the next time I try to connect."	port := aNumber</body><body package="MySQLEXDI">turnOffOEMEncoding	self useEncodingApi: true.	super encoding: nil.	self encoding</body><body package="MySQLEXDI">turnOnOEMEncoding	self useEncodingApi: false.	super turnOnOEMEncoding</body><body package="MySQLEXDI">useEncodingApi	^useEncodingApi		ifNil: [useEncodingApi := self class defaultUseEncodingApi]</body><body package="MySQLEXDI">useEncodingApi: aBoolean	"See class method defaultUseEncodingApi. True means use the MySQL interface functions for encoding."	useEncodingApi := aBoolean</body><body package="MySQLEXDI">xif	^self class xif</body></methods><methods><class-id>Database.MySQLConnection</class-id> <category>private-handles</category><body package="MySQLEXDI">aquireConnectionHandle	"Let the library allocate and initialize a pointer to a MYSQL struct for us. The library	will de-allocate the struct when we eventually call close with that pointer. There are	warnings against doing the allocation ourselves, because the library may not have	the same compilation (packing/alignment) settings as our OE does."	| xif hConn |	xif := self class xif.	hConn := xif mysql_init: 0.	(traceLevel &gt;= 3) ifTrue:		[self trace_mysql_init: 0 pConn: hConn].	(hConn isValid ) ifFalse:		[ | errs |		errs := self getEnvironmentErrors.		^self class unableToAllocateHandleSignal raiseWith: errs errorString: errs first dbmsErrorString].	self hConn: hConn.</body><body package="MySQLEXDI">closeAndFreeConnectionHandle	"Close the connection, and let the library free the allocated MYSQL data structure."	| xif |	self hasValidConnectionHandle 		ifTrue: 			[xif := self class xif.			xif mysql_close: self hConn.			traceLevel &gt;= 3 				ifTrue: 					[self 						traceFunc: 'mysql_close'						result: nil						params: self hConn]].	self hConn: nil</body><body package="MySQLEXDI">hConn	^self hConnHolder value</body><body package="MySQLEXDI">hConn: aCPointerOrNil 	self hConnHolder value: aCPointerOrNil</body><body package="MySQLEXDI">hConnHolder	^hConnHolder</body><body package="MySQLEXDI">hConnHolder: aValueHolder 	hConnHolder := aValueHolder</body><body package="MySQLEXDI">hasValidConnectionHandle	"Return true only if the allocated MYSQL data structure has a valid pointer."	| hConn |	^(hConn := self hConn) isNil ifTrue: [false] ifFalse: [hConn isValid]</body><body package="MySQLEXDI">unprotectedFinalizeLibrary	"Let the library deallocate its private memory, before we unload the library. This function can be called before we unload the library."	IsLibraryInitialized 		ifTrue: 			[self class xif mysqlLibraryEnd.			traceLevel &gt;= 2 				ifTrue: 					[self 						traceFunc: 'mysql_library_end'						result: nil						params: nil].			IsLibraryInitialized := false]</body><body package="MySQLEXDI">unprotectedInitializeLibrary	"Let the library to initialize itself. This call is necessary for threaded applications. It should only be called once, and the caller should be wrapped in a mutex."	| rc argc argv groups |	IsLibraryInitialized		ifFalse: 			[			[argc := -1.			argv := 0 gcCopyToHeap.			groups := 0 gcCopyToHeap.			rc := self class xif mysqlLibraryInitArgc: argc argv: argv groups: groups.			traceLevel &gt;= 2				ifTrue: 					[self						traceFunc: 'mysql_library_init'						result: rc						params: (Array with: argc with: argv with: groups)].			rc == self class xif SUCCESS ifTrue: [IsLibraryInitialized := true]]					on: Object errorSignal					do: [:ex | ex return]].	IsLibraryInitialized		ifFalse: 			[^self class externalDatabaseLibraryInaccessibleSignal raiseSignal ]</body></methods><methods><class-id>Database.MySQLConnection</class-id> <category>private-finalization</category><body package="MySQLEXDI">executor 	| ex |	ex := super executor.	ex hConnHolder: self hConnHolder.	^ex</body><body package="MySQLEXDI">finalizeExternal	(self hConn isNil or: [self hConn referentAddress isNil]) ifTrue:		[ ^self ].	( traceLevel &gt;= 1 ) ifTrue:		[ self class trace: nil ].	super finalizeExternal</body><body package="MySQLEXDI">key	"The hdbcHolder is unique to the connection and is constant	across pause/resume."	^self hConnHolder</body></methods><methods><class-id>Database.MySQLConnection</class-id> <category>private-execution</category><body package="MySQLEXDI">acquireExternal: aPassword 	"Acquire the external resources involved with a connection to the SQL-environment."	| name pw env db aPort |	name := self username.	[name isString] 		whileFalse: [name := self class requiredUsernameSignal raiseSignal].	pw := aPassword.	[pw isString] 		whileFalse: [pw := self class requiredPasswordSignal raiseSignal].	(env := self environment) isNil 		ifTrue: [env := self class defaultEnvironment].	[env isString] 		whileFalse: [env := self class requiredEnvironmentSignal raiseSignal].	env := self class mapLogical: env.	db := self database.	aPort := self port.	"Make sure the library has been initialized."	InitializeLibraryLock critical: [self unprotectedInitializeLibrary].	self hasValidConnectionHandle ifFalse: [self aquireConnectionHandle].	self readOptionsGroup: 'client'.	self 		connectExternalHost: env		user: name		passwd: pw		db: db		port: aPort.	self singleStatementTransactions</body><body package="MySQLEXDI">beginExternal	super beginExternal.	self multiStatementTransactions</body><body package="MySQLEXDI">connectExternalHost: host user: user passwd: passwd db: db port: aPort 	"We must connect with CLIENT_MULTI_RESULTS to enable calling any	stored procedure, since the proc will always return at least one result set,	and typically, more."	| flags |	flags := self class xif CLIENT_MULTI_RESULTS.	self 		connectExternalHost: host		user: user		passwd: passwd		db: db		port: aPort		socket: 0		flags: flags</body><body package="MySQLEXDI">connectExternalHost: host user: user passwd: passwd db: db port: aPort socket: unix_socket flags: clientFlags 	"mysql_real_connect()MYSQL *mysql_real_connect(MYSQL *mysql, const char *host, const char *user, const char *passwd, const char *db, unsigned int port, const char *unix_socket, unsigned long client_flag) "	| pConn sig |	pConn := self class xif 				mysql_real_connect: self hConn				host: host				user: user				passwd: passwd				db: db				port: aPort				unix_socket: unix_socket				clientflag: clientFlags.	traceLevel &gt;= 3 		ifTrue: 			[self 				traceFunc: 'mysql_real_connect'				result: pConn printString				params: ((OrderedCollection new)						add: self hConn printString;						add: host;						add: user;						add: passwd;						add: db;						add: aPort;						add: unix_socket;						add: clientFlags;						yourself)].	pConn isValid 		ifFalse: 			[| errs |			errs := self getConnectionErrors.			sig := (self class signalForErrorCode: errs first dbmsErrorCode) 						ifNil: [self class unableToConnectToSQLserverSignal].			^sig raiseWith: errs errorString: errs first dbmsErrorString]</body><body package="MySQLEXDI">dismissExternal	self closeAndFreeConnectionHandle"	| xif rc |	xif  := self class xif.	[ Begin unwind protection. 	rc := xif SQLDisconnect: self hdbc .	(traceLevel &gt;= 2) ifTrue:		[ (self traceStream)			print: rc;  			nextPutAll: ' = SQLDisconnect( hdbc = ';			nextPutAll: (self hdbc referentAddress printStringRadix: 16);			nextPutAll: ' )'.		self class trace: self emitTrace ].	(rc == xif SQL_SUCCESS) ifFalse:		[ | errs |		errs := self getConnectionErrors.		^self class unableToDisconnectSignal raiseRequestWith: errs ].	End unwind protection.]		ensure:			[ Whether or not there was a failure, there's no point in hanging			onto the handles.			HenvLock critical: [ self unprotectedFreeConnect ].			self supportedFunctions: IdentityDictionary new.			self generalInformationCache: IdentityDictionary new ]"</body><body package="MySQLEXDI">getErrorsExternal	"Return the most recent error code, or nil if none.	From MySQL Docs: Note that some functions like mysql_fetch_row() don't reset mysql_errno() if they succeed. 	A rule of thumb is that all functions that have to ask the server for information reset mysql_errno() if they succeed."	| xif errorMsg rc error |	xif := self class xif.	rc := xif mysql_errno: self hConn.	rc == xif SUCCESS ifFalse:		[ 	errorMsg := (xif mysql_error: self hConn) copyCStringFromHeap.			error := self class errorClass new.	     	error dbmsErrorCode: rc.	     	error dbmsErrorString: errorMsg.	     	error sqlState: (xif mysql_sqlstate: self hConn) copyCStringFromHeap.		( traceLevel &gt;= 2 ) ifTrue:			[self traceFunc: 'mysql_error' result: errorMsg params: self hConn ]].	^error</body><body package="MySQLEXDI">installExternal	super installExternal.	self hConn: nil.</body><body package="MySQLEXDI">lastAutoIncrementValue	"This method should only be called immediately after an INSERT to a table with an IDENTITY column.	The function returns 0 if there was an error in that INSERT, or if the table has no IDENTITY column."	^self class xif mysql_insert_id: self hConn</body><body package="MySQLEXDI">multiStatementTransactions	"Take the receiver's connection out of auto-commit mode for transaction behavior."	| rc |	rc := self class xif mysql_autocommit: self hConn with: 0.	rc == self class xif SUCCESS ifFalse:			[| errs |			errs := self getConnectionErrors.			self class transactionExceptionSignal raiseWith: errs				errorString: errs first dbmsErrorString]</body><body package="MySQLEXDI">readOptionsGroup: groupName	"Read the options group named [aString]. Apparently, the only group that libmysql uses is the default, [client] group.	The options enum assigns MYSQL_READ_DEFAULT_GROUP as 5."	| xif rc pGroupName |	xif := self class xif.	pGroupName := groupName gcCopyToHeap.	rc := xif mysql_options: self hConn with: (xif _MYSQL_READ_DEFAULT_GROUP) with: pGroupName.	rc == xif SUCCESS 		ifFalse: 			[| errs |			errs := self getConnectionErrors.			self class unableToReadOptionsSignal raiseRequestWith: errs				errorString: errs first dbmsErrorString]</body><body package="MySQLEXDI">singleStatementTransactions	"Put the receiver's connection into auto-commit mode for transaction behavior."	| rc |	rc := self class xif mysql_autocommit: self hConn with: 1.	rc == self class xif SUCCESS 		ifFalse: 			[| errs |			errs := self getConnectionErrors.			self class transactionExceptionSignal raiseWith: errs				errorString: errs first dbmsErrorString]</body><body package="MySQLEXDI">useDatabaseExternal	"Assign the receiver's connection to the given default database.	If the user doesn't have the required privileges, an error will be returned."	| rc |	rc := self class xif mysql_select_db: self hConn with: self database.	rc == self class xif SUCCESS 		ifFalse: 			[| errs |			errs := self getConnectionErrors.			self class unableToConnectToSQLenvironmentSignal raiseWith: errs				errorString: errs first dbmsErrorString]</body></methods><methods><class-id>Database.MySQLConnection</class-id> <category>private-tracing</category><body package="MySQLEXDI">traceFunc: functionName result: result params: params 	| strm |	strm := self traceStream.	strm		nextPutAll: result printString , '= ';		nextPutAll: functionName , '('.	(params isKindOf: Collection) 		ifTrue: [params do: [:param | strm nextPutAll: param printString, ', ']]		ifFalse: [strm nextPutAll: params printString].	strm nextPutAll: ') '.	self class trace: self emitTrace</body><body package="MySQLEXDI">trace_mysql_init: ptr pConn: pConn 	(self traceStream)		nextPutAll: ', pConn = ';		nextPutAll: (pConn referentAddress printStringRadix: 16);		nextPutAll: ' = mysql_init(' , ptr printString , ') '.	self class trace: self emitTrace</body></methods><methods><class-id>Database.MySQLConnection</class-id> <category>private-accessing</category><body package="MySQLEXDI">getConnectionErrors	"Return a non-empty collection of MySQL Errors associated with the connection handle.	Many senders assume non-empty collection, so use a default if no official error available."	| errors err |	errors := OrderedCollection new.	err := self getErrorsExternal ifNil: [self class defaultError].	errors add: err.	^errors</body><body package="MySQLEXDI">getEnvironmentErrors	"Answer an empty collection, since without a connection handle, we cannot fetch errors.	Callers expect an OrderedCollection."	^OrderedCollection new.</body></methods><methods><class-id>Database.MySQLConnection</class-id> <category>private-library calls</category><body package="MySQLEXDI">commitExternal	"Commits the current transaction. As of MySQL 5.0.3, the action of this function is subject to the value of the completion_type system variable. In particular, if the value of completion_type is 2, the server performs a release after terminating a transaction and closes the client connection. The client program should call mysql_close() to close the connection from the client side."	| rc |	super commitExternal ifFalse: [^self].	rc := self class xif mysql_commit: self hConn.	traceLevel &gt;= 3 		ifTrue: 			[self 				traceFunc: 'mysql_commit'				result: rc				params: self hConn].	rc == self class xif SUCCESS ifFalse:			[| errs |			errs := self getConnectionErrors.			^self class transactionExceptionSignal raiseWith: errs				errorString: errs first dbmsErrorString].	self singleStatementTransactions</body><body package="MySQLEXDI">rollbackExternal	"Note that the 'completion_type' server variable =2, then the server will disconnect us. (1 will begin a new transaction, 0 is default). See more in #commitExternal."	| rc |	super rollbackExternal ifFalse: [^self].	rc := self class xif mysql_rollback: self hConn.	traceLevel &gt;= 3 		ifTrue: 			[self 				traceFunc: 'mysql_rollback'				result: rc				params: self hConn].	rc == self class xif SUCCESS ifFalse:			[| errs |			errs := self getConnectionErrors.			^self class transactionExceptionSignal raiseWith: errs				errorString: errs first dbmsErrorString].	self singleStatementTransactions</body></methods><methods><class-id>Database.MySQLConnection</class-id> <category>private-encoding</category><body package="MySQLEXDI">getCharsetExternal	"Get the default character set used by this connection."	| xif charsetName rc |	xif := self class xif.	rc := xif mysql_character_set_name: self hConn.	charsetName := rc copyCStringFromHeap.	traceLevel &gt;= 2		ifTrue: [self				traceFunc: 'mysql_get_character_set_name'				result: charsetName				params: self hConn].	^charsetName</body><body package="MySQLEXDI">getEncoding	"If the encoding name string is not in our dictionary, raise a resumable exception."	| charsetName |	charsetName := self getCharsetExternal.	^self class charsetNameToEncoding at: charsetName		ifAbsent: [self class unableToGetConnectionEncodingSignal raiseSignal]</body><body package="MySQLEXDI">setCharsetExternal: aCharsetName	"Tell my connection to use this character set by name."	| xif rc |	xif := self class xif.	rc := xif mysql_set_character_set: self hConn with: aCharsetName.	traceLevel &gt;= 2		ifTrue: [self				traceFunc: 'mysql_set_character_set'				result: rc				params: (Array with: self hConn with: aCharsetName)].	rc == self class xif SUCCESS		ifFalse: [| errs |			errs := self getConnectionErrors.			^self class unableToSetConnectionEncodingSignal raiseWith: errs				errorString: errs first dbmsErrorString]</body><body package="MySQLEXDI">setEncoding: aSymbol	"If the encoding name string is not in our dictionary, raise a resumable exception."	| charsetName |	charsetName := self class charsetNameForEncoding: aSymbol.	charsetName		ifNil: [self class unableToSetConnectionEncodingSignal raiseSignal].	self setCharsetExternal: charsetName</body></methods><methods><class-id>Database.MySQLConnection</class-id> <category>initialize-release</category><body package="MySQLEXDI">initialize	"Establish initial value for instance variables." 	super initialize.	self hConnHolder: nil asValue. 	self useEncodingApi: true.	"self isolationLevel: #RR"</body><body package="MySQLEXDI">initializeFromLogin: aLogin	"In MySQL,  'database' really means 'schema'.  MySQL returns an error if the schema / database is an empty string.  Using a nil instead results in the default schema, which is probably the intent."		| aSchema |	super initializeFromLogin: aLogin.	aSchema := aLogin schema.	aSchema size = 0 ifTrue: [aSchema := nil].	self database: aSchema.</body></methods><methods><class-id>Database.MySQLConnection</class-id> <category>private-activation</category><body package="MySQLEXDI">quiesce	"Ignore errors freeing resources if the server has gone away."	[super quiesce] on: self class unableToFreeResourceSignal		do: 			[:ex |			ex parameter first dbmsErrorCode = self xif CR_SERVER_GONE_ERROR				ifTrue: [ex resume]				ifFalse: [ex pass]]</body></methods><methods><class-id>Database.MySQLConnection class</class-id> <category>private-registry</category><body package="MySQLEXDI">registry	^RegisteredMySQLConnections</body><body package="MySQLEXDI">registry: aCollection	RegisteredMySQLConnections := aCollection</body></methods><methods><class-id>Database.MySQLConnection class</class-id> <category>private-accessing</category><body package="MySQLEXDI">charsetNameForEncoding: aSymbol	"Return the MySQL character set name for the given encoding symbol.	The name is sent and retrieved instead of the symbolic name.	We don't do this very often, so a reverse key from value lookup is okay."	^self charsetNameToEncoding keyAtValue: aSymbol ifAbsent: [nil]</body><body package="MySQLEXDI">charsetNameToEncoding	"Return a dictionary which maps MySQL character set names to VW encoding symbols."	| map |	map := Dictionary new.	map		at: 'ascii' put: #ascii;		at: 'cp1250' put:	#ms_cp_1250;		at: 'cp1251' put:	#ms_cp_1251;		at: 'cp1256' put: #ms_cp_1256	;		at: 'cp1257' put:	#ms_cp_1257;		at: 'cp850' put:	#ms_cp_850;		at: 'cp852' put:	#ms_cp_852;		at: 'cp866' put: #ms_cp_866;		at: 'greek' put: #iso8859_7;		at: 'hebrew' put: #iso8859_8;		at: 'hp8' put: #hp_roman8;		at: 'koi8r' put: #koi8r;		at: 'koi8u' put: #koi8u;		at: 'latin1' put: #ms_cp_1252;		at: 'latin2' put: #iso8859_2;		at: 'latin5' put: #iso8859_9;		at: 'latin7' put: #iso8859_13;		at: 'macce' put: #maccenteuro;		at: 'macroman' put:	#macroman;		at: 'sjis' put: #ShiftJIS;				"Shift-JIS Japanese"		at: 'ucs2' put: #ucs_2;		at: 'ujis' put: #JapaneseEUC;		"EUC-JP Japanese"		at: 'utf8' put: #utf_8;		"The following do not currently have corresponding encodings in VW"		at: 'armscii8' put: #armscii_8;		"ARMSCII-8 Armenian"		at: 'big5' put:	#big5;					"Big5 Traditional Chinese"		at: 'binary' put: #binary;			"Binary pseudo charset"		at: 'cp932' put: #ms_cp_932;		"SJIS for Windows Japanese"		at: 'dec8' put: #dec8;				"DEC West European"		at: 'eucjpms' put: #eucjpms;		"UJIS for Windows Japanese"		at: 'euckr' put: #euckr;				"EUC-KR Korean"		at: 'gb2312' put: #gb2312;			"'GB2312 Simplified Chinese'"		at: 'gbk' put: #gbk;					"GBK Simplified Chinese"		at: 'geostd8' put: #geostd8;		"GEOSTD8 Georgian"		at: 'keybcs2' put: #keybcs2;		"DOS Kamenicky Czech-Slovak"		at: 'swe7' put: #swe_7;				"7bit Swedish"		at: 'tis620' put: #tis_620.			"TIS620 Thai"	^map</body><body package="MySQLEXDI">collationIdToCharsetName	"MySQLConnection collationIdToCharsetName"	| dict |	dict := Dictionary new.	^dict		add: 1 -&gt; 'big5';		add: 2 -&gt; 'latin2';		add: 3 -&gt; 'dec8';		add: 4 -&gt; 'cp850';		add: 5 -&gt; 'latin1';		add: 6 -&gt; 'hp8';		add: 7 -&gt; 'koi8r';		add: 8 -&gt; 'latin1';		add: 9 -&gt; 'latin2';		add: 10 -&gt; 'swe7';		add: 11 -&gt; 'ascii';		add: 12 -&gt; 'ujis';		add: 13 -&gt; 'sjis';		add: 14 -&gt; 'cp1251';		add: 15 -&gt; 'latin1';		add: 16 -&gt; 'hebrew';		add: 18 -&gt; 'tis620';		add: 19 -&gt; 'euckr';		add: 20 -&gt; 'latin7';		add: 21 -&gt; 'latin2';		add: 22 -&gt; 'koi8u';		add: 23 -&gt; 'cp1251';		add: 24 -&gt; 'gb2312';		add: 25 -&gt; 'greek';		add: 26 -&gt; 'cp1250';		add: 27 -&gt; 'latin2';		add: 28 -&gt; 'gbk';		add: 29 -&gt; 'cp1257';		add: 30 -&gt; 'latin5';		add: 31 -&gt; 'latin1';		add: 32 -&gt; 'armscii8';		add: 33 -&gt; 'utf8';		add: 34 -&gt; 'cp1250';		add: 35 -&gt; 'ucs2';		add: 36 -&gt; 'cp866';		add: 37 -&gt; 'keybcs2';		add: 38 -&gt; 'macce';		add: 39 -&gt; 'macroman';		add: 40 -&gt; 'cp852';		add: 41 -&gt; 'latin7';		add: 42 -&gt; 'latin7';		add: 43 -&gt; 'macce';		add: 44 -&gt; 'cp1250';		add: 47 -&gt; 'latin1';		add: 48 -&gt; 'latin1';		add: 49 -&gt; 'latin1';		add: 50 -&gt; 'cp1251';		add: 51 -&gt; 'cp1251';		add: 52 -&gt; 'cp1251';		add: 53 -&gt; 'macroman';		add: 57 -&gt; 'cp1256';		add: 58 -&gt; 'cp1257';		add: 59 -&gt; 'cp1257';		add: 63 -&gt; 'binary';		add: 64 -&gt; 'armscii8';		add: 65 -&gt; 'ascii';		add: 66 -&gt; 'cp1250';		add: 67 -&gt; 'cp1256';		add: 68 -&gt; 'cp866';		add: 69 -&gt; 'dec8';		add: 70 -&gt; 'greek';		add: 71 -&gt; 'hebrew';		add: 72 -&gt; 'hp8';		add: 73 -&gt; 'keybcs2';		add: 74 -&gt; 'koi8r';		add: 75 -&gt; 'koi8u';		add: 77 -&gt; 'latin2';		add: 78 -&gt; 'latin5';		add: 79 -&gt; 'latin7';		add: 80 -&gt; 'cp850';		add: 81 -&gt; 'cp852';		add: 82 -&gt; 'swe7';		add: 83 -&gt; 'utf8';		add: 84 -&gt; 'big5';		add: 85 -&gt; 'euckr';		add: 86 -&gt; 'gb2312';		add: 87 -&gt; 'gbk';		add: 88 -&gt; 'sjis';		add: 89 -&gt; 'tis620';		add: 90 -&gt; 'ucs2';		add: 91 -&gt; 'ujis';		add: 92 -&gt; 'geostd8';		add: 93 -&gt; 'geostd8';		add: 94 -&gt; 'latin1';		add: 95 -&gt; 'cp932';		add: 96 -&gt; 'cp932';		add: 97 -&gt; 'eucjpms';		add: 98 -&gt; 'eucjpms';		add: 128 -&gt; 'ucs2';		add: 129 -&gt; 'ucs2';		add: 130 -&gt; 'ucs2';		add: 131 -&gt; 'ucs2';		add: 132 -&gt; 'ucs2';		add: 133 -&gt; 'ucs2';		add: 134 -&gt; 'ucs2';		add: 135 -&gt; 'ucs2';		add: 136 -&gt; 'ucs2';		add: 137 -&gt; 'ucs2';		add: 138 -&gt; 'ucs2';		add: 139 -&gt; 'ucs2';		add: 140 -&gt; 'ucs2';		add: 141 -&gt; 'ucs2';		add: 142 -&gt; 'ucs2';		add: 143 -&gt; 'ucs2';		add: 144 -&gt; 'ucs2';		add: 145 -&gt; 'ucs2';		add: 146 -&gt; 'ucs2';		add: 192 -&gt; 'utf8';		add: 193 -&gt; 'utf8';		add: 194 -&gt; 'utf8';		add: 195 -&gt; 'utf8';		add: 196 -&gt; 'utf8';		add: 197 -&gt; 'utf8';		add: 198 -&gt; 'utf8';		add: 199 -&gt; 'utf8';		add: 200 -&gt; 'utf8';		add: 201 -&gt; 'utf8';		add: 202 -&gt; 'utf8';		add: 203 -&gt; 'utf8';		add: 204 -&gt; 'utf8';		add: 205 -&gt; 'utf8';		add: 206 -&gt; 'utf8';		add: 207 -&gt; 'utf8';		add: 208 -&gt; 'utf8';		add: 209 -&gt; 'utf8';		add: 210 -&gt; 'utf8';		yourself</body><body package="MySQLEXDI">collationIdToEncoding	"Return and encoder map which converts a collation Id (charsetnr of collumnDescription)	to a VW character set encoding symbol."	"MySQLConnection collationIdToEncoding"	| collationMap charsetMap collationIdToEncoding encoding |	collationMap := self collationIdToCharsetName.	charsetMap := self charsetNameToEncoding.	collationIdToEncoding := Dictionary new.	collationMap keysAndValuesDo: 			[:collationId :charsetName | 			encoding := charsetMap at: charsetName.			collationIdToEncoding at: collationId put: encoding].	^collationIdToEncoding</body><body package="MySQLEXDI">encodingForCollationId: aCollationId 	"Return the Smalltalk encoding symbol for the given MySQL collation id,	typically returned as charsetnr in a columnDescription."	| encoding |	encoding := EncoderMap at: aCollationId ifAbsent: [nil].	^encoding</body><body package="MySQLEXDI">transactionClass	^MySQLTransaction</body><body package="MySQLEXDI">xifMap	xifMap isNil ifTrue: [ self initializeExternalInterfaceMap ].	^xifMap</body></methods><methods><class-id>Database.MySQLConnection class</class-id> <category>accessing</category><body package="MySQLEXDI">columnDescriptionClass	"Answer the class to use for column description objects associated with receiver."	^MySQLColumnDescription</body><body package="MySQLEXDI">defaultDatabase	^'mysql'</body><body package="MySQLEXDI">defaultError	"Answer a default error instance for the receiver."	| err |	err := self errorClass new.	err dbmsErrorCode: 0.	err dbmsErrorString: 'Connection Error'.	err sqlState: String new.	^err</body><body package="MySQLEXDI">defaultNamedPipe	^self xif MYSQL_NAMEDPIPE</body><body package="MySQLEXDI">defaultPort	"Ignored unless using TCP/IP."	^3306</body><body package="MySQLEXDI">defaultUnixSocket	"If not NULL, it specifies the socket or named pipe to be used."	self error: 'Default unix socket not established.'.	^self xif MYSQL_NAMEDPIPE</body><body package="MySQLEXDI">defaultUseEncodingApi	"True means, by default, use the MySQL encoding api. That is, tell MySQL which charset to use, and/or ask MySQL which charset it is using, and accept the charset information supplied for each retrieved column. To ignore MySQL's encoding information, particularly if MySQL doesn't understand the encoding you've requested, you can change this default to false, or set it individually by connection."	^true</body><body package="MySQLEXDI">errorClass	"Answer the error class for the receiver."		^MySQLError</body><body package="MySQLEXDI">interfaceClass	"Answer the interface class for the current OS."	"MySQLConnection interfaceClass"	| interfaceClassName |	interfaceClassName := self xifMap at: self platformType ifAbsent: [nil].	^interfaceClassName notNil		ifTrue: [self environment at: interfaceClassName ifAbsent: [nil]]		ifFalse: [nil]</body><body package="MySQLEXDI">kind	"Answer a symbol representing the type of DMBS the receiver provides services for."	^#'MySQL'</body><body package="MySQLEXDI">sessionClass	"Answer the class to use for session objects associated with receiver."	^MySQLSession</body><body package="MySQLEXDI">signalForErrorCode: anErrorNumber 	"Answer the signal to use for this error number if found, else nil."	| sig |	sig := self signalMap at: anErrorNumber ifAbsent: [nil].	^sig ifNotNil: [self perform: sig]</body><body package="MySQLEXDI">signalMap	"Answer the signal map, which maps error codes to exceptions (signals)."	SignalMap isNil ifTrue: [self initializeSignalMap].	^SignalMap</body><body package="MySQLEXDI">xif	"Answer the ExternalInterface subclass instance to use." 	xif isNil ifTrue:		[ self initializeExternalInterface ].	^xif</body></methods><methods><class-id>Database.MySQLConnection class</class-id> <category>activation</category><body package="MySQLEXDI">pause	^self quiesce</body><body package="MySQLEXDI">resume	^self activate</body></methods><methods><class-id>Database.MySQLConnection class</class-id> <category>private-activation</category><body package="MySQLEXDI">install	( TraceLevel &gt;= 1 ) ifTrue:		[ self trace: nil ].	self xif: nil.	self sessionClass install.	self returnFromSnapshot</body></methods><methods><class-id>Database.MySQLConnection class</class-id> <category>signal constants</category><body package="MySQLEXDI">initializeSignalMap	"There are very many error and warning return codes. A few are pasted below, and offer custom error signals."	"MySQLConnection initializeSignalMap"	SignalMap := IdentityDictionary new.	SignalMap at: 1146 put: #invalidTableNameSignal.			"Error: 1146 SQLSTATE: 42S02 (ER_NO_SUCH_TABLE)"	SignalMap at: 1066 put: #invalidTableNameSignal.			"Error: 1066 SQLSTATE: 42000 (ER_NONUNIQ_TABLE)"	SignalMap at: 1022 put: #duplicateIndexesErrorSignal.	"Error: 1022 SQLSTATE: 23000 (ER_DUP_KEY)"	SignalMap at: 1401 put: #externalDatabaseTransactionErrorSignal.	"Error: 1401 SQLSTATE: XAE03 (ER_XAER_RMERR)"	SignalMap at: 1280 put: #indexConflictSignal.		"Error: 1280 SQLSTATE: 42000 (ER_WRONG_NAME_FOR_INDEX)"	SignalMap at: 1099 put: #objectLockedSignal.	"Error: 1099 SQLSTATE: HY000 (ER_TABLE_NOT_LOCKED_FOR_WRITE)"	SignalMap at: 1100 put: #objectLockedSignal.	"Error: 1100 SQLSTATE: HY000 (ER_TABLE_NOT_LOCKED)"	SignalMap at: 1044 put: #authenticationFailureSignal.	"Error: 1044 SQLSTATE: 42000 (ER_DBACCESS_DENIED_ERROR)"	SignalMap at: 1045 put: #authenticationFailureSignal. "Error: 1045 SQLSTATE: 28000 (ER_ACCESS_DENIED_ERROR)"	SignalMap at: 2003 put: #couldNotResolveServiceNameSignal.		"Error: 2003 (CR_CONN_HOST_ERROR)"	SignalMap at: 2005 put: #couldNotResolveServiceNameSignal.		"Error: 2005 (CR_UNKNOWN_HOST)"	SignalMap at: 1217 put: #rowIsReferencedErrorSignal.		"Error: 1217 SQLSTATE: 23000 (ER_ROW_IS_REFERENCED)"	SignalMap at: 1087 put: #successWithInformationSignal.		"Error: 1087 SQLSTATE: HY000 (ER_LOAD_INFO)"	SignalMap at: 1088 put: #successWithInformationSignal.		"Error: 1088 SQLSTATE: HY000 (ER_ALTER_INFO)"	SignalMap at: 1092 put: #successWithInformationSignal.		"Error: 1092 SQLSTATE: HY000 (ER_INSERT_INFO)"	SignalMap at: 1134 put: #successWithInformationSignal.		"Error: 1134 SQLSTATE: HY000 (ER_UPDATE_INFO)"	SignalMap at: 1201 put: #successWithInformationSignal.		"Error: 1201 SQLSTATE: HY000 (ER_MASTER_INFO)"</body><body package="MySQLEXDI">unableToGetConnectionEncodingSignal	^UnableToGetConnectionEncoding</body><body package="MySQLEXDI">unableToReadOptionsSignal	^UnableToReadOptions</body><body package="MySQLEXDI">unableToSetConnectionEncodingSignal	^UnableToSetConnectionEncoding</body></methods><methods><class-id>Database.MySQLConnection class</class-id> <category>tracing</category><body package="MySQLEXDI">trace: aStringOrNil	"Emit the standard trace header followed by aString (if not nil) into the trace log.	This method overrides the base method because we need to grab the context	one level deeper in the stack. The only difference is to add a second &gt;&gt;sender."	| header when sender depth |	TraceCollector == nil ifTrue: [ ^self ].	header := WriteStream on: (String new: 64).	when := Time dateAndTimeNow.	sender := thisContext sender sender.		"The immediate caller is traceFunc:, so skip beyond it."	depth := TraceLevel &gt; 4 ifTrue: [ TraceLevel - 4 ] ifFalse: [ 1 ].	"Emit a timestamp"	header		nextPutAll: '{';		"print: (when at: 1);"  nextPutAll: ((when at: 1) printFormat: #(1 2 3 $ 2 2));		nextPutAll: ' ';		print: (when at: 2);		nextPutAll: '} 	'.		"curly-brace, space and a tab"	"Emit a stack trace"	[ depth &gt; 0 ] whileTrue:		[ header			nextPutAll: sender mclass printString;			nextPutAll: '&gt;&gt;';			nextPutAll: sender selector asString.		sender := sender sender.		(depth := depth - 1) &gt; 0 ifTrue:			[ header cr; tab: 6 ] ].	TraceSequencer critical:		[ TraceCollector nextPutAll: header contents; cr.		( aStringOrNil size &gt; 0 ) ifTrue:			[ TraceCollector tab; nextPutAll: aStringOrNil; cr ].		TraceCollector flush ]</body></methods><methods><class-id>Database.MySQLConnection class</class-id> <category>examples</category><body package="MySQLEXDI">allExamples	"MySQLConnection allExamples"	^OrderedCollection new add: self example1; add: self example2; add: self example3; add: self example4; yourself</body><body package="MySQLEXDI">example1	"MySQLConnection example1"	^self exampleQuery: 'SHOW TABLES'</body><body package="MySQLEXDI">example2	"MySQLConnection example2"	^self exampleQuery: 'SHOW DATABASES'.</body><body package="MySQLEXDI">example3	"MySQLConnection example3"	| params |	params := Array with: 'SELECT'.	^self 		exampleQuery: 'SELECT description, example FROM help_topic WHERE name=?'		bind: params</body><body package="MySQLEXDI">example4	"MySQLConnection example4"	^self exampleQuery: 'show character set'.</body><body package="MySQLEXDI">exampleQuery: aQuery 	"Note that this method deliberately uses self, so subclasses will do things their own way."	"MySQLConnection exampleQuery: 'SHOW TABLES'."	| conn sess ans data |	conn := self new.	conn		username: 'root';		password: 'user';		environment: 'localhost'.		[conn connect.	sess := conn getSession.	sess prepare: aQuery.	sess execute.	ans := sess answer.	[ans = #noMoreAnswers] whileFalse: 			[ans = #noAnswerStream ifFalse: [data := ans upToEnd].			ans := sess answer]] 			ensure: [conn disconnect].	^data</body><body package="MySQLEXDI">exampleQuery: aQuery bind: aBoundInputParam 	"MySQLConnection exampleQuery: 'SHOW TABLES'."	| conn sess ans data |	conn := self new.	conn		username: 'root';		password: 'user';		environment: 'localhost'.		[conn connect.	sess := conn getSession.	sess prepare: aQuery.	sess bindInput: aBoundInputParam.	sess execute.	ans := sess answer.	[ans = #noMoreAnswers] whileFalse: 			[ans = #noAnswerStream ifFalse: [data := ans upToEnd].			ans := sess answer]] 			ensure: [conn disconnect].	^data</body><body package="MySQLEXDI">generateCharsetDictionary	"MySQLConnection generateCharsetDictionary"	| data dict |	data := MySQLConnection exampleQuery: 'show collation'.	dict := Dictionary new.	data do: [:each | dict at: (each at: 3) put: (each at: 2)].	^dict</body><body package="MySQLEXDI">generateCharsetNames	"MySQLConnection generateCharsetNames"	| data dict |	data := MySQLConnection exampleQuery: 'show character set'.	dict := Dictionary new.	data do: [:each | dict at: (each at: 2) put: (each at: 1)].	^dict</body></methods><methods><class-id>Database.MySQLConnection class</class-id> <category>class initialization</category><body package="MySQLEXDI">initialize	"MySQLConnection initialize"	self initializeExternalInterfaceMap.	InitializeLibraryLock := RecursionLock new.	IsLibraryInitialized := false.	EncoderMap := self collationIdToEncoding.	self xif: nil.	self initRegistry.	"SupportedIsolationLevels := IdentityDictionary new.	SupportedIsolationLevels at: #RR put: #SQL_TXN_REPEATABLE_READ.	SupportedIsolationLevels at: #RC put: #SQL_TXN_READ_COMMITTED.	SupportedIsolationLevels at: #RU put: #SQL_TXN_READ_UNCOMMITED.	SupportedIsolationLevels at: #serializable put: #SQL_TXN_SERIALIZABLE.	SupportedIsolationLevels at: #versioning put: #SQL_TXN_VERSIONING.	self sessionClass initialize."</body><body package="MySQLEXDI">initializeExternalInterface	"Reset xif call with the right interface class based on the current platform.	Set the xif libraryVersionString shared variable to nil, so that the xif is forced	to lazily initialize it later."	| xifClass |	xifClass := self interfaceClass.	self xif: (xifClass ifNotNil: [xifClass new] ifNil: [nil]).	xif ifNil: 			[^Dialog 				warn: 'The MySQL Client Driver is not correctly installed.' withCRs]	ifNotNil: [xifClass libraryMajorVersionString: nil]</body><body package="MySQLEXDI">initializeExternalInterfaceMap	"self initializeExternalInterfaceMap"	xifMap := IdentityDictionary new.	xifMap at: #nt put: #MySQLNTInterface.	xifMap at: #linux_i386_unix put: #MySQLLinuxInterface.	xifMap at: #sun5_unix put: #MySQLSolarisInterface.	xifMap at: #macOSX put: #MySQLI386MacOSXInterface.	xifMap at: #macOSX64 put: #MySQLMacOSX64Interface.	xifMap at: #nt64 put: #MySQLNT64Interface.	xifMap at: #linux_x86_64_unix put: #MySQLLinux64Interface.	xifMap at: #unix_sysV_sun_solaris64 put: #MySQLSolaris64Interface</body></methods><methods><class-id>Database.UnableToReadOptions</class-id> <category>printing</category><body package="MySQLEXDI">defaultMessageText	^(#errReadOptionsFile &lt;&lt; #mysql &gt;&gt; 'Unable to read the options file.') asString</body></methods><methods><class-id>Database.MySQLError</class-id> <category>accessing</category><body package="MySQLEXDI">sqlState	^sqlState</body><body package="MySQLEXDI">sqlState: anInteger	sqlState := anInteger</body></methods><methods><class-id>Database.UnableToSetConnectionEncoding</class-id> <category>printing</category><body package="MySQLEXDI">defaultMessageText	^(#errSetConnectionEncoding &lt;&lt; #mysql &gt;&gt; 'Unable to set the connection encoding.') asString</body></methods><methods><class-id>Database.UnableToGetConnectionEncoding</class-id> <category>printing</category><body package="MySQLEXDI">defaultMessageText	^(#errGetConnectionEncoding &lt;&lt; #mysql &gt;&gt; 'Unable to get the connection encoding.') asString</body></methods><methods><class-id>Database.MySQLBuffer</class-id> <category>accessing</category><body package="MySQLEXDI">at: anIndex	"Answer the object in the buffer at anIndex."	^(pIsNull contents = true)		ifTrue:	 [ nil ]		ifFalse: [ self perform: getSelector with: anIndex ]</body><body package="MySQLEXDI">at: anIndex put: anObject 	"Store anObject into the buffer at anIndex."	anObject isNil 		ifTrue: [pIsNull contents: true]		ifFalse: 			[pIsNull contents: false.			self perform: putSelector with: anIndex with: anObject].	^anObject</body><body package="MySQLEXDI">isBinary	^isBinary</body><body package="MySQLEXDI">isUnsigned	^isUnsigned</body><body package="MySQLEXDI">maxBufferSizeNeeded	^maxDbDatumLength</body><body package="MySQLEXDI">smalltalkType	^smalltalkType</body><body package="MySQLEXDI">wasDataTruncated	^maxDbDatumLength &gt; elementSize</body></methods><methods><class-id>Database.MySQLBuffer</class-id> <category>private-data conversion {get}</category><body package="MySQLEXDI">get64BitsAt: index 	"MySQL 64-bit Set data type is retrieved as an 8-byte ByteArray.	Return a MySQLSet, or ByteArray, based on the flag."	| byteArray |	byteArray := self getByteArrayAt: index.	^self class useSetsFor64Bits 		ifTrue: [MySQLBitfield newFromMySQLByteArray: byteArray]		ifFalse: [byteArray]</body><body package="MySQLEXDI">getByteArrayAt: index	"Answer a ByteArray populated from the buffer. MySQL tells us the	length required to retrieve all of this datum, so that we can resize	our buffer and try again, if we so wish. Keep track of the maximum	for this column so far." 	| numBytes byteArray dbDatumLength |	dbDatumLength := (pLength contents).	maxDbDatumLength := maxDbDatumLength max: dbDatumLength.	numBytes := elementSize min: dbDatumLength.	byteArray := ByteArray new: numBytes.	bufferPointer copyAt: (index -1) to: byteArray size: numBytes startingAt: 1.	^byteArray</body><body package="MySQLEXDI">getDateAt: index 	^self getTimestampAt: index</body><body package="MySQLEXDI">getDoubleAt: index	"Answer a Double populated from the buffer."	"Assume: bufferPointer points to at least 8 bytes in the heap."	| conversionBuffer |	conversionBuffer := UninterpretedBytes new: 8.	bufferPointer copyAt: (index -1) to: conversionBuffer size: 8 startingAt: 1.	^conversionBuffer doubleAt: 1</body><body package="MySQLEXDI">getFixedPointAt: index	"Answer a FixedPoint number populated from the buffer"	| numBytes str |	numBytes := pLength contents.	str := ByteString new: numBytes.	bufferPointer copyAt: (index -1) to: str size: numBytes startingAt: 1.	"Change E to e to help Fixedpoint conversion."	str := str copyReplaceAll: 'E' with: 'e'. 	^FixedPoint readFrom: str readStream</body><body package="MySQLEXDI">getFloatAt: index	"Answer a float populated from the buffer."	"Assume: bufferPointer points to at least 4 bytes in the heap."	| conversionBuffer |	conversionBuffer := UninterpretedBytes new: 4.	bufferPointer copyAt: (index -1) to: conversionBuffer size: 4 startingAt: 1.	^conversionBuffer floatAt: 1</body><body package="MySQLEXDI">getInt16At: index	"Answer a 16-bit, signed or unsigned, Integer populated from the buffer."	"Assume: bufferPointer points to at least 4 bytes in the heap."	| conversionBuffer |	conversionBuffer := UninterpretedBytes new: 2.	bufferPointer copyAt: (index -1) to: conversionBuffer size: 2 startingAt: 1.	^self isUnsigned 		ifTrue: [conversionBuffer unsignedShortAt: 1]		ifFalse: [conversionBuffer shortAt: 1]</body><body package="MySQLEXDI">getInt24At: index 	"Answer a 24-bit signed or unsigned Integer populated from the buffer.	Assume: bufferPointer points to at least 3 bytes in the heap.	If the column is signed, determine the sign bit (msb, 3rd byte)	and extend it through the 4th byte."	| conversionBuffer |	conversionBuffer := UninterpretedBytes new: 4.	conversionBuffer byteAt: 4 put: 16r00.	bufferPointer 		copyAt: index - 1		to: conversionBuffer		size: 3		startingAt: 1.	^self isUnsigned 		ifTrue: [conversionBuffer unsignedLongAt: 1]		ifFalse: 			[((conversionBuffer byteAt: 3) bitAnd: 16r80) = 0 				ifFalse: [conversionBuffer byteAt: 4 put: 16rFF].				conversionBuffer longAt: 1]</body><body package="MySQLEXDI">getInt32At: index 	"Answer a 32-bit signed or unsigned Integer populated from the buffer."	"Assume: bufferPointer points to at least 4 bytes in the heap."	| conversionBuffer |	conversionBuffer := UninterpretedBytes new: 4.	bufferPointer copyAt: index - 1 to: conversionBuffer size: 4 startingAt: 1.	^self isUnsigned 		ifTrue: [conversionBuffer unsignedLongAt: 1]		ifFalse: [conversionBuffer longAt: 1]</body><body package="MySQLEXDI">getInt64At: index	"Answer a 64-bit, signed or unsigned, Integer populated from the buffer."	"Assume: bufferPointer points to at least 4 bytes in the heap."	| conversionBuffer |	conversionBuffer := UninterpretedBytes new: 8.	bufferPointer copyAt: (index -1) to: conversionBuffer size: 8 startingAt: 1.	^self isUnsigned 		ifTrue: [conversionBuffer unsignedLongLongAt: 1]		ifFalse: [conversionBuffer longLongAt: 1]</body><body package="MySQLEXDI">getInt8At: index	"Answer an 8-bit char, signed or unsigned, populated from the buffer."	"Assume: bufferPointer points to at least 4 bytes in the heap."	| conversionBuffer |	conversionBuffer := UninterpretedBytes new: 1.	bufferPointer copyAt: (index -1) to: conversionBuffer size: 1 startingAt: 1.	^self isUnsigned 		ifTrue: [conversionBuffer byteAt: 1]		ifFalse: [conversionBuffer signedByteAt: 1]</body><body package="MySQLEXDI">getStringAt: index 	"If I am Binary, then return a byteArray. Otherwise, a String populated from the	buffer with my encoding."	| byteArray |	byteArray := self getByteArrayAt: index.	^self isBinary 		ifTrue: [byteArray]		ifFalse: [byteArray asStringEncoding: self encoding]</body><body package="MySQLEXDI">getTimeAt: index 	^self getTimestampAt: index</body><body package="MySQLEXDI">getTimeStructAt: index 	"Return the correspoinding Smalltalk time type from the retrieved structure.	The type, as determined from a flag in the struct, is Date, Time, or Timestamp, or nil.	Negative time values are currently not supported, and result in an error.	Note that mysql uses hour=24 when vw uses hour=0, which is a fixed up here."	| xif timeStructPtr year month day hour minute second neg time_type timestamp data |	xif := session xif.	timeStructPtr := xif MYSQL_TIME pointerType 				cast: bufferPointer.	year := timeStructPtr memberAt: #year.	month := timeStructPtr memberAt: #month.	day := timeStructPtr memberAt: #day.	hour := timeStructPtr memberAt: #hour.	minute := timeStructPtr memberAt: #minute.	second := timeStructPtr memberAt: #second.	"second_part := timeStructPtr memberAt: #second_part.	Not used in MySQL 5.03"	neg := timeStructPtr memberAt: #neg.	"Indicates that this time is negative."	time_type := timeStructPtr memberAt: #time_type.	timestamp := (Timestamp new)				year: year;				month: month;				day: day;				hour: (hour \\ 24);				minute: minute;				second: second.	data := nil.	(time_type = (xif timeType: #MYSQL_TIMESTAMP_ERROR))		ifTrue: [self error: 'Bad timestamp contents'].	neg = xif TRUE ifTrue: [self error: 'Negative time value'].	(time_type = (xif timeType: #MYSQL_TIMESTAMP_NONE)) 		ifTrue: [data := nil].	"= -2"	(time_type = (xif timeType: #MYSQL_TIMESTAMP_DATE)) 		ifTrue: [data := timestamp asDate].	(time_type = (xif timeType: #MYSQL_TIMESTAMP_DATETIME))		ifTrue: [data := timestamp].	(time_type = (xif timeType: #MYSQL_TIMESTAMP_TIME))		ifTrue: [data := timestamp asTime].	^data</body><body package="MySQLEXDI">getTimestampAt: index 	^self getTimeStructAt: index</body><body package="MySQLEXDI">getYearAt: index 	^self getInt16At: index</body></methods><methods><class-id>Database.MySQLBuffer</class-id> <category>testing</category><body package="MySQLEXDI">canHold: aValue	"For input buffers (send data to db). Can we re-use this buffer? Return true	if this buffer 	has the correct type and is big enough to hold aValue."	| elemSize |	^(self smalltalkType = (self smalltalkTypeForValue: aValue)		and: [self databaseType = (self databaseTypeForSmalltalkType: smalltalkType)])			ifTrue: [elemSize := self class sizesOfFixedSmalltalkTypes at: smalltalkType							ifAbsent: [self elementSizeFor: aValue asType: smalltalkType].				elemSize					ifNil: [self error: 'Bad type.']					ifNotNil: [elemSize &lt;= self elementSize]]			ifFalse: [false]</body><body package="MySQLEXDI">isLong	"Answer true if the receiver represents a long result column."	^false</body></methods><methods><class-id>Database.MySQLBuffer</class-id> <category>private-data conversion {put}</category><body package="MySQLEXDI">at: index put64Bits: aByteArray	"Copy the 8-byte array to the buffer. Append zeros for missing trailing bytes."	"Assume: bufferPointer points to at least 8 bytes in the heap."	| conversionBuffer |	pLength contents: 8.	conversionBuffer := aByteArray , #[0 0 0 0 0 0 0 0] copyFrom: 1 to: 8.	bufferPointer 		copyAt: index - 1		from: conversionBuffer		size: 8		startingAt: 1.	^aByteArray</body><body package="MySQLEXDI">at: index putBoolean: aBoolean 	"Set the buffer to hold an encoded bit."	"pIsNull contents == self class connectionClass xif TRUE"	self at: index putInt8: (aBoolean ifTrue: [1] ifFalse: [0]).	^aBoolean</body><body package="MySQLEXDI">at: index putByteArray: aByteArray 	"Copy the byte array to the buffer."	| len |	len := aByteArray size.	len &gt; elementSize ifTrue:		[ self class connectionClass unableToBindSignal raiseSignal ].	pLength contents: len.	bufferPointer copyAt: index - 1 from: aByteArray size: len startingAt: 1.	^aByteArray</body><body package="MySQLEXDI">at: index putDate: aDate 	"Convert to a timestamp, and apply to db."	self at: index putTimestamp: aDate asTimestamp.	^aDate</body><body package="MySQLEXDI">at: index putDouble: aDouble	"Answer a Double populated from the buffer."	"Assume: bufferPointer points to at least 8 bytes in the heap."	| conversionBuffer |	pLength contents: 8.	conversionBuffer := UninterpretedBytes new: 8.	conversionBuffer doubleAt: 1 put: aDouble.	bufferPointer copyAt: (index -1) from: conversionBuffer size: 8 startingAt: 1.	^aDouble</body><body package="MySQLEXDI">at: index putFixedPoint: aFixedPoint	"Put a string version of aFixedPoint, without the trailng $s into the buffer."	| strm byteArray |	strm := (String new: 40) writeStream.	aFixedPoint printOn: strm.	strm skip: -1.	byteArray := strm contents asByteArray.	self at: index putByteArray: byteArray.	^aFixedPoint</body><body package="MySQLEXDI">at: index putFloat: aFloat	"Answer a Double populated from the buffer."	"Assume: bufferPointer points to at least 8 bytes in the heap."	| conversionBuffer |	pLength contents: 4.	conversionBuffer := UninterpretedBytes new: 4.	conversionBuffer floatAt: 1 put: aFloat.	bufferPointer copyAt: (index -1) from: conversionBuffer size: 4 startingAt: 1.	^aFloat</body><body package="MySQLEXDI">at: index putInt16: anInteger	"Put anInteger into the buffer"	| conversionBuffer |	pLength contents: 2.	conversionBuffer := UninterpretedBytes new: 2.	conversionBuffer shortAt: 1 put: anInteger.	bufferPointer copyAt: (index -1) from: conversionBuffer size: 2 startingAt: 1.	^anInteger</body><body package="MySQLEXDI">at: index putInt32: anInteger	"Put anInteger into the buffer"	| conversionBuffer |	pLength contents: 4.	conversionBuffer := UninterpretedBytes new: 4.	conversionBuffer longAt: 1 put: anInteger.	bufferPointer copyAt: (index -1) from: conversionBuffer size: 4 startingAt: 1.	^anInteger</body><body package="MySQLEXDI">at:index putInt64: aLargeInteger	"Unused. Instead, LargeInteger now maps as a FixedPoint.	Assume: bufferPointer points to at least 8 bytes in the heap."	| conversionBuffer |	pLength contents: 8.	conversionBuffer := UninterpretedBytes new: 8.	conversionBuffer longLongAt: 1 put: aLargeInteger.	bufferPointer copyAt: (index -1) from: conversionBuffer size: 8 startingAt: 1.	^aLargeInteger</body><body package="MySQLEXDI">at: index putInt8: anInteger	"Put anInteger into the buffer"	| conversionBuffer |	pLength contents: 1.	conversionBuffer := UninterpretedBytes new: 1.	conversionBuffer byteAt: 1 put: anInteger.	bufferPointer copyAt: (index -1) from: conversionBuffer size: 1 startingAt: 1.	^anInteger</body><body package="MySQLEXDI">at: index putLargeInteger: aLargeInteger	"LargeInteger now maps as a FixedPoint (databasetype), which is transfered as a ByteArray."	| strm byteArray |	strm := (String new: 40) writeStream.	aLargeInteger printOn: strm.	byteArray := strm contents asByteArray.	self at: index putByteArray: byteArray.	^aLargeInteger</body><body package="MySQLEXDI">at: index putMySQLBitfield: aSet 	"Convert the set to an 8-byte ByteArray, and input this."	| ba |	ba := aSet asMySQLByteArray.	self at: index putByteArray: ba.	^aSet</body><body package="MySQLEXDI">at: index putString: aString 	"Put aString into the buffer, as a ByteArray. If isBinary is true, then the input var	is already a ByteArray."	| aByteArray |	aByteArray := self isBinary 				ifTrue: [aString asByteArray]				ifFalse: [aString asByteArrayEncoding: self encoding].	self at: index putByteArray: aByteArray.	^aString</body><body package="MySQLEXDI">at: index putTime: aTime 	"Convert to a timestamp, and apply to db."	self at: index putTimestamp: aTime asTimestamp.	^aTime</body><body package="MySQLEXDI">at: index putTimestamp: aTimestamp	"Return the correspoinding Smalltalk time type from the retrieved structure.	The type, as determined from a flag in the struct, is Date, Time, or Timestamp, or nil.	Negative time values are currently not supported, and result in an error."	| xif timeStructPtr time_type |	xif := session xif.	pLength contents: elementSize.	time_type := xif timeType: #MYSQL_TIMESTAMP_DATETIME.	timeStructPtr := xif MYSQL_TIME pointerType 				cast: bufferPointer.	timeStructPtr memberAt: #year put: aTimestamp year.	timeStructPtr memberAt: #month put: aTimestamp month.	timeStructPtr memberAt: #day put: aTimestamp day.	timeStructPtr memberAt: #hour put: aTimestamp hour.	timeStructPtr memberAt: #minute put: aTimestamp minute.	timeStructPtr memberAt: #second put: aTimestamp second.	timeStructPtr memberAt: #second_part put: 0.	"Not used in MySQL 5.03"	timeStructPtr memberAt: #neg put: 0.	"(0 (false) Indicates that this time is not negative."	timeStructPtr memberAt: #time_type put: time_type.	^aTimestamp</body></methods><methods><class-id>Database.MySQLBuffer</class-id> <category>binding</category><body package="MySQLEXDI">bindForInputValue: aValue	"Setup the receiver to hold the object being sent to the api."	"We won't re-use pointers."	self free.	"Allocate external CPointers."	self mallocUsingSelector: session class xif mallocSelector.		self value: aValue.	"Now give the session pointers to my data objects. Session will pass them on in a MYSQL_BIND array."	self bindInputExternal</body><body package="MySQLEXDI">bindForOutput	"Setup the receiver to hold the contents of a single column."	"We won't re-use pointers."	self free.	"Allocate external CPointers."	self mallocUsingSelector: session class xif mallocSelector.		"Now give the session pointers to my data objects. Session will pass them on in a MYSQL_BIND array."	self bindOutputExternal</body><body package="MySQLEXDI">rebindForInput	"Bind contents of the receiver to the server."	self bindInputExternal.</body></methods><methods><class-id>Database.MySQLBuffer</class-id> <category>allocation</category><body package="MySQLEXDI">free	"Free the main bufferPointer, owned by super, and our other pointers.	Note: use CPointer&gt;&gt;free, since it is more robust than &gt;&gt;freePointer,	which is disastrous if the pointer was gcMalloc'd."	bufferPointer notNil 		ifTrue: 			[bufferPointer free.			bufferPointer := nil].	pLength notNil 		ifTrue: 			[pLength free.			pLength := nil].	pIsNull notNil 		ifTrue: 			[pIsNull free.			pIsNull := nil].	pError notNil 		ifTrue: 			[pError free.			pError := nil].	super free</body><body package="MySQLEXDI">mallocUsingSelector: mallocSelector 	"Allocate pointers (bufferPointer allocated elsewhere) and assign default values."	super mallocUsingSelector: mallocSelector.	pLength := CIntegerType unsignedLong perform: mallocSelector with: 1.	pIsNull := CIntegerType booleanChar perform: mallocSelector with: 1.	pError := CIntegerType booleanChar perform: mallocSelector with: 1.	pLength contents: 0.	pIsNull contents: true.	pError contents: true.</body></methods><methods><class-id>Database.MySQLBuffer</class-id> <category>private-binding</category><body package="MySQLEXDI">bindExternal: aMYSQL_BIND	"Connect this buffer to send parameter data. Get the MYSQL_BIND	array from my session, and put these items in it at the correct index.	My data, refered to by these pointers, will be read by the api for input,	and read and updated by the api for output."	aMYSQL_BIND		memberAt: #length put: pLength;		memberAt: #buffer put: bufferPointer;		memberAt: #error put: pError;		memberAt: #is_null put: pIsNull;		memberAt: #buffer_type put: databaseType;		memberAt: #buffer_length put: elementSize</body><body package="MySQLEXDI">bindInputExternal	"Connect this buffer to send parameter data. Get the MYSQL_BIND	array from my session, and put these items in it at the correct index.	My data, refered to by these pointers, will be accepted by the api."	| aMYSQL_BIND |	aMYSQL_BIND := session inputBufferPtrsArrayRefAt: bufferIndex - 1.	self bindExternal: aMYSQL_BIND</body><body package="MySQLEXDI">bindOutputExternal	"Connect this buffer to receive column data. Get the MYSQL_BIND	array from my session, and put these items in it at the correct index.	My data, refered to by these pointers, will be updated by the api."	| aMYSQL_BIND |	aMYSQL_BIND := session outputBufferPtrsArrayRefAt: bufferIndex - 1.	self bindExternal: aMYSQL_BIND</body></methods><methods><class-id>Database.MySQLBuffer</class-id> <category>private-accessing</category><body package="MySQLEXDI">databaseTypeForSmalltalkType: aSmalltalkType 	"Return the MySQL database type number corresponding to the St type."	^self class smalltalkToMySQLTypesMap at: aSmalltalkType</body><body package="MySQLEXDI">determineGetSelector	"Based on my databaseType, use default getSelector.	If my data is Binary, use a blob selector (byteArray).	If my data is Unsigned, use an unsigned integer selector."	| map selector |	map := self class defaultTypesGetSelectorMap.	selector := map at: databaseType				ifAbsent: 					[session class connectionClass unableToDescribeSignal 						raiseSignal: #unknownDatabaseType &lt;&lt; #mysql 								&gt;&gt; 'Unknown database type'].	^selector</body><body package="MySQLEXDI">determinePutSelector	"Based on my smalltalkType, use default putSelector.	If my data is Binary, use a blob selector (byteArray).	If my data is Unsigned, use an unsigned integer selector."	| map selector |	map := self class defaultTypesPutSelectorMap.	selector := map at: smalltalkType				ifAbsent: 					[session class connectionClass unableToDescribeSignal 						raiseSignal: #unknownDatabaseType &lt;&lt; #mysql 								&gt;&gt; 'Unknown database type'].	^selector</body><body package="MySQLEXDI">elementSizeFor: aValue asType: aSmalltalkType 	"This method is used when sending data to the api (Input).	We need to know the number of bytes to allocate to hold the object (bufferPointer).	String and ByteArray types get a size equal to their length+1 for null terminators.	FixedPoint and LargeIntegers are input as DECIMAL type, passed as a string.	Other types have size equal to their MySQL C-language type representations."	| aByteArray |	^(#(#String #LargeString #ByteArray #LargeByteArray) 		includes: aSmalltalkType) 			ifTrue: 				[aValue ifNotNil: 						[aByteArray := (#(#String #LargeString) includes: aSmalltalkType) 									ifTrue: [aValue asByteArrayEncoding: self encoding]									ifFalse: [aValue asByteArray].						aByteArray size+1]					ifNil: [1]]			ifFalse: 				[(#(#FixedPoint #LargeInteger) includes: aSmalltalkType) 					ifTrue: [self class xif decimalSize + 1 ]]</body><body package="MySQLEXDI">encodingForCollationId: aCollationId 	"Return the Smalltalk encoding name (a symbol) based on the MySQL collation id."	^(self class connectionClass encodingForCollationId: aCollationId) ifNil: 			[session class connectionClass unableToDescribeSignal 				raiseSignal: #unknownCollationId &lt;&lt; #mysql 								&gt;&gt; 'Unknown character encoding collation id.']</body><body package="MySQLEXDI">reUse: aValue 	"Re-use this buffer for an object with the same mapped database type,	and same or smaller size."	(self canHold: aValue)		ifFalse: [self class connectionClass unableToBindSignal raiseSignal].	self value: aValue.	self rebindForInput</body><body package="MySQLEXDI">smalltalkTypeForDatabaseType: aDatabaseType 	"Return the Smalltalk type corresponding to the MySQL database type number."	^self class mySQLToSmalltalkTypesMap at: aDatabaseType</body><body package="MySQLEXDI">smalltalkTypeForValue: aValue 	^aValue isNil ifTrue: [#String] ifFalse: [aValue mysqlConversion]</body></methods><methods><class-id>Database.MySQLBuffer</class-id> <category>initialize-release</category><body package="MySQLEXDI">columnDescription: aColDesc position: position session: aSession	"Initialize an instance of receiver which is set up to hold values as described.f	We don't receive arrays, so allocCount is always 1.	elemSize is set to the max_length field, if it is available for this type.	If charsetnr = 63, then it is a binary object (eg., number, BINARY, VARBINARY, BLOB).	If the connection is using the api encoding information, use the charsetnr. Otherwise,	use the encoding asserted by the connection."	| elemSize enc |	maxDbDatumLength := 0.	databaseType := aColDesc mysqlType.	smalltalkType := self smalltalkTypeForDatabaseType: databaseType.	isNullable := aColDesc nullable.	isBinary := aColDesc charsetnr = 63.	isUnsigned := aColDesc isUnsigned.	elemSize := self class sizesOfFixedDatabaseTypes at: databaseType				ifAbsent: [aSession maxLongData						min: (aColDesc precision max: aColDesc maxColumnConstraint) + 2].	bufferIndex := position.	session := aSession.	enc := session connection useEncodingApi				ifTrue: [self encodingForCollationId: aColDesc charsetnr]				ifFalse: [session connection encoding].	self encoding: enc.	getSelector := self determineGetSelector.	putSelector := self determinePutSelector.	self elementSize: elemSize count: 0 databaseType: databaseType</body><body package="MySQLEXDI">on: aValue position: position session: aSession 	"Initialize an instance of receiver which is set up to hold aValue.	This method does not remember the actual value, but gets ready for it.	Note: the databaseType is the type of data that we are sending--not necessarily	the type of the destination column. The api will translate for us."	| elemSize |	count := 0.	smalltalkType := self smalltalkTypeForValue: aValue.	databaseType := self databaseTypeForSmalltalkType: smalltalkType.	bufferIndex := position.	session := aSession.	isNullable := true.	isUnsigned := false.	isBinary := #(#ByteArray #LargeByteArray) includes: smalltalkType.	self encoding: session connection encoding.	elemSize := self class sizesOfFixedSmalltalkTypes at: smalltalkType				ifAbsent: [self elementSizeFor: aValue asType: smalltalkType].	elemSize ifNil: [self error: 'Bad type.'].	getSelector := self determineGetSelector.	putSelector := self determinePutSelector.	self 		elementSize: elemSize		count: 0		databaseType: databaseType</body></methods><methods><class-id>Database.MySQLBuffer class</class-id> <category>accessing</category><body package="MySQLEXDI">connectionClass	^MySQLConnection</body><body package="MySQLEXDI">largeObjectBufferClass	"Currently, there is no dedicated LargeObject buffer class. MySQL allows INSERTing data piecewise (in a loop), but it does not allow SELECTing data that way. It's all fetched in a single chunk. So, for now, there is no special large buffer, and we insert and select using a single chunk."	^MySQLBuffer</body><body package="MySQLEXDI">useSetsFor64Bits	"If True, return a 64-bit Set (a MySQL column type) object to a Smalltalk Set.	If False, return such an object as an 8-byte ByteArray."	^UseSetsForMySQL64BitSets</body><body package="MySQLEXDI">useSetsFor64Bits: aBoolean	"If True, return a 64-bit Set (a MySQL column type) object to a Smalltalk Set.	If False, return such an object as an 8-byte ByteArray."	^UseSetsForMySQL64BitSets := aBoolean</body><body package="MySQLEXDI">xif	"Answer an instance of the ExternalInterface."	^self connectionClass xif</body></methods><methods><class-id>Database.MySQLBuffer class</class-id> <category>private-accessing</category><body package="MySQLEXDI">defaultTypesGetSelectorMap	^DefaultTypesGetSelectorMap</body><body package="MySQLEXDI">defaultTypesPutSelectorMap	^DefaultTypesPutSelectorMap</body><body package="MySQLEXDI">mySQLToSmalltalkTypesMap	^MySQLToSmalltalkTypesMap</body><body package="MySQLEXDI">sizesOfFixedDatabaseTypes	^SizesOfFixedDatabaseTypes</body><body package="MySQLEXDI">sizesOfFixedSmalltalkTypes	^SizesOfFixedSmalltalkTypes</body><body package="MySQLEXDI">smalltalkToMySQLTypesMap	^SmalltalkToMySQLTypesMap</body></methods><methods><class-id>Database.MySQLBuffer class</class-id> <category>filein/fileout</category><body package="MySQLEXDI">prerequisitesForLoading	"The receiver requires MySQLConnection to have initialized	 its interface mapping before it initializes."	^super prerequisitesForLoading		addLast: MySQLConnection;		addLast: MySQLInterface;		yourself</body></methods><methods><class-id>Database.MySQLBuffer class</class-id> <category>class initialization</category><body package="MySQLEXDI">initialize	"MySQLBuffer initialize"	self install.</body><body package="MySQLEXDI">initializeSelectorsMap	| xif |	xif := self xif.	"This map shows what databaseType to use for a given Smalltalk type."	"Use the xif's dictionary of type-name put: enum value.	These are the usual types, unless the Binary or Unsigned flag is set.	MYSQL_TYPE_STRING implies CHAR or BINARY column type.	MYSQL_TYPE_VAR_STRING implies VARCHAR or VARBINARY column type.	MYSQL_TYPE_BLOB implies TEXT or BLOB column type.	If charsetnr = 63, then it is a binary (#ByteArray) column, otherwise it is a character (#String) column."	(DefaultTypesGetSelectorMap := IdentityDictionary new)		at: (xif typeNumberFor: #MYSQL_TYPE_BIT) put: #get64BitsAt:;		at: (xif typeNumberFor: #MYSQL_TYPE_TINY) put: #getInt8At:;		at: (xif typeNumberFor: #MYSQL_TYPE_SHORT) put: #getInt16At:;		at: (xif typeNumberFor: #MYSQL_TYPE_INT24) put: #getInt24At:;		at: (xif typeNumberFor: #MYSQL_TYPE_LONG) put: #getInt32At:;		at: (xif typeNumberFor: #MYSQL_TYPE_LONGLONG) put: #getInt64At:;		at: (xif typeNumberFor: #MYSQL_TYPE_FLOAT) put: #getFloatAt:;		at: (xif typeNumberFor: #MYSQL_TYPE_DOUBLE) put: #getDoubleAt:;		at: (xif typeNumberFor: #MYSQL_TYPE_NEWDECIMAL) put: #getFixedPointAt:;		at: (xif typeNumberFor: #MYSQL_TYPE_TIME) put: #getTimeAt:;		at: (xif typeNumberFor: #MYSQL_TYPE_DATE) put: #getDateAt:;		at: (xif typeNumberFor: #MYSQL_TYPE_DATETIME) put: #getTimestampAt:;		at: (xif typeNumberFor: #MYSQL_TYPE_TIMESTAMP) put: #getTimestampAt:;		at: (xif typeNumberFor: #MYSQL_TYPE_YEAR) put: #getYearAt:;		at: (xif typeNumberFor: #MYSQL_TYPE_STRING) put: #getStringAt:;		at: (xif typeNumberFor: #MYSQL_TYPE_VAR_STRING) put: #getStringAt:;		at: (xif typeNumberFor: #MYSQL_TYPE_TINY_BLOB) put: #getStringAt:;		at: (xif typeNumberFor: #MYSQL_TYPE_BLOB) put: #getStringAt:;		at: (xif typeNumberFor: #MYSQL_TYPE_MEDIUM_BLOB) put: #getStringAt:;		at: (xif typeNumberFor: #MYSQL_TYPE_LONG_BLOB) put: #getStringAt:.	"This map shows what put-selector to use for a given Smalltalk type."	(DefaultTypesPutSelectorMap := IdentityDictionary new)		at: #String put: #at:putString:;		at: #ByteArray put: #at:putByteArray:;		at: #LargeString put: #at:putString:;		at: #LargeByteArray put: #at:putByteArray:;		at: #MySQLBitfield put: #at:putMySQLBitfield:; "The set should have integer elements within 1..64"		at: #Integer put: #at:putInt32:;		at: #LargeInteger put: #at:putLargeInteger:;		at: #Timestamp put: #at:putTimestamp:;		at: #Date put: #at:putDate:;		at: #Time put: #at:putTime:;		at: #FixedPoint put: #at:putFixedPoint:;		at: #Double put: #at:putDouble:;		at: #Float put: #at:putFloat:;		at: #Boolean put: #at:putBoolean:</body><body package="MySQLEXDI">initializeSizesMap	"These are the fixed-size types, and their sizes, used for moving data to/from the db.	Note that the integer types are all assinged 4-bytes length, even though they range	from 1, 2, 3 and 4 bytes length. So, 4 bytes is an adequate buffer size for each,	although long long (64-bits) is granted 8 bytes.	STRING, VARCHAR, BLOB and NEWDECIMAL are variable-sized. For variable-sized	input data (from the db), we can determine necessary buffer size using the precision	field in the columDescription object."	| xif |	xif := self xif.	"Used for output data (SELECT)."	(SizesOfFixedDatabaseTypes := IdentityDictionary new)		at: (xif typeNumberFor: #MYSQL_TYPE_TINY) put: CIntegerType long sizeof;		at: (xif typeNumberFor: #MYSQL_TYPE_SHORT) put: CIntegerType long sizeof;		at: (xif typeNumberFor: #MYSQL_TYPE_INT24) put: CIntegerType long sizeof;		at: (xif typeNumberFor: #MYSQL_TYPE_LONG) put: CIntegerType long sizeof;		at: (xif typeNumberFor: #MYSQL_TYPE_LONGLONG)			put: CIntegerType signedLongLong sizeof;		at: (xif typeNumberFor: #MYSQL_TYPE_DATETIME) put: xif MYSQL_TIME sizeof;		at: (xif typeNumberFor: #MYSQL_TYPE_DATE) put: xif MYSQL_TIME sizeof;		at: (xif typeNumberFor: #MYSQL_TYPE_TIME) put: xif MYSQL_TIME sizeof;		at: (xif typeNumberFor: #MYSQL_TYPE_TIMESTAMP) put: xif MYSQL_TIME sizeof;		at: (xif typeNumberFor: #MYSQL_TYPE_YEAR) put: CIntegerType long sizeof;		at: (xif typeNumberFor: #MYSQL_TYPE_DOUBLE)			put: CLimitedPrecisionRealType double sizeof;		at: (xif typeNumberFor: #MYSQL_TYPE_FLOAT)			put: CLimitedPrecisionRealType float sizeof;		at: (xif typeNumberFor: #MYSQL_TYPE_BIT)			put: CIntegerType unsignedChar sizeof * 8.	"SizesOfFixedSmalltalkTypes (sttype -&gt; size).	Used for input data (INSERT)."	(SizesOfFixedSmalltalkTypes := IdentityDictionary new)		at: #Boolean put: CIntegerType long sizeof;		at: #Double put: CLimitedPrecisionRealType double sizeof;		at: #Time put: xif MYSQL_TIME sizeof;		at: #Integer put: CIntegerType long sizeof;		at: #Date put: xif MYSQL_TIME sizeof;		at: #Timestamp put: xif MYSQL_TIME sizeof;		at: #MySQLBitfield put: CIntegerType unsignedChar sizeof * 8;		at: #Float put: CLimitedPrecisionRealType float sizeof.</body><body package="MySQLEXDI">initializeTypesMap	"Note that LargeInteger maps to NEWDECIMAL, since it can exceed the 64-bits of LONGLONG."	| xif |	xif := self xif.	"This map shows what databaseType to use for a given Smalltalk type."	(SmalltalkToMySQLTypesMap := IdentityDictionary new)		at: #String put: (xif typeNumberFor: #MYSQL_TYPE_STRING);		at: #ByteArray put: (xif typeNumberFor: #MYSQL_TYPE_BLOB);		at: #LargeString put: (xif typeNumberFor: #MYSQL_TYPE_STRING);		at: #LargeByteArray put: (xif typeNumberFor: #MYSQL_TYPE_BLOB);		at: #MySQLBitfield put: (xif typeNumberFor: #MYSQL_TYPE_BLOB);		at: #Integer put: (xif typeNumberFor: #MYSQL_TYPE_LONG);		at: #LargeInteger put: (xif typeNumberFor: #MYSQL_TYPE_BLOB);		at: #Timestamp put: (xif typeNumberFor: #MYSQL_TYPE_DATETIME);		at: #Date put: (xif typeNumberFor: #MYSQL_TYPE_DATE);		at: #Time put: (xif typeNumberFor: #MYSQL_TYPE_TIME);		at: #FixedPoint put: (xif typeNumberFor: #MYSQL_TYPE_BLOB);		at: #Double put: (xif typeNumberFor: #MYSQL_TYPE_DOUBLE);		at: #Float put: (xif typeNumberFor: #MYSQL_TYPE_FLOAT);		at: #Boolean put: (xif typeNumberFor: #MYSQL_TYPE_TINY).	"This map shows what Smalltalk to use with a given databaseType type."	(MySQLToSmalltalkTypesMap := IdentityDictionary new)		at: (xif typeNumberFor: #MYSQL_TYPE_BIT) put: #MySQLBitfield;		at: (xif typeNumberFor: #MYSQL_TYPE_TINY) put: #Integer;		at: (xif typeNumberFor: #MYSQL_TYPE_SHORT) put: #Integer;		at: (xif typeNumberFor: #MYSQL_TYPE_INT24) put: #Integer;		at: (xif typeNumberFor: #MYSQL_TYPE_LONG) put: #Integer;		at: (xif typeNumberFor: #MYSQL_TYPE_LONGLONG) put: #LargeInteger;		at: (xif typeNumberFor: #MYSQL_TYPE_FLOAT) put: #Float;		at: (xif typeNumberFor: #MYSQL_TYPE_DOUBLE) put: #Double;		at: (xif typeNumberFor: #MYSQL_TYPE_NEWDECIMAL) put: #FixedPoint;		at: (xif typeNumberFor: #MYSQL_TYPE_TIME) put: #Time;		at: (xif typeNumberFor: #MYSQL_TYPE_DATE) put: #Date;		at: (xif typeNumberFor: #MYSQL_TYPE_DATETIME) put: #Timestamp;		at: (xif typeNumberFor: #MYSQL_TYPE_TIMESTAMP) put: #Timestamp;		at: (xif typeNumberFor: #MYSQL_TYPE_YEAR) put: #Integer;		at: (xif typeNumberFor: #MYSQL_TYPE_STRING) put: #String;		at: (xif typeNumberFor: #MYSQL_TYPE_VAR_STRING) put: #String;		at: (xif typeNumberFor: #MYSQL_TYPE_TINY_BLOB) put: #ByteArray;		at: (xif typeNumberFor: #MYSQL_TYPE_BLOB) put: #ByteArray;		at: (xif typeNumberFor: #MYSQL_TYPE_MEDIUM_BLOB) put: #ByteArray;		at: (xif typeNumberFor: #MYSQL_TYPE_LONG_BLOB) put: #LargeByteArray.</body></methods><methods><class-id>Database.MySQLBuffer class</class-id> <category>private-activation</category><body package="MySQLEXDI">install	self initializeSelectorsMap.	self initializeTypesMap.	self initializeSizesMap.	UseSetsForMySQL64BitSets := true</body></methods><methods><class-id>Database.MySQLAdminBuffer</class-id> <category>accessing</category><body package="MySQLEXDI">copyFromPointer: aPointer length: numBytes 	"Copy the ByteArray from the pointer, and assign to myself.	If aPoiner is nil, NULL (or invalid), assign myself nil."	| ba len |	(self class xif isValidCPointer: aPointer) 		ifTrue: 			[maxDbDatumLength := maxDbDatumLength max: numBytes.			len := numBytes min: session maxLongData.			ba := ByteArray new: len.			aPointer 				copyAt: 0				to: ba				size: len				startingAt: 1].	self value: ba</body><body package="MySQLEXDI">encoding	^encoding</body><body package="MySQLEXDI">isBinary	^isBinary</body><body package="MySQLEXDI">isByteArray	"Return true only for columns which are character based, and binary.	Numeric and other types claim to be binary, but are returned as strings."	^(self class xif isCharacterType: databaseType) 		and: [self isBinary]</body><body package="MySQLEXDI">isNull	^isNull</body><body package="MySQLEXDI">isUnsigned	^isUnsigned</body><body package="MySQLEXDI">value	"Answer the buffer value, converted to a string if it is not binary or nil."	^self isNull 		ifTrue: [nil]		ifFalse: 			[self isByteArray 				ifTrue: [byteArray]				ifFalse: 					[self encoding = #binary 						ifTrue: [byteArray asString]						ifFalse: [byteArray asStringEncoding: self encoding]]]</body></methods><methods><class-id>Database.MySQLAdminBuffer</class-id> <category>private-accessing</category><body package="MySQLEXDI">encodingForCollationId: aCollationId	"Return the Smalltalk encoding name (a symbol) based on the MySQL collation id."	^(self class connectionClass encodingForCollationId: aCollationId)		ifNil: [session class connectionClass unableToDescribeSignal				raiseSignal: #unknownCollationId &lt;&lt; #mysql						&gt;&gt; 'Unknown character encoding collation id.']</body><body package="MySQLEXDI">free	"We don't have any allocated memory, but we must implement this method	as part of the expected buffer protocol."</body><body package="MySQLEXDI">isIntegerBased	^self class xif isIntegerType: databaseType</body><body package="MySQLEXDI">value: aByteArrayOrNil	byteArray := aByteArrayOrNil.	length := aByteArrayOrNil size.	isNull := aByteArrayOrNil isNil</body></methods><methods><class-id>Database.MySQLAdminBuffer</class-id> <category>summary-accessing</category><body package="MySQLEXDI">maxBufferSizeNeeded	"This method should only be called after the entire result set has been read.	It returns the size of the largest datum retrieved."	^maxDbDatumLength</body><body package="MySQLEXDI">wasDataTruncated	"This method should only be called after the entire result set has been read.	It returns true if one or more retrieved data exceeded the allowed size."	^maxDbDatumLength &gt; session maxLongData</body></methods><methods><class-id>Database.MySQLAdminBuffer</class-id> <category>initialize-release</category><body package="MySQLEXDI">columnDescription: aColDesc position: position session: aSession 	"Initialize an instance of receiver which is set up to hold byteArrray values.	If charsetnr = 63, then it is a binary object (eg., number, BINARY, VARBINARY, BLOB)."	maxDbDatumLength := 0.	databaseType := aColDesc mysqlType.	isNullable := aColDesc nullable.	isBinary := aColDesc charsetnr = 63.	isUnsigned := aColDesc isUnsigned.	bufferIndex := position.	session := aSession.	encoding := self encodingForCollationId: aColDesc charsetnr.	databaseType := databaseType.	self value: nil</body></methods><methods><class-id>Database.MySQLAdminBuffer class</class-id> <category>accessing</category><body package="MySQLEXDI">connectionClass	^MySQLConnection</body><body package="MySQLEXDI">xif	"Answer an instance of the ExternalInterface."	^self connectionClass xif</body></methods><methods><class-id>Database.MySQLAdminBuffer class</class-id> <category>filein/fileout</category><body package="MySQLEXDI">prerequisitesForLoading	"The receiver requires MySQLConnection to have initialized	 its interface mapping before it initializes."	^super prerequisitesForLoading		addLast: MySQLConnection;		addLast: MySQLInterface;		yourself</body></methods><methods><class-id>Database.MySQLAdminBuffer class</class-id> <category>class initialization</category><body package="MySQLEXDI">initialize	"MySQLCharacterBuffer initialize"	self install</body></methods><methods><class-id>Database.MySQLAdminBuffer class</class-id> <category>private-activation</category><body package="MySQLEXDI">install	"OracleConnection is64Bit ifTrue: [		Unsigned32BitIntType := CIntegerType unsignedInt.		Signed32BitIntType := CIntegerType signedInt.	] ifFalse: [		Unsigned32BitIntType := CIntegerType unsignedLong.		Signed32BitIntType := CIntegerType signedLong.	].	DefaultDoublePointerType := CLimitedPrecisionRealType double pointerType.	DefaultFloatPointerType := CLimitedPrecisionRealType float pointerType.	DefaultLongPointerType := Signed32BitIntType pointerType.	DefaultShortPointerType := CIntegerType short pointerType.	DefaultUnsignedCharPointerType := CIntegerType unsignedChar pointerType.	DefaultUnsignedShortPointerType := CIntegerType unsignedShort pointerType.	OracleConnection platformType == #win32s 		ifTrue: 			[DefaultDoublePointerType beFar.			DefaultFloatPointerType beFar.			DefaultLongPointerType beFar.			DefaultShortPointerType beFar.			DefaultUnsignedCharPointerType beFar.			DefaultUnsignedShortPointerType beFar]."</body></methods><methods><class-id>Database.MySQLColumnDescription</class-id> <category>accessing</category><body package="MySQLEXDI">catalog	^catalog</body><body package="MySQLEXDI">catalog: anObject	catalog := anObject</body><body package="MySQLEXDI">charsetnr	^charsetnr</body><body package="MySQLEXDI">charsetnr: anObject	charsetnr := anObject</body><body package="MySQLEXDI">db	^db</body><body package="MySQLEXDI">db: anObject	db := anObject</body><body package="MySQLEXDI">def	^def</body><body package="MySQLEXDI">def: anObject	def := anObject</body><body package="MySQLEXDI">isBinaryCollation	^isBinaryCollation</body><body package="MySQLEXDI">isBinaryCollation: anObject	isBinaryCollation := anObject</body><body package="MySQLEXDI">isUnsigned	^isUnsigned</body><body package="MySQLEXDI">isUnsigned: anObject	isUnsigned := anObject</body><body package="MySQLEXDI">mysqlType	^mysqlType</body><body package="MySQLEXDI">mysqlType: anObject	mysqlType := anObject</body><body package="MySQLEXDI">org_name	^org_name</body><body package="MySQLEXDI">org_name: anObject	org_name := anObject</body><body package="MySQLEXDI">org_table	^org_table</body><body package="MySQLEXDI">org_table: anObject	org_table := anObject</body><body package="MySQLEXDI">table	^table</body><body package="MySQLEXDI">table: anObject	table := anObject</body></methods><methods><class-id>Database.MySQLColumnDescription</class-id> <category>testing</category><body package="MySQLEXDI">isATimeType	"Answer true if the receiver represents a time-type column."	| xif |	xif := self class connectionClass xif.	^xif isTimeType: mysqlType.</body><body package="MySQLEXDI">isLong	"Answer true if the receiver represents a long result column.		TINYBLOB is 2^8-1, BLOB is 2^16-1, MEDIUMBLOB is 2^24-1, LONGBLOB is 2^32-1.	TEXT types have same mysqlType as BLOBs, but isBinary is false for TEXT."	| xif |	xif := self class connectionClass xif.	^xif isLongType: mysqlType.</body></methods><methods><class-id>Database.MySQLColumnDescription class</class-id> <category>accessing</category><body package="MySQLEXDI">connectionClass	^MySQLConnection</body></methods><methods><class-id>Database.MySQLSession</class-id> <category>private-answer set</category><body package="MySQLEXDI">acquireBuffers	"Generate the array which holds copies of our buffer pointers. The library	will populate the buffer data through these pointers. Each buffer corresponds	to one index in the array."	self hasOutputBuffers ifFalse: [ self generateBindArrayForOutput ].	"Acquire buffers for fetching the answer set from the server."	super acquireBuffers.	"Now pass the bind array (which the buffers have plugged themselves into)	to the api."	"self bindBufferPtrsArray."</body><body package="MySQLEXDI">advanceExternal		^self useStatementHandle		ifTrue: [self advanceExternalForStmt]		ifFalse: [self advanceExternalNoStmt]</body><body package="MySQLEXDI">advanceExternalForStmt	"Advance to the next row.  If now more rows, answer nil.	While not isRowCountKnown, increment rowCount after every fetch.	(If we used 'fetchAllRowsAtOnce', then rowCount has already been established.)	To do: don't let data truncation errors go uncaught..."	| xif rc |	xif := self xif.	rc := xif mysql_stmt_fetch: self hstmt.	(traceLevel &gt;= 3) ifTrue:			[self connection 				traceFunc: 'mysql_stmt_fetch'				result: rc				params: self hstmt].	(rc == xif MYSQL_NO_DATA) ifTrue:	"No more data."		[  self isRowCountKnown: true.		^nil ].	(rc == xif SUCCESS	or: [rc == xif MYSQL_DATA_TRUNCATED]) ifFalse:		[ | errs |		errs := self getStatementErrors.		self class connectionClass unableToFetchDataSignal raiseWith: errs errorString: errs first dbmsErrorString ].	self isRowCountKnown ifFalse: [self rowCount: (self rowCount + 1)].</body><body package="MySQLEXDI">advanceExternalNoStmt	"Advance to the next row.  If now more rows, answer nil."	| pRow pFieldLengths |	pRow := self fetchRow.	(self xif isValidCPointer: pRow) 		ifFalse: "No more data."			[self isRowCountKnown: true.			^nil].	pFieldLengths := self getFieldLengthsThisRow.	self updateBuffers: pRow lengths: pFieldLengths.	"Increment number of rows, unless it was already retrieved and set."	self isRowCountKnown ifFalse: [self rowCount: self rowCount + 1]</body><body package="MySQLEXDI">allocateRowBufferExternal: aColumn	"Answer an mysql buffer allocated for holding one column's worth of information 	as returned by the library. An appropriate buffer class for the result column 	will be choosen automatically."		| aColDescription bufferClass buffer |	aColDescription := columnDescriptions at: aColumn.	bufferClass := self useStatementHandle		ifTrue: [self class bufferClassForStmt]		ifFalse: [self class bufferClassNoStmt].	buffer := bufferClass new columnDescription: aColDescription position:			aColumn session: self.	self useStatementHandle ifTrue: [buffer bindForOutput].	^buffer</body><body package="MySQLEXDI">answerOfClass: anAnswerStreamClass		^self useStatementHandle		ifTrue: [self answerOfClassForStmt: anAnswerStreamClass]		ifFalse: [self answerOfClassNoStmt: anAnswerStreamClass]</body><body package="MySQLEXDI">answerOfClassForStmt: anAnswerStreamClass	"Answer an instance of the given subclass of ExternalDatabaseAnswerStream"	"Assert: anAnswerStreamClass isKindOf: ExternalDatabaseAnswerStream"	| initialAnswer |	initialAnswer := ( self state == #ready ).	self state: #validResults.	initialAnswer		ifTrue:	[ "Verify that the query executed without error."				self resultsExternal ]		ifFalse:	[ "If we're still holding on to a prior answer stream, dismiss it."				answerStream notNil					ifTrue:	[ answerStream close ].				"Assert: self state == #validResults"				self moreResultsExternal					ifFalse:	[ self state: #prepared.							^#noMoreAnswers ] ].	self hasAnswerSetExternal		ifTrue:	[ | answer |				initialAnswer ifFalse:					[ "Previous descriptions/buffers are no longer valid"					self releaseBuffers.					self releaseAdaptors.					self columnDescriptions: nil ].				self getColumnDescriptions.				self acquireBuffers.				self setupAdaptors.				self executeAndBindArrays.				self resultsExternal.	"Fetch errors now that query has been executed."				self aboutToAnswer.				answer := anAnswerStreamClass newForSession: self.				self answerStream: answer.				self state: #fetchingData.				^answer ]		ifFalse: [self executeAndBindArrays.				self resultsExternal.	"Fetch errors now that query has been executed." ].	^#noAnswerStream.</body><body package="MySQLEXDI">answerOfClassNoStmt: anAnswerStreamClass	"Answer an instance of the given subclass of ExternalDatabaseAnswerStream"	"Assert: anAnswerStreamClass isKindOf: ExternalDatabaseAnswerStream"	| initialAnswer |	initialAnswer := ( self state == #ready ).	self state: #validResults.	initialAnswer		ifTrue:	[ "Verify that the query executed without error."				self fetchResult.				self resultsExternal ]		ifFalse:	[ "If we're still holding on to a prior answer stream, dismiss it."				answerStream notNil					ifTrue:	[ answerStream close ].				"Assert: self state == #validResults"				self moreResultsExternal					ifTrue: [self fetchResult]					ifFalse:	[ self state: #prepared.							^#noMoreAnswers ] ].	self hasAnswerSetExternal		ifTrue:	[ | answer |				initialAnswer ifFalse:					[ "Previous descriptions/buffers are no longer valid"					self releaseBuffers.					self releaseAdaptors.					self columnDescriptions: nil ].				self getColumnDescriptions.				self acquireBuffers.				self setupAdaptors.				self fetchNumAffectedRows.				self aboutToAnswer.				answer := anAnswerStreamClass newForSession: self.				self answerStream: answer.				self state: #fetchingData.				^answer ]		ifFalse: [self fetchNumAffectedRows].	^#noAnswerStream.</body><body package="MySQLEXDI">answerStreamDismissed	"Close the cursor and discard pending results."		super answerStreamDismissed.	self useStatementHandle		ifTrue: [self freeStatementResults]		ifFalse: [self freeResultHandle]</body><body package="MySQLEXDI">cancelAnswerSet	"Cancel an answer set.  Used to release server resources.	This destroys the current cursor, and returns the statement to the prepared state."	self cancelAnswerSetExternal.	self state: #prepared.</body><body package="MySQLEXDI">cancelAnswerSetExternal	"Cancel current answer set from the server. i.e., close the cursor.	Keep the statement handle. MySQL will revert the statement back	to the prepared state.	To do: see how this affects the ongoing transaction."		| stateTemp |	stateTemp := self state.	(stateTemp == #new or: [stateTemp == #paused or: [self hstmt isNil and: [self useStatementHandle]]])		ifTrue: [^self].	self useStatementHandle		ifTrue: [self resetStatementExternal]		ifFalse: [self freeResultHandle]</body><body package="MySQLEXDI">describeAnswerColumns	"Fill in the columnDescriptions array. For prepared statements,	we discard the result handle afterwards. For a non-statement	query, we keep the handle throughout the entire query processing."		| pResult |	self useStatementHandle		ifTrue:			[pResult := self getResultMetaDataHandle.			self describeAnswerColumnsResult: pResult.			self freeResultMetaDataHandle: pResult]		ifFalse: [self describeAnswerColumnsResult: self hResult]</body><body package="MySQLEXDI">describeAnswerColumnsResult: pResult	"Fill in the columnDescriptions array. We check that numCols is as expected.	based on an earlier call using only the statement handle (not the results handle)."	|pFields pField flags type descrs columnDescriptionClass isNullable length colDesc isUnsigned isBinaryCollation isAutoIncrement charsetnr name org_name table org_table db catalog def decimals max_length numCols |	numCols := self getNumResultColumns: pResult.	numCols ~= self numColumns ifTrue: [ self numColumns: numCols ]. "These should match."	pFields := self getFields: pResult.	descrs := Array new: self numColumns.	columnDescriptionClass := self connection class columnDescriptionClass.	1 to: self numColumns do:		[ :aColumn |		pField := pFields refAt: aColumn-1.		name := (pField memberAt: #name) copyCStringFromHeap. "Could be a SQL alias (using AS)."		org_name := (pField memberAt: #org_name) copyCStringFromHeap.  "True column name."		table  := (pField memberAt: #table) copyCStringFromHeap.		"Could be alias (AS tablename)."		org_table  := (pField memberAt: #org_table) copyCStringFromHeap.   "True table name."		db := (pField memberAt: #db) copyCStringFromHeap.		catalog := (pField memberAt: #table) copyCStringFromHeap.		def := (pField memberAt: #def) isValid ifTrue: [ (pField memberAt: #def) copyCStringFromHeap] ifFalse: [nil].		length := pField memberAt: #length.		"The precision--total number of digits (max is 64)."		max_length := pField memberAt: #max_length.	"Only makes sense if stmt attiribute was set."		flags := pField memberAt: #flags.		decimals := pField memberAt: #decimals.	"The scale--digits after decimal point (max is 30). Sign and DP are added after retrieval."		charsetnr := pField memberAt: #charsetnr.   "63 means BINARY, ie., BLOB or BIT."		isNullable := (flags bitAnd: self xif NOT_NULL_FLAG) ~= 0.		isUnsigned := (flags bitAnd: self xif UNSIGNED_FLAG) ~= 0.		isBinaryCollation := (flags bitAnd: self xif BINARY_FLAG) ~= 0.		isAutoIncrement := (flags bitAnd: self xif AUTO_INCREMENT_FLAG) ~= 0.		type := pField memberAt: #type.		( traceLevel &gt;= 2) ifTrue:			[ (self traceStream)				nextPutAll: ' column =';  print: aColumn;				nextPutAll:  ', name: '; print: name;				nextPutAll:  ', org_name: '; print: org_name;				nextPutAll:  ', table: '; print: table;				nextPutAll:  ', org_table: '; print: org_table;				nextPutAll:  ', type: '; print: type;				nextPutAll:  ', db: '; print: db;				nextPutAll:  ', catalog: '; print: catalog;				nextPutAll:  ', def: '; print: def;				nextPutAll:  ', length: '; print: length;				nextPutAll:  ', max length: '; print: max_length;				nextPutAll:  ', flags: '; print: flags;				nextPutAll:  ', decimals '; print: decimals;				nextPutAll:  ', charsetnr: '; print: charsetnr;				nextPutAll:  ', is nullable: ';  print: isNullable;				nextPutAll:  ', is unsigned: ';  print: isUnsigned;				nextPutAll:  ', is binary collation: ';  print: isBinaryCollation;				nextPutAll:  ', is auto-incr: ';  print: isAutoIncrement;				nextPutAll:  ' )'.			self class trace: self emitTrace ].		(colDesc := columnDescriptionClass new) 			name: name;			index: aColumn;			type: nil;			maxColumnConstraint: max_length;			org_name: org_name;			table: table;			org_table: org_table;			db: db;			catalog: catalog;			def: def;			mysqlType: type;			maxColumnConstraint: max_length;			precision: length;			scale: decimals;			isUnsigned: isUnsigned;			nullable: isNullable;			isBinaryCollation: isBinaryCollation;			charsetnr: charsetnr.		descrs at: aColumn put: colDesc ].	self columnDescriptions: descrs</body><body package="MySQLEXDI">executeAndBindArrays	"Tell the api to execute the query, and then pass the bind array	(which the buffers have plugged themselves into) to the api.	If there are column return results expected, bind the buffers."	self numParameters &gt; 0 ifTrue: [self bindBufferPtrsForInput].	self executeExternalAfterDescribe.	self numColumns &gt; 0 ifTrue: [self bindBufferPtrsForOutput].	self class shouldFetchEntireResultAtOnceForStmt ifTrue: [self storeResults].	"Get the count for pre-fetched rows, or affected rows for inserts/updates."	(self class shouldFetchEntireResultAtOnceForStmt or: [self numColumns = 0]) 		ifTrue: [self fetchRowCount]</body><body package="MySQLEXDI">fetchEntireResultAtOnce		^self useStatementHandle		ifTrue: [self class shouldFetchEntireResultAtOnceForStmt]		ifFalse: [self class shouldFetchEntireResultAtOnceNoStmt]</body><body package="MySQLEXDI">fetchNumAffectedRows	"Get the count for pre-fetched rows, or affected rows for inserts/updates.	For SELECT queries, valid only if results have been 'stored' on client machine, using	mysql_store_result(). See self class fetchEntireResultAtOnce.	If we are not allowed to fetch the affected rows in advance, do nothing."		(self fetchEntireResultAtOnce or: [self numColumns = 0])		ifTrue: [self fetchRowCount]</body><body package="MySQLEXDI">fetchRowCount	"Answer an Integer representing the number of rows affected by the executed query.	For SELECT queries, valid only if results have been 'stored' on client machine, using	mysql_store_result(). See self class fetchEntireResultAtOnce."	self rowCount: (self numColumns &gt; 0 				ifTrue: [self rowCountForAnswered]				ifFalse: [self rowCountForNoAnswer]).	self isRowCountKnown: true</body><body package="MySQLEXDI">freeResultHandle	"Let the library free my result handle."		(self isValidHandle: self hResult)		ifTrue: [self freeResultMetaDataHandle: self hResult].	self hResult: nil</body><body package="MySQLEXDI">freeResultMetaDataHandle: pResult	"Let the library free this meta-data handle via mysql_free_result:.	There is no return value, and no error code."	self xif mysql_free_result: pResult.	traceLevel &gt;= 3 		ifTrue: 			[self connection 				traceFunc: 'mysql_free_result'				result: nil				params: pResult].</body><body package="MySQLEXDI">freeStatementResults	"Free the statement result set. This is done after the results have been fetched."	| rc |	rc := self xif mysql_stmt_free_result: self hstmt.	traceLevel &gt;= 3 		ifTrue: 			[self connection 				traceFunc: 'mysql_stmt_free_result'				result: rc				params: self hstmt].	rc = self xif SUCCESS		ifFalse: 			[| errs |			errs := self getStatementErrors.			self class connectionClass unableToFreeResourceSignal 				raiseRequestWith: errs				errorString: errs first dbmsErrorString]</body><body package="MySQLEXDI">getFieldExternal: aColumn 	| buffer |  	buffer := (self rowBuffers) at: aColumn.	^buffer value</body><body package="MySQLEXDI">getFieldLengthsThisRow 	"Get the column lengths for the current returned row. The client library owns and will dispose of the pointers."	| pFieldLengths |	pFieldLengths := self xif mysql_fetch_lengths: self hResult.	traceLevel &gt;= 3 		ifTrue: 			[self connection 				traceFunc: 'mysql_fetch_lengths'				result: pFieldLengths				params: self hResult].	^pFieldLengths</body><body package="MySQLEXDI">getFields: pResult 	" Get total columns in the query. The client library owns and will dispose of the pointers."	| pFields |	pFields := self xif mysql_fetch_fields: pResult.	traceLevel &gt;= 3 		ifTrue: 			[self connection 				traceFunc: 'mysql_fetch_fields'				result: pFields				params: pResult].	^pFields</body><body package="MySQLEXDI">getNumResultColumns: pResult 	" Get total columns in the query. This answer should be the same as that returned by getNumStatementColumns.	This method uses the api call for the result set handle. The other uses the api for the statement handle itself."	| numCols |	numCols := self xif mysql_num_fields: pResult.	traceLevel &gt;= 3 		ifTrue: 			[self connection 				traceFunc: 'mysql_num_fields'				result: numCols				params: pResult].	numCols &gt;= 0 		ifFalse: 			[| errs |			errs := self getStatementErrors.			self class connectionClass unableToFreeResourceSignal 				raiseRequestWith: errs				errorString: errs first dbmsErrorString].	^numCols</body><body package="MySQLEXDI">getNumStatementColumns		^self useStatementHandle		ifTrue: [self getNumStatementColumnsForStmt]		ifFalse: [self getNumStatementColumnsNoStmt]</body><body package="MySQLEXDI">getNumStatementColumnsForStmt	"Is this a SELECT statement, with rows of answers? If numColumns is not zero, rows are expected (0 or more) .	This method can be called after the statement has been prepared. (prepare:)"	| numCols |	numCols := self xif mysql_stmt_field_count: self hstmt.	traceLevel &gt;= 3 		ifTrue: 			[self connection 				traceFunc: 'mysql_stmt_field_count'				result: numCols				params: self hstmt].	^numCols</body><body package="MySQLEXDI">getNumStatementColumnsNoStmt	"Is this a SELECT statement, with rows of answers? If numColumns is not zero, rows are expected (0 or more) .	This method can be called after the statement has been executed."	| numCols |	numCols := self xif mysql_field_count: self hConn.	traceLevel &gt;= 3 		ifTrue: 			[self connection 				traceFunc: 'mysql_field_count'				result: numCols				params: self hConn].	^numCols</body><body package="MySQLEXDI">getResultMetaDataHandle	"Ask for a meta-data handle so that we can fetch info about the result set.	Note: The library expects to free this handle via mysql_free_result:."	| pResult |	pResult := self xif mysql_stmt_result_metadata: self hstmt.	traceLevel &gt;= 3 		ifTrue: 			[self connection 				traceFunc: 'mysql_stmt_result_metadata'				result: pResult				params: self hstmt].	pResult isValid 		ifFalse: 			[| errs |			errs := self getStatementErrors.			self class connectionClass unableToAllocateHandleSignal raiseWith: errs				errorString: errs first dbmsErrorString].	^pResult</body><body package="MySQLEXDI">hasAnswerSetExternal	"Is this a SELECT statement, with rows of answers? If numColumns is not zero,	rows are expected (0 or more). If numColumns is zero, no results are expected.	This method can be called after the statement has been prepared. (prepare:)."	| numCols |	numCols := self getNumStatementColumns.	self numColumns: numCols.	^numCols &gt; 0</body><body package="MySQLEXDI">hasOutputBuffers	"Return true if my output buffers have already been created.	This will be true after the first execute has been answered,	ready for subsequent executes and answers. Since the columns	returned are established, we can reuse the buffers."		^self outputBufferPtrsArray notNil and: [self rowBuffers notNil]</body><body package="MySQLEXDI">releaseBuffers	"Release buffers and their associated resources."	| rbs |	(rbs := self rowBuffers) notNil ifTrue: [1 to: rbs size do: [:aColumn | (rbs at: aColumn) free]].	traceLevel &gt;= 3 		ifTrue: 			[self connection 				traceFunc: 'releaseBuffers'				result: 0				params: 0].	super releaseBuffers</body><body package="MySQLEXDI">resetStatementExternal	"Cancel current answer set from the server. i.e., close the cursor.Reset a prepared statement in case there was a recoverable error.SYNOPSISmysql_stmt_reset()thd Thread handlepacket Packet with stmt idDESCRIPTIONThis function resets statement to the state it was right after prepare.It can be used to:- clear an error happened during mysql_stmt_send_long_data- cancel long data stream for all placeholders withouthaving to call mysql_stmt_execute.- close an open cursorSends 'OK' packet in case of success (statement was reset)or 'ERROR' packet (unrecoverable error/statement not found/etc)."	| xif rc |	xif := self xif.	rc := xif mysql_stmt_reset: self hstmt.	(traceLevel &gt;= 3) ifTrue:			[self connection 				traceFunc: 'mysql_stmt_reset'				result: rc				params: self hstmt].	(rc == xif SUCCESS) ifFalse:		[ | errs |		errs := self getStatementErrors.		self class connectionClass unableToCancelCursorSignal raiseWith: errs errorString: errs first dbmsErrorString ].</body><body package="MySQLEXDI">storeResults	"Fetch the entire result set to the local machine. This can be demanding on local memory for large result sets. An advantage is that &gt;&gt;rowCount returns the actual result set size before fetching each row individually."	| rc |	rc := self xif mysql_stmt_store_result: self hstmt.	traceLevel &gt;= 3 		ifTrue: 			[self connection 				traceFunc: 'mysql_stmt_store_result:'				result: rc				params: self hstmt].	(rc == self xif SUCCESS) ifFalse:		[ | errs |		errs := self getStatementErrors.		self class connectionClass unableToCancelCursorSignal raiseWith: errs errorString: errs first dbmsErrorString ].</body></methods><methods><class-id>Database.MySQLSession</class-id> <category>private-accessing</category><body package="MySQLEXDI">getStatementErrors		^self useStatementHandle		ifTrue: [self getStatementErrorsForStmt]		ifFalse: [self getStatementErrorsNoStmt]</body><body package="MySQLEXDI">getStatementErrorsExternal	"Return the most recent error code, or nil if none."	| xif errorMsg rc error |	xif := self xif.	rc := xif mysql_stmt_errno: self hstmt.	rc == xif SUCCESS ifFalse:		[ 	errorMsg := (xif mysql_stmt_error: self hstmt) copyCStringFromHeap.			error := self class errorClass new.	     	error dbmsErrorCode: rc.	     	error dbmsErrorString: errorMsg.	     	error sqlState: (xif mysql_stmt_sqlstate: self hstmt) copyCStringFromHeap.		( traceLevel &gt;= 2 ) ifTrue:			[self connection traceFunc: 'mysql_hstmt_error' result: errorMsg params: self hstmt ]].	^error</body><body package="MySQLEXDI">getStatementErrorsForStmt	"Return a collection of MySQLError(s) associated with the statement handle."	| errors err |	errors := OrderedCollection new.	"Many senders assume non-empty collection."	err := self getStatementErrorsExternal 				ifNil: [self connection class defaultError].	errors add: err.	^errors</body><body package="MySQLEXDI">getStatementErrorsNoStmt	"Return a collection of MySQLError(s) associated with the connection handle."	^self connection getConnectionErrors</body><body package="MySQLEXDI">hConn	^connection hConn</body><body package="MySQLEXDI">hResult	"Return the results pointer, used for iterating through the query results."	^self hResultHolder value</body><body package="MySQLEXDI">hResult: aResultsPointerOrNil 	"Save the results pointer, used for iterating through the query results."	^self hResultHolder value: aResultsPointerOrNil</body><body package="MySQLEXDI">hResultHolder	^hResultHolder</body><body package="MySQLEXDI">hResultHolder: anObject	hResultHolder := anObject</body><body package="MySQLEXDI">hstmt	^hstmtHolder value</body><body package="MySQLEXDI">hstmt: aCPointerOrNil	hstmtHolder value: aCPointerOrNil</body><body package="MySQLEXDI">isRowCountKnown: aBoolean	"True means we have either executed a query and		- retrieved the rowCount (which is only possible using fetchAllRowsAtOnce),		- or retrieved all the result rows individually, to the end of the stream."	isRowCountKnown := aBoolean</body><body package="MySQLEXDI">numParameters	^numParameters</body><body package="MySQLEXDI">numParameters: anObject	numParameters := anObject</body><body package="MySQLEXDI">resultsCache	"Answer the contents of the result cache.  Clear the cache."	| results |	results := resultsCache.	resultsCache := nil.	^results</body><body package="MySQLEXDI">resultsCache: results	"Cache results."	resultsCache := results</body><body package="MySQLEXDI">rowCount: aNumber	"Set using an Integer representing the number of rows affected by the previous query."	rowCount := aNumber</body><body package="MySQLEXDI">rowCountForAnswered		^self useStatementHandle		ifTrue: [self rowCountForAnsweredForStmt]		ifFalse: [self rowCountForAnsweredNoStmt]</body><body package="MySQLEXDI">rowCountForAnsweredForStmt	"Answer an Integer representing the number of rows returned by the previous query.	For SELECT statements, it is the number of rows returned. Valid only after the query	has been answered. Unlike mysql_stmt_affected_rows(), there is no error return value	for mysql_stmt_num_rows(), but a harmless check is made anyway."	| xif rc count |	xif := self xif.	self hstmt isNil ifTrue: [^nil].	rc := xif mysql_stmt_num_rows: self hstmt.	traceLevel &gt;= 2 		ifTrue: 			[self connection 				traceFunc: 'mysql_stmt_num_rows'				result: rc				params: self hstmt].	"This is declared by the api as an unsigned long long, but appears to be only a ulong."	rc highBit &gt;= 64 		ifTrue: [count := -1]		ifFalse: [count := xif signedFromUnsignedLong: rc].	"count == -1 		ifTrue: 			[| errs |			errs := self getStatementErrors.			self class connectionClass externalDatabaseErrorSignal raiseWith: errs				errorString: errs first dbmsErrorString]."	^count</body><body package="MySQLEXDI">rowCountForAnsweredNoStmt	"For the admin api, the same function call (mysql_affected_rows) works in both cases."	^self rowCountForNoAnswer</body><body package="MySQLEXDI">rowCountForNoAnswer		^self useStatementHandle		ifTrue: [self rowCountForNoAnswerForStmt]		ifFalse: [self rowCountForNoAnswerNoStmt]</body><body package="MySQLEXDI">rowCountForNoAnswerForStmt	"Answer an Integer representing the number of rows affected by the previous query.	For INSERT, UPDATE statements, it is the number of rows actually updated.	Valid only after the query has been answered."	| xif rc count |	xif := self xif.	self hstmt isNil ifTrue: [^nil].	rc := xif mysql_stmt_affected_rows: self hstmt.	traceLevel &gt;= 2 		ifTrue: 			[self connection 				traceFunc: 'mysql_stmt_affected_rows'				result: rc				params: self hstmt].	rc highBit &gt;= 64 		ifTrue: [count := -1]		ifFalse: [count := xif signedFromUnsignedLong: rc].	"Api says 64-bit, but here it's 32-bits valid."	"count == -1 		ifTrue: 			[| errs |			errs := self getStatementErrors.			self class connectionClass externalDatabaseErrorSignal raiseWith: errs				errorString: errs first dbmsErrorString]."	^count</body><body package="MySQLEXDI">rowCountForNoAnswerNoStmt	"Answer an Integer representing the number of rows affected by the previous query.	For INSERT, UPDATE statements, it is the number of rows actually updated.	For SELECT statements, it is the number of rows returned.	Valid only after the query has been answered. -1 means there was an error,	possibly because the call was made out of sequence."	| xif rc count |	xif := self xif.	self hConn isNil ifTrue: [^nil].	"rc := xif mysql_num_rows: self hConn."	rc := xif mysql_affected_rows: self hConn.	traceLevel &gt;= 2 		ifTrue: 			[self connection 				traceFunc: 'mysql_affected_rows'				result: rc				params: self hConn].	rc highBit &gt;= 64 		ifTrue: [count := -1]		ifFalse: [count := xif signedFromUnsignedLong: rc].	"Api says 64-bit, but here it's 32-bits valid."	"count == -1 		ifTrue: 			[| errs |			errs := self getStatementErrors.			self class connectionClass externalDatabaseErrorSignal raiseWith: errs				errorString: errs first dbmsErrorString]."	^count</body><body package="MySQLEXDI">setStatementAttributeExternal: type value: value	"Set the attribute. Make sure we allocate the correct C type for the given attribute type."	| rc arg |	arg := type = 0				ifTrue: [CIntegerType char gcMalloc]				ifFalse: [CIntegerType long gcMalloc].	arg contents: value.	rc := self xif				mysql_stmt_attr_set: self hstmt				attr_type: type				attr: arg.	traceLevel &gt;= 3		ifTrue: 			[self connection				traceFunc: 'mysql_stmt_attr_set'				result: rc				params: (Array						with: self hstmt						with: type						with: value)].	rc = self xif SUCCESS		ifFalse: 			[| errs |			errs := self getStatementErrors.			self class connectionClass unableToOpenCursorSignal raiseWith: errs				errorString: errs first dbmsErrorString]</body><body package="MySQLEXDI">setStatementAttributes	"There are three generalf attributes.		1. Always (or not) indicate the maximum length for each returned column 			when we describe answer columns.		2. Use a cursor to retrieve rows in blocks (of size blcockFactor).			Otherwise retrieve rows all at once, or singly--no cursor.		3. Specify the size of the blockFactor (if it has been enabled).	Currently, we use cursors, blockFactor, and indicate column max_length.	A failure in applying these settings results in an UnableToOpenCursor exception.	More detailed exceptions might be appropriate at some point."	| attributeTypes cursorTypes |	attributeTypes := self xif enum_stmt_attr_type.	cursorTypes := self xif enum_cursor_type.	self setStatementAttributeExternal: (attributeTypes memberNamed: #STMT_ATTR_UPDATE_MAX_LENGTH)		value: self xif TRUE.	self setStatementAttributeExternal:(attributeTypes memberNamed: #STMT_ATTR_CURSOR_TYPE)		value: (cursorTypes memberNamed: #CURSOR_TYPE_READ_ONLY).	self setStatementAttributeExternal: (attributeTypes memberNamed: #STMT_ATTR_PREFETCH_ROWS)		value: self blockFactor</body><body package="MySQLEXDI">useStatementHandle	^useStatementHandle</body></methods><methods><class-id>Database.MySQLSession</class-id> <category>private-execution</category><body package="MySQLEXDI">acquireExternal	"Acquire a statement handle. If nil, get the error report from the connection, since session errors need a valid statement handle."	| phstmt |	phstmt := self xif mysql_stmt_init: self connection hConn.	traceLevel &gt;= 3 		ifTrue: 			[self connection 				traceFunc: 'mysql_stmt_init'				result: phstmt				params: connection hConn].	phstmt isValid 		ifTrue: [self hstmt: phstmt]		ifFalse: 			[| errs |			errs := self connection getStatementErrors.			self class connectionClass unableToAllocateHandleSignal raiseWith: errs				errorString: errs first dbmsErrorString]</body><body package="MySQLEXDI">cancelExternal	"Handle cleanup when current query is cancelled."	^self</body><body package="MySQLEXDI">checkForMoreResults	"Return true if there are more results, false otherwise."		| xif rc |	self useStatementHandle		ifTrue: [self error: 'Statement handle-based query not expected.'].	xif := self xif.	rc := xif mysql_next_result: self hConn.	traceLevel &gt;= 3		ifTrue:			[self connection				traceFunc: 'mysql_next_result:'				result: rc				params: self hConn].	"rc=-1, no more results. rc=0: more results. rc&gt;0: there was an error."	rc &gt; 0		ifTrue:			[self class connectionClass unableToExecuteSQLSignal				raiseSignal:					#unableToRetrieveResults &lt;&lt; #mysql &gt;&gt; 'Unable to retrieve all results.'].	^rc = 0</body><body package="MySQLEXDI">dismissExternal	"Free allocated resources. This includes the statement handle.	Since this session maintains a statement handle for regular queries	and a results handle for the other kind of query, we need to free both	handles here, during cleanup."		self hasValidStatementHandle ifTrue: [self freeStatementExternal].	self hstmt: nil.	self freeResultHandle</body><body package="MySQLEXDI">executeExternal		^self useStatementHandle		ifTrue: [self executeExternalForStmt]		ifFalse: [self executeExternalNoStmt]</body><body package="MySQLEXDI">executeExternalAfterDescribe	"Execute the prepared SQL text."	| xif rc |	xif := self xif.	"Does the query text need to be sent to the server again?"	"self mustResendQuery ifTrue:		[ self prepareExternal.		  self mustResendQuery: false ]."	rc := xif mysql_stmt_execute: self hstmt.	traceLevel &gt;= 1 		ifTrue: 			[self connection 				traceFunc: 'mysql_stmt_execute'				result: rc				params: self hstmt].	rc = self xif SUCCESS 		ifFalse: [self resultsCache: self getStatementErrors]</body><body package="MySQLEXDI">executeExternalForStmt	"Set rowCount indicators prior to retrieval."	"Do not execute the prepared SQL text yet. Wait until column described!"	self rowCount: 0.	self isRowCountKnown: false.	^self</body><body package="MySQLEXDI">executeExternalNoStmt	"Execute the prepared SQL text."	| xif rc length sqlBa sqlBaPointer |	xif := self xif.	sqlBa := self query asByteArrayEncoding: self connection encoding.	sqlBaPointer := sqlBa gcCopyToHeap.	length := sqlBa size.	rc := xif 				mysql_real_query: self hConn				query: sqlBaPointer				length: length.	traceLevel &gt;= 1 		ifTrue: 			[self connection 				traceFunc: 'mysql_real_query'				result: rc				params: (Array 						with: self hConn						with: sqlBa						with: length)].	rc = self xif SUCCESS 		ifFalse: [self resultsCache: self getStatementErrors].	"Set rowCount indicators prior to retrieval."	self rowCount: 0.	self isRowCountKnown: false</body><body package="MySQLEXDI">fetchResult	"Fetch the handle to the result set."		| xif func pResult |	xif := self xif.	func := self class shouldFetchEntireResultAtOnceNoStmt		ifTrue: [#mysql_store_result:]		ifFalse: [#mysql_use_result:].	pResult := xif		perform: func		with: self hConn.	traceLevel &gt;= 3		ifTrue:			[self connection				traceFunc: func asString				result: pResult				params: self hConn].	self		hResult:			((self xif isValidCPointer: pResult)				ifTrue: [pResult]				ifFalse: [nil]).	"Check to ensure that there is a result set if one was expected."	(self hResult isNil and: [self getNumStatementColumns &gt; 0])		ifTrue:			[self class connectionClass unableToFetchDataSignal				raiseSignal:					#unableToFetchData &lt;&lt; #mysql &gt;&gt; 'Unable to fetch data.']</body><body package="MySQLEXDI">fetchRow	"Fetch the current row.  If no more rows, answer nil."	| xif pRow |	xif := self xif.	pRow := xif mysql_fetch_row: self hResult.	traceLevel &gt;= 3 		ifTrue: 			[self connection 				traceFunc: 'mysql_fetch_row'				result: pRow				params: self hResult].	^(self xif isValidCPointer: pRow)		ifFalse: 			["No more data."			nil]		ifTrue: [pRow]</body><body package="MySQLEXDI">freeStatementExternal	"Close the statement handle so the library can free related resources. The caller should formally reassign nil to my statement holder afterwards. According to MySQL, with the call to mysql_stmt_close(), the statement handle has been released and is no longer useable, regardless of the response code. In particular, we can no longer use that handle to fetch statement error codes and strings. Instead, use the connection's error facility."	| rc |	self hasValidStatementHandle ifFalse: [^self].	rc := self xif mysql_stmt_close: self hstmt.	traceLevel &gt;= 3		ifTrue: 			[self connection				traceFunc: 'mysql_stmt_close'				result: rc				params: self hstmt].	rc = self xif SUCCESS		ifFalse: 			[| errs |			errs := self connection getConnectionErrors.			self class connectionClass unableToFreeResourceSignal				raiseRequestWith: errs				errorString: errs first dbmsErrorString]</body><body package="MySQLEXDI">getParamCountExternal	"Get the parameter count from the statement just prepared.	If there are no parameters, the count will be zero."	| param_count |	param_count := self xif mysql_stmt_param_count: self hstmt.	traceLevel &gt;= 1 		ifTrue: 			[self connection 				traceFunc: 'mysql_stmt_param_count'				result: param_count				params: self hstmt].	^param_count</body><body package="MySQLEXDI">installExternal	super installExternal.	self hstmt: nil.	self hResult: nil.	self setMaxLongData: DefaultMaxLongData.</body><body package="MySQLEXDI">moreResultsExternal		^self useStatementHandle		ifTrue: [false]		ifFalse: [self checkForMoreResults]</body><body package="MySQLEXDI">readyExternal	"Answer whether or not the dbms has processed the SQL statement (batch).	Answer true, and let the client block."	^true</body><body package="MySQLEXDI">resultsExternal	"Retrieve any error information."	| errs sqlState |	(errs := self resultsCache) notNil ifTrue: [ 		1 to: errs size do: [ :position|			((sqlState := (errs at: position) sqlState asSymbol) == #'01000' 					or: [ sqlState  == #'S1000' ]) ifFalse: [ 				^self class connectionClass unableToExecuteSQLSignal 					raiseWith: errs errorString: (errs at: position) dbmsErrorString			]		].		self class connectionClass externalDatabaseInformationSignal signalWith: errs.	].	^true</body></methods><methods><class-id>Database.MySQLSession</class-id> <category>private-handles</category><body package="MySQLEXDI">hasValidStatementHandle	"Return true only if the allocated MYSQL_STMT data structure has a valid pointer."	^self xif isValidCPointer: self hstmt</body><body package="MySQLEXDI">isValidHandle: aHandle 	"Return true only if the handle is a valid pointer."	^aHandle isNil ifTrue: [false] ifFalse: [aHandle isValid]</body><body package="MySQLEXDI">xif	^self class xif</body></methods><methods><class-id>Database.MySQLSession</class-id> <category>data processing</category><body package="MySQLEXDI">isRowCountKnown	"Answer true if we have either executed a query and		- retrieved the rowCount (which is only possible using fetchAllRowsAtOnce),		- or retrieved all the result rows individually."	^isRowCountKnown</body><body package="MySQLEXDI">maxBufferSizeNeededDuringQuery	"Of all my buffers, return the largest size necessary for un-truncated retrieval."	| buffers |	buffers := rowBuffersHolder value.	^buffers inject: 0		into: [:max :buf | buf maxBufferSizeNeeded max: max]</body><body package="MySQLEXDI">maxLongData	"Return the maximum amount of data to be copied from LONGVARCHAR or LONGVARBINARY columns."	^maxLongData</body><body package="MySQLEXDI">prepare: aString	"Prepare a query string for processing. The useStatementHandle flag must	be updated only AFTER the previous buffers get released. See &gt;&gt;setupQuery:	methods which are invoked after &gt;&gt;startPrepare has released those buffers."	super prepare: aString.	self useStatementHandle ifTrue: [self setStatementAttributes]</body><body package="MySQLEXDI">rowCount	"Answer an Integer representing the number of rows affected by the previous query.	For INSERT, UPDATE statements, it is the number of rows actually updated.	For SELECT statements, it is the number of rows returned.	Valid only after the query has been answered."	^rowCount</body><body package="MySQLEXDI">setMaxLongData: anInteger	"Specify the maximum amount of data to be copied from LONGVARCHAR or LONGVARBINARY columns."	maxLongData := (self class defaultMaxLongData min: anInteger).</body></methods><methods><class-id>Database.MySQLSession</class-id> <category>private-finalization</category><body package="MySQLEXDI">executor	"Answer with an executor for the receiver--my shallow copy. It includes statementHolder, a ValueHolder, which points to my statement object, and a resultsHolder which is used for queries that don't use a statement handle."	| ex |	ex := super executor.	ex hstmtHolder: self hstmtHolder.	ex boundValueBuffersHolder: self boundValueBuffersHolder.	ex inputBufferPtrsArrayHolder: self inputBufferPtrsArrayHolder.	ex outputBufferPtrsArrayHolder: self outputBufferPtrsArrayHolder.	ex hResultHolder: self hResultHolder.	ex useStatementHandle: self useStatementHandle.	^ex</body><body package="MySQLEXDI">finalizeExternal	"Release all external resources"	self releaseBuffersAndAdaptors.	self releaseBindings.	"self hasValidStatementHandle ifFalse: [^self]. This is handled by &gt;&gt;dismissExternal."	traceLevel &gt;= 1 ifTrue: [self class trace: nil].	super finalizeExternal</body><body package="MySQLEXDI">key	"The hstmtHolder is unique to the session and is constant across pause/resume."	^self hstmtHolder</body></methods><methods><class-id>Database.MySQLSession</class-id> <category>private-buffer pointers array</category><body package="MySQLEXDI">freeBindArrays	"Free the memory used by the input and output buffer ptrs arrays."	(self connection notNil and: [ traceLevel &gt;= 3]) 		ifTrue: 			[self connection 				traceFunc: 'freeBindArrays'				result: 0				params: (Array with: (self inputBufferPtrsArray) with: (self outputBufferPtrsArray))].	self inputBufferPtrsArray ifNotNil: 			[self inputBufferPtrsArray isValid 				ifTrue: 					[self inputBufferPtrsArray free.					self inputBufferPtrsArray: nil]].	self outputBufferPtrsArray ifNotNil: 			[self outputBufferPtrsArray isValid 				ifTrue: 					[self outputBufferPtrsArray free.					self outputBufferPtrsArray: nil]]</body><body package="MySQLEXDI">generateBindArrayForInput	"MySQL doesn't individually bind a separate buffer pointer for each bound parameter.	Instead, it expects an array of MYSQL_BIND structs, each element of which has a	copy of the corresponding buffer's data pointer. For input parameters, the api will read	our buffers through the pointers it sees in the array, each array element (a struct)	is dedicated to a separate buffer."	self inputBufferPtrsArray: (self newBindArray: self numParameters)</body><body package="MySQLEXDI">generateBindArrayForOutput	"MySQL doesn't individually bind a separate buffer pointer for each returned column.	Instead, it expects an array of MYSQL_BIND structs, each element of which has a	copy of the corresponding buffer's data pointer. For each fetched row, the api will populate	our buffers through the pointers it sees in the array, each array element (a struct)	is dedicated to a separate buffer."	self outputBufferPtrsArray: (self newBindArray: self numColumns)</body><body package="MySQLEXDI">inputBufferPtrsArray	^inputBufferPtrsArrayHolder value</body><body package="MySQLEXDI">inputBufferPtrsArray: aCArrayObject	^inputBufferPtrsArrayHolder value: aCArrayObject</body><body package="MySQLEXDI">inputBufferPtrsArrayRefAt: indexMinusOne 	"Return a pointer to the corresponding element of the bufferPtrsArray."	(indexMinusOne &gt;= 0 and: [indexMinusOne &lt; self numParameters]) 		ifFalse: [self error: 'Bad parameter index.'].	^self inputBufferPtrsArray refAt: indexMinusOne</body><body package="MySQLEXDI">newBindArray: numElements 	"Allocate an array of MYSQL_BIND structs, each element of which can hold a	copy of the corresponding buffer's data pointer."	| mallocSelector bufferPtrsArray num |	num := numElements max: 1.	mallocSelector := self xif mallocSelector.	bufferPtrsArray := self xif MYSQL_BIND perform: mallocSelector with: num.	0 to: num - 1 do: [:i | (bufferPtrsArray refAt: i) zeroFill].	^bufferPtrsArray</body><body package="MySQLEXDI">outputBufferPtrsArray	^outputBufferPtrsArrayHolder value</body><body package="MySQLEXDI">outputBufferPtrsArray: aCArrayObject	^outputBufferPtrsArrayHolder value: aCArrayObject</body><body package="MySQLEXDI">outputBufferPtrsArrayRefAt: indexMinusOne 	"Return a pointer to the corresponding element of the bufferPtrsArray."	(indexMinusOne &gt;= 0 and: [indexMinusOne &lt; self numColumns]) 		ifFalse: [self error: 'Bad column index.'].	^self outputBufferPtrsArray refAt: indexMinusOne</body></methods><methods><class-id>Database.MySQLSession</class-id> <category>private-value holders</category><body package="MySQLEXDI">boundValueBuffersHolder	^boundValueBuffersHolder</body><body package="MySQLEXDI">boundValueBuffersHolder: aValueHolder	boundValueBuffersHolder := aValueHolder</body><body package="MySQLEXDI">hstmtHolder	^hstmtHolder</body><body package="MySQLEXDI">hstmtHolder: aValueHolder	hstmtHolder := aValueHolder</body><body package="MySQLEXDI">inputBufferPtrsArrayHolder	^inputBufferPtrsArrayHolder</body><body package="MySQLEXDI">inputBufferPtrsArrayHolder: anObject	inputBufferPtrsArrayHolder := anObject</body><body package="MySQLEXDI">outputBufferPtrsArrayHolder	^outputBufferPtrsArrayHolder</body><body package="MySQLEXDI">outputBufferPtrsArrayHolder: anObject	outputBufferPtrsArrayHolder := anObject</body></methods><methods><class-id>Database.MySQLSession</class-id> <category>private-binding</category><body package="MySQLEXDI">bindBufferPtrsForInput	"Tell api that this is the MYSQL_BIND array, with all the buffer pointers."	| rc |	rc := self xif mysql_stmt_bind_param: self hstmt bind: self inputBufferPtrsArray.	traceLevel &gt;= 3 		ifTrue: 			[self connection 				traceFunc: 'mysql_stmt_bind_param'				result: rc				params: (Array with: self hstmt with: self inputBufferPtrsArray)].	rc == self xif SUCCESS 		ifFalse: 			[| errs |			errs := self getStatementErrors.			self class connectionClass unableToBindSignal raiseWith: errs				errorString: errs first dbmsErrorString]</body><body package="MySQLEXDI">bindBufferPtrsForOutput	"Tell api that this is the MYSQL_BIND array, with all the buffer pointers."	| rc |	rc := self xif mysql_stmt_bind_result: self hstmt bind: self outputBufferPtrsArray.	traceLevel &gt;= 3 		ifTrue: 			[self connection 				traceFunc: 'mysql_stmt_bind_result'				result: rc				params: (Array with: self hstmt with: self outputBufferPtrsArray)].	rc == self xif SUCCESS 		ifFalse: 			[| errs |			errs := self getStatementErrors.			self class connectionClass unableToBindSignal raiseWith: errs				errorString: errs first dbmsErrorString]</body><body package="MySQLEXDI">bindExternal	^self useStatementHandle		ifTrue: [self bindExternalForStmt]		ifFalse: [self bindExternalNoStmt]</body><body package="MySQLEXDI">bindExternalForStmt	"Bind values to parameters in the query, avoiding unnecessary rebinding	where possible."	"For each bind marker in the query fragments, get the corresponding	value from the bindInput object. If the value isn't already bound, 	bind and remember it."	| leftToRightIndex numParams |	"Number of params MySQL expects from the query."	self numParameters: self getParamCountExternal.	"Number of params VW expects from the query."	numParams := (queryFragments size - 1) / 2.	numParams ~= self numParameters ifTrue:		[self class unableToBindSignal 			raiseSignal: #wrongNumberOfParameters &lt;&lt; #mysql &gt;&gt; 'Wrong number of parameters expected.'].	((self numParameters &gt; 0) and: [self inputBufferPtrsArray isNil]) ifTrue:		["Generate the array which holds copies of our buffer pointers. The library		will accept the buffer data through these pointers. Each buffer corresponds		to one index in the array."		self generateBindArrayForInput].	leftToRightIndex := 1.	2 to: queryFragments size by: 2 do:		[:index || bindMarker value |		bindMarker := queryFragments at: index.		value := self inBindInputAt: bindMarker.		"A bindMarker can be a symbol if the prepared SQL contained &lt;:name&gt;. Therefore we will have to manually specify a left-to-right index for our parameter positions"		self bindValue: value at: leftToRightIndex.		(self boundValueAt: bindMarker is: value) ifFalse:			[self bindValues at: bindMarker put: value].		leftToRightIndex := leftToRightIndex + 1].</body><body package="MySQLEXDI">bindExternalNoStmt	"There are no bound input values for queries that don't use statement handles.	Just perform the base class behavior."		^super bindExternal</body><body package="MySQLEXDI">bindValue: aValue at: position 	"Bind a value to a parameter position in the query. 	Re-use an existing buffer only if it is big enough.	An existing buffer can be too small if it holds a #String,	but the new value is a #LargeString, for example."	| buffer val |	self useStatementHandle ifFalse: [self error: 'Input binding is not available for this kind of query.'].	val := (aValue isKindOf: Stream) ifTrue: [aValue contents] ifFalse: [aValue].	buffer := self boundValueBuffers at: position ifAbsent: [nil].	buffer isNil ifFalse: [(buffer canHold: val)			ifFalse: 				[buffer free.				buffer := nil]].	buffer isNil		ifTrue: 			[buffer := self class bufferClassForStmt new						on: val						position: position						session: self.			buffer bindForInputValue: val.			self boundValueBuffers at: position put: buffer]		ifFalse: 			[buffer reUse: val]</body><body package="MySQLEXDI">boundValueBuffers	"Answer with the receiver's dictionary of bound rgbValue pointers (input parameters).	In some other EXDIs, this var is named bindValuePointers."	| bvph |	(bvph := self boundValueBuffersHolder) value isNil		ifTrue: [ bvph value: IdentityDictionary new ].	^bvph value</body><body package="MySQLEXDI">prepareExternal		^self useStatementHandle		ifTrue: [self prepareExternalForStmt]		ifFalse: [self prepareExternalNoStmt]</body><body package="MySQLEXDI">prepareExternalForStmt	"Prepare the server to execute a query."	| xif sql sqlBa sqlBaPointer rc sig |	xif := self xif.	"Assemble the query, substituting the correct parameter markers."	queryFragments size == 1 		ifTrue: [sql := queryFragments at: 1]		ifFalse: 			[| sqlStream |			sqlStream := (String new: query size) writeStream.			sqlStream nextPutAll: (queryFragments at: 1).			2 to: queryFragments size				by: 2				do: 					[:index | 					sqlStream						nextPut: $?;						nextPutAll: (queryFragments at: index + 1)].			sql := sqlStream contents].	"MySQL doesn't expect a ByteArray, but we want correct encoding."	sqlBa := sql asByteArrayEncoding: self connection encoding.	sqlBaPointer := sqlBa gcCopyToHeap.	rc := xif 				mysql_stmt_prepare: self hstmt				query: sqlBaPointer				length: sqlBa size.	traceLevel &gt;= 1 		ifTrue: 			[self connection 				traceFunc: 'mysql_stmt_prepare'				result: rc				params: (Array 						with: self hstmt						with: sql						with: sqlBa size)].	rc == xif SUCCESS 		ifFalse: 			[| errs |			errs := self getStatementErrors.			sig := (self class connectionClass 						signalForErrorCode: errs first dbmsErrorCode) 							ifNil: [self class connectionClass unableToPrepareSignal].			^sig raiseWith: errs errorString: errs first dbmsErrorString]</body><body package="MySQLEXDI">prepareExternalNoStmt	"With this kind of session, there is no prepare: simply execute the query."</body><body package="MySQLEXDI">releaseBindings	"If we have any, free our statement handle and our buffers."		| bvp |	self useStatementHandle		ifTrue:			[self freeBindArrays.			(bvp := self boundValueBuffersHolder value) notNil				ifTrue:					[bvp do: [:buffer | buffer notNil ifTrue: [buffer free]].					self boundValueBuffersHolder value: nil]].	super releaseBindings</body><body package="MySQLEXDI">setupQuery: aString	"Determine which type of query, based on the aString, then do usual setup."		self useStatementHandle: (self class isAnAdminQuery: aString) not.	^super setupQuery: aString</body><body package="MySQLEXDI">updateBuffers: pRow lengths: pFieldLengths 	"Retrieve the data for this row. pRow is a pointer to an array of pointers,	one for each returned column (field). A null pointer to data indicates a NULL	in that column."	| buffer pData length |	1 to: self numColumns		do: 			[:aColumn | 			pData := pRow at: aColumn - 1.			length := pFieldLengths at: aColumn - 1.			buffer := self rowBuffers at: aColumn.			buffer copyFromPointer: pData length: length]</body></methods><methods><class-id>Database.MySQLSession</class-id> <category>accessing</category><body package="MySQLEXDI">setupQueryWithoutBinding: aString	"Determine which type of query, based on the aString, then do usual setup."		self useStatementHandle: (self class isAnAdminQuery: aString) not.	^super setupQueryWithoutBinding: aString</body><body package="MySQLEXDI">useStatementHandle: anObject	useStatementHandle := anObject</body></methods><methods><class-id>Database.MySQLSession</class-id> <category>initialize-release</category><body package="MySQLEXDI">initialize	self useStatementHandle: true.	super initialize.	self setMaxLongData: self class defaultMaxLongData.	self rowCount: 0.	self isRowCountKnown: false.	hstmtHolder := nil asValue.	hResultHolder := nil asValue.	boundValueBuffersHolder := nil asValue.	inputBufferPtrsArrayHolder := nil asValue.	outputBufferPtrsArrayHolder := nil asValue.</body></methods><methods><class-id>Database.MySQLSession class</class-id> <category>accessing</category><body package="MySQLEXDI">bufferClassForStmt	"Answer the class to use for bindInput/Output objects associated with receiver."	^MySQLBuffer</body><body package="MySQLEXDI">bufferClassNoStmt	"Answer the class to use for bindInput/Output objects associated with receiver."	^MySQLAdminBuffer</body><body package="MySQLEXDI">connectionClass	"Answer the class to use for connection objects associated with receiver."	^MySQLConnection</body><body package="MySQLEXDI">defaultMaxLongData	^DefaultMaxLongData</body><body package="MySQLEXDI">defaultMaxLongData: anInteger	DefaultMaxLongData := anInteger</body><body package="MySQLEXDI">errorClass	"Answer the error class for the receiver."		^MySQLError</body><body package="MySQLEXDI">isAnAdminQuery: aString	"Return true if aString needs a MySQLAdminSession, i.e., it begins with any of these:	#('CREATE DATABASE'  'CREATE PROCEDURE'  'CREATE FUNCTION'  'CREATE USER' 'CREATE VIEW'		'CALL'  'USE'  'GRANT' 'SHOW GRANT'		'DROP DATABASE'  'DROP PROCEDURE'  'DROP FUNCTION'  'DROP USER')."		| noSpaces templates |	templates := #('CREATEDATABASE' 'CREATEPROCEDURE' 'CREATEFUNCTION' 'CREATEVIEW' 'CALL' 'USE' 'GRANT' 'SHOWGRANT' 'DROPDATABASE' 'DROPPROCEDURE' 'DROPFUNCTION' 'DROPUSER').	noSpaces := aString asUppercase copyWithout: $ .	^(templates		detect:			[:template | (noSpaces indexOfSubCollection: template startingAt: 1) = 1]		ifNone: [nil]) notNil</body><body package="MySQLEXDI">shouldFetchEntireResultAtOnceForStmt	"Return true to download all rows at once, false to download one row at a time.	Downloading all results at once can userp a lot of client memory for large result sets,	but this is the only way MySQL will tell you the rowCount before fetching every row."	"For statement handle-based queries, don't fetch all at once."	^false</body><body package="MySQLEXDI">shouldFetchEntireResultAtOnceNoStmt	"Return true to download all rows at once, false to download one row at a time.	Downloading all results at once can userp a lot of client memory for large result sets,	but this is the only way MySQL will tell you the rowCount before fetching every row."	"For statement handle-based queries, don't fetch all at once."	^true</body></methods><methods><class-id>Database.MySQLSession class</class-id> <category>private-registry</category><body package="MySQLEXDI">registry	^RegisteredMySQLSessions</body><body package="MySQLEXDI">registry: aCollection	RegisteredMySQLSessions := aCollection</body></methods><methods><class-id>Database.MySQLSession class</class-id> <category>class initialization</category><body package="MySQLEXDI">initialize	"MySQLBuffer initialize"	self initRegistry.	DefaultMaxLongData := 16777216.  "Default to 16 megs of long data"		"self initializeSQLStatementOptionConversionMap."	self install.</body></methods><methods><class-id>Database.MySQLSession class</class-id> <category>private-activation</category><body package="MySQLEXDI">install		self bufferClassForStmt install.	self bufferClassNoStmt install</body></methods><methods><class-id>Database.MySQLTransaction</class-id> <category>private-library calls</category><body package="MySQLEXDI">acquireExternal	^self</body><body package="MySQLEXDI">beginExternal	^self</body><body package="MySQLEXDI">commitExternal	^self</body><body package="MySQLEXDI">dismissExternal	^self</body><body package="MySQLEXDI">rollbackExternal	^self</body></methods><methods><class-id>Database.MySQLTransaction</class-id> <category>private-finalization</category><body package="MySQLEXDI">executor	^self shouldNotImplement</body><body package="MySQLEXDI">finalizeExternal	^self shouldNotImplement</body><body package="MySQLEXDI">key	^self shouldNotImplement</body></methods><methods><class-id>Database.MySQLTransaction class</class-id> <category>accessing</category><body package="MySQLEXDI">connectionClass	^MySQLConnection</body></methods><methods><class-id>Core.Integer</class-id> <category>private-mysql</category><body package="MySQLEXDI">mysqlConversion	"Answer the symbolic conversion name for instances of this 	class or subclasses."	^ObjectMemory is64Bit		ifTrue: 			[(self &gt;= -536870912 and: [self &lt;= 536870911])				ifTrue: [#Integer]				ifFalse: [#LargeInteger]]		ifFalse: [#Integer]</body></methods><methods><class-id>Core.String</class-id> <category>private-mysql</category><body package="MySQLEXDI">asBooleanForMySQL	"Try to interpret the string as a Boolean using a common Cobol paradigm.  Treat the value as null if it doesn't match the encoded value for true or false."	self size == 1 ifTrue:		[ self = 'Y' ifTrue: [ ^true ].		self = 'N' ifTrue: [ ^false ] ].	^nil</body></methods><methods><class-id>Core.Object</class-id> <category>private-mysql</category><body package="MySQLEXDI">mysqlConversion	"Answer the symbolic conversion name for instances of this 	class or subclasses.  The default is no conversion is defined"	^nil</body></methods><methods><class-id>Core.FixedPoint</class-id> <category>private-mysql</category><body package="MySQLEXDI">mysqlConversion	"Answer the symbolic conversion name for instances of this 	class or subclasses."	^#FixedPoint</body></methods><methods><class-id>Core.ByteArray</class-id> <category>private-mysql</category><body package="MySQLEXDI">mysqlConversion	"Answer the symbolic conversion name for instances of this 	class or subclasses."	self size &gt; 255 ifTrue: [^#LargeByteArray].	^#ByteArray</body></methods><methods><class-id>Core.LargeInteger</class-id> <category>private-mysql</category><body package="MySQLEXDI">mysqlConversion	"Answer the symbolic conversion name for instances of this 	class or subclasses."	^#LargeInteger</body></methods><methods><class-id>Core.Double</class-id> <category>private-mysql</category><body package="MySQLEXDI">mysqlConversion	"Answer the symbolic conversion name for instances of this 	class or subclasses."	^#Double</body></methods><methods><class-id>Core.Timestamp</class-id> <category>private-mysql</category><body package="MySQLEXDI">mysqlConversion	"Answer the symbolic conversion name for instances of this class 	or subclasses."	^#Timestamp</body></methods><methods><class-id>Core.SmallDouble</class-id> <category>private-mysql</category><body package="MySQLEXDI">mysqlConversion	"Answer the symbolic conversion name for instances of this 	class or subclasses."	^#Double</body></methods><methods><class-id>Core.Boolean</class-id> <category>private-mysql</category><body package="MySQLEXDI">mysqlConversion	"Answer the symbolic conversion name for instances of this 	class or subclasses."	^#Boolean</body><body package="MySQLEXDI">printStringForMySQL	"Encode receiver in one character using a common Cobol paradigm."	^self ifTrue: [ 'Y' ] ifFalse: [ 'N' ]</body></methods><methods><class-id>Core.Time</class-id> <category>private-mysql</category><body package="MySQLEXDI">mysqlConversion	"Answer the symbolic conversion name for instances of this 	class or subclasses."	^#Time</body></methods><methods><class-id>Core.Float</class-id> <category>private-mysql</category><body package="MySQLEXDI">mysqlConversion	"Answer the symbolic conversion name for instances of this 	class or subclasses."	^#Float</body></methods><methods><class-id>Core.Date</class-id> <category>private-mysql</category><body package="MySQLEXDI">mysqlConversion	"Answer the symbolic conversion name for instances of this 	class or subclasses."	^#Date</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>private-mysql</category><body package="MySQLEXDI">mysqlConversion	"Answer the symbolic conversion name for instances of this 	class or subclasses."	self size &gt; 255 ifTrue: [^#LargeString].	^#String</body></methods><initialize><class-id>Database.MySQLInterface</class-id></initialize><initialize><class-id>Database.MySQLConnection</class-id></initialize><initialize><class-id>Database.MySQLBuffer</class-id></initialize><initialize><class-id>Database.MySQLAdminBuffer</class-id></initialize><initialize><class-id>Database.MySQLSession</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Float</name><environment>Core</environment><super>Core.LimitedPrecisionReal</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Date</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>day year </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>CharacterArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>ExternalDatabaseBuffer</name><environment>Database</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>databaseType encoding elementSize count bufferPointer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><class><name>ExternalDatabaseException</name><environment>Database</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><class><name>ExternalInterface</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>includeFiles includeDirectories libraryFiles libraryDirectories virtual optimizationLevel </class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>External-Interface</category><attributes><package>External-Interface</package></attributes></class><class><name>ExternalDatabaseColumnDescription</name><environment>Database</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name index type length precision scale nullable </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><class><name>Timestamp</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>year month day hours minutes seconds milliseconds partialNanosecond </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>ExternalDatabaseSession</name><environment>Database</environment><super>Database.ExternalDatabaseFramework</super><private>false</private><indexed-type>none</indexed-type><inst-vars>connection query queryFragments bindInput bindTemplate bindOutput useNamedOutputBinding bindValues resultTemplate allocateForEachRow blockFactor numColumns columnDescriptions rowAdaptors rowBuffersHolder bufferIndex answerStream currentRow scrollable needBinding </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><class><name>Set</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>tally </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>Boolean</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Time</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hours minutes seconds milliseconds partialNanosecond </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>ExternalDatabaseConnection</name><environment>Database</environment><super>Database.ExternalDatabaseFramework</super><private>false</private><indexed-type>none</indexed-type><inst-vars>transaction username password environment transactionCoordinator cachedSession isolationLevel encoding </inst-vars><class-inst-vars>environmentMap xif xifMap dependents </class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><class><name>SmallDouble</name><environment>Core</environment><super>Core.LimitedPrecisionReal</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Double</name><environment>Core</environment><super>Core.LimitedPrecisionReal</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>ByteArray</name><environment>Core</environment><super>Core.IntegerArray</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>ExternalDatabaseError</name><environment>Database</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dbmsErrorCode dbmsErrorString osErrorCode osErrorString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><class><name>ExternalDatabaseTransaction</name><environment>Database</environment><super>Database.ExternalDatabaseFramework</super><private>false</private><indexed-type>none</indexed-type><inst-vars>memberCountHolder remainingCountHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>Integer</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>ExternalDatabaseResumableException</name><environment>Database</environment><super>Database.ExternalDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><class><name>FixedPoint</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars>numerator denominator scale </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>LargeInteger</name><environment>Core</environment><super>Core.Integer</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class></st-source>