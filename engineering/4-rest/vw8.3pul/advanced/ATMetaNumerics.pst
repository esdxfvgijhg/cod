<?xml version="1.0"?><st-source><!-- Name: AT MetaNumericsNotice: Copyright 1999-2013 Cincom Systems, Inc.  All rights reserved.Comment: Provides support classes for applications requiring advanced mathematical constructs such as complex numbers and infinity.DbIdentifier: bear73DbTrace: 400369DbUsername: nrossDbVersion: 7.10 - 1PackageName: AT MetaNumericsParcel: #('AT MetaNumerics')ParcelName: AT MetaNumericsPrintStringCache: (7.10 - 1,nross)Version: 7.10 - 1Date: 6:37:50 AM April 3, 2013 --><time-stamp>From VisualWorksÂ®, Pre-Release 7.10 (mar13.5) of April 3, 2013 on April 3, 2013 at 6:37:50 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>MetaNumeric</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers-MetaNumeric</category><attributes><package>AT MetaNumerics</package></attributes></class><comment><class-id>Core.MetaNumeric</class-id><body>MetaNumeric is the abstract superclass for unrepresentable numbers.  These include Infinity (very large numbers), Infinitesimal (very tiny numbers), and NotANumber (undefinable values).  In addition, the class SomeNumber represents finitely expressible numbers in the domain of MetaNumerics, so that coercion is possible if necessary.</body></comment><class><name>SomeNumber</name><environment>Core</environment><super>Core.MetaNumeric</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers-MetaNumeric</category><attributes><package>AT MetaNumerics</package></attributes></class><comment><class-id>Core.SomeNumber</class-id><body>SomeNumber represents a nonMetaNumeric scalar Number coerced into the MetaNumeric domain.  SomeNumbers respond to numeric protocol the same way that their values would, except that their generality is that of other MetaNumerics, and they know how to perform computations relative to MetaNumeric values.Instance variables:	value		&lt;Number&gt; the number that this instance represents</body></comment><class><name>Infinitesimal</name><environment>Core</environment><super>Core.MetaNumeric</super><private>false</private><indexed-type>none</indexed-type><inst-vars>negative </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers-MetaNumeric</category><attributes><package>AT MetaNumerics</package></attributes></class><comment><class-id>Core.Infinitesimal</class-id><body>Infinitesimals represent numbers so close to zero that they are unrepresentable in more conventional forms.  Infinitesimal may be thought of as the reciprocal of Infinity.  As a parallel to the description of Infinity, we show descriptions of the behavior of infinitesimals.  The symbols +tiny and -tiny are used to represent positive and negative infinitesimals.	x + +tiny = x   when x ~= 0.	0 + +tiny = +tiny	x * +tiny = +tiny  when x &gt; 0	x * -tiny = -tiny  when x &gt; 0	0 * +tiny = 0	+tiny + +tiny = +tiny	-tiny - +tiny = -tiny	+tiny * (+/-)tiny = (+/-)tiny	-tiny * (+/-)tiny = (-/+)tiny	+tiny - +tiny = undefined value, and an error occursIn addition, the following holds true:	x / +infinity = +tiny  for x &gt; 0	x / +tiny = +infinity  for x &gt; 0	+tiny * +infinity = undefined value, and an error occursLoosely speaking, +tiny is not a single value, but a set of all real numbers that are unrepresentably small.  Therefore, it makes no sense to ask whether +tiny = +tiny, and if you do, an error will occur.+tiny and -tiny are referenced in code via the expressions 'Infinitesimal positive' and 'Infinitesimal negative'.Instance variables	negative	&lt;Boolean&gt; whether the value is greater or less than zeroClass Variables	Negative	&lt;Infinitesimal&gt; the value representing -tiny	Positive		&lt;Infinitesimal&gt; the value representing +tiny</body></comment><class><name>Complex</name><environment>Core</environment><super>Core.ArithmeticValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars>real imaginary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>AT MetaNumerics</package></attributes></class><comment><class-id>Core.Complex</class-id><body>This is an implementation of complex numbers.  A complex number has real and imaginary parts which must be manipulated simultaneously in any numeric processing.  Complex numbers can be used in many of the same places that regular numbers can be used with one major exception of comparisons, since complex numbers cannot be directly compared for size (except through lengths of vectors (see absolute value)).Instance variables:	real			&lt;Number&gt; the part of the number which can be expressed as a Real number	imaginary	&lt;Number&gt; the part of the number which, in terms of how the number behaves,					has been multiplied by 'i' (-1 sqrt)</body></comment><class><name>NotANumber</name><environment>Core</environment><super>Core.MetaNumeric</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers-MetaNumeric</category><attributes><package>AT MetaNumerics</package></attributes></class><comment><class-id>Core.NotANumber</class-id><body>NotANumbers are very poor citizens of the number-object world.  They are basically placeholders that indicate that an illegal mathematical operation occurred at some unknown point in the past.  An application may generate NotANumbers when such operations occur as taking the square root of -729, computing the arcSin of 8, etc.</body></comment><class><name>Infinity</name><environment>Core</environment><super>Core.MetaNumeric</super><private>false</private><indexed-type>none</indexed-type><inst-vars>negative </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers-MetaNumeric</category><attributes><package>AT MetaNumerics</package></attributes></class><comment><class-id>Core.Infinity</class-id><body>It is occasionally convenient to support a class of numbers known as the "extended real numbers".  These include the real numbers as well as two new values, which are here referred to as +infinity and -infinity.  For any real number x, the operator &lt; is defined so that -infinity &lt; x &lt; +infinity.  Further,	x + +infinity = +infinity	x - +infinity = -infinity	x * +infinity = +infinity  when x &gt; 0	x * -infinity = -infinity  when x &gt; 0	0 * +infinity = 0	+infinity + +infinity = +infinity	-infinity - +infinity = -infinity	+infinity * (+/-)infinity = (+/-)infinity	-infinity * (+/-)infinity = (-/+)infinity	+infinity - +infinity = undefined value, and an error occursLoosely speaking, +infinity is not a single value, but a set of all real numbers that are unrepresentably large.  Therefore, it makes no sense to ask whether +infinity = +infinity, and if you do, an error will occur.+infinity and -infinity are referenced in code via the expressions 'Infinity positive' and 'Infinity negative'.Instance variables	negative	&lt;Boolean&gt; whether the value is greater or less than zeroClass Variables	Negative	&lt;Infinity&gt; the value representing -infinity	Positive		&lt;Infinity&gt; the value representing +infinity</body></comment><shared-variable><name>Positive</name><environment>Core.Infinity</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>AT MetaNumerics</package></attributes></shared-variable><shared-variable><name>Negative</name><environment>Core.Infinity</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>AT MetaNumerics</package></attributes></shared-variable><shared-variable><name>Positive</name><environment>Core.Infinitesimal</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>AT MetaNumerics</package></attributes></shared-variable><shared-variable><name>Negative</name><environment>Core.Infinitesimal</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>AT MetaNumerics</package></attributes></shared-variable><methods><class-id>Core.MetaNumeric</class-id> <category>double dispatching</category><body package="AT MetaNumerics">differenceFromDouble: aDouble	^self differenceFromSomeNumber: aDouble asMetaNumber</body><body package="AT MetaNumerics">differenceFromFloat: aFloat	^self differenceFromSomeNumber: aFloat asMetaNumber</body><body package="AT MetaNumerics">differenceFromFraction: aFraction	^self differenceFromSomeNumber: aFraction asMetaNumber</body><body package="AT MetaNumerics">differenceFromInteger: anInteger	^self differenceFromSomeNumber: anInteger asMetaNumber</body><body package="AT MetaNumerics">equalFromDouble: aDouble	^self equalFromSomeNumber: aDouble asMetaNumber</body><body package="AT MetaNumerics">equalFromFloat: aFloat	^self equalFromSomeNumber: aFloat asMetaNumber</body><body package="AT MetaNumerics">equalFromFraction: aFraction	^self equalFromSomeNumber: aFraction asMetaNumber</body><body package="AT MetaNumerics">equalFromInteger: anInteger	^self equalFromSomeNumber: anInteger asMetaNumber</body><body package="AT MetaNumerics">lessFromDouble: aDouble	^self lessFromSomeNumber: aDouble asMetaNumber</body><body package="AT MetaNumerics">lessFromFloat: aFloat	^self lessFromSomeNumber: aFloat asMetaNumber</body><body package="AT MetaNumerics">lessFromFraction: aFraction	^self lessFromSomeNumber: aFraction asMetaNumber</body><body package="AT MetaNumerics">lessFromInteger: anInteger	^self lessFromSomeNumber: anInteger asMetaNumber</body><body package="AT MetaNumerics">productFromDouble: aDouble	^self productFromSomeNumber: aDouble asMetaNumber</body><body package="AT MetaNumerics">productFromFloat: aFloat	^self productFromSomeNumber: aFloat asMetaNumber</body><body package="AT MetaNumerics">productFromFraction: aFraction	^self productFromSomeNumber: aFraction asMetaNumber</body><body package="AT MetaNumerics">productFromInteger: anInteger	^self productFromSomeNumber: anInteger asMetaNumber</body><body package="AT MetaNumerics">quotientFromDouble: aDouble	^self quotientFromSomeNumber: aDouble asMetaNumber</body><body package="AT MetaNumerics">quotientFromFloat: aFloat	^self quotientFromSomeNumber: aFloat asMetaNumber</body><body package="AT MetaNumerics">quotientFromFraction: aFraction	^self quotientFromSomeNumber: aFraction asMetaNumber</body><body package="AT MetaNumerics">quotientFromInteger: anInteger	^self quotientFromSomeNumber: anInteger asMetaNumber</body><body package="AT MetaNumerics">sumFromDouble: aDouble	^self sumFromSomeNumber: aDouble asMetaNumber</body><body package="AT MetaNumerics">sumFromFloat: aFloat	^self sumFromSomeNumber: aFloat asMetaNumber</body><body package="AT MetaNumerics">sumFromFraction: aFraction	^self sumFromSomeNumber: aFraction asMetaNumber</body><body package="AT MetaNumerics">sumFromInteger: anInteger	^self sumFromSomeNumber: anInteger asMetaNumber</body></methods><methods><class-id>Core.MetaNumeric</class-id> <category>coercing</category><body package="AT MetaNumerics">coerce: aNumber	^aNumber asMetaNumber</body><body package="AT MetaNumerics">generality	^120</body></methods><methods><class-id>Core.MetaNumeric</class-id> <category>converting</category><body package="AT MetaNumerics">asDouble	"Answer a Double that approximates the receiver."	^Number		raise: #coercionErrorSignal		receiver: self		selector: #asDouble		errorString: (#CannotCoerceMetaNumericToDouble &lt;&lt; #advanced &gt;&gt; 'Can''t coerce a MetaNumeric to a Double')</body><body package="AT MetaNumerics">asFloat	"Answer a Float that approximates the receiver."	^Number		raise: #coercionErrorSignal		receiver: self		selector: #asFloat		errorString: (#CannotCoerceMetaNumericToFloat &lt;&lt; #advanced &gt;&gt; 'Can''t coerce a MetaNumeric to a Float')</body><body package="AT MetaNumerics">asInteger	"Answer a Integer that approximates the receiver."	^Number		raise: #coercionErrorSignal		receiver: self		selector: #asInteger		errorString: (#CannotCoerceMetaNumericToInteger &lt;&lt; #advanced &gt;&gt; 'Can''t coerce a MetaNumeric to an Integer')</body><body package="AT MetaNumerics">asMetaNumber	"Represent the number as a MetaNumeric"	^self</body><body package="AT MetaNumerics">asRational	"Answer a Rational number that approximates the receiver."	^Number		raise: #coercionErrorSignal		receiver: self		selector: #asRational		errorString: (#CannotCoerceMetaNumericToRational &lt;&lt; #advanced &gt;&gt; 'Can''t coerce a MetaNumeric to a Rational')</body></methods><methods><class-id>Core.MetaNumeric</class-id> <category>private</category><body package="AT MetaNumerics">printOn: aStream printPolicy: aNumberPrintPolicy	^self printOn: aStream</body></methods><methods><class-id>Core.MetaNumeric</class-id> <category>comparing</category><body package="AT MetaNumerics">hash	^self class hash</body></methods><methods><class-id>Core.MetaNumeric class</class-id> <category>constants access</category><body package="AT MetaNumerics">unity	"Answer the value which allows, for any given arithmetic value, the following to be true		aNumber * aNumber class unity = aNumber	This must be true regardless of how a given subclass chooses to define #*"	^SomeNumber from: 1</body><body package="AT MetaNumerics">zero	"Answer the value which allows, for any given arithmetic value, the following to be true		aNumber + aNumber class zero = aNumber	This must be true regardless of how a given subclass chooses to define #+"	^SomeNumber from: 0</body></methods><methods><class-id>Core.SomeNumber</class-id> <category>converting</category><body package="AT MetaNumerics">asDouble	"Answer a Double that represents the receiver."	^value asDouble</body><body package="AT MetaNumerics">asFixedPoint: newScale	"Answer a FixedPoint that represents the receiver."	^value asFixedPoint: newScale</body><body package="AT MetaNumerics">asFloat	"Answer a Float that represents the receiver."	^value asFloat</body><body package="AT MetaNumerics">asRational	"Answer a Rational number that represents the receiver."	^value asRational</body><body package="AT MetaNumerics">reduceGeneralityIfPossible	"Answer the receiver transformed to a lower generality, if such a 	transformation is possible without losing information. If not, answer 	the receiver"	^value</body></methods><methods><class-id>Core.SomeNumber</class-id> <category>double dispatching</category><body package="AT MetaNumerics">differenceFromInfinitesimal: aNumber	value = 0		ifTrue:	[^aNumber]		ifFalse:	[^value negated]</body><body package="AT MetaNumerics">differenceFromInfinity: aNumber	^aNumber</body><body package="AT MetaNumerics">differenceFromSomeNumber: aNumber	^aNumber numericValue - value</body><body package="AT MetaNumerics">equalFromInfinitesimal: aNumber	^false</body><body package="AT MetaNumerics">equalFromInfinity: aNumber	^false</body><body package="AT MetaNumerics">equalFromSomeNumber: aNumber	^aNumber numericValue = value</body><body package="AT MetaNumerics">lessFromInfinitesimal: aNumber	value = 0		ifTrue:	[^aNumber negative].	^self positive</body><body package="AT MetaNumerics">lessFromInfinity: aNumber	^aNumber negative</body><body package="AT MetaNumerics">lessFromSomeNumber: aNumber	^aNumber numericValue &lt; value</body><body package="AT MetaNumerics">productFromInfinitesimal: aNumber	value = 0		ifTrue:	[^0].	^value negative		ifTrue:	[aNumber negated]		ifFalse:	[aNumber]</body><body package="AT MetaNumerics">productFromInfinity: aNumber	value = 0		ifTrue:	[^0].	^value negative		ifTrue:	[aNumber negated]		ifFalse:	[aNumber]</body><body package="AT MetaNumerics">productFromSomeNumber: aNumber	^aNumber numericValue * value</body><body package="AT MetaNumerics">quotientFromInfinitesimal: aNumber 	value = 0 ifTrue: [^self class			raise: #divisionByZeroSignal			receiver: aNumber			selector: #/			arg: self			errorString: (#CannotDivideANumberByZero &lt;&lt; #advanced &gt;&gt; 'Can''t divide a number by zero')].	^value negative		ifTrue: [aNumber negated]		ifFalse: [aNumber]</body><body package="AT MetaNumerics">quotientFromInfinity: aNumber	value = 0 ifTrue: [^self class			raise: #divisionByZeroSignal			receiver: aNumber			selector: #/			arg: self			errorString: (#CannotDivideANumberByZero &lt;&lt; #advanced &gt;&gt; 'Can''t divide a number by zero')].	^value negative		ifTrue:	[aNumber negated]		ifFalse:	[aNumber]</body><body package="AT MetaNumerics">quotientFromSomeNumber: aNumber	^aNumber numericValue / value</body><body package="AT MetaNumerics">sumFromInfinitesimal: aNumber	value = 0		ifTrue:	[^aNumber]		ifFalse:	[^value]</body><body package="AT MetaNumerics">sumFromInfinity: aNumber	^aNumber</body><body package="AT MetaNumerics">sumFromSomeNumber: aNumber	^aNumber numericValue + value</body></methods><methods><class-id>Core.SomeNumber</class-id> <category>arithmetic</category><body package="AT MetaNumerics">* aNumber 	"Answer the result of multiplying the receiver by the argument, aNumber."	^aNumber productFromSomeNumber: self</body><body package="AT MetaNumerics">+ aNumber 	"Answer the sum of the receiver and the argument, aNumber."	^aNumber sumFromSomeNumber: self</body><body package="AT MetaNumerics">- aNumber 	"Answer the difference between the receiver and aNumber."	^aNumber differenceFromSomeNumber: self</body><body package="AT MetaNumerics">/ aNumber 	"Answer the result of dividing receiver by aNumber."	^aNumber quotientFromSomeNumber: self</body></methods><methods><class-id>Core.SomeNumber</class-id> <category>printing</category><body package="AT MetaNumerics">printOn: aStream 	"Print the receiver on the stream, aStream.	Numbers print in a form recognized by the compiler."	value printOn: aStream</body><body package="AT MetaNumerics">printOn: aStream printPolicy: aNumberPrintPolicy	"Print the number on the stream. Use the	print policy to control rendering choices,	like what the decimal point is."	^value printOn: aStream printPolicy: aNumberPrintPolicy</body></methods><methods><class-id>Core.SomeNumber</class-id> <category>comparing</category><body package="AT MetaNumerics">&lt; aNumber	^aNumber lessFromSomeNumber: self</body><body package="AT MetaNumerics">= aNumber 	"Compare the receiver and aNumber"	^aNumber respondsToArithmetic and: [aNumber equalFromSomeNumber: self]</body><body package="AT MetaNumerics">hash	"Answer a SmallInteger that is equal to the hash value of 	any object that is equal to (=) the receiver. 	When two objects are not =, their hash values may or may not be the same.	The hash value may change based on the receiver's contents."	^value hash</body></methods><methods><class-id>Core.SomeNumber</class-id> <category>private</category><body package="AT MetaNumerics">setValue: aValue	value := aValue</body></methods><methods><class-id>Core.SomeNumber</class-id> <category>accessing</category><body package="AT MetaNumerics">numericValue	"Represent the receiver as a non-meta scalar quantity"	^value</body></methods><methods><class-id>Core.SomeNumber</class-id> <category>testing</category><body package="AT MetaNumerics">isZero	"Answer whether 'self = self class zero'.  We can't use #= because	#= is defined in terms of #isZero"	^value isZero</body></methods><methods><class-id>Core.SomeNumber</class-id> <category>truncation and round off</category><body package="AT MetaNumerics">truncated	"Answer an integer nearest the receiver toward zero."	^value truncated</body></methods><methods><class-id>Core.SomeNumber class</class-id> <category>instance creation</category><body package="AT MetaNumerics">from: aValue	"Create a wrapper around the given number that allows it to masquerade as a MetaNumber"	^self basicNew setValue: aValue</body></methods><methods><class-id>Core.Infinitesimal</class-id> <category>double dispatching</category><body package="AT MetaNumerics">differenceFromInfinitesimal: aNumber 	self negative ~= aNumber negative		ifTrue: [^aNumber]		ifFalse: [^self class				raise: #domainErrorSignal				receiver: aNumber				selector: #-				arg: self				errorString: (#CannotComputeDifferenceOfInfinitesimalsOfLikeSign &lt;&lt; #advanced &gt;&gt; 'Can''t compute the difference of Infinitesimals of like sign')]</body><body package="AT MetaNumerics">differenceFromInfinity: aNumber	^aNumber</body><body package="AT MetaNumerics">differenceFromSomeNumber: aNumber	aNumber isZero		ifTrue:	[^self negated].	^aNumber numericValue</body><body package="AT MetaNumerics">equalFromInfinitesimal: aNumber 	aNumber negative = self negative		ifTrue: [^self class				raise: #unorderedSignal				receiver: aNumber				selector: #=				arg: self				errorString: (#CannotCompareInfinitesimalsOfLikeSign &lt;&lt; #advanced &gt;&gt; 'Can''t compare Infinitesimals of like sign')]		ifFalse: [^false]</body><body package="AT MetaNumerics">equalFromInfinity: aNumber	^false</body><body package="AT MetaNumerics">equalFromSomeNumber: aNumber	^false</body><body package="AT MetaNumerics">lessFromInfinitesimal: aNumber 	aNumber negative = self negative		ifTrue: [^self class				raise: #unorderedSignal				receiver: aNumber				selector: #&lt;				arg: self				errorString: (#CannotCompareInfinitesimalsOfLikeSign &lt;&lt; #advanced &gt;&gt; 'Can''t compare Infinitesimals of like sign')]		ifFalse: [^aNumber negative]</body><body package="AT MetaNumerics">lessFromInfinity: aNumber	^aNumber negative</body><body package="AT MetaNumerics">lessFromSomeNumber: aNumber	aNumber isZero		ifTrue:	[^self positive].	^aNumber negative</body><body package="AT MetaNumerics">productFromInfinitesimal: aNumber 	self negative		ifTrue: [^aNumber negated]		ifFalse: [^aNumber]</body><body package="AT MetaNumerics">productFromInfinity: aNumber	^self class		raise: #domainErrorSignal		receiver: aNumber		selector: #*		arg: self		errorString: (#ProductOfInfinityAndInfinitesimalIsUndefined &lt;&lt; #advanced &gt;&gt; 'The product of Infinity and Infinitesimal is undefined')</body><body package="AT MetaNumerics">productFromSomeNumber: aNumber	aNumber isZero		ifTrue:	[^0].	aNumber negative		ifTrue:	[^self negated]		ifFalse:	[^self]</body><body package="AT MetaNumerics">quotientFromInfinitesimal: aNumber 	^self class		raise: #domainErrorSignal		receiver: aNumber		selector: #/		arg: self		errorString: (#CannotDivideInfinitesimalByInfinitesimal &lt;&lt; #advanced &gt;&gt; 'Can''t divide an Infinitesimal by an Infinitesimal')</body><body package="AT MetaNumerics">quotientFromInfinity: aNumber 	self negative		ifTrue:	[^aNumber negated]		ifFalse:	[^aNumber]</body><body package="AT MetaNumerics">quotientFromSomeNumber: aNumber 	aNumber isZero		ifTrue:	[^0].	^Infinity negative: aNumber negative ~= self negative</body><body package="AT MetaNumerics">sumFromInfinitesimal: aNumber 	self negative = aNumber negative		ifTrue: [^aNumber]		ifFalse: [^self class				raise: #domainErrorSignal				receiver: aNumber				selector: #+				arg: self				errorString: (#CannotAddInfinitesimalsOfDifferingSign &lt;&lt; #advanced &gt;&gt; 'Can''t add Infinitesimals of differing signs')]</body><body package="AT MetaNumerics">sumFromInfinity: aNumber	^aNumber</body><body package="AT MetaNumerics">sumFromSomeNumber: aNumber	aNumber isZero		ifTrue:	[^self].	^aNumber numericValue</body></methods><methods><class-id>Core.Infinitesimal</class-id> <category>arithmetic</category><body package="AT MetaNumerics">* aNumber 	"Multiply aNumber by the receiver"	^aNumber productFromInfinitesimal: self</body><body package="AT MetaNumerics">+ aNumber 	"Add the receiver to aNumber"	^aNumber sumFromInfinitesimal: self</body><body package="AT MetaNumerics">- aNumber 	"Subtract aNumber from the receiver"	^aNumber differenceFromInfinitesimal: self</body><body package="AT MetaNumerics">/ aNumber 	"Divide the receiver by aNumber"	^aNumber quotientFromInfinitesimal: self</body><body package="AT MetaNumerics">negated	^self class negative: negative == false</body></methods><methods><class-id>Core.Infinitesimal</class-id> <category>testing</category><body package="AT MetaNumerics">isZero	"Answer whether 'self = self class zero'.  We can't use #= because	#= is defined in terms of #isZero"	^false</body><body package="AT MetaNumerics">negative	"Answer whether the receiver is less than zero"	^negative</body><body package="AT MetaNumerics">positive	"Answer whether the receiver is greater than zero"	^negative == false</body></methods><methods><class-id>Core.Infinitesimal</class-id> <category>comparing</category><body package="AT MetaNumerics">&lt; aNumber 	"Compare the receiver and aNumber"	^aNumber lessFromInfinitesimal: self</body><body package="AT MetaNumerics">= aNumber 	"Compare the receiver and aNumber"	^aNumber respondsToArithmetic and: [aNumber equalFromInfinitesimal: self]</body></methods><methods><class-id>Core.Infinitesimal</class-id> <category>converting</category><body package="AT MetaNumerics">asDouble	"Answer a Double that approximates the receiver."	^0.0d</body><body package="AT MetaNumerics">asFixedPoint: newScale	"Answer a Double that approximates the receiver."	^0 asFixedPoint: newScale</body><body package="AT MetaNumerics">asFloat	"Answer a Float that approximates the receiver."	^0.0</body></methods><methods><class-id>Core.Infinitesimal</class-id> <category>private</category><body package="AT MetaNumerics">negative: aBoolean	negative := aBoolean</body></methods><methods><class-id>Core.Infinitesimal</class-id> <category>truncation and roundoff</category><body package="AT MetaNumerics">truncated	^0</body></methods><methods><class-id>Core.Infinitesimal</class-id> <category>printing</category><body package="AT MetaNumerics">printOn: aStream	aStream nextPut: (negative ifTrue: [$-] ifFalse: [$+]).	aStream nextPutAll: (#tiny &lt;&lt; #advanced &gt;&gt; 'tiny') asString</body></methods><methods><class-id>Core.Infinitesimal class</class-id> <category>instance creation</category><body package="AT MetaNumerics">negative	"Answer negative infinitesimal"	^Negative</body><body package="AT MetaNumerics">negative: boolean	"Answer a 'new' infinitesimal, either positive or negative"	^boolean		ifTrue:	[Negative]		ifFalse:	[Positive]</body><body package="AT MetaNumerics">positive	"Answer positive infinitesimal"	^Positive</body></methods><methods><class-id>Core.Infinitesimal class</class-id> <category>class initialization</category><body package="AT MetaNumerics">initialize	"Infinitesimal initialize"	Positive := self basicNew negative: false.	Negative := self basicNew negative: true</body></methods><methods><class-id>Core.Complex</class-id> <category>mathematical functions</category><body package="AT MetaNumerics">** aNumber 	"Answer the receiver raised to the power of the argument, aNumber."	"Just some infix sugar for Number&gt;&gt;raisedTo:"	^self raisedTo: aNumber</body><body package="AT MetaNumerics">cos	^self i exp + self i negated exp / 2</body><body package="AT MetaNumerics">exp	"Answer the exponential of the receiver"	| zero im |	zero := (real class zero + imaginary class zero) asLimitedPrecisionReal.	im := zero coerce: imaginary.	^(zero coerce: real) exp * (im cos + im sin i)</body><body package="AT MetaNumerics">ln	"Answer the natural log of the receiver."	^self class real: self r ln imaginary: self theta</body><body package="AT MetaNumerics">log	"Answer with base 10 logarithm."	| ln |	ln := self ln.	^ln / (ln class unity * 10) ln</body><body package="AT MetaNumerics">log: aNumber 	"Answer the log base aNumber of the receiver."	^self ln / aNumber ln</body><body package="AT MetaNumerics">raisedTo: aNumber 	"Answer the receiver raised to the power of the argument, aNumber."	| n |	(n := aNumber toMinimumGenerality) isInteger		ifTrue: ["Do the special case of integer power"				^self raisedToInteger: n].	(self = 0 or: [self = 1]) ifTrue: [^self].	([aNumber negative]		on: ArithmeticError		do: [:ex | ex return: false])			ifTrue: [^(self raisedTo: aNumber negated) reciprocal].	^(aNumber * self ln) exp		"Otherwise raise it to the power using logarithms"</body><body package="AT MetaNumerics">sin	^self i exp - self i negated exp / 2i</body><body package="AT MetaNumerics">sqrt	"Return the square root of the receiver"	| u v |	(imaginary = 0 and: [real &gt;= 0])		ifTrue:	[^real sqrt].	v := (self abs - real / 2) sqrt.	u := imaginary / 2 / v.	^Complex real: u imaginary: v</body><body package="AT MetaNumerics">tan	^self sin / self cos</body></methods><methods><class-id>Core.Complex</class-id> <category>testing</category><body package="AT MetaNumerics">isComplex	^true</body><body package="AT MetaNumerics">isReal	"Answer whether the receiver has no imaginary part"	^self imaginary = self imaginary class zero</body><body package="AT MetaNumerics">isZero	"Answer whether 'self = self class zero'.  We can't use #= because	#= is defined in terms of #isZero"	^real isZero and: [imaginary isZero]</body><body package="AT MetaNumerics">sign	^Complex real: real sign imaginary: imaginary sign</body></methods><methods><class-id>Core.Complex</class-id> <category>arithmetic</category><body package="AT MetaNumerics">* aNumber 	"Return the product of the receiver and the argument."	aNumber isComplex		ifTrue: 			[| u v |			u := aNumber real.			v := aNumber imaginary.			^Complex				real: real * u - (imaginary * v)				imaginary: real * v + (imaginary * u)]		ifFalse: [^self retry: #* coercing: aNumber]</body><body package="AT MetaNumerics">+ aNumber 	"Return the sum of the receiver and the argument."	aNumber isComplex		ifTrue: [^Complex					real: aNumber real + real					imaginary: aNumber imaginary + imaginary]		ifFalse: [^self retry: #+ coercing: aNumber]</body><body package="AT MetaNumerics">- aNumber	"Return the difference of the receiver and the argument."	aNumber isComplex		ifTrue: [^Complex					real: real - aNumber real					imaginary: imaginary - aNumber imaginary]		ifFalse: [^self retry: #- coercing: aNumber]</body><body package="AT MetaNumerics">/ aNumber 	"Return the quotient of the receiver and the argument."	aNumber isComplex		ifTrue: 			[| denom u v |			u := aNumber real.			v := aNumber imaginary.			denom := u * u + (v * v).			^Complex				real: u * real + (v * imaginary) / denom				imaginary: u * imaginary - (v * real) / denom]		ifFalse: [^self retry: #/ coercing: aNumber]</body><body package="AT MetaNumerics">abs	"Return the magnitude (or absolute value) of the complex number."	^ (real * real + (imaginary * imaginary)) sqrt</body><body package="AT MetaNumerics">conjugated	"Return the complex conjugate of this complex number."	^ Complex real: real imaginary: imaginary negated</body></methods><methods><class-id>Core.Complex</class-id> <category>printing</category><body package="AT MetaNumerics">printOn: aStream	self storeOn: aStream</body><body package="AT MetaNumerics">storeOn: aStream	aStream nextPut: $(.	real storeOn: aStream.	aStream nextPutAll: ' + '.	imaginary storeOn: aStream.	aStream nextPutAll: ' i)'.</body></methods><methods><class-id>Core.Complex</class-id> <category>comparing</category><body package="AT MetaNumerics">&lt; aNumber	^Number		raise: #unorderedSignal		receiver: self		selector: #&lt;		arg: aNumber		errorString: (#ComplexNumbersNotWellOrdered &lt;&lt; #advanced &gt;&gt; 'Complex numbers are not well ordered')</body><body package="AT MetaNumerics">= aNumber 	"Compare the receiver and aNumber."	^aNumber respondsToArithmetic		and: [aNumber isComplex				ifTrue: [aNumber real = real and: [aNumber imaginary = imaginary]]				ifFalse: [self retry: #= coercing: aNumber]]</body><body package="AT MetaNumerics">hash	"Hash is implemented because equals is implemented."	^ real hash bitXor: imaginary hash</body></methods><methods><class-id>Core.Complex</class-id> <category>coercing</category><body package="AT MetaNumerics">coerce: aNumber	^aNumber asComplex</body><body package="AT MetaNumerics">generality	^150</body></methods><methods><class-id>Core.Complex</class-id> <category>accessing</category><body package="AT MetaNumerics">imaginary	"Return the imaginary part of the complex number."	^ imaginary</body><body package="AT MetaNumerics">r	^self abs</body><body package="AT MetaNumerics">real	"Return the real part of the complex number."	^ real</body><body package="AT MetaNumerics">theta	"Answer the angle the receiver makes with the positive real axis in radians"	| tan theta floatClass |	floatClass := (real class zero + imaginary class zero)			asLimitedPrecisionReal class.	real = 0		ifTrue: [imaginary &gt;= 0				ifTrue: [^floatClass pi / 2]				ifFalse: [^floatClass pi * 3 / 2]]		ifFalse: 			[tan := imaginary / real.			theta := tan arcTan.			real &gt; 0				ifTrue: [^theta]				ifFalse: [^floatClass pi + theta]]</body></methods><methods><class-id>Core.Complex</class-id> <category>private</category><body package="AT MetaNumerics">setReal: u setImaginary: v	real := u.	imaginary := v.</body></methods><methods><class-id>Core.Complex</class-id> <category>converting</category><body package="AT MetaNumerics">asComplex	^self</body><body package="AT MetaNumerics">asPoint	"Return the complex number as a point."	^ real @ imaginary</body><body package="AT MetaNumerics">i	"Answer the receiver multiplied by (-1 sqrt)"	^self class real: imaginary negated imaginary: real</body><body package="AT MetaNumerics">reduceGeneralityIfPossible	"Answer the receiver transformed to a lower generality, if such a 	transformation is possible without losing information. If not, answer 	the receiver"	^imaginary isZero		ifTrue: [real]		ifFalse: [self]</body></methods><methods><class-id>Core.Complex class</class-id> <category>instance creation</category><body package="AT MetaNumerics">fromReal: aNumber	"Create a new complex number from the given real number."	^ self basicNew setReal: aNumber setImaginary: 0</body><body package="AT MetaNumerics">real: u imaginary: v	"Create a new complex number with the given real and imaginary parts.	Do not try to optimize the case where v = 0, otherwise expressions like	(1i * 1i) sqrt will fail"	^self basicNew		setReal: u setImaginary: v;		yourself</body></methods><methods><class-id>Core.Complex class</class-id> <category>exception handling</category><body package="AT MetaNumerics">trapImaginary: aBlock	"Complex trapImaginary: [-27 sqrt]"	^Number domainErrorSignal		handle: [ :ex |				| send |				send := ex parameter.				(send selector = #sqrt or: [send selector = #sqrtTruncated])					ifTrue:	[send receiver: send receiver asComplex.							ex proceedWith: send value]					ifFalse:	[ex reject]]		do: aBlock</body></methods><methods><class-id>Core.Complex class</class-id> <category>constants access</category><body package="AT MetaNumerics">unity	"Answer the value which allows, for any given arithmetic value, the following to be true		aNumber * aNumber class unity = aNumber	This must be true regardless of how a given subclass chooses to define #*"	^self fromReal: 1</body><body package="AT MetaNumerics">zero	"Answer the value which allows, for any given arithmetic value, the following to be true		aNumber + aNumber class zero = aNumber	This must be true regardless of how a given subclass chooses to define #+"	^self fromReal: 0</body></methods><methods><class-id>Core.NotANumber</class-id> <category>double dispatching</category><body package="AT MetaNumerics">differenceFromInfinitesimal: aNumber	^self class		raise: #domainErrorSignal		receiver: aNumber		selector: #-		arg: self		errorString: (#CannotPerformArithmeticFunctionsOnNaNs &lt;&lt; #advanced &gt;&gt; 'Can''t perform arithmetic functions on NaN')</body><body package="AT MetaNumerics">differenceFromInfinity: aNumber	^self class		raise: #domainErrorSignal		receiver: aNumber		selector: #-		arg: self		errorString: (#CannotPerformArithmeticFunctionsOnNaNs &lt;&lt; #advanced &gt;&gt; 'Can''t perform arithmetic functions on NaN')</body><body package="AT MetaNumerics">differenceFromSomeNumber: aNumber	^self class		raise: #domainErrorSignal		receiver: aNumber		selector: #-		arg: self		errorString: (#CannotPerformArithmeticFunctionsOnNaNs &lt;&lt; #advanced &gt;&gt; 'Can''t perform arithmetic functions on NaN')</body><body package="AT MetaNumerics">equalFromInfinitesimal: aNumber	^self class		raise: #unorderedSignal		receiver: aNumber		selector: #=		arg: self		errorString: (#CannotDoComparisonsOnNaNs &lt;&lt; #advanced &gt;&gt; 'Can''t do comparisons on NaN')</body><body package="AT MetaNumerics">equalFromInfinity: aNumber	^self class		raise: #unorderedSignal		receiver: aNumber		selector: #=		arg: self		errorString: (#CannotDoComparisonsOnNaNs &lt;&lt; #advanced &gt;&gt; 'Can''t do comparisons on NaN')</body><body package="AT MetaNumerics">equalFromSomeNumber: aNumber	^self class		raise: #unorderedSignal		receiver: aNumber		selector: #=		arg: self		errorString: (#CannotDoComparisonsOnNaNs &lt;&lt; #advanced &gt;&gt; 'Can''t do comparisons on NaN')</body><body package="AT MetaNumerics">lessFromInfinitesimal: aNumber	^self class		raise: #unorderedSignal		receiver: aNumber		selector: #&lt;		arg: self		errorString: (#CannotDoComparisonsOnNaNs &lt;&lt; #advanced &gt;&gt; 'Can''t do comparisons on NaN')</body><body package="AT MetaNumerics">lessFromInfinity: aNumber	^self class		raise: #unorderedSignal		receiver: aNumber		selector: #&lt;		arg: self		errorString: (#CannotDoComparisonsOnNaNs &lt;&lt; #advanced &gt;&gt; 'Can''t do comparisons on NaN')</body><body package="AT MetaNumerics">lessFromSomeNumber: aNumber	^self class		raise: #unorderedSignal		receiver: aNumber		selector: #&lt;		arg: self		errorString: (#CannotDoComparisonsOnNaNs &lt;&lt; #advanced &gt;&gt; 'Can''t do comparisons on NaN')</body><body package="AT MetaNumerics">productFromInfinitesimal: aNumber	^self class		raise: #domainErrorSignal		receiver: aNumber		selector: #*		arg: self		errorString: (#CannotPerformArithmeticFunctionsOnNaNs &lt;&lt; #advanced &gt;&gt; 'Can''t perform arithmetic functions on NaN')</body><body package="AT MetaNumerics">productFromInfinity: aNumber	^self class		raise: #domainErrorSignal		receiver: aNumber		selector: #*		arg: self		errorString: (#CannotPerformArithmeticFunctionsOnNaNs &lt;&lt; #advanced &gt;&gt; 'Can''t perform arithmetic functions on NaN')</body><body package="AT MetaNumerics">productFromSomeNumber: aNumber	^self class		raise: #domainErrorSignal		receiver: aNumber		selector: #*		arg: self		errorString: (#CannotPerformArithmeticFunctionsOnNaNs &lt;&lt; #advanced &gt;&gt; 'Can''t perform arithmetic functions on NaN')</body><body package="AT MetaNumerics">quotientFromInfinitesimal: aNumber	^self class		raise: #domainErrorSignal		receiver: aNumber		selector: #/		arg: self		errorString: (#CannotPerformArithmeticFunctionsOnNaNs &lt;&lt; #advanced &gt;&gt; 'Can''t perform arithmetic functions on NaN')</body><body package="AT MetaNumerics">quotientFromInfinity: aNumber	^self class		raise: #domainErrorSignal		receiver: aNumber		selector: #/		arg: self		errorString: (#CannotPerformArithmeticFunctionsOnNaNs &lt;&lt; #advanced &gt;&gt; 'Can''t perform arithmetic functions on NaN')</body><body package="AT MetaNumerics">quotientFromSomeNumber: aNumber	^self class		raise: #domainErrorSignal		receiver: aNumber		selector: #/		arg: self		errorString: (#CannotPerformArithmeticFunctionsOnNaNs &lt;&lt; #advanced &gt;&gt; 'Can''t perform arithmetic functions on NaN')</body><body package="AT MetaNumerics">sumFromInfinitesimal: aNumber	^self class		raise: #domainErrorSignal		receiver: aNumber		selector: #+		arg: self		errorString: (#CannotPerformArithmeticFunctionsOnNaNs &lt;&lt; #advanced &gt;&gt; 'Can''t perform arithmetic functions on NaN')</body><body package="AT MetaNumerics">sumFromInfinity: aNumber	^self class		raise: #domainErrorSignal		receiver: aNumber		selector: #+		arg: self		errorString: (#CannotPerformArithmeticFunctionsOnNaNs &lt;&lt; #advanced &gt;&gt; 'Can''t perform arithmetic functions on NaN')</body><body package="AT MetaNumerics">sumFromSomeNumber: aNumber	^self class		raise: #domainErrorSignal		receiver: aNumber		selector: #+		arg: self		errorString: (#CannotPerformArithmeticFunctionsOnNaNs &lt;&lt; #advanced &gt;&gt; 'Can''t perform arithmetic functions on NaN')</body></methods><methods><class-id>Core.NotANumber</class-id> <category>comparing</category><body package="AT MetaNumerics">&lt; aNumber	^self class		raise: #unorderedSignal		receiver: self		selector: #&lt;		arg: aNumber		errorString: (#CannotDoComparisonsOnNaNs &lt;&lt; #advanced &gt;&gt; 'Can''t do comparisons on NaN')</body><body package="AT MetaNumerics">= aNumber	^aNumber respondsToArithmetic and: [self class		raise: #unorderedSignal		receiver: self		selector: #=		arg: aNumber		errorString: (#CannotDoComparisonsOnNaNs &lt;&lt; #advanced &gt;&gt; 'Can''t do comparisons on NaN')]</body></methods><methods><class-id>Core.NotANumber</class-id> <category>arithmetic</category><body package="AT MetaNumerics">* aNumber	^self class		raise: #domainErrorSignal		receiver: self		selector: #*		arg: aNumber		errorString: (#CannotPerformArithmeticFunctionsOnNaNs &lt;&lt; #advanced &gt;&gt; 'Can''t perform arithmetic functions on NaN')</body><body package="AT MetaNumerics">+ aNumber	^self class		raise: #domainErrorSignal		receiver: self		selector: #+		arg: aNumber		errorString: (#CannotPerformArithmeticFunctionsOnNaNs &lt;&lt; #advanced &gt;&gt; 'Can''t perform arithmetic functions on NaN')</body><body package="AT MetaNumerics">- aNumber	^self class		raise: #domainErrorSignal		receiver: self		selector: #-		arg: aNumber		errorString: (#CannotPerformArithmeticFunctionsOnNaNs &lt;&lt; #advanced &gt;&gt; 'Can''t perform arithmetic functions on NaN')</body><body package="AT MetaNumerics">/ aNumber	^self class		raise: #domainErrorSignal		receiver: self		selector: #/		arg: aNumber		errorString: (#CannotPerformArithmeticFunctionsOnNaNs &lt;&lt; #advanced &gt;&gt; 'Can''t perform arithmetic functions on NaN')</body></methods><methods><class-id>Core.NotANumber</class-id> <category>testing</category><body package="AT MetaNumerics">isZero	"Answer whether 'self = self class zero'.  We can't use #= because	#= is defined in terms of #isZero"	^self class		raise: #unorderedSignal		receiver: self		selector: #isZero		errorString: (#CannotDoComparisonsOnNaNs &lt;&lt; #advanced &gt;&gt; 'Can''t do comparisons on NaN')</body></methods><methods><class-id>Core.NotANumber</class-id> <category>printing</category><body package="AT MetaNumerics">printOn: aStream	aStream nextPutAll: (#NaN &lt;&lt; #advanced &gt;&gt; 'NaN') asString</body></methods><methods><class-id>Core.NotANumber</class-id> <category>converting</category><body package="AT MetaNumerics">asFixedPoint: newScale	^self class		raise: #domainErrorSignal		receiver: self		selector: #truncated		errorString: 'Cannot convert NaN'</body></methods><methods><class-id>Core.NotANumber class</class-id> <category>instance creation</category><body package="AT MetaNumerics">new	^self basicNew</body></methods><methods><class-id>Core.Infinity</class-id> <category>double dispatching</category><body package="AT MetaNumerics">differenceFromInfinitesimal: aNumber	^self negated</body><body package="AT MetaNumerics">differenceFromInfinity: aNumber 	self negative = aNumber negative		ifTrue: [^self class				raise: #domainErrorSignal				receiver: aNumber				selector: #-				arg: self				errorString: (#CannotSubtractInfinitiesOfLikeSign &lt;&lt; #advanced &gt;&gt; 'Can''t subtract Infinities with like signs')]		ifFalse: [^aNumber]</body><body package="AT MetaNumerics">differenceFromSomeNumber: aNumber	^self negated</body><body package="AT MetaNumerics">equalFromInfinitesimal: aNumber	^false</body><body package="AT MetaNumerics">equalFromInfinity: aNumber 	aNumber negative = self negative		ifTrue: [^self class				raise: #unorderedSignal				receiver: aNumber				selector: #=				arg: self				errorString: (#CannotCompareInfinitiesOfLikeSign &lt;&lt; #advanced &gt;&gt; 'Can''t compare Infinities of like signs')]		ifFalse: [^false]</body><body package="AT MetaNumerics">equalFromSomeNumber: aNumber	^false</body><body package="AT MetaNumerics">lessFromInfinitesimal: aNumber	^self positive</body><body package="AT MetaNumerics">lessFromInfinity: aNumber 	aNumber negative = self negative		ifTrue: [^self class				raise: #unorderedSignal				receiver: aNumber				selector: #&lt;				arg: self				errorString: (#CannotCompareInfinitiesOfLikeSign &lt;&lt; #advanced &gt;&gt; 'Can''t compare Infinities of like signs')]		ifFalse: [^aNumber negative]</body><body package="AT MetaNumerics">lessFromSomeNumber: aNumber	^self positive</body><body package="AT MetaNumerics">productFromInfinitesimal: aNumber	^self class		raise: #domainErrorSignal		receiver: aNumber		selector: #*		arg: self		errorString: (#ProductOfInfinityAndInfinitesimalIsUndefined &lt;&lt; #advanced &gt;&gt; 'The product of Infinity and Infinitesimal is undefined')</body><body package="AT MetaNumerics">productFromInfinity: aNumber	aNumber negative		ifTrue:	[^self negated]		ifFalse:	[^self]</body><body package="AT MetaNumerics">productFromSomeNumber: aNumber	aNumber isZero		ifTrue:	[^0].	aNumber negative		ifTrue:	[^self negated]		ifFalse:	[^self]</body><body package="AT MetaNumerics">quotientFromInfinitesimal: aNumber	self negative		ifTrue:	[^aNumber negated]		ifFalse:	[^aNumber]</body><body package="AT MetaNumerics">quotientFromInfinity: aNumber 	^self class		raise: #domainErrorSignal		receiver: aNumber		selector: #/		arg: self		errorString: (#CannotDivideInfinityByInfinity &lt;&lt; #advanced &gt;&gt; 'Can''t divide Infinity by Infinity')</body><body package="AT MetaNumerics">quotientFromSomeNumber: aNumber 	aNumber isZero		ifTrue:	[^0].	^Infinitesimal negative: aNumber negative ~= self negative</body><body package="AT MetaNumerics">sumFromInfinitesimal: aNumber	^self</body><body package="AT MetaNumerics">sumFromInfinity: aNumber 	self negative ~= aNumber negative		ifTrue: [^self class				raise: #domainErrorSignal				receiver: aNumber				selector: #+				arg: self				errorString: (#CannotAddInfinitiesOfDifferingSign &lt;&lt; #advanced &gt;&gt; 'Can''t add Infinities of differing signs')]		ifFalse: [^aNumber]</body><body package="AT MetaNumerics">sumFromSomeNumber: aNumber	^self</body></methods><methods><class-id>Core.Infinity</class-id> <category>arithmetic</category><body package="AT MetaNumerics">* aNumber 	"Multiply aNumber by the receiver"	^aNumber productFromInfinity: self</body><body package="AT MetaNumerics">+ aNumber 	"Add aNumber to the receiver"	^aNumber sumFromInfinity: self</body><body package="AT MetaNumerics">- aNumber 	"Subtract aNumber from the receiver"	^aNumber differenceFromInfinity: self</body><body package="AT MetaNumerics">/ aNumber 	"Divide the receiver by aNumber"	^aNumber quotientFromInfinity: self</body><body package="AT MetaNumerics">negated	^self class negative: negative == false</body></methods><methods><class-id>Core.Infinity</class-id> <category>testing</category><body package="AT MetaNumerics">isZero	"Answer whether 'self = self class zero'.  We can't use #= because	#= is defined in terms of #isZero"	^false</body><body package="AT MetaNumerics">negative	"Answer whether the receiver is less than zero"	^negative</body><body package="AT MetaNumerics">positive	"Answer whether the receiver is greater than zero"	^negative == false</body></methods><methods><class-id>Core.Infinity</class-id> <category>comparing</category><body package="AT MetaNumerics">&lt; aNumber 	"Compare the receiver to aNumber"	^aNumber lessFromInfinity: self</body><body package="AT MetaNumerics">= aNumber 	"Compare the receiver and aNumber"	^aNumber respondsToArithmetic and: [aNumber equalFromInfinity: self]</body></methods><methods><class-id>Core.Infinity</class-id> <category>private</category><body package="AT MetaNumerics">negative: aBoolean	negative := aBoolean</body></methods><methods><class-id>Core.Infinity</class-id> <category>truncation and roundoff</category><body package="AT MetaNumerics">truncated	^self class		raise: #domainErrorSignal		receiver: self		selector: #truncated		errorString: (#CannotTruncateInfinity &lt;&lt; #advanced &gt;&gt; 'Can''t truncate infinity')</body></methods><methods><class-id>Core.Infinity</class-id> <category>printing</category><body package="AT MetaNumerics">printOn: aStream	aStream nextPut: (negative ifTrue: [$-] ifFalse: [$+]).	aStream nextPutAll: (#infinity &lt;&lt; #advanced &gt;&gt; 'infinity') asString</body></methods><methods><class-id>Core.Infinity</class-id> <category>converting</category><body package="AT MetaNumerics">asFixedPoint: newScale	^self class		raise: #domainErrorSignal		receiver: self		selector: #truncated		errorString: 'Cannot convert infinity'</body></methods><methods><class-id>Core.Infinity class</class-id> <category>instance creation</category><body package="AT MetaNumerics">negative	"Answer negative infinity"	^Negative</body><body package="AT MetaNumerics">negative: boolean	"Answer a 'new' infinity, either positive or negative"	^boolean		ifTrue:	[Negative]		ifFalse:	[Positive]</body><body package="AT MetaNumerics">positive	"Answer positive infinity"	^Positive</body></methods><methods><class-id>Core.Infinity class</class-id> <category>class initialization</category><body package="AT MetaNumerics">initialize	"Infinity initialize"	Positive := self basicNew negative: false.	Negative := self basicNew negative: true</body></methods><methods><class-id>Core.ArithmeticValue</class-id> <category>double dispatching</category><body package="AT MetaNumerics">differenceFromInfinitesimal: aNumber	^aNumber retry: #- coercing: self</body><body package="AT MetaNumerics">differenceFromInfinity: aNumber	^aNumber retry: #- coercing: self</body><body package="AT MetaNumerics">differenceFromSomeNumber: aNumber	^aNumber retry: #- coercing: self</body><body package="AT MetaNumerics">equalFromInfinitesimal: aNumber	^aNumber retry: #= coercing: self</body><body package="AT MetaNumerics">equalFromInfinity: aNumber	^aNumber retry: #= coercing: self</body><body package="AT MetaNumerics">equalFromSomeNumber: aNumber	^aNumber retry: #= coercing: self</body></methods><methods><class-id>Core.ArithmeticValue</class-id> <category>testing</category><body package="AT MetaNumerics">isComplex	"Answer whether the receiver has an imaginary part"	^false</body></methods><methods><class-id>Core.ArithmeticValue</class-id> <category>double dispatching</category><body package="AT MetaNumerics">lessFromInfinitesimal: aNumber	^aNumber retry: #&lt; coercing: self</body><body package="AT MetaNumerics">lessFromInfinity: aNumber	^aNumber retry: #&lt; coercing: self</body><body package="AT MetaNumerics">lessFromSomeNumber: aNumber	^aNumber retry: #&lt; coercing: self</body><body package="AT MetaNumerics">productFromInfinitesimal: aNumber	^aNumber retry: #* coercing: self</body><body package="AT MetaNumerics">productFromInfinity: aNumber	^aNumber retry: #* coercing: self</body><body package="AT MetaNumerics">productFromSomeNumber: aNumber	^aNumber retry: #* coercing: self</body><body package="AT MetaNumerics">quotientFromInfinitesimal: aNumber 	^aNumber retry: #/ coercing: self</body><body package="AT MetaNumerics">quotientFromInfinity: aNumber	^aNumber retry: #/ coercing: self</body><body package="AT MetaNumerics">quotientFromSomeNumber: aNumber 	^aNumber retry: #/ coercing: self</body><body package="AT MetaNumerics">sumFromInfinitesimal: aNumber	^aNumber retry: #+ coercing: self</body><body package="AT MetaNumerics">sumFromInfinity: aNumber	^aNumber retry: #+ coercing: self</body><body package="AT MetaNumerics">sumFromSomeNumber: aNumber	^aNumber retry: #+ coercing: self</body></methods><methods><class-id>Core.Number</class-id> <category>converting</category><body package="AT MetaNumerics">asComplex	"Answer a complex number with the receiver as the real part and 	zero as the imaginary part"	^Complex fromReal: self</body><body package="AT MetaNumerics">asMetaNumber	"Represent the number as a MetaNumeric"	^SomeNumber from: self</body><body package="AT MetaNumerics">i	"Answer the receiver multiplied by (-1 sqrt)"	^Complex real: self class zero imaginary: self</body></methods><initialize><class-id>Core.Infinitesimal</class-id></initialize><initialize><class-id>Core.Infinity</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>ArithmeticValue</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Number</name><environment>Core</environment><super>Core.ArithmeticValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class></st-source>