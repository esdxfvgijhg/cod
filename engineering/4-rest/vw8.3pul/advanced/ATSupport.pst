<?xml version="1.0"?><st-source><!-- Name: AT SupportNotice: Copyright 1999-2014 Cincom Systems, Inc.  All rights reserved.Comment: Contains support classes used by a number of the other AT packages.DbIdentifier: bear73DbTrace: 422868DbUsername: ablakeyDbVersion: 8.0 - 1DevelopmentPrerequisites: #(#(#any 'AT Menu Support' ''))PackageName: AT SupportParcel: #('AT Support')ParcelName: AT SupportPrerequisiteDescriptions: #(#(#name 'AT Menu Support' #componentType #package))PrerequisiteParcels: #(#('AT Menu Support' ''))PrintStringCache: (8.0 - 1,ablakey)Version: 8.0 - 1Date: 10:35:46 AM February 28, 2014 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.0 (feb14.4) of February 28, 2014 on February 28, 2014 at 10:35:46 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>LabeledObjectHolder</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>string object emphasis </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AT-Support</category><attributes><package>AT Support</package></attributes></class><comment><class-id>UI.LabeledObjectHolder</class-id><body>LabeledObjectHolder is used to apply indentation and/or boldness to the printString of an object like a MessageTallyInstance variables:	string		&lt;String&gt; used to supply indentation in an indented list, or as a label row on a report	object		&lt;Object | nil&gt; the object whose printString is being 'beautified' by the receiver	emphasis	&lt;Object&gt; any legal text emphasis, such as nil or #bold.  Used to allow line-by-line emphasis change in a ListView</body></comment><class><name>TreeObjectHolder</name><environment>Tools</environment><super>UI.LabeledObjectHolder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>leaf </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AT-Support</category><attributes><package>AT Support</package></attributes></class><comment><class-id>Tools.TreeObjectHolder</class-id><body>TreeObjectHolder is used to keep track of which items in an OutlineSelectionInList are leaves.Collaborators:	OutlineSelectionInListInstance variables:	leaf		&lt;Boolean&gt; this item is a leaf</body></comment><class><name>EvaluationHolder</name><environment>Tools</environment><super>UI.ValueHolder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>object </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AT-Support</category><attributes><package>AT Support</package></attributes></class><comment><class-id>Tools.EvaluationHolder</class-id><body>This class is defined so that an object can be referenced implicitly as 'self' in evaluated expressions in a specialized workspace.Instance Variables	object		&lt;Object&gt; the value to be referenced in Smalltalk expressions as 'self'</body></comment><class><name>DisablingSelectionInList</name><environment>UI</environment><super>UI.SelectionInList</super><private>false</private><indexed-type>none</indexed-type><inst-vars>enabledIndexSetHolder fullListHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AT-Support</category><attributes><package>AT Support</package></attributes></class><comment><class-id>UI.DisablingSelectionInList</class-id><body>DisablingSelectionInList is a subclass of SelectionInList that allows items in the list to be disabled and enabled, allowing them to be hidden and then re-exposed.Instance Variables:	enabledIndexSetHolder	&lt;ValueModel with: Set&gt;  The indices that are at present enabled	fullListHolder	&lt;ValueModel with: SequenceableCollection&gt;  The full sequence</body></comment><class><name>GroupingSelectionInList</name><environment>UI</environment><super>UI.DisablingSelectionInList</super><private>false</private><indexed-type>none</indexed-type><inst-vars>groupBlockHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AT-Support</category><attributes><package>AT Support</package></attributes></class><comment><class-id>UI.GroupingSelectionInList</class-id><body>This is a subclass of DisablingSelectionInList that allows the disabling and enabling to be done a group at a time, where the group indicator is interpreted by a block supplied by the user to supply a set of indices.  One typical use would be to enable and disable sub-trees in a hierarchy.Instance Variables:	groupBlock	&lt;ValueModel with: Block&gt;  a block of one argument that returns a Collection of indices associated with the argument</body></comment><class><name>OutlineSelectionInList</name><environment>UI</environment><super>UI.GroupingSelectionInList</super><private>false</private><indexed-type>none</indexed-type><inst-vars>childBlockHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AT-Support</category><attributes><package>AT Support</package></attributes></class><comment><class-id>UI.OutlineSelectionInList</class-id><body>This is a subclass of GroupingSelectionInList that allows the disabling and enabling to be done a subtree at a time.  Instance Variables:	childBlock	&lt;ValueModel with: Block&gt;  a block of one argument that returns a Collection of indices of children for that given index.  When called with zero, it should return a collection of indices of the roots of the trees.</body></comment><class><name>EnabledIndexSet</name><environment>UI</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AT-Support</category><attributes><package>AT Support</package></attributes></class><methods><class-id>UI.LabeledObjectHolder</class-id> <category>printing</category><body package="AT Support">asText	| text |	text := (string, object printString) asText.	text emphasizeFrom: string size + 1 to: text size with: emphasis.	^text</body><body package="AT Support">printOn: aStream	| oldEmphasis |	aStream nextPutAll: string.	oldEmphasis := aStream emphasis.	aStream emphasis: emphasis.	object == nil		ifFalse:	[object printOn: aStream].	aStream emphasis: oldEmphasis</body></methods><methods><class-id>UI.LabeledObjectHolder</class-id> <category>private</category><body package="AT Support">string: aString value: anObject	string := aString.	object := anObject</body></methods><methods><class-id>UI.LabeledObjectHolder</class-id> <category>drawing</category><body package="AT Support">asLabel	^Label with: self asText</body></methods><methods><class-id>UI.LabeledObjectHolder</class-id> <category>accessing</category><body package="AT Support">emphasis	^emphasis</body><body package="AT Support">emphasis: anEmphasis	emphasis := anEmphasis</body><body package="AT Support">value	^object</body></methods><methods><class-id>UI.LabeledObjectHolder class</class-id> <category>instance creation</category><body package="AT Support">new	^self string: '' value: nil</body><body package="AT Support">string: aString	^self string: aString value: nil</body><body package="AT Support">string: aString value: anObject	^self basicNew string: aString value: anObject</body></methods><methods><class-id>Tools.TreeObjectHolder</class-id> <category>expand contract</category><body package="AT Support">hasHiddenChildren	"Make this item show that it has hidden children"	self leaf ifFalse: [self emphasis: #bold]</body><body package="AT Support">hasHiddenChildren: aBoolean 	"Make this item show if it has hidden children or not"	aBoolean		ifTrue: [self hasHiddenChildren]		ifFalse: [self noHiddenChildren]</body><body package="AT Support">noHiddenChildren	"Make this item show that it has no hidden children"	self emphasis: nil</body></methods><methods><class-id>Tools.TreeObjectHolder</class-id> <category>accessing</category><body package="AT Support">leaf	^leaf</body><body package="AT Support">leaf: aBoolean	leaf := aBoolean</body></methods><methods><class-id>Tools.TreeObjectHolder class</class-id> <category>instance creation</category><body package="AT Support">string: aString value: anObject leaf: aBoolean	^(super string: aString value: anObject) leaf: aBoolean</body></methods><methods><class-id>Tools.EvaluationHolder</class-id> <category>accessing</category><body package="AT Support">doItReceiver	^object</body><body package="AT Support">object: doItReceiver	object := doItReceiver</body></methods><methods><class-id>UI.DisablingSelectionInList</class-id> <category>selection in list</category><body package="AT Support">enabledIndexSet	"Answer the enabled indexes"	^enabledIndexSetHolder value</body><body package="AT Support">fullList	"Answer the receiver's full list, anything that might be selected sometime."	^fullListHolder value</body><body package="AT Support">list: aSequenceableCollection	"Set the receiver's aSequenceableCollection."	self selectionIndex: 0.	self resetList: aSequenceableCollection.	self enabledIndexSet: (EnabledIndexSet withAll: (1 to: aSequenceableCollection size)).	self fullList: aSequenceableCollection.</body><body package="AT Support">list: aSequenceableCollection enabledSet: enabledIndexSet 	"Set the receiver's aSequenceableCollection."	| availableSelections |	"Create the new set with placeholders, then replace them all"	availableSelections := aSequenceableCollection species withAll: enabledIndexSet.	(1 to: enabledIndexSet size) with: enabledIndexSet asSortedCollection		do: [:indexOut :indexIn | availableSelections at: indexOut put: (aSequenceableCollection at: indexIn)].	self selectionIndex: 0.	self resetList: availableSelections.	self enabledIndexSet: enabledIndexSet.	self fullList: aSequenceableCollection</body></methods><methods><class-id>UI.DisablingSelectionInList</class-id> <category>private</category><body package="AT Support">calculateEnabledList	"recalculate the list of items that are enabled based on the current 	fullList and the enabledList"	| fullList enabledList |	fullList := self fullList.	enabledList := fullList species new: (self enabledIndexSet size).	self enabledIndexSet asSortedCollection do: [:index | enabledList add: (fullList at: index)].	^enabledList</body><body package="AT Support">enabledIndexSet: aSet	"Change the enabled indexes"	^enabledIndexSetHolder value: aSet</body><body package="AT Support">fullList: aSequenceableCollection	"Set the receiver's available selections."	fullListHolder value: aSequenceableCollection</body><body package="AT Support">resetList: aSequenceableCollection	"reset the list because the enablement has changed."	| selectionIndex |	selectionIndex := self selectionIndexInFull.	super list: aSequenceableCollection.	self selectionIndexInFull: selectionIndex</body></methods><methods><class-id>UI.DisablingSelectionInList</class-id> <category>disabling enabling</category><body package="AT Support">disableItem: aSelectionIndex 	"Disable the item. The index is the index in the fullList, NOT the 	index in the list of currentlly enabled items."	(self enabledIndexSet includes: aSelectionIndex)		ifTrue:			[self enabledIndexSet remove: aSelectionIndex.			self resetList: self calculateEnabledList]</body><body package="AT Support">disableItems: selectionIndexes 	"Disable the items. The index is the index in the fullList, NOT the 	index in the list of currentlly enabled items."	selectionIndexes do: [:aSelectionIndex | self enabledIndexSet remove: aSelectionIndex ifAbsent: []].	self resetList: self calculateEnabledList</body><body package="AT Support">enableItem: aSelectionIndex 	"Enable the item. The index is the index in the fullList, NOT the 	index in the list of currentlly enabled items."	(self enabledIndexSet includes: aSelectionIndex)		ifFalse: 			[self enabledIndexSet add: aSelectionIndex.			self resetList: self calculateEnabledList]</body><body package="AT Support">enableItems: selectionIndexes 	"Disable the items. The index is the index in the fullList, NOT the 	index in the list of currentlly enabled items."	selectionIndexes do: [:aSelectionIndex | self enabledIndexSet add: aSelectionIndex].	self resetList: self calculateEnabledList</body></methods><methods><class-id>UI.DisablingSelectionInList</class-id> <category>accessing</category><body package="AT Support">enabledIndexSetHolder	"Answer the enabledIndexSetHolder"	^enabledIndexSetHolder</body><body package="AT Support">enabledIndexSetHolder: aValueModel	"Set the enabledIndexSetHolder"	enabledIndexSetHolder removeDependent: self.	enabledIndexSetHolder := aValueModel.	enabledIndexSetHolder addDependent: self</body><body package="AT Support">fullListHolder	"Answer the fullListHolder"	^fullListHolder</body><body package="AT Support">fullListHolder: aValueModel	"Set the fullListHolder"	fullListHolder removeDependent: self.	fullListHolder := aValueModel.	fullListHolder addDependent: self</body></methods><methods><class-id>UI.DisablingSelectionInList</class-id> <category>testing</category><body package="AT Support">enabled: itemIndex 	"Answer a boolean telling if the item is at present enabled"	^self enabledIndexSet includes: itemIndex</body></methods><methods><class-id>UI.DisablingSelectionInList</class-id> <category>selection index</category><body package="AT Support">selectionIndexInFull	"Answer the index of the current selection in the full list. If no 	current selection answer the zeroIndex."	| selectionIndex |	^(selectionIndex := self selectionIndex) = self zeroIndex		ifTrue: [self zeroIndex]		ifFalse: [self enabledIndexSet asSortedCollection at: selectionIndex]</body><body package="AT Support">selectionIndexInFull: desiredSelection 	"Set the index of the current selection in the full list. If no 	current selection answer the zeroIndex."	"We do this by counting the number of selected items that are less 	than or equal to the desired selection. That's the index into the 	enabled list."	| enabledSelection |	enabledSelection := self enabledIndexSet inject: self zeroIndex into: [:count :index | index &lt;= desiredSelection					ifTrue: [count + 1]					ifFalse: [count]].	self selectionIndex: enabledSelection</body></methods><methods><class-id>UI.DisablingSelectionInList</class-id> <category>initialize-release</category><body package="AT Support">initialize	super initialize.	self enabledIndexSetHolder: Set new asValue.	self fullListHolder: List new asValue</body></methods><methods><class-id>UI.GroupingSelectionInList</class-id> <category>disabling enabling</category><body package="AT Support">disableGroup: aGroup	"Disable a group."	self disableItems: (self groupBlock value: aGroup)</body><body package="AT Support">enableGroup: aGroup	"Enable a group."	self enableItems: (self groupBlock value: aGroup)</body></methods><methods><class-id>UI.GroupingSelectionInList</class-id> <category>initialize-release</category><body package="AT Support">initialize	super initialize.	self groupBlockHolder: [ :index | #() ] asValue.</body></methods><methods><class-id>UI.GroupingSelectionInList</class-id> <category>index grouping</category><body package="AT Support">groupBlock	"Answer the groupBlock."	^groupBlockHolder value</body><body package="AT Support">groupBlock: aBlock	"Set the groupBlock."	^groupBlockHolder value: aBlock</body><body package="AT Support">groupFor: anIndex	^self groupBlock value: anIndex</body></methods><methods><class-id>UI.GroupingSelectionInList</class-id> <category>accessing</category><body package="AT Support">groupBlockHolder	"Answer the groupBlockHolder"	^groupBlockHolder</body><body package="AT Support">groupBlockHolder: aValueModel	"Set the groupBlockHolder"	groupBlockHolder removeDependent: self.	groupBlockHolder := aValueModel.	groupBlockHolder addDependent: self</body></methods><methods><class-id>UI.OutlineSelectionInList</class-id> <category>disabling enabling</category><body package="AT Support">contractFully	"Disable all of the descendants of the current selection"	| selectionIndex |	selectionIndex := self selectionIndex.	selectionIndex == self zeroIndex		ifFalse: 			[self disableGroup: selectionIndex.			self selectionIndex: selectionIndex]</body><body package="AT Support">disableChildren: aGroup 	"Disable just the children, but not the other descendants"	self disableItems: (self childBlock value: aGroup)</body><body package="AT Support">enableChildren: aGroup 	"Enable just the children, but not the other descendants"	self enableItems: (self childBlock value: aGroup)</body><body package="AT Support">expand	"Expand the children of the current selection"	| selectionIndex |	selectionIndex := self selectionIndex.	selectionIndex == self zeroIndex		ifFalse: 			[self enableChildren: selectionIndex.			self selectionIndex: selectionIndex]</body><body package="AT Support">expandFully	"Enable all of the descendants of the current selection"	| selectionIndex |	selectionIndex := self selectionIndex.	selectionIndex == 0		ifFalse: 			[self enableGroup: selectionIndex.			self selectionIndex: selectionIndex]</body></methods><methods><class-id>UI.OutlineSelectionInList</class-id> <category>outline grouping</category><body package="AT Support">childBlock	"Answer the childBlock"	^self childBlockHolder value</body><body package="AT Support">childBlock: aBlock 	"Take the block of one argument that tells what the immediate 	children of a node are, and install a groupBlock that will take the 	index of a node and return all the descendents of it."	self childBlockHolder value: aBlock.	self		groupBlock: 			[:nodeIndex | 			| children |			children := aBlock value: nodeIndex.			children copy inject: children asOrderedCollection				into: 					[:runningCollection :child | 					runningCollection addAll: (self groupBlock value: child).					runningCollection]]</body><body package="AT Support">childrenFor: anIndex 	"Answer the children for this index"	^self childBlock value: anIndex</body></methods><methods><class-id>UI.OutlineSelectionInList</class-id> <category>accessing</category><body package="AT Support">childBlockHolder	"Answer the childBlockHolder"	^ childBlockHolder</body><body package="AT Support">childBlockHolder: aValueModel	"Set the childBlockHolder"	childBlockHolder removeDependent: self.	childBlockHolder := aValueModel.	childBlockHolder addDependent: self</body></methods><methods><class-id>UI.OutlineSelectionInList</class-id> <category>initialize-release</category><body package="AT Support">initialize	super initialize.	self childBlockHolder: [ :index | #() ] asValue.</body></methods><methods><class-id>UI.EnabledIndexSet</class-id> <category>private</category><body package="AT Support">initialIndexFor: aHashValue boundedBy: length	"Optimize for comparatively small small integers"	^aHashValue hashMultiply \\ length + 1</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>SelectionInList</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>listHolder selectionIndexHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Collections</category><attributes><package>UIBasics-Collections</package></attributes></class><class><name>ValueHolder</name><environment>UI</environment><super>UI.ValueModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Support</category><attributes><package>Interface-Support</package></attributes></class><class><name>Set</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>tally </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class></st-source>