<?xml version="1.0"?><st-source><!-- Name: AT Parser ExampleNotice: Copyright 1999-2013 Cincom Systems, Inc.  All rights reserved.Comment: Contains an example SQL compiler written using the parser compiler facilities provided by the AT Parser package.DbIdentifier: bear73DbTrace: 400372DbUsername: nrossDbVersion: 7.10 - 1DevelopmentPrerequisites: #(#(#any 'AT Parser Compiler' ''))PackageName: AT Parser ExamplePackageName:: AT Parser ExampleParcel: #('AT Parser Example')ParcelName: AT Parser ExamplePrerequisiteParcels: #(#('AT Parser Compiler' ''))PrintStringCache: (7.10 - 1,nross)Version: 7.10 - 1Date: 6:43:49 AM April 3, 2013 --><time-stamp>From VisualWorksÂ®, Pre-Release 7.10 (mar13.5) of April 3, 2013 on April 3, 2013 at 6:43:49 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>SQLIdentifier</name><environment>Examples</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>components </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AT-Parsing Example</category><attributes><package>AT Parser Example</package></attributes></class><comment><class-id>Examples.SQLIdentifier</class-id><body>An SQLIdentifier represents more or less a single token in the SQL language.  It may refer to a user, table, column, or variable.  Tables may be qualified by the user that owns them.  Columns may be qualified by the table of which they are part.  For example:	joe.addresses.zipcodeis a column name.  'zipcode' is the column name, qualified by 'joe.addresses'.  In turn, 'addresses' is the table name, qualified by the user name 'joe'.  An instance of SQLIdentifier would then have the array #('joe' 'addresses' 'zipcode') as its components instance variable.Instance Variables:	components		&lt;Array of: String&gt; the components that comprise this identifier</body></comment><class><name>SQLLiteral</name><environment>Examples</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AT-Parsing Example</category><attributes><package>AT Parser Example</package></attributes></class><comment><class-id>Examples.SQLLiteral</class-id><body>SQLLiteral holds a literal string or number.  It allows literal values to understand whatever protocol SQLParseNodes may eventually be expected to support.Instance Variables:	value		&lt;Number | String&gt; the literal being represented</body></comment><class><name>SQLNode</name><environment>Examples</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name arguments </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AT-Parsing Example</category><attributes><package>AT Parser Example</package></attributes></class><comment><class-id>Examples.SQLNode</class-id><body>SQLNode represents a common class of SQL parse node:  those which occur as one or more clauses, each preceded by a recognizable word or series of words.  This includes statements, clauses within statements, and unary operators such as NOTInstance Variables:	name		&lt;String&gt; identifies the receiver, since we haven't defined a separate				class for each type	arguments	&lt;Array | SQLNode&gt; list of arguments for this Node.  Some clauses have a fixed				number of arguments, such as the HAVING clause.  Others may have				any number of arguments, such as the FROM clause.  If there is only one argument,				it is not necessary to encapsulate the node in an Array</body></comment><class><name>SQLFunction</name><environment>Examples</environment><super>Examples.SQLNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AT-Parsing Example</category><attributes><package>AT Parser Example</package></attributes></class><comment><class-id>Examples.SQLFunction</class-id><body>SQLFunction is a node that represents a function with arguments.  The usual examples are the MIN(), MAX(), and COUNT() functions, among others</body></comment><class><name>SQLClause</name><environment>Examples</environment><super>Examples.SQLNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AT-Parsing Example</category><attributes><package>AT Parser Example</package></attributes></class><comment><class-id>Examples.SQLClause</class-id><body>An SQLClause represents a modifier on an SQLStatement, such as the FOR, WHERE, or HAVING clauses of an SQL SELECT statement</body></comment><class><name>SQLInfixOperation</name><environment>Examples</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>operator components </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AT-Parsing Example</category><attributes><package>AT Parser Example</package></attributes></class><comment><class-id>Examples.SQLInfixOperation</class-id><body>SQLInfixOperation represents the generic class of infix operations within SQL, such as arithmetic, comparison, and the boolean operators 'AND' and 'OR'.Instance Variables:	operator		&lt;String&gt; the operator being applied to the components.  Most operators				can be applied to any argument list, but the comparison operators are				restricted to two arguments	components	&lt;Array&gt; the values being manipulated.  The types depend on the operator				being used</body></comment><class><name>SQLModifier</name><environment>Examples</environment><super>Examples.SQLNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AT-Parsing Example</category><attributes><package>AT Parser Example</package></attributes></class><comment><class-id>Examples.SQLModifier</class-id><body>SQLModifier represents a unary operator on an SQL parse node.  For example, the DISTINCT or ALL modifiers on a Select operation, or the Boolean operator NOT are represented as SQLModifiers.</body></comment><class><name>SQLPostModifier</name><environment>Examples</environment><super>Examples.SQLModifier</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AT-Parsing Example</category><attributes><package>AT Parser Example</package></attributes></class><comment><class-id>Examples.SQLPostModifier</class-id><body>SQLPostModifier is, like SQLModifier, a unary operator, but it follows the entity that it modifies.  This class only exists for purposes of changing the printing behavior</body></comment><class><name>SQLStatement</name><environment>Examples</environment><super>Examples.SQLNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AT-Parsing Example</category><attributes><package>AT Parser Example</package></attributes></class><comment><class-id>Examples.SQLStatement</class-id><body>An SQLStatement represents a basic SQL operation, such as the 'OPEN', 'UPDATE', and 'COMMIT WORK' statements</body></comment><class><name>SQLCompiler</name><environment>Examples</environment><super>Kernel.ExternalLanguageParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AT-Parsing Example</category><attributes><package>AT Parser Example</package></attributes></class><comment><class-id>Examples.SQLCompiler</class-id><body>An SQLCompiler transforms a string containing legitimate SQL source code into SQL parse trees, which could then conceivably be passed to a database engine to be evaluated.Disclaimer:No guarantee is made that this SQLCompiler actually does anything interesting.  It is believed to correctly parse SQL statements, but may not generate useful or indeed correct parse trees.  It is intended only as an example of how one might make use of the ParserCompiler to create a Compiler for another language.</body></comment><class><name>SQL</name><environment>Examples</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AT-Parsing Example</category><attributes><package>AT Parser Example</package></attributes></class><comment><class-id>Examples.SQL</class-id><body>SQL is a repository for SQL 'methods'.  An SQL method is a Smalltalk method which, when invoked, answers an Array of SQLStatements.  Ideally, these could be passed to some sort of database engine, which would process them according to a given database</body></comment><methods><class-id>Examples.SQLIdentifier</class-id> <category>initialize-release</category><body package="AT Parser Example">components: argList	components := argList</body></methods><methods><class-id>Examples.SQLIdentifier</class-id> <category>printing</category><body package="AT Parser Example">printOn: aStream	1 to: components size - 1 do:		[:i |		aStream nextPutAll: (components at: i).		aStream nextPut: $.].	aStream nextPutAll: components last</body><body package="AT Parser Example">printOn: aStream indented: level	1 to: components size - 1 do:		[:i |		aStream nextPutAll: (components at: i).		aStream nextPut: $.].	aStream nextPutAll: components last</body></methods><methods><class-id>Examples.SQLIdentifier</class-id> <category>adding</category><body package="AT Parser Example">addComponent: aTag	components := components copyWith: aTag</body></methods><methods><class-id>Examples.SQLIdentifier class</class-id> <category>instance creation</category><body package="AT Parser Example">components: argList	^super new components: argList</body><body package="AT Parser Example">new	^super new components: #()</body></methods><methods><class-id>Examples.SQLLiteral</class-id> <category>initialize-release</category><body package="AT Parser Example">value: aValue	value := aValue</body></methods><methods><class-id>Examples.SQLLiteral</class-id> <category>printing</category><body package="AT Parser Example">printOn: aStream	aStream print: value</body><body package="AT Parser Example">printOn: aStream indented: level	aStream print: value</body></methods><methods><class-id>Examples.SQLLiteral class</class-id> <category>instance creation</category><body package="AT Parser Example">value: anObject	^self new value: anObject</body></methods><methods><class-id>Examples.SQLNode</class-id> <category>accessing</category><body package="AT Parser Example">secondaryKeywords	"These are keywords that introduce the second and following arguments of 	the clause or statement. If the statement has more arguments than 	secondary keywords, the extra arguments are assumed not to be preceded 	by a keyword"	^#()</body></methods><methods><class-id>Examples.SQLNode</class-id> <category>printing</category><body package="AT Parser Example">printOn: aStream 	self printOn: aStream indented: 1</body><body package="AT Parser Example">printOn: aStream indented: level	aStream		nextPutAll: name;		space.	(arguments isKindOf: SequenceableCollection)		ifTrue: 			[1 to: arguments size - 1 do:				[:i |				((arguments at: i) respondsTo: #printOn:indented:) not					ifTrue:	[(arguments at: i) printOn: aStream]					ifFalse:	[(arguments at: i) printOn: aStream indented: level+1].				self separatorTabLevel: level on: aStream argumentNumber: i].			arguments isEmpty				ifFalse: [(arguments last respondsTo: #printOn:indented:) not							ifTrue:	[arguments last printOn: aStream]							ifFalse:	[arguments last printOn: aStream indented: level+1]]]		ifFalse: [arguments printOn: aStream indented: level].</body><body package="AT Parser Example">separatorTabLevel: level on: aStream argumentNumber: n	| names |	aStream crtab: level.	names := self secondaryKeywords.	n &lt;= names size		ifTrue:	[aStream nextPutAll: (names at: n); space].</body></methods><methods><class-id>Examples.SQLNode</class-id> <category>initialize-release</category><body package="AT Parser Example">arguments: argList	arguments := argList</body><body package="AT Parser Example">named: aType	name := aType</body></methods><methods><class-id>Examples.SQLNode class</class-id> <category>instance creation</category><body package="AT Parser Example">named: aStatementType	^self new named: aStatementType; arguments: #()</body><body package="AT Parser Example">named: aStatementType arguments: argList	^self new named: aStatementType; arguments: argList</body></methods><methods><class-id>Examples.SQLFunction</class-id> <category>printing</category><body package="AT Parser Example">printOn: aStream indented: level	aStream		nextPutAll: name, '('.	(arguments isKindOf: SequenceableCollection)		ifTrue: [arguments first printOn: aStream]		ifFalse: [arguments printOn: aStream].	aStream nextPut: $)</body></methods><methods><class-id>Examples.SQLClause</class-id> <category>printing</category><body package="AT Parser Example">printOn: aStream indented: level	| parens |	(parens := self shouldBeParenthesized)		ifTrue:	[aStream nextPut: $(].	super printOn: aStream indented: level.	parens		ifTrue:	[aStream nextPut: $)].</body><body package="AT Parser Example">shouldBeParenthesized	^#('SELECT') includes: name</body></methods><methods><class-id>Examples.SQLInfixOperation</class-id> <category>printing</category><body package="AT Parser Example">printOn: aStream	aStream nextPut: $(.	1 to: components size - 1 do:		[:i |		(components at: i) printOn: aStream.		aStream space; nextPutAll: operator; space].	components last printOn: aStream.	aStream nextPut: $).</body><body package="AT Parser Example">printOn: aStream indented: level	aStream nextPut: $(.	1 to: components size - 1 do:		[:i |		(components at: i) printOn: aStream indented: level.		self shouldIndent			ifTrue:	[aStream crtab: level-1]			ifFalse:	[aStream space].		aStream nextPutAll: operator; space].	components last printOn: aStream indented: level.	aStream nextPut: $).</body><body package="AT Parser Example">shouldIndent	^#('AND' 'OR') includes: operator</body></methods><methods><class-id>Examples.SQLInfixOperation</class-id> <category>initialize-release</category><body package="AT Parser Example">components: argList operator: aString	components := argList.	operator := aString</body></methods><methods><class-id>Examples.SQLInfixOperation class</class-id> <category>instance creation</category><body package="AT Parser Example">components: argList operator: operator	argList size = 1		ifTrue:	[^argList at: 1].	^super new components: argList operator: operator</body></methods><methods><class-id>Examples.SQLPostModifier</class-id> <category>printing</category><body package="AT Parser Example">printOn: aStream indented: level	(arguments isKindOf: SequenceableCollection)		ifTrue: 			[1 to: arguments size - 1 do:				[:i |				((arguments at: i) respondsTo: #printOn:indented:) not					ifTrue:	[(arguments at: i) printOn: aStream]					ifFalse:	[(arguments at: i) printOn: aStream indented: level+1].				self separatorTabLevel: level on: aStream argumentNumber: i].			arguments isEmpty				ifFalse: [(arguments last respondsTo: #printOn:indented:) not							ifTrue:	[arguments last printOn: aStream]							ifFalse:	[arguments last printOn: aStream indented: level+1]]]		ifFalse: [arguments printOn: aStream indented: level].	aStream space; nextPutAll: name</body></methods><methods><class-id>Examples.SQLStatement</class-id> <category>accessing</category><body package="AT Parser Example">secondaryKeywords	"These are keywords that introduce the second and following arguments of 	the clause or statement. If the statement has more arguments than 	secondary keywords, the extra arguments are assumed not to be preceded 	by a keyword"	name = 'SELECT'		ifTrue:	[^#('INTO')].	name = 'UPDATE'		ifTrue:	[^#('SET')].	^#()</body></methods><methods><class-id>Examples.SQLCompiler</class-id> <category>parsing support</category><body package="AT Parser Example">clause: statementName	^SQLClause named: statementName</body><body package="AT Parser Example">clause: statementName with: arg1	^SQLClause named: statementName arguments: (Array with: arg1)</body><body package="AT Parser Example">clause: statementName withAll: arg1	^SQLClause named: statementName arguments: arg1</body><body package="AT Parser Example">function: functionName with: arg1	^SQLFunction named: functionName arguments: arg1</body><body package="AT Parser Example">identifier: tokenList	^SQLIdentifier components: tokenList</body><body package="AT Parser Example">infix: operator with: arg1 with: arg2	^SQLInfixOperation components: (Array with: arg1 with: arg2) operator: operator</body><body package="AT Parser Example">infix: operator withAll: args	^SQLInfixOperation components: args operator: operator</body><body package="AT Parser Example">modifier: statementName with: arg1	^SQLModifier named: statementName arguments: arg1</body><body package="AT Parser Example">postModifier: statementName with: arg1	^SQLPostModifier named: statementName arguments: arg1</body><body package="AT Parser Example">statement: statementName	^SQLStatement named: statementName</body><body package="AT Parser Example">statement: statementName with: arg1	^SQLStatement named: statementName arguments: (Array with: arg1)</body><body package="AT Parser Example">statement: statementName with: arg1 with: arg2	^SQLStatement named: statementName arguments: (Array with: arg1 with: arg2)</body><body package="AT Parser Example">statement: statementName with: arg1 with: arg2 with: arg3	^SQLStatement named: statementName arguments: (Array with: arg1 with: arg2 with: arg3)</body></methods><methods><class-id>Examples.SQLCompiler</class-id> <category>scalar expressions</category><body package="AT Parser Example">atom =	parameterRef	| literal	| #USER [identifier: #('USER')]</body><body package="AT Parser Example">factor =	#+ primary [modifier: '+' with:]	| #- primary [modifier: '-' with:]	| primary</body><body package="AT Parser Example">functionRef =	@ #COUNT $( #* $)  [function: 'COUNT' with: '*']	|	( #AVG ['AVG']		| #MAX ['MAX']		| #MIN ['MIN']		| #SUM ['SUM']		| #COUNT ['COUNT'] )	$(	( #DISTINCT columnRef [modifier: 'DISTINCT' with:]	| ( #ALL | ) scalarExp [modifier: 'ALL' with:] )	$)			[function:with:]</body><body package="AT Parser Example">parameterRef =	parameter ( ( #INDICATOR | ) parameter [infix: 'INDICATOR' with:with:] | )</body><body package="AT Parser Example">primary =	functionRef	| columnRef	| atom	| $( scalarExp $)</body><body package="AT Parser Example">scalarExp =	term \ ( #+ | #- )			[infix: '+' withAll:]</body><body package="AT Parser Example">term =	factor \ ( #* | #/ )			[infix: '*' withAll:]</body></methods><methods><class-id>Examples.SQLCompiler</class-id> <category>query expressions</category><body package="AT Parser Example">fromClause = 	#FROM tableRef \ $,			[clause: 'FROM' withAll:]</body><body package="AT Parser Example">groupByClause = 	#GROUP #BY columnRef \ $,			[clause: 'GROUP BY' withAll:]</body><body package="AT Parser Example">havingClause = 	#HAVING searchCondition			[clause: 'HAVING' with:]</body><body package="AT Parser Example">queryExp = 	queryTerm \ ( #UNION ( #ALL | ) )			[infix: 'UNION' withAll:]</body><body package="AT Parser Example">querySpec =	selectRequest tableExp			[| tableExp |			tableExp := stack removeLast. "incorporate table expression array into arguments"			SQLClause named: 'SELECT' arguments: (stack removeLast: 1), tableExp ]</body><body package="AT Parser Example">queryTerm = 	querySpec	| $( queryExp $)</body><body package="AT Parser Example">selection = 	#* [identifier: #('*' ) ]	| scalarExp \ $,</body><body package="AT Parser Example">tableExp = 	fromClause [ stack removeLast: 1 ]	( whereClause [ :copyWith: ] | )	( groupByClause [ :copyWith: ] | )	( havingClause [ :copyWith: ] | )</body><body package="AT Parser Example">tableRef = 	table		( rangeVariable [ : -&gt; ]		| )</body><body package="AT Parser Example">whereClause = 	#WHERE searchCondition			[clause: 'WHERE' with:]</body></methods><methods><class-id>Examples.SQLCompiler</class-id> <category>search conditions</category><body package="AT Parser Example">betweenPredicate =	scalarExp ( #NOT | ) #BETWEEN scalarExp #AND scalarExp</body><body package="AT Parser Example">booleanFactor =	| negated |	[ negated := false ] .	( #NOT [ negated := true ] .	| )	( $( searchCondition $)	| predicate )			[negated				ifTrue: [self modifier: 'NOT' with: stack removeLast]				ifFalse: [stack removeLast]]</body><body package="AT Parser Example">booleanTerm =	booleanFactor \ #AND			[infix: 'AND' withAll:]</body><body package="AT Parser Example">comparison =	#= [#=]	| #&lt;&gt; [#&lt;&gt;]	| #&lt; [#&lt;]	| #&gt; [#&gt;]	| #&lt;= [#&lt;=]	| #&gt;= [#&gt;=]</body><body package="AT Parser Example">comparisonPredicate =	scalarExp comparison		( scalarExp		|	( #ALL ['ALL']			| #ANY ['ANY']			| #SOME ['SOME']			| [''] )		subquery [modifier:with:] )			[| op2 operator |			op2 := stack removeLast.			operator := stack removeLast.			self infix: operator withAll: (Array with: stack removeLast with: op2)]</body><body package="AT Parser Example">existenceTest =	#EXISTS subquery			[modifier: 'EXISTS' with:]</body><body package="AT Parser Example">inPredicate =	| infix |	[ infix := 'IN' ].	scalarExp ( #NOT [infix := 'NOT IN'] . | ) #IN		( subquery		| atom \ $, )			[infix: infix with:with:]</body><body package="AT Parser Example">likePredicate =	columnRef ( #NOT | ) #LIKE atom		( #ESCAPE atom | )</body><body package="AT Parser Example">predicate =	comparisonPredicate	| betweenPredicate	| likePredicate	| testForNull	| inPredicate	| existenceTest</body><body package="AT Parser Example">searchCondition =	booleanTerm \ #OR			[infix: 'OR' withAll:]</body><body package="AT Parser Example">selectRequest =	#SELECT	( #ALL ['ALL']				| #DISTINCT ['DISTINCT']				| [''] )		selection			[| selection |			selection := stack removeLast.			self modifier: stack removeLast with: selection]</body><body package="AT Parser Example">subquery =	$( querySpec $)</body><body package="AT Parser Example">testForNull =	columnRef #IS ( #NOT [false] | [true] ) #NULL			[self postModifier: (stack removeLast						ifTrue:	['IS NULL']						ifFalse:	['IS NOT NULL'])				with: stack removeLast]</body></methods><methods><class-id>Examples.SQLCompiler</class-id> <category>miscellaneous</category><body package="AT Parser Example">baseTable =	( @ user $. [ stack removeLast: 1 ]	| [#()] ) identifier			[ : copyWith: ]			[ identifier: ]</body><body package="AT Parser Example">baseTableID =	identifier</body><body package="AT Parser Example">column =	identifier</body><body package="AT Parser Example">columnList =	$( column \ $, $)</body><body package="AT Parser Example">columnRef =	@	[Array]	( @ user $. tableID $. [ : with:with: ]	| @ tableID $. [ : with: ]	| @ rangeVariable $. [ : with: ]	| [ : new ] )	column			[ : copyWith: ]			[identifier:]</body><body package="AT Parser Example">cursor =	identifier</body><body package="AT Parser Example">literal =	( string | number )			[ SQLLiteral value: stack removeLast ]</body><body package="AT Parser Example">parameter =	identifier</body><body package="AT Parser Example">rangeVariable =	identifier			[ self identifier: (stack removeLast: 1) ]</body><body package="AT Parser Example">table =	baseTable | view</body><body package="AT Parser Example">tableID =	baseTableID | viewID</body><body package="AT Parser Example">target =	parameterRef</body><body package="AT Parser Example">user =	identifier</body><body package="AT Parser Example">view =	( @ user $. [ stack removeLast: 1 ]	| [#()] ) identifier			[ : copyWith: ]			[identifier:]</body><body package="AT Parser Example">viewID =	identifier</body></methods><methods><class-id>Examples.SQLCompiler</class-id> <category>manipulative statements</category><body package="AT Parser Example">assignment =	column #= ( scalarExp | #NULL )</body><body package="AT Parser Example">closeStatement =	#CLOSE cursor			[statement: 'CLOSE' with:]</body><body package="AT Parser Example">commitStatement =	#COMMIT #WORK			[statement: 'COMMIT WORK']</body><body package="AT Parser Example">deleteStatement =	#DELETE #FROM table		( (@ #WHERE #CURRENT) #OF cursor				[clause: 'WHERE CURRENT OF' with:]		| whereClause )			[statement: 'DELETE FROM' with:with:]</body><body package="AT Parser Example">fetchStatement =	#FETCH cursor #INTO target \ $,			[statement: 'FETCH' with:with:]</body><body package="AT Parser Example">insertAtom =	atom	| #NULL [identifier: #('NULL' )]</body><body package="AT Parser Example">insertStatement =	#INSERT #INTO table ( columnList [ : -&gt; "Create an association with the table as key and the columns as value" ]						| )		( #VALUES $( insertAtom \ $, $)				[clause: 'VALUES' withAll:]		| querySpec )			[statement: 'INSERT INTO' with:with:]</body><body package="AT Parser Example">manipulativeStatement =	closeStatement	| commitStatement	| deleteStatement	| fetchStatement	| insertStatement	| openStatement	| rollbackStatement	| selectStatement	| updateStatement</body><body package="AT Parser Example">openStatement =	#OPEN cursor			[statement: 'OPEN' with:]</body><body package="AT Parser Example">rollbackStatement =	#ROLLBACK #WORK			[statement: 'ROLLBACK WORK' ]</body><body package="AT Parser Example">selectStatement =	selectRequest		#INTO target \ $,		tableExp			[| tableExp targets |			tableExp := stack removeLast.			targets := stack removeLast.			SQLStatement named: 'SELECT' arguments: (Array with: stack removeLast with: targets), tableExp]</body><body package="AT Parser Example">updateStatement =	#UPDATE table #SET assignment \ $,		( (@ #WHERE #CURRENT) #OF cursor				[clause: 'WHERE CURRENT OF' with:]	 	| whereClause )			[statement: 'UPDATE' with:with:with:]</body></methods><methods><class-id>Examples.SQLCompiler</class-id> <category>general parsing</category><body package="AT Parser Example">identifier	"Test to see if the token is a valid SQL variable name. Note that reserved 	words will not have a tokenType of #word"	^(tokenType == #word and: [token size &lt;= 18])		ifTrue: 			[stack addLast: token.			self scanToken.			true]		ifFalse: [false]</body><body package="AT Parser Example">method =	word [:asSymbol]	manipulativeStatement *			[: -&gt; ]</body></methods><methods><class-id>Examples.SQLCompiler class</class-id> <category>fileIn/Out</category><body package="AT Parser Example">prerequisitesForLoading		| list |	list := super prerequisitesForLoading.	list		add: SQLLiteral;		add: SQLFunction;		add: SQLClause;		add: SQLInfixOperation;		add: SQLModifier;		add: SQLPostModifier;		add: SQLIdentifier;		add: SQLStatement.	^list</body></methods><methods><class-id>Examples.SQL</class-id> <category>examples</category><body package="AT Parser Example">example	"SQL new example"	SELECT DISTINCT SPJX.JNO	INTO	someVariable	FROM	SPJ SPJX	WHERE	NOT EXISTS			(SELECT *			FROM	SPJ SPJY			WHERE	EXISTS					(SELECT *					FROM	SPJ SPJA					WHERE	SPJA.SNO = 'S1'					AND	SPJA.PNO = SPJY.PNO )			AND	NOT EXISTS					(SELECT *					FROM	SPJ SPJB					WHERE	SPJB.SNO = 'S1'					AND	SPJB.PNO = SPJY.PNO					AND	SPJB.JNO = SPJX.JNO ) )</body><body package="AT Parser Example">example2	"SQL new example2"	INSERT	INTO		S ( SNO, CITY, SNAME )	VALUES	( SNO_PARAM, NULL, SNAME_PARAM )</body><body package="AT Parser Example">example3	"SQL new example3"	DELETE FROM table WHERE CURRENT OF cursor</body><body package="AT Parser Example">example4	"SQL new example4"	UPDATE table1 SET column1 = column2 WHERE CURRENT OF cursor</body></methods><methods><class-id>Examples.SQL class</class-id> <category>compiling</category><body package="AT Parser Example">compilerClass	^SQLCompiler</body><body package="AT Parser Example">prerequisitesForLoading	| prerequisites |	prerequisites := super prerequisitesForLoading.	prerequisites add: SQLCompiler.	^prerequisites</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>ExternalLanguageParser</name><environment>Kernel</environment><super>Kernel.GeneralParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AT-ParserCompiler</category><attributes><package>AT Parser Compiler</package></attributes></class></st-source>