<?xml version="1.0"?><st-source><!-- Name: AT System AnalysisNotice: Copyright 1999-2017 Cincom Systems, Inc.  All rights reserved.Comment: Contains system analysis tools.  ClassReports provides a code-checking facility that can detect a number of errors in classes.  SystemAnalyser provides a number of image-checking facilities to find problems such as unbound methods, obsolete classes, and so on.  ReferencePathCollector provides facilities for revealing the path to some object, hence allowing one to track-down unwanted references to garbage.  ManualWriter provides facilities for generating documentation for class protocols.See the Advanced Tools User's Guide for more information.DbIdentifier: bear73DbTrace: 499362DbUsername: smichaelDbVersion: 8.3 - 1DevelopmentPrerequisites: #(#(#any 'AT Menu Support' ''))PackageName: AT System AnalysisParcel: #('AT System Analysis')ParcelName: AT System AnalysisPrerequisiteDescriptions: #(#(#name 'AT Menu Support' #componentType #package))PrerequisiteParcels: #(#('AT Menu Support' ''))PrintStringCache: (8.3 - 1,smichael)Version: 8.3 - 1Pre-Unload Block: 	[:pkg| SystemAnalyzer preUnloadFor: pkg ]Date: 1:43:28 PM March 17, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (mar17.3) of March 17, 2017 on March 17, 2017 at 1:43:28 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>ReferencePathCollector</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>target visited path successBlock rootSet </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AT-SystemAnalysis</category><attributes><package>AT System Analysis</package></attributes></class><comment><class-id>Kernel.ReferencePathCollector</class-id><body>My purpose is to find what is "hanging onto" objects that can't be garbage collected, by finding reference paths to a given object.  A reference path is a sequence of objects such that:	- the first element is a VariableBinding;	- the last element is the given object; and	- each element except the first is referred to by some instance variable of the preceding element.Instance Variables:	target	&lt;Object&gt;  "the object to which we are collecting reference paths"	visited	&lt;IdentitySet&gt;  "all the objects we have visited so far"	path	&lt;OrderedCollection&gt;  "the path to the object currently being examined"	successBlock	&lt;BlockClosure&gt;  "the block to evaluate with completed paths"</body></comment><class><name>ClassNameChooser</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>filter filterV filteredNamesV </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AT-SystemAnalysis</category><attributes><package>AT System Analysis</package></attributes></class><comment><class-id>Tools.ClassNameChooser</class-id><body>ClassNameChooser is a simple model for choosing multiple class names from a list that is constructed by matching all class names against patterns. (See CharacterArray match: for details of matching).  If a '&gt;' is found in a pattern then the meaning of the pattern is 'Category Pattern' &gt; 'Class Pattern'Instance Variables:	filter	&lt;String&gt;  a string of patterns separated by white space	filterV	&lt;ValueHolder on: filter&gt;  	filteredNamesV	&lt;MultiSelectionInList&gt;  the list of class names obtained by matching against the patterns</body></comment><class><name>MessageCollector</name><environment>Tools</environment><super>Kernel.Context</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selfMessages instVarMessages classVarMessages methodSelector labels blockMethods </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AT-SystemAnalysis</category><attributes><package>AT System Analysis</package></attributes></class><comment><class-id>Tools.MessageCollector</class-id><body>I collect the messages that methods send to self, and to individual instance or class variables.Instance Variables:	selfMessages	&lt;IdentityDictionary key: Symbol value: IdentitySet&gt; 						"messages sent to self (sender selector -&gt; message selector)"	instVarMessages	&lt;Array of: ((IdentityDictionary key: Symbol value: IdentitySet) | nil)&gt;						 "messages sent to each instance variable"	classVarMessages	&lt;IdentityDictionary key: Association value: (IdentityDictionary key: Symbol value: IdentitySet)&gt;						"messages sent to each class variable"	methodSelector	&lt;Symbol&gt;  "the selector of the method being analyzed"	labels	&lt;Array of: (Array | nil)&gt;  "stack contents for merging at joins"	blockMethods	&lt;OrderedCollection of: CompiledBlock&gt;  "queue of block methods"The simulator uses the collection of messages to indicate a known variable, and nil to indicate anything else.</body></comment><class><name>ClassDeclarations</name><environment>Tools</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>class instVars classVars classInstVars </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AT-SystemAnalysis</category><attributes><package>AT System Analysis</package></attributes></class><comment><class-id>Tools.ClassDeclarations</class-id><body>I know how to parse a class comment and extract declarations, and to check these declarations against the actual class definition.Instance Variables:	class	&lt;Class&gt;  "the class to check"	instVars	&lt;Collection of: (String -&gt; (Array | nil))&gt;  "types of instance variables"	classVars	&lt;Collection of: (String -&gt; (Array | nil))&gt;  "types of class variables"	classInstVars	&lt;Collection of: (String -&gt; (Array | nil))&gt;  "types of class instance variables"Class Variables:	TypeTemplates	&lt;IdentityDictionary key: Behavior value: String&gt;  "templates for automatically generated declarations"	UnknownType 	&lt;String&gt;  "this is a tag for an unknown type the value is ?type?'.Currently, this class checks declarations of instance variable types, class variable types, and class instance variable types, and subclass responsibilities.The category 'private-builder' is an implementation of that subset of ProgramNodeBuilder protocol that is needed by the type expression parser (in Parser).  The methods return LiteralNodes, rather than simple values, because the parser sends messages like sourcePosition: to them.  The value of the LiteralNode is just a list of class names separated by vertical bars: this makes parseTypeClasses: trivial.  Someday we may change this to accumulate more information.</body></comment><class><name>InstanceTally</name><environment>Tools</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>behavior instanceCount sumVarElements </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AT-SystemAnalysis</category><attributes><package>AT System Analysis</package></attributes></class><comment><class-id>Tools.InstanceTally</class-id><body>An InstanceTally is used to accumulate statistics on the instances of some Behavior.Instance variables:	behavior		&lt;Behavior&gt;  the class of the instances being weighed.	instanceCount	&lt;Integer&gt; number of instances tallied	sumVarElements &lt;Integer&gt; the sum of the instance variable parts seen thus far (in oops or bytes, as appropriate).</body></comment><class><name>MessageAnalyzer</name><environment>Tools</environment><super>Kernel.ProgramNodeEnumerator</super><private>false</private><indexed-type>none</indexed-type><inst-vars>class selector stack variables selfAndSuper argsAndTemps localsByMethod variablesByMethod selfByMethod </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AT-SystemAnalysis</category><attributes><package>AT System Analysis</package></attributes></class><comment><class-id>Tools.MessageAnalyzer</class-id><body>MessageAnalyzer scans a method or methods of a Class looking for anomalies of three kinds:	- Messages sent to self that are not implemented in the class or any ancestor;	- Messages sent to shared variables that are not implemented by that shared variable.		Note this considers Pools, ClassVariables and Globals as constants.	- Any argument or temp that receives a set of messages not implemented by any single class (taking inheritance into account).Instance Variables:	class	&lt;Class&gt;  the class being scanned	selector	&lt;Symbol&gt;  the selector of the current method	stack	&lt;OrderedCollection of: VariableNode&gt;  a stack used to find node that is the receiver of a message	variables	&lt;Dictionary&gt;  saves messages sent to instance variables, and shared variables for storing in variablesByMethod	selfAndSuper  &lt;Array&gt;	saves messages sent to self and super for storing in selfByMethod	argsAndTemps	&lt;IdentityDictionary&gt;  saves  messages sent to locals for storing in localsByMethod	localsByMethod  &lt;IdentityDictionary&gt;  saves an argsAndTemps for each selector	variablesByMethod &lt;IdentityDictionary&gt;  saves variables for each selector	selfByMethod &lt;IdentityDictionary&gt;  saves selfAndSuper for each selector</body></comment><class><name>ClassReporter</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>list correctnessBrowsingChoice mode filteredClassList sentButNotImplemented implementedButNotSent goodComment undeclared methodConsistency instVarsNotReferenced subclassResponsibilitiesNotImplemented spaceReport manualWriter sysAnalyzer compatibilityMessages indefiniteCompatibilityMessages compatibilityClasses subBuilder correctnessType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AT-SystemAnalysis</category><attributes><package>AT System Analysis</package></attributes></class><comment><class-id>Tools.ClassReporter</class-id><body>This class supports an application for reporting and browsing various things about classesInstance Variables:submode for correctness	correctnessBrowsingChoice	&lt;ValueHolder of: (#browseSentButNotImplemented | #browseImplementedButNotSent | #browseInconsistentMethods | #browseSubclassResponsibilitiesNotImplemented | #browseUndeclareds)&gt;  correctness browsing mode	list		&lt;SelectionInList&gt; model for the notebook	mode	&lt;PluggableAdaptor on: list&gt;  the mode	filteredClassList	&lt;ClassNameChooser&gt;  used in selecting classes	sentButNotImplemented	&lt;ValueHolder of: Boolean&gt;  used for choosing report	implementedButNotSent	&lt;ValueHolder of: Boolean&gt;  used for choosing report	goodComment	&lt;ValueHolder of: Boolean&gt;   used for choosing report	undeclared		&lt;ValueHolder of: Boolean&gt;   used for choosing report	methodConsistency	&lt;ValueHolder of: Boolean&gt;   used for choosing report	instVarsNotReferenced	&lt;ValueHolder of: Boolean&gt;   used for choosing report	compatibilityMessages &lt;ValueHolder of: Boolean&gt;  used for choosing report	indefiniteCompatibilityMessages &lt;ValueHolder of: Boolean&gt;  used for choosing report	compatibilityClasses  &lt;ValueHolder of: Boolean&gt;  used for choosing report	subclassResponsibilitiesNotImplemented	&lt;ValueHolder of: Boolean&gt;   used for choosing report	spaceReport	&lt;ValueHolder of: (#classWeightReport | #methodWeightReport | #instanceWeightReport)&gt;  space report mode	manualWriter &lt;ManualWriter&gt; the manual writer to produce nice listings	sysAnalyzer &lt;SystemAnalyzer&gt; used to analyze for reports and browsing.  It is short livedClass Variables:	ReportSuspectedAbstractClasses	&lt;Boolean&gt;	used to determine whether to print suspected Abstract classes in one report</body></comment><class><name>SystemAnalyzer</name><environment>Tools</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>allSentMessages allImplementedMessages allUndeclaredAssociations allCompatibilityClasses allCompatibilityMessages allIndefiniteCompatibilityMessages </inst-vars><class-inst-vars></class-inst-vars><imports>			private Smalltalk.OpcodePool.*			</imports><category>AT-SystemAnalysis</category><attributes><package>AT System Analysis</package></attributes></class><comment><class-id>Tools.SystemAnalyzer</class-id><body>SystemAnalyzer provides answers to a number of interesting queries about the system.  See the utilities protocol of the class.Instance variables:	allSentMessages						&lt;IdentitySet&gt; cache of all messages sent by all classes in the system	allImplementedMessages				&lt;IdentitySet&gt; cache of all messages implemented in the system	allUndeclaredAssociations				&lt;IdentitySet&gt; cache of undeclared Associations	allCompatibilityMessages				&lt;IdentitySet&gt; cache of all messages know to be for backward compatibility	allIndefiniteCompatibilityMessages	&lt;IdentitySet&gt; cache of all messages used non-exclusively for backward compatibility	allCompatibilityClasses				&lt;IdentitySet&gt; cache of all class names that exist for backward compatibilityClass variables:	BytesInOOP		&lt;Integer&gt; Number of bytes per pointer slot	BytesInHeader	&lt;Integer&gt; Number of bytes in header</body></comment><class><name>ManualWriter</name><environment>Tools</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>instance comment class protocols private method methodComment methodBody reportOrPrint classList postScript </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AT-SystemAnalysis</category><attributes><package>AT System Analysis</package></attributes></class><comment><class-id>Tools.ManualWriter</class-id><body>Class ManualWriter generates manual pages for a list of classes.Instance Variables:	instance			&lt;ValueHolder of: Boolean&gt;  switch to control generation of manual	comment		&lt;ValueHolder of: Boolean&gt;  switch to control generation of manual	class			&lt;ValueHolder of: Boolean&gt;  switch to control generation of manual	protocols		&lt;ValueHolder of: Boolean&gt;  switch to control generation of manual	private			&lt;ValueHolder of: Boolean&gt;  switch to control generation of manual	method			&lt;ValueHolder of: Boolean&gt;  switch to control generation of manual	methodComment	&lt;ValueHolder of: Boolean&gt;  switch to control generation of manual	methodBody		&lt;ValueHolder of: Boolean&gt;  switch to control generation of manual	reportOrPrint		&lt;ValueHolder of: (#print | #report)&gt;  mode to choose between printing or reporting	classList		&lt;Array of: Classes&gt;		The list of classes for the Manual	postScript		&lt;Boolean&gt;			True if printing to postScript documentClass Variables:	DefinitionTabSize	&lt;Number&gt;		Size in inches of postScript tab stops for definition text	NormalTabSize		&lt;Number&gt;		Size in inches of postScript tab stops for normal text</body></comment><shared-variable><name>UnknownType</name><environment>Tools.ClassDeclarations</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>AT System Analysis</package></attributes></shared-variable><shared-variable><name>TypeTemplates</name><environment>Tools.ClassDeclarations</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>AT System Analysis</package></attributes></shared-variable><shared-variable><name>ReportSuspectedAbstractClasses</name><environment>Tools.ClassReporter</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>AT System Analysis</package></attributes></shared-variable><shared-variable><name>DefinitionTabSize</name><environment>Tools.ManualWriter</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>AT System Analysis</package></attributes></shared-variable><shared-variable><name>NormalTabSize</name><environment>Tools.ManualWriter</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>AT System Analysis</package></attributes></shared-variable><shared-variable><name>BytesInHeader</name><environment>Tools.SystemAnalyzer</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>AT System Analysis</package></attributes></shared-variable><shared-variable><name>BytesInOOP</name><environment>Tools.SystemAnalyzer</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>AT System Analysis</package></attributes></shared-variable><methods><class-id>Kernel.ReferencePathCollector</class-id> <category>public access</category><body package="AT System Analysis">allReferencePathsTo: anObject	" Answer a collection of all the reference paths	to anObject. "	| refs |	refs := OrderedCollection new.	self referencePathsTo: anObject do:		[:rpath | refs add: rpath].	^refs</body><body package="AT System Analysis">allReferencePathsTo: anObject from: root	"Answer a collection of all the reference paths to anObject from anObject."	| refs |	refs := OrderedCollection new.	self ignore: thisContext.	self referencePathsTo: anObject fromRoots: (Array with: root) do:		[:rpath | refs add: rpath].	^refs</body><body package="AT System Analysis">ignore: anObject	"Ignore paths through anObject."	nil == visited		ifTrue: [visited := IdentitySet new: 10000].	visited add: anObject</body><body package="AT System Analysis">referencePathsTo: anObject do: aBlock	"For each reference path to anObject,	 evaluate aBlock with the path. Answer nil. "	self ignore: thisContext; ignore: Processor activeProcess.	^self referencePathsTo: anObject		fromRoots: (Array					with: Root					with: (ObjectMemory objectRegisteredWithEngineFor: 'sysOopRegistry'))		do: [:aPath| aBlock value: (self shorten: aPath)]</body><body package="AT System Analysis">someReferencePathTo: anObject	" Answer some reference path to anObject.	If we can't find such a path, answer nil. "	self referencePathsTo: anObject do:		[:rpath | ^self shorten: rpath].	^nil</body><body package="AT System Analysis">someReferencePathTo: anObject from: root	" Answer some reference path to anObject.	If we can't find such a path, answer nil. "	self ignore: thisContext.	self referencePathsTo: anObject fromRoots: (Array with: root) do:		[:rpath | ^rpath].	^nil</body></methods><methods><class-id>Kernel.ReferencePathCollector</class-id> <category>private-reflection protocol</category><body package="AT System Analysis">_object: anObject at: anInteger	"Answer the value of an indexable field in anObject. Fail if the	 argument anInteger is not an Integer or is out of bounds."	&lt;primitive: 160&gt;	^Object subscriptOutOfBoundsSignal raiseRequestWith: anInteger</body><body package="AT System Analysis">_object: anObject instVarAt: anInteger	"Answer with a fixed variable in anObject.  The numbering of the variables	 corresponds to the named instance variables.  Fail if the index is not an	 Integer or is not the index of a fixed variable."	&lt;primitive: 173&gt;	^Object subscriptOutOfBoundsSignal raiseRequestWith: anInteger</body><body package="AT System Analysis">_objectClass: anObject	"Answer the object which is the argument's class.."	&lt;primitive: 211&gt;	^self primitiveFailed</body><body package="AT System Analysis">_objectSize: anObject	"Answer the number of indexable fields in the argument anObject.	 This value is the same as the largest legal subscript."	&lt;primitive: 162&gt;	"The number of indexable fields of fixed-length objects is 0"	^0</body></methods><methods><class-id>Kernel.ReferencePathCollector</class-id> <category>private</category><body package="AT System Analysis">computeRootSet	"Compute the set of named roots, used to truncate paths to a minimum length.	 This is an IdentityDictionary from root object (Class, NameSpace or VariableBinding)	 to the path from a namable root to that object.  This complication is necessary because	 VariableBindings aren't autometonymic (self-naming); only Classes and NameSpaces	 know their names.  So while VariableBindings in system name spaces are roots their	 named root is actually their enclosing class or namespace."	| block |	rootSet := IdentityDictionary new: 1000.	block := [:nameSpace |		rootSet at: nameSpace put: #().		nameSpace asNameSpace bindingsDo:			[:binding|			binding isForGeneral ifTrue:				[rootSet					at: binding					put: (nameSpace referencePathToBinding: binding)].			(binding isForClass			 or: [binding isForNameSpace]) ifTrue:				[block value: binding value]]].	block value: Root</body><body package="AT System Analysis">referencePathsTo: anObject from: rootObject do: aBlock	"For each reference path to anObject,	evaluate aBlock with the path."	^self 		referencePathsTo: anObject 		fromRoots: (Array with: rootObject)		do: aBlock</body><body package="AT System Analysis">referencePathsTo: anObject fromRoots: roots do: aBlock	" For each reference path to anObject,	evaluate aBlock with the path.	Answer nil. "	successBlock := aBlock.	target := anObject.	self ignore: thisContext; ignore: Processor activeProcess.	path := OrderedCollection new: 100.	roots do: [:root| self trace: root].	^nil</body><body package="AT System Analysis">shorten: aPath	"Answer a copy of the path truncated to the last root reference (a Class or NameSpace)"	rootSet isNil ifTrue: [self computeRootSet].	aPath size - 1 to: 1 by: -1 do:		[:i| | referent rootPath |		referent := aPath at: i.		(rootPath := rootSet at: referent ifAbsent: nil) ~~ nil ifTrue:			[^rootPath, (aPath copyFrom: i to: aPath size) asArray]].	^aPath</body><body package="AT System Analysis">trace: anObject	" Recursively trace from anObject,	looking for the target. "	| objcl |	anObject == target ifTrue:		[path addLast: anObject.		" Note that we have to copy the path,		because we will modify it if we continue. "		successBlock value: path asArray.		^self].	anObject == nil ifTrue: [^self].	objcl := self _objectClass: anObject.	"Do not trace immediates or byte-types."	objcl isBits ifTrue: [^self].	(visited includes: anObject) ifTrue: [^self].	visited add: anObject.	path addLast: anObject.	" Recursively trace the instance variables."	objcl isGCSpecialClass		ifTrue:			[(objcl isWeak "a WeakArray's indexable fields are weak and hence don't count"			  or: [anObject isActiveEphemeron not]) "an active Ephemeron's fields are weak and hence don't count"				ifTrue:					[1 to: objcl instSize do:						[:index | self trace: (self _object: anObject instVarAt: index)]]]		ifFalse:			[objcl isVariable				ifTrue: 					[1 to: (self _objectSize: anObject) do:						[:index | self trace: (self _object: anObject at: index)]].			1 to: objcl instSize do:				[:index | self trace: (self _object: anObject instVarAt: index)]].	path removeLast</body></methods><methods><class-id>Kernel.ReferencePathCollector class</class-id> <category>utilities</category><body package="AT System Analysis">allReferencePathsTo: anObject	" Answer a collection of all the reference paths	to anObject. "	^self new allReferencePathsTo: anObject</body><body package="AT System Analysis">referencePathsTo: anObject do: aBlock	" For each reference path to anObject,	evaluate aBlock with the path.	Answer nil. "	^self new referencePathsTo: anObject do: aBlock</body><body package="AT System Analysis">referencePathsTo: anObject from: anOtherObject do: aBlock	" For each reference path to anObject from anOtherObject,	evaluate aBlock with the path.	Answer nil. "	^self new referencePathsTo: anObject from: anOtherObject do: aBlock</body><body package="AT System Analysis">someReferencePathTo: anObject	" Answer some reference path to anObject.	If we can't find such a path, answer nil. "	"ReferencePathCollector someReferencePathTo: ReferencePathCollector"	^self new someReferencePathTo: anObject</body><body package="AT System Analysis">someReferencePathTo: anObject from: anOtherObject	" Answer some reference path to anObject from anOtherObject.	If we can't find such a path, answer nil. "	^self new someReferencePathTo: anObject from: anOtherObject</body></methods><methods><class-id>Tools.ClassNameChooser</class-id> <category>initialize-release</category><body package="AT System Analysis">initialize	"Initialize the receiver to be all class names."	filter := String with: $*.	filterV := filter asValue.	self filteredNamesV list: self baseList.</body></methods><methods><class-id>Tools.ClassNameChooser</class-id> <category>accessing</category><body package="AT System Analysis">addAll	"Select all the elements in the receiver's name list that match the filter."	self filteredNamesV selectAll</body><body package="AT System Analysis">clearAll	"Remove all the receiver's selections."	self filteredNamesV clearAll</body><body package="AT System Analysis">filter	"Answer the receiver's filter."	^filter</body><body package="AT System Analysis">filter: aController	"Set the receiver's filter string."	filter := aController text asString.	filter isEmpty		ifTrue: [filter := String with: $*].	self makeFilteredList.	^true</body><body package="AT System Analysis">filteredList	"Answer the list of selectable names."	^filteredNamesV list</body><body package="AT System Analysis">selectedNames	"Answer the receiver's selected names."	^self filteredNamesV selections</body></methods><methods><class-id>Tools.ClassNameChooser</class-id> <category>aspects</category><body package="AT System Analysis">filterV	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^filterV isNil		ifTrue:			[filterV := String new asValue]		ifFalse:			[filterV]</body><body package="AT System Analysis">filteredNamesV	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^filteredNamesV isNil		ifTrue:			[filteredNamesV := MultiSelectionInList new]		ifFalse:			[filteredNamesV]</body></methods><methods><class-id>Tools.ClassNameChooser</class-id> <category>private</category><body package="AT System Analysis">baseList	^((Smalltalk withAllNameSpacesAndAllClasses reject: [:each | each isKindOf: NameSpace]) asSortedCollection: [:a :b | a name &lt; b name]) collect: [:i | i fullName]</body><body package="AT System Analysis">makeFilteredList	self makeFilteredListFromPatterns: (self patternsFromString: filter)</body><body package="AT System Analysis">makeFilteredListFromPatterns: patternArray	"Answer a list of selectable names by running the base list through all filters."	| included filteredList baseList |	included := Set new.	1 to: patternArray size do:		[:i |		| listAndPattern pattern classList |		listAndPattern := self namesAndPatternFor:  (patternArray at: i).		pattern := listAndPattern at: 2.		classList := listAndPattern at: 1.		1 to: classList size do:			[:j |			| element |			element := classList at: j.			(included includes: element) ifFalse:				[((pattern match: element)				or: [(element includes: $.)					and: ['*.', pattern match: element]])					ifTrue: [included add: element]]]].	baseList := self baseList.	filteredList := OrderedCollection new.	1 to: baseList size do:		[:i |		| element |		element := baseList at: i.		(included includes: element) ifTrue: [filteredList add: element]].	self filteredNamesV list: filteredList.</body><body package="AT System Analysis">namesAndPatternFor: aPattern	| index categoryPattern classPattern classNames |	index := aPattern nextIndexOf: $&gt; from: 1 to: aPattern size.	index isNil ifTrue: 		[^Array with: self baseList with: aPattern].	categoryPattern := aPattern copyFrom: 1 to: index - 1.	classPattern := aPattern copyFrom: index + 1 to: aPattern size.	categoryPattern isEmpty ifTrue: [categoryPattern := '*'].	classPattern isEmpty ifTrue: [classPattern := '*'].	classNames := OrderedCollection new.	Smalltalk withAllNameSpacesDo: 		[:nameSpace | | categories |		categories := nameSpace organization categories select: [:each | categoryPattern match: each].		categories do: 			[:each | 			(nameSpace organization listAtCategoryNamed: each) do: 				[:symbol | | binding |				(binding := nameSpace bindingFor: symbol) isForClass ifTrue:					[classNames add: binding value fullName]]]].	^Array 		with: classNames		with: classPattern</body><body package="AT System Analysis">patternsFromString: aString	| stream oc |	oc := OrderedCollection new.	stream := aString readStream.	[stream atEnd] whileFalse:		[| s2 ch |		stream skipSeparators.		s2 := (String new: 8) writeStream.		[stream atEnd or: [(ch := stream next) isSeparator]] whileFalse:			[ch == $'				ifTrue: [[stream atEnd or: [(ch := stream next) == $']] whileFalse: [s2 nextPut: ch]]				ifFalse: [ch == $\							ifTrue: [stream atEnd ifFalse: [s2 nextPut: stream next]]							ifFalse: [s2 nextPut: ch]]].		oc add: s2 contents].	^oc</body></methods><methods><class-id>Tools.ClassNameChooser</class-id> <category>private - menus</category><body package="AT System Analysis">listMenu	"Answer a simple menu for adding or clearing selections."	^Menu		labelArray: (Array				with: #AddAll &lt;&lt; #advanced &gt;&gt; 'Add all'				with: #ClearAll &lt;&lt; #advanced &gt;&gt; 'Clear all'				with: #Update &lt;&lt; #advanced &gt;&gt; 'Update')		lines: #[2]		values: #(addAll clearAll makeFilteredList)</body><body package="AT System Analysis">textMenu	^(Menu new)		addPart: TextEditorController editGroup;		addPart: TextEditorController acceptCancel</body></methods><methods><class-id>Tools.MessageCollector</class-id> <category>opcodes-data movement</category><body package="AT System Analysis">pushConstant: value	self push: nil.	(value isMemberOf: BlockClosure) ifTrue:		[blockMethods addLast: value method]</body><body package="AT System Analysis">pushContext	self push: nil</body><body package="AT System Analysis">pushCopiedValues: count	1 to: count do: [:i | self push: nil]</body><body package="AT System Analysis">pushInst: index	| msgs |	(msgs := instVarMessages at: index + 1) isNil ifTrue:		[instVarMessages at: index + 1 put: (msgs := IdentityDictionary new)].	self push: msgs</body><body package="AT System Analysis">pushLocal: index	self push: nil</body><body package="AT System Analysis">pushLocalIndirect: majorIndex index: minorIndex	self push: nil</body><body package="AT System Analysis">pushNewArray: size	self push: nil</body><body package="AT System Analysis">pushReceiver	self push: selfMessages</body><body package="AT System Analysis">pushStatic: assoc	self push: (classVarMessages at: assoc ifAbsent: [nil])</body><body package="AT System Analysis">storeInst: index</body><body package="AT System Analysis">storeLocal: index</body><body package="AT System Analysis">storePopLocalIndirect: majorIndex index: minorIndex	self pop</body></methods><methods><class-id>Tools.MessageCollector</class-id> <category>initialize-release</category><body package="AT System Analysis">class: aClass	selfMessages := IdentityDictionary new.	instVarMessages := Array new: aClass instSize.	classVarMessages := IdentityDictionary new.	aClass classPool bindingsDo: [:cv | classVarMessages at: cv put: IdentityDictionary new]</body><body package="AT System Analysis">method: aMethod	| meth fs |	meth := aMethod.	blockMethods := OrderedCollection new.	[super method: meth.	fs := meth frameSize.	fs = 0 ifTrue:		[fs := meth numTemps + 3.		meth isBlockMethod ifTrue:			[fs := fs + meth numCopiedValues]].	stack := Array new: fs.	stackp := 0.	labels := Array new: meth endPC + 1.	[self atEnd] whileFalse:		[| merge |		merge := labels at: pc.		merge notNil ifTrue: [self merge: merge].		self interpretNextInstructionFor: self].	blockMethods isEmpty]		whileFalse:			[meth := blockMethods removeFirst]</body><body package="AT System Analysis">selector: sel	methodSelector := sel</body></methods><methods><class-id>Tools.MessageCollector</class-id> <category>opcodes-control</category><body package="AT System Analysis">jump: delta	labels at: pc + delta put: (stack copyFrom: 1 to: stackp).	self checkMerge</body><body package="AT System Analysis">jump: delta if: condition	self send: (condition ifTrue: [#ifTrue:] ifFalse: [#ifFalse:]) numArgs: 0.	self pop.  "pop the condition"	labels at: pc + delta put: (stack copyFrom: 1 to: stackp)</body><body package="AT System Analysis">makeCopyingBlock: meth count: count	stackp := stackp - count.	self push: nil.	blockMethods addLast: meth</body><body package="AT System Analysis">makeFullBlock: meth	self push: nil.	blockMethods addLast: meth</body><body package="AT System Analysis">makeFullCopyingBlock: meth count: count	stackp := stackp - count.	self push: nil.	blockMethods addLast: meth</body><body package="AT System Analysis">methodPrimitive: index	self push: nil   "For the primitive's failure code"</body><body package="AT System Analysis">methodReturnTop: levels	self checkMerge</body><body package="AT System Analysis">primitiveReturn</body><body package="AT System Analysis">returnTop	self checkMerge</body><body package="AT System Analysis">send: selector numArgs: na	| rcvr |	stackp := stackp - na.	rcvr := stack at: stackp.	rcvr notNil ifTrue:		[self to: rcvr forKey: methodSelector add: selector.		stack at: stackp put: nil]</body><body package="AT System Analysis">sendSuper: selector numArgs: na	stackp := stackp - 1.  "pop super class"	self send: selector numArgs: na  "treat as send to self"</body></methods><methods><class-id>Tools.MessageCollector</class-id> <category>accessing</category><body package="AT System Analysis">classVarMessages	^classVarMessages</body><body package="AT System Analysis">home	"Answer the context in which the receiver was defined.	If this information is not available, answer nil."	^self shouldNotImplement</body><body package="AT System Analysis">homeReceiver	"Answer the receiver from the context	in which the receiver was defined."	^self shouldNotImplement</body><body package="AT System Analysis">instVarMessages	^instVarMessages</body><body package="AT System Analysis">mclass 	"Answer the class in which the receiver's method was found."	^self shouldNotImplement</body><body package="AT System Analysis">selector	"Answer the selector of the method that created the receiver."	^methodSelector</body><body package="AT System Analysis">selfMessages	^selfMessages</body><body package="AT System Analysis">sourceCode 	"Answer the source form of the receiver's method."	^self shouldNotImplement</body></methods><methods><class-id>Tools.MessageCollector</class-id> <category>private</category><body package="AT System Analysis">checkMerge	" We just did an unconditional branch	or return.  Check for an incoming branch. "	| merge |	merge := labels at: pc.	merge notNil ifTrue:		[labels at: pc put: nil.		stackp := merge size.		stack replaceFrom: 1 to: stackp with: merge startingAt: 1]</body><body package="AT System Analysis">findTemp: index do: aBlock elseDo: elseBlock	"index is a linear index that includes all enclosing scopes,	starting with the method scope, and that does not count	compiler-generated temporary variables.  Evaluate aBlock with	the actual context and index where the variable is stored.	Evaluate elseBlock if no such temp exists"	^self shouldNotImplement</body><body package="AT System Analysis">merge: stk	" stk was saved at a branch	to the current pc value. "	| ssize |	ssize := stk size.	1 to: ssize do: [:i | | a b |		a := stack at: i.		a notNil ifTrue:			[b := stk at: i.			b == a ifFalse: [stack at: i put: nil]]].	[stackp &gt; ssize] whileTrue:		[ssize := ssize + 1.		stack at: ssize put: nil]</body><body package="AT System Analysis">pop: count	stackp := stackp - count</body><body package="AT System Analysis">push: elt	stackp := stackp + 1.	stack at: stackp put: elt</body><body package="AT System Analysis">to: dict forKey: aKey add: value	| set |	set := dict at: aKey ifAbsent: [].	set == nil		ifTrue: [set := IdentitySet new.				dict at: aKey put: set].	set add: value</body></methods><methods><class-id>Tools.MessageCollector</class-id> <category>printing</category><body package="AT System Analysis">printOn: aStream 	"Append to the argument aStream a sequence of characters that describes the receiver."	^self basicPrintOn: aStream</body></methods><methods><class-id>Tools.ClassDeclarations</class-id> <category>private-checking</category><body package="AT System Analysis">checkAll: cmt 	^(self checkEmpty: cmt), 	 (self checkMessages: cmt), 	 (self checkSubclassResponsibility: cmt), 	 (self checkInstVars: cmt), 	 (self checkClassVars: cmt), 	 (self checkClassInstVars: cmt)</body><body package="AT System Analysis">checkAll: cmt forReport: rpt	(cmt indexOfSubCollection: (#UNDERDEVELOPMENT &lt;&lt; #advanced &gt;&gt; 'UNDER DEVELOPMENT') startingAt: 1) ~= 0 ifTrue:		[^rpt			ifTrue: [^Array with: ((#x1sIsMarkedAsUNDERDEVELOPMENT &lt;&lt; #advanced &gt;&gt; '&lt;1s&gt; is marked as UNDER DEVELOPMENT')			expandMacrosWith: class printString)]			ifFalse: [#()]].	^self checkAll: cmt</body><body package="AT System Analysis">checkClassInstVars: cmt	| vars dict |	self getClassInstVars: cmt.	vars := class class instVarNames.	dict := Dictionary new.	1 to: vars size do: [:i | dict at: (vars at: i) asSymbol put: (self civAt: i)].	^self checkVars: vars values: dict heading: 'Class Instance' against: classInstVars</body><body package="AT System Analysis">checkClassVars: cmt	| vars |	self getClassVars: cmt.	vars := class classPool keys asSortedCollection asArray collect: [:sym | sym asString].	^self checkVars: vars values: class classPool heading: 'Shared' against: classVars</body><body package="AT System Analysis">checkEmpty: cmt 	"Answer with an error message array if the class has not been commented yet."	^(cmt isNil or: [cmt isEmpty])		ifTrue: [Array with: ((#x1pHasNotBeenCommentedYet &lt;&lt; #advanced &gt;&gt; '&lt;1p&gt; has not been commented yet.')			expandMacrosWith: class)]		ifFalse: [Array new]</body><body package="AT System Analysis">checkInstVars: cmt	self getInstVars: cmt.	^self checkVars: self instVarNamesToDeclare heading: 'Instance' against: instVars</body><body package="AT System Analysis">checkMessages: cmt 	| checkMessagesErrors |	self getInstVars: cmt.	self getClassVars: cmt.	self getClassInstVars: cmt.	checkMessagesErrors := (self checkMessages: (self messages: class) in: class instVars: instVars heading: 'instance') ,	(self checkMessages: (self messages: class class) in: class class instVars: classInstVars heading: 'class').	^checkMessagesErrors isEmpty		ifTrue: [checkMessagesErrors]		ifFalse: [(Array with: (#SomeMessagesNotUnderstoodByCommentedClass &lt;&lt; #advanced &gt;&gt; 'Some messages are not understood by the commented class of the receiving variable:') asString) , checkMessagesErrors]</body><body package="AT System Analysis">checkMessages: coll in: aClass instVars: iv heading: which	" coll is a MessageCollector that has analyzed all the methods of the	  class aClass. iv is the parsed types of the instance variables of the	  class, which is either 'instance' or 'class'.  Answer the usual list of errors. "	| err ctypes vnames mlist |	err := (Array new: 5) writeStream.	" Check messages sent to self. "	coll selfMessages keysAndValuesDo:	[:smKey :smValue |	smValue do:		[:sel |		(aClass canUnderstand: sel) ifFalse:			[err nextPut: (#TheMethodSendsTheMessageButNeitherUnderstands &lt;&lt; #advanced &gt;&gt; 'The &lt;1s&gt; method &lt;2s&gt; sends the message &lt;3s&gt; to self, but neither &lt;4p&gt; nor any superclass understands this message.'			expandMacrosWith: which			with: smKey			with: sel			with: class)]]].	" Check messages sent to instance variables. "	iv notNil ifTrue:		[vnames := aClass instVarNames.		ctypes := Dictionary new.		iv do: [:nt | ctypes at: nt key put: (self parseTypeClasses: nt value)].		mlist := coll instVarMessages.		mlist := mlist copyFrom: mlist size - vnames size + 1 to: mlist size.		1 to: mlist size do: [:i | | vn type ml |			vn := vnames at: i.			type := ctypes at: vn ifAbsent: [#()].			ml := mlist at: i.			(type isEmpty or: [ml isNil]) ifFalse:				[ml keysAndValuesDo: [:smKey :smValue | smValue do: [:sel |					(type contains: [:c | c canUnderstand: sel]) ifFalse:						[err nextPut: (#The1sMethod2s &lt;&lt; #advanced &gt;&gt; 'The &lt;1s&gt; method &lt;2s&gt;'			expandMacrosWith: which			with: (self					messageError: smKey -&gt; sel					to: vn					declaredAs: type))]]]]]].	" Check messages sent to class variables. "	classVars notNil ifTrue:		[ctypes := IdentityDictionary new.		classVars do: [:nt | ctypes at: nt key asSymbol put: (self parseTypeClasses: nt value)].		coll classVarMessages associationsDo: [:aml | | sym type |			sym := aml key key.			type := ctypes at: sym ifAbsent: [#()].			type isEmpty ifFalse:				[aml value keysAndValuesDo: [:smKey :smValue | smValue do: [:sel |					(type contains: [:c | c canUnderstand: sel]) ifFalse:						[err nextPut: (#The1sMethod2s &lt;&lt; #advanced &gt;&gt; 'The &lt;1s&gt; method &lt;2s&gt;'			expandMacrosWith: which			with: (self messageError: smKey -&gt; sel to: sym declaredAs: type))]]]]]].	^err contents</body><body package="AT System Analysis">checkSelectorList: csl against: sels which: instOrClass	" Check a parsed list of (category -&gt; selectors)	against a list of selectors for subclassResponsibility. "	| dsels missing excess |	dsels := OrderedCollection new.	csl do: [:cs | dsels addAll: cs value].	missing := sels select: [:s | (dsels includes: s) not].	excess := dsels select: [:s | (sels includes: s) not].	^(missing isEmpty		ifTrue: [#()]		ifFalse: [missing size = 1					ifTrue: [Array with: ((#MessageShouldBeDescribedAsSubclassResponsibility &lt;&lt; #advanced &gt;&gt; 'The &lt;1s&gt; message &lt;2p&gt; should be described as subclassResponsibility, but is not.')			expandMacrosWith: instOrClass			with: (missing asArray at: 1))]					ifFalse: [Array with: ((#MessagesShouldBeDescribedAsSubclassResponsibility &lt;&lt; #advanced &gt;&gt; 'The following &lt;1s&gt; messages should be described as subclassResponsibility, but are not: &lt;2p&gt;')			expandMacrosWith: instOrClass			with: missing asArray)]]) ,	(excess isEmpty		ifTrue: [#()]		ifFalse: [excess size = 1					ifTrue: [Array with: ((#MessageShouldNotBeDescribedAsSubclassResponsibility &lt;&lt; #advanced &gt;&gt; 'The &lt;1s&gt; message &lt;2p&gt; is described as subclassResponsibility, but should not be.')			expandMacrosWith: instOrClass			with: (excess asArray at: 1))]					ifFalse: [Array with: ((#MessagesShouldNotBeDescribedAsSubclassResponsibility &lt;&lt; #advanced &gt;&gt; 'The following &lt;1s&gt; messages are described as subclassResponsibility, but should not be: &lt;2p&gt;')			expandMacrosWith: instOrClass			with: excess asArray)]])</body><body package="AT System Analysis">checkSubclassResponsibility: cmt	| sr srClass dsr dsrClass scan first |	sr := class whichSelectorsReferTo: 'subclassResponsibility' asSymbol.	srClass := class class whichSelectorsReferTo: 'subclassResponsibility' asSymbol.	dsr := dsrClass := #().	scan := cmt readStream.	(self findHeading: 'Subclasses must implement' where: [:line | line skipThrough: $:. true] in: scan)	  ifTrue:		[| pos1 pos2 |		pos1 := scan position.		first := self parseTabs: scan.		(first notNil and: [(first value sameAs: 'instance protocol') or: [first value sameAs: 'instance protocol:']])		  ifTrue: [dsr := self parseSelectorList: first key in: scan]		  ifFalse: [scan position: pos1].		pos2 := scan position.		first := self parseTabs: scan.		(first notNil and: [(first value sameAs: 'class protocol') or: [first value sameAs: 'class protocol:']])		  ifTrue: [dsrClass := self parseSelectorList: first key in: scan]		  ifFalse: [scan position: pos2].		scan position = pos1 ifTrue:  "didn't find either one"			[dsr := self parseSelectorList: 0 in: scan]].	^(self checkSelectorList: dsr against: sr which: 'instance') ,	(self checkSelectorList: dsrClass against: srClass which: 'class')</body><body package="AT System Analysis">checkVars: vars heading: aString against: found	| lcname err foundVars missing |	lcname := aString asLowercase.	vars isEmpty ifTrue:		[^(found isNil or: [found isEmpty])			ifTrue: [#()]			ifFalse:				[Array with: (#ClassHasNoVariablesButHasACommentDescribingThem							&lt;&lt; #advanced							&gt;&gt; '&lt;1p&gt; has no &lt;2s&gt; variables, but it has a comment describing them.'								expandMacrosWith: class with: lcname)]].	found isNil ifTrue:		[^Array with: ((vars size = 1						ifTrue:							[#ClassHasVariableButNoCommentDescribingIt								&lt;&lt; #advanced								&gt;&gt; '&lt;1p&gt; has &lt;2p&gt; &lt;3s&gt; variable, but no comment describing it.']						ifFalse:							[#ClassHasVariableButNoCommentDescribingThem								&lt;&lt; #advanced								&gt;&gt; '&lt;1p&gt; has &lt;2p&gt; &lt;3s&gt; variables, but no comment describing them.'])							expandMacrosWith: class							with: vars size							with: lcname)].	err := (Array new: 3) writeStream.	foundVars := found collect: [:vt | vt key].	missing := vars reject: [:v | foundVars includes: v].	missing notEmpty ifTrue:		[err nextPut:			(missing size = 1				ifTrue: [#ThereIsNoDescriptionOf1sVariable2p						&lt;&lt; #advanced						&gt;&gt; 'There is no description of the &lt;1s&gt; variable &lt;2p&gt;.'							expandMacrosWith: lcname with: missing first]				ifFalse: [#ThereAreNoDescriptions1sVariables2p						&lt;&lt; #advanced						&gt;&gt; 'There are no descriptions of the &lt;1s&gt; variables &lt;2p&gt;.'							expandMacrosWith: lcname with: missing])].	missing := foundVars reject: [:v | vars includes: v].	missing notEmpty ifTrue:		[err nextPut:			(missing size = 1				ifTrue: [#ThereIsADescriptionOfANonExistent1sVariable2p						&lt;&lt; #advanced						&gt;&gt; 'There is a description of a non-existent &lt;1s&gt; variable &lt;2p&gt;.'							expandMacrosWith: lcname with: missing first]				ifFalse: [#ThereAreDescriptionsOfNonExistent1sVariables2p						&lt;&lt; #advanced						&gt;&gt; 'There are descriptions of non-existent &lt;1s&gt; variables &lt;2p&gt;.'							expandMacrosWith: lcname with: missing])].	found do:		[:vt |		(vars includes: vt key)			ifTrue:				[vt value isNil					ifTrue: [err nextPut: (#TheDescriptionOf1sHasASyntaxError										&lt;&lt; #advanced										&gt;&gt; 'The description of &lt;1s&gt; has a syntax error.'											expandMacrosWith: vt key)]			  ifFalse:				[(self selectNonClasses: vt value) do:					[:t | err nextPut: ((#TheDescriptionOf1s2sIsNotAClassName									&lt;&lt; #advanced									&gt;&gt; 'In the description of &lt;1s&gt;, &lt;2s&gt; is not a class name.')										expandMacrosWith: vt key with: t)]]]].	^err contents</body><body package="AT System Analysis">checkVars: vars values: valueDict heading: aString against: found	| err |	err := self checkVars: vars heading: aString against: found.	" Check the declared types of the class variables	against their actual values. "	found isNil ifTrue: [^err].	found do: [:vt | | value dcl errorStream |		(vt value notNil		 and: [(value := valueDict at: vt key asSymbol ifAbsent: [vt key]) ~~ vt key]) ifTrue:			[dcl := self selectClasses: vt value.			(dcl anySatisfy: [:cls | value isKindOf: cls]) ifFalse:				[errorStream := (String new: 160) writeStream.				errorStream nextPutAll:					(#TheValueOfTheThingIsThatWhichDoesNotMatch					&lt;&lt; #advanced					&gt;&gt; 'The value of the &lt;1s&gt; variable &lt;2s&gt; is &lt;3s&gt;, which does not match the declared type(s) '						expandMacrosWith: aString asLowercase						with: vt key						with: (value isNil ifTrue: [value printString] ifFalse: [value basicPrintString])) asString.				errorStream nextPut: $&lt;.				dcl do: [:d | errorStream print: d] separatedBy: [errorStream nextPut: $| ].				errorStream nextPut: $&gt;; nextPut: $. .				err := err copyWith: errorStream contents]]].	^err</body><body package="AT System Analysis">messageError: selAndMethod to: varName declaredAs: type	" Answer an error string reporting	an apparently invalid message send. "	^(#x1sSendsTheMessage2sTo3sBut4sUnderstands		&lt;&lt; #advanced		&gt;&gt; '&lt;1s&gt; sends the message &lt;2s&gt; to &lt;3s&gt;, but &lt;4s&gt; understand this message.'			expandMacrosWith: selAndMethod key			with: selAndMethod value			with: varName			with: (type size = 1					ifTrue: [(#x1pDoesNot &lt;&lt; #advanced &gt;&gt; '&lt;1p&gt; does not'								expandMacrosWith: type first)]					ifFalse: [(#noneOf1p &lt;&lt; #advanced &gt;&gt; 'none of &lt;1p&gt;'								expandMacrosWith: type)]))</body><body package="AT System Analysis">selectClasses: parsedType	" Answer an Array of those classes	named in parsedType.  nil is treated as	a special case, equivalent to UndefinedObject. "	^self parsedType: parsedType collect:		[:cname :meta | | cls |		cls := cname == #nil				ifTrue: [Object]				ifFalse:					[(cname includes: $.)						ifTrue: [cname asQualifiedReference valueOrDo: []]						ifFalse:							[(BindingReference simpleName: cname in: class asNameSpace) valueOrDo:								[(BindingReference simpleName: cname in: class environment) valueOrDo: []]]].		cls isBehavior ifTrue: [meta ifTrue: [cls class] ifFalse: [cls]] ifFalse: [nil]]</body><body package="AT System Analysis">selectNonClasses: parsedType	"Answer an Array of those names in parsedType that are not	 the names of classes.  nil is treated as a special case, equivalent to UndefinedObject. "	^self parsedType: parsedType collect:		[:cname :meta | | valueOrNil |		valueOrNil := (cname includes: $.)						ifTrue: [cname asQualifiedReference valueOrDo: []]						ifFalse:							[(BindingReference simpleName: cname in: class asNameSpace) valueOrDo:								[(BindingReference simpleName: cname in: class environment) valueOrDo: []]].		(valueOrNil isBehavior or: [cname == #nil])			ifTrue: [nil]			ifFalse: [cname]]</body></methods><methods><class-id>Tools.ClassDeclarations</class-id> <category>initialize-release</category><body package="AT System Analysis">class: aClass	class := aClass.	self flushCache</body><body package="AT System Analysis">flushCache	" Flush cached information. "	instVars := classVars := classInstVars := nil</body></methods><methods><class-id>Tools.ClassDeclarations</class-id> <category>private</category><body package="AT System Analysis">civAt: index	^class instVarAt: index + class superclass class instSize</body><body package="AT System Analysis">instVarNamesToDeclare	| vars |	vars := class instVarNames.	self mustDeclareIndexedVars		ifTrue:			[vars := vars copyWith: '(indexed instance variables)'].	^vars</body><body package="AT System Analysis">messages: aClass	| coll |	coll := MessageCollector new.	coll class: aClass.	aClass selectorsAndMethodsDo: [:sel :meth |		coll selector: sel.		coll method: meth].	^coll</body><body package="AT System Analysis">mustDeclareIndexedVars	^class isVariable and: [class isPointers and: [class superclass isNil or: [class superclass isVariable not]]]</body><body package="AT System Analysis">parsedType: parsedType collect: aBlock	" For each element of parsedType,	evaluate aBlock with two arguments:	the type name, and a flag indicating	whether it is followed by 'class'.	Answer the result of collecting	any non-nil values returned by aBlock. "	| out in sym next isClass val |	parsedType isNil ifTrue: [^#()].	out := (Array new: parsedType size) writeStream.	in := parsedType readStream.	[in atEnd] whileFalse:		[sym := in next.  "class name"		next := in atEnd ifTrue: [nil] ifFalse: [in next].		(isClass := next == #class) ifTrue: [next := in next].		val := aBlock value: sym value: isClass.		val notNil ifTrue: [out nextPut: val].		" next is #| "].	^out contents</body></methods><methods><class-id>Tools.ClassDeclarations</class-id> <category>private-type inference</category><body package="AT System Analysis">inferInstVarTypes	" Answer some inferred instance variable types. "	| itypes mtypes |	itypes := self inferTypesFromInstances.	mtypes := self inferTypesFromMessages.	1 to: itypes size do: [:i | | v |		v := itypes at: i.		itypes at: i put:			((v isNil or: [v class == Object])			  ifTrue: [mtypes at: i]			  ifFalse: [self typeName: v])].	^itypes</body><body package="AT System Analysis">inferReceiver: mset from: all	" mset is a set of messages sent.	all is a dictionary mapping messages	to implementors.  Answer an inferred	type for an object receiving	all the messages in mset. "	" The following is just a heuristic.... "	| cset out |	cset := IdentitySet with: Object.	mset do: [:m | | new |		new := IdentitySet new.		(all at: m) do: [:ic | cset do: [:c |			(ic == c or: [ic inheritsFrom: c])			  ifTrue: [new add: ic]			  ifFalse:				[(c inheritsFrom: ic) ifTrue: [new add: c]]]].		cset := new].	cset := cset select: [:c | (cset detect: [:cc | c inheritsFrom: cc] ifNone: [nil]) isNil].	(cset isEmpty or: [cset includes: Object]) ifTrue: [^UnknownType].	out := (String new: 20) writeStream.	cset do: [:c |		out position = 0 ifFalse: [out nextPutAll: ' | '].		out print: c].	^out contents</body><body package="AT System Analysis">inferTypesFromInstances	" Answer an Array of nils or types	inferred from instances of this class (if any). "	| offset types indexed |	offset := class superclass instSize.	types := Array new: self instVarNamesToDeclare size.	indexed := self mustDeclareIndexedVars.	class allInstancesDo: [:inst |		offset + 1 to: class instSize do: [:i | | value |			value := inst instVarAt: i.			value == nil ifFalse:				[types at: i - offset put: (self unionType: (types at: i - offset) with: value)].			indexed ifTrue:				[1 to: inst basicSize do: [:j |					value := inst basicAt: j.					value == nil ifFalse: [types at: types size put: (self unionType: (types last) with: value)]]]]].	^types</body><body package="AT System Analysis">inferTypesFromMessages	" Answer instance variable types	inferred by analyzing the messages sent. "	| ivm all msgs mtypes |	ivm := (self messages: class) instVarMessages.	ivm := ivm copyFrom: class superclass instSize + 1 to: ivm size.	" Find all the messages sent to each instance variable. "	all := IdentityDictionary new.	msgs := ivm collect: [:csm | | mset |		mset := IdentitySet new.		csm notNil ifTrue:			[csm do: [:sm |				mset addAll: sm.				sm do: [:m | all at: m put: nil]]].		mset].	" Find all the implementors of each message sent to any variable. "	all keysDo: [:m | all at: m put: IdentitySet new].	SystemUtils allBehaviorsDo: [:c |		c selectors do: [:s | | iset |			iset := all at: s ifAbsent: [nil].			iset notNil ifTrue: [iset add: c]]].	" Determine the appropriate declared type. "	mtypes := msgs collect: [:mset | self inferReceiver: mset from: all].	self mustDeclareIndexedVars ifTrue: [mtypes := mtypes copyWith: UnknownType].	^mtypes</body><body package="AT System Analysis">unionType: old with: aValue	| oset nset ot nt |	old isNil ifTrue: [^aValue].	old class = aValue class ifTrue: [^old].	old class == Object ifTrue: [^old].	(old class inheritsFrom: aValue class) ifTrue: [^aValue].	(aValue class inheritsFrom: old class) ifTrue: [^old].	" Look for a common superclass	that isn't Object.  This is a last resort. "	oset := IdentitySet new.	nset := IdentitySet new.	ot := old class.	nt := aValue class.	[ot == nt ifTrue: [^ot basicNew].	(oset includes: nt) ifTrue: [^nt].	(nset includes: ot) ifTrue: [^ot].	oset add: ot.	nset add: nt.	ot == Object ifFalse: [ot := ot superclass].	nt == Object ifFalse: [nt := nt superclass]]		repeat</body></methods><methods><class-id>Tools.ClassDeclarations</class-id> <category>private-parsing</category><body package="AT System Analysis">findHeading: headString where: testBlock in: scan	" If a heading for aString	appears in the stream scan,	position scan appropriately and answer true,	otherwise answer false. "	| cr |	cr := Character cr.	[scan atEnd] whileFalse:		[| line |		line := (scan upTo: cr) readStream.		((line nextAvailable: headString size) sameAs: headString) ifTrue:		 [(testBlock value: line) ifTrue:		  [line peekFor: $:; skipSeparators.		  line atEnd ifTrue: [^true]]]].	^false</body><body package="AT System Analysis">findVariableHeading: aString variables: vars in: scan	" If a heading for aString (Instance or Class)	variables appears in the stream scan,	answer the parsed declarations following	the heading, otherwise answer nil.	Only vars size, not the contents of vars,	is relevant. "	^(self		findHeading: aString , ' Variable'		where: [:line |			line peek = $s			  ifTrue: [line next. true]			  ifFalse: [vars size = 1]]		in: scan)		ifTrue: [self parseVars: scan]		ifFalse: [nil]</body><body package="AT System Analysis">getClassInstVars: cmt	classInstVars isNil ifTrue:		[classInstVars := self findVariableHeading: 'Class Instance' variables: class class instVarNames in: cmt readStream]</body><body package="AT System Analysis">getClassVars: cmt	classVars isNil ifTrue:		[classVars := (self findVariableHeading: 'Class' variables: class classPool in: cmt readStream) ifNil:			[self findVariableHeading: 'Shared' variables: class classPool in: cmt readStream]]</body><body package="AT System Analysis">getInstVars: cmt	instVars isNil ifTrue:		[instVars := self findVariableHeading: 'Instance' variables: self instVarNamesToDeclare in: cmt readStream]</body><body package="AT System Analysis">parseSelectorList: indent in: scan	" Parse a category and selector list.	The categories are indented by	M &gt; indent tabs; the selectors are	indented by N &gt; M tabs.	Answer an array of (category -&gt; selectors).	Leave the stream positioned before	the first item that is indented	K &lt;= indent positions. "	| cat sels result pos line left |	result := (Array new: 5) writeStream.	pos := scan position.	line := self parseTabs: scan.	(line isNil or: [line key &lt;= indent]) ifTrue:		[scan position: pos.  ^#()].	[cat := line value.	left := line key.  "category indentation"	sels := (Array new: 5) writeStream.	[pos := scan position.	line := self parseTabs: scan.	line isNil or: [line key &lt;= left]]		whileFalse:			[" Should check for selector vs. message pattern here.... "			sels nextPut: line value asSymbol].	result nextPut: cat -&gt; sels contents.	line notNil and: [line key &gt; indent]]		whileTrue.	scan position: pos.	^result contents</body><body package="AT System Analysis">parseTabs: scan	" If the next line of the comment is blank,	skip over it and continue scanning.	If the next line of the comment	(disregarding initial spaces)	begins with one or more tabs,	answer (tabCount -&gt; contents).	Otherwise, answer nil. "	| tabs contents |	[tabs := 0.	[scan peekFor: Character space] whileTrue.	[scan peekFor: Character tab] whileTrue: [tabs := tabs + 1].	[scan peekFor: Character space] whileTrue.	scan peekFor: Character cr]		whileTrue.  "skip blank lines"	tabs = 0 ifTrue: [^nil].	contents := scan upTo: Character cr.	[contents isEmpty ifTrue: [^nil].	contents last isSeparator] whileTrue:		[contents := contents copyFrom: 1 to: contents size - 1].	^tabs -&gt; contents</body><body package="AT System Analysis">parseType: typeString	" Parse the typeString if possible.	Answer an array (for now).	If the string can't be parsed,	answer nil. "	| type |	type := [Compiler preferredParserClass new					parseType: typeString readStream					builder: self]				on: Object errorSignal				do: [:ex | ex returnWith: nil].	^type isNil ifTrue: [nil] ifFalse: [type value  "the value from the literal"]</body><body package="AT System Analysis">parseTypeClasses: parsedType 	"Convert the result of parsing 	a type declaration to an Array of classes. 	If the type declaration was invalid, 	answer an empty Array. 	See the class comment for the format 	of parsedType."	^self parsedType: parsedType collect: 		[:cname :meta | 		| cls |		(class scopeHas: cname ifTrue: [:binding | cls := binding value])			ifTrue: [meta					ifTrue: [cls class]					ifFalse: [cls]]			ifFalse: [nil]]</body><body package="AT System Analysis">parseVars: scan	" Parse variable declarations from scan	up to either the end of the stream,	or a blank line followed by a line that	does not begin with a space or tab.	Answer an array of (varName -&gt; type). "	| vars |	vars := (Array new: 6) writeStream.	[scan atEnd] whileFalse:		[scan peek = Character cr		  ifTrue:			[scan next.			(scan atEnd or: [scan peek isSeparator not]) ifTrue: [^vars contents]]		  ifFalse:			[| line vname type parens vtype |			scan skipSeparators.			scan atEnd ifTrue: [^vars contents].			line := (scan upTo: Character cr) readStream.			vname := (String new: 20) writeStream.			parens := line atEnd not and: [line peek = $(].			[line atEnd not and: [parens ifTrue: [line peek = $) ifTrue: [parens := false].  true] ifFalse: [line peek isSeparator not]]] whileTrue:				[vname nextPut: line next].			line skipSeparators.			(line next = $&lt; and:				[type := line through: $&gt;.				" Special hack for embedded -&gt; "				[type size &gt;= 2 and: [type last = $&gt; and: [(type at: type size - 1) = $-]]]					whileTrue: [type := type , (line through: $&gt;)].				type size &gt; 1 and: [type last = $&gt;]])			  ifTrue:				[vtype := self parseType: (type copyFrom: 1 to: type size - 1).				vars nextPut: (vname contents -&gt; vtype)]]].	^vars contents</body></methods><methods><class-id>Tools.ClassDeclarations</class-id> <category>private-builder</category><body package="AT System Analysis">buildType: typeArray	^LiteralNode new value: typeArray</body><body package="AT System Analysis">newLiteralValue: value	^self buildType: (Array with: value class name)</body><body package="AT System Analysis">newMessageReceiver: rcvr selector: selector arguments: args	" The selector is either a keyword selector,	#class, #|, or #-&gt;. "	selector == #class ifTrue: [^self buildType: rcvr value , #(#class)].	selector == #-&gt; ifTrue: [^self buildType: #(#Association)].	selector == #| ifTrue:		[^self buildType: rcvr value , #(#|) , args first value].	" Keyword selector, just discard the arguments. "	^rcvr</body><body package="AT System Analysis">newVariableName: aString	^self buildType: (Array with: aString asSymbol)</body></methods><methods><class-id>Tools.ClassDeclarations</class-id> <category>checking</category><body package="AT System Analysis">check	" Check whether the comment describes	the class and instance variables properly.	Answer an Array of error strings to present to the user.	If the comment is proper, or if checking is disabled	by the present of the phrase UNDER DEVELOPMENT,	answer an empty Array. "	^self checkAll: class comment forReport: false</body><body package="AT System Analysis">checkForReport	" Check whether the comment describes	the class and instance variables properly.	Answer an Array of error strings to present to the user.	If the comment is proper, answer an empty Array. "	^self checkAll: class comment forReport: true</body></methods><methods><class-id>Tools.ClassDeclarations</class-id> <category>private-accessing</category><body package="AT System Analysis">putCommentHeading: aString variables: varNames do: typeBlock on: aStream	varNames isEmpty ifTrue: [^self].	aStream cr; cr; nextPutAll: aString; cr.	1 to: varNames size do: [:index |		aStream tab; nextPutAll: (varNames at: index); tab;			nextPutAll: '&lt;', (typeBlock value: index), '&gt;  comment'; cr]</body><body package="AT System Analysis">putSelectors: selectors of: aClass indent: tabs on: aStream	| org |	org := aClass organization.	org categories do: [:cat | | sub |		sub := (org listAtCategoryNamed: cat) select: [:sel | selectors includes: sel].		sub isEmpty ifFalse:			[aStream nextPutAll: tabs; nextPutAll: cat; cr.			sub do: [:sel | aStream nextPutAll: tabs; tab; nextPutAll: sel; cr]]]</body><body package="AT System Analysis">typeName: value	" Answer the type name deduced from	an existing value.  This is usually,	but not always, the class name. "	| vc cname temp |	value isNil ifTrue: [^'type'].	value isInteger ifTrue: [^'Integer'].	value isSymbol ifTrue: [^'Symbol'].	value isString ifTrue: [^'String'].	(value == true or: [value == false]) ifTrue: [^'Boolean'].	" Look for a template. "	vc := value class.	cname := vc name asString.	[vc isNil] whileFalse:		[temp := TypeTemplates at: vc ifAbsent: [nil].		temp notNil ifTrue:			[temp == false ifTrue: [^cname].			^temp first = Character space ifTrue: [cname , temp] ifFalse: [temp]].		vc := vc superclass].	^cname</body></methods><methods><class-id>Tools.ClassDeclarations</class-id> <category>accessing</category><body package="AT System Analysis">commentTemplateString	"Answer a string to edit in order to produce the comment for the class."	^((#CommentTemplateString &lt;&lt; #advanced &gt;&gt; 'This class has not yet been commented.  The comment should state the purpose of the class, what messages are subclassResponsibility, and the type and purpose of each instance and class variable.&lt;n&gt;The comment should also explain any unobvious aspects of the implementation.&lt;n&gt;&lt;n&gt;') expandMacros asText emphasizeAllWith: #italic), (self formatComment: '')</body><body package="AT System Analysis">formatComment: aComment	" aComment is an existing class comment.	Answer aComment augmented with	filled-in declarations for any sections	that are completely missing, and	including the error report, if any. "	| scan stream added sr pool vars srClass cmt errs types declared defined uncommented |	stream := TextStream on: (String new: aComment size + 200).	stream nextPutAllText: aComment asText.	scan := aComment readStream.	added := OrderedCollection new.	sr := class whichSelectorsReferTo: 'subclassResponsibility' asSymbol.	srClass := class class whichSelectorsReferTo: 'subclassResponsibility' asSymbol.	((sr , srClass) isEmpty not and: [(self findHeading: 'Subclasses must implement' where: [:line | line skipThrough: $:. true] in: scan) not])		ifTrue:			[added add: 'subclass responsibilities'.			stream cr; nextPutAll: 'Subclasses must implement the following messages:'; cr.			srClass isEmpty			  ifTrue: [self putSelectors: sr of: class indent: '	' on: stream]			  ifFalse:				[sr isEmpty ifFalse:					[stream tab; nextPutAll: 'Instance protocol:'; cr.					self putSelectors: sr of: class indent: '		' on: stream].				stream tab; nextPutAll: 'Class protocol:'; cr.				self putSelectors: srClass of: class class indent: '		' on: stream]].	scan reset.	vars := class instVarNames.	vars isEmpty ifFalse:		[declared := self findVariableHeading: 'Instance' variables: vars in: scan.		defined := self instVarNamesToDeclare.		types := self inferInstVarTypes.		uncommented := declared isNil								ifTrue: [defined]								ifFalse: [defined reject: [:ivn| declared contains: [:assoc| ivn = assoc key]]].		(declared isNil or: [uncommented notEmpty]) ifTrue:			[added add: 'instance variables'.			declared isNil				ifTrue:					[self						putCommentHeading: 'Instance Variables:'						variables: defined						do: [:index | types at: index]						on: stream]				ifFalse:					[self						putCommentHeading: 'Uncommented Instance Variables:'						variables: uncommented						do: [:index | types at: (defined indexOf: (uncommented at: index))]						on: stream]]].	scan reset.	pool := class classPool.	(pool isEmpty or:	 [(self findVariableHeading: 'Shared' variables: pool keys in: scan) notNil])		ifFalse:			[added add: 'shared variables'.			vars := pool keys asSortedCollection.			self				putCommentHeading: 'Shared Variables:'				variables: vars				do: [:index | self typeName: (pool at: (vars at: index) ifAbsent: [nil])]				on: stream].	scan reset.	vars := class class instVarNames.	(vars isEmpty or:	 [(self findVariableHeading: 'Class Instance' variables: vars in: scan) notNil])		ifFalse:			[added add: 'class instance variables'.			self				putCommentHeading: 'Class Instance Variables:'				variables: vars				do: [:index | self typeName: (self civAt: index)]				on: stream].	cmt := stream contents.	" Now check the result for errors. "	errs := self checkAll: cmt forReport: false.	errs isEmpty ifFalse:		[stream reset; emphasis: #italic; nextPutAll: (#PleaseNoteTheFollowingProblems &lt;&lt; #advanced &gt;&gt; 'Please note the following possible problems:&lt;n&gt;') expandMacros.		errs do: [:m | stream tab; nextPutAll: m; cr].		added isEmpty ifFalse:			[stream nextPutAll: (#PleaseCheckAutomaticInsertions &lt;&lt; #advanced &gt;&gt; 'Also, please check the automatically inserted descriptions of &lt;1s&gt;' expandMacrosWith: added first).			2 to: added size - 1 do: [:i |				stream nextPutAll: ', '; nextPutAll: (added at: i)].			added size &gt; 2 ifTrue: [stream nextPut: $,].			added size &gt; 1 ifTrue: [stream nextPutAll: (#And1s &lt;&lt; #advanced &gt;&gt; ' and &lt;1s&gt;' expandMacrosWith: added last)].			stream nextPut: $.; cr].		stream cr; emphasis: nil; nextPutAllText: cmt.		cmt := stream contents].	^cmt</body></methods><methods><class-id>Tools.ClassDeclarations class</class-id> <category>utilities</category><body package="AT System Analysis">checkAll	" Check all the classes in the system.	Answer an error report suitable for	human consumption. "	"[:r | (Filename named: 'decl.report') writeStream nextPutAll: r; close]			value: ClassDeclarations checkAll	"	| cset |	cset := IdentitySet new.	SystemUtils allBehaviorsDo: [:cl |		cl isMeta ifFalse: [cset add: cl]].	^self checkClasses: cset</body><body package="AT System Analysis">checkCategories: cats	" Check the given categories.	Answer an error report suitable for	human consumption. "	| cset |	cset := IdentitySet new.	cats do: [:c | cset addAll: ((Smalltalk organization listAtCategoryNamed: c asSymbol) collect: [:cn | Smalltalk at: cn])].	^self checkClasses: cset</body><body package="AT System Analysis">checkClasses: classes	" Check the given classes.	Answer an error report suitable for	human consumption. "	| list report |	list := SortedCollection new.	classes do: [:cl | | err |		err := (self on: cl) checkForReport.		err isEmpty ifFalse: [list add: cl name -&gt; err]].	report := (String new: 100) writeStream.	list do: [:ce |		report nextPutAll: ((#hasTheFollowingProblems &lt;&lt; #advanced &gt;&gt; '&lt;1s&gt; has the following problems:&lt;n&gt;&lt;n&gt;')			expandMacrosWith: ce key).		ce value do: [:m | report tab; nextPutAll: m; cr;cr].		report cr].	^report contents</body><body package="AT System Analysis">commentExample	"(ClassDeclarations on: ClassDeclarations) formatComment: String new"</body></methods><methods><class-id>Tools.ClassDeclarations class</class-id> <category>class initialization</category><body package="AT System Analysis">initialize	"ClassDeclarations initialize"	TypeTemplates := IdentityDictionary new.	UnknownType := '?type?'.	self initializeTemplates</body><body package="AT System Analysis">initializeTemplates	" Initialize a standard set of templates."	self		templateFor: Collection put: ' of: ?type?';		templateFor: Dictionary put: ' key: ?type? value: ?type?';		templateFor: Interval put: false</body><body package="AT System Analysis">templateFor: aClass put: aString	" Add the declaration template for aClass.	If aString begins with a space, prepend	the actual class name to the template,	otherwise just use the template. "	TypeTemplates at: aClass put: aString</body></methods><methods><class-id>Tools.ClassDeclarations class</class-id> <category>instance creation</category><body package="AT System Analysis">on: aClass	^self new class: aClass</body></methods><methods><class-id>Tools.InstanceTally</class-id> <category>private</category><body package="AT System Analysis">setBehavior: beh	behavior := beh</body><body package="AT System Analysis">setInstanceCount: count	instanceCount := count</body><body package="AT System Analysis">setSumVarElements: count	sumVarElements := count</body></methods><methods><class-id>Tools.InstanceTally</class-id> <category>accessing</category><body package="AT System Analysis">averageBytes	"Answer the average number of bytes per instance.	Non-existant instances report as 0."	instanceCount = 0 ifTrue: [^0].	^self totalBytes asFloat / instanceCount</body><body package="AT System Analysis">averageElements	"Answer the average number of elements for variable-size	instances.  Fixed size instances will report as 0, as will	non-existant instances."	instanceCount = 0 ifTrue: [^0].	^sumVarElements asFloat / instanceCount</body><body package="AT System Analysis">behavior	^behavior</body><body package="AT System Analysis">bump: instance 	"Tally another instance."	instanceCount := instanceCount + 1.	behavior isVariable ifTrue: [sumVarElements := sumVarElements + instance basicSize]</body><body package="AT System Analysis">fixedBytes	"Answer the total bytes from fixed parts of the instances."	^((behavior hasImmediateInstances			ifTrue: [0]			ifFalse: [SystemAnalyzer bytesInHeader])		+ (behavior instSize * SystemAnalyzer bytesInOOP))		* instanceCount</body><body package="AT System Analysis">instanceCount	"Answer the number of instances"	^instanceCount</body><body package="AT System Analysis">totalBytes	"Answer the total bytes by the instances."	^self varBytes + self fixedBytes</body><body package="AT System Analysis">varBytes	"Answer the total bytes used in variable parts."	^behavior isBits		ifTrue: [sumVarElements]		ifFalse: [sumVarElements * SystemAnalyzer bytesInOOP]</body></methods><methods><class-id>Tools.InstanceTally</class-id> <category>initialize-release</category><body package="AT System Analysis">initialize	instanceCount := 0.	sumVarElements := 0</body></methods><methods><class-id>Tools.InstanceTally</class-id> <category>printing</category><body package="AT System Analysis">printOn: aStream	| varElements |	varElements := sumVarElements = 0						ifTrue: ['']						ifFalse:							[#x1pTotalVariableElements							 &lt;&lt; #advanced							 &gt;&gt; ', &lt;1p&gt;  total variable elements'								expandMacrosWith: sumVarElements].	aStream nextPutAll: (#x3psInstances						&lt;&lt; #advanced						&gt;&gt; '&lt;1p&gt;(&lt;2p&gt; -- &lt;3p&gt; instances&lt;4s&gt;)'							expandMacrosWith: self class							with: behavior							with: instanceCount							with: varElements)</body></methods><methods><class-id>Tools.InstanceTally class</class-id> <category>instance creation</category><body package="AT System Analysis">for: behavior	"Answer a new InstanceTally set to tally instance of the given	behavior."	| w |	w := self new.	w setBehavior: behavior.	^w</body><body package="AT System Analysis">new	^super new initialize</body></methods><methods><class-id>Tools.MessageAnalyzer</class-id> <category>private</category><body package="AT System Analysis">findNode: aVarNode	| name |	name := aVarNode name.	stack size to: 1 by: -1 do:		[:i |		| node |		node := stack at: i.		node variable name = name			ifTrue: [^node]].	^nil</body><body package="AT System Analysis">implementorsFor: msgs	" Answer an IdentityDictionary whose keys	are members of msgs,	and whose values are Arrays of the	classes that implement those messages. "	| d s a |	" Use two different strategies, depending on	whether msgs is large or small. "	d := IdentityDictionary new: (msgs size * 2 max: 2).	s := (Array new: msgs size) writeStream.	msgs do: [:m | | assoc |		assoc := Association key: m value: OrderedCollection new.		d add: assoc.		s nextPut: assoc].	a := s contents.	SystemUtils allBehaviorsDo: [:cl |		a size &gt; 50			ifTrue:				[" Enumerate the message dictionary,				looking up each selector. "				(cl instVarAt: 2) keysDo: [:sel | | imp |					imp := d at: sel ifAbsent: [nil].					imp == nil ifFalse: [imp add: cl]]]			ifFalse:				[" Enumerate the desired selectors,				checking each one against the				message dictionary. "				1 to: a size do: [:i |					(cl includesSelector: (a at: i) key) ifTrue:						[(a at: i) value add: cl]]]].	a do: [:assoc |		d at: assoc key put: assoc value asArray].	^d</body><body package="AT System Analysis">pop: aNumber	stack removeLast: aNumber</body><body package="AT System Analysis">possibilitiesFor: msgs in: impl	" Answer the set of classes that implement	all the messages in msgs.  Impl is a dictionary	that maps selectors to the classes that	implement them. "	" Since all the sets involved are small,	we implement them as arrays for added speed. "	| poss |	poss := IdentitySet with: Object.	msgs do: [:sel | | i int |		i := impl at: sel ifAbsent: [#()].		" Replace poss with the intersection of		poss and i, taking inheritance into account. "		int := IdentitySet new: poss basicSize.		1 to: i size do: [:ci | | cl |			cl := i at: ci.			(poss includes: cl)				ifTrue: [int add: cl]				ifFalse:					[| csize |					csize := cl instSize.  "for a quick check"					poss do: [:pc | | psize |						psize := pc instSize.						(psize &lt;= csize and: [cl inheritsFrom: pc])							ifTrue: [int add: cl]							ifFalse:								[(psize &gt;= csize and: [pc inheritsFrom: cl])									ifTrue: [int add: pc]]]]].		poss := int].	^poss</body></methods><methods><class-id>Tools.MessageAnalyzer</class-id> <category>enumerating</category><body package="AT System Analysis">doAssignment: aNode variable: var value: val	self doNode: var.	self doNode: val</body><body package="AT System Analysis">doBlock: aNode arguments: args body: seq	self doNodes: args.	self doNode: seq.	self pop: args size</body><body package="AT System Analysis">doCascade: aNode receiver: rcvr messages: msgs	self doNode: rcvr.	self doNodes: msgs</body><body package="AT System Analysis">doLiteral: aNode value: lit	^aNode</body><body package="AT System Analysis">doMessage: aNode receiver: rcvr selector: sel arguments: args	(rcvr isMemberOf: VariableNode)		ifTrue: [| name pNode set |				name := rcvr name.				name = 'self'					ifTrue: [set := selfAndSuper at: 1]					ifFalse: [name = 'super'							ifTrue: [set := selfAndSuper at: 2]							ifFalse: [pNode := self findNode: rcvr.									pNode notNil										ifTrue: [set := argsAndTemps at: pNode]										ifFalse: [set := variables at: rcvr name ifAbsent: [nil].												set == nil ifTrue: [variables at: rcvr name put: (set:= IdentitySet new)]]]].				set add: sel].	self doNode: rcvr.	self doNodes: args</body><body package="AT System Analysis">doMethod: aNode selector: sel primitive: prim block: block	^self doNode: block</body><body package="AT System Analysis">doParameter: aNode variable: var type: type	argsAndTemps at: aNode put: IdentitySet new.	stack add: aNode.	self doNode: var.	self doType: type.</body><body package="AT System Analysis">doReturn: aNode value: value	self doNode: value</body><body package="AT System Analysis">doSequence: aNode temporaries: temps statements: stats	self doNodes: temps.	self doNodes: stats.	self pop: temps size.</body><body package="AT System Analysis">doVariable: aNode name: nameString	^aNode</body></methods><methods><class-id>Tools.MessageAnalyzer</class-id> <category>analysis</category><body package="AT System Analysis">analyzeClass	localsByMethod := IdentityDictionary new.	variablesByMethod := IdentityDictionary new.	selfByMethod := IdentityDictionary new.	class selectors do:		[:sel |		self selector: sel.		self collectMessages.		localsByMethod at: sel put: argsAndTemps.		variablesByMethod at: sel put: variables.		selfByMethod at: sel put: selfAndSuper]</body><body package="AT System Analysis">collectMessages	| parserClass src |	parserClass := class parserClass.	(parserClass isKindOf: Parser class)		ifFalse: [^self error: (#classCanNotBeAnalyzed &lt;&lt; #advanced &gt;&gt; 'class can not be analyzed')].	stack := OrderedCollection new.	argsAndTemps := IdentityDictionary new.	variables := Dictionary new.	selfAndSuper := Array with: IdentitySet new with: IdentitySet new.	"If there is a problem just return because the code is supposed to be right."	src := (class compiledMethodAt: selector) getSource.	src isNil ifTrue: [src := String new].	self doNode: ( parserClass new		parse: src readStream		class: class		noPattern: false		context: nil		notifying: (SilentCompilerErrorHandler new failBlock: [^nil])		builder: ProgramNodeBuilder new		saveComments: true		ifFail: [^nil])</body><body package="AT System Analysis">report	" Answer a report of possible problems. "	| sent impl report  superclass instVarNames |	"Collect all implementations of any message sent to any variable. "	instVarNames := class allInstVarNames asSet.	sent := IdentitySet new.	variablesByMethod keysAndValuesDo:		[:k :d |		d keysAndValuesDo:			[:name :set | (instVarNames includes: name) ifTrue: [sent addAll: set]]].	localsByMethod keysAndValuesDo:		[:k :d | d do: [:set | sent addAll: set]].	impl := self implementorsFor: sent.	superclass := class superclass.	"Report variables that send a collection of messages that no class (or its ancestors) implements all of. "	report := OrderedCollection new.	variablesByMethod keys do: "all the dictionaries have the same keys"		[:key |		| coll  badSet |		coll := OrderedCollection new.		badSet := IdentitySet new.		((selfByMethod at: key) at: 1) do:	"self messages"			[:m | (class canUnderstand: m) ifFalse: [badSet add: m]].		badSet isEmpty			ifFalse: [coll add: (Association key: 'self' value: badSet).					badSet := IdentitySet new].		((selfByMethod at: key) at: 2) do:	"super messages"			[:m | (superclass canUnderstand: m) ifFalse: [badSet add: m]].		badSet isEmpty			ifFalse: [coll add: (Association key: 'super' value: badSet)].		(localsByMethod at: key) keysAndValuesDo:			[:mvKey :mvValue |			| poss |			poss := self possibilitiesFor: mvValue in: impl.			poss isEmpty ifTrue: [coll add: (Association key: mvKey name value: mvValue)]].		(variablesByMethod at: key) keysAndValuesDo:			[:mvKey :mvValue |			| assc |			(instVarNames includes: mvKey)				ifTrue: [| poss |						poss := self possibilitiesFor: mvValue in: impl.						poss isEmpty ifTrue: [coll add: (Association key: mvKey value: mvValue)]]				ifFalse: [(assc := class fullBindingFor: mvKey asSymbol) notNil							ifTrue:								[badSet := IdentitySet new.								mvValue do:	 [:m | (assc value respondsTo: m)												ifFalse: [badSet add: m]].								badSet isEmpty									ifFalse: [coll add: (Association key: mvKey value: badSet)]]]].			coll isEmpty ifFalse: [report add: (Association key: key value: coll)]].	^report</body><body package="AT System Analysis">selector: aSelector	selector := aSelector</body></methods><methods><class-id>Tools.MessageAnalyzer</class-id> <category>initialize-release</category><body package="AT System Analysis">class: aClass	class := aClass</body></methods><methods><class-id>Tools.MessageAnalyzer class</class-id> <category>testing</category><body package="AT System Analysis">test	"(MessageAnalyzer new class: TestClass) analyzeClass; report"</body></methods><methods><class-id>Tools.ClassReporter</class-id> <category>private-doit</category><body package="AT System Analysis">correctnessBrowse	self dispatch: correctnessBrowsingChoice value</body><body package="AT System Analysis">correctnessDoIt	self correctnessType value == #browse		ifTrue: [self correctnessBrowse]		ifFalse: [self correctnessReport]</body><body package="AT System Analysis">correctnessReport	| classes stream log |	classes := self getClasses.	classes isEmpty ifTrue: [^self].	stream := (String new: 256) writeStream.	log := methodConsistency value or: [goodComment value].	log ifTrue: [Transcript cr; show: (#Checking &lt;&lt; #advanced &gt;&gt; 'Checking...') asString; cr].	classes do:		[:class |		log ifTrue: [Transcript print: class; space; flush].		self reportClassCorrectness: class on: stream].	self openReportOn: stream contents labeled: (#Report &lt;&lt; #advanced &gt;&gt; 'Report')</body><body package="AT System Analysis">doIt	Cursor wait showWhile: [self dispatch: mode value]</body><body package="AT System Analysis">manualDoIt	| classes |	classes := self getClasses.	classes isEmpty ifTrue: [^self].	manualWriter classList: classes.	manualWriter doIt</body><body package="AT System Analysis">spaceDoIt	self dispatch: spaceReport value</body></methods><methods><class-id>Tools.ClassReporter</class-id> <category>aspects</category><body package="AT System Analysis">compatibilityClasses	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^compatibilityClasses isNil		ifTrue:			[compatibilityClasses := false asValue]		ifFalse:			[compatibilityClasses]</body><body package="AT System Analysis">compatibilityMessages	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^compatibilityMessages isNil		ifTrue:			[compatibilityMessages := false asValue]		ifFalse:			[compatibilityMessages]</body><body package="AT System Analysis">correctnessBrowsingChoice	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^correctnessBrowsingChoice isNil		ifTrue:			[correctnessBrowsingChoice := nil asValue]		ifFalse:			[correctnessBrowsingChoice]</body><body package="AT System Analysis">correctnessType	^correctnessType isNil		ifTrue: [correctnessType := #report asValue]		ifFalse: [correctnessType]</body><body package="AT System Analysis">goodComment	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^goodComment isNil		ifTrue:			[goodComment := false asValue]		ifFalse:			[goodComment]</body><body package="AT System Analysis">implementedButNotSent	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^implementedButNotSent isNil		ifTrue:			[implementedButNotSent := false asValue]		ifFalse:			[implementedButNotSent]</body><body package="AT System Analysis">indefiniteCompatibilityMessages	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^indefiniteCompatibilityMessages isNil		ifTrue:			[indefiniteCompatibilityMessages := false asValue]		ifFalse:			[indefiniteCompatibilityMessages]</body><body package="AT System Analysis">instVarsNotReferenced	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^instVarsNotReferenced isNil		ifTrue:			[instVarsNotReferenced := false asValue]		ifFalse:			[instVarsNotReferenced]</body><body package="AT System Analysis">methodConsistency	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^methodConsistency isNil		ifTrue:			[methodConsistency := false asValue]		ifFalse:			[methodConsistency]</body><body package="AT System Analysis">reportOrPrint	^manualWriter reportOrPrint</body><body package="AT System Analysis">sentButNotImplemented	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^sentButNotImplemented isNil		ifTrue:			[sentButNotImplemented := false asValue]		ifFalse:			[sentButNotImplemented]</body><body package="AT System Analysis">spaceReport	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^spaceReport isNil		ifTrue:			[spaceReport := nil asValue]		ifFalse:			[spaceReport]</body><body package="AT System Analysis">subclassResponsibilitiesNotImplemented	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^subclassResponsibilitiesNotImplemented isNil		ifTrue:			[subclassResponsibilitiesNotImplemented := false asValue]		ifFalse:			[subclassResponsibilitiesNotImplemented]</body><body package="AT System Analysis">undeclared	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^undeclared isNil		ifTrue:			[undeclared := false asValue]		ifFalse:			[undeclared]</body></methods><methods><class-id>Tools.ClassReporter</class-id> <category>private-correctness reporting</category><body package="AT System Analysis">reportClassCorrectness: class on: stream	sentButNotImplemented value		ifTrue: [self reportSentButNotImplementedFor: class on: stream].	implementedButNotSent value		ifTrue: [self reportImplementedButNotSentFor: class on: stream].	methodConsistency value		ifTrue: [self reportMethodConsistencyFor: class on: stream].	subclassResponsibilitiesNotImplemented value		ifTrue: [self reportSubclassResponsibilitiesNotImplementedFor: class on: stream].	undeclared value		ifTrue: [self reportUndeclaredReferencesFor: class on: stream].	instVarsNotReferenced value		ifTrue: [self reportInstVarsNotReferencedFor: class on: stream].	goodComment value		ifTrue: [self reportCommentFor: class on: stream].	compatibilityMessages value		ifTrue: [self reportCompatibilityMessageReferencesFor: class on: stream].	indefiniteCompatibilityMessages value		ifTrue: [self reportIndefiniteCompatibilityMessageReferencesFor: class on: stream].	compatibilityClasses value		ifTrue: [self reportCompatibilityClassReferencesFor: class on: stream].</body><body package="AT System Analysis">reportCommentFor: class on: stream	| errors |	errors := (ClassDeclarations on: class) checkForReport.	errors notEmpty ifTrue:		[stream nextPutAll: (#hasTheFollowingCommentProblems							&lt;&lt; #advanced							&gt;&gt; '&lt;n&gt;&lt;1p&gt; has the following comment problem&lt;2s&gt;&lt;n&gt;&lt;n&gt;'								expandMacrosWith: class with: (self pluralEndingFor: errors)).		 errors do: [:m | stream tab; nextPutAll: m; cr;cr].		 stream cr].</body><body package="AT System Analysis">reportCompatibilityClassReferencesFor: aClass on: stream	"Put onto stream a report of methods methods which reference backward compatibility Classes."	(Array with: aClass with: aClass class) do:		[:class | | array |		array := self systemAnalyzer allCompatibilityClassReferencesFor: class.		array notEmpty ifTrue:			[stream nextPutAll: (#nl1pRefersToTheFollowingBackwardCompatibilityClasses								&lt;&lt; #advanced								&gt;&gt; '&lt;n&gt;&lt;1p&gt; refers to the following backward compatibility Classes:&lt;n&gt;&lt;n&gt;'									expandMacrosWith: class).			array do: [:s |				stream nextPutAll: (#Tabx1sRefersTo &lt;&lt; #advanced &gt;&gt; '&lt;t&gt;&lt;1s&gt; refers to:&lt;n&gt;' expandMacrosWith: s key).				s value do: [:className | stream tab;tab; nextPutAll: className; cr].				stream cr]]]</body><body package="AT System Analysis">reportCompatibilityMessageReferencesFor: aClass on: stream	"Put onto stream a report of methods which appear to send messages that are known to be for backward compatibility."	(Array with: aClass with: aClass class) do:		[:class | | array |		array := self systemAnalyzer allCompatibilityMessageReferencesFor: class.		array notEmpty ifTrue:			[stream nextPutAll: (#sendsTheFollowingBackwardCompatibilityMessage								&lt;&lt; #advanced								&gt;&gt; '&lt;n&gt;&lt;1p&gt; sends the following backward compatibility message&lt;2s&gt;&lt;n&gt;&lt;n&gt;'									expandMacrosWith: class with: (self pluralEndingFor: array)).			 self reportMessagesSentIn: array on: stream]]</body><body package="AT System Analysis">reportImplementedButNotSentFor: aClass on: stream	(Array with: aClass with: aClass class) do:		[:class | | array |		array := self systemAnalyzer allUnSentMessagesFor: class.		array notEmpty ifTrue:			[stream nextPutAll: (#implementsTheFollowingUnsentMessage								&lt;&lt; #advanced								&gt;&gt; '&lt;n&gt;&lt;1p&gt; implements the following unsent message&lt;2s&gt;&lt;n&gt;&lt;n&gt;'									expandMacrosWith: class with: (self pluralEndingFor: array)).			 array do: [:s | stream tab; nextPutAll: s; cr].			 stream cr]]</body><body package="AT System Analysis">reportIndefiniteCompatibilityMessageReferencesFor: aClass on: stream	"Put onto stream a report of methods that reference a message that is defined in some class as backward compatibility but defined in another class as not backward compatibility."	(Array with: aClass with: aClass class) do:		[:class | | array |		array := self systemAnalyzer allIndefiniteCompatibilityMessageReferencesFor: class.		array notEmpty ifTrue:			[stream nextPutAll: (#sendsTheFollowingPossiblyBackwardCompatibilityMessage								&lt;&lt; #advanced								&gt;&gt; '&lt;n&gt;&lt;1p&gt; sends the following (possibly backward compatibility) message&lt;2s&gt;&lt;n&gt;&lt;n&gt;'									expandMacrosWith: class with: (self pluralEndingFor: array)).			 self reportMessagesSentIn: array on: stream]]</body><body package="AT System Analysis">reportInstVarsNotReferencedFor: aClass on: stream	(Array with: aClass with: aClass class) do:		[:class | | array |		array := self systemAnalyzer instanceVariablesNotReferencedFor: class.		array notEmpty ifTrue:			[stream nextPutAll: (#doesNotReferenceTheFollowingInstanceVariable								&lt;&lt; #advanced								&gt;&gt; '&lt;n&gt;&lt;1p&gt; does not reference the following instance variable&lt;2s&gt;&lt;n&gt;&lt;n&gt;'									expandMacrosWith: class with: (self pluralEndingFor: array)).			 array do: [:s | stream tab; nextPutAll: s; cr].			 stream cr]]</body><body package="AT System Analysis">reportMessagesSentIn: array on: stream 	array do: 		[:s | 		stream			tab;			nextPutAll: (#x1sSends &lt;&lt; #advanced &gt;&gt; '&lt;1s&gt; sends: ' expandMacrosWith: s key);			cr.		s value do: [:sel |  stream tab; tab; nextPutAll: sel; cr].		stream cr]</body><body package="AT System Analysis">reportMethodConsistencyFor: aClass on: stream	(Array with: aClass with: aClass class) do:		[:class | | ma selectors |		ma := MessageAnalyzer new.		ma class: class.		ma analyzeClass.		selectors := ma report.		selectors notEmpty ifTrue:			[stream nextPutAll: (#hasTheFollowingCurrentProblems							&lt;&lt; #advanced							&gt;&gt; '&lt;n&gt;&lt;1p&gt; has questionable messages sent by the following method&lt;2s&gt;&lt;n&gt;&lt;n&gt;'								expandMacrosWith: class with: (self pluralEndingFor: selectors)).			 selectors do:				[:assoc |				stream tab; nextPutAll: assoc key; nextPutAll: (#SendsTo &lt;&lt; #advanced &gt;&gt; ' sends to: ') asString; cr.				assoc value do:					[:a2 |					stream tab;tab; print: a2 key; space; space.					a2 value do: [:s | stream nextPutAll: s; space].					stream cr].				stream cr].			stream cr]]</body><body package="AT System Analysis">reportSentButNotImplementedFor: aClass on: stream	(Array with: aClass with: aClass class) do:		[:class | | array |		array := self systemAnalyzer allUnimplementedCallsFor: class.		array notEmpty ifTrue:			[stream nextPutAll: (#sendsTheFollowingUnimplementedMessage							&lt;&lt; #advanced							&gt;&gt; '&lt;n&gt;&lt;1p&gt; sends the following unimplemented message&lt;2s&gt;&lt;n&gt;&lt;n&gt;'								expandMacrosWith: class with: (self pluralEndingFor: array)).			 self reportMessagesSentIn: array on: stream]]</body><body package="AT System Analysis">reportSubclassResponsibilitiesNotImplementedFor: aClass on: stream	(Array with: aClass with: aClass class) do:		[:class | | array |		array := self systemAnalyzer unResponsivesFor: class.		(array notEmpty		 and: [self checkForReportingSubclassResponsibilityProblemsIn: array]) ifTrue:			[stream nextPutAll: (#SubclassResponsibilitiesWithoutImplementations								&lt;&lt; #advanced								&gt;&gt; '&lt;n&gt;&lt;1p&gt;  has the following subclassResponsibility&lt;n&gt;messages without subclass implementations:&lt;n&gt;&lt;n&gt;'									expandMacrosWith: class).			array do: [:assoc | self printSubclassResponsibility: assoc on: stream].			stream cr]]</body><body package="AT System Analysis">reportUndeclaredReferencesFor: aClass on: stream	(Array with: aClass with: aClass class) do:		[:class | | array |		array := self systemAnalyzer undeclaredsFor: class.		array notEmpty ifTrue:			[stream nextPutAll: (#hasUndeclaredReference							&lt;&lt; #advanced							&gt;&gt; '&lt;n&gt;&lt;1p&gt; has undeclared reference&lt;2s&gt;&lt;n&gt;&lt;n&gt;'								expandMacrosWith: class with: (self pluralEndingFor: array)).			array do:				[:a |				stream tab; nextPutAll: a key; space; nextPutAll: (#references &lt;&lt; #advanced &gt;&gt; 'references -- ') asString;cr; tab;tab.				a value do: [:ud | stream nextPutAll: ud key; space].				stream cr].			stream cr]]</body></methods><methods><class-id>Tools.ClassReporter</class-id> <category>private</category><body package="AT System Analysis">changedCorrectnessType	"The Browse/Report correctness state has changed. Hide one button group 	and expose the other."	self hideCorrectnessGroup</body><body package="AT System Analysis">changedManualMethod	"The state of the Manual&gt;Method check box has changed. Enable or disable 	the radio buttons accordingly."	self manualWriterMethod value		ifTrue: 			[(self subBuilder componentAt: #methodCommentRadioButton) enable.			(self subBuilder componentAt: #methodBodyRadioButton) enable]		ifFalse: 			[(self subBuilder componentAt: #methodCommentRadioButton) disable.			(self subBuilder componentAt: #methodBodyRadioButton) disable]</body><body package="AT System Analysis">changedMethodCommentOrBody	"The state of the Manual&gt;Method comments or Method bodies radio button	has changed. Propogate the change to the Manual&gt;Method bodies value holder."	self manualWriterMethodBody value: self manualWriterMethodComment value not</body><body package="AT System Analysis">checkForReportingSubclassResponsibilityProblemsIn: anArray	ReportSuspectedAbstractClasses ifTrue: [^true].	1 to: anArray size do:		[:i |		| assoc |		assoc := anArray at: i.		(assoc value at: 1) isEmpty not ifTrue: [^true]].	^false</body><body package="AT System Analysis">dispatch: aSymbolOrNil	aSymbolOrNil notNil ifTrue: [self perform: aSymbolOrNil]</body><body package="AT System Analysis">getClasses	| names  |	names := filteredClassList selectedNames.	names isEmpty ifTrue: [^#()].	^names collect: [:nm | nm asQualifiedReference value].</body><body package="AT System Analysis">hideCorrectnessGroup	"Make the appropriate gruop of buttons visible based on the state of the 	Browse/Report correctness button."	| state |	state := self correctnessType value == #browse.	(self subBuilder componentAt: #browseGroup)		isVisible: state.	(self subBuilder componentAt: #reportGroup)		isVisible: state not</body><body package="AT System Analysis">openListBrowserOn: aCollection label: aString	sysAnalyzer := nil.	aCollection isEmpty ifTrue: [^self warn: (#nothingToBrowse &lt;&lt; #advanced &gt;&gt; 'nothing to browse') asString].	MethodCollector new		openListBrowserOn: aCollection		label: aString asString</body><body package="AT System Analysis">openReportOn: string labeled: label	| holderView topView holder |	sysAnalyzer := nil.	string isEmpty ifTrue: [^self warn: (#nothingToReport &lt;&lt; #advanced &gt;&gt; 'nothing to report') asString].	holder := ValueHolder new value: string.	holderView := ComposedTextView model: holder.	UILookPolicy new setStyleOf: holderView to: #fixed.	topView := ScheduledWindow new.	topView model: holderView model.	topView label: label asString.	topView component: (LookPreferences edgeDecorator on: holderView).	topView minimumSize: 460 @ 460.	topView open</body><body package="AT System Analysis">pluralEndingFor: array	^array size ~= 1 ifTrue: [#s &lt;&lt; #advanced &gt;&gt; 's'] ifFalse: ['']</body><body package="AT System Analysis">printSubclassResponsibility: assoc on: stream	| concrete abstract |	concrete := assoc value at: 1.	abstract := assoc value at: 2.	(abstract notEmpty and: [ReportSuspectedAbstractClasses]) ifTrue:		[stream nextPutAll: (#Tab1sInPossiblyAbstractTabs							&lt;&lt; #advanced							&gt;&gt; '&lt;t&gt;&lt;1s&gt; in possibly abstract&lt;n&gt;&lt;t&gt;&lt;t&gt;'								expandMacrosWith: assoc key).		 abstract do: [:cl | stream print: cl; space].		 stream cr].	concrete notEmpty ifTrue:		[stream nextPutAll: (#Tab1sInTabs							&lt;&lt; #advanced							&gt;&gt; '&lt;t&gt;&lt;1s&gt; in&lt;n&gt;&lt;t&gt;&lt;t&gt;'								expandMacrosWith: assoc key).		 concrete do: [:cl | stream print: cl; space].		 stream cr]</body><body package="AT System Analysis">rebuild	| canvas next |	canvas := builder componentAt: #activeComponents.	next := list selection value at: 1.	self subBuilder: self builder newSubBuilder.	canvas widget		client: self		spec: next		builder: self subBuilder.	next == #correctnessSpec		ifTrue: 			[self relabelIndefiniteBackwardCompatibilityButton.			self hideCorrectnessGroup].	next == #manualSpec ifTrue: [self changedManualMethod]</body><body package="AT System Analysis">relabelIndefiniteBackwardCompatibilityButton	"Relabel the indefinite backwards compatibility button with a two line label."	| wrap label newLabel |	wrap := self subBuilder componentAt: #indefiniteBackwardCompatRadioButton.	label := wrap widget label.	newLabel := ComposedText 				withText: ((#IndefiniteBackwardCompatibilityMessageSends &lt;&lt; #advanced &gt;&gt; 'Indefinite backward compatibility&lt;n&gt;message sends') expandMacros asText							emphasizeAllWith: (label text emphasisAt: 1))				style: UILookPolicy systemWidgetTextStyle.	wrap label: newLabel.	wrap := self subBuilder componentAt: #indefiniteBackwardCompatCheckBox.	wrap label: newLabel.</body><body package="AT System Analysis">setFocus	"Set the keyboard input focus to be the first text input widget on the focus chain."	builder keyboardProcessor keyboardConsumers do: 			[:aWidget |			(aWidget isKindOf: TextEditorView)				ifTrue: 					[builder keyboardProcessor focusedView: aWidget.					^aWidget controller selectEntireText]]</body><body package="AT System Analysis">subBuilder	"Answer the builder used to construct the notebook slice."	^subBuilder</body><body package="AT System Analysis">subBuilder: aBuilder	"Set the builder used to construct the notebook slice."	subBuilder := aBuilder</body><body package="AT System Analysis">systemAnalyzer	sysAnalyzer == nil		ifTrue: [sysAnalyzer := SystemAnalyzer new].	^sysAnalyzer</body><body package="AT System Analysis">warn: messageString	"Present the message string to the user.  Continue processing	when the user hits the 'ok' box or types cr."	Dialog warn: messageString.	^messageString</body></methods><methods><class-id>Tools.ClassReporter</class-id> <category>accessing</category><body package="AT System Analysis">filteredClassList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^filteredClassList isNil		ifTrue:			[filteredClassList := ClassNameChooser new]		ifFalse:			[filteredClassList]</body></methods><methods><class-id>Tools.ClassReporter</class-id> <category>private - manualWriter aspects</category><body package="AT System Analysis">manualWriterComment	^manualWriter comment</body><body package="AT System Analysis">manualWriterDoClass	^manualWriter doClass</body><body package="AT System Analysis">manualWriterInstance	^manualWriter instance</body><body package="AT System Analysis">manualWriterMethod	^manualWriter method</body><body package="AT System Analysis">manualWriterMethodBody	^manualWriter methodBody</body><body package="AT System Analysis">manualWriterMethodComment	^manualWriter methodComment</body><body package="AT System Analysis">manualWriterPrivate	^manualWriter private</body><body package="AT System Analysis">manualWriterProtocols	^manualWriter protocols</body></methods><methods><class-id>Tools.ClassReporter</class-id> <category>interface opening</category><body package="AT System Analysis">postBuildWith: aBuilder		super postBuildWith: aBuilder.	(aBuilder componentAt: #notebook)		ifNotNil:			[:wrapper | 			wrapper widget tabBar component				visualBlock:					[:view :index | 					| item component |					item := view sequence at: index.					component := LabelAndIcon						with: item label						attributes: view textStyle.					component icon: item labelImage.					component offset: 6 @ 0.					BoundedWrapper on: component]]</body><body package="AT System Analysis">postOpenWith: aBuilder 	| canvas |	canvas := builder componentAt: #notebook.	canvas isNil ifTrue: [^self].	canvas widget		client: self		spec: #activeAreaSpec		builder: builder.	self updatePreferences</body></methods><methods><class-id>Tools.ClassReporter</class-id> <category>initialize-release</category><body package="AT System Analysis">initialize	"Initialize the receiver."	super initialize.	list := SelectionInList new.	list list: self class pagesMenu menuItems.	list selectionIndexHolder value: 1.	list selectionIndexHolder onChangeSend: #updatePreferences to: self.	manualWriter := ManualWriter new.	filteredClassList := ClassNameChooser new.	mode := PluggableAdaptor on: list.	mode getBlock: [:m | m selection value at: 2 ]		putBlock: [:m :v | false ]		updateBlock: [:m :a :p | false ].		mode addDependent: self.	sentButNotImplemented := ValueHolder with: false.	implementedButNotSent := ValueHolder with: false.	compatibilityMessages := ValueHolder with: false.	indefiniteCompatibilityMessages := ValueHolder with: false.	compatibilityClasses := ValueHolder with: false.	goodComment := ValueHolder with: false.	undeclared := ValueHolder with: false.	methodConsistency := ValueHolder with: false.	instVarsNotReferenced := ValueHolder with: false.	subclassResponsibilitiesNotImplemented := ValueHolder with: false.	spaceReport := ValueHolder with: #classWeightReport.</body><body package="AT System Analysis">release	super release.	self subBuilder: nil</body></methods><methods><class-id>Tools.ClassReporter</class-id> <category>top level</category><body package="AT System Analysis">preferenceChoice	^list selectionIndexHolder</body><body package="AT System Analysis">preferenceMasterList	^list</body><body package="AT System Analysis">updatePreferences	"Update the subcanvas for the currently selected preference item. Answer the receiver."	self rebuild.	self setFocus</body></methods><methods><class-id>Tools.ClassReporter</class-id> <category>private-correctness browsing</category><body package="AT System Analysis">browseCompatibilityClassReferences	"Browse methods which reference backward compatibility Classes."	| classes stream |	classes := self getClasses.	classes isEmpty ifTrue: [^self].	stream := Array new writeStream.	classes do: [:aClass |		(Array with: aClass with: aClass class) do: [:class |			(self systemAnalyzer allCompatibilityClassReferencesFor: class) do: [:assoc |				| str |				str := (String new: 20) writeStream.				str nextPutAll: (#refersTo &lt;&lt; #advanced &gt;&gt; 'refers to ').				assoc value do: [:s | str nextPutAll: s; space].				(stream nextPut: (MethodDefinition class: class selector: assoc key))					extraText: str contents]]].	self		openListBrowserOn: stream contents		label: (#BackwardCompatibilityClassReferences &lt;&lt; #advanced &gt;&gt; 'Backward Compatibility Class References')</body><body package="AT System Analysis">browseCompatibilityMessageReferences	"Browse methods which appear to send messages that are known to be for backward compatibility."	| classes stream |	classes := self getClasses.	classes isEmpty ifTrue: [^self].	stream := Array new writeStream.	classes do: [:aClass |		(Array with: aClass with: aClass class) do: [:class |			(self systemAnalyzer allCompatibilityMessageReferencesFor: class) do: [:assoc |				| str |				str := (String new: 20) writeStream.				str nextPutAll: (#sends &lt;&lt; #advanced &gt;&gt; 'sends ') asString.				assoc value do: [:s | str nextPutAll: s; space].				(stream nextPut: (MethodDefinition class: class selector: assoc key))					extraText: str contents]]].	self		openListBrowserOn: stream contents		label: (#BackwardCompatibilitySends &lt;&lt; #advanced &gt;&gt; 'Backward Compatibility Sends')</body><body package="AT System Analysis">browseImplementedButNotSent	| classes stream |	classes := self getClasses.	classes isEmpty ifTrue: [^self].	stream := (Array new: 1024) writeStream.	classes do: 		[:aClass |		(Array with: aClass with: aClass class) do:			[:class |			(self systemAnalyzer allUnSentMessagesFor: class) do:				[:sel | 				stream nextPut: (MethodDefinition class: class selector: sel)]]].	self		openListBrowserOn: stream contents		label: (#UnsentImplementations &lt;&lt; #advanced &gt;&gt; 'Unsent Implementations')</body><body package="AT System Analysis">browseInconsistentMethods	| ma  classes stream  |	classes := self getClasses.	classes isEmpty ifTrue: [^self].	Transcript cr; show: (#Checking &lt;&lt; #advanced &gt;&gt; 'Checking...'); cr.	stream := (Array new: 100) writeStream.	ma := MessageAnalyzer new.	classes do:		[:aClass |		Transcript print: aClass; space; flush.		(Array with: aClass with: aClass class) do:			[:class | | selectors |			ma class: class.			ma analyzeClass.			selectors := ma report.			selectors isEmpty ifFalse:				[selectors do:					[:assoc |					stream nextPut: (MethodDefinition class: class selector: assoc key)]]]].	self		openListBrowserOn: stream contents		label: (#InconsistentMessageSends &lt;&lt; #advanced &gt;&gt; 'Inconsistent Message Sends')</body><body package="AT System Analysis">browseIndefiniteCompatibilityMessageReferences	"Browse each method that reference a message that is defined in some class as backward compatibility but defined in another class as not backward compatibility."	| classes stream |	classes := self getClasses.	classes isEmpty ifTrue: [^self].	stream := Array new writeStream.	classes do: [:aClass |		(Array with: aClass with: aClass class) do: [:class |			(self systemAnalyzer allIndefiniteCompatibilityMessageReferencesFor: class) do: [:assoc |				| str |				str := (String new: 20) writeStream.				str nextPutAll: (#sends &lt;&lt; #advanced &gt;&gt; 'sends ').				assoc value do: [:s | str nextPutAll: s; space].				(stream nextPut: (MethodDefinition class: class selector: assoc key))					extraText: str contents]]].	self		openListBrowserOn: stream contents		label: (#IndefiniteBackwardCompatibilitySends &lt;&lt; #advanced &gt;&gt; 'Indefinite Backward Compatibility Sends')</body><body package="AT System Analysis">browseSentButNotImplemented	| classes stream |	classes := self getClasses.	classes isEmpty ifTrue: [^self].	stream := Array new writeStream.	classes do: 		[:aClass |		(Array with: aClass with: aClass class) do:			[:class |			(self systemAnalyzer allUnimplementedCallsFor: class) do:				[:assoc |				| str |				str := (String new: 10) writeStream.				str nextPutAll: (#sends &lt;&lt; #advanced &gt;&gt; 'sends ').				assoc value do: [:s | str nextPutAll: s; space].				(stream nextPut: (MethodDefinition class: class selector: assoc key))					extraText: str contents]]].	self		openListBrowserOn: stream contents		label: (#UnimplementedSends &lt;&lt; #advanced &gt;&gt; 'Unimplemented Sends')</body><body package="AT System Analysis">browseSubclassResponsibilitiesNotImplemented	| classes stream |	classes := self getClasses.	classes isEmpty ifTrue: [^self].	stream := (Array new: 10) writeStream.	classes do:		[:aClass |		(Array with: aClass with: aClass class) do:			[:class | | array |			array := self systemAnalyzer unResponsivesFor: class.			(self checkForReportingSubclassResponsibilityProblemsIn: array) ifTrue:				[array do:					[:assoc |					(ReportSuspectedAbstractClasses or: [(assoc value at: 1) isEmpty not]) ifTrue:						[stream nextPut: (MethodDefinition class: class selector: assoc key)]]]]].	self 		openListBrowserOn: stream contents		label: (#UnimplementedSubclassResponsibilities &lt;&lt; #advanced &gt;&gt; 'Unimplemented Subclass Responsibilities')</body><body package="AT System Analysis">browseUndeclareds	| classes stream |	classes := self getClasses.	classes isEmpty ifTrue: [^self].	stream := Array new writeStream.	classes do: 		[:aClass |		(Array with: aClass with: aClass class) do:			[:class |			(self systemAnalyzer undeclaredsFor: class) do:				[:assoc | 				stream nextPut: (MethodDefinition class: class selector: assoc key)]]].	self		openListBrowserOn: stream contents		label: (#UndeclaredReferences &lt;&lt; #advanced &gt;&gt; 'Undeclared References')</body></methods><methods><class-id>Tools.ClassReporter</class-id> <category>private-space reporting</category><body package="AT System Analysis">classWeightReport	| classes  stream |	classes := self getClasses.	classes isEmpty ifTrue: [^self].	stream := String new writeStream.	self systemAnalyzer classWeightReportFor: classes on: stream.	self		openReportOn: stream contents		labeled: (#classSize &lt;&lt; #advanced &gt;&gt; 'class size')</body><body package="AT System Analysis">instanceWeightReport	| classes hist sc  classSet stream |	classes := self getClasses.	classes isEmpty ifTrue: [^self].		ObjectMemory garbageCollect.	classSet := IdentitySet new.	classSet addAll: classes.	hist := self systemAnalyzer tallyObjectsSatisfying: [:obj | classSet includes: obj class].	sc := SortedCollection sortBlock: [:i1 :i2 | i1 totalBytes &gt; i2 totalBytes].	sc addAll: hist.	stream := String new writeStream.	self systemAnalyzer reportFrom: sc on: stream.	self		openReportOn: stream contents		labeled: (#instanceSize &lt;&lt; #advanced &gt;&gt; 'instance size')</body><body package="AT System Analysis">methodWeightReport	| classes  stream|	classes := self getClasses.	classes isEmpty ifTrue: [^self].	stream := (String new: 128) writeStream.	classes do:		[:class |		self systemAnalyzer methodWeightReportFor: class on: stream].	self openReportOn: stream contents labeled: (#methodSize &lt;&lt; #advanced &gt;&gt; 'method size')</body></methods><methods><class-id>Tools.ClassReporter class</class-id> <category>class initialization</category><body package="AT System Analysis">initialize	"Initialize class variables."	"ClassReporter initialize."	self reportSuspectedAbstractClasses: false</body></methods><methods><class-id>Tools.ClassReporter class</class-id> <category>constants</category><body package="AT System Analysis">reportSuspectedAbstractClasses: aBoolean	"Setup so that the subclassResponsibilities not implemented report does not report	classes that are suspected of being Abstract."	"ClassReporter reportSuspectedAbstractClasses: true"	ReportSuspectedAbstractClasses := aBoolean</body></methods><methods><class-id>Tools.SystemAnalyzer</class-id> <category>enumerating</category><body package="AT System Analysis">allBehaviors	"Answer a collection of all Behaviors in the system."	| collection |	collection := OrderedCollection new.	self allBehaviorsDo: [:b | collection add: b].	^collection</body><body package="AT System Analysis">allBehaviorsDo: aBlock 	"Evaluate the argument, aBlock, for each kind of Behavior in the system	(that is, Object and its subclasses, plus other classes that have no	superclass)."	Class rootsOfTheWorld do:		[:cls |		aBlock value: cls.		cls allSubclassesDo: aBlock]</body><body package="AT System Analysis">allClassesDo: aBlock	"Evaluate the argument, aBlock, for each class in the system."	SystemUtils allBehaviorsDo:		[:cl | (cl isMeta) ifFalse: [aBlock value: cl]]</body><body package="AT System Analysis">allSelect: aBlock 	"Answer a SortedCollection of each method that, when used as the	block argument to aBlock, gives a true result."	| aCollection |	aCollection := SortedCollection new.	self allBehaviorsDo: 		[:class | class selectorsAndMethodsDo: 			[:sel :cm | (aBlock value: cm)				ifTrue: [aCollection add: (MethodDefinition class: class selector: sel)]]].	^aCollection</body><body package="AT System Analysis">allSelectWithSelectorAndClass: aBlock	"Answer a SortedCollection of each method that, when used as the first	argument, the methods' selector as the second argument, and the method's	class as the last argument to aBlock, gives a true result."	| aCollection |	aCollection := SortedCollection new.	self allBehaviorsDo: 		[:class |		class selectorsAndMethodsDo: 			[:sel :cm |			(aBlock value: cm value: sel value: class) ifTrue:				[aCollection add: (MethodDefinition class: class selector: sel)]]].	^aCollection</body></methods><methods><class-id>Tools.SystemAnalyzer</class-id> <category>private-sizing</category><body package="AT System Analysis">byteSizeOfObject: anObject	| nbytes class |	(self shouldCountObject: anObject) ifFalse: [^0].	class := anObject class.	nbytes := self bytesInHeader.	class isBits		ifTrue: [nbytes := nbytes + (anObject basicSize + (self bytesInOOP - 1)									bitAnd: self bytesInOOP negated)]		ifFalse: [nbytes := nbytes + (class instSize * self bytesInOOP).				class isVariable ifTrue: [nbytes := nbytes + (anObject basicSize * self bytesInOOP)]].	^nbytes</body><body package="AT System Analysis">byteSizeOfObject: anObject andInstances: aCollection	| bytes  |	bytes := self byteSizeOfObject: anObject.	1  to: aCollection size do:		[:index |		bytes := bytes + (self byteSizeOfObject: (anObject instVarAt: (aCollection at: index)))].	^bytes</body><body package="AT System Analysis">byteSizeOfObjectsIn: anObject	| class visited bytes|	class := anObject class.	class isBits ifTrue: [^0].	visited := IdentitySet new.	visited add: anObject.	bytes := 0.	1 to: class instSize do:		[ :i |  		| obj | 		obj := anObject instVarAt: i.		(visited includes: obj)			ifFalse: [ bytes := bytes + (self byteSizeOfObject: obj).					visited add: obj]].	class isVariable		ifTrue: [1 to: anObject basicSize do:				[ :i |						| obj |				obj := anObject basicAt: i.				(visited includes: obj)					ifFalse: [ bytes := bytes + (self byteSizeOfObject: obj).						visited add: obj]]].	^bytes</body><body package="AT System Analysis">bytesInHeader	^BytesInHeader</body><body package="AT System Analysis">bytesInOOP	^BytesInOOP</body><body package="AT System Analysis">shouldCountObject: anObject	^(anObject == nil or: [anObject == true or: [anObject == false or: [anObject isImmediate]]]) not</body></methods><methods><class-id>Tools.SystemAnalyzer</class-id> <category>accessing</category><body package="AT System Analysis">allCompatibilityClasses"Answer the Set of Associations in Smalltalk that refer to Classes that appear to only exist for backward compatibility."	allCompatibilityClasses isNil ifTrue: [		self findAllCompatibilityClasses].	^allCompatibilityClasses</body><body package="AT System Analysis">allCompatibilityMessages"Answer the Set of all the message selectors in the system that appear to only exist for backward compatibility.""SystemAnalyzer new allCompatibilityMessages"	allCompatibilityMessages isNil		ifTrue: [self findAllCompatibilityMessages].	^allCompatibilityMessages</body><body package="AT System Analysis">allImplementedMessages	"Answer a Set of all the message selectors in the system."	allImplementedMessages == nil		ifTrue: [allImplementedMessages := IdentitySet new: (Symbol tableSize * 1.5) truncated.				self allBehaviorsDo:					[:cl |					(self methodDictionaryFor: cl ) keysDo: [:sel | allImplementedMessages add: sel]]].	^allImplementedMessages</body><body package="AT System Analysis">allIndefiniteCompatibilityMessages"Answer the Set of all the message selectors in the system that appear to exist sometimes only for backward compatibility.""SystemAnalyzer new allIndefiniteCompatibilityMessages"	allIndefiniteCompatibilityMessages isNil		ifTrue: [self findAllIndefiniteCompatibilityMessages].	^allIndefiniteCompatibilityMessages</body><body package="AT System Analysis">allSelectorsInInconsistentProtocols	"Return a collection of all methods that are in more than one protocol."	"SystemAnalyzer new allSelectorsInInconsistentProtocols"	| allSelectors |	allSelectors := IdentityDictionary new: ByteSymbol instanceCount.	self allBehaviorsDo:		[:class| | org |		(org := class organization) categories do:			[:cat|			(org listAtCategoryNamed: cat) do:				[:sel|				(allSelectors at: sel ifAbsentPut: [Set new]) add: cat]]].	^allSelectors select: [:set| set size &gt; 1]</body><body package="AT System Analysis">allSentMessages	"Answer the set of all message selectors sent by all behaviors in the the system."	allSentMessages == nil		ifTrue: [allSentMessages := IdentitySet new: 8000.				SpecialSelectorDictionary keysDo: [:key | allSentMessages add: key].				allImplementedMessages == nil					ifTrue: [allImplementedMessages := IdentitySet new: 8000.							self allBehaviorsDo: 								[:cl |								(self methodDictionaryFor: cl ) keysAndValuesDo:									[:sel :code |									allImplementedMessages add: sel.									self allLiteralsIn: code do:										[:lit |										lit isSymbol ifTrue: [allSentMessages add: lit]]]]]					ifFalse: [self allBehaviorsDo: 								[:cl |								(self methodDictionaryFor: cl ) do:									[:code |									self allLiteralsIn: code do:										[:lit |										lit isSymbol ifTrue: [allSentMessages add: lit]]]]]].	^allSentMessages</body><body package="AT System Analysis">allUndeclaredAssociations	"Answer the set of all associations in Undeclared."	allUndeclaredAssociations == nil		ifTrue: [allUndeclaredAssociations := IdentitySet new: Undeclared size*2.				Undeclared bindingsDo: [:a | allUndeclaredAssociations add: a]].	^allUndeclaredAssociations</body><body package="AT System Analysis">flushCaches	"Drop any cached information."	allSentMessages := nil.	allImplementedMessages := nil.	allUndeclaredAssociations := nil.</body></methods><methods><class-id>Tools.SystemAnalyzer</class-id> <category>retrieving</category><body package="AT System Analysis">allCallsOn: aLiteral 	"Answer a Collection of all the methods that call on aLiteral."	|aCollection |	aCollection := OrderedCollection new.	self allBehaviorsDo: 		[:class |		 (class whichSelectorsReferTo: aLiteral) do: 			[:sel | aCollection add: (MethodDefinition class: class selector: sel)]].	^aCollection</body><body package="AT System Analysis">allCallsOn: firstLiteral and: secondLiteral	"Answer a Collection of all the methods that call on both aLiteral and	secondLiteral."	| aCollection secondArray |	aCollection := OrderedCollection new.	self allBehaviorsDo:		[:class |		secondArray := class whichSelectorsReferTo: secondLiteral.		(class whichSelectorsReferTo: firstLiteral) do:			[:sel | (secondArray includes: sel) ifTrue:				[aCollection add: (MethodDefinition class: class selector: sel)]]].	^aCollection</body><body package="AT System Analysis">allClassesImplementing: aSelector  	"Answer an Array of all classes that implement the message aSelector."	| stream |	stream := (Array new: 64) writeStream.	self allBehaviorsDo:		[:class | (class includesSelector: aSelector)			ifTrue: [stream nextPut: class]].	^ stream contents</body><body package="AT System Analysis">allImplementorsOf: aSelector  	"Answer a Collection of all the classes that implement the message aSelector."	| aCollection |	aCollection := OrderedCollection new.	self allBehaviorsDo:		[:class |		(class includesSelector: aSelector)			ifTrue: [aCollection add: class ]].	^aCollection</body><body package="AT System Analysis">allMethodsSuchThat: aBlock 	"Answer a Collection of each method that, when used as the	block argument to aBlock, gives a true result."	| aCollection |	aCollection := OrderedCollection new.	self allBehaviorsDo: 		[:class | class selectorsAndMethodsDo: 			[:sel :cm | (aBlock value: cm)				ifTrue: [aCollection add: (Association key: class value: sel)]]].	^aCollection</body></methods><methods><class-id>Tools.SystemAnalyzer</class-id> <category>private</category><body package="AT System Analysis">allLiteralsIn: aMethod do: aBlock	"For each literal in aMethod do aBlock.  This includes all Blocks."	aMethod withAllBlockMethodsDo:		[:bm |		bm literalsDo: [:lit | self literal: lit do: aBlock]]</body><body package="AT System Analysis">allMethodsIn: aBehavior do: aBlock	(self methodDictionaryFor: aBehavior ) keysAndValuesDo: 		[:k :v | aBlock value: k -&gt; v]</body><body package="AT System Analysis">checkHierarchyUnder: class forSelector: sel	| subs |	subs := class subclasses.	subs isEmpty ifTrue: [^false].	subs do:		[:sc |		(sc includesSelector: sel )			ifFalse: [(self checkHierarchyUnder: sc forSelector: sel) ifFalse: [^false]]].	^true</body><body package="AT System Analysis">findAllCompatibilityClasses	"Find the Set of classes in Smalltalk that appear 	to only exist for backward compatibility."	allCompatibilityClasses := IdentitySet new. 	SystemUtils allClassesDo: [:class | 		('*backward compat*' match: class category)			ifTrue: [allCompatibilityClasses add: class]]</body><body package="AT System Analysis">findAllCompatibilityMessages"Find the Set of all the message selectors in the system that appear to only exist for backward compatibility."	allCompatibilityMessages := self allImplementedMessages copy.	self allBehaviorsDo: [:class |		| organizer |		organizer := class organization.		organizer categories do: [:category |			('*backward compat*' match: category) ifFalse: [				(organizer listAtCategoryNamed: category) do: [:selector |					allCompatibilityMessages remove: selector ifAbsent: []]]]]</body><body package="AT System Analysis">findAllIndefiniteCompatibilityMessages"Find the Set of all the message selectors in the system that appear to exist sometimes only for backward compatibility."	| allPossibleCompatibilityMessages |	allPossibleCompatibilityMessages := IdentitySet new.	self allBehaviorsDo: [:class |		| organizer |		organizer := class organization.		organizer categories do: [:category |			('*backward compat*' match: category) ifTrue: [				allPossibleCompatibilityMessages addAll: (organizer listAtCategoryNamed: category)]]].	allIndefiniteCompatibilityMessages := IdentitySet new.	self allBehaviorsDo: [:class |		| organizer |		organizer := class organization.		organizer categories do: [:category |			('*backward compat*' match: category) ifFalse: [				(organizer listAtCategoryNamed: category) do: [:selector |					(allPossibleCompatibilityMessages includes: selector) ifTrue: [						allIndefiniteCompatibilityMessages add: selector]]]]]</body><body package="AT System Analysis">isJustSuperSend: method selector: selector	"Answer true if aMethod simply sends its own selector to super with the same arguments."	| scanner |	(method numLiterals = 2	and: [method primitiveNumber isNil	and: [(method literalAt: 1) = method mclass	and: [(method literalAt: 2) = selector]]]) ifFalse: [^false].	scanner := InstructionStream on: method.	scanner next = OpLoadReceiver ifFalse: [^false].	"check for ascending sequence of argument loads."	0 to: method numArgs - 1 do: [:i| | byte |		byte := scanner next.		(i &lt;= MaxLoadTemp			ifTrue: [byte = (i + OpLoadTemp)]			ifFalse: [byte = OpXLoadTemp					and: [i = (method byteAt: scanner pc - 1)]])			ifFalse: [^false]].	scanner willLoad ifFalse: [^false]. "push of class for super send."	scanner next.	scanner willSendSuper ifFalse: [^false].	scanner next.	^scanner next = OpReturn</body><body package="AT System Analysis">literal: lit do: aBlock	"Evaluate aBlock on lit.  If lit is an Array, also evaluate its contents"	aBlock value: lit.	lit class == #() class		ifTrue:	[lit do: [:item | self literal: item do: aBlock]]</body><body package="AT System Analysis">method: aMethod referencesClassOtherThan: aClass	self allLiteralsIn: aMethod do:		[:v |		(v isVariableBinding and: [v value isBehavior and: [v value ~~ aClass]])			ifTrue: [^true]].	^false</body><body package="AT System Analysis">methodDictionaryFor: class	^class instVarAt: 2.</body><body package="AT System Analysis">methodReportFor: aClass label: labelString on: aStream	"Write report for aClass into aStream.  Answer total."	| total oc firstTitleString lastTitleString |	total := 0.	aStream nextPutAll: labelString; cr;cr.	firstTitleString := (#CodeLiteralLiteralFullTotalSelector &lt;&lt; #advanced &gt;&gt; 'Code   Literal  Literal  Full    Total        Selector') asString.	lastTitleString := (#BytesCountBytesBlocksBytes &lt;&lt; #advanced &gt;&gt; 'Bytes  Count    Bytes    Blocks  Bytes') asString.	aStream		nextPutAll: firstTitleString; cr;		nextPutAll: lastTitleString; cr;		nextPutAll: (self underlineAll: (Array with: firstTitleString with: lastTitleString)); cr.	oc := OrderedCollection new.	aClass selectorsAndMethodsDo:		[:sel :cm | | a |		a := Array new: 6.		a at: 1 put: sel.		total := total + (self breakDownForMethod: cm into: a).		oc add: a].	oc := oc asSortedCollection: [:a :b | (a at: 6) &gt;= (b at: 6)].	oc do:		[:a |		aStream nextPutAll: (self printStringFor: (a at: 2) rightIn: 5);space;space.		aStream nextPutAll: (self printStringFor: (a at: 3) rightIn: 7);space;space.		aStream nextPutAll: (self printStringFor: (a at: 4) rightIn: 7);space;space.		aStream nextPutAll: (self printStringFor: (a at: 5) rightIn: 6);space;space.		aStream nextPutAll: (self printStringFor: (a at: 6) rightIn: 5).		aStream nextPutAll: '        '.		aStream nextPutAll: (a at: 1).		aStream cr].	aStream cr.	^total</body><body package="AT System Analysis">printStringFor: anObject rightIn: fieldSize	"Answer a String whose characters are a description of the receiver;	pad with leading spaces to field size."	| printString pad |	printString := anObject printString.	pad := fieldSize - printString size.	^pad &lt;= 0		ifTrue: [printString]		ifFalse: [(String new: pad withAll: Character space), printString]</body><body package="AT System Analysis">underline: aString	"Answer a string of space and underline characters for aString	 such that any and all non-separators in aString have a	 corresponding dash in the result."	^self underlineAll: (Array with: aString)</body><body package="AT System Analysis">underlineAll: aCollectionOfStrings	"Answer a string of space and underline characters for aCollectionOfStrings	 such that any and all non-separators in aCollectionOfStrings have a	 corresponding dash in the result."	| underlineString |	underlineString := String new: aCollectionOfStrings first size withAll: Character space.	aCollectionOfStrings do:		[:string|		 1 to: string size do:			[:i| (string at: i) isLetter ifTrue: [underlineString at: i put: $-]]].	^underlineString</body></methods><methods><class-id>Tools.SystemAnalyzer</class-id> <category>private-weights</category><body package="AT System Analysis">breakDownForMethod: aMethod into: anArray	| codeBytes literalBytes numLiterals selfSize grand |	selfSize :=  self byteSizeOfObject: aMethod.	codeBytes := self byteSizeOfObject: (aMethod instVarAt: 1).	aMethod withAllBlockMethodsDo:		[:subMeth |		subMeth == aMethod "Don't count yourMethod."			ifFalse: [codeBytes := codeBytes + (self totalWeightForMethod: subMeth)]].	numLiterals := 0.	literalBytes := 0.	aMethod literalsDo:			[:lit |			numLiterals := numLiterals + 1.			literalBytes := literalBytes + (self weightForLiteral: lit)].	grand := codeBytes + literalBytes + selfSize.	anArray == nil		ifFalse: [	 | opFullBlk opFullCopyBlk numFullBlocks |				opFullBlk := OpcodePool at: #OpFullBlock.				opFullCopyBlk := OpcodePool at: #OpFullCopyingBlock.				numFullBlocks := 0.				aMethod withAllBlockMethods do:					[:b |	   				 ((b bytesIncludes: opFullBlk)					   or: [b bytesIncludes: opFullCopyBlk]) ifTrue:					 	[(InstructionStream on: b) scanFor:							[:op |							(op = opFullBlk or: [op = opFullCopyBlk]) ifTrue:								[numFullBlocks :=  numFullBlocks + 1]. false]]].				anArray at: 2 put: codeBytes.				anArray at: 3 put: numLiterals.				anArray at: 4 put: literalBytes.				anArray at: 5 put: numFullBlocks.				anArray at: 6 put: grand].	^grand</body><body package="AT System Analysis">simpleWeightForObject: anObject	(self shouldCountObject: anObject) ifFalse: [^0].	^(self byteSizeOfObject: anObject) + (self byteSizeOfObjectsIn: anObject)</body><body package="AT System Analysis">totalWeightForClass: aClass	"Answer an estimate of the space cost (in bytes) of the receiver."	"Doesn't include shared pools or contents of associations in class pools.	Completely implementation-specific."	|  bytes  |	bytes := self byteSizeOfObject: aClass andInstances: #[4 5 7 9 "subclasses instanceVariables name pools"]. 	bytes := bytes + (self simpleWeightForObject: (aClass instVarAt: 6) "organization").	bytes := bytes + (self simpleWeightForObject: (aClass instVarAt: 8) "classPool, it counts the associations").	bytes  := bytes + (self totalWeightForMethodDictionary: (aClass instVarAt: 2)).	"now for the Metaclass"	bytes := bytes + (self byteSizeOfObject: aClass class andInstances: #[4 5 "subclasses instanceVariables"]). 	bytes := bytes + (self simpleWeightForObject: (aClass class instVarAt: 6) "organization").	bytes  := bytes + (self totalWeightForMethodDictionary: (aClass class instVarAt: 2)).	^bytes</body><body package="AT System Analysis">totalWeightForClassOrganizer: co	^self simpleWeightForObject: co</body><body package="AT System Analysis">totalWeightForMethod: aMethod	"Answer an estimate of the space cost (in bytes) of a method."	"Only counts String, Array, BlockClosure &amp; Float literals (assumes	that they are unshared), and doesn't descend into literal Arrays."	"This is implementation-specific."	| bytes |	bytes := self byteSizeOfObject: aMethod andInstances: #[1].	aMethod withAllBlockMethodsDo:		[:subMeth |		subMeth == aMethod "Don't count youraMethod."			ifFalse: [bytes := bytes + (self totalWeightForMethod: subMeth)]].	aMethod literalsDo:			[:lit |			bytes := bytes + (self weightForLiteral: lit)].	^bytes</body><body package="AT System Analysis">totalWeightForMethodDictionary: md 	| bytes |	bytes := self byteSizeOfObject: md.	md do: [:method | bytes := bytes + (self totalWeightForMethod: method)].	^bytes</body><body package="AT System Analysis">weightForBlockClosure: aBlockClosure	|  bytes cv |	cv := aBlockClosure copiedValues.	bytes := self byteSizeOfObject: aBlockClosure.	(cv == nil or: [cv size = 0])		ifFalse: [bytes := bytes + (self byteSizeOfObject: cv)].	^bytes.</body><body package="AT System Analysis">weightForLiteral: aLiteral	| litClass |	litClass := aLiteral class.	"Don't want to count CompiledCode, Associations or Symbols."	litClass == BlockClosure		ifTrue: [^self weightForBlockClosure: aLiteral].	(litClass isBits and: [aLiteral isSymbol not])		ifTrue: [^self  byteSizeOfObject: aLiteral].	litClass == Array		ifTrue: [^self weightForLiteralArray: aLiteral].	"Otherwise Don't want to count CompiledCode, Associations or Symbols."	^0</body><body package="AT System Analysis">weightForLiteralArray: anArray	| bytes |	bytes := self byteSizeOfObject: anArray.	1 to: anArray size do: 		[:i |		bytes := bytes + (self weightForLiteral: (anArray at: i))].	^bytes</body></methods><methods><class-id>Tools.SystemAnalyzer</class-id> <category>static checks</category><body package="AT System Analysis">allCompatibilityClassReferencesFor: aClass"Answer a collection of Associations between selectors of this class whose methods reference compatibility Classes and the collection of compatibility Classes (names) they reference."	| answer theCompatibilityClasses |	answer := Set new.	theCompatibilityClasses := self allCompatibilityClasses.	self allMethodsIn: aClass do: [:methodAssociation |		| compatibilityUses |		compatibilityUses := Set new.		self allLiteralsIn: methodAssociation value do: [:literal |			(literal isVariableBinding and: [theCompatibilityClasses includes: literal value]) ifTrue: [				('*backward compat*' match: (aClass organization categoryOfElement: methodAssociation key)) ifFalse: [					compatibilityUses add: literal key]]].		compatibilityUses isEmpty ifFalse: [			answer add: (methodAssociation key -&gt; compatibilityUses asArray)]].	^answer</body><body package="AT System Analysis">allCompatibilityMessageReferencesFor: aClass"Answer a collection of Associations between selectors of this class whose methods reference compatibilityMessages and the collection of compatibility messages they reference."	| answer theCompatibilityMessages |	answer := Set new.	theCompatibilityMessages := self allCompatibilityMessages.	self allMethodsIn: aClass do: [:methodAssociation |		| compatibilityUses |		compatibilityUses := Set new.		self allLiteralsIn: methodAssociation value do: [:literal |			(theCompatibilityMessages includes: literal) ifTrue: [				('*backward compat*' match: (aClass organization categoryOfElement: methodAssociation key)) ifFalse: [					compatibilityUses add: literal]]].		compatibilityUses isEmpty ifFalse: [			answer add: (methodAssociation key -&gt; compatibilityUses asArray)]].	^answer</body><body package="AT System Analysis">allDuplicateMethods	"Answer a collection of all methods in each class that have the same code but different selectors 	(e.g. Behavior hasMethods and Behavior&gt;hasLocalMethods)"	| allMethods duplicates |	"There are approximately 24 methods per class/metaclass in a kitchen-sink 2.5.2 image.	 Make a dictionary larger than this to avoid grow overhead."	allMethods := Dictionary new: Smalltalk allClassNames size * 36.	self allBehaviorsDo: [:b|		b selectorsAndMethodsDo: [:s :m|			(allMethods at: m ifAbsentPut: [OrderedCollection new]) addLast: m]].	"Select the duplicates (much faster than removing non-duplicates)"	allMethods := allMethods select: [:ea| ea size &gt; 1].	"Check for redundancy.  If two methods have the same code and are both in	 the external protocol of the same class (not overridden) then they are duplicates.	 Ignore Object methods. E.g. there are many that just return self."	duplicates := OrderedCollection new: allMethods size.	allMethods do:		[:coll|		coll do:			[:meth| | mc |			(mc := meth mclass) ~~ Object ifTrue:				[coll do:					[:m| | omc | "N**2. Eek!!"					(m ~~ meth					and: [(omc := m mclass) ~~ Object					and: [((omc includesBehavior: mc) or: [mc includesBehavior: omc])					and: [(mc whichClassIncludesSelector: (omc selectorAtMethod: m ifAbsent: [#''])) == omc]]])						ifTrue:							[| def1 def2 |							def1 := meth definition.							def2 := m definition.							(duplicates includes: def1) ifFalse: [duplicates addLast: def1].							(duplicates includes: def2) ifFalse: [duplicates addLast: def2]]]]]].	^duplicates	"SystemAnalyzer new allDuplicateMethods"</body><body package="AT System Analysis">allIndefiniteCompatibilityMessageReferencesFor: aClass"Answer a collection of Associations between selectors of this class whose methods reference indefinite compatibility messages and the collection of compatibility messages they reference."	| answer theCompatibilityMessages |	answer := Set new.	theCompatibilityMessages := self allIndefiniteCompatibilityMessages.	self allMethodsIn: aClass do: [:methodAssociation |		| compatibilityUses |		compatibilityUses := Set new.		self allLiteralsIn: methodAssociation value do: [:literal |			(theCompatibilityMessages includes: literal) ifTrue: [				('*backward compat*' match: (aClass organization categoryOfElement: methodAssociation key)) ifFalse: [					compatibilityUses add: literal]]].		compatibilityUses isEmpty ifFalse: [			answer add: (methodAssociation key -&gt; compatibilityUses asArray)]].	^answer</body><body package="AT System Analysis">allMethodsInMultipleProtocols	"Answer a Set of methods that appear in more than one protocol."	| culprits |	culprits := IdentityDictionary new.	self allBehaviorsDo:		[:aClass |		aClass selectorsAndMethodsDo:			[:sel :meth |			(culprits at: sel ifAbsentPut: [Set new])				add: (MethodDefinition class: aClass selector: sel)]].	culprits := culprits select: [:mds | (mds collect: [:ea | ea protocol]) size &gt; 1].	^culprits inject: Set new into: [:s1 :s2 | s1 addAll: s2. s1]</body><body package="AT System Analysis">allSuperfluousMethods: includeOverridden	"Answer a collection of all methods that override an exactly equivalent method.	 If includeOverridden is true include the methods that are shadowed by the	 superfluous methods."	| duplicates |	duplicates := OrderedCollection new.	self allBehaviorsDo: 			[:class |			class selectorsAndMethodsDo: 					[:selector :method |					| superclass implementor |					((superclass := class superclass) ~~ nil and: 							[(implementor := superclass whichClassIncludesSelector: selector) ~~ nil								and: 									["exact duplicate"									(implementor compiledMethodAt: selector) = method or: 											["super send of same selector"											self isJustSuperSend: method selector: selector]]])						ifTrue: 							[| override |							override := MethodDefinition class: implementor selector: selector.							includeOverridden ifTrue: [duplicates addLast: override].							duplicates addLast: ((MethodDefinition class: class selector: selector)										extraText: (#Duplicates1p &lt;&lt; #advanced &gt;&gt; ' duplicates &lt;1p&gt;'													expandMacrosWith: override);										yourself)]]].	^duplicates</body><body package="AT System Analysis">allSuspiciousClassComments	"Answer a collection of ClassCommentChanges that have bad sources.  I.e. if	a) the class comment's first line doesn't contain the class name.	b) the source contains line-end characters other than cr, or the method is longer		than three lines and contains no singleton crs (e.g. cr-lf got mapped to cr-cr)	c) the source contains characters outside the printable ascii characters plus cr,		tab &amp; space"	| comments |	comments := SortedCollection sortBlock: 					[:ccc1 :ccc2| ccc1 className &lt;= ccc2 className].	self allBehaviorsDo:		[:b |		(b organization hasNoComment not		and: [[| src tokens |			   tokens := Parser new scanTokens: (src := b organization comment).			   (b isMeta				ifTrue: [tokens size ~= 4 or: [(tokens at: 2) ~~ #class]]				ifFalse: [tokens size ~= 3])			   or: [tokens first ~= b instanceBehavior name			   or: [tokens last isString not			   or: [(tokens at: tokens size - 1) ~~ #comment:			   or: [| bad i size n |				bad := false.				i := 0.				size := src size.				[bad or: [i &gt;= size]] whileFalse:					[n := (src at: (i := i + 1)) asInteger.					((n &gt;= 32 and: [n &lt;= 126]) or: [n = 9 or: [n = 13]]) ifFalse:						[bad := true]].				bad]]]]]					on: Object errorSignal					do: [:ex| ex returnWith: true]]) ifTrue:				[comments add: (ClassCommentChange new									className: b name;									yourself)]].	^comments	"SystemAnalyzer new allSuspiciousClassComments"	"ChangeList new		listName: 'Bad Class Comments';		openOn: SystemAnalyzer new allSuspiciousClassComments"</body><body package="AT System Analysis">allSuspiciousSources	"Answer a collection of all methods that have bad sources.  I.e. if	a) the source doesn't start with the method's selector	b) the source contains line-end characters other than cr, or the method is longer		than three lines and contains no singleton crs (e.g. cr-lf got mapped to cr-cr)	c) the source contains characters outside the printable ascii characters plus cr,		tab &amp; space"	^self allSelectWithSelectorAndClass:		[:m :s :c|		[| src kw kws |		src := m getSource.		kw := s keywords first.		kws := kw size.		src size &lt; kw size		or: [(src copyFrom: 1 to: kws) string ~= kw		or: [| numCrs numCrCrs lastWasCr bad |			numCrs := 0.			numCrCrs := 0.			lastWasCr := false.			bad := false.			1 to: src size do:				[:i| | n |				(n := (src at: i) asInteger) = 13					ifTrue:						[numCrs := numCrs + 1.						lastWasCr							ifTrue: [numCrCrs := numCrCrs + 1. lastWasCr := false]							ifFalse: [lastWasCr := true]]					ifFalse:						[lastWasCr := false.						((n &gt;= 32 and: [n &lt;= 126]) or: [n = 9]) ifFalse:							[bad := true]]].			bad or: [numCrs &gt; 2 and: [numCrCrs &gt;= (numCrs + 1 // 2)]]]]]				on: Object errorSignal				do: [:ex| ex returnWith: true]]	"SystemAnalyzer new allSuspiciousSources"	"MethodCollector new		openListBrowserOn: SystemAnalyzer new allSuspiciousSources		label: 'Bad Sources'"</body><body package="AT System Analysis">allUnSentMessagesFor: aBehavior	"Answer a Collection of each message that is implemented by aBehavior but is not sent by any method in the system."	| unsentSelectors |	unsentSelectors := OrderedCollection new.	(self methodDictionaryFor: aBehavior ) keysDo:		[:sel |		(self allSentMessages includes: sel)			ifFalse: [unsentSelectors add: sel]].	^unsentSelectors</body><body package="AT System Analysis">allUnimplementedCallsFor: aClass	"Answer an Array of each message that is sent by an expression in a method but is not implemented in the system."	| aStream |	aStream := nil.	(aClass instVarAt: 2) keysDo:		[:sel |		| badSet |		badSet := nil.		 (aClass compiledMethodAt: sel) withAllBlockMethodsDo:			[:meth |			|scanner |			scanner := InstructionStream on: meth.			scanner	scanFor: 				[:byte |				| selector |				selector := scanner peekForSelector.				selector == nil					ifFalse: [(self allImplementedMessages includes: selector) 								ifFalse: [badSet == nil ifTrue: [badSet := IdentitySet new].										badSet add: selector]].				false	"keep scanning"]].		badSet == nil			ifFalse: [aStream == nil ifTrue: [aStream := (Array new: 8) writeStream].					aStream nextPut: sel -&gt; badSet]].	^aStream == nil		ifTrue: [#()]		ifFalse: [aStream contents]</body><body package="AT System Analysis">dependenciesFor: aClass	"Answer a Collection of classes that aClass references (depends on)."	"self new dependenciesFor: Browser"	| set |	set :=  IdentitySet new.	self allMethodsIn: aClass do: 		[:m |		self allLiteralsIn: m value do:			[:v |			(v isVariableBinding and: [v value isBehavior and: [v value ~~ aClass]])				ifTrue: [set add: v value]]].	self allMethodsIn: aClass class do: 		[:m |		self allLiteralsIn: m value do:			[:v |			(v isVariableBinding and: [v value isBehavior and: [v value ~~ aClass]])				ifTrue: [set add: v value]]].	^set</body><body package="AT System Analysis">dependentMethodsFor: aClass	"Answer a collection of methods in aClass that reference another class."	| collection |	collection := OrderedCollection new.	self allMethodsIn: aClass do: 		[:m |		(self method: m value referencesClassOtherThan: aClass)			ifTrue: [collection add: m key]].	^collection</body><body package="AT System Analysis">flatDuplicateMethods	"Answer a collection of all methods in the same class that have the same code but	 different selectors (e.g. Behavior hasMethods and Behavior&gt;hasLocalMethods)"	| allMethods duplicates |	"There are approximately 24 methods per class/metaclass in a kitchen-sink 2.5.2 image.	 Make a dictionary larger than this to avoid grow overhead."	allMethods := Dictionary new: Smalltalk allClassNames size * 36.	self allBehaviorsDo:		[:b|		b selectorsAndMethodsDo:			[:s :m|			(allMethods at: m ifAbsentPut: [OrderedCollection new]) addLast: m]].	"Select the duplicates (much faster than removing non-duplicates)"	allMethods := allMethods select: [:ea| ea size &gt; 1].	"Check for redundancy."	duplicates := OrderedCollection new: allMethods size.	allMethods do:		[:coll|		coll do:			[:meth| | mc |			mc := meth mclass.			coll do:				[:m| "N**2. Eek!!"				(m ~~ meth				and: [m mclass == mc])					ifTrue:						[| def1 def2 |						def1 := meth definition.						def2 := m definition.						(duplicates includes: def1) ifFalse: [duplicates addLast: def1].						(duplicates includes: def2) ifFalse: [duplicates addLast: def2]]]]].	^duplicates	"SystemAnalyzer new flatDuplicateMethods"</body><body package="AT System Analysis">instanceVariablesNotReferencedFor: aClass	"Answer a list of classes and instance variables defined in, but not used in that class."	| aStream classes |	aStream := Array new writeStream.	classes := (Array with: aClass) , aClass allSubclasses.	aClass instVarNames do:		[:instVarName |		classes detect: [:c | (c whichSelectorsAccess: instVarName) size &gt; 0]			ifNone: [aStream nextPut: instVarName]].	^aStream contents</body><body package="AT System Analysis">obsoleteAssociations	"Answer a collection of all associations containing obsolete classes."	"SystemAnalyzer new obsoleteAssociations."	| class |	^Association allInstances,	VariableBinding allInstances select:		[:assoc |		class := assoc value class.		class isMeta and: [class isObsolete]]</body><body package="AT System Analysis">obsoleteClassReferences	"Answer a collection of all the methods that reference obsolete classes."	| methods assocs |	methods := SortedCollection new.	assocs := self obsoleteAssociations.	self allBehaviorsDo: [:class | 		class selectorsAndMethodsDo: [:sel :meth|			meth allLiteralsDo: [:lit|				"If the method refers to more than one class then the set will				 eliminate multiple entries for this method."				(lit isVariableBinding				and: [lit value isBehavior				and: [assocs includes: lit]]) ifTrue:					[methods add: (MethodDefinition class: class selector: sel)]]]].	^methods</body><body package="AT System Analysis">obsoleteClasses	"Answer a collection of all obsolete classes."	"SystemAnalyzer new obsoleteClasses."	^(Metaclass allInstances select: [:metaclass | metaclass isObsolete])		collect: [:metaclass | metaclass someInstance]</body><body package="AT System Analysis">obsoleteMetaclasses	"Answer a collection of all obsolete Metaclasses."	"SystemAnalyzer new obsoleteMetaclasses."	^Metaclass allInstances select: [:metaclass | metaclass ~~ metaclass soleInstance class]</body><body package="AT System Analysis">unResponsivesFor: class	"Answer an Array of Associations with the key a selector and the value an Array with two Sets.	The selector is a selector implemented as subclassResponsibility.	The first set includes the classes that didn't implement the selector.	The second set includes the subclasses that are suspected of being also Abstract	since each member has subclass implementations."	| stream aCollection concreteSet abstractSet workingSet aSubclass srsym |	srsym := 'subclassResponsibility' asSymbol.	aCollection := class whichSelectorsReferTo: srsym.	aCollection size &gt; 0		ifTrue:		[stream := WriteStream on: (Array new: aCollection size).		aCollection do:			[:selector |			workingSet := class subclasses asOrderedCollection.			concreteSet := Set new.			abstractSet := Set new.			[workingSet isEmpty] whileFalse:			[aSubclass := workingSet removeFirst.			(aSubclass includesSelector: selector)				ifFalse: 				[(self checkHierarchyUnder: aSubclass forSelector: selector)					ifFalse: [concreteSet add: aSubclass.						 	workingSet addAll: aSubclass subclasses]					ifTrue: [(class whichSelectorsReferTo: srsym) size &gt; 0								ifTrue: [abstractSet add: aSubclass.						 				workingSet addAll: aSubclass subclasses]]]].			(concreteSet isEmpty and: [abstractSet isEmpty])					ifFalse: [stream nextPut: selector-&gt;(Array with: concreteSet with: abstractSet)]].			^stream contents]		ifFalse: [^Array new].</body><body package="AT System Analysis">undeclaredsFor: class	"Answer an Array of Associations with the selector as key and the value a Collection of undeclared Associations."	| answer ud |	ud := self allUndeclaredAssociations.	answer := nil.	self allMethodsIn: class do: 		[:m |		| oc |		oc := nil.		self allLiteralsIn: m value do: 			[:v |			(v isVariableBinding and: [ud includes: v binding])				ifTrue: [oc == nil ifTrue: [oc := OrderedCollection new: 2].						oc add: v]].		oc == nil			ifFalse: [answer == nil ifTrue: [answer := (Array new: 5) writeStream].					answer nextPut: (m key -&gt; oc)]].	^answer == nil		ifTrue: [#()]		ifFalse: [answer contents]</body></methods><methods><class-id>Tools.SystemAnalyzer</class-id> <category>dynamic checks</category><body package="AT System Analysis">allActiveUnboundMethods	"Answer a collection of all active methods in the system that are unbound, i.e. that are not in some class's method dictionary. Ignore the process running this method."	| unbound |	unbound := OrderedCollection new.	Process allInstancesDo: [:p|		p ~~ Processor activeProcess			ifTrue:				[[| ctxt |				ctxt := p suspendedContext.				[ctxt ~~ nil] whileTrue:					[ctxt method homeMethod definition == nil ifTrue:						[unbound addLast: ctxt method].					ctxt := ctxt sender]] valueUnpreemptively]].	^unbound	"SystemAnalyzer new allActiveUnboundMethods"</body><body package="AT System Analysis">allProcessesWithUnboundMethods	"Answer a collection of all processes that have an unbound method on their stack.	 Ignore the process running this method."	| processes |	processes := Set new.	Process allInstancesDo: [:p|		p ~~ Processor activeProcess			ifTrue:				[[| ctxt |				ctxt := p suspendedContext.				[ctxt ~~ nil] whileTrue:					[ctxt method homeMethod definition == nil						ifTrue:							[processes add: p.							ctxt := nil]						ifFalse: [ctxt := ctxt sender]]] valueUnpreemptively]].	^processes asArray	"SystemAnalyzer new allProcessesWithUnboundMethods"</body><body package="AT System Analysis">allUnboundMethods	"Answer a collection of all methods in the system that are unbound, i.e. that are not in some class's method dictionary.."	| unbound |	unbound := OrderedCollection new.	CompiledCode allSubInstancesDo:		[:m|		m homeMethod definition == nil ifTrue:			[unbound addLast: m]].	^unbound	"| unbound |	unbound := SystemAnalyzer new allUnboundMethods.	unbound remove: thisContext method ifAbsent: nil.	unbound"</body><body package="AT System Analysis">obsoleteInstanceCounts	"Answer a Dictionary of the number of instances of each obsolete class."	| obsolete count |	obsolete := Dictionary new.	self obsoleteClasses do:		[:class |		count := class instanceCount.		count &gt; 0 ifTrue: [obsolete at: class put: count]].	^obsolete</body><body package="AT System Analysis">tallyObjectsSatisfying: aBlock 	"Tally instances which satisfy the block predicate.	Answers an Array of InstanceTallies usable as a histogram."	| id result indx inst |	inst := ObjectMemory someObject.	id := IdentityDictionary new: Smalltalk size. "guess good size"	[inst == 0] whileFalse: 		[			(aBlock value: inst) ifTrue: 				[					| beh weight |					beh := thisContext _objectClass: inst.					weight := id						at: beh						ifAbsent: [id at: beh put: (InstanceTally for: beh)].					weight bump: inst				].			inst := ObjectMemory nextObjectAfter: inst		].	"asArray"	result := Array new: id size.	indx := 0.	id do: [:weight | result at: (indx := indx + 1) put: weight].	^result</body><body package="AT System Analysis">weighInstancesOf: aClass with: aBlock	"Answer the total weight of all instances of aClass	by using aBlock to compute the weight of each instance."	| bytes |	bytes := 0.	aClass allInstancesDo: [:i | bytes := bytes + (aBlock value: i)].	^bytes</body></methods><methods><class-id>Tools.SystemAnalyzer</class-id> <category>reporting</category><body package="AT System Analysis">classWeightReportFor: classes on: aStream	"Write a class weight report for classes on aStream."	| sc total titleString |	sc := SortedCollection sortBlock: [:a1 :a2 | a1 value &gt; a2 value].	total := 0.	classes do:		[:cls | | cw |		cw := self totalWeightForClass: cls.		total := total + cw.		sc add: (Association key: cls value: cw)].	titleString := (#BytesClass &lt;&lt; #advanced &gt;&gt; '   Bytes    Class') asString.	aStream nextPutAll: titleString; cr; nextPutAll: (self underline: titleString); cr.	sc do: [:ass |		aStream nextPutAll: (self printStringFor: ass value rightIn: 8).		aStream nextPutAll: '    '.		aStream nextPutAll: ass key name; cr].	classes size &gt; 1		ifTrue: [aStream cr; nextPutAll: (self printStringFor: total rightIn: 8).		aStream nextPutAll: (#All &lt;&lt; #advanced &gt;&gt; '    *** All ***') asString; cr]</body><body package="AT System Analysis">methodWeightReportFor: aClass on: aStream	"Write a method weight report into aStream."	| total |	total := 0.	aClass selectors size &gt; 0 ifTrue:		[total := self methodReportFor: aClass label: aClass name on: aStream].	aClass class selectors size &gt; 0 ifTrue:		[total := total + (self methodReportFor: aClass class label: aClass class name on: aStream)].	total &gt; 0 ifTrue:		[aStream nextPutAll: (#NlTotalBytesIsNl &lt;&lt; #advanced &gt;&gt; '&lt;n&gt;&lt;n&gt;Total Bytes = &lt;1p&gt;&lt;n&gt;'								expandMacrosWith: total)].	aStream cr.</body><body package="AT System Analysis">reportFrom: histogram on: aStream	"Taking a collection of InstanceTallies, write a report on aStream."	| str sic stb |	histogram isEmpty ifTrue: [^String new].	str := (#InstancesTotBytesAveBytesClass &lt;&lt; #advanced &gt;&gt; 'Instances    TotBytes    AvgBytes    Class') asString.	aStream nextPutAll:str; cr; nextPutAll: (self underline: str); cr.	sic := stb := 0.	histogram do:		[:weight |		sic := sic + weight instanceCount.		stb := stb + weight totalBytes.		aStream			nextPutAll: (self printStringFor: weight instanceCount rightIn: 9);			nextPutAll: (self printStringFor: weight totalBytes rightIn: 12);			nextPutAll: (self printStringFor: weight averageBytes rounded rightIn: 12);			next: 4 put: Character space;			print: weight behavior;			cr].	histogram size &gt; 1 ifTrue:		["Produce summary"		aStream			cr;			nextPutAll: (self printStringFor: sic rightIn: 9);			nextPutAll: (self printStringFor: stb rightIn: 12);			nextPutAll: (self printStringFor: (stb asFloat / sic roundTo: 0.1) rightIn: 12);			nextPutAll: (#All &lt;&lt; #advanced &gt;&gt; '    *** All ***') asString; cr].</body></methods><methods><class-id>Tools.SystemAnalyzer class</class-id> <category>constants</category><body package="AT System Analysis">bytesInHeader	"Answer the number of bytes in an objects header."	^BytesInHeader</body><body package="AT System Analysis">bytesInOOP	"Answer the number of bytes taken up an OOP."	^BytesInOOP</body></methods><methods><class-id>Tools.SystemAnalyzer class</class-id> <category>class initialization</category><body package="AT System Analysis">initialize	"Initialize class variables."	"SystemAnalyzer initialize"	| om |	om := ObjectMemory current.	BytesInOOP := om bytesPerOOP.	BytesInHeader := om bytesPerOTE.</body></methods><methods><class-id>Tools.SystemAnalyzer class</class-id> <category>parcel load/unload/save</category><body package="AT System Analysis">preUnloadFor: aParcel	"Close any open applications implemented by this parcel."	ApplicationModel checkUnloadOfApplicationsDefinedBy: aParcel</body></methods><methods><class-id>Tools.SystemAnalyzer class</class-id> <category>utility-browsing</category><body package="AT System Analysis">browseAllCompatibilityClassReferences	"Browse each method that references a backward compatibility Class."	"SystemAnalyzer browseAllCompatibilityClassReferences"	| systemAnalyzer stream |		systemAnalyzer := self new.	stream := Array new writeStream.	systemAnalyzer allBehaviorsDo: [:class |		(systemAnalyzer allCompatibilityClassReferencesFor: class) do: [:assoc |			| str |			str := (String new: 20) writeStream.			str nextPutAll: (#refersTo &lt;&lt; #advanced &gt;&gt; 'refers to ') asString.			assoc value do: [:s | str nextPutAll: s; space].			(stream nextPut: (MethodDefinition class: class selector: assoc key))				extraText: str contents]].	MethodCollector new		openListBrowserOn: stream contents		label: (#BackwardCompatibilityClassReferences &lt;&lt; #advanced &gt;&gt; 'Backward Compatibility Class References') asString</body><body package="AT System Analysis">browseAllCompatibilityMessageReferences	"Browse each method that reference a message that is known to be for backward compatibility."	"SystemAnalyzer browseAllCompatibilityMessageReferences"	| systemAnalyzer stream |	systemAnalyzer := self new.	stream := Array new writeStream.	systemAnalyzer allBehaviorsDo: [:class |		(systemAnalyzer allCompatibilityMessageReferencesFor: class) do: [:assoc |			| str |			str := (String new: 20) writeStream.			str nextPutAll: (#calls &lt;&lt; #advanced &gt;&gt; 'calls ') asString.			assoc value do: [:s | str nextPutAll: s; space].			(stream nextPut: (MethodDefinition class: class selector: assoc key))				extraText: str contents]].	MethodCollector new		openListBrowserOn: stream contents		label: (#BackwardCompatibilitySends &lt;&lt; #advanced &gt;&gt; 'Backward Compatibility Sends') asString</body><body package="AT System Analysis">browseAllDuplicateMethods	"Browse all methods in each class that have the same code but different selectors."	"SystemAnalyzer browseAllDuplicateMethods."	MethodCollector new		openListBrowserOn: self new allDuplicateMethods		label: (#DuplicateMethods &lt;&lt; #advanced &gt;&gt; 'Duplicate methods') asString</body><body package="AT System Analysis">browseAllIndefiniteCompatibilityMessageReferences	"Browse each method that reference a message that is defined in some class as backward compatibility but defined in another class as not backward compatibility."	"SystemAnalyzer browseAllIndefiniteCompatibilityMessageReferences"	| systemAnalyzer stream |	systemAnalyzer := self new.	stream := Array new writeStream.	systemAnalyzer allBehaviorsDo: [:class |		(systemAnalyzer allIndefiniteCompatibilityMessageReferencesFor: class) do: [:assoc |			| str |			str := (String new: 20) writeStream.			str nextPutAll: (#calls &lt;&lt; #advanced &gt;&gt; 'calls ') asString.			assoc value do: [:s | str nextPutAll: s; space].			(stream nextPut: (MethodDefinition class: class selector: assoc key))				extraText: str contents]].	MethodCollector new		openListBrowserOn: stream contents		label: (#IndefiniteBackwardCompatibilitySends &lt;&lt; #advanced &gt;&gt; 'Indefinite Backward Compatibility Sends') asString</body><body package="AT System Analysis">browseAllMethodsInMultipleProtocols	"Open a Browser on all methods that appear in more than one protocol."	"SystemAnalyzer browseAllMethodsInMultipleProtocols"	| culprits |	culprits := self new allMethodsInMultipleProtocols.	MethodCollector new		openListBrowserOn: (culprits asSortedCollection:								[:md1 :md2 | "sort by selector, not class"								md1 selector &lt; md2 selector								or: [md1 selector = md2 selector									and: [md1 implementingClass name &lt;= md2 implementingClass name]]])		label: (#methodsInMultipleProtocols &lt;&lt; #advanced &gt;&gt; 'methods in multiple protocols') asString</body><body package="AT System Analysis">browseAllSelect: aBlock	"Browse each method that, when used as the	block argument to aBlock gives a true result."	"	For example,		SystemAnalyzer browseAllSelect: 			[:method | 			method numLiterals &gt; 10]	"	MethodCollector new		openListBrowserOn: (self new allSelect: aBlock)		label: (#selectedMessages &lt;&lt; #advanced &gt;&gt; 'selected messages') asString</body><body package="AT System Analysis">browseAllSuperfluousMethods: includeOverridden	"Browse each method that overrides an exacly equivalent method.	 Included in the list are the methods that are overridden."	"SystemAnalyzer browseAllSuperfluousMethods: true"	"SystemAnalyzer browseAllSuperfluousMethods: false"	MethodCollector new		openListBrowserOn: (self new allSuperfluousMethods: includeOverridden)		label: (#SuperfluousMethods &lt;&lt; #advanced &gt;&gt; 'Superfluous methods') asString</body><body package="AT System Analysis">browseAllUnSentMessages	"Browse each method that is not sent by any class in the system."		"SystemAnalyzer browseAllUnSentMessages "	| stream sa |	stream := (Array new: 64) writeStream.	sa := self new.	sa allBehaviorsDo: 		[:cl |		(sa allUnSentMessagesFor: cl) do:			[:sel | 			stream nextPut: (MethodDefinition class: cl selector: sel)]].	MethodCollector new		openListBrowserOn: stream contents		label: (#UnsentMessages &lt;&lt; #advanced &gt;&gt; 'Unsent Messages') asString</body><body package="AT System Analysis">browseAllUnimplementedCalls	"Browse each method that includes a message	that is not implemented in any class in the system."	"SystemAnalyzer browseAllUnimplementedCalls."	| stream sa |	stream := Array new writeStream.	sa := self new.	sa allBehaviorsDo: 		[:class |		(sa allUnimplementedCallsFor: class) do:			[:assoc |			| str |			str := (String new: 10) writeStream.			str nextPutAll: (#calls &lt;&lt; #advanced &gt;&gt; 'calls ') asString.			assoc value do: [:s | str nextPutAll: s; space].			(stream nextPut: (MethodDefinition class: class selector: assoc key))				extraText: str contents]].	MethodCollector new		openListBrowserOn: stream contents		label: (#UnimplementedCalls &lt;&lt; #advanced &gt;&gt; 'Unimplemented calls') asString</body><body package="AT System Analysis">browseMethodsOfCopyingBlocks	"Browse ever method in the system that has a copying block.	 Note that we do not include full copying blocks, which are included	 with full blocks.  A copying block should be more efficient than	 a full block, and a full block should be more efficient than a full	 copying block."	"SystemAnalyzer browseMethodsOfCopyingBlocks"	self browseAllSelect: [:m |	  (m withAllBlockMethods select: [:b |	    (b bytesIncludes: OpXCopyingBlock) and: [(InstructionStream on: b)	      scanFor: [:op | op = OpXCopyingBlock]]]) isEmpty not]</body><body package="AT System Analysis">browseMethodsOfFullBlocks	"Browse ever method in the system that has a full block."	"SystemAnalyzer browseMethodsOfFullBlocks"	self browseAllSelect: [:m |	  (m withAllBlockMethods select: [:b |	    ((b bytesIncludes: OpFullBlock) or: [b bytesIncludes: OpFullCopyingBlock])		and: [(InstructionStream on: b) scanFor:				[:op | op = OpFullBlock or: [op = OpFullCopyingBlock]]]]) isEmpty not]</body><body package="AT System Analysis">browseObsoleteClassReferences	"Browse all methods that reference obsolete classes."	"SystemAnalyzer browseObsoleteClassReferences."	MethodCollector new		openListBrowserOn: self new obsoleteClassReferences 		label: (#ReferencesToObsoleteClasses &lt;&lt; #advanced &gt;&gt; 'References to Obsolete Classes') asString</body></methods><methods><class-id>Tools.SystemAnalyzer class</class-id> <category>utility-reports</category><body package="AT System Analysis">classDependencyReport	"Schedules a view with a report of the class dependencies for all classes in the system."	"SystemAnalyzer classDependencyReport"	| stream categories sa |	stream := String new writeStream.	sa := self new.	categories := Dictionary new.	Root withAllNameSpacesDo:		[:nameSpace |		nameSpace organization classCategories do:			[:cat|			(categories at: cat ifAbsentPut: [Set new]) add: nameSpace]].	categories keys asSortedCollection do:		[:cat | | nameSpaces classesInCategory |		nameSpaces := categories at: cat.		classesInCategory := Set new.		nameSpaces do:			[:nameSpace|			 classesInCategory				addAll: (((nameSpace organization listAtCategoryNamed: cat)							select: [:key| (nameSpace bindingFor: key) isForClass])								collect: [:key| (nameSpace bindingFor: key) value])].		classesInCategory notEmpty ifTrue:			[stream cr; nextPutAll: cat.			 (classesInCategory asSortedCollection: [:c1 :c2| c1 name &lt; c2 name]) do:				[:cls | | deps count|				stream cr; tab; print: cls; cr; tab; tab.				deps := sa dependenciesFor: cls.				count := 0.				(deps  asSortedCollection: [:c1 :c2| c1 name &lt; c2 name]) do: 					[:dep |					count := count + 1.					(count \\ 4) = 0 ifTrue: [stream cr; tab; tab].					stream nextPutAll: dep name; space]]]].	self makeViewFor: stream contents		labeled: (#ClassDependencies &lt;&lt; #advanced &gt;&gt; 'Class dependencies')</body><body package="AT System Analysis">showClassWeights	"Schedules a view with a list of estimated class weights (total size 	in bytes), sorted by space used."	"SystemAnalyzer showClassWeights"	| stream classes |	stream := String new writeStream.	classes := OrderedCollection new.	SystemUtils allBehaviorsDo:		[:beh | beh isMeta ifFalse: [classes add: beh]].	classes := classes asSortedCollection: [:c1 :c2 | c1 fullName &lt; c2 fullName].	self new classWeightReportFor: classes on: stream.	self makeViewFor: stream contents		labeled: (#ClassCostsEstimatedBytes &lt;&lt; #advanced &gt;&gt; 'Class costs (estimated bytes)')</body><body package="AT System Analysis">showSystemHistogram	"Schedules a view with a histogram of all instances, sorted by total 	space used."	"SystemAnalyzer showSystemHistogram"	| hist sc sa stream |	ObjectMemory garbageCollect.	sa := self new.	hist := sa tallyObjectsSatisfying: [:obj | true].	sc := SortedCollection sortBlock: [:i1 :i2 | i1 totalBytes &gt; i2 totalBytes].	sc addAll: hist.	stream := String new writeStream.	sa reportFrom: sc on: stream.	self		makeViewFor: stream contents		labeled: (#AllInstancesHistogram &lt;&lt; #advanced &gt;&gt; 'All instances histogram')</body></methods><methods><class-id>Tools.SystemAnalyzer class</class-id> <category>private</category><body package="AT System Analysis">makeViewFor: string labeled: label	"Schedule a workspace with the supplied contents."	| holderView topView holder |	holder := ValueHolder new value: string.	holderView := ComposedTextView model: holder.	UILookPolicy new setStyleOf: holderView to: #fixed.	topView := ScheduledWindow new.	topView model: holderView model.	topView label: label asString.	topView component: (LookPreferences edgeDecorator on: holderView).	topView minimumSize: 460 @ 460.	topView open</body></methods><methods><class-id>Tools.ManualWriter</class-id> <category>report-actions</category><body package="AT System Analysis">doHardcopy	(postScript := #{Document} isDefined)		ifTrue: [self reportPostscript]		ifFalse: [self reportText asParagraph hardcopy]</body><body package="AT System Analysis">doIt	reportOrPrint value == #report		ifTrue: [^self doReport].	reportOrPrint value == #print		ifTrue: [^self doHardcopy].</body><body package="AT System Analysis">doReport	postScript := false.	ComposedTextView		open: (ValueHolder new value: self reportText)		label: (#ManualWriter &lt;&lt; #advanced &gt;&gt; 'Manual Writer') asString		extent: 400 @ 300</body><body package="AT System Analysis">reportDefinitionFor: cl on: streamOrDoc	"Place onto the argument, streamOrDoc, a textual definition of the class argument, cl. Answer the receiver."	| instVars classVars pools |	self tabsOfSize: DefinitionTabSize on: streamOrDoc.	self reportKeyword: 'Class:' tabs: 4 on: streamOrDoc.	self reportValue: cl name on: streamOrDoc emphasis: self emphasisForClassName.	(cl environment bindingFor: cl name) isPrivate		ifTrue: [self reportValue: '  (private)' on: streamOrDoc emphasis: self emphasisForClassDefinition].	self cr: streamOrDoc.	instance value ifTrue:		[self reportKeyword: 'Environment:' tabs: 2 on: streamOrDoc.		self reportValue: cl environment printString on: streamOrDoc emphasis: self emphasisForClassDefinition.		self reportKeyword: 'Superclass:' tabs: 3 on: streamOrDoc.		self reportValue: cl superclass printString on: streamOrDoc emphasis: self emphasisForClassDefinition.		self reportKeyword: 'Category:' tabs: 3 on: streamOrDoc.		self reportValue: cl category on: streamOrDoc emphasis: self emphasisForClassDefinition.		(instVars := cl instVarNames) isEmpty			ifFalse: [self reportKeyword: 'Instance variables:' tabs: 1 on: streamOrDoc.					self reportValueCollection: instVars						on: streamOrDoc 						emphasis: self emphasisForClassDefinition].		cl isVariable			ifTrue:				[self reportKeyword: 'Indexed variables:' tabs: 1 on: streamOrDoc.				self reportValue: (cl isBits ifTrue: ['bytes'] ifFalse: ['objects'])					on: streamOrDoc 					emphasis: self emphasisForClassDefinition].		(classVars := cl class instVarNames asSortedCollection) isEmpty			ifFalse: [self reportKeyword: 'Class instance variables:' tabs: 1 on: streamOrDoc.					self reportValueCollection: classVars						on: streamOrDoc						emphasis: self emphasisForClassDefinition].		(classVars := cl classVarNames asSortedCollection) isEmpty			ifFalse: [self reportKeyword: 'Class variables:' tabs: 2 on: streamOrDoc.					self reportValueCollection: classVars						on: streamOrDoc						emphasis: self emphasisForClassDefinition].		(pools := cl importDefinitions) isEmpty			ifFalse: [self reportKeyword: 'Imports:' tabs: 4 on: streamOrDoc.					self reportValueCollection: (pools collect: [:pd | pd definitionString])						on: streamOrDoc						emphasis: self emphasisForClassDefinition].		self reportExtendedDefinitionFor: cl on: streamOrDoc.		self cr: streamOrDoc; cr: streamOrDoc].	self tabsOfSize: NormalTabSize on: streamOrDoc.	comment value ifTrue:		[self reportValue: cl comment on: streamOrDoc emphasis: self emphasisForClassComment]</body><body package="AT System Analysis">reportExtendedDefinitionFor: cl on: streamOrDoc	"Place onto the argument, streamOrDoc, additional class definition arguments not covered by #reportDefinitionFor:on:. Answer the receiver. This method assumes the default arguments are instance variable names, class variable names, pool dictionaries, and the class category. It also assumes a particular tabbing layout given the class keyword font emphasis (see the method #emphasisForClassDefinition)."	| definitionMessage keywords arguments defaultSelectors |	definitionMessage := cl definitionMessage.	arguments := definitionMessage arguments.	keywords := definitionMessage selector keywords.	defaultSelectors := #( 'instanceVariableNames:' 'classVariableNames:'							'classInstanceVariableNames:' 'imports:'							'superclass:' 'indexedType:' 'private:'							'poolDictionaries:' 'category:' ).	2 to: keywords size do: [:i | | aKeyword anArg |		aKeyword := keywords at: i.		(defaultSelectors includes: aKeyword) ifFalse: [			anArg := arguments at: i.			anArg isString				ifTrue: [anArg := anArg tokensBasedOn: Character space]				ifFalse: [anArg := Array with: anArg printString].			anArg := anArg reject: [:theArg | theArg isString and: [theArg isEmpty]].			anArg isEmpty ifFalse: [| keywordSize |				aKeyword at: 1 put: aKeyword first asUppercase.				keywordSize := (aKeyword asText					emphasizeAllWith: self emphasisForClassDefinitionKeyword)						asComposedText width.				self reportKeyword: aKeyword tabs: (120 - keywordSize / 24 max: 1) ceiling on: streamOrDoc.				self reportValueCollection: anArg					on: streamOrDoc					emphasis: self emphasisForClassDefinition]]]</body><body package="AT System Analysis">reportForClass: cl on: streamOrDoc	self reportDefinitionFor: cl on: streamOrDoc.	cl organization categories do:		[:cat |		self reportProtocol: cat for: cl on: streamOrDoc].	class value ifTrue:		[self reportMetaDefinitionFor: cl on: streamOrDoc.		cl class organization categories do:			[:cat |			self reportProtocol: cat for: cl class on: streamOrDoc]]</body><body package="AT System Analysis">reportKeyword: keyword tabs: anInteger on: streamOrDoc	postScript		ifTrue:			[streamOrDoc addText:				((keyword, (String with: Character tab)) asText					emphasizeAllWith: self emphasisForClassDefinitionKeyword)]		ifFalse:			[self emphasizeForClassDefinitionKeyword: streamOrDoc.			streamOrDoc nextPutAll: keyword.			anInteger timesRepeat: [streamOrDoc tab]]</body><body package="AT System Analysis">reportMetaDefinitionFor: cl on: streamOrDoc	| instVars |	2 timesRepeat: [self cr: streamOrDoc].	self tabsOfSize: DefinitionTabSize on: streamOrDoc.	self reportKeyword: 'MetaClass:' tabs: 3 on: streamOrDoc.	self reportValue: cl class name		on: streamOrDoc		emphasis: self emphasisForClassDefinition.	self cr: streamOrDoc.	self tabsOfSize: NormalTabSize on: streamOrDoc.	(instVars := cl class instVarNames) isEmpty		ifFalse: [self reportKeyword: 'Instance variables:' tabs: 1 on: streamOrDoc.				self reportValueCollection: instVars					on: streamOrDoc 					emphasis: self emphasisForClassDefinition].</body><body package="AT System Analysis">reportMethod: sel for: cl on: stream	| source parser header endOfHeader thisComment body |	method value ifFalse: [^self].	stream cr; cr.	source := cl sourceCodeAt: sel.	source isEmpty ifTrue: [^self].	(parser := cl parserClass new) parseSelector: source.	endOfHeader := parser endOfLastToken.	[(source at: endOfHeader) isSeparator] whileTrue:		[endOfHeader := endOfHeader - 1].	"back up over white space"	header := source copyFrom: 1 to: (endOfHeader min: source size).	thisComment := parser parseMethodComment: source setPattern: [:none | none].	thisComment isEmpty		ifFalse: [thisComment := thisComment first].	body := source copyFrom: endOfHeader + 1 to: source size.	self emphasizeForMethodHeader: stream.	stream nextPutAll: header.	methodBody value		ifTrue:			[self emphasizeForMethodBody: stream.			stream nextPutAll: body]		ifFalse:			[methodComment value ifTrue: 				[self emphasizeForMethodComment: stream.				stream cr; tab; nextPutAll: thisComment]].</body><body package="AT System Analysis">reportPostscript	"Create a postscript document, put the report into it, and print it."	| doc |	doc := Document new.	1 to: classList size do:		[:i || cl |		cl := classList at: i.		doc doFooter: true footerString: cl name asString doPageNumbers: true.		self reportForClass: cl on: doc.		i &lt; classList size ifTrue: [self newPageOn: doc]].	doc close; toPrinter</body><body package="AT System Analysis">reportProtocol: cat for: cl on: streamOrDoc	| textStream |	(private value not and: ['private*' match: cat])		ifTrue: [^self].	postScript		ifTrue: [textStream := TextStream on: (String new: 100)]		ifFalse: [textStream := streamOrDoc].	protocols value ifTrue:		[textStream cr.		self emphasizeForProtocol: textStream.		textStream cr; nextPutAll: cat].	(cl organization listAtCategoryNamed: cat) do:		[:sel |		self reportMethod: sel for: cl on: textStream].	postScript ifTrue:		[streamOrDoc addText: textStream contents]</body><body package="AT System Analysis">reportText	"Answer a Text containing the report for the current classes."	| stream |	stream := TextStream on: (String new: 100).	1 to: classList size do:		[:i || cl |		cl := classList at: i.		self reportForClass: cl on: stream.		i &lt; classList size ifTrue: [self newPageOn: stream]].	^stream contents</body><body package="AT System Analysis">reportValue: string on: streamOrDoc emphasis: anEmphasis	"A keyword and tabs have already been reported.   Add the string in the given	emphasis, and put out a cr at the end."	postScript		ifTrue:			[streamOrDoc addText:				(string asText emphasizeAllWith: anEmphasis)]		ifFalse:			[streamOrDoc emphasis: anEmphasis.			streamOrDoc nextPutAll: string].	self cr: streamOrDoc</body><body package="AT System Analysis">reportValueCollection: coll on: streamOrDoc emphasis: anEmphasis	"A keyword and tabs have already been reported.   Add the character in the collection,	putting out a cr and tabs whenever hitting the right margin is likely, the test for which is just	the heuristic of 50 characters."	| strm count |	strm := WriteStream on: (String new: 100).	count := 0.	coll do:		[:string |		count + string size &gt; 50			ifTrue: 				[strm cr; tab.	"One tab for postscript; five for non-postscript"				postScript ifFalse: [4 timesRepeat: [strm tab]].				count := 0].		strm nextPutAll: string; space.		count := count + string size].	postScript		ifTrue:			[streamOrDoc addText:				(strm contents asText emphasizeAllWith: anEmphasis)]		ifFalse:			[streamOrDoc emphasis: anEmphasis.			streamOrDoc nextPutAll: strm contents].	self cr: streamOrDoc</body></methods><methods><class-id>Tools.ManualWriter</class-id> <category>report-emphases</category><body package="AT System Analysis">emphasisForClassComment	^#italic</body><body package="AT System Analysis">emphasisForClassDefinition	^#(#sanserif #large)</body><body package="AT System Analysis">emphasisForClassDefinitionKeyword	^#(#serif #large)</body><body package="AT System Analysis">emphasisForClassName	^#(#large #bold)</body><body package="AT System Analysis">emphasisForMethodBody	^nil</body><body package="AT System Analysis">emphasisForMethodComment	^#italic</body><body package="AT System Analysis">emphasisForMethodHeader	^#bold</body><body package="AT System Analysis">emphasisForProtocol	^#(#italic #large)</body><body package="AT System Analysis">emphasizeForClassDefinitionKeyword: stream	stream emphasis: self emphasisForClassDefinitionKeyword</body><body package="AT System Analysis">emphasizeForMethodBody: stream	stream emphasis: self emphasisForMethodBody</body><body package="AT System Analysis">emphasizeForMethodComment: stream	stream emphasis: self emphasisForMethodComment</body><body package="AT System Analysis">emphasizeForMethodHeader: stream	stream emphasis: self emphasisForMethodHeader</body><body package="AT System Analysis">emphasizeForProtocol: stream	stream emphasis: self emphasisForProtocol</body></methods><methods><class-id>Tools.ManualWriter</class-id> <category>report-utilities</category><body package="AT System Analysis">cr: streamOrDoc	postScript		ifTrue:			[streamOrDoc addText: (String with: Character cr) asText]		ifFalse:			[streamOrDoc cr]</body><body package="AT System Analysis">newPageOn: streamOrDoc	postScript		ifTrue: [streamOrDoc newPage]		ifFalse: [streamOrDoc nextPut: (Character newPage)]</body><body package="AT System Analysis">tabsOfSize: tabValue on: streamOrDoc	"If doing postScript, then reset the document's tab to the given size"	| tabArray |	postScript		ifTrue:			[tabArray := Array new: 34.			1 to: tabArray size do:				[:i | tabArray at: i put: i*tabValue].			streamOrDoc setTabs: tabArray.			streamOrDoc startParagraph]</body></methods><methods><class-id>Tools.ManualWriter</class-id> <category>button-updating</category><body package="AT System Analysis">update: anAspect with: aParameter from: anObject	anObject == method		ifTrue: [^self updateMethod].	anObject == instance		ifTrue: [^self updateInstance].	anObject == methodBody		ifTrue: [^self updateMethodBody].	anObject == methodComment		ifTrue: [^self updateMethodComment].</body><body package="AT System Analysis">updateInstance	instance value			ifFalse: [comment value: false]</body><body package="AT System Analysis">updateMethod	method value		ifTrue: [methodComment value: false]		ifFalse: [methodComment value: false.				methodBody value: false]</body><body package="AT System Analysis">updateMethodBody	"Can't have both comment and body"	methodBody value		ifTrue: [methodComment value: false]</body><body package="AT System Analysis">updateMethodComment	"Can't have both comment and body"	methodComment value		ifTrue: [methodBody value: false]</body></methods><methods><class-id>Tools.ManualWriter</class-id> <category>button-accessing</category><body package="AT System Analysis">classList: aCollection	classList := aCollection</body><body package="AT System Analysis">comment	"Answer the value for comment"	^comment</body><body package="AT System Analysis">doClass	"Answer the value for class"	^class</body><body package="AT System Analysis">instance	"Answer the value for instance"	^instance</body><body package="AT System Analysis">method	"Answer the value for method"	^method</body><body package="AT System Analysis">methodBody	"Answer the value for methodBody"	^methodBody</body><body package="AT System Analysis">methodComment	"Answer the value for methodComment"	^methodComment</body><body package="AT System Analysis">private	"Answer the value for private"	^private</body><body package="AT System Analysis">protocols	"Answer the value for protocols"	^protocols</body><body package="AT System Analysis">reportOrPrint	^reportOrPrint</body></methods><methods><class-id>Tools.ManualWriter</class-id> <category>initialize-release</category><body package="AT System Analysis">initialize	instance := ValueHolder with: true.	comment := ValueHolder with: true.	class := ValueHolder with: true.	protocols := ValueHolder with: true.	private := ValueHolder with: true.	method := ValueHolder with: true.	methodComment := ValueHolder with: true.	methodBody := ValueHolder with: false.	reportOrPrint := ValueHolder with: #report.	classList:= #().	methodBody addDependent: self.	methodComment addDependent: self.	method addDependent: self.	instance addDependent: self.	postScript := false.</body></methods><methods><class-id>Tools.ManualWriter class</class-id> <category>examples</category><body package="AT System Analysis">example	"Open a report on class ManualWriter.  Use the default behavior,	except include all source code, not just the method comments."	"ManualWriter example"	| mw |	mw := self new.	mw classList: (Array with: self).	mw methodBody value: true.	mw doReport</body></methods><methods><class-id>Tools.ManualWriter class</class-id> <category>class initialization</category><body package="AT System Analysis">initialize	"ManualWriter initialize"	DefinitionTabSize := 1.25.	NormalTabSize := 0.25.</body></methods><methods><class-id>Tools.ManualWriter class</class-id> <category>instance creation</category><body package="AT System Analysis">new	^super new initialize</body></methods><methods><class-id>Core.VariableBinding class</class-id> <category>testing</category><body package="AT System Analysis">isClassOfBinding	"True if instances of the receiver can represent variable bindings.	The test is on the class side so that we can use it without sending	any messages to the object we test (to avoid disturibing proxies)."	^true</body></methods><methods><class-id>Kernel.GeneralNameSpace</class-id> <category>user interface</category><body package="AT System Analysis">referencePathToBinding: aBinding	^(bindings includes: aBinding) ifTrue:		[Array with: self with: bindings]</body></methods><methods><class-id>Core.Behavior</class-id> <category>testing</category><body package="AT System Analysis">isClassOfBinding	"True if instances of the receiver can represent variable bindings.	The test is on the class side so that we can use it without sending	any messages to the object we test (to avoid disturibing proxies)."	^false</body></methods><methods><class-id>Core.Class</class-id> <category>user interface</category><body package="AT System Analysis">referencePathToBinding: aBinding	| refPath |	^(classPool size = 0	  or: [(refPath := classPool referencePathToBinding: aBinding) isNil])		ifFalse: [(Array with: self), refPath]</body></methods><methods><class-id>Kernel.DeferredBinding class</class-id> <category>testing</category><body package="AT System Analysis">isClassOfBinding	"True if instances of the receiver can represent variable bindings.	The test is on the class side so that we can use it without sending	any messages to the object we test (to avoid disturibing proxies)."	^true</body></methods><methods><class-id>Tools.ClassNameChooser class</class-id> <category>interface specs</category><body package="AT System Analysis">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #ClassReports #defaultString: 'Class Reports' #catalogID: #advanced) 			#bounds: #(#{Graphics.Rectangle} 643 436 958 765 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0 130 0 -1 1 -1 1 ) 					#model: #filteredNamesV 					#menu: #listMenu 					#multipleSelections: true 					#useModifierKeys: true 					#selectionType: #checkMark ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0 30 0 -1 1 100 0 ) 					#model: #filterV 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#requestValueChangeSelector: 						#filter: ) 					#menu: #textMenu 					#tabRequiresControl: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 2 5 ) 					#label: #(#{Kernel.UserMessage} #key: #ClassPatterns #defaultString: 'Class patterns' #catalogID: #advanced) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 2 105 ) 					#label: #(#{Kernel.UserMessage} #key: #ClassList #defaultString: 'Class list' #catalogID: #advanced) ) ) ) )</body></methods><methods><class-id>Tools.ClassReporter class</class-id> <category>interface specs</category><body package="AT System Analysis">activeAreaSpec	"UIPainter new openOnClass: self andSelector: #activeAreaSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec #window: #(#WindowSpec #label: #(#{Kernel.UserMessage} #key: #Settings #defaultString: 'Settings' #catalogID: #advanced) #min: #(#Point 265 317 ) #max: #(#Point 265 317 ) #bounds: #(#Rectangle 453 380 718 697 ) ) #component: #(#SpecCollection #collection: #(#(#SubCanvasSpec #layout: #(#LayoutFrame 2 0 2 0 -2 1 -2 1 ) #name: #activeComponents #flags: 0 ) ) ) )</body><body package="AT System Analysis">correctnessSpec	"UIPainter new openOnClass: self andSelector: #correctnessSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #advanced) 			#bounds: #(#Rectangle 627 492 952 783 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#CompositeSpecCollection 					#collection: #(						#(#CheckBoxSpec 							#layout: #(#Point 0 0 ) 							#model: #sentButNotImplemented 							#label: #(#{Kernel.UserMessage} #key: #MessagesSentButNotImplemented #defaultString: 'Messages sent but not implemented' #catalogID: #advanced) ) 						#(#CheckBoxSpec 							#layout: #(#Point 0 25 ) 							#model: #implementedButNotSent 							#label: #(#{Kernel.UserMessage} #key: #MessagesImplementedButNotSent #defaultString: 'Messages implemented but not sent' #catalogID: #advanced) ) 						#(#CheckBoxSpec 							#layout: #(#Point 0 50 ) 							#model: #methodConsistency 							#label: #(#{Kernel.UserMessage} #key: #MethodConsistency #defaultString: 'Method consistency' #catalogID: #advanced) ) 						#(#CheckBoxSpec 							#layout: #(#Point 0 75 ) 							#model: #subclassResponsibilitiesNotImplemented 							#label: #(#{Kernel.UserMessage} #key: #SubclassResponsibilitiesNotImplemented #defaultString: 'Subclass responsibilities not implemented' #catalogID: #advanced) ) 						#(#CheckBoxSpec 							#layout: #(#Point 0 100 ) 							#model: #undeclared 							#label: #(#{Kernel.UserMessage} #key: #Undeclaredreferences #defaultString: 'Undeclared references' #catalogID: #advanced) ) 						#(#CheckBoxSpec 							#layout: #(#Point 0 125 ) 							#model: #instVarsNotReferenced 							#label: #(#{Kernel.UserMessage} #key: #InstVarsNotReferenced #defaultString: 'Inst vars not referenced' #catalogID: #advanced) ) 						#(#CheckBoxSpec 							#layout: #(#Point 0 150 ) 							#model: #goodComment 							#label: #(#{Kernel.UserMessage} #key: #CheckComment #defaultString: 'Check comment' #catalogID: #advanced) ) 						#(#CheckBoxSpec 							#layout: #(#Point 0 175 ) 							#model: #compatibilityMessages 							#label: #(#{Kernel.UserMessage} #key: #BackwardCompatibilityMessageSends #defaultString: 'Backward compatibility message sends' #catalogID: #advanced) ) 						#(#CheckBoxSpec 							#layout: #(#Point 0 198 ) 							#name: #indefiniteBackwardCompatCheckBox 							#model: #indefiniteCompatibilityMessages 							#label: ' ' ) 						#(#CheckBoxSpec 							#layout: #(#Point 0 235 ) 							#model: #compatibilityClasses 							#label: #(#{Kernel.UserMessage} #key: #BackwardCompatibilityClassReferences #defaultString: 'Backward Compatibility Class References' #catalogID: #advanced) ) ) 					#compositeSpec: 					#(#CompositeSpec 						#layout: #(#Rectangle 10 35 304 291 ) 						#name: #reportGroup ) ) 				#(#RadioButtonSpec 					#layout: #(#LayoutOrigin -75 0.5 10 0 ) 					#name: #reportCorrectnessButton 					#model: #correctnessType 					#callbacksSpec: 					#(#UIEventCallbackSubSpec 						#valueChangeSelector: #changedCorrectnessType ) 					#label: #(#{Kernel.UserMessage} #key: #Report #defaultString: 'Report' #catalogID: #advanced) 					#select: #report ) 				#(#RadioButtonSpec 					#layout: #(#LayoutOrigin 10 0.5 10 0 ) 					#name: #browseCorrectnessButton 					#model: #correctnessType 					#callbacksSpec: 					#(#UIEventCallbackSubSpec 						#valueChangeSelector: #changedCorrectnessType ) 					#label: #(#{Kernel.UserMessage} #key: #Browse #defaultString: 'Browse' #catalogID: #advanced) 					#select: #browse ) 				#(#CompositeSpecCollection 					#collection: #(						#(#RadioButtonSpec 							#layout: #(#Point 0 0 ) 							#model: #correctnessBrowsingChoice 							#label: #(#{Kernel.UserMessage} #key: #MessagesSentButNotImplemented #defaultString: 'Messages sent but not implemented' #catalogID: #advanced) 							#select: #browseSentButNotImplemented ) 						#(#RadioButtonSpec 							#layout: #(#Point 0 25 ) 							#model: #correctnessBrowsingChoice 							#label: #(#{Kernel.UserMessage} #key: #MessagesImplementedButNotSent #defaultString: 'Messages implemented but not sent' #catalogID: #advanced) 							#select: #browseImplementedButNotSent ) 						#(#RadioButtonSpec 							#layout: #(#Point 0 50 ) 							#model: #correctnessBrowsingChoice 							#label: #(#{Kernel.UserMessage} #key: #MethodConsistency #defaultString: 'Method consistency' #catalogID: #advanced) 							#select: #browseInconsistentMethods ) 						#(#RadioButtonSpec 							#layout: #(#Point 0 75 ) 							#model: #correctnessBrowsingChoice 							#label: #(#{Kernel.UserMessage} #key: #SubclassResponsibilitiesNotImplemented #defaultString: 'Subclass responsibilities not implemented' #catalogID: #advanced) 							#select: #browseSubclassResponsibilitiesNotImplemented ) 						#(#RadioButtonSpec 							#layout: #(#Point 0 100 ) 							#model: #correctnessBrowsingChoice 							#label: #(#{Kernel.UserMessage} #key: #Undeclaredreferences #defaultString: 'Undeclared references' #catalogID: #advanced) 							#select: #browseUndeclareds ) 						#(#RadioButtonSpec 							#layout: #(#Point 0 125 ) 							#flags: 32 							#tabable: false 							#model: #correctnessBrowsingChoice 							#label: #(#{Kernel.UserMessage} #key: #InstVarsNotReferenced #defaultString: 'Inst vars not referenced' #catalogID: #advanced) ) 						#(#RadioButtonSpec 							#layout: #(#Point 0 150 ) 							#flags: 32 							#tabable: false 							#model: #correctnessBrowsingChoice 							#label: #(#{Kernel.UserMessage} #key: #CheckComment #defaultString: 'Check comment' #catalogID: #advanced) ) 						#(#RadioButtonSpec 							#layout: #(#Point 0 175 ) 							#model: #correctnessBrowsingChoice 							#label: #(#{Kernel.UserMessage} #key: #BackwardCompatibilityMessageSends #defaultString: 'Backward compatibility message sends' #catalogID: #advanced) 							#select: #browseCompatibilityMessageReferences ) 						#(#RadioButtonSpec 							#layout: #(#Point 0 198 ) 							#name: #indefiniteBackwardCompatRadioButton							#model: #correctnessBrowsingChoice 							#label: ' ' 							#select: #browseIndefiniteCompatibilityMessageReferences ) 						#(#RadioButtonSpec 							#layout: #(#Point 0 235 ) 							#model: #correctnessBrowsingChoice 							#label: #(#{Kernel.UserMessage} #key: #Backwardcompatibilityclassceferences #defaultString: 'Backward compatibility class references' #catalogID: #advanced) 							#select: #browseCompatibilityClassReferences ) ) 					#compositeSpec: 					#(#CompositeSpec 						#layout: #(#Rectangle 10 35 304 291 ) 						#name: #browseGroup ) ) ) ) )</body><body package="AT System Analysis">manualSpec	"UIPainter new openOnClass: self andSelector: #manualSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #advanced) 			#bounds: #(#Rectangle 224 257 554 551 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#CheckBoxSpec 					#layout: #(#Point 10 35 ) 					#model: #manualWriterInstance 					#label: #(#{Kernel.UserMessage} #key: #ClassDefinition #defaultString: 'Class definition' #catalogID: #advanced) ) 				#(#CheckBoxSpec 					#layout: #(#Point 10 60 ) 					#model: #manualWriterComment 					#label: #(#{Kernel.UserMessage} #key: #ClassComment #defaultString: 'Class comment' #catalogID: #advanced) ) 				#(#CheckBoxSpec 					#layout: #(#Point 10 85 ) 					#model: #manualWriterDoClass 					#label: #(#{Kernel.UserMessage} #key: #IncludeMetaclass #defaultString: 'Include metaclass' #catalogID: #advanced) ) 				#(#CheckBoxSpec 					#layout: #(#Point 10 110 ) 					#model: #manualWriterProtocols 					#label: #(#{Kernel.UserMessage} #key: #ProtocolNames #defaultString: 'Protocol names' #catalogID: #advanced) ) 				#(#CheckBoxSpec 					#layout: #(#Point 10 135 ) 					#model: #manualWriterPrivate 					#label: #(#{Kernel.UserMessage} #key: #IncludePrivateProtocols #defaultString: 'Include private protocols' #catalogID: #advanced) ) 				#(#CheckBoxSpec 					#layout: #(#Point 10 160 ) 					#model: #manualWriterMethod 					#callbacksSpec: 					#(#UIEventCallbackSubSpec 						#valueChangeSelector: #changedManualMethod ) 					#label: #(#{Kernel.UserMessage} #key: #Methods #defaultString: 'Methods' #catalogID: #advanced) ) 				#(#RadioButtonSpec 					#layout: #(#Point 20 185 ) 					#name: #methodCommentRadioButton 					#flags: 32 					#model: #manualWriterMethodComment 					#callbacksSpec: 					#(#UIEventCallbackSubSpec 						#valueChangeSelector: #changedMethodCommentOrBody ) 					#label: #(#{Kernel.UserMessage} #key: #MethodCommentsOnly #defaultString: 'Method comments only' #catalogID: #advanced) 					#select: true ) 				#(#RadioButtonSpec 					#layout: #(#Point 20 210 ) 					#name: #methodBodyRadioButton 					#flags: 32 					#model: #manualWriterMethodBody 					#callbacksSpec: 					#(#UIEventCallbackSubSpec 						#valueChangeSelector: #changedMethodCommentOrBody ) 					#label: #(#{Kernel.UserMessage} #key: #MethodBodiesIncludingComments #defaultString: 'Method bodies (including comments)' #catalogID: #advanced) 					#select: true )				#(#RadioButtonSpec 					#layout: #(#LayoutOrigin -75 0.5 10 0 ) 					#model: #reportOrPrint 					#label: #(#{Kernel.UserMessage} #key: #Report #defaultString: 'Report' #catalogID: #advanced) 					#select: #report ) 				#(#RadioButtonSpec 					#layout: #(#LayoutOrigin 10 0.5 10 0 ) 					#model: #reportOrPrint 					#label: #(#{Kernel.UserMessage} #key: #Print #defaultString: 'Print' #catalogID: #advanced) 					#select: #print )  ) ) )</body><body package="AT System Analysis">spaceSpec	"UIPainter new openOnClass: self andSelector: #spaceSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #advanced) 			#bounds: #(#Rectangle 202 309 585 688 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#RadioButtonSpec 					#layout: #(#Point 10 10 ) 					#model: #spaceReport 					#label: #(#{Kernel.UserMessage} #key: #ClassSize #defaultString: 'Class size' #catalogID: #advanced) 					#select: #classWeightReport ) 				#(#RadioButtonSpec 					#layout: #(#Point 10 35 ) 					#model: #spaceReport 					#label: #(#{Kernel.UserMessage} #key: #MethodSize #defaultString: 'Method size' #catalogID: #advanced) 					#select: #methodWeightReport ) 				#(#RadioButtonSpec 					#layout: #(#Point 10 60 ) 					#model: #spaceReport 					#label: #(#{Kernel.UserMessage} #key: #InstanceSize #defaultString: 'Instance size' #catalogID: #advanced) 					#select: #instanceWeightReport ) ) ) )</body><body package="AT System Analysis">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #ClassReports 				#defaultString: 'Class Reports' 				#catalogID: #advanced ) 			#min: #(#{Core.Point} 552 396 ) 			#bounds: #(#{Graphics.Rectangle} 720 450 1308 846 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0 1 0 -1 0.4 -1 1 ) 					#flags: 0 					#majorKey: #{Tools.ClassNameChooser} 					#minorKey: #windowSpec 					#clientKey: #filteredClassList ) 				#(#{UI.TabControlSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0.4 1 0 -1 1 -33 1 ) 					#name: #notebook 					#model: #preferenceMasterList 					#labels: #() ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -25 0.7 -32 1 25 0.7 -2 1 ) 					#model: #doIt 					#label: 					#(#{Kernel.UserMessage} 						#key: #run 						#defaultString: 'run' 						#catalogID: #advanced ) 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Tools.ClassReporter class</class-id> <category>resources</category><body package="AT System Analysis">pagesMenu	"Tools.MenuEditor new openOnClass: self andSelector: #pagesMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Correctness 					#defaultString: 'Correctness' 					#catalogID: #advanced ) 				#value: #(#correctnessSpec #correctnessDoIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Space 					#defaultString: 'Space' 					#catalogID: #advanced ) 				#value: #(#spaceSpec #spaceDoIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Manual 					#defaultString: 'Manual' 					#catalogID: #advanced ) 				#value: #(#manualSpec #manualDoIt ) ) ) #(3 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>UI.CommandRegistry class</class-id> <category>commands - launcher</category><body package="AT System Analysis">openClassReporterCommand	&lt;command: #openClassReporter&gt;	^Command		label: #ATClassReports &lt;&lt; #menus &gt;&gt; 'Class reports'		group: #launcher		bindings: #()</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>menus - tools - advanced</category><body package="AT System Analysis">menuItemClassReporter	&lt;menuItemForCommand: #openClassReporter		nameKey: nil		menu: #(#menuBar #tools #atTools)		position: 10.2&gt;	self openApplicationForClassNamed: #{ClassReporter} withSelector: #open</body></methods><initialize><class-id>Tools.ClassDeclarations</class-id></initialize><initialize><class-id>Tools.ClassReporter</class-id></initialize><initialize><class-id>Tools.SystemAnalyzer</class-id></initialize><initialize><class-id>Tools.ManualWriter</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Model</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dependents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Behavior</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>superclass methodDict format subclasses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>Context</name><environment>Kernel</environment><super>Kernel.InstructionStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sender receiver stackp stack </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>Class</name><environment>Core</environment><super>Core.ClassDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name classPool environment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>GeneralNameSpace</name><environment>Kernel</environment><super>Core.KeyedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>organization bindings specificImports generalImports </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Name Spaces</category><attributes><package>System-Name Spaces</package></attributes></class><class><name>ProgramNodeEnumerator</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Support</category><attributes><package>System-Compiler-Support</package></attributes></class><class><name>VisualLauncher</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuBar toolBar textCollector transcriptView statusBar </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>Tools-Misc</package></attributes></class></st-source>