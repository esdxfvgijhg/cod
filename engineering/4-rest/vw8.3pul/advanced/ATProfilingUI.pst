<?xml version="1.0"?><st-source><!-- Name: AT Profiling UINotice: Copyright 2005-2014 Cincom Systems, Inc.  All rights reserved.Comment: This package contains the user interface components of the Advanced Tools profilers.  Both user interface and core components must be loaded in an image used to initiate profiling runs or to examine profiling results, irrespective of whether a profiled process is local or remote.  The TimeProfiler and the AllocationProfiler are used to profile, respectively, the time and space usage of a single process.  The corresponding multi-profilers attempt to profile all processes instead of one.  Note that all profilers rely on a statistical sampling heuristic to estimate, rather than on instrumentation to directly measure, the resources consumed by a process.  See the code comments for more information.  Note that the new profilers should not be loaded over the old profiling code in 'AT Profiling'.This package was based on code contributed by Florin Mateoc, created with valuable assistance from his colleague Kerry LeClue, and once shipped as 'ATProfilingEnhancements'.  Florin also contributed to the validation of this package.  Florin's original code included a refactoring of the original VisualWorks profiler, once shipped as 'ATProfiling', and several modifications to the that profiler, to improve accuracy, decrease overhead, report more details, and improve the lists of target primitives.  It also included the multi-process profilers.DbIdentifier: bear73DbTrace: 448499DbUsername: kgreekDbVersion: 8.1 - 1DevelopmentPrerequisites: #(#(#any 'AT Profiling Core' '') #(#any 'AT Support' ''))PackageName: AT Profiling UIParcel: #('AT Profiling UI')ParcelName: AT Profiling UIPrerequisiteDescriptions: #(#(#name 'AT Profiling Core' #componentType #package) #(#name 'AT Support' #componentType #package))PrerequisiteParcels: #(#('AT Profiling Core' '') #('AT Support' ''))PrintStringCache: (8.1 - 1,kgreek)Version: 8.1 - 1Pre-Unload Block: 	[:pkg| Profiler preUnloadFor: pkg ]Date: 8:40:34 AM October 10, 2014 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.1 (oct14.1) of October 10, 2014 on October 10, 2014 at 8:40:34 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>DetailsProfilePage</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>detailsList tally root </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AT Profiling UI</package></attributes></class><comment><class-id>DetailsProfilePage</class-id><body>DetailsProfilePage is a collaborator of ProfileDetailBrowser that lists all immediate message contributors or derivators of a message tallyInstance Variables	detailsList	&lt;SelectionInList of: MessageTally&gt;	list of tallies that immediately contribute to or are derived from the tally 	node	&lt;MessageTally&gt;		MessageTally browsed	root		&lt;MessageTally&gt; 	Source root of MessageTally browsed</body></comment><class><name>ProfilePage</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>profiler label cutoffHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AT Profiling UI</package></attributes></class><comment><class-id>ProfilePage</class-id><body>ProfilePage is abstact class to add a profile results page to a ProfileOutlineBrowser   Subclasses must implement the following messages:	reports		reportOn:Instance Variables	cutoffHolder	&lt;ValueHolder on: Integer&gt;	any MessageTallies that consume less resource than ''cutoff'' will not be displayed.	label	&lt;String&gt;	description for this page of results	profiler	&lt;AllocationProfiler&gt;	the Profiler that, in collaboration with a ProfilerCore,  generated the execution profile.</body></comment><class><name>ProfileDetailBrowser</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>profileList codeBrowser navigator </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AT Profiling UI</package></attributes></class><comment><class-id>ProfileDetailBrowser</class-id><body>ProfileDetailBrowser is a code browser upon a subset of a profile summary.Instance Variables	codeBrowser	&lt;ProfilerCodeTool&gt;	code browser text pane	navigator	&lt;BrowserNavigator&gt;	profile navigator	profileList	&lt;DetailsProfilePage&gt;	profile list pane</body></comment><class><name>TotalsProfilePage</name><environment>Smalltalk</environment><super>ProfilePage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>totalsList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AT Profiling UI</package></attributes></class><comment><class-id>TotalsProfilePage</class-id><body>TotalsProfilePage is a ProfilePage reporting either space or time utilization totals for a ProfilerInstance Variables	totalsList	&lt;SelectionInList&gt;	list model for totals</body></comment><class><name>Profiler</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>core samplingIntervalAdaptor textModel </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AT Profiling UI</category><attributes><package>AT Profiling UI</package></attributes></class><comment><class-id>Tools.Profiler</class-id><body>A Profiler supplies both an optional user interface and a non-optional programmatic interface for initiating profiling runs.  A Profiler always has a ProfilerCore, usually co-located, as a collaborator.  When a profiling run is finished, reports are usually presented in a ProfileOutlineBrowser, but may also be written to a file.   By default, a Profiler is always co-located with the presenting ProfileOutlineBrowser.  See the methods in the class side 'public api' protocol for examples.  If you understand the default, instructional text presented in the Profiler user interfaces, evaluate 'Profile showTemplates: true' to see standard code templates instead.Subclasses must implement the following messages:	accessing		sampleUnitName	reporting		reportTotalsOn:Instance Variables:	core					&lt;ProfileCore&gt;							the collaborating ProfilerCore	samplingIntervalAdaptor	&lt;PluggableAdaptor&gt;							on the samplingInterval of the applicable ProfilerCore	textModel				&lt;EvaluationHolder | String &gt;							containing the text to be evaluated, if a profiling run is invoked using the optional user interface</body></comment><class><name>AllocationProfiler</name><environment>Tools</environment><super>Tools.Profiler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AT Profiling UI</category><attributes><package>AT Profiling UI</package></attributes></class><comment><class-id>Tools.AllocationProfiler</class-id><body>AllocationProfiler is the concrete class of Profiler used for space allocation profiling.  Note that all profilers rely on a statistical sampling heuristic to estimate, rather than on instrumentation to directly measure, the resources consumed by a process.</body></comment><class><name>MultiAllocationProfiler</name><environment>Tools</environment><super>Tools.AllocationProfiler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AT Profiling UI</category><attributes><package>AT Profiling UI</package></attributes></class><comment><class-id>Tools.MultiAllocationProfiler</class-id><body>MultiAllocationProfiler is the concrete class of Profiler used for multi-process space allocation profiling.  Users are urged to remember that all the profilers rely upon a statistical sampling heuristic to estimate, rather than on instrumentation to directly measure, the resources consumed by a process.  Multi-process profilers will distribute the probes used to estimate resource consumption over several processes, rather than one, mayhaps unevenly.  Also, running multi-process profilers will cause garbage collection and other maintenance processes to be run more frequently than otherwise.  These facts should be kept firmly in view when setting up multi-process profiling runs and when estimating the reliability of their results.  Within these limitations, multi-process profilers have proven useful in tuning web applications involving many hundreds of  processes.</body></comment><class><name>SpaceProfilePage</name><environment>Smalltalk</environment><super>ProfilePage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>usageReport </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AT Profiling UI</package></attributes></class><comment><class-id>SpaceProfilePage</class-id><body>SpaceProfilePage is a ProfilePage reporting space utilization details for an AllocationProfile or MultiAllocationProfileInstance Variables	usageReport	&lt;ValueModel&gt;	text model for space usage report</body></comment><class><name>ProfilerCodeTool</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserCodeTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AT Profiling UI</package></attributes></class><comment><class-id>Refactory.Browser.ProfilerCodeTool</class-id><body>ProfilerCodeTool is a CodeTool editor for methods or unbound code appearing in a profile tree</body></comment><class><name>ProfileBrowser</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>profiler profileTabList totalsReport cutoff pages </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AT Profiling UI</package></attributes></class><comment><class-id>ProfileBrowser</class-id><body>ProfileBrowser implements a user interface used to view the results of a profiling run.Instance Variables	cutoff				&lt;ValueHolder on: Integer&gt; 						any MessageTallies that consume less resource than ''cutoff'' will not be displayed.	profiler				&lt;Profiler&gt;						the Profiler that, in collaboration with a ProfilerCore,  generated the execution profile presented in this ProfileBrowser	findNextMenu		&lt;UndefinedObject | Array of: Symbol&gt;						an Array of the selectors of the methods 'probed' during the collaborating ProfilerCore's execution	pages 				&lt;Collection of: ProfilePage&gt; tab page models ordered by profileTabList.	profileTabList	&lt;SelectionInList&gt;	tab page labels.	totalsReport		&lt;ValueHolder&gt;	profile summary text model. </body></comment><class><name>TallyWrapper</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>messageTally cutoff children </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AT-Support</category><attributes><package>AT Profiling UI</package></attributes></class><comment><class-id>UI.TallyWrapper</class-id><body>TallyWrapper adapts a profiler MessageTally instance to be accessed by a TreeModel using message and #children, #parent, and #printString. Instance Variables	children	&lt;Collection of: TallyWrapper | nil&gt;	description of children	cutoff	&lt;Number&gt;	profiler cutoff value used when messageTally was created. 	messageTally	&lt;MessageTally&gt;	profiler MessageTally I adapt</body></comment><class><name>TimeProfiler</name><environment>Tools</environment><super>Tools.Profiler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AT Profiling UI</category><attributes><package>AT Profiling UI</package></attributes></class><comment><class-id>Tools.TimeProfiler</class-id><body>TimeProfiler is the concrete class of Profiler used for time profiling.  Note that all profilers rely on a statistical sampling heuristic to estimate, rather than on instrumentation to directly measure, the resources consumed by a process.</body></comment><class><name>MultiTimeProfiler</name><environment>Tools</environment><super>Tools.TimeProfiler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AT Profiling UI</category><attributes><package>AT Profiling UI</package></attributes></class><comment><class-id>Tools.MultiTimeProfiler</class-id><body>MultiTimeProfiler is the concrete class of Profiler used for multi-process time profiling.  Users are urged to remember that all the profilers rely upon a statistical sampling heuristic to estimate, rather than on instrumentation to directly measure, the resources consumed by a process.  Multi-process profilers will distribute the probes used to estimate resource consumption over several processes, rather than one, mayhaps unevenly.  Also, running multi-process profilers will cause garbage collection and other maintenance processes to be run more frequently than otherwise.  These facts should be kept firmly in view when setting up multi-process profiling runs and when estimating the reliability of their results.  Within these limitations, multi-process profilers have proven useful in tuning web applications involving many hundreds of  processes.</body></comment><class><name>TreeProfilePage</name><environment>Smalltalk</environment><super>ProfilePage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>treeList root findNextCache allNodes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AT Profiling UI</package></attributes></class><comment><class-id>TreeProfilePage</class-id><body>TreeProfilePage is ProfilePage for selection of nodes in a profile treeInstance Variables	allNodes	&lt;OrderedCollection of: MessageTally | nil&gt;	top down list of all nodes in the tree. Used as an aid for search.	findNextCache	&lt;Array | nil&gt;	 all unique message names in the profile. Used as an aid for search.	root	&lt;MessageTally&gt;	tree root.	treeList	&lt;SelectionInTree&gt;	tree selection model of profile</body></comment><shared-variable><name>ShowTemplates</name><environment>Tools.Profiler</environment><private>false</private><constant>false</constant><category>template control</category><attributes><package>AT Profiling UI</package></attributes></shared-variable><methods><class-id>DetailsProfilePage</class-id> <category>interface opening</category><body package="AT Profiling UI">postBuildWith: aBuilder	super postBuildWith: aBuilder.	((aBuilder componentAt: #profileList) widget)		visualBlock: 				[:view :index |				BoundedWrapper on: (self labelForTally: (view sequence at: index))];		selectedVisualBlock: 				[:view :index |				| rw |				rw := ReversingWrapper on: (self labelForTally: (view sequence at: index)).				rw reverse setValue: true.				BoundedWrapper on: rw]</body></methods><methods><class-id>DetailsProfilePage</class-id> <category>private</category><body package="AT Profiling UI">integrateTalliesForNode: targetMessageTally intoCollection: aCollection	| copyMT rootMT targetMT pSet cSet pT pS tT tS cF |	root := targetMessageTally root.	"I.  Set up working root and target message tallies."	copyMT := root copy.	rootMT := ( ( MessageTally new )					class: copyMT methodClass					method: copyMT method )						tally: copyMT tally;						samples: copyMT samples;						yourself.	targetMT := ( MessageTally new )					class: targetMessageTally methodClass					method: targetMessageTally method.	"II.  Pass 1 :Classify nodes as parents or children of the target, and set links."	( copyMT )		classifyFromWith: targetMT 		parents: ( pSet := Set new: 7 )		children: ( cSet := Set new: 7 ).	pSet do:		[ :mt |	mt parent: rootMT.				rootMT receivers at: mt method put: mt 		].	 pSet isEmpty ifFalse:[targetMT parent: pSet asSortedCollection last].	cSet do:		[ :mt |	mt parent: targetMT.				targetMT receivers at: mt method put: mt		].	"III.  Pass 2 : Integrate the data."	( cSet isEmpty not )		ifTrue:	[ ( copyMT ) integrateChildrenFrom: targetMT children: cSet ].	( copyMT ) integrateParentsFrom: targetMT parents: pSet.	"IV. No children fix-ups."	( cSet isEmpty )		ifTrue:	[	pT := pSet inject: 0 into: [ :x : y | x + y tally ].					pS := pSet inject: 0 into: [ :x :y | x + y samples ].				 	targetMT  bump: pT samples: pS.					cF := ( copyMT copy )								name: ( #noChildren &lt;&lt; #advanced &gt;&gt; '&lt;no children&gt;' ) asString;								parent: targetMT;								yourself.					cSet add: cF.					targetMT receivers at: cF method put: cF.				].	"V. Primitive fix-ups."	( cSet isEmpty not )		ifTrue:	[	pT := pSet inject: 0 into: [ :x : y | x + y tally ].					pS := pSet inject: 0 into: [ :x :y | x + y samples ].					tT := targetMT tally.					tS := targetMT samples.					( ( pT &gt; tT ) and: [ ( ( pT - tT ) / pT ) &gt; 0.001 ] )					ifTrue:	[ 	targetMT tally: pT; samples: pS.								cF := ( copyMT copy )										name: (#primitives &lt;&lt; #advanced &gt;&gt; 'primitives') asString;										parent: targetMT;										tally: pT - tT;										samples: pS - tS;										yourself.								cSet add: cF.								targetMT receivers at: cF method put: cF.							]				].	"VI.  Organize output and return."	aCollection addAll: pSet asSortedCollection.	aCollection add: targetMT.	aCollection addAll: targetMT receivers values asSortedCollection.	^targetMT</body><body package="AT Profiling UI">labelForTally: aMessageTally	| index focus |	focus := self detailsList list identityIndexOf: tally.	index := self detailsList list identityIndexOf: aMessageTally.	^index &lt; focus		ifTrue: [Label with: aMessageTally printString]		ifFalse: 			[index &gt; focus				ifTrue: [Label with: aMessageTally printString offset: 48 @ 0]				ifFalse: [Label with: aMessageTally printString asText allBold offset: 24 @ 0]]</body></methods><methods><class-id>DetailsProfilePage</class-id> <category>actions</category><body package="AT Profiling UI">browseClass	self detailsList selectionDo: 			[:selection |			SmalltalkWorkbench				browseClass: (MessageTallyDefinition new tally: selection)						implementingClass instanceBehavior]</body><body package="AT Profiling UI">browseImplementors	self detailsList		selectionDo: [:selection | MethodCollector new browseAllImplementorsOf: selection selector]</body><body package="AT Profiling UI">browseMessages	| mc sel |	mc := MethodCollector new.	mc interfaceWindow: builder window.	sel := mc		showMenu: self detailsList selection method allSymbolLiterals asSortedCollection		prompt: (#FindAllImplementorsOf &lt;&lt; #advanced &gt;&gt; 'Find all implementors of...').	sel == nil ifTrue: [^self].	mc browseAllImplementorsOf: sel</body><body package="AT Profiling UI">browseSenders	self detailsList		selectionDo: [:selection | MethodCollector new browseAllReferencesTo: selection selector]</body><body package="AT Profiling UI">spawnCurrent	ProfileDetailBrowser openOnTally: self selectedMessageTally</body></methods><methods><class-id>DetailsProfilePage</class-id> <category>accessing</category><body package="AT Profiling UI">selectedMessageTally	self detailsList selectionDo: 			[:selection |			^root detect: [:any | any method = selection method] ifNone: nil].	^nil</body><body package="AT Profiling UI">tally	^tally</body></methods><methods><class-id>DetailsProfilePage</class-id> <category>aspects</category><body package="AT Profiling UI">browseTally: aMessageTally	self detailsList list: List new.	tally := self integrateTalliesForNode: aMessageTally intoCollection: self detailsList list.</body><body package="AT Profiling UI">detailsList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^detailsList isNil		ifTrue:			[detailsList := SelectionInList new]		ifFalse:			[detailsList]</body></methods><methods><class-id>DetailsProfilePage</class-id> <category>testing</category><body package="AT Profiling UI">enableSpawn	^self selectedMessageTally notNil</body></methods><methods><class-id>ProfilePage</class-id> <category>accessing</category><body package="AT Profiling UI">cutoff 	^cutoffHolder value</body><body package="AT Profiling UI">cutoffValue 	^(profiler tally * self cutoff) rounded</body><body package="AT Profiling UI">label	^label</body><body package="AT Profiling UI">profiler	^profiler</body></methods><methods><class-id>ProfilePage</class-id> <category>reports</category><body package="AT Profiling UI">reportOn: aStream	self subclassResponsibility</body></methods><methods><class-id>ProfilePage</class-id> <category>updating</category><body package="AT Profiling UI">updateReport	"Subclasses will reimplement this notification if they choose to"</body></methods><methods><class-id>ProfilePage</class-id> <category>initialize-release</category><body package="AT Profiling UI"> profiler: aProfiler cutoffHolder: aValueHolder label: reportString 	profiler := aProfiler.	cutoffHolder := aValueHolder.	label := reportString.	self updateReport.</body></methods><methods><class-id>ProfilePage class</class-id> <category>instance creation</category><body package="AT Profiling UI">on: aProfiler cutoffHolder: aValueHolder label: labelString 	^self new		profiler: aProfiler		cutoffHolder: aValueHolder		label: labelString</body></methods><methods><class-id>ProfilePage class</class-id> <category>interface specs</category><body package="AT Profiling UI">windowSpec	self subclassResponsibility</body></methods><methods><class-id>ProfileDetailBrowser</class-id> <category>private accessing</category><body package="AT Profiling UI">activeTool	^self codeBrowser</body><body package="AT Profiling UI">currentToolset	^self</body><body package="AT Profiling UI">definition	^self selectedCode ifNotNil: [:method | [method definition] on: MessageNotUnderstood do:[:ex| nil]]</body><body package="AT Profiling UI">isReadOnly	^self codeBrowser selector = #unboundMethod</body><body package="AT Profiling UI">methodClass	self detailsList selectionDo: [:selection | ^selection method mclass].	^nil</body><body package="AT Profiling UI">navigator	^navigator		ifNil: 			[navigator := Refactory.Browser.BrowserNavigator new						environment: Refactory.Browser.BrowserEnvironment new.			navigator dispatcher browser: self.			navigator]</body><body package="AT Profiling UI">packages	^Array with: self codeBrowser methodPackage</body><body package="AT Profiling UI">protocols	^self selectedCode		ifNil: [#()]		ifNotNil: 			[:method |			Array with: ([method protocol] on: MessageNotUnderstood do: [:ex | nil])]</body><body package="AT Profiling UI">selectedClass 	 ^self methodClass</body><body package="AT Profiling UI">selectedCode	self detailsList selectionDo: [:selection | ^selection method].	^nil</body><body package="AT Profiling UI">selector	self detailsList selectionDo: [:selection | ^selection selector].	^nil</body><body package="AT Profiling UI">selectors	^Array with: self selector</body><body package="AT Profiling UI">setSelector: aSelector	"I do nothing"</body><body package="AT Profiling UI">tool	^self</body></methods><methods><class-id>ProfileDetailBrowser</class-id> <category>accessing</category><body package="AT Profiling UI">codeBrowser	^codeBrowser isNil		ifTrue:			[codeBrowser := Refactory.Browser.ProfilerCodeTool codeModel: self]		ifFalse:			[codeBrowser]</body><body package="AT Profiling UI">detailsList	^self profileList detailsList</body><body package="AT Profiling UI">profileList	^profileList isNil		ifTrue:			[profileList := DetailsProfilePage new]		ifFalse:			[profileList]</body></methods><methods><class-id>ProfileDetailBrowser</class-id> <category>interface opening</category><body package="AT Profiling UI">postOpenWith: aBuilder	super postOpenWith: aBuilder.	self profileList addDependent: self codeBrowser.	aBuilder window label: self profileList tally printString</body></methods><methods><class-id>ProfileDetailBrowser</class-id> <category>initialize-release</category><body package="AT Profiling UI">release	self detailsList selectionIndexHolder retractAllInterestsFor: self codeBrowser.	super release</body><body package="AT Profiling UI">tally: aMessageTally	| detailsList |	self profileList addDependent: self codeBrowser.	self profileList browseTally: aMessageTally.	detailsList := self detailsList.	detailsList selectionIndexHolder onChangeSend: #updateContents		to: self codeBrowser.	detailsList selection: aMessageTally</body></methods><methods><class-id>ProfileDetailBrowser class</class-id> <category>instance creation</category><body package="AT Profiling UI">openOnTally: aMessageTally 	^(self new tally: aMessageTally) open</body></methods><methods><class-id>TotalsProfilePage</class-id> <category>reports</category><body package="AT Profiling UI">reportOn: aStream	aStream		cr;		nextPutAll: (#asterisks1s &lt;&lt; #advanced &gt;&gt; '** &lt;1s&gt; **'					expandMacrosWith: label);		cr.	self totalsList list do: 			[:each |			aStream				print: each;				cr]</body></methods><methods><class-id>TotalsProfilePage</class-id> <category>aspects</category><body package="AT Profiling UI">totalsList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^totalsList isNil		ifTrue:			[totalsList := SelectionInList new]		ifFalse:			[totalsList]</body></methods><methods><class-id>TotalsProfilePage</class-id> <category>updating</category><body package="AT Profiling UI">updateReport	| flatSummary limit |	flatSummary := Set new: 128.	profiler core rootTally addLocalUsageInto: flatSummary.	limit := self cutoffValue.	self totalsList list: ( flatSummary select: [:node | node tally &gt; limit] ) asSortedCollection asList</body></methods><methods><class-id>TotalsProfilePage</class-id> <category>actions</category><body package="AT Profiling UI">browseClass	self totalsList selectionDo: 			[:selection |			SmalltalkWorkbench				browseClass: (MessageTallyDefinition new tally: selection)						implementingClass instanceBehavior]</body><body package="AT Profiling UI">browseImplementors	MethodCollector new		browseAllImplementorsOf: self totalsList selection selector</body><body package="AT Profiling UI">browseMessages	| mc sel |	mc := MethodCollector new.	mc interfaceWindow: builder window.	sel := mc		showMenu: self totalsList selection value method allSymbolLiterals asSortedCollection		prompt: (#FindAllImplementorsOf &lt;&lt; #advanced &gt;&gt; 'Find all implementors of...').	sel == nil ifTrue: [^self].	mc browseAllImplementorsOf: sel</body><body package="AT Profiling UI">browseSenders	MethodCollector new browseAllReferencesTo: self totalsList selection selector</body><body package="AT Profiling UI">spawnCurrent	self totalsList selectionDo: 			[:selection |			ProfileDetailBrowser openOnTally: selection]</body></methods><methods><class-id>Tools.Profiler</class-id> <category>accessing</category><body package="AT Profiling UI">core	^core</body><body package="AT Profiling UI">howMany	"... added for backward compatibility in the public api."	^self samplingInterval</body><body package="AT Profiling UI">maxSamplingInterval	"Answer an appropriate upper bound for sampleSize"	^core maxSamplingInterval</body><body package="AT Profiling UI">sampleUnitName	"Answer a string describing what units of measure the receiver uses to measure resources. For example, TimeProfilers measure 'milliseconds', and AllocationProfilers measure 'bytes'."	^self subclassResponsibility</body><body package="AT Profiling UI">samplingInterval	"Answer the amount that will trigger a sample of the execution, in appropriate units"	^samplingIntervalAdaptor value</body><body package="AT Profiling UI">tally	^core tally</body></methods><methods><class-id>Tools.Profiler</class-id> <category>reporting</category><body package="AT Profiling UI">reportOn: aStream cutoffPercent: percent	"Write a profile report on the supplied stream."	core tally = 0		ifTrue:	[	aStream nextPutAll: (#noSamples &lt;&lt; #advanced &gt;&gt; 'no samples') asString				]		ifFalse:	[	self reportTotalsOn: aStream.					aStream cr; cr.					core rootTally fullPrintOn: aStream cutoff: percent				]</body><body package="AT Profiling UI">reportTotalsOn: aStream	"Report total samples and amount of resource consumed onto the supplied stream."	self subclassResponsibility</body><body package="AT Profiling UI">totalsReport	| stream |	stream := ( String new: 256 ) writeStream.	self reportTotalsOn: stream.	^stream contents</body></methods><methods><class-id>Tools.Profiler</class-id> <category>aspects</category><body package="AT Profiling UI">samplingIntervalAdaptor	^samplingIntervalAdaptor</body><body package="AT Profiling UI">textModel	^( textModel isNil )		ifTrue:	[ textModel := String new asValue ]		ifFalse:	[ textModel ]</body></methods><methods><class-id>Tools.Profiler</class-id> <category>initialize-release</category><body package="AT Profiling UI">initialize	super initialize.	core := self class coreClass new.	samplingIntervalAdaptor := ( PluggableAdaptor on: core )							getBlock:	[:m | m samplingInterval ] 							putBlock: [:m :v | m samplingInterval: v ]							updateBlock: [:m :a :p | true ].	textModel := ( EvaluationHolder new ) object: self</body><body package="AT Profiling UI">release	super release.	core release</body></methods><methods><class-id>Tools.Profiler</class-id> <category>public api</category><body package="AT Profiling UI">howMany: amount	"... added for backward compatibility in the public api."	self samplingInterval: amount</body><body package="AT Profiling UI">profile: aBlock	^self profile: aBlock onExitDo: self class defaultExitBlock</body><body package="AT Profiling UI">profile: aBlock onExitDo: exitBlock	self reinitializeCore.	self core targetBlock: aBlock.	self core 		coreStart: self		onExitDo: exitBlock.	^aBlock		ensure: [ self class stopProfiling ]</body><body package="AT Profiling UI">profile: theBlock reportTo: filename	^self 		profile: theBlock 		onExitDo: ( self class defaultFileBlock: filename )</body><body package="AT Profiling UI">reinitializeCore	| samplingInterval |	samplingInterval := self samplingInterval. 	core  		stopWatching;  		initialize; 		samplingInterval: samplingInterval</body><body package="AT Profiling UI">samplingInterval: anInteger	"Set the amount of resource to be consumed before sampling."	samplingIntervalAdaptor value: anInteger</body><body package="AT Profiling UI">stopProfiling	self class stopProfiling</body></methods><methods><class-id>Tools.Profiler</class-id> <category>private</category><body package="AT Profiling UI">accept	"Be a good model for dialog views"</body><body package="AT Profiling UI">pagesMenu	^self class pagesMenu</body></methods><methods><class-id>Tools.Profiler</class-id> <category>interface opening</category><body package="AT Profiling UI">labelFor: aKey	( aKey == #sampleUnitName )		ifTrue:	[ ^self sampleUnitName ].	( aKey == #maxSamplingInterval )		ifTrue: [ ^self maxSamplingInterval printString ].	^nil</body><body package="AT Profiling UI">postBuildWith: aBuilder	"Alter the performer in the text window to be the controller."	| textModelController |	super postBuildWith: aBuilder.	( aBuilder componentAt: #sampleSizeSlider) widget 		rangeMap:	( RangeMap						start: 1						stop: self maxSamplingInterval						grid: 1).	aBuilder window label: ((#Profile1s &lt;&lt; #advanced &gt;&gt; 'Profile &lt;1s&gt;')			expandMacrosWith: core description).	textModelController := ( aBuilder componentAt: #textModel ) widget controller.	textModelController performer: textModelController</body></methods><methods><class-id>Tools.Profiler class</class-id> <category>collaborator access</category><body package="AT Profiling UI">activeProfilerCore	^self coreClass activeProfilerCore</body><body package="AT Profiling UI">coreClass	self subclassResponsibility</body></methods><methods><class-id>Tools.Profiler class</class-id> <category>testing</category><body package="AT Profiling UI">needsSafeRebinding	^true</body></methods><methods><class-id>Tools.Profiler class</class-id> <category>parcel load/unload/save</category><body package="AT Profiling UI">preUnloadFor: aParcel	"Close any open applications implemented by this parcel."	ApplicationModel checkUnloadOfApplicationsDefinedBy: aParcel</body></methods><methods><class-id>Tools.Profiler class</class-id> <category>abstract resources</category><body package="AT Profiling UI">textModelMenu	^Menu new		addPart: ParagraphEditor editGroup;		addPart: ParagraphEditor evaluateGroup;		addPart: ParagraphEditor hardcopyGroup;		yourself</body></methods><methods><class-id>Tools.Profiler class</class-id> <category>instance creation</category><body package="AT Profiling UI">new	"Answer a new Profiler, properly initialized.  Catch the simple error of using the abstract class."	( self == Profiler )		ifTrue: [ ^self error: (#ProfilerIsAnAbstractClassUseAConcreteSubclass &lt;&lt; #advanced &gt;&gt; 'Profiler is an abstract class.  Use a concrete subclass.') ].	^super new</body><body package="AT Profiling UI">on: aBlock	"Answer a new Profiler, ready to spy on the supplied block."	| n |	n := self new.	n core targetBlock: aBlock.	^n</body></methods><methods><class-id>Tools.Profiler class</class-id> <category>public api</category><body package="AT Profiling UI">defaultExitBlock	^[ :spy | ProfileBrowser				openOutlineBrowserOn: spy 				label: ((#x1sProfile &lt;&lt; #advanced &gt;&gt; '&lt;1s&gt; profile')			expandMacrosWith: spy core description)	]</body><body package="AT Profiling UI">defaultFileBlock: aFilename	^[ :spy |	| fs |			fs := aFilename writeStream.			[	fs timeStamp; cr.				spy 					reportOn: fs 					cutoffPercent: 1			] ensure: [ fs close ]	]</body><body package="AT Profiling UI">profile: theBlock	"Set a block up for profiling and open a ProfileOutlineBrowser containing the report.  Do not use this method to invoke 'multi' profilers."	"((( AllocationProfiler profile: [ 10 timesRepeat: [ ScheduledControllers restore ] ] )))"	"((( TimeProfiler profile: [ 10 timesRepeat: [ ScheduledControllers restore ] ] )))"	^self		profile: theBlock 		onExitDo: self defaultExitBlock</body><body package="AT Profiling UI">profile: theBlock onExitDo: exitBlock	| profiler |	profiler :=  self on: theBlock.	profiler core		coreStart: profiler 		onExitDo: exitBlock.	^theBlock		ensure: [ self stopProfiling ]</body><body package="AT Profiling UI">profile: theBlock reportTo: aFilenameOrString	"Set a block up for profiling and write the report on the supplied file.  Answer the block's value."	"((( AllocationProfiler profile: [ 10 timesRepeat: [ 5000 factorial ] ] reportTo: 'factorial.rpt' asFilename )))"	"((( TimeProfiler profile: [ 10 timesRepeat: [ 5000 factorial ] ] reportTo: 'factorial.rpt' asFilename )))"	self 		profile: theBlock 		onExitDo: ( self defaultFileBlock: aFilenameOrString asFilename )</body><body package="AT Profiling UI">stopProfiling	self coreClass coreStopProfiling</body></methods><methods><class-id>Tools.Profiler class</class-id> <category>interface opening</category><body package="AT Profiling UI">basicText	^(#BasicText &lt;&lt; #advanced &gt;&gt; '"Profilers rely on a statistical sampling heuristic to estimate, rather than on instrumentation to directly measure, the resources consumed by a process.  A profiling run is adequate if it takes enough samples to produce estimates accurate enough to justify decision.  (The number of samples actually taken is the first item reported after a standard profiling run, in the upper left hand corner of the spawned ProfilerOutlineBrowser.)  The required number of samples required increases with the extent of the resources consumed by the profiled process, and with an increase in the degree of discrimination required.  You may increase the number of samples by either raising the number of repetitions or lowering the sampling interval.  If you wish to compare several alternative implementations, use the same number of repetitions and the same sampling interval in the profiling run of each.  You may increase the relative precision of sequentially executed, comparative runs by evaluating ''ObjectMemory globalGarbageCollect'' before each."') asString</body><body package="AT Profiling UI">demonstrationText: iterationCount	^(#DemonstrationText &lt;&lt; #advanced &gt;&gt; '"The three runs below profile alternative approaches to String construction.  Evaluate each test separately and compare the results."	"mere concatenation"	"((( self				samplingInterval: 3;			profile:	[ &lt;1p&gt; timesRepeat:						[ | str |  str := ''''. 256 timesRepeat: [ str := str, ''~'' ] ] ] )))"	"conventionally allocated WriteStream"	"((( self				samplingInterval: 3;			profile:	[ &lt;1p&gt; timesRepeat:						[ | str |  str := WriteStream on: ( String new ).								256 timesRepeat: [ str nextPut: $~ ] ] ] )))"	"WriteStream allocated with a decent estimate of the expected size"	"((( self				samplingInterval: 3;			profile:	[ &lt;1p&gt; timesRepeat:						[ | str |  str := WriteStream on: ( String new: 192 ).								256 timesRepeat: [ str nextPut: $~ ] ] ] )))"')		expandMacrosWithArguments: ( Array with: iterationCount )</body><body package="AT Profiling UI">multiText	^(#MultiText &lt;&lt; #advanced &gt;&gt; '"Profilers rely on a statistical sampling heuristic to estimate, rather than on instrumentation to directly measure, the resources consumed by a process.  In multi-profilers, the samples are distributed over several processes rather than one.  This fact should be kept in view when setting up multi-profiling runs or evaluating the reliability of their reports.  To exercise the &lt;1p&gt;, select and evaluate the following expressions, separately, and in order.  More than one test expression may be executed between the ''start'' and ''stop'' lines.  Alternatively, you may execute the "start" line to begin profiling processes already initiated, or the system in general.  Be sure always to execute a ''stopProfiling'' after a ''startProfiling*''.  Multi-profilers may generate vary large tally trees, with few processes consuming more than a fraction of a percent of the total resource usage, that it may take several minutes to display after you have lowered the cutoff percentage."')	expandMacrosWithArguments: ( Array with: self )</body><body package="AT Profiling UI">openViewWithText: aText	"... altered to answer a builder, like other interface opening methods."	| instance |	instance := self new.	instance textModel value: aText.	^[ self openOn: instance ]		on: GetWindowManagerUsagePolicy		do: [ :ex | ex resume: UseParentWindowManagerUsagePolicy new ]</body><body package="AT Profiling UI">templateText	^self subclassResponsibility</body></methods><methods><class-id>Tools.Profiler class</class-id> <category>accessing</category><body package="AT Profiling UI">showTemplates	^ShowTemplates</body><body package="AT Profiling UI">showTemplates: aBoolean	"((( self showTemplates: true )))"	"((( self showTemplates: false )))"	ShowTemplates := aBoolean</body></methods><methods><class-id>Tools.Profiler class</class-id> <category>class initialization</category><body package="AT Profiling UI">initialize	"Profiler initialize"	ShowTemplates := false.</body></methods><methods><class-id>Tools.AllocationProfiler</class-id> <category>reporting</category><body package="AT Profiling UI">bytesForClass: class basedOn: counts	| count vslots |	count := class isVariable ifTrue: [counts at: 1] ifFalse: [counts].	vslots := class isVariable ifTrue: [counts at: 2] ifFalse: [0].	^(( AllocationProfilerCore.ByteOverhead + (class instSize * 4)) * count) +				(class isBits ifTrue: [vslots] ifFalse: [vslots * 4]).</body><body package="AT Profiling UI">reportOn: aStream cutoffPercent: percent	"Write a profile report on the supplied stream."	| statistics |	super reportOn: aStream cutoffPercent: percent.	statistics := core statistics.	(statistics isNil or: [statistics isEmpty])		ifFalse: 			[aStream cr; cr.			self reportStatisticsOn: aStream]</body><body package="AT Profiling UI">reportStatisticsOn: aStream	"Write a statistics report on the supplied stream."	| statistics sc ptrInsts byInsts ptrSz bySz labelClass widthClass labelCount widthCount labelBytes widthBytes |	statistics := core statistics.	sc := SortedCollection sortBlock:				[:x :y |				(self bytesForClass: x key basedOn: x value)					&gt;= (self bytesForClass: y key basedOn: y value)].	statistics associationsDo: [:ass | sc add: ass].	labelClass := (#Class &lt;&lt; #advanced &gt;&gt; 'Class') asString copyWithout: Character space.	widthClass := labelClass size + 8.	labelCount := (#instances &lt;&lt; #advanced &gt;&gt; 'instances') asString.	widthCount := labelCount size + 4.	labelBytes := (#sizeBytes &lt;&lt; #advanced &gt;&gt; 'size (bytes)') asString.	widthBytes := labelBytes size + 4.	sc do:		[:elem |		| class count bytes |		class := elem key.		widthClass := widthClass max: class printString size + 4.		count := class isVariable ifTrue: [elem value at: 1] ifFalse: [elem value].		widthCount := widthCount max: count printString size + 4.		bytes := self bytesForClass: class basedOn: elem value.		widthBytes := widthBytes max: bytes printString size + 4].	aStream next: 2 put: Character space.	aStream nextPutAll: labelCount.	aStream		next: widthCount - aStream position + 2		put: Character space.	aStream nextPutAll: labelBytes.	aStream		next: widthCount + widthBytes - aStream position + 4		put: Character space.	aStream nextPutAll: labelClass.	aStream cr.	ptrInsts := byInsts := ptrSz := bySz := 0.	sc do:		[:elem |		| class count bytes lineStart |		lineStart := aStream position.		class := elem key.		count := class isVariable ifTrue: [elem value at: 1] ifFalse: [elem value].		bytes := self bytesForClass: class basedOn: elem value.		class isBits			ifTrue: [byInsts := byInsts + count. bySz := bySz + bytes]			ifFalse: [ptrInsts := ptrInsts + count. ptrSz := ptrSz + bytes].		count printOn: aStream paddedWith: Character space to: widthCount-2 base: 10.		aStream			next: lineStart + widthCount - aStream position			put: Character space.		bytes printOn: aStream paddedWith: Character space to: widthBytes-2 base: 10.		aStream			next: lineStart + widthCount + widthBytes + 2 - aStream position			put: Character space.		aStream nextPutAll: class printString.		aStream cr].	aStream crtab; nextPutAll: (#AllocationSummary &lt;&lt; #advanced &gt;&gt; '  Allocation summary:') asString; cr.	aStream nextPutAll: ((#x1pTotalObjectsAverageSize2pBytes &lt;&lt; #advanced &gt;&gt; '&lt;1p&gt; total objects, average size &lt;2p&gt; bytes.')			expandMacrosWith: byInsts + ptrInsts			with: ((bySz + ptrSz) asFloat / (byInsts + ptrInsts) roundTo: 0.1)); cr.	aStream nextPutAll: ((#x1pByteObjectsAverageSize2pBytes &lt;&lt; #advanced &gt;&gt; '&lt;1p&gt; byte objects, average size &lt;2p&gt; bytes.')			expandMacrosWith: byInsts			with: (bySz asFloat / (byInsts max: 1) roundTo: 0.1)); cr.	aStream nextPutAll: ((#x1pPointerObjectsAverageSize2pBytes &lt;&lt; #advanced &gt;&gt; '&lt;1p&gt; pointer objects, average size &lt;2p&gt; bytes.')			expandMacrosWith: ptrInsts			with: (ptrSz asFloat / (ptrInsts max: 1) roundTo: 0.1)); cr.	aStream cr</body><body package="AT Profiling UI">reportTotalsOn: aStream	"Report total samples and amount of resource consumed onto the supplied stream."	| samples totalBytes |	samples := core samples.	totalBytes := core totalBytes.	aStream nextPutAll: ((#AllocationProfilerTotals &lt;&lt; #advanced &gt;&gt; '&lt;1p&gt; samples, &lt;2p&gt; average bytes/sample, &lt;4p&gt; scavenges, &lt;5p&gt; incGCs, &lt;n&gt;&lt;6p&gt; stack spills, &lt;7p&gt; mark stack overflows, &lt;8p&gt; weak list overflows, &lt;9p&gt; JIT cache spills&lt;n&gt;&lt;3p&gt; bytes')			expandMacrosWithArguments:				((Array new: 9)					at: 1 put: samples;					at: 2 put: ( samples = 0 ifTrue: [0] ifFalse: [totalBytes // samples] );					at: 3 put: totalBytes;					at: 4 put: core scavenges;					at: 5 put: core incrementalGCs;					at: 6 put: core nativeStackSpills;					at: 7 put: core numMarkStackOverflows;					at: 8 put: core numWeakObjectListOverflows;					at: 9 put: core numCompactNMethods;					yourself))</body></methods><methods><class-id>Tools.AllocationProfiler</class-id> <category>public api</category><body package="AT Profiling UI">keepStatistics: aBoolean	core keepStatistics: aBoolean</body></methods><methods><class-id>Tools.AllocationProfiler</class-id> <category>accessing</category><body package="AT Profiling UI">sampleUnitName	^(#bytes &lt;&lt; #advanced &gt;&gt; 'bytes') asString</body></methods><methods><class-id>Tools.AllocationProfiler</class-id> <category>private</category><body package="AT Profiling UI">pagesMenu	| menu item |	menu := self class pagesMenu.	core keepStatistics		ifFalse: 			[item := menu menuItems detect: [:mi | mi value == #spaceUsage].			menu removeItem: item].	^menu</body></methods><methods><class-id>Tools.AllocationProfiler class</class-id> <category>collaborator access</category><body package="AT Profiling UI">coreClass	^AllocationProfilerCore</body></methods><methods><class-id>Tools.AllocationProfiler class</class-id> <category>public api</category><body package="AT Profiling UI">profile: theBlock	^self profile: theBlock withStatistics: false</body><body package="AT Profiling UI">profile: theBlock withStatistics: trueOrFalse	"Set a block up for profiling and open a workspace containing the report."	"((( AllocationProfiler profile: [ScheduledControllers restore] withStatistics: true )))"	| profiler |	profiler := self on: theBlock.	profiler core		coreStart: (profiler keepStatistics: trueOrFalse )		onExitDo:	[ :spy | ProfileBrowser 								openOutlineBrowserOn: spy 								label: ((#x1sProfile &lt;&lt; #advanced &gt;&gt; '&lt;1s&gt; profile')			expandMacrosWith: spy core description)					].	^theBlock		ensure: [ self stopProfiling ]</body></methods><methods><class-id>Tools.AllocationProfiler class</class-id> <category>interface opening</category><body package="AT Profiling UI">openView	"... altered to answer a builder, like other interface opening methods."	"((( AllocationProfiler openView )))"	| txt bldr |	txt := ( self showTemplates )			ifTrue:	[ self templateText ]			ifFalse:	[ self basicText, ( self demonstrationText: 1000 ) ].	bldr := self openViewWithText: txt.	^bldr</body><body package="AT Profiling UI">templateText	^'	"(((	self 			profile:	[ ((anIntegerR)) timesRepeat:							[ ((anExpression)) ] ] )))"	"(((	self 			profile:	[ ((anIntegerR)) timesRepeat:							[ ((anExpression)) ] ]			reportTo: ((aFilename)) )))"	"(((	self			keepStatistics: ((aBoolean));			profile:	[ ((anIntegerR)) timesRepeat:							[ ((anExpression)) ] ]  )))"	"(((	( self 			keepStatistics: ((aBoolean));			samplingInterval: ((anIntegerS));			yourself )				profile:	[ ((anIntegerR)) timesRepeat:							[ ((anExpression)) ] ] 				onExitDo: ((aBlock)) )))"'</body></methods><methods><class-id>Tools.MultiAllocationProfiler</class-id> <category>public api</category><body package="AT Profiling UI">profile: aBlock	^self shouldNotImplement</body><body package="AT Profiling UI">profile: aBlock onExitDo: exitBlock	^self shouldNotImplement</body><body package="AT Profiling UI">profile: theBlock reportTo: filename	^self shouldNotImplement</body><body package="AT Profiling UI">startProfiling	^self startProfilingWithStatistics: false</body><body package="AT Profiling UI">startProfilingReportTo: aFilename	^self		startProfilingWithStatistics: true		onExitDo: ( self class defaultFileBlock: aFilename )</body><body package="AT Profiling UI">startProfilingWithStatistics: trueOrFalse	^self		startProfilingWithStatistics: trueOrFalse 		onExitDo: self class defaultExitBlock</body><body package="AT Profiling UI">startProfilingWithStatistics: trueOrFalse onExitDo: exitBlock	self reinitializeCore.	^self core		coreStart: ( self keepStatistics: trueOrFalse ) 		onExitDo: exitBlock</body></methods><methods><class-id>Tools.MultiAllocationProfiler class</class-id> <category>collaborator access</category><body package="AT Profiling UI">coreClass	^MultiAllocationProfilerCore</body></methods><methods><class-id>Tools.MultiAllocationProfiler class</class-id> <category>public api</category><body package="AT Profiling UI">profile: theBlock	^self shouldNotImplement</body><body package="AT Profiling UI">profile: theBlock onExitDo: exitBlock	^self shouldNotImplement</body><body package="AT Profiling UI">profile: theBlock reportTo: filename	^self shouldNotImplement</body><body package="AT Profiling UI">startProfiling	"Start profiling all processes. When watcher is terminated, open a workspace containing the report."	"... evaluate the following expressions in order."	"The middle expression can be any that uses up some space."	"((( MultiAllocationProfiler startProfiling )))"	"((( 3 timesRepeat: [ [ ScheduledControllers restore ] fork ] )))"	"((( MultiAllocationProfiler stopProfiling )))"	^self startProfilingWithStatistics: false</body><body package="AT Profiling UI">startProfilingWithStatistics: trueOrFalse	"Start profiling all processes. When watcher is terminated, open a workspace containing the report."	"... evaluate the following expressions in order."	"The middle expression can be any that uses up some space."	"((( MultiAllocationProfiler startProfilingWithStatistics: true )))"	"((( 3 timesRepeat: [ [ ScheduledControllers restore ] fork ] )))"	"((( MultiAllocationProfiler stopProfiling )))"	^self 		startProfilingWithStatistics: trueOrFalse 		onExitDo: self defaultExitBlock</body><body package="AT Profiling UI">startProfilingWithStatistics: trueOrFalse onExitDo: exitBlock	"... evaluate the following expressions in order."	"The middle expression can be any that uses up some space."	"((( MultiAllocationProfiler		startProfilingWithStatistics: true 		onExitDo: [:spy |	| fs |							fs := 'ui.report' asFilename writeStream.							[	fs timeStamp; cr.								spy reportOn: fs cutoffPercent: 1							] ensure: [ fs close ] ] )))"	"((( 3 timesRepeat: [ [ ScheduledControllers restore ] fork ] )))"	"((( MultiAllocationProfiler stopProfiling )))"	| profiler |	profiler :=  self new keepStatistics: trueOrFalse.	^profiler core		coreStart: profiler		onExitDo: exitBlock</body></methods><methods><class-id>Tools.MultiAllocationProfiler class</class-id> <category>interface opening</category><body package="AT Profiling UI">openView	"... altered to answer a builder, like other interface opening methods."	"((( MultiAllocationProfiler openView )))"	| txt bldr |	txt := ( self showTemplates )			ifTrue:	[ self templateText ]			ifFalse:	[ self multiText,'	"((( self startProfilingWithStatistics: true )))"	"((( 20 timesRepeat:					[ [	| s r |						s := SortedCollection new: 0.						r := Random new.						256 timesRepeat: [ s add: ( r next * 1000 ) truncated ] ] fork ] )))"	"((( self stopProfiling )))"'].	bldr := self openViewWithText: txt.	^bldr</body><body package="AT Profiling UI">templateText	^'	"(((	self startProfiling )))"		"((( ((anIntegerR)) timesRepeat: [ ((anExpression)) ] )))"	"((( self stopProfiling )))"	"(((	self startProfilingReportTo: ((aFilename)) )))"		"((( ((anIntegerR)) timesRepeat: [ ((anExpression)) ] )))"	"((( self stopProfiling )))"	"(((	self 			keepStatistics: ((aBoolean));			samplingInterval: ((anIntegerS));			startProfilingOnExitDo: ((aBlock)) )))"		"((( ((anIntegerR)) timesRepeat: [ ((anExpression)) ] )))"	"((( self stopProfiling )))"'</body></methods><methods><class-id>SpaceProfilePage</class-id> <category>aspects</category><body package="AT Profiling UI">usageReport	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^usageReport isNil		ifTrue:			[usageReport := String new asValue]		ifFalse:			[usageReport]</body></methods><methods><class-id>SpaceProfilePage</class-id> <category>reports</category><body package="AT Profiling UI">reportOn: aStream	aStream		cr;		nextPutAll: (#asterisks1s &lt;&lt; #advanced &gt;&gt; '** &lt;1s&gt; **'					expandMacrosWith: label);		cr.	aStream nextPutAll: self usageReport value.</body></methods><methods><class-id>SpaceProfilePage</class-id> <category>updating</category><body package="AT Profiling UI">updateReport	profiler core statistics		ifNotNil: 			[ | reportStream report style1 style2 lineStart nextStart cIndex |			reportStream := String new writeStream.			profiler reportStatisticsOn: reportStream.			style1 := Refactory.Browser.SourceCodeEditor defaultTheme default.			style2 := style1 copy.			style2 fontDescription: (style2 fontDescription copy					family: #('cour*' '*fixed*' '*')).			report := Text2.Document fromString: reportStream contents style: style1.			lineStart := report nextIndexOf: Character cr from: 1 to: report size.			report replaceBetween: 1 and: lineStart-1 apply: [style2].			[nextStart := report nextIndexOf: Character cr from: lineStart+1 to: report size.			nextStart - lineStart = 1]				whileFalse:					[cIndex := report						findFirst: [:c | c isSeparator not and: [c isDigit not]]						startingAt: lineStart + 1.					report replaceBetween: lineStart+1 and: cIndex-1 apply: [style2].					lineStart := nextStart].			self usageReport value: report]</body></methods><methods><class-id>Refactory.Browser.ProfilerCodeTool</class-id> <category>probes</category><body package="AT Profiling UI">areProbeCommandsLegal	^super areProbeCommandsLegal and:[ self isReadOnly not]</body><body package="AT Profiling UI">selectedMethod	^self methodClass compiledMethodAt: self selector ifAbsent: [CompiledCode new]</body></methods><methods><class-id>Refactory.Browser.ProfilerCodeTool</class-id> <category>updating</category><body package="AT Profiling UI">isReadOnly: aBoolean	(self widgetAt: #textEditor)		ifNotNil: 			[:textEditor |			aBoolean				ifTrue: [textEditor beReadOnly]				ifFalse: [textEditor controller readOnly: false]]</body><body package="AT Profiling UI">updateContents	self selector = #unboundMethod		ifTrue: 			[| compiledMethod source text |			self isReadOnly: true.			compiledMethod := codeModel selectedCode ifNil: [^self text: ''].			source := compiledMethod getSource.			text := self formatSource: source for: compiledMethod.			^self text: text].	self isReadOnly: false.	self selector isSymbol		ifFalse: 			[modified := false.			self updateTextWidget.			^self text: ''].	super updateContents</body></methods><methods><class-id>Refactory.Browser.ProfilerCodeTool</class-id> <category>testing</category><body package="AT Profiling UI">isReadOnly	^(self widgetAt: #textEditor)		ifNil: [false]		ifNotNil: [:textEditor | textEditor controller readOnly]</body></methods><methods><class-id>ProfileBrowser</class-id> <category>actions</category><body package="AT Profiling UI">acceptCutoff	"Invoked by the 'apply cutoff' button, to cause the list to be recomputed.  Flush the findNext menu at the same time."	pages do:[:each| each updateReport] .</body><body package="AT Profiling UI">spawnTextReport	"Transform the profiler's report into textual form so that it can be edited"		| stream textView topView |	stream := TextStream on: String new.	profiler reportTotalsOn: stream.	stream cr.	pages do:[:page| page reportOn: stream].	textView := ComposedTextView model: (ValueHolder with: stream contents).	textView displayObject textStyle: (TextAttributes styleNamed: #fixed).	topView := ScheduledWindow new.	topView controller model: textView model.	topView component: (LookPreferences edgeDecorator on: textView).	topView		label:			(#x1sProfile &lt;&lt; #advanced &gt;&gt; '&lt;1s&gt; profile'				expandMacrosWith: profiler core description).	topView minimumSize: 200 @ 150.	topView open</body></methods><methods><class-id>ProfileBrowser</class-id> <category>tab pages</category><body package="AT Profiling UI">priorityTree	^TreeProfilePage on: profiler cutoffHolder: cutoff label: #priorityTree &lt;&lt; #advanced &gt;&gt; 'Priority Tree' root: profiler core priorityTally</body><body package="AT Profiling UI">profileTree	^TreeProfilePage on: profiler cutoffHolder: cutoff label: #tree &lt;&lt; #advanced &gt;&gt; 'Tree' root: profiler core rootTally</body><body package="AT Profiling UI">spaceUsage	^SpaceProfilePage on: profiler cutoffHolder: cutoff label: #spaceUsage &lt;&lt; #advanced &gt;&gt; 'Space Usage'</body><body package="AT Profiling UI">totals	^TotalsProfilePage on: profiler cutoffHolder: cutoff label: #totals &lt;&lt; #advanced &gt;&gt; 'Totals'</body></methods><methods><class-id>ProfileBrowser</class-id> <category>aspects</category><body package="AT Profiling UI">cutoff	^cutoff</body><body package="AT Profiling UI">profileTabList	^profileTabList</body><body package="AT Profiling UI">totalsReport	^totalsReport</body></methods><methods><class-id>ProfileBrowser</class-id> <category>notification</category><body package="AT Profiling UI">tabChanged	(self builder componentAt: #tabControl)		ifNotNil: 			[:wrapper |			wrapper widget				client: (pages at: profileTabList selectionIndex)				spec: #windowSpec]</body></methods><methods><class-id>ProfileBrowser</class-id> <category>interface opening</category><body package="AT Profiling UI">postOpenWith: aBuilder	super postOpenWith: aBuilder.	self profileTabList selectionIndex: 1.	self tabChanged</body></methods><methods><class-id>ProfileBrowser</class-id> <category>initialize-release</category><body package="AT Profiling UI">initialize	super initialize.	profileTabList := SelectionInList new.	cutoff := ( 2 /100 ) asValue.	totalsReport := String new asValue</body><body package="AT Profiling UI">on: aProfiler	"Set the receiver's tree to be aTree."	| pagesMenu |	profiler := aProfiler.	self totalsReport value: aProfiler totalsReport.	pagesMenu := aProfiler pagesMenu. 	self profileTabList list: pagesMenu  labels asList.	pages := pagesMenu menuItems collect:[:each| self perform: each value ].</body></methods><methods><class-id>ProfileBrowser class</class-id> <category>interface opening</category><body package="AT Profiling UI">openOutlineBrowserOn: aProfiler label: aString	"The opening interface for this browser has a different protocol than the usual ApplicationModel as part of its history.  ... altered to answer a builder, like other interface opening methods"	| bldr window |	bldr := (self new on: aProfiler) open.	window := bldr window.	window label: aString.	^bldr</body></methods><methods><class-id>UI.TallyWrapper</class-id> <category>accessing</category><body package="AT Profiling UI">children	^children		ifNil: 			[children := (messageTally childrenOver: cutoff)						collect: [:each | TallyWrapper on: each cutoff: cutoff]]</body><body package="AT Profiling UI">cutoff	^cutoff</body><body package="AT Profiling UI">parent		^messageTally parent ifNotNil:[:parent | TallyWrapper on: parent cutoff: cutoff]</body><body package="AT Profiling UI">value	^messageTally</body></methods><methods><class-id>UI.TallyWrapper</class-id> <category>comparing</category><body package="AT Profiling UI">= aTallyWrapper	^self class = aTallyWrapper class and: 			[cutoff = aTallyWrapper cutoff and: 					[messageTally = aTallyWrapper value						and: [self children = aTallyWrapper children]]]</body><body package="AT Profiling UI">hash	^(cutoff hash bitXor: messageTally hash) bitXor: children hash</body></methods><methods><class-id>UI.TallyWrapper</class-id> <category>printing</category><body package="AT Profiling UI">indentation	^String new: 2 * self level withAll: Character space</body><body package="AT Profiling UI">level	^self parent ifNil: [0] ifNotNil: [self parent level + 1]</body><body package="AT Profiling UI">printString	^messageTally printString</body></methods><methods><class-id>UI.TallyWrapper</class-id> <category>initialize-release</category><body package="AT Profiling UI">messageTally: aMessageTally cutoff: aNumber	messageTally := aMessageTally.	cutoff := aNumber</body></methods><methods><class-id>UI.TallyWrapper class</class-id> <category>instance creation</category><body package="AT Profiling UI">on: aMessageTally cutoff: aNumber	^self new messageTally: aMessageTally cutoff: aNumber</body></methods><methods><class-id>Tools.TimeProfiler</class-id> <category>accessing</category><body package="AT Profiling UI">sampleUnitName	^(#milliseconds &lt;&lt; #advanced &gt;&gt; 'milliseconds') asString</body></methods><methods><class-id>Tools.TimeProfiler</class-id> <category>reporting</category><body package="AT Profiling UI">reportTotalsOn: aStream	"Report total samples and amount of resource consumed onto the supplied stream."	| samples processTime totalTime otherProcessesTime |	totalTime := core totalTime.	processTime := core processTime.	samples := core samples.	otherProcessesTime := core otherProcessesTime.	aStream nextPutAll: ((#TimeProfilerTotals &lt;&lt; #advanced &gt;&gt; '&lt;1p&gt; samples, &lt;2p&gt; average ms/sample, &lt;7p&gt; scavenges, &lt;8p&gt; incGCs, &lt;n&gt;&lt;9p&gt; stack spills, &lt;10p&gt; mark stack overflows, &lt;11p&gt; weak list overflows, &lt;12p&gt; JIT cache spills&lt;n&gt;&lt;4p&gt;s active, &lt;5p&gt;s other processes,&lt;n&gt;&lt;3p&gt;s real time, &lt;6p&gt;s profiling overhead')			expandMacrosWithArguments:		((Array new: 12)			at: 1 put: samples;			at: 2 put: ( samples = 0 ifTrue: [0] ifFalse: [ ( totalTime // samples / 10 ) rounded / 100.0 ] );			at: 3 put: ( totalTime / 10000 ) rounded / 100.0;			at: 4 put: ( processTime / 10000 ) rounded / 100.0;			at: 5 put: ( otherProcessesTime / 10000 ) rounded / 100.0;			at: 6 put: ( ( totalTime - processTime - otherProcessesTime ) / 10000 ) rounded / 100.0;			at: 7 put: core scavenges;			at: 8 put: core incrementalGCs;			at: 9 put: core nativeStackSpills;			at: 10 put: core numMarkStackOverflows;			at: 11 put: core numWeakObjectListOverflows;			at: 12 put: core numCompactNMethods;			yourself))</body></methods><methods><class-id>Tools.TimeProfiler class</class-id> <category>collaborator access</category><body package="AT Profiling UI">coreClass	^TimeProfilerCore</body></methods><methods><class-id>Tools.TimeProfiler class</class-id> <category>interface opening</category><body package="AT Profiling UI">openView	"... altered to answer a builder, like other interface opening methods."	"((( TimeProfiler openView )))"	| txt bldr |	txt := ( self showTemplates )			ifTrue:	[ self templateText ]			ifFalse:	[ self basicText, ( self demonstrationText: 9000 ) ].	bldr := self openViewWithText: txt.	^bldr</body><body package="AT Profiling UI">templateText	^'	"(((	self profile:	[ ((anIntegerR)) timesRepeat:							[ ((anExpression)) ] ] )))"	"(((	self 			profile:	[ ((anIntegerR)) timesRepeat:							[ ((anExpression)) ] ]			reportTo: ((aFilename)) )))"	"(((	( self 			samplingInterval: ((anIntegerS));			yourself )				profile:	[ ((anIntegerR)) timesRepeat:							[ ((anExpression)) ] ] 				onExitDo: ((aBlock)) )))"'</body></methods><methods><class-id>Tools.MultiTimeProfiler</class-id> <category>public api</category><body package="AT Profiling UI">profile: aBlock	^self shouldNotImplement</body><body package="AT Profiling UI">profile: aBlock onExitDo: exitBlock	^self shouldNotImplement</body><body package="AT Profiling UI">profile: theBlock reportTo: filename	^self shouldNotImplement</body><body package="AT Profiling UI">startProfiling	^self startProfilingOnExitDo: self class defaultExitBlock</body><body package="AT Profiling UI">startProfilingOnExitDo: exitBlock	self reinitializeCore.	^self core 		coreStart: self 		onExitDo: exitBlock</body><body package="AT Profiling UI">startProfilingReportTo: aFilename	^self startProfilingOnExitDo: ( self class defaultFileBlock: aFilename )</body></methods><methods><class-id>Tools.MultiTimeProfiler</class-id> <category>reporting</category><body package="AT Profiling UI">reportTotalsOn: aStream	"Report total samples and amount of resource consumed onto the supplied stream."	| samples processTime totalTime otherProcessesTime |	totalTime := core totalTime.	processTime := core processTime.	samples := core samples.	otherProcessesTime := core otherProcessesTime.	aStream nextPutAll: ((#MultiTimeProfilerTotals &lt;&lt; #advanced &gt;&gt; '&lt;1p&gt; samples, &lt;2p&gt; average ms/sample, &lt;7p&gt; scavenges, &lt;8p&gt; incGCs, &lt;n&gt;&lt;9p&gt; stack spills, &lt;10p&gt; mark stack overflows, &lt;11p&gt; weak list overflows, &lt;12p&gt; JIT cache spills&lt;n&gt;&lt;4p&gt;s active, &lt;5p&gt;s semaphore waits,&lt;n&gt;&lt;3p&gt;s real time, &lt;6p&gt;s profiling overhead')			expandMacrosWithArguments:		((Array new: 12)			at: 1 put: samples;			at: 2 put: ( samples = 0 ifTrue: [0] ifFalse: [ ( totalTime // samples / 10 ) rounded / 100.0 ] );			at: 3 put: ( totalTime / 10000 ) rounded / 100.0;			at: 4 put: ( processTime / 10000 ) rounded / 100.0;			at: 5 put: ( otherProcessesTime / 10000 ) rounded / 100.0;			at: 6 put: ( ( totalTime - processTime - otherProcessesTime ) / 10000 ) rounded / 100.0;			at: 7 put: core scavenges;			at: 8 put: core incrementalGCs;			at: 9 put: core nativeStackSpills;			at: 10 put: core numMarkStackOverflows;			at: 11 put: core numWeakObjectListOverflows;			at: 12 put: core numCompactNMethods;			yourself))</body></methods><methods><class-id>Tools.MultiTimeProfiler class</class-id> <category>collaborator access</category><body package="AT Profiling UI">coreClass	^MultiTimeProfilerCore</body></methods><methods><class-id>Tools.MultiTimeProfiler class</class-id> <category>public api</category><body package="AT Profiling UI">profile: theBlock	^self shouldNotImplement</body><body package="AT Profiling UI">profile: theBlock onExitDo: exitBlock	^self shouldNotImplement</body><body package="AT Profiling UI">profile: theBlock reportTo: filename	^self shouldNotImplement</body><body package="AT Profiling UI">startProfiling	"Start profiling all processes. When watcher is terminated, open a workspace containing the report."	"... evaluate the following expressions in order."	"The middle expression can be any that uses up some time."	"(((	MultiTimeProfiler startProfiling )))"	"((( 10 timesRepeat: [ [ 100 to: 1000 by: 100 do: [ :i | i factorial. Processor yield ] ] fork ] )))"	"((( MultiTimeProfiler stopProfiling )))"	^self startProfilingOnExitDo: self defaultExitBlock</body><body package="AT Profiling UI">startProfilingOnExitDo: exitBlock	"... evaluate the following expressions in order."	"The middle expression can be any that uses up some time."	"(((	MultiTimeProfiler startProfilingOnExitDo: 			[ :spy |	| fs |					fs := 'factorial.rpt' asFilename writeStream.					[	fs timeStamp; cr.						spy reportOn: fs cutoffPercent: 1					] ensure: [ fs close ]			] )))"	"((( 10 timesRepeat: [ [ 100 to: 1000 by: 100 do: [ :i | i factorial. Processor yield ] ] fork ] )))"	"((( MultiTimeProfiler stopProfiling )))"	| profiler |	profiler := self new.	^profiler core		coreStart: profiler		onExitDo: exitBlock</body><body package="AT Profiling UI">startProfilingReportTo: aFilename	"Start profiling all processes. When watcher is terminated, open a workspace containing the report."	"... evaluate the following expressions in order."	"The middle expression can be any that uses up some time."	"(((	MultiTimeProfiler startProfilingReportTo: 'factorial.rpt' )))"	"((( 10 timesRepeat: [ [ 100 to: 1000 by: 100 do: [ :i | i factorial. Processor yield ] ] fork ] )))"	"((( MultiTimeProfiler stopProfiling )))"	^self startProfilingOnExitDo: ( self defaultFileBlock: aFilename )</body></methods><methods><class-id>Tools.MultiTimeProfiler class</class-id> <category>interface opening</category><body package="AT Profiling UI">openView	"... altered to answer a builder, like other interface opening methods."	"((( MultiTimeProfiler openView )))"	| txt bldr |	txt := ( self showTemplates )			ifTrue:	[ self templateText ]			ifFalse:	[ self multiText, '	"((( self startProfiling )))"	"((( 10 timesRepeat: [ [ 100 to: 1000 by: 100 do: [ :i | i factorial. Processor yield ] ] fork ] )))"	"((( self stopProfiling )))"'].	bldr := self openViewWithText: txt.	^bldr</body><body package="AT Profiling UI">templateText	^'	"(((	self startProfiling )))"		"((( ((anIntegerR)) timesRepeat: [ ((anExpression)) ] )))"	"((( self stopProfiling )))"	"(((	self startProfilingReportTo: ((aFilename)) )))"		"((( ((anIntegerR)) timesRepeat: [ ((anExpression)) ] )))"	"((( self stopProfiling )))"	"(((	self 			samplingInterval: ((anIntegerS));			startProfilingOnExitDo: ((aBlock)) )))"		"((( ((anIntegerR)) timesRepeat: [ ((anExpression)) ] )))"	"((( self stopProfiling )))"'</body></methods><methods><class-id>TreeProfilePage</class-id> <category>initialize-release</category><body package="AT Profiling UI">profiler: aProfiler cutoffHolder: aValueHolder label: labelString root: aMessageTally	root := aMessageTally.	self profiler: aProfiler cutoffHolder: aValueHolder label: labelString.</body></methods><methods><class-id>TreeProfilePage</class-id> <category>accessing</category><body package="AT Profiling UI">root	^root</body></methods><methods><class-id>TreeProfilePage</class-id> <category>aspects</category><body package="AT Profiling UI">treeList	^treeList isNil		ifTrue:			[treeList := SelectionInTree new]		ifFalse:			[treeList]</body></methods><methods><class-id>TreeProfilePage</class-id> <category>updating</category><body package="AT Profiling UI">updateReport	root		ifNotNil: 			[self treeList tree				root: (TallyWrapper on: self root cutoff: self cutoffValue)				displayIt: true.			self treeList tree expandFully: 1.			findNextCache := allNodes := nil]</body></methods><methods><class-id>TreeProfilePage</class-id> <category>actions</category><body package="AT Profiling UI">browseImplementors	MethodCollector new		browseAllImplementorsOf: self treeList selection value selector</body><body package="AT Profiling UI">browseMessages	| mc sel |	mc := MethodCollector new.	mc interfaceWindow: builder window.	sel := mc		showMenu: self treeList selection value method allSymbolLiterals asSortedCollection		prompt: (#FindAllImplementorsOf &lt;&lt; #advanced &gt;&gt; 'Find all implementors of...').	sel == nil ifTrue: [^self].	mc browseAllImplementorsOf: sel</body><body package="AT Profiling UI">browseSenders	MethodCollector new browseAllReferencesTo: self treeList selection value selector</body><body package="AT Profiling UI">findNextMenu	"Prompt the user for the next selector to select." 	findNextCache isNil		ifTrue: 			[| selectorSet topmost |			topmost := self treeList tree root.			allNodes := (OrderedCollection with: topmost) , (self treeList tree allChildrenFor: topmost).			selectorSet := Set new: allNodes size.			allNodes do: [:each | selectorSet add: each value selector].			findNextCache := selectorSet asSortedCollection asArray].	(Dialog		choose: #SelectMethod &lt;&lt; #advanced &gt;&gt; 'Select method'		fromList: findNextCache		values: findNextCache		buttons: #()		values: #()		lines: (32 min: findNextCache size)		cancel: []		for: nil) ifNotNil: [:selector | self findNext: selector]</body><body package="AT Profiling UI">spawnCurrent	self treeList selectionDo: 			[:selection |			ProfileDetailBrowser openOnTally: selection value]</body></methods><methods><class-id>TreeProfilePage</class-id> <category>reports</category><body package="AT Profiling UI">reportOn: aStream	| reportRoot |	aStream		cr;		nextPutAll: (#asterisks1s &lt;&lt; #advanced &gt;&gt; '** &lt;1s&gt; **'					expandMacrosWith: label);		cr.	reportRoot := self treeList tree root.	aStream		nextPutAll: reportRoot printString;		cr.	(self treeList tree allChildrenFor: reportRoot) do: 			[:each |			aStream				nextPutAll: each indentation;				nextPutAll: each printString;				cr]</body></methods><methods><class-id>TreeProfilePage</class-id> <category>private</category><body package="AT Profiling UI">findNext: aSelector	"Select the next item in the list with the supplied selector."	| start limit |	start := (allNodes indexOf: self treeList selection) + 1.	limit := allNodes size.	start to: limit		do: 			[:i |			| node |			node := allNodes at: i.			node value selector == aSelector				ifTrue: [^self treeList tree expandFound: node]].	1 to: start - 1		do: 			[:i |			| node |			node := allNodes at: i.			node value selector == aSelector				ifTrue: [^self treeList tree expandFound: node]]</body></methods><methods><class-id>TreeProfilePage class</class-id> <category>instance creation</category><body package="AT Profiling UI">on: aProfiler cutoffHolder: aValueHolder label: labelString root: aMessageTally	^self new		profiler: aProfiler		cutoffHolder: aValueHolder		label: labelString		root: aMessageTally</body></methods><methods><class-id>Tools.ProfilerCore</class-id> <category>public api</category><body package="AT Profiling UI">coreStart: aProfiler onExitDo: exitBlock	self class coreStopProfiling.	MessageTally initializeCaches.	self installWrappers.	self class activeProfilerCore: self.	self profileOnExitDo:					[	self class activeProfilerCore: nil.						self coreFinishedProfiling.						self deinstallWrappers.						MessageTally releaseCaches.						exitBlock value: aProfiler					].	^aProfiler</body></methods><methods><class-id>Kernel.BlockClosure</class-id> <category>general inquiries</category><body package="AT Profiling UI">allocationProfile	^AllocationProfiler profile: self</body><body package="AT Profiling UI">multiAllocationProfile	| answer |	MultiAllocationProfiler startProfiling.	answer := self value.	MultiAllocationProfiler stopProfiling.	^answer</body><body package="AT Profiling UI">multiTimeProfile	| answer |	MultiTimeProfiler startProfiling.	answer := self value.	MultiTimeProfiler stopProfiling.	^answer</body><body package="AT Profiling UI">timeProfile	^TimeProfiler profile: self</body></methods><methods><class-id>DetailsProfilePage class</class-id> <category>interface specs</category><body package="AT Profiling UI">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Unlabeled Canvas' 			#bounds: #(#{Graphics.Rectangle} 584 347 1032 586 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 1 ) 					#name: #profileList 					#model: #detailsList 					#menu: #listMenu 					#style: #fixed 					#useModifierKeys: true 					#selectionType: #highlight ) ) ) )</body></methods><methods><class-id>DetailsProfilePage class</class-id> <category>resources</category><body package="AT Profiling UI">listMenu	"Tools.MenuEditor new openOnClass: self andSelector: #listMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Spawn 					#defaultString: 'Spawn' 					#catalogID: #advanced ) 				#nameKey: #spawn 				#value: #spawnCurrent 				#enabled: false 				#enablementSelector: #enableSpawn ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Senders 					#defaultString: 'Senders' 					#catalogID: #advanced ) 				#value: #browseSenders ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Implementors 					#defaultString: 'Implementors' 					#catalogID: #advanced ) 				#value: #browseImplementors ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #browseClass 					#defaultString: 'Browse Class' 					#catalogID: #advanced ) 				#value: #browseClass ) ) #(1 3 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>ProfilePage class</class-id> <category>resources</category><body package="AT Profiling UI">listMenu	"Tools.MenuEditor new openOnClass: self andSelector: #listMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Spawn 					#defaultString: 'Spawn' 					#catalogID: #advanced ) 				#nameKey: #spawn 				#value: #spawnCurrent ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Senders 					#defaultString: 'Senders' 					#catalogID: #advanced ) 				#value: #browseSenders ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Implementors 					#defaultString: 'Implementors' 					#catalogID: #advanced ) 				#value: #browseImplementors ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #browseClass 					#defaultString: 'Browse Class' 					#catalogID: #advanced ) 				#value: #browseClass ) ) #(1 3 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>ProfileDetailBrowser class</class-id> <category>interface specs</category><body package="AT Profiling UI">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Unlabeled Canvas' 			#bounds: #(#{Graphics.Rectangle} 119 454 570 781 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 150 0 ) 					#name: #subcanvas 					#flags: 0 					#majorKey: #{DetailsProfilePage} 					#minorKey: #windowSpec 					#clientKey: #profileList ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 150 0 0 1 153 0 ) 					#name: #ResizingSplitter1 					#flags: 8 					#horizontal: true 					#minAboveSize: 30 					#minBelowSize: 30 					#aboveWidgets: 'subcanvas' 					#belowWidgets: 'codeBrowser' ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 153 0 0 1 0 1 ) 					#name: #codeBrowser 					#flags: 0 					#majorKey: #{Refactory.Browser.ProfilerCodeTool} 					#minorKey: #windowSpec 					#clientKey: #codeBrowser ) ) ) )</body></methods><methods><class-id>TotalsProfilePage class</class-id> <category>resources</category><body package="AT Profiling UI">listMenu	"Tools.MenuEditor new openOnClass: self andSelector: #listMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Spawn 					#defaultString: 'Spawn' 					#catalogID: #advanced ) 				#nameKey: #spawn 				#value: #spawnCurrent ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Senders 					#defaultString: 'Senders' 					#catalogID: #advanced ) 				#value: #browseSenders ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Implementors 					#defaultString: 'Implementors' 					#catalogID: #advanced ) 				#value: #browseImplementors ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #browseClass 					#defaultString: 'Browse Class' 					#catalogID: #advanced ) 				#value: #browseClass ) ) #(1 3 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>TotalsProfilePage class</class-id> <category>interface specs</category><body package="AT Profiling UI">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Unlabeled Canvas' 			#bounds: #(#{Graphics.Rectangle} 416 376 864 615 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 5 0 -5 1 -5 1 ) 					#name: #List1 					#model: #totalsList 					#menu: #listMenu 					#useModifierKeys: true 					#selectionType: #highlight ) ) ) )</body></methods><methods><class-id>Tools.Profiler class</class-id> <category>interface specs</category><body package="AT Profiling UI">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #ProfileSomething 				#defaultString: 'Profile something' 				#catalogID: #advanced ) 			#min: #(#{Core.Point} 650 350 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 700 525 1350 875 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} -5 1 43 0 1 0 ) 					#label: #maxSamplingInterval ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 1 0.5 43 0 ) 					#label: #sampleUnitName ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 5 43 ) 					#label: '1' ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 8 0 22 0 -8 1 40 0 ) 					#name: #sampleSizeSlider 					#model: #samplingIntervalAdaptor 					#orientation: #horizontal 					#start: 1 					#step: 1 ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} -58 0.5 42 0 -1 0.5 62 0 ) 					#flags: 0 					#model: #samplingIntervalAdaptor 					#alignment: #right 					#isReadOnly: true 					#type: #number 					#formatString: '##0' ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0 67 0 -1 1 -1 1 ) 					#name: #textModel 					#model: #textModel 					#tabable: true 					#menu: #textModelMenu 					#tabRequiresControl: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 7 2 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #SamplingInterval 						#defaultString: 'Sampling Interval:' 						#catalogID: #advanced ) ) ) ) )</body></methods><methods><class-id>Tools.Profiler class</class-id> <category>resources</category><body package="AT Profiling UI">pagesMenu	"Tools.MenuEditor new openOnClass: self andSelector: #pagesMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #tree 					#defaultString: 'Tree' 					#catalogID: #advanced ) 				#value: #profileTree ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #totals 					#defaultString: 'Totals' 					#catalogID: #advanced ) 				#value: #totals ) ) #(2 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.AllocationProfiler class</class-id> <category>resources</category><body package="AT Profiling UI">pagesMenu	"Tools.MenuEditor new openOnClass: self andSelector: #pagesMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #tree 					#defaultString: 'Tree' 					#catalogID: #advanced ) 				#value: #profileTree ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #spaceUsage 					#defaultString: 'Space Usage' 					#catalogID: #advanced ) 				#value: #spaceUsage ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #totals 					#defaultString: 'Totals' 					#catalogID: #advanced ) 				#value: #totals ) ) #(3 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.MultiAllocationProfiler class</class-id> <category>resources</category><body package="AT Profiling UI">pagesMenu	"Tools.MenuEditor new openOnClass: self andSelector: #pagesMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #tree 					#defaultString: 'Tree' 					#catalogID: #advanced ) 				#value: #profileTree ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #priority 					#defaultString: 'Priority' 					#catalogID: #advanced ) 				#value: #priorityTree ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #spaceUsage 					#defaultString: 'Space Usage' 					#catalogID: #advanced ) 				#value: #spaceUsage ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #totals 					#defaultString: 'Totals' 					#catalogID: #advanced ) 				#value: #totals ) ) #(4 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>SpaceProfilePage class</class-id> <category>interface specs</category><body package="AT Profiling UI">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Unlabeled Canvas' 			#bounds: #(#{Graphics.Rectangle} 528 439 976 678 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.DocumentViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 5 0 -5 1 -5 1 ) 					#name: #TextEditor1 					#flags: 15 					#model: #usageReport 					#isReadOnly: true 					#isWrapped: false ) ) ) )</body></methods><methods><class-id>ProfileBrowser class</class-id> <category>interface specs</category><body package="AT Profiling UI">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #Profile 				#defaultString: 'Profile' 				#catalogID: #advanced ) 			#min: #(#{Core.Point} 725 450 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 423 372 1148 822 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 275 110 375 135 ) 					#model: #acceptCutoff 					#label: 					#(#{Kernel.UserMessage} 						#key: #applyCutoff 						#defaultString: 'apply cutoff' 						#catalogID: #advanced ) 					#defaultable: true ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.Rectangle} 5 115 215 135 ) 					#name: #cutoff 					#model: #cutoff 					#orientation: #horizontal 					#start: 0 					#stop: 0.1 ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 215 115 250 135 ) 					#flags: 0 					#model: #cutoff 					#isReadOnly: true 					#type: #number 					#formatString: '0.0%' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 5 90 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #CutoffPercentage 						#defaultString: 'Cutoff Percentage' 						#catalogID: #advanced ) ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 5 0 -5 1 90 0 ) 					#name: #totalsReport 					#flags: 4 					#model: #totalsReport 					#isReadOnly: true 					#tabRequiresControl: true ) 				#(#{UI.TabControlSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 142 0 -5 1 -5 1 ) 					#name: #tabControl 					#model: #profileTabList 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #tabChanged ) 					#labels: #() ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutSizedOrigin} -130 1 110 0 100 25 ) 					#name: #spawnTextReport 					#model: #spawnTextReport 					#label: 					#(#{Kernel.UserMessage} 						#key: #spawnText 						#defaultString: 'spawn text' 						#catalogID: #advanced ) 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Tools.MultiTimeProfiler class</class-id> <category>resources</category><body package="AT Profiling UI">pagesMenu	"Tools.MenuEditor new openOnClass: self andSelector: #pagesMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #tree 					#defaultString: 'Tree' 					#catalogID: #advanced ) 				#value: #profileTree ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #priority 					#defaultString: 'Priority' 					#catalogID: #advanced ) 				#value: #priorityTree 				#helpText: 'Tree grouped by priority' ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #totals 					#defaultString: 'Totals' 					#catalogID: #advanced ) 				#value: #totals ) ) #(3 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>TreeProfilePage class</class-id> <category>interface specs</category><body package="AT Profiling UI">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Unlabeled Canvas' 			#bounds: #(#{Graphics.Rectangle} 416 376 864 615 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TreeViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 1 ) 					#name: #TreeView1 					#flags: 15 					#model: #treeList 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#requestValueChangeSelector: #changeRequest ) 					#menu: #treeMenu 					#useModifierKeys: true 					#selectionType: #highlight 					#useLines: false 					#rootExpander: false ) ) ) )</body></methods><methods><class-id>TreeProfilePage class</class-id> <category>resources</category><body package="AT Profiling UI">treeMenu	"Tools.MenuEditor new openOnClass: self andSelector: #treeMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #expand #defaultString: 'expand' #catalogID: #advanced) 				#nameKey: #expand 				#value: #expand ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #expandFully #defaultString: 'expand fully' #catalogID: #advanced) 				#nameKey: #expandFully 				#value: #expandFully ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #contractFully #defaultString: 'contract fully' #catalogID: #advanced) 				#nameKey: #contractFully 				#value: #contractFully ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #senders #defaultString: 'senders' #catalogID: #advanced) 				#nameKey: #browseSenders 				#value: #browseSenders ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #implementors #defaultString: 'implementors' #catalogID: #advanced) 				#nameKey: #browseImplementors 				#value: #browseImplementors ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #messages #defaultString: 'messages...' #catalogID: #advanced) 				#nameKey: #browseMessages 				#value: #browseMessages ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #spawn #defaultString: 'spawn' #catalogID: #advanced) 				#nameKey: #spawnCurrent 				#value: #spawnCurrent ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #findNext #defaultString: 'find next' #catalogID: #advanced) 				#nameKey: #findNextMenu 				#value: #findNextMenu ) ) #(3 3 1 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>menus - tools - advanced</category><body package="AT Profiling UI">menuItemAllocationProfiler	&lt;menuItemForCommand: #openAllocationProfiler		nameKey: nil		menu: #(#menuBar #tools #atTools #atProfiles)		position: 10.2&gt;	self openApplicationForClassNamed: #{AllocationProfiler} withSelector: #openView</body><body package="AT Profiling UI">menuItemMultiAllocationsProfiler	&lt;menuItemForCommand: #openMultiAllocationProfiler		nameKey: nil		menu: #(#menuBar #tools #atTools #atProfiles)		position: 10.4&gt;	self openApplicationForClassNamed: #{MultiAllocationProfiler} withSelector: #openView</body><body package="AT Profiling UI">menuItemMultiTimeProfiler	&lt;menuItemForCommand: #openMultiTimeProfiler		nameKey: nil		menu: #(#menuBar #tools #atTools #atProfiles)		position: 10.3&gt;	self openApplicationForClassNamed: #{MultiTimeProfiler} withSelector: #openView</body><body package="AT Profiling UI">menuItemTimeProfiler	&lt;menuItemForCommand: #openTimeProfiler		nameKey: nil		menu: #(#menuBar #tools #atTools #atProfiles)		position: 10.1&gt;	self openApplicationForClassNamed: #{TimeProfiler} withSelector: #openView</body></methods><methods><class-id>UI.CommandRegistry class</class-id> <category>commands - launcher</category><body package="AT Profiling UI">openAllocationProfilerCommand	&lt;command: #openAllocationProfiler&gt;	^Command		label: #ATAllocations &lt;&lt; #menus &gt;&gt; 'Allocations'		group: #launcher		bindings: #()</body><body package="AT Profiling UI">openMultiAllocationProfilerCommand	&lt;command: #openMultiAllocationProfiler&gt;	^Command		label: #ATMultiAllocations &lt;&lt; #menus &gt;&gt; 'MultiAllocations'		group: #launcher		bindings: #()</body><body package="AT Profiling UI">openMultiProfilerCommand	&lt;command: #openTimeProfiler&gt;	^Command		label: #ATTime &lt;&lt; #menus &gt;&gt; 'Time'		group: #launcher		bindings: #()</body><body package="AT Profiling UI">openMultiTimeProfilerCommand	&lt;command: #openMultiTimeProfiler&gt;	^Command		label: #ATMultiTime &lt;&lt; #menus &gt;&gt; 'MultiTime'		group: #launcher		bindings: #()</body></methods><initialize><class-id>Tools.Profiler</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>ProfilerCore</name><environment>Tools</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>accessPoint active incrementalGCs observedProcess priorityTally random rootTally samplingInterval scavenges nativeStackSpills numMarkStackOverflows numWeakObjectListOverflows numCompactNMethods extraMethods targetMethods </inst-vars><class-inst-vars>activeProfilerCore targetPrimNumbers targetMethods extraMethods </class-inst-vars><imports></imports><category>AT Profiling Core</category><attributes><package>AT Profiling Core</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>BrowserCodeTool</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserTextTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars>modified initialLookPrefs </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Code Tools</category><attributes><package>Browser-BrowserUI</package></attributes></class><class><name>BlockClosure</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method outerContext copiedValues </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>VisualLauncher</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuBar toolBar textCollector transcriptView statusBar </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>Tools-Misc</package></attributes></class></st-source>