<?xml version="1.0"?><st-source><!-- Name: AT Parser CompilerNotice: Copyright 1999-2014 Cincom Systems, Inc.  All rights reserved.Comment: The parser compiler classes make it easier to write compilers in Smalltalk.For an example of a parser, see the SQL Compiler in the AT Parser Example package.DbIdentifier: bear73DbTrace: 431243DbUsername: smichaelDbVersion: 8.0 - 3PackageName: AT Parser CompilerParcel: #('ATParserCompiler')ParcelName: AT Parser CompilerPrintStringCache: (8.0 - 3,smichael)Version: 8.0 - 3Date: 7:45:47 AM May 13, 2014 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.0 (may14.2) of May 13, 2014 on May 13, 2014 at 7:45:47 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>PushFragment</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>setup parts </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AT-ParserCompiler</category><attributes><package>AT Parser Compiler</package></attributes></class><comment><class-id>Kernel.PushFragment</class-id><body>I am a partially constructed message (binary or keyword) appearing in an action in a grammar. My result will be pushed onto the parser stack.Instance Variables:	setup	&lt;String&gt; code to pop the receiver and arguments off the stack as necessary	parts	&lt;Array of: String&gt; one per receiver or selector part</body></comment><class><name>GeneralParser</name><environment>Kernel</environment><super>Kernel.Scanner</super><private>false</private><indexed-type>none</indexed-type><inst-vars>requestor class targetClass failBlock correctionDelta stack backupStack reservedWords keywordMarker retryBlock </inst-vars><class-inst-vars>typeTable reservedWords hasKeywords methodInfo </class-inst-vars><imports></imports><category>AT-ParserCompiler</category><attributes><package>AT Parser Compiler</package></attributes></class><comment><class-id>Kernel.GeneralParser</class-id><body>GeneralParser provides a framework for parsers produced by the parser compiler, which are subclasses of this class.Subclasses must implement the following messages:	parsing		methodInstance Variables:	requestor	&lt;ParagraphEditor | nil&gt; object from which parsing was invoked.				If not nil, this object will be sent -notify: prior to evaluating the failBlock	class		&lt;Behavior&gt; the class that describes the environment in which the				compiled code will be executed	targetClass	&lt;Behavior&gt; the class in which the method will be installed--this will				usually be identical to 'class'	failBlock		&lt;BlockContext&gt; to be evaluated in case of parse errors	correctionDelta	&lt;Integer&gt; offset of corrected code relative to source stream				owing to interactive corrections so far	stack		&lt;OrderedCollection&gt;  used by generated parsers to hold partially				completed parse trees, see the documentation in ParserCompiler				class for details	backupStack	&lt;OrderedCollection&gt;  holds backup information	reservedWords	&lt;Set | false&gt;	keywordMarker	&lt;Symbol&gt;	#colon if keywords are recognized, #xLetter if not	retryBlock		&lt;BlockClosure&gt; block to reinitialize the source stream to permit					retrying after correcting a syntax errorClass Variables	ParserCompilerInstalled	&lt;Boolean&gt; indicates whether the ParserCompiler can be							used (for bootstrapping).  nil is interpreted as falseClass Instance Variables	typeTable				&lt;ScannerTable | nil&gt; maps characters to Symbols, which identify							the type of token the character may introduce	reservedWords			&lt;Set | false | nil&gt;	hasKeywords			&lt;Boolean | nil&gt; whether the language uses keywords	methodInfo				&lt;(Dictionary keys: Symbol values: (Array new: 3)) | nil&gt;</body></comment><class><name>ParserCompiler</name><environment>Kernel</environment><super>Kernel.GeneralParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>newTypeTable newReservedWords typeSet hasKeywords temps vars </inst-vars><class-inst-vars>showSourceAsSmalltalk </class-inst-vars><imports></imports><category>AT-ParserCompiler</category><attributes><package>AT Parser Compiler</package></attributes></class><comment><class-id>Kernel.ParserCompiler</class-id><body>I generate parsers, given the syntax of the source language (lexical and phrase).  See the method 'method' for the syntax I accept, written in itself.  See the method 'documentation' in my class for documentation on how to use me.Note this class must be filed in after RecognizerFragment and PushFragment.Instance Variables:	newTypeTable	&lt;Dictionary key: Character value: Symbol&gt;	newReservedWords	&lt;Set of: String&gt;	typeSet	&lt;Set of: Symbol&gt; set of explicitly recognized type names	hasKeywords	&lt;Boolean&gt; whether the compiler being generated recognizes keywords	temps	&lt;String&gt; the string of temporary variables for the method being compiled	vars	&lt;Set of: String&gt; variable names that are recognizedClass Instance Variables	showSourceAsSmalltalk	&lt;Boolean | nil&gt; determines whether all method sources are							presented as Smalltalk, decompiling if necessary. nil is							interpreted as false</body></comment><class><name>RecognizerFragment</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name action test </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AT-ParserCompiler</category><attributes><package>AT Parser Compiler</package></attributes></class><comment><class-id>Kernel.RecognizerFragment</class-id><body>I represent a fragment of code which will be part of a parsing method.Instance Variables:	name &lt;String | nil&gt; The name of the construct that this fragment recognizes.  Only			used for generating error messages of the form '... expected' in the generated parser.	action &lt;String&gt; A piece of Smalltalk code that does something before any tests are made.	test &lt;String&gt; A Smalltalk expression that does some kind of test on the source stream.</body></comment><class><name>ExternalLanguageParser</name><environment>Kernel</environment><super>Kernel.GeneralParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AT-ParserCompiler</category><attributes><package>AT Parser Compiler</package></attributes></class><comment><class-id>Kernel.ExternalLanguageParser</class-id><body>I am an abstract superclass for handling 'compilers' for languages that do not produce Smalltalk code, but have some other execution mechanism.  The CompiledMethods in the method dictionaries of my subclasses simply return a data structure produced by the parser, rather than executing any code.I expect the parser to leave on the top of the stack an Association whose key is a unary selector, and whose value is some object (someObject).  I send the message	self subGenerate: someObjectand make the result be the value returned by the CompiledMethod.</body></comment><shared-variable><name>ParserCompilerInstalled</name><environment>Kernel.GeneralParser</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>AT Parser Compiler</package></attributes></shared-variable><methods><class-id>Kernel.PushFragment</class-id> <category>accessing</category><body package="AT Parser Compiler">contents	| code |	code := (String new: 100) writeStream.	setup isEmpty		ifTrue: [code nextPutAll: 'stack addLast: (']		ifFalse: [code nextPutAll: setup; nextPutAll: 'self replaceStackTop: ('].	parts do: [:word | code space; nextPutAll: word].	code nextPutAll: '). '.	^RecognizerFragment		name: nil		action: code contents		test: 'true'</body></methods><methods><class-id>Kernel.PushFragment</class-id> <category>adding</category><body package="AT Parser Compiler">add: selectorPart from: generator	^setup isEmpty		ifTrue:			[self				setup: ' '				addPart: selectorPart, 'stack last']		ifFalse:			[| c |			c := generator makeTemp.			self				setup: c, ' := stack removeLast. ', setup				addPart: selectorPart, c]</body><body package="AT Parser Compiler">add: selectorPart value: aConstant	^self		setup: setup		addPart: selectorPart, ' ', aConstant</body></methods><methods><class-id>Kernel.PushFragment</class-id> <category>private</category><body package="AT Parser Compiler">setup: setupString addPart: newPart	^self class setup: setupString parts: (parts copyWith: newPart)</body><body package="AT Parser Compiler">setup: setupString parts: partList	setup := setupString.	parts := partList</body></methods><methods><class-id>Kernel.PushFragment class</class-id> <category>instance creation</category><body package="AT Parser Compiler">new	^self setup: '' parts: #()</body><body package="AT Parser Compiler">setup: setupString parts: parts	^self basicNew setup: setupString parts: parts</body></methods><methods><class-id>Kernel.GeneralParser</class-id> <category>initialize</category><body package="AT Parser Compiler">initScanner	super initScanner.	typeTable := self class typeTable.	reservedWords := self class reservedWords.	keywordMarker := self class hasKeywords		ifTrue: [#colon]		ifFalse: [#xLetter].	stack := OrderedCollection new: 20.	backupStack := OrderedCollection new</body><body package="AT Parser Compiler">targetClass: aClassDescription	targetClass := aClassDescription</body></methods><methods><class-id>Kernel.GeneralParser</class-id> <category>public access</category><body package="AT Parser Compiler">compile: textOrStream in: aContext allowReceiver: allowSelf	class: aClass environment: env noPattern: noPattern	notifying: aRequestor ifFail: aFailBlock handler: aHandler	| methodNodeHolder |	methodNodeHolder := self compile: textOrStream in: aClass notifying: aHandler ifFail: aFailBlock.	methodNodeHolder == nil ifTrue: [^nil].	^methodNodeHolder generate</body><body package="AT Parser Compiler">compile: textOrStream in: aClass notifying: aRequestor ifFail: aBlock 	| code retrySignal myStream |	myStream := textOrStream.	self retryBlock: 		[ :lengthChange | 		self initScanner.		myStream := requestor text asString readStream.		( retrySignal := Object errorSignal new ) raise.		].	self setClass: aClass.	^Object errorSignal		handle: [ :ex | ex == retrySignal ifTrue: [ ex restart ] ifFalse: [ ex pass ] ]		do:	[self				init: myStream				notifying: aRequestor				failBlock: [^aBlock value].			self method ifFalse: [ self unexpectedError ].			tokenType == #doIt ifFalse: [self notify: (#EndOfMethodExpected &lt;&lt; #advanced &gt;&gt; 'End of method expected') asString].			stack size = 1 ifFalse: [self notify: (#StackSizeErrorCompilerBug &lt;&lt; #advanced &gt;&gt; 'Stack size error, compiler bug!') asString].			code := self generate: stack last.			code isNil ifTrue: [self notify: (#CodeGenerationFailed &lt;&lt; #advanced &gt;&gt; 'Code generation failed!') asString].			code]</body><body package="AT Parser Compiler">environment: aNamespace	"Ignore this in general"</body><body package="AT Parser Compiler">format: sourceCode in: aClass notifying: aRequestor	^Compiler new format: sourceCode in: aClass notifying: aRequestor</body><body package="AT Parser Compiler">parse: string as: construct	self		initScanner;		init: string notifying: nil failBlock: nil;		perform: construct.	^stack</body><body package="AT Parser Compiler">parse: sourceCode in: aClass environment: env allowReceiver: allowSelf noPattern: noPattern notifying: aRequestor	"Compile the incoming text and answer with the resulting parse tree.	This is the only public message that saves the source map	and the comments.  If the requestor is nil,	warning messages (as opposed to outright errors)	are silently discarded."	self setClass: aClass.	self		init: sourceCode		notifying: aRequestor		failBlock: nil.	self method ifFalse: [self unexpectedError].	tokenType == #doIt ifFalse: [self notify: (#EndOfMethodExpected &lt;&lt; #advanced &gt;&gt; 'End of method expected') asString].	stack size = 1 ifFalse:		[self notify: (#StackSizeErrorCompilerBug &lt;&lt; #advanced &gt;&gt; 'Stack size error, compiler bug!') asString].	^Compiler new		parse: stack last		in: class		environment: env		allowReceiver: allowSelf		noPattern: noPattern		notifying: aRequestor</body><body package="AT Parser Compiler">parse: sourceCode in: aClass notifying: aRequestor	"Compile the incoming text and answer with the resulting parse tree.	This is the only public message that saves the source map	and the comments.  If the requestor is nil,	warning messages (as opposed to outright errors)	are silently discarded."	self setClass: aClass.	self		init: sourceCode		notifying: aRequestor		failBlock: nil.	self method ifFalse: [self unexpectedError].	tokenType == #doIt ifFalse: [self notify: (#EndOfMethodExpected &lt;&lt; #advanced &gt;&gt; 'End of method expected') asString].	stack size = 1 ifFalse:		[self notify: (#StackSizeErrorCompilerBug &lt;&lt; #advanced &gt;&gt; 'Stack size error, compiler bug!') asString].	^Compiler new		parse: stack last		in: class		notifying: aRequestor</body></methods><methods><class-id>Kernel.GeneralParser</class-id> <category>subclass responsibility</category><body package="AT Parser Compiler">method	"Parse a method, leaving the parsed representation, either a parse tree or 	Smalltalk source code, as the sole item on the stack"	^self subclassResponsibility</body></methods><methods><class-id>Kernel.GeneralParser</class-id> <category>scanning</category><body package="AT Parser Compiler">keywords	"Recognize one or more keywords,	and pack them together."	| words lastType |	tokenType == #keyword ifFalse: [^false].	(typeTable at: hereChar asInteger) == #xLetter ifFalse:		["only one keyword"		stack addLast: token.		self scanToken.		^true].	"Must check whether there were intervening delimiters.	Do this by comparing starting positions in source."	words := (String new: 30) writeStream.	words nextPutAll: token.	[(lastType := typeTable at: hereChar asInteger) == #xLetter and:			[self scanToken.			tokenType == #keyword]]		whileTrue:			["No delimiters"			words nextPutAll: token].	lastType == #xLetter		ifFalse:	[self scanToken].	stack addLast: words contents.	^true</body><body package="AT Parser Compiler">peekForType: aType	"Test to see if tokenType matches aType. If so, advance to the next token, 	pushing the old token on the stack"	^tokenType == aType		ifTrue: 			[stack addLast: token.			self scanToken.			true]		ifFalse: [false]</body><body package="AT Parser Compiler">peekForType: aType value: trialValue 	"Test to see if tokenType matches aType and token equals trialValue. If so, 	advance to the next token"	^(tokenType == aType and: [token = trialValue])		ifTrue: 			[self scanToken.			true]		ifFalse: [false]</body><body package="AT Parser Compiler">peekForTypeNoPush: aType	"Test to see if tokenType matches aType. If so, advance to the next token, 	leaving the stack unchanged"	^tokenType == aType		ifTrue: 			[self scanToken.			true]		ifFalse: [false]</body><body package="AT Parser Compiler">signedNumber	"Recognize a possibly signed number."	tokenType == #number		ifTrue:			[stack addLast: token.			self scanToken.			^true].	(token == #- and: [hereChar notNil and: [hereChar isDigit]])  "no intervening delimiters"		ifTrue:			[self scanToken.			stack addLast: token negated.			self scanToken.			^true].	^false</body><body package="AT Parser Compiler">sourcePosition	"return the source position of here"	^mark - 1 + correctionDelta</body><body package="AT Parser Compiler">sourcePosition: pos	"set the source position of here"	source position: pos.	self step.  "fill character buffer"	self scanToken.  "fill scanner buffer"</body><body package="AT Parser Compiler">xLetter	"form a word, keyword, or reserved word"	| type char |	buffer reset.	buffer nextPut: hereChar.	[char := source next.	char notNil and:		[type := typeTable at: char asInteger.		type == #xLetter or: [type == #xDigit]]]		whileTrue:			[buffer nextPut: char].	(char notNil and: [type == keywordMarker])  "either #colon, if keywords,				  or #xLetter (no match) if none"		ifTrue: 			[buffer nextPut: char.			char := source next.			tokenType := #keyword]		ifFalse: 			[tokenType := #word].	hereChar := char.	token := buffer contents.	reservedWords == false ifFalse:		[(reservedWords includes: token)			ifTrue: [tokenType := token asSymbol]]</body></methods><methods><class-id>Kernel.GeneralParser</class-id> <category>backing up</category><body package="AT Parser Compiler">backupDiscard	"discard the backup state on success"	backupStack removeLast.	backupStack removeLast.	^true</body><body package="AT Parser Compiler">backupRestore	"restore the saved state on failure"	self popStackTo: backupStack removeLast.	self sourcePosition: backupStack removeLast.	^false</body><body package="AT Parser Compiler">backupSave	"save the current state for backing up"	backupStack		addLast: self sourcePosition;		addLast: stack size</body></methods><methods><class-id>Kernel.GeneralParser</class-id> <category>error handling</category><body package="AT Parser Compiler">abort	| exitBlock |	exitBlock := failBlock.	failBlock := nil.	^exitBlock value</body><body package="AT Parser Compiler">expected: aString 	"Notify a problem at token 'here'"	^self notify: ((#x1sExpected &lt;&lt; #advanced &gt;&gt; '%&lt;- &lt;1s&gt; expected ')			expandMacrosWith: aString) at: mark</body><body package="AT Parser Compiler">notify: aString 	"Notify problem at token before 'here'"	^self notify: aString at: source position</body><body package="AT Parser Compiler">notify: aString at: position	backupStack isEmpty		ifFalse: [^false].  "we are inside a backup"	requestor == nil		ifTrue:			[ | p contents |			"Temporarily reset source in order to get full contents"			p := source position.			contents := source reset; contents.			source position: p.			SyntaxErrorException new				targetClass: class;				messageText: aString;				source: contents;				position: position;				raiseSignal]		ifFalse: [requestor _isCompilerErrorHandler			ifTrue: [requestor syntaxError: aString asString at: position]			ifFalse: [requestor insertAndSelect: aString asString at: position]].	self abort</body><body package="AT Parser Compiler">offEnd: aString 	" notify a problem beyond 'here' (in lookAhead token).  Don't be offEnded!"	^ self notify: aString at: mark</body><body package="AT Parser Compiler">retryBlock: aBlock	retryBlock := aBlock</body><body package="AT Parser Compiler">unexpectedError	self notify: (#syntaxError &lt;&lt; #advanced &gt;&gt; 'syntax error') asString.	^false</body></methods><methods><class-id>Kernel.GeneralParser</class-id> <category>code generation</category><body package="AT Parser Compiler">generate: parsedSource	"This is a default, assuming that	generated parsers produce Smalltalk source code."	^Compiler new		targetClass: targetClass;		compile: parsedSource		in: class		notifying: nil		ifFail: [^nil]</body></methods><methods><class-id>Kernel.GeneralParser</class-id> <category>stack operations</category><body package="AT Parser Compiler">combineStackTo: oldSize 	"Make the items down to oldSize into an array, 	and replace them with it."	|  size |	size := stack size.	oldSize = size ifTrue: [^stack addLast: #()].	(oldSize &gt; size or: [oldSize &lt; 0])		ifTrue: [self error: (#InvalidSizeForCombiningStack &lt;&lt; #advanced &gt;&gt; 'Invalid size for combining stack')].	stack addLast: (stack removeLast: size - oldSize)</body><body package="AT Parser Compiler">popStackTo: newSize	newSize &gt; stack size ifTrue: [^false].	stack size - newSize timesRepeat: [stack removeLast].  "pop and nil elements"	^true</body><body package="AT Parser Compiler">replaceStackTop: anElement	"This is only generated in cases where	it is known that the stack is not empty."	^stack at: stack size put: anElement</body></methods><methods><class-id>Kernel.GeneralParser</class-id> <category>private</category><body package="AT Parser Compiler">init: streamOrString notifying: req failBlock: aBlock	"Initialize the scanner.  Return the initial position	in the source stream, so that we can back up	over an initial scan if necessary."	| sourceStream startPos |	(streamOrString isKindOf: Stream)		ifTrue:	[startPos := streamOrString position.				sourceStream := streamOrString]		ifFalse:	[startPos := 1.				sourceStream := streamOrString asString readStream].	requestor := req.	failBlock := aBlock.	correctionDelta := 0.	self scan: sourceStream.	^startPos</body><body package="AT Parser Compiler">setClass: aClass	class := aClass.	targetClass == nil		ifTrue:	[targetClass := aClass]</body></methods><methods><class-id>Kernel.GeneralParser class</class-id> <category>accessing</category><body package="AT Parser Compiler">compilerClass	 ^ParserCompilerInstalled == true		ifTrue: [ParserCompiler]		ifFalse: [Compiler]</body><body package="AT Parser Compiler">hasKeywords	hasKeywords == nil ifTrue: [self computeTables].	^hasKeywords</body><body package="AT Parser Compiler">methodInfo	methodInfo == nil ifTrue: [methodInfo := Dictionary new].	reservedWords := typeTable := hasKeywords := nil.  "Clear cache"	^methodInfo</body><body package="AT Parser Compiler">nilTypeTable	typeTable := nil</body><body package="AT Parser Compiler">preferredParserClass	^Compiler preferredParserClass</body><body package="AT Parser Compiler">reservedWords	reservedWords == nil ifTrue: [self computeTables].	^reservedWords</body><body package="AT Parser Compiler">typeTable	typeTable == nil  ifTrue: [self computeTables].	^typeTable</body></methods><methods><class-id>Kernel.GeneralParser class</class-id> <category>testing</category><body package="AT Parser Compiler">isGrammarExpression: string	"Answer whether this string is a grammar expression method,	 as opposed to Smalltalk code (or nil)"	^string notNil and: [self compilerClass new isGrammarExpression: string readStream]</body><body package="AT Parser Compiler">parse: aString as: constructMessage	^self new parse: aString as: constructMessage</body><body package="AT Parser Compiler">treatsAsSimpleSmalltalk: string	"Answer whether this string is Smalltalk code (or nil),	 as opposed to a grammar expression method"	^(self isGrammarExpression: string) not</body></methods><methods><class-id>Kernel.GeneralParser class</class-id> <category>binary storage</category><body package="AT Parser Compiler">codeWriterTraceOnto: tracer	super codeWriterTraceOnto: tracer.	tracer trace: typeTable.	tracer trace: reservedWords.	tracer trace: hasKeywords.	tracer trace: methodInfo.</body><body package="AT Parser Compiler">readInitializationObjectsOn: aBinaryCodeReader	super readInitializationObjectsOn: aBinaryCodeReader.	typeTable := aBinaryCodeReader readObject.	reservedWords := aBinaryCodeReader readObject.	hasKeywords := aBinaryCodeReader readObject.	methodInfo := aBinaryCodeReader readObject.</body><body package="AT Parser Compiler">storeInitializationObjectsOn: aBinaryCodeWriter	aBinaryCodeWriter trace: typeTable.	aBinaryCodeWriter trace: reservedWords.	aBinaryCodeWriter trace: hasKeywords.	aBinaryCodeWriter trace: methodInfo.</body></methods><methods><class-id>Kernel.GeneralParser class</class-id> <category>private</category><body package="AT Parser Compiler">computeTables	"Compute the character type, reserved word tables, and	keyword flag from the information associated with each method."	| words types kwds info typeInfo |	words := Set new.	types := TypeTable copy.	kwds := false. 	self methodInfo keys do:		[:selector |		(methodDict includesKey: selector)			ifTrue:				[info := methodInfo at: selector.				words addAll: (info at: 1).				typeInfo := info at: 2.				typeInfo isEmpty ifFalse:					[typeInfo associationsDo:						[:char |						types at: char key asInteger							put: char value]].				kwds := kwds | (info at: 3)]			ifFalse:				[methodInfo removeKey: selector]].	reservedWords := words isEmpty ifTrue: [false] ifFalse: [words].	typeTable := types.	hasKeywords := kwds</body></methods><methods><class-id>Kernel.GeneralParser class</class-id> <category>class initialization</category><body package="AT Parser Compiler">postCopyFromShadow: shadowClass	"We have just been copied from a shadow namespace, either because we were just loaded, or because changes to us were just loaded. Normally we shouldn't have to do anything, but in some circumstances we might. For example, subclasses of GeneralParser rely on side effects of method compilation to populate the methodInfo class instance variable. If the class is compiled in shadow and then the resulting compiled methods are applied, those side effects will have happened only to the shadow class. This method gives us an opportunity to do anything necessary."	super postCopyFromShadow: shadowClass.	methodInfo := shadowClass methodInfo.</body></methods><methods><class-id>Kernel.ParserCompiler</class-id> <category>initialize-release</category><body package="AT Parser Compiler">initScanner	super initScanner.	typeSet := Set new: 10.	typeSet addAll: #(binary character keyword number string word).	newTypeTable := Dictionary new.	newReservedWords := Set new.	hasKeywords := false.	temps := ' '.</body></methods><methods><class-id>Kernel.ParserCompiler</class-id> <category>public access</category><body package="AT Parser Compiler">compile: textOrStream in: aClass notifying: aRequestor ifFail: aBlock	| sourceStream startPos |	self setClass: aClass.	sourceStream := (textOrStream isKindOf: Stream)		ifTrue: [startPos := textOrStream position.  textOrStream]		ifFalse: [startPos := 1.  textOrStream asString readStream].	"Parse the method header to see if it is a syntax equation."	(self isGrammarExpression: sourceStream)		ifTrue:			[sourceStream position: startPos.			vars := aClass allInstVarNames asSet.			^super compile: textOrStream				in: aClass				notifying: aRequestor				ifFail: aBlock]		ifFalse:			[sourceStream position: startPos.			^Compiler new				targetClass: targetClass;				compile: textOrStream				in: class				notifying: aRequestor				ifFail: aBlock]</body><body package="AT Parser Compiler">format: sourceCode in: aClass notifying: aRequestor	^(self isGrammarExpression: sourceCode)		ifTrue: [sourceCode]		ifFalse: [Compiler new format: sourceCode in: aClass notifying: aRequestor]</body><body package="AT Parser Compiler">isGrammarExpression: textStream	"Parse the method header to see if it is a syntax equation."	self init: textStream notifying: nil failBlock: nil.	tokenType == #word		ifTrue: [self scanToken]		ifFalse:			[(tokenType == #keyword and:					[self scanToken.					tokenType == #word])				ifTrue:					[[self scanToken.					tokenType == #keyword and:							[self scanToken.							tokenType == #word]]						whileTrue: []]				ifFalse: [^false]].	^token == #=</body><body package="AT Parser Compiler">parse: textOrStream in: aClass environment: env allowReceiver: allowSelf noPattern: noPattern notifying: aRequestor	"Compile the incoming text and answer with the resulting parse tree.	This is the only public message that saves the source map	and the comments.  If the requestor is nil,	warning messages (as opposed to outright errors)	are silently discarded."	| startPos sourceStream |	sourceStream := (textOrStream isKindOf: Stream)		ifTrue: [startPos := textOrStream position.  textOrStream]		ifFalse: [startPos := 1.  textOrStream asString readStream].	"Parse the method header to see if it is a syntax equation."	(self isGrammarExpression: sourceStream)		ifTrue:			[sourceStream position: startPos.			vars := aClass allInstVarNames asSet.			^super parse: textOrStream				in: aClass				environment: env				allowReceiver: allowSelf				noPattern: noPattern 				notifying: aRequestor]		ifFalse:			[sourceStream position: startPos.			^Compiler new parse: textOrStream				in: aClass				environment: env				allowReceiver: allowSelf				noPattern: noPattern 				notifying: aRequestor]</body><body package="AT Parser Compiler">parse: textOrStream in: aClass notifying: aRequestor	"Compile the incoming text and answer with the resulting parse tree.	This is the only public message that saves the source map	and the comments.  If the requestor is nil,	warning messages (as opposed to outright errors)	are silently discarded."	| startPos sourceStream |	sourceStream := (textOrStream isKindOf: Stream)		ifTrue: [startPos := textOrStream position.  textOrStream]		ifFalse: [startPos := 1.  textOrStream asString readStream].	"Parse the method header to see if it is a syntax equation."	(self isGrammarExpression: sourceStream)		ifTrue:			[sourceStream position: startPos.			vars := aClass allInstVarNames asSet.			^super parse: textOrStream				in: aClass				notifying: aRequestor]		ifFalse:			[sourceStream position: startPos.			^Compiler new parse: textOrStream				in: aClass				notifying: aRequestor]</body></methods><methods><class-id>Kernel.ParserCompiler</class-id> <category>parsing-syntax</category><body package="AT Parser Compiler">alternative =	#@ term* [terms: flagErrors: false] [backup:]	| term* [terms: flagErrors: true]</body><body package="AT Parser Compiler">definition = 	alternative ($| definition [alternative:with:] | )</body><body package="AT Parser Compiler">method = 	(word [self beginPattern]		| keyword [self beginPattern] word [pattern:arg:]		  (keyword [pattern:keyword:] word [pattern:arg: ])*!)	#=	($| (word [addTemp:] . )*! $| | )	definition	[phraseDef:pattern:as:]</body><body package="AT Parser Compiler">term =	unit (#* [repeat:combine: true] | 		#*! [repeat:combine: false] |		#+ [repeatPlus:combine: true] |		#+! [repeatPlus:combine: false] |		#\ unit [repeat:separatedBy:combine: true] |		#\! unit [repeat:separatedBy:combine: false] |		#!* [self uncombine] |		)	| action</body><body package="AT Parser Compiler">unit  =	word=#word [#word] 		(#= $# word [nonTerminal:value:]		| [nonTerminal:])	| word=#keyword [#keyword] [self setKeywords] .		(#= $# keyword [nonTerminal:value:] | [nonTerminal:])	| word [nonTerminal:]	| character [terminal:]	| $#		(word [reservedWord:]		| keyword [self setKeywords] . [reservedWord:]		| binary [reservedBinary:]		| $| [terminal: $|]		| string [reservedWord:])	| $( definition $)</body></methods><methods><class-id>Kernel.ParserCompiler</class-id> <category>parsing-code generation</category><body package="AT Parser Compiler">addTemp: tempName	(vars includes: tempName)		ifTrue: [self error: 'temp name ', tempName, ' already used'].	temps := temps, (tempName, ' ').	vars add: tempName</body><body package="AT Parser Compiler">alternative: first with: second	^(second test = 'true' and: [second action isEmpty])		ifTrue:			["Second alternative is empty,			so result can't fail."			RecognizerFragment				name: 'optional ', first nameString				action: first code, '. '				test: 'true']		ifFalse:			[RecognizerFragment				name: first nameString, ' or ',					second nameString				action: first action				test: '(', first test,					' or: [', second code, '])']</body><body package="AT Parser Compiler">backup: recog	^RecognizerFragment		name: recog name		action:			'self backupSave. ', recog action		test:			'(', recog test,			' ifTrue: [self backupDiscard] ifFalse: [self backupRestore])'</body><body package="AT Parser Compiler">beginPattern	^stack last</body><body package="AT Parser Compiler">nonTerminal: aWord	| sym |	^RecognizerFragment		name: aWord		test:			((typeSet includes: (sym := aWord asSymbol))				ifTrue:					["Predefined terminal symbol."					'(self peekForType: #', sym, ')']				ifFalse:					["Defined phrase type.					If keywords, remember that the					generated parser must recognize					keywords specially."					sym == #keywords ifTrue:						[hasKeywords := true].					'self ', sym])</body><body package="AT Parser Compiler">nonTerminal: nameWord value: valueWord	"Literal token of specified type.	If keyword, remember that the generated	parser must recognize keywords specially."	nameWord = 'keyword' ifTrue: [hasKeywords := true].	^RecognizerFragment		name: valueWord storeString		test: '(self peekForType: #', nameWord, ' value: ', valueWord asString storeString, ' )'</body><body package="AT Parser Compiler">pattern: pattern arg: argName	vars add: argName.	^pattern, ' ', argName</body><body package="AT Parser Compiler">pattern: pattern keyword: aKeyword	self replaceStackTop: stack last, aKeyword.  "accumulate selector"	^pattern, ' ', aKeyword</body><body package="AT Parser Compiler">phraseDef: selector pattern: pattern as: code	(newReservedWords isEmpty &amp; newTypeTable isEmpty &amp; hasKeywords not)		ifTrue: [class methodInfo			removeKey: selector asSymbol			ifAbsent: []]		ifFalse: [class methodInfo			at: selector asSymbol			put: (Array				with: newReservedWords				with: newTypeTable with: hasKeywords)].	^pattern, ' |', temps, '| ', code action, '^', code test</body><body package="AT Parser Compiler">repeat: unitCode combine: flag	| code c |	code := '[', unitCode code, '] whileTrue: []. '.	flag ifTrue:		[c := self makeTemp.		code := c, ' := stack size. ', code,			'self combineStackTo: ', c, '. '].	^RecognizerFragment action: code</body><body package="AT Parser Compiler">repeat: unitCode separatedBy: seprCode combine: flag	| c f r action test |	f := self makeTemp.	r := self makeTemp.	action := f, ' := true. [(', r, ' := ', f, ' or: [', seprCode code,		']) and: [', unitCode code, ']] whileTrue: [',		f, ' := false]. '.	test := '(', f, ' ifTrue: [false] ifFalse: [',		r, ' ifTrue: [self unexpectedError]. '.	flag ifTrue:		[c := self makeTemp.		action := c, ' := stack size. ', action.		test := test, 'self combineStackTo: ', c, '. '].	^RecognizerFragment		name: unitCode name		action: action		test: test, 'true])'</body><body package="AT Parser Compiler">repeatPlus: unitCode combine: flag	| c f action test |	f := self makeTemp.	action := f, ' := false. [', unitCode code, '] whileTrue: [',		f, ' := true]. '.	test := f.	flag ifTrue:		[c := self makeTemp.		action := c, ' := stack size. ', action.		test := '(', f, ' and: [self combineStackTo: ', c, '. true])'].	^RecognizerFragment		name: unitCode name		action: action		test: test</body><body package="AT Parser Compiler">reservedBinary: aBinary	^RecognizerFragment		name: aBinary		test: '(self peekForType: #binary value: #', aBinary, ')'</body><body package="AT Parser Compiler">reservedWord: aWord 	newReservedWords add: aWord asString.	^RecognizerFragment name: aWord test: '(self peekForTypeNoPush: ', aWord asSymbol storeString, ')'</body><body package="AT Parser Compiler">setKeywords	"This grammar includes a literal keyword,	or the word keyword, so the generated parser	should recognize keywords specially."	hasKeywords := true</body><body package="AT Parser Compiler">terminal: aCharacter	| type oldType |	oldType := self class typeTable at: aCharacter asInteger.	type := newTypeTable at: aCharacter ifAbsent: [oldType].	type first == $x ifTrue:		["Assign a type for this character"		type := aCharacter asInteger printStringRadix: 8.		type := ('ascii', type) asSymbol.		newTypeTable at: aCharacter put: type].	^RecognizerFragment		name: (type = oldType			ifFalse: [String with: aCharacter]			ifTrue: [type])		test: '(self peekForTypeNoPush: #', type, ')'</body><body package="AT Parser Compiler">terms: termArray flagErrors: errorFlag	| pre clause terms initialTerm name depth |	termArray isEmpty ifTrue: [^RecognizerFragment empty].	termArray size = 1 ifTrue: [^termArray first].	pre := (String new: 100) writeStream.	terms := termArray readStream.	[terms atEnd ifTrue: [^RecognizerFragment action: pre contents].	initialTerm := terms next.	pre nextPutAll: initialTerm action.	initialTerm test = 'true']		whileTrue: [].	clause := (String new: 100) writeStream.	clause		nextPut: $(;		nextPutAll: initialTerm test;		nextPutAll: ' and: ['.	name := initialTerm name.	depth := 1.	terms do:		[:term |		clause nextPutAll: term action.		term test = 'true'			ifFalse:				[name == nil ifTrue: [name := term name].				clause nextPutAll: term test.				errorFlag					ifTrue:						[clause nextPutAll: ' ifFalse: [self '.						term name == nil							ifTrue: [clause nextPutAll:								'unexpectedError']							ifFalse: [clause nextPutAll:								'expected: '; store: term name].						clause nextPut: $]]					ifFalse:	[clause nextPutAll: ' ifFalse: [false]'].				clause nextPutAll: ' ifTrue: ['.				depth := depth + 1]].	clause nextPutAll: 'true'.	depth timesRepeat: [clause nextPut: $]].	clause nextPut: $).	^RecognizerFragment		name: name		action: pre contents		test: clause contents</body><body package="AT Parser Compiler">uncombine	^RecognizerFragment action: ' stack addAll: stack removeLast. '</body></methods><methods><class-id>Kernel.ParserCompiler</class-id> <category>actions-syntax</category><body package="AT Parser Compiler">action =	$[	codeRest	| #&lt; [self sourceBegin]	| #&gt; [self sourceEnd]	| #&lt;&lt; [self sourcePush]	| #&gt;&gt; [self sourcePopEnd]	| #? [self popTest]	| $. [self popNoTest]</body><body package="AT Parser Compiler">codeRest = 	$: [self beginFragment] message $]	| [beginFragmentWith: 'self'] messageToSelf $]	| . smalltalkBlock</body><body package="AT Parser Compiler">constValue = 	(number | string | character) [:storeString]	| $# (string ['#', stack removeLast storeString]		| literalConstant [:storeString])	| constWord</body><body package="AT Parser Compiler">constWord	"Recognize a word denoting a constant 	(nil/true/false/self/capitalized variable)."	^(tokenType == #word and: [(#('nil' 'true' 'false' 'self' ) includes: token)			or: [((LocalScope forClass: class)					variableAt: token from: nil) ~~ nil ]])		ifTrue: 			[stack addLast: token.			self scanToken.			true]		ifFalse: [false]</body><body package="AT Parser Compiler">literalConstant = 	word [:asSymbol]	| binary	| keywords [:asSymbol]	| $( ( $# literalConstant		| number		| string		| character		| literalConstant)* $)	| $[ number * $] [| bytes |					bytes := (ByteArray new: stack last size) writeStream.					stack removeLast do:						[:i | bytes nextPut: i].					bytes contents]	| $| [#|]  "special hack for | used as binary"</body><body package="AT Parser Compiler">message = 	(	word [:add:value: '']		| binary messageArg		| (keyword messageArg)+!	)	[:contents]</body><body package="AT Parser Compiler">messageArg =	constValue [:add:value:]	| varWord [:add:value:]	| undeclaredVarWord [:add:value:]	| [:add:from: self]</body><body package="AT Parser Compiler">messageToSelf = 	(	binary messageArg		| (keyword messageArg)+!	)	[:contents]</body><body package="AT Parser Compiler">undeclaredVarWord	"Recognize a word denoting a known	(local/temp/instance) variable."	| var binding node |	tokenType == #word ifFalse: [^false].	var := (LocalScope forClass: class) undeclared: token from: nil.	binding := var binding.	node := VariableNode new name: token; sourcePosition: mark.	self errorHandler error: #undeclared with: binding in: node from: nil.	stack addLast: token.	self scanToken.	^true</body><body package="AT Parser Compiler">varWord	"Recognize a word denoting a known	(local/temp/instance) variable."	^(tokenType == #word and: [vars includes: token])		ifTrue: [stack addLast: token.				self scanToken.				true]		ifFalse: [false]</body></methods><methods><class-id>Kernel.ParserCompiler</class-id> <category>actions-code generation</category><body package="AT Parser Compiler">beginFragment	^PushFragment new add: '' from: self</body><body package="AT Parser Compiler">beginFragmentWith: receiver	^PushFragment new add: '' value: receiver</body><body package="AT Parser Compiler">makeTemp	"Make a temporary variable"	| c |	"Use the current size of the temp string as a unique temp id"	c := 'c', temps size printString.	temps := temps, (c, ' ').	^c</body><body package="AT Parser Compiler">popNoTest	^RecognizerFragment		action: ' stack removeLast. '</body><body package="AT Parser Compiler">popTest	^RecognizerFragment		name: nil		test: 'stack removeLast'</body><body package="AT Parser Compiler">smalltalkBlock	| parser src2 parseNode result |	src2 := source copy.	src2 position: mark - 1.	[(src2 skip: -1; peek) = $[ ] whileFalse.	parser := Parser new		init: src2		notifying: self errorHandler		saveComments: saveComments		failBlock: failBlock;		setBuilder: ProgramNodeBuilder new;		blockExpression;		yourself.	parseNode := parser instVarAt: 16.	result := (String new: 20) writeStream.	parseNode isComplex		ifTrue: [parseNode printOn: result indent: 0.				result nextPutAll: ' value']		ifFalse: [parseNode body printOn: result indent: 0].	stack addLast: (PushFragment setup: '' parts: (Array with: result contents)) contents.	self sourcePosition: parser endOfLastToken.	^true</body><body package="AT Parser Compiler">sourceBegin	| sname |	sname := self sourceSaveName.	self sourceSaved		ifFalse:			[temps := (' ', sname), temps].	^RecognizerFragment action: sname, ' := mark. '</body><body package="AT Parser Compiler">sourceEnd	self sourceSaved		ifFalse: [self error: '&gt; without previous &lt;'].	^RecognizerFragment		action: 'stack last sourcePosition: (', self sourceSaveName, ' to: mark). '</body><body package="AT Parser Compiler">sourcePopEnd	| c |	c := self makeTemp.	^RecognizerFragment		action: c, ' := stack removeLast. ', c, ' sourcePosition: (stack last to: mark). self replaceStackTop: ', c, '. '</body><body package="AT Parser Compiler">sourcePush	^RecognizerFragment action: 'stack addLast: mark. '</body><body package="AT Parser Compiler">sourceSaved	"Return true if we have already generated a temp	for saving the source position."	| sname |	sname := self sourceSaveName.	^temps size &gt; sname size and: [(temps copyFrom: 2 to: sname size + 1) = sname]</body><body package="AT Parser Compiler">sourceSaveName	^'sourceStart'</body></methods><methods><class-id>Kernel.ParserCompiler</class-id> <category>private</category><body package="AT Parser Compiler">errorHandler 	^requestor == nil		ifTrue: [NonInteractiveCompilerErrorHandler new				class: class;				source: nil]		ifFalse: [InteractiveCompilerErrorHandler new				editor: requestor;				retryBlock: retryBlock;				failBlock: failBlock]</body></methods><methods><class-id>Kernel.ParserCompiler class</class-id> <category>initialization</category><body package="AT Parser Compiler">initialize	"Tell the GeneralParser that the the ParserCompiler is ready	 to be used (needed for bootstrapping)"	ParserCompilerInstalled := true.</body></methods><methods><class-id>Kernel.ParserCompiler class</class-id> <category>accessing</category><body package="AT Parser Compiler">methodInfo	"Override standard message to avoid bootstrap circularity."	| dict |	methodInfo isNil ifFalse: [^methodInfo].	dict := Dictionary new.	'#' do: [:char | dict at: char put:		('ascii', (char asInteger printStringRadix: 8)) asSymbol].	methodInfo := Dictionary new.	methodInfo at: #initScanner put:		(Array with: Set new with: dict with: true).	^methodInfo</body><body package="AT Parser Compiler">showSmalltalkSource: boolean	"Set whether this class should present all methods	 as Smalltalk source code"	showSourceAsSmalltalk := boolean</body></methods><methods><class-id>Kernel.ParserCompiler class</class-id> <category>accessing method dictionary</category><body package="AT Parser Compiler">grammarExpressionMethods	"Answer a set of method selectors for all methods in this class	 which are grammar expressions"	^methodDict keys select:		[:sel |		self isGrammarExpression: (methodDict at: sel) getSource]</body><body package="AT Parser Compiler">sourceCodeForMethod: method at: messageSelector 	"intercept to possibly convert grammar expressions into Smalltalk"	| source |	source := super sourceCodeForMethod: method at: messageSelector.	(showSourceAsSmalltalk notNil and: [showSourceAsSmalltalk			and: [self isGrammarExpression: source]])		ifTrue: [^(self compilerClass new					parse: source					in: self					notifying: nil) node printString]		ifFalse: [^source]</body></methods><methods><class-id>Kernel.ParserCompiler class</class-id> <category>fileIn/Out</category><body package="AT Parser Compiler">fileOutSourceOn: aSourceFileManager	"Intercept to allow bootstrap of the ParserCompiler	 from the fileOut.  This is not necessary when writing a new	system source file."	aSourceFileManager willUpdateSourcePointers		ifTrue: [super fileOutSourceOn: aSourceFileManager]		ifFalse:			[self showSmalltalkSource: true.			super fileOutSourceOn: aSourceFileManager.			self showSmalltalkSource: false.			aSourceFileManager					fileOutMessages: self grammarExpressionMethods					for: self]</body></methods><methods><class-id>Kernel.ParserCompiler class</class-id> <category>documentation</category><body package="AT Parser Compiler">documentation0"The purpose of the ParserCompiler is to make it a lot easier to write compilers in Smalltalk.Compilers can generally be divided into a number of phases:	scanning - breaking up the source code into tokens -- words, numbers, operators, etc.;	parsing - combining tokens into larger and larger structured units;	semantic analysis - checking that variables have been declared, type checking, etc.; and	code generation - actually producing a compiled program (perhaps in several phases if optimization or more than one representation of the output code is involved).If you use the ParserCompiler, here is what you get as the framework for these various activities:	scanning - the Smalltalk Scanner, slightly modified.  Details are in documentation1.	parsing - you get to write your own in a fairly nice language.  This is the main thing that the ParserCompiler provides.  Details are in documentation2.	semantic analysis - the ParserCompiler makes it fairly easy to mix in semantics during parsing.  This is a good way to do it, when possible, because it makes it easy to generate an error message and have it point at the right place in the source code.  Details are in documentation3.	code generation - you're on your own.  The ParserCompiler itself demonstrates one style of code generation: it generates Smalltalk source code during parsing.  Most languages aren't as simple as the parsing language that the ParserCompiler supports, and can't do code generation interleaved with parsing."</body><body package="AT Parser Compiler">documentation1"The scanner defines 7 standard types of token:	- word (variable or unary message name)	- number (integer or floating point)	- character (like $X)	- string	- binary (infix operators like + or &gt;=)	- keyword (word followed by :) -- see below	- signedNumber (number optionally preceded by a -, with no intervening delimiters)There is an 8th standard token type, keywords, which means one or more keywords in succession with no intervening delimiters: this produces a single token.  Keywords are only recognized specially if your grammar uses the word keyword or keywords, or if your grammar includes any literal keywords.  (This is for the benefit of grammars that don't use keywords, but use : for other purposes.)In addition, the scanner has fixed ideas about delimiters (blank, tab, end-of-line, and new-page, which separate tokens but aren't tokens themselves), and also knows that certain characters are tokens on their own (specifically, #()|[]:=^; and .).  If you want to change any of this, you have to understand how the Scanner works, and you have to write your own initScanner method that calls 'super initScanner' and then patches up the appropriate entries in the typeTable."</body><body package="AT Parser Compiler">documentation2"The way the ParserCompiler works is that you make your compiler a subclass of GeneralParser, which in turn is a subclass of Scanner.  This does two things: it gives you access to the scanning machinery, and it also arranges things so that you can write special parsing methods which recognize syntactic constructs in the source stream.  These special methods have the form	constructName = constructDescriptionThe ParserCompiler expands these methods into Smalltalk code, and then hands them to the Smalltalk compiler: if you decompile a method of this sort, you will see the Smalltalk code.A parsing method basically looks at the source stream, possibly advancing it and reading some new tokens, and returns true if it found the construct it was expecting.  The parsing framework reads one token ahead, but has no default provision for backing up, so you have to be a little careful about how you write the grammar.  For example, the definition	foo = fie fum | fie feewon't work if fie is anything other than a literal token.  You should write	foo = fie (fum | fee)instead.  Alternatively, you could write	foo = @ fie fum | fie feewhich will back up if the first alternative fails, but then you lose some error checking as described below.Here is a simplified version of the grammar for parsing methods, written in itself.  It is enough like BNF that you should have no trouble reading it.  The comments in {} are not part of the actual grammar.	method = pattern #= temporaries definition	pattern = word | (keyword word)+	temporaries = $| word* $| |	definition = alternative ($| alternative)*	alternative = ($@ | ) term* {@ means allow backing up on failure}	term = unit		((#* | #*!) {0 or more repetitions}		| (#+ | #+!) {1 or more repetitions}		| (#\ | #\!) unit {a \ b means a (b a)*} | )	unit = word {subconstruct} | character		| $# (word | keyword | binary | string) {reserved word}		| $( definition $)The repetition constructs with the ! only affect how the stack is treated -- see the next section of the documentation.  Note that if you write a literal character as a unit, the scanner gets told to treat that character specially (as a 1-character token with its own token type).  Note also that there is a special hack (to accommodate a hack in the Smalltalk language) that allows you to write #|, which is equivalent to $|.Any word or keyword mentioned literally in a unit gets its own token type, i.e. it won't be recognized as a plain word or keyword.  (This doesn't apply to binary operators.)  If you don't want this to happen, i.e. you still want the word or keyword recognized by 'word' or 'keyword' if it occurs in another context in the input, you can write	word=#fooor	keyword=#foo:instead of just	#fooor	#foo:The construct #string (e.g. #'&lt;&lt;=') is an escape hatch for languages whose lexical syntax differs from that of Smalltalk.  It is equivalent to #binary (e.g. #&lt;&lt;=) except that Smalltalk lexical syntax prevents one from writing the latter.Because parsers normally doesn't allow backing up, they provide somewhat informative default error messages for syntax errors, indicating what kind of token was expected next in the input.  If you choose to allow backing up by using the @ construct, you lose this feature: any failure anywhere in the alternative marked with @ will cause backup, and no error message will be produced.  Thus, for example, if you write	foo = @ fie fum | fie feeand supply input consisting of a legal fie followed by a faulty fum, the first alternative will fail and back up, and the parser will try to parse the text following the fie as a fee.  On the other hand,	foo = fie (fum | fee)will produce an error message if the failure occurs partway through the fum.Note that although arguments and temporary variables are allowed in syntax equations, you can't call a syntax method with arguments as conveniently as one with none: instead of just saying	fooyou have to say	[foo: arg] ?as described in the next section of documentation."</body><body package="AT Parser Compiler">documentation3"Besides recognizing source constructs, you can write semantic actions mixed in with parsing.  Semantic actions have the following overall structure:	- Pop some arguments (0 or more) from the stack of already-recognized constructs that is part of the parsing framework (the stack instance variable of GeneralParser).	- Send a message to the compiler or another object, where the receiver and each argument may be a global variable, compiler class variable, compiler instance variable, local (argument or temporary) variable, constant, or an argument just popped from the stack.	- Take the result and push it on the stackTo be able to use the stack effectively, you have to know how parsing and semantic constructs affect it.	- When a literal token is recognized (i.e. an explicit character, word, keyword, or binary), nothing happens to the stack.	- When a non-literal token is recognized (i.e. word, character, number, string, binary, or keyword), the token is pushed on the stack (a string in the case of a word, string, or keyword; the character in the case of a character; the number in the case of a number; and a symbol in the case of a binary operator.)	- The *, +, and \ constructs take all the stack entries added as a result of the repetitive construct, make them into an array, and push it back on the stack, e.g. if the source stream contains 'alpha beta gamma' and the construct being recognized is word* or word+, the effect is to push the array #('alpha' 'beta' 'gamma') on the stack.  If you don't want this to happen, use *!, +!, or \! respectively instead.	- Semantic actions affect the stack as indicated just above.  Note that semantic actions, being written in Smalltalk, can do anything to the stack or input stream that they want, but this is generally not advisable.There are essentially two forms of semantic block that are recognized;in both cases, the action is enclosed in square braces, just like a Smalltalkliteral block.One type of action is to write a standard Smalltalk expression.  The blockmay contain any clauses that are legal in a Smalltalk block with no arguments,such as:	[| count |	count := 4.	stack removeLast: count]which pops the last four elements off the stack, changes them to an Array,and pushes them on the stack.The other form of semantic action allows common actions to be abbreviated.In this form, the block is parsed as follows:- only one message can be sent- the message must be either binary or keyword type- the receiver may be	- empty, which is interpreted as 'self'	- a single :, which is interpreted as popping the top element off the	    stack and using it as the receiver- arguments may be	- empty, which is interpreted as popping the top element off the stack	- a Smalltalk constant	- a recognized variable nameThis does not permit an argument of the message to be the result of anothermessage send.In this form, the stack is popped while parsing the code right to left, ratherthan left to right.  Thus, the following expression:	[Array] word word [: with: with:]would be equivalent to the more verbose:	[Array] word word [| t1 t2 |						t1 := stack removeLast.						t2 := stack removeLast.						stack removeLast with: t2 with: t1]Semantic blocks are intended to fill three roles:- to push a value on the stack	This happens automatically, by virtue of the definition of a block	in the ParserCompiler.- to make a test as to whether the current parsing phase is successful	The special action		?	pops the top value off the stack.  If this value is true, parsing is	successful; if false, alternate choices in the parse rule are attempted- to cause an effect	The special action		.	(the period) pops the top value off the stack and discards it.There are special semantic actions provided for the benefit of compilers that want to record the range of source characters that constructs occupy. The special action	&lt;records the current source position in a temporary variable of the current method, named sourceStart. The special action	&gt;tells the top element of the stack what range of characters has been scanned since the last &lt;, by sending the message	stack last sourcePosition: (sourceStart to: mark).Note that &lt; and &gt; do not nest, because the source position is saved in a variable, not on the stack. The special actions &lt;&lt; and &gt;&gt; are equivalent actions that use the stack, i.e.	&lt;&lt;pushes the current source position on the stack, and	&gt;&gt;has the effect of	| node |	node := stack removeLast.	node sourcePosition: (stack removeLast to: mark).	stack addLast: nodei.e. it assumes that the saved source postion is on the stack just below the top, and pops it off.  Of course, you can also write code that references mark by name, since it is an instance variable of the compiler framework.At this point you should go read all the syntax methods in class ParserCompiler.  This will give you the full story on the grammar recognized by the ParserCompiler."</body><body package="AT Parser Compiler">documentation4"The way you actually write programs in your new language is to define a compiler class MyLanguageCompiler, then define a dummy class MyLanguage, and to include the following method in MyLanguage class (*not* in MyLanguage itself):	compilerClass		^MyLanguageCompilerThen any methods defined in class MyLanguage or any of its subclasses will compile with MyLanguageCompiler rather than the standard Smalltalk compiler.The final step in code generation is done by the message generate:.  This message is defined in GeneralParser on the assumption that the output of your compiler (i.e. the single element left on the stack at the end of recognizing a method) is a string which is actually a Smalltalk source method, which then gets handed to the Smalltalk compiler.  However, you can override this message in your own compiler to do something different if you want.  It should return a selector if the code generation succeeds, or nil if it fails."</body></methods><methods><class-id>Kernel.RecognizerFragment</class-id> <category>accessing</category><body package="AT Parser Compiler">action	^action</body><body package="AT Parser Compiler">code	^action , test</body><body package="AT Parser Compiler">name	^name</body><body package="AT Parser Compiler">nameString	^name isNil ifTrue: ['(something)'] ifFalse: [name]</body><body package="AT Parser Compiler">test	^test</body></methods><methods><class-id>Kernel.RecognizerFragment</class-id> <category>printing</category><body package="AT Parser Compiler">printOn: aStream	aStream nextPutAll: '(RecognizerFragment name: ';		store: name;		nextPutAll: ' action: ';		store: action;		nextPutAll: ' test: ';		store: test;		nextPut: $)</body></methods><methods><class-id>Kernel.RecognizerFragment</class-id> <category>private</category><body package="AT Parser Compiler">name: nameString action: actionString test: testString	name := nameString.	action := actionString.	test := testString</body></methods><methods><class-id>Kernel.RecognizerFragment class</class-id> <category>instance creation</category><body package="AT Parser Compiler">action: actionString	^super new name: nil action: actionString test: 'true'</body><body package="AT Parser Compiler">empty	^super new name: nil action: '' test: 'true'</body><body package="AT Parser Compiler">name: nameString action: actionString test: testString	^super new name: nameString action: actionString test: testString</body><body package="AT Parser Compiler">name: nameString test: testString	^super new name: nameString action: '' test: testString</body></methods><methods><class-id>Kernel.ExternalLanguageParser</class-id> <category>formatting</category><body package="AT Parser Compiler">format: sourceCode in: aClass notifying: aRequestor	| text |	text := self subFormat: sourceCode in: aClass notifying: aRequestor.	text == nil ifTrue: [^super format: sourceCode in: aClass notifying: aRequestor].	^text asText</body><body package="AT Parser Compiler">subFormat: sourceCode in: aClass notifying: aRequestor	"Format the source code if possible.	If not, return nil and let the default compiler do it."	^nil</body></methods><methods><class-id>Kernel.ExternalLanguageParser</class-id> <category>code generation</category><body package="AT Parser Compiler">generate: anAssociation 	"Construct a CompiledMethod which 	simply returns anObject."	| ret builder codeStream methodNode method holder |	builder := ProgramNodeBuilder new.	ret := builder newReturnValue: (builder newLiteralValue: (self subGenerate: anAssociation value)).	methodNode := builder				newMethodSelector: anAssociation key asSymbol				arguments: #()				temporaries: #()				statements: (Array with: ret).	(BlockAnalyzer new analyze: methodNode inClass: targetClass context: nil)		storeHintsForStandardSmalltalk.	codeStream := HintedCodeStream new.	codeStream class: targetClass outerScope: NullScope new; requestor: nil.	methodNode emitEffect: codeStream.	method := codeStream makeMethod: methodNode.	holder := MethodNodeHolder new.	holder node: methodNode.	holder method: method.	^holder</body><body package="AT Parser Compiler">subGenerate: anObject	"anObject is the result of parsing.	Return the object that will be stored	in the CompiledMethod.  By default,	this is anObject itself, but subclasses	may want to condense it in some way."	^anObject</body></methods><initialize><class-id>Kernel.ParserCompiler</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Scanner</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>source mark prevEnd hereChar token tokenType saveComments currentComment buffer typeTable </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Public Access</category><attributes><package>System-Compiler-Public Access</package></attributes></class></st-source>