<?xml version="1.0"?><st-source><!-- Name: AT BenchmarksNotice: Copyright 2002-2014 Cincom Systems, Inc.  All rights reserved.Comment: Contains the Benchmark framework, which enables you to create and run benchmarks for your application across versions in various operating environments.As an example, we have provided class SystemBenchmark which contains the historic benchmarking test suite that ParcPlace has used to compare system performance on different platforms.See the "Advanced Tools User's Guide" for more information.DbIdentifier: bear73DbTrace: 422872DbUsername: ablakeyDbVersion: 8.0 - 1DevelopmentPrerequisites: #(#(#any 'AT Menu Support' ''))PackageName: AT BenchmarksParcel: #('AT Benchmarks')ParcelName: AT BenchmarksPrerequisiteDescriptions: #(#(#name 'AT Menu Support' #componentType #package))PrerequisiteParcels: #(#('AT Menu Support' ''))PrintStringCache: (8.0 - 1,ablakey)Version: 8.0 - 1Pre-Unload Block: 	[:pkg| Benchmark preUnloadFor: pkg ]Date: 10:35:47 AM February 28, 2014 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.0 (feb14.4) of February 28, 2014 on February 28, 2014 at 10:35:47 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>Benchmark</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>benchmarksToDo perItemStatisticsToDoHolder overallStatisticsToDoHolder transcript iterationsHolder outputFilenameHolder reportStream reportOnTranscriptHolder reportOnFileHolder reportRawMeasurementsHolder reportIndividualStatisticsHolder reportOverallStatisticsHolder benchmarkMeasurements runMeasurements measureRatesHolder benchmarkSelectorsHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AT-Benchmarks</category><attributes><package>AT Benchmarks</package></attributes></class><comment><class-id>Tools.Benchmark</class-id><body>Class Benchmark contains facilities for measuring the performance of benchmarks.  Subclasses are responsible for implementing the benchmarks of interest; class Benchmark provides the framework for running the benchmarks, collecting data over multiple iterations, and analyzing and reporting the results.Benchmarks implemented in subclasses should do whatever preparatory work is necessary, then send	self test: aBlock labeled: aLabel repeated: howManyTimes.or	self testDisplayOperation: aBlock labeled: aLabel repeated: howManyTimes.to execute aBlock howManyTimes and report the results (if reporting of raw measurements is enabled), using aLabel for ease of identification.  The latter choice (#testDisplayOperation:...) should be used when the benchmark displays graphics, since accurate benchmarking in that case requires that graphics output be flushed and synchronized at the appropriate time.Three different reports can be generated:	* raw benchmark measurements	* statistics (minimum, maximum, arithmetic mean, and median) of the results for an individual benchmark over multiple iterations	* statistics (minimum, maximum, arithmetic mean, harmonic mean, and median) of the weighted results of an entire benchmark suite over multiple iterationsAn interactive dialog that allows editing of benchmark parameters can be created by sending the #open message to a subclass instance, e.g.	SystemBenchmark open.Subclasses must implement the following messages:	accessing		benchmarkLabelForSelector:		benchmarkSelectors		initiallySelectedBenchmarksSubclasses may also wish to override some of the methods in the 'defaults' and 'weighting' protocols.  By default, the benchmarks measure elapsed time during the execution of the tests.  Subclasses wishing to measure other things should override:	accessing		measurementsName	weighting		scale	testing		measure:	private		reportStringMeasuredAt:repeatedInstance Variables:	benchmarkSelectorsHolder	&lt;MultiSelectionInList&gt;										"multi-select list for picking benchmarks."	benchmarksToDo		&lt;SequenceableCollection of: Symbol&gt;										"list of selected benchmarks to run"	perItemStatisticsToDoHolder		&lt;ValueHolder on: SequenceableCollection of: Symbol&gt;										"list of statistics to report for each benchmark (#Minimum, #Maximum, #Mean, #Median)"	overallStatisticsToDoHolder		&lt;ValueHolder on: SequenceableCollection of: Symbol&gt;										"list of statistics to report for the overall performance of the benchmark suite"	measureRatesHolder			&lt;ValueHolder on: Boolean&gt;	"whether to measure rates rather than times"	iterationsHolder				&lt;ValueHolder on: Integer&gt;	"number of times to run each benchmark in the suite"	transcript				&lt;TextCollector&gt;	"where to write benchmark transcript output"	outputFilenameHolder			&lt;ValueHolder on: String&gt;		"name of file on which to write reports"	reportStream				&lt;ExternalStream&gt;										"file stream on which to write reports"	reportOnTranscriptHolder		&lt;ValueHolder on: Boolean&gt;	"whether to write a report on the benchmark transcript"	reportOnFileHolder				&lt;ValueHolder on: Boolean&gt;	"whether to write a report on the output file"	reportRawMeasurementsHolder	&lt;ValueHolder on: Boolean&gt;	"whether to report the raw benchmark measurements"	reportIndividualStatisticsHolder	&lt;ValueHolder on: Boolean&gt;	"whether to report individual benchmark statistics"	reportOverallStatisticsHolder	&lt;ValueHolder on: Boolean&gt;	"whether to report overall statistics"	benchmarkMeasurements		&lt;OrderedCollection of: Number&gt;										"benchmark measurements for current run"	runMeasurements		&lt;OrderedCollection of: (OrderedCollection of: Number)&gt;											"benchmark measurements for all the iterations of the current run"</body></comment><class><name>BenchDecompilerTestClass</name><environment>Tools</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AT-Benchmarks</category><attributes><package>AT Benchmarks</package></attributes></class><comment><class-id>Tools.BenchDecompilerTestClass</class-id><body>The methods in class BenchDecompilerTestClass are used for decompilation by the SystemBenchmark testDecompiler benchmark.  They consist of the methods in InputSensor for ObjectWorks for Smalltalk-80(r) version 2.5.  Note that the code in this class is invalid for the current Smalltalk system and will never actually be executed: it exists only to be decompiled by the testDecompiler benchmark.Class Variables:	CurrentCursor	&lt;Object&gt;	"used by the 2.5 InputSensor code"	CurrentInputState	&lt;Object&gt;	"used by the 2.5 InputSensor code"</body></comment><class><name>SystemBenchmark</name><environment>Tools</environment><super>Tools.Benchmark</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dummy </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AT-Benchmarks</category><attributes><package>AT Benchmarks</package></attributes></class><comment><class-id>Tools.SystemBenchmark</class-id><body>Class SystemBenchmark contains benchmarks for profiling the performance of Smalltalk-80 systems.There are built-in methods for timing certain activities that occur frequently in using the Smalltalk-80 system.  There are also facilities for timing the execution of most byte codes.Try an example.  To time your system's performance of simple addition, say	SystemBenchmark new test3plus4or to time pushing an instance variable onto the stack, say	SystemBenchmark new testLoadInstVar.If you had wished to print the results on a file, you could have said	(SystemBenchmark new		outputFilename: 'Smalltalk.timing';		selectedBenchmarks: #(#testLoadInstVar);		reportRawTimes: true;		reportOnFile: true) run.You can run the standard benchmark suite by saying	SystemBenchmark new run.You can also bring up an interactive dialog that allows you to set report and run parameters.  To do so, say	SystemBenchmark open.The message category "macro operations" contains methods for timing more involved activities such as compiling, decompiling, editing text, formatting text, etc.Instance Variables:	dummy	&lt;Object&gt;	"used by benchmarks that time stores into an instance variable"Class Variables:	AvailableBenchmarks	&lt;OrderedCollection of: Symbol&gt;	"specifies the available benchmarks, in order of presentation"	BenchmarkLabels	&lt;Dictionary key: Symbol value: String&gt;	"specifies the report labels (the values) to be used for the benchmarks (the keys)"	DoradoBenchmarkTimes	&lt;Dictionary key: Symbol value: Number&gt;	"specifies the times (the values) required to run the benchmarks (the keys) on the Xerox Dorado, the standard Smalltalk-80 machine"	InitiallySelectedBenchmarks	&lt;Set of: Symbol&gt;	"specifies the default set of benchmarks to be run as a suite"	</body></comment><class><name>BenchmarkRunner</name><environment>Tools</environment><super>Tools.SystemBenchmark</super><private>false</private><indexed-type>none</indexed-type><inst-vars>profiler helpText </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AT-Benchmarks</category><attributes><package>AT Benchmarks</package></attributes></class><comment><class-id>Tools.BenchmarkRunner</class-id><body>BenchmarkRunner is a specialized type of SystemBenchmark that allows one to run any of the various system profilers (if they are in the system) over the selected benchmarks.Instance Variables:	profiler	&lt;Profiler|nil&gt;	The profiler to use on the benchmarks being run	helpText &lt;ValueHolder on: String&gt; Text to describe what the BenchmarkRunner does</body></comment><class><name>BenchmarkTable</name><environment>Tools</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name columnLabels rows significantDigits </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AT-Benchmarks</category><attributes><package>AT Benchmarks</package></attributes></class><comment><class-id>Tools.BenchmarkTable</class-id><body>I represent a two-dimensional table with restricted protocol appropriate forpresenting benchmark results.Instance Variables:	name			&lt;String&gt;			"name of table, used to create the report title"	columnLabels	&lt;SequenceableCollection of: CharacterArray&gt;									"labels for the columns of the report"	rows			&lt;OrderedCollection of: SequenceableCollection&gt;									"data, ordered by rows"	significantDigits	&lt;Integer | nil&gt;	"number of significant digits to print; nilmeans no rounding"</body></comment><shared-variable><name>NonIOMacroBenchmarks</name><environment>Tools.SystemBenchmark</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>AT Benchmarks</package></attributes></shared-variable><shared-variable><name>BenchmarkLabels</name><environment>Tools.SystemBenchmark</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>AT Benchmarks</package></attributes></shared-variable><shared-variable><name>AvailableBenchmarks</name><environment>Tools.SystemBenchmark</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>AT Benchmarks</package></attributes></shared-variable><shared-variable><name>InitiallySelectedBenchmarks</name><environment>Tools.SystemBenchmark</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>AT Benchmarks</package></attributes></shared-variable><shared-variable><name>DoradoBenchmarkTimes</name><environment>Tools.SystemBenchmark</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>AT Benchmarks</package></attributes></shared-variable><shared-variable><name>CurrentInputState</name><environment>Tools.BenchDecompilerTestClass</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>AT Benchmarks</package></attributes></shared-variable><shared-variable><name>CurrentCursor</name><environment>Tools.BenchDecompilerTestClass</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>AT Benchmarks</package></attributes></shared-variable><methods><class-id>Tools.Benchmark</class-id> <category>aspects</category><body package="AT Benchmarks">benchmarkSelectorsHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^benchmarkSelectorsHolder isNil		ifTrue:			[benchmarkSelectorsHolder := MultiSelectionInList new]		ifFalse:			[benchmarkSelectorsHolder]</body><body package="AT Benchmarks">benchmarkTranscript	| view |	view := TextCollectorView model: self transcript.	view textStyle: (TextAttributes styleNamed: #fixed).	^LookPreferences edgeDecorator on: view</body><body package="AT Benchmarks">iterationsHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^iterationsHolder isNil		ifTrue:			[iterationsHolder := 0 asValue]		ifFalse:			[iterationsHolder]</body><body package="AT Benchmarks">measureRatesHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^measureRatesHolder isNil		ifTrue:			[measureRatesHolder := nil asValue]		ifFalse:			[measureRatesHolder]</body><body package="AT Benchmarks">outputFilenameHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^outputFilenameHolder isNil		ifTrue:			[outputFilenameHolder := Text new asValue]		ifFalse:			[outputFilenameHolder]</body><body package="AT Benchmarks">overallStatisticsToDoHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^overallStatisticsToDoHolder isNil		ifTrue:			[overallStatisticsToDoHolder := false asValue]		ifFalse:			[overallStatisticsToDoHolder]</body><body package="AT Benchmarks">perItemStatisticsToDoHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^perItemStatisticsToDoHolder isNil		ifTrue:			[perItemStatisticsToDoHolder := false asValue]		ifFalse:			[perItemStatisticsToDoHolder]</body><body package="AT Benchmarks">reportIndividualStatisticsHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^reportIndividualStatisticsHolder isNil		ifTrue:			[reportIndividualStatisticsHolder := false asValue]		ifFalse:			[reportIndividualStatisticsHolder]</body><body package="AT Benchmarks">reportOnFileHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^reportOnFileHolder isNil		ifTrue:			[reportOnFileHolder := false asValue]		ifFalse:			[reportOnFileHolder]</body><body package="AT Benchmarks">reportOnTranscriptHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^reportOnTranscriptHolder isNil		ifTrue:			[reportOnTranscriptHolder := false asValue]		ifFalse:			[reportOnTranscriptHolder]</body><body package="AT Benchmarks">reportOverallStatisticsHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^reportOverallStatisticsHolder isNil		ifTrue:			[reportOverallStatisticsHolder := false asValue]		ifFalse:			[reportOverallStatisticsHolder]</body><body package="AT Benchmarks">reportRawMeasurementsHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^reportRawMeasurementsHolder isNil		ifTrue:			[reportRawMeasurementsHolder := false asValue]		ifFalse:			[reportRawMeasurementsHolder]</body></methods><methods><class-id>Tools.Benchmark</class-id> <category>selecting</category><body package="AT Benchmarks">benchmarkSelectionMenu	"Answer the menu for benchmark selection."	^Menu		labelArray: (Array				with: (#selectAll &lt;&lt; #advanced &gt;&gt; 'select all')				with: (#clearSelections &lt;&lt; #advanced &gt;&gt; 'clear selections')				with: (#resetToDefault &lt;&lt; #advanced &gt;&gt; 'reset to default'))		values: #(#selectAllBenchmarks #deselectAllBenchmarks #resetToDefaultBenchmarks)</body><body package="AT Benchmarks">deselectAllBenchmarks	"Deselect all benchmarks."	self selectedBenchmarks: #()</body><body package="AT Benchmarks">resetToDefaultBenchmarks	"Revert selected benchmarks to the default set."	self selectedBenchmarks: self initiallySelectedBenchmarks</body><body package="AT Benchmarks">selectAllBenchmarks	"Select all the available benchmarks."	self selectedBenchmarks: self benchmarkSelectors</body></methods><methods><class-id>Tools.Benchmark</class-id> <category>defaults</category><body package="AT Benchmarks">defaultIterations	"Answer the default number of iterations per run."	^3</body><body package="AT Benchmarks">defaultMeasureRate	"Answer whether to measure rates by default."	^false</body><body package="AT Benchmarks">defaultOutputFilename	"Answer the default output filename."	^''</body><body package="AT Benchmarks">initiallySelectedOverallStatistics	"Answer a list of the overall statistics to be initially selected."	^#(#Mean)</body><body package="AT Benchmarks">initiallySelectedPerItemStatistics	"Answer a list of the per-item statistics to be initially selected."	^#(#Minimum #Maximum #Median)</body></methods><methods><class-id>Tools.Benchmark</class-id> <category>weighting</category><body package="AT Benchmarks">convert: measurement toRateFor: benchmarkSelector	"Convert a measurement to a rate for the	specified benchmark.  Answer the result."	^1.0 / (measurement max: 1.0e-6)</body><body package="AT Benchmarks">scale	"Answer an amount to scale each individual measurement.	All benchmark measurements are scaled in the same way."	"By default, measurements are in milliseconds.  Scale them to	be in seconds.  Subclasses may wish to override."	^0.001</body><body package="AT Benchmarks">weightFor: benchmarkSelector	"Answer the weight the specified benchmark when calculating overall	averages."	^1</body></methods><methods><class-id>Tools.Benchmark</class-id> <category>accessing-subclassResponsibility</category><body package="AT Benchmarks">benchmarkLabelForSelector: benchmarkSelector	"Answer the label to be used for the benchmark	represented by benchmarkSelector."	^self subclassResponsibility</body><body package="AT Benchmarks">benchmarkSelectors	"Answer an ordered list of the benchmark selectors."	^self subclassResponsibility</body><body package="AT Benchmarks">initiallySelectedBenchmarks	"Answer the set of benchmarks to be initially selected."	^self subclassResponsibility</body></methods><methods><class-id>Tools.Benchmark</class-id> <category>accessing</category><body package="AT Benchmarks">iterations	"Answer the number of iterations to run at a time."	^iterationsHolder value</body><body package="AT Benchmarks">iterations: anInteger 	"Set the number of iterations to run at a time."	self iterations = anInteger ifFalse:		[self iterationsHolder value: anInteger.		self changed: #iterations]</body><body package="AT Benchmarks">measureRates	"Answer whether the receiver should measure rates rather than times."	^measureRatesHolder value</body><body package="AT Benchmarks">measureRates: aBoolean	"Set whether the receiver should measure rates rather than times."	self measureRates = aBoolean ifFalse:		[self measureRatesHolder value: aBoolean.		self changed: #measureRates]</body><body package="AT Benchmarks">measurementsName	"Answer a string describing the type of measurements taken"		^self class measurementsName</body><body package="AT Benchmarks">measurementsNameLowercase	"Answer a string describing the type of measurements taken"		^self measurementsName asLowercase</body><body package="AT Benchmarks">name	"Answer a name that identifies the type of benchmarks that I support."	^(#Benchmarks &lt;&lt; #advanced &gt;&gt; 'Benchmarks') asString</body><body package="AT Benchmarks">outputFilename	"Answer the name of the output file."	^outputFilenameHolder value</body><body package="AT Benchmarks">outputFilename: aTextOrString	"Set the output filename to the indicated text or string."	self outputFilename = aTextOrString ifFalse:		[self outputFilenameHolder value: aTextOrString.		self changed: #outputFilename]</body><body package="AT Benchmarks">overallStatisticsToDo	"Answer a list of the overall statistics to do."	^overallStatisticsToDoHolder value</body><body package="AT Benchmarks">overallStatisticsToDo: statisticsList	"Set the list of the overall statistics to do."	self overallStatisticsToDo = statisticsList ifFalse:		[| newList changedAspects |		newList := #(#Minimum #Maximum #Mean #Median)								select: [:elt | statisticsList includes: elt].		changedAspects :=			(self overallStatisticsToDo reject: [:elt | newList includes: elt]),			(newList reject: [:elt | self overallStatisticsToDo includes: elt]).		self overallStatisticsToDoHolder value: newList.		self changed: #overallStatisticsToDo with: changedAspects]</body><body package="AT Benchmarks">perItemStatisticsToDo	"Answer a list of the perItem statistics to do."	^perItemStatisticsToDoHolder value</body><body package="AT Benchmarks">perItemStatisticsToDo: statisticsList	"Set the list of the perItem statistics to do."	self perItemStatisticsToDo = statisticsList ifFalse:		[| newList changedAspects |		newList := #(#Minimum #Maximum #Mean #Median)								select: [:elt | statisticsList includes: elt].		changedAspects :=			(self perItemStatisticsToDo reject: [:elt | newList includes: elt]),			(newList reject: [:elt | self perItemStatisticsToDo includes: elt]).		self perItemStatisticsToDoHolder value: newList.		self changed: #perItemStatisticsToDo with: changedAspects]</body><body package="AT Benchmarks">reportIndividualStatistics	"Answer whether to report individual benchmark statistics."	^reportIndividualStatisticsHolder value</body><body package="AT Benchmarks">reportIndividualStatistics: aBoolean	"Set whether to report individual benchmark statistics."	self reportIndividualStatistics = aBoolean ifFalse:		[self reportIndividualStatisticsHolder value: aBoolean.		self changed: #reportIndividualStatistics]</body><body package="AT Benchmarks">reportOnFile	"Answer whether to write a report on a file."	^reportOnFileHolder value</body><body package="AT Benchmarks">reportOnFile: aBoolean	"Set whether to write a report on a file."	self reportOnFile = aBoolean ifFalse:		[self reportOnFileHolder value: aBoolean.		self changed: #reportOnFile]</body><body package="AT Benchmarks">reportOnTranscript	"Answer whether to write a report on the Transcript."	^reportOnTranscriptHolder value</body><body package="AT Benchmarks">reportOnTranscript: aBoolean	"Set whether to write a report on the Transcript."	self reportOnTranscript = aBoolean ifFalse:		[self reportOnTranscriptHolder value: aBoolean.		self changed: #reportOnTranscript]</body><body package="AT Benchmarks">reportOverallStatistics	"Answer whether to report overall benchmark statistics."	^reportOverallStatisticsHolder value</body><body package="AT Benchmarks">reportOverallStatistics: aBoolean	"Set whether to report overall benchmark statistics."	self reportOverallStatistics = aBoolean ifFalse:		[self reportOverallStatisticsHolder value: aBoolean.		self changed: #reportOverallStatistics]</body><body package="AT Benchmarks">reportRawMeasurements	"Answer whether to report raw benchmark measurements."	^reportRawMeasurementsHolder value</body><body package="AT Benchmarks">reportRawMeasurements: aBoolean	"Set whether to report raw benchmark measurements."	self reportRawMeasurements = aBoolean ifFalse:		[self reportRawMeasurementsHolder value: aBoolean.			self changed: #reportRawMeasurements]</body><body package="AT Benchmarks">selectedBenchmarks	"Answer the benchmarks currently selected to be run."	^self benchmarkSelectorsHolder selections asSet</body><body package="AT Benchmarks">selectedBenchmarks: aCollection	"Set the benchmarks currently selected to be run."	self setSelectedBenchmarks: aCollection.	self changed: #selectedBenchmarks</body><body package="AT Benchmarks">setSelectedBenchmarks	self setSelectedBenchmarks: self benchmarkSelectorsHolder selections</body><body package="AT Benchmarks">setSelectedBenchmarks: aCollection	"Set the benchmarks currently selected to be run.  Don't	inform dependents."	aCollection isSequenceable		ifTrue: [self benchmarkSelectorsHolder selections: aCollection]		ifFalse:			[| availableBenchmarks |			availableBenchmarks := self benchmarkSelectors.			self benchmarkSelectorsHolder selections: ((aCollection collect: [:selector | availableBenchmarks indexOf: selector])				asSortedCollection collect: [:index | availableBenchmarks at: index])]</body><body package="AT Benchmarks">significantDigits	"Answer the number of significant digits to use for floating-point	number output. Nil (default) means that measurements should be	printed using full floating-point precision.  Subclasses	should override if the results are less accurate."	^nil</body><body package="AT Benchmarks">transcript	"Answer the transcript to which my reports are written."	^transcript</body></methods><methods><class-id>Tools.Benchmark</class-id> <category>private</category><body package="AT Benchmarks">beginningOfIteration	"Begin an iteration of the benchmark suite.  Subclasses may extend this."	benchmarkMeasurements := OrderedCollection new</body><body package="AT Benchmarks">beginningOfRun	"Begin a benchmark run.  Subclasses may extend this."	runMeasurements := OrderedCollection new.	self reportOnFile ifTrue:		[| fn |		fn := self outputFilename asFilename.		(fn exists not or: [Dialog confirm: ((#Overwrite1s &lt;&lt; #advanced &gt;&gt; 'Overwrite &lt;1s&gt;?')			expandMacrosWith: fn asString)])			ifTrue: [reportStream := fn writeStream]			ifFalse: [OSErrorHolder existingReferentSignal raise]]</body><body package="AT Benchmarks">changeOverallMeanLabel	"Change to indicate which of harmonic and arithmetic mean we're 	doing"	| button |	button := (builder componentAt: #overallMean) widget.	button labelString: (self measureRates			ifTrue: [#harmonicMean &lt;&lt; #advanced &gt;&gt; 'harmonic mean']			ifFalse: [#arithmeticMean &lt;&lt; #advanced &gt;&gt; 'arithmetic mean']) asString</body><body package="AT Benchmarks">endOfIteration	"Finish an iteration of the benchmark suite.  Subclasses may extend this."	| measurements |	self measureRates		ifTrue:			[measurements := OrderedCollection new.			self benchmarkSelectorsHolder selections with: benchmarkMeasurements do:				[:benchmark :time |				measurements addLast: (self convert: time toRateFor: benchmark)]]		ifFalse: [measurements := benchmarkMeasurements].	runMeasurements addLast: measurements</body><body package="AT Benchmarks">endOfRun	"Finish a benchmark run.  Subclasses may extend this."	self reportOutput: ''.	self reportTitle.	self reportIndividualStatistics		ifTrue:			[self individualBenchmarksReport.			self reportOutput: ''].	self reportOverallStatistics		ifTrue:			[self summaryReport].	self endOutput</body><body package="AT Benchmarks">endOutput	"Flush output."	transcript endEntry.	reportStream notNil ifTrue:		[reportStream close.		reportStream := nil]</body><body package="AT Benchmarks">makeReportRunValues: runValues title: titleString typeLabel: typeLabelrowLabels: labelArray statisticsTypes: statisticsTypeArray	| benchmarkTable lineValues stats |	lineValues := Array new: runValues first size.	1 to: lineValues size do:		[:i | lineValues at: i put: OrderedCollection new].	runValues do:		[:iterationValues |		lineValues with: iterationValues do: [:line :value | line addLast: value]].	stats := statisticsTypeArray collect:				[:type | type == #Mean						ifTrue: [#'A-Mean']						ifFalse: [type]].	benchmarkTable := BenchmarkTable						name: titleString asString						columnLabels: (Array with: typeLabel asString), stats						significantDigits: self significantDigits.	labelArray with: lineValues do:		[:label :line |		self statisticsForRun: line do:			[:min :max :arithmeticMean :harmonicMean :median | | row |			row := OrderedCollection with: label.			(stats includes: #Minimum) ifTrue: [row add: min].			(stats includes: #Maximum) ifTrue: [row add: max].			(stats includes: #'A-Mean') ifTrue: [row add: arithmeticMean].			(stats includes: #Median) ifTrue: [row add: median].			benchmarkTable addRow: row]].	self reportOutput: benchmarkTable</body><body package="AT Benchmarks">reportMeasuredAt: measurement repeated: numberOfTimes	"Do all the reporting, both in the transcript and on the output file or stream."	self reportRawMeasurements		ifTrue: [self reportOutput: (self reportStringMeasuredAt: measurement						repeated: numberOfTimes)].	benchmarkMeasurements addLast: self scale * measurement "save the measurement for comparison"</body><body package="AT Benchmarks">reportOutput: anObject	"Report anObject to my outputs."	| outputString |	outputString := anObject isString					ifTrue: [anObject]					ifFalse: [anObject printString].	self reportOnTranscript ifTrue:		[transcript nextPutAll: outputString; flush].	self reportOnFile ifTrue:		[reportStream nextPutAll: outputString].</body><body package="AT Benchmarks">reportStringMeasuredAt: measurement repeated: numberOfTimes	"Generate the parsible string to represent the measurement of a benchmark."	"Default to a time measurement.  Subclasses may wish to override."	| nTimes unitTime seconds aStream |	aStream := WriteStream on: (String new: 200).	nTimes := numberOfTimes &lt;= 1000				ifTrue: [numberOfTimes]				ifFalse: [numberOfTimes // 1000 * 1000].	seconds := measurement asFloat / 1000.	aStream nextPutAll: (#RepetitionsIn &lt;&lt; #advanced &gt;&gt; '&lt;t&gt;&lt;1p&gt; repetition(s) in&lt;t&gt;&lt;2p&gt; seconds&lt;n&gt;' expandMacrosWith: nTimes with: seconds).	nTimes ~= 1 ifTrue: 		[unitTime := (measurement * 1000) asFloat / nTimes.		aStream nextPutAll: (#MicrosecondsPerRepetition &lt;&lt; #advanced &gt;&gt; '&lt;t&gt;&lt;1p&gt; microseconds per repetition&lt;n&gt;' expandMacrosWith: unitTime)].	^aStream contents</body><body package="AT Benchmarks">reportTitle	| title |	title := self name,			(self measureRates				ifTrue: [(#Rates &lt;&lt; #advanced &gt;&gt; ' (Rates)') asString ]				ifFalse: [ ((#x1s &lt;&lt; #advanced &gt;&gt; ' (&lt;1s&gt;)' )							expandMacrosWith: self measurementsName) ]).	self reportOutput: title.	self reportOutput: (String with: Character cr).	self reportOutput: (String new: title size withAll: $-).	self reportOutput: (String with: Character cr with: Character cr)</body><body package="AT Benchmarks">statisticsForRun: runValues do: aBlock	"Calculate the minimum, maximum, arithmetic mean,	harmonic mean, and median for the specified run of	values, then evaluate aBlock with them as arguments."	| min max sum reciprocalSum sortedRunValues arithmeticMean harmonicMean median statistics |	runValues isEmpty ifTrue: [^aBlock valueWithArguments: #(0 0 0 0 0)].	min := max := runValues first.	sum := reciprocalSum := 0.	runValues do:		[:value |		value &lt; min ifTrue: [min := value].		value &gt; max ifTrue: [max := value].		sum := sum + value.		reciprocalSum := reciprocalSum + (1.0 / (value max: 1.0e-6))].	arithmeticMean := sum asFloat / runValues size.	harmonicMean := runValues size asFloat / reciprocalSum.	sortedRunValues := runValues asSortedCollection.	median := sortedRunValues at: sortedRunValues size + 1 // 2.	statistics := Array new: 5.	statistics		at: 1 put: min;		at: 2 put: max;		at: 3 put: arithmeticMean;		at: 4 put: harmonicMean;		at: 5 put: median.	aBlock valueWithArguments: statistics</body><body package="AT Benchmarks">test: aBlock labeled: label repeated: nTimes using: selector	"Time nTimes iterations of aBlock.  Selector indicates which	test harness (display or normal) to use."	| time |	self reportRawMeasurements		ifTrue: [self reportOutput: ('[&lt;1s&gt;]&lt;n&gt;' expandMacrosWith: label)]		ifFalse: [self reportOnTranscript			ifTrue: [transcript nextPutAll: ('[&lt;1s&gt;]' expandMacrosWith: label); cr; flush]].	Cursor wait showWhile:		[time := self perform: selector with: aBlock with: nTimes].	self		reportMeasuredAt: time		repeated: nTimes</body><body package="AT Benchmarks">test: aBlock labeled: label repeated: nTimes using: selector scaledBy: scale	"Time nTimes iterations of aBlock.  Selector indicates which	test harness (display or normal) to use."	| output time |	output := '[&lt;1s&gt;]&lt;n&gt;' expandMacrosWith: label.	self reportRawMeasurements		ifTrue: [self reportOutput: output]		ifFalse: [self reportOnTranscript ifTrue: 					[transcript nextPutAll: output; endEntry]].	Cursor wait showWhile:		[time := self perform: selector with: aBlock with: nTimes].	self		reportMeasuredAt: time * scale		repeated: nTimes</body></methods><methods><class-id>Tools.Benchmark</class-id> <category>initialize-release</category><body package="AT Benchmarks">initialize	self benchmarkSelectorsHolder list: self benchmarkSelectors.	self benchmarkSelectorsHolder selections: self initiallySelectedBenchmarks.	self setSelectedBenchmarks: self initiallySelectedBenchmarks.	perItemStatisticsToDoHolder := self initiallySelectedPerItemStatistics asValue.	overallStatisticsToDoHolder := self initiallySelectedOverallStatistics asValue.	measureRatesHolder := self defaultMeasureRate asValue.	measureRatesHolder onChangeSend: #changeOverallMeanLabel to: self.	iterationsHolder := self defaultIterations asValue.	transcript := TextCollector new.	self outputFilenameHolder value: self defaultOutputFilename.	reportStream := nil.	reportOnTranscriptHolder := true asValue.	reportOnFileHolder := false asValue.	reportRawMeasurementsHolder := false asValue.	reportIndividualStatisticsHolder := true asValue.	reportOverallStatisticsHolder := true asValue.	benchmarkMeasurements := OrderedCollection new.	runMeasurements := OrderedCollection new.</body></methods><methods><class-id>Tools.Benchmark</class-id> <category>interface opening</category><body package="AT Benchmarks">adapt: aPluggableAdaptor toSymbol: aSymbol atAspect: aspectName withBuilder: aBuilder 	"Install an adapter for a button to control a value in an array, for 	example."	aBuilder aspectAt: aspectName put: (aPluggableAdaptor			getBlock: [:m | m value includes: aSymbol]			putBlock: [:m :v | (m value includes: aSymbol)					= v ifFalse: [v						ifTrue: [m value: (m value copyWith: aSymbol)]						ifFalse: [m value: (m value copyWithout: aSymbol)]]]			updateBlock: [:m :a :p | a == #value])</body><body package="AT Benchmarks">postBuildWith: aBuilder 	aBuilder window label: self name</body><body package="AT Benchmarks">preBuildWith: aBuilder 	"Install the adapters."	self adapt: (PluggableAdaptor on: self perItemStatisticsToDoHolder) toSymbol: #Mean atAspect: #individualMean withBuilder: aBuilder.	self adapt: (PluggableAdaptor on: self perItemStatisticsToDoHolder) toSymbol: #Median atAspect: #individualMedian withBuilder: aBuilder.	self adapt: (PluggableAdaptor on: self perItemStatisticsToDoHolder) toSymbol: #Maximum atAspect: #individualMaximum withBuilder: aBuilder.	self adapt: (PluggableAdaptor on: self perItemStatisticsToDoHolder) toSymbol: #Minimum atAspect: #individualMinimum withBuilder: aBuilder.	self adapt: (PluggableAdaptor on: self overallStatisticsToDoHolder) toSymbol: #Mean atAspect: #overallMean withBuilder: aBuilder.	self adapt: (PluggableAdaptor on: self overallStatisticsToDoHolder) toSymbol: #Median atAspect: #overallMedian withBuilder: aBuilder.	self adapt: (PluggableAdaptor on: self overallStatisticsToDoHolder) toSymbol: #Maximum atAspect: #overallMaximum withBuilder: aBuilder.	self adapt: (PluggableAdaptor on: self overallStatisticsToDoHolder) toSymbol: #Minimum atAspect: #overallMinimum withBuilder: aBuilder.</body></methods><methods><class-id>Tools.Benchmark</class-id> <category>testing</category><body package="AT Benchmarks">measure: aBlock	"Measure the result of running aBlock."	"Default to measuring time in milliseconds.	Subclasses may override."	^Time millisecondsToRun: aBlock</body><body package="AT Benchmarks">measure: aBlock repeated: nTimes	"Measure the execution of aBlock nTimes, correcting for the	effects of executing an empty block.  Answer the measurement."	| emptyBlock emptyMeasure blockMeasure |	emptyBlock := [].	emptyMeasure := self measure: 							[nTimes timesRepeat: [emptyBlock value]].	blockMeasure := self measure: 							[nTimes timesRepeat: [aBlock value]].	^blockMeasure - emptyMeasure max: 0</body><body package="AT Benchmarks">measureDisplayOperation: aBlock repeated: nTimes	"Measure the execution of the display operation aBlock nTimes,	correcting for the effects of executing an empty block. Answer the measurement."	| emptyBlock emptyMeasure blockMeasure |	emptyBlock := [].	Screen default sync.	emptyMeasure := self measure: 							[nTimes timesRepeat: [emptyBlock value].							Screen default sync].	Screen default sync.	blockMeasure := self measure: 							[nTimes timesRepeat: [aBlock value].							Screen default sync].	^blockMeasure - emptyMeasure max: 0</body><body package="AT Benchmarks">run	"Run the selected benchmarks."	OSErrorHolder existingReferentSignal		handle: [:ex | ex return]		do:			[self beginningOfRun.			iterationsHolder value timesRepeat:				[self beginningOfIteration.				self benchmarkSelectorsHolder selections do:					[:selector |					self perform: selector].				self endOfIteration].			self endOfRun]</body><body package="AT Benchmarks">test: aBlock labeled: label repeated: nTimes 	"This is the main message to a Benchmark. aBlock is repeated nTimes, and 	the  results are reported."	self		test: aBlock		labeled: label		repeated: nTimes		using: #measure:repeated:</body><body package="AT Benchmarks">test: aBlock labeled: label repeated: nTimes scaledBy: scale	"This is an auxilliary message to a Benchmark. aBlock is repeated nTimes, and 	the results are reported, but the time is scaled by scale."	self		test: aBlock		labeled: label		repeated: nTimes		using: #measure:repeated:		scaledBy: scale</body><body package="AT Benchmarks">testDisplayOperation: aBlock labeled: label repeated: nTimes 	"This is the main message to a benchmark that performs display 	operations.  aBlock is repeated nTimes, and the results are reported."	self		test: aBlock		labeled: label		repeated: nTimes		using: #measureDisplayOperation:repeated:</body></methods><methods><class-id>Tools.Benchmark</class-id> <category>output</category><body package="AT Benchmarks">individualBenchmarksReport	"Summarize the performance during the last run."	self makeReportRunValues: runMeasurements		title: (#IndividualBenchmarkResults1pIterations &lt;&lt; #advanced &gt;&gt; 'Individual benchmark results (&lt;1p&gt; iterations):'			expandMacrosWith: self iterations)		typeLabel: #Benchmark &lt;&lt; #advanced &gt;&gt; 'Benchmark'		rowLabels: (self benchmarkSelectorsHolder selections collect: [:selector | self benchmarkLabelForSelector: selector])		statisticsTypes: self perItemStatisticsToDo</body><body package="AT Benchmarks">summaryReport	"Summarize the performance."	| statistics ratingTypes |	statistics := OrderedCollection new.	ratingTypes := self overallStatisticsToDo collect:		[:stat |		stat == #Mean			ifTrue: [self measureRates					ifTrue: [#'H-Mean']					ifFalse: [#'A-Mean']]			ifFalse: [stat]].	runMeasurements do:		[:measurements | | weightedMeasurements |		weightedMeasurements := OrderedCollection new: measurements size.		measurements with: self benchmarkSelectorsHolder selections do:			[:measurement :benchmark |			weightedMeasurements addLast: (measurement * (self weightFor: benchmark))].					self statisticsForRun: weightedMeasurements do:			[:min :max :arithmeticMean :harmonicMean :median |			statistics addLast:				(ratingTypes collect:					[:stat |					stat == #Minimum ifTrue: [min] ifFalse: [					stat == #Maximum ifTrue: [max] ifFalse: [					stat == #'H-Mean' ifTrue: [harmonicMean] ifFalse: [					stat == #'A-Mean' ifTrue: [arithmeticMean] ifFalse: [					stat == #Median ifTrue: [median]]]]]])]].	self makeReportRunValues: statistics		title: (#BenchmarkSuiteResults1sIterations &lt;&lt; #advanced &gt;&gt; 'Benchmark suite results (&lt;1p&gt; iterations):'			expandMacrosWith: self iterations)		typeLabel: #RatingType &lt;&lt; #advanced &gt;&gt; 'Rating Type'		rowLabels: ratingTypes		statisticsTypes: self perItemStatisticsToDo</body></methods><methods><class-id>Tools.Benchmark class</class-id> <category>accessing</category><body package="AT Benchmarks">measurementsName	"Answer a string describing the type of measurements taken.	Note that the name should be plural."	"Default to time measurements.  Subclasses may wish to override."	^(#Times &lt;&lt; #advanced &gt;&gt; 'Times') asString</body><body package="AT Benchmarks">measurementsNameLowercase	"Answer a string describing the type of measurements taken.	Note that the name should be plural."	^self measurementsName asLowercase</body></methods><methods><class-id>Tools.Benchmark class</class-id> <category>instance creation</category><body package="AT Benchmarks">new	^super new initialize</body></methods><methods><class-id>Tools.Benchmark class</class-id> <category>parcel load/unload/save</category><body package="AT Benchmarks">preUnloadFor: aParcel	"Close any open applications implemented by this parcel."	ApplicationModel checkUnloadOfApplicationsDefinedBy: aParcel</body></methods><methods><class-id>Tools.BenchDecompilerTestClass</class-id> <category>mouse</category><body package="AT Benchmarks">anyButtonPressed	"Answer whether a mouse button is being pressed."	^self buttons &gt; 0</body><body package="AT Benchmarks">blueButtonPressed	"Answer whether only the blue mouse button is being pressed."	^self buttons = 1</body><body package="AT Benchmarks">mousePoint	"Answer a Point indicating the coordinates of the current mouse location."	^CurrentInputState mousePoint</body><body package="AT Benchmarks">mousePointNext	"Answer the next mouse point if red button or tablet is down; false otherwise."	self redButtonPressed ifTrue: [^self mousePoint].	^false</body><body package="AT Benchmarks">noButtonPressed	"Answer whether any mouse button is not being pressed."	^self anyButtonPressed == false</body><body package="AT Benchmarks">redButtonPressed	"Answer whether only the red mouse button is being pressed."	^self buttons = 4</body><body package="AT Benchmarks">waitButton	"Wait for the user to press any mouse button and then answer with the 	current location of the cursor."	[self anyButtonPressed] whileFalse.	^self cursorPoint</body><body package="AT Benchmarks">waitClickButton	"Wait for the user to click (press and then release) any mouse button and then	answer with the current location of the cursor."	self waitButton.	^self waitNoButton</body><body package="AT Benchmarks">waitNoButton	"Wait for the user to release any mouse button and then answer with the 	current location of the cursor."	[self anyButtonPressed] whileTrue.	^self cursorPoint</body><body package="AT Benchmarks">yellowButtonPressed	"Answer whether only the yellow mouse button is being pressed."	^self buttons = 2</body></methods><methods><class-id>Tools.BenchDecompilerTestClass</class-id> <category>private</category><body package="AT Benchmarks">buttons	^self primMouseButtons</body><body package="AT Benchmarks">primCursorLocPut: pt 	CurrentInputState cursorPoint: pt</body><body package="AT Benchmarks">primMouseButtons	^CurrentInputState mouseButtons</body><body package="AT Benchmarks">primMousePt	"Poll the mouse to find out its position. Return a Point. Fail if event-driven 	tracking is used instead of polling."	&lt;primitive: 90&gt;	^CurrentInputState mousePoint</body></methods><methods><class-id>Tools.BenchDecompilerTestClass</class-id> <category>current cursor</category><body package="AT Benchmarks">currentCursor	"Answer the instance of Cursor currently displayed."	^CurrentCursor</body><body package="AT Benchmarks">currentCursor: newCursor 	"Set newCursor to be the displayed Cursor form."	CurrentCursor := newCursor.	Cursor currentCursor: CurrentCursor</body><body package="AT Benchmarks">cursorPoint	"Answer a Point indicating the cursor location."	^self mousePoint</body><body package="AT Benchmarks">cursorPoint: aPoint 	"Set aPoint to be the current cursor location."	^self primCursorLocPut: aPoint</body></methods><methods><class-id>Tools.SystemBenchmark</class-id> <category>private</category><body package="AT Benchmarks">longishString	^ 'Now is the time for all good people to come to the aid of the cause of world peace.  It is just fine, even desirable, to love your country, if that means wanting it to play a beneficial role in the course of world events and be the best possible example of a good society.  But if it means wanting dominion over the rest of the world, it is not love but defensiveness or self-glorification, and will lead only to oblivion.'</body><body package="AT Benchmarks">numberOfMethodsScaleFactor	| numberOfMethodsInDoradoImage numberOfMethodsInThisImage |	numberOfMethodsInDoradoImage := 4491. "derivered from Smalltalk-80.sources"	numberOfMethodsInThisImage := 0.	(MethodCollector new methodsSelect:		[:m| 		numberOfMethodsInThisImage := numberOfMethodsInThisImage + 1.		false]) select.	^numberOfMethodsInDoradoImage asFloat / numberOfMethodsInThisImage asFloat</body><body package="AT Benchmarks">recur: exp 	"Invokes a recursion involving ((2 raisedTo: exp+1) - 1) activations and 	returns."	exp = 0 ifTrue: [^self].	self recur: exp - 1.	^self recur: exp - 1</body><body package="AT Benchmarks">stringForDisplay	^'testTextDisplay	| clipRect para range scanner |	clipRect := Display boundingBox.	para := Paragraph withText: self textForDisplay.	range := 1 to: para numberOfLines.	scanner := DisplayScanner new.	self test: [scanner				displayLines: range				in: para				clippedBy: clipRect]		labeled: ''displaying text'' repeated: 10	"Benchmark new testTextDisplay"'</body><body package="AT Benchmarks">stringHolderBenchmark: aBlock		"Evaluate aBlock (a benchmark test) with a window as a parameter."	| aComposedTextView window |	aComposedTextView := ComposedTextView model: (ValueHolder with: self longishString).	window := ScheduledWindow new.	window label: (#BenchmarkScratchpad &lt;&lt; #advanced &gt;&gt; 'Benchmark Scratchpad').	window component: aComposedTextView.	window openIn: (Screen default makeRectangleVisible: (Rectangle origin: 20@20 extent: 300@200)).	[window windowManager processOutstandingEvents.	aBlock value: aComposedTextView]		ensure: [aComposedTextView topComponent controller closeAndUnschedule]</body><body package="AT Benchmarks">textForDisplay	^self stringForDisplay asText</body><body package="AT Benchmarks">windowBenchmark: aBlock	"Evaluate aBlock (a benchmark test) with a window as a parameter."	| window |	window := ScheduledWindow new.	window label: (#BenchmarkScratchpad &lt;&lt; #advanced &gt;&gt; 'Benchmark Scratchpad').	window openIn: (Screen default makeRectangleVisible: (Rectangle origin: 20@20 extent: 600@500)).	[window windowManager processOutstandingEvents.	aBlock value: window]		ensure: [window controller closeAndUnschedule]</body></methods><methods><class-id>Tools.SystemBenchmark</class-id> <category>accessing</category><body package="AT Benchmarks">benchmarkLabelForSelector: benchmarkSelector	^BenchmarkLabels		at: benchmarkSelector		ifAbsent: [(#Unknown &lt;&lt; #advanced &gt;&gt; 'Unknown') asString]</body><body package="AT Benchmarks">benchmarkSelectors	^AvailableBenchmarks</body><body package="AT Benchmarks">initiallySelectedBenchmarks	^InitiallySelectedBenchmarks</body><body package="AT Benchmarks">name	^(#SystemBenchmarks &lt;&lt; #advanced &gt;&gt; 'System Benchmarks') asString</body><body package="AT Benchmarks">nonIoMacroBenchmarks	^NonIOMacroBenchmarks</body><body package="AT Benchmarks">significantDigits	"System benchmarks are probably no more accurate than 	three significant digits."	^3</body></methods><methods><class-id>Tools.SystemBenchmark</class-id> <category>weighting</category><body package="AT Benchmarks">convert: time toRateFor: benchmarkSelector	"Convert as a rate proportional to Dorado performance.  A rate of	100 indicates equivalent performance to the Dorado on the benchmark,	a rate of 150 indicates 50% better performance, and so forth."	^(DoradoBenchmarkTimes at: benchmarkSelector ifAbsent: [0.0]) / (time max: 1.0e-6) * 100</body></methods><methods><class-id>Tools.SystemBenchmark</class-id> <category>defaults</category><body package="AT Benchmarks">defaultMeasureRate	^true</body><body package="AT Benchmarks">defaultOutputFilename	^(#Smalltalktiming &lt;&lt; #advanced &gt;&gt; 'Smalltalk.timing') asString</body></methods><methods><class-id>Tools.SystemBenchmark</class-id> <category>selecting</category><body package="AT Benchmarks">benchmarkSelectionMenu	"Answer the menu for benchmark selection."	^Menu		labelArray: (Array			with: (#selectAll &lt;&lt; #advanced &gt;&gt; 'select all')			with: (#clearSelections &lt;&lt; #advanced &gt;&gt; 'clear selections')			with: (#resetToDefault &lt;&lt; #advanced &gt;&gt; 'reset to default')			with: (#resetToNonioMacro &lt;&lt; #advanced &gt;&gt; 'reset to non-io macro'))		values: #(#selectAllBenchmarks #deselectAllBenchmarks #resetToDefaultBenchmarks #resetToNonIOMacroBenchmarks)</body><body package="AT Benchmarks">resetToNonIOMacroBenchmarks	"Revert selected benchmarks to the set of macro benchmarks that don't do I/O."	self selectedBenchmarks: self nonIoMacroBenchmarks</body></methods><methods><class-id>Tools.SystemBenchmark</class-id> <category>macro operations</category><body package="AT Benchmarks">testAllCallsOn	self test:			[MethodCollector new allReferencesTo: #printStringRadix:]		labeled: (#GenKey10 &lt;&lt; #advanced &gt;&gt; 'find all calls on #printStringRadix:')		repeated: 1		scaledBy: self numberOfMethodsScaleFactor	"SystemBenchmark new testAllCallsOn"</body><body package="AT Benchmarks">testAllImplementors	self test:			[MethodCollector new allImplementorsOf: #next]		labeled: (#GenKey11 &lt;&lt; #advanced &gt;&gt; 'find all implementors of #next')		repeated: 5		scaledBy: self numberOfMethodsScaleFactor	"SystemBenchmark new testAllImplementors"</body><body package="AT Benchmarks">testClassOrganizer	| class |	class := SystemBenchmark.	self test:			[class organization changeFromString: class organization printString]		labeled: (#GenKey18 &lt;&lt; #advanced &gt;&gt; 'read and write class organization') repeated: 5	"SystemBenchmark new testClassOrganizer"</body><body package="AT Benchmarks">testCompiler	"SystemBenchmark new testCompiler"		self test:		[Store.Policies packagePolicy			forcePackage: Store.Registry nullPackage			while:				[SystemBenchmark compile:	'dummy: aBlock repeated: nTimes | i emptyBlock emptyTime blockTime |	nTimes &gt; 1000 ifTrue: [^self time: aBlock repeatedK: nTimes // 1000].	emptyBlock := [].	emptyTime := Time millisecondsToRun:		[i := 0.		 [(i := i + 1) &lt;= nTimes] whileTrue: [emptyBlock value]].	blockTime := Time millisecondsToRun:		[i := 0.		 [(i := i + 1) &lt;= nTimes] whileTrue: [aBlock value]].	^blockTime - emptyTime'						notifying: nil						ifFail: []]]		labeled: #compileDummyMethod &lt;&lt; #advanced &gt;&gt; 'compile dummy method'		repeated: 10.	SystemBenchmark removeSelectorSimply: #dummy:repeated:</body><body package="AT Benchmarks">testDecompiler        | class |        class := BenchDecompilerTestClass.        self                test: [class selectors do:                                [:sel | (class decompilerClass new                                                decompile: sel                                                in: class                                                method: (class compiledMethodAt: sel)) formattedCode]]                labeled: (#GenKey21 &lt;&lt; #advanced &gt;&gt; 'decompile class BenchDecompilerTestClass') repeated: 5	"SystemBenchmark new testDecompiler"</body><body package="AT Benchmarks">testInspect	self test:			[Inspector buildScheduledView: (Inspector inspect: Compiler new)]		labeled: (#createAnInspectorView &lt;&lt; #advanced &gt;&gt; 'create an inspector view') repeated: 50	"SystemBenchmark new testInspect"</body><body package="AT Benchmarks">testPrintDefinition	| class |	class := Compiler.	self test:			[class definition]		labeled: (#printAClassDefinition &lt;&lt; #advanced &gt;&gt; 'print a class definition') repeated: 100	"SystemBenchmark new testPrintDefinition"</body><body package="AT Benchmarks">testPrintHierarchy	| class |	class := InstructionStream.	self test:			[class printHierarchy]		labeled: (#printAClassHierarchy &lt;&lt; #advanced &gt;&gt; 'print a class hierarchy') repeated: 100	"SystemBenchmark new testPrintHierarchy"</body><body package="AT Benchmarks">testTextDisplay	| para gc |	self windowBenchmark:		[:window |		para := ComposedText withText: self textForDisplay.		gc := window graphicsContext.		para displayOn: gc at: 200@200.		self testDisplayOperation: [para displayOn: gc at: 200@200]			labeled: (#displayText &lt;&lt; #advanced &gt;&gt; 'display text') repeated: 50]	"SystemBenchmark new testTextDisplay"</body><body package="AT Benchmarks">testTextEditing	self stringHolderBenchmark:		[:aStringHolderView |		| editor selectPoint |		editor := aStringHolderView controller.		selectPoint := 0.		self testDisplayOperation:			[editor selectAt: (selectPoint := selectPoint + 5).			 editor replaceSelectionWith: 'Now! ' asText]		labeled: (#GenKey34 &lt;&lt; #advanced &gt;&gt; 'text replacement and redisplay') repeated: 25]	"SystemBenchmark new testTextEditing"</body><body package="AT Benchmarks">testTextFormatting	| aString aView window |	aString := self stringForDisplay.	aView := ComposedTextView model: ValueHolder newString.	window := ScheduledWindow new.	window changeExtent: 200@200.	window component: (LookPreferences edgeDecorator on: aView).	window extentEvent: window extent.	"Note: this benchmark does not do any display."	self test:			[aView editString: (aString asText makeSelectorBoldIn: SystemBenchmark)]		labeled: (#formatABunchOfText &lt;&lt; #advanced &gt;&gt; 'format a bunch of text') repeated: 50.	aView release.	window release	"SystemBenchmark new testTextFormatting"</body></methods><methods><class-id>Tools.SystemBenchmark</class-id> <category>primitive byte codes</category><body package="AT Benchmarks">testClass	| pt |	pt := 0@0.	self test:			[pt class. pt class. pt class. pt class. pt class.			 pt class. pt class. pt class. pt class. pt class.			 pt class. pt class. pt class. pt class. pt class.			 pt class. pt class. pt class. pt class. pt class. nil]		labeled: (#GenKey17 &lt;&lt; #advanced &gt;&gt; 'send #class 20 times (to a point)') repeated: 50000	"SystemBenchmark new testClass"</body><body package="AT Benchmarks">testCreation	self test:			[Association new. Association new. Association new.			Association new. Association new. Association new.			Association new. Association new. Association new.			Association new. Association new. Association new.			Association new. Association new. Association new.			Association new. Association new. Association new.			Association new. Association new. nil]		labeled: (#GenKey20 &lt;&lt; #advanced &gt;&gt; 'create 20 uninitialized associations') repeated: 10000	"SystemBenchmark new testCreation"</body><body package="AT Benchmarks">testEQ	| temp |	temp := 1.	self test: [temp == temp == temp == temp == temp ==			  temp == temp == temp == temp == temp ==			  temp == temp == temp == temp == temp ==			  temp == temp == temp == temp == temp. nil]		labeled: (#sendEQ20Times &lt;&lt; #advanced &gt;&gt; 'send ==, 20 times') repeated: 100000	"SystemBenchmark new testEQ"</body><body package="AT Benchmarks">testLoadThisContext	self test: [thisContext == thisContext. thisContext == thisContext.			  thisContext == thisContext. thisContext == thisContext.			  thisContext == thisContext. thisContext == thisContext.			  thisContext == thisContext. thisContext == thisContext.			  thisContext == thisContext. thisContext == thisContext. nil]		labeled: (#loadThisContext20Times &lt;&lt; #advanced &gt;&gt; 'load thisContext, 20 times') repeated: 20000	"SystemBenchmark new testLoadThisContext"</body><body package="AT Benchmarks">testPointCreation	self test: [3@4. 3@4. 3@4. 3@4. 3@4. 3@4. 3@4. 3@4. 3@4. 3@4. nil]		labeled: (#create3410Times &lt;&lt; #advanced &gt;&gt; 'create 3@4, 10 times') repeated: 20000	"SystemBenchmark new testPointCreation"</body><body package="AT Benchmarks">testPointX	| pt |	pt := 0@0.	self test: [pt x. pt x. pt x. pt x. pt x. pt x. pt x. pt x. pt x. pt x. nil]		labeled: (#executeAPointX10Times &lt;&lt; #advanced &gt;&gt; 'execute aPoint x, 10 times') repeated: 100000	"SystemBenchmark new testPointX"</body><body package="AT Benchmarks">testStreamNext	| strm |	strm := ReadStream on: 'abcdefghijklmnopqrstuvwxyz'.	self test: [strm position: 0.			  strm next. strm next. strm next. strm next.			  strm next. strm next. strm next. strm next.			  strm next. strm next. strm next. strm next.			  strm next. strm next. strm next. strm next.			  strm next. strm next. strm next. strm next. nil]		labeled: (#GenKey29 &lt;&lt; #advanced &gt;&gt; 'execute ReadStream next, 20 times') repeated: 10000	"SystemBenchmark new testStreamNext"</body><body package="AT Benchmarks">testStreamNextPut	| strm ch |	strm := ReadWriteStream on: 'abcdefghijklmnopqrstuvwxyz' copy.	ch := $q.	self test: [strm position: 0.			  strm nextPut: ch. strm nextPut: ch. strm nextPut: ch. strm nextPut: ch.			  strm nextPut: ch. strm nextPut: ch. strm nextPut: ch. strm nextPut: ch.			  strm nextPut: ch. strm nextPut: ch. strm nextPut: ch. strm nextPut: ch.			  strm nextPut: ch. strm nextPut: ch. strm nextPut: ch. strm nextPut: ch.			  strm nextPut: ch. strm nextPut: ch. strm nextPut: ch. strm nextPut: ch. nil]		labeled: (#GenKey30 &lt;&lt; #advanced &gt;&gt; 'execute ReadWriteStream nextPut:, 20 times') repeated: 10000	"SystemBenchmark new testStreamNextPut"</body><body package="AT Benchmarks">testValue	| block |	block := [3+4].	self test: [block value. block value. block value. block value.			  block value. block value. block value. block value.			  block value. block value. block value. block value.			  block value. block value. block value. block value.			  block value. block value. block value. block value. nil]		labeled: (#GenKey36 &lt;&lt; #advanced &gt;&gt; 'evaluate the block: (3+4), 20 times') repeated: 15000	"SystemBenchmark new testValue"</body></methods><methods><class-id>Tools.SystemBenchmark</class-id> <category>arrays and strings</category><body package="AT Benchmarks">testArrayAt	| array index |	array := #(1 2 3 4 5 6).	index := 4.	self test:			[array at: index. array at: index. array at: index. array at: index.			 array at: index. array at: index. array at: index. array at: index.			 array at: index. array at: index. array at: index. array at: index.			 array at: index. array at: index. array at: index. array at: index.			 array at: index. array at: index. array at: index. array at: index. nil]		labeled: (#GenKey12 &lt;&lt; #advanced &gt;&gt; 'send #at: 20 times (to an array)') repeated: 25000	"SystemBenchmark new testArrayAt"</body><body package="AT Benchmarks">testArrayAtPut	| array index element |	array := #(1 2 3 4 5 6) copy.	index := 4.	element := 17.	self test:			[array at: index put: element. array at: index put: element.			 array at: index put: element. array at: index put: element.			 array at: index put: element. array at: index put: element.			 array at: index put: element. array at: index put: element.			 array at: index put: element. array at: index put: element.			 array at: index put: element. array at: index put: element.			 array at: index put: element. array at: index put: element.			 array at: index put: element. array at: index put: element.			 array at: index put: element. array at: index put: element.			 array at: index put: element. array at: index put: element. nil]		labeled: (#GenKey13 &lt;&lt; #advanced &gt;&gt; 'send #at:put: 20 times (to an array)') repeated: 15000	"SystemBenchmark new testArrayAtPut"</body><body package="AT Benchmarks">testSize	| string |	string := 'abcde'.	self test:			[string size. string size. string size. string size. string size.			 string size. string size. string size. string size. string size.			 string size. string size. string size. string size. string size.			 string size. string size. string size. string size. string size. nil]		labeled: (#GenKey28 &lt;&lt; #advanced &gt;&gt; 'send #size 20 times (to a string)') repeated: 40000	"SystemBenchmark new testSize"</body><body package="AT Benchmarks">testStringAt	| string index |	string := 'abcdefg'.	index := 4.	self test:			[string at: index. string at: index. string at: index. string at: index.			 string at: index. string at: index. string at: index. string at: index.			 string at: index. string at: index. string at: index. string at: index.			 string at: index. string at: index. string at: index. string at: index.			 string at: index. string at: index. string at: index. string at: index. nil]		labeled: (#GenKey31 &lt;&lt; #advanced &gt;&gt; 'send #at: 20 times (to a string)') repeated: 40000	"SystemBenchmark new testStringAt"</body><body package="AT Benchmarks">testStringAtPut	| string index char |	string := 'abcdefg' copy.	index := 4.	char := $q.	self test:			[string at: index put: char. string at: index put: char.			 string at: index put: char. string at: index put: char.			 string at: index put: char. string at: index put: char.			 string at: index put: char. string at: index put: char.			 string at: index put: char. string at: index put: char.			 string at: index put: char. string at: index put: char.			 string at: index put: char. string at: index put: char.			 string at: index put: char. string at: index put: char.			 string at: index put: char. string at: index put: char.			 string at: index put: char. string at: index put: char. nil]		labeled: (#GenKey32 &lt;&lt; #advanced &gt;&gt; 'send #at:put: 20 times (to a string)') repeated: 25000	"SystemBenchmark new testStringAtPut"</body></methods><methods><class-id>Tools.SystemBenchmark</class-id> <category>load and popStore</category><body package="AT Benchmarks">testLoadInstVar	dummy := 1.	self test: [dummy == dummy. dummy == dummy.			  dummy == dummy. dummy == dummy.			  dummy == dummy. dummy == dummy.			  dummy == dummy. dummy == dummy.			  dummy == dummy. dummy == dummy. nil]		labeled: (#GenKey22 &lt;&lt; #advanced &gt;&gt; 'load an instance variable, 20 times') repeated: 100000	"SystemBenchmark new testLoadInstVar"</body><body package="AT Benchmarks">testLoadLiteralImmediate	self test: [3 == 3. 3 == 3. 3 == 3. 3 == 3. 3 == 3.			  3 == 3. 3 == 3. 3 == 3. 3 == 3. 3 == 3. nil]		labeled: (#GenKey23 &lt;&lt; #advanced &gt;&gt; 'load immediate literal, 20 times') repeated: 250000	"SystemBenchmark new testLoadLiteralImmediate"</body><body package="AT Benchmarks">testLoadLiteralIndirect	self test: [Point == Point. Point == Point.			  Point == Point. Point == Point.			  Point == Point. Point == Point.			  Point == Point. Point == Point.			  Point == Point. Point == Point. nil]		labeled: (#GenKey24 &lt;&lt; #advanced &gt;&gt; 'load literal indirect, 20 times') repeated: 50000	"SystemBenchmark new testLoadLiteralIndirect"</body><body package="AT Benchmarks">testLoadQuickConstant	self test: [1 == 1. 1 == 1. 1 == 1. 1 == 1. 1 == 1.			  1 == 1. 1 == 1. 1 == 1. 1 == 1. 1 == 1.			  1 == 1. 1 == 1. 1 == 1. 1 == 1. 1 == 1.			  1 == 1. 1 == 1. 1 == 1. 1 == 1. 1 == 1. nil]		labeled: (#GenKey25 &lt;&lt; #advanced &gt;&gt; 'load 1, 40 times; send ==, 20 times') repeated: 200000	"SystemBenchmark new testLoadQuickConstant"</body><body package="AT Benchmarks">testLoadTemp	| temp |	temp := 0@0.	self test: [temp == temp. temp == temp.			  temp == temp. temp == temp.			  temp == temp. temp == temp.			  temp == temp. temp == temp.			  temp == temp. temp == temp. nil]		labeled: (#load0020Times &lt;&lt; #advanced &gt;&gt; 'load 0@0, 20 times') repeated: 200000	"SystemBenchmark new testLoadTemp"</body><body package="AT Benchmarks">testLoadTempImmediate	| temp |	temp := 1.	self test: [temp == temp. temp == temp.			  temp == temp. temp == temp.			  temp == temp. temp == temp.			  temp == temp. temp == temp.			  temp == temp. temp == temp. nil]		labeled: (#load1AsATemp20Times &lt;&lt; #advanced &gt;&gt; 'load 1 as a temp, 20 times') repeated: 200000	"SystemBenchmark new testLoadTempImmediate"</body><body package="AT Benchmarks">testPopStoreInstVar	self test: [dummy := 1. dummy := 1. dummy := 1. dummy := 1. dummy := 1.			  dummy := 1. dummy := 1. dummy := 1. dummy := 1. dummy := 1.			  dummy := 1. dummy := 1. dummy := 1. dummy := 1. dummy := 1.			  dummy := 1. dummy := 1. dummy := 1. dummy := 1. dummy := 1. nil]		labeled: (#GenKey27 &lt;&lt; #advanced &gt;&gt; 'store into an instance variable, 20 times') repeated: 40000	"SystemBenchmark new testPopStoreInstVar"</body><body package="AT Benchmarks">testPopStoreTemp	| temp |	self test: [temp := 1. temp := 1. temp := 1. temp := 1. temp := 1.			  temp := 1. temp := 1. temp := 1. temp := 1. temp := 1.			  temp := 1. temp := 1. temp := 1. temp := 1. temp := 1.			  temp := 1. temp := 1. temp := 1. temp := 1. temp := 1. temp]		labeled: (#storeIntoATemp20Times &lt;&lt; #advanced &gt;&gt; 'store into a temp, 20 times') repeated: 150000.	"SystemBenchmark new testPopStoreTemp"</body></methods><methods><class-id>Tools.SystemBenchmark</class-id> <category>arithmetic</category><body package="AT Benchmarks">test3div4	self test: [3//4. 3//4. 3//4. 3//4. 3//4. 3//4. 3//4. 3//4. 3//4. 3//4. nil]		labeled: (#divide3By410Times &lt;&lt; #advanced &gt;&gt; 'divide 3 by 4, 10 times') repeated: 20000	"SystemBenchmark new test3div4"</body><body package="AT Benchmarks">test3lessThan4	self test: [3&lt;4. 3&lt;4. 3&lt;4. 3&lt;4. 3&lt;4. 3&lt;4. 3&lt;4. 3&lt;4. 3&lt;4. 3&lt;4. nil]		labeled: (#test3less410Times &lt;&lt; #advanced &gt;&gt; 'test 3 &lt; 4, 10 times') repeated: 200000	"SystemBenchmark new test3lessThan4"</body><body package="AT Benchmarks">test3plus4	self test: [3+4. 3+4. 3+4. 3+4. 3+4. 3+4. 3+4. 3+4. 3+4. 3+4. nil]		labeled: (#add3410Times &lt;&lt; #advanced &gt;&gt; 'add 3 + 4, 10 times') repeated: 300000	"SystemBenchmark new test3plus4"</body><body package="AT Benchmarks">test3times4	self test: [3*4. 3*4. 3*4. 3*4. 3*4. 3*4. 3*4. 3*4. 3*4. 3*4. nil]		labeled: (#multiply3410Times &lt;&lt; #advanced &gt;&gt; 'multiply 3 * 4, 10 times') repeated: 50000	"SystemBenchmark new test3times4"</body></methods><methods><class-id>Tools.SystemBenchmark</class-id> <category>primitive methods</category><body package="AT Benchmarks">testAsFloat	self test: [1 asFloat. 1 asFloat. 1 asFloat. 1 asFloat. 1 asFloat.			  1 asFloat. 1 asFloat. 1 asFloat. 1 asFloat. 1 asFloat.			  1 asFloat. 1 asFloat. 1 asFloat. 1 asFloat. 1 asFloat.			  1 asFloat. 1 asFloat. 1 asFloat. 1 asFloat. 1 asFloat. nil]		labeled: (#GenKey14 &lt;&lt; #advanced &gt;&gt; 'convert 1 to floating point, 20 times') repeated: 10000	"SystemBenchmark new testAsFloat"</body><body package="AT Benchmarks">testBasicAt	| coll index |	coll := Set new: 16.	index := 5.	self test:			[coll basicAt: index. coll basicAt: index. coll basicAt: index. coll basicAt: index.			 coll basicAt: index. coll basicAt: index. coll basicAt: index. coll basicAt: index.			 coll basicAt: index. coll basicAt: index. coll basicAt: index. coll basicAt: index.			 coll basicAt: index. coll basicAt: index. coll basicAt: index. coll basicAt: index.			 coll basicAt: index. coll basicAt: index. coll basicAt: index. coll basicAt: index. nil]		labeled: (#GenKey15 &lt;&lt; #advanced &gt;&gt; 'send #basicAt: 20 times (to a set)') repeated: 25000	"SystemBenchmark new testBasicAt"</body><body package="AT Benchmarks">testBasicAtPut	| coll index element |	coll := Set new: 16.	index := 5.	element := 17.	self test:			[coll basicAt: index put: element. coll basicAt: index put: element.			 coll basicAt: index put: element. coll basicAt: index put: element.			 coll basicAt: index put: element. coll basicAt: index put: element.			 coll basicAt: index put: element. coll basicAt: index put: element.			 coll basicAt: index put: element. coll basicAt: index put: element.			 coll basicAt: index put: element. coll basicAt: index put: element.			 coll basicAt: index put: element. coll basicAt: index put: element.			 coll basicAt: index put: element. coll basicAt: index put: element.			 coll basicAt: index put: element. coll basicAt: index put: element.			 coll basicAt: index put: element. coll basicAt: index put: element. nil]		labeled: (#GenKey16 &lt;&lt; #advanced &gt;&gt; 'send #basicAtPut: 20 times (to a set)') repeated: 20000	"SystemBenchmark new testBasicAtPut"</body><body package="AT Benchmarks">testFloatingPointAddition	| a b |	a := 3.1.	b := 4.1.	self test: [a+b. a+b. a+b. a+b. a+b. a+b. a+b. a+b. a+b. a+b.			  a+b. a+b. a+b. a+b. a+b. a+b. a+b. a+b. a+b. a+b. nil]		labeled: (#add31Plus4120Times &lt;&lt; #advanced &gt;&gt; 'add 3.1 plus 4.1, 20 times') repeated: 10000	"SystemBenchmark new testFloatingPointAddition"</body><body package="AT Benchmarks">testPerform	self test: [3 perform: #+ with: 4. 3 perform: #+ with: 4.			  3 perform: #+ with: 4. 3 perform: #+ with: 4.			  3 perform: #+ with: 4. 3 perform: #+ with: 4.			  3 perform: #+ with: 4. 3 perform: #+ with: 4.			  3 perform: #+ with: 4. 3 perform: #+ with: 4.			  3 perform: #+ with: 4. 3 perform: #+ with: 4.			  3 perform: #+ with: 4. 3 perform: #+ with: 4.			  3 perform: #+ with: 4. 3 perform: #+ with: 4.			  3 perform: #+ with: 4. 3 perform: #+ with: 4.			  3 perform: #+ with: 4. 3 perform: #+ with: 4. nil]		labeled: (#GenKey26 &lt;&lt; #advanced &gt;&gt; '3 perform: #+ with: 4, 20 times') repeated: 10000	"SystemBenchmark new testPerform"</body><body package="AT Benchmarks">testStringReplace	| source sink size |	source := self longishString copy.	sink := source copy.	size := sink size.	self test:			[sink replaceFrom: 1 to: size with: source startingAt: 1. nil]		labeled: (#GenKey33 &lt;&lt; #advanced &gt;&gt; 'replace characters in a string') repeated: 20000	"SystemBenchmark new testStringReplace"</body><body package="AT Benchmarks">testTextScanning	| gc font scanner displayPosition string stringMap stringSize |	self windowBenchmark:		[:window |		gc := window graphicsContext.		gc clear.		font := gc font.		scanner := font scanner.		string := 'Hi there, folks!'.		stringSize := string size.		displayPosition := 0@20.		scanner displayString: string from: 1 to: stringSize at: displayPosition on: gc.		stringMap := scanner map: string.		self testDisplayOperation:			[scanner destX: 0.			 scanner				scanCharactersFrom: 1				to: stringSize				in: string				rightX: 400				stopConditions: stringMap.			font				displayString: string				from: 1				to: scanner lastIndex				at: displayPosition				on: gc				map: stringMap]			labeled: #scanCharactersPrimitiveTextDisplay &lt;&lt; #advanced &gt;&gt; 'scan characters (primitive text display)' repeated: 1500]	"SystemBenchmark new testTextScanning"</body></methods><methods><class-id>Tools.SystemBenchmark</class-id> <category>control</category><body package="AT Benchmarks">testActivationReturn	self test:			[self recur: 14]		labeled: (#GenKey9 &lt;&lt; #advanced &gt;&gt; 'activate and return, 32K times') repeated: 10	"SystemBenchmark new testActivationReturn"</body><body package="AT Benchmarks">testWhileLoop	| temp |	self test: [temp := 10000.			  [temp &gt; 0] whileTrue: [temp := temp - 1].			  nil]		labeled: (#GenKey37 &lt;&lt; #advanced &gt;&gt; 'simple whileLoop, 10000 times through') repeated: 25	"SystemBenchmark new testWhileLoop"</body></methods><methods><class-id>Tools.SystemBenchmark class</class-id> <category>class initialization</category><body package="AT Benchmarks">initialize	"SystemBenchmark initialize"	AvailableBenchmarks := OrderedCollection new.	BenchmarkLabels := Dictionary new.	DoradoBenchmarkTimes := Dictionary new.	"convert to rates as percentages of Dorado execution time"	#(#(#testAllCallsOn 'AllCallsOn' 1.8)		#(#testAllImplementors 'AllImplementors' 3.25)		#(#testClassOrganizer 'ClassOrganizer' 6.05)		#(#testCompiler 'Compiler' 4.46)		#(#testDecompiler 'Decompiler' 6.2)		#(#testInspect 'Inspect' 4.55)		#(#testPrintDefinition 'PrintDefinition' 4.25)		#(#testPrintHierarchy 'PrintHierarchy' 10.0)		#(#testTextDisplay 'TextDisplay' 6.4)		#(#testTextEditing 'TextEditing' 5.275)		#(#testTextFormatting 'TextFormatting' 11.5)		#(#testAsFloat 'AsFloat' 25.1)		#(#testBasicAt 'BasicAt' 4.6)		#(#testBasicAtPut 'BasicAtPut' 4.28)		#(#testFloatingPointAddition 'FloatingPointAddition' 24.6)		#(#testPerform 'Perform' 2.9)		#(#testStringReplace 'StringReplace' 205.2)		#(#testTextScanning 'TextScanning' 4.68)		#(#testLoadInstVar 'LoadInstVar' 2.75)		#(#testLoadLiteralIndirect 'LoadLiteralIndirect' 2.39)		#(#testLoadLiteralImmediate 'testLoadLiteralImmediate' 6.875)		#(#testLoadQuickConstant 'LoadQuickConstant' 9.82)		#(#testLoadTempImmediate 'LoadTempImmediate' 5.5)		#(#testLoadTemp 'LoadTemp' 7.8)		#(#testPopStoreInstVar 'PopStoreInstVar' 0.692)		#(#testPopStoreTemp 'PopStoreTemp' 2.61)		#(#test3div4 '3div4' 11.22)		#(#test3lessThan4 '3lessThan4' 3.6)		#(#test3plus4 '3plus4' 4.77)		#(#test3times4 '3times4' 1.975)		#(#testActivationReturn 'ActivationReturn' 9.96)		#(#testWhileLoop 'WhileLoop' 1.0775)		#(#testArrayAt 'ArrayAt' 4.675)		#(#testArrayAtPut 'ArrayAtPut' 3.285)		#(#testSize 'Size' 5.76)		#(#testStringAt 'StringAt' 7.32)		#(#testStringAtPut 'StringAtPut' 5.7)		#(#testClass 'Class' 6.3)		#(#testCreation 'Creation' 3.47)		#(#testEQ 'EQ' 3.65)		#(#testLoadThisContext 'LoadThisContext' 0.78)		#(#testPointCreation 'PointCreation' 7.32)		#(#testPointX 'PointX' 3.46)		#(#testStreamNext 'StreamNext' 8.92)		#(#testStreamNextPut 'StreamNextPut' 10.35)		#(#testValue 'Value' 3.735))			do: [:selectorLabelTime |				AvailableBenchmarks addLast: (selectorLabelTime at: 1).				BenchmarkLabels at: (selectorLabelTime at: 1) put: (selectorLabelTime at: 2).				DoradoBenchmarkTimes at: (selectorLabelTime at: 1) put: (selectorLabelTime at: 3)].	InitiallySelectedBenchmarks :=			#(	#testAllCallsOn #testAllImplementors				#testTextScanning #testClassOrganizer				#testPrintDefinition #testPrintHierarchy				#testInspect				#testCompiler #testDecompiler				#testTextDisplay #testTextFormatting #testTextEditing) asSet.	NonIOMacroBenchmarks :=			#(	#testAllCallsOn #testAllImplementors				#testClassOrganizer				#testPrintDefinition #testPrintHierarchy				#testInspect				#testCompiler #testDecompiler				#testTextFormatting) asSet</body></methods><methods><class-id>Tools.BenchmarkRunner</class-id> <category>private</category><body package="AT Benchmarks">beginningOfIteration	"Override to do nothing"</body><body package="AT Benchmarks">endOfIteration	"Override to do nothing."</body><body package="AT Benchmarks">endOfRun	"Override to do nothing."</body><body package="AT Benchmarks">numberOfMethodsScaleFactor	"This class doesn't care."	^1</body></methods><methods><class-id>Tools.BenchmarkRunner</class-id> <category>testing</category><body package="AT Benchmarks">run	Cursor execute showWhile:		[profiler value == #nil			ifTrue: [super run]			ifFalse: [profiler value asQualifiedReference value profile: [super run]]]</body><body package="AT Benchmarks">test: aBlock labeled: label repeated: nTimes 	"This is the main message to a Benchmark. aBlock is repeated nTimes."	nTimes timesRepeat: [aBlock value]</body><body package="AT Benchmarks">test: aBlock labeled: label repeated: nTimes scaledBy: scale	"This is the main message to a Benchmark. aBlock is repeated nTimes."	nTimes timesRepeat: [aBlock value]</body><body package="AT Benchmarks">test: aBlock labeled: label repeated: nTimes using: selector	"Intercept message to ensure the other testing messags are being used."	^self shouldNotImplement</body><body package="AT Benchmarks">test: aBlock labeled: label repeated: nTimes using: selector scaledBy: scale	"Intercept message to ensure the other testing messags are being used."	^self shouldNotImplement</body><body package="AT Benchmarks">testDisplayOperation: aBlock labeled: label repeated: nTimes 	"This is the main message to a benchmark that performs display 	operations.  aBlock is repeated nTimes."	| screen |	screen :=  Screen default.	nTimes timesRepeat: [aBlock value. screen sync]</body></methods><methods><class-id>Tools.BenchmarkRunner</class-id> <category>aspects</category><body package="AT Benchmarks">helpText	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^helpText isNil		ifTrue:			[helpText := String new asValue]		ifFalse:			[helpText]</body><body package="AT Benchmarks">profilerType	^profiler</body></methods><methods><class-id>Tools.BenchmarkRunner</class-id> <category>menu building</category><body package="AT Benchmarks">profilerMenu	| menu |	menu := self class profilerMenu.	menu 		augmentFrom: self class		to: self class		menuName: #profilerMenu		for: self.	^menu</body></methods><methods><class-id>Tools.BenchmarkRunner</class-id> <category>initialize-release</category><body package="AT Benchmarks">initialize	super initialize.	transcript := nil.	profiler := #nil asValue.	self helpText value: self class helpText asString</body></methods><methods><class-id>Tools.BenchmarkRunner class</class-id> <category>resources</category><body package="AT Benchmarks">helpText	^#BenchmarkRunnerHelpText &lt;&lt; #advanced &gt;&gt; 'BenchmarkRunner is a specialized type of SystemBenchmark that allows one to run any of the various system profilers (if they are in the system) over the selected benchmarks.'</body></methods><methods><class-id>Tools.BenchmarkTable</class-id> <category>private</category><body package="AT Benchmarks">characterWidthOfColumn: columnNumber	"Answer the character width of the widest field in the specified column."	| max |	max := (self outputStringFor: (columnLabels at: columnNumber)) size.	rows do:		[:row | | elementWidth |		elementWidth := (self outputStringFor: (row at: columnNumber)) size.		elementWidth &gt; max ifTrue: [max := elementWidth]].	^max</body><body package="AT Benchmarks">outputStringFor: anObject	"Answer the string to be output for anObject."	"Use the object itself if it is a String. If the object is a real	and significantDigits is non-nil, then print to that many digits;	otherwise use the printString."	^anObject isString		ifTrue: [anObject]		ifFalse: [((anObject isKindOf: LimitedPrecisionReal) and: [significantDigitsnotNil])					ifTrue: [| strm |						strm := (String new: 10) writeStream.						anObject printOn: strm digits: significantDigits.						strm contents ]					ifFalse: [anObject printString]]</body><body package="AT Benchmarks">printRow: rowElements on: aStream columnWidths: columnWidths	"Print the row elements on aStream, formatted with the specified	column widths."	| lastElement |	lastElement := rowElements size.	1 to: lastElement do:		[:index | | fieldString |		fieldString := self outputStringFor: (rowElements at: index).		aStream nextPutAll: fieldString.		(columnWidths at: index) - fieldString size			timesRepeat: [aStream space].		index = lastElement ifFalse: [aStream tab]].	aStream cr</body></methods><methods><class-id>Tools.BenchmarkTable</class-id> <category>accessing</category><body package="AT Benchmarks">name	"Answer the name of the benchmark table."	^name</body><body package="AT Benchmarks">numberOfColumns	"Answer the number of columns in the table."	^columnLabels size</body><body package="AT Benchmarks">numberOfRows	"Answer the number of rows in the table."	^rows size</body></methods><methods><class-id>Tools.BenchmarkTable</class-id> <category>printing</category><body package="AT Benchmarks">printOn: aStream	"Print myself on aStream.  Format the output to print prettily	assuming a fixed-pitch font."	| columnWidths |	aStream nextPutAll: (self outputStringFor: name); cr; cr.	columnWidths :=		(1 to: self numberOfColumns) collect:			[:columnNumber | self characterWidthOfColumn: columnNumber].	self printRow: columnLabels on: aStream columnWidths: columnWidths.	self printRow: (columnLabels collect: [:label | String new: label size withAll: $-])		on: aStream		columnWidths: columnWidths.	aStream cr.	rows do:		[:row |		self printRow: row on: aStream columnWidths: columnWidths]</body></methods><methods><class-id>Tools.BenchmarkTable</class-id> <category>initialize-release</category><body package="AT Benchmarks">name: nameString columnLabels: labels	^self name: nameString columnLabels: labels significantDigits: nil</body><body package="AT Benchmarks">name: nameString columnLabels: labels significantDigits: anIntegerOrNil	name := nameString.	columnLabels := labels.	rows := OrderedCollection new.	significantDigits := anIntegerOrNil</body></methods><methods><class-id>Tools.BenchmarkTable</class-id> <category>adding</category><body package="AT Benchmarks">addRow: rowElements	"Add the specified row elements to the end of the table."	rowElements size = columnLabels size		ifFalse: [^self error: #incorrectNumberOfRowElements &lt;&lt; #advanced &gt;&gt; 'incorrect number of row elements'].	rows addLast: rowElements</body></methods><methods><class-id>Tools.BenchmarkTable class</class-id> <category>instance creation</category><body package="AT Benchmarks">name: nameString columnLabels: labels	"Create a new benchmark table with the specified name and column headings."	^self name: nameString columnLabels: labels significantDigits: nil</body><body package="AT Benchmarks">name: nameString columnLabels: labels significantDigits: anIntegerOrNil	"Create a new benchmark table with the specified name, column headings,	and significant digits."	^self new name: nameString columnLabels: labels significantDigits:anIntegerOrNil</body></methods><methods><class-id>Tools.Inspector class</class-id> <category>view creation</category><body package="AT Benchmarks">buildScheduledView: anInspector 	"Build the view for anInspector but do not open it. This method is called during 	benchmarking only."	anInspector allButOpenInterface: #windowSpec</body></methods><methods><class-id>Tools.Benchmark class</class-id> <category>interface specs</category><body package="AT Benchmarks">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#properties: #(#{UI.PropertyListDictionary} #labelFromApplication true ) 			#label: #name 			#min: #(#{Core.Point} 40 20 ) 			#max: #(#{Core.Point} 1024 768 ) 			#bounds: #(#{Graphics.Rectangle} 163 239 1023 762 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 25 0 200 0 -5 1 ) 					#model: #benchmarkSelectorsHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #setSelectedBenchmarks ) 					#menu: #benchmarkSelectionMenu 					#multipleSelections: true 					#useModifierKeys: true 					#selectionType: #checkMark ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 5 5 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #BenchmarksC 						#defaultString: 'Benchmarks:' 						#catalogID: #advanced ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 210 486 405 516 ) 					#model: #run 					#tabable: true 					#label: 					#(#{Kernel.UserMessage} 						#key: #Run 						#defaultString: 'Run' 						#catalogID: #advanced ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 210 0 50 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #IterationsC 						#defaultString: 'Iterations:' 						#catalogID: #advanced ) ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 225 81 ) 					#model: #measureRatesHolder 					#tabable: true 					#label: #measurementsNameLowercase 					#select: false ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 315 81 ) 					#model: #measureRatesHolder 					#label: 					#(#{Kernel.UserMessage} 						#key: #rates 						#defaultString: 'rates' 						#catalogID: #advanced ) 					#select: true ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 225 150 ) 					#model: #reportRawMeasurementsHolder 					#tabable: true 					#label: 					#(#{Kernel.UserMessage} 						#key: #RawMeasurements 						#defaultString: 'Raw measurements' 						#catalogID: #advanced ) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 225 175 ) 					#model: #reportIndividualStatisticsHolder 					#tabable: true 					#label: 					#(#{Kernel.UserMessage} 						#key: #BenchmarkResults 						#defaultString: 'Benchmark results' 						#catalogID: #advanced ) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 225 281 ) 					#model: #reportOverallStatisticsHolder 					#tabable: true 					#label: 					#(#{Kernel.UserMessage} 						#key: #OverallSuiteStatistics 						#defaultString: 'Overall suite statistics' 						#catalogID: #advanced ) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 244 196 ) 					#name: #individualMinimum 					#model: #individualMinimum 					#label: 					#(#{Kernel.UserMessage} 						#key: #minimum 						#defaultString: 'minimum' 						#catalogID: #advanced ) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 244 216 ) 					#name: #individualMaximum 					#model: #individualMaximum 					#tabable: true 					#label: 					#(#{Kernel.UserMessage} 						#key: #maximum 						#defaultString: 'maximum' 						#catalogID: #advanced ) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 244 256 ) 					#name: #individualMean 					#model: #individualMean 					#tabable: true 					#label: 					#(#{Kernel.UserMessage} 						#key: #arithmeticMean 						#defaultString: 'arithmetic mean' 						#catalogID: #advanced ) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 244 236 ) 					#name: #individualMedian 					#model: #individualMedian 					#tabable: true 					#label: 					#(#{Kernel.UserMessage} 						#key: #median 						#defaultString: 'median' 						#catalogID: #advanced ) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 244 302 ) 					#name: #overallMinimum 					#model: #overallMinimum 					#tabable: true 					#label: 					#(#{Kernel.UserMessage} 						#key: #minimum 						#defaultString: 'minimum' 						#catalogID: #advanced ) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 244 322 ) 					#name: #overallMaximum 					#model: #overallMaximum 					#tabable: true 					#label: 					#(#{Kernel.UserMessage} 						#key: #maximum 						#defaultString: 'maximum' 						#catalogID: #advanced ) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 244 362 ) 					#name: #overallMean 					#model: #overallMean 					#tabable: true 					#label: 					#(#{Kernel.UserMessage} 						#key: #harmonicMean 						#defaultString: 'harmonic mean' 						#catalogID: #advanced ) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 244 342 ) 					#name: #overallMedian 					#model: #overallMedian 					#tabable: true 					#label: 					#(#{Kernel.UserMessage} 						#key: #median 						#defaultString: 'median' 						#catalogID: #advanced ) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 225 422 ) 					#model: #reportOnTranscriptHolder 					#tabable: true 					#label: 					#(#{Kernel.UserMessage} 						#key: #BenchmarkTranscript 						#defaultString: 'Benchmark Transcript' 						#catalogID: #advanced ) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 225 446 ) 					#model: #reportOnFileHolder 					#tabable: true 					#label: 					#(#{Kernel.UserMessage} 						#key: #FileC 						#defaultString: 'File:' 						#catalogID: #advanced ) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 290 446 395 467 ) 					#model: #outputFilenameHolder 					#tabable: true 					#type: #text ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 315 25 405 51 ) 					#model: #iterationsHolder 					#tabable: true 					#type: #number ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.Rectangle} 210 55 405 116 ) 					#name: #GroupBox1 					#label: 					#(#{Kernel.UserMessage} 						#key: #Measure 						#defaultString: 'Measure' 						#catalogID: #advanced ) ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.Rectangle} 210 125 405 395 ) 					#name: #GroupBox2 					#label: 					#(#{Kernel.UserMessage} 						#key: #IncludeInReport 						#defaultString: 'Include in report' 						#catalogID: #advanced ) ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.Rectangle} 210 400 405 480 ) 					#name: #GroupBox3 					#label: 					#(#{Kernel.UserMessage} 						#key: #WriteReportTo 						#defaultString: 'Write report to' 						#catalogID: #advanced ) ) 				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 415 0 25 0 -5 1 -5 1 ) 					#name: #ViewHolder1 					#flags: 0 					#component: #benchmarkTranscript ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 415 5 ) 					#name: #Label1 					#label: 					#(#{Kernel.UserMessage} 						#key: #BenchmarkTranscriptC 						#defaultString: 'Benchmark Transcript:' 						#catalogID: #advanced ) ) ) ) )</body></methods><methods><class-id>Tools.BenchmarkRunner class</class-id> <category>resources</category><body package="AT Benchmarks">profilerMenu	"Tools.MenuEditor new openOnClass: self andSelector: #profilerMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 					#(#{Kernel.UserMessage} 						#key: #NoProfiler 						#defaultString: 'No Profiler' 						#catalogID: #advanced  ) 				#nameKey: #noProfiler 				#value: #nil ) 			#(#{UI.MenuItem} 				#rawLabel: 					#(#{Kernel.UserMessage} 						#key: #TimeProfiler 						#defaultString: 'Time Profiler' 						#catalogID: #advanced )				#nameKey: #timeProfiler 				#value: #TimeProfiler ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} 						#key: #AllocationProfiler 						#defaultString: 'Allocation Profiler' 						#catalogID: #advanced )				#nameKey: #AllocationProfiler 				#value: #AllocationProfiler ) ) #(3 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.BenchmarkRunner class</class-id> <category>interface specs</category><body package="AT Benchmarks">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#properties: #(#{UI.PropertyListDictionary} #labelFromApplication true ) 			#label: #name 			#min: #(#{Core.Point} 300 430 ) 			#max: #(#{Core.Point} 1024 768 ) 			#bounds: #(#{Graphics.Rectangle} 512 338 812 768 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 25 0 -10 1 -105 1 ) 					#name: #benchmarkSelectorsHolder 					#model: #benchmarkSelectorsHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #setSelectedBenchmarks ) 					#menu: #benchmarkSelectionMenu 					#multipleSelections: true 					#useModifierKeys: true 					#selectionType: #checkMark ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.5 -100 1 -10 1 -75 1 ) 					#name: #iterationsHolder 					#model: #iterationsHolder 					#tabable: true 					#type: #number ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.5 -70 1 -10 1 -45 1 ) 					#name: #profilerMenu 					#model: #profilerType 					#menu: #profilerMenu ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -40 0.5 -35 1 40 0.5 -10 1 ) 					#model: #run 					#tabable: true 					#label: 					#(#{Kernel.UserMessage} 						#key: #Run 						#defaultString: 'Run' 						#catalogID: #advanced ) 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 10 4 ) 					#name: #Benchmarks 					#label: 					#(#{Kernel.UserMessage} 						#key: #BenchmarksC 						#defaultString: 'Benchmarks:' 						#catalogID: #advanced ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 -75 1 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #IterationsPerRun 						#defaultString: 'Iterations per run:' 						#catalogID: #advanced ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 -45 1 0 1 ) 					#name: #profilerToUseLabel 					#label: 					#(#{Kernel.UserMessage} 						#key: #ProfilerToUseC 						#defaultString: 'Profiler to use:' 						#catalogID: #advanced ) ) ) ) )</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>menus - tools - advanced</category><body package="AT Benchmarks">menuItemBenchmarkRunner	&lt;menuItemForCommand: #openBenchmarkRunner		nameKey: nil		menu: #(#menuBar #tools #atTools #atProfiles)		position: 10.6&gt;	self openApplicationForClassNamed: #{BenchmarkRunner} withSelector: #open</body><body package="AT Benchmarks">menuItemSystemBenchmark	&lt;menuItemForCommand: #openSystemBenchmark		nameKey: nil		menu: #(#menuBar #tools #atTools)		position: 10.3&gt;	self openApplicationForClassNamed: #{SystemBenchmark} withSelector: #open</body></methods><methods><class-id>UI.CommandRegistry class</class-id> <category>commands - launcher</category><body package="AT Benchmarks">openBenchmarkRunnerCommand	&lt;command: #openBenchmarkRunner&gt;	^Command		label: #ATBenchmarkRunner &lt;&lt; #menus &gt;&gt; 'Benchmark runner'		group: #launcher		bindings: #()</body><body package="AT Benchmarks">openSystemBenchmarkCommand	&lt;command: #openSystemBenchmark&gt;	^Command		label: #ATBenchmarks &lt;&lt; #menus &gt;&gt; 'Benchmarks'		group: #launcher		bindings: #()</body></methods><initialize><class-id>Tools.SystemBenchmark</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>VisualLauncher</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuBar toolBar textCollector toolDock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>Tools-Misc</package></attributes></class></st-source>