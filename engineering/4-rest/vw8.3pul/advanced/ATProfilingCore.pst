<?xml version="1.0"?><st-source><!-- Name: AT Profiling CoreNotice: Copyright 1999-2014 Cincom Systems, Inc.  All rights reserved.Comment: This package contains the core components of the Advanced Tools profilers, and must be loaded in an image being profiled, either locally or remotely.  The TimeProfilerCore and the AllocationProfilerCore are used to profile, respectively, the time and space usage of a single process.  The corresponding multi-profilers attempt to profile all processes instead of one.  Note that all profilers rely on a statistical sampling heuristic to estimate, rather than on instrumentation to directly measure, the resources consumed by a process.  See the code comments for more information.Note that the new profilers should not be loaded over the old profiling code in 'AT Profiling'.This package was based on code contributed by Florin Mateoc, created with valuable assistance from his colleague Kerry LeClue, and once shipped as 'ATProfilingEnhancements'.  Florin also contributed to the validation of this package.  Florin's original code included a refactoring of the original VisualWorks profiler, once shipped as 'ATProfiling', and several modifications to that VisualWorks profiler, to improve accuracy, decrease overhead, report more details, and improve the lists of target primitives.  It also included the multi-process profilers.DbIdentifier: bear73DbTrace: 448500DbUsername: kgreekDbVersion: 8.1 - 1PackageName: AT Profiling CoreParcel: #('AT Profiling Core')ParcelName: AT Profiling CorePreReadBlock: [	| oldProfilerPresent |	oldProfilerPresent := (Parcel parcelOrPundleNamed: 'AT Profiling') notNil.	oldProfilerPresent 		ifTrue: [ Dialog warn: 'The new profiling parcels, ''AT Profiling Core'' and ''AT Profiling UI'', should not be loaded when ''AT Profiling'' is present.  Please unload ''AT Profiling'' if you want to load the new profiler.'. ].	oldProfilerPresent not]PrintStringCache: (8.1 - 1,kgreek)Version: 8.1 - 1Pre-Read Block: 	[	| oldProfilerPresent |	oldProfilerPresent := (Parcel parcelOrPundleNamed: 'AT Profiling') notNil.	oldProfilerPresent 		ifTrue: [ Dialog warn: 'The new profiling parcels, ''AT Profiling Core'' and ''AT Profiling UI'', should not be loaded when ''AT Profiling'' is present.  Please unload ''AT Profiling'' if you want to load the new profiler.'. ].	oldProfilerPresent not]Date: 8:40:31 AM October 10, 2014 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.1 (oct14.1) of October 10, 2014 on October 10, 2014 at 8:40:31 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>ProfilerCore</name><environment>Tools</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>accessPoint active incrementalGCs observedProcess priorityTally random rootTally samplingInterval scavenges nativeStackSpills numMarkStackOverflows numWeakObjectListOverflows numCompactNMethods extraMethods targetMethods </inst-vars><class-inst-vars>activeProfilerCore targetPrimNumbers targetMethods extraMethods </class-inst-vars><imports></imports><category>AT Profiling Core</category><attributes><package>AT Profiling Core</package></attributes></class><comment><class-id>Tools.ProfilerCore</class-id><body>A ProfilerCore spies on the execution of one or more processes.  It collects data, in the the form of a MesageTally tree, that provides an estimate -- rather than a direct measurement -- of the resources consumed.   A ProfilerCore operates by periodically interrupting the execution of the methods invoked during the course of a process and tallies the results of these 'probes' in its dynamically constructed MessageTally tree.  When the profiled process terminates or profiliing is stopped, the estimates of the resources consumed are prepared from the collected data by a collaborating Profiler and then, by default, presented to the user in a ProfileOutlineBrowser.ProfilerCore contains unused instance variables, in anticipation of support for remote profiling.  A ProfilerCore is the item that should be always co-located with the process or processes it profiles.  When profiling remotely, a ProfilerCore may not be co-located with the Profiler initiating the profiling run or the ProfileOutlineBrowser presenting the results.  Only packages containing ProfilerCore code must be loaded into images, potentially headless, that are the targets of remote profiling.Subclasses must implement the following messages:	accessing		defaultAmount		description		maxSampleSize	initialize-release		initializeWatcherInstance Variables	accessPoint		&lt;UndefinedObject|IPSocketAddress&gt;							address of the socket used to communicate with the image containing this ProfilerCore, if profiling is remote	active				&lt;Boolean&gt;						used to control the execution of the signaller loop of this ProfilerCore	incrementalGCs		&lt;Integer&gt;						the number of incremental garbage collections that occurred during the profiling run	lastSplicePoint		&lt;MessageTally&gt;						the point at which MessageTally subtrees generated by a remote ProfilerCore must be spliced into the local MessageTally in order to represent the execution tree of a logically distributed process	observedProcess	&lt;Process&gt;						the process being profiled	priorityTally			&lt;UndefiendObject|MessageTally&gt;						a MessageTally organized by process priority rather than by process, generated only when more than one process is being profiled	random				&lt;ScaledRandom&gt;						used to control the introduction of a limited amount of randomization in the delay between 'probes'	reducedTally		&lt;UndefinedObject|MessageTally&gt;						a MessageTally, generated only when profiling a distributed process, that omits the large, ancillary resource costs specific to distributed profiling (in particular, the cost of initializing and starting remote profilers)	rootTally			&lt;MessageTally&gt;						the tally always constructed by a ProfilerCore	samplingInterval		&lt;Integer&gt;						the trip value regulating when profiled processes are 'probed'	scavenges			&lt;Integer&gt;						the number of scavenges that occurred during the profiling run	signaller			&lt;Delay&gt;						governs the frequency of 'probes'	spliceRecords		&lt;Dictionary&gt;						of remote MessageTrees, required when profiling a logically distributed process involving several identical but iterated remote calls	targetMethods		&lt;Array of: (Array with: Behavior with: Symbol with: CompiledMethod1 with: CompiledMethod2)&gt;						like the class instance variable. Contains the methods installed before profiling, used for uninstalling the same methods, even if the class instance variable is updated	extraMethods		&lt;Array of: (Array with: Behavior with: Symbol with: CompiledMethod)&gt;Class Instance Variables	activeProfilerCore	&lt;ProfilerCore&gt;						an instance of a concrete subclass of ProfilerCore, the currently active ProfilerCore.	targetPrimNumbers	&lt;IdentitySet of: SmallInteger&gt;						primitive numbers for allocation primitives which are to be wrapped when profiling.  (You must add to this list if you add new primitives which allocate.  Do this by adding code to *ProfilerCore&gt;&gt;initTargetPrimitiveList.).	targetMethods		&lt;Array of: (Array with: Behavior with: Symbol with: CompiledMethod1 with: CompiledMethod2)&gt;						For every Behavior/Symbol pair (a method definition) we keep the CompiledMethod which is defined there (#1) and a new CompiledMethod (#2) which is to be installed during profiling.	extraMethods		&lt;Array of: (Array with: Behavior with: Symbol with: CompiledMethod)&gt;						For every Behavior/Symbol pair we keep a CompiledMethod which is called by CompiledMethod#2 above and so must be installed during profiling.</body></comment><class><name>TimeProfilerCore</name><environment>Tools</environment><super>Tools.ProfilerCore</super><private>false</private><indexed-type>none</indexed-type><inst-vars>callbackPrimitive initialTime otherProcessesTime time waitPrimitive </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AT Profiling Core</category><attributes><package>AT Profiling Core</package></attributes></class><comment><class-id>Tools.TimeProfilerCore</class-id><body>A TimeProfilerCore provides estimates of execution time consumption.  The resource tracked is elapsed wall-clock time.Instance Variables:	callBackPrimitive		&lt;CompiledMethod							'CCallback class compiledMethodAt: #primProcessCallback'	initialTime				&lt;Integer&gt;							a millisecondClock value	otherProcessesTime		&lt;Integer&gt;							a duration in milliseconds	time					&lt;Integer&gt;							a millisecondClock value	totalTime				&lt;Integer | UndefinedObject&gt;							a duration in milliseconds, used only if profiling remotely	waitPrimitive			&lt;CompilerMethod&gt;							'Semaphore compiledMethodAt: #wait'</body></comment><class><name>MessageTally</name><environment>Tools</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>accessPoint bytes class method msgCount name tally samples parent receivers selector </inst-vars><class-inst-vars>default </class-inst-vars><imports></imports><category>Opentalk-Profiling</category><attributes><package>AT Profiling Core</package></attributes></class><comment><class-id>Tools.MessageTally</class-id><body>Instances of MessageTally represent nodes in a tree that gathers statistics on resources used in various parts of the system.  Each node represents a message send, and the amount of a resource consumed.  Note that MessageTally contains unused instance variables, that come into play only when extensions for remote profiling are loaded into the image.Instance Variables:	accessPoint	&lt;IPSocketAddress | UndefinedObject&gt;					the address of the request broker used to communicate with this image, if profiling remotely	bytes			&lt;Integer | UndefinedObject&gt;					the size in bytes of the marshaled form of this message, if profiling remotely	class			&lt;Behavior&gt;					the class of the receiver of the message	method			&lt;CompiledMethod&gt;					the method running when a 'probe' occurred	msgCount		&lt;Integer | UndefinedObject&gt;					the number of times this message was sent remotely, if profiling remotely	name			&lt;String&gt;					a reasonable name for the MessageTally node	parent			&lt;MessageTally | UndefinedObject&gt;					the MessageTally on this context's sender	receivers		&lt;(IdentityDictionary of: MessageTally)&gt;					children of this node in the tree, representing tallies of methods called from this one. (If this field is nil, it indicates tallies due to primitives.)	samples		&lt;Integer&gt;					number of times this method was or its children were sampled	selector			&lt;Symbol | UndefinedObject&gt;					the selector of the message tallied (but if profiling remotely this will not be 'doesNotUnderstand:')	tally			&lt;Integer&gt;					amount of the resource consumed by this method or its childrenClass Instance Variables:	default			&lt;MessageTally&gt;					a default MessageTallyShared Variables:	Dummy			&lt;CompiledMethod&gt;					a dummy CompiledMethod	ObjectCache	&lt;(Array of: MessageTally)&gt;					an Array used to preallocate MessageTallys	StackHolder		&lt;(Array of: MethodContext&gt;					an Array used to optimize 'tally:by:'</body></comment><class><name>MultiTimeProfilerCore</name><environment>Tools</environment><super>Tools.TimeProfilerCore</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AT Profiling Core</category><attributes><package>AT Profiling Core</package></attributes></class><comment><class-id>Tools.MultiTimeProfilerCore</class-id><body>A MultiTimeProfilerCore provides estimates of execution time consumption, but for all of the process initiated between the time the profiler is started and stopped, rather than for a single process.  Users are urged to remember that all the profilers rely upon a statistical sampling heuristic to estimate, rather than on instrumentation to directly measure, the resources consumed by a process.  Multi-process profilers will distribute the probes used to estimate resource consumption over several processes, rather than one, mayhaps unevenly.  Also, running multi-process profilers will cause garbage collection and other maintenance processes to be run more frequently than otherwise.  These facts should be kept firmly in view when setting up multi-process profiling runs and when estimating the reliability of their results.  Within these limitations, multi-process profilers have proven useful in tuning web applications involving many hundreds of  processes.</body></comment><class><name>ProfilerProcessInfo</name><environment>Tools</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>priority displayString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Profiling</category><attributes><package>AT Profiling Core</package></attributes></class><comment><class-id>Tools.ProfilerProcessInfo</class-id><body>A ProfilerProcessInfo is used to record process-specific information for tallies that record resource use by multiple, co-located processes.Instance Variables:	displayString	&lt;String&gt;	a process description	priority			&lt;Integer&gt;	a process priority</body></comment><class><name>MessageTallyDefinition</name><environment>Tools</environment><super>Tools.GeneralMethodDefinition</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tally </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Profiling</category><attributes><package>AT Profiling Core</package></attributes></class><comment><class-id>Tools.MessageTallyDefinition</class-id><body>A MessageTallyDefinition wraps and provides an interface for extracting data from a tally.  MessageTallyDefinitions bear nearly the same API as other subclasses of GeneralMethodDefinition, and like them, may be used to represent MethodTallys in a browser.Instance Variables:	tally	&lt;MessageTally&gt;	the tally wrapped by the MethodTallyDefinition</body></comment><class><name>AllocationProfilerCore</name><environment>Tools</environment><super>Tools.ProfilerCore</super><private>false</private><indexed-type>none</indexed-type><inst-vars>byteCount currentlyActive keepStatistics statistics </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AT Profiling Core</category><attributes><package>AT Profiling Core</package></attributes></class><comment><class-id>Tools.AllocationProfilerCore</class-id><body>AllocationProfilerCore provides estimates of memory space consumption. The resource consumption it tracks is bytes of objects allocated.  In order to track allocations, we need to be notified by any method which does an allocation (by calling a primitive).  Such allocating methods must use 'AllocationProfiler tallyNew: newObject' to report a newly allocated object.  (See 'AllocationProfilerCore class&gt;&gt;makeWrappedMethodCodeFor:using:' for details.)  Methods which call allocation primitives *without* doing this would make for untracked allocations.  Class-side methods in AllocationProfilerCore know how to find all methods which define allocation primitives; before profiling, such methods are "wrapped" by making an "inner method" which actually calls the primitive and replacing the original method with one which calls the inner method. The wrapped methods are removed after profiling.  See the class-side comment of ProfilerCore for more details on wrapping.Because of restrictions in the implementation, only one AllocationProfilerCore can be running at any given time.Instance Variables:	byteCount		&lt;Integer&gt;					running count of allocated bytes as reported by senders of #tallyNew:	currentlyActive	&lt;Boolean&gt;					true when the observedProcess is allocating normal objects, false when the allocations are occurring only for the purposes of AllocationProfiler bookkeeping, so that the observedProcess is not penalized for being profiled	keepStatistics	&lt;Boolean&gt;					'true' if the AllocationProfilerCore is set to generate space usage statistics by class	statistics		&lt;IdentityDictionary | nil&gt;					optionally used to construct a histogram of instances created by class.Shared Variables:	ByteOverhead	&lt;Integer&gt; 					implementation-specific per-object overhead (in bytes), 4-bytes per slot is assumed in the code</body></comment><class><name>ScaledRandom</name><environment>Smalltalk</environment><super>Core.FastRandom</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Profiling</category><attributes><package>AT Profiling Core</package></attributes></class><comment><class-id>ScaledRandom</class-id><body>A ScaledRandom is used the regulate the frequency of profiling 'probes'.</body></comment><class><name>MultiAllocationProfilerCore</name><environment>Tools</environment><super>Tools.AllocationProfilerCore</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AT Profiling Core</category><attributes><package>AT Profiling Core</package></attributes></class><comment><class-id>Tools.MultiAllocationProfilerCore</class-id><body>A MultiAllocationProfilerCore provides estimates of memory space consumption, but for all of the process initiated between the time the profiler is started and stopped, rather than for a single process.  Users are urged to remember that all the profilers rely upon a statistical sampling heuristic to estimate, rather than on instrumentation to directly measure, the resources consumed by a process.  Multi-process profilers will distribute the probes used to estimate resource consumption over several processes, rather than one, mayhaps unevenly.  Also, running multi-process profilers will cause garbage collection and other maintenance processes to be run more frequently than otherwise.  These facts should be kept firmly in view when setting up multi-process profiling runs and when estimating the reliability of their results.  Within these limitations, multi-process profilers have proven useful in tuning web applications involving many hundreds of  processes.</body></comment><shared-variable><name>ObjectCache</name><environment>Tools.MessageTally</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>AT Profiling Core</package></attributes></shared-variable><shared-variable><name>Dummy</name><environment>Tools.MessageTally</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>AT Profiling Core</package></attributes></shared-variable><shared-variable><name>StackHolder</name><environment>Tools.MessageTally</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>AT Profiling Core</package></attributes></shared-variable><shared-variable><name>ByteOverhead</name><environment>Tools.AllocationProfilerCore</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>AT Profiling Core</package></attributes></shared-variable><methods><class-id>Tools.ProfilerCore</class-id> <category>accessing</category><body package="AT Profiling Core">accessPoint	^accessPoint</body><body package="AT Profiling Core">accessPoint: anObject	accessPoint := anObject</body><body package="AT Profiling Core">defaultSamplingInterval	"Answer the default amount of resource to be consumed before sampling."	self subclassResponsibility</body><body package="AT Profiling Core">description	"Answer a string appropriate for labeling a resource report."	self subclassResponsibility</body><body package="AT Profiling Core">incrementalGCs	^incrementalGCs</body><body package="AT Profiling Core">maxSamplingInterval	"Answer an appropriate upper bound for sampleSize"	self subclassResponsibility</body><body package="AT Profiling Core">nativeStackSpills	^nativeStackSpills</body><body package="AT Profiling Core">numCompactNMethods	^numCompactNMethods</body><body package="AT Profiling Core">numMarkStackOverflows	^numMarkStackOverflows</body><body package="AT Profiling Core">numWeakObjectListOverflows	^numWeakObjectListOverflows</body><body package="AT Profiling Core">priorityTally	^( priorityTally isNil )		ifTrue:	[ priorityTally := self generatePriorityTally ]		ifFalse:	[ priorityTally ]</body><body package="AT Profiling Core">rootTally	^rootTally</body><body package="AT Profiling Core">samples	^rootTally samples</body><body package="AT Profiling Core">samplingInterval	"Answer the amount that will trigger a sample of the execution, in appropriate units"	^samplingInterval</body><body package="AT Profiling Core">scavenges	^scavenges</body><body package="AT Profiling Core">tally	^rootTally tally</body></methods><methods><class-id>Tools.ProfilerCore</class-id> <category>initialize-release</category><body package="AT Profiling Core">initialize	"Initialize the ProfilerCore."	samplingInterval := self defaultSamplingInterval.	self initializeWatcher.	observedProcess := Processor activeProcess.</body><body package="AT Profiling Core">initializeWatcher	self subclassResponsibility</body></methods><methods><class-id>Tools.ProfilerCore</class-id> <category>state transition</category><body package="AT Profiling Core">coreFinishedProfiling	"Prepare the rootTally for report generation."	rootTally do: [:t | t name]	.	"Make sure names are computed before deinstalling wrappers."</body><body package="AT Profiling Core">postProfile	| objectMemory |	objectMemory := self currentObjectMemory.	scavenges := objectMemory numScavenges - scavenges.	incrementalGCs := objectMemory numIncGCs - incrementalGCs.	nativeStackSpills := objectMemory nativeStackSpills - nativeStackSpills.	numMarkStackOverflows := objectMemory numMarkStackOverflows - numMarkStackOverflows.	numWeakObjectListOverflows := objectMemory numWeakObjectListOverflows - numWeakObjectListOverflows.	numCompactNMethods := objectMemory numCompactNMethods - numCompactNMethods</body><body package="AT Profiling Core">preProfile	| objectMemory |	objectMemory := self currentObjectMemory.	incrementalGCs := objectMemory numIncGCs.	scavenges := objectMemory numScavenges.	nativeStackSpills := objectMemory nativeStackSpills.	numMarkStackOverflows := objectMemory numMarkStackOverflows.	numWeakObjectListOverflows := objectMemory numWeakObjectListOverflows.	numCompactNMethods := objectMemory numCompactNMethods.	active := true.</body><body package="AT Profiling Core">profileOnExitDo: exitBlock	"Start the watcher process and run the block."	| invocationPriority |	invocationPriority := Processor activeProcess priority.	[self preProfile.		[[active]			whileTrue:				[(random next + 1000) microseconds wait.	"make sure we wait at least 1 ms"				active					ifTrue: [self startTally]]		] ensure:			[self postProfile.			Processor activeProcess priority: invocationPriority.			exitBlock value ]	] forkAt: Processor timingPriority.</body><body package="AT Profiling Core">startTally	self subclassResponsibility</body><body package="AT Profiling Core">stopWatching	active := false</body></methods><methods><class-id>Tools.ProfilerCore</class-id> <category>public api</category><body package="AT Profiling Core">profile: aBlock	self class profile: aBlock.</body><body package="AT Profiling Core">samplingInterval: anInteger	"Set the amount of resource to be consumed before sampling."	samplingInterval := ( anInteger max: 1 ).	self initializeWatcher.</body><body package="AT Profiling Core">targetBlock: aBlock	"Set the profiler to spy on the supplied block."	rootTally :=		( ( MessageTally			class: aBlock method mclass 			method: aBlock method ) 				name: aBlock printString; 				yourself )</body></methods><methods><class-id>Tools.ProfilerCore</class-id> <category>utility</category><body package="AT Profiling Core">currentObjectMemory	^ObjectMemory current</body><body package="AT Profiling Core">generatePriorityTally	| dict keys newDict |	dict := rootTally receivers.	keys := (dict keys collect: [:p | p priority]) asSet.	newDict := IdentityDictionary new: keys size.	keys do: [:pri | | rolledUpTally |		rolledUpTally := MessageTally root name: (#ProcessesAtPriority1p &lt;&lt; #advanced &gt;&gt; 'Processes at priority &lt;1p&gt;'			expandMacrosWith: pri).		rolledUpTally parent: rootTally.		newDict at: pri put: rolledUpTally.		dict keysAndValuesDo: [:proc :tally |			proc priority = pri ifTrue: [tally addTo: rolledUpTally]]].	^( rootTally shallowCopy )		receivers: newDict;		yourself</body></methods><methods><class-id>Tools.ProfilerCore</class-id> <category>method switching</category><body package="AT Profiling Core">deinstallWrappers	"Remove all the wrapped methods and their inner methods."	[targetMethods		do:			[:quad |			| beh sel cm |			beh := quad at: 1.			sel := quad at: 2.			cm := quad at: 3.			(beh compiledMethodAt: sel ifAbsent: [nil]) == (quad at: 4) "if the method has changed, don't destroy the change"				ifTrue: [beh replaceMethodAt: sel withMethod: cm]].	extraMethods		do:			[:triple |			| beh sel |			beh := triple at: 1.			sel := triple at: 2.			(beh includesSelector: sel)	"defensive programming"				ifTrue: [beh removeSelectorSimply: sel]]	] valueUninterruptably</body><body package="AT Profiling Core">installWrappers	"Replace all the methods to be profiled with their wrapped	versions (installing the inner methods first)."	extraMethods := self class extraMethods.	targetMethods := self class targetMethods.	[extraMethods do:		[:triple |		| beh sel cm |		beh := triple at: 1.		sel := triple at: 2.		cm := triple at: 3.		beh replaceMethodAt: sel withMethod: cm].	targetMethods do:		[:quad |		| beh sel cm |		beh := quad at: 1.		sel := quad at: 2.		cm := quad at: 4.		beh replaceMethodAt: sel withMethod: cm]	] valueUninterruptably</body></methods><methods><class-id>Tools.ProfilerCore class</class-id> <category>accessing</category><body package="AT Profiling Core">activeProfilerCore	^activeProfilerCore</body><body package="AT Profiling Core">activeProfilerCore: core	activeProfilerCore := core</body></methods><methods><class-id>Tools.ProfilerCore class</class-id> <category>public access</category><body package="AT Profiling Core">coreStopProfiling	self subclassResponsibility</body></methods><methods><class-id>Tools.ProfilerCore class</class-id> <category>method substitute construction</category><body package="AT Profiling Core">buildWrappers	"Construct the wrappers and their inner methods."	| i |	extraMethods := Array new: targetMethods size.	i := 1.	targetMethods do:		[:quad |		| beh sel cm newSel extraCm wrapCode wrappedCm |		beh := quad at: 1.		sel := quad at: 2.		cm := quad at: 3.		newSel := self makeInnerSelectorFrom: sel.		extraCm := self makeExtraMethodFrom: cm named: newSel.		wrapCode := self makeWrappedMethodCodeFor: sel using: newSel.		wrappedCm := Compiler new compile: wrapCode in: nil allowReceiver: true				class: beh environment: self environment				noPattern: false notifying: nil ifFail: [nil].		self fixupStatics: wrappedCm.		wrappedCm sourcePointer: cm sourcePointer.		quad at: 4 put: wrappedCm.		extraMethods at: i put: (Array with: beh with: newSel with: extraCm).		i := i + 1]</body><body package="AT Profiling Core">findTargetPrimitives	"Find all the methods in the system which define targeted	primitives and record them."	| pam |	pam := OrderedCollection new: targetPrimNumbers size * 2.	SystemUtils allBehaviorsDo:		[:beh |		beh selectorsAndMethodsDo:			[:sel :cm |			(targetPrimNumbers includes: cm primitiveNumber)					ifTrue: [pam add: (Array with: beh with: sel with: cm with: nil)]]].	targetMethods := pam asArray</body><body package="AT Profiling Core">fixupStatics: method	method withAllBlockMethods do: [:m |		1 to: m numLiterals do: [:i | | lit |			lit := m literalAt: i.			(lit isVariableBinding and: [lit isDeferred])				ifTrue: [m basicAt: i put: lit binding]]]</body><body package="AT Profiling Core">initTargetPrimitiveList	"Build the list of primitives to be subject to special profiling."	targetPrimNumbers := IdentitySet new</body></methods><methods><class-id>Tools.ProfilerCore class</class-id> <category>testing</category><body package="AT Profiling Core">methodsAreCurrent	"test if targetMethods contains only current i.e bound methods.	 unbound methods exist if a method is deleted or changed and	 targetMethods is not updated"	^targetMethods allSatisfy: [:eachArray | (eachArray at: 3) isBound]</body><body package="AT Profiling Core">needsSafeRebinding	^true</body></methods><methods><class-id>Tools.ProfilerCore class</class-id> <category>opentalk priorities</category><body package="AT Profiling Core">remoteProfilingPriority	"The watcher process must run at a higher priority than the Opentalk worker process priority.  The latter is a configurable parameter, so we need to do arithmetic."	^#{Opentalk.RequestTransport} 		ifDefinedDo:  [ :x | x workerPriority + 1 ]</body></methods><methods><class-id>Tools.ProfilerCore class</class-id> <category>private</category><body package="AT Profiling Core">extraMethods	"rebuild the collection if necessary, i.e. after methods with primitives have been updated, added or removed"	(extraMethods isNil or: [self methodsAreCurrent not])		ifTrue: 			[self findTargetPrimitives.			self buildWrappers].	^extraMethods</body><body package="AT Profiling Core">makeExtraMethodFrom: aCompiledMethod named: newSel	"Answer a suitable inner method (for a wrapper) from the provided compiled method.  Leaves the sources wrong, but who cares?"	^aCompiledMethod</body><body package="AT Profiling Core">makeInnerSelectorFrom: aSymbol	"Construct a selector from the supplied symbol appropriate for an inner method selector."	| namePart |	namePart := aSymbol isInfix		ifTrue:			[| s |			s := (String new: 10) writeStream.			aSymbol do: [:ch | s print: ch asInteger; nextPut: $_].			s nextPut: $:.			s contents]		ifFalse: [aSymbol].	^(self name, '_', namePart) asSymbol</body><body package="AT Profiling Core">makeWrappedMethodCodeFor: oldSelector using: newSelector	"Make the code for a new wrapped method called oldSelector which calls the inner method named newSelector."	self subclassResponsibility</body><body package="AT Profiling Core">targetMethods	"rebuild the collection if necessary, i.e. after methods with primitives have been updated, added or removed"	(targetMethods isNil or: [self methodsAreCurrent not])		ifTrue: 			[self findTargetPrimitives.			self buildWrappers].	^targetMethods</body></methods><methods><class-id>Tools.ProfilerCore class</class-id> <category>instance creation</category><body package="AT Profiling Core">new	"Answer a new ProfilerAgent, properly initialized.  Catch the simple error of using the abstract class."	( self == ProfilerCore ) 		ifTrue: [ ^self error: (#ProfilerCoreIsAnAbstractClassUseAConcreteSubclass &lt;&lt; #advanced &gt;&gt; 'ProfilerCore is an abstract class.  Use a concrete subclass.') ].	^super new initialize</body></methods><methods><class-id>Tools.ProfilerCore class</class-id> <category>validation</category><body package="AT Profiling Core">checkConsistency: aClass	"((( ProfilerCore checkConsistency: TimeProfilerCore )))"	"((( ProfilerCore checkConsistency: AllocationProfilerCore )))"		| space tab primitives primitiveNumbers class checkedNumbers wrongPrimitiveNumbers missingSelectors replacedNumbers wronglyAttributedNumbers matched result uncheckedMethods uncheckedNumbers |	space := Character space.	tab := Character tab.	class := aClass class.	primitives := CompiledMethod allGeneralInstances		select: [:e | e primitiveNumber notNil].	primitiveNumbers := (primitives collect: [:e | e primitiveNumber]) asSet.	checkedNumbers := Set new.	wrongPrimitiveNumbers := Dictionary new.	missingSelectors := OrderedCollection new.	wronglyAttributedNumbers := OrderedCollection new.	matched := OrderedCollection new.	replacedNumbers := OrderedCollection new.	(class organization listAtCategoryNamed: #'building primitive list')		do:			[:sel | 			((class compiledMethodAt: sel) getSource string tokensBasedOn: Character cr)				do:					[:line | 					| actualMatches number tokens selector stream cl cm actualNumber |					line replaceAll: tab with: space.					tokens := line trimBlanks tokensBasedOn: $".					(tokens size = 3						and: [(tokens first indexOfSubCollection: 'add:' startingAt: 1) = 1])						ifTrue:							[number := Integer								readFrom:									(tokens first										copyFrom: 5										to: tokens first size) trimBlanks readStream.							checkedNumbers add: number.							actualMatches := primitives								select: [:e | e primitiveNumber = number].							tokens := ((tokens at: 2) trimBlanks tokensBasedOn: space)								asOrderedCollection.							selector := tokens removeLast asSymbol.							stream := ReadWriteStream on: (String new: 16).							tokens								do:									[:t | 									stream										nextPutAll: t;										space].							cl := Compiler evaluate: stream reset.							cl isBehavior								ifTrue:									[cm := cl										compiledMethodAt: selector										ifAbsent: [].									cm isNil										ifTrue:											[selector last == $.												ifTrue:													[| matchingMethods |													selector := selector														copyFrom: 1														to: (selector indexOf: $.) - 1.													matchingMethods := Set new.													cl														selectorsAndMethodsDo:															[:eachSelector :eachMethod | 															(eachSelector indexOfSubCollection: selector startingAt: 1) = 1																ifTrue: [matchingMethods add: eachMethod]].													matchingMethods														detect:															[:c | 															c primitiveNumber = number																and:																	[matched add: number.																	true]]														ifNone:															[wrongPrimitiveNumbers at: number put: actualMatches.															missingSelectors add: stream contents , '&gt;&gt;' , selector]]												ifFalse:													[wrongPrimitiveNumbers at: number put: actualMatches.													missingSelectors add: stream contents , '&gt;&gt;' , selector]]										ifFalse:											[cm primitiveNumber = number												ifTrue: [matched add: number]												ifFalse:													[wrongPrimitiveNumbers at: number put: actualMatches.													actualNumber := cm primitiveNumber.													actualNumber notNil														ifTrue:															[checkedNumbers add: actualNumber.															replacedNumbers add: number -&gt; actualNumber]														ifFalse: [wronglyAttributedNumbers add: number -&gt; cm]]]]								ifFalse:									[wrongPrimitiveNumbers at: number put: actualMatches.									missingSelectors add: stream contents , '&gt;&gt;' , selector]]]].	uncheckedMethods := Dictionary new.	primitives		do:			[:p | 			(checkedNumbers includes: p primitiveNumber)				ifFalse:					[(uncheckedMethods						at: p mclass						ifAbsentPut: [IdentitySet new]) add: p]].	uncheckedNumbers := Dictionary new.	primitiveNumbers - checkedNumbers		do:			[:i | 			uncheckedNumbers				at: i				put: (primitives select: [:e | e primitiveNumber = i])].	result := IdentityDictionary new.	result at: #wrongPrimitiveNumbers put: wrongPrimitiveNumbers.	result at: #replacedNumbers put: replacedNumbers.	result at: #wronglyAttributedNumbers put: wronglyAttributedNumbers.	result at: #missingSelectors put: missingSelectors.	result at: #matched put: matched.	result at: #uncheckedNumbers put: uncheckedNumbers.	result at: #uncheckedMethods put: uncheckedMethods.	^result</body></methods><methods><class-id>Tools.ProfilerCore class</class-id> <category>updating</category><body package="AT Profiling Core">flushAllMethods	self withAllSubclasses do: [:c | c flushMethods]</body><body package="AT Profiling Core">flushMethods	targetMethods := nil.	extraMethods := nil</body><body package="AT Profiling Core">update: anAspectSymbol with: aParameter from: aSender	"whenever a method with a primitive is added or changed, the list of wrapped method is no longer up to date.	 We nil it out here and rebuild it later when needed"	aSender == ChangeSet ifFalse: [^self].	(#(#changeSelector:class:attributes: #addSelector:class:attributes:) includes: anAspectSymbol)			ifTrue: 				[| method |				method := (aParameter at: 2) compiledMethodAt: (aParameter at: 1).				method primitiveNumber notNil					ifTrue: [self flushAllMethods]].	#removeClass: == anAspectSymbol		ifTrue:			[(aParameter first inheritsFrom: ExternalInterface) ifTrue: [self flushAllMethods]].	#removeSelector:class: == anAspectSymbol		ifTrue: [((aParameter at: 2) inheritsFrom: ExternalInterface) ifTrue: [self flushAllMethods]].</body></methods><methods><class-id>Tools.ProfilerCore class</class-id> <category>class initialization</category><body package="AT Profiling Core">initialize	"Install the global variable and build the method-substitution lists."	"((( ProfilerCore initialize )))"	self initTargetPrimitiveList.	self findTargetPrimitives.	self buildWrappers.	ChangeSet addDependent: self</body></methods><methods><class-id>Tools.ProfilerCore class</class-id> <category>initialize-release</category><body package="AT Profiling Core">obsolete	ChangeSet removeDependent: self.	super obsolete.</body></methods><methods><class-id>Tools.TimeProfilerCore</class-id> <category>accessing</category><body package="AT Profiling Core">defaultSamplingInterval	"Answer the default number of time ticks between sampling."	^16</body><body package="AT Profiling Core">description	"Answer a string appropriate for labeling a resource report."	^(#ExecutionTime &lt;&lt; #advanced &gt;&gt; 'Execution Time') asString</body><body package="AT Profiling Core">maxSamplingInterval	"Answer an appropriate upper bound for sampling interval."	^200</body><body package="AT Profiling Core">otherProcessesTime	^otherProcessesTime</body><body package="AT Profiling Core">processTime	^self tally</body><body package="AT Profiling Core">time	^time</body><body package="AT Profiling Core">totalTime	^time - initialTime</body></methods><methods><class-id>Tools.TimeProfilerCore</class-id> <category>initialize-release</category><body package="AT Profiling Core">initialize	"Initialize the profiler to default values."	super initialize.	rootTally := MessageTally root name: ''.	otherProcessesTime := 0.	waitPrimitive := Semaphore compiledMethodAt: #wait.	callbackPrimitive := CCallback class compiledMethodAt: #primProcessCallback.</body><body package="AT Profiling Core">initializeWatcher 	random := ScaledRandom upperBound: (self samplingInterval * 2 min: self maxSamplingInterval) * 1000 - 1000.</body></methods><methods><class-id>Tools.TimeProfilerCore</class-id> <category>state transition</category><body package="AT Profiling Core">postProfile	time := Time microsecondClock.	super postProfile.</body><body package="AT Profiling Core">preProfile	super preProfile.	time := Time microsecondClock.	initialTime := time.</body><body package="AT Profiling Core">startTally	"Attribute the consumed resources to the tally tree."	| p newTime |	newTime := Time microsecondClock.	(p := Processor preemptedProcessWith: waitPrimitive with: callbackPrimitive) == observedProcess		ifTrue: [rootTally tally: p suspendedContext by: newTime - time]		ifFalse: [otherProcessesTime := otherProcessesTime + newTime - time].	time := Time microsecondClock.</body></methods><methods><class-id>Tools.TimeProfilerCore class</class-id> <category>public access</category><body package="AT Profiling Core">coreStopProfiling	| activePriority |	activePriority := Processor activePriority.	Processor activeProcess priority: Processor timingPriority.	( activeProfilerCore notNil )		ifTrue:	[ activeProfilerCore stopWatching ].	Processor activeProcess priority: activePriority</body></methods><methods><class-id>Tools.TimeProfilerCore class</class-id> <category>class initialization</category><body package="AT Profiling Core">initTargetPrimitiveList	"Build the list of primitives to be subject to time profiling."	targetPrimNumbers := IdentitySet new: 32.	self addMiscTimePrimsToList.	self addGraphicsTimePrimsToList.	self addIOTimePrimsToList.</body><body package="AT Profiling Core">initialize	"Build the method-substitution lists.  This is here so that the fileIn will automatically initialize"	"((( TimeProfilerCore initialize )))"	super initialize</body></methods><methods><class-id>Tools.TimeProfilerCore class</class-id> <category>private</category><body package="AT Profiling Core">makeWrappedMethodCodeFor: oldSelector using: newSelector	"Make the code for a new wrapped method called oldSelector which calls the inner method named newSelector.  We have to do wrapping to accurately measure the time consumed by primitives"	| ws numComponents components argPrefix hasArgs |	argPrefix := 'ARG'.	ws := WriteStream on: (String new: 100).	hasArgs := oldSelector numArgs &gt; 0.	components := oldSelector keywords.	numComponents := components size.	1 to: numComponents do:			[:i |			ws nextPutAll: (components at: i); space.			hasArgs				ifTrue:	[ws nextPutAll: argPrefix; print: i; space]].	ws nextPutAll: ('&lt;nt&gt;"Generated by &lt;1p&gt;"&lt;nnt&gt;| done result |&lt;nt&gt;done := false.&lt;nt&gt;[done] whileFalse:&lt;ntt&gt;[result := self ' expandMacrosWith: self).	components := newSelector keywords.	1 to: numComponents do:			[:i |			ws nextPutAll: (components at: i); space.			hasArgs				ifTrue:	[ws nextPutAll: argPrefix; print: i; space]].	ws nextPutAll: '.&lt;ntt&gt;done := true].&lt;nt&gt;^result' expandMacros.	^ws contents</body></methods><methods><class-id>Tools.TimeProfilerCore class</class-id> <category>building primitive list</category><body package="AT Profiling Core">addGraphicsTimePrimsToList	"Add to the list of target primitives those which should be profiled if you care about accurate measurement of the time spent in graphics primitives."	targetPrimNumbers		add: 850 "ApplicationWindow primGrowWindow:max:";		add: 900 "Screen allocatePixmapWithExtent:";		add: 901 "Screen allocateMaskWithExtent:";		add: 903 "Screen oldPrimAllocateFontNamed:";		add: 904 "Screen allocateCursorWithImage:...";		add: 905 "Screen getPixmapFromClipboard";		add: 906 "Screen allocateWindowAt:extent:min:max:windowType:owner:";		add: 907 "Window minimumWidth:height:maximumWidth:height:";		add: 908 "Screen primAllocateFontNamed:";		add: 910 "Screen getExternalSelection:";		add: 911 "Screen putExternalSelection:with:";		add: 912 "Screen primCursorLocPut:";		add: 916 "ScreenFont getWidths:into:";		add: 933 "ByteArray copyBitsClippedStride:...";		add: 934 "ByteArray tileBits32By32Stride:...";		add: 935 "Screen dragShape:...";		add: 936 "Screen resizeRectangle...";		add: 937 "Screen displayShape:...";		add: 938 "Window resizeFromUserWithMinimum:maximum:";		add: 940 "Window primClose";		add: 942 "Window getDimensions";		add: 943 "Window moveTo:resize:";		add: 944 "Window primMap";		add: 946 "Screen flush";		add: 947 "Screen getScreenDimensions";		add: 948 "Window primUnmap";		add: 949 "HostGraphicsDevice primPlatformName";		add: 950 "Screen sync";		add: 951 "Window setIconMask:";		add: 952 "Window primLabel:iconLabel:";		add: 953 "Window raise";		add: 954 "Window lower";		add: 955 "Screen queryStackingOrder";		add: 956 "TextMeasurer primScanCharactersFrom:...";		add: 957 "ScreenGraphicsContext primDisplayMappedString:from:to:at:withMap:";		add: 959 "Window setBackgroundPixel:";		add: 960 "Screen class primOpen:";		add: 962 "Window primCollapse";		add: 963 "Window primExpand";		add: 971 "Mask privateClose";		add: 972 "TextMeasurer primScanCharactersFrom:to:in:rightX:stopConditions:widths:";		add: 975 "ScreenGraphicsContext primDisplayTwoByteString:from:to:at:";		add: 976 "ScreenGraphicsContext primDisplayCharacterOfIndex:at:";		add: 977 "Screen primListFontNames";		add: 980 "ScreenFont primUnLoadFont";		add: 985 "ScreenGraphicsContext primDisplayLineFrom:to:";		add: 986 "ScreenGraphicsContext primDisplayPolyline:at:";		add: 987 "ScreenGraphicsContext primDisplayPolygon:at:";		add: 988 "ScreenGraphicsContext primDisplayRectangleOrigin:extent:";		add: 989 "ScreenGraphicsContext primDisplayRectangularBorderOrigin:extent:";		add: 990 "ScreenGraphicsContext primDisplayArcBBoxOrigin:extent:startAngle:sweepAngle:";		add: 991 "ScreenGraphicsContext primDisplayWedgeBBoxOrigin:extent:startAngle:sweepAngle:";		add: 992 "ScreenGraphicsContext primDisplayMask:at:";		add: 993 "ScreenGraphicsContext primDisplayUninterpretedImageBits:at:";		add: 994 "ScreenGraphicsContext primCopyRectangularAreaExtent:from:sourceOffset:destinationOffset:";		add: 995 "ScreenGraphicsContext primCopyMaskedArea:from:sourceOffset:destinationOffset:";		add: 996 "Screen deviceColormap";		add: 998 "ScreenGraphicsContext primDisplayUninterpretedMonoImageBits:foreground:background:at:";		add: 1100 "Pixmap deviceContentsOfAreaOriginX:y:width:height:into:startingAt:";		add: 1101 "Mask deviceContentsOfAreaOriginX:y:width:height:into:startingAt:";		add: 1102 "Window deviceContentsOfAreaOriginX:y:width:height:into:startingAt:";		add: 1103 "Screen deviceContentsOfAreaOriginX:y:width:height:into:startingAt:";		add: 1104 "Screen colorDepthAndBitsPerPixel";		add: 1105 "Screen coverageDepthAndBitsPerPixel";		add: 1110 "Window setIcon:mask:";		add: 1111 "Screen primWindowAtX:y:";		add: 1120 "Screen color:for:look:";		add: 1200 "HostPrinter primNewPrinter";		add: 1201 "HostPrinter primListFontNames";		add: 1202 "HostPrinter oldAllocateFontNamed:";		add: 1203 "HostPrinter primClose";		add: 1204 "HostPrintJob getDimensions";		add: 1205 "HostPrinter primPrinterName";		add: 1206 "HostPrinter colorDepthAndBitsPerPixel";		add: 1207 "HostPrinter coverageDepthAndBitsPerPixel";		add: 1208 "HostPrintJob primChangeExtent:";		add: 1209 "HostPrintJob primSetLandscape:";		add: 1210 "HostPrinter primCreatePrintJobNamed:";		add: 1214 "HostPrinter allocateFontNamed:";		add: 1216 "HostPrintJob startPage";		add: 1217 "HostPrintJob endPage";		add: 1218 "HostPrintJob primPrint";		add: 1220 "HostPrinterGraphicsContext primDisplayMappedString:from:to:at:withMap:";		add: 1221 "HostPrinterGraphicsContext primDisplayCharacterOfIndex:at:";		add: 1222 "HostPrinterGraphicsContext primDisplayMappedTwoByteString:from:to:at:withMap:";		add: 1223 "HostPrinterGraphicsContext primDisplayTwoByteString:from:to:at:";		add: 1225 "HostPrinterGraphicsContext primDisplayLineFrom:to:";		add: 1226 "HostPrinterGraphicsContext primDisplayPolyline:at:";		add: 1227 "HostPrinterGraphicsContext primDisplayPolygon:at:";		add: 1228 "HostPrinterGraphicsContext primDisplayRectangleOrigin:extent:";		add: 1229 "HostPrinterGraphicsContext primDisplayRectangularBorderOrigin:extent:";		add: 1230 "HostPrinterGraphicsContext primDisplayArcBBoxOrigin:extent:startAngle:sweepAngle:";		add: 1231 "HostPrinterGraphicsContext primDisplayWedgeBBoxOrigin:extent:startAngle:sweepAngle:";		add: 1232 "HostPrinterGraphicsContext primDisplayMask:at:";		add: 1233 "HostPrinterGraphicsContext primDisplayUninterpretedImageBits:at:";		add: 1234 "HostPrinterGraphicsContext primDisplayUninterpretedMonoImageBits:foreground:background:at:";		add: 1916 "MacOSXFont getWidths:into:"</body><body package="AT Profiling Core">addIOTimePrimsToList	"Add to the list of target primitives those which should be profiled if you care about accurate measurements of the time spent in IO primitives."	targetPrimNumbers		add: 611 "IOAccessor primBufferSize";		add: 612 "IOAccessor primGetDescriptor";		add: 615 "UnixFilename primSetProtection:errInto:";		add: 616 "UnixFilename class primSetCreationMask:errInto:";		add: 617 "UnixFilename primGetProtectionErrInto:";		add: 619 "MacOSXSystemSupport class primSetUserDefaultNamed:value:";		add: 630 "SocketAccessor setOptionsLevel:name:value:";		add: 631 "SocketAccessor getOptionsLevel:name:";		add: 632 "SocketAccessor primGetName";		add: 633 "SocketAccessor primGetPeer";		add: 634 "SocketAccessor atMark";		add: 640 "IPSocketAddress class primHostAddressByName:";		add: 641 "IPSocketAddress class primNetAddressByName:";		add: 642 "IPSocketAddress class primProtocolNumberByName:";		add: 643 "IPSocketAddress class primServicePortByName:";		add: 645 "IPSocketAddress class primHostNameByAddress:";		add: 646 "IPSocketAddress class primNetNameByAddress:";		add: 647 "IPSocketAddress class primProtocolNameByNumber:";		add: 648 "IPSocketAddress class primServiceNameByPort:";		add: 649 "SocketAccessor class primGetHostname";		add: 650 "Filename primOpenFileNamed:direction:creation:errorInto:";		add: 651 "IOAccessor primClose";		add: 652 "UnixPipeAccessor class primPipeErrorInto:";		add: 654 "SocketAccessor class primPairErrorInto:";		add: 660 "IOAccessor primReadInto:startingAt:for:";		add: 661 "IOAccessor primWriteFrom:startingAt:for:";		add: 662 "IOAccessor primSeekTo:";		add: 664 "IOAccessor truncateTo:";		add: 665 "PCDiskFileAccessor commit";		add: 666 "IOAccessor primGetSize";		add: 667 "MacDiskFileAccessor lock:for:";		add: 668 "BlockableIOAccessor setSem:forWrite:";		add: 669 "BlockableIOAccessor bytesForRead";		add: 670 "SocketAccessor class primFamily:type:protocol:errInto:";		add: 671 "SocketAccessor primAccept";		add: 672 "SocketAccessor bindTo:";		add: 673 "SocketAccessor listenFor:";		add: 674 "SocketAccessor primConnectTo:";		add: 675 "SocketAccessor primReceiveFrom:buffer:start:for:flags:";		add: 676 "SocketAccessor sendTo:buffer:start:for:flags:";		add: 677 "SocketAccessor shutdown:";		add: 678 "SocketAccessor primClose";		add: 679 "SocketAccessor privateReadInto:startingAt:for:";		add: 680 "SocketAccessor privateWriteFrom:startingAt:for:";		add: 681 "UnixProcess class primFork:arguments:environment:descriptors:errorTo:";		add: 682 "UnixProcess class reapOne";		add: 683 "UnixProcess kill:";		add: 685 "SocketAccessor setSem:forWrite:";		add: 690 "CEnvironment class primEnvironment";		add: 691 "CEnvironment class primCommandLine";		add: 692 "OSHandle class primProcessId";		add: 693 "MacOSXSystemSupport class primGetUserDefaultNamed:";		add: 696 "OSErrorHolder class primErrorName:";		add: 697 "OSErrorHolder class primErrorDescriptionFor:";		add: 698 "SocketAccessor class primInit:";		add: 744 "MacLookPolicy class primEnableHostCursor:";		add: 752 "MacFilename primSetCreator:type:errInto:";		add: 754 "MacIOAccessor class primGetAccessories";		add: 755 "MacIOAccessor class runAccessory:";		add: 757 "MacOSFilename putFileWithPrompt:";		add: 761 "MacOSFilename class getStartupFiles";		add: 769 "MacFilename primSetAsDefaultVolume";		add: 770 "PCFilename printPSFileErrInto:";		add: 771 "PCFilename printTextFileErrInto:";		add: 775 "PowerMacSystemSupport class primGetEnvironmentNamed:";		add: 1600 "Filename getDates";		add: 1601 "Filename delete";		add: 1602 "Filename isDirectory";		add: 1603 "Filename renameToFilename:";		add: 1604 "Filename makeDirectory";		add: 1605 "Filename class getDefaultDirectory";		add: 1606 "Filename fileSize";		add: 1607 "Filename isWritable";		add: 1608 "Filename setWritable:";		add: 1609 "Filename primitiveExists";		add: 1610 "MacFilename primOpenFileDirection:creation:";		add: 1620 "PCFilename class getFileSystem:";		add: 1621 "PCFilename class getVolumes";		add: 1622 "PCFilename class getFileSystemAttributes:";		add: 1630 "MacOSFilename primResolvePath";		add: 1631 "MacFilename primSetFileType:";		add: 1632 "MacFilename printFile";		add: 1670 "MacOSFilename getDatesIn:";		add: 1671 "MacOSFilename deleteIn:";		add: 1672 "MacOSFilename isDirectoryIn:";		add: 1673 "MacOSFilename renameIn:toFilename:";		add: 1674 "MacOSFilename makeDirectoryIn:";		add: 1676 "MacOSFilename fileSizeIn:";		add: 1677 "MacOSFilename isWritableIn:";		add: 1678 "MacOSFilename setWritableIn:to:";		add: 1679 "MacOSFilename primitiveExistsIn:";		add: 1680 "MacOSFilename primOpenFileIn:direction:creation:";		add: 1682 "MacOSFilename primSetFileIn:toType:";		add: 1683 "MacOSFilename primDirectoryStringIn:";		add: 1684 "MacFilename primGetFileInfoIn:";		add: 1685 "MacOSFilename class primGetFileDialogUsingTypes:";		add: 1690 "Filename privateDirectoryContents";		add: 1691 "MacOSFilename directoryContentsIn:"</body><body package="AT Profiling Core">addMiscTimePrimsToList	"Add to the list of target primitives those which should be profiled if	you care about accurate measurement of the time spent in miscellaneous	long-running primitives."	targetPrimNumbers		add: 89 "Behavior flushVMmethodCache";		add: 105 "ByteEncodedString replaceElementsFrom:to:withByteEncodedString:startingAt:";		add: 223 "ByteEncodedString =";		add: 323 "ObjectMemory class primGrowOldSpaceBy:";		add: 330 "ExternalLibrary primLoadLibrary:";		add: 331 "ExternalLibrary primUnloadLibrary:";		add: 332 "ExternalLibrary primMapAddress:library:";		add: 333 "ExternalMethod class primMapStatic:";		add: 334 "ExternalMethod class primUnlinkedSendSelector:for:instVarOffset:";		add: 335 "CPointer primCopyCStringFromHeap:pointerKind:";		add: 337 "ExternalMethod class primCallC:specifierCallFlags:arguments:argumentKinds:structArgSize:structReturnSize:datumClass:resultType:";		add: 382 "CPointer primCopyDoubleByteStringFromHeap:pointerKind:";		add: 384 "UninterpretedBytes copySingleByteCString";		add: 385 "UninterpretedBytes copyDoubleByteCString";		add: 392 "CPointer primFree:pointerKind:";		add: 395 "ExternalMethod ";		add: 396 "CType class numBitsForKind:";		add: 397 "CType primMalloc:pointerKind:";		add: 398 "CPointer primCopyFromExternalHeap:pointerKind:offset:to:size:startingAt:";		add: 399 "CPointer primCopyToExternalHeap:pointerKind:offset:from:size:startingAt:";		add: 402 "Behavior allInstancesWeakly:";		add: 403 "Object allOwnersWeakly:";		add: 408 "Object allStrongOwnersWeakly:";		add: 414 "TwoByteString replaceElementsFrom:to:withTwoByteString:startingAt:";		add: 415 "TwoByteString =";		add: 417 "String trueCompare:";		add: 418 "ByteEncodedString nextIndexOf:from:to:";		add: 419 "ByteEncodedString prevIndexOf:from:to:";		add: 422 "WeakArray indexOf:replaceWith:startingAt:stoppingAt:";		add: 432 "WeakArray searchForInternedSymbol:";		add: 450 "Array replaceFrom:to:with:startingAt:";		add: 460 "WeakArray class newNoRetry:";		add: 471 "Locale class getLocaleName";		add: 480 "CCompositeType contentsOf:at:pointerKind:";		add: 481 "CCompositeType contentsOf:at:put:pointerKind:";		add: 482 "CPointer primContentsAt:pointerKind:datumKind:containerClass:type:";		add: 483 "CPointer primContentsAt:pointerKind:datumKind:put:";		add: 484 "CCompositeType contentsOf:at:";		add: 485 "CCompositeType contentsOf:at:put:";		add: 486 "CCompoundType primIndexOf:slotsPerMember:";		add: 490 "CPointer primContentsAt:index:pointerKind:datumKind:containerClass:type:";		add: 491 "CPointer primContentsAt:index:pointerKind:datumKind:put:";		add: 522 "Behavior flushVMmethodCacheEntriesFor:";		add: 524 "Context nFromVPC:";		add: 525 "Context vFromNPC:";		add: 526 "CompiledCode flushCachedVMCode";		add: 558 "ByteArray replaceBytesFrom:to:with:startingAt:map:";		add: 559 "ByteArray replaceBytesFrom:to:with:startingAt:";		add: 705 "Screen ringBell";		add: 707 "Cursor primBeCursor";		add: 708 "Cursor primFreeCursor";		add: 776 "Pixmap toClipboard";		add: 808 "Context findNextMarkedUpTo:";		add: 809 "Context terminateTo:";		add: 1040 "Behavior newInFixedSpace:";		add: 1042 "ObjectMemory class primGrowFixedSpaceBy:";		add: 1700 "Byte object hash";		add: 1701 "Mapped byte object hash";		add: 1702 "Two byte object hash";		add: 1747 "SmallInteger&gt;&gt;hashMultiply"</body></methods><methods><class-id>Tools.TimeProfilerCore class</class-id> <category>utility</category><body package="AT Profiling Core">checkConsistency		self checkConsistency: self</body></methods><methods><class-id>Tools.MessageTally</class-id> <category>comparing</category><body package="AT Profiling Core">&lt; aMessageTally	"Answer whether the receiver is less than the argument."	^tally &gt; aMessageTally tally</body><body package="AT Profiling Core">= aMessageTally	"Answer whether the receiver is equal to the argument."	( self species == aMessageTally species )		ifFalse: [ ^false ].	^( aMessageTally method == self method )</body><body package="AT Profiling Core">hash	^method identityHash</body><body package="AT Profiling Core">identityHash	^super identityHash hashMultiply		bitXor: self hash</body></methods><methods><class-id>Tools.MessageTally</class-id> <category>private</category><body package="AT Profiling Core">ALL</body><body package="AT Profiling Core">class: aClass method: aMethod	"Initialize this tally for a given class and method."	class := aClass.	method := aMethod.	tally := 0.	samples := 0.	receivers := IdentityDictionary new.	"recursive := nil."</body><body package="AT Profiling Core">findMatchFor: aTally inSet: aSet	| index |	index := aSet			find: aTally			ifAbsent: [nil].	^index == nil		ifTrue:			[| aMessageTally |			aSet add:				(aMessageTally := aTally class class: aTally methodClass method: aTally method).			aMessageTally parent: aTally root.			aMessageTally name: aTally name.			aMessageTally]		ifFalse:	[aSet basicAt: index]</body><body package="AT Profiling Core">maxTallyingDepth	^127</body><body package="AT Profiling Core">parent: aMessageTally	parent := aMessageTally</body><body package="AT Profiling Core">primitives: anInteger	"Initialize this tally to correspond to a primitive."	tally := anInteger.	receivers := nil</body></methods><methods><class-id>Tools.MessageTally</class-id> <category>tallying</category><body package="AT Profiling Core">bump: n	"Increase the resource count attributed to this node."	tally := tally + n.	samples := samples + 1.</body><body package="AT Profiling Core">bump: n samples: sampleCount	"Increase the resource count attributed to this node."	tally := tally + n.	samples := samples + sampleCount.</body><body package="AT Profiling Core">tally: context by: n	"Explicitly tally the specified context and its stack."	| ctx mTally i ordered |	ctx := context.	i := 0.	ordered := StackHolder.	[nil == ctx] whileFalse:		[ctx method == method			ifTrue: [				mTally := self bump: n.				^self maxTallyingDepth &lt; i					ifTrue: [						| collapsed collapsedReceivers share |						i to: i - self maxTallyingDepth + 1 by: -1 do: [:k |							mTally := mTally tallyPath: (ordered at: k) by: n].						collapsed := IdentitySet new.						(1 max: i - (self maxTallyingDepth * 2 + 1)) to: i - self maxTallyingDepth do: [:k |							collapsed add: (ordered at: k) method].						collapsedReceivers := mTally receivers.						share := n // collapsed size.						collapsed do: [:e | (collapsedReceivers at: e ifAbsentPut: [											(self class												class: nil												method: e) parent: mTally]) bump: share]]					ifFalse: [						i to: 1 by: -1 do: [:k |							mTally := mTally tallyPath: (ordered at: k) by: n]]]			ifFalse: [				i := i + 1.				ordered at: i put: ctx.				ctx := ctx sender]].	^self</body><body package="AT Profiling Core">tally: aContext process: aProcess by: tallyDelta	"Materialize a tree from the receiver node to the called context	and accumulate tallies for that path."	self bump: tallyDelta.	^(receivers at: ( ProfilerProcessInfo forProcess: aProcess ) ifAbsentPut: [self class default parent: self; name: aProcess shortString; yourself])		tally: aContext  by: tallyDelta</body><body package="AT Profiling Core">tallyPath: context by: tallyDelta	"Materialize a tree from the receiver node to the called context	and accumulate tallies for that path."	| aMethod |	aMethod := context method.	^(receivers at: aMethod ifAbsentPut:		[(self class			class: nil			method: aMethod) parent: self]) bump: tallyDelta</body></methods><methods><class-id>Tools.MessageTally</class-id> <category>accessing</category><body package="AT Profiling Core">addTo: aMessageTally	| otherReceivers |	aMessageTally bump: tally samples: samples.	otherReceivers := aMessageTally receivers.	receivers keysAndValuesDo: [:meth :child | | match |		match := otherReceivers at: meth ifAbsent: [].		match == nil			ifTrue: [otherReceivers at: meth put: (child copy parent: aMessageTally)]			ifFalse: [child addTo: match]].</body><body package="AT Profiling Core">childrenOver: threshold	"Answer a collection of child nodes whose tallies are over the supplied threshold."	| hereTally last children |	(receivers == nil or: [receivers size = 0]) ifTrue: [^#()].	hereTally := tally.	children := receivers select:  "subtract subNode tallies for primitive hits here"		[:child |		hereTally := hereTally - child tally.		child tally &gt; threshold].	hereTally &gt; threshold		ifTrue:			[last := self class class: class method: method.			last name: (#primitives &lt;&lt; #advanced &gt;&gt; 'primitives') asString.			last parent: self.			^children asSortedCollection copyWith: (last primitives: hereTally)].	^children asSortedCollection</body><body package="AT Profiling Core">class: c	class := c</body><body package="AT Profiling Core">method	"Answer the tally's method."	^( method isNil )		ifTrue:	[ method := Dummy ]		ifFalse:	[ method ]</body><body package="AT Profiling Core">method: m	method := m</body><body package="AT Profiling Core">methodClass	^class</body><body package="AT Profiling Core">name	( name == nil )		ifTrue:	[ name := self computeName ].	^name</body><body package="AT Profiling Core">name: aString	name := aString</body><body package="AT Profiling Core">parent	^parent</body><body package="AT Profiling Core">receivers	^receivers</body><body package="AT Profiling Core">receivers: anIdentityDictionary	receivers := anIdentityDictionary</body><body package="AT Profiling Core">root	"Answer the root of the tree that contains the receiver"	| current next |	current := self.	[ nil == ( next := current parent ) ]		whileFalse:	[ current := next ].	^current</body><body package="AT Profiling Core">samples	^samples</body><body package="AT Profiling Core">samples: anInteger	samples := anInteger</body><body package="AT Profiling Core">selector	| idx |	idx := self name indexOfSubCollection: '&gt;&gt;' startingAt: 1.	^( idx = 0 )		ifTrue:	[ name ]		ifFalse:	[ ( name copyFrom: idx + 2 to: self name size ) asSymbol ]</body><body package="AT Profiling Core">tally	"Answer the tally's resource usage."	^tally</body><body package="AT Profiling Core">tally: s	tally := s</body><body package="AT Profiling Core">text	| messageSelector aClass |	messageSelector := class 							selectorAtMethod: method homeMethod							setClass: [ :cl | aClass := cl ].	^(aClass sourceCodeForMethod: method homeMethod at: messageSelector) asText						makeSelectorBoldIn: aClass</body></methods><methods><class-id>Tools.MessageTally</class-id> <category>enumerating</category><body package="AT Profiling Core">addLocalUsageInto: summarySet	| t s |	t := tally.	s := samples.	receivers do:		[:mTally |		t := t - mTally tally.		s := s - mTally samples.		mTally addLocalUsageInto: summarySet].	(s = 0 and: [t = 0])		ifFalse: [(self findMatchFor: self inSet: summarySet)					bump: t samples: s]</body><body package="AT Profiling Core">detect: aBlock ifNone: exceptionBlock	self do: [:e | ( aBlock value: e ) ifTrue: [ ^e ] ].	^exceptionBlock value</body><body package="AT Profiling Core">do: aBlock	aBlock value: self.	receivers do: [ :x | x do: aBlock ].</body><body package="AT Profiling Core">select: aBlock	| matches |	matches := OrderedCollection new.	self do: [:e | ( aBlock value: e ) ifTrue: [ matches add: e ] ].	^matches</body></methods><methods><class-id>Tools.MessageTally</class-id> <category>printing</category><body package="AT Profiling Core">computeName	"Determine what the MessageTally should be named"	method == nil ifTrue: [ ^'' ].	^receivers == nil		ifTrue: [(#primitives &lt;&lt; #advanced &gt;&gt; 'primitives') asString]		ifFalse:			[| str |			str := (String new: 40) writeStream.			method printNameOn: str inClass: class.			str contents]</body><body package="AT Profiling Core">fullPrintOn: aStream cutoff: perCent	"Generate a report on the supplied stream.  Supress tallies which account for less than perCent of the total."	| threshold |	threshold := (perCent asFloat / 100 * tally) rounded.	aStream nextPutAll: (#Tree &lt;&lt; #advanced &gt;&gt; '** Tree **') asString; cr.	self treePrintOn: aStream		tabs: OrderedCollection new		over: threshold.	aStream nextPut: Character newPage; cr.	aStream nextPutAll: (#Totals &lt;&lt; #advanced &gt;&gt; '** Totals **') asString; cr.	self totalsPrintOn: aStream		over: threshold.</body><body package="AT Profiling Core">printOn: aStream	"Print a report on the supplied stream, starting from the root, given the total resource consumed."	[aStream print: (tally asFloat / self root tally * 100.0 roundTo: 0.1)]		on: Number divisionByZeroSignal		do: [:ex |			aStream print: 0.0.			ex return].	aStream space; nextPutAll: self name</body><body package="AT Profiling Core">printString	"Implemented here as a speed optimization"	| aStream |	aStream := WriteStream on: (String new: self name size + 6).	tally = 0		ifTrue: [aStream nextPutAll: '0.0']		ifFalse: [0.1 * (1000.0 * tally / self root tally) rounded printOn: aStream digits: 4].	^aStream		space; 		nextPutAll: name; 		contents</body><body package="AT Profiling Core">shortPrintString	"Implemented here as a speed optimization"	| aStream |	aStream := WriteStream on: (String new: 15 + 6).	aStream nextPut: $[.	tally = 0		ifTrue: [aStream nextPutAll: '0.0']		ifFalse: [0.1 * (1000.0 * tally / self root tally) rounded printOn: aStream digits: 4].	^aStream		space; 		nextPutAll: ( self name copyFrom: ( ( self name indexOf: $&gt; ) + 2 ) to: ( self name size ) );		nextPut: $];		contents</body><body package="AT Profiling Core">totalsPrintOn: aStream over: threshold	"Report on the supplied stream the tallies for all leaves which are over the supplied threshold."	| totals |	totals := Set new: 128.	self addLocalUsageInto: totals.	(totals asOrderedCollection select: [:node | node tally &gt; threshold])		asSortedCollection do:		[:node |		node printOn: aStream.		aStream cr]</body><body package="AT Profiling Core">treePrintOn: aStream tabs: tabs over: threshold	"Print the report tree on the supplied stream."	| sons |	1 to: tabs size - 1 do: [:i | aStream nextPutAll: (tabs at: i)].	tabs size &gt; 0		ifTrue:			[self printOn: aStream.			aStream cr].	sons := self childrenOver: threshold.	sons isEmpty ifFalse:		[1 to: sons size do:			[:i |			tabs addLast: (i &lt; sons size ifTrue: ['  |'] ifFalse: ['  ']).			(sons at: i) treePrintOn: aStream tabs: tabs over: threshold.			tabs removeLast]]</body></methods><methods><class-id>Tools.MessageTally</class-id> <category>copying</category><body package="AT Profiling Core">postCopy	receivers := receivers copyWithCopiedValues.	receivers do: [:aMessageTally | aMessageTally parent: self ]</body></methods><methods><class-id>Tools.MessageTally</class-id> <category>utility</category><body package="AT Profiling Core">classifyFromWith: target parents: pSet children: cSet	"Traverse the activation tree, identifying and collecting clean versions of the parent and child tallies."	self		dfsUsing:	[ :node |						node							classifyNode: target							parents: pSet							children: cSet					]</body><body package="AT Profiling Core">classifyNode: target parents: pSet children: cSet	"Add a clean version of the node to either the parent or the child set."	"Do not use 'MessageTally&gt;&gt;class:method:'."	"It may be worth mentioning that since we are comparing CompiledMethods in the antecedents here, any methods with different names, but with the same code, and compiled in the same class, will be ==.  'An interesting but little known fact."	| cM tM pM |	cM := method.	tM := target method.	pM := ( parent isNil )				ifTrue: [ nil ]				ifFalse: [ parent method ].	( pM ~~ nil )		ifTrue:	[			( cM == tM ) 				ifTrue:	[					pSet add: ( ( MessageTally new )						class: parent methodClass						method: parent method )						].			( pM == tM )				ifTrue:	[					cSet add: ( ( MessageTally new )						class: self methodClass						method: method )						]				]</body><body package="AT Profiling Core">dfsConditionalUsing: aBlock	"... performs a depth-first search.  The search terminates if aBlock answers 'false'."	( aBlock value: self )		ifTrue:	[ receivers do: [ :r | r dfsUsing: aBlock ] ]</body><body package="AT Profiling Core">dfsConditionalUsing: aBlock withStack: stackOC	"... performs a depth-first search, keeping track of the stack.  The search terminates if aBlock answers 'false'."	| newStack |	( aBlock value: self value: stackOC )		ifTrue:	[ 	newStack := stackOC shallowCopy.					newStack addFirst: self.					self receivers do: [ :r | r dfsConditionalUsing: aBlock withStack: newStack ]				]</body><body package="AT Profiling Core">dfsUsing: aBlock	"... performs a depth-first search."	aBlock value: self.	receivers do: [ :r | r dfsUsing: aBlock ]</body><body package="AT Profiling Core">dfsUsing: aBlock withStack: stackOC	"... performs a depth-first search, keeping track of the stack."	| newStack |	aBlock value: self value: stackOC.	newStack := stackOC shallowCopy.	newStack addFirst: self.	self receivers do: [ :r | r dfsUsing: aBlock withStack: newStack ]</body><body package="AT Profiling Core">integrateChildNode: targetMT stack: stackOC children: cSet 	"Only integrate and stop searching if the current node is called, directly or indirectly by the target, and has neither the target nor any other children among its direct or indirect receivers.  If all these conditions are fulfilled, add this tally to the working target and to the first child found in the stack that is directly preceeded by the target.  (This condition is necessary, in case a known direct child of the target is called indirectly by some other child.)  Otherwise, continue searching."	"I.  Test conditions&gt;"	(stackOC includes: targetMT) 		ifFalse:	[ ^true].	(self receiversInclude: targetMT) 		ifTrue:	[ ^true].	(self receiversIncludeAny: cSet) 		ifTrue:	[ ^true].	"II. Accumulate into target."	targetMT bump: tally samples: samples.	"III. Determine attribution and accumulate into the selected child."	( targetMT = self parent ) 		ifTrue:	[	( self matchIn: cSet )						bump: tally samples: samples				]		ifFalse:	[	( ( stackOC detect: [:x | cSet includes: x ] ) matchIn: cSet )						bump: tally samples: samples				].	^false</body><body package="AT Profiling Core">integrateChildrenFrom: targetMT children: cSet	self		dfsConditionalUsing:		[ :node :stackOC |									node										integrateChildNode: targetMT										stack: stackOC										children: cSet								]		withStack: ( OrderedCollection new: 43 )</body><body package="AT Profiling Core">integrateParentNode: target stack: stackOC parents: pSet	| pT nT nP |	( parent ~~ nil )		ifTrue:	[ 	nT := ( method == target method).					pT := ( parent method == target method ).					( nT &amp; pT )						ifTrue:	[ 	"Case I.  Direct recursive call."									( parent parent method ~~ target method )										ifTrue:	[	( parent matchIn: pSet )														bump: tally samples: samples.													( parent parent matchIn: pSet )														bump: tally negated samples: samples negated												]								]						ifFalse:	[	"Case II.  Any other call."									( nT )										ifTrue:	[ 	( parent matchIn: pSet ) bump: tally samples: samples.													nP := target matchBeforeAny: pSet in: stackOC startingAt: 2.													( nP ~~ nil )														ifTrue:	[ ( nP ) bump: tally negated samples: samples negated ] ]									]				]</body><body package="AT Profiling Core">integrateParentsFrom: targetMT parents: pSet	self		dfsUsing:	[ :node :stackOC |						node							integrateParentNode: targetMT							stack: stackOC							parents: pSet					]		withStack: ( OrderedCollection new: 29 )</body><body package="AT Profiling Core">matchAfterAny: aCollection in: aSequenceableCollection startingAt: anIndex	"Answer the tally in aCollection that matches the element in aSequenceableCollection which occurs before the first element in a SequenceableCollection that matches the receiver.  Looks for 'self' first, ans answers a predecessor (in a top-first representation of a stack) within aCollection.	( [ ..*.. RETURNED self ..*.. ] )."	| sCol pred |	sCol := aSequenceableCollection copyFrom: anIndex to: aSequenceableCollection size.	2 to: sCol size do: 		[ :ndx |	( ( sCol at: ndx ) = self )					ifTrue:	[	pred := sCol at: ( ndx - 1 ).								( aCollection includes: pred )									ifTrue:	[ ^pred ]							]		].	^nil</body><body package="AT Profiling Core">matchBeforeAny: aCollection in: aSequenceableCollection startingAt: anIndex	"Answer the tally in aCollection that matches the first element in aSequenceableCollection which occurs after the first element in a SequenceableCollection that matches the receiver. ( [ ..*.. self RETURNED ..*.. ] )."	| sCol start |	sCol := aSequenceableCollection copyFrom: anIndex to: aSequenceableCollection size.	start := sCol findFirst: [ :x | x method == method ].	( start == 0 ) ifTrue: [ ^nil ].	( start + 1 ) to: sCol size do:		[ :ndx |	aCollection do: 					[ :t | ( t method == ( sCol at: ndx ) method )							ifTrue: [ ^t ]					]		].	^nil</body><body package="AT Profiling Core">matchIn: aCollection	^aCollection		detect: [ :x | x method == method ]		ifNone: []</body><body package="AT Profiling Core">receiversInclude: aMessageTally	receivers do: [ :r | ( r = aMessageTally ) ifTrue: [ ^true ] ].	^false</body><body package="AT Profiling Core">receiversIncludeAny: aCollection	receivers do: [ :r | ( aCollection includes: r ) ifTrue: [ ^true ] ].	^false</body></methods><methods><class-id>Tools.MessageTally class</class-id> <category>instance creation</category><body package="AT Profiling Core">class: aClass method: aMethod	"Answer a new tally for the given class and method."	ObjectCache isNil ifTrue: [ ^self new class: aClass method: aMethod ].	ObjectCache atEnd ifTrue: [ ^self new class: aClass method: aMethod ].	^ObjectCache next class: aClass method: aMethod</body><body package="AT Profiling Core">default	^default copy</body><body package="AT Profiling Core">root	^self new class: nil method: nil</body></methods><methods><class-id>Tools.MessageTally class</class-id> <category>class initialization</category><body package="AT Profiling Core">initialize	default := self new class: Process class method: (Process class compiledMethodAt: #forBlock:priority:) literals first.	Dummy := self compiledMethodAt: #ALL</body><body package="AT Profiling Core">initializeCaches	| cache |	StackHolder := Array new: 100000.	cache := Array new: 1000.	1 to: cache size do: [:i | cache at: i put: self new ].	ObjectCache := cache readStream</body><body package="AT Profiling Core">releaseCaches	StackHolder := nil.	ObjectCache := nil</body></methods><methods><class-id>Tools.MultiTimeProfilerCore</class-id> <category>initialize-release</category><body package="AT Profiling Core">initialize	"Initialize the profiler to default values."	super initialize.	rootTally name: (#AllProcesses &lt;&lt; #advanced &gt;&gt; 'All processes') asString.</body></methods><methods><class-id>Tools.MultiTimeProfilerCore</class-id> <category>accessing</category><body package="AT Profiling Core">description	"Answer a string appropriate for labeling a resource report."	^(#MultiProcessExecutionTime &lt;&lt; #advanced &gt;&gt; 'Multi-Process Execution Time') asString</body></methods><methods><class-id>Tools.MultiTimeProfilerCore</class-id> <category>state transition</category><body package="AT Profiling Core">startTally	"Attribute the consumed resources to the tally tree."	| newTime p |	newTime := Time microsecondClock.	(p := Processor preemptedProcessWith: waitPrimitive with: callbackPrimitive) notNil		ifTrue: [rootTally tally: p suspendedContext process: p by: newTime - time.]		ifFalse: [otherProcessesTime := otherProcessesTime + newTime - time].	time := Time microsecondClock.</body></methods><methods><class-id>Tools.MultiTimeProfilerCore class</class-id> <category>class initialization</category><body package="AT Profiling Core">initialize	"Build the method-substitution lists.  This is here so that the fileIn will automatically initialize"	"((( MultiTimeProfilerCore initialize )))"	super initialize</body></methods><methods><class-id>Tools.ProfilerProcessInfo</class-id> <category>printing</category><body package="AT Profiling Core">printOn: aStream	aStream nextPutAll: displayString</body></methods><methods><class-id>Tools.ProfilerProcessInfo</class-id> <category>accessing</category><body package="AT Profiling Core">priority	^priority</body><body package="AT Profiling Core">values	^Array with: priority with: displayString</body></methods><methods><class-id>Tools.ProfilerProcessInfo</class-id> <category>initialize-release</category><body package="AT Profiling Core">priority: anInteger displayString: s	priority := anInteger.	displayString := s</body></methods><methods><class-id>Tools.ProfilerProcessInfo class</class-id> <category>instance creation</category><body package="AT Profiling Core">forProcess: aProcess	|  info |	info := aProcess environmentAt: #profilerInfo.	info isNil ifFalse: [ ^info ].	^aProcess environmentAt: #profilerInfo put: ( self priority: aProcess priority displayString: aProcess shortString )</body><body package="AT Profiling Core">priority: p displayString: s	^self new priority: p displayString: s</body></methods><methods><class-id>Tools.MessageTallyDefinition</class-id> <category>accessing</category><body package="AT Profiling Core">extraText	^nil</body><body package="AT Profiling Core">implementingClass	^self method mclass</body><body package="AT Profiling Core">inheritingClass	^tally methodClass</body><body package="AT Profiling Core">method	^tally method homeMethod</body><body package="AT Profiling Core">selector	^tally selector</body><body package="AT Profiling Core">sourceCode	"Have to make sure we get the source of the original method."	^self implementingClass		sourceCodeForMethod: self method		at: self selector</body><body package="AT Profiling Core">tally: aMessageTally	tally := aMessageTally</body></methods><methods><class-id>Tools.AllocationProfilerCore</class-id> <category>allocation notification</category><body package="AT Profiling Core">accumulateStats: anObject	"Account for the argument object in the class histogram."	| count class |	class := anObject class.	count := statistics at: class ifAbsent: [class isVariable					ifTrue: [Array with: 0 with: 0]					ifFalse: [0]].	class isVariable		ifTrue:			[count at: 1 put: (count at: 1) + 1.			count at: 2 put: (count at: 2) + anObject basicSize]		ifFalse: [count := count + 1].	statistics at: class put: count</body><body package="AT Profiling Core">tallyNewObject: anObject	"Account for a newly allocated object; called by a method doing allocation.  Check to see if we've crossed the tripwire and signal any watchers if so."	currentlyActive ifTrue: [		currentlyActive := false.		Processor activeProcess == observedProcess ifTrue: [			anObject isImmediate ifFalse: [				statistics == nil ifFalse: [self accumulateStats: anObject].				byteCount := byteCount + (self weigh: anObject).				byteCount &gt; samplingInterval ifTrue: [					rootTally tally: thisContext sender sender sender by: byteCount.					byteCount := 0]]].		currentlyActive := true]</body><body package="AT Profiling Core">weigh: anObject	"Answer the size, in bytes of the argument.  This is implementation-dependent."	| class slots |	class := anObject class.	slots := anObject basicSize.	^ByteOverhead + (class isBits			ifTrue: [slots]			ifFalse: [class instSize + slots * 4])</body></methods><methods><class-id>Tools.AllocationProfilerCore</class-id> <category>initialize-release</category><body package="AT Profiling Core">initialize	"Initialize the profiler to default values."	super initialize.	byteCount := 0.	currentlyActive := true.	keepStatistics == nil ifTrue: [keepStatistics := false].	( statistics == nil )		ifFalse:	[ statistics := IdentityDictionary new: 128 ]</body><body package="AT Profiling Core">initializeWatcher	random := ScaledRandom upperBound: self maxDelay</body></methods><methods><class-id>Tools.AllocationProfilerCore</class-id> <category>state transition</category><body package="AT Profiling Core">preProfile	super preProfile.	byteCount := 0.</body><body package="AT Profiling Core">startTally	"For an allocation profiler, the watcher loop does nothing, it is only used to check for termination and to trigger the exit block."</body></methods><methods><class-id>Tools.AllocationProfilerCore</class-id> <category>accessing</category><body package="AT Profiling Core">defaultSamplingInterval	"Answer the number of bytes between sampling."	^1024</body><body package="AT Profiling Core">description	"Answer a string appropriate for labeling a resource report."	^(#ObjectAllocation &lt;&lt; #advanced &gt;&gt; 'Object Allocation') asString</body><body package="AT Profiling Core">keepStatistics	^keepStatistics</body><body package="AT Profiling Core">maxDelay	"This is the maximum acceptable delay (measured in microseconds) for noticing that the profiling ended, at which time we should perform the exit block (that, for example, opens a ProfileOutlineBrowser).  We cannot make it very small because we don't want to check too often, to avoid the overhead."	^200000</body><body package="AT Profiling Core">maxSamplingInterval	"Answer an appropriate upper bound for the sampling interval."	^16384</body><body package="AT Profiling Core">statistics	^statistics</body><body package="AT Profiling Core">totalBytes	^self tally</body></methods><methods><class-id>Tools.AllocationProfilerCore</class-id> <category>public api</category><body package="AT Profiling Core">keepStatistics: aBoolean	keepStatistics := aBoolean.	statistics := aBoolean					ifTrue:	[ IdentityDictionary new: 128 ]					ifFalse:	[ nil ]</body></methods><methods><class-id>Tools.AllocationProfilerCore class</class-id> <category>building primitive list</category><body package="AT Profiling Core">addBasicAllocPrimsToList	"Add to the list of allocation primitives those which should certainly be profiled."	targetPrimNumbers		add: 18 "Number @";		add: 40 "SmallInteger asFloat";		add: 41 "Float +";		add: 42 "Float -";		add: 49 "Float *";		add: 50 "Float /";		add: 52 "Float fractionPart";		add: 54 "Float timesTwoPower:";		add: 70 "Behavior basicNew";		add: 71 "Behavior basicNew:";		add: 532 "Object shallowCopy";		add: 591 "Float cos";		add: 592 "Float arcSin";		add: 593 "Float arcCos";		add: 600 "Float sin";		add: 601 "Float tan";		add: 602 "Float arcTan";		add: 603 "Float sqrt";		add: 604 "Float ln";		add: 605 "Float exp";		add: 606 "Float raisedTo:";		add: 609 "Float floorLog10";		add: 1040 "Behavior newInFixedSpace:"</body><body package="AT Profiling Core">addDoubleAllocPrimsToList	"Add to the list of allocation primitives those which should be profiled if	we care about Doubles."	targetPrimNumbers		add: 560 "Double class fromNumber:";		add: 561 "Double +";		add: 562 "Double -";		add: 569 "Double *";		add: 570 "Double /";		add: 572 "Double fractionPart";		add: 574 "Double timesTwoPower:";		add: 576 "Double sin";		add: 577 "Double cos";		add: 578 "Double tan";		add: 579 "Double arcSin";		add: 580 "Double arcCos";		add: 581 "Double arcTan";		add: 582 "Double sqrt";		add: 583 "Double ln";		add: 584 "Double exp";		add: 585 "Double raisedTo:";		add: 587 "Double floorLog10";		add: 588 "Double asFloat"</body><body package="AT Profiling Core">addIOAllocPrimsToList	"Add to the list of allocation primitives those which should be profiled if	you care about allocation during IO (pretty unimportant)."	targetPrimNumbers		add: 631 "SocketAccessor getOptionsLevel:name:";		add: 632 "SocketAccessor primGetName";		add: 633 "SocketAccessor primGetPeer";		add: 640 "IPSocketAddress class primHostAddressByName:";		add: 641 "IPSocketAddress class primNetAddressByName:";		add: 642 "IPSocketAddress class primProtocolNumberByName:";		add: 643 "IPSocketAddress class primServicePortByName:";		add: 645 "IPSocketAddress class primHostNameByAddress:";		add: 646 "IPSocketAddress class primNetNameByAddress:";		add: 647 "IPSocketAddress class primProtocolNameByNumber:";		add: 648 "IPSocketAddress class primServiceNameByPort:";		add: 649 "SocketAccessor class primGetHostname";		add: 652 "UnixPipeAccessor class primPipeErrorInto:";		add: 654 "SocketAccessor class primPairErrorInto:";		add: 671 "SocketAccessor primAccept";		add: 690 "CEnvironment class primEnvironment";		add: 691 "CEnvironment class primCommandLine";		add: 693 "MacOSXSystemSupport class primGetUserDefaultNamed:";		add: 696 "OSErrorHolder class primErrorName:";		add: 697 "OSErrorHolder class primErrorDescriptionFor:";		add: 754 "MacIOAccessor class primGetAccessories";		add: 761 "MacOSFilename class getStartupFiles";		add: 775 "PowerMacSystemSupport class primGetEnvironmentNamed:";		add: 1600 "Filename getDates";		add: 1605 "Filename class getDefaultDirectory";		add: 1620 "PCFilename class getFileSystem:";		add: 1621 "PCFilename class getVolumes";		add: 1622 "PCFilename class getFileSystemAttributes:";		add: 1630 "MacOSFilename primResolvePath";		add: 1670 "MacOSFilename getDatesIn:";		add: 1683 "MacOSFilename primDirectoryStringIn:";		add: 1684 "MacFilename primGetFileInfoIn:";		add: 1685 "MacOSFilename class primGetFileDialogUsingTypes:";		add: 1690 "Filename privateDirectoryContents";		add: 1691 "MacOSFilename directoryContentsIn:"</body><body package="AT Profiling Core">addIntegerAllocPrimsToList	"Add to the list of allocation primitives those which should be profiled if	LargeInteger arithmetic primitives are ever implemented."	"If they are *not* implemented, don't add them or they'll be double-counted."	targetPrimNumbers		add: 21 "LargePositiveInteger +";		add: 22 "LargePositiveInteger -";		add: 29 "LargePositiveInteger *";		add: 30 "LargePositiveInteger /";		add: 31 "LargePositiveInteger \\";		add: 32 "LargePositiveInteger //";		add: 33 "LargePositiveInteger quo:";		add: 34 "LargePositiveInteger bitAnd:";		add: 35 "LargePositiveInteger bitOr:";		add: 36 "LargePositiveInteger bitXor:";		add: 37 "LargePositiveInteger bitShift:";		add: 38 "LargePositiveInteger computeGCD:"</body><body package="AT Profiling Core">addMiscAllocPrimsToList	"Add to the list of allocation primitives various primitives which should be profiled."	targetPrimNumbers		add: 142 "ObjectMemory class primRegistrationNames";		add: 302 "ObjectMemory class versionId";		add: 303 "ObjectMemory class getHeraldString";		add: 306 "ObjectMemory class sizesAtStartup";		add: 307 "ObjectMemory class defaultSizesAtStartup";		add: 309 "ObjectMemory class defaultThresholds";		add: 326 "ObjectMemory class getMemoryUsageAndZeroFragmentationStatisticsIf:";		add: 335 "CPointer primCopyCStringFromHeap:pointerKind:";		add: 340 "ByteEncodedString class platformStringPreference";		add: 351 "Time class microsecondClock";		add: 382 "CPointer primCopyDoubleByteStringFromHeap:pointerKind:";		add: 395 "ExternalInterface";		add: 397 "CType primMalloc:pointerKind:";		add: 400 "SystemError class getSystemErrors";		add: 402 "Behavior allInstancesWeakly:";		add: 403 "Object allOwnersWeakly:";		add: 404 "ObjectMemory class allObjectsWeakly:";		add: 408 "Object allStrongOwnersWeakly:";		add: 460 "WeakArray class newNoRetry:";		add: 471 "Locale class getLocaleName";		add: 480 "CCompositeType contentsOf:at:pointerKind:";		add: 482 "CPointer primContentsAt:pointerKind:datumKind:containerClass:type:";		add: 484 "CCompositeType contentsOf:at:";		add: 490 "CPointer primContentsAt:index:pointerKind:datumKind:containerClass:type:";		add: 682 "UnixProcess class reapOne";		add: 900 "Screen allocatePixmapWithExtent:";		add: 901 "Screen allocateMaskWithExtent:";		add: 903 "Screen oldPrimAllocateFontNamed:";		add: 904 "Screen allocateCursorWithImage:...";		add: 905 "Screen getPixmapFromClipboard";		add: 906 "Screen allocateWindowAt:extent:min:max:windowType:owner:";		add: 908 "Screen primAllocateFontNamed:";		add: 910 "Screen getExternalSelection:";		add: 936 "Screen resizeRectangleOriginX:...";		add: 942 "Window getDimensions";		add: 947 "Screen getScreenDimensions";		add: 949 "HostGraphicsDevice primPlatformName";		add: 955 "Screen queryStackingOrder";		add: 960 "Screen class primOpen:";		add: 977 "Screen primListFontNames";		add: 994 "ScreenGraphicsContext primCopyRectangularAreaExtent:...";		add: 995 "ScreenGraphicsContext primCopyMaskedArea:...";		add: 996 "Screen deviceColormap";		add: 1055 "ProcessorScheduler primGetThreadLevels";		add: 1100 "Pixmap deviceContentsOfAreaOriginX:y:width:height:into:startingAt:";		add: 1101 "Mask deviceContentsOfAreaOriginX:y:width:height:into:startingAt:";		add: 1102 "Window deviceContentsOfAreaOriginX:y:width:height:into:startingAt:";		add: 1103 "Screen deviceContentsOfAreaOriginX:y:width:height:into:startingAt:";		add: 1104 "Screen colorDepthAndBitsPerPixel";		add: 1105 "Screen coverageDepthAndBitsPerPixel";		add: 1200 "HostPrinter primNewPrinter";		add: 1201 "HostPrinter primListFontNames";		add: 1202 "HostPrinter oldAllocateFontNamed:";		add: 1204 "HostPrintJob getDimensions";		add: 1205 "HostPrinter primPrinterName";		add: 1206 "HostPrinter colorDepthAndBitsPerPixel";		add: 1207 "HostPrinter coverageDepthAndBitsPerPixel";		add: 1214 "HostPrinter allocateFontNamed:"</body><body package="AT Profiling Core">addUninterpretedByteAllocPrimsToList	"Add to the list of allocation primitives those which allocate objects	when reading information from UninterpretedBytes"	targetPrimNumbers		add: 384 "UninterpretedBytes copySingleByteCString";		add: 385 "UninterpretedBytes copyDoubleByteCString";		add: 544 "UninterpretedBytes unsignedLongAt:";		add: 546 "UninterpretedBytes longAt:";		add: 548 "UninterpretedBytes floatAt:";		add: 550 "UninterpretedBytes longFloatAt:";		add: 552 "UninterpretedBytes unsignedLongLongAt:";		add: 554 "UninterpretedBytes longLongAt:"</body></methods><methods><class-id>Tools.AllocationProfilerCore class</class-id> <category>public access</category><body package="AT Profiling Core">coreStopProfiling	( activeProfilerCore notNil )		ifTrue: [ activeProfilerCore stopWatching ]</body></methods><methods><class-id>Tools.AllocationProfilerCore class</class-id> <category>class initialization</category><body package="AT Profiling Core">initTargetPrimitiveList	"Build the list of primitives to be subject to allocation profiling."	targetPrimNumbers := IdentitySet new: 32.	self addBasicAllocPrimsToList.	self addDoubleAllocPrimsToList.	self addMiscAllocPrimsToList.	"self addIOAllocPrimsToList."	self addIntegerAllocPrimsToList.	self addUninterpretedByteAllocPrimsToList.</body><body package="AT Profiling Core">initialize	"Install the global variable and build the method-substitution lists."	"((( AllocationProfilerCore initialize )))"	ByteOverhead := ObjectMemory current bytesPerOTE.	super initialize</body></methods><methods><class-id>Tools.AllocationProfilerCore class</class-id> <category>profiling support</category><body package="AT Profiling Core">tallyNew: anObject	"Account for a newly allocated object; called by a method doing allocation. Check to see if we've crossed the tripwire and signal any watchers if so."	"Believe that this is sent."	activeProfilerCore == nil ifFalse: [activeProfilerCore tallyNewObject: anObject]</body></methods><methods><class-id>Tools.AllocationProfilerCore class</class-id> <category>private</category><body package="AT Profiling Core">makeWrappedMethodCodeFor: oldSelector using: newSelector	"Make the code for a new wrapped method called oldSelector which calls the inner method named newSelector."	| ws numComponents components argPrefix hasArgs |	argPrefix := 'ARG'.	ws := WriteStream on: (String new: 100).	hasArgs := oldSelector numArgs &gt; 0.	components := oldSelector keywords.	numComponents := components size.	1 to: numComponents do:			[:i |			ws nextPutAll: (components at: i); space.			hasArgs				ifTrue:	[ws nextPutAll: argPrefix; print: i; space]].	ws nextPutAll: ('&lt;nt&gt;"Generated by &lt;1p&gt;"&lt;nnt&gt;| result |&lt;nt&gt;result := self '			expandMacrosWith: self).	components := newSelector keywords.	1 to: numComponents do:			[:i |			ws nextPutAll: (components at: i); space.			hasArgs				ifTrue:	[ws nextPutAll: argPrefix; print: i; space]].	ws nextPutAll: ('.&lt;nt&gt;&lt;1s&gt; tallyNew: result.&lt;nt&gt;^result'			expandMacrosWith: self name).	^ws contents</body></methods><methods><class-id>ScaledRandom</class-id> <category>accessing</category><body package="AT Profiling Core">next	"Answer the next random number."	^self step * fmodulus // modulus + 1</body></methods><methods><class-id>ScaledRandom</class-id> <category>private</category><body package="AT Profiling Core">scaleBy: aMultiplier	fmodulus := aMultiplier</body></methods><methods><class-id>ScaledRandom class</class-id> <category>instance creation</category><body package="AT Profiling Core">upperBound: aSmallInt	"This creates a generator for random integers between 1 and upperBound"	^super new scaleBy: aSmallInt</body></methods><methods><class-id>Tools.MultiAllocationProfilerCore</class-id> <category>allocation notification</category><body package="AT Profiling Core">tallyNewObject: anObject	"Account for a newly allocated object; called by a method doing	allocation. Check to see if we've crossed the tripwire and signal	any watchers if so."	currentlyActive ifTrue: [		currentlyActive := false.		anObject isImmediate ifFalse: [			statistics == nil ifFalse: [self accumulateStats: anObject].			byteCount := byteCount + (self weigh: anObject).			byteCount &gt; samplingInterval ifTrue: [				rootTally tally: thisContext sender sender sender process: Processor activeProcess by: byteCount.				byteCount := 0]].		currentlyActive := true]</body></methods><methods><class-id>Tools.MultiAllocationProfilerCore</class-id> <category>initialize-release</category><body package="AT Profiling Core">initialize	"Initialize the profiler to default values."	super initialize.	rootTally := MessageTally root name: (#AllProcesses &lt;&lt; #advanced &gt;&gt; 'All processes') asString.</body></methods><methods><class-id>Tools.MultiAllocationProfilerCore</class-id> <category>accessing</category><body package="AT Profiling Core">description	"Answer a string appropriate for labeling a resource report."	^(#MultiProcessObjectAllocation &lt;&lt; #advanced &gt;&gt; 'Multi-Process Object Allocation') asString</body></methods><methods><class-id>Tools.MultiAllocationProfilerCore class</class-id> <category>class initialization</category><body package="AT Profiling Core">initialize	"Build the method-substitution lists.  This is here so that the fileIn will automatically initialize"	"((( MultiAllocationProfilerCore initialize )))"	super initialize</body></methods><methods><class-id>Core.LinkedList</class-id> <category>accessing</category><body package="AT Profiling Core">firstLink	^firstLink</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>enumerating</category><body package="AT Profiling Core">findFirst: aBlock startingAt: anIndex	anIndex to: self size do: [:index |		(aBlock value: (self at: index)) ifTrue: [^index]].	^ 0</body></methods><methods><class-id>External.ExternalInterface class</class-id> <category>compiling</category><body package="AT Profiling Core">instanceMethodsChanged	ProfilerCore flushAllMethods</body></methods><methods><class-id>Kernel.BlockClosure</class-id> <category>general inquiries</category><body package="AT Profiling Core">microsecondsToRun	^Time microsecondsToRun: self</body><body package="AT Profiling Core">millisecondsToRun	^Time millisecondsToRun: self</body></methods><methods><class-id>Core.Process</class-id> <category>testing</category><body package="AT Profiling Core">isForeignCallbackProcess	"Asnwer true if the receiver is a foreign callback process installed by CCallback class&gt;&gt;installForeignCallbackProcess."	^self isSystemProcess and: [self name = 'ForeignCallbackProcess']</body></methods><methods><class-id>Core.Process</class-id> <category>printing</category><body package="AT Profiling Core">shortString	"Append to the argument aStream a sequence of characters that identifies the receiver."	| aStream |	aStream := String new writeStream.	super printOn: aStream.	(self name notNil and: [self name notEmpty])		ifTrue:  [			aStream				nextPutAll: ' named: ' ;				nextPutAll: self name ].	aStream		nextPutAll: ' at: ';		print: priority.	^aStream contents</body></methods><methods><class-id>Kernel.ProcessorScheduler</class-id> <category>accessing</category><body package="AT Profiling Core">preemptedProcessWith: waitPrimitive with: callbackPrimitive	"This method tries to find out, after the fact, what was the process running at the time when the currently active, high	priority one, was signalled by its semaphore and resumed, preempting it.	We start below the active process priority, since higher priority processes will never be visible by the activeProcess on the	Processor lists, they would always preempt it if they were active (and right now they must be waiting on some semaphore).	Other processes at the same priority can also not be preempted by the activeProcess, so they would be on the list because	they yielded, not because they were preempted"	"If a process has returned from one of the waiting primitives (passed as arguments here), it has not done so by itself,	it is because some other process (or the VM) has just woken it up. If they did not have a priority	sufficient to actually start running, they were just put on the list. If they did start running, they would	not be in that context anymore, they would have returned.	Therefore, processes on my lists that are in one of these contexts are not preempted processes"	activeProcess priority - 1		to: 1		by: -1		do:			[:i |			| process method |			process := (quiescentProcessLists at: i) firstLink.			nil == process ifFalse: [				process isForeignCallbackProcess					ifTrue: ["skip"]					ifFalse: 						[method := process suspendedContext method.						(method == waitPrimitive or: [method == callbackPrimitive])							ifTrue: [								"We just missed a higher priority process that was actually active in the immediately previous period"								^nil].						^process ] ]].	"No process was actually preempted by the highest-priority active process, they are all (except the active process)	waiting on semaphores"	^nil</body></methods><initialize><class-id>Tools.ProfilerCore</class-id></initialize><initialize><class-id>Tools.TimeProfilerCore</class-id></initialize><initialize><class-id>Tools.MessageTally</class-id></initialize><initialize><class-id>Tools.MultiTimeProfilerCore</class-id></initialize><initialize><class-id>Tools.AllocationProfilerCore</class-id></initialize><initialize><class-id>Tools.MultiAllocationProfilerCore</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>BlockClosure</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method outerContext copiedValues </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>ProcessorScheduler</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>quiescentProcessLists activeProcess pausedProcesses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Processes</category><attributes><package>Kernel-Processes</package></attributes></class><class><name>Magnitude</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>GeneralMethodDefinition</name><environment>Tools</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Programming</category><attributes><package>Tools-Programming</package></attributes></class><class><name>SequenceableCollection</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>LinkedList</name><environment>Core</environment><super>Core.SequenceableCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>firstLink lastLink </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Sequenceable</category><attributes><package>Collections-Sequenceable</package></attributes></class><class><name>FastRandom</name><environment>Core</environment><super>Core.Random</super><private>false</private><indexed-type>none</indexed-type><inst-vars>increment modulus fmodulus multiplier </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Process</name><environment>Core</environment><super>Core.Link</super><private>false</private><indexed-type>none</indexed-type><inst-vars>suspendedContext priority myList depth hostThreadKey interruptProtect environment isSystem name debugger locale </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Processes</category><attributes><package>Kernel-Processes</package></attributes></class></st-source>