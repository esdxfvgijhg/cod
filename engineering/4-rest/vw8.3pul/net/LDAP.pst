<?xml version="1.0"?><st-source><!-- Name: LDAPNotice: Copyright 2001 Matt Rosen, Ted KaehlerCopyright 2003 Cees de Groot, 2004 Jan Schuemmer, 2009 Holger GuhlCopyright 2016 Cincom Systems, Inc.Class Base64MimeConverter was written By Ted Kaehler, based on Tim Olson`s Base64Filter.  All other classes in the 2001 version were written by Matt Rosen, based on Java equivalents from the Netscape Java LDAP SDK. Corrections and improvements were added by Cees de Groot, Jan Schuemmer and Holger Guhl. In 2016, maintenance of this utility was taken over by Cincom Systems.The Netscape Java LDAP SDK is covered by the Mozilla Public License (http://www.mozilla.org/MPL/); this software, except as noted above, is subject to the MPL Version 1.1.  This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.Comment: This is a simple port of the San Joachin Delta College LDAP code into VW.  The code has been moved into the NET namespace.  Otherwise, the code is not changed.  1) The class structure, instance variable names, and most method names mirror their counterparts from the Netscape Java SDK.  This allows enhancements to the original Java SDK to be made in the Smalltalk SDK more easily.  It also allows leveraging of the original Java SDK documentation, which can currently be found at:http://developer.netscape.com/docs/manuals/dirsdk/jsdk30/index.htmOne major departure is that embedded classes, notably classes LDAPConnThread and ResponseControl from the original LDAPConnection class, have been created as separate regular classes.  Java interfaces have been ignored in this Smalltalk implementation.2) See the examples on the class side of class LDAPConnection.  Examples are provided for various types of inquiry and searching, iterating over results, support for LDAP URLs, add/modify/delete of directory entries, schema inquiry, and so on.  The examples cover most of the common uses for the SDK in typical applications.3) For better separation and packaging of code, all user interface classes have moved to the new parcel 'LDAPTestUI'4) The LDAP over TLS implementation is provided by Cincom LDAPS package.Questions can be addressed to Matt Rosen (mrosen@sjcoe.net)KNOWN BUGS AND LIMITATIONSA) Asynchronous search (i.e. specifying a batch size in the LDAPSearchConstraint other than zero) sometimes indicates that no more results are available when in fact they have just not arrived yet.  Hack: Inserting a delay scaled based on the specified batch size in method LDAPConnThread>>searchForDN:scope:filter:attributes:attributesOnly:constraints:takes care of this problem (a comment for the delay appears in the appropriate location).  When in doubt, use the default synchronous search.B) Automatic following of LDAP referrals has not been tested.USEFUL RESOURCES"Understanding and Deploying LDAP Directory Services"	Howes, Smith, and Good	1999, MacMillan Technical Publishing	ISBN 1-57870-070-1"LDAP Programming with Java"	By Rob Weltman, Tony Dahbura	2000, Published by Addison-Wesley	ISBN 0-20165-758-9	Detailed description of the Netscape LDAP Java Software Development Kit	by the principle implementers.Netscape Java Directory SDK Java Programmer's Guide	http://developer.netscape.com/docs/manuals/dirsdk/jsdk30/index.htmVersion history:===LDAP(tkogan) 01/14/2016- Some refactoring to allow StartTLS operation be implemented in LDAPConnection subclass- Fixed extended operation request === LDAP(hguhl-1) 16-SEP-2009- Fix infinite loop with CPU load of 100% in LDAPConnThread>>run- Fix MNU #newFromBERTag: sent to JDAPSearchResultReference class- Fix MNU #getValue sent to instance of BERSequence- Fix MNU #add: sent to an instance of LDAPSearchResults- Fix no result after searching with LDAPReferralException- Fix MNU #next sent to nil in LDAPConnThread>>run- Fix MNU #asString sent to a Character in CharacterArray>>tokensBasedOnAnyOf:answerTokens:- Fix Invalid match expression in LDAPAttributeSet>>getAttribute:language:- Reviews, optimizations, discard dead code=== LDAP(iviews-1) 27-FEB-2004- removed/fixed calls to non existant methods- no more Code Critic errors in category 'bugs'- Moved UI part into a separate package 'LDAPTestUI'=== LDAP(cg-1) 23-MAY-2002- Correct JDAPProtocolOp to use namespaced lookup- Fix off-by-one error in BERObjectId- Q&D hacks in BERElement to add support for IA5String and TeletexString=== LDAP(5i.3) 26-MAR-01first published on Cincom Public RepositoryDbIdentifier: bear73DbTrace: 494009DbUsername: tkoganDbVersion: 8.3 - 1DevelopmentPrerequisites: #(#(#any 'NetClientBase' ''))KSignature: #('definedClasses' 110 'definedClassesHash' 98843939694 'extendedClasses' 4 'extendedClassesHash' 649802327)PackageName: LDAPParcel: #('LDAP')ParcelName: LDAPPrerequisiteParcels: #(#('NetClientBase' ''))PrintStringCache: (8.3 - 1,tkogan)Version: 8.3 - 1Date: 2:30:31 PM April 28, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (apr17.3) of April 28, 2017 on April 28, 2017 at 2:30:31 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>BERElement</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-BER</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.BERElement</class-id><body>Abstract superclass for all Basic Encoding Rules element types.  Utility class methods for reading and writing components of the encoding are included.See CCITT X.209 for formal definitions for the encoding rules.</body></comment><class><name>BERConstruct</name><environment>Net</environment><super>Net.BERElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mElements </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-BER</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.BERConstruct</class-id><body>Abstract class for construct types such as sequence or set.See CCITT X.209</body></comment><class><name>BERSet</name><environment>Net</environment><super>Net.BERConstruct</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-BER</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.BERSet</class-id><body>Class for BERSet objects.  A set object contains a collection of other BER elements.See CCITT X.209</body></comment><class><name>LDAPEntryComparator</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.LDAPEntryComparator</class-id><body>LDAPEntryComparator is an abstract class used to represent algorithms used to sort search results.  Implementing subclasses specify one method, isGreater, which compares two entries and determines the order in which the entries should be sorted.See method sort of class LDAPSearchResults.</body></comment><class><name>LDAPCompareAttrNames</name><environment>Net</environment><super>Net.LDAPEntryComparator</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mAttrs mAscending </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.LDAPCompareAttrNames</class-id><body>Compares LDAPEntry objects based on one or more attribute values.To use this comparison for sorting search results, pass an instance of this class to the sort method in LDAPSearchResults.Instance Variables:	mAscending	&lt;OrderedCollection of String&gt;	Collection of attributes names for comparison between entries	mAttrs			&lt;OrderedCollection of Boolean&gt;	Collection of boolean values corresponding to attributes above.													Indicates whether each is to be sorted in ascending order.</body></comment><class><name>LDAPModification</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>operation attribute </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.LDAPModification</class-id><body>Specifies changes to be made to the values of an attribute.  The change is specified in terms of the following aspects:The type of modification (add, replace, or delete the value of an attribute)The type of value being modified (string or binary)The name of the attributeThe actual valueAfter specifying the change to an attribute, the change can be executed by sending the modify method to an LDAPConnection object and specifying the distinguished name of the entry to be modified.Instance variables:	operation 				&lt;Integer&gt;			Specifies the type of modification	attribute					&lt;LDAPAttribute&gt;	The attribute to be modified, including new value if any</body></comment><class><name>LDAPv2</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.LDAPv2</class-id><body>This class packages various constants that apply for the Lightweight Directory Access Protocol (LDAP) version 2.  See RFC 1777 for a detailed definition of the protocol.In the general model for this protocol, objects exist under a directory in a particular server.  Object are identified by unique, hierarchical names called Distinguished Names (DN).  An example of a DN: cn=Barbara Jensen, ou=Product Development, o=Ace Industry, c=us.Object have attributes of the form:attributeName = attributeValue(s)Attribute names must be Strings, and attribute values can be any 8-bit sequence (Strings or binary values).</body></comment><class><name>LDAPv3</name><environment>Net</environment><super>Net.LDAPv2</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.LDAPv3</class-id><body>Specifies additional constants that apply specifically to LDAP version 3.</body></comment><class><name>LDAPAttribute</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name values recursionLock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.LDAPAttribute</class-id><body>Represents the name and values of an attribute belonging to an entry.	name 			&lt;String&gt;				The name of the attribute	values			&lt;OrderedCollection&gt;		The values associated with the attribute	recursionLock	&lt;RecursionLock&gt;		For multithreaded access</body></comment><class><name>BERAny</name><environment>Net</environment><super>Net.BERElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mValue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-BER</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.BERAny</class-id><body>This class is for the any object that is unknown to the BER package but conforms to BER encoding rules.Encoding Rule:	The encoding is the encoding of the chosen type.See CCITT X.209</body></comment><class><name>JDAPAbandonRequest</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mMsgId </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-Client-Opers</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.JDAPAbandonRequest</class-id><body>Implements the abandon request, sent to an LDAP server.AbandonRequest ::= [APPLICATION 16] MessageIDSee RFC 1777Instance Variables:	mMsgId		&lt;Integer&gt;	identifier of message to abandon</body></comment><class><name>LDIFContent</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-Util</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.LDIFContent</class-id><body>Abstract class for representatations of the content of an LDIF record.  An LDIF record can specify an entry or modifications to be made to an entry.Specific subclasses:	LDIFAttributeContent		Represent the content of an LDIF record that specifies an entry	LDIFAddContent				Represent the content of a record that adds a new entry	LDIFModifyContent			Represent the content of a record that modifies an existing entry	LDIFDeleteContent			Represent the content of a record that deletes an existing entry	LDIFModDNContent			Represent the content of a record that changes the RDN or DN of									an existing entry</body></comment><class><name>LDIFModifyContent</name><environment>Net</environment><super>Net.LDIFContent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mMods </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-Util</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.LDIFModifyContent</class-id><body>Represents the content of an LDIF record that specifies modifications to an entry.  An instance of this class can be obtained from an LDIFRecord object using the getContent method.</body></comment><class><name>JDAPFilterOpers</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-Client</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.JDAPFilterOpers</class-id><body>Provides miscellaneous operations for JDAPFilter objects.  It converts strings with escape characters to a corresponding byte array.  It also answers a BEROctetString for a specified string with escape characters.Class Variables:	EscapeKey	&lt;Character&gt;	escape character $\	Debug		&lt;Boolean&gt;		true when debugging.  Prints trace messages.</body></comment><class><name>BERBoolean</name><environment>Net</environment><super>Net.BERElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mValue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-BER</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.BERBoolean</class-id><body>Boolean BER type.Encoding Rule:	tag = 0x01	length = 0x01	one contents octet (non-zero indicates true)Example 1: (false)	01 01 00Example 2: (true)	01 01 FFSee CCITT X.209</body></comment><class><name>JDAPFilter</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-Client</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.JDAPFilter</class-id><body>Abstract class for implementing the LDAP filter.Filter ::= CHOICE {			and [0] SET OF Filter,			or [1] SET OF Filter,			not [2] Filter,			equalityMatch [3] AttributeValueAssertion,			substrings [4] SubstringFilter,			greaterOrEqual [5] AttributeValueAssertion,			lessOrEqual [6] AttributeValueAssertion,			present [7] AttributeType,			approxMatch [8] AttributeValueAssertion		}Filter string syntax:     * Constructs filter from filter string specified in RFC1558.     * &lt;pre&gt;     * &lt;filter&gt; ::= '(' &lt;filtercomp&gt; ')'     * &lt;filtercomp&gt; ::= &lt;and&gt; | &lt;or&gt; | &lt;not&gt; | &lt;item&gt;     * &lt;and&gt; ::= '&amp;' &lt;filterlist&gt;     * &lt;or&gt; ::= '|' &lt;filterlist&gt;     * &lt;not&gt; ::= '!' &lt;filter&gt;     * &lt;filterlist&gt; ::= &lt;filter&gt; | &lt;filter&gt; &lt;filterlist&gt;     * &lt;item&gt; ::= &lt;simple&gt; | &lt;present&gt; | &lt;substring&gt;     * &lt;simple&gt; ::= &lt;attr&gt; &lt;filtertype&gt; &lt;value&gt;     * &lt;filtertype&gt; ::= &lt;equal&gt; | &lt;approx&gt; | &lt;greater&gt; | &lt;less&gt;     * &lt;equal&gt; ::= '='     * &lt;approx&gt; ::= '~='     * &lt;greater&gt; ::= '&gt;='     * &lt;less&gt; ::= '&lt;='     * &lt;present&gt; ::= &lt;attr&gt; '=*'     * &lt;substring&gt; ::= &lt;attr&gt; '=' &lt;initial&gt; &lt;any&gt; &lt;final&gt;     * &lt;initial&gt; ::= NULL | &lt;value&gt;     * &lt;any&gt; ::= '*' &lt;starval&gt;     * &lt;starval&gt; ::= NULL | &lt;value&gt; '*' &lt;starval&gt;     * &lt;final&gt; ::= NULL | &lt;value&gt;</body></comment><class><name>JDAPFilterSet</name><environment>Net</environment><super>Net.JDAPFilter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mTag mSet </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-Client</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.JDAPFilterSet</class-id><body>Abstract class for support of the 'and' and 'or' filters.Instance Variables:	mSet	&lt;OrderedCollection&gt;		collection of JDAPFilter objects	mTag	&lt;Integer&gt;				integer corresponding to a BERTag value</body></comment><class><name>JDAPFilterAnd</name><environment>Net</environment><super>Net.JDAPFilterSet</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-Client</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.JDAPFilterAnd</class-id><body>Implements the filter 'and'.</body></comment><class><name>JDAPSearchResultReference</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mURLs mElement </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-Client-Opers</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.JDAPSearchResultReference</class-id><body>Implements the search result reference.SearchResultReference ::= [APPLICATION 19] SEQUENCE OF LDAPURLSee RFC 1777Instance Variables:	mElement		&lt;BERElement&gt;			BERElement containing the encoded result from LDAP server	mURLs			&lt;Collection of String&gt;	Collection of strings representing the URLs that refer to the result</body></comment><class><name>BERUTCTime</name><environment>Net</environment><super>Net.BERElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mValue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-BER</category><attributes><package>LDAP</package></attributes></class><class><name>MalformedURLException</name><environment>Net</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP</category><attributes><package>LDAP</package></attributes></class><class><name>DistinguishedName</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mRDNs mDNType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-Util</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.DistinguishedName</class-id><body>Represents distinguished names (DNs).  A distinguished name is used to uniquely identify an entry in a directory.  This class is used internally by the LDAPDN class.  In most cases, the LDAPDN class should be instantiated for use in LDAP applications instead of instantiating this class directly.The following are examples of distinguished name formats that may appear:uid=bjensen, ou=People, o=Arius.com		RFC 1485 format											(see http://ds.internic.net/rfc/rfc1485.txt)o=Arius.com/ou=People/uid=bjensen			OSF formatInstance variables:	mRDNs					&lt;OrderedCollection&gt;		Collection of RDNs.  A DN consists of one or more													RDNs.	mDNType				&lt;Integer&gt;				Specifies DN format.  0 = RFC1485, 1 = OSF</body></comment><class><name>BERTag</name><environment>Net</environment><super>Net.BERElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mTag mElement mImplicit </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-BER</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.BERTag</class-id><body>This class is for the tagged object.  Nested tags are allowed.  A tagged element contains another BER element.See CCITT X.209</body></comment><class><name>LDAPUrl</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hostName portNumber dn attributes scope filter url </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.LDAPUrl</class-id><body>Represents an LDAP URL.  The complete specification for LDAP URLs is in RFC 1959.  LDAP URLs have the following format:'ldap://' [ hostName [ ':' portNumber ] ] '/' distinguishedName [ '?' attributeList [ '?' scope '?' filterString ] ]whereall text in 'single quotes' is literal;hostName and portNumber identify the network location of the LDAP server;distinguishedName is the name of an entry within the given directory and represents the starting point of the search;attributeList contains a comma delimited list of attributes to retrieve (if none, all attributes are returned);scope is one of the following:	base = indicates that only the specified entry is to be searched (default)	one = indicates that this is a search for matching entries one level below the base entry (not including the base)	sub = indicates that this is a search for matching entries at all levels below the base (including the base itself)filterString is a human-readable representation of the search criteria, used for scope one or sub searchesNote that if scope and filterString are not specified, an LDAP URL identifies exactly one entry in the directory.The same encoding rules for other URLs (e.g. HTTP) apply for LDAP URLs.  Specifically, any 'illegal' characters are escaped with %HH, where HH represents the two hex digits which correspond to the ASCII value of the character.  This encoding is only lega (or necessary) on the DN and filter portions of the URL.Instance Variables:	attributes		&lt;OrderedCollection						of String&gt;		attribute types to answer in search result	dn				&lt;String&gt;			distinguished name of base entry in search	filter			&lt;String&gt;			filter string (see RFC 1558)	hostName		&lt;String&gt;			name of LDAP server host	portNumber		&lt;Integer&gt;			port number on LDAP host	scope			&lt;Integer&gt;			identifies scope (See LDAPv2 class protocol constants-scope)	url				&lt;String&gt;			the full URL string</body></comment><class><name>BERTagDecoder</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-BER</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.BERTagDecoder</class-id><body>Abstract class which should be subclassed for use in conjunction with the BERTag class in decoding application specific BER tags.  Since each different application may define its own tags, the BER package needs the tag decoder to give hints for how to decode implicit tagged objects.  See CCITT X.209</body></comment><class><name>LDIFModDNContent</name><environment>Net</environment><super>Net.LDIFContent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mNewParent mRDN mDeleteOldRDN </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-Util</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.LDIFModDNContent</class-id><body>Represents the content of an LDIF record that specifies changes to an RDN or the DN of an entry.  An instance of this class can be obtained from an LDIFRecord object using the getContent method.Instance variables:	mRDN					The string representation of the new RDN to be assigned to the entry	mNewParent			The string representation of the DN of the new parent for the entry	mDeleteOldRDN			If true, the old RDN should be removed as an attribute of the entry</body></comment><class><name>BERCharacterString</name><environment>Net</environment><super>Net.BERElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mValue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-BER</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.BERCharacterString</class-id><body>Abstract class for character string types.See CCITT X.209</body></comment><class><name>BERPrintableString</name><environment>Net</environment><super>Net.BERCharacterString</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-BER</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.BERPrintableString</class-id><body>Class for printable string type.See CCITT X.209</body></comment><class><name>BERIntegral</name><environment>Net</environment><super>Net.BERElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mValue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-BER</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.BERIntegral</class-id><body>Base class for integral types such as Integer and Enumerated.Encoding Rule:	Primitive Definite length.	tag = &lt;&lt; depends on type &gt;&gt;	length = (short or long form)	one or more contents octets hold integral value	value in two's complementExample 1: (Integer - 0)	02 01 00Example 2: (Enumerated - 1)	0A 01 01Example 3: (Integer - 300, short form)	02 02 01 2CExample 4: (Integer - 300, long form)	02 84 00 00 01 2CSee CCITT X.209</body></comment><class><name>JDAPFilterAva</name><environment>Net</environment><super>Net.JDAPFilter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mTag mAva </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-Client</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.JDAPFilterAva</class-id><body>Implements the attribute value assertion (AVA) filter.Instance Variables:	mAva	&lt;JDAPAva&gt;	attribute value assertion	mTag	&lt;Integer&gt;	tag value</body></comment><class><name>JDAPFilterApproxMatch</name><environment>Net</environment><super>Net.JDAPFilterAva</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-Client</category><attributes><package>LDAP</package></attributes></class><class><name>LDAPConnThread</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mHighMsgId mServerStream mRequests mMessages mRegistered mDisconnected mSecurityLayer mMaxBacklog lock backlogSemaphore socket process </inst-vars><class-inst-vars>defaultTimeout </class-inst-vars><imports></imports><category>LDAP</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.LDAPConnThread</class-id><body>Represents and manages the low level network connection to the server.  Multiple LDAPConnection objects can share this single connection.  All LDAPConnections send requests and obtain responses by way of an LDAPConnThread.Instance Variables:	mCache			&lt;LDAPCache&gt;	Searches may be cached to improve performance.	mDisconnected		&lt;Boolean&gt;		True if connection is not active.	mFailed				&lt;Boolean&gt;		Used to ensure this link go away should the initial connection fail.	mHighMsgId		&lt;Integer&gt;		Last assigned arbitrary, unique message Id used to correlate requests &amp; responses.	mMaxBacklog		&lt;Integer&gt;		The limit in backlogged search responses received before halting receipt of more.	mMessages			&lt;Dictionary&gt;	Key is message Id, value is OrderedCollection of JDAPMessages for that Id.	mRegistered		&lt;OrderedCollection&gt;		Collection of LDAPConnections this instance services.	mRequests			&lt;Dictionary&gt;	Key is message Id, value is LDAPResponseListener to notify of reply.	mSecurityLayer		&lt;Object&gt;		Not used in this implementation currently.	mServerStream		&lt;ExternalReadAppendStream&gt;	Socket input/output stream. Close also closes the socket.	lock				&lt;RecursionLock&gt;	Ensures threadsafe operation	backlogSemaphore	&lt;Semaphore&gt;	Allows thread to sleep when excess backlog of requests to be processed.	socket 		&lt;SocketAccessor&gt;	process		&lt;Process&gt; runs response processClass Instance Variables:	defaultTimeout		&lt;integer&gt;  default timeout to connect</body></comment><class><name>JDAPFilterSubString</name><environment>Net</environment><super>Net.JDAPFilter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mType mInitial mAny mFinal </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-Client</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.JDAPFilterSubString</class-id><body>Implements the filter 'substring'.[4] SEQUENCE {	type AttributeType,	SEQUENCE OF CHOICE {		initial [0] LDAPString,		any [1] LDAPString,		final [2] LDAPString	}}See RFC 1777Instance Variables:	mAny	&lt;OrderedCollection of String&gt;	collection of attribute values for 'any' match	mFinal	&lt;OrderedCollection of String&gt;	collection of attribute values for 'final' match	mInitial	&lt;OrderedCollection of String&gt;	collection of attribute values for 'initial' match	mType	&lt;OrderedCollection of String&gt;	string representing the attribute type</body></comment><class><name>JDAPSearchResponse</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mObjectName mElement mAttributes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-Client-Opers</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.JDAPSearchResponse</class-id><body>Implements the search response, sent from the LDAP server in response to a search request.SearchResultEntry ::= [APPLICATION 4]  SEQUENCE {						objectName LDAPDN,						attributes SEQUENCE OF SEQUENCE {							AttributeType,							SET OF AttributeValue						}					}Note that the following is the LDAPv3 definition:SearchResultEntry ::= [APPLICATION 4] SEQUENCE {							objectName LDAPDN,							attributes PartialAttributeList						}PartialAttributeList ::= SEQUENCE OF SEQUENCE {							type AttributeDescription,							vals SET OF AttributeValue						}Instance Variables:	mAttributes			&lt;Collection of LDAPAttribute&gt;	collection of attribute objects returned by search request	mElement			&lt;BERElement&gt;					encoded response from LDAP server	mObjectName		&lt;String&gt;						distinguished name of object searched</body></comment><class><name>BERNull</name><environment>Net</environment><super>Net.BERElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-BER</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.BERNull</class-id><body>Class for Null type.Encoding Rule:	tag = 0x05	length value is zero (short or long form)	no contentsExample 1: (short form)	05 00Example 2: (long form)	05 81 00See CCITT X.209</body></comment><class><name>JDAPFilterEqualityMatch</name><environment>Net</environment><super>Net.JDAPFilterAva</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-Client</category><attributes><package>LDAP</package></attributes></class><class><name>LDAPRebindAuth</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mDN mPassword </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.LDAPRebindAuth</class-id><body>Instances are used for authentication when following referrals automatically. Instance Variables:	mDN		&lt;String&gt;	Distinguished name to use for authentication.	mPassword	&lt;String&gt;	Password for distinguished name to use for authentication.</body></comment><class><name>JDAPResult</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mElement mResultCode mMatchedDN mErrorMessage mReferrals </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-Client-Opers</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.JDAPResult</class-id><body>Implements the ldap result in which a request status is stored.  This is the base class for all responses except search responses.  Instances are sent from the server to the client interface.LDAPResult ::= SEQUENCE {					resultCode ENUMERATED {						success (0), 						...					}				matchedDN LDAPDN,				errorMessage LDAPString				}Note that LDAPv3 supports referral within the LDAP Result.  The added component is:LDAPResult ::= SEQUENCE {					...				errorMessage LDAPString,				referral [3] Referral OPTIONAL				}Instance Variables:	mElement			&lt;BERElement&gt;			encoded response from server that this instance will decode	mErrorMessage		&lt;String&gt;				text of error message returned	mMatchedDN		&lt;String&gt;				matched distinguished name	mReferrals			&lt;Collection of String&gt;	Collection containing referral strings	mResultCode		&lt;Integer&gt;				result code returned (see ResultCodes class variable)Class Variables:	ResultCodes		&lt;Dictionary&gt;			keys are Integer result codes, values are String result meanings</body></comment><class><name>JDAPDelResponse</name><environment>Net</environment><super>Net.JDAPResult</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-Client-Opers</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.JDAPDelResponse</class-id><body>Implements a compare request, sent from an LDAP server.DeleteResponse ::= [APPLICATION 11] LDAPResult</body></comment><class><name>JDAPBaseDNRequest</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mDN </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-Client-Opers</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.JDAPBaseDNRequest</class-id><body>Abstract class for all requests that have a base Distinguished Name component.</body></comment><class><name>JDAPAddRequest</name><environment>Net</environment><super>Net.JDAPBaseDNRequest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mAttrs </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-Client-Opers</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.JDAPAddRequest</class-id><body>Implements the add request.  Instances are sent to the LDAP server.AddRequest ::= [APPLICATION 8] SEQUENCE {	entry LDAPDN,	attrs SEQUENCE OF SEQUENCE {		type AttributeType, 		values SET OF AttributeValue	}}Instance Variables:	mAttrs		&lt;Collection of LDAPAttribute&gt;	LDAPAttributes associated with the add request</body></comment><class><name>JDAPSearchResult</name><environment>Net</environment><super>Net.JDAPResult</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-Client-Opers</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.JDAPSearchResult</class-id><body>Implements the search result, sent from the LDAP server to the interface.  Note that search response is separated into a search response (sic) and search result.  The search response contains the result from the server, while the research result indicates the end of the search response sequence.resultCode ::= [APPLICATION 5] LDAPResult</body></comment><class><name>JDAPFilterExtensible</name><environment>Net</environment><super>Net.JDAPFilter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mTag mType mValue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-Client</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.JDAPFilterExtensible</class-id><body>Implements the extended match filter.Instance Variables:	mTag	&lt;Integer&gt;	tag value	mType	&lt;String&gt;	attribute description	mValue	&lt;String&gt;	matching rule assertion</body></comment><class><name>JDAPAva</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mType mVal </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-Client</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.JDAPAva</class-id><body>Implements the attribute value assertion.  Such objects are used with filters.Instance Variables:	mType	&lt;String&gt;	attribute type	mVal	&lt;String&gt;	attribute value</body></comment><class><name>LDAPControl</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mOid mCritical mValue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.LDAPControl</class-id><body>Represents arbitrary control data that can be used with a particular LDAP operation.  LDAP controls are part of version 3 of the LDAP protocol.LDAP controls allow extension of the functionality of an LDAP operation.  For example, an LDAP control can be used in a search operation to sort search results on an LDAP server.An LDAP control can be either a server control or a client control.  Server controls can be sent to the LDAP server or returned by the server on any operation.  Client controls are intended to affect only the client side of the operation.An LDAP control consists of the following information:1) A unique object identifier (OID) that identifies the control.2) A "criticality" field which indicates whether or not the control is critical to the operation.  If the control is critical to the operation and the server does not support the control, the server should not execute the operation.3) Data relevant to the control.To determine which server controls are supported by a particular server, you need to search for the root DSE (DSA-specific entry, where DSA is another term for LDAP server) and find the values of the supportedControl attribute.  This attribute contains the object identifiers of the controls supported by the server.For more information on LDAP controls, see the Internet Draft on the LDAP v3 protocol.Instance Variables:	mCritical		&lt;Boolean&gt;		true if this control is critical to the operation in question	mOid			&lt;String&gt;		object identifier in dotted number format (i.e. 1.2.3.4)	mValue			&lt;ByteArray&gt;	arbitrary data to support control</body></comment><class><name>LDAPSortControl</name><environment>Net</environment><super>Net.LDAPControl</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-Controls</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.LDAPSortControl</class-id><body>Represents an LDAPv3 server control that specifies that the server should return sorted results.  When constructing an LDAPSortControl object, the order in which the results are to be sorted can be specified.  Whether or not this control is critical to the search operation can also be specified.To specify the sort order, an LDAPSortKey object is created and passed to the LDAPSortControl instance creation method.  The LDAPSortKey object represents a list of the attributes to be used for sorting (a sort key list).  The control is then added to the search constraints associated with the search operation.The LDAP server sends back a sort response control to indicate the result of the sorting operation.  This control contains:a) The result code from the sorting operationb) Optionally, the first attribute type in the sort key list that resulted in an error (for example, if the attribute does not exist).To parse this control, use the parseControl method..</body></comment><class><name>BEREnumerated</name><environment>Net</environment><super>Net.BERIntegral</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-BER</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.BEREnumerated</class-id><body>Class for Enumerated objects.See CCITT X.209</body></comment><class><name>LDAPModificationSet</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>modifications recursionLock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.LDAPModificationSet</class-id><body>Represents a collection of modifications to be made to attributes in a directory entry.  A set of modifications is made up of LDAPModification objects.After specifying changes to attributes, the changes can be executed by sending the modify message to an LDAPConnection object and specifying the distinguished name of the entry that you want to modify.Instance variables:	current					&lt;Integer&gt;	modifications			&lt;OrderedCollection&gt;		Contains LDAPModification objects	recursionLock			&lt;RecursionLock&gt;		Allows threadsafe operation</body></comment><class><name>LDAPExtendedOperation</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mOid mVals </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.LDAPExtendedOperation</class-id><body>Version 3 of the LDAP protocol includes the means of defining additional operations (extended operations) beyond the standard LDAP operations.  An LDAPv3 client can send an extended operation request, identifying the operation by its unique object identifier (OID).  The server receives the request and if OID corresponds to an operation supported by the server, the server processes the request and sends an extended operation response back to the client.Object of this class can be used to represent extented operation requests, sent by the client, or extended operation responses returned by an LDAP v3 server.To determine which extended operations are supported by a server, the client needs to search for the root DSE (DSA-specific Entry, where DSA is another term for LDAP server) and find values fo the supportedExtension attribute.  This attribute contains the object identifiers of the extended operations supported by the server.Instance Variables:	mOid	&lt;String&gt;		Object identifier of the extended operation in dotted string format (1.2.3.4)	mVals	&lt;ByteArray&gt;	Data associated with the extended operation</body></comment><class><name>JDAPAddResponse</name><environment>Net</environment><super>Net.JDAPResult</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-Client-Opers</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.JDAPAddResponse</class-id><body>Represents the response from the LDAP server to a JDAPAddRequest message.AddResponse ::= [APPLICATION 9]	LDAPResultSee RFC 1777</body></comment><class><name>LDAPException</name><environment>Net</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars>resultCode </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP</category><attributes><package>LDAP</package></attributes></class><class><name>JDAPFilterNot</name><environment>Net</environment><super>Net.JDAPFilter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mFilter </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-Client</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.JDAPFilterNot</class-id><body>Implements the filter 'not'.  See RFC 1777.Instance Variables:	mFilter	&lt;JDAPFilter&gt;	filter which will be logically negated by this filter</body></comment><class><name>ResponseControl</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mConnection mMessageId mControls </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.ResponseControl</class-id><body>Represents the value of the response control dictionary within an LDAPConnection object.  It stores the response controls and the corresponding LDAPConnection and message ID for the associated JDAPMessage.Instance Variables:mConnection	&lt;LDAPConnection&gt;			The connection associated with the controls.mMessageId	&lt;Integer&gt;					The message ID the controls were received under.mControls		&lt;Collection of LDAPControl&gt;	The controls themselves.</body></comment><class><name>LDAPVirtualListControl</name><environment>Net</environment><super>Net.LDAPControl</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mBeforeCount mAfterCount mListIndex mListSize </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-Controls</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.LDAPVirtualListControl</class-id><body>Represents control data for returning paged results from a search.Instance Variables:	mAfterCount	&lt;Integer&gt;	number of entries desired after the top/center to return per page	mBeforeCount	&lt;Integer&gt;	number of entries desired before the top/center to return per page	mListIndex		&lt;Integer&gt;	index of the current entry	mListSize		&lt;Integer&gt;	total size of the list</body></comment><class><name>Base64MimeConverter</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dataStream mimeStream </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-Util</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.Base64MimeConverter</class-id><body>This class encodes and decodes data in Base64 format.  This is MIME encoding.  We translate a whole stream at once, taking a Stream as input and giving one as output.  Returns a whole stream for the caller to use.           0 A            17 R            34 i            51 z           1 B            18 S            35 j            52 0           2 C            19 T            36 k            53 1           3 D            20 U            37 l            54 2           4 E            21 V            38 m            55 3           5 F            22 W            39 n            56 4           6 G            23 X            40 o            57 5           7 H            24 Y            41 p            58 6           8 I            25 Z            42 q            59 7           9 J            26 a            43 r            60 8          10 K            27 b            44 s            61 9          11 L            28 c            45 t            62 +          12 M            29 d            46 u            63 /          13 N            30 e            47 v          14 O            31 f            48 w         (pad) =          15 P            32 g            49 x          16 Q            33 h            50 yOutbound: bytes are broken into 6 bit chunks, and the 0-63 value is converted to a character.  3 data bytes go into 4 characters.Inbound: Characters are translated in to 0-63 values and shifted into 8 bit bytes.(See: N. Borenstein, Bellcore, N. Freed, Innosoft, Network Working Group, Request for Comments: RFC 1521, September 1993, MIME (Multipurpose Internet Mail Extensions) Part One: Mechanisms for Specifying and Describing the Format of Internet Message Bodies. Sec 6.2)By Ted Kaehler, based on Tim Olson`s Base64Filter.</body></comment><class><name>LDIFAddContent</name><environment>Net</environment><super>Net.LDIFContent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mAttrs </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-Util</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.LDIFAddContent</class-id><body>Represents the content of an LDIF record that specifies an entry to be added.  An instance of this class can be obtained from an LDIFRecord object using the getContent method.</body></comment><class><name>BERVisibleString</name><environment>Net</environment><super>Net.BERCharacterString</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-BER</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.BERVisibleString</class-id><body>Class for visible string type.See CCITT X.209</body></comment><class><name>JDAPFilterLessOrEqual</name><environment>Net</environment><super>Net.JDAPFilterAva</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-Client</category><attributes><package>LDAP</package></attributes></class><class><name>LDIFLineReader</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>inStream nextItem </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-Util</category><attributes><package>LDAP</package></attributes></class><class><name>JDAPExtendedResponse</name><environment>Net</environment><super>Net.JDAPResult</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mOid mValue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-Client-Opers</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.JDAPExtendedResponse</class-id><body>Represents the response from the LDAP server to an extended request message.  This is a v3 response.ExtendedResponse ::= [APPLICATION 23] SEQUENCE {						COMPONENTS OF LDAPResult,						responseName [10] LDAPOID OPTIONAL,						response [11] OCTET STRING OPTIONAL				   		}See RFC 1777Instance Variables:	mOid		&lt;String&gt;			object identifier associated with extended request	mValue		&lt;Byte Array&gt;		data associated with extended request response</body></comment><class><name>JDAPControl</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mType mCriticality mVals </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-Client</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.JDAPControl</class-id><body>Implements controls for LDAPv3.Control ::= SEQUENCE {				controlType	LDAPOID,				criticality		BOOLEAN DEFAULT FALSE,				controlValue	OCTET STRING OPTIONAL			}Instance Variables:	mCriticality		&lt;Boolean&gt;		indicates the criticality of the control for the operation in question.  Default is false	mType			&lt;String&gt;		type of control as a dotted string format object identifier	mVals			&lt;ByteArray&gt;	control data</body></comment><class><name>JDAPCompareResponse</name><environment>Net</environment><super>Net.JDAPResult</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-Client-Opers</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.JDAPCompareResponse</class-id><body>Implements a compare request, sent from an LDAP server.CompareResponse ::= [APPLICATION 15] LDAPResult</body></comment><class><name>LDAPConnection</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>defaultConstraints responseListeners searchListeners bound host mHostList port mPortList mDefaultPort prevBoundDN prevBoundPasswd boundDN boundPasswd protocolVersion connThread mAttachedList mResponseControlTable mAnonymousBound saslBind mReferralConnection lock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.LDAPConnection</class-id><body>Represents a connection to an LDAP server.  Use instances to perform LDAP operations (such as adding, modifying, deleting and renaming entries, or searching for entries).To perform an operation on a server, logically perform the following steps:Create an instance of this class.Send the connect method to the instance to establish the link to the LDAP server.Use the authenticate method to 'log in' to the server.Perform the LDAP operation.Use the disconnect method to 'log off' of the server and shut down the connection.All operations block until completion (with the exception of the search method when the results are not all returned at the same time).This class also specifies a default set of search constraints, such as the maximum number of results returned by a search, which apply to all operations.  These constraints can be obtained and modified using the getOption and setOption methods.  To override the default constraints for a particular operation, define a new set of constraints by creating an LDAPSearchConstraints object and pass the object to the search method of the LDAPConnection object.If the client is configured to follow referrals automatically, an operation that results in a referral will create a new connection to the LDAP server identified in the referral.  In order to have the client authenticate to the LDAP server automatically, the application will need to define a subclass of LDAPRebind.  In that subclass, overide the getRebindAuthenticationForHost:  port: method to answer an appropriately initialized instance of LDAPRebindAuth (i.e. containing the appropriate DN and password to use for the new server).Most errors that occur raise the same exception, LDAPException.  See that class for the meaning of the various result codes.Instance Variables:	bound				&lt;Boolean&gt;				True if connection is bound to a server	boundDN			&lt;String&gt;				DN connection is bound under	boundPasswd		&lt;String&gt;				Password used for binding to server	connThread			&lt;LDAPConnThread&gt;		Current connection thread	defaultConstraints	&lt;LDAPSearchConstraints&gt;	Default constraints object	host				&lt;String&gt;				Domain name string for host	mAnonymousBound	&lt;Boolean&gt;				Indicates whether last binding was anonymous	mAttachedList		&lt;OrderedCollection&gt;		mCache			&lt;LDAPCache&gt;			Cache object in use by this connection	mClientCB			&lt;Object&gt;		mDefaultPort		&lt;Integer&gt;				Default port to use for connecting to host	mHostList			&lt;OrderedCollection&gt;		Collection of host strings to use for connections	mMechanismDriver	&lt;Object&gt;		mPortList			&lt;OrderedCollection&gt;		Collection of port integers corresponding to mHostList	mReferralConnection	&lt;LDAPConnection&gt;	Connection from a search referral	mResponseControlTable	&lt;Dictionary&gt;		Key is connection thread, values are corresponding response controls	mSecurity			&lt;Object&gt;					mSecurityProperties	&lt;Properties&gt;				port					&lt;Integer&gt;				Port used at last binding	prevBoundDN		&lt;String&gt;				Prior DN used for binding	prevBoundPasswd	&lt;String&gt;				Prior password used for binding	protocolVersion		&lt;Integer&gt;				LDAP version in use, currently either 2 or 3	responseListeners	&lt;OrderedCollection&gt;		Response listener object pool	saslBind			&lt;Boolean&gt;				True if binding using SASL (not supported in this implementation)	searchListeners		&lt;OrderedCollection&gt;		Search listener object pool	lock				&lt;RecursionLock&gt;		Allow thread safe method executionClass Variables:	ReadConstraints	&lt;LDAPSearchConstraints&gt;		ThreadConnTable	&lt;Dictionary&gt;			Keys are LDAPConnThreads, values are Collection of LDAPConnections													which use that LDAPConnThread</body></comment><class><name>JDAPFilterOr</name><environment>Net</environment><super>Net.JDAPFilterSet</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-Client</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.JDAPFilterOr</class-id><body>Implements the filter 'or'.</body></comment><class><name>BERNumericString</name><environment>Net</environment><super>Net.BERCharacterString</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-BER</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.BERNumericString</class-id><body>Class for numeric string type.See CCITT X.209</body></comment><class><name>LDAPResponseListener</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>response exception exceptionOccured controls connection id queue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.LDAPResponseListener</class-id><body>Instances take the asynchronous LDAP responses and make them appear somewhat synchronized.  Uses SharedQueue mechanisms to block response process until a response is received.  This is also used to communicate exceptions across processes.Instance Variables:	connection			&lt;LDAPConnection&gt;	Connection owning this listener	controls				&lt;Collection of 						LDAPControl&gt;		Controls associated with request/response	exception			&lt;LDAPException&gt;	Exception returned from operation	exceptionOccured	&lt;Boolean&gt;			True if an exception occurred in carrying out operation	id					&lt;Integer&gt;			Current unique message identifier	queue				&lt;SharedQueue&gt;		Synchronizes wait for receipt of response	response			&lt;JDAPMessage&gt;	The response received</body></comment><class><name>JDAPCompareRequest</name><environment>Net</environment><super>Net.JDAPBaseDNRequest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mAva </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-Client-Opers</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.JDAPCompareRequest</class-id><body>Implements a bind request, sent to an LDAP server.CompareRequest ::= [APPLICATION 14] SEQUENCE {						entry LDAPDN,						ava AttributeValueAssertion					}Instance Variables:	mAva	&lt;JDAPAva&gt;			attribute value assertion</body></comment><class><name>LDAPReferralException</name><environment>Net</environment><super>Core.Notification</super><private>false</private><indexed-type>none</indexed-type><inst-vars>resultCode mReferrals </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.LDAPReferralException</class-id><body>Represents the situation in which the LDAP server refers the client to another LDAP server.  This exception constructs a list of referral URLs from the LDAP error message returned by the server.  Applications can get this list by using the getURLs message.Instance Variables:	mReferrals	&lt;String&gt;	URLs for other servers referred to by responding server</body></comment><class><name>JDAPModifyResponse</name><environment>Net</environment><super>Net.JDAPResult</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-Client-Opers</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.JDAPModifyResponse</class-id><body>Implements a modify request, sent from an LDAP server.ModifyResponse ::= [APPLICATION 7] LDAPResult</body></comment><class><name>JDAPBERTagDecoder</name><environment>Net</environment><super>Net.BERTagDecoder</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-Client</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.JDAPBERTagDecoder</class-id><body>Assists BER libraries in decoding an implicit object.</body></comment><class><name>LDAPSearchResults</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>entries resultSource searchComplete connectionToClose currConn persistentSearch currCons currBase currScope currFilter currAttrs currAttrsOnly referralResults firstResult lock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.LDAPSearchResults</class-id><body>Implements a stream-like access to the results of a search operation.  The results can only be traversed once, so if the results are needed more than once by the application they should be stored as is appropriate.  Instances can also be used to abandon a search in progress.Instance Variables:	connectionToClose	&lt;LDAPConnection&gt;	Connection to be closed when results have all been received.	currAttrs			&lt;Collection of							String&gt;			Collection of attribute types associated with the search.	currAttrsOnly		&lt;Boolean&gt;			Indicates whether attribute values only were desired from search.	currBase			&lt;String&gt;			DN of search base.	currConn			&lt;LDAPConnection&gt;	Connection currently used to carry out search operation.	currCons			&lt;LDAPSearchConstraints&gt;	The constraints associated with the search.	currFilter			&lt;String&gt;			The filter associated with the search.	currScope			&lt;Integer&gt;			The scope associated with the search.	entries				&lt;OrderedCollection&gt;		LDAPEntry objects answered as a result of the search.	firstResult			&lt;Boolean&gt;			Used only for persistent search.  Indicates this is the first result.	persistentSearch	&lt;Boolean&gt;			Indicates if this is a persistent search operation.	referralResults		&lt;OrderedCollection&gt;		Results which are LDAPReferralExceptions.	resultSource		&lt;LDAPSearchListener&gt;	The listener which obtained the results.	searchComplete		&lt;Boolean&gt;			True if search is complete, false otherwise.</body></comment><class><name>LDAPSchemaElement</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>oid name description attrName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.LDAPSchemaElement</class-id><body>Abstract class representing an element (such as an object class definition, an attribute type definition, or a matching rule definition) in the schema.  The specific types of elements are represented by the LDAPObjectClassSchema, LDAPAttributeSchema and LDAPMatchingRuleSchema subclasses.See http://ds.internic.net/rfc/rfc2252.txt, RFC 2252 Lightweight Directory Access Protocol (v3): Attributed Syntax Definitions for the types of information that needs to be specified in the definition of an object class, attribute type, or matching rule.  All of these schema elements can specify the following information:	a name identifying the element	an OID (object identification number) identifying the element	a description of the element.The LDAPSchemaElement class implements methods that can be used with each of the types of schema elements.  You can do the following:	get the name, OID, or description of a schema element	add an element to the schema	remove an element from the schema</body></comment><class><name>LDAPObjectClassSchema</name><environment>Net</environment><super>Net.LDAPSchemaElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>superior must may auxiliary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.LDAPObjectClassSchema</class-id><body>Represents an object class definition in a directory.  See RFC 2252, Lightweight Directory Access Protocol (v3): Attribute Syntax Definitions.  This reference indicates the types of information that need to be specified in the definition of an object class.  According to the RFC, the description of an object class can include the following information: an OID identifying the object classa name identifying the object classa description of the object classthe name of the parent object classthe list of attribute types that are required for objects belonging to the object classthe list of attribute types that are allowed (optional)  for objects belonging to the object class.When an LDAPObjectClassSchema is instantiated, you can specify the values of these attributes via the instance creation methods or by using the ObjectClassDescription format specified in RFC 2252.  Note: When an LDAP client searches an LDAP server for the schema, the server returns schema information as an object with attribute values in this format.RFC 2252 also notes that you can specify whether or not an object class is abstract, structural, or auxiliary in the object description.  (Abstract object classes are used only to derive other object classes.  Entries cannot belong to an abstract object class.  "top" is an abstract object class, for example.)Directory entries must belong to a structural object class, so most object classes are structural object classes.  Objects of the LDAPObjectClassSchema class are structural object classes by default.  Auxiliary object classes can be used to construct entries of different types.  For example, an auxiliary object class might be used to specify a type of entry with a structural object class that can vary (an auxiliary object class might specify that an entry must either be an organizationalPerson or residentialPerson).  If the definition of an object (in ObjectClassDescription format) specifies the AUXILIARY keyword, an LDAPObjectClassSchema object created from that description represents an auxiliary object class.Instance Variables:	auxiliary	&lt;Boolean&gt;				true if this object is auxiliary (see above)	may		&lt;OrderedCollection&gt;		collection of strings naming optional attributes for objects of this class	must		&lt;OrderedCollection&gt;		collection of strings naming mandatory attributes for objects of this class	superior		&lt;String&gt;				name of object class which is the parent of this class</body></comment><class><name>JDAPFilterGreaterOrEqual</name><environment>Net</environment><super>Net.JDAPFilterAva</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-Client</category><attributes><package>LDAP</package></attributes></class><class><name>LDIFRecord</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dn content </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-Util</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.LDIFRecord</class-id><body>Instances represent LDIF records in an LDIF file, or in LDIF data.  A record can contain a list of attributes which describe an entry, or a list of modifications which describe the changes that need to be made to an entry.  Each record has a distinguished name (dn).Instance Variables:dn			&lt;String&gt;			distinguished name of the entry associated with this recordcontent		&lt;LDIFContent&gt;		list of attributes describing the entry, or list of modifications to an entry</body></comment><class><name>JDAPFilterPresent</name><environment>Net</environment><super>Net.JDAPFilter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-Client</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.JDAPFilterPresent</class-id><body>Implements the filter 'present'.Instance Variables:	mType	&lt;String&gt;	string representation of attribute type</body></comment><class><name>LDAPDN</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.LDAPDN</class-id><body>This class essentially organizes a set of utility class side methods useful for working with LDAP Distinguished Names.</body></comment><class><name>JDAPModifyRequest</name><environment>Net</environment><super>Net.JDAPBaseDNRequest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mMods </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-Client-Opers</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.JDAPModifyRequest</class-id><body>Implements a bind request, sent to an LDAP server.ModifyRequest ::= [APPLICATION 16] SEQUENCE {						object LDAPDN,						modification SEQUENCE OF SEQUENCE {							operation ENUMERATED {								add (0),								delete (1),								replace (2)							},							modification SEQUENCE {								type AttributeType,								values SET OF AttributeValue							}						}					}Instance Variables:	mMods	&lt;Collection of LDAPModification&gt;	modification objects to be applied to entry specified by DN</body></comment><class><name>JDAPMessage</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mMsgId mProtocolOp mControls </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-Client</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.JDAPMessage</class-id><body>Represents the LDAPMessage in RFC 1777.  The message is the entity that got transferred back and forth between the server and the client interface.  Each message has a protocol operation.  The protocol operation indicates whether the message is a request or a response, and which type.LDAPMessage ::= SEQUENCE {						messageID MessageID,						protocolOp CHOICE {							bindRequest BindRequest,							...						}						controls [0] Controls OPTIONAL					}Instance Variables:	mControls		&lt;Collection of LDAPControls&gt;	LDAPv3 addition to protocol	mMsgId			&lt;Integer&gt;						unique message identifier	mProtocolOp	&lt;JDAPProtocolOp&gt;				essentially a BERTag (integer) identifying the operation associated with														the message.  See class JDAPProtocolOp class variable														OperationTypes</body></comment><class><name>JDAPModifyRdnResponse</name><environment>Net</environment><super>Net.JDAPResult</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-Client-Opers</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.JDAPModifyRdnResponse</class-id><body>Implements a compare request, sent from an LDAP server.ModifyRDNResponse ::= [APPLICATION 13] LDAPResult</body></comment><class><name>JDAPBindResponse</name><environment>Net</environment><super>Net.JDAPResult</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mCredentials </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-Client-Opers</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.JDAPBindResponse</class-id><body>Represents the response from the LDAP server to a JDAPBindRequest message.BindResponse ::= [APPLICATION 1]	LDAPResultNote that the LDAPv3 Bind Response is structured sa follows:BindResponse ::= [APPLICATION 1] SEQUENCE {					COMPONENTS OF LDAPResult,					serverCreds [7] SaslCredentials OPTIONAL				   }See RFC 1777Instance Variables:	mCredentials	&lt;String&gt;	Sasl credentials</body></comment><class><name>BERInteger</name><environment>Net</environment><super>Net.BERIntegral</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-BER</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.BERInteger</class-id><body>Class for Integer objects.Encoding Rule:	Primitive Definite length.	tag = 0x02	length = (short or long form)	one or more contents octets hold integer	value in two's complementExample 1: (zero)	02 01 00Example 2: (1)	02 01 01Example 3: (Integer - 300, short form)	02 02 01 2CExample 4: (Integer - 300, long form)	02 84 00 00 01 2CSee CCITT X.209</body></comment><class><name>LDAPError</name><environment>Core</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>LDAP</package></attributes></class><class><name>LDAPSearchListener</name><environment>Net</environment><super>Net.LDAPResponseListener</super><private>false</private><indexed-type>none</indexed-type><inst-vars>searchResults mKey mConstraints resultSemaphore lock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.LDAPSearchListener</class-id><body>Used in particular for LDAP search operations, all other operations use the generic LDAPResponseListener object.  Search results are captured until a response is received, which indicates that all search results have been returned from the server.Instance Variables:	mConstraints	&lt;LDAPSearchConstraints&gt;	The constraints that apply to this search operation.	mKey			&lt;Integer&gt;					Used for caching support.	searchResults	&lt;OrderedCollection&gt;			The results of the search.	lock			&lt;RecursionLock&gt;			Used by LDAPConnection for multithreaded processing</body></comment><class><name>LDAPSearchConstraints</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>timeLimit deref maxRes referrals batch mRebindProc mHopLimit mClientControls mServerControls mMaxBacklog </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.LDAPSearchConstraints</class-id><body>Represents a set of search preferences.  These preferences for a particular search can be set by creating an instance, setting the preference values, and passing the instance to the LDAPConnection search method.Instance Variables:	batch				&lt;Integer&gt;		Number of results to return at a time (1 by default)	deref				&lt;Integer&gt;		Indicates when alias directory entries should be dereferenced.										Valid values from LDAPv2 class constants protocol methods.	maxRes			&lt;Integer&gt;		The maximum number of search results to return (1000 by default).	mClientControls		&lt;Collection of 						LDAPControl&gt;	Client controls for LDAP operations.	mHopLimit			&lt;Integer&gt;		The maximum number of hops to follow during a referral.  Default is 10).	mMaxBacklog		&lt;Integer&gt;		The maximum number of unread entries any search listener can have before										reading from the server is stopped.	mRebindProc		&lt;LDAPRebind&gt;	Specifies the object that provides the method for getting authentication										authentication information if authentication must be done for other 										servers during referrals.  Default is nil.	mServerControls		&lt;Collection of 						LDAPControl&gt;	Server controls for LDAP operations.	referrals				&lt;Boolean&gt;		True if referrals are to be followed.  If true, a valid value must be assigned to										the mRebindProc instance variable.	timeLimit			&lt;Integer&gt;		The maximum number of milliseconds to wait for any operation under these										search constraints.</body></comment><class><name>LDIFDeleteContent</name><environment>Net</environment><super>Net.LDIFContent</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-Util</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.LDIFDeleteContent</class-id><body>Represents the content of an LDIF record that specifies deletion of an entry.  An instance of this class can be obtained from an LDIFRecord object using the getContent method.</body></comment><class><name>JDAPUnbindRequest</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-Client-Opers</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.JDAPUnbindRequest</class-id><body>Implements the unbind request, sent to the LDAP server.UnbindRequest ::= [APPLICATION 2] NULL</body></comment><class><name>BERObjectId</name><environment>Net</environment><super>Net.BERElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mValue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-BER</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.BERObjectId</class-id><body>Class for the Object ID object type.See CCITT X.209</body></comment><class><name>BEROctetString</name><environment>Net</environment><super>Net.BERElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mValue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-BER</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.BEROctetString</class-id><body>For the OctetString type.See CCITT X.209</body></comment><class><name>BERChoice</name><environment>Net</environment><super>Net.BERAny</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-BER</category><attributes><package>LDAP</package></attributes></class><class><name>LDAPAttributeSchema</name><environment>Net</environment><super>Net.LDAPSchemaElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>syntax single </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.LDAPAttributeSchema</class-id><body>The definition of an attribute type in the schema.  See http://ds.internic.net/rfc/rfc2252.txt (RFC 2252, Lightweight Directory Access Protocol (v3) Attribute Syntax Definitions).  According to the RFC, the description of an attribute type can include the following information:an OID identifying the attribute typea name identifying the attribute typea description of the attribute typethe name of the parent attribute typethe syntax used by the attribute (for example, cis (case ignoring string) vs. int)	Syntax symbol meanings:		cis = Case Ignoring String (case is ignored for comparison)		ces = Case Exact String (case is taken into account in comparison)		telephone = Like cis, but allows parentheses and hyphens and ignores them in comparisons		dn = Distinguished name string		integer = a string containing only digits		binary = raw binary dataan indication of whether or not the attribute type is single or multi-valued.When an LDAPAttributeSchema is instantiated, you can specify the values of these attributes via the instance creation methods or by using the AttributeTypeDescription format specified in RFC 2252.  Note: When an LDAP client searches an LDAP server for the schema, the server returns schema information as an object with attribute values in this format.Instance variables:	syntax				&lt;String&gt;			Object identifier for the schema attribute type.											See LDAPSchemaElement class method typeForOid: for value symbols.											See above for symbol meanings.	single				&lt;Boolean&gt;			True if single valued, false if multi-valued</body></comment><class><name>LDAPMatchingRuleSchema</name><environment>Net</environment><super>Net.LDAPAttributeSchema</super><private>false</private><indexed-type>none</indexed-type><inst-vars>attributes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.LDAPMatchingRuleSchema</class-id><body>Represents a matching rule definition in a directory.  See RFC 2252, Lightweight Directory Access Protocol (v3): Attribute Syntax Definitions.  This reference indicates the types of information that need to be specified in the definition of a matching rule.  According to the RFC, the description of a matching rule can include the following information: an OID identifying the object classa name identifying the object classa description of the object classthe syntax of the matching ruleThe LDAPMatchingRuleSchema class also specifies the matching rule "use description", which describes the attributes which can be used with the matching rule.When an LDAPObjectClassSchema is instantiated, you can specify the values of these attributes via the instance creation methods or by using the MatchingRuleDescription and MatchingRuleUseDescription formats specified in RFC 2252.  Note: When an LDAP client searches an LDAP server for the schema, the server returns schema information as objects with attribute values in these formats.Instance Variables:	attributes	&lt;OrderedCollection&gt;		collection of object ids (oids) of attributes which can be used in matching rule</body></comment><class><name>LDAPEntry</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dn attrSet </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.LDAPEntry</class-id><body>Represents an entry in an LDAP directory.	dn			&lt;String&gt;				Unique distinguished name of the entry	attrSet		&lt;LDAPAttributeSet&gt;		Group of attributes associated with this entry</body></comment><class><name>LDAPEntryChangeControl</name><environment>Net</environment><super>Net.LDAPControl</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mChangeNumber mChangeTypes mPreviousDN </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-Controls</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.LDAPEntryChangeControl</class-id><body>Represents an LDAPv3 server control that specifies information about a change to an entry in the directory.  The OID for this control is given by class method entryChanged.  this control is needed in conjunction with a persistent search control object.To use persistent searching for change notification, you create a persistent search control that specifies the types of changes that are to be tracked.  When an entry is changed, the server sends that entry back to the client and may include an entry change notification control that specifies additional information about the change.Typically, the getResponseControls method of the LDAPConnection object and the parseResponse method of the LDAPPersistentSearchControl object are used to get an LDAPEntryChangeControl object.Once the LDAPEntryChangeControl object is retrieved, the following additional information about the change is available:a) The type of change made (add, modify, delete, or modify DN)b) The change number identifying the record of the change in the change log (if the server supports change logs)c) If the entry was renamed, the old DN of the entry.Instance Variables:	mChangeNumber	&lt;Integer&gt;	The identifying number of the change in the change log.	mChangeTypes		&lt;Integer&gt;	Identifies the type of change.  See class constants protocol for 									class LDAPPersistSearchControl for code meanings.	mPreviousDN		&lt;String&gt;	If the change is a DN rename, the old DN of the entry.</body></comment><class><name>JDAPProtocolOp</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-Client-Opers</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.JDAPProtocolOp</class-id><body>In Java version of the LDAP SDK, represents the interface implemented by the various protocol operations.  Included here to keep the OperationTypes dictionary.Class Variables:	OperationTypes	&lt;Dictionary&gt;	key is Integer representing protocol operation type, value is String naming operation</body></comment><class><name>JDAPDelRequest</name><environment>Net</environment><super>Net.JDAPBaseDNRequest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-Client-Opers</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.JDAPDelRequest</class-id><body>Implements a delete request, sent to an LDAP server.DelRequest ::= [APPLICATION 10]  LDAPDN</body></comment><class><name>LDAPSchema</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>objectClasses attributes matchingRules entryName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.LDAPSchema</class-id><body>Represents the schema of an LDAPv3 server.  The fetchSchema method can be used to retrieve the schema used by a server (the server must support LDAPv3 and the capability to retrieve the schema over the LDAP protocol).After the schema is retrieved, this object can extract the object classes, attribute types, and matching rule descriptions defined in the schema.  New object classes, attribute types, and matching rules can also be added to the schema.To remove any object classes, attribute types, or matching rules that have been added, use the remove methods of the LDAPObjectClassSchema, LDAPAttributeSchema, and LDAPMatchingRuleSchema classes.Instance Variables:	attributes		&lt;Dictionary&gt;	Keys are attribute names, values are attribute objects.	entryName		&lt;String&gt;		DN of the schema object in the directory (Example: cn=schema).	matchingRules	&lt;Dictionary&gt;	Keys are matching rule names, values are matching rule objects.	objectClasses	&lt;Dictionary&gt;	Keys are object class names, values are object class objects.</body></comment><class><name>BERReal</name><environment>Net</environment><super>Net.BERElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mValue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-BER</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.BERReal</class-id><body>This class is not fully implemented.Class for representation of real numbers.Encoding Rule:	tag = 0x09See CCITT X.209</body></comment><class><name>LDIF</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mReader mSource mDecoder mDone mCurrEntryDone </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-Util</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.LDIF</class-id><body>LDAP Data Interchange Format (LDIF) is a file format used to import and export directory data from an LDAP server and to describe a set of changes to be applied to data in a directory.  This format is described in the Internet draft located at ftp://ftp.ietf.org/internet-drafts/draft-good-ldap-ldif-00.txt, The LDAP Data Interchange Format (LDIF) - Technical Specification.This class implements an LDIF file parser.  You can construct an object of this class to parse data in LDIF format and manipulate the data as individual LDIFRecord objects.</body></comment><class><name>LDAPVirtualListResponse</name><environment>Net</environment><super>Net.LDAPControl</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mFirstPosition mContentCount mResultCode </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-Controls</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.LDAPVirtualListResponse</class-id><body>Represents control data for returning paged results from a search.Instance Variables:	mContentCount	&lt;Integer&gt;	The size of the virtual result set.	mFirstPosition	&lt;Integer&gt;	The index of the first entry returned.	mResultCode	&lt;Integer&gt;	The result code from the operation.  See LDAPException for meanings.</body></comment><class><name>BERSequence</name><environment>Net</environment><super>Net.BERConstruct</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-BER</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.BERSequence</class-id><body>Class for BERSequence objects.  A sequence object contains a collection of other BER elements.Its implementation is essentially identical to the BERSet class implementation.See CCITT X.209</body></comment><class><name>JDAPExtendedRequest</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mOid mValue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-Client-Opers</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.JDAPExtendedRequest</class-id><body>Implements an extended request, sent to an LDAP server.  This is a v3 request.ExtendedRequest ::= [APPLICATION 23] SEQUENCE {					requestName [0] LDAPOID,					requestValue [1] OCTET STRING OPTIONAL,					}See RFC 1777Instance Variables:	mOid		&lt;String&gt;		object identifier of request	mValue		&lt;ByteArray&gt;	request value</body></comment><class><name>JDAPBindRequest</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mVersion mName mPassword mMechanism mCredentials </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-Client-Opers</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.JDAPBindRequest</class-id><body>Implements a bind request, sent to an LDAP server.BindRequest ::= [APPLICATION 0] SEQUENCE {					version INTEGER(1..127),					name LDAPDN,					authentication CHOICE {						simple [0]	OCTET STRING,						krbv42ldap [1] OCTET STRING,						krbv42dsa [2] OCTET STRING					}				}Note that LDAPv3 bind requests are structured as follows:BindRequest ::= [APPLICATION 0] SEQUENCE {					version INTEGER(1..127),					name LDAPDN,					authentication AuthenticationChoice				}AuthenticationChoice ::= CHOICE {						simple [0]	OCTET STRING,							-- 1 and 2 reserved						sasl [3] SaslCredentials				}SaslCredentials ::= SEQUENCE {						mechanism LDAPString,						credentials OCTET STRING				}Instance Variables:	mCredentials	&lt;ByteArray&gt;	binding credentials for sasl binding method	mMechanism	&lt;String&gt;		sasl binding mechanism	mName			&lt;String&gt;		distinguished name	mPassword		&lt;String&gt;		password	mVersion		&lt;Integer&gt;		version number</body></comment><class><name>LDAPPersistSearchControl</name><environment>Net</environment><super>Net.LDAPControl</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mChangeTypes mChangesOnly mReturnECs </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-Controls</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.LDAPPersistSearchControl</class-id><body>Represents an LDAPv3 server control that specifies a persistent search (an ongoing search operation), which allows an LDAP client to get notification of changes to the directory.  This control can be used in conjunction with an entry change notification control, represented by an LDAPEntryChangeControl object.To use persistent searching for change notification, you create a persistent search control that specifies the types of changes that you want to track.  You include the control in a search request as part of the search constraints.  If an entry in the directory is changed, the server determines if the entry matches the search criteria in your request and if the change is the type of change that you are tracking.  If both of these are true, the server sends the entry to your client.The server can also include an entry change notification control with the entry.  This control contains additional information about the change made to the entry.  See class LDAPEntryChangeControl.When constructing an LDAPPersistSearchControl object, the following information can be specified:a) The type of change to be tracked (added, modified, deleted, or renamed entries)b) A preference indicating whether or not the server is to return all entries that initially matched the search criteria (rather than only the entries that change)c) A preference indicating whether or not you want entry change notification controls included with every entry returned by the server.Instance Variables:	mChangesOnly	&lt;Boolean&gt;	False if all entries which meet the search conditions are initially returned by the server.	mChangeTypes	&lt;Integer&gt;	Indicates which types of changes are to be tracked.  See class side constants protocol.	mReturnECs	&lt;Boolean&gt;	True if entry change control entries are to be returned with each search result.</body></comment><class><name>JDAPModifyRdnRequest</name><environment>Net</environment><super>Net.JDAPBaseDNRequest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mOldDN mNewRDN mDeleteOldDN mNewSuperior </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-Client-Opers</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.JDAPModifyRdnRequest</class-id><body>Implements the modify relative domain name request.  Instances are sent to the LDAP server.ModifyRDNRequest ::= [APPLICATION 12] SEQUENCE {						entry LDAPDN,						newrdn Relative LDAPDN						deleteoldrdn BOOLEAN						}Note that LDAPv3 renames this object to JDAPModifyDNRequest and has the following definition:ModifyDNRequest ::=  [APPLICATION 12] SEQUENCE {						entry LDAPDN,						newrdn Relative LDAPDN						newSuperior [0] LDAPDN OPTIONAL						deleteoldrdn BOOLEAN						}Instance Variables:	mDeleteOldDN		&lt;Boolean&gt;	if true, then old domain name should be removed from directory	mNewRDN			&lt;String&gt;	the new relative domain name entry should have (relative to new superior DN)	mNewSuperior		&lt;String&gt;	the new domain name above the new relative domain name in the directory tree	mOldDN			&lt;String&gt;	the old domain name for the entry</body></comment><class><name>RelativeDistinguishedName</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mType mValue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-Util</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.RelativeDistinguishedName</class-id><body>Represents a component of a DistinguishedName.  These components are referred to as RelativeDistinguishedNames or RDNs.  For example, the DN "uid=bjensen, ou=People, o=Arius.com" has three RDN components: "uid=bjensen", "ou=People", and "o=Arius.com".Each DN component consists of an attribute type and value pair.  For example, in "o=Arius.com", the attribute type is "o" (an abbreviation for "organization") and the attribute value is "Arius.com".Objects of this class can be used to add components to an existing DistinguishedName object.</body></comment><class><name>LDAPAttributeSet</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>attrs recursionLock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.LDAPAttributeSet</class-id><body>Represents a set of attributes, for example the set of attributes in a LDAP entry.	attrs 			&lt;Dictionary&gt;		key is attribute name, value is attribute</body></comment><class><name>LDIFAttributeContent</name><environment>Net</environment><super>Net.LDIFContent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mAttrs </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-Util</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.LDIFAttributeContent</class-id><body>Represents the content of an LDIF record that specifies an entry and its attributes.  An instance of this class can be obtained from an LDIFRecord object using the getContent method.</body></comment><class><name>LDAPSortKey</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mKey mReverse mMatchRule </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.LDAPSortKey</class-id><body>Represents sorting instructions for a particular attribute.  Instance Variables:	mKey			&lt;String&gt;	The attribute to sort by (for example: cn)	mMatchRule	&lt;String&gt;	Object identifier (oid) of the matching rule to use for sorting.  May be nil.	mReverse		&lt;Boolean&gt;	True if sorting is to be in descending order.</body></comment><class><name>JDAPSearchRequest</name><environment>Net</environment><super>Net.JDAPBaseDNRequest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mScope mDeref mSizeLimit mTimeLimit mAttrsOnly mFilter mAttrs </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LDAP-Client-Opers</category><attributes><package>LDAP</package></attributes></class><comment><class-id>Net.JDAPSearchRequest</class-id><body>Implements the search request, which is sent to an LDAP server.SearchRequest ::= [APPLICATION 3] SEQUENCE {						baseObject LDAPDN,						scope ENUMERATED {							baseObject (0),							singleLevel (1),							wholeSubtree (2)						},						derefAliases ENUMERATED {							neverDerefAliases (0),							derefInSearching (1),							derefFindingBaseObj (2),							derefAlways (3)						},						sizeLimit INTEGER,						timeLimite INTEGER,						attrsOnly BOOLEAN,						filter Filter,						attributes SEQUENCE OF AttributeType					}Instance Variables:	mAttrs			&lt;Collection of String&gt;	list of attribute types to answer 	mAttrsOnly		&lt;Boolean&gt;				should answer attribute types only, not attribute values	mDeref			&lt;Integer&gt;				how alias objects should be handled	mFilter			&lt;String&gt;				string filter based on RFC 1558	mScope		&lt;Integer&gt;				scope of the search	mSizeLimit		&lt;Integer&gt;				maximum number of entries to be answered	mTimeLimit		&lt;Integer&gt;				maximum time allowed for search</body></comment><shared-variable><name>ThreadTableLock</name><environment>Net.LDAPConnection</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>LDAP</package></attributes></shared-variable><shared-variable><name>ThreadConnTable</name><environment>Net.LDAPConnection</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>LDAP</package></attributes></shared-variable><shared-variable><name>ReadConstraints</name><environment>Net.LDAPConnection</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>LDAP</package></attributes></shared-variable><shared-variable><name>ResultCodes</name><environment>Net.JDAPResult</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>LDAP</package></attributes></shared-variable><shared-variable><name>ToCharTable</name><environment>Net.Base64MimeConverter</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>LDAP</package></attributes></shared-variable><shared-variable><name>FromCharTable</name><environment>Net.Base64MimeConverter</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>LDAP</package></attributes></shared-variable><shared-variable><name>LDAPResultCodes</name><environment>Net.LDAPException</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>LDAP</package></attributes></shared-variable><shared-variable><name>MinusInfinity</name><environment>Net.BERReal</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>LDAP</package></attributes></shared-variable><shared-variable><name>PlusInfinity</name><environment>Net.BERReal</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>LDAP</package></attributes></shared-variable><shared-variable><name>AttrOIDs</name><environment>Net.LDAPSchemaElement</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>LDAP</package></attributes></shared-variable><shared-variable><name>AttrTypes</name><environment>Net.LDAPSchemaElement</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>LDAP</package></attributes></shared-variable><shared-variable><name>EscapeKey</name><environment>Net.JDAPFilterOpers</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>LDAP</package></attributes></shared-variable><shared-variable><name>Debug</name><environment>Net.JDAPFilterOpers</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>LDAP</package></attributes></shared-variable><shared-variable><name>BERTypes</name><environment>Net.BERElement</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>LDAP</package></attributes></shared-variable><shared-variable><name>BERTags</name><environment>Net.BERElement</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>LDAP</package></attributes></shared-variable><shared-variable><name>RDNSignals</name><environment>Net.RelativeDistinguishedName</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>LDAP</package></attributes></shared-variable><shared-variable><name>OperationTypes</name><environment>Net.JDAPProtocolOp</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>LDAP</package></attributes></shared-variable><methods><class-id>Net.BERElement</class-id> <category>input-output</category><body package="LDAP">writeOn: outStream	"Sends the BER encoding directly on output stream.	Answer the bytes written to stream."	^ self subclassResponsibility</body></methods><methods><class-id>Net.BERElement</class-id> <category>initialize-release</category><body package="LDAP">initialize	^ self</body></methods><methods><class-id>Net.BERElement</class-id> <category>accessing</category><body package="LDAP">getType	"Answer the element type."		^ self subclassResponsibility</body></methods><methods><class-id>Net.BERElement</class-id> <category>printing</category><body package="LDAP">byteToHexString: aByte	"Converts byte to hex string.	Answers hex string."	| tVal |	tVal := aByte.	aByte &lt; 0		ifTrue: [tVal := (aByte bitAnd: 127) + 128].	^ tVal printStringRadix: 16</body><body package="LDAP">toString	"Answer the string representation"	^ self subclassResponsibility</body></methods><methods><class-id>Net.BERElement class</class-id> <category>constants</category><body package="LDAP">any	"Internal non-transmitted tag"	^  -3</body><body package="LDAP">choice	"Internal non-transmitted tag"	^  -2</body><body package="LDAP">tag	"Internal non-transmitted tag"	^  -1</body><body package="LDAP">tag: aString	^ BERTags		at: aString		ifAbsent: [self error: 'Unknown BER Tag ', aString]</body><body package="LDAP">type: aString	^ BERTypes 		at: aString		ifAbsent: [self error: 'Unknown BER Type ', aString]</body></methods><methods><class-id>Net.BERElement class</class-id> <category>utilities</category><body package="LDAP">readLengthOctetsFrom: inStream bytesRead: anArray	"Decodes length octets from input stream.	anArray is an array of 1 integer, incremented by the number of bytes read from stream.	Answers the length of the contents as encoded, or -1 if indefinite length."	| contentsLength octet bytesRead lowHalf numLengthOctets idx |	bytesRead := anArray at: 1.	contentsLength := 0.	octet := inStream next.	bytesRead := bytesRead + 1.	lowHalf := 128.	(octet = lowHalf)							"Indefinite length"		ifTrue: [contentsLength := -1]		ifFalse: [(octet bitAnd: lowHalf) &gt; 0						"Definite (long form) nbr octets encoded in right 7 bits"					ifTrue: [numLengthOctets := (octet bitAnd: (Integer fromHex: '7F')).						    idx := 0.						    [idx &lt; numLengthOctets]								whileTrue: [									octet := inStream next.									bytesRead := bytesRead + 1.									contentsLength := (contentsLength bitShift: 8) + octet.									idx := idx + 1]]					"Definite (short form) one length octet.  Value encoded in 7 right bits"					ifFalse: [contentsLength := octet]].	anArray at: 1 put: bytesRead.	^ contentsLength</body><body package="LDAP">readTwosComplementFrom: inStream bytesRead: anArray length: theLength	"Reads the two complement representation from the input stream.	 anArray contains 1 integer representing the number of bytes read.	 theLength is the length of the bytes to be read.	 Answers the value of the two complement."	| value negative octet idx bytesRead |	value := 0.	bytesRead := anArray at: 1.	theLength &gt; 0		ifTrue: [negative := false.			    octet := inStream next.			    bytesRead := bytesRead + 1.			    ((octet bitAnd: 128) &gt; 0)		"Left-most bit is 1"					ifTrue: [negative := true].			    idx := 0.			    [idx &lt; theLength]					whileTrue: [						idx &gt; 0							ifTrue: [octet := inStream next.								     bytesRead := bytesRead + 1].						negative							ifTrue: [value := (value bitShift: 8) + ((octet bitXor: 255) bitAnd: 255)]							ifFalse: [value := (value bitShift: 8) + (octet bitAnd: 255)].						idx := idx + 1].				negative						"Convert to two's complement"					ifTrue: [value := (value + 1) negated]].	anArray at: 1 put: bytesRead.	^ value</body><body package="LDAP">readUnsignedBinaryFrom: inStream bytesRead: anArray length: theLength	"Reads the unsigned binary from the input stream.	anArray is an array containing 1 integer representing the number of bytes read from the stream.	theLength is the length of the byte to be read.	Answers the value of the two complement."	| theValue octet idx bytesRead |	theValue := 0.	bytesRead := anArray at: 1.	idx := 0.	[idx &lt; theLength]		whileTrue: [octet := inStream next.				    bytesRead := bytesRead + 1.				    theValue := (theValue bitShift: 8) + octet.				    idx := idx + 1].	anArray at: 1 put: bytesRead.	^ theValue</body><body package="LDAP">sendDefiniteLengthOn: outStream numberOfOctets: nbrOctets	"Writes encoded length of octets (definite length only) onto output stream.	Uses short form whenever possible.	nbrOctets is the value to be encoded into length octets.	Answer the number of bytes written onto the stream"	| bytesWritten numLengthOctets num buffer idx |	bytesWritten := 0.	(nbrOctets &lt;= 127)			"Use short form"		ifTrue: [outStream nextPut: nbrOctets.				bytesWritten := 1]			"Use long form:			Need to determine how many octets are required to encode the length"		ifFalse: [numLengthOctets := 0.				num := nbrOctets.				[num &gt; 0]					whileTrue: [numLengthOctets := numLengthOctets + 1.							    num := num bitShift: -8].				buffer := ByteArray new: (numLengthOctets + 1).				buffer at: 1 put: (128 bitOr: numLengthOctets).				num := nbrOctets.				idx := numLengthOctets.				[idx &gt; 0]					whileTrue: [buffer at: (idx + 1) put: (num bitAnd: 255).							    num := num bitShift: -8.							    idx := idx - 1].				outStream nextPutAll: buffer.				bytesWritten := buffer size].	^ bytesWritten</body></methods><methods><class-id>Net.BERElement class</class-id> <category>signals</category><body package="LDAP">invalidTagSignal</body><body package="LDAP">unsupportedRealEncodingSignal</body></methods><methods><class-id>Net.BERElement class</class-id> <category>class initialization</category><body package="LDAP">initialize	"BERElement initialize"	"See CCITT X.209"	BERTypes := Dictionary new.	BERTypes at: 'Boolean' put: (Integer fromHex: '01').	BERTypes at: 'Integer' put: (Integer fromHex: '02').	BERTypes at: 'BitString' put: (Integer fromHex: '03').	BERTypes at: 'OctetString' put: (Integer fromHex: '04').	BERTypes at: 'Null' put: (Integer fromHex: '05').	BERTypes at: 'ObjectId' put: (Integer fromHex: '06').	BERTypes at: 'Real' put: (Integer fromHex: '09').	BERTypes at: 'Enumerated' put: (Integer fromHex: '0A').	BERTypes at: 'Set' put: (Integer fromHex: '31').	BERTypes at: 'Sequence' put: (Integer fromHex: '30').	BERTypes at: 'NumericString' put: (Integer fromHex: '12').	BERTypes at: 'PrintableString' put: (Integer fromHex: '13').	BERTypes at: 'TeletexString' put: (Integer fromHex: '14')."	BERTypes at: 'VideotexString' put: (Integer fromHex: '15')."	BERTypes at: 'IA5String' put: (Integer fromHex: '16').	BERTypes at: 'UTCTime' put: (Integer fromHex: '17')."	BERTypes at: 'Graphic' put: (Integer fromHex: '19')."	BERTypes at: 'VisibleString' put: (Integer fromHex: '1A')."	BERTypes at: 'GeneralString' put: (Integer fromHex: '1B')."	BERTypes at: 'Tag' put: -1.	BERTypes at: 'Choice' put: -2.	BERTypes at: 'Any' put: -3.	BERTags := Dictionary new.	BERTags at: 'EOC' put: (Integer fromHex: '00').	"End of Construction"	BERTags at: 'Universal' put: (Integer fromHex: '00').	BERTags at: 'Application' put: (Integer fromHex: '40').	BERTags at: 'Context' put: (Integer fromHex: '80').	BERTags at: 'SASLContext' put: (Integer fromHex: 'A0').	BERTags at: 'Private' put: (Integer fromHex: 'C0').	BERTags at: 'Primitive' put: (Integer fromHex: '00').	BERTags at: 'Constructed' put: (Integer fromHex: '20').	BERTags at: 'MRA_Oid' put: (Integer fromHex: '01').	BERTags at: 'MRA_Type' put: (Integer fromHex: '02').	BERTags at: 'MRA_Value' put: (Integer fromHex: '03').	BERTags at: 'MRA_DNAttrs' put: (Integer fromHex: '04').	BERTags at: 'EXOP_Req_Oid' put: (Integer fromHex: '00').	BERTags at: 'EXOP_Req_Value' put: (Integer fromHex: '01').	BERTags at: 'EXOP_Res_Oid' put: (Integer fromHex: '0A').	BERTags at: 'EXOP_Res_Value' put: (Integer fromHex: '0B').	BERTags at: 'SK_Matchrule' put: (Integer fromHex: '00').	BERTags at: 'SK_Reverse' put: (Integer fromHex: '01').	BERTags at: 'SR_Attrtype' put: (Integer fromHex: '00').</body></methods><methods><class-id>Net.BERElement class</class-id> <category>instance creation</category><body package="LDAP">getElementFrom: inStream decoder: aBERTagDecoder bytesRead: anArray	"Answers a BER element from the input stream.	aBERTagDecoder is a decoder for an application specific BER encoding.	anArray is an array containing 1 integer, incremented by the number of bytes read		from the input stream."	| element tag |	element := nil.	tag := inStream next.	anArray at: 1 put: 1.	(tag = (self tag: 'EOC'))			"End of construction"		ifTrue: [inStream next.		"Size byte, always zero for EOC"			    ^ element].	(tag = (self type: 'Boolean'))		ifTrue: [^ BERBoolean newFrom: inStream bytesRead: anArray].	(tag = (self type: 'Integer'))		ifTrue: [^ BERInteger newFrom: inStream bytesRead: anArray].	(tag = (self type: 'BitString'))		ifTrue: [^ self error: 'BERBitStrings are unimplemented'.				"^ BERBitString newFrom: inStream bytesRead: anArray"].	(tag = ((self type: 'BitString') bitOr: (self tag: 'Constructed')))		ifTrue: [^ self error: 'BERBitStrings are unimplemented'.				"^ BERBitString newFrom: inStream decoder: aBERTagDecoder bytesRead: anArray"].	(tag = (self type: 'OctetString'))		ifTrue: [^ BEROctetString newFrom: inStream bytesRead: anArray].	(tag = ((self type: 'OctetString') bitOr: (self tag: 'Constructed')))		ifTrue: [^ BEROctetString newFrom: inStream decoder: aBERTagDecoder bytesRead: anArray].	(tag = (self type: 'Null'))		ifTrue: [^ BERNull newFrom: inStream bytesRead: anArray].	(tag = (self type: 'ObjectId'))		ifTrue: [^ BERObjectId newFrom: inStream bytesRead: anArray].	(tag = (self type: 'Real'))		ifTrue: [self invalidTagSignal raiseWith: tag.			    ^ BERReal newFrom: inStream bytesRead: anArray].	(tag = (self type: 'Enumerated'))		ifTrue: [^ BEREnumerated newFrom: inStream bytesRead: anArray].	(tag = (self type: 'Sequence'))		ifTrue: [^ BERSequence newFrom: inStream decoder: aBERTagDecoder bytesRead: anArray].	(tag = (self type: 'Set'))		ifTrue: [^ BERSet newFrom: inStream decoder: aBERTagDecoder bytesRead: anArray].	(tag = (self type: 'NumericString'))		ifTrue: [^ BERNumericString newFrom: inStream bytesRead: anArray].	(tag = ((self type: 'NumericString') bitOr: (self tag: 'Constructed')))		ifTrue: [^ BERNumericString newFrom: inStream decoder: aBERTagDecoder bytesRead: anArray].	(tag = (self type: 'PrintableString'))		ifTrue: [^ BERPrintableString newFrom: inStream bytesRead: anArray].	(tag = (self type: 'TeletexString'))		ifTrue: [^ BERPrintableString newFrom: inStream bytesRead: anArray].	(tag = (self type: 'IA5String'))		ifTrue: [^ BERPrintableString newFrom: inStream bytesRead: anArray].	(tag = ((self type: 'PrintableString') bitOr: (self tag: 'Constructed')))		ifTrue: [^ BERPrintableString newFrom: inStream decoder: aBERTagDecoder bytesRead: anArray].	(tag = (self type: 'UTCTime'))		ifTrue: [^ BERUTCTime newFrom: inStream bytesRead: anArray].	(tag = ((self type: 'UTCTime') bitOr: (self tag: 'Constructed')))		ifTrue: [^ BERUTCTime newFrom: inStream decoder: aBERTagDecoder bytesRead: anArray].	(tag = (self type: 'VisibleString'))		ifTrue: [^ BERVisibleString newFrom: inStream bytesRead: anArray].	(tag = ((self type: 'VisibleString') bitOr: (self tag: 'Constructed')))		ifTrue: [^ BERVisibleString newFrom: inStream decoder: aBERTagDecoder bytesRead: anArray].	(tag bitAnd: (((self tag: 'Application') bitOr: (self tag: 'Private')) bitOr: (self tag: 'Context'))) &gt; 0		ifTrue: [^ BERTag newFrom: inStream decoder: aBERTagDecoder tag: tag bytesRead: anArray].	LDAPError raiseSignal: tag printString</body><body package="LDAP">new	^ super new initialize</body><body package="LDAP">newForValue: aBoolean	^ self new value: aBoolean; yourself</body></methods><methods><class-id>Net.BERConstruct</class-id> <category>accessing</category><body package="LDAP">addElement: anElement	mElements add: anElement</body><body package="LDAP">elementAt: anInteger	^ mElements at: anInteger</body><body package="LDAP">elements	^ mElements copyWithout: nil</body><body package="LDAP">size	^ self elements size</body></methods><methods><class-id>Net.BERConstruct</class-id> <category>input-output</category><body package="LDAP">writeOn: outStream	| contents contentsStream |	outStream nextPut: self getType.	contents := OrderedCollection new.	contentsStream := WriteStream on: contents.	self elements do: [:anElement | anElement writeOn: contentsStream].	contents := contents copyWithout: nil.	self class sendDefiniteLengthOn: outStream numberOfOctets: contents size.	outStream nextPutAll: contents</body></methods><methods><class-id>Net.BERConstruct</class-id> <category>initialize-release</category><body package="LDAP">initialize	super initialize.	mElements := OrderedCollection new</body></methods><methods><class-id>Net.BERConstruct class</class-id> <category>instance creation</category><body package="LDAP">newFrom: inStream decoder: aBERTagDecoder bytesRead: anArray	"Constructs an octet string element from input stream (for constructed encoding).	anArray is an array of 1 integer representing the number of bytes read from input stream."	| contentsLength componentLength bytesRead element instance continue |	contentsLength := self readLengthOctetsFrom: inStream bytesRead: anArray.	componentLength := Array new: 1.	bytesRead := anArray at: 1.	instance := self new.	(contentsLength = -1)				"Constructed - indefinite length"		ifTrue: [componentLength at: 1 put: 0.			    continue := true.			    [continue]					whileTrue: [			    			element := self getElementFrom: inStream 											decoder: aBERTagDecoder 											bytesRead: componentLength.			   		      element isNil								ifTrue: [continue := false]								ifFalse: [instance addElement: element]].				bytesRead := bytesRead + (componentLength at: 1)]		ifFalse: [bytesRead := bytesRead + contentsLength.			"Constructed - definite length"				[contentsLength &gt; 0]					whileTrue: [						componentLength at: 1 put: 0.						element := self getElementFrom: inStream											decoder: aBERTagDecoder											bytesRead: componentLength.						element isNil							ifFalse: [instance addElement: element].						contentsLength := contentsLength - (componentLength at: 1)]].	anArray at: 1 put: bytesRead.	^ instance</body></methods><methods><class-id>Net.BERSet</class-id> <category>accessing</category><body package="LDAP">getType	^ self class type: 'Set'</body></methods><methods><class-id>Net.BERSet</class-id> <category>printing</category><body package="LDAP">toString	| aString |	aString := self elements					inject: 'Set {'					into: [:newString :nextElement |							newString, nextElement toString, ', '].	^ (aString copyFrom: 1 to: (aString size - 2)), '}'</body></methods><methods><class-id>Net.LDAPEntryComparator</class-id> <category>utilities</category><body package="LDAP">ldapEntry: gEntry isGreaterThan: lEntry	"Answers true if gEntry is greater than lEntry.  Both gEntry and lEntry are instances of LDAPEntry."	^ self subclassResponsibility</body></methods><methods><class-id>Net.LDAPCompareAttrNames</class-id> <category>initialize-release</category><body package="LDAP">initialize	mAttrs := OrderedCollection new.	mAscending := OrderedCollection new.	^ self</body></methods><methods><class-id>Net.LDAPCompareAttrNames</class-id> <category>utilities</category><body package="LDAP">ldapEntry: gEntry isGreaterThan: lEntry	^ self attrGreater: gEntry lesser: lEntry attributeIndex: 1</body></methods><methods><class-id>Net.LDAPCompareAttrNames</class-id> <category>accessing</category><body package="LDAP">addAscending: aBoolean	mAscending add: aBoolean</body><body package="LDAP">addAttribute: aString	mAttrs add: aString</body></methods><methods><class-id>Net.LDAPCompareAttrNames</class-id> <category>private</category><body package="LDAP">attrGreater: gEntry lesser: lEntry attributeIndex: anInt	"Compares a particular attribute in both entries.  If equal, comparison goes on to the next attribute.  Answers true if gEntry is larger than lEntry.  If an entry is missing an attribute, it is considered smaller.  gEntry is considered larger by default."	| gValue lValue aName ascending |	"We have exhausted the attributes we can compare against."	anInt &gt; mAttrs size		ifTrue: [^ true].	aName := mAttrs at: anInt.	ascending := mAscending at: anInt.	lValue := lEntry getAttribute: aName.	lValue isNil		ifFalse: [lValue := lValue getStringValues first].	gValue := gEntry getAttribute: aName.	gValue isNil		ifFalse: [gValue := gValue getStringValues first].	lValue isNil &amp; gValue isNil		ifTrue: [^ self attrGreater: gEntry lesser: lEntry attributeIndex: (anInt + 1)].	lValue isNil		ifTrue: [^ ascending].	gValue isNil		ifTrue: [^ ascending not].	gValue &gt; lValue		ifTrue: [^ ascending].	gValue &lt; lValue		ifTrue: [^ ascending not].	"Values are equal"	^ self attrGreater: gEntry lesser: lEntry attributeIndex: (anInt + 1)</body></methods><methods><class-id>Net.LDAPCompareAttrNames class</class-id> <category>instance creation</category><body package="LDAP">new	^ self basicNew initialize</body><body package="LDAP">newComparingAttribute: aString	"Answers a comparator that compares the string values of a named attribute in LDAP entries, and sorts the entries in ascending order."	| instance |	instance := self new.	instance addAttribute: aString.	instance addAscending: true.	^ instance</body><body package="LDAP">newComparingAttribute: aString ascending: aBoolean	"Answers a comparator that compares the string values of a named attribute in LDAP entries, and sorts the entries in ascending order if aBoolean is true, descending otherwise."	| instance |	instance := self new.	instance addAttribute: aString.	instance addAscending: aBoolean.	^ instance</body><body package="LDAP">newComparingAttributes: aStringCollect	"Answers a comparator that compares the string values in a collection of named attributes in LDAP entries, and sorts the entries in ascending order.  The order of the attribute names in aStringCollect are significant.  The first attribute name in aStringCollect is applied first.  If that attribute value is the same for both LDAPEntries being compared, comparison goes on to the next named attribute, and so on."	| instance |	instance := self new.	aStringCollect do: [:each |		instance addAttribute: each.		instance addAscending: true].	^ instance</body><body package="LDAP">newComparingAttributes: aStringCollect ascendings: aBooleanCollect	"Answers a comparator that compares the string values in a collection of named attributes in LDAP entries, and sorts the entries in ascending order.  The order of the attribute names in aStringCollect are significant.  The first attribute name in aStringCollect is applied first.  If that attribute value is the same for both LDAPEntries being compared, comparison goes on to the next named attribute, and so on.  aBooleanCollect indicates whether the attribute comparison is to be made in ascending order for the corresponding attribute name in aStringCollect."	"For example, if aStringCollect := #('roomNumber' 'cn') and aBooleanCollect := #(false true), the LDAPEntries will be compared first by roomNumber.  Since the corresponding element in aBooleanCollect is false, the entries will be compared so that the smallest roomNumber string value appears first.  If the attribute values for roomNumber are equal, comparison next goes to the cn (common name) attribute values.  In this case, the corresponding value in aBooleanCollect is true, so the entries will appear in ascending order."	| instance |	instance := self new.	1 to: aStringCollect size do: [:idx |		instance addAttribute: (aStringCollect at: idx).		instance addAscending: (aBooleanCollect at: idx)].	^ instance</body></methods><methods><class-id>Net.LDAPModification</class-id> <category>accessing</category><body package="LDAP">attribute	^ attribute</body><body package="LDAP">attribute: anLDAPAttribute	^ attribute := anLDAPAttribute</body><body package="LDAP">getOp	^ self operation</body><body package="LDAP">operation	^ operation</body><body package="LDAP">operation: anInteger	operation := anInteger</body></methods><methods><class-id>Net.LDAPModification</class-id> <category>initialize-release</category><body package="LDAP">initialize	operation := self class addOperation.	attribute := LDAPAttribute new.	^ self</body></methods><methods><class-id>Net.LDAPModification</class-id> <category>encoding</category><body package="LDAP">getBERElement	"Answers the BER (Basic Encoding Rules) representation of the modification object"	| seq |	seq := BERSequence new.	seq addElement: (BEREnumerated newForValue: operation).	seq addElement: attribute getBERElement.	^ seq</body></methods><methods><class-id>Net.LDAPModification</class-id> <category>printing</category><body package="LDAP">toString	"Answers the string representation of the current modification.  For example:	LDAPModification: REPLACE, LDAPAttribute {type='mail', values='babs@ace.com'}	LDAPModification: ADD, LDAPAttribute {type='description', values='This entry was modified by VW' "	| outStream stringArray |	outStream := WriteStream on: String new.	outStream nextPutAll: (self class name, ': ').	(operation &lt; 0) | (operation &gt; 2)		ifTrue: [outStream nextPutAll: 'INVALID OP, ']		ifFalse: [stringArray := #('ADD' 'DELETE' 'REPLACE').				outStream nextPutAll: (stringArray at: operation + 1).				outStream nextPutAll: ', '].	outStream nextPutAll: attribute toString.	^ outStream contents</body></methods><methods><class-id>Net.LDAPModification class</class-id> <category>instance creation</category><body package="LDAP">newWithOperation: anInteger attribute: anLDAPAttribute	| anInstance |	anInstance := self basicNew initialize.	anInstance operation: anInteger.	anInstance attribute: anLDAPAttribute.	^ anInstance</body></methods><methods><class-id>Net.LDAPModification class</class-id> <category>constants</category><body package="LDAP">addOperation	"Operation type for adding a value to an attribute"	^ 0</body><body package="LDAP">deleteOperation	"Operation type for removing a value from an attribute"	^ 1</body><body package="LDAP">replaceOperation	"Operation type for replacing the existing value of an attribute with a new value"	^ 2</body></methods><methods><class-id>Net.LDAPv2 class</class-id> <category>constants-defaults</category><body package="LDAP">defaultPort	^ 389</body></methods><methods><class-id>Net.LDAPv2 class</class-id> <category>constants-deref</category><body package="LDAP">derefAlways	"Aliases are always dereferenced."	^ 3</body><body package="LDAP">derefFinding	"Aliases are dereferenced when finding the starting entry, but not when searching the entries beneath the starting point of the search."	^ 2</body><body package="LDAP">derefNever	"Aliases are never dereferenced."	^ 0</body><body package="LDAP">derefSearching	"Aliases are dereferenced when searching the entries beneath the starting point of the search, but not when finding the starting entry."	^ 1</body></methods><methods><class-id>Net.LDAPv2 class</class-id> <category>constants-options</category><body package="LDAP">batchSize	^ 20</body><body package="LDAP">deref	^ 2</body><body package="LDAP">protocolVersion	^ 17</body><body package="LDAP">referrals	^ 8</body><body package="LDAP">referralsHopLimit	^ 10</body><body package="LDAP">referralsRebindProc	^ 9</body><body package="LDAP">sizeLimit	^ 3</body><body package="LDAP">timeLimit	^ 4</body></methods><methods><class-id>Net.LDAPv2 class</class-id> <category>constants-scope</category><body package="LDAP">scopeBase	"Search includes only the base DN"	^ 0</body><body package="LDAP">scopeOne	"Search includes only one level below the DN"	^ 1</body><body package="LDAP">scopeSub	"Search includes the base DN and all entries at all levels beneath that base"	^ 2</body></methods><methods><class-id>Net.LDAPv3 class</class-id> <category>constants-attrtypes</category><body package="LDAP">allUserAttrs	"Attribute type that can be specied in the search if all attributes are to be included for entries found by the search"	^ '*'</body><body package="LDAP">noAttrs	"Attribute type that can be specied in the search if no attributes are to be included for entries found by the search"	^ '1.1'</body></methods><methods><class-id>Net.LDAPv3 class</class-id> <category>constants-options</category><body package="LDAP">clientControls	^ 11</body><body package="LDAP">serverControls	^ 12</body></methods><methods><class-id>Net.LDAPAttribute</class-id> <category>accessing</category><body package="LDAP">addValue: aValue	values add: aValue</body><body package="LDAP">getBaseName	"Extracts the subtypes from the attribute name of this object.  See class method getSubtypes:"	^ self class getBaseName: self name</body><body package="LDAP">getByteValues	| valueCopy |	valueCopy := OrderedCollection new: values size.	recursionLock critical: [		(values copyWithout: nil) do: [:aValue |			(aValue isKindOf: String)				ifTrue: [valueCopy add: (aValue asByteArrayEncoding: #UTF_8)]				ifFalse: [valueCopy add: aValue copy]]].	^ ReadStream on: valueCopy</body><body package="LDAP">getLangSubtype	"Answers the language subtype from the attribute name of this object, if any.  Language subtypes begin with the string 'lang-'."	^ self getSubtypes 		detect: [:aString | aString match: 'lang-*']		ifNone: [nil]</body><body package="LDAP">getName	^ self name</body><body package="LDAP">getStringValues	| valueCopy |	valueCopy := OrderedCollection new: values size.	recursionLock critical: [		(values copyWithout: nil) do: [:aValue |			(aValue isKindOf: String)				ifTrue: [valueCopy add: aValue]				ifFalse: [valueCopy add: (aValue asStringEncoding: #UTF_8)]]].	^ ReadStream on: valueCopy</body><body package="LDAP">getSubtypes	"Extracts the subtypes from the attribute name of this object.  See class method getSubtypes:"	^ self class getSubtypes: self name</body><body package="LDAP">name	^ name</body><body package="LDAP">name: aString	name := aString asLowercase</body><body package="LDAP">removeValue: aValue	values remove: aValue		ifAbsent: []</body><body package="LDAP">size	^ values size</body><body package="LDAP">stringValues	| valueCopy |	valueCopy := OrderedCollection new: values size.	recursionLock critical: [		(values copyWithout: nil) do: [:aValue |			(aValue isKindOf: String)				ifTrue: [valueCopy add: aValue]				ifFalse: [valueCopy add: (aValue asStringEncoding: #UTF_8)]]].	^valueCopy</body><body package="LDAP">values	^ values</body></methods><methods><class-id>Net.LDAPAttribute</class-id> <category>encoding</category><body package="LDAP">getBERElement	"Answers the Basic Encoding Rules representation of myself."	| seq set |	seq := BERSequence new.	seq addElement: (BEROctetString newFromString: self name).	set := BERSet new.	values do: [:aValue |		(aValue isKindOf: String)			ifTrue: [set addElement: (BEROctetString newFromString: aValue)].		(aValue isKindOf: ByteArray)			ifTrue: [set addElement: (BEROctetString newFromByteArray: aValue)]].	seq addElement: set.	^ seq</body></methods><methods><class-id>Net.LDAPAttribute</class-id> <category>testing</category><body package="LDAP">hasSubtype: aString		"Answers whether the name of this attribute has the subtype identified by aString.	For example, if the subtype is 'lang-en', and the attribute name is 'cn;lang-en', this	method answers true."	^ self getSubtypes includes: aString asLowercase</body><body package="LDAP">hasSubtypes: aCollection		"Answers whether the name of this attribute includes all subtypes listed in aCollection.	See method hasSubtype:"	aCollection do: [:aString |		(self hasSubtype: aString) ifFalse: [^ false]].	^ true</body></methods><methods><class-id>Net.LDAPAttribute</class-id> <category>copying</category><body package="LDAP">asSingleValueAttributes	^self values collect: [ :v | | newAttr | newAttr := self class new. newAttr name: self name. newAttr addValue: v. newAttr ]</body><body package="LDAP">copy	^ self class newFromAttribute: self</body></methods><methods><class-id>Net.LDAPAttribute</class-id> <category>initialize-release</category><body package="LDAP">initialize	name := String new.	values := OrderedCollection new.	recursionLock := RecursionLock new.</body></methods><methods><class-id>Net.LDAPAttribute</class-id> <category>utilities</category><body package="LDAP">getParamString	"Answers the string representation of attribute parameters"	| s fVals tVal  outStream |	s := String new.	fVals := self values copyWithout: nil.	1 to: fVals size do: [:idx |		idx = 1			ifFalse: [s := s, ','].		tVal := fVals at: idx.		(tVal isKindOf: String)			ifTrue: [s := s, tVal].		(tVal isKindOf: ByteArray)			ifTrue: [s := s, (tVal  asStringEncoding: #UTF_8)]].	outStream := WriteStream on: String new.	outStream nextPutAll: '{type='.	outStream nextPut: $'.	outStream nextPutAll: self name.	outStream nextPut: $'.	outStream nextPutAll: ', values='.	outStream nextPut: $'.	outStream nextPutAll: s.	outStream nextPut: $'.	outStream nextPutAll: '}'.	^ outStream contents</body></methods><methods><class-id>Net.LDAPAttribute</class-id> <category>printing</category><body package="LDAP">toString	^ 'LDAPAttribute ', self getParamString</body></methods><methods><class-id>Net.LDAPAttribute class</class-id> <category>utilities</category><body package="LDAP">getBaseName: anAttributeName	"Extracts the base name from the specified attribute name.  For example, if the attribute name is 'cn;lang-ja;phonetic', this method answers 'cn'."	| theCollect |	theCollect := anAttributeName tokensBasedOn: $;.	theCollect size = 0		ifTrue: [^ String new].	^ theCollect first</body><body package="LDAP">getSubtypes: anAttributeName	"Extracts the subtypes from the specified attribute name.  For example, if the attribute name is 'cn;lang-ja;phonetic', this method answers a collection containing 'lang-ja' and 'phonetic'."	| theCollect |	theCollect := anAttributeName tokensBasedOn: $;.	theCollect size &gt; 1		ifFalse: [^ OrderedCollection new].	^ theCollect copyFrom: 2 to: (theCollect size)</body></methods><methods><class-id>Net.LDAPAttribute class</class-id> <category>instance creation</category><body package="LDAP">new	^ self basicNew initialize</body><body package="LDAP">newFromAttribute: anLDAPAttribute	| anInstance |	anInstance := self new.	anInstance name: anLDAPAttribute name.	anLDAPAttribute values do: [:aValue |			anInstance addValue: aValue copy].	^ anInstance</body><body package="LDAP">newFromBERElement: aBERSequence	"Answer an attribute constructed form a Basic Encoding Rules sequence element."	| anInstance type set |	anInstance := self new.	type := aBERSequence elementAt: 1.	anInstance name: (type getValue asStringEncoding: #UTF_8).	set := aBERSequence elementAt: 2.	set elements do: [:anElement |		anInstance addValue: anElement value].	^ anInstance</body><body package="LDAP">newWithName: aString	"Answers an LDAPAttribute with a name, but no values"	| instance |	instance := self new.	instance name: aString.	^ instance</body><body package="LDAP">newWithName: aString withValue: aValue	| anInstance |		anInstance := self newWithName: aString.	anInstance addValue: aValue.	^ anInstance</body><body package="LDAP">newWithName: aString withValues: aCollection	| anInstance |		anInstance := self newWithName: aString.	aCollection do: [:aValue |		anInstance addValue: aValue].	^ anInstance</body></methods><methods><class-id>Net.BERAny</class-id> <category>input-output</category><body package="LDAP">writeOn: aStream	mValue writeOn: aStream</body></methods><methods><class-id>Net.BERAny</class-id> <category>printing</category><body package="LDAP">toString	^ 'Any {', mValue toString, '}'</body></methods><methods><class-id>Net.BERAny</class-id> <category>accessing</category><body package="LDAP">getType	^ self class type: 'Any'</body><body package="LDAP">getValue	^ self value</body><body package="LDAP">value	^ mValue</body><body package="LDAP">value: aValue	mValue := aValue</body></methods><methods><class-id>Net.BERAny class</class-id> <category>instance creation</category><body package="LDAP">fromValue: aValue	^ self new value: aValue; yourself</body><body package="LDAP">newFrom: inStream decoder: aBERTagDecoder bytesRead: anArray	"Constructs an any element from the input stream.	 Note that with the current decoding architecture any types will not	 be decoded as any's, but rather only as the types chosen.	 I.E. this method will never be called in the current implementation."	| value |	value := self getElementFrom: inStream					decoder: aBERTagDecoder					bytesRead: anArray.	^ self fromValue: value</body></methods><methods><class-id>Net.JDAPAbandonRequest</class-id> <category>initialize-release</category><body package="LDAP">initialize	mMsgId := 0.	^ self</body></methods><methods><class-id>Net.JDAPAbandonRequest</class-id> <category>accessing</category><body package="LDAP">getType	^ JDAPProtocolOp codeForOperationType: 'ABANDON_REQUEST'</body><body package="LDAP">msgId	^ mMsgId</body><body package="LDAP">msgId: anInteger	mMsgId := anInteger</body></methods><methods><class-id>Net.JDAPAbandonRequest</class-id> <category>printing</category><body package="LDAP">getParamString	| paramStream |	paramStream := WriteStream on: String new.	paramStream nextPutAll: '{msgid='.	paramStream nextPutAll: self msgId asString.	paramStream nextPut: $}.	^ paramStream contents</body><body package="LDAP">toString	^ self class name, ' ', self getParamString</body></methods><methods><class-id>Net.JDAPAbandonRequest</class-id> <category>encoding</category><body package="LDAP">getBERElement        " Assume mMsgId = 1. The BER encoding output           should be                     [*] umich-ldap-v3.3:               0x50 (implicit tagged integer)               0x01 (length)               0x01 (message id)           [*] umich-ldap-v3.0:               0x50 (tag APPLICATION|CONSTRUCTED)               0x85 0x00 0x00 0x00 0x07 (tag length)               0x02 (integer tag)               0x85 0x00 0x00 0x00 0x01 0x01 (message id) "	| i tag element |	i := BERInteger newForValue: self msgId.	tag := ((BERElement tag: 'Application') bitOr: (BERElement tag: 'Constructed')) bitOr: 16.	element := BERTag					newWithTag: tag					element: i					implicit: true.	^ element</body></methods><methods><class-id>Net.JDAPAbandonRequest class</class-id> <category>instance creation</category><body package="LDAP">newForMessageId: anInteger	| instance |	instance := self basicNew initialize.	instance msgId: anInteger.	^ instance</body></methods><methods><class-id>Net.LDIFContent</class-id> <category>printing</category><body package="LDAP">toString	^ self subclassResponsibility</body></methods><methods><class-id>Net.LDIFContent</class-id> <category>accessing</category><body package="LDAP">getType	^ self subclassResponsibility</body></methods><methods><class-id>Net.LDIFContent class</class-id> <category>constants</category><body package="LDAP">addContent	^ 1</body><body package="LDAP">attributeContent	^ 0</body><body package="LDAP">deleteContent	^ 2</body><body package="LDAP">modDNContent	^ 4</body><body package="LDAP">modificationContent	^ 3</body></methods><methods><class-id>Net.LDIFModifyContent</class-id> <category>accessing</category><body package="LDAP">addElement: anLDAPModification	mMods add: anLDAPModification</body><body package="LDAP">getModifications	^ mMods copy</body><body package="LDAP">getType	^ self class modificationContent</body></methods><methods><class-id>Net.LDIFModifyContent</class-id> <category>initialize-release</category><body package="LDAP">initialize	mMods := OrderedCollection new</body></methods><methods><class-id>Net.LDIFModifyContent</class-id> <category>printing</category><body package="LDAP">toString	| outStream |	outStream := WriteStream on: String new.	mMods do: [:aMod |		outStream nextPutAll: aMod toString].	^ self class name asString, ' {', outStream contents, '}'</body></methods><methods><class-id>Net.LDIFModifyContent class</class-id> <category>instance creation</category><body package="LDAP">new	^ self basicNew initialize</body></methods><methods><class-id>Net.JDAPFilterOpers class</class-id> <category>utilities</category><body package="LDAP">getByteValues: aString	"Converts aString into bytes, handling any embedded escape characters along the way."	| pos v val totalSize s1 b num result |	v := OrderedCollection new.	pos := 0.	val := aString copy.	totalSize := 0.	[pos := val indexOf: EscapeKey.	pos &gt; 0]		whileTrue: [			[s1 := val copyFrom: 1 to: (pos - 1).			b := s1 asByteArrayEncoding: #UTF_8.			totalSize := totalSize + b size.			v add: b]				on: Error				do: [:ex | Debug							ifTrue: [Transcript show: 'Error in byte array encoding: ', ex description; cr].						^ ByteArray new].			num := Integer fromHex: (val copyFrom: (pos + 1) to: (pos + 2)).			totalSize := totalSize + 1.			v add: (ByteArray with: num).			val := val copyFrom: (pos + 3) to: val size].	val size &gt; 0		ifTrue: [[b := val asByteArrayEncoding: #UTF_8.			    totalSize := totalSize + b size.			    v add: b]					on: Error					do: [:ex | Debug								ifTrue: [Transcript show: 'Error in byte array encoding: ', ex description; cr].							^ ByteArray new]].	result := ByteArray new: totalSize.	pos := 0.	v do: [:chunk |		1 to: chunk size do: [:ndx |			pos := pos + 1.			result at: pos put: (chunk at: ndx)]].	^ result</body><body package="LDAP">getOctetString: aString	| byteVal |	(aString indexOf: EscapeKey) &gt; 0		ifTrue: [byteVal := self getByteValues: aString.			    ^ BEROctetString newFromByteArray: byteVal]		ifFalse: [^ BEROctetString newFromString: aString]</body></methods><methods><class-id>Net.JDAPFilterOpers class</class-id> <category>class initialization</category><body package="LDAP">initialize	"JDAPFilterOpers initialize"	EscapeKey := $\.	Debug := false</body></methods><methods><class-id>Net.BERBoolean</class-id> <category>accessing</category><body package="LDAP">getType	^ self class type: 'Boolean'</body><body package="LDAP">getValue	^ self value</body><body package="LDAP">value	^ mValue</body><body package="LDAP">value: aBoolean	mValue := aBoolean</body></methods><methods><class-id>Net.BERBoolean</class-id> <category>input-output</category><body package="LDAP">writeOn: outStream	outStream nextPut: self getType.			"Write type byte"	outStream nextPut: 1.					"Write length byte"	mValue											ifTrue: [outStream nextPut: 255]		"Non-zero is true"		ifFalse: [outStream nextPut: 0]		"Zero is false"</body></methods><methods><class-id>Net.BERBoolean</class-id> <category>printing</category><body package="LDAP">toString	^ 'Boolean {', mValue asString, '}'</body></methods><methods><class-id>Net.BERBoolean</class-id> <category>initialize-release</category><body package="LDAP">initialize	super initialize.	mValue := true</body></methods><methods><class-id>Net.BERBoolean class</class-id> <category>instance creation</category><body package="LDAP">newFrom: inStream bytesRead: anArray	"Reads a new instance from input stream.	anArray includes 1 integer representing the number of bytes read from input stream.	Answers new instance."	| bytesRead octet |	bytesRead := anArray at: 1.	inStream next.				"Skip length byte"	bytesRead := bytesRead + 1.	octet := inStream next.	bytesRead := bytesRead + 1.	anArray at: 1 put: bytesRead.	^ self newForValue: (octet &gt; 0)</body></methods><methods><class-id>Net.JDAPFilter</class-id> <category>encoding</category><body package="LDAP">getBERElement	^ self subclassResponsibility</body></methods><methods><class-id>Net.JDAPFilter</class-id> <category>initialize-release</category><body package="LDAP">initialize	^ self</body></methods><methods><class-id>Net.JDAPFilter</class-id> <category>printing</category><body package="LDAP">toString	^ self subclassResponsibility</body></methods><methods><class-id>Net.JDAPFilter class</class-id> <category>instance creation</category><body package="LDAP">getFilter: filterString	| f |	f := filterString.	f trim.	( f first == $( ) &amp; ( f last == $) )		ifTrue: [^ self getFilterComp: (f copyFrom: 2 to: (f size - 1))]		ifFalse: [^ self getFilterComp: f]</body><body package="LDAP">new	^ self basicNew initialize</body></methods><methods><class-id>Net.JDAPFilter class</class-id> <category>private</category><body package="LDAP">getFilterComp: aString	| f  filters filterAnd filterOr |	f := aString.	f trim.	" and "	f first == $&amp;		ifTrue: [filters := self getFilterList: (f copyFrom: 2 to: f size).			    filterAnd := JDAPFilterAnd new.			    filters do: [:each |					filterAnd addElement: each].			    ^ filterAnd].	" or "	f first == $|		ifTrue: [filters := self getFilterList: (f copyFrom: 2 to: f size).			    filterOr := JDAPFilterOr new.			    filters do: [:each |					filterOr addElement: each].			    ^ filterOr].	" not "	f first == $!		ifTrue: [^ JDAPFilterNot newForFilter: (self getFilter: (f copyFrom: 2 to: f size))].	^ self getFilterItem: f</body><body package="LDAP">getFilterItem: aString	| item idx type value ava  st sub initial any |	item := aString trim.	idx := item indexOf: $=.	idx = 0		ifTrue: [^ nil].	type := (item copyFrom: 1 to: (idx - 1)) trim.	value := (item copyFrom: (idx + 1) to: aString size) trim.	"Make a decision by looking at the type"	type last == $~		ifTrue: [ava := JDAPAva newForType: (type copyFrom: 1 to: (type size - 1)) value: value.				^ JDAPFilterApproxMatch newForAva: ava].	type last == $&gt;		ifTrue: [ava := JDAPAva newForType: (type copyFrom: 1 to: (type size - 1)) value: value.				^ JDAPFilterGreaterOrEqual newForAva: ava].	type last == $&lt;		ifTrue: [ava := JDAPAva newForType: (type copyFrom: 1 to: (type size - 1)) value: value.				^ JDAPFilterLessOrEqual newForAva: ava].	type last == $:		ifTrue: [^ JDAPFilterExtensible newForType: (type copyFrom: 1 to: (type size - 1)) value: value].	"For those that are not simple"	(value first == $*) &amp; (value size = 1)		ifTrue: [^ JDAPFilterPresent newForType: type].	"If value contains no * then it is equality"	(value indexOf: $*) = 0		ifTrue: [ava := JDAPAva newForType: type value: value.				^ JDAPFilterEqualityMatch newForAva: ava].	"Must be substring at this point"	st := ReadStream on: (value tokensBasedOn: $*).	sub := JDAPFilterSubString newForType: type.	value first == $*		ifFalse: [initial := st next.				 initial := initial trim].	sub addInitial: initial.	[st atEnd]		whileFalse: [any := st next trim.					st atEnd						ifFalse: [sub addAny: any]						ifTrue: [value last == $*									ifTrue: [sub addAny: any.											sub addFinal: nil]									ifFalse: [sub addFinal: any]]].	^ sub</body><body package="LDAP">getFilterList: aString	| list level start end v |	v := OrderedCollection new.	list := aString.	list trim.	level := 0.	1 to: list size do: [:ndx |		(list at: ndx) == $(			ifTrue: [level = 0						ifTrue: [start := ndx].					level := level + 1].		(list at: ndx) == $)			ifTrue: [level := level - 1.					level = 0						ifTrue: [end := ndx.								v add: (JDAPFilter getFilter: (list copyFrom: start to: end))]]].	^ v</body></methods><methods><class-id>Net.JDAPFilterSet</class-id> <category>accessing</category><body package="LDAP">addElement: aJDAPFilter	mSet add: aJDAPFilter</body><body package="LDAP">set	^ mSet</body><body package="LDAP">tag	^ mTag</body><body package="LDAP">tag: anInteger	mTag := anInteger</body></methods><methods><class-id>Net.JDAPFilterSet</class-id> <category>encoding</category><body package="LDAP">getBERElement	| filters element |	filters := BERSet new.	mSet do: [:each |		filters addElement: each getBERElement].	element := BERTag newWithTag: self tag element: filters implicit: true.	^ element</body></methods><methods><class-id>Net.JDAPFilterSet</class-id> <category>printing</category><body package="LDAP">getParamString	| paramStream first |	paramStream := WriteStream on: String new.	first := true.	self set do: [:each |		first			ifTrue: [first := false]			ifFalse: [paramStream nextPut: $,].		paramStream nextPutAll: each toString].	^ paramStream contents</body><body package="LDAP">toString	self class name, ' {', self getParamString, '}'</body></methods><methods><class-id>Net.JDAPFilterSet</class-id> <category>initialize-release</category><body package="LDAP">initialize	super initialize.	mSet := OrderedCollection new.	mTag := 0.</body></methods><methods><class-id>Net.JDAPFilterSet class</class-id> <category>instance creation</category><body package="LDAP">newForTag: anInt	| instance |	instance := self basicNew initialize.	instance tag: anInt.	^ instance</body></methods><methods><class-id>Net.JDAPFilterAnd class</class-id> <category>instance creation</category><body package="LDAP">new	| tag |	tag := ((BERElement tag: 'Constructed') bitOr: (BERElement tag: 'Context')) bitOr: 0.	^ self newForTag: tag</body></methods><methods><class-id>Net.JDAPSearchResultReference</class-id> <category>accessing</category><body package="LDAP">addURL: aString 	mURLs add: aString</body><body package="LDAP">element	^ mElement</body><body package="LDAP">element: aBERElement	mElement := aBERElement</body><body package="LDAP">getType	^ JDAPProtocolOp codeForOperationType: 'SEARCH_RESULT_REFERENCE'</body><body package="LDAP">urls 	^ mURLs</body></methods><methods><class-id>Net.JDAPSearchResultReference</class-id> <category>printing</category><body package="LDAP">getParamString	| paramStream first |	paramStream := WriteStream on: String new.	paramStream nextPutAll: '{references='.	first := true.	self urls do: [:each |		first			ifTrue: [first := false]			ifFalse: [paramStream nextPut: $,].		paramStream nextPutAll: each].	paramStream nextPut: $}.	^ paramStream contents</body><body package="LDAP">toString	^ self class name, ' ', self getParamString</body></methods><methods><class-id>Net.JDAPSearchResultReference</class-id> <category>initialize-release</category><body package="LDAP">initialize	mElement := BERElement new.	mURLs := OrderedCollection new.	^ self</body></methods><methods><class-id>Net.JDAPSearchResultReference class</class-id> <category>instance creation</category><body package="LDAP">new	^ self basicNew initialize</body><body package="LDAP">newFromBERElement: aBERElement 	| instance |	(aBERElement isMemberOf: BERSequence) 		ifFalse: 			[LDAPError 				raiseErrorString: 'Assertion failed in JDAPSearchResultReference class&gt;&gt;newFromBERElement:'].	instance := self new.	instance element: aBERElement.	1 to: aBERElement size		do: 			[:idx | 			| aBEROctetString |			aBEROctetString := aBERElement elementAt: idx.			instance addURL: (aBEROctetString getValue asStringEncoding: #UTF_8)].	^instance</body><body package="LDAP">newFromBERTag: aBERTag 	^self newFromBERElement: aBERTag getValue</body></methods><methods><class-id>Net.BERUTCTime</class-id> <category>input-output</category><body package="LDAP">writeOn: outStream	"Writes BERUTCTime object on output stream"	| bArray |	outStream nextPut: self getType.	(mValue isNil or: [mValue size = 0])		ifTrue: [self class sendDefiniteLengthOn: outStream numberOfOctets: 0]		ifFalse: [bArray := mValue asByteArrayEncoding: #UTF_8.				self class sendDefiniteLengthOn: outStream numberOfOctets: bArray size.				outStream nextPutAll: bArray]</body></methods><methods><class-id>Net.BERUTCTime</class-id> <category>printing</category><body package="LDAP">toString	mValue isNil		ifTrue: [^ 'UTCTime {}'].	^ 'UTCTime {', mValue, '}'</body></methods><methods><class-id>Net.BERUTCTime</class-id> <category>accessing</category><body package="LDAP">getType	^ self class type: 'UTCTime'</body><body package="LDAP">getValue	^ self value</body><body package="LDAP">value	^ mValue</body><body package="LDAP">value: utcString	mValue := utcString</body></methods><methods><class-id>Net.BERUTCTime class</class-id> <category>instance creation</category><body package="LDAP">newFrom: inStream bytesRead: anArray	"Constructs a character string element from the input stream, for primitive encoding.	anArray contains 1 integer representing the number of bytes read from inStream."	| contentsLength buffer bytesRead value |	contentsLength := self readLengthOctetsFrom: inStream bytesRead: anArray.	bytesRead := anArray at: 1.	value := String new.	"Definite length octets string"	contentsLength &gt; 0		ifTrue: [buffer := ByteArray new: contentsLength.			     1 to: contentsLength do: [:idx |					buffer at: idx put: inStream next].			     bytesRead := bytesRead + contentsLength.			     value := buffer asStringEncoding: #UTF_8].	anArray at: 1 put: bytesRead.	^ self newFromString: value</body><body package="LDAP">newFrom: inStream decoder: aBERTagDecoder bytesRead: anArray	"Constructs a UTC Time element from input stream (for constructed encoding).	anArray is an array of 1 integer representing the number of bytes read from input stream."	| contentsLength componentLength element bytesRead value continue |	contentsLength := self readLengthOctetsFrom: inStream bytesRead: anArray.	componentLength := Array with: 0.	bytesRead := anArray at: 1.	value := String new.	element := nil.	contentsLength = -1					"Constructed - indefinite length content octets"		ifTrue: [continue := true.			     [continue]					whileTrue: [						element := self getElementFrom: inStream											decoder: aBERTagDecoder											bytesRead: componentLength.						element isNil							ifTrue: [continue := false]							ifFalse: [value := value, element]]	.	"Element is an octet string"				bytesRead := bytesRead + (componentLength at: 1)]		ifFalse: [bytesRead := bytesRead + contentsLength.				[contentsLength &gt; 0]					whileTrue: [						componentLength at: 1 put: 0.						element := self getElementFrom: inStream											decoder: aBERTagDecoder											bytesRead: componentLength.						element isNil							ifFalse: [value := value, element].						contentsLength := contentsLength - (componentLength at: 1)]].	anArray at: 1 put: bytesRead.	^ self new value: value</body><body package="LDAP">newFromString: utcString	^ self new value: utcString</body></methods><methods><class-id>Net.MalformedURLException</class-id> <category>accessing</category><body package="LDAP">messageText	"Answer the exception text."	^'URL is malformed and cannot be parsed.'</body></methods><methods><class-id>Net.DistinguishedName</class-id> <category>accessing</category><body package="LDAP">addRDN: anRDN	(RelativeDistinguishedName isRDN: anRDN)		ifFalse: [^ false].	self isRFCFormat		ifTrue: [self addRDNToFront: anRDN]		ifFalse: [self addRDNToBack: anRDN].	^ true</body><body package="LDAP">addRDNToBack: anRDN	"Adds the Relative Distinguished Name to the end of the current distinguished name"	mRDNs addLast: anRDN</body><body package="LDAP">addRDNToFront: anRDN	"Adds the Relative Distinguished Name to the beginning of the current distinguished name"	mRDNs addFirst: anRDN</body><body package="LDAP">countRDNs	"Answers the number of components that make up the current distinguished name"	^ mRDNs size</body><body package="LDAP">dnType	^ mDNType</body><body package="LDAP">dnType: anInteger	mDNType := anInteger</body><body package="LDAP">explodeDNNoTypes: aBoolean	"Answer an array of individual components that make up this distinguished name.  aBoolean indicates whether the type of each component attribute is to be suppressed (For example: 'cn=')"	^ aBoolean		ifTrue: [self rdns collect: [:anRDN | anRDN getValue]]		ifFalse: [self rdns collect: [:anRDN | anRDN toString]]</body><body package="LDAP">getParent	"Answers the parent Distinguished Name associated with this DN"	"Example: If DN is 'uid=bjensen, ou=People, o=Arius.com', then the parent is 'ou=People, o=Arius.com'"	| newInstance |	newInstance := self class new.	(self countRDNs - 1) to: 1 do: [:idx |		newInstance addRDN: (mRDNs at: idx)].	^ newInstance</body><body package="LDAP">includes: aDN	"Answers true if this DN is under a subtree specified by aDN."	"For example, if receiver is 'uid=bjensen, ou=People, o=Arius.com', and aDN is 'ou=People, o=Arius.com', answer will be true"	| rdns1 rdns2 i j |	rdns1 := aDN rdns.	rdns2 := self rdns.	i := rdns1 size - 1.	j := rdns2 size - 1.	[(i &gt; 0) &amp; (j &gt; 0)]		whileTrue: [			((rdns2 at: j) equivalentTo: (rdns1 at: i))				ifFalse: [^ false].			i := i - 1.			j := j - 1].	^ true</body><body package="LDAP">rdns	"Answers a collection of the components (relative distinguished names) that make up this distinguished name"	^ mRDNs</body></methods><methods><class-id>Net.DistinguishedName</class-id> <category>testing</category><body package="LDAP">isOSFFormat	^ mDNType = self class osfFormat</body><body package="LDAP">isRFCFormat	^ mDNType = self class rfcFormat</body></methods><methods><class-id>Net.DistinguishedName</class-id> <category>initialize-release</category><body package="LDAP">initialize	mRDNs := OrderedCollection new.	mDNType := self class rfcFormat.	^ self</body></methods><methods><class-id>Net.DistinguishedName</class-id> <category>comparing</category><body package="LDAP">equivalentTo: aDN	^ (self toRFCString asUppercase) = (aDN toRFCString asUppercase)</body></methods><methods><class-id>Net.DistinguishedName</class-id> <category>printing</category><body package="LDAP">toOSFString	^ self rdns		inject: ''		into: [:subString :nextRDN |				subString size = 0					ifTrue: [nextRDN toString]					ifFalse: [nextRDN toString , '/', subString]]</body><body package="LDAP">toRFCString	^ self rdns		inject: ''		into: [:subString :nextRDN |				subString size = 0					ifTrue: [nextRDN toString]					ifFalse: [subString, ',', nextRDN toString]]</body><body package="LDAP">toString	^ self isRFCFormat		ifTrue: [self toRFCString]		ifFalse: [self toOSFString]</body></methods><methods><class-id>Net.DistinguishedName class</class-id> <category>utilities</category><body package="LDAP">isDN: aString	"Answers true if the specified string is a distinguished name."	^ (self newFromString: aString) countRDNs &gt; 0</body><body package="LDAP">isOSFString: dnString	^ dnString includes: $/</body><body package="LDAP">isRFCString: aString	"Answers true if aString forms a Distinguished Name in RFC 1438 format"	| index |	index := aString findString: ',' startingAt: 1.	"First or last character cannot ge the first unescaped comma"	[(index &gt; 1) &amp; (index &lt; (aString size - 1))]		whileTrue: [			(aString at: (index - 1)) == $\				ifFalse: [^ true].			index := aString findString: ',' startingAt: (index + 1)].	^ false</body></methods><methods><class-id>Net.DistinguishedName class</class-id> <category>instance creation</category><body package="LDAP">new	^ self basicNew initialize</body><body package="LDAP">newFromOSFString: dnString	| instance st rdns rdn |	instance := self new.	instance dnType: self osfFormat.	rdns := OrderedCollection new.	st := ReadStream on: (dnString tokensBasedOn: $/).	[st atEnd]		whileFalse: [			rdn := st next.			(RelativeDistinguishedName isRDN: rdn)				ifTrue: [rdns add: (RelativeDistinguishedName newFromString: rdn)]				ifFalse: [^ instance]].	rdns reverseDo: [:anRDN | instance addRDN: anRDN].	^ instance</body><body package="LDAP">newFromRFCString: dnString	"Creates an instance from the specified string in distinguished name format.  The string must be in RFC 1485 format"	| buffer rBuffer idx openQuotes c instance |	instance := self new.	buffer := dnString copy.	rBuffer := String new.	idx := 1.	openQuotes := false.	[idx &lt; buffer size]		whileTrue: [			rBuffer := rBuffer, (buffer at: idx) asString.			(buffer at: idx) == $\				ifTrue: [c := buffer at: (idx + 1).					    (self escapedChars includes: c)							ifTrue: [idx := idx + 1.								    rBuffer := rBuffer, (buffer at: idx) asString]]				ifFalse: [(buffer at: idx) == $"							ifTrue: [openQuotes										ifTrue: [openQuotes := false]										ifFalse: [openQuotes := true]]							ifFalse: [(buffer at: idx) == $,										ifTrue: [openQuotes													ifFalse: [rBuffer := rBuffer copyFrom: 1 																		to: (rBuffer size - 1).															(instance addRDN: rBuffer)																ifFalse: [^ self new].															rBuffer := String new]]]].			idx := idx + 1].	"Did not find the second quote, so DN is not in proper format"	openQuotes		ifTrue: [^ self new].	"rBuffer must contain a proper RDN"	(instance addRDN: rBuffer)		ifFalse: [^ self new].	^ instance</body><body package="LDAP">newFromString: dnString	"Creates an instance from the specified string in distinguished name format.  The string may be in either RFC 1485 or OSF format"	| instance |	(dnString isNil or: [dnString size = 0])		ifTrue: [^ self new].	(self isRFCString: dnString)		ifTrue: [^ self newFromRFCString: dnString].	(self isOSFString: dnString)		ifTrue: [^ self newFromOSFString: dnString].	(RelativeDistinguishedName isRDN: dnString)		ifTrue: [instance := self new.			    instance addRDN: dnString.			    ^ instance].	LDAPError raiseSignal: dnString printString</body></methods><methods><class-id>Net.DistinguishedName class</class-id> <category>constants</category><body package="LDAP">escapedChars	"Array of characters that may be escaped in a distinguished name"	^ #($, $+ $" $\ $;)</body><body package="LDAP">osfFormat	^ 1</body><body package="LDAP">rfcFormat	^ 0</body></methods><methods><class-id>Net.BERTag</class-id> <category>accessing</category><body package="LDAP">element: aBERElement	mElement := aBERElement</body><body package="LDAP">getType	^ self class type: 'Tag'</body><body package="LDAP">getValue	^ mElement</body><body package="LDAP">implicit: aBoolean	"Sets implicit tag.  If tag is implicit, the next element tag can be omitted (i.e. will not be sent to stream or buffer)"	mImplicit := aBoolean</body><body package="LDAP">tag	^ mTag</body><body package="LDAP">tag: anInteger	mTag := anInteger</body></methods><methods><class-id>Net.BERTag</class-id> <category>input-output</category><body package="LDAP">writeOn: outStream	| contentsStream contentsBuffer |	outStream nextPut: mTag.	contentsBuffer := OrderedCollection new.	contentsStream := WriteStream on: contentsBuffer.	mElement writeOn: contentsStream.	contentsBuffer := contentsBuffer copyWithout: nil.	mImplicit		ifTrue: [ "Assumes tag is only one byte.  Rest of buffer is length 				and contents of tagged element"				outStream nextPutAll: (contentsBuffer copyFrom: 2 to: contentsBuffer size)]		ifFalse: ["Send length"				self class sendDefiniteLengthOn: outStream 					numberOfOctets: contentsBuffer size.				"Send contents"				outStream nextPutAll: contentsBuffer]</body></methods><methods><class-id>Net.BERTag</class-id> <category>printing</category><body package="LDAP">toString	| s tagString |	s := (mTag bitAnd: 192) = 0		ifTrue: ['Universal-']											"Bits 8+7=00"		ifFalse: [((mTag bitAnd: 128) bitAnd: (mTag bitAnd: 64)) &gt; 0					ifTrue: [ 'Private-']								"Bits 8+7=11"					ifFalse: [(mTag bitAnd: 64) &gt; 0								ifTrue: [ 'Application-']				"Bits 8+7=01"								ifFalse: [(mTag bitAnd: 128) &gt; 0											ifTrue: [ 'Context-']]]].		"Bits 8+7=10"	tagString := (mTag bitAnd: 31) asString.	^ '[', s, tagString, '] ', mElement toString</body></methods><methods><class-id>Net.BERTag</class-id> <category>initialize-release</category><body package="LDAP">initialize	super initialize.	mTag := 0.	mImplicit := false.</body></methods><methods><class-id>Net.BERTag class</class-id> <category>instance creation</category><body package="LDAP">newFrom: inStream decoder: aBERTagDecoder tag: tag bytesRead: anArray	| implicit element |	implicit := Array new: 1.	element := aBERTagDecoder 					getElementFrom: inStream					decoder: aBERTagDecoder					tag: tag					bytesRead: anArray					implicit: implicit.	^ self newWithTag: tag element: element implicit: (implicit at: 1)</body><body package="LDAP">newWithTag: anInteger element: aBERElement implicit: aBoolean	| anInstance |	anInstance := self new.	anInstance tag: anInteger.	anInstance element: aBERElement.	anInstance implicit: aBoolean.	^ anInstance</body></methods><methods><class-id>Net.LDAPUrl</class-id> <category>accessing</category><body package="LDAP">addAttribute: aString	self attributes add: aString</body><body package="LDAP">attributes	^attributes</body><body package="LDAP">attributes: anObject	attributes := anObject</body><body package="LDAP">dn	^dn</body><body package="LDAP">dn: anObject	dn := anObject</body><body package="LDAP">filter	^filter</body><body package="LDAP">filter: anObject	filter := anObject</body><body package="LDAP">hostName	^hostName</body><body package="LDAP">hostName: anObject	hostName := anObject</body><body package="LDAP">portNumber	^portNumber</body><body package="LDAP">portNumber: anObject	portNumber := anObject</body><body package="LDAP">scope	^scope</body><body package="LDAP">scope: anObject	scope := anObject</body><body package="LDAP">url	^url</body><body package="LDAP">url: anObject	url := anObject</body></methods><methods><class-id>Net.LDAPUrl</class-id> <category>utilities</category><body package="LDAP">getScope: aString	"Answers the numeric value that represents the scope of the search encoded by aString"	"An answer of -1 indicates that aString does not represent a valid scope." 	| lower s |	s := -1.	lower := aString asLowercase.	lower = 'base'		ifTrue: [s := LDAPv2 scopeBase]		ifFalse: [lower = 'one'					ifTrue: [s := LDAPv2 scopeOne]					ifFalse: [lower = 'sub'								ifTrue: [s := LDAPv2 scopeSub]]].	^ s</body></methods><methods><class-id>Net.LDAPUrl</class-id> <category>private</category><body package="LDAP">isAttribute: aString	"Answers true if aString is a candidate to be a valid attribute expression."	| lower |	(self isFilter: aString)		ifTrue: [^ false].	lower := aString asLowercase.	^(#('base' 'one' 'sub') includes: lower) not</body><body package="LDAP">isFilter: aString	"Answers true if aString is a candidate to be a valid filter expression."	^ aString first == $(</body><body package="LDAP">readNextConstructFrom: parserStream	[parserStream atEnd		ifFalse: [parserStream next.		" ? "				^ parserStream next]]		on: EndOfStreamNotification		do: [:ex | ex resignalAs: MalformedURLException new].	^ nil</body></methods><methods><class-id>Net.LDAPUrl</class-id> <category>initialize-release</category><body package="LDAP">initialize	hostName := String new.	portNumber := LDAPv2 defaultPort.	dn := String new.	attributes := OrderedCollection new.	scope := LDAPv2 scopeBase.	filter := self class defaultFilter.	url := String new.	^ self</body><body package="LDAP">initializeUrl	| urlStream first hadAttributes |	urlStream := WriteStream on: String new.	urlStream nextPutAll: 'LDAP://'.	self hostName notNil		ifTrue: [urlStream nextPutAll: self hostName.			    self portNumber ~= LDAPv2 defaultPort					ifTrue: [urlStream nextPut: $:.						    urlStream nextPutAll: portNumber asString]].	urlStream nextPut: $/.	urlStream nextPutAll: (self class encode: self dn).	hadAttributes := false.	(self attributes notNil and: [self attributes size &gt; 0])		ifTrue: [hadAttributes := true.			    urlStream nextPut: $?.			    first := true.			    self attributes do: [:each |					first						ifTrue: [first := false]						ifFalse: [urlStream nextPut: $,].					urlStream nextPutAll: each]].	self filter notNil		ifTrue: [hadAttributes					ifFalse: [urlStream nextPut: $?].			    urlStream nextPut: $?.			    self scope = LDAPv2 scopeBase					ifTrue: [urlStream nextPutAll: 'base']					ifFalse: [self scope = LDAPv2 scopeOne								ifTrue: [urlStream nextPutAll: 'one']								ifFalse: [self scope = LDAPv2 scopeSub											ifTrue: [urlStream nextPutAll: 'sub']]].			    urlStream nextPut: $?.			    urlStream nextPutAll: self filter].	self url: urlStream contents</body></methods><methods><class-id>Net.LDAPUrl class</class-id> <category>utilities</category><body package="LDAP">decode: encodedString	"Decodes a URL-encoded string.  Any occurences of %HH are decoded to the hex value represented.  However, this method does not decode '+' into ' ' (space).  See RFC 1738 for full details about URL encoding/decoding."	| decoded encoded val |	decoded := WriteStream on: String new.	encoded := ReadStream on: encodedString.	[[encoded atEnd]		whileFalse: [decoded nextPutAll: (encoded upTo: $%).					encoded atEnd						ifFalse: [val := Integer fromHex: (encoded next: 2).								decoded nextPut: (Character value: val)]]]			on: Exception			do: [:ex | (ex isKindOf: MalformedURLException)						ifTrue: [ex pass]						ifFalse: [ex resignalAs: MalformedURLException new]].	^ decoded contents</body><body package="LDAP">encode: decodedString	"URL-encodes a string.  Any occurences of illegal characters are encoded as %HH where HH is the hex value of the character.  However, this method does not decode ' ' (space) into '+' (this is an HTTP thing, not a general URL thing).  See RFC 1738 for full details about URL encoding/decoding."	| decoded encoded val legal pVal |	legal := '$-_.+!*(),'.	decoded := ReadStream on: decodedString.	encoded := WriteStream on: String new.	[decoded atEnd]		whileFalse: [val := decoded next.					(val isAlphaNumeric) | (legal includes: val) | (val == $')						ifTrue: [encoded nextPut: val]						ifFalse: [encoded nextPut: $%.								pVal := val asInteger printStringRadix: 16.								pVal size &lt; 2									ifTrue: [encoded nextPutAll: '0'].								encoded nextPutAll: pVal]].	^ encoded contents</body></methods><methods><class-id>Net.LDAPUrl class</class-id> <category>instance creation</category><body package="LDAP">new	^ self basicNew initialize</body><body package="LDAP">newForHost: hostString port: portInteger dn: dnString 	"This form is typically used to create a URL reference to a particular object in the directory."	| instance urlStream |	instance := self new.	urlStream := WriteStream on: String new.	urlStream nextPutAll: 'LDAP://'.	hostString notNil 		ifTrue: 			[urlStream nextPutAll: hostString.			portInteger ~= LDAPv2 defaultPort 				ifTrue: 					[urlStream nextPut: $:.					urlStream nextPutAll: portInteger asString]].	urlStream nextPut: $/.	urlStream nextPutAll: (self encode: dnString).	instance url: urlStream contents.	instance hostName: hostString.	instance portNumber: portInteger.	instance filter: self defaultFilter.	instance scope: LDAPv2 scopeBase.	^instance</body><body package="LDAP">newForHost: hostString port: portInteger dn: dnString attributes: attrCollect scope: scopeInteger filter: filterString	"Constructs a full-blown LDAP URL to specify an LDAP search operation"	| instance |	instance := self new.	instance hostName: hostString.	instance portNumber: portInteger.	instance dn: dnString.	instance attributes: attrCollect.	instance scope: scopeInteger.	instance filter: filterString.	instance initializeUrl.	^ instance</body><body package="LDAP">newFromString: url 	| instance urlParser currentToken attributeList str attributeParser |	instance := self new.	urlParser := ReadStream 				on: (url tokensBasedOnAnyOf: ':/?' answerTokens: true).	instance url: url.	currentToken := urlParser next.	currentToken asLowercase = 'ldap' 		ifFalse: [MalformedURLException new raiseSignal].	3 timesRepeat: [urlParser next].	"://"	currentToken := urlParser next.	currentToken = '/' 		ifTrue: 			[instance hostName: String new.			instance portNumber: LDAPv2 defaultPort]		ifFalse: 			[instance hostName: currentToken.			urlParser atEnd 				ifTrue: 					[instance portNumber: LDAPv2 defaultPort.					^instance].			currentToken := urlParser next.	" either ':' or '/' "			currentToken = ':' 				ifTrue: 					[instance portNumber: urlParser next asNumber.					urlParser atEnd ifTrue: [^instance].					urlParser next]				ifFalse: [instance portNumber: LDAPv2 defaultPort]	" / "].	urlParser atEnd ifTrue: [^instance].	instance dn: (self decode: urlParser next).	"If last token was ?, no distinguished name was supplied"	instance dn = '?' 		ifTrue: [instance dn: String new]		ifFalse: [instance dn = '/' ifTrue: [^MalformedURLException new raiseSignal]].	urlParser atEnd 		ifFalse: 			[str := instance readNextConstructFrom: urlParser.	"There is a '?attributeList' portion"			str = '?' 				ifTrue: 					[attributeList := OrderedCollection new.	"No attribute(s) supplied"					str := urlParser next]				ifFalse: 					[attributeList := self decode: str.					str := instance readNextConstructFrom: urlParser].			"Check for scope"			(str notNil and: 					[instance scope: (instance getScope: str).					(instance scope = -1) not]) 				ifTrue: [str := instance readNextConstructFrom: urlParser]				ifFalse: 					[instance scope: LDAPv2 scopeBase.					(str notNil and: [str = '?']) ifTrue: [str := urlParser next]].	"No scope supplied"			"Check for filter"			((str notNil and: [str size &gt; 0]) and: [instance isFilter: str]) 				ifTrue: 					[instance filter: (self decode: str).					str := instance readNextConstructFrom: urlParser]].	attributeList notNil 		ifTrue: 			[attributeParser := ReadStream on: (attributeList tokensBasedOnAnyOf: ', ').			instance attributes: OrderedCollection new.			[attributeParser atEnd] 				whileFalse: [instance addAttribute: attributeParser next]].	^instance</body></methods><methods><class-id>Net.LDAPUrl class</class-id> <category>constants</category><body package="LDAP">defaultFilter	^ '(objectClass=*)'</body></methods><methods><class-id>Net.BERTagDecoder</class-id> <category>utilities</category><body package="LDAP">getElementFrom: inStream decoder: aBERTagDecoder tag: tag bytesRead: anArray implicit: implicit	"Answers the next element from inStream.	aBERTagDecoder is this instance.	tag is an integer representing the tag value already read.	bytesRead is an array with one element representing the number of bytes read from inStream.	implicit is an array with one element which indicates whether the element is implicit.		(See comment for method implicit: in class BERTag)"	^ self subclassResponsibility</body></methods><methods><class-id>Net.LDIFModDNContent</class-id> <category>printing</category><body package="LDAP">toString	| outStream |	outStream := WriteStream on: String new.	outStream nextPutAll: 'new parent('.	outStream nextPutAll: mNewParent.	outStream nextPutAll: '), '.	outStream nextPutAll: 'deleteOldRDN('.	outStream nextPutAll: mDeleteOldRDN asString.	outStream nextPutAll: '), '.	outStream nextPutAll: 'new rdn('.	outStream nextPutAll: mRDN.	outStream nextPutAll: ')'.	^ self class name, ' {', outStream contents, '}'</body></methods><methods><class-id>Net.LDIFModDNContent</class-id> <category>accessing</category><body package="LDAP">deleteOldRDN	^ mDeleteOldRDN</body><body package="LDAP">deleteOldRDN: aBoolean	mDeleteOldRDN := aBoolean</body><body package="LDAP">getType	^ self class modDNContent</body><body package="LDAP">newParent	^ mNewParent</body><body package="LDAP">newParent: aString	mNewParent := aString</body><body package="LDAP">rdn	^ mRDN</body><body package="LDAP">rdn: aString	mRDN := aString</body></methods><methods><class-id>Net.LDIFModDNContent</class-id> <category>initialize-release</category><body package="LDAP">initialize	mRDN := String new.	mNewParent := String new.	mDeleteOldRDN := false.	^ self</body></methods><methods><class-id>Net.LDIFModDNContent class</class-id> <category>instance creation</category><body package="LDAP">new	^ self basicNew initialize</body></methods><methods><class-id>Net.BERCharacterString</class-id> <category>accessing</category><body package="LDAP">getValue	^ self value</body><body package="LDAP">value	^ mValue</body><body package="LDAP">value: aString	mValue := aString</body></methods><methods><class-id>Net.BERCharacterString</class-id> <category>input-output</category><body package="LDAP">writeOn: outStream	"Writes BERCharacterString object on output stream"	| bArray |	outStream nextPut: self getType.	(mValue isNil or: [mValue size = 0])		ifTrue: [self class sendDefiniteLengthOn: outStream numberOfOctets: 0]		ifFalse: [bArray := mValue asByteArrayEncoding: #UTF_8.				self class sendDefiniteLengthOn: outStream numberOfOctets: bArray size.				outStream nextPutAll: bArray]</body></methods><methods><class-id>Net.BERCharacterString class</class-id> <category>instance creation</category><body package="LDAP">newFrom: inStream bytesRead: anArray	"Constructs a character string element from the input stream, for primitive encoding.	anArray contains 1 integer representing the number of bytes read from inStream."	| contentsLength buffer bytesRead value |	contentsLength := self readLengthOctetsFrom: inStream bytesRead: anArray.	bytesRead := anArray at: 1.	value := String new.	"Definite length octets string"	contentsLength &gt; 0		ifTrue: [buffer := ByteArray new: contentsLength.			     1 to: contentsLength do: [:idx |					buffer at: idx put: inStream next].			     bytesRead := bytesRead + contentsLength.			     value := buffer asStringEncoding: #UTF_8].	anArray at: 1 put: bytesRead.	^ self newFromString: value</body><body package="LDAP">newFrom: inStream decoder: aBERTagDecoder bytesRead: anArray	"Constructs a character string element from input stream (for constructed encoding).	anArray is an array of 1 integer representing the number of bytes read from input stream."	| contentsLength componentLength element bytesRead value continue |	contentsLength := self readLengthOctetsFrom: inStream bytesRead: anArray.	element := nil.	componentLength := Array with: 0.	bytesRead := anArray at: 1.	value := String new.	contentsLength = -1							"Constructed - indefinite length"		ifTrue: [continue := true.			    [continue]					whileTrue: [						componentLength at: 1 put: 0.						element := self getElementFrom: inStream											decoder: aBERTagDecoder											bytesRead: componentLength.						element isNil							ifTrue: [continue := false]							ifFalse: [value := value, element].						bytesRead := bytesRead + (componentLength at: 1)]]		ifFalse: [bytesRead := bytesRead + contentsLength.		"Definite length string"				[contentsLength &gt; 0]					whileTrue: [						componentLength at: 1 put: 0.						element := self getElementFrom: inStream											decoder: aBERTagDecoder											bytesRead: componentLength.						element notNil							ifTrue: [value := value, element].						contentsLength := contentsLength - (componentLength at: 1)]].	anArray at: 1 put: bytesRead.	^ self new value: value</body><body package="LDAP">newFromByteArray: anArray	"Create a character string element from byte array.	anArray is a byte array in UTF-8 format."	^ self new value: (anArray asStringEncoding: #UTF_8); yourself</body><body package="LDAP">newFromString: aString	^ self new value: aString</body></methods><methods><class-id>Net.BERPrintableString</class-id> <category>accessing</category><body package="LDAP">getType	^ self class type: 'PrintableString'</body></methods><methods><class-id>Net.BERPrintableString</class-id> <category>printing</category><body package="LDAP">toString	mValue isNil		ifTrue: [^ 'PrintableString {}'].	^ 'PrintableString {', mValue, '}'</body></methods><methods><class-id>Net.BERIntegral</class-id> <category>input-output</category><body package="LDAP">writeOn: outStream	"Writes BER to stream.	 Answer number of bytes written to stream."	| binaryValue numContentOctets offset lead idx contentOctets netOctets continue |	binaryValue := self value.	numContentOctets := 0.	offset := 2.	contentOctets := ByteArray new: 10.		"Should be plenty big"	netOctets := ByteArray new: 10.			"Need this in network order"	continue := true.	self value = 0		ifTrue: [numContentOctets := 1.			    contentOctets at: offset put: 0.			    netOctets at: offset put: 0]		ifFalse: [self value &lt; 0				"Convert from two's complement"					ifTrue: [binaryValue := (self value negated) - 1].				[continue]					whileTrue: [						self value &lt; 0							ifTrue: [contentOctets 										at: (numContentOctets + offset)										put: ((binaryValue bitXor: 255) bitAnd: 255)]							ifFalse: [contentOctets										at: (numContentOctets + offset)										put: (binaryValue bitAnd: 255)].						binaryValue := binaryValue bitShift: -8.						numContentOctets := numContentOctets + 1.						continue := binaryValue &gt; 0].				"String created in non-network order.  Flip to network order."				idx := 0.				[idx &lt; numContentOctets]					whileTrue: [						netOctets at: (offset + numContentOctets - 1 - idx)								   put: (contentOctets at: (offset + idx)).						idx := idx + 1].				"If +ve value encoded and leading encoding bit is set, stuff in a leading zero byte"				lead := netOctets at: offset.				((self value &gt; 0) &amp; ((lead bitAnd: 128) &gt; 0))					ifTrue: [offset := 1.						    netOctets at: offset put: 0.						    numContentOctets := numContentOctets + 1]].	outStream nextPut: self getType.	self class sendDefiniteLengthOn: outStream numberOfOctets: numContentOctets.	outStream nextPutAll: (netOctets copyFrom: offset to: (offset + numContentOctets - 1)).	^ numContentOctets</body></methods><methods><class-id>Net.BERIntegral</class-id> <category>accessing</category><body package="LDAP">getValue	^ self value</body><body package="LDAP">value	^ mValue</body><body package="LDAP">value: anInteger	mValue := anInteger</body></methods><methods><class-id>Net.BERIntegral</class-id> <category>initialize-release</category><body package="LDAP">initialize	super initialize.	mValue := 0</body></methods><methods><class-id>Net.BERIntegral class</class-id> <category>instance creation</category><body package="LDAP">newFrom: inStream bytesRead: anArray	"Reads a new instance from input stream.	anArray includes 1 integer representing the number of bytes read from input stream.	Answers new instance."	| contentsLength negative octet bytesRead idx value |	contentsLength := self readLengthOctetsFrom: inStream bytesRead: anArray.	bytesRead := anArray at: 1.	value := 0.	"Definite length content octets string"	contentsLength &gt; 0		ifTrue: [negative := false.			    octet := inStream next.			    bytesRead := bytesRead + 1.			    (octet bitAnd: 128) &gt; 0			"Left-most bit is 1"					ifTrue: [negative := true].			    idx := 0.			    [idx &lt; contentsLength]					whileTrue: [						idx &gt; 0							ifTrue: [octet := inStream next.								    bytesRead := bytesRead + 1].						negative							ifTrue: [value := (value bitShift: 8) + ((octet bitXor: 255) bitAnd: 255)]							ifFalse: [value := (value bitShift: 8) + (octet bitAnd: 255)].						idx := idx + 1].			    negative					ifTrue: [value := (value + 1) negated]].	anArray at: 1 put: bytesRead.	^ self newForValue: value</body></methods><methods><class-id>Net.JDAPFilterAva</class-id> <category>accessing</category><body package="LDAP">ava	^ mAva</body><body package="LDAP">ava: aJDAPAva	mAva := aJDAPAva</body><body package="LDAP">tag	^ mTag</body><body package="LDAP">tag: anInteger	mTag := anInteger</body></methods><methods><class-id>Net.JDAPFilterAva</class-id> <category>printing</category><body package="LDAP">toString	^ self class name, ' {', self ava toString, '}'</body></methods><methods><class-id>Net.JDAPFilterAva</class-id> <category>encoding</category><body package="LDAP">getBERElement	^ BERTag newWithTag: self tag element: self ava getBERElement implicit: true.</body></methods><methods><class-id>Net.JDAPFilterAva</class-id> <category>initialize-release</category><body package="LDAP">initialize	super initialize.	mAva := JDAPAva new.	mTag := 0.</body></methods><methods><class-id>Net.JDAPFilterAva class</class-id> <category>instance creation</category><body package="LDAP">newForTag: anInt ava: aJDAPAva	| instance |	instance := self new.	instance tag: anInt.	instance ava: aJDAPAva.	^ instance</body></methods><methods><class-id>Net.JDAPFilterApproxMatch class</class-id> <category>instance creation</category><body package="LDAP">newForAva: aJDAPAva	| tag |	tag := ((BERElement tag: 'Constructed') bitOr: (BERElement tag: 'Context')) bitOr: 8.	^ self newForTag: tag ava: aJDAPAva</body></methods><methods><class-id>Net.LDAPConnThread</class-id> <category>initialize-release</category><body package="LDAP">cleanUp	"Clean up tasks before shutting down this thread"	| registered2 |	mServerStream ifNotNil: [		mServerStream close.		mServerStream := nil].	self disconnected: true.	self stopProcess.	registered2 := self registered copy.	registered2 do: [:aConnection | aConnection deregisterConnection].	self clearRegistered.	self clearMessages.	self clearRequests.</body><body package="LDAP">clearMessages	mMessages := Dictionary new</body><body package="LDAP">clearRegistered	mRegistered := OrderedCollection new</body><body package="LDAP">clearRequests	mRequests := Dictionary new</body><body package="LDAP">initialize	mHighMsgId := 0.	mRequests := Dictionary new.	mMessages := Dictionary new.	mRegistered := OrderedCollection new.	mDisconnected := false.	mMaxBacklog := 100.	lock := RecursionLock new.	backlogSemaphore := Semaphore new.	^ self</body><body package="LDAP">newForHost: hostString port: portInteger 	"Constructs a connection thread that maintains its connection to the LDAP server."	self connectTo: hostString port: portInteger.	self startProcess</body><body package="LDAP">startProcess	process := [self run ] fork. 	process name: 'LDAPConnThread run'.</body><body package="LDAP">stopProcess	process ifNotNil: [ 		process terminate.		process := nil ].</body></methods><methods><class-id>Net.LDAPConnThread</class-id> <category>accessing</category><body package="LDAP">addRegistered: anLDAPConnection	self registered add: anLDAPConnection</body><body package="LDAP">allocateId	mHighMsgId := (mHighMsgId + 1) rem: self class maxMsgId.	^ mHighMsgId</body><body package="LDAP">backlogSemaphore	^ backlogSemaphore</body><body package="LDAP">clientCount	^ self registered size</body><body package="LDAP">disconnected	^ mDisconnected</body><body package="LDAP">disconnected: aBoolean	mDisconnected := aBoolean</body><body package="LDAP">highMsgId	^ mHighMsgId</body><body package="LDAP">maxBacklog	^ mMaxBacklog</body><body package="LDAP">maxBacklog: anInteger	mMaxBacklog := anInteger</body><body package="LDAP">messages	^ mMessages</body><body package="LDAP">registered	^ mRegistered</body><body package="LDAP">requests	^ mRequests</body><body package="LDAP">securityLayer	^ mSecurityLayer</body><body package="LDAP">securityLayer: anObject	^ mSecurityLayer := anObject</body><body package="LDAP">serverStream	^ mServerStream</body><body package="LDAP">serverStream: anExternalReadAppendStream	mServerStream := anExternalReadAppendStream</body></methods><methods><class-id>Net.LDAPConnThread</class-id> <category>processing</category><body package="LDAP">abandon: aMessageId	"Stop dispatching responses for a particular message with the given identifier"	self requests removeKey: aMessageId ifAbsent: []</body><body package="LDAP">checkBacklog	"Sleep if there is a backlog of search results"	| doWait |	doWait := true.	[doWait]		whileTrue: [doWait := false.				    self requests keys do: [:aListener |						(aListener isKindOf: LDAPSearchListener)							ifTrue: [(aListener constraints batchSize ~= 0) &amp;								     (aListener getCount &gt;= self maxBacklog)										ifTrue: [doWait := true]]].					doWait						ifTrue: [self backlogSemaphore wait]]</body><body package="LDAP">checkControls: aJDAPMessage	| con jc |	aJDAPMessage isNil		ifTrue: [^ nil].	jc := aJDAPMessage controls.	con := OrderedCollection new.	(jc isNil or: [jc size = 0])		ifFalse: [con := OrderedCollection new: jc size.				jc do: [:each |					con add: (LDAPControl newFromOid: each getID 										critical: each criticality 										value: each getValue)]].	^ con</body><body package="LDAP">constructLDAPEntry: aJDAPMessage	"Construct an LDAPEntry from aJDAPMessage and answer it."	| op lattrs attrs dn |	op := aJDAPMessage protocolOp.		"An instance of JDAPSearchResponse"	lattrs := op attributes.	(lattrs isNil or: [lattrs size = 0])		ifTrue: [attrs := LDAPAttributeSet new]		ifFalse: [attrs := LDAPAttributeSet newFromAttributes: lattrs].	dn := op objectName.	^ LDAPEntry newWithName: dn attributeSet: attrs</body><body package="LDAP">processResponse: msg approxSize: sizeInt 	"This method processes a response JDAPMessage msg.  It will pass the message on to the listener associated with the original request, which is identified by the message identifier.  By placing the response in the listener object's shared queue, the waiting listener process will unblock and application execution will continue."	| messageId listener controls responseControl op key fail |	lock critical: 			[messageId := msg msgId.			"If the ExtendedResponse contains a resultCode other than success, this indicates that the server is unwilling or unable to negotiate TLS. If the server does not support TLS (whether by design or by current configuration), it MUST set the resultCode to protocolErrorhttps://tools.ietf.org/html/rfc4511#section-4.14.1"			(messageId = 0				and: [ (msg protocolOp isKindOf: JDAPExtendedResponse) 					and: [msg protocolOp resultCode ~= 0 ]])				ifTrue: [^self error: msg protocolOp class name, ' Error: ', msg protocolOp resultCode printString, ' ', msg protocolOp errorMessage ].			listener := self requests 						at: messageId 						ifAbsent: [Transcript cr; show: 'No listener waiting for response.';cr. ^nil].				controls := self checkControls: msg.			(controls isNil or: [controls size = 0]) 				ifTrue: 					[responseControl := ResponseControl 								newForConnection: listener connection								messageId: messageId								controls: controls].			listener connection responseControls: responseControl from: self.			op := msg protocolOp.			(op isKindOf: JDAPSearchResponse) 				| (op isKindOf: JDAPSearchResultReference) 					ifTrue: [listener addSearchResult: msg]					ifFalse: 						[listener queue nextPut: msg.	"Wake up listener"						"If this was an unsuccessful search, add message as result, since the listener"						"in this case is waiting on a result semaphore instead of checking response queue."						(op isKindOf: JDAPSearchResult) 							ifTrue: [op resultCode &gt; 0 ifTrue: [listener addSearchResult: msg]].						(listener isKindOf: LDAPSearchListener) 							ifTrue: 								[key := listener key.								key notNil 									ifTrue: 										[fail := false.										(op isKindOf: JDAPSearchResult) 											ifTrue: [op resultCode &gt; 0 ifTrue: [fail := true]]]].						self requests removeKey: messageId ifAbsent: []]]</body><body package="LDAP">run	"Reads incoming LDAP messages from the LDAP server stream"	| msg decoder element nRead |	decoder := JDAPBERTagDecoder new.	[self disconnected] 		whileFalse: 			[Processor activeProcess yield.			nRead := Array with: 0.			self checkBacklog.						[element := self disconnected 						ifTrue: ["I have seen this; maybe #yield gave another process the chance to disconnect"]						ifFalse: [BERElement getElementFrom: self serverStream decoder: decoder bytesRead: nRead].			element notNil 				ifTrue: 					[msg := JDAPMessage newFromBERElement: element.					self processResponse: msg approxSize: nRead first]] 					on: Error					do: 						[:ex | 						(MessageNotUnderstood handles: ex) ifTrue: [ex pass].						Transcript show: ('Exception in LDAPConnThread&gt;&gt;run : &lt;1s&gt;&lt;n&gt;' expandMacrosWith: ex description).						self disconnected ifFalse: [							self disconnected: true.							self networkError: ex]]]</body><body package="LDAP">sendRequest: aJDAPProtocolOp notify: anLDAPResponseListener constraints: anLDAPSearchConstraints	| msg lc jc |lock critical: [	self serverStream isNil		ifTrue: [^(LDAPException newForResultCode: 80) raiseSignal: 'Not connected to server.'].	lc := anLDAPSearchConstraints serverControls.	(lc notNil and: [lc size &gt; 0])		ifTrue: [jc := OrderedCollection new: lc size.			    lc do: [:anLC |			   	 jc add: (JDAPControl newOfType: anLC id criticality: anLC isCritical vals: anLC value)].				msg := JDAPMessage newWithMessageId: self allocateId protocolOp: aJDAPProtocolOp controls: jc]		ifFalse: [msg := JDAPMessage newWithMessageId: self allocateId protocolOp: aJDAPProtocolOp].	anLDAPResponseListener notNil		ifTrue: [ "Only concerned with notification if a response is expected"				(aJDAPProtocolOp isKindOf: JDAPAbandonRequest) |			      (aJDAPProtocolOp isKindOf: JDAPUnbindRequest)					ifFalse: [self requests at: msg msgId put: anLDAPResponseListener].				anLDAPResponseListener id: msg msgId].	[msg writeOn: self serverStream.	self serverStream flush]		on: Error		do: [:ex | self networkError: ex]]</body></methods><methods><class-id>Net.LDAPConnThread</class-id> <category>notification</category><body package="LDAP">deregister: anLDAPConnection	"Deregister with this connection thread.  If all connections have deregistered this thread should be killed."	| cons |lock critical: [	self registered remove: anLDAPConnection ifAbsent: [].	self getClientCount = 0		ifTrue: [[cons := anLDAPConnection getSearchConstraints.				self sendRequest: JDAPUnbindRequest new notify: nil constraints: cons.				self cleanUp.				"self stop."				(Delay forMilliseconds: 100) wait]		"Give threads time to shutdown"					on: Exception					do: [:ex | LDAPConnection printDebug: ex description]]]</body><body package="LDAP">getClientCount	"Answer the number of clients (LDAPConnection) using this channel."	^lock critical: [self registered size]</body><body package="LDAP">register: anLDAPConnection	"Register with this connection thread"lock critical: [	(self registered includes: anLDAPConnection)		ifFalse: [self addRegistered: anLDAPConnection]]</body><body package="LDAP">resultRetrieved	"This is invoked when a search result has been retrieved from the incoming queue.  This notification will unblock the this thread if it is waiting for the backlog to diminish."lock critical: [	backlogSemaphore signal]</body></methods><methods><class-id>Net.LDAPConnThread</class-id> <category>exception handling</category><body package="LDAP">networkError: anException	"Handle network errors.  Shut down the whole connection."	| tRequests registerCopy |lock critical: [	[tRequests := self requests values.	tRequests do: [:each |		each exception: (LDAPException newForResultCode: 81)]]			on: Exception			do: [:ex | Transcript show: 'Exception: ', ex description; cr].	"Notify all registered connections that the thread is shutting down."	registerCopy := self registered copy.	registerCopy do: [:each |		each deregisterConnection]]</body></methods><methods><class-id>Net.LDAPConnThread</class-id> <category>connecting</category><body package="LDAP">connectTo: hostString port: portInteger 	"Constructs a connection thread that maintains its connection to the LDAP server."	| exhaustedAllChoices |    exhaustedAllChoices := false.     [    (IPSocketAddress tcpAddressesForHost: hostString port: portInteger)             detect: [ :info |                 [    socket := info asSocketAccessor.                     [ socket connectTo: info address ] ifCurtailed: [ socket close ].                     true                 ] on: OsError do: [ :ex | false ] ]             ifNone: [ exhaustedAllChoices := true ]     ]    onTimeout: self class defaultTimeout milliseconds         do: [ OSErrorHolder operationStartedSignal raiseSignal ].     exhaustedAllChoices ifTrue: [OsInaccessibleError raiseSignal].   mServerStream := ( socket asExternalConnection withEncoding: #default ) readAppendStream       	lineEndConvention: LineEndTransparent;		binary.</body></methods><methods><class-id>Net.LDAPConnThread class</class-id> <category>constants</category><body package="LDAP">defaultTimeoutValue	"Milliseconds"	^20000</body><body package="LDAP">maxMsgId	^ SmallInteger maxVal</body></methods><methods><class-id>Net.LDAPConnThread class</class-id> <category>instance creation</category><body package="LDAP">new	^ self basicNew initialize</body><body package="LDAP">newForHost: hostString port: portInteger 	"Constructs a connection thread that maintains its connection to the LDAP server."	^self new		newForHost: hostString port: portInteger</body></methods><methods><class-id>Net.LDAPConnThread class</class-id> <category>accessing</category><body package="LDAP">defaultTimeout	^defaultTimeout ifNil: [ defaultTimeout := self defaultTimeoutValue ]</body><body package="LDAP">defaultTimeout: anInteger	"Milliseconds"	defaultTimeout := anInteger</body></methods><methods><class-id>Net.JDAPFilterSubString</class-id> <category>encoding</category><body package="LDAP">getBERElement	| seq strSeq tag element |	seq := BERSequence new.	seq addElement: (BEROctetString newFromString: self type).	strSeq := BERSequence new.	self initial do: [:each |		each size &gt; 0			ifTrue: [tag := (BERElement tag: 'Context') bitOr: 0.				    strSeq addElement: (BERTag											newWithTag: tag											element: (JDAPFilterOpers getOctetString: each)											implicit: true)]].	self any do: [:each |		each size &gt; 0			ifTrue: [tag := (BERElement tag: 'Context') bitOr: 1.				    strSeq addElement: (BERTag											newWithTag: tag											element: (JDAPFilterOpers getOctetString: each)											implicit: true)]].	self final do: [:each |		each size &gt; 0			ifTrue: [tag := (BERElement tag: 'Context') bitOr: 2.				    strSeq addElement: (BERTag											newWithTag: tag											element: (JDAPFilterOpers getOctetString: each)											implicit: true)]].	seq addElement: strSeq.	tag := ((BERElement tag: 'Constructed') bitOr: (BERElement tag: 'Context')) bitOr: 4.	element := BERTag					newWithTag: tag					element: seq					implicit: true.	^ element</body></methods><methods><class-id>Net.JDAPFilterSubString</class-id> <category>accessing</category><body package="LDAP">addAny: aString	mAny add: aString</body><body package="LDAP">addFinal: aString	mFinal add: aString</body><body package="LDAP">addInitial: aString	mInitial add: aString</body><body package="LDAP">any	^ mAny</body><body package="LDAP">final	^ mFinal</body><body package="LDAP">initial	^ mInitial</body><body package="LDAP">type	^ mType</body><body package="LDAP">type: aString	mType := aString</body></methods><methods><class-id>Net.JDAPFilterSubString</class-id> <category>printing</category><body package="LDAP">getParamString	| paramStream first |	paramStream := WriteStream on: String new.	first := true.	paramStream nextPutAll: '{type='.	paramStream nextPutAll: self type.	paramStream nextPutAll: ', initial='.	self initial do: [:each |		first			ifTrue: [first := false]			ifFalse: [paramStream nextPut:$,].		paramStream nextPutAll: each].	first := true.	paramStream nextPutAll: ', any='.	self any do: [:each |		first			ifTrue: [first := false]			ifFalse: [paramStream nextPut:$,].		paramStream nextPutAll: each].	first := true.	paramStream nextPutAll: ', final='.	self final do: [:each |		first			ifTrue: [first := false]			ifFalse: [paramStream nextPut:$,].		paramStream nextPutAll: each].	paramStream nextPut: $}.	^ paramStream contents</body><body package="LDAP">toString	^ self class name, self getParamString</body></methods><methods><class-id>Net.JDAPFilterSubString</class-id> <category>initialize-release</category><body package="LDAP">initialize	super initialize.	mType := String new.	mInitial := OrderedCollection new.	mAny := OrderedCollection new.	mFinal := OrderedCollection new.</body></methods><methods><class-id>Net.JDAPFilterSubString class</class-id> <category>instance creation</category><body package="LDAP">newForType: typeString	| instance |	instance := self new.	instance type: typeString.	^ instance</body></methods><methods><class-id>Net.JDAPSearchResponse</class-id> <category>accessing</category><body package="LDAP">addAttribute: anLDAPAttribute	mAttributes add: anLDAPAttribute</body><body package="LDAP">attributes	^ mAttributes</body><body package="LDAP">element	^ mElement</body><body package="LDAP">element: aBERElement	mElement := aBERElement</body><body package="LDAP">getType	^ JDAPProtocolOp codeForOperationType: 'SEARCH_RESPONSE'</body><body package="LDAP">objectName	^ mObjectName</body><body package="LDAP">objectName: aString	mObjectName := aString</body></methods><methods><class-id>Net.JDAPSearchResponse</class-id> <category>initialize-release</category><body package="LDAP">initialize	mObjectName := String new.	mElement := BERElement new.	mAttributes := OrderedCollection new.	^ self</body></methods><methods><class-id>Net.JDAPSearchResponse</class-id> <category>printing</category><body package="LDAP">getParamString	| paramStream first |	paramStream := WriteStream on: String new.	paramStream nextPutAll: '{entry='.	paramStream nextPutAll: self objectName.	paramStream nextPutAll: ', attributes='.	first := true.	self attributes do: [:each |		first			ifTrue: [first := false]			ifFalse: [paramStream nextPut: $,].		paramStream nextPutAll: each].	paramStream nextPut: $}.	^ paramStream contents</body><body package="LDAP">toString	^ self class name, ' ', self getParamString</body></methods><methods><class-id>Net.JDAPSearchResponse class</class-id> <category>instance creation</category><body package="LDAP">new	^ self basicNew initialize</body><body package="LDAP">newFromBERTag: aBERTag	| instance tag seq objName buf attrs |	instance := self new.	instance element: aBERTag.	tag := aBERTag.	seq :=  tag getValue.	objName := seq elementAt: 1.	buf := objName getValue.	(buf isNil or: [buf size = 0])		ifTrue: [instance objectName: String new]		ifFalse: [instance objectName: (buf asStringEncoding: #UTF_8)].	attrs := seq elementAt: 2.	1 to: attrs size do: [:ndx |		instance addAttribute: (attrs elementAt: ndx)].	^ instance</body></methods><methods><class-id>Net.BERNull</class-id> <category>accessing</category><body package="LDAP">getType	^ self class type: 'Null'</body></methods><methods><class-id>Net.BERNull</class-id> <category>printing</category><body package="LDAP">toString	"Answer the string representation"	^ 'Null {}'</body></methods><methods><class-id>Net.BERNull</class-id> <category>input-output</category><body package="LDAP">writeOn: outStream	outStream nextPut: self getType.			"Write type byte"	outStream nextPut: 0					"Write length byte"</body></methods><methods><class-id>Net.BERNull class</class-id> <category>instance creation</category><body package="LDAP">newFrom: inStream bytesRead: anArray	"Constructs a new element from the input stream.	anArray contains 1 integer representing the number of bytes read from inStream."	self readLengthOctetsFrom: inStream bytesRead: anArray.	^ self new</body></methods><methods><class-id>Net.JDAPFilterEqualityMatch class</class-id> <category>instance creation</category><body package="LDAP">newForAva: aJDAPAva	| tag |	tag := ((BERElement tag: 'Constructed') bitOr: (BERElement tag: 'Context')) bitOr: 3.	^ self newForTag: tag ava: aJDAPAva</body></methods><methods><class-id>Net.LDAPRebindAuth</class-id> <category>initialize-release</category><body package="LDAP">initialize	^ self</body></methods><methods><class-id>Net.LDAPRebindAuth</class-id> <category>accessing</category><body package="LDAP">dn	^ mDN</body><body package="LDAP">dn: dnString	mDN := dnString</body><body package="LDAP">password	^ mPassword</body><body package="LDAP">password: aString	mPassword := aString</body></methods><methods><class-id>Net.LDAPRebindAuth class</class-id> <category>instance creation</category><body package="LDAP">newForDN: dnString password: passwordString	| instance |	instance := self basicNew initialize.	instance dn: dnString.	instance password: passwordString.	^ instance</body></methods><methods><class-id>Net.JDAPResult</class-id> <category>accessing</category><body package="LDAP">addReferral: aString	mReferrals add: aString</body><body package="LDAP">element	^ mElement</body><body package="LDAP">element: aBERElement	mElement := aBERElement</body><body package="LDAP">errorMessage	^ mErrorMessage</body><body package="LDAP">errorMessage: aString	mErrorMessage := aString</body><body package="LDAP">matchedDN	^ mMatchedDN</body><body package="LDAP">matchedDN: aString	mMatchedDN := aString</body><body package="LDAP">referrals	^ mReferrals</body><body package="LDAP">resultCode	^ mResultCode</body><body package="LDAP">resultCode: anInteger	mResultCode := anInteger</body></methods><methods><class-id>Net.JDAPResult</class-id> <category>initialize-release</category><body package="LDAP">initialize	mElement := String new.	mResultCode := 0.	mMatchedDN := String new.	mErrorMessage := String new.	mReferrals := OrderedCollection new.	^ self</body></methods><methods><class-id>Net.JDAPResult</class-id> <category>printing</category><body package="LDAP">getParamString	"Answers string representation of the result."	| paramStream |	paramStream := WriteStream on: String new.	paramStream nextPutAll: '{resultCode='.	paramStream nextPutAll: self resultCode.	paramStream nextPutAll: ', matchedDN='.	paramStream nextPutAll: self matchedDN.	paramStream nextPutAll: ', errorMessage='.	paramStream nextPutAll: self errorMessage.	paramStream nextPutAll: '}'.	^ paramStream contents</body><body package="LDAP">toString	^ self class name, ' ', self getParamString</body></methods><methods><class-id>Net.JDAPResult class</class-id> <category>instance creation</category><body package="LDAP">new	^ self basicNew initialize</body><body package="LDAP">newFromBERElement: aBERElement	"Result from a successful bind request."	"[*] umich-ldap-v3.3"	"	0x0a 0x07			(implicit [APPLICATION 1] OctetString)"	"	0x0a 0x01 0x00		(result code)"	"	0x04 0x00			(matched dn)"	"	0x04 0x00			(error message)"	"Referrals in ldap-v2.0"	"[*] umich-ldap-v3.3"	"	0x65 0x2a"	"	0x0a 0x01 0x09"	"	0x04 0x00"	"	0x04 0x23 	R e f e r r a l : 0x0a"	"				l d a p : / / l d a p . "	"				i t d . u m i c h . e d u "	| instance e seq buf t v |	instance := self new.	instance element: aBERElement.	seq := aBERElement.		"Possible return from [x500.arc.nasa.gov]:"		"SEQUENCE {SEQUENCE {Enumerated{2} ... }}"	e := seq elementAt: 1.	e getType = (BERElement type: 'Sequence')		ifTrue: [seq := e].	instance resultCode: (seq elementAt: 1) getValue.	buf := (seq elementAt: 2) getValue.	buf isNil		ifTrue: [instance matchedDN: String new]		ifFalse: [instance matchedDN: (buf asStringEncoding: #UTF_8)].	buf := (seq elementAt: 3) getValue.	buf isNil		ifTrue: [instance errorMessage: String new]		ifFalse: [instance errorMessage: (buf asStringEncoding: #UTF_8)].	"Extract LDAPv3 referrals"	seq size &gt;= 4		ifTrue: [t := seq elementAt: 4.			    v := t getValue.			    v getType = (BERElement type: 'Integer')					ifTrue: ["MS - [CONTEXT-5] Integer {3}"						    "To be determined"]					ifFalse: [(v isKindOf: BERSequence)								ifTrue: [1 to: v size do: [:idx |											instance addReferral: ((v elementAt: idx) asStringEncoding: #UTF_8)]]]].	^ instance</body></methods><methods><class-id>Net.JDAPResult class</class-id> <category>class initialization</category><body package="LDAP">initialize	"JDAPResult initialize" 	"Result codes are based on RFC1777"	ResultCodes := Dictionary new.   	ResultCodes at: 0 put: 'SUCCESS'.    	ResultCodes at: 1 put: 'OPERATION_ERROR'.    	ResultCodes at: 2 put: 'PROTOCOL_ERROR'.    	ResultCodes at: 3 put: 'TIME_LIMIT_EXCEEDED'.    	ResultCodes at: 4 put: 'SIZE_LIMIT_EXCEEDED'.   	ResultCodes at: 5 put: 'COMPARE_FALSE'.    	ResultCodes at: 6 put: 'COMPARE_TRUE'.    	ResultCodes at: 7 put: 'AUTH_METHOD_NOT_SUPPORTED'.    	ResultCodes at: 8 put: 'STRONG_AUTH_REQUIRED'.	"Referrals Within the LDAPv2 Protocol"    	ResultCodes at: 9 put: 'LDAP_PARTIAL_RESULTS'.    	"Added for LDAPv3 - BEGIN"    	ResultCodes at: 10 put: 'REFERRAL'.    	ResultCodes at: 11 put: 'ADMIN_LIMIT_EXCEEDED'.    	ResultCodes at: 12 put: 'UNAVAILABLE_CRITICAL_EXTENSION'.    	ResultCodes at: 13 put: 'CONFIDENTIALITY_REQUIRED'.    	ResultCodes at: 14 put: 'SASL_BIND_IN_PROGRESS'.   	"Added for LDAPv3 - END"    	ResultCodes at: 16 put: 'NO_SUCH_ATTRIBUTE'.    	ResultCodes at: 17 put: 'UNDEFINED_ATTRIBUTE_TYPE'.    	ResultCodes at: 18 put: 'INAPPROPRIATE_MATCHING'.    	ResultCodes at: 19 put: 'CONSTRAINT_VIOLATION'.    	ResultCodes at: 20 put: 'ATTRIBUTE_OR_VALUE_EXISTS'.    	ResultCodes at: 21 put: 'INVALID_ATTRIBUTE_SYNTAX'.    	ResultCodes at: 32 put: 'NO_SUCH_OBJECT'.    	ResultCodes at: 33 put: 'ALIAS_PROBLEM'.    	ResultCodes at: 34 put: 'INVALID_DN_SYNTAX'.    	ResultCodes at: 35 put: 'IS_LEAF'.    	ResultCodes at: 36 put: 'ALIAS_DEREFERENCING_PROBLEM'.    	ResultCodes at: 48 put: 'INAPPROPRIATE_AUTHENTICATION'.    	ResultCodes at: 49 put: 'INVALID_CREDENTIALS'.    	ResultCodes at: 50 put: 'INSUFFICIENT_ACCESS_RIGHTS'.    	ResultCodes at: 51 put: 'BUSY'.    	ResultCodes at: 52 put: 'UNAVAILABLE'.    	ResultCodes at: 53 put: 'UNWILLING_TO_PERFORM'.    	ResultCodes at: 54 put: 'LOOP_DETECT'.    	ResultCodes at: 64 put: 'NAMING_VIOLATION'.    	ResultCodes at: 65 put: 'OBJECT_CLASS_VIOLATION'.    	ResultCodes at: 66 put: 'NOT_ALLOWED_ON_NONLEAF'.    	ResultCodes at: 67 put: 'NOT_ALLOWED_ON_RDN'.    	ResultCodes at: 68 put: 'ENTRY_ALREADY_EXISTS'.    	ResultCodes at: 69 put: 'OBJECT_CLASS_MODS_PROHIBITED'.    	ResultCodes at: 71 put: 'AFFECTS_MULTIPLE_DSAS'.    	ResultCodes at: 80 put: 'OTHER'.    	ResultCodes at: 81 put: 'SERVER_DOWN'.    	ResultCodes at: 89 put: 'PARAM_ERROR'.    	ResultCodes at: 91 put: 'CONNECT_ERROR'.    	ResultCodes at: 92 put: 'LDAP_NOT_SUPPORTED'.    	ResultCodes at: 93 put: 'CONTROL_NOT_FOUND'.    	ResultCodes at: 94 put: 'NO_RESULTS_RETURNED'.    	ResultCodes at: 95 put: 'MORE_RESULTS_TO_RETURN'.    	ResultCodes at: 96 put: 'CLIENT_LOOP'.    	ResultCodes at: 97 put: 'REFERRAL_LIMIT_EXCEEDED'.</body></methods><methods><class-id>Net.JDAPResult class</class-id> <category>accessing</category><body package="LDAP">resultForCode: anInteger	^ ResultCodes at: anInteger ifAbsent: ['Unknown Result Code']</body></methods><methods><class-id>Net.JDAPDelResponse</class-id> <category>accessing</category><body package="LDAP">getType	^ JDAPProtocolOp codeForOperationType: 'DEL_RESPONSE'</body></methods><methods><class-id>Net.JDAPDelResponse class</class-id> <category>instance creation</category><body package="LDAP">newFromBERTag: aBERTag	^ self newFromBERElement: (aBERTag getValue)</body></methods><methods><class-id>Net.JDAPBaseDNRequest</class-id> <category>printing</category><body package="LDAP">getParamString	^ self subclassResponsibility</body><body package="LDAP">toString	^ self class name, ' ', self getParamString</body></methods><methods><class-id>Net.JDAPBaseDNRequest</class-id> <category>initialize-release</category><body package="LDAP">initialize	mDN := String new.	^ self</body></methods><methods><class-id>Net.JDAPBaseDNRequest</class-id> <category>accessing</category><body package="LDAP">baseDN	^ mDN</body><body package="LDAP">baseDN: aString	mDN := aString</body></methods><methods><class-id>Net.JDAPBaseDNRequest class</class-id> <category>instance creation</category><body package="LDAP">new	^ self basicNew initialize</body></methods><methods><class-id>Net.JDAPAddRequest</class-id> <category>accessing</category><body package="LDAP">addAttrs: aLDAPAttribute	mAttrs add: aLDAPAttribute</body><body package="LDAP">attrs	^ mAttrs</body><body package="LDAP">getType	^ JDAPProtocolOp codeForOperationType: 'ADD_REQUEST'</body></methods><methods><class-id>Net.JDAPAddRequest</class-id> <category>encoding</category><body package="LDAP">getBERElement	"Assume we are adding cn=patrick,o=ncware,c=ca with the following attributes: "	"	cn: patrick"	"	title: programmer"	"[*]	umich-ldap-v3.3:"	"	0x68 0x46			([APPLICATION8])"	"	0x04 0x1a	c n = p a t r i c k , 0x20 "	"				o = n c w a r e , 0x20 c = "	"				c a 		(entry - OctetString)"	"	0x30 0x28			(SEQUENCE)"	"	0x30 0x0f			(SEQUENCE)"	"	0X04 0X02	c n		(attribute type - OctetString)"	"	0x31 0x09			(SET OF)"	"	0x04 0x07	p a t r i c k  (attribute value - OctetString)"	"	0x30 0x15 "	"	0x04 0x05	t i t l e "	"	0x31 0x0c			(SET OF)"	"	0x04 0x0a	p r o g r a m m e r "	| seq attrsList element tag |	seq := BERSequence new.	seq addElement: (BEROctetString newFromString: self baseDN).	attrsList := BERSequence new.	self attrs do: [:each |		attrsList addElement: (each getBERElement)].	seq addElement: attrsList.	tag := ((BERElement tag: 'Application') bitOr: (BERElement tag: 'Constructed')) bitOr: 8.	element := BERTag newWithTag: tag element: seq implicit: true.	^ element</body></methods><methods><class-id>Net.JDAPAddRequest</class-id> <category>initialize-release</category><body package="LDAP">initialize	super initialize.	mAttrs := OrderedCollection new.	^ self</body></methods><methods><class-id>Net.JDAPAddRequest</class-id> <category>printing</category><body package="LDAP">getParamString	| paramStream first |	first := true.	paramStream := WriteStream on: String new.	paramStream nextPutAll: '{entry='.	paramStream nextPutAll: self baseDN.	paramStream nextPutAll: ', attrs='.	self attrs do: [:each |		first			ifTrue: [first := false]			ifFalse: [paramStream space].		paramStream nextPutAll: each toString].	paramStream nextPutAll: '}'.	^ paramStream contents</body></methods><methods><class-id>Net.JDAPAddRequest class</class-id> <category>instance creation</category><body package="LDAP">newWithBaseDN: aString attributes: aCollect	| instance |	instance := self new.	instance baseDN: aString.	aCollect do: [:each |		instance addAttrs: each].	^ instance</body></methods><methods><class-id>Net.JDAPSearchResult</class-id> <category>accessing</category><body package="LDAP">getType	^ JDAPProtocolOp codeForOperationType: 'SEARCH_RESULT'</body></methods><methods><class-id>Net.JDAPSearchResult class</class-id> <category>instance creation</category><body package="LDAP">newFromBERTag: aBERTag	^ self newFromBERElement: (aBERTag getValue)</body></methods><methods><class-id>Net.JDAPFilterExtensible</class-id> <category>accessing</category><body package="LDAP">tag	^ mTag</body><body package="LDAP">type	^ mType</body><body package="LDAP">type: aString	mType := aString</body><body package="LDAP">value	^ mValue</body><body package="LDAP">value: aString	mValue := aString</body></methods><methods><class-id>Net.JDAPFilterExtensible</class-id> <category>encoding</category><body package="LDAP">getBERElement	"Answers the BER encoding for the filter"	"Extended filter: [type]  [':dn'] [':'oid]':='value"	"BER:	extensibleMatch		[9] MatchingRuleAssertion"	"		MatchingRuleAssertion ::= SEQUENCE { "	"			matchingRule	[1]	MatchingRuleID OPTIONAL, "	"			type			[2]	AttributeDescription OPTIONAL, "	"			matchValue		[3]	AssertionValue, "	"			dnAttributes		[4]	BOOLEAN DEFAULT FALSE "	"			} "	| value defs colonIndex isDN oid seq tag element |	value := self value.	defs := self type.	" Need either ':dn' or ':'oid "	colonIndex := defs lastIndexOf: $:.	colonIndex = 0		ifTrue: [^ nil].	" Is it dn or oid ? "	isDN := false.	((defs size &lt; (colonIndex + 3)) 		or: [((defs copyFrom: (colonIndex + 1) to: (colonIndex + 3)) match: 'dn')])			ifTrue: [isDN := true]			ifFalse: [oid := defs copyFrom: (colonIndex + 1) to: defs size].		" Any more ? "	defs := defs copyFrom: 1 to: (colonIndex - 1).	colonIndex := defs lastIndexOf: $:.	colonIndex = 0		ifFalse: [((defs size &lt; (colonIndex + 3)) 					or: [((defs copyFrom: (colonIndex + 1) to: (colonIndex + 3)) match: 'dn')])							ifTrue: [isDN := true]							ifFalse: [oid := defs copyFrom: (colonIndex + 1) to: defs size]].		"Add the object identifier (oid) if present"	seq := BERSequence new.	oid isNil		ifFalse: [tag := (BERElement tag: 'Context') bitOr: (BERElement tag: 'MRA_Oid').				seq addElement: (BERTag 									newWithTag: tag 									element: (BEROctetString newFromString: oid) 									implicit: true)].	"Add the attribute description if present"	defs size &gt; 0		ifTrue: [tag := (BERElement tag: 'Context') bitOr: (BERElement tag: 'MRA_Type').				seq addElement: (BERTag 									newWithTag: tag 									element: (BEROctetString newFromString: defs) 									implicit: true)].	"Must have a value"	tag := (BERElement tag: 'Context') bitOr: (BERElement tag: 'MRA_Value').	seq addElement: (BERTag 						newWithTag: tag 						element: (BEROctetString newFromString: value) 						implicit: true).	"Was ':dn' specified? "	tag := (BERElement tag: 'Context') bitOr: (BERElement tag: 'MRA_DNAttrs').	seq addElement: (BERTag 						newWithTag: tag 						element: (BERBoolean newForValue: isDN) 						implicit: true).	element := BERTag newWithTag: self tag element: seq implicit: true.	^ element</body></methods><methods><class-id>Net.JDAPFilterExtensible</class-id> <category>printing</category><body package="LDAP">toString	^ self class name, ' {', self value, '}'</body></methods><methods><class-id>Net.JDAPFilterExtensible</class-id> <category>initialize-release</category><body package="LDAP">initialize	super initialize.	mTag := ((BERElement tag: 'Constructed') bitOr: (BERElement tag: 'Context')) bitOr: 9.	mType := String new.	mValue := String new.</body></methods><methods><class-id>Net.JDAPFilterExtensible class</class-id> <category>instance creation</category><body package="LDAP">newForType: typeString match: matchString	"matchString is a matching rule assertion"	| instance |	instance := self new.	instance type: typeString.	instance value: matchString.	^ instance</body></methods><methods><class-id>Net.JDAPAva</class-id> <category>initialize-release</category><body package="LDAP">initialize	mType := String new.	mVal := String new.	^ self</body></methods><methods><class-id>Net.JDAPAva</class-id> <category>accessing</category><body package="LDAP">type	^ mType</body><body package="LDAP">type: aString	mType := aString</body><body package="LDAP">value	^ mVal</body><body package="LDAP">value: aString	mVal := aString</body></methods><methods><class-id>Net.JDAPAva</class-id> <category>printing</category><body package="LDAP">getParamString	| paramStream |	paramStream := WriteStream on: String new.	paramStream nextPutAll: '{type='.	paramStream nextPutAll: self type.	paramStream nextPutAll: ', value='.	paramStream nextPutAll: self value.	paramStream nextPutAll: '}'.	^ paramStream contents</body><body package="LDAP">toString	^ 'JDAPAva ', self getParamString</body></methods><methods><class-id>Net.JDAPAva</class-id> <category>encoding</category><body package="LDAP">getBERElement	| seq |	seq := BERSequence new.	seq addElement: (BEROctetString newFromString: self type).	seq addElement: (JDAPFilterOpers getOctetString: self value).	^ seq</body></methods><methods><class-id>Net.JDAPAva class</class-id> <category>instance creation</category><body package="LDAP">new	^ self basicNew initialize</body><body package="LDAP">newForType: tString value: vString	| instance |	instance := self new.	instance type: tString.	instance value: vString.	^ instance</body></methods><methods><class-id>Net.LDAPControl</class-id> <category>copying</category><body package="LDAP">copy	| newInstance |	newInstance := self class new.	newInstance oid: mOid.	newInstance critical: mCritical.	newInstance value: (mValue copy).	^ newInstance</body></methods><methods><class-id>Net.LDAPControl</class-id> <category>accessing</category><body package="LDAP">critical	^ mCritical</body><body package="LDAP">critical: aBoolean	mCritical := aBoolean</body><body package="LDAP">oid	^ mOid</body><body package="LDAP">oid: aString	mOid := aString</body><body package="LDAP">value	^ mValue</body><body package="LDAP">value: aByteArray	mValue := aByteArray</body></methods><methods><class-id>Net.LDAPControl</class-id> <category>utilities</category><body package="LDAP">flattenBER: aBERSequence	"Create a 'flattened' BER encoding from a BERSequence, and answer it as a byte array."	| aStream bCollect bArray ndx |	bCollect := OrderedCollection new: (aBERSequence size).	aStream := WriteStream on: bCollect.	aBERSequence writeOn: aStream.	bArray := ByteArray new: aStream position.	ndx := 0.	aStream contents do: [:each |		ndx := ndx + 1.		bArray at: ndx put: each].	^ bArray</body></methods><methods><class-id>Net.LDAPControl</class-id> <category>testing</category><body package="LDAP">isCritical	^ mCritical</body></methods><methods><class-id>Net.LDAPControl</class-id> <category>initialize-release</category><body package="LDAP">initialize	mOid := String new.	mCritical := false.	mValue := ByteArray new</body></methods><methods><class-id>Net.LDAPControl class</class-id> <category>instance creation</category><body package="LDAP">new	^ self basicNew initialize</body><body package="LDAP">newFromOid: oidString critical: critBoolean value: dataByteArray	"Answers a new instance using the specified object identifier (oidString), criticality field (critBoolean), and the data to be used by the control (dataByteArray)"	| instance |	instance := self new.	instance oid: oidString.	instance critical: critBoolean.	instance value: dataByteArray.	^ instance</body></methods><methods><class-id>Net.LDAPControl class</class-id> <category>constants</category><body package="LDAP">managedSAIT	^ '2.16.840.1.113730.3.4.2'</body><body package="LDAP">pwExpired	"Password information sent back to client"	^ '2.16.840.1.113730.3.4.4'</body><body package="LDAP">pwExpiring	"Password information sent back to client"	^ '2.16.840.1.113730.3.4.5'</body></methods><methods><class-id>Net.LDAPSortControl</class-id> <category>encoding</category><body package="LDAP">createSortSpecification: keyCollect	| ber seq tag |	"Creating a sequence of sequences"	ber := BERSequence new.	"Add each sort key as a sequence"	keyCollect do: [:each |		seq := BERSequence new.		"The attribute name"		seq addElement: (BEROctetString newFromString: each key).		"Optional matching rule"		(each matchRule isNil or: [each matchRule size = 0])			ifFalse: [tag := (BERElement tag: 'Context') bitOr: 0.					seq addElement: (BERTag newWithTag: tag 												element: each matchRule 												implicit: true)].		"Optional reverse-order sort"		each reverse			ifTrue: [tag := (BERElement tag: 'Context') bitOr: 1.				    seq addElement: (BERTag newWithTag: tag												element: (BEREnumerated newForValue: LDAPSortKey reverse)												implicit: true)].		ber addElement: seq].	^ self flattenBER: ber</body></methods><methods><class-id>Net.LDAPSortControl class</class-id> <category>constants</category><body package="LDAP">sortRequest	^ '1.2.840.113556.1.4.473'</body><body package="LDAP">sortResponse	^ '1.2.840.113556.1.4.474'</body></methods><methods><class-id>Net.LDAPSortControl class</class-id> <category>input-output</category><body package="LDAP">parseResponse: controls results: resultArray	"Parse the sort response control sent by the server and retrieve the result code from the sorting operation, including the attribute that caused the sort to fail (if specified by the server).  The controls returned by the server can be obtained by using the getResponseControls method sent to an LDAPConnection object."	"This method answers the attribute which caused the sort operation to fail (or nil, if the server did not specify such an attribute).  The resultArray contains an array of integers, the first of which is the result code answered by the server."	"Result code meanings are available from the LDAPException class"	| attr sort inStream decoder nRead result t seq |	controls isNil		ifTrue: [^ nil].	sort := controls detect: [:aControl | aControl id = self sortResponse] ifNone: [nil].	sort isNil		ifTrue: [^ nil].	inStream := ReadStream on: sort value.	decoder := JDAPBERTagDecoder new.	nRead := Array with: 0.	seq := BERElement getElementFrom: inStream decoder: decoder bytesRead: nRead.	result := (seq elementAt: 1) value.	(resultArray notNil and: [resultArray size &gt; 0])		ifTrue: [resultArray at: 1 put: result].	t := seq elementAt: 2.	attr := t value asStringEncoding: #UTF_8.	^ attr</body></methods><methods><class-id>Net.LDAPSortControl class</class-id> <category>instance creation</category><body package="LDAP">newWithSortKey: anLDAPSortKey critical: criticalBoolean	"Creates sort control object with a single sorting key."	| instance keys |	instance := self newFromOid: self sortRequest critical: criticalBoolean value: ByteArray new.	keys := Array with: anLDAPSortKey.	instance value: (instance createSortSpecification: keys).	^ instance</body><body package="LDAP">newWithSortKeys: sortKeyCollection critical: criticalBoolean	"Creates sort control object with a collection of sort keys."	| instance |	instance := self newFromOid: self sortRequest critical: criticalBoolean value: ByteArray new.	instance value: (instance createSortSpecification: sortKeyCollection).	^ instance</body></methods><methods><class-id>Net.BEREnumerated</class-id> <category>printing</category><body package="LDAP">toString	^ 'Enumerated {', mValue asString, '}'</body></methods><methods><class-id>Net.BEREnumerated</class-id> <category>accessing</category><body package="LDAP">getType	^ self class type: 'Enumerated'</body></methods><methods><class-id>Net.LDAPModificationSet</class-id> <category>accessing</category><body package="LDAP">addModificationWithOperation: anInteger attribute: anLDAPAttribute	| mod |		mod := LDAPModification newWithOperation: anInteger attribute: anLDAPAttribute.	recursionLock critical:		[modifications add: mod]</body><body package="LDAP">removeModWithAttributeNamed: aString	"Removes the first modification that has an attribute whose name matches aString"	| theMod compString |	compString := aString asLowercase.	recursionLock critical:		[theMod := modifications 						detect: [:aMod | aMod attribute getName asLowercase = compString]						ifNone: [nil].		theMod isNil			ifFalse: [modifications remove: theMod]]</body><body package="LDAP">size	^ modifications size</body></methods><methods><class-id>Net.LDAPModificationSet</class-id> <category>private</category><body package="LDAP">elementAt: anIndex	^ modifications at: anIndex</body><body package="LDAP">removeElementAt: anIndex	^ modifications removeAtIndex: anIndex</body></methods><methods><class-id>Net.LDAPModificationSet</class-id> <category>initialize-release</category><body package="LDAP">initialize	modifications := OrderedCollection new.	recursionLock := RecursionLock new.	^ self</body></methods><methods><class-id>Net.LDAPModificationSet class</class-id> <category>instance creation</category><body package="LDAP">new	^ self basicNew initialize</body></methods><methods><class-id>Net.LDAPExtendedOperation</class-id> <category>accessing</category><body package="LDAP">oid	^ mOid</body><body package="LDAP">oid: aString	mOid := aString</body><body package="LDAP">vals	^ mVals</body><body package="LDAP">vals: aByteArray	mVals := aByteArray</body></methods><methods><class-id>Net.LDAPExtendedOperation</class-id> <category>initialize-release</category><body package="LDAP">initialize	mOid := String new.	mVals := ByteArray new.	^ self</body></methods><methods><class-id>Net.LDAPExtendedOperation class</class-id> <category>instance creation</category><body package="LDAP">new	^ self basicNew initialize</body><body package="LDAP">newForOid: oidString vals: valByteArray	| instance |	instance := self new.	instance oid: oidString.	instance vals: valByteArray.	^ instance</body></methods><methods><class-id>Net.JDAPAddResponse</class-id> <category>accessing</category><body package="LDAP">getType	^ JDAPProtocolOp codeForOperationType: 'ADD_RESPONSE'</body></methods><methods><class-id>Net.JDAPAddResponse class</class-id> <category>instance creation</category><body package="LDAP">newFromBERTag: aBERTag	^ self newFromBERElement: (aBERTag getValue)</body></methods><methods><class-id>Net.LDAPException</class-id> <category>accessing</category><body package="LDAP">resultCode	^ resultCode</body><body package="LDAP">resultCode: anInteger	resultCode := anInteger</body></methods><methods><class-id>Net.LDAPException</class-id> <category>printing</category><body package="LDAP">description	| errorStream |	self resultCode isNil ifTrue: [ ^ super description ].	errorStream := WriteStream on: String new.	errorStream nextPutAll: 'LDAP Error Code '. 	errorStream nextPutAll: self resultCode printString.	errorStream nextPutAll: ': '.	errorStream nextPutAll: (self class errorMessageFor: self resultCode).	^ errorStream contents</body><body package="LDAP">toString	^ self description</body></methods><methods><class-id>Net.LDAPException class</class-id> <category>instance creation</category><body package="LDAP">newForResultCode: anInteger	| instance |	instance := self new.	instance resultCode: anInteger.	^ instance</body></methods><methods><class-id>Net.LDAPException class</class-id> <category>accessing</category><body package="LDAP">errorMessageFor: anInteger	^ LDAPResultCodes 		at: anInteger 		ifAbsent: ['Unknown: An unknown error code was returned.']</body></methods><methods><class-id>Net.LDAPException class</class-id> <category>class initialization</category><body package="LDAP">initialize	"LDAPException initialize"	LDAPResultCodes := Dictionary new.		LDAPResultCodes at: 0 put: 'Success: The operation completed successfully.'.	LDAPResultCodes at: 1 put: 'Operation Error: An internal error occurred in the LDAP server.'.	LDAPResultCodes at: 2 put: 'Protocol Error: A LDAP server could not correctly interpret the request sent by the client because the request does not strictly comply with the LDAP protocol.  (For example, the data was not correctly BER-encoded, or a specified value -- such as the search scope or modification type -- does not comply with the LDAP protocol.  If you invent your own search scope, for instance, this result code might be returned.'.	LDAPResultCodes at: 3 put: 'Time Limit Exceeded: The search operation could not be completed within the maximum time limit.  You can specify the maximum time limit by calling the LDAPConnection setOption:value: method, or by calling the LDAPSearchConstraints timeLimit: method.'.	LDAPResultCodes at: 4 put: 'Size Limit Exceeded: The search found more than the maximum number of results.  You can specifiy the maximum number of results by calling the LDAPConnection setOption:value: method, or by calling the LDAPSearchConstraints maxRes: method.'.	LDAPResultCodes at: 5 put: 'Compare False: Value returned by an LDAP compare operation if the specified attribute and value is not found in the entry (no matching value found).'.	LDAPResultCodes at: 6 put: 'Compare True: Value returned by an LDAP compare operation if the specified attribute and value is  found in the entry (matching value found).'.	LDAPResultCodes at: 7 put: 'Auth Method Not Supported: The specified authentication method is not supported by the LDAP server that is being connected to.'.	LDAPResultCodes at: 8 put: 'Strong Auth Required: A stronger authentication method (more than LDAP authentication simple) is required by the LDAP server being connected to.'.	LDAPResultCodes at: 9 put: 'LDAP Partial Results: An error has occured during the referral process in of the search.  The search was referred to another server, and an error occurred after that referral.'.	LDAPResultCodes at: 10 put: 'Referral: The server does not hold the requested entry.  The referral field of the server response contains a reference to another server or set of servers.  Typically, these references are LDAP URLs that identify the server that may contain the requested entry.  When this occurs, an LDAPException with this code is raised.  The application can handle this exception to undertake the search on the referenced server.'.	LDAPResultCodes at: 11 put: 'Admin Limit Exceeded: The administrative limit on the maximum number of entries to return was exceeded (look through limit for the server).  This is the maximum number of entries that the server will check when determining which entries match the search filter and scope.'.	LDAPResultCodes at: 12 put: 'Unavailable Critical Extension: The server received an LDAPv3 control that is marked critical and either (1) is not recognized or supported by the server, or (2) is inappropriate for the operation requested.  The Netscape Directory Server 3.0 also returns this result code if the client specifies a matching rule that is not supported by the server.'.	LDAPResultCodes at: 13 put: 'Confidentiality Required: A secure connection is required for this operation.'.	LDAPResultCodes at: 14 put: 'SASL Bind In Progress: While authenticating the client by using a SASL mechanism, the server requires the client to send a new SASL bind request (specifying the same SASL mechanism) to continue the authentication process.'.	LDAPResultCodes at: 16 put: 'No Such Attribute: The specified attribute could not be found.'.	LDAPResultCodes at: 17 put: 'Undefined Attribute Type: The specified attribute type is not defined.'.	LDAPResultCodes at: 18 put: 'Inappropriate Matching: An inappropriate type of matching was used.'.	LDAPResultCodes at: 19 put: 'Constraint Violation: An internal error occurred in the LDAP server.'.	LDAPResultCodes at: 20 put: 'Attribute Or Value Exists: The value being added to an attribute already exists in the attribute.'.	LDAPResultCodes at: 21 put: 'Invalid Attribute Syntax: The request contains invalid syntax.'.	LDAPResultCodes at: 32 put: 'No Such Object: The entry specified in the request does not exist.'.	LDAPResultCodes at: 33 put: 'Alias Problem: A problem occurred with an alias.'.	LDAPResultCodes at: 34 put: 'Invalid DN Syntax: The specified distinguished name (DN) uses invalid syntax.'.	LDAPResultCodes at: 35 put: 'Is Leaf: The specified entry is a "leaf" entry (it has no entries beneath it in the directory tree).'.	LDAPResultCodes at: 36 put: 'Alias Dereferencing Problem: An error occurred when dereferencing an alias.'.	LDAPResultCodes at: 48 put: 'Inappropriate Authentication: The authentication presented to the server is inappropriate.  The result code might occur, for example, if the client presents a password and the corresponding entry has not user password attribute.'.	LDAPResultCodes at: 49 put: 'Invalid Credentials: The credentials presented to the server for authentication are not valid.  (For example, the password sent to the server does not match the user password in the directory.'.	LDAPResultCodes at: 50 put: 'Insufficient Access Rights: The client is authenticated as a user who does not have the access privileges to perform this operation.'.	LDAPResultCodes at: 51 put: 'Busy: The LDAP server is busy.'.	LDAPResultCodes at: 52 put: 'Unavailable: The LDAP server is unavailable.'.	LDAPResultCodes at: 53 put: 'Unwilling To Perform: The LDAP server is unable to perform the specified operation.'.	LDAPResultCodes at: 54 put: 'Loop Detect: A loop has been detected.'.	LDAPResultCodes at: 60 put: 'Sort Control Missing: The "server-side sorting" control was not included with the "virtual list view" control in the serach request.'.	LDAPResultCodes at: 61 put: 'Index Range Error: An index range error occurred.'.	LDAPResultCodes at: 64 put: 'Naming Violation: A naming violation has occurred.'.	LDAPResultCodes at: 65 put: 'Object Class Violation: The requested operation will add or change data so that the data no longer complies with the schema.'.	LDAPResultCodes at: 66 put: 'Not Allowed On Non-Leaf: The requested operation can only be performed on an entry that has no entries beneath it in the directory tree (in other words, a "leaf" entry).  For example, an entry cannot be deleted or renamed if it has subentries beneath it.'.	LDAPResultCodes at: 67 put: 'Not Allowed On RDN: The specified operation cannot be performed on a relative distinguished name (RDN).'.	LDAPResultCodes at: 68 put: 'Entry Already Exists: The specified entry already exists.  This error might be received if attempting to add an entry that already exists, or if attempting to change the name of an entry to the same name as an entry that already exists.'.	LDAPResultCodes at: 69 put: 'Object Class Mods Prohibited: The specified object class cannot be modified.'.	LDAPResultCodes at: 71 put: 'Affects Multiple DSAS: The client attempted to move an entry from one LDAP server to another by requesting a "modify DN" operation.  In general, clients should not be able to arbitrarily move entries and subtrees between servers.'.	LDAPResultCodes at: 80 put: 'Other: General result code for other types of errors that may occur.'.	LDAPResultCodes at: 81 put: 'Server Down: The LDAP server cannot be contacted.'.	LDAPResultCodes at: 89 put: 'Param Error: When calling a constructor or method from the client, one or more parameters were incorrectly specified.'.	LDAPResultCodes at: 91 put: 'Connect Error: The client failed to connect to the LDAP server.'.	LDAPResultCodes at: 92 put: 'LDAP Not Supported: The request is not supported by this version of the LDAP protocol.'.	LDAPResultCodes at: 93 put: 'Control Not Found: The requested control is not found.'.	LDAPResultCodes at: 94 put: 'No Results Returned: No results have been returned from the server.'.	LDAPResultCodes at: 95 put: 'More Results To Return: More results are being returned by the server.'.	LDAPResultCodes at: 96 put: 'Client Loop: The LDAP client detected a loop in the referral.'.	LDAPResultCodes at: 97 put: 'Referral Limit Exceeded: The number of sequential referrals has exceeded the maximum number of referrals (the LDAPv2 referralsHopLimit option).'.</body></methods><methods><class-id>Net.JDAPFilterNot</class-id> <category>accessing</category><body package="LDAP">filter	^ mFilter</body><body package="LDAP">filter: aJDAPFilter	mFilter := aJDAPFilter</body></methods><methods><class-id>Net.JDAPFilterNot</class-id> <category>encoding</category><body package="LDAP">getBERElement	| tag |	tag := ((BERElement tag: 'Constructed') bitOr: (BERElement tag: 'Context')) bitOr: 2.	^ BERTag		newWithTag: tag		element: self filter getBERElement		implicit: false</body></methods><methods><class-id>Net.JDAPFilterNot</class-id> <category>printing</category><body package="LDAP">toString	^ self class name, ' {', self filter toString, '}'</body></methods><methods><class-id>Net.JDAPFilterNot class</class-id> <category>instance creation</category><body package="LDAP">newForFilter: aJDAPFilter	| instance |	instance := self new.	instance filter: aJDAPFilter.	^ instance</body></methods><methods><class-id>Net.ResponseControl</class-id> <category>accessing</category><body package="LDAP">addControl: anLDAPControl	mControls add: anLDAPControl</body><body package="LDAP">connection	^ mConnection</body><body package="LDAP">connection: anLDAPConnection	mConnection := anLDAPConnection</body><body package="LDAP">controls	^ mControls</body><body package="LDAP">messageId	^ mMessageId</body><body package="LDAP">messageId: anInteger	mMessageId := anInteger</body></methods><methods><class-id>Net.ResponseControl</class-id> <category>initialize-release</category><body package="LDAP">initialize	mControls := OrderedCollection new.	mMessageId := 0.	^ self</body></methods><methods><class-id>Net.ResponseControl class</class-id> <category>instance creation</category><body package="LDAP">new	^ self basicNew initialize</body><body package="LDAP">newForConnection: anLDAPConnection messageId: msgInteger controls: controlCollection	| instance |	instance := self new.	instance connection: anLDAPConnection.	instance messageId: msgInteger.	controlCollection do: [:each |		instance addControl: each].	^ instance</body></methods><methods><class-id>Net.LDAPVirtualListControl</class-id> <category>accessing</category><body package="LDAP">afterCount	^ mAfterCount</body><body package="LDAP">afterCount: anInteger	mAfterCount := anInteger</body><body package="LDAP">beforeCount	^ mBeforeCount</body><body package="LDAP">beforeCount: anInteger	mBeforeCount := anInteger</body><body package="LDAP">index	^ self listIndex</body><body package="LDAP">listIndex	^ mListIndex</body><body package="LDAP">listIndex: anInteger	mListIndex := anInteger</body><body package="LDAP">listSize	^ mListSize</body><body package="LDAP">listSize: anInteger	mListSize := anInteger</body></methods><methods><class-id>Net.LDAPVirtualListControl</class-id> <category>encoding</category><body package="LDAP">createPageSpecification: jumpString before: bCount after: aCount	"Creates a flattened BER encoding of the requested page specifications and answers it as a byte array."	| seq tag |	seq := BERSequence new.	seq addElement: (BERInteger newForValue: bCount).	seq addElement: (BERInteger newForValue: aCount).	tag := (BERElement tag: 'Context') bitOr: self class tagByFilter.	seq addElement: (BERTag newWithTag: tag								element: (BEROctetString newFromString: jumpString)								implicit: true).	^ self flattenBER: seq</body><body package="LDAP">createPageSpecificationIndex: lIndex size: lSize before: bCount after: aCount	"Creates a flattened BER encoding of the requested page specifications and answers it as a byte array."	| seq tag indexSeq |	seq := BERSequence new.	seq addElement: (BERInteger newForValue: bCount).	seq addElement: (BERInteger newForValue: aCount).	indexSeq := BERSequence new.	indexSeq addElement: (BERInteger newForValue: lIndex).	indexSeq addElement: (BERInteger newForValue: lSize).	tag := ((BERElement tag: 'Context') bitOr: (BERElement tag: 'Constructed')) bitOr: self class tagByIndex.	seq addElement: (BERTag newWithTag: tag								element: indexSeq								implicit: true).	^ self flattenBER: seq</body></methods><methods><class-id>Net.LDAPVirtualListControl</class-id> <category>initialize-release</category><body package="LDAP">initialize	super initialize.	mListSize := 0.	mListIndex := 0.	mBeforeCount := 0.	mAfterCount := 0.</body><body package="LDAP">setRange: jumpString before: beforeInteger after: afterInteger	self beforeCount: beforeInteger.	self afterCount: afterInteger.	self value: (self createPageSpecification: jumpString						before: self beforeCount						after: self afterCount)</body><body package="LDAP">setRangeIndex: startInteger before: beforeInteger after: afterInteger	self beforeCount: beforeInteger.	self afterCount: afterInteger.	self listIndex: startInteger.	self value: (self createPageSpecificationIndex: self listIndex						size: self listSize						before: self beforeCount						after: self afterCount)</body></methods><methods><class-id>Net.LDAPVirtualListControl class</class-id> <category>constants</category><body package="LDAP">tagByFilter	^ 1</body><body package="LDAP">tagByIndex	^ 0</body><body package="LDAP">virtualList	^ '2.16.840.1.113730.3.4.9'</body></methods><methods><class-id>Net.LDAPVirtualListControl class</class-id> <category>instance creation</category><body package="LDAP">new	^ self newFromOid: self virtualList critical: true value: ByteArray new</body><body package="LDAP">newForJumpTo: jumpToString beforeCount: beforeInteger afterCount: afterInteger	"Constructs a new LDAPVirtualListControl object.  Use this method on an initial search operation, specifying the first entry to be matched, or the initial part of it.  jumpToString contains an LDAP search expression defining the result set.  beforeInteger and afterInteger are the number of results before and after the top/center to return per page."	| instance |	instance := self new.	instance setRange: jumpToString before: beforeInteger after: afterInteger.	^ instance</body><body package="LDAP">newForStart: startInteger beforeCount: beforeInteger afterCount: afterInteger contentCount: contentInteger	"Constructs a new LDAPVirtualListControl object.  Use this method on a subsequent search operation, after the size of the virtual list is known in order to fetch a subset.  startInteger is the index into the virtual list of an entry to return.  beforeInteger and afterInteger are the number of results before and after the top/center to return per page."	| instance |	instance := self new.	instance listSize: contentInteger.	instance setRangeIndex: startInteger before: beforeInteger after: afterInteger.	^ instance</body></methods><methods><class-id>Net.Base64MimeConverter</class-id> <category>accessing</category><body package="LDAP">dataStream	^dataStream</body><body package="LDAP">dataStream: anObject	dataStream := anObject</body><body package="LDAP">mimeStream	^mimeStream</body><body package="LDAP">mimeStream: anObject	mimeStream := anObject</body></methods><methods><class-id>Net.Base64MimeConverter</class-id> <category>conversion</category><body package="LDAP">mimeDecode	"Convert a stream in base 64 with only a-z,A-Z,0-9,+,/ to a full byte stream of characters.  Return a whole stream for the user to read."	| nibA nibB nibC nibD |	[mimeStream atEnd] whileFalse: [		(nibA := self nextValue) isNil ifTrue: [^ dataStream].		(nibB := self nextValue) isNil ifTrue: [^ dataStream].		dataStream nextPut: ((nibA bitShift: 2) + (nibB bitShift: -4)) asCharacter.		nibB := nibB bitAnd: 16rF.		(nibC := self nextValue) isNil ifTrue: [^ dataStream].		dataStream nextPut: ((nibB bitShift: 4) + (nibC bitShift: -2)) asCharacter.		nibC := nibC bitAnd: 16r3.		(nibD := self nextValue) isNil ifTrue: [^ dataStream].		dataStream nextPut: ((nibC bitShift: 6) + nibD) asCharacter.		].	^ dataStream</body><body package="LDAP">mimeDecodeToByteArray	"Convert a stream in base 64 with only a-z,A-Z,0-9,+,/ to a full ByteArray of 0-255 values.  Reutrn a whole stream for the user to read."	| nibA nibB nibC nibD |	[mimeStream atEnd] whileFalse: [		(nibA := self nextValue) isNil ifTrue: [^ dataStream].		(nibB := self nextValue) isNil ifTrue: [^ dataStream].		dataStream nextPut: ((nibA bitShift: 2) + (nibB bitShift: -4)).		nibB := nibB bitAnd: 16rF.		(nibC := self nextValue) isNil ifTrue: [^ dataStream].		dataStream nextPut: ((nibB bitShift: 4) + (nibC bitShift: -2)).		nibC := nibC bitAnd: 16r3.		(nibD := self nextValue) isNil ifTrue: [^ dataStream].		dataStream nextPut: ((nibC bitShift: 6) + nibD).		].	^ dataStream</body><body package="LDAP">mimeEncode	"Convert from data to 6 bit characters."	| phase1 phase2 raw nib data |	phase1 := phase2 := false.	[dataStream atEnd] whileFalse: [ 		data :=raw := dataStream next asInteger.		nib := (data bitAnd: 16rFC) bitShift: -2.		mimeStream nextPut: (ToCharTable at: nib+1).		(raw := dataStream next) isNil ifTrue: [raw := 0. phase1 := true].		data := ((data bitAnd: 3) bitShift: 8) + raw asInteger.		nib := (data bitAnd: 16r3F0) bitShift: -4.		mimeStream nextPut: (ToCharTable at: nib+1).		(raw := dataStream next) isNil ifTrue: [raw := 0. phase2 := true].		data := ((data bitAnd: 16rF) bitShift: 8) + (raw asInteger).		nib := (data bitAnd: 16rFC0) bitShift: -6.		mimeStream nextPut: (ToCharTable at: nib+1).		nib := (data bitAnd: 16r3F).		mimeStream nextPut: (ToCharTable at: nib+1)].	phase1 ifTrue: [mimeStream skip: -2; nextPut: $=; nextPut: $=.			^ mimeStream].	phase2 ifTrue: [mimeStream skip: -1; nextPut: $=.			^ mimeStream].</body><body package="LDAP">nextValue	"The next six bits of data char from the mimeStream, or nil.  Skip all other chars"	| raw num |	[raw := mimeStream next.	raw isNil ifTrue: [^ nil].	"end of stream"	raw == $= ifTrue: [^ nil].	num := FromCharTable at: raw asInteger + 1.	num isNil ifFalse: [^ num].	"else ignore space, return, tab, ..."	true] whileTrue.</body></methods><methods><class-id>Net.Base64MimeConverter class</class-id> <category>encoding</category><body package="LDAP">mimeDecodeToBytes: aStream 	"Return a RWBinaryOrTextStream of the original ByteArray.  aStream has only 65 innocuous character values.  aStream is not binary.  (See class comment). 4 bytes in aStream goes to 3 bytes in output."	| me |	aStream position: 0.	me := self new mimeStream: aStream.	me dataStream: (ReadWriteStream on: (ByteArray new: aStream size * 3 // 4)).	me mimeDecodeToByteArray.	me dataStream position: 0.	^ me dataStream</body><body package="LDAP">mimeDecodeToChars: aStream 	"Return a ReadWriteStream of the original String.  aStream has only 65 innocuous character values.  It is not binary.  (See class comment). 4 bytes in aStream goes to 3 bytes in output."	| me |	aStream position: 0.	me := self new mimeStream: aStream.	me dataStream: (ReadWriteStream on: (String new: aStream size * 3 // 4)).	me mimeDecode.	me dataStream position: 0.	^ me dataStream</body><body package="LDAP">mimeEncode: aStream	"Return a ReadWriteStream of characters.  The data of aStream is encoded as 65 innocuous characters.  (See class comment). 3 bytes in aStream goes to 4 bytes in output."	| me |	aStream position: 0.	me := self new dataStream: aStream.	me mimeStream: (ReadWriteStream on: (String new: (aStream size * 4 // 3)  + 20)).	me mimeEncode.	me mimeStream position: 0.	^ me mimeStream</body></methods><methods><class-id>Net.Base64MimeConverter class</class-id> <category>class initialization</category><body package="LDAP">initialize	| ind |	FromCharTable := Array new: 256.	"nils"	ToCharTable := Array new: 64.	ind := 0.	$A asInteger to: $Z asInteger do: [:val | 		ind := ind + 1.		FromCharTable at: val+1 put: ind-1.		ToCharTable at: ind put: val asCharacter].	ind := 0.	$a asInteger to: $z asInteger do: [:val | 		ind := ind + 1.		FromCharTable at: val+1 put: ind+25.		ToCharTable at: ind+26 put: val asCharacter].	ind := 0.	$0 asInteger to: $9 asInteger do: [:val | 		ind := ind + 1.		FromCharTable at: val+1 put: ind+25+26.		ToCharTable at: ind+26+26 put: val asCharacter].	FromCharTable at: ($+ asInteger + 1) put: 62.	ToCharTable at: 63 put: $+.	FromCharTable at: ($/ asInteger + 1) put: 63.	ToCharTable at: 64 put: $/.</body></methods><methods><class-id>Net.Base64MimeConverter class</class-id> <category>examples</category><body package="LDAP">example	"Base64MimeConverter example"| ss bb | ss := ReadWriteStream on: (String new: 10).ss nextPutAll: 'Hi There!'.bb := Base64MimeConverter mimeEncode: ss.	"bb contents  'SGkgVGhlcmUh'"^ (Base64MimeConverter mimeDecodeToChars: bb) contents</body></methods><methods><class-id>Net.LDIFAddContent</class-id> <category>initialize-release</category><body package="LDAP">initialize	mAttrs := OrderedCollection new.</body></methods><methods><class-id>Net.LDIFAddContent</class-id> <category>accessing</category><body package="LDAP">addElement: aLDAPAttribute	mAttrs add: aLDAPAttribute</body><body package="LDAP">getAttributes	^ mAttrs copy</body><body package="LDAP">getType	^ self class addContent</body></methods><methods><class-id>Net.LDIFAddContent</class-id> <category>printing</category><body package="LDAP">toString	| outStream |	outStream := WriteStream on: String new.	mAttrs do: [:anAttr |		outStream nextPutAll: anAttr toString].	^ self class name asString, ' {', outStream contents, '}'</body></methods><methods><class-id>Net.LDIFAddContent class</class-id> <category>instance creation</category><body package="LDAP">new	^ self basicNew initialize</body><body package="LDAP">newWithAttributes: attrCollect	"Answer a new instance having each of the LDAPAttributes specified in attrCollect."	| instance |	instance := self new.	attrCollect do: [:anAttr |		instance addElement: anAttr].	^ instance</body></methods><methods><class-id>Net.BERVisibleString</class-id> <category>accessing</category><body package="LDAP">getType	^ self class type: 'VisibleString'</body></methods><methods><class-id>Net.BERVisibleString</class-id> <category>printing</category><body package="LDAP">toString	mValue isNil		ifTrue: [^ 'VisibleString {}'].	^ 'VisibleString {', mValue, '}'</body></methods><methods><class-id>Net.JDAPFilterLessOrEqual class</class-id> <category>instance creation</category><body package="LDAP">newForAva: aJDAPAva	| tag |	tag := ((BERElement tag: 'Constructed') bitOr: (BERElement tag: 'Context')) bitOr: 6.	^ self newForTag: tag ava: aJDAPAva</body></methods><methods><class-id>Net.LDIFLineReader</class-id> <category>accessing</category><body package="LDAP">inStream	^ inStream</body><body package="LDAP">inStream: anInputStream	inStream := anInputStream</body></methods><methods><class-id>Net.LDIFLineReader</class-id> <category>input-output</category><body package="LDAP">readLine	"Reads a non-comment line.  Answers an array containing the string read and a boolean indicating whether reading is finished."	| line result continue |	continue := true.	[continue]		whileTrue: [			nextItem isNil				ifTrue: [line := inStream upTo: Character cr]				ifFalse: [line := nextItem.						nextItem := nil].			"Empty line implies end of record"			line isNil				ifTrue: [continue := false]				ifFalse: [line size &lt; 1							ifTrue: [result isNil										ifTrue: [result := line]										ifFalse: [nextItem := line.												continue := false]]							ifFalse: [(line at: 1) == LDIF commentChar										ifTrue: []			"Ignore comment"										ifFalse: [(line at: 1) == Character space	"Continuation line"													ifTrue: [result isNil																ifTrue: [^ self error: 'Invalid continuation &lt;', line, '&gt;']																ifFalse: [result := result, 																				   line copyFrom: 2 to: line size]]													ifFalse: [result isNil																ifTrue: [result := line]																ifFalse: [nextItem := line.																		continue := false]]]]]].	^ Array with: result with: (line isNil)</body></methods><methods><class-id>Net.LDIFLineReader class</class-id> <category>instance creation</category><body package="LDAP">newForInputStream: anInputStream	^ self new inStream: anInputStream</body></methods><methods><class-id>Net.JDAPExtendedResponse</class-id> <category>accessing</category><body package="LDAP">getType	^ JDAPProtocolOp codeForOperationType: 'EXTENDED_RESPONSE'</body><body package="LDAP">oid	^ mOid</body><body package="LDAP">oid: aString	mOid := aString</body><body package="LDAP">value	^ mValue</body><body package="LDAP">value: aByteArray	mValue := aByteArray</body></methods><methods><class-id>Net.JDAPExtendedResponse</class-id> <category>printing</category><body package="LDAP">toString	^ 'ExtendedResponse ', self getParamString</body></methods><methods><class-id>Net.JDAPExtendedResponse</class-id> <category>initialize-release</category><body package="LDAP">initialize	super initialize.	mOid := String new.	mValue := ByteArray new.</body></methods><methods><class-id>Net.JDAPExtendedResponse class</class-id> <category>instance creation</category><body package="LDAP">newFromBERTag: aBERTag	| seq instance el oid t |	instance := self newFromBERElement: aBERTag getValue.	seq := aBERTag getValue.	1 to: seq size do: [:idx |		el := seq elementAt: idx.		el getType = (BERElement type: 'Tag')			ifTrue: [t := el tag bitAnd: (Integer fromHex: '0F').				    t = 10						ifTrue: [oid := el getValue.							    instance oid: (oid asStringEncoding: #UTF_8)].				    t = 11						ifTrue: [instance value: el getValue]]].	^ instance</body></methods><methods><class-id>Net.JDAPControl</class-id> <category>accessing</category><body package="LDAP">criticality	^ mCriticality</body><body package="LDAP">criticality: aBoolean	mCriticality := aBoolean</body><body package="LDAP">getID	^ self type</body><body package="LDAP">getValue	^ self vals</body><body package="LDAP">type	^ mType</body><body package="LDAP">type: aString	mType := aString</body><body package="LDAP">vals	^ mVals</body><body package="LDAP">vals: aByteArray	mVals := aByteArray</body></methods><methods><class-id>Net.JDAPControl</class-id> <category>printing</category><body package="LDAP">toString	| sStream |	sStream := WriteStream on: String new.	sStream nextPutAll: 'Control { type='.	sStream nextPutAll: self type.	sStream nextPutAll: ', criticality='.	sStream nextPutAll: self criticality asString.	sStream nextPutAll: ' }'.	^ sStream contents</body></methods><methods><class-id>Net.JDAPControl</class-id> <category>testing</category><body package="LDAP">isCritical	^ self criticality</body></methods><methods><class-id>Net.JDAPControl</class-id> <category>encoding</category><body package="LDAP">getBERElement	| seq |	seq := BERSequence new.	seq addElement: (BEROctetString newFromString: self type).	seq addElement: (BERBoolean newForValue: self criticality).	self vals size = 0		ifTrue: [seq addElement: (BEROctetString newFromByteArray: ByteArray new)]		ifFalse: [seq addElement: (BEROctetString newFromByteArray: self vals from: 1 to: self vals size)].	^ seq</body></methods><methods><class-id>Net.JDAPControl</class-id> <category>initialize-release</category><body package="LDAP">initialize	mType := String new.	mCriticality := false.	mVals := ByteArray new.	^ self</body></methods><methods><class-id>Net.JDAPControl class</class-id> <category>instance creation</category><body package="LDAP">new	^ self basicNew initialize</body><body package="LDAP">newFromBERElement: element	| instance seq value |	instance := self new.	seq := element.	instance type: ((seq elementAt: 1) getValue asStringEncoding: #UTF_8).	value := seq elementAt: 2.	(value isKindOf: BERBoolean)		ifTrue: [instance criticality: value getValue]		ifFalse: [instance vals: value getValue].	seq size &gt;= 3		ifTrue: [instance vals: ((seq elementAt: 3) getValue)].	^ instance</body><body package="LDAP">newOfType: typeString criticality: criticalBoolean vals: valByteArray	| instance |	instance := self new.	instance type: typeString.	instance criticality: criticalBoolean.	instance vals: valByteArray.	^ instance</body></methods><methods><class-id>Net.JDAPCompareResponse</class-id> <category>accessing</category><body package="LDAP">getType	^ JDAPProtocolOp codeForOperationType: 'COMPARE_RESPONSE'</body></methods><methods><class-id>Net.JDAPCompareResponse class</class-id> <category>instance creation</category><body package="LDAP">newFromBERTag: aBERTag	^ self newFromBERElement: (aBERTag getValue)</body></methods><methods><class-id>Net.LDAPConnection</class-id> <category>private</category><body package="LDAP">bindForVersion: vInteger rebind: rebindBoolean constraints: cons	self startConnectionRebinding: rebindBoolean.	self finishBindForVersion: vInteger rebind: rebindBoolean constraints: cons</body><body package="LDAP">bindWithConstraints: cons	saslBind		ifTrue: [saslBind := false]		ifFalse: [self bindForVersion: self protocolVersion rebind: false constraints: cons]</body><body package="LDAP">connect	lock critical: 			[connThread isNil ifFalse: [^nil].			(host isNil | port) &lt; 0 				ifTrue: 					[^(LDAPException newForResultCode: 89) 						raiseSignal: 'No connection parameters'].			connThread := self getNewThreadForHost: self host port: self port]</body><body package="LDAP">deleteThreadConnEntry	| oc |self class threadTableLock critical: [	self class threadConnTable keys do: [:aConnThread |		oc := self class threadConnTable at: aConnThread.		oc copy do: [:aConnection |			aConnection == self				ifTrue: [oc remove: aConnection].			oc size = 0				ifTrue: [self class threadConnTable removeKey: aConnThread]]]]</body><body package="LDAP">deregisterConnectionlock critical: [	self connThread deregister: self.	self connThread: nil.	self bound: false.]</body><body package="LDAP">finishBindForVersion: vInteger rebind: rebindBoolean constraints: cons	| request response myListener |	bound &amp; rebindBoolean not ifTrue: [^self].	"Connection is still intact and no rebind request"	"If the connection was lost and did not have any kind of bind operation, and the current one does not"	"request any bind operation (i.e. authenticate has not been invoked)"	mAnonymousBound not &amp; (boundDN isNil | boundPasswd isNil)		&amp; rebindBoolean not ifTrue: [^self].	bound &amp; rebindBoolean		ifTrue: 			[self protocolVersion = vInteger				ifTrue: 					[mAnonymousBound &amp; (boundDN isNil | boundPasswd isNil) ifTrue: [^self].					mAnonymousBound not &amp; boundDN notNil &amp; boundPasswd notNil						&amp; (boundDN = prevBoundDN) &amp; (boundPasswd = prevBoundPasswd)						ifTrue: [^self]].			"Need to rebind, since previous and current credentials are different."			"If the current connection is the only one for the conn thread, then reuse the current connection."			"Otherwise, disconnect the current connection and reconnect (to a new conn thread)."			connThread clientCount &gt; 1				ifTrue: 					[self disconnect.					self connect]].	self protocolVersion: vInteger.	myListener := self getResponseListener.		[	[mReferralConnection notNil		ifTrue: 			[mReferralConnection disconnect.			mReferralConnection := nil].	request := JDAPBindRequest				newForVersion: self protocolVersion				name: boundDN				password: boundPasswd.	self sendRequest: request notify: myListener constraints: cons.	response := myListener getResponse.	self checkMsg: response]			on: LDAPReferralException			do: [:ex | self createReferralConnection: ex constraints: cons]]			ensure: [self releaseResponseListener: myListener].	self updateThreadConnTable</body><body package="LDAP">getNewThreadForHost: hString port: pInteger 	| newThread oc keys connExist |	self class threadTableLock critical: [		keys := self class threadConnTable keys.		connExist := false.		keys do: 	[:aConnThread | 			oc := self class threadConnTable at: aConnThread.			oc do: [:aConnection | 				connExist ifFalse: [					aConnection == self ifTrue: [connExist := true].					aConnThread disconnected ifTrue: [						[newThread := self newThreadConnectTo: hString port: pInteger.						newThread maxBacklog: self getSearchConstraints maxBacklog.						self class threadConnTable removeKey: aConnThread] 							on: Error							do: [:ex | (self processConnectionError: ex) ifNil: [ ^nil] ]]	"Need to move connections to a new thread"]]].			connExist ifFalse: [				[newThread := self newThreadConnectTo: hString port: pInteger.				newThread maxBacklog: self getSearchConstraints maxBacklog.				oc := OrderedCollection new.				oc add: self] 					on: Error					do: [:ex | (self processConnectionError: ex) ifNil: [ ^nil] ]].			newThread ifNotNil: [				self class threadConnTable at: newThread put: oc.				oc do: [:aConnection | 						newThread register: aConnection.						aConnection connThread: newThread]]].	^newThread</body><body package="LDAP">getResponseListener	"Answer a new listening agent from the internal buffer of available agents.  These objects are used to make the asynchronous LDAP operations synchronous."	| aListener |lock critical: [	responseListeners size = 0		ifTrue: [aListener :=  LDAPResponseListener newForConnection: self]		ifFalse: [aListener :=  responseListeners removeAtIndex: 1]].	^ aListener</body><body package="LDAP">getSearchListener	"Answer a new search listening agent from the internal buffer of available agents.  These objects are used to make the asynchronous LDAP operations synchronous."	^ self getSearchListener: self defaultConstraints</body><body package="LDAP">getSearchListener: cons	"Answer a new search listening agent from the internal buffer of available agents.  These objects are used to make the asynchronous LDAP operations synchronous."	| aListener |lock critical: [	searchListeners size = 0		ifTrue: [aListener :=  LDAPSearchListener newForConnection: self constraints: cons]		ifFalse: [aListener :=  searchListeners removeAtIndex: 1]].	^ aListener</body><body package="LDAP">newThreadConnectTo: aHost port: aPort 	^LDAPConnThread newForHost: aHost port: aPort</body><body package="LDAP">performReferralsOnConnection: connection constraints: cons protocolOp: op dn: dn scope: scope filter: filter attributes: types attributesOnly: attrsOnly mods: mods entry: entry attribute: attribute results: results	| res bool |	[(JDAPProtocolOp codeForOperationType: 'SEARCH_REQUEST') = op			ifTrue: [res := connection searchForDN: dn 							scope: scope 							filter: filter 							attributes: types 							attributesOnly: attrsOnly 							constraints: cons.				    res notNil						ifTrue: [res closeOnCompletion: connection.							    results add: res]						ifFalse: [(mReferralConnection isNil) | (connection ~~ mReferralConnection)									ifTrue: [connection disconnect]]].	  (JDAPProtocolOp codeForOperationType: 'MODIFY_REQUEST') = op			ifTrue: [connection modifyDN: dn modifications: mods constraints: cons].	  (JDAPProtocolOp codeForOperationType: 'ADD_REQUEST') = op			ifTrue: [(dn notNil and: [dn size &gt; 0])						ifTrue: [entry dn: dn].				    connection add: entry constraints: cons].	  (JDAPProtocolOp codeForOperationType: 'DEL_REQUEST') = op			ifTrue: [connection deleteDN: dn constraints: cons].	  (JDAPProtocolOp codeForOperationType: 'MODIFY_RDN_REQUEST') = op			ifTrue: [connection renameDN: dn newRDN: filter deleteOld: attrsOnly constraints: cons].	  (JDAPProtocolOp codeForOperationType: 'COMPARE_REQUEST') = op			ifTrue: [bool := connection compareDN: dn attribute: attribute constraints: cons.				    results add: bool]]		ensure: [(connection notNil) &amp;				(((JDAPProtocolOp codeForOperationType: 'SEARCH_REQUEST') ~= op) | (res isNil)) &amp;				((mReferralConnection isNil) | (connection ~~ mReferralConnection))					ifTrue: [connection disconnect]]</body><body package="LDAP">prepareReferral: anLDAPUrl constraints: cons	"Set up connection for referral"	| connection |	connection := LDAPConnection new.	connection setOption: LDAPv2 referrals to: true.	connection setOption: LDAPv2 referralsRebindProc to: cons rebindProc.	connection setOption: LDAPv2 protocolVersion to: self class protocolVersion.	connection setOption: LDAPv2 referralsHopLimit to: cons hopLimit.	connection connectToHost: anLDAPUrl hostName port: anLDAPUrl portNumber.	^ connection</body><body package="LDAP">processConnectionError: anError		 (anError isKindOf: LDAPException) 		ifTrue: [Transcript 	show: 'Exception: ' , anError toString;	cr. ^nil]		ifFalse: [anError resignalAs: (LDAPException newForResultCode: 52)]</body><body package="LDAP">releaseResponseListener: aListener	"Place a listening agent into the internal buffer of available agents."lock critical: [	aListener reset.	responseListeners add: aListener.]</body><body package="LDAP">releaseSearchListener: aListener	"Place a listening agent into the internal buffer of available agents."lock critical: [	aListener reset.	searchListeners add: aListener.]</body><body package="LDAP">startConnectionRebinding: rebindBoolean	connThread isNil		ifTrue: [			bound := false.			self connect]		ifFalse: [			"Special case: the connection currently is not bound, and now there is a bind request."			"The connection needs to reconnect if the connection thread has more than one connection."			bound not &amp; rebindBoolean &amp; (connThread clientCount &gt; 1) ifTrue: [				self disconnect.				self connect]]</body><body package="LDAP">updateThreadConnTableself class threadTableLock critical: [	(self class threadConnTable includesKey: connThread)		ifTrue: [(self class threadConnTable at: connThread) do: [:aConnection |					aConnection bound: true]]		ifFalse: [self printDebug: 'Thread table does not contain the specified thread']]</body></methods><methods><class-id>Net.LDAPConnection</class-id> <category>connecting</category><body package="LDAP">connectToHost: hString port: pInteger	"Connect to specified host at the specified port number without authentication."	"hString may be a list of host and port number pairs, separated by a colon, with a space between each host:port pair.  If a host appears in the list without a port number, the default port number specified by pInteger will be used instead."	"Example host list:"	"myhost histhost:389 herhost:5000 whathost"	self connectToHost: hString port: pInteger dn: nil password: nil constraints: defaultConstraints authenticate: false</body><body package="LDAP">connectToHost: hString port: pInteger dn: dnString password: pString	self connectToHost: hString port: pInteger dn: dnString password: pString constraints: defaultConstraints authenticate: true</body><body package="LDAP">connectToHost: hString port: pInteger dn: dnString password: pString constraints: cons	self connectToHost: hString port: pInteger dn: dnString password: pString constraints: cons authenticate: true</body><body package="LDAP">connectToHost: hString port: pInteger dn: dnString password: pString constraints: cons authenticate: authBoolean	| hStream s colIndx conExcept success |	connThread notNil		ifTrue: [self disconnect].	(hString isNil or: [hString size = 0])		ifTrue: [^ (LDAPException newForResultCode: 89) raiseSignal: 'No host specified'].	mDefaultPort := pInteger.	"Build the host and port lists from the string provided."	hStream := ReadStream on: (hString tokensBasedOn: Character space).	mHostList := OrderedCollection new.	mPortList := OrderedCollection new.	[hStream atEnd]		whileFalse: [s := hStream next.					colIndx := s indexOf: $:.					colIndx &gt; 0						ifTrue: [mHostList add: (s copyFrom: 1 to: (colIndx - 1)).							    mPortList add: (s copyFrom: (colIndx + 1) to: s size)]						ifFalse: [mHostList add: s.								mPortList add: mDefaultPort]].	"Try each possible host until a connection attempt doesn`t cause an exception."	success := false.	1 to: mHostList size do: [:idx  |		[success			ifFalse: [self host: (mHostList at: idx).					self port: (mPortList at: idx).					self connect.					conExcept := nil.					success := true]]			on: LDAPException			do: [:ex | conExcept := ex]].	success										"Unable to connect to any of the hosts."		ifFalse: [self host: mHostList first.				self port: mDefaultPort.				conExcept raiseSignal].	authBoolean		ifTrue: [self authenticateAs: dnString password: pString constraints: cons]</body><body package="LDAP">connectToHost: hString port: pInteger version: vInteger dn: dnString password: pString	"Connect to specified host (or one of available hosts in host list, see comment in connectToHost:port:) using the version specified (2 or 3).  If version is unavailable on host, raise and LDAPException."		self connectToHost: hString port: pInteger version: vInteger dn: dnString password: pString constraints: defaultConstraints</body><body package="LDAP">connectToHost: hString port: pInteger version: vInteger dn: dnString password: pString constraints: cons	"Connect to specified host (or one of available hosts in host list, see comment in connectToHost:port:) using the version specified (2 or 3).  If version is unavailable on host, raise and LDAPException."		self protocolVersion: vInteger.	self connectToHost: hString port: pInteger dn: dnString password: pString constraints: cons</body><body package="LDAP">createReferralConnection: aReferralException constraints: cons	"Establish the LDAPConnection to the referred server and answer it.  This one is used for bind operation only since we need to keep this new connection for the subsequent operations.  This new connection will be destroyed in two circumstances: invocation of the disconnect method, or the client binding as someone else."	| urls connection dn |	cons hopLimit &lt;=0		ifTrue: [(LDAPException newForResultCode: aReferralException resultCode)					raiseSignal: 'Exceed hop limit'].	cons referrals		ifFalse: [aReferralException raiseSignal].	urls := aReferralException getURLs.	(urls isNil or: [urls size = 0 or: [urls first size = 0]])		ifTrue: [(LDAPException newForResultCode: 94)						"No Results Returned"					raiseSignal: 'No target URL in referral'].	connection := self prepareReferral: urls first constraints: cons.	dn := urls first dn.	(dn isNil or: [dn size = 0])		ifTrue: [dn := boundDN].	connection authenticateAs: dn password: boundPasswd.	^ connection</body><body package="LDAP">disconnect	"Disconnect from the LDAP server.  Before processing LDAP operations again, the application must reconnect sending a connect message."lock critical: [	mReferralConnection notNil		ifTrue: [mReferralConnection disconnect.			    mReferralConnection := nil].	connThread isNil		ifTrue: [^self "ok" "(LDAPException newForResultCode: 80) raiseSignal: 'Cannot disconnect without connecting.'"].	self deleteThreadConnEntry.	self deregisterConnection.]</body></methods><methods><class-id>Net.LDAPConnection</class-id> <category>searching</category><body package="LDAP">checkSearchMsg: aSearchResult response: aMessage constraints: cons base: aDN scope: aScope filter: aFilter attributes: theAttributes attributesOnly: attrOnly	| res |	[[self checkMsg: aMessage.	(aMessage protocolOp getType) = (JDAPProtocolOp codeForOperationType: 'SEARCH_RESULT')		ifFalse: [aSearchResult addEntry: aMessage protocolOp]]			on: LDAPReferralException			do: [:ex | res := OrderedCollection new.					self performReferrals: ex							constraints: cons							protocolOp: (JDAPProtocolOp codeForOperationType: 'SEARCH_REQUEST')							dn: aDN							scope: aScope							filter: aFilter							attributes: theAttributes							attributesOnly: attrOnly							mods: nil							entry: nil							attribute: nil							results: res.					"The size of the collection can be more than 1 because it is possible to visit more than"					"one referral URL to retrieve the entries"					res do: [:anEntry |						aSearchResult addReferralEntries: anEntry]]]			on: LDAPException			do: [:ex | (ex resultCode = 3) | 				"Time Limit Exceeded"					  (ex resultCode = 4) |				"Size Limit Exceeded"					  (ex resultCode = 11)				"Admin Limit Exceeded"							ifTrue: [aSearchResult addEntry: ex]							ifFalse: [ex pass]]</body><body package="LDAP">readDN: dnString	"Reads the entry for the specified distinguished name (DN) and retrieves all attributes for the entry."	^ self readDN: dnString attributes: OrderedCollection new constraints: self defaultConstraints</body><body package="LDAP">readDN: dnString attributes: attrCollect	"Reads the entry for the specified distinguished name (DN) and retrieves only the specified attributes for the entry."	^ self readDN: dnString attributes: attrCollect constraints: self defaultConstraints</body><body package="LDAP">readDN: dnString attributes: attributeCollect constraints: cons	| results |	results := self searchForDN: dnString 					scope: LDAPv2 scopeBase					filter: self class defaultFilter					attributes: attributeCollect					attributesOnly: false					constraints: cons.	results isNil		ifTrue: [^ nil].	^ results next</body><body package="LDAP">readDN: dnString constraints: cons	"Reads the entry for the specified distinguished name (DN) and retrieves all attributes for the entry.  This method allows the application to specify the preferences for the read operation."	^ self readDN: dnString attributes: nil constraints: cons</body><body package="LDAP">searchForDN: theDN scope: theScope filter: theFilter attributes: theAttributes attributesOnly: attrOnly constraints: cons	"Performs the search specified by the criteria provided.  This method also allows the application to specify contraints for the search (such as the maximum number of entries to find or the maximum time to wait for search results).  As part of the search constraints, the application can specify whether or not the results should be delivered all at once or in smaller batches.  If the results are to be returned in smaller batches, each iteration blocks until the next batch of results is returned."	"Parameters:"	"theDN			&lt;String&gt;				distinguished name that is the base of the search"	"theScope		&lt;Integer&gt;				see LDAPv2 class side protocol constants-scope"	"theFilter		&lt;String&gt;				filter string"	"theAttributes	&lt;Collection of String&gt;	attribute types to return in the search result"	"attrOnly		&lt;Boolean&gt;				true if the attribute names available should be answered (not values"	"cons			&lt;LDAPSearchConstraints&gt;	search constraints that apply to this search"	| thisCons returnValue myListener deref request success response results op msg firstResult controls |		cons isNil		ifTrue: [thisCons := self defaultConstraints]		ifFalse: [thisCons := cons].	returnValue := LDAPSearchResults newForConnection: self						constraints: thisCons						base: theDN						scope: theScope						filter: theFilter						attributes: theAttributes						attrsOnly: attrOnly.	self bindWithConstraints: thisCons.	myListener := self getSearchListener: thisCons.	deref := thisCons deref.	request := JDAPSearchRequest newForDN: theDN 					scope: theScope 					dereference: deref 					sizeLimit: thisCons maxRes  					timeLimit: thisCons timeLimit 					attrsOnly: attrOnly 					filter: theFilter 					attrs: theAttributes.	myListener lock critical: [		success := false.		[self sendRequest: request notify: myListener constraints: thisCons.		success := true]			ensure: [success						ifFalse: [self releaseSearchListener: myListener]].	].		"Synchronous search if all requested at once"	thisCons batch = 0		ifTrue: [["Block until all results are in"				response := myListener getResponse.				results := myListener getSearchResults.				[self checkSearchMsg: returnValue						response: response						constraints: thisCons						base: theDN						scope: theScope						filter: theFilter						attributes: theAttributes						attributesOnly: attrOnly]					on: LDAPException						"Was the exception due to a bad referral?"					do: [:ex | op := response protocolOp.							  ((op isKindOf: JDAPSearchResultReference) |							   (op isKindOf: JDAPSearchResult))									ifTrue: [Transcript print: 'LDAPConnection&gt;&gt;checkSearchMsg: ignoring bad referral'; cr]									ifFalse: [ex pass]].				[results atEnd]					whileFalse: [msg := results next.								self checkSearchMsg: returnValue										response: msg										constraints: thisCons										base: theDN										scope: theScope										filter: theFilter										attributes: theAttributes										attributesOnly: attrOnly]]			ensure: [self releaseSearchListener: myListener]]		ifFalse: ["Asynchronous search, retrieving results one at a time."				"Ensure that the search did not fail."				"Give the connection thread an opportunity to process results."				Processor activeProcess yield.				"(Delay forMilliseconds: 100) wait."				firstResult := myListener nextResult. 				firstResult isNil					ifTrue: [firstResult := myListener response.						    [self checkSearchMsg: returnValue									response: firstResult									constraints: thisCons									base: theDN									scope: theScope									filter: theFilter									attributes: theAttributes									attributesOnly: attrOnly]								ensure: [self releaseSearchListener: myListener]]					ifFalse: ["First result could be a bad referral, ultimately causeing a NoSuchObject exception."							"Do not want to miss all following objects, so skip it"							[self checkSearchMsg: returnValue										response: firstResult										constraints: thisCons										base: theDN										scope: theScope										filter: theFilter										attributes: theAttributes										attributesOnly: attrOnly]								on: LDAPException								do: [:ex | "Was the exception caused by a bad referral?"										(firstResult protocolOp isKindOf: JDAPSearchResultReference)											ifTrue: [Transcript show: ('LDAPConnection&gt;&gt;checkSearchMsg :', 																	'ignoring bad referral'); cr]											ifFalse: [ex pass]].							controls := self getOption: LDAPv3 serverControls constraints: thisCons.							controls isNil								ifFalse: [controls do: [:aControl |											(aControl isKindOf: LDAPPersistSearchControl)												ifTrue: [returnValue associatePersistentSearch: myListener.													    ^ returnValue]]].							returnValue associate: myListener]].	^ returnValue</body></methods><methods><class-id>Net.LDAPConnection</class-id> <category>modifying</category><body package="LDAP">modifyDN: dnString modification: mod	"Makes a single change to an existing entry in the directory with the distinguished name dnString.  A change can be altering the value of an attribute, adding a new attribute value, or removing an existing attribute value.  mod is an LDAPModification object to specify the change that needs to be made.  The LDAPModification object can add an attribute value, change an attribute value, or remove an attribute value."	self modifyDN: dnString modification: mod constraints: self defaultConstraints</body><body package="LDAP">modifyDN: dnString modification: mod constraints: cons	"Makes a single change to an existing entry in the directory with distinguished name dnString, and allows the application to specify preferences for this modification operation (using an LDAPSearchConstraint object, cons).  For example, the application can specify whether or not to follow referrals, or can apply LDAPv3 controls to the operation."	| mods |	mods := Array with: mod.	self modifyDN: dnString modifications: mods constraints: cons</body><body package="LDAP">modifyDN: dnString modificationSet: modSet	"Makes a set of changes (represented by LDAPModificationSet modSet)  to an existing entry in the directory (whose distinguished name is dnString)."	self modifyDN: dnString modificationSet: modSet constraints: self defaultConstraints</body><body package="LDAP">modifyDN: dnString modificationSet: modSet constraints: cons	"Makes a set of changes (represented by LDAPModificationSet modSet)  to an existing entry in the directory (whose distinguished name is dnString), and allows the application to specify preferences for this modification operation (using an LDAPSearchConstraint object, cons).  For example, the application can specify whether or not to follow referrals, or can apply LDAPv3 controls to the operation."	| mods |	mods := OrderedCollection new: modSet size.	1 to: modSet size do: [:ndx |		mods add: (modSet elementAt: ndx)].	self modifyDN: dnString modifications: mods constraints: cons</body><body package="LDAP">modifyDN: dnString modifications: mods	"Makes a set of changes (collection of LDAPModifications, mods)  to an existing entry in the directory (whose distinguished name is dnString)."	self modifyDN: dnString modifications: mods constraints: self defaultConstraints</body><body package="LDAP">modifyDN: dnString modifications: mods constraints: cons	"Makes a set of changes (collection of LDAPModifications, mods)  to an existing entry in the directory (whose distinguished name is dnString), and allows the application to specify preferences for this modification operation (using an LDAPSearchConstraint object, cons).  For example, the application can specify whether or not to follow referrals, or can apply LDAPv3 controls to the operation."	| myListener response |	self bindWithConstraints: cons.	myListener := self getResponseListener.	[[self sendRequest: (JDAPModifyRequest newForDN: dnString mods: mods)			notify: myListener			constraints: cons.	  response := myListener getResponse.	  self checkMsg: response]		on: LDAPReferralException		do: [:ex | self performReferrals: ex						constraints: cons						protocolOp: (JDAPProtocolOp codeForOperationType: 'MODIFY_REQUEST')						dn: dnString						scope: 0						filter: nil						attributes: nil						attributesOnly: false						mods: mods						entry: nil						attribute: nil						results: nil]]			ensure: [self releaseResponseListener: myListener]</body></methods><methods><class-id>Net.LDAPConnection</class-id> <category>accessing</category><body package="LDAP">authenticationDN	^ boundDN</body><body package="LDAP">authenticationPassword	^ boundPasswd</body><body package="LDAP">bound	^ bound</body><body package="LDAP">bound: aBoolean	bound := aBoolean</body><body package="LDAP">connThread	^ connThread</body><body package="LDAP">connThread: anLDAPConnThread	connThread := anLDAPConnThread</body><body package="LDAP">defaultConstraints	^ defaultConstraints</body><body package="LDAP">defaultConstraints: anLDAPSearchConstraints	defaultConstraints := anLDAPSearchConstraints</body><body package="LDAP">getResponseControls	^ self responseControls</body><body package="LDAP">getSearchConstraints	^ self defaultConstraints</body><body package="LDAP">host	^ host</body><body package="LDAP">host: aString	host := aString</body><body package="LDAP">port	^ port</body><body package="LDAP">port: anInteger	port := anInteger</body><body package="LDAP">protocolVersion	^ protocolVersion</body><body package="LDAP">protocolVersion: anInteger	protocolVersion := anInteger</body><body package="LDAP">responseControls	"Answer a collection of the latest controls (if any) from the server."	| controls responses |lock critical: [	responses := mResponseControlTable at: self connThread ifAbsent: [nil].	responses isNil		ifFalse: [responses copy do: [:aResponseObj |					controls isNil						ifTrue: [aResponseObj connection == self									ifTrue: [controls := aResponseObj controls.											responses remove: aResponseObj]]]]].	^ controls</body><body package="LDAP">responseControls: aResponseControl from: anLDAPConnThread	"Set response controls fro the current connnection for a particular connection thread.  Get the oldest returned controls and remove them from the queue.  If the connection is executing a persistent search, there may be more than one set of controls in the queue.  For any other operation, there will only ever be at most one set of controls (controls from any earlier operation are replaced by controls received on the latest operatoin on this connection by this thread)."	| aCollect |lock critical: [	aCollect := mResponseControlTable at: anLDAPConnThread ifAbsent: [nil].	"If the current connection thread already contains response controls from a previous op"	(aCollect notNil and: [aCollect size &gt; 0])		ifTrue: [(aCollect copyWithout: nil) do: [:response |						"If this response control belongs to this connection..."						response connection == self									"If the given control is nil or the control in question does not"									"correspond to the new JDAPMessage"							ifTrue: [(aResponseControl isNil											or: [aResponseControl messageId ~= response messageId])										ifTrue: [aCollect remove: response]]]]		ifFalse: [aResponseControl notNil						ifTrue: [aCollect := OrderedCollection new]].	aResponseControl notNil		ifTrue: [aCollect add: aResponseControl.				mResponseControlTable at: anLDAPConnThread put: aCollect].	"Do some garbage collection: check if any attached threads have exited"	mAttachedList copy do: [:aThread |		aThread disconnected			ifTrue: [mResponseControlTable removeKey: aThread.					mAttachedList remove: aThread]].	"Make sure connection thread is registred."	(mAttachedList includes: anLDAPConnThread)		ifFalse: [mAttachedList add: anLDAPConnThread]]</body></methods><methods><class-id>Net.LDAPConnection</class-id> <category>deleting</category><body package="LDAP">deleteDN: dnString	"Deletes the entry identified by distinguished name dnString from the directory."	self deleteDN: dnString constraints: self defaultConstraints</body><body package="LDAP">deleteDN: dnString constraints: cons	"Deletes the entry identified by distinguished name dnString from the directory, and allows the application to specify preferences for this modification operation (using an LDAPSearchConstraint object, cons).  For example, the application can specify whether or not to follow referrals, or can apply LDAPv3 controls to the operation."	| myListener response |	self bindWithConstraints: cons.	myListener := self getResponseListener.	[[self sendRequest: (JDAPDelRequest newForDN: dnString)			notify: myListener			constraints: cons.	  response := myListener getResponse.	  self checkMsg: response]		on: LDAPReferralException		do: [:ex | self performReferrals: ex						constraints: cons						protocolOp: (JDAPProtocolOp codeForOperationType: 'DEL_REQUEST')						dn: dnString						scope: 0						filter: nil						attributes: nil						attributesOnly: false						mods: nil						entry: nil						attribute: nil						results: nil]]		ensure: [self releaseResponseListener: myListener]</body></methods><methods><class-id>Net.LDAPConnection</class-id> <category>adding</category><body package="LDAP">add: anLDAPEntry	"Adds an entry to the directory.  Before sending this method, the application needs to create an LDAPEntry object and use it to specify the distinguished name and attributes of the new entry.  Values must be specified for all required attributes in the entry.  If all required attributes are not specified and the LDAP server checks the entry against the schema, an LDAPException may be signalled with the LDAP result code OBJECT_CLASS_VIOLATION."	self add: anLDAPEntry constraints: self defaultConstraints</body><body package="LDAP">add: anLDAPEntry constraints: cons	"Adds an entry to the directory and allows the application to specify preferences for this add operation by using an LDAPSearchConstraints object, cons.  For example, the application can specify whether or not to follow referrals.  LDAPv3 controls can also be applied to the operation."	| myListener attrEnum attrs response |	self bindWithConstraints: cons.	myListener := self getResponseListener.	attrEnum := anLDAPEntry attrSet getAttributes.	attrs := OrderedCollection new.	[attrEnum atEnd]		whileFalse: [attrs add: attrEnum next].	[[self sendRequest: (JDAPAddRequest newWithBaseDN: anLDAPEntry dn attributes: attrs)			notify: myListener			constraints: cons.	 response := myListener getResponse.	 self checkMsg: response]		on: LDAPReferralException		do: [:ex | self performReferrals: ex						constraints: cons						protocolOp: (JDAPProtocolOp codeForOperationType: 'ADD_REQUEST')						dn: nil						scope: 0						filter: nil						attributes: nil						attributesOnly: false						mods: nil						entry: anLDAPEntry						attribute: nil						results: nil]]		ensure: [self releaseResponseListener: myListener]</body></methods><methods><class-id>Net.LDAPConnection</class-id> <category>accessing-options</category><body package="LDAP">getOption: optionInteger	"Answers the value of the specified option used by default for this connection.  To obtain all of the default operational constraints, send the defaultConstraints method to the LDAPConnection instance."	self getOption: optionInteger constraints: self defaultConstraints</body><body package="LDAP">getOption: optionInteger constraints: cons	"Answers the value of the specified option for the LDAPSearchConstraint cons.  These options represent specific constraints applied on a particular operation, or on all operations by default for this connection.  To obtain all of the default operational constraints, send the defaultConstraints method to the LDAPConnection instance."	optionInteger = LDAPv2 deref		ifTrue: [^ cons deref].	optionInteger = LDAPv2 sizeLimit		ifTrue: [^ cons maxRes].	optionInteger = LDAPv2 timeLimit		ifTrue: [^ cons timeLimit].	optionInteger = LDAPv2 referrals		ifTrue: [^ cons referrals].	optionInteger = LDAPv2 referralsRebindProc		ifTrue: [^ cons rebindProc].	optionInteger = LDAPv2 referralsHopLimit		ifTrue: [^ cons hopLimit].	optionInteger = LDAPv2 batchSize		ifTrue: [^ cons batch].	optionInteger = LDAPv3 clientControls		ifTrue: [^ cons clientControls].	optionInteger = LDAPv3 serverControls		ifTrue: [^ cons serverControls].	optionInteger = self class maxBacklog		ifTrue: [^ cons maxBacklog].	(LDAPException newForResultCode: 89)						"Param Error"		raiseSignal: 'Invalid Option Code'</body><body package="LDAP">setOption: optionInteger to: valueObject	"Set the value of the specified option for this connection.  These options represent specific constraints applied on a particular operation, or on all operations by default for this connection."	self setOption: optionInteger to: valueObject constraints: self defaultConstraints</body><body package="LDAP">setOption: optionInteger to: valueObject constraints: cons	"Set the value of the specified option for the LDAPSearchConstraint cons.  These options represent specific constraints applied on a particular operation, or on all operations by default for this connection."	optionInteger = LDAPv2 deref		ifTrue: [^ cons deref: valueObject].				"Integer"	optionInteger = LDAPv2 sizeLimit		ifTrue: [^ cons maxRes: valueObject].			"Integer"	optionInteger = LDAPv2 timeLimit		ifTrue: [^ cons timeLimit: valueObject].			"Integer"	optionInteger = LDAPv2 referrals		ifTrue: [^ cons referrals: valueObject].			"Boolean"	optionInteger = LDAPv2 referralsRebindProc		ifTrue: [^ cons rebindProc: valueObject].			"LDAPRebind"	optionInteger = LDAPv2 referralsHopLimit		ifTrue: [^ cons hopLimit: valueObject].			"Integer"	optionInteger = LDAPv2 batchSize		ifTrue: [^ cons batch: valueObject].				"Integer"	optionInteger = LDAPv3 clientControls				"LDAPControl or Collection of LDAPControl"		ifTrue: [(valueObject isKindOf: Collection)					ifTrue: [^ cons clientControls: valueObject]					ifFalse: [(valueObject isKindOf: LDAPControl)									ifTrue: [^ cons addClientControl: valueObject]									ifFalse: [(LDAPException newForResultCode: 89)			"Param Error"													raiseSignal: 'Invalid LDAPControl']]].	optionInteger = LDAPv3 serverControls				"LDAPControl or Collection of LDAPControl"		ifTrue: [(valueObject isKindOf: Collection)					ifTrue: [^ cons serverControls: valueObject]					ifFalse: [(valueObject isKindOf: LDAPControl)									ifTrue: [^ cons addServerControl: valueObject]									ifFalse: [(LDAPException newForResultCode: 89)			"Param Error"													raiseSignal: 'Invalid LDAPControl']]].	optionInteger = self class maxBacklog		ifTrue: [valueObject &gt;= 1					ifFalse: [(LDAPException newForResultCode: 89)						"Param Error"									raiseSignal: 'MaxBacklog must be at least 1'].				^ cons maxBacklog: valueObject].			"Integer"	(LDAPException newForResultCode: 89)					"Param Error"		raiseSignal: 'Invalid Option Code'</body></methods><methods><class-id>Net.LDAPConnection</class-id> <category>extended operation</category><body package="LDAP">extendedOperation: theExtOp	"Performs an extended operation represented by theExtOp (an LDAPExtendedOperation instance) on the directory.  Extended operations are part of version 3 of the LDAP protocol.  Note that in order for the extended operation to work, the server that the application is connecting to must support LDAPv3, and must be configured to process the specified extended operation."	^ self extendedOperation: theExtOp constraints: self defaultConstraints</body><body package="LDAP">extendedOperation: theExtOp constraints: cons	"Performs an extended operation represented by theExtOp (an LDAPExtendedOperation instance) on the directory.  Extended operations are part of version 3 of the LDAP protocol.  This method allows the application to set the preferences for the operation.  Note that in order for the extended operation to work, the server that the application is connecting to must support LDAPv3, and must be configured to process the specified extended operation."	| myListener response results resultId |	self bindWithConstraints: cons.	myListener := self getResponseListener.	[[self sendRequest: (JDAPExtendedRequest newForOid: theExtOp oid value: theExtOp vals)				notify: myListener				constraints: cons.	  response := myListener getResponse.	  self checkMsg: response.	  results := response value.	  resultId := response oid]		on: LDAPReferralException		do: [:ex | ^ self performExtendedReferrals: ex							constraints: cons							extendedOp: theExtOp]]			ensure: [self releaseResponseListener: myListener].	^ (LDAPExtendedOperation newForOid: resultId vals: results)</body></methods><methods><class-id>Net.LDAPConnection</class-id> <category>printing</category><body package="LDAP">printDebug: aString	self class printDebug: aString</body></methods><methods><class-id>Net.LDAPConnection</class-id> <category>testing</category><body package="LDAP">checkCommunicator	"We are not running in Netscape Communicator"	^ false</body><body package="LDAP">isAuthenticated	bound		ifTrue: [(boundDN isNil or: [boundDN size = 0]) | (boundPasswd isNil or: [boundPasswd size = 0])					ifTrue: [^ false]].	^ bound</body><body package="LDAP">isConnected	^ connThread notNil</body><body package="LDAP">isNetscape	^ self checkCommunicator</body></methods><methods><class-id>Net.LDAPConnection</class-id> <category>renaming</category><body package="LDAP">renameDN: dnString newRDN: newRDNString deleteOld: deleteBoolean	"Renames an existing entry in the directory.  The application can specify whether or not the original name of the entry is retained as a value in the entry.  For example, suppose the application renames the entry 'cn=Barbara' to 'cn=Babs'.  The application can keep 'cn=Barbara' as a value in the entry so that the cn attribute has two values ('Babs' and 'Barbara')."	self renameDN: dnString 		newRDN: newRDNString 		parent: nil 		deleteOld: deleteBoolean 		constraints: self defaultConstraints</body><body package="LDAP">renameDN: dnString newRDN: newRDNString deleteOld: deleteBoolean constraints: cons	"Renames an existing entry in the directory.  The application can specify whether or not the original name of the entry is retained as a value in the entry.  For example, suppose the application renames the entry 'cn=Barbara' to 'cn=Babs'.  The application can keep 'cn=Barbara' as a value in the entry so that the cn attribute has two values ('Babs' and 'Barbara').  Also allows the application to specify preferences to this LDAP modify DN operation by using an LDAPSearchConstraints object, cons.  For example, the application can specify whether or not to follow referrals.  LDAPv3 controls can also be applied to the operation."	self renameDN: dnString 		newRDN: newRDNString 		parent: nil 		deleteOld: deleteBoolean 		constraints: cons</body><body package="LDAP">renameDN: dnString newRDN: newRDNString parent: newParentDN deleteOld: deleteBoolean	"Renames an existing entry in the directory, and (optionally) changes the location of the entry in the directory tree."	"Note: Netscape Directory Server 3.0 does not support the capability of moving an entry to a different location in the directory tree.  If you specify a value for the newParentDN argument, an LDAPException will be raised."	self renameDN: dnString 		newRDN: newRDNString 		parent: newParentDN 		deleteOld: deleteBoolean 		constraints: self defaultConstraints</body><body package="LDAP">renameDN: dnString newRDN: newRDNString parent: newParentDN deleteOld: deleteBoolean constraints: cons	"Renames an existing entry in the directory, and (optionally) changes the location of the entry in the directory tree.  Also allows the application to specify preferences to this LDAP modify DN operation by using an LDAPSearchConstraints object, cons.  For example, the application can specify whether or not to follow referrals.  LDAPv3 controls can also be applied to the operation."	"Note: Netscape Directory Server 3.0 does not support the capability of moving an entry to a different location in the directory tree.  If you specify a value for the newParentDN argument, an LDAPException will be raised."	| myListener response request |	self bindWithConstraints: cons.	myListener := self getResponseListener.	[[ (newParentDN isNil or: [newParentDN size = 0])			ifTrue: [request := JDAPModifyRdnRequest 									newForOldDN: dnString									newRDN: newRDNString									deleteOldDN: deleteBoolean]			ifFalse: [request := JDAPModifyRdnRequest 									newForOldDN: dnString									newRDN: newRDNString									deleteOldDN: deleteBoolean									newSuperior: newParentDN].	  self sendRequest: request notify: myListener constraints: cons.	  response := myListener getResponse.	  self checkMsg: response]			on: LDAPReferralException			do: [:ex | self performReferrals: ex						constraints: cons						protocolOp: (JDAPProtocolOp codeForOperationType: 'MODIFY_RDN_REQUEST')						dn: dnString						scope: 0						filter: newRDNString						attributes: nil						attributesOnly: deleteBoolean						mods: nil						entry: nil						attribute: nil						results: nil]]		ensure: [self releaseResponseListener: myListener]</body></methods><methods><class-id>Net.LDAPConnection</class-id> <category>comparing</category><body package="LDAP">compareDN: dnString attribute: anLDAPAttribute	^ self compareDN: dnString attribute: anLDAPAttribute constraints: self defaultConstraints</body><body package="LDAP">compareDN: dnString attribute: anLDAPAttribute constraints: cons	"Send a request to the server to determine whether the entry named by dnString contains an attribute with the name and value specified by anLDAPAttribute.   Answers false if the entry does not have the attribute, or has the attribute but it does not match the specified value.  Note that only string valued attributes can be used in the comparison."	| myListener bvStream val tVal ava response resultCode res aBoolean |	self bindWithConstraints: cons.	myListener := self getResponseListener.	bvStream := anLDAPAttribute getByteValues.	val := bvStream next.	tVal := String new.	[tVal := val asStringEncoding: #UTF_8]		on: Exception		do: [].	ava := JDAPAva newForType: anLDAPAttribute name value: tVal.	[[self sendRequest: (JDAPCompareRequest newForDN: dnString attribValueAssertion: ava)			notify: myListener 			constraints: cons.	response := myListener getResponse.	resultCode := response protocolOp resultCode.	((JDAPResult resultForCode: resultCode) = 'COMPARE_FALSE')		ifTrue: [^ false].	((JDAPResult resultForCode: resultCode) = 'COMPARE_TRUE')		ifTrue: [^ true].	self checkMsg: response]		on: LDAPReferralException		do: [:ex | res := OrderedCollection new.				  self performReferrals: ex							constraints: cons							protocolOp: (JDAPProtocolOp codeForOperationType: 'COMPARE_REQUEST')							dn: dnString							scope: 0							filter: nil							attributes: nil							attributesOnly: false							mods: nil							entry: nil							attribute: anLDAPAttribute							results: res.				  aBoolean := false.				  res size &gt; 0					ifTrue: [aBoolean := res at: 1].				  ^ aBoolean]]		ensure: [self releaseResponseListener: myListener].	^ false</body></methods><methods><class-id>Net.LDAPConnection</class-id> <category>authenticating</category><body package="LDAP">authenticateAs: dnString password: pwString	self authenticateAs: dnString password: pwString version: self protocolVersion constraints: self defaultConstraints</body><body package="LDAP">authenticateAs: dnString password: pwString constraints: cons	self authenticateAs: dnString password: pwString version: self protocolVersion constraints: cons</body><body package="LDAP">authenticateAs: dnString password: pwString version: vInteger	self authenticateAs: dnString password: pwString version: vInteger constraints: self defaultConstraints</body><body package="LDAP">authenticateAs: dnString password: pwString version: vInteger constraints: cons	"Authenticates to the LDAP server (assumes that a connection has been established) using the specified distinguished name and password, and requesting that the server use at least the specified protocol version.  If the server doesn`t support that level, an LDAPException is thrown with the error code Protocol_Error.  This method allwos the user to specify the preferences for the bind operation."	prevBoundDN := boundDN.	prevBoundPasswd := boundPasswd.	boundDN := dnString.	boundPasswd := pwString.	(prevBoundDN isNil) | (prevBoundPasswd isNil)		ifTrue: [mAnonymousBound := true]		ifFalse: [mAnonymousBound := false].	self bindForVersion: vInteger rebind: true constraints: cons</body><body package="LDAP">saslBind: rebindBoolean	^ (LDAPException newForResultCode: 80) raiseSignal: 'SASL not implemented in this client'</body></methods><methods><class-id>Net.LDAPConnection</class-id> <category>processing</category><body package="LDAP">abandon: searchResults	"Abandons a current search operation, notifying the server not to send additional search results.  searchResults is an instance of LDAPSearchResults."	| id sendOk |		(connThread isNil) | (searchResults isNil)		ifTrue: [^ self].	searchResults abandon.	id := searchResults id.	sendOk := false.	3 timesRepeat: [		[ sendOk 			ifFalse: [connThread abandon: id.		  			connThread sendRequest: (JDAPAbandonRequest newForMessageId: id) 									notify: nil 									constraints: self defaultConstraints.					sendOk := true]]						on: Exception						do: ["Nothing"]].	connThread isNil		ifTrue: [(LDAPException newForResultCode: 80) raiseSignal: 'Failed to send abandon request to server'].</body><body package="LDAP">checkMsg: aJDAPMessage	"Checks the message (assumed to be a return value).  If the message resultCode is anything other than SUCCESS, it signals an LDAPException describing the server error response."	| response resultCode referrals |	(aJDAPMessage protocolOp isKindOf: JDAPResult)		ifTrue: [response := aJDAPMessage protocolOp.			    resultCode := response resultCode.			    (JDAPResult resultForCode: resultCode) = 'SUCCESS'					ifTrue: [^ self].			    (JDAPResult resultForCode: resultCode) = 'REFERRAL'					ifTrue: [^(LDAPReferralException 								newForResultCode: resultCode 								referrals: response referrals) 									raiseSignal: 'referral'].			    (JDAPResult resultForCode: resultCode) = 'LDAP_PARTIAL_RESULTS'					ifTrue: [^(LDAPReferralException 								newForResultCode: resultCode 								errorString: response errorMessage) 									raiseSignal: 'referral'].			    (LDAPException newForResultCode: resultCode)					raiseSignal: (response errorMessage, ' DN: ', response matchedDN)]		ifFalse: [(aJDAPMessage protocolOp isKindOf: JDAPSearchResultReference)					ifTrue: [referrals := aJDAPMessage protocolOp urls.						    (LDAPReferralException 								newForResultCode: 0 				"SUCCESS"								referrals: referrals) 									raiseSignal: 'referral']]</body><body package="LDAP">performExtendedReferrals: ex constraints: cons extendedOp: op	| urls connection results |	cons hopLimit &lt;= 0		ifTrue: [(LDAPException newForResultCode: ex resultCode)					raiseSignal: 'Exceed hop limit'].	cons referrals		ifFalse: [ex raiseSignal].	urls := ex getURLs.	"If there are no referrals (because the server isn't set up for them) give up here."	(urls isNil or: [urls size = 0])		ifTrue: [^ nil].	urls do: [:anURL |		[connection := self prepareReferral: anURL constraints: cons.		 results := connection extendedOperation: op.		 ^ results]		"Answer immediately if operation is successful"			on: LDAPException			do: [:exc | ]].	^ nil</body><body package="LDAP">performReferrals: except constraints: cons protocolOp: op dn: dn scope: scope filter: filter attributes: types attributesOnly: attrsOnly mods: mods entry: entry attribute: attribute results: results 	"Performs a referral. Parameter definitions: 	except  	LDAPReferralException returned initially by the server.	cons		LDAPSearchConstraints applying for these referral operations.	Note: the next parameters are a 'union' of different operation parameters:	op			Integer.  One of the Operation Types defined in JDAPProtocolOp class	dn			String representing a distinguished name.	scope		Integer representing the scope of a search	filter		String search filter.	types		Collection of Strings representing attribute types.	attrsOnly	Boolean, true if attribute values only are to be answered by search	mods		Collection of LDAPModification objects.	entry		LDAPEntry.	attribute	LDAPAttribute	Note: result answered by this referral operation:	result		OrderedCollection"	| urls tDN newDN theRes newcons continue connection |	cons hopLimit &lt;= 0 		ifTrue: 			[^(LDAPException newForResultCode: except resultCode) 				raiseSignal: 'Exceed hop limit'].	cons referrals 		ifFalse: 			[(JDAPProtocolOp codeForOperationType: 'SEARCH_REQUEST') = op 				ifTrue: 					[theRes := LDAPSearchResults new.					theRes addEntry: except.					results add: theRes.					^self]				ifFalse: [except raiseSignal]].	urls := except getURLs.	"If there are no referrals (because server is not set up for them, give up here"	urls isNil ifTrue: [^self].	urls do: 			[:aUrl | 			newDN := aUrl dn.			(newDN isNil or: [newDN size = 0]) 				ifTrue: [tDN := dn]				ifFalse: [tDN := newDN].			newcons := cons copy.			newcons hopLimit: cons hopLimit - 1.			continue := true.						[(mReferralConnection notNil and: 					[aUrl hostName = mReferralConnection host 						&amp; (aUrl portNumber = mReferralConnection port)]) 				ifTrue: 					[self 						performReferralsOnConnection: mReferralConnection						constraints: newcons						protocolOp: op						dn: tDN						scope: scope						filter: filter						attributes: types						attributesOnly: attrsOnly						mods: mods						entry: entry						attribute: attribute						results: results.					continue := false]] 					on: LDAPException					do: [:le | le resultCode ~= 50 ifTrue: [le pass]	"Insufficient Access Rights"].			continue 				ifTrue: 					[connection := self prepareReferral: aUrl constraints: cons.					connection authenticateAs: String new password: String new.					self 						performReferralsOnConnection: connection						constraints: newcons						protocolOp: op						dn: tDN						scope: scope						filter: filter						attributes: types						attributesOnly: attrsOnly						mods: mods						entry: entry						attribute: attribute						results: results]]</body><body package="LDAP">resultRetrieved	"Invoked when a search result has been retrieved from the incoming queue by a search listener.  Notify the connection thread so that it can unblock if it was waiting for the backlog to lighten."	self connThread isNil		ifFalse: [self connThread resultRetrieved]</body><body package="LDAP">sendRequest: request notify: listener constraints: cons	| |"	Transcript cr;  show: request printString, ' --&gt;' , request getParamString; cr."	connThread isNil		ifTrue: [^(LDAPException newForResultCode: 80) raiseSignal: 'The connection is not available'].	"Retry three times."	"success := false.	3 timesRepeat: [[		success			ifFalse: ["connThread sendRequest: request notify: listener constraints: cons.					"success := true]]			on: Exception			do: [:ex |" "Nothing" "]]."	connThread isNil		ifTrue: [(LDAPException newForResultCode: 80) raiseSignal: 'The connection is not available']</body></methods><methods><class-id>Net.LDAPConnection</class-id> <category>copying</category><body package="LDAP">copy	| newInstance oc |	newInstance := super copy.	self connThread isNil		ifTrue: [self bindWithConstraints: self defaultConstraints].	newInstance defaultConstraints: self defaultConstraints copy.	self class threadTableLock critical: [		oc := self class threadConnTable at: (self connThread) ifAbsent: [nil].		oc isNil			ifTrue: [self printDebug: 'Failed to copy connection'.				    ^ nil]			ifFalse: [oc add: newInstance]].	newInstance connThread register: newInstance.	^ newInstance</body><body package="LDAP">postCopy	super postCopy.	responseListeners := OrderedCollection new.	searchListeners := OrderedCollection new.	lock := RecursionLock new.	mResponseControlTable := Dictionary new.	^ self</body></methods><methods><class-id>Net.LDAPConnection</class-id> <category>initialize-release</category><body package="LDAP">initialize	defaultConstraints := LDAPSearchConstraints new.	responseListeners := OrderedCollection new.	searchListeners := OrderedCollection new.	bound := false.	host := String new.	mHostList := OrderedCollection new.	port := -1.	mDefaultPort := LDAPv2 defaultPort.	mPortList := OrderedCollection new.	boundDN := String new.	boundPasswd := String new.	protocolVersion := self class ldapVersion.	mAttachedList := OrderedCollection new.	mResponseControlTable := Dictionary new.	mAnonymousBound := false.	saslBind := false.	lock := RecursionLock new.</body><body package="LDAP">release	connThread isNil		ifFalse: [self disconnect].	super release.</body></methods><methods><class-id>Net.LDAPConnection class</class-id> <category>examples</category><body package="LDAP">example1	"Connect to a specific LDAP server.  Obtain the common name, surname, and e-mail attributes for an entry with a specific distinguished name.  Iterate over the returned attribute collection and print the results."	"LDAPConnection example1"	| foundEntry myConn dn attrs outStream attrStream subtypes first |	"Establish the connection.  No need to authenticate to this server."	myConn := LDAPConnection new.	[myConn connectToHost: 'sunspot.sjdccd.cc.ca.us' port: 389]		on: LDAPException		do: [:ex | myConn isConnected					ifTrue: [myConn disconnect].				  Dialog warn: 'Connection unsuccessful.  ', (ex toString).				  ^ String new].	"Specify the distinguished name of the entry to retrieve, and the desired attributes."	dn := 'cn=Matt Rosen,ou=Information Services,o=San Joaquin Delta College, c=US'.	attrs := #('cn' 'sn' 'mail').	"Conduct the search, making sure the connection is closed afterward."	[[foundEntry := myConn readDN: dn attributes: attrs]		on: LDAPException		do: [:ex | Dialog warn: 'LDAPException occurred.  ', (ex toString).				  ^ String new]]		ensure: [myConn disconnect].	"Now present the results."	outStream := WriteStream on: String new.	foundEntry getAttributeSet getAttributes do: [:anAttribute |		subtypes := anAttribute getSubtypes.		outStream nextPutAll: anAttribute name.		outStream nextPutAll: ': '.		" Show something reasonable for binary attribute values."		(subtypes includes: 'binary')			ifTrue: [outStream nextPutAll: ' binary data'.					outStream cr]			ifFalse: [first := true.					attrStream := anAttribute getStringValues.					[attrStream atEnd]						whileFalse: [							first								ifTrue: [first := false]								ifFalse: [outStream tab].							outStream nextPutAll: attrStream next.							outStream cr]].		outStream cr].	^ outStream contents</body><body package="LDAP">example10	"Connect to a specific LDAP server.  Perform a comparison to determine whether an existing entry contains an attribute with the specified value."	"LDAPConnection example10"	| myConn dn attribute result |	"Establish the connection.  No need to authenticate to this server."	myConn := LDAPConnection new.	[myConn connectToHost: 'sunspot.sjdccd.cc.ca.us' port: 9033]	 	on: LDAPException		do: [:ex | myConn isConnected					ifTrue: [myConn disconnect].				  Dialog warn: 'Connection unsuccessful.  ', (ex toString).				  ^ false].	"Specify the distinguished name of the base entry for search, the filter, and the desired attributes."	dn := 'uid=rcreel, ou=People, o=sjdccd.cc.ca.us'.	attribute := LDAPAttribute newWithName: 'title' withValue: 'Student'.	"Send the request and check the result, making sure the connection is closed afterward."	[[result := myConn compareDN: dn attribute: attribute]		on: LDAPException		do: [:ex | Dialog warn: 'LDAPException occurred.  ', (ex toString).				  ^ false]]		ensure: [myConn disconnect].	^ result</body><body package="LDAP">example11	"Identical to Example 5 (search using a filter), but specifies a server side control to sort the results by common name (cn)."	"This example currently does not work with Netscape Directory Server Version 3.1 or 4.0.  See SDK release notes."	"LDAPConnection example11"	| found foundEntry myConn dn filter attrs sk sc outStream attrStream subtypes first cons |	"Establish the connection.  No need to authenticate to this server."	myConn := LDAPConnection new.	"Note that to use server side controls we must utilize version 3 of the LDAP protocol."	myConn protocolVersion: 3.	[myConn connectToHost: 'sunspot.sjdccd.cc.ca.us' port: 9033]		on: LDAPException		do: [:ex | myConn isConnected					ifTrue: [myConn disconnect].				  Dialog warn: 'Connection unsuccessful.  ', (ex toString).				  ^ String new].	"Specify the distinguished name of the base entry for search, the filter, and the desired attributes."	dn := 'o=sjdccd.cc.ca.us'.	filter := 'cn=*'.	attrs := #('cn' 'mail').	cons := LDAPSearchConstraints new.	cons batch: 0.	sk := LDAPSortKey newFromKey: 'cn' reverse: false.	sc := LDAPSortControl newWithSortKey: sk critical: false.	cons addServerControl: sc.	"Conduct the search, making sure the connection is closed afterward."	[[found := myConn searchForDN: dn						scope: LDAPv2 scopeSub						filter: filter						attributes: attrs						attributesOnly: false						constraints: cons]		on: LDAPException		do: [:ex | Dialog warn: 'LDAPException occurred.  ', (ex toString).				  ^ String new].	"Now present the results.  The search answered an LDAPSearchResults object, so enumerate over it."	outStream := WriteStream on: String new.	[found hasMoreElements]		whileTrue: [foundEntry := found next.					foundEntry getAttributeSet getAttributes do: [:anAttribute |						subtypes := anAttribute getSubtypes.						outStream nextPutAll: anAttribute name.						outStream nextPutAll: ': '.						" Show something reasonable for binary attribute values."						(subtypes includes: 'binary')							ifTrue: [outStream nextPutAll: ' binary data'.									outStream cr]							ifFalse: [first := true.									attrStream := anAttribute getStringValues.									[attrStream atEnd]										whileFalse: [											first												ifTrue: [first := false]												ifFalse: [outStream tab].											outStream nextPutAll: attrStream next.											outStream cr]].						outStream cr]]]		ensure: [myConn disconnect].	^ outStream contents</body><body package="LDAP">example2	"Connect to a specific LDAP server.  Obtain all attributes for an entry with a specific distinguished name.  Iterate over the returned attribute collection and print the results."	"LDAPConnection example2"	| foundEntry myConn dn outStream attrStream subtypes first |	"Establish the connection.  No need to authenticate to this server."	myConn := LDAPConnection new.	[myConn connectToHost: 'sunspot.sjdccd.cc.ca.us' port: 9033]		on: LDAPException		do: [:ex | myConn isConnected					ifTrue: [myConn disconnect].				  Dialog warn: 'Connection unsuccessful.  ', (ex toString).				  ^ String new].	"Specify the distinguished name of the entry to retrieve."	dn := 'uid=mrosen,ou=People,o=sjdccd.cc.ca.us'.	"Conduct the search, making sure the connection is closed afterward."	[[foundEntry := myConn readDN: dn]		on: LDAPException		do: [:ex | Dialog warn: 'LDAPException occurred.  ', (ex toString).				  ^ String new]]	ensure: [myConn disconnect].	"Now present the results."	outStream := WriteStream on: String new.	foundEntry getAttributeSet getAttributes do: [:anAttribute |		subtypes := anAttribute getSubtypes.		outStream nextPutAll: anAttribute name.		outStream nextPutAll: ': '.		" Show something reasonable for binary attribute values."		(subtypes includes: 'binary')			ifTrue: [outStream nextPutAll: ' binary data'.					outStream cr]			ifFalse: [first := true.					attrStream := anAttribute getStringValues.					[attrStream atEnd]						whileFalse: [							first								ifTrue: [first := false]								ifFalse: [outStream tab].							outStream nextPutAll: attrStream next.							outStream cr]].		outStream cr].	^ outStream contents</body><body package="LDAP">example3	"Use an LDAP URL to obtain information about a particular named entry."	"LDAPConnection example3"	| aURL result outStream subtypes attrStream first |	"Construct the URL.  Note that uuencoding is optional."	"Example URL consists of:"	"Protocol identification			ldap"	"Host name and optional port	sunspot.sjdccd.cc.ca.us:389"	"Distinguished name				uid=mrosen...o=sjdccd.cc.ca.us"	"Attributes requested			cn,mail,sn"		aURL := LDAPUrl newFromString: 'ldap://sunspot.sjdccd.cc.ca.us:9033/uid=mrosen,ou=people,o=sjdccd.cc.ca.us?cn,mail,sn??'.	"Obtain the results using the URL"	[result := LDAPConnection readUrl: aURL]		on: LDAPException		do: [:ex | Dialog warn: 'LDAPException occurred.  ', ex toString.				  ^ String new].	"Now present the results."	outStream := WriteStream on: String new.	result getAttributeSet getAttributes do: [:anAttribute |		subtypes := anAttribute getSubtypes.		outStream nextPutAll: anAttribute name.		outStream nextPutAll: ': '.		" Show something reasonable for binary attribute values."		(subtypes includes: 'binary')			ifTrue: [outStream nextPutAll: ' binary data'.					outStream cr]			ifFalse: [first := true.					attrStream := anAttribute getStringValues.					[attrStream atEnd]						whileFalse: [							first								ifTrue: [first := false]								ifFalse: [outStream tab].							outStream nextPutAll: attrStream next.							outStream cr]].		outStream cr].	^ outStream contents</body><body package="LDAP">example3a	"Use an LDAP URL to search for entries matching a filter."	"LDAPConnection example3a"	| aURL outStream subtypes attrStream first found foundEntry |	"Construct the URL.  Note that uuencoding is optional."	"Example URL consists of:"	"Protocol identification				ldap"	"Host name and optional port		sunspot.sjdccd.cc.ca.us:9033"	"Distinguished name search base	ou=people,o=sjdccd.cc.ca.us"	"Attributes requested				cn,mail,sn"	"Scope of search					sub"	"Search filter						(&amp;(objectclass=person)(title=Student))"		aURL := LDAPUrl newFromString: 'ldap://sunspot.sjdccd.cc.ca.us:9033/ou=people,o=sjdccd.cc.ca.us?cn,mail,sn?sub?(&amp;(objectclass=person)(title=Student))'.	"Obtain the results using the URL"	[found := LDAPConnection searchUrl: aURL]		on: LDAPException		do: [:ex | Dialog warn: 'LDAPException occurred.  ', ex toString.				  ^ String new].	"Now present the results.  The search answered an LDAPSearchResults object, so enumerate over it."	outStream := WriteStream on: String new.	[found hasMoreElements]		whileTrue: [foundEntry := found next.					foundEntry getAttributeSet getAttributes do: [:anAttribute |						subtypes := anAttribute getSubtypes.						outStream nextPutAll: anAttribute name.						outStream nextPutAll: ': '.						" Show something reasonable for binary attribute values."						(subtypes includes: 'binary')							ifTrue: [outStream nextPutAll: ' binary data'.									outStream cr]							ifFalse: [first := true.									attrStream := anAttribute getStringValues.									[attrStream atEnd]										whileFalse: [											first												ifTrue: [first := false]												ifFalse: [outStream tab].											outStream nextPutAll: attrStream next.											outStream cr]].						outStream cr]].	^ outStream contents</body><body package="LDAP">example4	"Obtain the schema of a directory."	"LDAPConnection example4"	| myConn theSchema |	myConn := LDAPConnection new.	[myConn connectToHost: 'sunspot.sjdccd.cc.ca.us' port: 389]		on: LDAPException		do: [:ex | myConn isConnected					ifTrue: [myConn disconnect].				  Dialog warn: 'Connection unsuccessful.  ', (ex toString).				  ^ String new].	theSchema := LDAPSchema new.	[[theSchema fetchSchemaUsingConnection: myConn]		on: LDAPException		do: [:ex | Dialog warn: 'LDAPException: ', ex toString.				  ^ String new]]	ensure: [myConn disconnect].	^ theSchema</body><body package="LDAP">example5	"Connect to a specific LDAP server.  Obtain the common name and e-mail attributes for any entries at or below a designated base distinguished name which match a search filter criteria.  Iterate over the returned results and print the results."	"LDAPConnection example5"	| found foundEntry myConn dn filter attrs outStream attrStream subtypes first cons |	"Establish the connection.  No need to authenticate to this server."	myConn := LDAPConnection new.	[myConn connectToHost: 'sunspot.sjdccd.cc.ca.us' port: 9033]		on: LDAPException		do: [:ex | myConn isConnected					ifTrue: [myConn disconnect].				  Dialog warn: 'Connection unsuccessful.  ', (ex toString).				  ^ String new].	"Specify the distinguished name of the base entry for search, the filter, and the desired attributes."	dn := 'o=sjdccd.cc.ca.us'.	filter := 'cn=*'.	attrs := #('cn' 'mail').	cons := LDAPSearchConstraints new.	cons batch: 0.	"Conduct the search, making sure the connection is closed afterward."	[[found := myConn searchForDN: dn						scope: LDAPv2 scopeSub						filter: filter						attributes: attrs						attributesOnly: false						constraints: cons]		on: LDAPException		do: [:ex | Dialog warn: 'LDAPException occurred.  ', (ex toString).				  ^ String new].	"Now present the results.  The search answered an LDAPSearchResults object, so enumerate over it."	outStream := WriteStream on: String new.	[found hasMoreElements]		whileTrue: [foundEntry := found next.					foundEntry getAttributeSet getAttributes do: [:anAttribute |						subtypes := anAttribute getSubtypes.						outStream nextPutAll: anAttribute name.						outStream nextPutAll: ': '.						" Show something reasonable for binary attribute values."						(subtypes includes: 'binary')							ifTrue: [outStream nextPutAll: ' binary data'.									outStream cr]							ifFalse: [first := true.									attrStream := anAttribute getStringValues.									[attrStream atEnd]										whileFalse: [											first												ifTrue: [first := false]												ifFalse: [outStream tab].											outStream nextPutAll: attrStream next.											outStream cr]].						outStream cr]]]		ensure: [myConn disconnect].	^ outStream contents</body><body package="LDAP">example6	"Connect to a specific LDAP server.  Modify a particular entry, identified by distinuished name, by adding an attribute value to it."	"LDAPConnection example6"	| myConn dn mods attribute |	"Establish the connection.  Need to authenticate to this server."	myConn := LDAPConnection new.	[myConn connectToHost: 'sunspot.sjdccd.cc.ca.us' port: 9033 dn:'cn=Directory Manager' password: 'xyzxyz3']	 	on: LDAPException		do: [:ex | myConn isConnected					ifTrue: [myConn disconnect].				  Dialog warn: 'Connection unsuccessful.  ', (ex toString).				  ^ String new].	"Specify the distinguished name of the base entry for search, the filter, and the desired attributes."	dn := 'uid=mrosen, ou=People, o=sjdccd.cc.ca.us'.	attribute := LDAPAttribute newWithName: 'title' withValue: 'Scholar'.	mods := LDAPModificationSet new.	mods addModificationWithOperation: (LDAPModification addOperation) attribute: attribute.	"Send the request and check the result, making sure the connection is closed afterward."	[[myConn modifyDN: dn				modificationSet: mods]		on: LDAPException		do: [:ex | Dialog warn: 'LDAPException occurred.  ', (ex toString).				  ^ String new]]		ensure: [myConn disconnect]</body><body package="LDAP">example7	"Connect to a specific LDAP server.  Add a new entry with a specified distinguished name."	"LDAPConnection example7"	| myConn dn attributes valArray entry |	"Establish the connection. Need to authenticate to this server."	myConn := LDAPConnection new.	[myConn connectToHost: 'sunspot.sjdccd.cc.ca.us' port: 9033 dn:'cn=Directory Manager' password: 'xyzxyz3']	 	on: LDAPException		do: [:ex | myConn isConnected					ifTrue: [myConn disconnect].				  Dialog warn: 'Connection unsuccessful.  ', (ex toString).				  ^ String new].	"Specify the distinguished name of the base entry for search, the filter, and the desired attributes."	dn := 'uid=alewman, ou=People, o=sjdccd.cc.ca.us'.	attributes := LDAPAttributeSet new.	valArray := Array new: 4.	valArray at: 1 put: 'top'.	valArray at: 2 put: 'person'.	valArray at: 3 put: 'organizationalPerson'.	valArray at: 4 put: 'inetorgperson'.	attributes addAttribute: (LDAPAttribute newWithName: 'objectclass' withValues: valArray).	attributes addAttribute: (LDAPAttribute newWithName: 'uid' withValue: 'ALewman').	attributes addAttribute: (LDAPAttribute newWithName: 'cn' withValue: 'Aubrey Lewman').	attributes addAttribute: (LDAPAttribute newWithName: 'givenname' withValue: 'Aubrey').	attributes addAttribute: (LDAPAttribute newWithName: 'sn' withValue: 'Lewman').	attributes addAttribute: (LDAPAttribute newWithName: 'mail' withValue: 'alewman@sjdccd.cc.ca.us').	attributes addAttribute: (LDAPAttribute newWithName: 'telephonenumber' withValue: '(209)954-5300').	attributes addAttribute: (LDAPAttribute newWithName: 'facsimiletelephonenumber' withValue: '(209)954-5302').	attributes addAttribute: (LDAPAttribute newWithName: 'title' 								  withValues: (Array with: 'Programmer/Analyst I' with: 'Student')).	entry := LDAPEntry newWithName: dn attributeSet: attributes.	"Send the request and check the result, making sure the connection is closed afterward."	[[myConn add: entry]		on: LDAPException		do: [:ex | Dialog warn: 'LDAPException occurred.  ', (ex toString).				  ^ String new]]		ensure: [myConn disconnect]</body><body package="LDAP">example8	"Connect to a specific LDAP server.  Rename an existing entry to a new relative distinguished name.  Note that you cannot change which entry is the parent of the specified entry."	"LDAPConnection example8"	| myConn dn newRdn |	"Establish the connection.  Need to authenticate to this server."	myConn := LDAPConnection new.	[myConn connectToHost: 'sunspot.sjdccd.cc.ca.us' port: 9033 dn:'cn=Directory Manager' password: 'xyzxyz3']	 	on: LDAPException		do: [:ex | myConn isConnected					ifTrue: [myConn disconnect].				  Dialog warn: 'Connection unsuccessful.  ', (ex toString).				  ^ String new].	"Specify the distinguished name of the base entry for search, the filter, and the desired attributes."	dn := 'uid=alewman, ou=People, o=sjdccd.cc.ca.us'.	newRdn := 'uid=aubreyLewman'.	"Send the request and check the result, making sure the connection is closed afterward."	[[myConn renameDN: dn newRDN: newRdn deleteOld: true]		on: LDAPException		do: [:ex | Dialog warn: 'LDAPException occurred.  ', (ex toString).				  ^ String new]]		ensure: [myConn disconnect]</body><body package="LDAP">example9	"Connect to a specific LDAP server.  Delete an existing entry identified by a distinguished name."	"LDAPConnection example9"	| myConn dn |	"Establish the connection.  Need to authenticate to this server."	myConn := LDAPConnection new.	[myConn connectToHost: 'sunspot.sjdccd.cc.ca.us' port: 9033 dn:'cn=Directory Manager' password: 'xyzxyz3']	 	on: LDAPException		do: [:ex | myConn isConnected					ifTrue: [myConn disconnect].				  Dialog warn: 'Connection unsuccessful.  ', (ex toString).				  ^ String new].	"Specify the distinguished name of the base entry for search, the filter, and the desired attributes."	dn := 'uid=aubreylewman, ou=People, o=sjdccd.cc.ca.us'.	"Send the request and check the result, making sure the connection is closed afterward."	[[myConn deleteDN: dn]		on: LDAPException		do: [:ex | Dialog warn: 'LDAPException occurred.  ', (ex toString).				  ^ String new]]		ensure: [myConn disconnect]</body></methods><methods><class-id>Net.LDAPConnection class</class-id> <category>accessing</category><body package="LDAP">readConstraints	^ ReadConstraints</body><body package="LDAP">threadConnTable	^ ThreadConnTable</body><body package="LDAP">threadTableLock	^ ThreadTableLock</body></methods><methods><class-id>Net.LDAPConnection class</class-id> <category>constants</category><body package="LDAP">defaultFilter	^ '(objectClass=*)'</body><body package="LDAP">delim	^ $#</body><body package="LDAP">ldapPropertyProtocol	^ 'version.protocol'</body><body package="LDAP">ldapPropertySDK	^ 'version.sdk'</body><body package="LDAP">ldapPropertySecurity	^ 'version.security'</body><body package="LDAP">ldapVersion	^ 3</body><body package="LDAP">majorVersion	^ 3.0</body><body package="LDAP">maxBacklog	"Option specifying the maximum number of unread entries to be cached in any LDAPSearchResults without suspending reading from the server."	^ 30</body><body package="LDAP">minorVersion	^0.05</body><body package="LDAP">persistSearchPackageName	^ 'LDAPPersistSearchControl'</body><body package="LDAP">protocolVersion	^ 3.0</body><body package="LDAP">sdkVersion	^ 3.04</body><body package="LDAP">securityVersion	^ 'none,simple'</body></methods><methods><class-id>Net.LDAPConnection class</class-id> <category>utilities</category><body package="LDAP">printDebug: aString	Transcript show: aString; cr</body><body package="LDAP">readUrl: anLDAPUrl	"Answers the LDAPEntry specified by the given LDAPUrl.  When this method is invoked, a new connection is created automatically using the host and port specified in the URL.  After finding the entry, the method closes this connection (disconnects from the LDAP server).  If the URL specifies a filter and scope, these are not used.  Of the information specified in the URL, this method only uses the LDAP host name, port number, the base distinguished name (DN), and the list of attributes to return."	| theHost thePort theAttributes theDN returnVal instance |	theHost := anLDAPUrl hostName.	thePort := anLDAPUrl portNumber.	(theHost isNil or: [theHost size = 0])		ifTrue: [(LDAPException newForResultCode: 89) raiseSignal: 'No host for connection'].	theAttributes := anLDAPUrl attributes.	theDN := anLDAPUrl dn.	instance := self new.	instance connectToHost: theHost port: thePort.	[returnVal := instance readDN: theDN attributes: theAttributes]		ensure: [instance disconnect].	^ returnVal</body><body package="LDAP">searchUrl: anLDAPUrl	"Performs the search specified by the LDAP URL."	^ self searchUrl: anLDAPUrl constraints: nil</body><body package="LDAP">searchUrl: anLDAPUrl constraints: cons	"Performs the search specified by the given LDAPUrl.  This method also allows you to specify constraints for the search (such as the maximum number of entries to find or the maximum time to wait for the search results.  As part of the search constraints, you can specify whether or not you want the results delivered all at once or in smaller batches.  If you specify that you want the results delivered in smaller batches, each iteration blocks until the next batch of results is returned."	| theHost thePort theAttributes theDN theScope theFilter instance results |	theHost := anLDAPUrl hostName.	thePort := anLDAPUrl portNumber.	(theHost isNil or: [theHost size = 0])		ifTrue: [(LDAPException newForResultCode: 89) raiseSignal: 'No host for connection'].	theAttributes := anLDAPUrl attributes.	theDN := anLDAPUrl dn.	theFilter := anLDAPUrl filter.	(theFilter isNil or: [theFilter size = 0])		ifTrue: [theFilter := self defaultFilter].	theScope := anLDAPUrl scope.	instance := self new.	instance connectToHost: theHost port: thePort.	results := instance 				searchForDN: theDN				scope: theScope				filter: theFilter				attributes: theAttributes				attributesOnly: false				constraints: cons.	results closeOnCompletion: instance.	^ results</body></methods><methods><class-id>Net.LDAPConnection class</class-id> <category>class initialization</category><body package="LDAP">initialize	"LDAPConnection initialize"	ReadConstraints := LDAPSearchConstraints new.	ThreadConnTable := Dictionary new.	ThreadTableLock := RecursionLock new.</body></methods><methods><class-id>Net.LDAPConnection class</class-id> <category>instance creation</category><body package="LDAP">new	^ self basicNew initialize</body></methods><methods><class-id>Net.JDAPFilterOr class</class-id> <category>instance creation</category><body package="LDAP">new	| tag |	tag := ((BERElement tag: 'Constructed') bitOr: (BERElement tag: 'Context')) bitOr: 1.	^ self newForTag: tag</body></methods><methods><class-id>Net.BERNumericString</class-id> <category>printing</category><body package="LDAP">toString	mValue isNil		ifTrue: [^ 'NumericString {}'].	^ 'NumericString {', mValue, '}'</body></methods><methods><class-id>Net.BERNumericString</class-id> <category>accessing</category><body package="LDAP">getType	^ self class type: 'NumericString'</body></methods><methods><class-id>Net.LDAPResponseListener</class-id> <category>initialize-release</category><body package="LDAP">initialize	exceptionOccured := false.	controls := OrderedCollection new.	id := 0.	queue := SharedQueue new: 1.	^ self</body><body package="LDAP">reset	exceptionOccured := false.</body></methods><methods><class-id>Net.LDAPResponseListener</class-id> <category>accessing</category><body package="LDAP">connection	^ connection</body><body package="LDAP">connection: anLDAPConnection	connection := anLDAPConnection</body><body package="LDAP">controls	^ controls</body><body package="LDAP">controls: aCollectionOfLDAPControls	controls := aCollectionOfLDAPControls</body><body package="LDAP">exception	^ exception</body><body package="LDAP">exception: anLDAPException	exception := anLDAPException.	self exceptionOccured: true</body><body package="LDAP">exceptionOccured	^ exceptionOccured</body><body package="LDAP">exceptionOccured: aBoolean	exceptionOccured := aBoolean</body><body package="LDAP">id	^ id</body><body package="LDAP">id: anInteger	id := anInteger</body><body package="LDAP">queue	^ queue</body><body package="LDAP">response	^ response</body></methods><methods><class-id>Net.LDAPResponseListener</class-id> <category>processing</category><body package="LDAP">getResponse	response := queue next.	self exceptionOccured		ifTrue: [exception raiseSignal]. 	^ response</body></methods><methods><class-id>Net.LDAPResponseListener class</class-id> <category>instance creation</category><body package="LDAP">newForConnection: anLDAPConnection	| instance |	instance := self basicNew initialize.	instance connection: anLDAPConnection.	^ instance</body></methods><methods><class-id>Net.JDAPCompareRequest</class-id> <category>encoding</category><body package="LDAP">getBERElement	| seq element tag |	seq := BERSequence new.	seq addElement: (BEROctetString newFromString: self baseDN).	seq addElement: (self ava getBERElement).	tag := ((BERElement tag: 'Application') bitOr: (BERElement tag: 'Constructed')) bitOr: 14.	element := BERTag					newWithTag: tag					element: seq					implicit: true.	^ element</body></methods><methods><class-id>Net.JDAPCompareRequest</class-id> <category>accessing</category><body package="LDAP">ava	^ mAva</body><body package="LDAP">ava: aJDAPAva	mAva := aJDAPAva</body><body package="LDAP">getType	^ JDAPProtocolOp codeForOperationType: 'COMPARE_REQUEST'</body></methods><methods><class-id>Net.JDAPCompareRequest</class-id> <category>initialize-release</category><body package="LDAP">initialize	super initialize.	mAva := JDAPAva new.	^ self</body></methods><methods><class-id>Net.JDAPCompareRequest</class-id> <category>printing</category><body package="LDAP">getParamString	| paramStream |	paramStream := WriteStream on: String new.	paramStream nextPutAll: '{entry='.	paramStream nextPutAll: self baseDN.	paramStream nextPutAll: ', ava='.	paramStream nextPutAll: self ava printString.	paramStream nextPutAll: '}'.	^ paramStream contents</body></methods><methods><class-id>Net.JDAPCompareRequest class</class-id> <category>instance creation</category><body package="LDAP">newForDN: dnString attribValueAssertion: anAva	| instance |	instance := self new.	instance baseDN: dnString.	instance ava: anAva.	^ instance</body></methods><methods><class-id>Net.LDAPReferralException</class-id> <category>accessing</category><body package="LDAP">addReferral: aString	mReferrals add: aString</body><body package="LDAP">getURLs	^ self referrals collect: [:aString | LDAPUrl newFromString: aString]</body><body package="LDAP">messageText		^ LDAPException errorMessageFor: self resultCode</body><body package="LDAP">referrals	^ mReferrals</body><body package="LDAP">referrals: aCollectionOfStrings	mReferrals := aCollectionOfStrings</body><body package="LDAP">resultCode	^ resultCode</body><body package="LDAP">resultCode: anInteger	resultCode := anInteger</body></methods><methods><class-id>Net.LDAPReferralException</class-id> <category>initialize-release</category><body package="LDAP">initialize	super initialize.	mReferrals := OrderedCollection new.	^ self</body></methods><methods><class-id>Net.LDAPReferralException</class-id> <category>printing</category><body package="LDAP">toString	| errorStream |	errorStream := WriteStream on: String new.	errorStream nextPutAll: 'Error Code '.	errorStream nextPutAll: self resultCode asString.	errorStream nextPutAll: ' '.	errorStream nextPutAll: self messageText.	^ errorStream contents</body></methods><methods><class-id>Net.LDAPReferralException</class-id> <category>utilities</category><body package="LDAP">extractReferralsFromString: errorString	| st seenReferral v token |	(errorString isNil or: [errorString size = 0])		ifTrue: [^ OrderedCollection new].	st := ReadStream on: (errorString tokensBasedOn: Character cr).	seenReferral := false.	v := OrderedCollection new.	[st atEnd]		whileFalse: [			token := st next.			seenReferral				ifTrue: [v add: token]				ifFalse: [(token match: 'Referral:*')							ifTrue: [seenReferral := true]]].	^ v</body></methods><methods><class-id>Net.LDAPReferralException class</class-id> <category>instance creation</category><body package="LDAP">newForResultCode: anInteger	| instance |	instance := self new.	instance resultCode: anInteger.	^ instance</body><body package="LDAP">newForResultCode: anInteger errorString: aString	| instance |	instance := self newForResultCode: anInteger.	instance referrals: (instance extractReferralsFromString: aString).	^ instance</body><body package="LDAP">newForResultCode: anInteger referrals: aCollection	| instance |	instance := self newForResultCode: anInteger.	instance referrals: aCollection.	^ instance</body></methods><methods><class-id>Net.JDAPModifyResponse</class-id> <category>accessing</category><body package="LDAP">getType	^ JDAPProtocolOp codeForOperationType: 'MODIFY_RESPONSE'</body></methods><methods><class-id>Net.JDAPModifyResponse class</class-id> <category>instance creation</category><body package="LDAP">newFromBERTag: aBERTag	^ self newFromBERElement: (aBERTag getValue)</body></methods><methods><class-id>Net.JDAPBERTagDecoder</class-id> <category>utilities</category><body package="LDAP">getElementFrom: inStream decoder: aBERTagDecoder tag: tag bytesRead: anArray implicit: implicit	"Gets an application specific BER element from the input stream"	| element |	implicit at: 1 put: true.	(#(96 97 99 100 101 103 104 105 106 107 109 111 115 120) includes: tag)  "104"		ifTrue: [element := BERSequence newFrom: inStream decoder: aBERTagDecoder bytesRead: anArray].	tag = 128		ifTrue: [element := BERInteger newFrom: inStream bytesRead: anArray].	"a) Handle Microsoft v3 referral bugs"	"b) Handle Microsoft v3 supportedVersion in Bind response"	tag = 133		ifTrue: [element := BERInteger newFrom: inStream bytesRead: anArray].	"Handle Microsoft Filter 'present' in search request"	tag = 135		ifTrue: [element := BEROctetString newFrom: inStream decoder: aBERTagDecoder bytesRead: anArray].	"Handle extended response"	((tag = 138) | (tag = 139))		ifTrue: [element := BEROctetString newFrom: inStream decoder: aBERTagDecoder bytesRead: anArray].	"Handle Microsoft v3 sasl bind request"	tag = 163		ifTrue: [element := BERSequence newFrom: inStream decoder: aBERTagDecoder bytesRead: anArray].	"Handle Microsoft v3 serverCred in bind response.  MS encodes it as a SEQUENCE OF while it should be"	"encoded as a CHOICE OF"	tag = 167		ifTrue: [element := BERSequence newFrom: inStream decoder: aBERTagDecoder bytesRead: anArray].	"v3 Server Control"	"SEQUENCE OF SEQUENCE OF {OID [critical] [value]}"	tag = 160		ifTrue: [element := BERSequence newFrom: inStream decoder: aBERTagDecoder bytesRead: anArray].	element isNil		ifTrue: [self error: 'Unknown tag value'].	^ element</body></methods><methods><class-id>Net.LDAPSearchResults</class-id> <category>asynchronous</category><body package="LDAP">abandon	lock critical: [self searchComplete: true]</body><body package="LDAP">associate: aListener	"Prepares to return asynchronous results froma search.  aListener is the LDAPSearchListener providing the results."	self resultSource: aListener.	self searchComplete: false.</body><body package="LDAP">associatePersistentSearch: aListener	"Prepares to return asynchronous results froma search.  aListener is the LDAPSearchListener providing the results."	self resultSource: aListener.	self persistentSearch: true.	self searchComplete: false.	self firstResult: true</body><body package="LDAP">closeOnCompletion: aConnection	"For asynchronous search, this mechanism allows the application to close aConnection whenever the search completes."	self searchComplete		ifTrue: [ [aConnection disconnect]					on: LDAPException					do: [] ]		ifFalse: [self connectionToClose: aConnection]</body><body package="LDAP">fetchResult	"Fetches the next result, for asynchronous searches."	| msg response |		Processor activeProcess yield.	self resultSource notNil		ifTrue: [lock critical: [					((self searchComplete) | (self firstResult))						ifTrue: [self firstResult: false.							    ^ nil].					msg := resultSource nextResult.					(msg isNil)						ifTrue: ["Check response and see if we need to do referral"							    "v2: Referral is stored in the JDAPResult"							    [[response := resultSource response.								currConn 									checkSearchMsg: self									response: response									constraints: self currCons									base: self currBase									scope: self currScope									filter: self currFilter									attributes: self currAttrs									attributesOnly: self currAttrsOnly]										on: LDAPException										do: [:ex | Transcript show: 'Exception: ', ex toString; cr]]									ensure: [currConn releaseSearchListener: resultSource].								self searchComplete: true.								self connectionToClose notNil									ifTrue: [[self connectionToClose disconnect]												on: LDAPException												do: []]]						ifFalse: [[currConn 									checkSearchMsg: self									response: msg									constraints: self currCons									base: self currBase									scope: self currScope									filter: self currFilter									attributes: self currAttrs									attributesOnly: self currAttrsOnly]										on: LDAPException										do: [:ex | Transcript show: 'Exception: ', ex toString; cr]]]]</body></methods><methods><class-id>Net.LDAPSearchResults</class-id> <category>accessing</category><body package="LDAP">addEntry: aJDAPProtocolOp	(aJDAPProtocolOp isKindOf: JDAPSearchResponse)		ifTrue: [self addSearchResponse: aJDAPProtocolOp].	(aJDAPProtocolOp isKindOf: JDAPSearchResultReference)		ifTrue: [self addSearchResultReference: aJDAPProtocolOp].	(aJDAPProtocolOp isKindOf: LDAPException)		ifTrue: [entries add: aJDAPProtocolOp].	(aJDAPProtocolOp isKindOf: LDAPReferralException)		ifTrue: [entries add: aJDAPProtocolOp]</body><body package="LDAP">addReferralEntries: aLDAPSearchResults	referralResults add: aLDAPSearchResults</body><body package="LDAP">connectionToClose	^connectionToClose</body><body package="LDAP">connectionToClose: anLDAPConnection	connectionToClose := anLDAPConnection</body><body package="LDAP">currAttrs	^currAttrs</body><body package="LDAP">currAttrs: aCollection	currAttrs := aCollection</body><body package="LDAP">currAttrsOnly	^currAttrsOnly</body><body package="LDAP">currAttrsOnly: aBoolean	currAttrsOnly := aBoolean</body><body package="LDAP">currBase	^currBase</body><body package="LDAP">currBase: aString	currBase := aString</body><body package="LDAP">currConn	^currConn</body><body package="LDAP">currConn: anLDAPConnection	currConn := anLDAPConnection</body><body package="LDAP">currCons	^currCons</body><body package="LDAP">currCons: anLDAPSearchConstraints	currCons := anLDAPSearchConstraints</body><body package="LDAP">currFilter	^currFilter</body><body package="LDAP">currFilter: aString	currFilter := aString</body><body package="LDAP">currScope	^currScope</body><body package="LDAP">currScope: anInteger	currScope := anInteger</body><body package="LDAP">entries	^ entries</body><body package="LDAP">entries: aCollection	^ entries := aCollection</body><body package="LDAP">firstResult	^firstResult</body><body package="LDAP">firstResult: aBoolean	firstResult := aBoolean</body><body package="LDAP">id	((resultSource isNil) | searchComplete)		ifTrue: [^ -1].	^ resultSource id</body><body package="LDAP">persistentSearch	^persistentSearch</body><body package="LDAP">persistentSearch: aBoolean	persistentSearch := aBoolean</body><body package="LDAP">referralResults	^ referralResults</body><body package="LDAP">resultSource	^resultSource</body><body package="LDAP">resultSource: aLDAPSearchListener	resultSource := aLDAPSearchListener</body><body package="LDAP">searchComplete	^searchComplete</body><body package="LDAP">searchComplete: aBoolean	searchComplete := aBoolean".  self halt.	aBoolean &amp; (self resultSource notNil)		ifTrue: [self resultSource resultSemaphore signal]"</body></methods><methods><class-id>Net.LDAPSearchResults</class-id> <category>private</category><body package="LDAP">addSearchResponse: sr	"Adds one JDAPSearchResponse (sr) to the collection of entries."	| lattrs attrs dn entry |	lattrs := sr attributes.	lattrs isNil		ifTrue: [attrs := LDAPAttributeSet new]		ifFalse: [attrs := LDAPAttributeSet 							newFromAttributes: (lattrs collect: [:aBERSeq | 														LDAPAttribute newFromBERElement: aBERSeq])].	dn := sr objectName.	entry := LDAPEntry newWithName: dn attributeSet: attrs.	entries add: entry</body><body package="LDAP">addSearchResultReference: sr	"Adds an JDAPSearchResultReference instance (sr) to the collection of entries."	| urls |	urls := sr urls.	urls isNil		ifFalse: [entries add: (LDAPReferralException newForResultCode: 0 referrals: urls)]</body><body package="LDAP">nextElement	entries size &gt; 0		ifTrue: [^ entries removeFirst].	referralResults size &gt; 0		ifTrue: [^ self nextReferralElement].	^ nil</body><body package="LDAP">nextReferralElement	| res obj |	res := referralResults first.	(((res persistentSearch not) &amp; (res hasMoreElements)) | res persistentSearch)		ifTrue: [obj := res nextElement.			    obj notNil					ifTrue: [^ obj].			    res hasMoreElements					ifFalse: [referralResults removeFirst]]		ifFalse: [referralResults removeFirst].	^ nil</body></methods><methods><class-id>Net.LDAPSearchResults</class-id> <category>enumerating</category><body package="LDAP">getCount	"Answer a count of the entries in the search results."	| totReferralEntries |	totReferralEntries := referralResults							inject: 0							into: [:subtotal :res |								subtotal + (res getCount)].	^ (entries size + totReferralEntries)</body><body package="LDAP">next	"Answers the next LDAPEntry object from the search results and signals an exception if the next result is a referral, or if a size limit or time limit error occurs."	"Example code fragment:"	"| res findEntry |	res := aConnection search (...).	[res hasMoreElements]		whileTrue: [[findEntry := res next]						on: LDAPException, LDAPReferralException						do: [:ex |								(ex isKindOf: LDAPException)									ifTrue: [... code for handling limit errors...										    ex return]									ifFalse: [ex urls do: [:aURL | ...code for handing referrals...].											ex resume: referralResult]]]"	| obj |	obj := self nextElement.	(obj isKindOf: Exception)		ifTrue: [obj class raiseSignal: obj description].	(obj isKindOf: LDAPEntry)		ifTrue: [^ obj].	^ nil</body><body package="LDAP">sortUsingComparator: compare	"Sorts the search results."	"compare (instance of LDAPEntryComparator) determines the sort order used.  For example, if the comparator uses the uid attribute for comparison, the search results are sorted according to uid."	"Example code fragment:"	"| sortAttrs ascending ldapConn res |	sortAttrs :=Array with: 'sn' with: 'cn'.	ascending := Array with: true with: true.	ldapConn := LDAPConnection new.	ldapConn connect.  (...)	res := ldapConn search.  (...) (res is an LDAPSearchResults)	res sortUsingComparator: (LDAPCompareAttrNames newComparingAttributes: sortAttrs ascendings: ascending)."	"Note: If search results arrive asynchronously, this method blocks until all of the results are returned."	"If some of the elements have already been fetched, the 'stream' is reset to the (new) first element."	lock		critical: [	| obj numEntries toSort |	[searchComplete]		whileFalse: [self fetchResult].	"If automatic referral is being performed, add to the entries, otherwise don't do it since the elements in"	"referralResults are LDAPReferralException objects"	currCons referrals		ifTrue: [[referralResults size &gt; 0]					whileTrue: [obj := self nextReferralElement.							    obj isNil									ifFalse: [entries add: obj]]].	numEntries := entries size.	numEntries = 0		ifTrue: [^ self].	toSort := SortedCollection 				withAll: entries				sortBlock: [:t1 :t2 | (compare ldapEntry: t1 isGreaterThan: t2) not].	entries := OrderedCollection new: toSort size.	toSort do: [:each | entries add: each]	]	"End of RecursionLock critical:"</body></methods><methods><class-id>Net.LDAPSearchResults</class-id> <category>initialize-release</category><body package="LDAP">initialize	entries := OrderedCollection new.	searchComplete := false.	persistentSearch := false.	currCons := LDAPSearchConstraints new.	currBase := String new.	currScope := LDAPv2 scopeBase.	currFilter := String new.	currAttrs := OrderedCollection new.	referralResults := OrderedCollection new.	firstResult := false.	lock := RecursionLock new.	^ self</body></methods><methods><class-id>Net.LDAPSearchResults</class-id> <category>testing</category><body package="LDAP">hasMoreElements	"Answers true if there are more available elements in this search results object."	| res |	[(entries size = 0) &amp; (searchComplete not)]		whileTrue: [self fetchResult].	[referralResults size &gt; 0]		whileTrue: [res := referralResults first.				    res hasMoreElements						ifTrue: [^ true]						ifFalse: [referralResults removeFirst]].	^ (entries size &gt; 0)</body></methods><methods><class-id>Net.LDAPSearchResults class</class-id> <category>instance creation</category><body package="LDAP">new	| instance |	instance := self basicNew initialize.	instance searchComplete: true.	^ instance</body><body package="LDAP">newForConnection: aLDAPConnection constraints: aLDAPConstraints base: baseString scope: scopeInteger filter: filterString attributes: attrCollection attrsOnly: attrOnlyBoolean	| instance |	instance := self new.	instance currConn: aLDAPConnection.	instance currCons: aLDAPConstraints.	instance currBase: baseString.	instance currScope: scopeInteger.	instance currFilter: filterString.	instance currAttrs: attrCollection.	instance currAttrsOnly: attrOnlyBoolean.	^ instance</body><body package="LDAP">newForResults: aCollection	"Answers an LDAPSearchResults for the results contained in aCollection.  Used when returning results from a cache."	| instance |	instance := self new.	instance entries: aCollection copy.	"Each cache value is represented by an OrderedCollection.  The first element"	"represents the size of all the LDAPEntries.  This needs to be removed before"	"iterating through each LDAPEntry."	(instance entries notNil and: [instance entries size &gt; 0])		ifTrue: [instance entries removeAtIndex: 1].	^ instance</body><body package="LDAP">newForResults: aCollection connection: aLDAPConnection constraints: aLDAPConstraints base: baseString scope: scopeInteger filter: filterString attributes: attrCollection attrsOnly: attrOnlyBoolean	| instance |	instance := self newForResults: aCollection.	instance currConn: aLDAPConnection.	instance currCons: aLDAPConstraints.	instance currBase: baseString.	instance currScope: scopeInteger.	instance currFilter: filterString.	instance currAttrs: attrCollection.	instance currAttrsOnly: attrOnlyBoolean.	^ instance</body></methods><methods><class-id>Net.LDAPSchemaElement</class-id> <category>initialize-release</category><body package="LDAP">initialize	name := String new.	description := String new.	oid := String new</body></methods><methods><class-id>Net.LDAPSchemaElement</class-id> <category>processing</category><body package="LDAP">addOnConnection: anLDAPConnection	"Adds the current object class, attribute type, or matching rule definition to the schema.  Typically, most servers will require an authenticated connection before allowing modification of the schema."	self updateOnConnection: anLDAPConnection		operation: self class addOperation		attributeName: self name</body><body package="LDAP">removeOnConnection: anLDAPConnection	"Removes the current object class, attribute type, or matching rule definition from the schema.  Typically, most servers will require an authenticated connection before allowing modification of the schema."	self updateOnConnection: anLDAPConnection		operation: self class deleteOperation		attributeName: self name</body><body package="LDAP">updateOnConnection: anLDAPConnection operation: anInteger attribute: anLDAPAttribute	| attrs |	attrs := Array with: anLDAPAttribute.	^ self updateOnConnection: anLDAPConnection			operation: anInteger			attributes: attrs</body><body package="LDAP">updateOnConnection: anLDAPConnection operation: anInteger attributeName: aString	"Add, remove, or modify a definition in a directory.  anLDAPConnection must be an opened connection to a directory server.  Typically, authentication is required in order to modify a directory.  anInteger indicates the type of modification to be made (see class LDAPModification).  aString is the name of an attribute in the schema entry to modify."	| attr |	attr := LDAPAttribute newWithName: aString withValue: self getValue.	self updateOnConnection: anLDAPConnection operation: anInteger attribute: attr</body><body package="LDAP">updateOnConnection: anLDAPConnection operation: anInteger attributes: aCollectOfAttributes	"Add, remove, or modify a definition in a directory.  anLDAPConnection must be an opened connection to a directory server.  Typically, authentication is required in order to modify a directory.  anInteger indicates the type of modification to be made (see class LDAPModification).  aCollectionOfAttributes is a collection containing one or more LDAPAttribute objects to be modified."	| mods |	mods := LDAPModificationSet new.	aCollectOfAttributes do: [:anAttribute |		mods addModificationWithOperation: anInteger attribute: anAttribute].	anLDAPConnection modifyDN: 'cn=schema' modificationSet: mods</body></methods><methods><class-id>Net.LDAPSchemaElement</class-id> <category>accessing</category><body package="LDAP">attrName	^ attrName</body><body package="LDAP">attrName: aString	attrName := aString</body><body package="LDAP">description	^ description</body><body package="LDAP">description: aString	description := aString</body><body package="LDAP">getValue	^ self subclassResponsibility</body><body package="LDAP">name	^ name</body><body package="LDAP">name: aString	name := aString</body><body package="LDAP">oid	^ oid</body><body package="LDAP">oid: aString	oid := aString</body></methods><methods><class-id>Net.LDAPSchemaElement class</class-id> <category>class initialization</category><body package="LDAP">initAttrOIDs	AttrOIDs := Dictionary new.	AttrOIDs at: '1.3.6.1.4.1.1466.115.121.1.15' put: #cis.	AttrOIDs at: '1.3.6.1.4.1.1466.115.121.1.5' put: #binary.	AttrOIDs at: '1.3.6.1.4.1.1466.115.121.1.50' put: #telephone.	AttrOIDs at: '1.3.6.1.4.1.1466.115.121.1.26' put: #ces.	AttrOIDs at: '1.3.6.1.4.1.1466.115.121.1.27' put: #int.	AttrOIDs at: '1.3.6.1.4.1.1466.115.121.1.12' put: #dn.</body><body package="LDAP">initAttrTypes	AttrTypes := Dictionary new.	AttrTypes at: #unknown put: 0.	AttrTypes at: #cis put: 1.	AttrTypes at: #binary put: 2.	AttrTypes at: #telephone put: 3.	AttrTypes at: #ces put: 4.	AttrTypes at: #dn put: 5.	AttrTypes at: #integer put: 6</body><body package="LDAP">initialize	"LDAPSchemaElement initialize"	self initAttrTypes.	self initAttrOIDs</body></methods><methods><class-id>Net.LDAPSchemaElement class</class-id> <category>instance creation</category><body package="LDAP">new	^ self basicNew initialize</body><body package="LDAP">newWithName: nameString oid: oidString description: descString	"Answer a new instance with the specified attribute values."	"nameString is the name of the element"	"oidString is the object identifier (oid) of this element in dotted string format (i.e. '1.2.3.4')"	"descString is the description of the element"	| instance |	instance := self basicNew initialize. 	instance name: nameString.	instance oid: oidString.	instance description: descString.	^ instance</body></methods><methods><class-id>Net.LDAPSchemaElement class</class-id> <category>accessing</category><body package="LDAP">oidFor: aSymbol	^ AttrOIDs keyAtValue: aSymbol ifAbsent: [self error: 'No LDAP Schema attribute object identifier for type.']</body><body package="LDAP">symbolForType: anInteger	^ AttrTypes keyAtValue: anInteger ifAbsent: [#unknown]</body><body package="LDAP">typeFor: aSymbol	^ AttrTypes at: aSymbol ifAbsent: [self error: 'LDAP Schema attribute type not found.']</body><body package="LDAP">typeForOid: aString	^ AttrOIDs at: aString ifAbsent: [#unknown]</body></methods><methods><class-id>Net.LDAPObjectClassSchema</class-id> <category>accessing</category><body package="LDAP">addMay: aString	may add: aString</body><body package="LDAP">addMust: aString	must add: aString</body><body package="LDAP">auxiliary	^auxiliary</body><body package="LDAP">auxiliary: aBoolean	auxiliary := aBoolean</body><body package="LDAP">getOptionalAttributes	^ ReadStream on: may</body><body package="LDAP">getRequiredAttributes	^ ReadStream on: must</body><body package="LDAP">getValue	"Answer the object class definition in a string representation in the ObjectClassDescription form defined in X.501, RFC 2252 (see class comment for more information)."	| outStream first elemStream |	outStream := WriteStream on: String new.	outStream nextPutAll: '( '.	outStream nextPutAll: oid.	outStream nextPutAll: ' NAME '.	outStream nextPut: $'.	outStream nextPutAll: name.	outStream nextPut: $'.	outStream nextPutAll: ' DESC '.	outStream nextPut: $'.	outStream nextPutAll: description.	outStream nextPut: $'.	outStream nextPutAll: ' SUP '.	outStream nextPut: $'.	outStream nextPutAll: superior.	outStream nextPut: $'.	outStream space.	self auxiliary		ifTrue: [outStream nextPutAll: 'AUXILIARY'].	first := true.	outStream nextPutAll: 'MUST ( '.	elemStream := self getRequiredAttributes.	[elemStream atEnd]		whileFalse: [first						ifTrue: [first := false]						ifFalse: [outStream nextPutAll: ' $ '].					outStream nextPutAll: (elemStream next)].	outStream nextPutAll: ' ) '.	first := true.	outStream nextPutAll: 'MAY ( '.	elemStream := self getOptionalAttributes.	[elemStream atEnd]		whileFalse: [first						ifTrue: [first := false]						ifFalse: [outStream nextPutAll: ' $ '].					outStream nextPutAll: (elemStream next)].	outStream nextPutAll: ' ) )'.	^ outStream contents</body><body package="LDAP">superior	^superior</body><body package="LDAP">superior: aString	superior := aString</body></methods><methods><class-id>Net.LDAPObjectClassSchema</class-id> <category>printing</category><body package="LDAP">toString	| outStream first |	outStream := WriteStream on: String new.	outStream tab.	outStream nextPutAll: 'Name: '.	outStream nextPutAll: name.	outStream nextPutAll: '; '.	outStream cr; tab.	outStream nextPutAll: 'OID: '.	outStream nextPutAll: oid.	outStream nextPutAll: '; '.	outStream cr; tab.	outStream nextPutAll: 'Superior: '.	outStream nextPutAll: superior.	outStream nextPutAll: '; '.	outStream cr; tab.	outStream nextPutAll: 'Description: '.	outStream nextPutAll: description.	outStream nextPutAll: '; '.	outStream cr; tab.	outStream nextPutAll: 'Required: '.	first := true.	self getRequiredAttributes do: [:each |		each size = 0 			ifFalse: [first						ifTrue: [first := false]						ifFalse: [outStream nextPutAll: ', '].					outStream nextPutAll: each]].	outStream nextPutAll: '; '.	outStream cr; tab.	outStream nextPutAll: 'Optional: '.	first := true.	self getOptionalAttributes do: [:each |		each size = 0			ifFalse: [first						ifTrue: [first := false]						ifFalse: [outStream nextPutAll: ', '].					outStream nextPutAll: each]].	outStream cr.	^ outStream contents</body></methods><methods><class-id>Net.LDAPObjectClassSchema</class-id> <category>initialize-release</category><body package="LDAP">initialize	super initialize.	may := OrderedCollection new.	must := OrderedCollection new.	auxiliary := false.	superior := String new</body></methods><methods><class-id>Net.LDAPObjectClassSchema class</class-id> <category>instance creation</category><body package="LDAP">newFromString: aString	"Creates an object class definition based upon a description in the ObjectClassDescription format.  See class comment for additional information."	| inStream tString instance s val continue char elems |	instance := self new.	instance attrName: 'objectclasses'.	tString := aString lTrim rTrim.	"Do not consider enclosing '( ' and ')'  "	inStream := ReadStream on: (tString copyFrom: 3 to: tString size - 1).	instance oid: (inStream upTo: Character space).	[inStream atEnd]		whileFalse: [inStream skipSeparators.					s := (inStream upTo: Character space) asLowercase.					s = 'auxiliary'						ifTrue: [instance auxiliary: true]						ifFalse: [continue := true.								[continue]									whileTrue: [inStream atEnd													ifTrue: [continue := false]													ifFalse: [char := inStream next.															char == $'																ifTrue: [val := inStream upTo: $'.																	     continue := false.																	     s = 'name'																			ifTrue: [instance name: val].																		s = 'desc'																			ifTrue: [instance description: val].																		s = 'sup'																			ifTrue: [instance superior: val]].															char == $(																ifTrue: [elems := (inStream upTo: $)) 																					tokensBasedOn: Character space.																	    continue := false.																	    (elems reject: [:e | e = '$'] ) do: [:each |																			s = 'may'																				ifTrue: [instance addMay: each].																			s = 'must'																				ifTrue: [instance addMust: each]]]]]]].	^ instance</body><body package="LDAP">newWithName: nameString oid: oidString superior: parentString description: descString required: requiredCollection optional: optionalCollection	"Answer an instance using the specified information."	"nameString is the name of the attribute type"	"oidString is the object identifier (oid) in dotted string format (i.e. '1.2.3.4')"	"parentString is the name of the class which is the parent or superior of this class"	"descString is a string providing the description of the attribute type"	"requiredCollection is a collection of strings representing the names of attributes which are required for objects of this class"	"optionalCollection is a collection of strings representing the names of attributes which are optional for objects of this class"	| instance |	instance := self newWithName: nameString oid: oidString description: descString.	instance attrName: 'objectclasses'.	instance superior: parentString.	requiredCollection do: [:aString |		instance addMust: aString].	optionalCollection do: [:aString |		instance addMay: aString].	^ instance</body></methods><methods><class-id>Net.JDAPFilterGreaterOrEqual class</class-id> <category>instance creation</category><body package="LDAP">newForAva: aJDAPAva	| tag |	tag := ((BERElement tag: 'Constructed') bitOr: (BERElement tag: 'Context')) bitOr: 5.	^ self newForTag: tag ava: aJDAPAva</body></methods><methods><class-id>Net.LDIFRecord</class-id> <category>printing</category><body package="LDAP">toString	^ self class name, '{dn=', self dn, ', content=', self content toString, '}'</body></methods><methods><class-id>Net.LDIFRecord</class-id> <category>accessing</category><body package="LDAP">content	^ content</body><body package="LDAP">content: anLDIFContent	content := anLDIFContent</body><body package="LDAP">dn	^ dn</body><body package="LDAP">dn: aString	dn := aString</body></methods><methods><class-id>Net.LDIFRecord class</class-id> <category>instance creation</category><body package="LDAP">newWithDN: dnString content: anLDIFContent	| instance |	instance := self new.	instance dn: dnString.	instance content: anLDIFContent.	^ instance</body></methods><methods><class-id>Net.JDAPFilterPresent</class-id> <category>printing</category><body package="LDAP">toString	^ self class name, ' {', self type, '}'</body></methods><methods><class-id>Net.JDAPFilterPresent</class-id> <category>accessing</category><body package="LDAP">type	^ mType</body><body package="LDAP">type: aString	mType := aString</body></methods><methods><class-id>Net.JDAPFilterPresent</class-id> <category>encoding</category><body package="LDAP">getBERElement	| tag |	tag := (BERElement tag: 'Context') bitOr: 7.	^ BERTag		newWithTag: tag		element: (BEROctetString newFromString: self type)		implicit: true</body></methods><methods><class-id>Net.JDAPFilterPresent class</class-id> <category>instance creation</category><body package="LDAP">newForType: aString	| instance |	instance := self new.	instance type: aString.	^ instance</body></methods><methods><class-id>Net.LDAPDN class</class-id> <category>utilities</category><body package="LDAP">escapeRDN: aString	"Answers the string representation of a relative distinguished name specified by aString, escaping any appropriate characters (see class method escapeChars in class DistinguishedName)."	| aRDN valStream resultStream nextChar |	aRDN := RelativeDistinguishedName newFromString: aString.	aRDN value size = 0		ifTrue: [^ aString].	valStream := ReadStream on: aRDN value.	resultStream := WriteStream on: String new.	[valStream atEnd]		whileFalse: [			nextChar := valStream next.			(self isEscape: nextChar)				ifTrue: [resultStream nextPut: $\].			resultStream nextPut: nextChar].	^ aRDN type, '=', resultStream contents</body><body package="LDAP">explodeDN: aString noTypes: aBoolean	"Answers the individual components of a distinguished name.  The no types parameter indicates whether the attribute type of each component should be suppressed.  For example, if the attribute is 'uid=bjensen' and the no types parameter is true, then the attribute will be returned without the 'uid=' portion."	| aDN |	aDN := DistinguishedName newFromString: aString.	^ aDN explodeDNNoTypes: aBoolean</body><body package="LDAP">explodeRDN: aString noTypes: aBoolean	"Answers the individual components of a relative distinguished name.  The no types parameter indicates whether the attribute type of each component should be suppressed.  For example, if the attribute is 'uid=bjensen' and the no types parameter is true, then the attribute will be returned without the 'uid=' portion."	| aRDN |	aRDN := RelativeDistinguishedName newFromString: aString.	^ aRDN explodeRDNNoTypes: aBoolean</body><body package="LDAP">isEscape: aChar	^ DistinguishedName escapedChars includes: aChar</body><body package="LDAP">unescapeRDN: aString	"Answers the string representation of a relative distinguished name specified by aString, unescaping any escaped characters (see class method escapeChars in class DistinguishedName)."	| aRDN |	aRDN := RelativeDistinguishedName newFromString: aString.	aRDN value size = 0		ifTrue: [^ aString].	^ aRDN type, '=', (aRDN value copyWithout: $\)</body></methods><methods><class-id>Net.JDAPModifyRequest</class-id> <category>accessing</category><body package="LDAP">addMod: aLDAPModification	mMods add: aLDAPModification</body><body package="LDAP">getType	^ JDAPProtocolOp codeForOperationType: 'MODIFY_REQUEST'</body><body package="LDAP">mods	^ mMods</body><body package="LDAP">mods: anOrderedCollection	mMods := anOrderedCollection</body></methods><methods><class-id>Net.JDAPModifyRequest</class-id> <category>initialize-release</category><body package="LDAP">initialize	super initialize.	mMods := OrderedCollection new.	^ self</body></methods><methods><class-id>Net.JDAPModifyRequest</class-id> <category>encoding</category><body package="LDAP">getBERElement	| seq modList element tag |	seq := BERSequence new.	seq addElement: (BEROctetString newFromString: self baseDN).	modList := BERSequence new.	self mods do: [:each |		modList addElement: each getBERElement].	seq addElement: modList.	tag := ((BERElement tag: 'Application') bitOr: (BERElement tag: 'Constructed')) bitOr: 6.	element := BERTag					newWithTag: tag					element: seq					implicit: true.	^ element</body></methods><methods><class-id>Net.JDAPModifyRequest</class-id> <category>printing</category><body package="LDAP">getParamString	| paramStream first |	paramStream := WriteStream on: String new.	paramStream nextPutAll: '{object='.	paramStream nextPutAll: self baseDN.	paramStream nextPutAll: ', modification='.	first := true.	self mods do: [:each |		first			ifTrue: [first := false]			ifFalse: [paramStream nextPut: $+].		paramStream nextPutAll: each toString].	paramStream nextPutAll: '}'.	^ paramStream contents</body></methods><methods><class-id>Net.JDAPModifyRequest class</class-id> <category>instance creation</category><body package="LDAP">newForDN: dnString mods: modCollection	| instance |	instance := self new.	instance baseDN: dnString.	instance mods: modCollection.	^ instance</body></methods><methods><class-id>Net.JDAPMessage</class-id> <category>accessing</category><body package="LDAP">controls	^ mControls</body><body package="LDAP">controls: aCollection	mControls := aCollection</body><body package="LDAP">getId	^ self msgId</body><body package="LDAP">msgId	^ mMsgId</body><body package="LDAP">msgId: anInteger	mMsgId := anInteger</body><body package="LDAP">protocolOp	^ mProtocolOp</body><body package="LDAP">protocolOp: aJDAPProtocolOp	mProtocolOp := aJDAPProtocolOp</body></methods><methods><class-id>Net.JDAPMessage</class-id> <category>printing</category><body package="LDAP">toString	^ '[JDAPMessage] ', self msgId asString, ' ', self protocolOp toString</body></methods><methods><class-id>Net.JDAPMessage</class-id> <category>input-output</category><body package="LDAP">writeOn: aStream	| seq i e c t |	seq := BERSequence new.	i := BERInteger newForValue: self msgId.	seq addElement: i.	e := self protocolOp getBERElement. 	e isNil		ifTrue: [^ self error: 'Bad BER element'].	seq addElement: e.	self controls size &gt; 0		ifTrue: [c := BERSequence new.			    self controls do: [:each |					c addElement: each getBERElement].			    t := ((BERElement tag: 'Context') bitOr: (BERElement tag: 'Constructed')) bitOr: 0.			    seq addElement: (BERTag									newWithTag: t									element: c									implicit: true)].	seq writeOn: aStream</body></methods><methods><class-id>Net.JDAPMessage</class-id> <category>initialize-release</category><body package="LDAP">initialize	mMsgId := 0.	mProtocolOp := JDAPProtocolOp new.	mControls := OrderedCollection new.	^ self</body></methods><methods><class-id>Net.JDAPMessage class</class-id> <category>instance creation</category><body package="LDAP">new	^ self basicNew initialize</body><body package="LDAP">newFromBERElement: element	| instance seq msgId protocolOp tag protocolClass controls |	instance := self new.	(element getType) = (BERElement type: 'Sequence')		ifFalse: [^LDAPError raiseErrorString: 'SEQUENCE in JDAP message expected'].	seq := element.	msgId := seq elementAt: 1.	instance msgId: msgId getValue.	protocolOp := seq elementAt: 2.	(protocolOp getType) = (BERElement type: 'Tag')		ifFalse: [^LDAPError raiseErrorString: 'TAG in protocol operation within JDAP message expected'].	tag := protocolOp tag bitAnd: 16r1F.	" If doing search without bind, x500.arc.nasa.gov returns tag SEARCH_REQUEST in SEARCH_RESULT "	tag = (JDAPProtocolOp codeForOperationType: 'SEARCH_REQUEST')		ifTrue: [tag := JDAPProtocolOp codeForOperationType: 'SEARCH_RESULT'].	protocolClass := JDAPProtocolOp classImplementingOperation: tag.	protocolClass isNil		ifTrue: [^LDAPError raiseErrorString: 'Unknown protocol operation in JDAP message ', tag printString].	instance protocolOp: (protocolClass newFromBERTag: protocolOp).	" Parse  controls [0] Controls OPTIONAL"	seq size &gt;= 3		ifTrue: [tag := seq elementAt: 3.			    (tag tag) = ((BERElement tag: 'Constructed') + (BERElement tag: 'Context'))					ifTrue: [controls := tag getValue.						" Controls ::= SEQUENCE OF control Control"						controls elements do: [:ctrl |							instance controls add: (JDAPControl newFromBERElement: ctrl)]]].	^ instance</body><body package="LDAP">newWithMessageId: anInteger protocolOp: requestOrResponse	"requestOrResponse is an instance of one of the concrete classes in the LDAP-Client-Opers category"	| instance |	instance := self new.	instance msgId: anInteger.	instance protocolOp: requestOrResponse.	^ instance</body><body package="LDAP">newWithMessageId: anInteger protocolOp: requestOrResponse controls: collectOfControls	"requestOrResponse is an instance of one of the concrete classes in the LDAP-Client-Opers category"	| instance |	instance := self new.	instance msgId: anInteger.	instance protocolOp: requestOrResponse.	instance controls: collectOfControls.	^ instance</body></methods><methods><class-id>Net.JDAPModifyRdnResponse</class-id> <category>accessing</category><body package="LDAP">getType	^ JDAPProtocolOp codeForOperationType: 'MODIFY_RDN_RESPONSE'</body></methods><methods><class-id>Net.JDAPModifyRdnResponse class</class-id> <category>instance creation</category><body package="LDAP">newFromBERTag: aBERTag	^ self newFromBERElement: (aBERTag getValue)</body></methods><methods><class-id>Net.JDAPBindResponse</class-id> <category>accessing</category><body package="LDAP">credentials	^ mCredentials</body><body package="LDAP">credentials: aString	mCredentials := aString</body><body package="LDAP">getType	^ JDAPProtocolOp codeForOperationType: 'BIND_RESPONSE'</body></methods><methods><class-id>Net.JDAPBindResponse</class-id> <category>initialize-release</category><body package="LDAP">initialize	super initialize.	mCredentials := String new.</body></methods><methods><class-id>Net.JDAPBindResponse class</class-id> <category>instance creation</category><body package="LDAP">newFromBERTag: aBERTag	| instance s e str |	instance := self newFromBERElement: (aBERTag getValue).	s := aBERTag getValue.	s size &lt;= 3		ifTrue: [^ instance].	e := s elementAt: 4.	e getType = (BERElement type: 'Tag')		ifTrue: [str := e getValue.			    instance credentials: (str getValue asStringEncoding: #UTF_8)].	^ instance</body></methods><methods><class-id>Net.BERInteger</class-id> <category>accessing</category><body package="LDAP">getType	^ self class type: 'Integer'</body></methods><methods><class-id>Net.BERInteger</class-id> <category>printing</category><body package="LDAP">toString	^ 'Integer {', mValue asString, '}'</body></methods><methods><class-id>Net.LDAPSearchListener</class-id> <category>processing</category><body package="LDAP">nextResult	"Answers the next server search result.  Only used in asynchronous mode.  This method will block if no new messages have been received since the last call to nextResult.  If a response is received (indicating that there are no more matches), this method will answer nil."	| result |	searchResults size = 0		ifTrue: [self getResponse isNil					ifFalse: [^ nil].			     resultSemaphore wait].	result := searchResults removeAtIndex: 1.	"Notify connection that a result was retrieved.  It can then signal its underlying communications handler in case it was waiting with a backlog of results."	self connection resultRetrieved.	^ result</body></methods><methods><class-id>Net.LDAPSearchListener</class-id> <category>accessing</category><body package="LDAP">addSearchResult: aJDAPMessage	searchResults add: aJDAPMessage. 	resultSemaphore signal</body><body package="LDAP">constraints	^ mConstraints</body><body package="LDAP">constraints: anLDAPSearchConstraints	mConstraints := anLDAPSearchConstraints</body><body package="LDAP">getCount	^ searchResults size</body><body package="LDAP">getSearchResults	^ ReadStream on: self searchResults</body><body package="LDAP">key	^ mKey</body><body package="LDAP">key: anInteger	mKey := anInteger</body><body package="LDAP">lock	^ lock</body><body package="LDAP">resultSemaphore	^ resultSemaphore</body><body package="LDAP">searchResults	^ searchResults</body></methods><methods><class-id>Net.LDAPSearchListener</class-id> <category>initialize-release</category><body package="LDAP">initialize	super initialize.	searchResults := OrderedCollection new.	resultSemaphore := Semaphore new.	lock := RecursionLock new.	^ self</body><body package="LDAP">reset	super reset.	searchResults := OrderedCollection new.	resultSemaphore := Semaphore new.</body></methods><methods><class-id>Net.LDAPSearchListener class</class-id> <category>instance creation</category><body package="LDAP">newForConnection: anLDAPConnection constraints: cons	| instance |	instance := self newForConnection: anLDAPConnection.	instance constraints: cons.	^ instance</body></methods><methods><class-id>Net.LDAPSearchConstraints</class-id> <category>accessing</category><body package="LDAP">addClientControl: aLDAPControl	mClientControls add: aLDAPControl</body><body package="LDAP">addServerControl: aLDAPControl	mServerControls add: aLDAPControl</body><body package="LDAP">batch	^ batch</body><body package="LDAP">batch: anInteger	batch := anInteger</body><body package="LDAP">clientControls	^ mClientControls</body><body package="LDAP">clientControls: aCollection	mClientControls := aCollection</body><body package="LDAP">deref	^ deref</body><body package="LDAP">deref: anInteger	deref := anInteger</body><body package="LDAP">hopLimit	^ mHopLimit</body><body package="LDAP">hopLimit: anInteger	mHopLimit := anInteger</body><body package="LDAP">maxBacklog	^ mMaxBacklog</body><body package="LDAP">maxBacklog: anInteger	mMaxBacklog := anInteger</body><body package="LDAP">maxRes	^ maxRes</body><body package="LDAP">maxRes: anInteger	maxRes := anInteger</body><body package="LDAP">rebindProc	^ mRebindProc</body><body package="LDAP">rebindProc: anObject	mRebindProc := anObject</body><body package="LDAP">referrals	^ referrals</body><body package="LDAP">referrals: aBoolean	referrals := aBoolean</body><body package="LDAP">serverControls	^ mServerControls</body><body package="LDAP">serverControls: aCollection	mServerControls := aCollection</body><body package="LDAP">timeLimit	^ timeLimit</body><body package="LDAP">timeLimit: anInteger	timeLimit := anInteger</body></methods><methods><class-id>Net.LDAPSearchConstraints</class-id> <category>initialize-release</category><body package="LDAP">initialize	timeLimit := 0.	deref := LDAPv2 derefNever.	maxRes := 1000.	referrals := false.	batch := 0.	mRebindProc := nil.	mHopLimit := 10.	mClientControls := OrderedCollection new.	mServerControls := OrderedCollection new.	mMaxBacklog := 10.	^ self</body></methods><methods><class-id>Net.LDAPSearchConstraints</class-id> <category>copying</category><body package="LDAP">copy	| newInstance cCollect sCollect |	newInstance := self copy.	cCollect := OrderedCollection new.	self clientControls do: [:each |		cCollect add: each copy].	newInstance clientControls: cCollect.	sCollect := OrderedCollection new.	self serverControls do: [:each |		sCollect add: each copy].	newInstance serverControls: sCollect.	^ newInstance</body></methods><methods><class-id>Net.LDAPSearchConstraints class</class-id> <category>instance creation</category><body package="LDAP">new	^ self basicNew initialize</body><body package="LDAP">newWithTimeLimit: limitInteger dereference: derefInteger maxResults: maxResultInteger doReferrals: referBoolean batchSize: batchInteger rebindProc: rebindObject hopLimit: hopInteger	| instance |	instance := self new.	instance timeLimit: limitInteger.	instance deref: derefInteger.	instance maxRes: maxResultInteger.	instance referrals: referBoolean.	instance batch: batchInteger.	instance rebindProc: rebindObject.	instance hopLimit: hopInteger.	^ instance</body></methods><methods><class-id>Net.LDIFDeleteContent</class-id> <category>printing</category><body package="LDAP">toString	^ self class name, ' {}'</body></methods><methods><class-id>Net.LDIFDeleteContent</class-id> <category>accessing</category><body package="LDAP">getType	^ self class deleteContent</body></methods><methods><class-id>Net.LDIFDeleteContent</class-id> <category>initialize-release</category><body package="LDAP">initialize	^ self</body></methods><methods><class-id>Net.LDIFDeleteContent class</class-id> <category>instance creation</category><body package="LDAP">new	^ self basicNew initialize</body></methods><methods><class-id>Net.JDAPUnbindRequest</class-id> <category>printing</category><body package="LDAP">getParamString	^ '{}'</body><body package="LDAP">toString	^ self class name, ' ', self getParamString</body></methods><methods><class-id>Net.JDAPUnbindRequest</class-id> <category>accessing</category><body package="LDAP">getType	^ JDAPProtocolOp codeForOperationType: 'UNBIND_REQUEST'</body></methods><methods><class-id>Net.JDAPUnbindRequest</class-id> <category>encoding</category><body package="LDAP">getBERElement	"[*] umich-ldap-v3.3:"	"	0x42 0x00"	| n tag element |	n := BERNull new.	tag := (BERElement tag: 'Application') bitOr: 2.	element := BERTag newWithTag: tag 					element: n					implicit: true.	^ element</body></methods><methods><class-id>Net.BERObjectId</class-id> <category>printing</category><body package="LDAP">toString	| oid |	mValue isNil		ifTrue: [^ 'ObjectIdentifier {}'].	oid := 'ObjectIdentfier {'.	mValue do: [:anId | oid := oid, ' ', anId asString].	^ oid, ' }'</body></methods><methods><class-id>Net.BERObjectId</class-id> <category>accessing</category><body package="LDAP">getType	^ self class type: 'ObjectId'</body><body package="LDAP">getValue	^ self value</body><body package="LDAP">value	^ mValue</body><body package="LDAP">value: anArray	"Set internal value to be anArray, which should be an array of integers"	mValue := anArray</body></methods><methods><class-id>Net.BERObjectId</class-id> <category>input-output</category><body package="LDAP">writeOn: outStream	"Sends the BER encoding directly to outStream.	Note that the Object ID must have two or more identifier components (values)."	| contents firstSub |	outStream nextPut: self getType.	contents := OrderedCollection new.	firstSub := ((mValue at: 1) * 40) + (mValue at: 2).	self addSubIdentifierTo: contents value: firstSub.	3 to: mValue size do: [:ndx |		self addSubIdentifierTo: contents value: (mValue at: ndx)].	self class sendDefiniteLengthOn: outStream numberOfOctets: contents size.	outStream nextPutAll: contents</body></methods><methods><class-id>Net.BERObjectId</class-id> <category>private</category><body package="LDAP">addSubIdentifierTo: aCollect value: aSubId	| tCollect tId |	tCollect := OrderedCollection new.	tId := aSubId.	"Gather octets in reverse order"	[tId &gt; 0]		whileTrue: [tCollect add: (tId bitAnd: 127).				    tId := tId bitShift: -7].	"All but last octet have bit 8 = 1"	(tCollect size) to: 2 by: -1 do: [:idx |		aCollect add: ((tCollect at: idx) bitOr: 128)].	"Last octet has bit 8 = 0"	aCollect add: (tCollect at: 1).	^ aCollect</body></methods><methods><class-id>Net.BERObjectId class</class-id> <category>instance creation</category><body package="LDAP">newFrom: inStream bytesRead: anArray	"Constructs an object id element from the input stream.	anArray contains 1 integer representing the number of bytes read from inStream."	| contentsLength contentsRead oid subId fSub bytesRead value |	contentsLength := self readLengthOctetsFrom: inStream bytesRead: anArray.	bytesRead := anArray at: 1.	bytesRead := bytesRead + contentsLength.	anArray at: 1 put: bytesRead.	oid := OrderedCollection new.	contentsRead := Array with: 0.	subId := self readSubIdentifierFrom: inStream bytesRead: contentsRead.	contentsLength := contentsLength - (contentsRead at: 1).	fSub := (subId // 40) min: 2.	oid add: fSub.	oid add: (subId - (fSub * 40)).	[contentsLength &gt; 0]		whileTrue: [contentsRead at: 1 put: 0.				    subId := self readSubIdentifierFrom: inStream bytesRead: contentsRead.				    contentsLength := contentsLength - (contentsRead at: 1).				    oid add: subId].	value := Array new: oid size.	1 to: oid size do: [:idx | 		value at: idx put: (oid at: idx)].	^ self newFromArray: value</body><body package="LDAP">newFromArray: anArray 	"Constructs an object id element from anArray, an array of integers"	^(self new)		value: anArray copy;		yourself</body><body package="LDAP">newFromString: aString	"Constructs an object id element from aString, which as the form '2.100.3' "	| intArray |	intArray := (aString tokensBasedOn: $.) collect: [:subStr | subStr asNumber].	^ self newFromArray: intArray</body></methods><methods><class-id>Net.BERObjectId class</class-id> <category>private</category><body package="LDAP">readSubIdentifierFrom: inStream bytesRead: anArray	| octet subId bytesRead continue |	subId := 0.	continue := true.	bytesRead := anArray at: 1.	[continue]		whileTrue: [octet := inStream next.				    bytesRead := bytesRead + 1.				    subId := (subId bitShift: 7) bitOr: (octet bitAnd: 127).				    continue := (octet bitAnd: 128) &gt; 0].	anArray at: 1 put: bytesRead.	^ subId</body></methods><methods><class-id>Net.BEROctetString</class-id> <category>accessing</category><body package="LDAP">getType	^ self class type: 'OctetString'</body><body package="LDAP">getValue	^ self value</body><body package="LDAP">value	^ mValue</body><body package="LDAP">value: aByteArray	mValue := aByteArray</body></methods><methods><class-id>Net.BEROctetString</class-id> <category>printing</category><body package="LDAP">toString	| tString |	mValue isNil		ifTrue: [^ 'OctetString {}'].	tString := 'OctetString {'.	tString := mValue 				inject: tString				into: [:nString :anOctet | nString, (anOctet printStringRadix: 16), ' '].	^ tString, '}'</body></methods><methods><class-id>Net.BEROctetString</class-id> <category>input-output</category><body package="LDAP">writeOn: outStream	outStream nextPut: self getType.	mValue isNil		ifTrue: [self class sendDefiniteLengthOn: outStream numberOfOctets: 0]		ifFalse: [self class sendDefiniteLengthOn: outStream numberOfOctets: mValue size.				outStream nextPutAll: mValue].</body></methods><methods><class-id>Net.BEROctetString class</class-id> <category>instance creation</category><body package="LDAP">newFrom: inStream bytesRead: anArray	"Constructs an octet string element from the input stream, for primitive encoding.	anArray contains 1 integer representing the number of bytes read from inStream."	| contentsLength bytesRead value idx |	contentsLength := self readLengthOctetsFrom: inStream bytesRead: anArray.	bytesRead := anArray at: 1.	value := nil.	contentsLength &gt; 0		ifTrue: [value := ByteArray new: contentsLength.			    idx := 0.			    [idx &lt; contentsLength]					whileTrue: [						value at: (idx + 1) put: inStream next.						idx := idx + 1].			    bytesRead := bytesRead + contentsLength].	anArray at: 1 put: bytesRead.	^ self new value: value</body><body package="LDAP">newFrom: inStream decoder: aBERTagDecoder bytesRead: anArray 	"Constructs an octet string element from input stream (for constructed encoding).	anArray is an array of 1 integer representing the number of bytes read from input stream."	| contentsLength componentLength element bytesRead octetBuffer value newBuffer newBuffSize |	contentsLength := self readLengthOctetsFrom: inStream bytesRead: anArray.	componentLength := Array new: 1.	value := nil.	contentsLength = -1 		ifTrue: 			[			[componentLength at: 1 put: 0.			element := self 						getElementFrom: inStream						decoder: aBERTagDecoder						bytesRead: componentLength.			element isNil 				ifFalse: 					["element is an octetstring - add it to the existing buffer"					octetBuffer := element getValue.					value isNil 						ifTrue: 							[value := ByteArray new: octetBuffer size.							value 								replaceFrom: 1								to: octetBuffer size								with: octetBuffer								startingAt: 1]						ifFalse: 							[newBuffSize := value size + octetBuffer size.							newBuffer := ByteArray new: newBuffSize.							newBuffer 								replaceFrom: 1								to: value size								with: value								startingAt: 1.							newBuffer 								replaceFrom: value size + 1								to: newBuffSize								with: octetBuffer								startingAt: 1.							value := newBuffer]].			element notNil] 					whileTrue]		ifFalse: 			[bytesRead := anArray at: 1.			bytesRead := bytesRead + contentsLength.			anArray at: 1 put: bytesRead.			value := (inStream next: contentsLength) asByteArray].	"Constructed - indefinite length content octets"	"Definite length content octets string"	^self newFromByteArray: value</body><body package="LDAP">newFromByteArray: anArray	"Create an octet string element containing anArray.	anArray is a byte array in UTF-8 format, if it is string data."	^ self new value: anArray</body><body package="LDAP">newFromByteArray: anArray from: startPos to: endPos	"Create an octet string element containing a subset of anArray.	anArray is a byte array.	startPos and endPos are integers specifying the starting and ending locations to copy."	^ self new value: (anArray copyFrom: startPos to: endPos)</body><body package="LDAP">newFromString: aString	"Create an octet string element containing a copy of the contents of aString"	^ self new value: (aString asByteArrayEncoding: #UTF_8)</body></methods><methods><class-id>Net.BERChoice</class-id> <category>accessing</category><body package="LDAP">getType	^ self class type: 'Choice'</body></methods><methods><class-id>Net.BERChoice</class-id> <category>printing</category><body package="LDAP">toString	^ 'Choice {', mValue toString, '}'</body></methods><methods><class-id>Net.LDAPAttributeSchema</class-id> <category>accessing</category><body package="LDAP">getValue	"Answer the attribute type definition in a string representation in the AttributeTypeDescription form defined in X.501, RFC 2252 (see class comment for more information)."	| outStream |	outStream := WriteStream on: String new.	outStream nextPutAll: '( '.	outStream nextPutAll: oid.	outStream nextPutAll: ' NAME '.	outStream nextPut: $'.	outStream nextPutAll: name.	outStream nextPut: $'.	outStream nextPutAll: ' DESC '.	outStream nextPut: $'.	outStream nextPutAll: description.	outStream nextPut: $'.	outStream nextPutAll: ' SYNTAX '.	outStream nextPut: $'.	outStream nextPutAll: self internalSyntaxToString.	outStream nextPut: $'.	outStream space.	self isSingleValued		ifTrue: [outStream nextPutAll: 'SINGLE-VALUE '].	outStream nextPut: $).	^ outStream contents</body><body package="LDAP">isSingleValued	^ single</body><body package="LDAP">single: aBoolean	single := aBoolean</body><body package="LDAP">syntax	^ syntax</body><body package="LDAP">syntax: anInteger	syntax := anInteger</body><body package="LDAP">syntaxSymbol	^ self class typeForOid: syntax</body></methods><methods><class-id>Net.LDAPAttributeSchema</class-id> <category>printing</category><body package="LDAP">toString	| outStream |	outStream := WriteStream on: String new.	outStream tab.	outStream nextPutAll: 'Name: '.	outStream nextPutAll: name.	outStream nextPutAll: '; '.	outStream cr; tab.	outStream nextPutAll: 'OID: '.	outStream nextPutAll: oid.	outStream nextPutAll: '; '.	outStream cr; tab.	outStream nextPutAll: 'Type: '.	outStream nextPutAll: self syntaxToString.	outStream nextPutAll: '; '.	outStream cr; tab.	outStream nextPutAll: 'Description: '.	outStream nextPutAll: description.	outStream nextPutAll: '; '.	outStream cr; tab.	self isSingleValued		ifTrue: [outStream nextPutAll: 'single-valued']		ifFalse: [outStream nextPutAll: 'multi-valued'].	outStream cr.	^ outStream contents</body></methods><methods><class-id>Net.LDAPAttributeSchema</class-id> <category>utilities</category><body package="LDAP">internalSyntaxToString	^ self class oidFor: self syntaxSymbol</body><body package="LDAP">syntaxCheck: aString	"Answers the integer corresponding to the type represented by the object identifier (oid) aString"	^ self class typeForOid: aString</body><body package="LDAP">syntaxToString	^ self syntaxSymbol asString</body></methods><methods><class-id>Net.LDAPAttributeSchema</class-id> <category>initialize-release</category><body package="LDAP">initialize	super initialize.	syntax := self class typeFor: #unknown.	single := false.</body></methods><methods><class-id>Net.LDAPAttributeSchema class</class-id> <category>instance creation</category><body package="LDAP">newFromString: aString	"Creates an attribute type definition based upon a description in the AttributeTypeDescription format.  See class comment for additional information."	| inStream tString instance s val |	instance := self new.	instance attrName: 'attributetypes'.	tString := aString lTrim rTrim.	"Do not consider enclosing '( ' and ')'  "	inStream := ReadStream on: (tString copyFrom: 3 to: tString size - 1).	instance oid: (inStream upTo: Character space).	[inStream atEnd]		whileFalse: [inStream skipSeparators.					s := (inStream upTo: Character space) asLowercase.					s = 'single-value'						ifTrue: [instance single: true]						ifFalse: [inStream upTo: $'.								val := inStream upTo: $'.								s = 'name'									ifTrue: [instance name: val].								s = 'desc'									ifTrue: [instance description: val].								s = 'syntax'									ifTrue: [instance syntax: val]]].	^ instance</body><body package="LDAP">newWithName: nameString oid: oidString description: descString syntax: aSymbol singleValued: aBoolean	"Answer an instance using the specified information."	"nameString is the name of the attribute type"	"oidString is the object identifier (oid) in dotted string format (i.e. '1.2.3.4')"	"descString is a string providing the description of the attribute type"	"aSymbol is a symbol identifying the syntax type.  See LDAPSchemaElement class method initAttrTypes"	"aBoolean is true if the attribute type is single valued, false if multi-valued"	| instance |	instance := self newWithName: nameString oid: oidString description: descString.	instance attrName: 'attributetypes'.	instance syntax: (self typeFor: aSymbol).	instance single: aBoolean.	^ instance</body></methods><methods><class-id>Net.LDAPMatchingRuleSchema</class-id> <category>accessing</category><body package="LDAP">addAttribute: aString	attributes add: aString</body><body package="LDAP">getAttributes	^ attributes</body><body package="LDAP">getUseValue	"Answer the matching rule use definition in a string representation in the MatchingRuleUseDescription form defined in X.501, RFC 2252 (see class comment for more information)."	| outStream first |	outStream := WriteStream on: String new.	outStream nextPutAll: '( '.	outStream nextPutAll: oid.	outStream nextPutAll: ' APPLIES ( '.	first := true.	self getAttributes do: [:each |		first			ifTrue: [first := false]			ifFalse: [outStream nextPutAll: ' $ '].		outStream nextPutAll: each].	outStream nextPutAll: ') )'.	^ outStream contents</body><body package="LDAP">getValue	"Answer the matching rule definition in a string representation in the MatchingRuleDescription form defined in X.501, RFC 2252 (see class comment for more information)."	| outStream |	outStream := WriteStream on: String new.	outStream nextPutAll: '( '.	outStream nextPutAll: oid.	outStream nextPutAll: ' NAME '.	outStream nextPut: $'.	outStream nextPutAll: name.	outStream nextPut: $'.	outStream nextPutAll: ' DESC '.	outStream nextPut: $'.	outStream nextPutAll: description.	outStream nextPut: $'.	outStream nextPutAll: ' SYNTAX '.	outStream nextPut: $'.	outStream nextPutAll: self internalSyntaxToString.	outStream nextPut: $'.	outStream nextPut: $).	^ outStream contents</body></methods><methods><class-id>Net.LDAPMatchingRuleSchema</class-id> <category>private</category><body package="LDAP">processRule: rString	"Complete the creation of a rule definition from a string value (rString) returned from a search of a directory schema. Answer the object identifier (oid) encoded in the definition."	| tString inStream theOid s val continue char elems |	rString isNil		ifTrue: [^ nil].	 tString := rString lTrim rTrim.	tString size &lt; 3		ifTrue: [^ nil].	"Do not consider enclosing '( ' and ')'  "	inStream := ReadStream on: (tString copyFrom: 3 to: tString size - 1).	theOid := (inStream upTo: Character space).	[inStream atEnd]		whileFalse: [inStream skipSeparators.					s := (inStream upTo: Character space) asLowercase.					continue := true.					[continue]						whileTrue: [inStream atEnd										ifTrue: [continue := false]										ifFalse: [char := inStream next.												char == $'													ifTrue: [val := inStream upTo: $'.														     continue := false.														     s = 'name'																ifTrue: [self name: val].															s = 'desc'																ifTrue: [self description: val].															s = 'syntax'																ifTrue: [self syntax: val]].												char == $(													ifTrue: [elems := (inStream upTo: $)) 																		tokensBasedOn: Character space.														    continue := false.														    (elems reject: [:e | e = '$'] ) do: [:each |																s = 'applies'																	ifTrue: [self addAttribute: each]]]]]].	^ theOid</body></methods><methods><class-id>Net.LDAPMatchingRuleSchema</class-id> <category>processing</category><body package="LDAP">updateOnConnection: anLDAPConnection operation: anInteger attributeName: aString	"Add, remove, or modify a definition in a directory.  anLDAPConnection must be an opened connection to a directory server.  Typically, authentication is required in order to modify a directory.  anInteger indicates the type of modification to be made (see class LDAPModification).  aString is the name of an attribute in the schema entry to modify (ignored here)."	| attrCollect |	attrCollect := Array new: 2.	attrCollect at: 1 put: (LDAPAttribute newWithName: 'matchingRules' withValue: self getValue).	attrCollect at: 2 put: (LDAPAttribute newWithName: 'matchingRuleUse' withValue: self getUseValue).	self updateOnConnection: anLDAPConnection operation: anInteger attributes: attrCollect</body></methods><methods><class-id>Net.LDAPMatchingRuleSchema</class-id> <category>initialize-release</category><body package="LDAP">initialize	super initialize.	attributes := OrderedCollection new</body></methods><methods><class-id>Net.LDAPMatchingRuleSchema</class-id> <category>printing</category><body package="LDAP">toString	| outStream first |	outStream := WriteStream on: String new.	outStream tab.	outStream nextPutAll: 'Name: '.	outStream nextPutAll: name.	outStream nextPutAll: '; '.	outStream cr; tab.	outStream nextPutAll: 'OID: '.	outStream nextPutAll: oid.	outStream nextPutAll: '; '.	outStream cr; tab.	outStream nextPutAll: 'Type: '.	outStream nextPutAll: self syntaxToString.	outStream nextPutAll: '; '.	outStream cr; tab.	outStream nextPutAll: 'Description: '.	outStream nextPutAll: description.	attributes size = 0		ifFalse: [outStream nextPutAll: '; '.				outStream cr; tab.				outStream nextPutAll: 'Applies To: '.				first := true.				attributes do: [:each |					first						ifTrue: [first := false]						ifFalse: [outStream nextPutAll: ', '].					outStream nextPutAll: each]].	^ outStream contents</body></methods><methods><class-id>Net.LDAPMatchingRuleSchema class</class-id> <category>instance creation</category><body package="LDAP">newFromString: rawString useDesc: useString	"Creates an matching rule definition based upon a description in the MatchingRuleDescription format (rawString), and the use description in the MatchingRuleUseDescription format (useString).  See class comment for additional information."	| instance checkOid |	instance := self new.	instance oid: (instance processRule: rawString).	checkOid := instance processRule: useString.	((instance oid notNil &amp; checkOid notNil ) and: [instance oid ~= checkOid])		ifTrue: [self error: ('Matching Rule OID ', instance oid, 							' not equal to Use Description OID ', checkOid)].	instance oid isNil		ifTrue: [instance oid: checkOid].	^ instance</body><body package="LDAP">newWithName: nameString oid: oidString description: descString syntax: aSymbol attributes: attrCollection	"Answer an instance using the specified information."	"nameString is the name of the attribute type"	"oidString is the object identifier (oid) in dotted string format (i.e. '1.2.3.4')"	"descString is a string providing the description of the attribute type"	"aSymbol is a symbol identifying the syntax type.  See LDAPSchemaElement class method initAttrTypes"	"attrCollection is a collection of the oids of the attributes which can be used with this matching rule"	| instance |	instance := self newWithName: nameString 						oid: oidString 						description: descString 						syntax: aSymbol 						singleValued: true.	instance attrName: 'matchingrules'.	attrCollection do: [:each |		instance addAttribute: each].	^ instance</body></methods><methods><class-id>Net.LDAPEntry</class-id> <category>accessing</category><body package="LDAP">attrSet	^ attrSet</body><body package="LDAP">attrSet: aLDAPAttributeSet	attrSet := aLDAPAttributeSet</body><body package="LDAP">dn	^ dn</body><body package="LDAP">dn: aString	dn := aString</body><body package="LDAP">getAttribute: aString 	"Answer the attribute whose name exactly matches aString, except for case.  See instance method getAttribute: of class LDAPAttributeSet."	^ aString = '..' 		ifTrue: [ LDAPAttribute newWithName: aString withValue: self parentDn ]		ifFalse: [ attrSet getAttribute: aString ]</body><body package="LDAP">getAttribute: nameString language: langString	"Answer the attribute whose name exactly matches nameString, except for case, and that bets matches a language specification langString.  See instance method getAttribute: language: in class LDAPAttributeSet."	^ attrSet getAttribute: nameString language: langString</body><body package="LDAP">getAttributeSet	^ self attrSet</body><body package="LDAP">getAttributeSubset: aString	"Answer an attribute set containing attributes from my attribute set associated with the subset specified by aString.  See instance method getSubset: of class LDAPAttributeSet."	^ self attrSet getSubset: aString</body><body package="LDAP">parentDn	| result aStream |	result := self dn asOrderedCollection.	[	result notEmpty and: 			[ | fc |				fc := result removeFirst.				fc = $\ 					ifTrue: 					[	result removeFirst.						true 					]					ifFalse: [ fc ~= $, ] 			] 	] whileTrue.	aStream := String new writeStream.	aStream nextPutAll: result.	^ aStream contents</body></methods><methods><class-id>Net.LDAPEntry</class-id> <category>printing</category><body package="LDAP">toString	^ 'LDAPEntry: ', dn, ' ', attrSet toString</body></methods><methods><class-id>Net.LDAPEntry</class-id> <category>utilities</category><body package="LDAP">modificationSetFrom: anotherLDAPEntry	"Answer an LDAPModificationSet object that represents all of the changes required to make this entry match anotherLDAPEntry, other than distinguished name."	| modSet mySet otherSet |	mySet := self attrSet.	otherSet := anotherLDAPEntry attrSet.	modSet := LDAPModificationSet new.	"Add or replace attributes from anotherLDAPEntry"	otherSet getAttributes contents do: [:otherAttr | | myAttr |		myAttr := mySet getAttribute: otherAttr name.		myAttr isNil			ifTrue: [modSet 						addModificationWithOperation: LDAPModification addOperation						attribute: otherAttr]			ifFalse: [myAttr values = otherAttr values						ifFalse: [modSet									addModificationWithOperation: LDAPModification replaceOperation									attribute: otherAttr]]].	"Remove any of my attributes that are not in anotherLDAPEntry"	mySet getAttributes contents do: [:myAttr | | otherAttr |		otherAttr := otherSet getAttribute: myAttr name.		otherAttr isNil			ifTrue: [modSet						addModificationWithOperation: LDAPModification deleteOperation						attribute: myAttr]].	^ modSet</body></methods><methods><class-id>Net.LDAPEntry</class-id> <category>initialize-release</category><body package="LDAP">initialize	dn := String new.	attrSet := LDAPAttributeSet new.	^ self</body></methods><methods><class-id>Net.LDAPEntry</class-id> <category>copying</category><body package="LDAP">copy	| newInstance |	newInstance := self class newWithName: self dn.	newInstance attrSet: self attrSet copy.	^ newInstance</body></methods><methods><class-id>Net.LDAPEntry class</class-id> <category>instance creation</category><body package="LDAP">new	^ self basicNew initialize</body><body package="LDAP">newWithName: aString	^ self new dn: aString</body><body package="LDAP">newWithName: aString attributeSet: aLDAPAttributeSet	| anInstance |	anInstance := self newWithName: aString.	anInstance attrSet: aLDAPAttributeSet.	^ anInstance</body></methods><methods><class-id>Net.LDAPEntryChangeControl</class-id> <category>accessing</category><body package="LDAP">changeNumber	^ mChangeNumber</body><body package="LDAP">changeNumber: anInteger	mChangeNumber := anInteger</body><body package="LDAP">changeTypes	^ mChangeTypes</body><body package="LDAP">changeTypes: anInteger	mChangeTypes := anInteger</body><body package="LDAP">previousDN	^ mPreviousDN</body><body package="LDAP">previousDN: aString	mPreviousDN := aString</body></methods><methods><class-id>Net.LDAPEntryChangeControl</class-id> <category>initialize-release</category><body package="LDAP">initialize	super initialize.	mChangeNumber := -1.	mChangeTypes := -1.	mPreviousDN := String new.</body></methods><methods><class-id>Net.LDAPEntryChangeControl class</class-id> <category>constants</category><body package="LDAP">entryChanged	^ '2.16.840.1.113730.3.4.7'</body></methods><methods><class-id>Net.LDAPEntryChangeControl class</class-id> <category>instance creation</category><body package="LDAP">new	^ self newFromOid: self entryChanged critical: false value: ByteArray new</body></methods><methods><class-id>Net.JDAPProtocolOp class</class-id> <category>class initialization</category><body package="LDAP">initialize	"JDAPProtocolOp initialize"	"See RFC 1777"	OperationTypes := Dictionary new.    	OperationTypes at: 0 put: 'BIND_REQUEST'.    	OperationTypes at: 1 put: 'BIND_RESPONSE'.    	OperationTypes at: 2 put: 'UNBIND_REQUEST'.    	OperationTypes at: 3 put: 'SEARCH_REQUEST'.    	OperationTypes at: 4 put: 'SEARCH_RESPONSE'.    	OperationTypes at: 5 put: 'SEARCH_RESULT'.    	OperationTypes at: 6 put: 'MODIFY_REQUEST'.    	OperationTypes at: 7 put: 'MODIFY_RESPONSE'.    	OperationTypes at: 8 put: 'ADD_REQUEST'.    	OperationTypes at: 9 put: 'ADD_RESPONSE'.    	OperationTypes at: 10 put: 'DEL_REQUEST'.    	OperationTypes at: 11 put: 'DEL_RESPONSE'.    	OperationTypes at: 12 put: 'MODIFY_RDN_REQUEST'.    	OperationTypes at: 13 put: 'MODIFY_RDN_RESPONSE'.    	OperationTypes at: 14 put: 'COMPARE_REQUEST'.    	OperationTypes at: 15 put: 'COMPARE_RESPONSE'.    	OperationTypes at: 16 put: 'ABANDON_REQUEST'.    	OperationTypes at: 19 put: 'SEARCH_RESULT_REFERENCE'.    	OperationTypes at: 23 put: 'EXTENDED_REQUEST'.    	OperationTypes at: 24 put: 'EXTENDED_RESPONSE'.</body></methods><methods><class-id>Net.JDAPProtocolOp class</class-id> <category>accessing</category><body package="LDAP">classImplementingOperation: anInteger 	"Answer the implementation class for operation tag &lt;anInteger&gt;. 	The class is obtained from the operation name kept in the tag-to-operation mapping 	by concatenating operation name fragments (separated by underline), with 	- fragments first character capitalized	- other characters lower-case	- underline removed (e.g. BLA_BLA_BLA =&gt; BlaBlaBla)	Return: Class"	| opName opStream acnStream aChar |	opName := self operationType: anInteger.	opStream := opName readStream.	acnStream := (String new: opName size) writeStream.	acnStream nextPutAll: 'JDAP'.	acnStream nextPut: opStream next.	[opStream atEnd] whileFalse: 			[(aChar := opStream next) == $_ 				ifTrue: [acnStream nextPut: opStream next]				ifFalse: [acnStream nextPut: aChar asLowercase]].	^Net at: acnStream contents asSymbol ifAbsent: []</body><body package="LDAP">codeForOperationType: aString 	"Answer the code for operation named &lt;aString&gt;.	Inline Dictionary&gt;&gt;keyAtValue:ifAbsent: to compare values with #= instead of #==.	Return: Integer"	OperationTypes 		keysAndValuesDo: [:aKey :aValue | aValue = aString ifTrue: [^aKey]].	LDAPError raiseErrorString: 'Unknown operation type ' , aString</body><body package="LDAP">operationType: anInteger	^ OperationTypes at: anInteger ifAbsent: ['Unknown Operation Type']</body></methods><methods><class-id>Net.JDAPDelRequest</class-id> <category>encoding</category><body package="LDAP">getBERElement	| s element tag |	s := BEROctetString newFromString: self baseDN.	tag := (BERElement tag: 'Application') bitOr: 10.	element := BERTag					newWithTag: tag					element: s					implicit: true.	^ element</body></methods><methods><class-id>Net.JDAPDelRequest</class-id> <category>accessing</category><body package="LDAP">getType	^ JDAPProtocolOp codeForOperationType: 'DEL_REQUEST'</body></methods><methods><class-id>Net.JDAPDelRequest</class-id> <category>printing</category><body package="LDAP">getParamString	| paramStream |	paramStream := WriteStream on: String new.	paramStream nextPutAll: '{entry='.	paramStream nextPutAll: self baseDN.	paramStream nextPutAll: '}'.	^ paramStream contents</body></methods><methods><class-id>Net.JDAPDelRequest class</class-id> <category>instance creation</category><body package="LDAP">newForDN: aString	| instance |	instance := self new.	instance baseDN: aString.	^ instance</body></methods><methods><class-id>Net.LDAPSchema</class-id> <category>accessing</category><body package="LDAP">addAttribute: anLDAPAttributeSchema	self attributes 		at: anLDAPAttributeSchema name asLowercase 		put: anLDAPAttributeSchema</body><body package="LDAP">addMatchingRule: anLDAPMatchingRuleSchema	self matchingRules 		at: anLDAPMatchingRuleSchema name asLowercase 		put: anLDAPMatchingRuleSchema</body><body package="LDAP">addObjectClass: anLDAPObjectClassSchema	self objectClasses 		at: anLDAPObjectClassSchema name asLowercase 		put: anLDAPObjectClassSchema</body><body package="LDAP">attributes	^ attributes</body><body package="LDAP">entryName	^ entryName</body><body package="LDAP">entryName: aString	entryName := aString</body><body package="LDAP">getAttributeNamed: aString	^ self attributes 		at: aString asLowercase 		ifAbsent: [nil]</body><body package="LDAP">getAttributeNames	^ ReadStream on: self attributes keys</body><body package="LDAP">getAttributes	^ ReadStream on: self attributes values</body><body package="LDAP">getMatchingRuleNamed: aString	^ self matchingRules 		at: aString asLowercase 		ifAbsent: [nil]</body><body package="LDAP">getMatchingRuleNames	^ ReadStream on: self matchingRules keys</body><body package="LDAP">getMatchingRules	^ ReadStream on: self matchingRules values</body><body package="LDAP">getObjectClassNamed: aString	^ self objectClasses 		at: aString asLowercase 		ifAbsent: [nil]</body><body package="LDAP">getObjectClassNames	^ ReadStream on: self objectClasses keys</body><body package="LDAP">getObjectClasses	^ ReadStream on: self objectClasses values</body><body package="LDAP">matchingRules	^ matchingRules</body><body package="LDAP">objectClasses	^ objectClasses</body></methods><methods><class-id>Net.LDAPSchema</class-id> <category>utilities</category><body package="LDAP">fetchSchemaUsingConnection: anLDAPConnection	| entry attr strm sch h raw use |	(anLDAPConnection isNil or: [anLDAPConnection isConnected not])		ifTrue: [^ (LDAPException newForResultCode: 80) raiseSignal: 'No Connection'].	entry := anLDAPConnection readDN: String new.	entry isNil		ifTrue: [^ (LDAPException newForResultCode: 32) raiseSignal].	attr := entry getAttribute: 'subschemasubentry'.	self entryName: 'cn=schema'.	attr notNil		ifTrue: [strm := attr getStringValues.			    strm atEnd					ifFalse: [self entryName: strm next]].	"Get the entire schema definition entry"	entry := anLDAPConnection readDN: self entryName.	"Get all object class definitions"	attr := entry getAttribute: 'objectclasses'.	attr notNil		ifTrue: [strm := attr getStringValues.			    [strm atEnd]					whileFalse: [						sch := LDAPObjectClassSchema newFromString: strm next.						self addObjectClass: sch]].	"Get all attribute definitions"	attr := entry getAttribute: 'attributetypes'.	attr notNil		ifTrue: [strm := attr getStringValues.			    [strm atEnd]					whileFalse: [						sch := LDAPAttributeSchema newFromString: strm next.						self addAttribute: sch]].	"Matching rules are tricky, because we have to match up a rule with its use.  First get all the uses."	h := Dictionary new.	attr := entry getAttribute: 'matchingruleuse'.	attr notNil		ifTrue: [strm := attr getStringValues.			    [strm atEnd]					whileFalse: [						use := strm next.						sch := LDAPMatchingRuleSchema newFromString: nil useDesc: use.						h at: sch oid put: use]].	"Now get the rules, and assign uses to them"	attr := entry getAttribute: 'matchingrules'.	attr notNil		ifTrue: [strm := attr getStringValues.			    [strm atEnd]					whileFalse: [						raw := strm next.						sch := LDAPMatchingRuleSchema newFromString: raw useDesc: nil.						use := h at: sch oid ifAbsent: [nil].						use isNil							ifFalse: [sch := LDAPMatchingRuleSchema newFromString: raw useDesc: use].						self addMatchingRule: sch]]</body></methods><methods><class-id>Net.LDAPSchema</class-id> <category>printing</category><body package="LDAP">toString	| outStream strm |	outStream := WriteStream on: String new.	outStream nextPutAll: 'Object classes: '.	outStream cr; cr.	strm := self getObjectClasses.	[strm atEnd]		whileFalse: [outStream nextPutAll: strm next toString.					outStream cr].	outStream cr; cr.	outStream nextPutAll: 'Attributes: '.	outStream cr.	strm := self getAttributes.	[strm atEnd]		whileFalse: [outStream nextPutAll: strm next toString.					outStream cr].	outStream cr.	outStream nextPutAll: 'Matching Rules: '.	strm := self getMatchingRules.	[strm atEnd]		whileFalse: [outStream nextPutAll: strm next toString.					outStream cr].	^ outStream contents</body></methods><methods><class-id>Net.LDAPSchema</class-id> <category>initialize-release</category><body package="LDAP">initialize	attributes := Dictionary new.	objectClasses := Dictionary new.	matchingRules := Dictionary new.	entryName := String new.	^ self</body></methods><methods><class-id>Net.LDAPSchema class</class-id> <category>instance creation</category><body package="LDAP">new	^ self basicNew initialize</body></methods><methods><class-id>Net.BERReal</class-id> <category>accessing</category><body package="LDAP">getType	^ self class type: 'Real'</body><body package="LDAP">getValue	^ self value</body><body package="LDAP">value	^ mValue</body><body package="LDAP">value: aFloat	mValue := aFloat</body></methods><methods><class-id>Net.BERReal</class-id> <category>input-output</category><body package="LDAP">writeOn: outStream	"This method is not implemented."</body></methods><methods><class-id>Net.BERReal</class-id> <category>printing</category><body package="LDAP">toString	^ 'Real {', mValue asString, '}'</body></methods><methods><class-id>Net.BERReal</class-id> <category>initialize-release</category><body package="LDAP">initialize	super initialize.	mValue := 0.0.</body></methods><methods><class-id>Net.BERReal class</class-id> <category>accessing</category><body package="LDAP">minusInfinity	MinusInfinity isNil ifTrue: [self initialize].	^ MinusInfinity</body><body package="LDAP">plusInfinity	PlusInfinity isNil ifTrue: [self initialize].	^ PlusInfinity</body></methods><methods><class-id>Net.BERReal class</class-id> <category>class initialization</category><body package="LDAP">initialize	"Approximate value of plus/minus infinity for practical purposes.	Installation of the meta number package would allow a more rigorous implementation."	"BERReal initialize"	PlusInfinity := LimitedPrecisionReal					readFrom: (ReadStream on: '1.0e29').	MinusInfinity := LimitedPrecisionReal						readFrom: (ReadStream on: '-1.0e29').</body></methods><methods><class-id>Net.BERReal class</class-id> <category>instance creation</category><body package="LDAP">fromValue: aFloat	^ self basicNew initialize value: aFloat</body><body package="LDAP">newFrom: inStream bytesRead: anArray 	"Read from input stream.	anArray contains a single integer representing the number of bytes read from the stream."	| length value octet bytesRead sign base number f exponent mantissa numExponentOctets contentsLengthLeft |	length := self readLengthOctetsFrom: inStream bytesRead: anArray.	length = 0 ifTrue: [^self fromValue: 0].	bytesRead := anArray at: 1.	octet := inStream next.	bytesRead := bytesRead + 1.	"Special Real Values"	octet = 64 		ifTrue: 			[anArray at: 1 put: bytesRead.			^self fromValue: self plusInfinity].	octet = 65 		ifTrue: 			[anArray at: 1 put: bytesRead.			^self fromValue: self minusInfinity].	(octet bitAnd: 128) = 0 		ifTrue: 			[anArray at: 1 put: bytesRead.			^self unsupportedRealEncodingSignal raise].	"Bit 8"	"Binary encoding"	"M = S * N * 2^F where S = +/-1, 0 &lt;= F &lt;= 3"	(octet bitAnd: 64) &gt; 0 ifTrue: [sign := -1] ifFalse: [sign := 1].	"Bit 7"	(octet bitAnd: 32) &gt; 0 		ifTrue: 			[(octet bitAnd: 16) &gt; 0 ifTrue: [base := 0] ifFalse: [base := 16]	"Bit 5"	"Bits 6+5 = 11, Reserve for future use"]		ifFalse: 			[(octet bitAnd: 16) &gt; 0 ifTrue: [base := 8] ifFalse: [base := 2]	"Bits 6+5=01"].	"Bit 6"	"Bits 6+5 = 10"	"Bits 6+5=00"	(octet bitAnd: 8) &gt; 0 		ifTrue: 			[(octet bitAnd: 4) &gt; 0 ifTrue: [f := 3] ifFalse: [f := 2]	"Bit 3"	"Bits 4+3=11"]		ifFalse: 			[(octet bitAnd: 4) &gt; 0 ifTrue: [f := 1] ifFalse: [f := 0]	"Bits 4+3=01"].	"Bit 4"	"Bits 4+3=10"	"Bits 4+3=00"	(octet bitAnd: 2) &gt; 0 		ifTrue: 			[(octet bitAnd: 1) &gt; 0 				ifTrue: 					[numExponentOctets := inStream next.					bytesRead := bytesRead + 1]				ifFalse: [numExponentOctets := 3	"Bits 2+1=10"].	"Bit 1"			"Bits 2+1=11"			"Following octet encodes number of octets used to encode the exponent"			anArray at: 1 put: bytesRead.			exponent := self 						readTwosComplementFrom: inStream						bytesRead: anArray						length: numExponentOctets]		ifFalse: 			[anArray at: 1 put: bytesRead.			(octet bitAnd: 1) &gt; 0 				ifTrue: 					["Bits 2+1=01"					numExponentOctets := 2]				ifFalse: 					["Bits 2+1=00"					numExponentOctets := 1].			exponent := self 						readTwosComplementFrom: inStream						bytesRead: anArray						length: numExponentOctets].	"Bit 2"	contentsLengthLeft := length - 1 - numExponentOctets.	number := self 				readUnsignedBinaryFrom: inStream				bytesRead: anArray				length: contentsLengthLeft.	mantissa := sign * number * (2 raisedToInteger: f).	value := mantissa * (base raisedTo: exponent).	^self fromValue: value</body></methods><methods><class-id>Net.LDIF</class-id> <category>accessing</category><body package="LDAP">decoder	^ mDecoder</body><body package="LDAP">reader	^ mReader</body><body package="LDAP">reader: anLDIFLineReader	mReader := anLDIFLineReader</body><body package="LDAP">source	^ mSource</body><body package="LDAP">source: aStream	mSource := aStream</body><body package="LDAP">version	"Answer the version of LDIF used in the data."	^ 1</body></methods><methods><class-id>Net.LDIF</class-id> <category>private</category><body package="LDAP">getDecodedString: eString	| eStream |	eStream := ReadStream on: eString.	^ (mDecoder mimeDecodeToChars: eStream) contents</body><body package="LDAP">parseAddSpec	| ac |	ac := self parseLDIFContent.	mCurrEntryDone		ifTrue: [mCurrEntryDone := false].	^ LDIFAddContent newWithAttributes: ac getAttributes</body><body package="LDAP">parseDeleteSpec	| rArray line |	rArray := self reader readLine.	mDone := rArray at: 2.	line := rArray at: 1.	(line isNil or: [line size = 0])		ifTrue: [^ LDIFDeleteContent new].	^ Error raiseSignal: 'Invalid delete specification &lt;', line, '&gt;'</body><body package="LDAP">parseLDIFContent	"Parses LDIF content.  The list of attributes is terminated by CR-LF or '-'.  This method is also used to parse the attributes in modifications."	| line rArray changetype dict continue newtype val newAttr len idx substr lArray ac |	rArray := self reader readLine.	mDone := rArray at: 2.	mDone		ifTrue: [^ nil].	line := rArray at: 1.		(line isNil or: [line size &lt; 1 or: [ line = '-']])		ifTrue: [line notNil &amp; line size &lt; 1					ifTrue: [mCurrEntryDone := true].			    ^ nil].	"Handle the modification record type"	('changetype:*' match: line ignoreCase: true)		ifTrue: [changetype := (line copyFrom: 12 to: line size) rTrim.			    changetype = 'modify'					ifTrue: [^ self parseModSpec].			    changetype = 'add'					ifTrue: [^ self parseAddSpec].			    changetype = 'delete'					ifTrue: [^ self parseDeleteSpec].			    (changetype = 'moddn') | (changetype = 'modrdn')					ifTrue: [^ self parseModDNSpec].			   ^ Error raiseSignal: ('Change type not supported: ', changetype)].	"Handle the attribute list record type"	dict := Dictionary new.	continue := true.	[continue]		whileTrue: [			len := line size.			len &lt; 1				ifTrue: [continue := false]				ifFalse: [idx := line indexOf: $:.						idx = 0							ifTrue: [^ Error raiseSignal: ('No ":" found in &lt;', line, '&gt;')].						newtype := line copyFrom: 1 to: (idx - 1).						idx := idx + 1.						len &gt; idx							ifTrue: [(line at: idx) == $:										ifTrue: [idx := idx + 1.											    substr := (line copyFrom: idx to: line size) lTrim rTrim.											    val := self getDecodedString: substr]										ifFalse: [(line at: idx) == $&lt;													ifTrue: [^ Error raiseSignal: 'File redirection not supported.']													ifFalse: [val := (line copyFrom: idx to: line size) lTrim rTrim]]].						newAttr := dict at: newtype ifAbsent: [LDAPAttribute newWithName: newtype].						newAttr addValue: val.						dict at: newtype put: newAttr.						lArray := self reader readLine.						line := lArray at: 1.						mDone := lArray at: 2.						(line isNil or: [line size &lt; 1 or: [ line = '-' ]])							ifTrue: [(line notNil and: [ line size &lt; 1 ])										ifTrue: [mCurrEntryDone := true].								    continue := false]]].	ac := LDIFAttributeContent new.	dict values do: [:anAttribute |		ac addElement: anAttribute].	^ ac</body><body package="LDAP">parseLDIFRecord	"Parses LDIF content.  The list of attributes is terminated by CR-LF or '-'.  This method is also used to parse the attributes in modifications."	| line dn rArray content |	rArray := self reader readLine.	mDone := rArray at: 2.	mDone		ifTrue: [^ nil].	line := rArray at: 1.	line isNil		ifTrue: [mDone := true.			    ^ nil].	line size = 0		ifTrue: [^ nil].	('dn:*' match: line ignoreCase: true)		ifFalse: [^ Error raiseSignal: ('No DN found in &lt;', line, '&gt;')].	dn := (line copyFrom: 4 to: (line size)) lTrim rTrim.	"Double ':' after an attribute name signifies attribute value is Base 64 MIME encoded."	(dn size &gt; 1 and: [dn first == $:])		ifTrue: [dn := self getDecodedString: (dn copyFrom: 2 to: dn size)].	content := self parseLDIFContent.	^ LDIFRecord newWithDN: dn content: content</body><body package="LDAP">parseModDNSpec	| rArray line mc continue str |	rArray := self reader readLine.	mDone := rArray at: 2.	line := rArray at: 1.	mc := LDIFModDNContent new.	continue := true.	[continue]		whileTrue: [('newrdn:*' match: line ignoreCase: true) &amp; (line size &gt; ('newrdn:' size + 1))						ifTrue: [mc rdn: (line copyFrom: ('newrdn:' size + 1) to: line size) lTrim rTrim].				    ('deleteoldrdn:*' match: line ignoreCase: true) &amp; (line size &gt; ('deleteoldrdn:' size + 1))						ifTrue: [str := (line copyFrom: ('deleteoldrdn:' size + 1) to: line size) lTrim rTrim.							    str = '0'									ifTrue: [mc deleteOldRDN: false]									ifFalse: [str = '1'												ifTrue: [mc deleteOldRDN: true]												ifFalse: [^ Error raiseSignal: ('Incorrect input for delete old RDN &lt;', str, '&gt;')]]].				     ('newsuperior:*' match: line ignoreCase: true) &amp; (line size &gt; ('newsuperior:' size + 1))						ifTrue: [mc newParent: (line copyFrom: ('newsuperior:' size + 1) to: line size) lTrim rTrim].				     rArray := self reader readLine.				     mDone := rArray at: 2.				     line := rArray at: 1.				     (line isNil or: [line size = 0])						ifTrue: [continue := false]].	^ mc</body><body package="LDAP">parseModSpec	| line rArray mc continue oper index attrName ac attr |	rArray := self reader readLine.	mDone := rArray at: 2.	line := rArray at: 1.	mc := LDIFModifyContent new.	continue := true.	[continue]		whileTrue: [			oper := -1.			('add:*' match: line)				ifTrue: [oper := LDAPModification addOperation].			('delete:*' match: line)				ifTrue: [oper := LDAPModification deleteOperation].			('replace:*' match: line)				ifTrue: [oper := LDAPModification replaceOperation].			oper = -1				ifTrue: [^ Error raiseSignal: ('Unknown modify type &lt;', line, '&gt;')].			ac := self parseLDIFContent.			ac notNil				ifTrue: [ac getAttributes do: [:anAttribute |							mc addElement: (LDAPModification newWithOperation: oper attribute: anAttribute)]]				ifFalse: [index := line indexOf: $:.						index = 0							ifTrue: [^ Error raiseSignal: ('Colon missing in &lt;', line, '&gt;')].						attrName := (line copyFrom: (index + 1) to: line size) lTrim.						oper = LDAPModification addOperation							ifTrue: [^ Error raiseSignal: ('Add operation needs value for attribute ', attrName)].						attr := LDAPAttribute newWithName: attrName.						mc addElement: (LDAPModification newWithOperation: oper attribute: attr)].			mCurrEntryDone				ifTrue: [mCurrEntryDone := false.					    continue := false]				ifFalse: [rArray := self reader readLine.						mDone := rArray at: 2.						line := rArray at: 1.						(line isNil or: [line size = 0])							ifTrue: [continue := false]]].	^ mc</body></methods><methods><class-id>Net.LDIF</class-id> <category>printing</category><body package="LDAP">toString	^ 'LDIF {', mSource asString, '}'</body></methods><methods><class-id>Net.LDIF</class-id> <category>input-output</category><body package="LDAP">nextRecord	mDone ifTrue: [^ nil].	^ self parseLDIFRecord</body></methods><methods><class-id>Net.LDIF</class-id> <category>initialize-release</category><body package="LDAP">initialize	mDecoder := Base64MimeConverter.	mDone := false.	mCurrEntryDone := false.	^ self</body><body package="LDAP">release	self reader inStream close.	super release.</body></methods><methods><class-id>Net.LDIF class</class-id> <category>instance creation</category><body package="LDAP">new	^ self basicNew initialize</body><body package="LDAP">newForFilename: aFilename	| instance |	instance := self new.	instance reader: (LDIFLineReader newForInputStream: (aFilename withEncoding: #UTF_8) readStream).	instance source: aFilename.	^ instance</body><body package="LDAP">newForStream: anInputStream	"anInputStream assumed to support UTF_8 encoding"	| instance |	instance := self new.	instance reader: (LDIFLineReader newForInputStream: anInputStream).	instance source: anInputStream.	^ instance</body></methods><methods><class-id>Net.LDIF class</class-id> <category>utilities</category><body package="LDAP">breakString: vString on: outStream max: maxInteger	"Write vString onto outStream in LDIF line continuation format.  No line will be longer than maxInteger characters.  A continuation line starts with a single space."	| left written maxChars toWrite s |	left := vString size.	written := 0.	maxChars := maxInteger.	[left &gt; 0]		whileTrue: [			toWrite := maxChars min: left.			s := vString copyFrom: (written + 1) to: (written + toWrite).			written = 0				ifTrue: [outStream nextPutAll: s.					    maxChars := maxChars - 1]				ifFalse: [outStream space.						outStream nextPutAll: s].			written := written + toWrite.			left := left - toWrite.			outStream cr]</body><body package="LDAP">isPrintable: aByteArray	"Answers false if aByteArray should be Base 64 MIME converted on output."	| val lo hi tab |		lo := Character space asInteger.	hi := 127.	tab := Character tab asInteger.	aByteArray do: [:aByte |		val := aByte asInteger.		val &lt; lo | val &gt; hi			ifTrue: [val = tab						ifFalse: [^ false]]].	^ true</body></methods><methods><class-id>Net.LDIF class</class-id> <category>constants</category><body package="LDAP">commentChar	^ $#</body></methods><methods><class-id>Net.LDAPVirtualListResponse</class-id> <category>accessing</category><body package="LDAP">contentCount	^mContentCount</body><body package="LDAP">contentCount: anInteger	mContentCount := anInteger</body><body package="LDAP">firstPosition	^mFirstPosition</body><body package="LDAP">firstPosition: anInteger	mFirstPosition := anInteger</body><body package="LDAP">resultCode	^ mResultCode</body><body package="LDAP">resultCode: anInteger	mResultCode := anInteger</body></methods><methods><class-id>Net.LDAPVirtualListResponse</class-id> <category>input-output</category><body package="LDAP">parseResponse	| inStream decoder nRead seq |	inStream := ReadStream on: self value.	decoder := JDAPBERTagDecoder new.	nRead := Array with: 0.	[seq := BERElement getElementFrom: inStream decoder: decoder bytesRead: nRead.	self firstPosition: (seq elementAt: 1) value.	self contentCount: (seq elementAt: 2) value.	self resultCode: (seq elementAt: 3) value]		on: Exception		do: [self firstPosition: -1.			self contentCount: -1.			self resultCode: -1]</body></methods><methods><class-id>Net.LDAPVirtualListResponse</class-id> <category>initialize-release</category><body package="LDAP">initialize	super initialize.	mFirstPosition := 0.	mContentCount := 0.	mResultCode := -1.</body></methods><methods><class-id>Net.LDAPVirtualListResponse class</class-id> <category>constants</category><body package="LDAP">virtualListResponse	^ '2.16.840.1.113730.3.4.10'</body></methods><methods><class-id>Net.LDAPVirtualListResponse class</class-id> <category>input-output</category><body package="LDAP">parseResponse: controls	"Answers a control returned on a VirtualList search.  The controls returned by the server can be obtained using the reponseControls method of an LDAPConnection object."	| con |	controls isNil		ifTrue: [^ nil].	controls do: [:aControl |		aControl id = self virtualListResponse			ifTrue: [con := self newFromByteArray: aControl value]].	con isNil		ifFalse: [con parseResponse].	^ con</body></methods><methods><class-id>Net.LDAPVirtualListResponse class</class-id> <category>instance creation</category><body package="LDAP">new	^ self newFromOid: self virtualListResponse critical: true value: ByteArray new</body><body package="LDAP">newFromByteArray: aByteArray	"Answers a new instance with data value given by a BER encoded byte array."	| instance |	instance := self new.	instance value: aByteArray.	instance parseResponse.	^ instance</body></methods><methods><class-id>Net.BERSequence</class-id> <category>printing</category><body package="LDAP">toString	| aString |	aString := self elements					inject: 'Sequence {'					into: [:newString :nextElement |							newString, nextElement toString, ', '].	^ (aString copyFrom: 1 to: (aString size - 2)), '}'</body></methods><methods><class-id>Net.BERSequence</class-id> <category>accessing</category><body package="LDAP">getType	^ self class type: 'Sequence'</body></methods><methods><class-id>Net.JDAPExtendedRequest</class-id> <category>printing</category><body package="LDAP">getParamString	| paramStream |	paramStream := WriteStream on: String new.	paramStream nextPutAll: '{OID='.	paramStream nextPutAll: self oid.	paramStream nextPutAll: ', value='.	paramStream nextPutAll: (self value size = 0 									ifTrue: [String new] 									ifFalse: [self value asStringEncoding: #UTF_8]).	paramStream nextPutAll: '}'.	^ paramStream contents</body><body package="LDAP">toString	^ self class, ' ', self getParamString</body></methods><methods><class-id>Net.JDAPExtendedRequest</class-id> <category>accessing</category><body package="LDAP">getType	^ JDAPProtocolOp codeForOperationType: 'EXTENDED_REQUEST'</body><body package="LDAP">oid	^ mOid</body><body package="LDAP">oid: aString	mOid := aString</body><body package="LDAP">value	^ mValue</body><body package="LDAP">value: aByteArray	mValue := aByteArray</body></methods><methods><class-id>Net.JDAPExtendedRequest</class-id> <category>initialize-release</category><body package="LDAP">initialize	mOid := String new.	mValue := ByteArray new.	^ self</body></methods><methods><class-id>Net.JDAPExtendedRequest</class-id> <category>encoding</category><body package="LDAP">getBERElement	| seq element tag |	seq := BERSequence new.	tag := BERElement tag: 'Application'.	seq addElement: (BEROctetString newFromString: self oid).		 "(BERTag 							newWithTag: tag 							element: (BEROctetString newFromString: self oid) 							implicit: true)."	mValue size &gt; 0		ifTrue: [ tag := (BERElement tag: 'Application') bitOr: 1.				seq addElement: (BERTag 									newWithTag: tag 									element: (BEROctetString newFromByteArray: self value from: 1 to: self value size) 									implicit: true)].									tag := ((BERElement tag: 'Application') bitOr: (BERElement tag: 'Constructed')) bitOr: 23.	element := BERTag newWithTag: tag							element: seq							implicit: true.	^ element</body></methods><methods><class-id>Net.JDAPExtendedRequest class</class-id> <category>instance creation</category><body package="LDAP">newForOid: oidString value: aByteArray	| instance |	instance := self new.	instance oid: oidString.	instance value: aByteArray.	^ instance</body></methods><methods><class-id>Net.JDAPBindRequest</class-id> <category>accessing</category><body package="LDAP">credentials	^ mCredentials</body><body package="LDAP">credentials: aByteArray	mCredentials := aByteArray</body><body package="LDAP">getType	^ JDAPProtocolOp codeForOperationType: 'BIND_REQUEST'</body><body package="LDAP">mechanism	^ mMechanism</body><body package="LDAP">mechanism: aString	mMechanism := aString</body><body package="LDAP">name	^ mName</body><body package="LDAP">name: aString	mName := aString</body><body package="LDAP">password	^ mPassword</body><body package="LDAP">password: aString	mPassword := aString</body><body package="LDAP">version	^ mVersion</body><body package="LDAP">version: anInteger	mVersion := anInteger</body></methods><methods><class-id>Net.JDAPBindRequest</class-id> <category>encoding</category><body package="LDAP">getBERElement	| seq auth sasl element tag |	seq := BERSequence new.	seq addElement: (BERInteger newForValue: self version).	seq addElement: (BEROctetString newFromString: self name).	(self mechanism isNil or: [self mechanism size = 0])		ifTrue: [tag := BERElement tag: 'Context'.			    auth := BERTag 							newWithTag: tag 							element: (BEROctetString newFromString: self password) 							implicit: true]		ifFalse: [sasl := BERSequence new.				self credentials isNil					ifTrue: [sasl addElement: (BEROctetString newFromByteArray: ByteArray new)]					ifFalse: [sasl addElement: (BEROctetString 													newFromByteArray: self credentials 													from: 1 													to: self credentials size)].				tag := (BERElement tag: 'SASLContext') bitOr: 3.				auth := BERTag							newWithTag: tag							element: sasl							implicit: true].	seq addElement: auth.	tag := (BERElement tag: 'Application') bitOr: (BERElement tag: 'Constructed').	element := BERTag					newWithTag: tag					element: seq					implicit: true.	^ element</body></methods><methods><class-id>Net.JDAPBindRequest</class-id> <category>printing</category><body package="LDAP">getParamString	| paramStream |	paramStream := WriteStream on: String new.	paramStream nextPutAll: '{version='.	paramStream nextPutAll: self version displayString.	paramStream nextPutAll: ', name='.	paramStream nextPutAll: self name.	paramStream nextPutAll: ', authentication='.	paramStream nextPutAll: self password.	paramStream nextPutAll: '}'.	^ paramStream contents</body><body package="LDAP">toString	^ self class, ' ', self getParamString</body></methods><methods><class-id>Net.JDAPBindRequest</class-id> <category>initialize-release</category><body package="LDAP">initialize	mVersion := 2.	mName := String new.	mPassword := String new.	mMechanism := String new.	mCredentials := ByteArray new.	^ self</body></methods><methods><class-id>Net.JDAPBindRequest class</class-id> <category>instance creation</category><body package="LDAP">newForVersion: anInteger name: nString mechanism: mString credentials: aByteArray	"Constructs an LDAPv3 SaslCredentials bind request.  Mechanism parameter is required."	| instance |	instance := self new.	instance version: anInteger.	instance name: nString.	instance mechanism: mString.	instance credentials: aByteArray.	^ instance</body><body package="LDAP">newForVersion: anInteger name: nString password: pString	"Constructs an anonymous or simple bind request"	| instance |	instance := self new.	instance version: anInteger.	instance name: nString.	instance password: pString.	^ instance</body></methods><methods><class-id>Net.LDAPPersistSearchControl</class-id> <category>encoding</category><body package="LDAP">createPersistSearchSpecificationFor: typesInteger changesOnly: changeBoolean returnControls: returnBoolean	"Creates a 'flattened' BER encoding of the persistent search specifications and answers it as a byte array."	| seq |	seq := BERSequence new.	seq addElement: (BERInteger newForValue: self changeTypes).	seq addElement: (BERBoolean newForValue: self changesOnly).	seq addElement: (BERBoolean newForValue: self returnECs).	^ self flattenBER: seq</body></methods><methods><class-id>Net.LDAPPersistSearchControl</class-id> <category>accessing</category><body package="LDAP">changeTypes	^ mChangeTypes</body><body package="LDAP">changeTypes: anInteger	mChangeTypes := anInteger</body><body package="LDAP">changesOnly	^ mChangesOnly</body><body package="LDAP">changesOnly: aBoolean	mChangesOnly := aBoolean</body><body package="LDAP">returnECs	^ mReturnECs</body><body package="LDAP">returnECs: aBoolean	mReturnECs := aBoolean</body></methods><methods><class-id>Net.LDAPPersistSearchControl</class-id> <category>input-output</category><body package="LDAP">parseResponse: aByteArray	"Takes an input byte array and extracts the BER elements, assigning them to appropriate variables in the entry change control.  Answers an instance of LDAPEntryChangeControl."	| con inStream decoder numRead s enum num str |	con := LDAPEntryChangeControl new.	inStream := ReadStream on: aByteArray.	decoder := JDAPBERTagDecoder new.	numRead := Array with: 0.	s := BERElement getElementFrom: inStream decoder: decoder bytesRead: numRead.	enum := s elementAt: 1.	con changeTypes: enum value.	s size &gt; 1		ifTrue: [((s elementAt: 2) isKindOf: BEROctetString)					ifTrue: [str := s elementAt: 2.						    con previousDN: (str value asStringEncoding: #UTF_8)]					ifFalse: [((s elementAt: 2) isKindOf: BERInteger)								ifTrue: [num := s elementAt: 2.									    con changeNumber: num value]]].	s size &gt; 2		ifTrue: [num := s elementAt: 3.			    con changeNumber: num value].	^ con</body></methods><methods><class-id>Net.LDAPPersistSearchControl</class-id> <category>initialize-release</category><body package="LDAP">initialize	super initialize.	mChangeTypes := 1.	mChangesOnly := false.	mReturnECs := false.</body></methods><methods><class-id>Net.LDAPPersistSearchControl class</class-id> <category>instance creation</category><body package="LDAP">new	^ self newFromOid: self persistentSearch critical: true value: ByteArray new</body><body package="LDAP">newForTypes: typesInteger changesOnly: changeBoolean returnControls: returnBoolean isCritical: criticalBoolean	| instance |	instance := self newFromOid: self persistentSearch critical: criticalBoolean value: ByteArray new.	instance value: (instance createPersistSearchSpecificationFor: typesInteger 								changesOnly: changeBoolean 								returnControls: returnBoolean).	^ instance</body></methods><methods><class-id>Net.LDAPPersistSearchControl class</class-id> <category>constants</category><body package="LDAP">add	^ 1</body><body package="LDAP">delete	^ 2</body><body package="LDAP">modDN	^ 8</body><body package="LDAP">modify	^ 4</body><body package="LDAP">persistentSearch	^ '2.16.840.1.113730.3.4.3'</body></methods><methods><class-id>Net.LDAPPersistSearchControl class</class-id> <category>input-output</category><body package="LDAP">parseResponse: controls	"Answers an entry change notification control object if the control is in the specified collection 'controls'.  Use this method to retrieve an entry change notification control included with an entry sent by the server.  The controls returned by the server can be obtained using the reponseControls method of an LDAPConnection object."	| con |	controls isNil		ifTrue: [^ nil].	con := self new.	controls do: [:aControl |		aControl id = LDAPEntryChangeControl entryChanged			ifTrue: [^ con parseResponse: aControl value]].	^ nil</body></methods><methods><class-id>Net.JDAPModifyRdnRequest</class-id> <category>accessing</category><body package="LDAP">deleteOldDN	^ mDeleteOldDN</body><body package="LDAP">deleteOldDN: aBoolean	mDeleteOldDN := aBoolean</body><body package="LDAP">getType	^ JDAPProtocolOp codeForOperationType: 'MODIFY_RDN_REQUEST'</body><body package="LDAP">newRDN	^ mNewRDN</body><body package="LDAP">newRDN: aString	mNewRDN := aString</body><body package="LDAP">newSuperior	^ mNewSuperior</body><body package="LDAP">newSuperior: aString	mNewSuperior := aString</body><body package="LDAP">oldDN	^ mOldDN</body><body package="LDAP">oldDN: aString	mOldDN := aString</body></methods><methods><class-id>Net.JDAPModifyRdnRequest</class-id> <category>printing</category><body package="LDAP">getParamString	| paramStream |	paramStream := WriteStream on: String new.	paramStream nextPutAll: '{entry='.	paramStream nextPutAll: self oldDN.	paramStream nextPutAll: ', newrdn='.	paramStream nextPutAll: self newRDN.	paramStream nextPutAll: ', deleteoldrdn='.	paramStream nextPutAll: self deleteOldDN toString.	paramStream nextPutAll: '}'.	^ paramStream contents</body></methods><methods><class-id>Net.JDAPModifyRdnRequest</class-id> <category>encoding</category><body package="LDAP">getBERElement	| seq element tag |	seq := BERSequence new.	seq addElement: (BEROctetString newFromString: self oldDN).	seq addElement: (BEROctetString newFromString: self newRDN).		"LDAPv3 new parent dn feature support"	self newSuperior size &gt; 0		ifTrue: [seq addElement: (BEROctetString newFromString: self newSuperior)].	seq addElement: (BERBoolean newForValue: self deleteOldDN).	tag := ((BERElement tag: 'Application') bitOr: (BERElement tag: 'Constructed')) bitOr: 12.	element := BERTag newWithTag: tag element: seq implicit: true.	^ element</body></methods><methods><class-id>Net.JDAPModifyRdnRequest</class-id> <category>initialize-release</category><body package="LDAP">initialize	super initialize.	mOldDN := String new.	mNewRDN := String new.	mDeleteOldDN := true.	mNewSuperior := String new.</body></methods><methods><class-id>Net.JDAPModifyRdnRequest class</class-id> <category>instance creation</category><body package="LDAP">newForOldDN: oldString newRDN: newString deleteOldDN: aBoolean	| instance |	instance := self new.	instance oldDN: oldString.	instance newRDN: newString.	instance deleteOldDN: aBoolean.	^ instance</body><body package="LDAP">newForOldDN: oldString newRDN: newString deleteOldDN: aBoolean newSuperior: supString	| instance |	instance := self new.	instance oldDN: oldString.	instance newRDN: newString.	instance deleteOldDN: aBoolean.	instance newSuperior: supString.	^ instance</body></methods><methods><class-id>Net.RelativeDistinguishedName</class-id> <category>printing</category><body package="LDAP">toString	^ mType, '=', mValue</body></methods><methods><class-id>Net.RelativeDistinguishedName</class-id> <category>accessing</category><body package="LDAP">explodeRDNNoTypes: aBoolean	"Answer an array including the value that makes up this relative distinguished name.  aBoolean indicates whether the type of the component attribute is to be suppressed (For example: 'cn=')"	aBoolean		ifTrue: [^ Array with: mValue]		ifFalse: [^ Array with: self toString]</body><body package="LDAP">getType	^ self type</body><body package="LDAP">getValue	^ self value</body><body package="LDAP">type	^ mType</body><body package="LDAP">type: aString	mType := aString</body><body package="LDAP">value	^ mValue</body><body package="LDAP">value: aString	mValue := aString</body></methods><methods><class-id>Net.RelativeDistinguishedName</class-id> <category>comparing</category><body package="LDAP">equivalentTo: aRDN	^ (self toString asUppercase) = (aRDN toString asUppercase)</body></methods><methods><class-id>Net.RelativeDistinguishedName</class-id> <category>initialize-release</category><body package="LDAP">initialize	mType := String new.	mValue := String new.	^ self</body></methods><methods><class-id>Net.RelativeDistinguishedName class</class-id> <category>instance creation</category><body package="LDAP">new	^ self basicNew initialize</body><body package="LDAP">newFromString: aString	"Constructs a new instance from a string with the format: 'type=value', where type is the string representing the attribute type (for example: o, ou, uid, cn), and value is the string representing the attribute value."	| idx instance |	idx := aString indexOf: $=.	idx &lt;= 1		ifTrue: [^ self invalidRDNFormatSignal raiseRequestWith: aString].	instance := self new.	instance type: (aString copyFrom: 1 to: (idx - 1)).	instance value: (aString copyFrom: (idx + 1) to: aString size).	^ instance</body></methods><methods><class-id>Net.RelativeDistinguishedName class</class-id> <category>utilities</category><body package="LDAP">isRDN: aString	^ self invalidRDNFormatSignal		handle: [:ex | ex proceedWith: self new]		do: [ | instance result | 			result := true.			instance := self newFromString: aString.			instance type size &gt; 0				ifFalse: [result := false].			instance value size &gt; 0				ifFalse: [result := false].			result].</body></methods><methods><class-id>Net.RelativeDistinguishedName class</class-id> <category>signals</category><body package="LDAP">invalidRDNFormatSignal	^ RDNSignals at: #invalidRDNFormatSignal</body></methods><methods><class-id>Net.RelativeDistinguishedName class</class-id> <category>class initialization</category><body package="LDAP">initialize	"RelativeDistinguishedName initialize"	RDNSignals := Dictionary new.	RDNSignals 		at: #invalidRDNFormatSignal		put: ((Signal basicNew				parent: Object errorSignal				mayProceed: true)					notifierString: 'Relative Distinguished Name string has invalid format';					nameClass: self message: #invalidRDNFormatSignal; 					yourself)</body></methods><methods><class-id>Net.LDAPAttributeSet</class-id> <category>copying</category><body package="LDAP">copy	| clone |	clone := self class new.	recursionLock		critical: [			attrs values do: [:anAttr |				clone addAttribute: anAttr copy]].	^ clone</body><body package="LDAP">getSubset: subtypeString	"Answers a new LDAPAttributeSet containing only those attributes that contain the subtype corresponding to subtypeString.  For example, suppose an attribute set contains the following attributes:	cn	cn;lang-ja	sn;phonetic;lang-ja	sn;lang-usMessage getSubset: 'lang-ja' will answer an attribute set containing the following attributes:	cn;lang-ja	sn;phonetic;lang-jasubtypeString is a semi-colon delimited list of all subtypes to match in attribute names.  For example:	'lang-ja'			matches Japanese language subtypes	'binary'			matches binary subtypes	'binary;lang-ja'	matches Japanese language subtypes which are also binary."	| newSet searchTypes |	newSet := self class new.	(subtypeString isNil or: [subtypeString size = 0])		ifTrue: [^ newSet].	searchTypes := subtypeString tokensBasedOn: $;.	searchTypes size &lt; 1		ifTrue: [^ newSet].	((attrs values copyWithout: nil)		select: [:anAttr | anAttr hasSubtypes: searchTypes])			do: [:anAttr | newSet addAttribute: anAttr].	^ newSet</body></methods><methods><class-id>Net.LDAPAttributeSet</class-id> <category>accessing</category><body package="LDAP">addAttribute: aLDAPAttribute	aLDAPAttribute isNil		ifTrue: [^ self].	attrs at: aLDAPAttribute name put: aLDAPAttribute copy</body><body package="LDAP">attributes	| tCollect |	tCollect := OrderedCollection new: attrs values size.	recursionLock		critical: [			attrs values do: [:aValue | tCollect add: aValue copy]].	^tCollect</body><body package="LDAP">elementAt: anIndex	"Unsupported, since a Dictionary is used to maintain the collection of attributes."	^ self error: 'elementAt: method unsupported for LDAPAttributeSet'</body><body package="LDAP">getAttribute: aString	"Answer the attribute whose name exactly matches aString (except for case)"	^ attrs 		at: aString asLowercase		ifAbsent: [nil]</body><body package="LDAP">getAttribute: nameString language: langString	"Answers the subtype that matches the attribute name specified by nameString and the language specification identified by langString.	If no attribute in this set has the specified name and language subtype, answer nil.	Attributes containing subtypes other than lang (for example 'cn;binary') are answered only if they contain the specified lang subtype, and if the set contains no attribute having only the lang subtype.  (For example, getAttribute: 'cn' language: 'lang-ja' answers the 'cn;lang-ja-phonetic' attribute only if the 'cn;lang-ja' attribute does not exist.	If nil is specified for the language argument, invoking this method is the same as invoking the getAttribute: method."	| langLower langComponents base subs found isCandidate matchCount attrLang attrLangs tCount |	(langString isNil or: [langString size = 0])		ifTrue: [^ self getAttribute: nameString].	langLower := langString asLowercase.	('lang-*' match: langLower)		ifFalse: [^ nil].	langComponents := langLower tokensBasedOn: $-.	"First element is just 'lang-' "	langComponents := langComponents copyFrom: 2 to: (langComponents size).	matchCount := 0.	base := (LDAPAttribute getBaseName: nameString) asLowercase.	subs := (LDAPAttribute getSubtypes: nameString) collect: [: subType | subType asLowercase ].	(attrs values copyWithout: nil) do: [:anAttr |		isCandidate := false.		anAttr getBaseName = base			ifTrue: [(subs isNil or: [subs size &lt; 1])						ifTrue: [isCandidate := true]						ifFalse: [(anAttr hasSubtypes: subs)									ifTrue: [isCandidate := true]]].		isCandidate			ifTrue: [attrLang := anAttr getLangSubtype.				    attrLang isNil						ifTrue: [found := anAttr]						ifFalse: [attrLangs := attrLang asLowercase tokensBasedOn: $-.								"First token is just 'lang-' "							 	attrLangs := attrLangs copyFrom: 2 to: (attrLangs size).								attrLangs size &lt;= langComponents size									ifTrue: [tCount := 0.											1 to: attrLangs size do: [:idx |												(attrLangs at: idx) = (langComponents at: idx)													ifTrue: [tCount := tCount + 1]													ifFalse: [tCount := 0]].											tCount &gt; matchCount												ifTrue: [found := anAttr.													     matchCount := tCount]]]]].	^ found</body><body package="LDAP">getAttributes	| tCollect |	tCollect := OrderedCollection new: attrs values size.	recursionLock		critical: [			attrs values do: [:aValue | tCollect add: aValue copy]].	^ ReadStream on: tCollect</body><body package="LDAP">removeAttribute: aString	"Removes the attribute with the specified name from this set"	attrs removeKey: aString asLowercase 		ifAbsent: []</body><body package="LDAP">removeElementAt: anIndex	"Unsupported, since a Dictionary is used to maintain the collection of attributes."	^ self error: 'removeElementAt: method unsupported for LDAPAttributeSet'</body><body package="LDAP">size	^ attrs size</body></methods><methods><class-id>Net.LDAPAttributeSet</class-id> <category>printing</category><body package="LDAP">toString	"Answers the string representation of each attribute in the set.	Example: 	LDAPAttributeSet: LDAPAttribute {type='cn', values='Barbara Jensen,Babs Jensen'} LDAPAttribute {type='sn', values='Jensen'} LDAPAttribute {type='givenname', values='Barbara'} LDAPAttribute {type='objectclass', values='top,person,organizationalPerson,inetOrgPerson'} LDAPAttribute {type='ou', values='Product Development,People'}"	^ (attrs values copyWithout: nil)		inject: 'LDAPAttributeSet:'		into: [:theString :nextAttr | theString, ' ', nextAttr toString]</body></methods><methods><class-id>Net.LDAPAttributeSet</class-id> <category>initialize-release</category><body package="LDAP">initialize	attrs := Dictionary new.	recursionLock := RecursionLock new.	^ self</body></methods><methods><class-id>Net.LDAPAttributeSet class</class-id> <category>instance creation</category><body package="LDAP">new	^ self basicNew initialize</body><body package="LDAP">newFromAttributes: aCollect	"Answers an attribute set containing the attributes in aCollect"	| anInstance |	anInstance := self new.	aCollect do: [:anAttr | anInstance addAttribute: anAttr].	^ anInstance</body></methods><methods><class-id>Net.LDIFAttributeContent</class-id> <category>accessing</category><body package="LDAP">addElement: aLDAPAttribute	mAttrs add: aLDAPAttribute</body><body package="LDAP">getAttributes	^ mAttrs copy</body><body package="LDAP">getType	^ self class attributeContent</body></methods><methods><class-id>Net.LDIFAttributeContent</class-id> <category>printing</category><body package="LDAP">toString	| outStream |	outStream := WriteStream on: String new.	mAttrs do: [:anAttr |		outStream nextPutAll: anAttr toString].	^ self class name asString, ' {', outStream contents, '}'</body></methods><methods><class-id>Net.LDIFAttributeContent</class-id> <category>initialize-release</category><body package="LDAP">initialize	mAttrs := OrderedCollection new.</body></methods><methods><class-id>Net.LDIFAttributeContent class</class-id> <category>instance creation</category><body package="LDAP">new	^ self basicNew initialize</body></methods><methods><class-id>Net.LDAPSortKey</class-id> <category>accessing</category><body package="LDAP">key	^ mKey</body><body package="LDAP">key: aString	mKey := aString</body><body package="LDAP">matchRule	^ mMatchRule</body><body package="LDAP">matchRule: aString	mMatchRule := aString</body><body package="LDAP">reverse	^ mReverse</body><body package="LDAP">reverse: aBoolean	mReverse := aBoolean</body></methods><methods><class-id>Net.LDAPSortKey</class-id> <category>initialize-release</category><body package="LDAP">initialize	mKey := String new.	mReverse := false.	^ self</body></methods><methods><class-id>Net.LDAPSortKey class</class-id> <category>instance creation</category><body package="LDAP">new	^ self basicNew initialize</body><body package="LDAP">newFromDescription: descString	| instance colonIndex |	instance := self new.	(descString isNil or: [descString size = 0])		ifTrue: [^ instance].	descString first == $-		ifTrue: [instance reverse: true.			    instance key: (descString copyFrom: 2 to: descString size)]		ifFalse: [instance key: descString].	colonIndex := instance key indexOf: $:.	colonIndex = 1		ifTrue: [instance key: String new]		ifFalse: [colonIndex &gt; 0					ifTrue: [instance matchRule: (instance key 													copyFrom: (colonIndex + 1) 													to: instance key size).						    instance key: (instance key copyFrom: 1 to: (colonIndex - 1))]].	^ instance</body><body package="LDAP">newFromKey: keyString reverse: aBoolean	| instance |	instance := self new.	instance key: keyString.	instance reverse: aBoolean.	^ instance</body><body package="LDAP">newFromKey: keyString reverse: aBoolean matchRule: matchRuleString	| instance |	instance := self newFromKey: keyString reverse: aBoolean.	instance matchRule: matchRuleString.	^ instance</body></methods><methods><class-id>Net.LDAPSortKey class</class-id> <category>constants</category><body package="LDAP">reverse	^ Integer fromHex: '81'</body></methods><methods><class-id>Net.JDAPSearchRequest</class-id> <category>accessing</category><body package="LDAP">addAttr: aString	mAttrs add: aString</body><body package="LDAP">attrs	^ mAttrs</body><body package="LDAP">attrs: aCollection	mAttrs := aCollection</body><body package="LDAP">attrsOnly	^ mAttrsOnly</body><body package="LDAP">attrsOnly: aBoolean	mAttrsOnly := aBoolean</body><body package="LDAP">deref	^ mDeref</body><body package="LDAP">deref: anInteger	mDeref := anInteger</body><body package="LDAP">filter	^ mFilter</body><body package="LDAP">filter: aString	mFilter := aString</body><body package="LDAP">getType	^ JDAPProtocolOp codeForOperationType: 'SEARCH_REQUEST'</body><body package="LDAP">scope	^ mScope</body><body package="LDAP">scope: anInteger	mScope := anInteger</body><body package="LDAP">sizeLimit	^ mSizeLimit</body><body package="LDAP">sizeLimit: anInteger	mSizeLimit := anInteger</body><body package="LDAP">timeLimit	^ mTimeLimit</body><body package="LDAP">timeLimit: anInteger	mTimeLimit := anInteger</body></methods><methods><class-id>Net.JDAPSearchRequest</class-id> <category>encoding</category><body package="LDAP">getBERElement        "Assumed that searching with the following criteria:         *     base object = 'c=ca'         *     filter      = FilterPresent(objectClass)         * [*] zoomit server v1.0 (search on c=ca)         *     0x63 0x81 0x8d              ([APPLICATION 3])         *     0x30 0x81 0x8a 0x04 0x00    (seq of)         *     0x0a 0x01 0x02         *     0x0a 0x01 0x00         *     0x02 0x01 0x65         *     0x02 0x01 0x1e         *     0x01 0x01 0x00         *     0xa0 0x3b         *     0x30 0x39 0xa5 0x0d         *     0x30 0x0b 0x04 0x07 P A G E _ D N         *     0x04 0x00         *     0xa3 0x0e         *     0x30 0x0c 0x04 0x08 P A G E _ K E Y         *     0x04 0x00 0xa3 0x18         *     0x30 0x16 0x04 0x0e z c A n y A t t r i b u t e         *     0x04 0x04 c = c a         *     0x30 0x3a 0x04 0x0b O b j e c t C l a s s         *     0x04 0x11 a l i a s e d O b j e c t N a m e         *     0x04 0x07 d s e T y p e         *     0x04 0x0f t e l e p h o n e N u m b e r         * [*] umich-ldap-v3.3:         *     0x63 0x24          ([APPLICATION 3])         *     0x04 0x04 c = c a  (base object - OctetString)         *     0x0a 0x01 0x00     (scope - Enumerated)         *     0x0a 0x01 0x00     (derefAlias - Enumerated)         *     0x02 0x01 0x00     (size limit - Integer)         *     0x02 0x01 0x00     (time limit - Integer)         *     0x01 0x01 0x00     (attr only - Boolean)         *     0x87 0x0b o b j e c t C l a s s (filter)         *     0x30 0x00          (attrs - Sequence of OctetString)"	| seq tag element attrTypeList filter |		seq := BERSequence new.	seq addElement: (BEROctetString newFromString: self baseDN).	seq addElement: (BEREnumerated newForValue: self scope).	seq addElement: (BEREnumerated newForValue: self deref).	seq addElement: (BERInteger newForValue: self sizeLimit).	seq addElement: (BERInteger newForValue: self timeLimit).	seq addElement: (BERBoolean newForValue: self attrsOnly).	filter := JDAPFilter getFilter: self filter.	filter isNil		ifTrue: [^ nil].	seq addElement: filter getBERElement.	attrTypeList := BERSequence new.	self attrs do: [:each |		attrTypeList addElement: (BEROctetString newFromString: each)].	seq addElement: attrTypeList.	tag := ((BERElement tag: 'Application') bitOr: (BERElement tag: 'Constructed')) bitOr: 3.	element := BERTag newWithTag: tag element: seq implicit: true.	^ element</body></methods><methods><class-id>Net.JDAPSearchRequest</class-id> <category>initialize-release</category><body package="LDAP">initialize	super initialize.	mScope := self class baseObject.	mDeref := self class neverDerefAliases.	mSizeLimit := 0.	mTimeLimit := 0.	mAttrsOnly := false. 	mFilter := String new.	mAttrs := OrderedCollection new.	^ self</body></methods><methods><class-id>Net.JDAPSearchRequest</class-id> <category>printing</category><body package="LDAP">getParamString	| paramStream first |	paramStream := WriteStream on: String new.	paramStream nextPutAll: '{baseObject='.	paramStream nextPutAll: self baseDN.	paramStream nextPutAll: ', scope='.	paramStream nextPutAll: self scope displayString.	paramStream nextPutAll: ', derefAliases='.	paramStream nextPutAll: self deref displayString.	paramStream nextPutAll: ', sizeLimit='.	paramStream nextPutAll: self sizeLimit displayString.	paramStream nextPutAll: ', timeLimit='.	paramStream nextPutAll: self timeLimit displayString.		paramStream nextPutAll: ', attrsOnly='.	paramStream nextPutAll: self attrsOnly displayString.	paramStream nextPutAll: ', filter='.	paramStream nextPutAll: self filter.	paramStream nextPutAll: ', attributes='.	first := true.	self attrs do: [:each |		first 			ifTrue: [first := false]			ifFalse: [paramStream nextPut: $+].		paramStream nextPutAll: each].	paramStream nextPutAll: '}'.	^ paramStream contents</body></methods><methods><class-id>Net.JDAPSearchRequest class</class-id> <category>constants</category><body package="LDAP">baseObject	^ 0</body><body package="LDAP">derefAlways	^ 3</body><body package="LDAP">derefFindingBaseObj	^ 2</body><body package="LDAP">derefInSearching	^ 1</body><body package="LDAP">neverDerefAliases	^ 0</body><body package="LDAP">singleLevel	^ 1</body><body package="LDAP">wholeSubtree	^ 2</body></methods><methods><class-id>Net.JDAPSearchRequest class</class-id> <category>instance creation</category><body package="LDAP">newForDN: dnString scope: scopeInt dereference: derefInt sizeLimit: sizeInt timeLimit: timeInt attrsOnly: attrBoolean filter: filterString attrs: attrCollect	"Answers a search request.  dnString is the base distinguished name from which to search the directory.  scopeInt indicates which levels in the directory to search from the base distinguished name (see class constants protocol).  derefInt indicates how to handle directory aliases encountered during the search (see class constants protocol).  sizeInt indicates the maximum number of entries to be retrieved.  timeInt indicates the maximum time allowed for the search.  attrBoolean, if true, indicates that only the attribute types should be retrieved, not the attribute values themselves.  filterString specifies a filter based on RFC 1558.  attrCollect is a collection of the string identifiers corresponding to the attribute types to be retrieved in the search."	| instance |	instance := self new.	instance baseDN: dnString.	instance scope: scopeInt.	instance deref: derefInt.	instance sizeLimit: sizeInt.	instance timeLimit: timeInt.	instance attrsOnly: attrBoolean.	instance filter: filterString.	attrCollect do: [:each |		instance addAttr: each].	^ instance</body></methods><methods><class-id>Core.String</class-id> <category>copying</category><body package="LDAP">lTrim	"Answer a copy of the string with the leading spaces removed."	| firstNonSpace  |	firstNonSpace := self findFirst: [:aChar | aChar isSeparator not].	(firstNonSpace = 0) ifTrue: [^ ''].	^ self copyFrom: firstNonSpace to: (self size)</body><body package="LDAP">rTrim	"Answer a copy of the string with the trailing spaces removed."	^self copyFrom: 1 to: (self findLast: [:aChar | aChar isSeparator not])</body><body package="LDAP">trim	^ self lTrim rTrim</body></methods><methods><class-id>Core.PeekableStream</class-id> <category>accessing</category><body package="LDAP">upToAnyOf: aCollection	"Answer a subcollection from position to the occurrence of any member of aCollection, exclusive.	 The stream is left positioned before the member encountered.	If no member is found answer everything."	| newStream element |	newStream := (self contentsSpecies new: 64) writeStream.	[self atEnd]		whileFalse:			[element := self peek.			(aCollection includes: element)				ifTrue: [^newStream contents].			newStream nextPut: self next].	^newStream contents</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>converting</category><body package="LDAP">tokensBasedOnAnyOf: aCollection	^ self tokensBasedOnAnyOf: aCollection answerTokens: false</body><body package="LDAP">tokensBasedOnAnyOf: aCollection answerTokens: aBoolean 	"Answer a collection of substrings based on any of the delimiters contained in aCollection (a collection of characters).  	If aBoolean is true, the separator tokens are included as strings in the result."	| str tokens |	tokens := OrderedCollection new.	self isEmpty ifTrue: [^tokens].	str := self readStream.	[str atEnd] whileFalse: 			[| chunk separator |			chunk := str upToAnyOf: aCollection.			chunk isEmpty ifFalse: [tokens add: chunk].			str atEnd 				ifFalse: 					[separator := str next.					aBoolean ifTrue: [tokens add: (String with: separator)]]].	(aCollection includes: self last) ifTrue: [tokens add: ''].	^tokens</body></methods><methods><class-id>Core.Integer class</class-id> <category>instance creation</category><body package="LDAP">fromHex: aString	^ self readFrom: (ReadStream on: aString) radix: 16</body></methods><initialize><class-id>Net.BERElement</class-id></initialize><initialize><class-id>Net.JDAPFilterOpers</class-id></initialize><initialize><class-id>Net.JDAPResult</class-id></initialize><initialize><class-id>Net.LDAPException</class-id></initialize><initialize><class-id>Net.Base64MimeConverter</class-id></initialize><initialize><class-id>Net.LDAPConnection</class-id></initialize><initialize><class-id>Net.LDAPSchemaElement</class-id></initialize><initialize><class-id>Net.JDAPProtocolOp</class-id></initialize><initialize><class-id>Net.BERReal</class-id></initialize><initialize><class-id>Net.RelativeDistinguishedName</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>CharacterArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>PeekableStream</name><environment>Core</environment><super>Core.Stream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>Notification</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class></st-source>