<?xml version="1.0"?><st-source><!-- Name: NetConfigToolNotice: Copyright 1999-2017 Cincom Systems, Inc.  All rights reserved.Comment: Contains pages for the Network Settings to store a few default values that are useful while working with NetClients.DbIdentifier: bear73DbTrace: 499775DbUsername: tkoganDbVersion: 8.3 - 1DevelopmentPrerequisites: #(#(#any 'NetClientBase' '') #(#any 'Tools-Settings' '') #(#any 'HTTP' '') #(#any 'Tools-Settings-VW' ''))DisregardedPrerequisites: #(#(#name 'MIME' #componentType #package) #(#name 'FTP' #componentType #package))PackageName: NetConfigToolParcel: #('NetConfigTool')ParcelName: NetConfigToolPrerequisiteDescriptions: #(#(#name 'NetClientBase') #(#name 'Tools-Settings') #(#name 'HTTP' #componentType #package) #(#name 'Tools-Settings-VW' #componentType #package))PrerequisiteParcels: #(#('NetClientBase' '') #('Tools-Settings' '') #('HTTP' '') #('Tools-Settings-VW' ''))PrintStringCache: (8.3 - 1,tkogan)Version: 8.3 - 1Date: 2:30:29 PM April 28, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (apr17.3) of April 28, 2017 on April 28, 2017 at 2:30:29 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>NetSettingsPage</name><environment>Net</environment><super>Tools.SettingsManagerPage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>userPreferences userListOwner </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetConfigTool</package></attributes></class><comment><class-id>Net.NetSettingsPage</class-id><body>A NetSettingsPage provides an user-interface for editing a Settings properties. Instance Variables:	identityListAspect	&lt;SelectionInList&gt;	identities list	serverListAspect	&lt;SelectionInList&gt;	mail server list	netUser	&lt;NetUser&gt;	selected instance of NetClient	hostSpec	&lt;HostSpec&gt;	selected instance of HostSpecShared Variables:	UserPreferences	&lt;Dictionary&gt;	The user preference profile is a Dictionary with of value models against subject keys</body></comment><class><name>HttpProxyPage</name><environment>Net</environment><super>Net.NetSettingsPage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>redirectRequest proxyExceptions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetConfigTool</package></attributes></class><comment><class-id>Net.HttpProxyPage</class-id><body>HttpPage creates Http UI Settings pageInstance Variables:	proxyExceptions	&lt;Collection of Strings&gt;	do not use proxy servers for domains in the proxyExceptions list	redirectRequest	&lt;ValueModel of Boolean&gt;	describe wether or not redirect the request </body></comment><class><name>NetSettings</name><environment>Net</environment><super>Tools.GenericSettingDescriptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetConfigTool</package></attributes></class><comment><class-id>Net.NetSettings</class-id><body>Settings is a central repository for various preference items related to Internet Connectivity clients. The Setting class is the model for application model UISettings.Instance Variables:Shared Variables:	Registry	&lt;IdentityDictionary&gt;	holds all settings</body></comment><class><name>UserPage</name><environment>Net</environment><super>Net.NetSettingsPage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>identityListAspect netUser </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetConfigTool</package></attributes></class><comment><class-id>Net.UserPage</class-id><body>A UserPage provides an user-interface for editing a Settings properties. Instance Variables:	identityListAspect	&lt;SelectionInList&gt;	identities list	serverListAspect	&lt;SelectionInList&gt;	mail server list	netUser	&lt;NetUser&gt;	selected instance of NetClient	hostSpec	&lt;HostSpec&gt;	selected instance of HostSpecShared Variables:	UserPreferences	&lt;Dictionary&gt;	The user preference profile is a Dictionary with of value models against subject keys</body></comment><class><name>AddNetUser</name><environment>Net</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parent accountIdentity emailAddressIdentity fullNameIdentity passwordIdentity userNameIdentity verifyPasswordIdentity </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetConfigTool</package></attributes></class><comment><class-id>Net.AddNetUser</class-id><body>A AddNetUser is an application model designed to add new user for UISettings. The only reason to have this class that TabbedDialog as supperclass for UISettings doesn't support two models.Instance Variables:	parent	&lt;UISettings&gt;	an instance of UISettings</body></comment><class><name>MailServerPage</name><environment>Net</environment><super>Net.NetSettingsPage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>serverListAspect hostSpec </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetConfigTool</package></attributes></class><comment><class-id>Net.MailServerPage</class-id><body>MailPage creates the UI page for the mail server settingsInstance Variables:	hostSpec	&lt;HostSpec&gt;	name of the selected mail server	serverListAspect	&lt;SelectionInList&gt;	mail server list</body></comment><class><name>HttpProxyExceptions</name><environment>Net</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>httpProxyExceptions parent </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetConfigTool</package></attributes></class><comment><class-id>Net.HttpProxyExceptions</class-id><body>A HttpProxyException  provides an user-interface for editing a http proxy exceptions. Instance Variables:	httpProxyExceptions	&lt;String&gt;	proxy exceptions</body></comment><class><name>NetRef</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetConfigTool</package></attributes></class><comment><class-id>Net.NetRef</class-id><body>NetRef is used to save/restore objects from the Net Settings</body></comment><shared-variable><name>Registry</name><environment>Net.NetSettings</environment><private>false</private><constant>false</constant><category>registry</category><attributes><package>NetConfigTool</package></attributes></shared-variable><methods><class-id>Net.NetSettingsPage</class-id> <category>accessing settings</category><body package="NetConfigTool">registry	^self class registry</body><body package="NetConfigTool">resetUserPreferences	userPreferences := Dictionary new.	^userPreferences</body><body package="NetConfigTool">userPreferences	^userPreferences isNil 		ifTrue: [ self resetUserPreferences]		ifFalse: [ userPreferences ]</body><body package="NetConfigTool">userPreferencesAt: aSymbol	^self  userPreferences at: aSymbol</body><body package="NetConfigTool">userPreferencesAt: aSymbol ifAbsentPut: aBlock	^self userPreferences at: aSymbol ifAbsentPut: aBlock</body><body package="NetConfigTool">userPreferencesAt: aSymbol put: anObject	self userPreferences at: aSymbol put: anObject</body></methods><methods><class-id>Net.NetSettingsPage</class-id> <category>accessing</category><body package="NetConfigTool">settings	^Array with: Net.NetSettings new</body><body package="NetConfigTool">userListOwner	^userListOwner</body></methods><methods><class-id>Net.NetSettingsPage</class-id> <category>notifications</category><body package="NetConfigTool">triggered	manager triggerChannel value 		ifTrue: [self accept]		ifFalse: [ self reset ]</body></methods><methods><class-id>Net.NetSettingsPage</class-id> <category>actions</category><body package="NetConfigTool">accept</body><body package="NetConfigTool">importSnapshots: aCollection	NetSettings importSnapshots: aCollection first stateNodes.	self reset</body><body package="NetConfigTool">reset</body></methods><methods><class-id>Net.NetSettingsPage</class-id> <category>initialize-release</category><body package="NetConfigTool">manager: aSettingsManager	super manager: aSettingsManager.	userListOwner := manager pageWithId: #(net ).	manager triggerChannel onChangeSend: #triggered to: self</body></methods><methods><class-id>Net.NetSettingsPage class</class-id> <category>accessing settings</category><body package="NetConfigTool">registry	^Settings</body></methods><methods><class-id>Net.NetSettingsPage class</class-id> <category>class initialization</category><body package="NetConfigTool">initialize	"UISettings initialize "	( NetSettings dependents includes: self )		ifFalse:	[ NetSettings addDependent: self ].</body><body package="NetConfigTool">obsolete	"Break dependencies"	[NetSettings dependents includes: self] whileTrue:		[NetSettings removeDependent: self].	^super obsolete</body></methods><methods><class-id>Net.HttpProxyPage</class-id> <category>actions</category><body package="NetConfigTool">accept	(self httpUseProxy value		and: [self httpHost value isEmpty])			 ifTrue: [ ^Dialog warn: (#ProxyHostIsEmpty &lt;&lt; #net &gt;&gt; 'Proxy host is empty!')].	self registry useProxy: self httpUseProxy value.	(self httpUseProxy value 		and: [self httpHost value notNil and: [ self httpHost value notEmpty ]])		ifTrue: 			[ self registry proxyHost: 					(HostSpec new							name: self httpHost value;							port:  self httpPort value;							type: 'http';							netUser: self proxyUserMenuAspect value;							yourself) ].	self registry proxyExceptions:  self proxyExceptions.</body><body package="NetConfigTool">acceptProxyExceptions: aCollection	proxyExceptions := aCollection.	manager tickle</body><body package="NetConfigTool">addIdentity	self userListOwner addIdentity</body><body package="NetConfigTool">httpAdvanced	( HttpProxyExceptions new parent: self; yourself ) open</body><body package="NetConfigTool">importSnapshots: aCollection	super importSnapshots: aCollection.	self userListOwner reset</body><body package="NetConfigTool">reset	self httpUseProxy value: self registry useProxy.	self resetProxyAspects.</body><body package="NetConfigTool">resetProxyAspects	self httpHost value: self defaultProxyHost.	self proxyUserMenuAspect value: self defaultProxyUserMenuAspect.	self httpPort value: self defaultPort.</body><body package="NetConfigTool">resetUIStateToDefault	self httpUseProxy value: self registry useProxyDefault.	self resetProxyAspects.</body><body package="NetConfigTool">useProxyChanged	| aBoolean | 	aBoolean := self httpUseProxy value. 	#(proxyAddress proxyPort addIdentityButton advancedButton proxyUserMenuAspect addressLabel portLabel  proxyUserLabel )		do: [ :each | (self widgetAt: each ) isEnabled: aBoolean ].</body></methods><methods><class-id>Net.HttpProxyPage</class-id> <category>accessing</category><body package="NetConfigTool">helpText	^(#HttpProxySettingsHelp &lt;&lt; #net &gt;&gt; 'HTTP Settings allow specifying proxy server settings on a per-user basis.  Proxies are used in some situations to access the web through a firewall, or for improved web access. - Use proxy must be checked to use the proxy information - Address: is the host IP or name of the proxy server - Port: is the port number for the proxy server - Proxy User: is an user ID authorized to access the proxyProxy user must be defined as a user (see User Identities ) and then selected from the drop-down list. To define a new user, click Add User... .  Complete the form as described in help for the User Identities page.') asString</body><body package="NetConfigTool">httpHost	^self 		userPreferencesAt: #httpHost		ifAbsentPut: [ self defaultProxyHost asValue]</body><body package="NetConfigTool">httpPort	^self 		userPreferencesAt: #httpPort		ifAbsentPut: 			[ self defaultPort asValue]</body><body package="NetConfigTool">httpUseProxy 	^self 		userPreferencesAt: #httpUseProxy  		ifAbsentPut: [ self registry useProxy  asValue ]</body><body package="NetConfigTool">netUserMenu 	^self userListOwner netUserMenu</body><body package="NetConfigTool">proxyExceptions	proxyExceptions isNil		ifTrue: [ proxyExceptions := self registry proxyExceptions].	 ^proxyExceptions</body><body package="NetConfigTool">proxyUserMenuAspect	^self 		userPreferences at: #proxyUserMenuAspect		ifAbsentPut: [ self defaultProxyUserMenuAspect asValue]</body></methods><methods><class-id>Net.HttpProxyPage</class-id> <category>defaults</category><body package="NetConfigTool">defaultHttpUserMenuAspect	| ids | 	^(ids := self netUserMenu value menuItems) notEmpty		ifTrue: [ ids first value asValue]		ifFalse: [ nil asValue ]</body><body package="NetConfigTool">defaultPort	^self registry proxyHost notNil				ifTrue: [ self registry proxyHost port]				ifFalse: [80]</body><body package="NetConfigTool">defaultProxyHost	^self registry proxyHost notNil			ifTrue: [ self registry proxyHost name]			ifFalse: ['' ]</body><body package="NetConfigTool">defaultProxyUserMenuAspect	| uh usr |	uh := self registry proxyHost notNil		ifTrue: 			[( usr := self registry proxyHost netUser) notNil				ifTrue: [ usr ]].	^uh isNil 		ifTrue: [ self defaultHttpUserMenuAspect value]		ifFalse: [ uh]</body></methods><methods><class-id>Net.HttpProxyPage</class-id> <category>interface opening</category><body package="NetConfigTool">postBuildWith: aBuilder	self httpHost onChangeSend: #tickle to: self.	self httpPort onChangeSend: #tickle to: self.	self httpUseProxy onChangeSend: #tickle to: self.	self proxyUserMenuAspect onChangeSend: #tickle to: self.	self httpUseProxy onChangeSend: #useProxyChanged to: self.	self useProxyChanged.</body></methods><methods><class-id>Net.HttpProxyPage class</class-id> <category>accessing settings</category><body package="NetConfigTool">registry	^HttpSettings</body></methods><methods><class-id>Net.NetSettings</class-id> <category>persistence</category><body package="NetConfigTool">addStateXmlElementsTo: rootElement	self class addStateXmlElementsTo: rootElement</body><body package="NetConfigTool">restoreFrom: aSettingSnapshot	self class importSnapshots: aSettingSnapshot stateNodes</body></methods><methods><class-id>Net.NetSettings</class-id> <category>initialize-release</category><body package="NetConfigTool">initialize	super initialize.	id := #( net )</body></methods><methods><class-id>Net.NetSettings class</class-id> <category>private</category><body package="NetConfigTool">collection: aCollection asXmlNode: aString	| node |	node := self nodeForClass: 'OrderedCollection' tag: aString.	aCollection do: [ :each | node addNode: (each asXmlNode: 'item' ) ].	^node</body><body package="NetConfigTool">createNetRefFor: aNetClient tag: aString	| node attr |	node := self nodeForClass: 'Net.NetRef' tag: aString.	attr := node attributes.	attr 	add: ( XML.Attribute name: 'fullName' value: aNetClient fullName ).	^node</body><body package="NetConfigTool">createNetRefServerFor: aHostSpec tag: aString	| node attr |	node := self nodeForClass: 'Net.NetRef' tag: aString.	attr := node attributes.	attr 	add: ( XML.Attribute name: 'name' value: aHostSpec name ).	^node</body><body package="NetConfigTool">dictionary: aDict asXmlNode: aString	| node entry |	node := self nodeForClass: 'Dictionary' tag: aString.	aDict 		keysAndValuesDo: 			[ :key :value | 			entry := XML.Element tag: 'entry'.			node addNode: entry.			entry addNode: ( key asXmlNode: 'key' ).			entry addNode: ( value asXmlNode: 'value' ) ].		^node</body><body package="NetConfigTool">netObject: aClass asXmlNode: aString "We don't save #password values "	| value root |	aString = #defaultIdentity		ifTrue: [  ^self createNetRefFor: aClass  tag: aString ].	(aString = #defaultIncomingServer or: [ aString = #defaultOutgoingServer ])		ifTrue: [  ^self createNetRefServerFor: aClass  tag: aString ].	root := self nodeForClass: aClass class fullName tag: aString.	aClass class instVarNames do: [:ins | 		((value := aClass instVarAt: (aClass class instVarIndexFor: ins)) notNil 			and: [ ins ~= 'password' ])				ifTrue: [ root addNode: ( value class name = #NetUser 										ifTrue: [ self createNetRefFor: value tag: ins ]										ifFalse: [ value asXmlNode: ins ]) ]].	^root</body><body package="NetConfigTool">nodeForClass: aClassName tag: aString	| node |	node := XML.Element tag: aString.	node attributes: (OrderedCollection with: ( XML.Attribute name: 'smalltalkClass' value: aClassName )).	^node</body><body package="NetConfigTool">object: anObject asXmlNode: aString	| node |	node := self nodeForClass: anObject class fullName tag: aString.	node addNode: (XML.Text text: anObject printString ).	^node</body><body package="NetConfigTool">restoreClassFrom: anXMLElement	^(anXMLElement valueOfAttribute: 'smalltalkClass' ifAbsent: [^nil])		asSymbol asQualifiedReference value.</body><body package="NetConfigTool">restoreNetObject: anObject from:  anXMLElement	| val xmlColl |	xmlColl := anXMLElement realElements.	xmlColl do: 			[ :el |  			val := el restoreValue.			anObject perform: (el tag type, ':') asSymbol  with: val].	^anObject</body><body package="NetConfigTool">restoreRefFrom:  anXMLElement	| tag val |	tag := anXMLElement tag type asSymbol.	(tag = #defaultIdentity or: [ tag = #netUser ])		ifTrue: 			[  val := anXMLElement valueOfAttribute: 'fullName' ifAbsent: [ nil].			^Settings detectIdentityByName: val ].	(tag = #defaultIncomingServer or: [ tag = #defaultOutgoingServer ])		ifTrue: 			[ val := anXMLElement valueOfAttribute: 'name' ifAbsent: [ nil].			^Settings detectMailHostByName: val ].</body><body package="NetConfigTool">string: valString asXmlNode: aString	| node |	node := self nodeForClass: 'String' tag: aString.	node addNode: (XML.Text text: valString ).	^node</body></methods><methods><class-id>Net.NetSettings class</class-id> <category>persistence</category><body package="NetConfigTool">addStateXmlElementsTo: rootElement	| coll  | 	(coll := self registry at: #identities ifAbsent: [ nil]) notNil		ifTrue:  [ rootElement addNode: ( coll asXmlNode: #identities)].	(coll := self registry at: #mailServers ifAbsent: [ nil]) notNil		ifTrue:  [ rootElement addNode: ( coll asXmlNode: #mailServers)].	self registry keysAndValuesDo:		[ :key :value | 		(key ~= #identities and: [ key ~= #mailServers])			ifTrue: [	rootElement addNode: ( value asXmlNode: key) ]].</body><body package="NetConfigTool">importSnapshots: aCollectionElements	aCollectionElements do:		[ :el | self restoreSettingFrom: el ]</body><body package="NetConfigTool">restoreSettingFrom: anXMLElement	| key coll |	key := anXMLElement tag type  asSymbol.	key = #identities		ifTrue: 			[coll := self restoreValueFrom: anXMLElement. 			^coll do: [ :each | Settings addIdentity:  each] ].	key = #mailServers		ifTrue: 			[coll := self restoreValueFrom: anXMLElement.			 ^coll do: [ :each | Settings updateMailHost:  each] ].	self registry 		at: key		put: (self restoreValueFrom: anXMLElement)</body><body package="NetConfigTool">restoreValueFrom: anXMLElement	^(self restoreClassFrom:  anXMLElement ) 			restoreValueFrom: anXMLElement</body></methods><methods><class-id>Net.NetSettings class</class-id> <category>accessing settings</category><body package="NetConfigTool">registry	^Settings registry</body></methods><methods><class-id>Net.UserPage</class-id> <category>accessing</category><body package="NetConfigTool">accountIdentity 	^self 		userPreferencesAt: #accountIdentity  		ifAbsentPut: [ self defaultAccountIdentity asValue]</body><body package="NetConfigTool">defaultAccountIdentity 	^self netUser isNil		ifTrue: [ '' ]		ifFalse: [ self netUser account ]</body><body package="NetConfigTool">defaultFullNameIdentity  	^self netUser isNil		ifTrue: [ '' ]		ifFalse: [ self netUser fullName ]</body><body package="NetConfigTool">defaultMailAddressIdentity  	^self netUser isNil		ifTrue: [ '' ]		ifFalse: [ self netUser mailAddress ]</body><body package="NetConfigTool">defaultNetUserMenu	| menu |	menu := Menu new.	self defaultUser: self registry defaultIdentity.	self registry identities copy		do: 	[ :each |			menu				addItemLabel: (self userAsString: each)				value: each  ].	^menu</body><body package="NetConfigTool">defaultPasswordIdentity  	^self netUser isNil		ifTrue: [ '' ]		ifFalse: [ self netUser password ]</body><body package="NetConfigTool">defaultUser	^self userPreferencesAt: #defaultUser ifAbsentPut: [ nil ]</body><body package="NetConfigTool">defaultUser: aNetUser	^self userPreferencesAt: #defaultUser put: aNetUser</body><body package="NetConfigTool">defaultUserNameIdentity 	^self netUser isNil		ifTrue: [ '']		ifFalse: [ self netUser username ]</body><body package="NetConfigTool">emailAddressIdentity  	^self userPreferencesAt: #emailAddressIdentity  		ifAbsentPut: [self defaultMailAddressIdentity  asValue ]</body><body package="NetConfigTool">fullNameIdentity  	^self userPreferencesAt: #fullNameIdentity  			ifAbsentPut: [ self defaultFullNameIdentity asValue]</body><body package="NetConfigTool">helpText	^(#IdentityHelp &lt;&lt; #net &gt;&gt; 'Network Identities lists user identifications for this client. You may have only one, or several user identities.  To add an ID, click Add and complete the Add Identity dialog. In the Add Identity dialog: - Full name: is your name as it will be displayed - User Name: is your account user ID - Email address: is your email address for this account - Account is the account ID used if an FTP host requires an account (does not accept anonymous FTP)To provide a password for this account: - check Remember password to store this information - enter your password identically twice (Enter: and Confirm:). The password is masked while you type.') asString</body><body package="NetConfigTool">identityListAspect	identityListAspect isNil		ifTrue: 			[identityListAspect := SelectionInList							adapt: self 							aspect: #selectedIdentity							list: #userIdentities							selection: #selectedIdentity:].	^identityListAspect</body><body package="NetConfigTool">netUser	^netUser</body><body package="NetConfigTool">netUser: aNetUser	netUser := aNetUser.	self updateIdentityValuesFrom: netUser</body><body package="NetConfigTool">netUserMenu	^self 		userPreferencesAt: #netUserMenu  		ifAbsentPut: [ self defaultNetUserMenu asValue ]</body><body package="NetConfigTool">passwordIdentity  	^self userPreferencesAt: #passwordIdentity  			ifAbsentPut: [ self defaultPasswordIdentity asValue]</body><body package="NetConfigTool">proxyUserMenuAspect	^self userPreferences at: #proxyUserMenuAspect ifAbsent: [ nil asValue ]</body><body package="NetConfigTool">selectedIdentity	^self userAsString: self netUser</body><body package="NetConfigTool">selectedIdentity: aNetUserString	self enableButtons: aNetUserString notNil.	aNetUserString notNil ifTrue: [ self netUser: (self detectUser: aNetUserString string) ]</body><body package="NetConfigTool">userIdentities	^self netUserMenu value menuItems collect: [ :it | it label ]</body><body package="NetConfigTool">userNameIdentity 	^self userPreferencesAt: #userNameIdentity 			ifAbsentPut: [ self defaultUserNameIdentity  asValue]</body><body package="NetConfigTool">verifyPasswordIdentity	^self userPreferencesAt: #verifyPasswordIdentity  ifAbsentPut: [ nil asValue ].</body></methods><methods><class-id>Net.UserPage</class-id> <category>actions</category><body package="NetConfigTool">accept	self registry resetIdentities.	self netUserMenu value menuItems 		do: [ :itemx |			self registry addIdentity: itemx value].	self defaultUser notNil		ifTrue: [ self registry defaultIdentity: self defaultUser].	self updateIdentityListAspects.</body><body package="NetConfigTool">addIdentity	self netUser: NetUser new.	AddNetUser openWithSpec: #addIdentitySpec parent: self</body><body package="NetConfigTool">editIdentity	AddNetUser openWithSpec: #addIdentitySpec parent: self</body><body package="NetConfigTool">removeIdentity	| resp  | 	(self registry hasIdentityReference: self netUser)		ifTrue: 			[ resp := Dialog confirm: ((#IdentityIsUsedInServerSettings &lt;&lt; #net &gt;&gt; '&lt;1s&gt; identity is used in server settings. &lt;n&gt;Do you want to delete it?')			expandMacrosWith: self netUser fullName).			resp ifFalse: [^nil]]. 	self removeMenuItemFor: self netUser.	(self defaultUser notNil and: [self defaultUser fullName =  self netUser fullName])		ifTrue: [ self setAsDefaultIdentity: nil ].	(self proxyUserMenuAspect value notNil		and: [ self proxyUserMenuAspect value fullName =  self netUser fullName ])		ifTrue: [ self proxyUserMenuAspect value: nil ].	self identityListAspect listHolder changed: #value.	manager tickle.</body><body package="NetConfigTool">reset	self resetUIStateToDefault.</body><body package="NetConfigTool">resetUIStateToDefault	self netUserMenu  value: self defaultNetUserMenu.	self identityListAspect listHolder changed: #value.</body><body package="NetConfigTool">setAsDefaultIdentity	self setAsDefaultIdentity: self netUser</body></methods><methods><class-id>Net.UserPage</class-id> <category>interface opening</category><body package="NetConfigTool">enableButtons: aBoolean	self builder isNil ifTrue: [ ^nil ].	(self builder componentAt: #editButton) widget isEnabled: aBoolean.	(self builder componentAt: #removeButton) widget isEnabled: aBoolean.	(self builder componentAt: #setAsDefaultButton) widget isEnabled: aBoolean.</body><body package="NetConfigTool">postBuildWith: aBuilder	self enableButtons: false</body></methods><methods><class-id>Net.UserPage</class-id> <category>private</category><body package="NetConfigTool">detectUser: aString	| item |	item := self 			netUserMenu value menuItems detect: [ :it | (self userAsString: it value ) = aString ] 			ifNone: [ ^nil].	^item value</body><body package="NetConfigTool">removeMenuItemFor: aNetUser	|  item |	(item := self netUserMenu value menuItems detect: [ :itemx | itemx value = aNetUser ] ifNone: [ nil ] ) notNil		ifTrue: [	self netUserMenu value removeItem: item].</body><body package="NetConfigTool">setAsDefaultIdentity: aNetUser	self defaultUser: (aNetUser isNil		ifTrue: 			[ self netUserMenu value menuItems notEmpty 				ifTrue: [self netUserMenu value menuItems first value]				ifFalse: [nil]]		ifFalse: [ aNetUser ]).	self netUserMenu value menuItems do: 		[ :itemx |  itemx label: ( self userAsString: itemx value )  ].	self identityListAspect listHolder changed: #value.	manager tickle.</body><body package="NetConfigTool">updateIdentityListAspects	| selectIndex |	selectIndex := self identityListAspect selectionIndex.	self identityListAspect listHolder changed:#value.	self identityListAspect selectionIndex: selectIndex.</body><body package="NetConfigTool">updateIdentityValuesFrom: aNetUser	self fullNameIdentity value: aNetUser fullName.	self userNameIdentity value: 	aNetUser username.	self passwordIdentity value: 	aNetUser password.	self emailAddressIdentity value: aNetUser mailAddress.	self accountIdentity value: aNetUser account.	self verifyPasswordIdentity value: aNetUser password.</body><body package="NetConfigTool">updateNetUser: aNetUser	self removeMenuItemFor: self netUser.	(self detectUser:  (self userAsString: aNetUser)) ifNotNil: [ :existingUser | self removeMenuItemFor: existingUser].	netUser := aNetUser.	self defaultUser isNil ifTrue: [ self defaultUser: netUser].	self netUserMenu value		addItemLabel: ( self userAsString: netUser ) 		value: netUser.	self identityListAspect listHolder changed:#value.	manager tickle</body><body package="NetConfigTool">userAsString: aNetUser	| stream |	stream := String new writeStream.	aNetUser printNameOn: stream.	(self defaultUser notNil and: [ aNetUser fullName = self defaultUser fullName])			ifTrue: [ aNetUser printDefaultOn: stream ].	aNetUser printMailAddressOn: stream.		^stream contents</body></methods><methods><class-id>Net.UserPage</class-id> <category>initialize-release</category><body package="NetConfigTool">initialize	| usr |	super initialize. 	(usr := HttpSettings proxyHost) notNil		ifTrue: [usr := HttpSettings proxyHost netUser].	usr := (usr notNil		ifTrue: [ usr ]		ifFalse: [nil ]) asValue.	self  userPreferences 		at: #proxyUserMenuAspect		put: usr</body></methods><methods><class-id>Net.AddNetUser</class-id> <category>accessing</category><body package="NetConfigTool">parent	^parent isNil 		ifTrue: [ parent := UserPage new ]		ifFalse: [ parent ]</body><body package="NetConfigTool">parent: aUISettings	parent := aUISettings</body></methods><methods><class-id>Net.AddNetUser</class-id> <category>accessing settings</category><body package="NetConfigTool">netUser	^self parent netUser</body><body package="NetConfigTool">userPreferencesAt: aSymbol	^self  parent userPreferencesAt: aSymbol</body><body package="NetConfigTool">userPreferencesAt: aSymbol ifAbsentPut: aBlock	^self parent userPreferencesAt: aSymbol ifAbsentPut: aBlock</body><body package="NetConfigTool">userPreferencesAt: aSymbol put: anObject	self parent userPreferencesAt: aSymbol put: anObject</body></methods><methods><class-id>Net.AddNetUser</class-id> <category>aspects</category><body package="NetConfigTool">accountIdentity 	^accountIdentity ifNil: [ accountIdentity := self parent netUser account  asValue ]</body><body package="NetConfigTool">emailAddressIdentity  	^emailAddressIdentity ifNil: [ emailAddressIdentity := self parent netUser mailAddress asValue]</body><body package="NetConfigTool">fullNameIdentity  	^fullNameIdentity ifNil: [ fullNameIdentity := self parent netUser fullName asValue ]</body><body package="NetConfigTool">passwordIdentity  	^passwordIdentity ifNil: [ passwordIdentity := self parent netUser password asValue ]</body><body package="NetConfigTool">userNameIdentity 	^userNameIdentity ifNil: [ userNameIdentity := self parent netUser username asValue ]</body><body package="NetConfigTool">verifyPasswordIdentity	^verifyPasswordIdentity ifNil: [ verifyPasswordIdentity :=  self parent netUser password  asValue ].</body></methods><methods><class-id>Net.AddNetUser</class-id> <category>actions</category><body package="NetConfigTool">okToAddIdentity	(self passwordIdentity value = self verifyPasswordIdentity value) ifFalse: [ 		self passwordIdentity value: ''.		self verifyPasswordIdentity value: ''. 		^Dialog warn: (#NewPasswordWasNotCorrectlyConfirmed &lt;&lt; #net &gt;&gt; 'The new password was not correctly confirmed')].	((self fullNameIdentity value isNil or: [self fullNameIdentity value isEmpty])		or: [ self userNameIdentity value isNil or: [self userNameIdentity value isEmpty]])			ifTrue: [ ^Dialog warn: (#UserNameIsEmpty &lt;&lt; #net &gt;&gt; 'User name is empty') ].	self parent updateNetUser:		(NetUser new					fullName: self fullNameIdentity value;					username: self userNameIdentity value;					password: self passwordIdentity value;					mailAddress: self emailAddressIdentity value;					account: self accountIdentity value;					yourself).			self accept value: true</body></methods><methods><class-id>Net.AddNetUser class</class-id> <category>instance creation</category><body package="NetConfigTool">openWithSpec: aSpec parent: uiSettings	^self openOn: (self new parent: uiSettings)		 withSpec: aSpec.</body></methods><methods><class-id>Net.MailServerPage</class-id> <category>accessing</category><body package="NetConfigTool">defaultIncomingServer	^self userPreferencesAt: #defaultIncomingServer ifAbsentPut: [ nil ]</body><body package="NetConfigTool">defaultIncomingServer: aHostSpec	^self userPreferencesAt: #defaultIncomingServer put: aHostSpec</body><body package="NetConfigTool">defaultMailServerName	| serv | 	^((serv := self serverList) notEmpty 				ifTrue: [ serv first ]				ifFalse: [ '' ])</body><body package="NetConfigTool">defaultMailServerTypeMenuAspect	^self mailServerMenu value menuItems notEmpty 		ifTrue: [ self mailServerMenu value menuItems first value type]		ifFalse: 			[self registry supportedMailClients notEmpty				ifTrue: [self registry supportedMailClients first serverType ]				ifFalse: [(String new) ] ]</body><body package="NetConfigTool">defaultMailUserMenuAspect	^self mailServerMenu value menuItems notEmpty 			ifTrue: [ self mailServerMenu value menuItems first value netUser ]			ifFalse: [ nil  ]</body><body package="NetConfigTool">defaultOutgoingServer	^self userPreferencesAt: #defaultOutgoingServer ifAbsentPut: [ nil ]</body><body package="NetConfigTool">defaultOutgoingServer: aHostSpec	^self userPreferencesAt: #defaultOutgoingServer put: aHostSpec</body><body package="NetConfigTool">helpText	^(#ServerHelp &lt;&lt; #net &gt;&gt; 'You can specify several mail servers.  Typically you will have only a single outgoing mail server, but may have several incoming mail servers, if you receive mail from multiple mail services.To add a server, complete these fields and click Accept: - Name is the server''s fully qualified internet host name or IP address - Type is the server type, either POP3 (incoming), IMAP (incoming), or SMTP (outgoing) - User is a user ID already defined on the Identities page. To define a new user, click Add User... .  Complete the form as described in help for the Identities page.') asString</body><body package="NetConfigTool">hostSpec	^hostSpec</body><body package="NetConfigTool">hostSpec: aHostSpec	hostSpec := aHostSpec.	self updateHostValuesFrom: aHostSpec</body><body package="NetConfigTool">mailServerMenu	^self 		userPreferencesAt: #mailServerMenu  		ifAbsentPut: [self initializeFromRegistry asValue]</body><body package="NetConfigTool">mailServerName	^self userPreferencesAt: #mailServerName		ifAbsentPut: [ self defaultMailServerName asValue ]</body><body package="NetConfigTool">mailServerTypeMenu	| menu | 	menu := Menu new.	self registry supportedMailClients 		do: 	[ :each | 			menu			addItemLabel: ( each serverType, ' ', each description asString)			value: each serverType ].	^menu</body><body package="NetConfigTool">mailServerTypeMenuAspect	^self userPreferencesAt: #mailServerTypeMenuAspect		ifAbsentPut: [ self defaultMailServerTypeMenuAspect asValue ]</body><body package="NetConfigTool">mailUserMenuAspect	^self 		userPreferencesAt: #mailUserMenuAspect		ifAbsentPut: [ self defaultMailUserMenuAspect asValue ]</body><body package="NetConfigTool">netUserMenu 	^self userListOwner netUserMenu</body><body package="NetConfigTool">selectedServer	^self hostSpec</body><body package="NetConfigTool">selectedServer: aHostSpecString	self enableButtons: aHostSpecString notNil.	aHostSpecString notNil 		ifTrue: [ self hostSpec: (self detectServer: aHostSpecString string) ]</body><body package="NetConfigTool">serverList 	^self mailServerMenu value menuItems collect: [ :it | it label ]</body><body package="NetConfigTool">serverListAspect 	serverListAspect isNil		ifTrue: 			[serverListAspect := SelectionInList					adapt: self 					aspect: #selectedServer					list: #serverList					selection: #selectedServer:].	^serverListAspect</body></methods><methods><class-id>Net.MailServerPage</class-id> <category>actions</category><body package="NetConfigTool">accept	self registry resetServers.	self mailServerMenu value menuItems 		do: [ :itemx | self registry updateMailHost: itemx value].	self defaultIncomingServer notNil		ifTrue: [ self registry defaultIncomingHost: self defaultIncomingServer].	self defaultOutgoingServer notNil		ifTrue: [ self registry defaultOutgoingHost: self defaultOutgoingServer].</body><body package="NetConfigTool">addIdentity	self  userListOwner addIdentity</body><body package="NetConfigTool">disturb</body><body package="NetConfigTool">importSnapshots: aCollection	super importSnapshots: aCollection.	self userListOwner reset</body><body package="NetConfigTool">mailServerTypeMenuString: aType	^aType first, ' (', (aType at:2), ')'</body><body package="NetConfigTool">okToAddServer	( self mailServerName value isNil or: [self mailServerName value isEmpty])		ifTrue: [ ^Dialog warn: (#HostNameIsEmpty &lt;&lt; #net &gt;&gt; 'Host name is empty') ].	( self mailServerTypeMenuAspect value isNil or: [ self mailServerTypeMenuAspect value isEmpty])		ifTrue: [ ^Dialog warn: (#HostTypeIsEmpty &lt;&lt; #net &gt;&gt; 'Host type is empty') ].	hostSpec := HostSpec new						name: self mailServerName value;						type: self mailServerTypeMenuAspect value;						netUser: self mailUserMenuAspect value;						yourself.	self removeMenuItemFor: hostSpec.	(hostSpec isIncomingTypeMail and: [self defaultIncomingServer isNil])		ifTrue: [self defaultIncomingServer: hostSpec].	(hostSpec isOutgoingTypeMail and: [self defaultOutgoingServer isNil])		ifTrue: [self defaultOutgoingServer: hostSpec].	self mailServerMenu value		addItemLabel: ( self serverAsString: hostSpec ) 		value: hostSpec.		self updateMenuAspects.	manager tickle.</body><body package="NetConfigTool">removeServer	| it |	self removeMenuItemFor:  self hostSpec. 	self hostSpec  = self defaultIncomingServer 		ifTrue: 			[ (it := self mailServerMenu value menuItems 					detect: [ :itx | itx value isIncomingTypeMail ] 					ifNone: [nil]) notNil				ifTrue: 					[self defaultIncomingServer: it value.					it label: (self serverAsString: it value)]				ifFalse: [self defaultIncomingServer: nil]].	self hostSpec  = self defaultOutgoingServer 		ifTrue: 			[ (it := self mailServerMenu value menuItems 						detect: [ :itx | itx value isOutgoingTypeMail ] 						ifNone: [nil]) notNil				ifTrue: 					[self defaultOutgoingServer: it value.					it label: (self serverAsString: it value)]				ifFalse: [ self defaultOutgoingServer: nil ]].	self hostSpec: HostSpec new.	self serverListAspect listHolder changed:#value.</body><body package="NetConfigTool">reset	self resetUIStateToDefault</body><body package="NetConfigTool">resetUIStateToDefault	self mailServerMenu value: self initializeFromRegistry.	self serverListAspect listHolder changed:#value.	self mailServerName value: self defaultMailServerName.	self mailServerTypeMenuAspect value: self defaultMailServerTypeMenuAspect.	self mailUserMenuAspect value: self defaultMailUserMenuAspect.</body><body package="NetConfigTool">setServerAsDefault	self setAsDefaultServer: self hostSpec.</body></methods><methods><class-id>Net.MailServerPage</class-id> <category>private</category><body package="NetConfigTool">detectServer: aString	| item |	^(item := self 			mailServerMenu value menuItems detect: [ :it | (self serverAsString: it value ) = aString ] 			ifNone: [ nil]) isNil		ifTrue: [ HostSpec new ]		ifFalse: [ item value]</body><body package="NetConfigTool">initializeFromRegistry	| menu | 	menu := Menu new.	self defaultIncomingServer: self registry defaultIncomingHost.	self defaultOutgoingServer: self registry defaultOutgoingHost.	self registry mailServers copy		do: 	[ :each |			menu			addItemLabel: (self serverAsString: each)			value: each  ].	^menu</body><body package="NetConfigTool">removeMenuItemFor: aSpecHost	|  item |	item := self mailServerMenu value menuItems 				detect: [ :itemx | itemx value isSameAs: aSpecHost ] 				ifNone: [ ^nil ].	self mailServerMenu value removeItem: item.	self serverListAspect listHolder changed:#value.	manager tickle</body><body package="NetConfigTool">serverAsString: aHostSpec	| stream |	stream := String new writeStream.	stream nextPutAll: aHostSpec name.	((self defaultIncomingServer notNil and: [ aHostSpec isSameAs: self defaultIncomingServer  ])		or: [self defaultOutgoingServer notNil 	and: [aHostSpec  isSameAs: self defaultOutgoingServer ]])		ifTrue: [ aHostSpec printDefaultDescriptionOn: stream ]		ifFalse: [ aHostSpec printDescriptionOn: stream ].	^stream contents</body><body package="NetConfigTool">setAsDefaultServer: aHostSpec	| host |	host :=  (aHostSpec isNil		ifTrue: 			[ self mailServerMenu value menuItems notEmpty 				ifTrue: [self mailServerMenu menuItems first value]				ifFalse: [nil]]		ifFalse: [ aHostSpec ]).	host isNil ifTrue: [ ^nil ].	host isIncomingTypeMail		ifTrue: [ self defaultIncomingServer: host]		ifFalse: [ self defaultOutgoingServer: host].	self mailServerMenu value menuItems do: 		[ :itemx |  itemx label: ( self serverAsString: itemx value )  ].	self updateMenuAspects.	manager tickle.</body><body package="NetConfigTool">updateHostValuesFrom: aHostSpec	self mailServerName value: aHostSpec name.	self mailUserMenuAspect value:  aHostSpec netUser.	self mailServerTypeMenuAspect value:  aHostSpec type.</body><body package="NetConfigTool">updateMenuAspects	| selectIndex |	selectIndex := self serverListAspect selectionIndex.	self serverListAspect listHolder changed:#value. 	selectIndex notNil		ifTrue: [ self serverListAspect selectionIndex: selectIndex ]</body></methods><methods><class-id>Net.MailServerPage</class-id> <category>interface opening</category><body package="NetConfigTool">enableButtons	(self builder componentAt: #addButton) widget isEnabled: self mailServerName value notNil.</body><body package="NetConfigTool">enableButtons: aBoolean	self builder isNil ifTrue: [^nil].	#( removeButton setAsDefaultButton )		do: [ :each | (self widgetAt: each) isEnabled: aBoolean ].</body><body package="NetConfigTool">postBuildWith: aBuilder	self serverList notEmpty ifTrue: [self serverListAspect 	selectionIndex: 1 ].	self mailServerName onChangeSend: #enableButtons to: self.</body></methods><methods><class-id>Net.HttpProxyExceptions</class-id> <category>aspects</category><body package="NetConfigTool">domainCollectionAsString	| aStream col |	col :=  parent proxyExceptions.	^col isEmpty		ifTrue: [String new]		ifFalse: 			[aStream := (String new: 64) writeStream.			col				do: [:element | aStream nextPutAll: element]				separatedBy: [aStream nextPut: $;].			aStream contents]</body><body package="NetConfigTool">httpProxyExceptions	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^httpProxyExceptions isNil		ifTrue:			[httpProxyExceptions := self domainCollectionAsString asValue]		ifFalse:			[httpProxyExceptions]</body><body package="NetConfigTool">parent: aHttpPage	parent := aHttpPage</body></methods><methods><class-id>Net.HttpProxyExceptions</class-id> <category>actions</category><body package="NetConfigTool">acceptHttpExceptions	| proxyExceptions sc token |	proxyExceptions := OrderedCollection new: 10. 	sc := self httpProxyExceptions value string readStream.	[ sc atEnd ]		whileFalse: 			[token := sc upTo: $;. 			token notEmpty ifTrue: [ proxyExceptions add: token trimBlanks]].	parent acceptProxyExceptions: proxyExceptions.	self cancelHttpException.</body><body package="NetConfigTool">cancelHttpException	^self closeRequest</body></methods><methods><class-id>Net.NetRef class</class-id> <category>persistence</category><body package="NetConfigTool">restoreValueFrom: anXMLElement	^NetSettings restoreRefFrom: anXMLElement</body></methods><methods><class-id>Core.String class</class-id> <category>net clients</category><body package="NetConfigTool">restoreValueFrom: anXMLElement	| els |	^(els := anXMLElement elements) isEmpty		ifTrue: [self new]		ifFalse: [ els first text ]</body></methods><methods><class-id>Core.String</class-id> <category>net clients</category><body package="NetConfigTool">asXmlNode: aString	| node |	node := XML.Element tag: aString.	node attributes: (OrderedCollection with: ( XML.Attribute name: 'smalltalkClass' value: 'String' )).	node addNode: (XML.Text text: self ).	^node</body></methods><methods><class-id>Core.Dictionary class</class-id> <category>net clients</category><body package="NetConfigTool">restoreValueFrom: anXMLElement	| xmlColl dict key value |	xmlColl := anXMLElement realElements.	dict := self new: xmlColl size.	xmlColl do: 			[ :el |			key := el realElements first restoreValue.			value := el realElements last restoreValue.			dict at:  key put: value ].	^dict</body></methods><methods><class-id>Core.Dictionary</class-id> <category>net clients</category><body package="NetConfigTool">asXmlNode: aString	^Net.NetSettings dictionary: self  asXmlNode: aString</body></methods><methods><class-id>XML.Text</class-id> <category>net clients</category><body package="NetConfigTool">restoreValue</body><body package="NetConfigTool">restoreValueFor: aClass	^aClass readFrom: self text</body></methods><methods><class-id>Core.Collection class</class-id> <category>net clients</category><body package="NetConfigTool">restoreValueFrom: anXMLElement	| coll xmlColl |	xmlColl := anXMLElement realElements.	coll := self new: xmlColl size.	xmlColl do: 			[ :el |			coll add: el restoreValue ].	^coll</body></methods><methods><class-id>Core.Collection</class-id> <category>net clients</category><body package="NetConfigTool">asXmlNode: aString	^Net.NetSettings collection: self  asXmlNode: aString</body></methods><methods><class-id>Net.CookieAgent class</class-id> <category>persistence</category><body package="NetConfigTool">restoreRegistryFrom: aDataSource	| xml |	xml := (XML.XMLParser on:  aDataSource)				validate: false;				scanDocument.	Registry := (Dictionary restoreValueFrom: xml root)</body><body package="NetConfigTool">storeRegistryTo: aStream	aStream nextPutAll: '&lt;?xml version="1.0"?&gt;'.	(self registry asXmlNode: 'CookieRegistry' ) printOn: aStream.</body></methods><methods><class-id>Net.NetUser class</class-id> <category>persistance</category><body package="NetConfigTool">restoreValueFrom: xmlColl	^NetSettings restoreNetObject: self new from:  xmlColl</body></methods><methods><class-id>Net.NetUser</class-id> <category>persistence</category><body package="NetConfigTool">asXmlNode: aString 	^NetSettings netObject: self asXmlNode: aString</body></methods><methods><class-id>XML.Element</class-id> <category>net clients</category><body package="NetConfigTool">restoreValue	^Net.NetSettings restoreValueFrom: self</body></methods><methods><class-id>Net.HostSpec class</class-id> <category>persistance</category><body package="NetConfigTool">restoreValueFrom: xmlColl	^NetSettings restoreNetObject: self new from:  xmlColl</body></methods><methods><class-id>Net.HostSpec</class-id> <category>persistence</category><body package="NetConfigTool">asXmlNode: aString 	^NetSettings netObject: self asXmlNode: aString</body><body package="NetConfigTool">isSecure: aBoolean	isSecure := aBoolean</body></methods><methods><class-id>Core.Object class</class-id> <category>net clients</category><body package="NetConfigTool">restoreValueFrom: anXMLElement	^self readFrom: anXMLElement elements first text readStream</body></methods><methods><class-id>Core.Object</class-id> <category>net clients</category><body package="NetConfigTool">asXmlNode: aString	^Net.NetSettings object: self asXmlNode: aString</body></methods><methods><class-id>Net.NetClient class</class-id> <category>persistance</category><body package="NetConfigTool">restoreValueFrom: xmlColl	^NetSettings restoreNetObject: self new from:  xmlColl</body></methods><methods><class-id>Net.NetClient</class-id> <category>persistence</category><body package="NetConfigTool">asXmlNode: aString 	^NetSettings netObject: self asXmlNode: aString</body></methods><methods><class-id>Core.Symbol class</class-id> <category>net clients</category><body package="NetConfigTool">restoreValueFrom: anXMLElement	^self readFrom: anXMLElement elements first text readStream</body></methods><methods><class-id>Core.Symbol</class-id> <category>net clients</category><body package="NetConfigTool">asXmlNode: aString	| node |	node := XML.Element tag: aString.	node attributes: (OrderedCollection with: ( XML.Attribute name: 'smalltalkClass' value: 'Symbol' )).	node addNode: (XML.Text text: '#''', self, '''' ).	^node</body></methods><methods><class-id>Net.HttpProxyPage class</class-id> <category>interface specs</category><body package="NetConfigTool">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #HTTPSettings 				#defaultString: 'HTTP Settings' 				#catalogID: #net ) 			#min: #(#{Core.Point} 363 311 ) 			#max: #(#{Core.Point} 363 311 ) 			#bounds: #(#{Graphics.Rectangle} 720 450 1083 761 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 135 0 65 0 -10 1 90 0 ) 					#name: #proxyAddress 					#model: #httpHost ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 135 0 100 0 -10 1 125 0 ) 					#name: #proxyPort 					#model: #httpPort 					#type: #number ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 135 0 135 0 -10 1 160 0 ) 					#name: #proxyUserMenuAspect 					#model: #proxyUserMenuAspect 					#menu: #netUserMenu ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -175 1 180 0 -95 1 205 0 ) 					#name: #addIdentityButton 					#model: #addIdentity 					#label: 					#(#{Kernel.UserMessage} 						#key: #AddUser 						#defaultString: 'Add User...' 						#catalogID: #net ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -90 1 180 0 -10 1 205 0 ) 					#name: #advancedButton 					#model: #httpAdvanced 					#label: 					#(#{Kernel.UserMessage} 						#key: #Advandec 						#defaultString: 'Advanced...' 						#catalogID: #webservices ) 					#defaultable: true ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Graphics.Rectangle} 10 20 100 37 ) 					#model: #httpUseProxy 					#label: 					#(#{Kernel.UserMessage} 						#key: #UseProxy 						#defaultString: 'Use proxy' 						#catalogID: #net ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.Rectangle} 10 65 65 90 ) 					#name: #addressLabel 					#label: 					#(#{Kernel.UserMessage} 						#key: #Address 						#defaultString: 'Address:' 						#catalogID: #net ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.Rectangle} 10 100 60 125 ) 					#name: #portLabel 					#label: 					#(#{Kernel.UserMessage} 						#key: #Port 						#defaultString: 'Port:' 						#catalogID: #net ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.Rectangle} 10 135 90 160 ) 					#name: #proxyUserLabel 					#label: 					#(#{Kernel.UserMessage} 						#key: #ProxyUser 						#defaultString: 'Proxy user:' 						#catalogID: #net ) ) ) ) )</body></methods><methods><class-id>Net.UserPage class</class-id> <category>interface specs</category><body package="NetConfigTool">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #Identity 				#defaultString: 'Identity' 				#catalogID: #net ) 			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 748 365 1172 676 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 25 0 -100 1 0 1 ) 					#model: #identityListAspect 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -90 1 25 0 0 1 50 0 ) 					#model: #addIdentity 					#label: 					#(#{Kernel.UserMessage} 						#key: #Add 						#defaultString: 'Add...' 						#catalogID: #net ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -90 1 50 0 0 1 75 0 ) 					#name: #editButton 					#model: #editIdentity 					#label: 					#(#{Kernel.UserMessage} 						#key: #Edit 						#defaultString: 'Edit...' 						#catalogID: #net ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -90 1 75 0 0 1 100 0 ) 					#name: #removeButton 					#model: #removeIdentity 					#label: 					#(#{Kernel.UserMessage} 						#key: #Remove 						#defaultString: 'Remove' 						#catalogID: #net ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -90 1 100 0 0 1 125 0 ) 					#name: #setAsDefaultButton 					#model: #setAsDefaultIdentity 					#label: 					#(#{Kernel.UserMessage} 						#key: #SetAsDefault 						#defaultString: 'Set As Default' 						#catalogID: #net ) 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 0 0 ) 					#name: #Label1 					#label: 					#(#{Kernel.UserMessage} 						#key: #UserIdentitiesC 						#defaultString: 'User Identities:' 						#catalogID: #net ) ) ) ) )</body></methods><methods><class-id>Net.AddNetUser class</class-id> <category>interface specs</category><body package="NetConfigTool">addIdentitySpec	"Tools.UIPainter new openOnClass: self andSelector: #addIdentitySpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #AddIdentity 				#defaultString: 'Add Identity' 				#catalogID: #net ) 			#min: #(#{Core.Point} 371 290 ) 			#max: #(#{Core.Point} 371 290 ) 			#bounds: #(#{Graphics.Rectangle} 801 498 1172 788 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 36 194 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #Enter 						#defaultString: 'Enter:' 						#catalogID: #net ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 36 223 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #Confirm 						#defaultString: 'Confirm:' 						#catalogID: #net ) ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.Rectangle} 10 154 281 269 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #Password 						#defaultString: 'Password' 						#catalogID: #net ) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 115 10 270 35 ) 					#model: #fullNameIdentity ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 115 66 270 91 ) 					#model: #emailAddressIdentity 					#isReadOnly: false ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 115 93 270 118 ) 					#model: #accountIdentity ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 130 193 270 218 ) 					#model: #passwordIdentity 					#type: #password ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 129 220 270 245 ) 					#model: #verifyPasswordIdentity 					#type: #password ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 290 10 360 35 ) 					#model: #okToAddIdentity 					#label: 					#(#{Kernel.UserMessage} 						#key: #OK 						#defaultString: 'OK' 						#catalogID: #net ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 290 36 360 61 ) 					#model: #cancel 					#label: 					#(#{Kernel.UserMessage} 						#key: #Cancel 						#defaultString: 'Cancel' 						#catalogID: #net ) 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 115 39 270 64 ) 					#model: #userNameIdentity 					#type: #string ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.Rectangle} 10 15 105 30 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #FullName 						#defaultString: 'Full name:' 						#catalogID: #net ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.Rectangle} 10 44 105 63 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #UserNameC 						#defaultString: 'User Name:' 						#catalogID: #net ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.Rectangle} 10 72 105 97 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #EmailAddress 						#defaultString: 'Email address:' 						#catalogID: #net ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.Rectangle} 10 100 105 125 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #Account 						#defaultString: 'Account:' 						#catalogID: #net ) ) ) ) )</body></methods><methods><class-id>Net.MailServerPage class</class-id> <category>interface specs</category><body package="NetConfigTool">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #MailServerList 				#defaultString: 'Mail Server List' 				#catalogID: #net ) 			#min: #(#{Core.Point} 383 350 ) 			#max: #(#{Core.Point} 383 350 ) 			#bounds: #(#{Graphics.Rectangle} 720 450 1103 800 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 0.5 ) 					#model: #serverListAspect 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 5 0.5 -100 1 120 0.5 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #Host 						#defaultString: 'Host' 						#catalogID: #net ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 50 0.5 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #Name 						#defaultString: 'Name:' 						#catalogID: #net ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 110 0.5 0 1 ) 					#name: #user 					#label: 					#(#{Kernel.UserMessage} 						#key: #User 						#defaultString: 'User:' 						#catalogID: #net ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 80 0.5 0 1 ) 					#name: #serverType 					#label: 					#(#{Kernel.UserMessage} 						#key: #Type 						#defaultString: 'Type:' 						#catalogID: #net ) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 100 0 25 0.5 -110 1 50 0.5 ) 					#name: #mailServerName 					#model: #mailServerName 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #disturb ) 					#type: #string ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 100 0 55 0.5 -110 1 80 0.5 ) 					#model: #mailServerTypeMenuAspect 					#menu: #mailServerTypeMenu ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 100 0 85 0.5 -110 1 110 0.5 ) 					#model: #mailUserMenuAspect 					#menu: #netUserMenu ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -92 1 15 0.5 0 0.994778 40 0.5 ) 					#name: #addButton 					#model: #okToAddServer 					#label: 					#(#{Kernel.UserMessage} 						#key: #AddNoDots 						#defaultString: 'Add' 						#catalogID: #net ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -92 1 40 0.5 0 0.994778 65 0.5 ) 					#name: #removeButton 					#model: #removeServer 					#label: 					#(#{Kernel.UserMessage} 						#key: #Remove 						#defaultString: 'Remove' 						#catalogID: #net ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -92 1 65 0.5 0 0.994778 90 0.5 ) 					#name: #setAsDefaultButton 					#model: #setServerAsDefault 					#label: 					#(#{Kernel.UserMessage} 						#key: #SetAsDefault 						#defaultString: 'Set As Default' 						#catalogID: #net ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -92 1 90 0.5 0 0.994778 115 0.5 ) 					#model: #addIdentity 					#label: 					#(#{Kernel.UserMessage} 						#key: #AddUser 						#defaultString: 'Add User...' 						#catalogID: #net ) 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Net.HttpProxyExceptions class</class-id> <category>interface specs</category><body package="NetConfigTool">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #HTTPProxyExceptions 				#defaultString: 'HTTP Proxy  Exceptions' 				#catalogID: #net ) 			#min: #(#{Core.Point} 497 239 ) 			#max: #(#{Core.Point} 497 239 ) 			#bounds: #(#{Graphics.Rectangle} 723 447 1220 686 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -90 1 200 0 -10 1 225 0 ) 					#name: 'ActionButton1' 					#model: #cancelHttpException 					#label: 					#(#{Kernel.UserMessage} 						#key: #Cancel 						#defaultString: 'Cancel' 						#catalogID: #net ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -175 1 200 0 -95 1 225 0 ) 					#name: 'ActionButton2' 					#model: #acceptHttpExceptions 					#label: 					#(#{Kernel.UserMessage} 						#key: #OK 						#defaultString: 'OK' 						#catalogID: #net ) 					#defaultable: true ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 15 0 45 0 -10 1 -100 1 ) 					#name: 'TextEditor1' 					#model: #httpProxyExceptions 					#tabRequiresControl: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutFrame} 15 0 10 0 -10 1 30 0 ) 					#name: 'Label1' 					#label: 					#(#{Kernel.UserMessage} 						#key: #DoNotUseProxyServersForDomains 						#defaultString: 'Do not use proxy servers for domains beginning with:' 						#catalogID: #net ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutFrame} 15 0 155 0 -10 1 180 0 ) 					#name: 'Label2' 					#label: 					#(#{Kernel.UserMessage} 						#key: #UseSemicolonSeparateDomains 						#defaultString: 'Use semicolon (;) to separate domains.' 						#catalogID: #net ) ) ) ) )</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-http-cookie</category><body package="NetConfigTool">c02EnableCookieProcessing	&lt;setting: #(net http httpCookie enableCookieProcessing )&gt;	| class |	#{Net.HttpSettings} ifDefinedDo: [ :val | class := val ] elseDo: [^nil].	^(BooleanSetting on: class aspect: #enableCookieProcessing)		label: #HttpEnableCookieProcessing&lt;&lt; #net &gt;&gt; 'Enable cookie processing';		default: Net.HttpSettings enableCookieProcessingDefault;		helpText: #HttpEnableCookieProcessingHelpText &lt;&lt; #net &gt;&gt; 'Specifies whether to process Http cookies.';		yourself</body><body package="NetConfigTool">c1CacheCookies	&lt;setting: #(net http httpCookie cacheCookies )&gt;	| class |	#{Net.CookieAgent } ifDefinedDo: [ :val | class := val ] elseDo: [^nil].	^(BooleanSetting on: class aspect: #cacheCookies)		label: #HttpCacheCookies&lt;&lt; #net &gt;&gt; 'Enable cookie caching';		default: class defaultCacheCookies;		helpText: #HttpCacheCookiesHelpText &lt;&lt; #net &gt;&gt; 'Specifies whether to cache Http cookies when a session is terminated.';		yourself</body><body package="NetConfigTool">c2UseCachedCookies	&lt;setting: #(net http httpCookie useCachedCookies )&gt;	| class |	#{Net.CookieAgent }  ifDefinedDo: [ :val | class := val ] elseDo: [^nil].	^(BooleanSetting on: class aspect: #useCachedCookies)		label: #HttpUseCachedCookies&lt;&lt; #net &gt;&gt; 'Use cached cookies';		default: class defaultUseCachedCookies;		helpText: #HttpUseCachedCookiesHelpText &lt;&lt; #net &gt;&gt; 'Specifies whether to use already cached cookies for each session.';		yourself</body><body package="NetConfigTool">c3EnableLimits	&lt;setting: #(net http httpCookie enableLimits )&gt;	| class |	#{Net.CookieAgent} ifDefinedDo: [:val | class := val] elseDo: [^nil].	^(BooleanSetting on: class aspect: #enableLimits)		label: #HttpEnableLimits &lt;&lt; #net &gt;&gt; 'Enable cookie processing limits';		default: class defaultEnableLimits;		helpText: #HttpEnableLimitsHelpText &lt;&lt; #net &gt;&gt; 'Enables enforcement of cookie registry limits.';		yourself</body><body package="NetConfigTool">c4NumberRegistryEntries	&lt;setting: #(net http  httpCookie numberRegistryEntries )&gt;	| class |	#{Net.CookieAgent }  ifDefinedDo: [ :val | class := val ] elseDo: [^nil].	^(NumberSetting on: class aspect: #numberEntries)		label: #HttpNumberEntries&lt;&lt; #net &gt;&gt; 'Total number of cookies';		default: class defaultNumberEntries;		helpText: #HttpNumberEntriesHelpText &lt;&lt; #net &gt;&gt; 'Specifies the maximum number of cookies stored in the registry.';		yourself</body><body package="NetConfigTool">c5NumberEntriesPerServer	&lt;setting: #(net  http httpCookie numberEntriesPerServer )&gt;	| class |	#{Net.CookieAgent }  ifDefinedDo: [ :val | class := val ] elseDo: [^nil].	^(NumberSetting on: class aspect: #numberEntriesPerServer)		label: #HttpNumberEntriesPerServer&lt;&lt; #net &gt;&gt; 'Max cookies per host';		default: class defaultNumberEntriesPerServer;		helpText: #HttpNumberEntriesPerServerHelpText &lt;&lt; #net &gt;&gt; 'Specifies the maximum number of cookies per unique host stored in the registry.';		yourself</body><body package="NetConfigTool">c6NumberBytesPerCookie	&lt;setting: #(net http httpCookie numberBytesPerCookie )&gt;	| class |	#{Net.CookieAgent} ifDefinedDo: [:val | class := val] elseDo: [^nil].	^(NumberSetting on: class aspect: #numberBytesPerCookie)		label: #HttpNumberBytesPerCookie &lt;&lt; #net &gt;&gt; 'Max bytes per cookie';		default: class defaultNumberBytesPerCookie;		helpText: #HttpNumberBytesPerCookieHelpText &lt;&lt; #net &gt;&gt; 'Specifies the maximum size of cookies in bytes.';		yourself</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-ftp</category><body package="NetConfigTool">ftp1AnonymousLoginPassword	&lt;setting: #(net ftp anonymousLoginPassword)&gt;	| class |	#{Net.FTPSettings }  ifDefinedDo: [ :val | class := val ] elseDo: [^nil].	^(StringSetting on: Net.FTPSettings aspect: #anonymousLoginPassword )		default: String new;		label: #AnonymousLoginPassword &lt;&lt; #net &gt;&gt; 'Anonymous login password';		helpText: #AnonymousLoginPasswordHelpText &lt;&lt; #net &gt;&gt; 'Specifies the email address to be used as the password for anonymous FTP connections.  Anonymous FTP sites typically accept "anonymous" as the user name and an email address as the password.';		yourself</body><body package="NetConfigTool">ftp2UsePassiveMode	&lt;setting: #(net ftp usePassiveMode)&gt;	| class |	#{Net.FTPSettings }  ifDefinedDo: [ :val | class := val ] elseDo: [^nil].	^(BooleanSetting on: Net.FTPSettings aspect: #passiveMode )		default: Net.FTPSettings  passiveModeDefault;		label: #UsePassiveMode &lt;&lt; #net &gt;&gt; 'Use passive mode';		helpText: #UsePassiveModeHelpText &lt;&lt; #net &gt;&gt; 'If checked, it causes the server to use passive mode for transactions. This means that the server listens for the client to make the connection instead of initiating it. This is often necessary for clients located behind a firewall.';		yourself</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>pages</category><body package="NetConfigTool">ftpPage	&lt;settingsPage: #(net ftp)&gt;	#{Net.FTPClient} isDefined ifFalse: [ ^nil]. 	^ModularSettingsPage new		label: #FTP &lt;&lt; #labels &gt;&gt; 'FTP';		icon: (ListIconLibrary visualFor: #net);		settings: (self settingsWithPrefix: #(net ftp ));		yourself</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-http</category><body package="NetConfigTool">http1UsePersistentConnection	&lt;setting: #(net http #connectionPersists) position: 70&gt;	| class |	#{Net.HttpSettings}  ifDefinedDo: [ :val | class := val ] elseDo: [^nil].	^(BooleanSetting on: class aspect: #connectionPersists )		label: #keepAliveConnection &lt;&lt; #net &gt;&gt; 'Use persistent connections';		default: class connectionPersistsDefault;		helpText: #usePersistentConnectionHelpText &lt;&lt; #net &gt;&gt; 'Persistent connection allows the client to reuse the same connection for several requests. Non-persistent connections close after each request. This setting controls the Connection: header field.';		yourself</body><body package="NetConfigTool">http2Redirect	&lt;setting: #(net http redirect) position: 60&gt;	| class |	#{Net.HttpSettings}  ifDefinedDo: [ :val | class := val ] elseDo: [^nil].	^(BooleanSetting on: class aspect: #redirectRequest )		label: #redirectRequest &lt;&lt; #net &gt;&gt; 'Automatically redirect requests';		default: class redirectRequestDefault;		helpText: #redirectHelpText &lt;&lt; #net &gt;&gt; 'This settings controls handling of the HttpMovedError (301 and 302 response status codes) . There are a few scenarios:	a. An application does not have http error handling - in this case the http client uses its default error handling for the HttpMovedError and sends a new request to the new location specified in the server reply.	b. An application has http error handling and this option is unchecked - the http client passes the HttpMovedError exception to the application.	c. An application has http error handling and this option is checked - the http clients uses its default error handling for the HttpMovedError exception.';		yourself</body><body package="NetConfigTool">http3NTLMDomain	&lt;setting: #(net http #ntlmDomain) position: 50&gt;	| class |	#{Net.HttpSettings}  ifDefinedDo: [ :val | class := val ] elseDo: [^nil].	^(StringSetting on: class aspect: #domain )		label: #ntlmDomain &lt;&lt; #net &gt;&gt; 'NTLM Domain';		default: class domainDefault;		helpText: #ntlmDomainHelpText &lt;&lt; #net &gt;&gt; 'The name of the default NTLM domain for NTLM authentication. User credentials being authenticated must belong to users from this domain. Correct domain name must be specified otherwise NTLM authentication will fail. The default value will be taken from a system evironment variable ''USERDOMAIN'', if it is present.';		yourself</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>pages</category><body package="NetConfigTool">httpCookiePage	&lt;settingsPage: #(net http httpCookie)&gt;	#{Net.CookieAgent} isDefined ifFalse: [^nil].	^(ModularSettingsPage new)		label: #HTTPCookies &lt;&lt; #net &gt;&gt; 'Cookies';		icon: (ListIconLibrary visualFor: #net);		settings: (self settingsWithPrefix: #(#net http #httpCookie));		yourself</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-http</category><body package="NetConfigTool">httpDefaultTimeout	&lt;setting: #(net http defaultTimeout ) position: 10&gt;	| class |	#{Net.HttpSettings}  ifDefinedDo: [ :val | class := val ] elseDo: [^nil].	^(NumberSetting on: class aspect: #defaultTimeout)		label: #DefaultTimeout&lt;&lt; #net &gt;&gt; 'Default timeout (ms)';		default: class defaultTimeoutValue;		helpText: #NetDefaultTimeoutHelpText &lt;&lt; #net &gt;&gt; 'This is the number of milliseconds to wait for an issued command to complete before signaling an error.';		yourself</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>pages</category><body package="NetConfigTool">httpMessageParsingPage	&lt;settingsPage: #(net http messageParsing)&gt;	#{Net.HttpBuildHandler} isDefined ifFalse: [ ^nil]. 	^ModularSettingsPage new		label: #MessageParsing &lt;&lt; #labels &gt;&gt; 'Message Parsing';		icon: (ListIconLibrary visualFor: #net);		settings: (self settingsWithPrefix: #(net http messageParsing));		yourself</body><body package="NetConfigTool">httpMessageWritingPage	&lt;settingsPage: #(net http messageWriting)&gt;	#{Net.HttpWriteHandler} isDefined ifFalse: [ ^nil]. 	^ModularSettingsPage new		label: #MessageWriting &lt;&lt; #labels &gt;&gt; 'Message Writing';		icon: (ListIconLibrary visualFor: #net);		settings: (self settingsWithPrefix: #(net http messageWriting));		yourself</body><body package="NetConfigTool">httpPage	&lt;settingsPage: #(net http)&gt;	#{Net.HttpClient} isDefined ifFalse: [ ^nil]. 	^ModularSettingsPage new		label: #HttpSettings &lt;&lt; #labels &gt;&gt; 'HTTP';		icon: (ListIconLibrary visualFor: #net);		settings: (self settingsWithPrefix: #(net http ));		yourself</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-http-parsing</category><body package="NetConfigTool">httpParse1DecodeContent	&lt;setting: #(net http messageParsing decodeContent)&gt;	| class |	#{Net.HttpBuildHandler }  ifDefinedDo: [ :val | class := val ] elseDo: [^nil].	^(BooleanSetting on: class aspect: #decodeContents )		label: #decodeContents &lt;&lt; #net &gt;&gt; 'Decode messages (content-type encoding)';		default: class decodeContentsValue;		helpText: #decodeContentHelpText &lt;&lt; #net &gt;&gt; 'Specifies whether to decode http message bodies into text using the charset specificied by the content-type header field. If this settings is turned off the body contents will contain raw bytes.';		yourself</body><body package="NetConfigTool">httpParse2RemoveContentEncoding	&lt;setting: #(net http messageParsing removeContentEncoding)&gt;	| class |	#{Net.HttpBuildHandler }  ifDefinedDo: [ :val | class := val ] elseDo: [^nil].	^(BooleanSetting on: class aspect: #decompressContents )		label: #decompressContents &lt;&lt; #net &gt;&gt; 'Decompress messages (content-encoding gzip)';		default: class defaultDecompressContents;		helpText: #removeContentEncodingHelpText &lt;&lt; #net &gt;&gt; 'Specifies whether to decompress http message body if it has the "content-encoding: gzip" header field. If this setting is turned off the body will contain raw compressed bytes (if it is compressed)';		yourself</body><body package="NetConfigTool">httpParse3SaveAttachmentAsFile	&lt;setting: #(net http messageParsing saveAttachmentAsFile)&gt;	| class |	#{Net.HttpBuildHandler }  ifDefinedDo: [ :val | class := val ] elseDo: [^nil].	^(BooleanSetting on: class aspect: #saveAttachmentsAsFiles )		label: #SaveAttachmentAsFileValue &lt;&lt; #net &gt;&gt; 'Save attachments as files';		default: class saveAttachmentsAsFilesValue;		helpText: #saveAttachmentAsFileValueHelpText &lt;&lt; #net &gt;&gt; 'Specifies whether to save attachments into files. This settings allows to process large attachments more efficiently. If this settings is turned off attachments will be reconstructed entirely in memory.';		yourself</body><body package="NetConfigTool">httpParse4UploadDirectory	&lt;setting: #(net http messageParsing uploadDirectory)&gt;	| class |	#{Net.HttpBuildHandler }  ifDefinedDo: [ :val | class := val ] elseDo: [^nil].	^(StringSetting on: class aspect: #defaultAttachmentDirectoryString )		label: #defaultAttachmentDirectory &lt;&lt; #net &gt;&gt; 'Save attachments in';		default: class defaultAttachmentDirectoryValue;		helpText: #defaultUploadDirectoryHelpText &lt;&lt; #net &gt;&gt; 'This setting specifies the directory that will be used to save file attachments.';		yourself</body><body package="NetConfigTool">httpParse5ParameterValueEncoding	&lt;setting: #(net http messageParsing parameterValueEncoding)&gt;	| class |	#{Net.HttpBuildHandler }  ifDefinedDo: [ :val | class := val ] elseDo: [^nil].	^(StringSetting on: Net.ValueWithParams aspect: #defaultParameterValueEncoding )		label: #defaultParameterValueEncoding &lt;&lt; #net &gt;&gt; 'Decode header parameters with:';		default: Net.ValueWithParams defaultParameterValueEncodingValue;		helpText: #defaultParameterValueEncodingHelpText &lt;&lt; #net &gt;&gt; 'If set, the specified encoding will be applied if we encounter non-ascii characters in header field parameter values (technically this is against the MIME specification, but seems to be a widespread practice, e.g. many web browsers do that with filenames of uploaded files)';		yourself</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>pages</category><body package="NetConfigTool">httpProxyPage	&lt;settingsPage: #(net http httpProxy)&gt;	#{Net.HttpClient} isDefined ifFalse: [ ^nil]. 	^Net.HttpProxyPage new		label: #HttpProxyServer &lt;&lt; #labels &gt;&gt; 'Proxy Server';		icon: (ListIconLibrary visualFor: #net);		yourself</body><body package="NetConfigTool">httpServersCacheCookiesFrom	&lt;settingsPage: #(net http httpCookie serversCacheCookiesFrom)&gt;	| class |	#{Net.CookieAgent} ifDefinedDo: [:val | class := val] elseDo: [^nil].	^(SequenceSettingPage new)		label: #CookieServers &lt;&lt; #labels &gt;&gt; 'Cookie Servers';		icon: (ListIconLibrary visualFor: #net);		listHolder: class serversCacheCookiesFrom asValue displayBlock: [:value | value] acceptBlock: [:value | value];		helpText: #HttpServersCacheCookiesFromHelpText &lt;&lt; #net &gt;&gt; 'Specifies list of servers to cache cookies from. Empty list means to store cookies from all servers';		yourself</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-http-writing</category><body package="NetConfigTool">httpWrite1ChunkSize	&lt;setting: #(net http messageWriting chunkSize)&gt;	| class |	#{Net.ChunkedWriteStream }  ifDefinedDo: [ :val | class := val ] elseDo: [^nil].	^(NumberSetting on: class aspect: #defaultWriteLimit)		label: #HttpChunkSize&lt;&lt; #net &gt;&gt; 'Default chunk size';		default: class defaultWriteLimitValue;		helpText: #HttpChunkSizeHelpText &lt;&lt; #net &gt;&gt; 'If an http message body shorter than the specified chunk size it it will be sent as it is and the message header will include the content-length header field with corresponding byte size value. If the body is longer than that the body will be written out in chunked format and the header will include transfer-encoding field with value ''chunked'' instead of the content-length field.';		yourself</body><body package="NetConfigTool">httpWrite2UseGZipTransfer	&lt;setting: #(net http messageWriting useGZipTransfer)&gt;	| class |	#{Net.HttpWriteHandler}  ifDefinedDo: [ :val | class := val ] elseDo: [^nil].	^(BooleanSetting on: class aspect: #useGZipTransfer)		label: #UseGZipTransfer&lt;&lt; #net &gt;&gt; 'Compress messages (transfer-encoding: gzip)';		default: class useGZipTransferValue;		helpText: #UseGZipTransferHelpText &lt;&lt; #net &gt;&gt; 'Specifies whether to apply gzip compression to outgoing messages. If this option is checked the messages will be sent compressed with header field Transfer-Encoding: gzip.';		yourself</body><body package="NetConfigTool">httpWrite3AddUserAgentField	&lt;setting: #(net http messageWriting addUserAgentField)&gt;	| class |	#{Net.HttpWritingOptions}  ifDefinedDo: [ :val | class := val ] elseDo: [^nil].	^(BooleanSetting on: class aspect: #addUserAgentField)		label: #AddUserAgentField&lt;&lt; #net &gt;&gt; 'Add User-Agent field to Http requests';		default: class addUserAgentFieldValue;		helpText: #AddUserAgentFieldValueHelpText &lt;&lt; #net &gt;&gt; 'Defines if the User-Agent field should be added to Http requests';		yourself</body><body package="NetConfigTool">httpWrite4UserAgentFieldValue	&lt;setting: #(net http messageWriting userAgentFieldValue)&gt;	| class |	#{Net.HttpWritingOptions}  ifDefinedDo: [ :val | class := val ] elseDo: [^nil].	^(StringSetting on: class aspect: #userAgentFieldValue)		label: #UserAgentFieldValue &lt;&lt; #net &gt;&gt; 'User-Agent field value:';		default: class userAgentFieldDefaultValue;		helpText: #UserAgentFieldValueHelpText &lt;&lt; #net &gt;&gt; 'Default User-Agent field value';		yourself</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-imap</category><body package="NetConfigTool">imapDefaultTimeout	&lt;setting: #(net imap defaultTimeout)  position: 10&gt;	| class |	#{Net.IMAPSettings}  ifDefinedDo: [ :val | class := val ] elseDo: [^nil].	^(NumberSetting on: class aspect: #defaultTimeout)		label: #DefaultTimeout&lt;&lt; #net &gt;&gt; 'Default timeout (ms)';		default: class defaultTimeoutValue;		helpText: #NetDefaultTimeoutHelpText &lt;&lt; #net &gt;&gt; 'This is the number of milliseconds to wait for an issued command to complete before signaling an error.';		yourself</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>pages</category><body package="NetConfigTool">imapPage	&lt;settingsPage: #(net imap)&gt;	#{Net.IMAPSettings} isDefined ifFalse: [ ^nil]. 	^ModularSettingsPage new		label: #IMAP &lt;&lt; #labels &gt;&gt; 'IMAP';		icon: (ListIconLibrary visualFor: #net);		settings: (self settingsWithPrefix: #(net imap ));		yourself</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-mail</category><body package="NetConfigTool">mail1DefaultContentDisposition	&lt;setting: #(net mail defaultContentDisposition)&gt;	| class |	#{Net.ContentDispositionField }  ifDefinedDo: [ :val | class := val ] elseDo: [^nil].	^((EnumerationSetting 				choices: #(attachment inline)				labels: (Array with: (#attachment &lt;&lt; #net &gt;&gt; 'attachment') with: (#inline &lt;&lt; #net &gt;&gt; 'inline') ))			on: class aspect: #defaultContentDisposition )		default: class defaultContentDispositionValue;		label: #defaultContentDisposition &lt;&lt; #net &gt;&gt; 'Default content disposition type';		helpText: #defaultContentDispositionHelpText &lt;&lt; #net &gt;&gt; 'Specifies the default disposition type for bodyparts in multipart mail messages. A bodypart should be marked "inline" if it is intended to be displayed along with the message. Body parts can be designated "attachment" to indicate that they are separate from the main body of the message';		yourself</body><body package="NetConfigTool">mail2DefaultCharsetEncoder	&lt;setting: #(net mail defaultCharsetEncoder)&gt;	| class |	#{Net.SimpleBody }  ifDefinedDo: [ :val | class := val ] elseDo: [^nil].	^(StringSetting on: class aspect: #defaultCharsetEncoder )		label: #defaultCharsetEncoder &lt;&lt; #net &gt;&gt; 'Default content encoding';		default: class defaultCharsetEncoderValue;		helpText: #defaultCharsetEncoderHelpText &lt;&lt; #net &gt;&gt; 'This is the default encoding used for a message body when an encoding is not specified by the message.';		yourself</body><body package="NetConfigTool">mail3RemoveContentTransferEncoding	&lt;setting: #(net mail removeContentTransferEncoding)&gt;	| class |	#{Net.MailBuildHandler}  ifDefinedDo: [ :val | class := val ] elseDo: [^nil].	^(BooleanSetting on: class aspect: #removeContentTransferEncoding )		default: class  removeContentTransferEncodingValue;		label: #removeContentTransferEncoding &lt;&lt; #net &gt;&gt; 'Remove transfer encoding from messages';		helpText: #removeContentTransferEncodingrHelpText &lt;&lt; #net &gt;&gt; 'Specifies whether to automatically remove transfer encoding (quoted-printable, or base-64, etc) along with the corresponding Content-Transfer-Encoding field while parsing mail messages.';		yourself</body><body package="NetConfigTool">mail4SaveAttachmentAsFile	&lt;setting: #(net mail saveAttachmentAsFile)&gt;	| class |	#{Net.MimeBuildHandler}  ifDefinedDo: [ :val | class := val ] elseDo: [^nil].	^(BooleanSetting on: class aspect: #saveAttachmentsAsFiles )		label: #SaveAttachmentAsFileValue &lt;&lt; #net &gt;&gt; 'Save attachments as files';		default: class saveAttachmentsAsFilesValue;		helpText: #saveAttachmentAsFileValueHelpText &lt;&lt; #net &gt;&gt; 'Specifies whether to save attachments into files. This settings allows to process large attachments more efficiently. If this settings is turned off attachments will be reconstructed entirely in memory.';		yourself</body><body package="NetConfigTool">mail5UploadDirectory	&lt;setting: #(net mail uploadDirectory)&gt;	| class |	#{Net.MimeBuildHandler}  ifDefinedDo: [ :val | class := val ] elseDo: [^nil].	^(StringSetting on: class aspect: #defaultAttachmentDirectoryString )		label: #defaultAttachmentDirectory &lt;&lt; #net &gt;&gt; 'Save attachments in';		default: class defaultAttachmentDirectoryValue;		helpText: #defaultUploadDirectoryHelpText &lt;&lt; #net &gt;&gt; 'This setting specifies the directory that will be used to save file attachments.';		yourself</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>pages</category><body package="NetConfigTool">mailMessagePage	&lt;settingsPage: #(net mail)&gt;	#{Net.MimeEntity} isDefined ifFalse: [ ^nil]. 	^ModularSettingsPage new		label: #Mail &lt;&lt; #net &gt;&gt; 'Mail';		icon: (ListIconLibrary visualFor: #net);		settings: (self settingsWithPrefix: #(net mail ));		yourself</body><body package="NetConfigTool">mailServerPage	&lt;settingsPage: #(net mail mailServers)&gt;	(#{Net.IMAPClient} isDefined 		or: [#{POP3Client} isDefined 			or: [#{SMTPClient} isDefined]] ) ifFalse: [ ^nil]. 	^Net.MailServerPage new		label: #MailServers &lt;&lt; #labels &gt;&gt; 'Mail Servers';		icon: (ListIconLibrary visualFor: #net);		yourself</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-pop3</category><body package="NetConfigTool">pop3DefaultTimeout	&lt;setting: #(net pop3 defaultTimeout)  position: 10&gt;	| class |	#{Net.POP3Settings}  ifDefinedDo: [ :val | class := val ] elseDo: [^nil].	^(NumberSetting on: class aspect: #defaultTimeout)		label: #DefaultTimeout&lt;&lt; #net &gt;&gt; 'Default timeout (ms)';		default: class defaultTimeoutValue;		helpText: #NetDefaultTimeoutHelpText &lt;&lt; #net &gt;&gt; 'This is the number of milliseconds to wait for an issued command to complete before signaling an error.';		yourself</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>pages</category><body package="NetConfigTool">pop3Page	&lt;settingsPage: #(net pop3)&gt;	#{Net.POP3Settings} isDefined ifFalse: [ ^nil]. 	^ModularSettingsPage new		label: #POP3 &lt;&lt; #labels &gt;&gt; 'POP3';		icon: (ListIconLibrary visualFor: #net);		settings: (self settingsWithPrefix: #(net pop3 ));		yourself</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-mail</category><body package="NetConfigTool">smtp1UseAuthentication	&lt;setting: #(net mail useAuthentication)&gt;	| class |	#{Net.SMTPClient }  ifDefinedDo: [ :val | class := val ] elseDo: [^nil].	^(BooleanSetting on: class aspect: #useAuthentication )		default: class  useAuthenticationValue;		label: #useAuthenticationToConnectToSMTPServer &lt;&lt; #net &gt;&gt; 'Use authentication for SMTP';		helpText: #useAuthenticationToConnectToSMTPServerHelpText &lt;&lt; #net &gt;&gt; 'Specifies whether to use authentication while connecting to SMTP servers. With authentication the client sends EHLO and AUTH commands depending on the authentication schemes supported by the server. Without authentication the client will use simpler (unauthenticated) HELO command to start a session with the server. Many ISPs require authenticated SMTP sessions.';		yourself</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-smtp</category><body package="NetConfigTool">smtpDefaultTimeout	&lt;setting: #(net smtp defaultTimeout)  position: 10&gt;	| class |	#{Net.SMTPSettings}  ifDefinedDo: [ :val | class := val ] elseDo: [^nil].	^(NumberSetting on: class aspect: #defaultTimeout)		label: #DefaultTimeout&lt;&lt; #net &gt;&gt; 'Default timeout (ms)';		default: class defaultTimeoutValue;		helpText: #NetDefaultTimeoutHelpText &lt;&lt; #net &gt;&gt; 'This is the number of milliseconds to wait for an issued command to complete before signaling an error.';		yourself</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>pages</category><body package="NetConfigTool">smtpPage	&lt;settingsPage: #(net smtp)&gt;	#{Net.SMTPSettings} isDefined ifFalse: [ ^nil]. 	^ModularSettingsPage new		label: #SMTP &lt;&lt; #labels &gt;&gt; 'SMTP';		icon: (ListIconLibrary visualFor: #net);		settings: (self settingsWithPrefix: #(net smtp ));		yourself</body><body package="NetConfigTool">userIdentityPage	&lt;settingsPage: #(net  )&gt;	^Net.UserPage new		label: #Net &lt;&lt; #labels &gt;&gt; 'Net';		icon: (ListIconLibrary visualFor: #net);		yourself</body></methods><initialize><class-id>Net.NetSettingsPage</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Collection</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>Symbol</name><environment>Core</environment><super>Core.String</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>HostSpec</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name netUser type port isSecure useSTARTTLS </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><class><name>NetClient</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>user hostName portNumber clientPI state </inst-vars><class-inst-vars>defaultProtocolInterpreterClass </class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>NetUser</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>username password fullName account mailAddress </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><class><name>Dictionary</name><environment>Core</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>Text</name><environment>XML</environment><super>XML.Node</super><private>false</private><indexed-type>none</indexed-type><inst-vars>text stripped </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Nodes</category><attributes><package>XML</package></attributes></class><class><name>SettingsManagerPage</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>manager id position label icon children definingMethod </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Settings-UI</category><attributes><package>Tools-Settings</package></attributes></class><class><name>Element</name><environment>XML</environment><super>XML.Node</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tag attributes namespaces elements definition </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Nodes</category><attributes><package>XML</package></attributes></class><class><name>GenericSettingDescriptor</name><environment>Tools</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id position definingMethod </inst-vars><class-inst-vars></class-inst-vars><imports>			XML.Element			XML.Attribute			</imports><category>Tools-Settings</category><attributes><package>Tools-Settings</package></attributes></class><class><name>SimpleDialog</name><environment>UI</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>close accept cancel preBuildBlock postBuildBlock postOpenBlock escapeIsCancel parentView useParentColors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Dialogs</category><attributes><package>Interface-Dialogs</package></attributes></class></st-source>