<?xml version="1.0"?><st-source><!-- Name: SMTPNotice: Copyright 1999-2016 Cincom Systems, Inc.  All rights reserved.Comment: SMTPSupport provides a very basic SMTP Client that alllows you to send rfc822 messages to a SMTP server.The SMTP Authentication included with this release is based on code contributed by Federico Balaguer <balaguer@uiuc.edu>.  DbIdentifier: bear73DbTrace: 493289DbUsername: tkoganDbVersion: 8.3 - 0DevelopmentPrerequisites: #(#(#any 'Mail' '') #(#package 'MIME' '') #(#package 'HashesBase' '') #(#package 'MD5' '') #(#package 'NetClientBase' '') #(#package 'Protocols-Common' ''))PackageName: SMTPParcel: #('SMTP')ParcelName: SMTPPrerequisiteParcels: #(#('Mail' '') #('MIME' '') #('HashesBase' '') #('MD5' '') #('NetClientBase' '') #('Protocols-Common' ''))PrintStringCache: (8.3 - 0,tkogan)Version: 8.3 - 0Date: 2:30:31 PM April 28, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (apr17.3) of April 28, 2017 on April 28, 2017 at 2:30:31 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>SMTPClient</name><environment>Net</environment><super>Net.NetClient</super><private>false</private><indexed-type>none</indexed-type><inst-vars>serverResponses useAuthentication </inst-vars><class-inst-vars>useAuthentication </class-inst-vars><imports></imports><category>Net-SMTP-Support</category><attributes><package>SMTP</package></attributes></class><comment><class-id>Net.SMTPClient</class-id><body>SMPT Client sends rfc822 messages to SMTP server. SMTPClient uses state objects to validate if a request is valid in a given state and to handle state transitions. Instance Variables:	useAuthentication	&lt;Boolean&gt;  the option specifies whether or not the sending utilities will use EHLO command and authentication scheme if the server has one. The defaut is true. If the the option is set to false the client starts the session with the HELO command.	serverResponses	&lt;OrderedCollection&gt;  server responsesClass Variables:	useAuthentication &lt;Boolean&gt; default option </body></comment><class><name>SMTPState</name><environment>Net</environment><super>Net.NetClientState</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-SMTP-Support</category><attributes><package>SMTP</package></attributes></class><comment><class-id>Net.SMTPState</class-id><body>SMTPState is superclass for all SMTP states. Publishes command signatures, implements them all as invalid for the state</body></comment><class><name>SMTPNotConnectedState</name><environment>Net</environment><super>Net.SMTPState</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-SMTP-Support</category><attributes><package>SMTP</package></attributes></class><comment><class-id>Net.SMTPNotConnectedState</class-id><body>SMTPNotConnectedState is set when the client is not connected to a server</body></comment><class><name>SMTPResponseError</name><environment>Net</environment><super>Net.NetClientError</super><private>false</private><indexed-type>none</indexed-type><inst-vars>code errorMessages status </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>SMTP</package></attributes></class><comment><class-id>Net.SMTPResponseError</class-id><body>SMTPResponseError is proceedable exception that is raised if the SMTP mail server replies with the code more than 400.Instance Variables	code	&lt;Number&gt;	error code	errorMessages	&lt;Collection of: String&gt; error replies	status &lt;String&gt; the error status code (http://tools.ietf.org/html/rfc3463#section-3.6)The exception allows proceeding with the message if a mail server failed to verify one of recipients.For example if a mail server retuns reply as:C: RCPT TO:&lt;bogusRecipient&gt;S: 550 5.1.1 &lt;bogusRecipient&gt;... User unknown:You can catch the exception and proceed sending the message to the rest of the recipients		[ self client send: message]		on: SMTPResponseError		do: [ :exc | 			(exc code = 550 and: [exc status = '5.1.1'])  ifTrue: [exc proceed]]</body></comment><class><name>SMTPConnectedState</name><environment>Net</environment><super>Net.SMTPState</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-SMTP-Support</category><attributes><package>SMTP</package></attributes></class><comment><class-id>Net.SMTPConnectedState</class-id><body>SMTPConnectedState state is used when the client is connected and the user has to be authorized to SMTP server. Only authorization commands are valid</body></comment><class><name>SMTPAuthentication</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>client </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SMTPAUTH</category><attributes><package>SMTP</package></attributes></class><comment><class-id>Net.SMTPAuthentication</class-id><body>SMTPAuthentication is an abstract class that implements authentication mechanism for SMTP commands. Subclasses must implement the following messages:	authenticate		authenticateInstance Variables:	client	&lt;SMTPClient&gt;	SMTP client</body></comment><class><name>CRAMMD5Authentication</name><environment>Net</environment><super>Net.SMTPAuthentication</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SMTP</category><attributes><package>SMTP</package></attributes></class><comment><class-id>Net.CRAMMD5Authentication</class-id><body>CRAM-MD5 authentication.</body></comment><class><name>SMTPSettings</name><environment>Net</environment><super>Net.NetPISettings</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-SMTP-Support</category><attributes><package>SMTP</package></attributes></class><comment><class-id>Net.SMTPSettings</class-id><body>SMTPSettings  represents SMTP options</body></comment><class><name>PlainAuthentication</name><environment>Net</environment><super>Net.SMTPAuthentication</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SMTPAUTH</category><attributes><package>SMTP</package></attributes></class><comment><class-id>Net.PlainAuthentication</class-id><body>PlainAuthentication  implements  'AUTH PLAIN' authentication</body></comment><class><name>SMTPStateError</name><environment>Net</environment><super>Net.NetClientError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SMTP</category><attributes><package>SMTP</package></attributes></class><comment><class-id>Net.SMTPStateError</class-id><body>SMTPStateError signals the error for commands that are invalid in the current state</body></comment><class><name>SMTPQuitFailure</name><environment>Net</environment><super>Core.Warning</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SMTP</category><attributes><package>SMTP</package></attributes></class><comment><class-id>Net.SMTPQuitFailure</class-id><body>The SMTPQuitFailure is raised when the client sent the #QUIT command but a server closed the connection without any reply for #QUIT. We observed this behavior with the gmail server for SSL connection. Usually the server finishes all transactions anyway</body></comment><class><name>SMTPProtocolInterpreter</name><environment>Net</environment><super>Net.NetProtocolInterpreter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SMTP</category><attributes><package>SMTP</package></attributes></class><comment><class-id>Net.SMTPProtocolInterpreter</class-id><body>SMTPProtocolInterpreter manages SMTP server connection and provides interface for sending SMTP commands and handling SMTP responses. </body></comment><class><name>SMTPAuthenticatedState</name><environment>Net</environment><super>Net.SMTPState</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-SMTP-Support</category><attributes><package>SMTP</package></attributes></class><comment><class-id>Net.SMTPAuthenticatedState</class-id><body>SMTPAuthenticatedState  is set when the user has connected in and authorized himself to an SMTP server. Messages can be sent now</body></comment><class><name>SMTPWriteHandler</name><environment>Net</environment><super>Net.MimeWriteHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>blindRecipients </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-SMTP-Support</category><attributes><package>SMTP</package></attributes></class><comment><class-id>Net.SMTPWriteHandler</class-id><body>This writer is used to write rfc822 messages on an SMTP stream. If the rfc822 message contains "bcc:" fields,  the "bcc:" lines will be  removed even though all of the recipients (including those specified in the "bcc:" field) are sent a copy of the message. The 'Bcc:' field (where the 'Bcc' means 'Blind Carbon Copy') contains  addresses of recipients of the message whose addresses are not to be revealed to other recipients of the message.  Instance Variables:	blindRecipients	&lt;Collection of (String)&gt;	default: #('bcc' 'resent-bcc')</body></comment><class><name>LoginAuthentication</name><environment>Net</environment><super>Net.SMTPAuthentication</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SMTPAUTH</category><attributes><package>SMTP</package></attributes></class><comment><class-id>Net.LoginAuthentication</class-id><body>LoginAuthentication implements  'AUTH LOGIN' authentication</body></comment><class><name>SMTPConnection</name><environment>Net</environment><super>Net.NetConnection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.IOConstants.*			</imports><category>Net-SMTP-Support</category><attributes><package>SMTP</package></attributes></class><comment><class-id>Net.SMTPConnection</class-id><body>SMTPConnection is the SMTP connection stream wrapper</body></comment><class><name>SMTPTransactionState</name><environment>Net</environment><super>Net.SMTPState</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-SMTP-Support</category><attributes><package>SMTP</package></attributes></class><comment><class-id>Net.SMTPTransactionState</class-id><body>The SMTPTransactionState starts when the SMTP client initiates a mail transaction in which the mail data will be delivered to an SMTP server. The transaction state starts with the "MAIL" command</body></comment><methods><class-id>Net.SMTPClient</class-id> <category>commands</category><body package="SMTP">authenticateCRAMMD5	^self state authenticateCRAMMD5</body><body package="SMTP">authenticateLogin	^self state authenticateLogin</body><body package="SMTP">authenticatePlain	^self state authenticatePlain</body><body package="SMTP">data	^self state data</body><body package="SMTP">ehlo	^self state ehlo</body><body package="SMTP">ehloDo: aBlock	^self state ehloDo: aBlock</body><body package="SMTP">expand	^self state expand</body><body package="SMTP">hello	^self state hello</body><body package="SMTP">help	^self state help</body><body package="SMTP">login	self state login</body><body package="SMTP">mailFrom: aString"This command is used to initiate a mail transaction in which the mail data is delivered to an SMTP server which may, in turn, deliver it to one or more mailboxes or pass it on to another system (possibly using SMTP).  The argument field contains a reverse-path and may contain optional parameters.  In general, the MAIL command may be sent only  when no mail transaction is in progress"	^self state mailFrom: aString</body><body package="SMTP">noop	^self state noop</body><body package="SMTP">quit "  This command specifies that the receiver MUST send an OK reply, and  then close the transmission channel."	[self connection privateQuitDo: [self state quit.]	] ensure: [ self disconnect ].</body><body package="SMTP">recipients: aCollection	^self state recipients: aCollection</body><body package="SMTP">reset	^self state reset</body><body package="SMTP">senderAddressFrom: mailMessage	^(self user notNil and: [self user mailAddress notNil ])			ifTrue: [self user mailAddress ]			ifFalse: [mailMessage smtpFromSendStrings ].</body><body package="SMTP">verify: aString	^self state verify: aString</body></methods><methods><class-id>Net.SMTPClient</class-id> <category>accessing</category><body package="SMTP">serverResponses	^serverResponses isNil		ifTrue: [serverResponses := OrderedCollection new]		ifFalse: [serverResponses]</body><body package="SMTP">useAuthentication	^useAuthentication ifNil: [useAuthentication := self class useAuthentication]</body><body package="SMTP">useAuthentication: aBoolean	useAuthentication := aBoolean</body></methods><methods><class-id>Net.SMTPClient</class-id> <category>low-level command interface</category><body package="SMTP">executeCommand: aString	serverResponses := self clientPI executeCommand: aString.	^serverResponses</body><body package="SMTP">writeMessage: mailMessage	self state writeMessage: mailMessage.</body></methods><methods><class-id>Net.SMTPClient</class-id> <category>connection management</category><body package="SMTP">close	self quit</body><body package="SMTP">connect	| responses |	super connect.	self state: SMTPConnectedState new.	responses := self clientPI waitForResponses.	self clientPI connection finishConnecting: self.	^responses</body><body package="SMTP">disconnect	"Disconnect from the host"	super disconnect.	self state: SMTPNotConnectedState new.</body></methods><methods><class-id>Net.SMTPClient</class-id> <category>initialize-release</category><body package="SMTP">configureFrom: aHostSpec	super configureFrom: aHostSpec.	aHostSpec useSTARTTLS ifTrue: [		#'Net.SMTPSTARTTLSConnection' asQualifiedReference isDefined 			ifTrue: [self useSecureConnectionIfAvailable ]			ifFalse: [self error: #LoadSMTPSParcel &lt;&lt; #net &gt;&gt; 'Load SMTPS parcel to create secure connection']].	aHostSpec user ifNil: [ self useAuthentication: false ]</body><body package="SMTP">initialize	super initialize.	self state: SMTPNotConnectedState new.</body></methods><methods><class-id>Net.SMTPClient</class-id> <category>utilities</category><body package="SMTP">send: mailMessage	self connectIfClosed.	[self login.	self sendMessage: mailMessage 	] ensure: [ self quit ]</body><body package="SMTP">sendMessage: mailMessage		self mailFrom: (self senderAddressFrom: mailMessage).	self recipients: mailMessage smtpDestinationAddresses.	self writeMessage: mailMessage</body></methods><methods><class-id>Net.SMTPClient</class-id> <category>private</category><body package="SMTP">responseLineFor: keyword	^serverResponses 		detect: [:each | (each indexOfSubCollection: keyword startingAt: 1) ~= 0]		ifNone: [nil]</body></methods><methods><class-id>Net.SMTPClient class</class-id> <category>constants</category><body package="SMTP">description	^(#outgoingMailServer &lt;&lt; #net &gt;&gt; 'outgoing mail server') asString</body><body package="SMTP">serverType	^#SMTP</body></methods><methods><class-id>Net.SMTPClient class</class-id> <category>testing</category><body package="SMTP">isIncomingMailClient	^false</body><body package="SMTP">isMailClient	^true</body><body package="SMTP">isOutgoingMailClient	^true</body></methods><methods><class-id>Net.SMTPClient class</class-id> <category>private</category><body package="SMTP">update: anAspect with: arguments from: anObject</body></methods><methods><class-id>Net.SMTPClient class</class-id> <category>class initialization</category><body package="SMTP">initialize"We're just calling super so that this class gets initialized on load (only classes that define initialize get called)	self initialize."	super initialize.</body><body package="SMTP">registerClass	self mailRegistry at: self serverType put: self name</body></methods><methods><class-id>Net.SMTPClient class</class-id> <category>default values</category><body package="SMTP">defaultProtocolInterpreterClassValue	^SMTPProtocolInterpreter</body><body package="SMTP">useAuthenticationValue	^true</body></methods><methods><class-id>Net.SMTPClient class</class-id> <category>defaults</category><body package="SMTP">useAuthentication	^useAuthentication ifNil: [useAuthentication := self useAuthenticationValue]</body><body package="SMTP">useAuthentication: aBoolean	useAuthentication := aBoolean</body></methods><methods><class-id>Net.SMTPState</class-id> <category>commands</category><body package="SMTP">authenticateCRAMMD5	self signalError</body><body package="SMTP">authenticateLogin	self signalError</body><body package="SMTP">authenticatePlain	self signalError</body><body package="SMTP">data	self signalError</body><body package="SMTP">ehlo	self signalError</body><body package="SMTP">ehloDo: aBlock	self signalError</body><body package="SMTP">expand"The case of expanding a mailbox list requires a multiline reply, such  as:      C: EXPN Example-People      S: 250-Jon Postel &lt;Postel@isi.edu&gt;      S: 250-Fred Fonebone &lt;Fonebone@physics.foo-u.edu&gt;      S: 250 Sam Q. Smith &lt;SQSmith@specific.generic.com&gt;   or      C: EXPN Executive-Washroom-List      S: 550 Access Denied to You."	self client sendCommand: 'EXPN'.	self client readResponses.	^self client serverResponses</body><body package="SMTP">hello	self signalError</body><body package="SMTP">help	^self client executeCommand: 'HELP'.</body><body package="SMTP">login	self signalError</body><body package="SMTP">mailFrom: aMailMessage	self signalError</body><body package="SMTP">noop	^self client executeCommand: 'NOOP'.</body><body package="SMTP">quit	^self client executeCommand: 'QUIT'.</body><body package="SMTP">recipients: aCollection	self signalError</body><body package="SMTP">reset"   This command specifies that the current mail transaction will be  aborted.  Any stored sender, recipients, and mail data MUST be discarded, and all buffers and state tables cleared.  "	self client executeCommand: 'RSET'.	^self client serverResponses</body><body package="SMTP">verify: aString"3.5.2 VRFY Normal Response   When normal (2yz or 551) responses are returned from a VRFY or EXPNthe following are legitimate response to VRFY:      553 User ambiguous   or      553- Ambiguous;  Possibilities are      553-Harry Smith &lt;hsmith@foo.com&gt;      553 Melvin Smith &lt;dweep@foo.com&gt;3.5.3 Meaning of VRFY or EXPN Success Response   A server MUST NOT return a 250 code in response to a VRFY or EXPN command unless it has actually verified the address.  In particular, a server MUST NOT return 250 if all it has done is to verify that the syntax given is valid.  In that case, 502 (Command not implemented) or 500 (Syntax error, command unrecognized) SHOULD be returned.  As   stated elsewhere, implementation (in the sense of actually validating  addresses and returning information) of VRFY and EXPN are strongly recommended.  "	self client clientPI sendCommand: 'VRFY ', aString.	^self client clientPI readResponses.</body><body package="SMTP">writeMessage: mailMessage	self signalError</body></methods><methods><class-id>Net.SMTPState</class-id> <category>accessing</category><body package="SMTP">stateErrorClass	^SMTPStateError</body></methods><methods><class-id>Net.SMTPResponseError</class-id> <category>accessing</category><body package="SMTP">code	^code</body><body package="SMTP">code: aNumber	code := aNumber</body><body package="SMTP">errorMessages	^errorMessages</body><body package="SMTP">errorMessages: aCollection	errorMessages := aCollection</body><body package="SMTP">status	^status</body></methods><methods><class-id>Net.SMTPResponseError</class-id> <category>initialize-release</category><body package="SMTP">code: aNumber errorMessages: aCollection	code := aNumber.	errorMessages := aCollection.	status := aCollection first copyFrom: 5 to: 9.</body><body package="SMTP">initialize	super initialize.	errorMessages := OrderedCollection new.</body></methods><methods><class-id>Net.SMTPResponseError</class-id> <category>printing</category><body package="SMTP">description	| stream |	stream := String new writeStream.	self errorMessages 		do: [ :each | stream nextPutAll: each ]		separatedBy: [stream cr].	^stream contents</body></methods><methods><class-id>Net.SMTPResponseError class</class-id> <category>testing</category><body package="SMTP">mayResume	^true</body></methods><methods><class-id>Net.SMTPResponseError class</class-id> <category>signalling</category><body package="SMTP">raiseRequestWith: aParameter code: aNumber errors: aCollection	"Raise the resumable exception"	^self new		parameter: aParameter;		code: aNumber errorMessages: aCollection;		raiseRequest.</body></methods><methods><class-id>Net.SMTPConnectedState</class-id> <category>commands</category><body package="SMTP">authenticateCRAMMD5	^self client executeCommand: 'AUTH CRAM-MD5'.</body><body package="SMTP">authenticateLogin	^self client executeCommand: 'AUTH LOGIN'.</body><body package="SMTP">authenticatePlain	^self client executeCommand: 'AUTH PLAIN'.</body><body package="SMTP">ehlo	^self ehloDo: []</body><body package="SMTP">ehloDo: aBlock	self client executeCommand: ('EHLO ', self client hostName).	aBlock value.	self client state: SMTPAuthenticatedState new.	^self client serverResponses</body><body package="SMTP">handShakeServer	(self client user isNil or: [self client username isNil or: [ self client  password isNil]])		ifTrue:			 [NetClientError signalWith: #authenticate message: (#CanNotAuthenticateTheUser &lt;&lt; #net &gt;&gt; 'Can not authenticate the user. There is no user name or password provided.')].	self ehloDo: [ (SMTPAuthentication for: self client ) ifNotNil: [ :authentication | authentication authenticate ] ].</body><body package="SMTP">hello	self client executeCommand: ('HELO ',  self client hostName).	self client state: SMTPAuthenticatedState new.	^self client serverResponses</body><body package="SMTP">login	self client useAuthentication		ifTrue: [self handShakeServer ]		ifFalse: [self hello ].</body></methods><methods><class-id>Net.SMTPAuthentication</class-id> <category>accessing</category><body package="SMTP">client	^client</body><body package="SMTP">client: smtpClient	client := smtpClient</body></methods><methods><class-id>Net.SMTPAuthentication</class-id> <category>authenticate</category><body package="SMTP">authenticate</body></methods><methods><class-id>Net.SMTPAuthentication class</class-id> <category>instance creation</category><body package="SMTP">for: smtpClient 	| auth policies |	auth := smtpClient responseLineFor: 'AUTH '.	auth ifNil: [ ^nil ].	policies := OrderedCollection new.	auth notNil ifTrue:[			('*CRAM-MD5*' match: auth) ifTrue: [ policies add: CRAMMD5Authentication ].			('*LOGIN*' match: auth) ifTrue: [ policies add: LoginAuthentication ].			('*PLAIN*' match: auth) ifTrue: [ policies add: PlainAuthentication ]].	policies isEmpty ifTrue: [		^NetClientError signalWith: smtpClient			message: (#NoneOfSupportedAuthMethodAvail &lt;&lt; #net &gt;&gt; 'None of the supported authentication methods is available!')].	^policies first new		client: smtpClient;		yourself</body></methods><methods><class-id>Net.CRAMMD5Authentication</class-id> <category>authenticate</category><body package="SMTP">authenticate	self client authenticateCRAMMD5.	[ :code :data || challenge response hmac |		challenge := (DecodedStream on: data readStream encodedBy: B64StreamDecoder asEncoder) contents.		[	hmac := Security.HMAC MD5: (self client user password asByteArrayEncoding: #ASCII)		] on: Warning do: [ :ex | "resume warnings about weak keys" ex resume: true ].		response := hmac hash: challenge.		response := '&lt;1s&gt; &lt;2s&gt;' expandMacrosWith: self client user username with: response asHexString asLowercase.		response := (DecodedStream on: String new writeStream encodedBy: B64StreamDecoder asEncoder)					nextPutAll: (response asByteArrayEncoding: #ASCII);					close;					encodedContents.		self client executeCommand: response.	] valueWithArguments: (		self client serverResponses first tokensBasedOn: Character space) asArray.</body></methods><methods><class-id>Net.PlainAuthentication</class-id> <category>authenticate</category><body package="SMTP">authenticate	self client authenticatePlain.	self client executeCommand: (self encodeLoginPassword: self client user).</body><body package="SMTP">encodeLoginPassword: netUser 	" Encoding string as base64 "	| stream |	stream := (ByteArray new withEncoding: #BASE64) writeStream.	stream nextPut: (Character value: 0).	stream nextPutAll: netUser username.	stream nextPut: (Character value: 0).	stream nextPutAll: netUser password.	stream close.	^(stream encodedContents withEncoding: #ASCII) readStream contents</body></methods><methods><class-id>Net.SMTPProtocolInterpreter</class-id> <category>responses</category><body package="SMTP">readResponses	| result replyStream serverResponses |	serverResponses := OrderedCollection new.	replyStream := self connection getResponseStream.	[result := replyStream throughAll: CRLF.	self  log: [ ('S: &lt;1s&gt;' expandMacrosWith: result) ] level: #SMTPServer.	serverResponses add: result.	result size &gt; 4 and: [(result at: 4)= $-]] whileTrue.	^serverResponses</body><body package="SMTP">serverErrorCheck: aCollection	"Raise an error if the last response from the SMTP server has an error."	| code |	code := (aCollection first copyFrom: 1 to: 3 ) asNumber.	code &gt;= 400 		ifTrue: 			[SMTPResponseError 				raiseRequestWith: self 				code: code				errors: aCollection ]</body><body package="SMTP">waitForResponses	| serverResponses |	serverResponses:= self readResponses.	serverResponses first notEmpty ifTrue: [self serverErrorCheck: serverResponses].	^serverResponses</body></methods><methods><class-id>Net.SMTPProtocolInterpreter</class-id> <category>public</category><body package="SMTP">executeCommand: aString	self sendCommand: aString.	^self waitForResponses.</body><body package="SMTP">sendCommand: string	"Will CRLF terminate"	self isConnected ifFalse:		[NetClientError signalWith: #SMTPClient message: (#SMTPClientConnectionIsClosed &lt;&lt; #net &gt;&gt;'SMTPClient: Connection is closed') asString.].	self log: [ ('C: &lt;1s&gt;' expandMacrosWith: string) ] level: #SMTPClient.	MailIncrementNotification signalWith: string size. 	self stream 		nextPutAll: string;		nextPutAll: CRLF;		commit</body></methods><methods><class-id>Net.SMTPProtocolInterpreter</class-id> <category>private</category><body package="SMTP">writeMessage: mailMessage	[ self stream lineEndCRLF.	self log: [ | str |			str := String new writeStream.			SMTPWriteHandler writeMessage: mailMessage on: str.			 ('C: &lt;1s&gt;' expandMacrosWith: str contents) ] level: #SMTPClient.	SMTPWriteHandler writeMessage: mailMessage on: self stream]		ensure: [ self stream lineEndTransparent].		self executeCommand: CRLF, '.'.</body></methods><methods><class-id>Net.SMTPProtocolInterpreter class</class-id> <category>debugging</category><body package="SMTP">debugLabelsAndValues	^OrderedCollection new		add: ((#SMTPClientMessages &lt;&lt; #net &gt;&gt; 'SMTP Client Messages')-&gt;#SMTPClient);		add: ((#SMTPServerMessages &lt;&lt; #net &gt;&gt; 'SMTP Server Messages')-&gt;#SMTPServer);		yourself</body><body package="SMTP">menuItemName	^(#SMTPClientMessages &lt;&lt; #net &gt;&gt; 'SMTP Client Messages')</body></methods><methods><class-id>Net.SMTPProtocolInterpreter class</class-id> <category>class initialization</category><body package="SMTP">initialize	"self initialize."	self registerToDebug.</body><body package="SMTP">obsolete	self unregisterFromDebug.	super obsolete.</body></methods><methods><class-id>Net.SMTPProtocolInterpreter class</class-id> <category>default values</category><body package="SMTP">defaultNetConnectionValue	^SMTPConnection</body><body package="SMTP">settings	^SMTPSettings</body></methods><methods><class-id>Net.SMTPAuthenticatedState</class-id> <category>commands</category><body package="SMTP">mailFrom: aString	| from resp |	from := (self client user notNil and: [self client user mailAddress notNil ])			ifTrue: [self client user mailAddress ]			ifFalse: [aString ].	resp := self client executeCommand: ('MAIL FROM:%&lt;&lt;1s&gt;%&gt;' expandMacrosWith: from).	self client state: SMTPTransactionState new.	^resp</body></methods><methods><class-id>Net.SMTPWriteHandler</class-id> <category>defaults</category><body package="SMTP">defaultBlindRecipients	^#('bcc' 'resent-bcc')</body></methods><methods><class-id>Net.SMTPWriteHandler</class-id> <category>private</category><body package="SMTP">selectFieldsFrom: aMessageHeader	| fields finalFields |	fields := super selectFieldsFrom: aMessageHeader.	finalFields := OrderedCollection new: fields size.	finalFields addAll: ( fields reject: [ :fieldx | self blindRecipients includes: fieldx name]).	^finalFields</body></methods><methods><class-id>Net.SMTPWriteHandler</class-id> <category>accessing</category><body package="SMTP">blindRecipients	^blindRecipients ifNil: [ self defaultBlindRecipients ]</body><body package="SMTP">blindRecipients: aCollection	blindRecipients := aCollection</body></methods><methods><class-id>Net.LoginAuthentication</class-id> <category>authenticate</category><body package="SMTP">authenticate	self client authenticateLogin.	self client executeCommand: (self encodeLogin: self client user).	self client executeCommand: (self encodePassword: self client user).</body><body package="SMTP">encodeLogin: netUser 	" Encoding string as base64 "	| stream |	stream := (ByteArray new withEncoding: #BASE64) writeStream.	stream nextPutAll: netUser username.	stream close.	^(stream encodedContents withEncoding: #ASCII) readStream contents</body><body package="SMTP">encodePassword: netUser 	" Encoding string as base64 "	| stream |	stream := (ByteArray new withEncoding: #BASE64) writeStream.	stream nextPutAll: netUser password.	stream close.	^(stream encodedContents withEncoding: #ASCII) readStream contents</body></methods><methods><class-id>Net.SMTPConnection</class-id> <category>private</category><body package="SMTP">finishConnecting: client	^self</body><body package="SMTP">privateQuitDo: aBlock	aBlock value</body></methods><methods><class-id>Net.SMTPConnection class</class-id> <category>default values</category><body package="SMTP">defaultLineEndConvention	^LineEndTransparent</body><body package="SMTP">defaultPortNumber	^SocketAccessor IPPORT_SMTP</body></methods><methods><class-id>Net.SMTPTransactionState</class-id> <category>commands</category><body package="SMTP">data	^self client executeCommand: 'DATA'.</body><body package="SMTP">recipients: aCollection 	aCollection 		do: [ :receiver | self client executeCommand: ('RCPT TO:%&lt;&lt;1s&gt;%&gt;' expandMacrosWith: receiver)].	^self client serverResponses</body><body package="SMTP">reset	| resp |	resp := super reset.	self client state: SMTPAuthenticatedState new.	^resp</body><body package="SMTP">writeMessage: mailMessage	self data.	self client clientPI writeMessage: mailMessage.	self client state: SMTPAuthenticatedState new</body></methods><methods><class-id>Net.UnparsedHeaderValue</class-id> <category>testing</category><body package="SMTP">isValid	^false</body></methods><methods><class-id>Net.HostSpec class</class-id> <category>instance creation</category><body package="SMTP">smtp: host user: user	^self protocol: #SMTP host:  host user: user</body><body package="SMTP">smtp: host username: username password: password	^self protocol: #SMTP host: host username: username password: password</body></methods><methods><class-id>Net.MailMessage</class-id> <category>accessing</category><body package="SMTP">smtpDestinationAddresses" Answer collection of destination addresses. These addresses have been preprocessedto make them good for SMTP transport. This means removing everything but address-spec "	| coll f |	coll := OrderedCollection new.	self destinationFields 		do: [ :fn |  			(f := self fieldAt: fn ifAbsent: [nil])				ifNotNil: [ f addresses do: [ :addressDesc | 							addressDesc isValid ifTrue: [ coll add: addressDesc addressSpecString]]]].	^coll</body><body package="SMTP">smtpFromSendStrings	| str from |	from := self fieldAt: 'from' ifAbsent:[^String new].	from addresses 		do: [ :adx | (adx isValid and: [(str := adx addressSpecString) notEmpty]) ifTrue: [ ^str]].	^String new</body></methods><initialize><class-id>Net.SMTPClient</class-id></initialize><initialize><class-id>Net.SMTPProtocolInterpreter</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>NetClient</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>user hostName portNumber clientPI state </inst-vars><class-inst-vars>defaultProtocolInterpreterClass </class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><class><name>Warning</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>NetClientState</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>client </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><class><name>UnparsedHeaderValue</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>errorDescription source errorPosition </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><class><name>NetConnection</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream settings </inst-vars><class-inst-vars>encoding </class-inst-vars><imports>			private OS.IOConstants.*			</imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><class><name>NetClientError</name><environment>Net</environment><super>Net.NetError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><class><name>NetPISettings</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tlsContext tlsSubjectVerifier retries timeout delaySeconds </inst-vars><class-inst-vars>defaultDelaySeconds defaultRetries defaultTimeout </class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><class><name>MimeWriteHandler</name><environment>Net</environment><super>Net.MimeOutputHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>originalStream binaryMode </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><class><name>MailMessage</name><environment>Net</environment><super>Net.RFC822Message</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>Mail</package></attributes></class><class><name>NetProtocolInterpreter</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>connection settings </inst-vars><class-inst-vars>defaultNetConnection </class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class></st-source>