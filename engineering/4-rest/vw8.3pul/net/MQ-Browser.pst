<?xml version="1.0"?><st-source><!-- Name: MQ-BrowserNotice: Copyright © 2008 Cincom Systems, Inc.  All Rights Reserved.Comment: This package contains a simple MQ queue browser.DbIdentifier: bear73DbTrace: 319424DbUsername: gheegDbVersion: 7.8 - 1DevelopmentPrerequisites: #(#(#any 'MQ-Domain' ''))PackageName: MQ-BrowserParcel: #('MQ-Browser')ParcelName: MQ-BrowserPrerequisiteParcels: #(#('MQ-Domain' ''))PrintStringCache: (7.8 - 1,gheeg)Version: 7.8 - 1Date: 12:48:27 PM June 24, 2016 --><time-stamp>From VisualWorks®, Pre-Release 8.2 (jun16.4) of June 24, 2016 on June 24, 2016 at 12:48:27 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>QueueBrowser</name><environment>MQ</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>portNumber serverChannel queueName hostName qm connected messageList2 queueNameList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIApplications-New</category><attributes><package>MQ-Browser</package></attributes></class><comment><class-id>MQ.QueueBrowser</class-id><body>QueueBrowser is a simple browser for MQ.It allows the naming of an  MQ host, its server channel and (optional) aport number, in order to connect to a queue manager.A queue name can be specified, which then can be browsed and emptied.A test message can be send to that queue, too.Instance Variables:	connected		&lt;ValueModel&gt;		connection status of the queueManager	hostName		&lt;ValueModel&gt;		the hostName	messageList2	&lt;SelectionInList&gt;	list of message objects fetched from the queue	portNumber		&lt;ValueHolder&gt;		the  port number	q				&lt;BrowseQueue&gt;		the queue	qm				&lt;RemoteQueueManager&gt;	the queueManager	queueName		&lt;ValueModel&gt;		name of the queue	serverChannel	&lt;ValueModel&gt;		name of the serverChannel</body></comment><methods><class-id>MQ.QueueBrowser</class-id> <category>testing</category><body package="MQ-Browser">hasMessages	"Answer true if the messages list is not empty, false otherwise"	^self messageList2 list isEmpty not</body><body package="MQ-Browser">isConnected	^qm notNil and: [qm isConnected]</body><body package="MQ-Browser">isMessageSelected	"Answer true if some element in the messages list is selected, false otherwise"	^self messageList2 selection notNil</body></methods><methods><class-id>MQ.QueueBrowser</class-id> <category>aspects</category><body package="MQ-Browser">connected	"Answer the ValueHolder that remembers the connection state.	Return: ValueHolder on: Boolean"	^connected isNil 		ifTrue: 			[connected := false asValue.			connected onChangeSend: #updateButtonStatus to: self]		ifFalse: [connected]</body><body package="MQ-Browser">hostName	"Answer the ValueHolder with the name of the host that runs the MQ manager.	Return: ValueHolder on: String"	^hostName isNil 		ifTrue: 			[| setup aString |			aString := (setup := self mqSetup) isNil 						ifTrue: [String new]						ifFalse: [setup host].			hostName := aString asValue]		ifFalse: [hostName]</body><body package="MQ-Browser">messageList2	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^messageList2 isNil		ifTrue:			[messageList2 :=  SelectionInList new]		ifFalse:			[messageList2]</body><body package="MQ-Browser">portNumber	"Answer the ValueHolder with the MQ service port number.	Return: ValueHolder on: Integer"	^portNumber isNil ifTrue: [portNumber := nil asValue] ifFalse: [portNumber]</body><body package="MQ-Browser">queueName	"Answer the ValueHolder for input and selection of the queue name ComboBox list.	Return: ValueHolder on: String"	^queueName isNil 		ifTrue: 			[| qnames |			qnames := self queueNameList value.			queueName := (qnames isEmpty ifTrue: [''] ifFalse: [qnames first]) asValue.			queueName onChangeSend: #updateForNewQueueName to: self.			queueName]		ifFalse: [queueName]</body><body package="MQ-Browser">queueNameList	"Answer the ValueHolder with the list of existing and browsable queue names.	For convenience put in the SUnit test queues (if defined) and any live queue instances.	Return: ValueHolder on: (List of: String)"	^queueNameList isNil 		ifTrue: 			[| list |			list := #().			#{MQ.MQTestServices} ifDefinedDo: 					[:theClass | 					list := #(#FirstQueueName #SecondQueueName #ModelQueueName #BlueQueueName) 								collect: [:each | theClass asNameSpace dataAt: each ifAbsent: []].					list := list copyWithout: '' 	"in case any of the constants is defined as empty string"].			list := list asSet.			self registeredQueueManagers 				do: [:each | each allQueues do: [:aQueue | list add: aQueue queueName trimBlanks]].			queueNameList := list asSortedCollection asList asValue]		ifFalse: [queueNameList]</body><body package="MQ-Browser">selMsg	^ self messageList2 selectionHolder</body><body package="MQ-Browser">serverChannel	"Answer the ValueHolder with the name of the MQ manager connect channel.	Return: ValueHolder on: String"	^serverChannel isNil 		ifTrue: 			[| setup aString |			aString := (setup := self mqSetup) isNil 						ifTrue: [String new]						ifFalse: [setup channelName].			serverChannel := aString asValue]		ifFalse: [serverChannel]</body></methods><methods><class-id>MQ.QueueBrowser</class-id> <category>menu actions</category><body package="MQ-Browser">inspectAllMessages	"Open an Inspector with all messages."	self messageList2 list asArray inspect</body><body package="MQ-Browser">inspectMessage	"Open an Inspector on the selected message."	self messageList2 selection inspect</body></methods><methods><class-id>MQ.QueueBrowser</class-id> <category>private</category><body package="MQ-Browser">mqSetup	"Answer the MQ setup for this platform.	Settings are known for tests only, so return nil if tests are not loaded."	^#{MQTestConfiguration} ifDefinedDo: [:theClass | theClass current]</body><body package="MQ-Browser">registeredQueueManagers	"Retrieve QueueManager instances.	Return: Array of: MQ.QueueManager"	^QueueManager registry reject: [:each | each == 0 | each isNil]</body><body package="MQ-Browser">updateButtonStatus	"Button 'Connect' shall be enabled only if not connected.	Button 'Disconnect' shall be enabled only if connected.	Queue operation buttons shall be enabled if connected and queue name selected."	| isConnected |	isConnected := self connected value.	(self wrapperAt: #ConnectButton) isEnabled: isConnected not.	(self wrapperAt: #DisconnectButton) isEnabled: isConnected.	self updateQueueButtonStatus</body><body package="MQ-Browser">updateQueueButtonStatus	"Enable/disable buttons that trigger operations on the selected queue.	Enable if connected and queue name selected, else disable."	| enabled |	enabled := self connected value.	(self wrapperAt: #cbQueueName) isEnabled: enabled.	enabled := enabled &amp; self queueName value trimBlanks notEmpty.	#(#btnBrowseQueue #btnEmptyQueue #btnSendTest)		do: [:each | (self wrapperAt: each) isEnabled: enabled]</body></methods><methods><class-id>MQ.QueueBrowser</class-id> <category>updating</category><body package="MQ-Browser">updateForNewQueueName	"The queue name input field has changed. Add its value to the ComboList if not yet included."	| newSelectedQueueName qnames trimmed |	newSelectedQueueName := queueName value.	(trimmed := newSelectedQueueName trimBlanks) size &lt; newSelectedQueueName size		ifTrue: 			[queueName value: trimmed.			^self	"the #onChangeSend: definition will repeat the request with the then shortened value"].	self updateQueueButtonStatus.	newSelectedQueueName isEmpty ifTrue: [^self].	self browseQueue isNil		ifTrue: [^self	"failed to connect; do not add to ComboBox list"].	qnames := self queueNameList value.	(qnames includes: newSelectedQueueName)		ifFalse: [qnames add: newSelectedQueueName]</body></methods><methods><class-id>MQ.QueueBrowser</class-id> <category>interface opening</category><body package="MQ-Browser">postOpenWith: aBuilder 	"Derive connection data from existing Queue Managers to initialize connection input fields."	| vHolder allManagers aManager |	super postOpenWith: aBuilder.	self updateButtonStatus.	(allManagers := self registeredQueueManagers) isEmpty ifTrue: [^self].	aManager := allManagers first.	(vHolder := self hostName) value isEmpty ifTrue: [vHolder value: aManager host].	((vHolder := self portNumber) value isNil or: [vHolder value isZero]) 		ifTrue: [vHolder value: aManager port].	(vHolder := self serverChannel) value isEmpty 		ifTrue: [vHolder value: aManager channel]</body></methods><methods><class-id>MQ.QueueBrowser</class-id> <category>actions</category><body package="MQ-Browser">browseQueue	"Browse the selected queue and display its messages in the dataSet.	Return the number of messages found (nil if connection failed)"	| theQueue errorMsg messages msg |	self isConnected		ifFalse: 			[self connect.			self isConnected ifFalse: [^self]].	(theQueue := qm getBrowseQueue: self queueName value)		browseFirst;		noWait.	errorMsg := 			[theQueue ensureOpenQueue.			nil] on: MQQueueOpenError					do: 						[:ex |						| returnCode isBadQueueName |						returnCode := ex parameter.						isBadQueueName := returnCode reason = returnCode interfaceClass MQRC_UNKNOWN_OBJECT_NAME.						isBadQueueName							ifTrue: [ex return: ('&lt;1s&gt;:&lt;n&gt;&lt;2s&gt;' expandMacrosWith: ex class name with: ex description)]							ifFalse: [ex pass	"let the developer decide what to do"]].	messages := List new.	errorMsg isString		ifTrue: 			[self messageList2 list: messages.			Dialog warn: errorMsg.			^nil].	[(msg := theQueue getIncomingMessage) isNil] whileFalse: 			[messages add: msg.			theQueue browseNext].	theQueue close.	self messageList2 list: messages.	Transcript show: 'Messages: ' , messages size printString; cr.	^messages size</body><body package="MQ-Browser">connect	"Connect to the queue manager"	| hn pn result |	(hn := self hostName value) isEmpty		ifTrue: [^Dialog warn: 'You must enter a hostname to connect!'].	(pn := self portNumber value) = 0		ifTrue: 			["Zero is the default model of an Number input field, 			but MQ manager interface regards it as decent port number value 			and will fail with this setting (MQRC_Q_MGR_NOT_AVAILABLE).			Force input field back to nil."			self portNumber value: (pn := nil)].	(qm := QueueManager setDevelopment new: #remote threaded: false)		host: hn;		port: pn;		channel: self serverChannel value.	result := [qm connect] on: MQNotConnectedError				do: 					[:ex |					| msg |					msg := 'Connection failed: &lt;n&gt;&lt;1s&gt;' expandMacrosWith: ex description.					ex return: msg].	result isString ifTrue: [Dialog warn: result].	self connected value: self isConnected</body><body package="MQ-Browser">disconnect	"Disconnect from the queue manager."	self isConnected ifTrue: [qm disconnect].	self connected value: self isConnected</body><body package="MQ-Browser">emptyQueue	"Fetch all messages from the queue."	| m reader |	self isConnected		ifFalse: 			[self connect.			self isConnected ifFalse: [^self]].	(reader := qm getReceiverQueue: self queueName value) noWait.	[(m := reader getIncomingMessage) isNil] whileFalse.	reader close.	self browseQueue</body><body package="MQ-Browser">sendTestMessage	| sender msg |	self isConnected		ifFalse: 			[self connect.			self isConnected ifFalse: [^self]].	sender := qm getSenderQueue: self queueName value.	(msg := sender newAsynchronousMessage) data: 'This is a Test!'.	sender		put: msg;		close.	self browseQueue</body></methods><methods><class-id>MQ.QueueBrowser</class-id> <category>interface closing</category><body package="MQ-Browser">noticeOfWindowClose: aWindow	"The application is in the process of closing. Close queue and disconnect from the queue manager."	self disconnect.	super noticeOfWindowClose: aWindow</body></methods><methods><class-id>MQ.MQMessage</class-id> <category>printing</category><body package="MQ-Browser">correlIDString	"Answer the string contents of structure field 'CorrelId' 	(w/o null bytes or white space)"	^self correlationID asString trimMQTrailer</body></methods><methods><class-id>MQ.MQMessage</class-id> <category>user interface</category><body package="MQ-Browser">inspectorExtraAttributes	^Array 		with: (Tools.Trippy.DerivedAttribute label: 'message ID'				valueBlock: [self messageID])		with: (Tools.Trippy.DerivedAttribute label: 'correl ID'				valueBlock: [self correlationID])		with: (Tools.Trippy.DerivedAttribute label: 'data string'				valueBlock: [self shortDataString])</body></methods><methods><class-id>MQ.MQMessage</class-id> <category>printing</category><body package="MQ-Browser">messageIDString	^ self messageID asString</body><body package="MQ-Browser">putDateNiceString	"Answer the string contents of structure field 'PutDate',	with date token characters inserted for a nice date print string look,	e.g. '20040927' -&gt; '2004-09-27' "	| raw aStream |	(raw := self putDateString) isEmpty ifTrue: [^raw].	aStream := raw readStream.	^((String new: raw size + 10) writeStream)		nextPutAll: (aStream next: 4);		nextPut: $-;		nextPutAll: (aStream next: 2);		nextPut: $-;		nextPutAll: (aStream next: 2);		contents</body><body package="MQ-Browser">putDateString	"Answer the string contents of structure field 'PutDate' (w/o white space)"	^self putDate asString trimBlanks</body><body package="MQ-Browser">putDateTimeNiceString	"Answer the string contents of structure field 'PutDate'+'PutTime',	with time token characters inserted for a nice timestamp print string look,	e.g. '2004092715290526' -&gt; '2004-09-27 15:29:05.26' "	| raw aStream |	(raw := self putDateString) isEmpty ifTrue: [^raw].	raw := raw, self putTimeString.	aStream := raw readStream.	^((String new: raw size + 10) writeStream)		nextPutAll: (aStream next: 4);		nextPut: $-;		nextPutAll: (aStream next: 2);		nextPut: $-;		nextPutAll: (aStream next: 2);		space;		nextPutAll: (aStream next: 2);		nextPut: $:;		nextPutAll: (aStream next: 2);		nextPut: $:;		nextPutAll: (aStream next: 2);		nextPut: $.;		nextPutAll: aStream upToEnd;		contents</body><body package="MQ-Browser">putTimeString	"Answer the string contents of structure field 'PutTime' (w/o white space)"	^self putTime asString trimBlanks</body><body package="MQ-Browser">shortDataString	"Answer data bytes as String, limited to maximum length"	| bytes maxLength |	(bytes := self data) isNil ifTrue: [^'nil'].	(bytes allSatisfy: [:byte | byte = 0])		ifTrue: [^'(ByteArray new: ', bytes size printString, ')'].	bytes size &gt; (maxLength := 1024) 		ifTrue: [bytes := (bytes copyFrom: 1 to: maxLength) , #[46 46 46]].	^bytes asString</body><body package="MQ-Browser">userIdentifierString	"Answer the string contents of structure field 'UserIdentifier' (w/o white space)"	^self userIdentifier asString trimBlanks</body></methods><methods><class-id>MQ.QueueBrowser class</class-id> <category>interface specs</category><body package="MQ-Browser">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'MQ-Browser' 			#bounds: #(#{Graphics.Rectangle} 640 512 1209 964 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 8 13 ) 					#name: #lblQueueName 					#label: 'Queue-Name:' ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.Rectangle} 108 11 475 35 ) 					#name: #cbQueueName 					#model: #queueName 					#helpText: 'Enter or select a queue name' 					#isReadOnly: false 					#comboList: #queueNameList ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 481 8 565 38 ) 					#name: #btnBrowseQueue 					#flags: 40 					#model: #browseQueue 					#helpText: 'Browse the selected queue' 					#label: 'Browse ...' 					#defaultable: true ) 				#(#{UI.DataSetSpec} 					#properties: #(#{UI.PropertyListDictionary} #showHorizontalLines true #allowColumnResizing true #showVerticalLines true #allowColumnReordering false #showLineNumbers true ) 					#layout: #(#{Graphics.LayoutFrame} 8 0 46 0 -6 1 -133 1 ) 					#name: #Dataset1 					#model: #messageList2 					#menu: #listMenu 					#columns: #(						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting true #labelFromApplication false ) 							#labelIsImage: false 							#width: 30 							#rendererType: #rowSelector 							#editorType: #rowSelector 							#noScroll: true ) 						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting true #labelFromApplication false ) 							#model: #'selMsg messageIDString' 							#label: 'MsgID' 							#labelFont: #default 							#labelIsImage: false 							#width: 80 							#rendererType: #Text 							#editorType: #None 							#font: #fixed 							#noScroll: false ) 						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting true #labelFromApplication false ) 							#model: #'selMsg correlIDString' 							#label: 'Correl ID' 							#labelFont: #default 							#labelIsImage: false 							#width: 80 							#rendererType: #Text 							#editorType: #None 							#noScroll: false ) 						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting true #labelFromApplication false ) 							#model: #'selMsg putDateTimeNiceString' 							#label: 'Put Date' 							#labelFont: #default 							#labelIsImage: false 							#width: 80 							#rendererType: #Text 							#editorType: #None 							#noScroll: false ) 						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting true #labelFromApplication false ) 							#model: #'selMsg userIdentifierString' 							#label: 'User' 							#labelFont: #default 							#labelIsImage: false 							#width: 60 							#rendererType: #Text 							#editorType: #None 							#noScroll: false ) 						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting true #labelFromApplication false ) 							#model: #'selMsg shortDataString' 							#label: 'Data' 							#labelFont: #default 							#labelIsImage: false 							#width: 400 							#rendererType: #Text 							#editorType: #None 							#font: #systemDefault 							#noScroll: false ) ) 					#labelsAsButtons: false ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 331 0 -122 1 452 0 -100 1 ) 					#name: #btnSendTest 					#flags: 40 					#model: #sendTestMessage 					#helpText: 'Send a test message to the selected queue' 					#label: 'Send Testmessage' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 459 0 -122 1 550 0 -100 1 ) 					#name: #btnEmptyQueue 					#flags: 40 					#model: #emptyQueue 					#helpText: 'Remove all messages from the queue' 					#label: 'Empty queue' 					#defaultable: true ) 				#(#{UI.DividerSpec} 					#layout: #(#{Graphics.LayoutFrame} 8 0 -98 1 -8 1 -94 1 ) 					#name: #Divider1 ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 7 0 -83 1 ) 					#name: #lblHostname 					#label: 'Host:' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 110 0 -84 1 386 0 -62 1 ) 					#name: #txtHostname 					#model: #hostName ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 7 0 -55 1 ) 					#name: #lblPortNumber 					#label: 'Port:' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 110 0 -56 1 385 0 -34 1 ) 					#name: #txtPortNumber 					#model: #portNumber 					#type: #number 					#formatString: '0;[Red]-0' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 7 0 -29 1 ) 					#name: #lblServerChannel 					#label: 'Server Channel:' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 110 0 -30 1 385 0 -8 1 ) 					#name: #txtServerChannel 					#model: #serverChannel ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 428 0 -87 1 554 0 -54 1 ) 					#name: #ConnectButton 					#model: #connect 					#helpText: 'You are NOT connected right now!' 					#label: 'Connect' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 428 0 -51 1 554 0 -18 1 ) 					#name: #DisconnectButton 					#flags: 40 					#model: #disconnect 					#helpText: 'You are connected!' 					#label: 'Disconnect' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>MQ.QueueBrowser class</class-id> <category>resources</category><body package="MQ-Browser">listMenu	"Tools.MenuEditor new openOnClass: self andSelector: #listMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: '&amp;Inspect' 				#value: #inspectMessage 				#enablementSelector: #isMessageSelected 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #inspect ) 				#helpText: 'Open an Inspector on the selected message' ) 			#(#{UI.MenuItem} 				#rawLabel: 'Inspect &amp;All' 				#value: #inspectAllMessages 				#enablementSelector: #hasMessages 				#helpText: 'Open an Inspector with all messages' ) ) #(2 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>actions</category><body package="MQ-Browser">openMQBrowser	"Open the WebSphere MQ Queue Browser."	&lt;menuItem: 'MQ-Browser'		icon: nil		nameKey: nil		menu: #(#menuBar #tools )		position: 100.0&gt;	MQ.QueueBrowser open</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>VisualLauncher</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuBar toolBar textCollector transcriptView statusBar </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>Tools-Misc</package></attributes></class><class><name>MQMessage</name><environment>MQ</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>messageHndl data targetQueue reportOptions </inst-vars><class-inst-vars>msgTypeNumber </class-inst-vars><imports></imports><category>MQ-Domain</category><attributes><package>MQ-Domain</package></attributes></class></st-source>