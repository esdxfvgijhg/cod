<?xml version="1.0"?><st-source><!-- Name: FTPNotice: Copyright 1999-2017 Cincom Systems, Inc.  All rights reserved.Comment: FTPSupport provides a complete File Transfer Protocol client implementation based on RFC959 and RFC1123.DbIdentifier: bear73DbTrace: 500679DbUsername: tkoganDbVersion: 8.3 - 1DevelopmentPrerequisites: #(#(#any 'NetClientBase' ''))PackageName: FTPParcel: #('FTP')ParcelName: FTPPrerequisiteParcels: #(#('NetClientBase' ''))PrintStringCache: (8.3 - 1,tkogan)Version: 8.3 - 1Date: 2:30:30 PM April 28, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (apr17.3) of April 28, 2017 on April 28, 2017 at 2:30:30 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>FTPSignal</name><environment>Net</environment><super>Net.NetError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-FTP-Support</category><attributes><package>FTP</package></attributes></class><comment><class-id>Net.FTPSignal</class-id><body>FTPSignal is the abstract class for all Ftp signals. Instance Variables:</body></comment><class><name>FTPNoSocketSignal</name><environment>Net</environment><super>Net.FTPSignal</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-FTP-Support</category><attributes><package>FTP</package></attributes></class><comment><class-id>Net.FTPNoSocketSignal</class-id><body>This exception is signaled if FTP client does not have active socket connection to FTP server at the time of the request. It is application's responsibility to catch this signal. A possible strategy might be to send connect message to FTP client and retry the requestInstance Variables:</body></comment><class><name>FTPSocketAccessor</name><environment>Net</environment><super>OS.SocketAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>ftpConn callback </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-FTP-Support</category><attributes><package>FTP</package></attributes></class><comment><class-id>Net.FTPSocketAccessor</class-id><body>This class provides additional logic for FTP-based data transfer. FTP data transferinvolves two socket connections -- control and data connections; both should bemonitored during data transfer.Instance Variables:	ftpConn	&lt;FTPClient&gt;	An instance of FTP Client representing the control connection</body></comment><class><name>FTPPermSignal</name><environment>Net</environment><super>Net.FTPSignal</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-FTP-Support</category><attributes><package>FTP</package></attributes></class><comment><class-id>Net.FTPPermSignal</class-id><body>FTPPermSignal is signaled when the FTPProtocolInterpreter receives a permanent error reply from a server.  It is analagous to the Permanent Negative Completion reply documented in the FTPResponse class comment.</body></comment><class><name>FTPPreliminaryReply</name><environment>Net</environment><super>Net.FTPSignal</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-FTP-Support</category><attributes><package>FTP</package></attributes></class><comment><class-id>Net.FTPPreliminaryReply</class-id><body>FTPPreliminaryReply is signaled when the FTPProtocolInterpreter receives a preliminary reply from the server when the FTPProtocolInterpreter is not expecting a preliminary reply.  Instance Variables:</body></comment><class><name>FTPProtocolInterpreter</name><environment>Net</environment><super>Net.NetProtocolInterpreter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>socket stream passiveServer mutex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-FTP-Support</category><attributes><package>FTP</package></attributes></class><comment><class-id>Net.FTPProtocolInterpreter</class-id><body>FTPProtocolInterpreter communicates with the FTP server via the control and data connection.  It has knowledge of the connection via the socket instance variable.  It also handles server transfers on the stream instance variable.  FTPProtocolInterpreter receives server replies (as an FTPResponse), handles them where appropriate, and passes replies to the FTPClient where appropriate.  Instance Variables:	socket	&lt;SocketAccessor&gt;	socket connection to the serverr	stream	&lt;ExternalReadStream&gt;	transfer stream	passiveServer	&lt;Boolean&gt;	boolean to determine method of transfer	controlReadProcess	&lt;Process&gt;	description of variable's function	dataTransferProcess	&lt;Process&gt;	description of variable's function	abortingProcess	&lt;Process&gt;	description of variable's function	controlPromises	&lt;Dictionary&gt;	description of variable's function	mutex	&lt;Semaphore&gt;	description of variable's functionClass Variables:	CrLf	&lt;ClassOfVariable&gt;	description of variable''s function</body></comment><class><name>FTPConnectionSignal</name><environment>Net</environment><super>Net.FTPSignal</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-FTP-Support</category><attributes><package>FTP</package></attributes></class><comment><class-id>Net.FTPConnectionSignal</class-id><body>Signaled when a lack of connection is detected.Instance Variables:</body></comment><class><name>FTPTransientReply</name><environment>Net</environment><super>Net.FTPSignal</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-FTP-Support</category><attributes><package>FTP</package></attributes></class><comment><class-id>Net.FTPTransientReply</class-id><body>FTPTransientReply is signaled by the FTPProtocolInterpreter when the command was not accepted by the server and the requested action did not take place.  However, the error condition is temporary and the action may be requested again.Instance Variables:</body></comment><class><name>FtpURL</name><environment>Net</environment><super>OS.URLwithAuthority</super><private>false</private><indexed-type>none</indexed-type><inst-vars>passiveMode user password </inst-vars><class-inst-vars>userAddress </class-inst-vars><imports></imports><category>Net-Resources</category><attributes><package>FTP</package></attributes></class><comment><class-id>Net.FtpURL</class-id><body>FtpURL implements FTP URL as defined in RFC2396 (URL). It is responsible for parsing FTP url string and publishes methods providing access to FTP file storages. FtpURL is designed to resemble Filename class, so it implements many of the methods providing directory access and stream creation.Instance Variables:	host	&lt;String&gt;	FTP server host name	port	&lt;Integer&gt;	FTP server port number	user	&lt;String&gt;	User name	password	&lt;String&gt;	Password</body></comment><class><name>FTPClient</name><environment>Net</environment><super>Net.NetClient</super><private>false</private><indexed-type>none</indexed-type><inst-vars>binaryBlockSize transferOffset delayedResponse finalResponse commandInProgress unixServerTimestamp unixServerTimestampBlock features useUtf8 </inst-vars><class-inst-vars>unixServerTimestampBlock useUtf8 </class-inst-vars><imports></imports><category>Net-FTP-Support</category><attributes><package>FTP</package></attributes></class><comment><class-id>Net.FTPClient</class-id><body>The combination of FTPClient, FTPProtocolInterpreter, FTPResponse is a complete File Transfer Protocol client implementation based on RFC959 and RFC1123.  FTPClient contains methods to do server transfers and other commands.  File Transfer Protocol is a protocol to enable two remote computers to share their file systems.  This is done with a two connections.  A control connection and a data connection.  The control connection between the client and the maintains synchronization with the use of command-reply structure.  Commands are sent as strings on the control connection.  Each command issued from the client to the server on the control connection returns a reply from the server.  Data connections are used for transfering of files between the file systems.  Note that the data connection may be used in either direction and that the data connection need not exist all of the time.In this client implementation, the client does not have direct knowledge of how its control and data connections are handled.  That is done by FTPProtocolInterpreter.  The FTPClient keeps track of the FTPUser and is the API to the protocol.  The FTP-Restart protocol contains methods for restarting previous FTP transfers which have failed.  This is done with the use of Smalltalk Streams, and not with markers (the way that RFC959 specifies).  Only the defaul modes of transfer (Stream) and structure (File) are used in this implementation.  The client also supports "Feature negotiation mechanism for the File Transfer Protocol" http://tools.ietf.org/html/rfc2389Instance Variables	features &lt;Collection of: String &gt;  list all extension commands, or extended mechanisms, that the FTP server supports	useUtf8 &lt;Boolean&gt; if the option is true and the server supports utf8 encoding the commands will be sent utf8 encoded and replies decoded	binaryBlockSize	&lt;Number&gt;	holds a Number that determines the amount of bytes transfered at a time	transferOffset	&lt;Number&gt;	used as the server marker at which file transfer should be restarted	delayedResponse &lt;FTPResponse&gt; delayed server response	finalResponse &lt;FTPResponse&gt; final server response	unixServerTimestamp &lt;Timestamp&gt; the timestamp returned by #unixServerTimestampBlock	unixServerTimestampBlock &lt;BlockClosure&gt; This block should return a reasonable approximation of the current time on the server. This timestamp is needed to correctly interpret some of the time related file attributes received from the server. The protocol doesn't provide any indication of the timezone that these values are related to, so the default block simply assumes that it's the same as the client's. This block allows overriding this default for specific cases where the correct time of the server can be deduced via other means, e.g. if you know that the server clock is 5 hours behind UTC, the block body can be: 'Timestamp nowUTC - 5 hours'.Class Variables	unixServerTimestampBlock &lt;BlockClosure&gt; default value is "Timestamp now"	useUtf8 &lt;Boolean&gt; default for utf8 encoding option. The default value is true	</body></comment><class><name>FTPIntermediateReply</name><environment>Net</environment><super>Net.FTPSignal</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-FTP-Support</category><attributes><package>FTP</package></attributes></class><comment><class-id>Net.FTPIntermediateReply</class-id><body>FTPIntermediateReply is signaled when the FTPProtocolInterpreter receives a intermediate reply from the server.  It is trapped in the FTPClient and used to execute a series of Ftp commands.  Instance Variables:</body></comment><class><name>FTPChallenge</name><environment>Net</environment><super>Net.FTPSignal</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-FTP-Support</category><attributes><package>FTP</package></attributes></class><comment><class-id>Net.FTPChallenge</class-id><body>FTPChallenge is signaled when the FTPProtocolInterpreter discovers that socket is no longer active and is used to restart client connection.  Instance Variables:</body></comment><class><name>FTPResponse</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>code messageStream stream </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-FTP-Support</category><attributes><package>FTP</package></attributes></class><comment><class-id>Net.FTPResponse</class-id><body>The File Transfer Protocol defines that each request to the server will have a response.  The response syntax is a three digit number followed by an english message.  Here is an excerpt from RFC959 exlaining the five different types of responses.            1yz   Positive Preliminary reply               The requested action is being initiated; expect another               reply before proceeding with a new command.  (The               user-process sending another command before the               completion reply would be in violation of protocol; but               server-FTP processes should queue any commands that               arrive while a preceding command is in progress.)  This               type of reply can be used to indicate that the command               was accepted and the user-process may now pay attention               to the data connections, for implementations where               simultaneous monitoring is difficult.  The server-FTP               process may send at most, one 1yz reply per command.            2yz   Positive Completion reply               The requested action has been successfully completed.  A               new request may be initiated.            3yz   Positive Intermediate reply               The command has been accepted, but the requested action               is being held in abeyance, pending receipt of further               information.  The user should send another command               specifying this information.  This reply is used in               command sequence groups.            4yz   Transient Negative Completion reply               The command was not accepted and the requested action did               not take place, but the error condition is temporary and               the action may be requested again.  The user should               return to the beginning of the command sequence, if any.               It is difficult to assign a meaning to "transient",               particularly when two distinct sites (Server- and               User-processes) have to agree on the interpretation.               Each reply in the 4yz category might have a slightly               different time value, but the intent is that the               user-process is encouraged to try again.  A rule of thumb               in determining if a reply fits into the 4yz or the 5yz               (Permanent Negative) category is that replies are 4yz if               the commands can be repeated without any change in               command form or in properties of the User or Server               (e.g., the command is spelled the same with the same               arguments used; the user does not change his file access               or user name; the server does not put up a new               implementation.)            5yz   Permanent Negative Completion reply               The command was not accepted and the requested action did               not take place.  The User-process is discouraged from               repeating the exact request (in the same sequence).  Even               some "permanent" error conditions can be corrected, so               the human user may want to direct his User-process to               reinitiate the command sequence by direct action at some               point in the future (e.g., after the spelling has been               changed, or the user has altered his directory status.)         The following function groupings are encoded in the second         digit:            x0z   Syntax - These replies refer to syntax errors,                  syntactically correct commands that don't fit any                  functional category, unimplemented or superfluous                  commands.            x1z   Information -  These are replies to requests for                  information, such as status or help.            x2z   Connections - Replies referring to the control and                  data connections.            x3z   Authentication and accounting - Replies for the login                  process and accounting procedures.            x4z   Unspecified as yet.            x5z   File system - These replies indicate the status of the                  Server file system vis-a-vis the requested transfer or                  other file system action.         The third digit gives a finer gradation of meaning in each of         the function categories, specified by the second digit.  The         list of replies below will illustrate this.  Note that the text         associated with each reply is recommended, rather than         mandatory, and may even change according to the command with         which it is associated.  The reply codes, on the other hand,         must strictly follow the specifications in the last section;         that is, Server implementations should not invent new codes for         situations that are only slightly different from the ones         described here, but rather should adapt codes already defined.Instance Variables	code	&lt;String&gt;	response code	messageStream	&lt;Stream&gt;	a stream with the parsed response 	stream	&lt;SimpleScanner&gt;	stream the response is read from</body></comment><class><name>FTPSettings</name><environment>Net</environment><super>Net.NetPISettings</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>anonymousLoginPassword passiveMode </class-inst-vars><imports></imports><category>Net-FTP-Support</category><attributes><package>FTP</package></attributes></class><comment><class-id>Net.FTPSettings</class-id><body>FTPSettings represents FTP PI options</body></comment><class><name>MacFTPProtocolInterpreter</name><environment>Net</environment><super>Net.FTPProtocolInterpreter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-FTP-Support</category><attributes><package>FTP</package></attributes></class><comment><class-id>Net.MacFTPProtocolInterpreter</class-id><body>MacFTPProtocolInterpreter implements Macintosh type TCP socket commands</body></comment><class><name>FTPUser</name><environment>Net</environment><super>Net.NetUser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-FTP-Support</category><attributes><package>FTP</package></attributes></class><comment><class-id>Net.FTPUser</class-id><body>Read the comment for NetUser.  FTPUser adds the account instance variable.  Account is used by the Ftp protocol.  Instance Variables:	account	&lt;String&gt;	holds an account name, where the account is on the ftp server</body></comment><shared-variable><name>PermError</name><environment>Net.FTPClient</environment><private>true</private><constant>false</constant><category>obsolete</category><initializer>nil</initializer><attributes><package>FTP</package></attributes></shared-variable><shared-variable><name>ReplyError</name><environment>Net.FTPClient</environment><private>true</private><constant>false</constant><category>obsolete</category><initializer>nil</initializer><attributes><package>FTP</package></attributes></shared-variable><shared-variable><name>DebugLevels</name><environment>Net.FTPClient</environment><private>false</private><constant>false</constant><category>debugging</category><initializer>Core.Set new</initializer><attributes><package>FTP</package></attributes></shared-variable><shared-variable><name>ChallengeError</name><environment>Net.FTPClient</environment><private>true</private><constant>false</constant><category>obsolete</category><initializer>nil</initializer><attributes><package>FTP</package></attributes></shared-variable><shared-variable><name>TempError</name><environment>Net.FTPClient</environment><private>true</private><constant>false</constant><category>obsolete</category><initializer>nil</initializer><attributes><package>FTP</package></attributes></shared-variable><shared-variable><name>ProtocolError</name><environment>Net.FTPClient</environment><private>true</private><constant>false</constant><category>obsolete</category><initializer>nil</initializer><attributes><package>FTP</package></attributes></shared-variable><shared-variable><name>CrLf</name><environment>Net.FTPClient</environment><private>true</private><constant>false</constant><category>statics</category><initializer>nil</initializer><attributes><package>FTP</package></attributes></shared-variable><shared-variable><name>Whitespace</name><environment>Net.FTPResponse</environment><private>false</private><constant>false</constant><category>defaults</category><attributes><package>FTP</package></attributes></shared-variable><shared-variable><name>CrLf</name><environment>Net.MacFTPProtocolInterpreter</environment><private>false</private><constant>false</constant><category>const</category><initializer>Array new: 5</initializer><attributes><package>FTP</package></attributes></shared-variable><shared-variable><name>CrLf</name><environment>Net.FTPProtocolInterpreter</environment><private>true</private><constant>false</constant><category>statics</category><initializer>nil</initializer><attributes><package>FTP</package></attributes></shared-variable><methods><class-id>Net.FTPSignal</class-id> <category>printing</category><body package="FTP">defaultMessageText	^super defaultMessageText, '\(' withCRs, parameter printString, ')'</body></methods><methods><class-id>Net.FTPSignal class</class-id> <category>handling ftp responses</category><body package="FTP">handleResponse: resp	"trigger exceptions for all responses but 2xx (success) "	resp isSuccess 		ifFalse: [			resp isChallenge ifTrue: [ FTPChallenge signalWith: resp].			resp isPreliminaryReply ifTrue: [ FTPPreliminaryReply signalWith: resp].			resp isTransientError ifTrue: [ FTPTransientReply raiseRequestWith: resp errorString: resp printString].			resp isPermanentError ifTrue: [ FTPPermSignal raiseWith: resp errorString: resp printString]].	^resp</body></methods><methods><class-id>Net.FTPSocketAccessor</class-id> <category>accessing</category><body package="FTP">callback	^callback</body><body package="FTP">callback: aBlock	callback := aBlock</body><body package="FTP">ftpConn	^ftpConn</body><body package="FTP">ftpConn: aValue	ftpConn := aValue</body></methods><methods><class-id>Net.FTPSocketAccessor</class-id> <category>private</category><body package="FTP">close	| res |	super close.	self callback notNil 		ifTrue: 			[[res := callback value]				on: FTPSignal 				do: [:ex | ex return]].	^res</body><body package="FTP">privateReadInto: buffer startingAt: index for: count 	"buffer is a byte-object, the place where IO is performed. 	index is a SmallInteger, the starting-point in the buffer. 	count is a SmallInteger, the number of bytes to be read."	"Returns a SmallInteger, which is the count of the bytes read."	"WouldBlock is a potential error condition."	&lt;primitive: 679 errorCode: _ec&gt;	(self class restartableError: _ec)		ifTrue: 			[ftpConn notNil ifTrue: [ftpConn pollResponses].			self readWaitWithTimeoutMs: self readPauseInterval.			^OSErrorHolder needRetrySignal raise].	^self reportError: _ec</body></methods><methods><class-id>Net.FTPProtocolInterpreter</class-id> <category>connection management</category><body package="FTP">connectToHost: aHostName port: aNumber	| port address |	port := aNumber isNil ifTrue: [ self defaultPortNumber ] ifFalse: [ aNumber]. 	address := IPSocketAddress hostName: aHostName port: port.	self socket:( SocketAccessor				family: address domainCode				type: SocketAccessor sockStream).	self socket connectTo: address.	self stream: (ExternalReadAppendStream on: self socket asExternalConnection) lineEndCRLF.	[self getResponse] on: FTPPreliminaryReply do: [ :ex | ex retry ].	^self</body><body package="FTP">disconnect	self closeConnection</body></methods><methods><class-id>Net.FTPProtocolInterpreter</class-id> <category>accessing</category><body package="FTP">closed	^self socket == nil or: [ self socket isActive not ]</body><body package="FTP">defaultPortNumber	^SocketAccessor IPPORT_FTP</body><body package="FTP">mutex	mutex == nil ifTrue: [mutex := Semaphore forMutualExclusion].	^mutex</body><body package="FTP">passiveServer		^passiveServer</body><body package="FTP">passiveServer: aBoolean	passiveServer := aBoolean</body><body package="FTP">setServerActive	"Use passive or active mode for data transfers.  With a false argument,	use the normal PORT mode.  With a true argument, use the PASV command and	the server will provide a port on which it is listening."	self passiveServer: false</body><body package="FTP">setServerPassive	"Use passive or active mode for data transfers.  With a false argument,	use the normal PORT mode.  With a true argument, use the PASV command and	the server will provide a port on which it is listening."	self passiveServer: true</body><body package="FTP">socket 	^socket</body><body package="FTP">socket: aSocket	socket := aSocket</body><body package="FTP">stream	^stream</body><body package="FTP">stream: aStream	stream := aStream</body><body package="FTP">tlsConnectionClass	^self error: (#ThatOptionNotSupported &lt;&lt; #net &gt;&gt; 'That option is not supported.')</body></methods><methods><class-id>Net.FTPProtocolInterpreter</class-id> <category>private</category><body package="FTP">closeConnection	stream notNil ifTrue: [stream close].	socket notNil ifTrue: [socket close]</body><body package="FTP">parseResponse	"get a response"	^FTPResponse readFrom: self stream</body><body package="FTP">privatePollResponse	"Answer next response if available, otherwise answer nil without waiting. We first check our internal buffer with #basicAtEnd, and then the operating system buffer with #readWaitWithTimeoutMs:. A zero argument ensures we don't block."	^socket notNil 		ifTrue: 			[(stream noPendingBufferredData and: [socket readWaitWithTimeoutMs: 0]) 				ifFalse: [self parseResponse]]		ifFalse: [nil]</body><body package="FTP">putCommand: aString 	self class log: [((#put1s &lt;&lt; #net &gt;&gt; '*put*  &lt;1s&gt;')			expandMacrosWith: (self sanitize: aString , CrLf))] level: #FTPClient.	self socket isActive			ifFalse: 			[FTPProtocolInterpreter log: [(#ExceptionSocketIsNotActive &lt;&lt; #net &gt;&gt; '*exception* socket is not active')] level: #FTPException.			FTPNoSocketSignal raise ].		[self socket writeWaitWithTimeoutMs: 200 ] 		whileTrue: [self pollResponse].	self stream nextPutAll: aString; cr; commit</body><body package="FTP">sanitize: aString 	"Internal"	| s |	s := aString copy.	((s copyFrom: 1 to: (5 min: aString size))		sameAs: 'pass ')		ifTrue: 			[| i |			i := s size.			[i &gt; 5 and: [CrLf includes: (s at: i - 1)]]				whileTrue: [i := i - 1].			s := (s copyFrom: 1 to: 5)						, ((String new: i - 5)								atAllPut: $*) , (s copyFrom: i + 1 to: s size)].	^s</body></methods><methods><class-id>Net.FTPProtocolInterpreter</class-id> <category>protocol commands</category><body package="FTP">abort	"Abort a file transfer "	| line |	self class log: ['*put*  ABOR'] level: #FTPClient.	self mutex critical:		[line := 'ABOR' , CrLf.		self socket			sendTo: self socket getPeer			buffer: line			start: 1			for: line size			flags: SocketAccessor msgOob].	^self getResponse</body><body package="FTP">makeport	"Create a new socket and send a PORT 	command for it."	| sock resp |	sock := FTPSocketAccessor newTCP.	sock listenFor: 1.	(resp := self sendport: (self socket getName hostAddress) with: sock getName port) isSuccess		ifFalse: [ self class permSignal raiseWith: resp. ].	^sock</body><body package="FTP">pollResponse" Answer next response if one is waiting, nil otherwise "		| resp |	^(resp := self privatePollResponse) notNil		ifTrue: [FTPSignal handleResponse: resp]		ifFalse: [ nil ]</body><body package="FTP">sendCommand: aString 	"Send a command and return the response. Expect a successful response, if not generate an exception."	^self putCommand: aString; getResponse</body><body package="FTP">sendport: aHostAddress with: aPort 	"Send a PORT command with the current 	[sic] host and 	the given port number."	| bytes cmd |	bytes := aHostAddress, (ByteArray with: aPort // 256 with: aPort \\ 256).	cmd := 'PORT '.	bytes do: [:byte | cmd := cmd , byte printString]		separatedBy: [cmd := cmd , ','].	^self sendCommand: cmd</body></methods><methods><class-id>Net.FTPProtocolInterpreter</class-id> <category>responses</category><body package="FTP">getResponse	"Obtains and answers an instance of FTPResponse "	^FTPSignal handleResponse: self parseResponse</body></methods><methods><class-id>Net.FTPProtocolInterpreter</class-id> <category>initialize-release</category><body package="FTP">initialize	FTPSettings passiveMode		ifTrue: [ self setServerPassive]		ifFalse: [self setServerActive].</body></methods><methods><class-id>Net.FTPProtocolInterpreter class</class-id> <category>signals</category><body package="FTP">challengeSignal	^FTPChallenge</body><body package="FTP">connectionSignal	^FTPConnectionSignal</body><body package="FTP">intermediateSignal	^FTPIntermediateReply</body><body package="FTP">permErrorSignal	^FTPPermSignal</body><body package="FTP">permSignal	^FTPPermSignal</body><body package="FTP">preliminarySignal		^FTPPreliminaryReply</body><body package="FTP">transientErrorSignal	^FTPTransientReply</body></methods><methods><class-id>Net.FTPProtocolInterpreter class</class-id> <category>initialization</category><body package="FTP">initialize	"self initialize"		self initializeSequences.	self initializeSignals.	self registerToDebug</body><body package="FTP">initializeSequences	CrLf := String with: Character cr with: Character lf.</body><body package="FTP">initializeSignals	"self initializeSignals"	"unexpected [123]xx reply"	FTPPreliminaryReply		notifierString: (#x1xxReply &lt;&lt; #net &gt;&gt; '1xx reply');		nameClass: self message: #preliminarySignal.	FTPIntermediateReply		notifierString: (#x3xxReply &lt;&lt; #net &gt;&gt; '3xx reply');		nameClass: self message: #intermediateSignal.	FTPTransientReply 		notifierString: (#x4xxError &lt;&lt; #net &gt;&gt; '4xx error');		nameClass: self message: #transientErrorSignal.	FTPPermSignal		notifierString: (#x5xxError &lt;&lt; #net &gt;&gt; '5xx error'); 		nameClass: self message: #permSignal.	FTPChallenge		notifierString: (#needToMakeConnection &lt;&lt; #net &gt;&gt; 'need to make connection'); 		nameClass: self message: #challengeSignal.			FTPConnectionSignal		notifierString: (#needToMakeConnection &lt;&lt; #net &gt;&gt; 'need to make connection'); 		nameClass: self message: #connectionSignal.</body></methods><methods><class-id>Net.FTPProtocolInterpreter class</class-id> <category>debugging</category><body package="FTP">debugLabelsAndValues	^OrderedCollection new		add: ((#FTPClientCommands &lt;&lt; #net &gt;&gt; 'FTPClient Commands')-&gt;#FTPClient);		add: ((#FTPResponses &lt;&lt; #net &gt;&gt; 'FTPResponses')-&gt;#FTPResponse);		add: ((#FTPTesting &lt;&lt; #net &gt;&gt; 'FTP Testing')-&gt;#FTPTest);		add: ((#FTPExceptions &lt;&lt; #net &gt;&gt; 'FTPExceptions')-&gt;#FTPException);		yourself</body><body package="FTP">menuItemName	^(#FTPMessages &lt;&lt; #net &gt;&gt; 'FTP Messages')</body></methods><methods><class-id>Net.FTPProtocolInterpreter class</class-id> <category>instance creation</category><body package="FTP">connectToHost: aHostName port: aNumber	^self new connectToHost: aHostName port: aNumber</body></methods><methods><class-id>Net.FTPProtocolInterpreter class</class-id> <category>default values</category><body package="FTP">settings	^FTPSettings</body></methods><methods><class-id>Net.FTPProtocolInterpreter class</class-id> <category>class initialization</category><body package="FTP">obsolete		self unregisterFromDebug.	super obsolete.</body></methods><methods><class-id>Net.FTPTransientReply class</class-id> <category>testing</category><body package="FTP">mayResume	^true</body></methods><methods><class-id>Net.FtpURL</class-id> <category>private</category><body package="FTP">beCurrentDirectoryFor: anFtpUrl with: aClient 	"Opportunistic code: Try changing directory using full path. If this fails, try segment-by-segment descent."	[aClient setCurrentDirectory: anFtpUrl filePathString] on: FTPPermSignal		do: 			[:ex | 						[1 to: anFtpUrl path size				do: [:ind | aClient setCurrentDirectory: (anFtpUrl pathAt: ind)]] 					on: FTPPermSignal					do: [:_ | ex pass	"fail with original exception"]]</body><body package="FTP">client	| effectiveUser effectivePassword client |	user == nil		ifTrue:			[effectiveUser := 'anonymous'.			effectivePassword := self class emailAddress]		ifFalse:			[effectiveUser := user.			effectivePassword := password].	client := FTPClient connectToHost: host port: port.	[client login: effectiveUser passwd: effectivePassword ]		on: FTPChallenge 		do: [ :ex |				(self handleChallenge: ex parameter for: client) 					ifTrue: [ ex return ]					ifFalse: [ ex pass ] ].	self passiveMode ifTrue: [ client setServerPassive ].	^client</body><body package="FTP">copyFromFTP: aURI	"Copied from superclass, but we could eventually optimize this to do server to server transfers."	self writeStreamDo: [:dest |		aURI readStreamDo: [:src :parms |			[src atEnd] whileFalse:				[dest nextPutAll: (src nextAvailable: 1024)]]]</body><body package="FTP">fileDirectoryDo: aDyadicBlock 	" Position to current directory and evaluate dyadic block. First argument is canonicalized uri, the second is FTP client used in operations "		| client canonical |	^self safelyExecuteBlock: 		[client := self client.		canonical := self canonicalize.		self 			beCurrentDirectoryFor: canonical directory			with: client.		aDyadicBlock 			value: canonical			value: client]</body><body package="FTP">fileDirectoryDoAndClose: aDyadicBlock 	" Same as fileDirectoryDo: but ensure client is closed at the end "		^self fileDirectoryDo: 		[:canonicalUri :client | 		[aDyadicBlock value: canonicalUri value: client] 			ensure: [client close]]</body><body package="FTP">handleChallenge: aResponse for: client	| str |	aResponse needAccountForLogin		ifTrue: 			[ (str := Dialog 						request: ((#ProvideLoginAccountFor &lt;&lt; #net &gt;&gt; 'Please, provide login account for &lt;1s&gt;')			expandMacrosWith: client hostName)) isEmpty not				ifTrue: [  client account: str. ^true]].	aResponse needPassword		ifTrue: 			[(str := SimplePasswordDialog new						request: ((#ProvideLoginPasswordFor &lt;&lt; #net &gt;&gt; 'Please, provide login password for &lt;1s&gt;')			expandMacrosWith: client hostName)						initialAnswer: ''						onCancel: []) notNil				ifTrue: [ client pass: str. ^true ]].	^false</body><body package="FTP">indexFor: aClient	| index |	path last = ''		ifTrue: [index := path size-1]		ifFalse: [index := path size].	1 to: index-1 do: [:i | aClient setCurrentDirectory: (self pathAt: i)].	^index</body><body package="FTP">passwordSameAs: aURI	|  p1 p2 |	p1 := self password ifNil: [ String new].	p2 := aURI password ifNil: [ String new].	^p1 = p2 or: [ ('anonymous' match: self user) and: [ p1 match: p2 ]]</body><body package="FTP">simpleDirectory	^super directory</body><body package="FTP">userSameAs: aURL	| us1 us2 |	us1 := self user ifNil: [ String new].	us2 := aURL user ifNil: [ String new].	^us1 match: us2</body></methods><methods><class-id>Net.FtpURL</class-id> <category>accessing</category><body package="FTP">asString	| str |	str := (String new: 64) writeStream.	self printProtocolOn: str.	self printUserOn: str.	self printAuthorityOn: str.	^str contents</body><body package="FTP">passiveMode	passiveMode isNil 		ifTrue: [ passiveMode := self class defaultPassiveMode ].	^passiveMode</body><body package="FTP">passiveMode: aBoolean	passiveMode := aBoolean</body><body package="FTP">password	^password</body><body package="FTP">resource	| data |	data := self readStreamDo: [:str :params | str contents].	^XML.InputSource		uri: self		encoding: nil		stream: (data withEncoding: #UTF_8) readStream lineEndTransparent</body><body package="FTP">setServerActive	self passiveMode: false</body><body package="FTP">setServerPassive	self passiveMode: true</body><body package="FTP">user	^user</body></methods><methods><class-id>Net.FtpURL</class-id> <category>stream -- unguarded</category><body package="FTP">appendStream	self isDirectory ifTrue: [self error: (#AppendStreamCanntBeOpenedOnDirectory &lt;&lt; #net &gt;&gt; 'An appendStream cannot be opened on a directory')].	^self fileDirectoryDo: [ :canonicalUri :client | client appendBinaryStream: canonicalUri tail]</body><body package="FTP">binaryReadStream	^self fileDirectoryDo: [ :canonicalUri :client | client readBinaryStream: canonicalUri tail]</body><body package="FTP">binaryWriteStream	^self fileDirectoryDo: [ :canonicalUri :client | client writeBinaryStream: canonicalUri tail]</body><body package="FTP">envelopeAppendStream	^self appendStream</body><body package="FTP">envelopeReadStream	^self readStream</body><body package="FTP">envelopeWriteStream	^self writeStream</body></methods><methods><class-id>Net.FtpURL</class-id> <category>utilities</category><body package="FTP">asFilename" Just have this method, please "</body><body package="FTP">contentsOfEntireFile	"Answer the contents of the file represented by the receiver."	^self readStreamDo: [ :stream :context | stream contents]</body><body package="FTP">copyTo: aURI	aURI asURI copyFromURI: self</body><body package="FTP">delete		| isDir |	isDir := self isDirectory.	^isDir 		ifTrue: [self removeDirectory]		ifFalse: [self removeFile]</body><body package="FTP">directory	^self canonicalize simpleDirectory</body><body package="FTP">fastDelete	" This is an opportunistic version of delete that first attempts to delete it as file and only if this fails tries to deleye it as a directory "	[self removeFile]			on: FTPPermSignal		do: [ :ex | self removeDirectory]</body><body package="FTP">fileSize	" Try SIZE command first, this failed, try getting file size harder way that requires us to set up transfer "	^self fileDirectoryDoAndClose: 		[:canonicalUri :client | 		[(client fileSize: canonicalUri tail) parse213AsBytes ] 			on: FTPPermSignal			do: [:ex | ex return: (client fileSizeFromTransferSetup: canonicalUri tail)]]</body><body package="FTP">head	| p index |	p := (String new: 32) writeStream.	path isEmpty ifTrue: [^''].	self isDirectory 		ifTrue: [index := path size]		ifFalse: [index := path size - 1].	^index &gt; 0		ifTrue:			[1 to: index -1 do: [:i | p nextPutAll: ((self pathAt: i), '/')].			p nextPutAll: (self pathAt: index).			p contents]		ifFalse: [String new]</body><body package="FTP">makeDirectory		^self fileDirectoryDoAndClose: 		[:canonicalUri :client | client makeDirectory: canonicalUri tail]</body><body package="FTP">modTime	"Return modification time of fileName."	^self fileDirectoryDoAndClose: 		[:canonicalUri :client | (client modTime: canonicalUri tail) parse213AsTimestamp ]</body><body package="FTP">removeDirectory		^self fileDirectoryDoAndClose: 		[:canonicalUri :client | client removeDirectory: canonicalUri tail]</body><body package="FTP">removeFile		^self fileDirectoryDoAndClose: 		[:canonicalUri :client | client deleteFile: canonicalUri tail]</body></methods><methods><class-id>Net.FtpURL</class-id> <category>printing</category><body package="FTP">directoryPathString	| stream |	stream := (String new: 64) writeStream.	self printDirectoryPathOn: stream.	^stream contents</body><body package="FTP">filePathString	| stream |	stream := (String new: 32) writeStream.	self printPathOn: stream.	^stream contents</body><body package="FTP">printDirectoryPathOn: aStream 		^self directory printPathOn: aStream</body><body package="FTP">printOn: aStream 	"Overwrite inherited method URL&gt;&gt;printOn: to hide output of password."	aStream nextPutAll: '&lt;URL:'.	self		printProtocolOn: aStream;		printUserWithHiddenPasswordOn: aStream;		printHostAndPortOn: aStream;		printPathOn: aStream;		printExtrasOn: aStream.	aStream nextPutAll: '&gt;'</body><body package="FTP">printUserOn: aStream	user == nil ifFalse:		[self class encodeUserPass: user on: aStream.		password == nil ifFalse:			[aStream nextPutAll: ':'.			self class encodeUserPass: password on: aStream].		aStream nextPutAll: '@'].</body><body package="FTP">printUserWithHiddenPasswordOn: aStream 	"Copied from #printUserOn: : Print user name, but not the password."	user isNil ifTrue: [^self].	aStream nextPutAll: user.	self password notNil 		ifTrue: 			[aStream nextPutAll: ':'.			aStream nextPutAll:  '******' ].	aStream nextPutAll: '@'</body></methods><methods><class-id>Net.FtpURL</class-id> <category>stream -- guarded</category><body package="FTP">readStreamDo: aBlock 	^self fileDirectoryDoAndClose: 		[:canonicalUri :client | 		client 			readBinaryStream: canonicalUri tail			do: 				[:data | 				aBlock 					value: data					value: (Dictionary new 								at: #MIME 								put: canonicalUri guessMimeType; yourself)]]</body><body package="FTP">writeStreamDo: aBlock 	| res |	^self fileDirectoryDoAndClose: 		[:canonicalUri :client |  		res := client 			writeBinaryStream: canonicalUri tail			do:	aBlock.		(Delay forMilliseconds: 100) wait.		res]</body></methods><methods><class-id>Net.FtpURL</class-id> <category>testing</category><body package="FTP">exists	"Answer true if the file specified by the receiver exists, false otherwise.http://en.wikipedia.org/wiki/Filesystem_permissions    - denotes a regular file    d denotes a directory    b denotes a block special file    c denotes a character special file    l denotes a symbolic link    p denotes a named pipe    s denotes a domain socket	http://en.wikipedia.org/wiki/Symbolic_link	Note: (Symbolic) Link files create listing output like 'mysymboliclink -&gt; linktarget'.x5z   File system - These replies indicate the status of the                  Server file system vis-a-vis the requested transfer or                  other file system action."	path isEmpty ifTrue: [^true].	path asSet asArray = #('') ifTrue: [^true].	^	[self fileDirectoryDoAndClose: 			[:canonicalUri :client | 			| myName |			myName := self tail.			client parseDirectoryContents: #()				do: 					[:dictionary | 					| fname |					(((fname := dictionary at: #name) match: myName) or: 							[(dictionary at: #type) == $l 								and: [(fname readStream upToAll: ' -&gt; ') match: myName]]) 						ifTrue: [^true]].			false]] 			on: FTPPermSignal			do: 				[:ex | 				ex parameter status = 550 					ifTrue: [ex return: false	"i.e. '550 ...: No such file or directory....' "]					ifFalse: [ex pass]]</body><body package="FTP">isDirectory	path isEmpty ifTrue: [^true].	path asSet asArray = #('') ifTrue: [^true].	^self fileDirectoryDoAndClose: 			[:canonicalUri :client | 			client parseDirectoryContents: #()				do: 					[:dictionary | 					((dictionary at: #name) match: self tail) ifTrue: [^dictionary at: #isDir]].			false]</body></methods><methods><class-id>Net.FtpURL</class-id> <category>resolution</category><body package="FTP">construct:  aFileComponent	^self canonicalize copy		addComponent: aFileComponent;		yourself</body></methods><methods><class-id>Net.FtpURL</class-id> <category>file utilities</category><body package="FTP">canonicalize		^(path size &gt; 0 and: [path last = '']) 		ifTrue: 			[self copy				path: (path copyFrom: 1 to: path size - 1);				yourself]		ifFalse: [self]</body><body package="FTP">directoryContents	| client results basePath canonical |	^self safelyExecuteBlock: 			[client := self client.			results := OrderedCollection new.						[canonical := self canonicalize.			basePath := canonical path.			self beCurrentDirectoryFor: canonical with: client.			client parseDirectoryContents: #()				do: 					[:dictionary | 					| name newPath |					name := dictionary at: #name.					newPath := (dictionary at: #isDir) 								ifTrue: [basePath , (Array with: name with: '')]								ifFalse: [basePath copyWith: ( self class encode: name ) ].					results add: (canonical copy path: newPath)]] 					ensure: [client close].			results]</body></methods><methods><class-id>Net.FtpURL</class-id> <category>comparing</category><body package="FTP">sameAs: aURI	^(super sameAs: aURI)		and: [ (user isNil and: [ aURI user isNil])				or: [	 (self userSameAs: aURI ) and: [ self passwordSameAs: aURI ]]]</body></methods><methods><class-id>Net.FtpURL</class-id> <category>initialize</category><body package="FTP">parseHost: aHostSpecification 	| fullHost |	fullHost := self parseUserinfo: aHostSpecification.	self parseHostPort: fullHost</body><body package="FTP">parseUserinfo: aHostSpecification 	| idx fullUser fullHost |	(aHostSpecification includes: $@)		ifTrue:			[idx := aHostSpecification lastIndexOf: $@.			fullUser := aHostSpecification copyFrom: 1 to: idx-1.			fullHost := aHostSpecification copyFrom: idx+1 to: aHostSpecification size.			(fullUser includes: $:)				ifTrue:					[idx := fullUser indexOf: $:.					user := fullUser copyFrom: 1 to: idx-1.					password := fullUser copyFrom: idx+1 to: fullUser size ]				ifFalse:					[user := fullUser.					password := nil]]		ifFalse:			[user := nil.			password := nil.			fullHost := aHostSpecification].	^fullHost</body></methods><methods><class-id>Net.FtpURL class</class-id> <category>accessing</category><body package="FTP">defaultPassiveMode	^FTPSettings passiveMode</body><body package="FTP">defaultPassiveMode: aBoolean	FTPSettings passiveMode:  aBoolean</body><body package="FTP">emailAddress	" self emailAddress "	^userAddress isNil 		ifFalse: [userAddress]		ifTrue: [userAddress := FTPSettings anonymousLoginPassword]</body><body package="FTP">emailAddress: aString	self userAddress: aString</body><body package="FTP">protocol	^'ftp'</body><body package="FTP">userAddress	^userAddress</body><body package="FTP">userAddress: aString	userAddress := aString</body><body package="FTP">userAllowedChars	^self unreservedChar, ';&amp;=+$,'</body></methods><methods><class-id>Net.FtpURL class</class-id> <category>updating</category><body package="FTP">update: anAspectSymbol with: aParameter from: aSender	"Record snapshot changes to we now whther we're installed or not."	anAspectSymbol == #earlySystemInstallation ifTrue:		[userAddress := nil]</body></methods><methods><class-id>Net.FtpURL class</class-id> <category>private</category><body package="FTP">queryAddress	| address |	address := Dialog request: (#WhatIsYourEmailAddress &lt;&lt; #net &gt;&gt; 'What is your email address?').	^address isEmpty		ifTrue: [self error: (#NoEmailAddressSupplied &lt;&lt; #net &gt;&gt; 'No email address supplied'). nil]		ifFalse: [address]</body></methods><methods><class-id>Net.FtpURL class</class-id> <category>defaults</category><body package="FTP">defaultPortNumber	^SocketAccessor IPPORT_FTP</body></methods><methods><class-id>Net.FtpURL class</class-id> <category>encoding/decoding</category><body package="FTP">encodeUserPass: aString on: stream	self encode: aString  on: stream</body></methods><methods><class-id>Net.FTPClient</class-id> <category>accessing</category><body package="FTP">applyUTF8EncodedStream	^(self useUtf8 and: [self features anySatisfy: [ :token | 'UTF8' match: token]])</body><body package="FTP">binaryBlockSize	^binaryBlockSize</body><body package="FTP">binaryBlockSize: anInteger	binaryBlockSize := anInteger</body><body package="FTP">commandInProgress	^commandInProgress ifNil: [ commandInProgress := false ]</body><body package="FTP">commandInProgress: aBoolean	commandInProgress := aBoolean</body><body package="FTP">features	^features</body><body package="FTP">unixServerTimestampBlock	^unixServerTimestampBlock ifNil: [unixServerTimestampBlock := self class unixServerTimestampBlock]</body><body package="FTP">unixServerTimestampBlock: aBlock	unixServerTimestampBlock := aBlock</body><body package="FTP">userAccount	^self user account</body><body package="FTP">userPassword	^self user password</body></methods><methods><class-id>Net.FTPClient</class-id> <category>commands</category><body package="FTP">abort"Abort a file transfer. Intercept response 426. This response, if received, actually belongs to the data transfer thread, so we poll next response expecting it to be 226, which is ours.Once found, we make 426 to be the delayed response so that data transfer thread will get it on close, and return "	| nextResp |	^[self clientPI abort]		on: FTPTransientReply		do: [ :ex | ex parameter isTransferAborted					ifTrue: 						[(nextResp := self clientPI getResponse) isTransferCompletion							ifTrue: [delayedResponse := ex parameter. 									FTPProtocolInterpreter log: [((#SetDelayedResponse1s &lt;&lt; #net &gt;&gt; 'Set delayed response &lt;1s&gt;')			expandMacrosWith: delayedResponse code)] level: #FTPResponse.									FTPProtocolInterpreter log: [((#ReturningResponse1s &lt;&lt; #net &gt;&gt; 'Returning response &lt;1s&gt;')			expandMacrosWith: nextResp code)] level: #FTPResponse.									ex return: nextResp ].						" If we didn't find 226, just return this response "						FTPProtocolInterpreter log: [((#ReturningResponse1s &lt;&lt; #net &gt;&gt; 'Returning response &lt;1s&gt;')			expandMacrosWith: ex parameter code)] level: #FTPResponse.						ex return: ex parameter.]					ifFalse: [ ex pass ]]</body><body package="FTP">account: aString	"Send new account name."	^self executeCommand: 'ACCT ' , aString retryChallenge: false</body><body package="FTP">beCurrentDirectory: directoryName 	"obsolete"	^self setCurrentDirectory: directoryName</body><body package="FTP">cmdRest: position	| resp |	^[resp := self executeCommand: 'REST ', position printString. FTPSignal raiseWith: resp]		on: FTPChallenge		do: [:ex | ex parameter needFileInfo					ifTrue: [ex return: resp]					ifFalse: [ex pass]]</body><body package="FTP">cmdUser: aString 	"Send user"	^self executeCommand: 'USER ' , aString retryChallenge: false</body><body package="FTP">currentWorkingDirectory	^self executeSequence: [self executeCommand: 'PWD']</body><body package="FTP">deleteFile: aFileNameString 	^self executeSequence: [self executeCommand: 'DELE ' , aFileNameString]</body><body package="FTP">feat" http://tools.ietf.org/html/rfc2389 If #features value  is not nil and empty the server doesn't support any extra features."	[features := (self executeCommand: 'FEAT ') parse211Features.	useUtf8 := features anySatisfy: [ :token | 'UTF8' match: token].	]		on: FTPPermSignal do: [ :ex | 		"Where a server-FTP process does not support the FEAT command, it will respond to the FEAT command with a 500 or 502 reply."		features := OrderedCollection new ].</body><body package="FTP">fileSize: fileName 	"Return size of fileName."	^self executeSequence: [self executeCommand: 'SIZE ' , fileName]</body><body package="FTP">fileSizeFromTransferSetup: fileName 	"Return size of fileName. Setup transfer to get the remote side to tell us about file size, then promptly close data connection"	| array size accessor |	^self executeSequence: [		self binaryTransfer.		array := self privateStartTransferCmd: 'RETR ', fileName asString.		size := array last.		accessor := array first.		accessor callback: nil.		accessor close.		[self readFinalResponseBlock value] on: FTPSignal do: [ :ex | ex return].		size].</body><body package="FTP">fileStructure	^self structure: $F</body><body package="FTP">help	"Return server's default help information."	^self help: nil</body><body package="FTP">help: aString	"ask for specific HELP with the string value, not implemented on all servers."	^self executeSequence: 		[self executeCommand: ('HELP',( aString isString ifTrue: [ ' ',aString] ifFalse:[ '']))]</body><body package="FTP">makeDirectory: directoryNameString 	^self executeSequence: [self executeCommand: 'MKD ' , directoryNameString]</body><body package="FTP">modTime: fileName 	"Return modification time of fileName."	^self executeSequence: [self executeCommand: 'MDTM ' , fileName]</body><body package="FTP">mode: aChar	"This implementation only supports Stream mode"	"S - Stream 	B - Block	C - Compressed"	^self executeSequence: [self executeCommand: 'MODE ' , aChar asSymbol asString]</body><body package="FTP">noop	"this is the No Operation command used to check 	the server for a connection and proper response"	^self executeSequence: [self executeCommand: 'NOOP']</body><body package="FTP">pass: aString 	"Send password"	^ self executeCommand:  'PASS ' , aString retryChallenge: false</body><body package="FTP">presentWorkingDirectory	^self executeSequence: [self executeCommand: 'PWD ']</body><body package="FTP">quit	| resp |	self clientPI socket isActive 		ifTrue: [ resp := self executeCommand: 'QUIT'].	self disconnect.	^resp</body><body package="FTP">quote: aString	^self executeSequence: [self executeCommand: 'QUOTE ', aString]</body><body package="FTP">remoteSystemType	^self executeSequence: [self executeCommand: 'SYST ']</body><body package="FTP">removeDirectory: directoryNameString 	^self executeSequence: [self executeCommand: 'RMD ' , directoryNameString]</body><body package="FTP">rename: dirOrFileName to: targetName 	"Rename initialFileName to targetFileName.  Where targetFileName is a filename only, not the path"	^self executeSequence: [ 			[self executeCommand: 'RNFR ' , dirOrFileName] 				on: FTPChallenge				do: [:ex | ex parameter needFileInfo					ifTrue: [ex return: (self executeCommand: 'RNTO ' , targetName)]					ifFalse: [ex pass]]]</body><body package="FTP">setCurrentDirectory: directoryName 	"Change to the directory named 	directoryName."	| cmd |	cmd := directoryName = '..'				ifTrue: ['CDUP']				ifFalse: ['CWD ' , directoryName].	^self executeSequence: [self executeCommand: cmd]</body><body package="FTP">setRemoteStreamPosition: position" Set position in remote stream for the next transfer operation. This command should result in 350 response. Anything elese is error "	^[self executeCommand: 'REST ' , position asString] 		on: FTPChallenge		do: [:ex | ex parameter needFileInfo					ifTrue: [ex return]					ifFalse: [ex pass]]</body><body package="FTP">setServerActive	"Use this command in conjunction with a file transfer command 	to set the server to active.  This message must be sent before	each transfer command that requires a passive server."	self clientPI setServerActive.</body><body package="FTP">setServerPassive	"Use this command in conjunction with a file transfer command 	to set the server to PASV.  This message must be sent before	each transfer command that requires a passive server."	self clientPI setServerPassive.</body><body package="FTP">site: cmdString	"SITE commands are server specific.  Some commands require permission granted	by and administrator.  User the #siteHelp to determine which commands are valid.	Such as the following,	MSG &lt;any message&gt;	Sends a message to the console.	or,	KICK &lt;user handle&gt;	214- Throw a user off."	^self executeSequence: [self executeCommand: 'SITE ', cmdString]</body><body package="FTP">siteHelp	^self help: 'SITE'</body><body package="FTP">stat	^self executeSequence: [self executeCommand: 'STAT']</body><body package="FTP">streamMode	"sets the transfer MODE as Stream.  Other possibilites are Bock and Compressed"	^self mode: $S</body><body package="FTP">structure: aChar	"set the file transfer structure.  This implementation only supports the File Structure"	"F - File	R - Record	P - Page"	^self executeSequence: [self executeCommand: 'STRU ' , aChar asSymbol asString]</body><body package="FTP">transferOffset	^transferOffset</body><body package="FTP">transferOffset: position	transferOffset := position</body></methods><methods><class-id>Net.FTPClient</class-id> <category>streams -- guarded</category><body package="FTP">appendBinaryStreamCmd: aString do: aBlock	^self executeSequence: 		[self 			guardedBinaryTransferCmd: aString  			do: [ :ftpAccessor | self stream: ftpAccessor writeStream binary do: aBlock ]]</body><body package="FTP">appendStreamCmd: aString do: aBlock	^self appendBinaryStreamCmd: aString do: aBlock</body><body package="FTP">appendTextStreamCmd: aString do: aBlock	^self executeSequence: 		[self 			guardedTextTransferCmd: aString 			do: [ :ftpAccessor | self stream: ftpAccessor writeStream text do: aBlock ]]</body><body package="FTP">readBinaryStream: aFileNameString do: aBlock	^self readBinaryStreamCmd: 'RETR ', aFileNameString do: aBlock</body><body package="FTP">readBinaryStreamCmd: aString do: aBlock	^self executeSequence: 		[self 			guardedBinaryTransferCmd: aString 			do: [ :ftpAccessor | 	self stream: ftpAccessor readStream binary do: aBlock ]]</body><body package="FTP">readStream: aFileNameString do: aBlock	^self readBinaryStream: aFileNameString do: aBlock</body><body package="FTP">readStreamCmd: aString do: aBlock	^self readBinaryStreamCmd: aString do: aBlock</body><body package="FTP">readTextStream: aFileNameString do: aBlock	^self readTextStreamCmd: 'RETR ', aFileNameString do: aBlock</body><body package="FTP">readTextStreamCmd: aString do: aBlock	^self executeSequence: 		[self 			guardedTextTransferCmd: aString 			do: [ :ftpAccessor |  | remoteStream |				remoteStream := (ExternalReadAppendStream on: ftpAccessor asExternalConnection) lineEndCRLF.				remoteStream := self applyUTF8EncodedStream					ifTrue: [ 	(EncodedStream on: remoteStream binary  encodedBy: (StreamEncoder new: #utf8)) lineEndCRLF ]					ifFalse: [ remoteStream  ].				self stream: remoteStream do: aBlock ]]</body><body package="FTP">writeBinaryStream: aFileNameString do: aBlock	^self writeBinaryStreamCmd: 'STOR ', aFileNameString do: aBlock</body><body package="FTP">writeBinaryStreamCmd: aString do: aBlock	^self executeSequence: 		[self 			guardedBinaryTransferCmd: aString 			do: [ :ftpAccessor | 	self stream: ftpAccessor writeStream binary do: aBlock ]]</body><body package="FTP">writeStream: aFileNameString do: aBlock	^self writeBinaryStream: aFileNameString do: aBlock</body><body package="FTP">writeStreamCmd: aString do: aBlock	^self writeBinaryStreamCmd: aString do: aBlock</body><body package="FTP">writeTextStream: aFileNameString do: aBlock	^self writeTextStreamCmd: 'STOR ', aFileNameString do: aBlock</body><body package="FTP">writeTextStreamCmd: aString do: aBlock	^self executeSequence: 		[self 			guardedTextTransferCmd: aString 			do: [ :ftpAccessor | 	self stream: ftpAccessor writeStream text do: aBlock ]]</body></methods><methods><class-id>Net.FTPClient</class-id> <category>private -- guarded stream setup</category><body package="FTP">guardedBinaryTransferCmd: aString do: aBlock 	"Perform guarded binary transfer over data connection. Returns final response. 	This is used for transfers that are done under our control, so we ensure 	that data stream is closed and final data response is read"	^self		binaryTransfer; 		guardedTransferCmd: aString do: aBlock</body><body package="FTP">guardedTextTransferCmd: aString do: aBlock 	"Perform guarded text transfer over data connection. Returns final response. 	This is used for transfers that are done under our control, so we ensure 	that data stream is closed and final data response is read"	^self		textTransfer; 		guardedTransferCmd: aString do: aBlock</body><body package="FTP">guardedTransferCmd: aString do: aBlock 	"Perform guarded transfer over data connection. Returns result of the block. 	This is used for transfers that are done under our control, so we ensure 	that data stream is closed and final data response is read"	| accessor result |	accessor := self startTransferCmd: aString.	result := [accessor callback: nil.	aBlock value: accessor]		ensure: [accessor close].	finalResponse := self readFinalResponseBlock value.	^result</body><body package="FTP">stream: externalStream do: aBlock	^[ aBlock value: externalStream ] ensure: [ externalStream close ]</body></methods><methods><class-id>Net.FTPClient</class-id> <category>private -- command interface</category><body package="FTP">checkCommandInProgress	self commandInProgress 		ifTrue: 			[self disconnect.			self error: #CanNotStartTransferComamnd &lt;&lt; #net &gt;&gt; 'Can not start the transfer command. There is already a command in progress'].</body><body package="FTP">executeCommand: aString retryChallenge: aBoolean" Most command travel though here. If retryChallenge is true and the responseis intermediate reply (3xx), we handle it as a challenge (by sending user name, password, etc.) and then retry the original command. To avoid recursion, user authorisation commands themselves (USER, PASS, ACCT) are sent with no retry on challenge"	^[ self clientPI sendCommand: aString ]		on: FTPChallenge 		do: [ :ex |				FTPProtocolInterpreter log: [ 'FTPChallenge: ', ex messageText ] level: #FTPException.				(self handleChallenge: ex parameter command: aString)					ifTrue: [ aBoolean ifTrue: [ ex retry ]]					ifFalse: [ ex pass ]]</body><body package="FTP">handleChallenge: aResponse command: aString	aResponse needAccountForLogin		ifTrue: 			[aString = 'ACCT ' ifTrue: [ ^false ]. 			self userAccount notNil 				ifTrue: [ self account: self userAccount. ^true]].	aResponse needPassword		ifTrue: 			[aString = 'PASS ' ifTrue: [ ^false ].  			self userPassword notNil				ifTrue: [ self pass: self userPassword. ^true ]].	^false</body><body package="FTP">privateStartTransferCmd: aString 	"Initiate a transfer over the data connection.  	If the transfer is active, send a port command and the transfer 	command, and accept the connection. If the server is passive, 	send a pasv command, connect to it, and start the transfer 	command.  Return the passiveServer instance variable to false after the operation.	Either way, return the socket for the connection 	and the expected size of the transfer. The expected size 	may be None if it could not be determined."	| conn resp |	delayedResponse := nil.	self clientPI passiveServer		ifTrue: 			[| sockAddress |			sockAddress := (self executeCommand: 'PASV') parse227HostPort.			(conn := FTPSocketAccessor newTCP) connectTo: sockAddress.			transferOffset &gt; 0 ifTrue: [self cmdRest: transferOffset].			resp := self transferCmd: aString		]		ifFalse: 			[| sock counter |			sock := self clientPI makeport.			transferOffset &gt; 0 ifTrue: [self cmdRest: transferOffset].			resp := self transferCmd: aString.			"!!!this didn't work on Macs:				conn := sock accept."			counter := 50.			[conn := sock acceptNonBlock.			conn isNil and: [counter &gt; 0]]				whileTrue: 					[counter := counter - 1.					(Delay forSeconds: 1) wait].			"If no client solicited a connection, give up."			conn isNil 				ifTrue: 					[Transcript show: (#givingUp &lt;&lt; #dialogs &gt;&gt; 'Giving up!') asString; cr.					sock close.					^nil].		].	conn ftpConn: self.	^Array with: conn with: resp parse150Size.</body><body package="FTP">startTransferCmd: aString	"Initiate a transfer over the data connection.  Returns 	the socket for the connection."	^(self privateStartTransferCmd: aString ) first</body><body package="FTP">transferCmd: aString" This one is used to send transfer command (RETR, STOR, STOU, LIST, NLST). The only valid reply is a preliminary reply "	| resp | 	^[resp := self clientPI sendCommand: aString. FTPSignal raiseWith: resp				 ] on: FTPPreliminaryReply do:[:ex | ex return: ex parameter ]</body></methods><methods><class-id>Net.FTPClient</class-id> <category>low-level command interface</category><body package="FTP">executeCommand: aString	^ self executeCommand: aString retryChallenge: true</body><body package="FTP">executeSequence: aBlock" Catch reply 421 (Server closed control connection. This should helpin most time-out/stale connection situations. There is a small chance of getting this in the middle of a command sequence and this would be bad "	self connectIfClosed.	^[[aBlock value] 		on: FTPTransientReply		do: [ :ex | ex parameter hasConnectionClosed					ifTrue: [ self reconnect.							ex retry ]					ifFalse: [ ex pass ]]]		on: OSErrorHolder peerFaultSignal		do: [ :ex | self reconnect.					ex retry ]</body><body package="FTP">executeSequenceSafely: aBlock	self checkCommandInProgress.	^self executeSequence: aBlock</body><body package="FTP">getResponse	^self clientPI getResponse</body><body package="FTP">sendCommand: aString " This is direct passthrough to protocol interpreter. We are not using it,but if somebody needs to send unadited command directly to FTP server,this is the place "	^self clientPI sendCommand: aString</body></methods><methods><class-id>Net.FTPClient</class-id> <category>streams -- unguarded</category><body package="FTP">appendBinaryStream: aFileString	^ self executeSequence: [(self openBinaryTransferCmd: 'APPE ', aFileString) writeStream binary]</body><body package="FTP">appendStream: aFileString	^self appendBinaryStream: aFileString</body><body package="FTP">appendTextStream: aFileString	^ self executeSequence: [(self openTextTransferCmd: 'APPE ', aFileString) writeStream lineEndCRLF ]</body><body package="FTP">readBinaryStream: cmd	^ self executeSequence: [(self openBinaryTransferCmd: 'RETR ', cmd) readStream binary]</body><body package="FTP">readStream: cmd	^self readBinaryStream: cmd</body><body package="FTP">readStreamCmd: cmd	^self executeSequence: [(self openBinaryTransferCmd: cmd) readStream ]</body><body package="FTP">readTextStream: cmd	^self executeSequence: [(self openTextTransferCmd: 'RETR ', cmd) readStream lineEndCRLF]</body><body package="FTP">writeBinaryStream: aFileString	^ self executeSequence: [(self openBinaryTransferCmd: 'STOR ', aFileString) writeStream binary ]</body><body package="FTP">writeStream: aString	^self writeBinaryStream: aString</body><body package="FTP">writeStreamCmd: cmd	^self executeSequence: [(self openBinaryTransferCmd: cmd) writeStream ]</body><body package="FTP">writeTextStream: aFileString	^ self executeSequence: [(self openTextTransferCmd: 'STOR ', aFileString) writeStream lineEndCRLF ]</body></methods><methods><class-id>Net.FTPClient</class-id> <category>private -- unguarded stream setup</category><body package="FTP">openBinaryTransferCmd: aString 	"Open binary transfer over the data connection. Returns 	socket accessor for the connection.This is used for transfers that are entirely controller by user 	agent. User agent has a responsibility to close data stream. We make sure that when this	happens, the final data response is read"	^self		binaryTransfer;		openTransferCmd: aString</body><body package="FTP">openTextTransferCmd: aString 	"Open text transfer over the data connection. Returns 	socket accessor for the connection.This is used for transfers that are entirely controller by user 	agent. User agent has a responsibility to close data stream. We make sure that when this	happens, the final data response is read"	^self		textTransfer;		openTransferCmd: aString</body><body package="FTP">openTransferCmd: aString 	"Open transfer over the data connection. Returns 	socket accessor for the connection.This is used for transfers that are entirely controller by user 	agent. User agent has a responsibility to close data stream. We make sure that when this	happens, the final data response is read"	^(self startTransferCmd: aString)		callback: self readFinalResponseBlock; yourself</body></methods><methods><class-id>Net.FTPClient</class-id> <category>ftp experimental commands</category><body package="FTP">xBeCurrentDirectory: directoryName 	"Change to the directory named 	directoryName."	^directoryName = '..' 		ifTrue: [self executeCommand: 'XCUP']		ifFalse: [self executeCommand: 'XCWD ' , directoryName]</body><body package="FTP">xCurrentWorkingDirectory	^self executeCommand: 'XPWD'</body><body package="FTP">xMakeDirectory: directoryNameString 	^self executeCommand: 'XMKD ' , directoryNameString</body><body package="FTP">xRemoveDirectory: directoryNameString 	^self executeCommand: 'XRMD ' , directoryNameString</body></methods><methods><class-id>Net.FTPClient</class-id> <category>private -- utilities</category><body package="FTP">binaryTransfer	^self executeCommand: 'TYPE I'</body><body package="FTP">copyFrom: inputStream to: outputStream	^self copyFrom: inputStream to: outputStream blockSize: self binaryBlockSize</body><body package="FTP">copyFrom: inputStream to: outputStream blockSize: blockSize	| data counter |	data := inputStream contentsSpecies new: blockSize.	[ inputStream atEnd ] whileFalse: 		[counter := inputStream nextAvailable: blockSize into: data startingAt: 1.  		outputStream next: counter putAll: data startingAt: 1].</body><body package="FTP">dosAttributesFromStream: aStream 	| attributes date time dirOrSize sizeString |	attributes := Dictionary new.	date := Date readFrom: aStream.	aStream skipSeparators.	time := Time readFrom: aStream.	attributes at: #timestamp put: (Timestamp fromDate: date andTime: time).	dirOrSize := aStream				skipSeparators;				upToSeparator.	(attributes at: #isDir put: dirOrSize = '&lt;DIR&gt;') 		ifFalse: 			[sizeString := dirOrSize copyWithout: $,.			attributes at: #size put: (Integer readFrom: sizeString readStream)].	attributes at: #name		put: (aStream				skipSeparators;				upToEnd).	^attributes</body><body package="FTP">lines: cmd do: aBlock 	"Retrieve data in line mode. Suppress all empty lines. Used by directory listing routines.	The argument is a RETR or LIST command."	self checkCommandInProgress.	self commandInProgress: true.	^[self executeSequence:		[self readTextStreamCmd: cmd do:			[ :remoteStream | 				remoteStream linesDo: [ :line |					FTPProtocolInterpreter log: [ ((#data1s &lt;&lt; #net &gt;&gt; '*data*&lt;1s&gt;')			expandMacrosWith: line) ] level: #FTPResponse.					line isEmpty ifFalse: [aBlock value: line]]]	]		] ensure: [ self commandInProgress: false  ]</body><body package="FTP">parseDirLine: line 	(line size &lt; 3 or: ['total*' match: line]) ifTrue: [^nil].	"Assume the line format is either DOS or Unix.  	If the first two characters are digits, then it's DOS (?)."	^(line first isDigit and: [(line at: 2) isDigit]) 		ifTrue: [self dosAttributesFromStream: line readStream]		ifFalse: [self unixAttributesFromStream: line readStream]</body><body package="FTP">parseDirLine: line do: aBlock	| isUnix isDir name index parser |	('total*' match: line) ifTrue: [^self].	"Assume it's either Windows or Unix.	If it's Windows, the first two characters must be digits (?)."	isUnix := false.	#('0123456789' '0123456789' ) keysAndValuesDo: [:i :str |		(line size &gt;= i and: [str includes: (line at: i)])			ifFalse: [isUnix := true]].	index := 1.  	parser :=		[index := (index to: line size) detect: [:i | (line at: i) isSeparator] ifNone: [index].		index := (index to: line size) detect: [:i | (line at: i) isSeparator not] ifNone: [index]].	isUnix		ifTrue:			[isDir := line first = $d.			parser value.    "skip permissions"			parser value.    "skip link count"			parser value.    "skip user"			parser value.    "skip group"			parser value.    "skip size"			3 timesRepeat: [parser value].    "skip month, day, and time"			name := line copyFrom: index to: line size]		ifFalse:			[isDir := ('*&lt;DIR&gt;*' match: line).			3 timesRepeat: [parser value].    "skip date, time, dir/size"			name := name := line copyFrom: index to: line size.].	aBlock value: isDir value: name</body><body package="FTP">restoreFrom: position do: aBlock" This method aids in restoring file transfers from a specified position. This position will cause the server to start transfer operation not at the beginning of the file, but at specified position. This method can be used if a long transfer was interrupted in the middle. The application may then look at how much data was already transferred and restart transfer at thepoint immediately after this data. "	self transferOffset: position.	^aBlock ensure: 		[self transferOffset: 0].</body><body package="FTP">setUnixServerTimestamp	unixServerTimestamp := self unixServerTimestampBlock value: self.</body><body package="FTP">textTransfer	^self executeCommand: 'TYPE A'</body><body package="FTP">unixAttributesFromStream: aStream 	| attributes type timestamp |	attributes := Dictionary new.	type := aStream next.	attributes		at: #type put: type;		at: #isDir put: type == $d;		at: #permissions put: aStream upToSeparator.	aStream skipSeparators.	attributes		at: #linkCount put: (Integer readFrom: aStream);		at: #user			put: (aStream					skipSeparators;					upToSeparator);		at: #group			put: (aStream					skipSeparators;					upToSeparator).	aStream skipSeparators.	attributes at: #size put: (Integer readFrom: aStream).	timestamp := self unixTimestampFromStream: aStream.	attributes		at: #timestamp put: timestamp;		at: #name put: aStream upToEnd.	^attributes</body><body package="FTP">unixTimestampFromStream: aStream 	" FTPClient new unixTimestampFromStream: 'Mar 30 23:45' readStream.	 FTPClient new unixTimestampFromStream: 'Mar 30  2002' readStream.	Read a Timestamp from FTP LIST output &lt;aStream&gt;. See what 'info ls' documents about the format:	Formatting file timestamps	   By default, file timestamps are listed in abbreviated form.  Most locales use a timestamp like '2002-03-30 23:45'.  	However, the default POSIX locale uses a date like 'Mar 30  2002' for non-recent timestamps,	and a date-without-year and time like 'Mar 30 23:45' for recent timestamps.	   A timestamp is considered to be 'recent' if it is less than six months old, and is not dated in the future.  	If a timestamp dated today is not listed in recent form, the timestamp is in the future, which means you probably have clock skew problems ..."	| month day yearOrTime date |	month := aStream				skipSeparators;				upToSeparator.	aStream skipSeparators.	day := Integer readFrom: aStream.	yearOrTime := aStream				skipSeparators;				upToSeparator.	^(yearOrTime includes: $:) 		ifTrue: 			[ | tm |			 "date-without-year, e.g. 'Nov 20 11:50' with Date today = Feb 25 2008"			tm := Timestamp 				fromDate: ( Date newDay: day month: month year: unixServerTimestamp year )				andTime: (Time readFrom: yearOrTime readStream ).			tm &gt; unixServerTimestamp ifTrue: [tm year: tm year - 1].			tm]		ifFalse: 			["e.g. 'May 15  2007' "			date := Date newDay: day month: month year: (Integer readFrom: yearOrTime readStream).			Timestamp fromDate: date andTime: (Time fromSeconds: 0)].</body></methods><methods><class-id>Net.FTPClient</class-id> <category>file and directory utilities</category><body package="FTP">appendBinaryFileNamed: aString to: aDestString 	| file |	self checkCommandInProgress.	^[file := aString asFilename readStream binary.	self 		appendBinaryStreamCmd: 'APPE ', aDestString 		do: [ :stream | self copyFrom: file to: stream blockSize: self binaryBlockSize ].	finalResponse ]		ensure: 	 [file close]</body><body package="FTP">appendFileNamed: aString to: aDestString 	self checkCommandInProgress.	^self appendBinaryFileNamed: aString to: aDestString</body><body package="FTP">appendTextFileNamed: aString to: aDestString 	| file |	self checkCommandInProgress.	^[file := aString asFilename readStream text.	self 		appendTextStreamCmd: 'APPE ', aDestString 		do: [ :stream | self copyFrom: file to: stream ].	finalResponse ]		ensure: 	 [file close]</body><body package="FTP">copyFileNamed: remoteFileString on: aBinaryStream" Copy file onto specified binary stream "	^self executeSequenceSafely: 		[self readBinaryStreamCmd: 'RETR ', remoteFileString 			do: [ :remoteStream | self copyFrom: remoteStream to: aBinaryStream].		finalResponse ]</body><body package="FTP">copyFrom: aBinaryStream toFileNamed: remoteFileString" Copy specified binary stream to remote file "	^self executeSequenceSafely: 		[self writeBinaryStreamCmd: 'STOR ', remoteFileString 			do: [ :remoteStream | self copyFrom: aBinaryStream to: remoteStream].		finalResponse]</body><body package="FTP">copyFromFTP: otherServer file: otherFile toFile: myFile passive: aBoolean" Direct file transfer between two servers. Copy file from specified file on otheServer tospecified file on myself. The transfer is setup in such a way that the two servers talkdirectly to each other "	^self executeSequenceSafely: 		[otherServer executeSequence:			[aBoolean				ifTrue: [otherServer executeCommand: 'PORT ', (self executeCommand: 'PASV') parse227HostPortString]				ifFalse: [self executeCommand: 'PORT ', (otherServer executeCommand: 'PASV') parse227HostPortString].			self binaryTransfer; transferCmd: 'STOR ', myFile.			otherServer binaryTransfer; transferCmd: 'RETR ', otherFile.			otherServer getResponse.			self getResponse]]</body><body package="FTP">directoryContents: argumentCollection do: aBlock	"List a directory in long form. 	All non-empty arguments before it are concatenated	to the LIST command. (This *should* only be used for 	a pathname.)"	| cmd |	cmd := 'LIST'.	argumentCollection isString 		ifTrue: [cmd := cmd, ' ', argumentCollection] 		ifFalse: [ argumentCollection do: [:each | each isNil ifFalse: [cmd := cmd , ' ' , each]]].	^self lines: cmd do: aBlock</body><body package="FTP">filesInDirectory: argumentCollection do: aBlock	"Evaluate block for every filenames in a given directory ""Using this command for a file transfer can cause getting wrong responses for the transfer command.Instead of using:ftpClient  filesInDirectory: (Array with: dir)  do: [:entry | entry = 'xxx.xxx' ifTrue: [ ftpClient retrieveFileNamed: entry as: 'xxx.jpg']].Consider two step approach:ftpClient filesInDirectory: (Array with: dir) do: [:entry | coll add: entry].ftpClient setCurrentDirectory: dir.ftpClient retrieveFileNamed: coll first as: 'xxx.jpg'."	| cmd |	cmd := 'NLST'.	argumentCollection isString 		ifTrue: [cmd := cmd, ' ', argumentCollection] 		ifFalse: [ argumentCollection do: [:each | each isNil ifFalse: [cmd := cmd , ' ' , each]]].	^self lines: cmd do: aBlock</body><body package="FTP">parseDirectoryContents: argumentCollection do: aBlock 	"List a directory in long form. All non-empty arguments before it are concatenated to the LIST command. (This *should* only be used for a pathname.)http://cr.yp.to/ftp/list.html"	| cmd attributes |	self setUnixServerTimestamp.	cmd := 'LIST'.	argumentCollection isString 		ifTrue: [cmd := cmd , ' ' , argumentCollection]		ifFalse: 			[argumentCollection 				do: [:each | each isNil ifFalse: [cmd := cmd , ' ' , each]]].	self lines: cmd		do: 			[:line | 			attributes := self parseDirLine: line.			attributes notNil ifTrue: [aBlock value: attributes]]</body><body package="FTP">retrieveFileNamed: remoteFileString as: localFileString	| localFileStream |	^self executeSequenceSafely: 		[[localFileStream := localFileString asFilename writeStream binary.		self readBinaryStreamCmd: 'RETR ', remoteFileString 			do: [ :remoteStream | self copyFrom: remoteStream to: localFileStream].		finalResponse]		ensure: 	[localFileStream close]]</body><body package="FTP">storeFileNamed: localFileString to: remoteFileString	| localFileStream |	localFileStream := localFileString asFilename readStream binary.	^self executeSequenceSafely: 		[	[self writeBinaryStreamCmd: 'STOR ', remoteFileString 			do: [ :remoteStream | self copyFrom: localFileStream to: remoteStream].			finalResponse		]			ensure: 	[localFileStream ifNotNil: [localFileStream close]]]</body></methods><methods><class-id>Net.FTPClient</class-id> <category>restart</category><body package="FTP">restartRetrieveLocalFile: localFileNameString fromFile: remoteFileNameString 	"restart retrieve by checking size of local file and transfering only data that has not 	been transferred yet. Useful to recover from transient transfer errors "	| localFilename localFileStream localSize remoteSize |	(localFilename := localFileNameString asFilename) exists not 		ifTrue: [localFilename writeStream close].		" Create file if does not exist yet "		[localFileStream := localFilename appendStream binary setToEnd.	localSize := localFilename fileSize.	remoteSize := [(self fileSize: remoteFileNameString) parse213AsBytes]					on: FTPPermSignal					do: [ :ex | 						ex parameter notImplementedCommand							ifTrue: [	ex return: 0]							ifFalse: [ ex pass] ].	(remoteSize == 0  or: [localSize &lt; remoteSize]) 		ifTrue: [self restoreFrom: localFileStream position					do: [ self copyFileNamed: remoteFileNameString on: localFileStream ]]]		ensure: [localFileStream close]</body><body package="FTP">restartStoreRemoteFile: remoteFileNameString fromFile: localFileNameString 	" restart retrieve by checking size of remote file and transfering only data that has not 	been transferred yet. Useful to recover from transient transfer errors "	| localFilename localFileStream remoteSize |	(localFilename := localFileNameString asFilename) exists not 		ifTrue: [^self error: ((#File1sDoesNotExist &lt;&lt; #net &gt;&gt; 'File &lt;1s&gt; does not exist')			expandMacrosWith: localFileNameString)].	[localFileStream := localFilename readStream binary.	remoteSize := [(self fileSize: remoteFileNameString) parse213AsBytes] 					on: FTPPermSignal					do: [ :ex | 						ex parameter notImplementedCommand							ifTrue: [	ex return: 0]							ifFalse: [ ex pass] ].	localFilename fileSize &gt; remoteSize 		ifTrue: [localFileStream position: remoteSize.				self 					appendBinaryStreamCmd: 'APPE ', remoteFileNameString 					do: [ :remoteStream | self copyFrom: localFileStream to: remoteStream ]]]		ensure: [localFileStream close]</body></methods><methods><class-id>Net.FTPClient</class-id> <category>initialization-release</category><body package="FTP">initialize	self binaryBlockSize: self class defaultBinaryBlockSize.	transferOffset := 0.	self portNumber: SocketAccessor IPPORT_FTP.</body></methods><methods><class-id>Net.FTPClient</class-id> <category>ftp accessor callbacks</category><body package="FTP">pollResponses	| resp |	[(resp := self clientPI pollResponse) notNil] 		whileTrue: 			[resp isTransferCompletion 				ifTrue: 					[FTPProtocolInterpreter log: [((#SetDelayedResponse1s &lt;&lt; #net &gt;&gt; 'Set delayed response &lt;1s&gt;')			expandMacrosWith: resp code)] level: #FTPResponse.					delayedResponse := resp.]].	^resp</body><body package="FTP">readFinalResponseBlock	| resp |	^[resp := delayedResponse notNil		ifTrue: 			[FTPProtocolInterpreter log: [((#UsingDelayedResp1s &lt;&lt; #net &gt;&gt; 'Using delayed resp &lt;1s&gt;')			expandMacrosWith: delayedResponse code)] level: #FTPResponse.			FTPSignal handleResponse: delayedResponse]		ifFalse: [self clientPI getResponse].	delayedResponse := nil.	self transferOffset: 0. 	resp]</body></methods><methods><class-id>Net.FTPClient</class-id> <category>connection management</category><body package="FTP">close	self disconnect</body><body package="FTP">connect	"Establish a connection to the host"	| pi str |	pi := self clientPI 			connectToHost: self hostName 			port: self portNumber.	"Check the server if it supports any extra features. If #features is not nil we have already asked it"	features ifNil: [self feat].	self applyUTF8EncodedStream		ifTrue: [pi stream binary.			str := (EncodedStream on: pi stream encodedBy: (StreamEncoder new: #utf8)) lineEndCRLF.			str text.			pi stream: str ].	^pi</body><body package="FTP">connectIfClosed	self clientPI closed 		ifTrue: [ self reconnect ]</body><body package="FTP">disconnect	clientPI notNil ifTrue: [clientPI disconnect].	clientPI := nil</body><body package="FTP">doLogin	^self cmdUser: self user username</body><body package="FTP">isConnected	^self clientPI closed not</body><body package="FTP">login: userString passwd: passwdString	self login: userString passwd: passwdString acct: nil</body><body package="FTP">login: userString passwd: passwdString acct: acctString		^self loginWithUser: (FTPUser createUser: userString password: passwdString account: acctString)</body><body package="FTP">loginToHost: aHostName asUser: userString withPassword: passwdString	self loginToHost: aHostName asUser: userString withPassword: passwdString withAcct: nil</body><body package="FTP">loginToHost: aHostName asUser: userString withPassword: passwdString withAcct: acctString	^self connectToHost: aHostName port: nil; 		login: userString passwd: passwdString acct: acctString.</body><body package="FTP">loginToHost: aHostName withUser: anFTPUser	self connectToHost: aHostName port: nil; 		loginWithUser: anFTPUser</body><body package="FTP">loginWithUser: anFTPUser	self user: anFTPUser.	^self doLogin</body><body package="FTP">reconnect	FTPProtocolInterpreter log: [(#reconnect &lt;&lt; #net &gt;&gt; '*reconnect*')] level: #FTPException.	self disconnect;		connect;		doLogin</body></methods><methods><class-id>Net.FTPClient</class-id> <category>testing</category><body package="FTP">useUtf8	^useUtf8 ifNil: [ useUtf8 := self class useUtf8 ]</body></methods><methods><class-id>Net.FTPClient class</class-id> <category>instance creation</category><body package="FTP">connectToHost: aHostname	^self new connectToHost: aHostname</body><body package="FTP">connectToHost: aHostname port: aPort	^self new connectToHost: aHostname port: aPort</body><body package="FTP">loginToHost: aHostName asUser: userString withPassword: passwdString 	^self loginToHost: aHostName asUser: userString withPassword: passwdString withAcct: nil</body><body package="FTP">loginToHost: aHostName asUser: userString withPassword: passwdString withAcct: acctString	|  conn |	conn := self new.	conn loginToHost: aHostName asUser: userString withPassword: passwdString withAcct: acctString.	^conn</body><body package="FTP">loginToHost: aHostName withUser: anFTPUser	| conn  |	conn := self new.	conn loginToHost: aHostName withUser: anFTPUser.	^conn</body></methods><methods><class-id>Net.FTPClient class</class-id> <category>constants</category><body package="FTP">description	^(#FTPServer &lt;&lt; #net &gt;&gt; 'FTP server') asString</body><body package="FTP">serverType	^#FTP</body></methods><methods><class-id>Net.FTPClient class</class-id> <category>default values</category><body package="FTP">defaultBinaryBlockSize	^4096</body><body package="FTP">defaultProtocolInterpreterClassValue	"Use a special protocolInterpreter on Macintosh, because its socket 	implementation insists on using the right 'write*' primitives for TCP 	connections."	^OSHandle currentOS == #mac		ifTrue: [MacFTPProtocolInterpreter]		ifFalse: [FTPProtocolInterpreter]</body><body package="FTP">defaultUnixServerTimestampBlock" http://cr.yp.to/ftp/list.htmlhttp://cr.yp.to/ftp/list/binls.htmlThe month name, day number, hour number, and minute number express the file's modification time in the server's local time zone. This creates several obstacles to reliable mirroring. -rw-r--r-- 1 owner group           213 Aug 26 16:31 READMEThe format shown above applies only to files modified in the last six months. Other files show the year instead of the hour number and minute number:  -rw-r--r-- 1 owner group          1383 Apr 10  1997 ip.cSome servers (e.g., NetWare) set the cutoff at one year, making it impossible for the client to reliably distinguish dates near the cutoff from recent dates.Clients attempting to parse /bin/ls format must be prepared for a much wider range of line formats. "		^[ :client  | Timestamp now 	]</body><body package="FTP">defaultUseUtf8	^true</body></methods><methods><class-id>Net.FTPClient class</class-id> <category>defaults</category><body package="FTP">ftpAnonymousUser	^self settings anonymousUser</body><body package="FTP">unixServerTimestampBlock	^unixServerTimestampBlock ifNil: [unixServerTimestampBlock := self defaultUnixServerTimestampBlock]</body><body package="FTP">unixServerTimestampBlock: aBlock	unixServerTimestampBlock := aBlock</body><body package="FTP">useUtf8	^useUtf8 ifNil: [ useUtf8 := self defaultUseUtf8 ]</body><body package="FTP">useUtf8: aBoolean	useUtf8 := aBoolean</body></methods><methods><class-id>Net.FTPChallenge</class-id> <category>initialize-release</category><body package="FTP">initialize	super initialize.	messageText := (#PositiveIntermediateReply &lt;&lt; #net &gt;&gt; '3xx Positive Intermediate reply') asString</body></methods><methods><class-id>Net.FTPResponse</class-id> <category>testing</category><body package="FTP">hasConnectionClosed		^self responseEquals: '421'</body><body package="FTP">isChallenge	^ self isIntermediateReply</body><body package="FTP">isClosedConnection	" Last digit = 6 means 'connection closed' "	^(self codeAt: 3) == $6</body><body package="FTP">isError	^self isPermanentError or: [ self isTransientError or: [ self isUnknownError ] ]</body><body package="FTP">isIntermediateReply	"Positive Intermediate reply. The command has been accepted, but the requested action is being held"	^self responseTypeIs: $3</body><body package="FTP">isPermanentError	^self responseTypeIs: $5</body><body package="FTP">isPreliminaryReply		^(self responseEquals: '125') or: [ self responseEquals: '150']</body><body package="FTP">isSuccess	"Success - The action was received, understood and accepted"	^self responseTypeIs: $2</body><body package="FTP">isTransferAborted" This response is returned when transfer in progress is interrupted by sendingan ABORT command. 	Either thread sending abort or thread performing transfermay receive this response. If this response is seen by ABORT command, it isreturned to the application but exception is suppressed. If data transfer threadsees it, it causes FTPTransientReply exception "	^self responseEquals: '426'</body><body package="FTP">isTransferCompletion	^self code = '226' or: [self code = '250']</body><body package="FTP">isTransientError	^self responseTypeIs: $4</body><body package="FTP">isUnknownError	^code isEmpty not		ifTrue: [ ('12345' includes: code first) not ]</body><body package="FTP">needAccountForLogin		^self responseEquals: '332'</body><body package="FTP">needFileInfo		^self responseEquals: '350'</body><body package="FTP">needMoreInfo	^self isIntermediateReply</body><body package="FTP">needPassword		^self responseEquals: '331'</body><body package="FTP">notImplementedCommand		^self responseEquals: '502'</body></methods><methods><class-id>Net.FTPResponse</class-id> <category>parsing</category><body package="FTP">parse150ForReceive	"Parse a 150 response for a RETR request"	"for RETR-  150 Sending ""c:\serv\test2.bmp"" (100150 bytes). Mode STREAM Type BINARY."	"for STOR-  150 Ready to receive ""c:\serv\test4.bmp"". Mode STREAM Type BINARY."		^self message first equivalentTo: $R ignoreCase: true</body><body package="FTP">parse150Size	"Parse a 150 response for a RETR request.	Returns the expected transfer size or nil.  Size	is not guaranteed to be present in the 150 message."	"150 Sending ""c:\serv\test2.bmp"" (100150 bytes). Mode STREAM Type BINARY."	| string |	(string := self parseForStringFrom: $( toEndString: ' bytes') isEmpty ifTrue: [^nil].	^string asNumber</body><body package="FTP">parse211Features	"Replies to the FEAT command MUST comply with the following syntax.   Text on the first line of the reply is free form, and not   interpreted, and has no practical use, as this text is not expected   to be revealed to end users.  The syntax of other reply lines is   precisely defined, and if present, MUST be exactly as specified.        feat-response   = error-response / no-features / feature-listing        no-features     = 211 SP *TCHAR CRLF        feature-listing = 211- *TCHAR CRLF                          1*( SP feature CRLF )                          211 End CRLF        feature         = feature-label [ SP feature-parms ]        feature-label   = 1*VCHAR        feature-parms   = 1*TCHAR"	| tokens readStream |	tokens := OrderedCollection new.	readStream := self message readStream.	[readStream atEnd]		whileFalse: [ tokens add: ( readStream upTo: Character cr )].	^tokens size &gt; 2		ifTrue: [ tokens copyFrom: 2 to: tokens size - 1 ]		ifFalse: [OrderedCollection new]</body><body package="FTP">parse213AsBytes	"Parse the '213' response for file size in bytes."	^self code = '213' 		ifTrue: [ self message asNumber ]		ifFalse: [ FTPProtocolInterpreter permSignal raiseWith: self  ]</body><body package="FTP">parse213AsTimestamp	"Parse the '213' response for a timestamp represented as YYYYMMDDhhmmss."	| year month day hour minute second |	self code = '213' 		ifFalse: [^FTPProtocolInterpreter permSignal raiseWith: self].	stream := self message readStream.	year := (stream next: 4) asNumber.	month := (stream next: 2) asNumber.	day := (stream next: 2) asNumber.	hour := (stream next: 2) asNumber.	minute := (stream next: 2) asNumber.	second := (stream next: 2) asNumber.	^Timestamp fromDate: (Date 				newDay: day				monthNumber: month				year: year)		andTime: (Time fromSeconds: hour * 3600 + (minute * 60) + second)</body><body package="FTP">parse227HostPort	"Parse the '227' response for a PASV request. 	Raise error_proto if it does not contain 	'(h1,h2,h3,h4,p1,p2)' 	Return ('host.addr.as.numbers' , port#) tuple."	| numbers |	numbers := self parse227HostPortString tokensBasedOn: $,.	numbers size ~~ 6 ifTrue: [ FTPProtocolInterpreter permSignal raiseWith: self message].	numbers := numbers collect: [:ea | Integer readFrom: ea readStream ].	^IPSocketAddress hostAddress: (ByteArray withAll: (numbers copyFrom: 1 to: 4)) port: (ByteArray with: (numbers at: 5)			with: (numbers at: 6))</body><body package="FTP">parse227HostPortString	"Parse the '227' response for a PASV request. 	Raise error_proto if it does not contain 	'(h1,h2,h3,h4,p1,p2)' "		| str left right |	code ~= '227' ifTrue: [ FTPProtocolInterpreter permSignal raiseWith: self message].	left := (str := self message)				nextIndexOf: $(				from: 1				to: str size.	left isNil ifTrue: [ FTPProtocolInterpreter permSignal raiseWith: self  message].	right := str				nextIndexOf: $)				from: left + 1				to: str size.	right isNil ifTrue: [ FTPProtocolInterpreter permSignal raiseWith: str].	^(str copyFrom: left + 1 to: right - 1)</body><body package="FTP">parse230"230 User logged in, proceed.""not done yet"</body><body package="FTP">parse250Dir 	"Parse the '250' response for a CWD request. 	Returns the directory name in the 250 reply."	code ~= '250' ifTrue: [FTPProtocolInterpreter permSignal raiseWith: self printString].	^self parseForQuotedString</body><body package="FTP">parse257Dir 	"Parse the '257' response for a MKD or PWD request. 	Returns the directory name in the 250 reply."	code ~= '257' ifTrue: [FTPProtocolInterpreter permSignal raiseWith: self  printString].	^self parseForQuotedString</body><body package="FTP">parseForQuotedString 	"Parse the FTPresponse for the string inside a pair of quotes" 	^self parseForStringFrom: $" to: $"</body><body package="FTP">parseForStringFrom: aChar1 to: aChar2	"Parse the FTPresponse for the string inside a pair of aCharacter"	| str start stop |	str := self message.	start := str findFirst: [:ch | ch == aChar1].	start = 0 ifTrue: [ ^'' ].	stop := str				nextIndexOf: aChar2				from: start + 1				to: str size.	stop = 0 ifTrue: [ ^'' ].	^str copyFrom: start + 1 to: stop - 1	"get rid of characters"</body><body package="FTP">parseForStringFrom: aChar toEndString: aString	"Parse the FTPresponse for the string inside a pair of aCharacter and aString"	| str start stop |	str := self message.	stop := str indexOfSubCollection: aString startingAt: 1. 	stop = 0 ifTrue: [ ^'' ].	start := str				prevIndexOf: aChar				from: stop				to: 1.	start = 0 ifTrue: [ ^'' ].	^str copyFrom: start + 1 to: stop - 1	"get rid of characters"</body></methods><methods><class-id>Net.FTPResponse</class-id> <category>private</category><body package="FTP">getLine	"Return one line from the server, stripping CR/LF."	| line lineStream |	lineStream := (self stream upTo: Character cr) readStream.	[ Whitespace includes: lineStream peek ] whileTrue: [ lineStream next ].	line := lineStream upToEnd.	self logLine: line.	line ifNil: [self class connectionSignal newException newException					messageText: ( #ReadingFTPResponseReturnsNil &lt;&lt; #net &gt;&gt;'Reading FTP response returns nil ');					raiseRequest ]. 	^line</body><body package="FTP">hasContinuation: tokens" Answer true if this reply has continuation line(s) "	^(tokens at: 2) == self class continuationToken.</body><body package="FTP">isContinuationLine: line" Answer true if this is a reply continuation line "	^(self isLastLine: line) not</body><body package="FTP">isLastLine: tokens 	"Answer true if this is a last line of the response, that is, 	it has space in the fourth position and reply number in positions 	1-3 is the same as the current reply number"	^(tokens at: 2)		== self class terminationToken and: [tokens first = code]</body><body package="FTP">logLine: line	line ifNil: [^nil].	#{Tools.LogEnvironment} ifDefinedDo: [ :le | 		le  default log: [((#get1s &lt;&lt; #net &gt;&gt; '*get* %&lt;&lt;1s&gt;%&gt;')			expandMacrosWith: line)] level: #FTPResponse.]</body><body package="FTP">readResponse	"Read first line of the response. Decode response code.	and answer the line. A reply is defined to contain the 3-digit code, followed by Space&lt;SP&gt;, followed by one line of text"	| tokens line |	tokens := self tokenizeLine: ( line := self getLine) .	code := tokens first.	(code size ~= 3 or: [code anySatisfy: [ :c | c isDigit not ]])		ifTrue: [ ^self class connectionSignal newException					messageText: ( #InvalidFTPResponseCode &lt;&lt; #net &gt;&gt;'Invalid FTP response code ');					parameter: line;					raiseRequest. ].	messageStream nextPutAll: (tokens at: 3).	(self hasContinuation: tokens)		ifTrue: [			[ line := self getLine.			tokens := self tokenizeLine: line.			self isLastLine: tokens]				whileFalse: 					[ tokens last ifNotNil: [ messageStream cr; nextPutAll: tokens last]].			(tokens at: 3) ifNotNil: [messageStream cr; nextPutAll: (tokens at: 3)]]</body><body package="FTP">responseEquals: threeDigitString 	^code asNumber =  threeDigitString asNumber</body><body package="FTP">responseTypeIs: char 	^code isEmpty not		ifTrue: [ code first == char ]</body><body package="FTP">tokenizeLine: aString 	"Answer 4-element array containing 3-character reply code, delimiter character, 	remainder of the string and the string itself"	| answer |	answer := Array new: 4.	aString isNil ifTrue: [ ^answer ].	^[answer		at: 4 put: aString;		at: 1 put: (aString copyFrom: 1 to: 3); 		at: 2 put: (aString at: 4); 		at: 3 put: (aString copyFrom: 5 to: aString size); 		yourself]		on: Object subscriptOutOfBoundsSignal do: [:ex | ex return: answer]</body></methods><methods><class-id>Net.FTPResponse</class-id> <category>initialization</category><body package="FTP">initialize	code := ''.	messageStream := (String new: 64) writeStream.</body></methods><methods><class-id>Net.FTPResponse</class-id> <category>instance creation</category><body package="FTP">readFrom: aStream	self initialize.	self stream: aStream.	self readResponse.</body></methods><methods><class-id>Net.FTPResponse</class-id> <category>accessing</category><body package="FTP">code	^code</body><body package="FTP">codeAt: position" Answer character at specified position inside the status code "	^code at: position</body><body package="FTP">message	^messageStream contents</body><body package="FTP">status" Answer code as a number " 	^code notNil		ifTrue: [ Integer readFrom: code readStream]		ifFalse: [ 0 ]</body><body package="FTP">statusAt: position" Answer digit value of status code at a specified position " 	^(self codeAt: position) digitValue</body><body package="FTP">stream	^stream</body><body package="FTP">stream: aStream	stream := aStream</body></methods><methods><class-id>Net.FTPResponse</class-id> <category>comparing</category><body package="FTP">= other	^code = other code</body><body package="FTP">hash	^code hash</body></methods><methods><class-id>Net.FTPResponse</class-id> <category>printing</category><body package="FTP">printOn: aStream	| textStream |	code isNil ifTrue: [ ^super printOn: aStream ].	aStream nextPutAll: code; space.	messageStream notNil 		ifTrue: [textStream := messageStream contents readStream.		aStream nextPutAll: (textStream nextAvailable: 64).		textStream atEnd ifTrue: [aStream nextPutAll: '...']].</body></methods><methods><class-id>Net.FTPResponse class</class-id> <category>signals</category><body package="FTP">connectionSignal	^FTPConnectionSignal</body></methods><methods><class-id>Net.FTPResponse class</class-id> <category>initialize</category><body package="FTP">initialize	Whitespace := Array with: CR with: LF with: Character tab with: Character space.	self initializeSignals</body><body package="FTP">initializeSignals	FTPConnectionSignal		notifierString: (#needToMakeConnection &lt;&lt; #net &gt;&gt; 'need to make connection'); 		nameClass: self message: #connectionSignal.</body></methods><methods><class-id>Net.FTPResponse class</class-id> <category>instance creation</category><body package="FTP">new	^super new initialize</body><body package="FTP">readFrom: aStream	^self new readFrom: aStream</body></methods><methods><class-id>Net.FTPResponse class</class-id> <category>constants</category><body package="FTP">continuationToken	^$-</body><body package="FTP">terminationToken	^Character space</body></methods><methods><class-id>Net.FTPSettings class</class-id> <category>accessing</category><body package="FTP">anonymousLoginPassword	^anonymousLoginPassword ifNil: [		(Settings defaultIdentity notNil and: [Settings defaultIdentity mailAddress notNil])			ifTrue: [anonymousLoginPassword := Settings defaultIdentity mailAddress].		anonymousLoginPassword		]</body><body package="FTP">anonymousLoginPassword: aString	anonymousLoginPassword := aString</body><body package="FTP">anonymousUser	^NetUser new			fullName: 'anonymous';			username: 'anonymous';			password: self anonymousLoginPassword;			yourself</body><body package="FTP">passiveMode	^passiveMode ifNil: [ passiveMode := self passiveModeDefault]</body><body package="FTP">passiveMode: aBoolean	^passiveMode := aBoolean</body><body package="FTP">passiveModeDefault	^false</body></methods><methods><class-id>Net.MacFTPProtocolInterpreter</class-id> <category>connection management</category><body package="FTP">abort	"Abort a file transfer. Uses out-of-band data. 	Doesn''t follow RFC proceedure to send 	Telnet IP and Synch, 	so maybe this should be changed."	"Macintosh wants propper TCP socket commands, like writeAll:."	| line |	self mutex critical:		[line := 'ABOR' , CrLf.		self socket writeAll: line].	^self getResponse</body></methods><methods><class-id>Net.MacFTPProtocolInterpreter</class-id> <category>private</category><body package="FTP">putCommand: aString 	"Macintosh wants propper TCP socket commands, like writeAll:."	| line |	line := aString , CrLf.	self class log: [((#put1s &lt;&lt; #net &gt;&gt; '*put*  &lt;1s&gt;')			expandMacrosWith: (self sanitize: line))] level: #FTPClient.	self socket isActive 		ifTrue: [self socket writeWait ]		ifFalse: [ 			FTPProtocolInterpreter log: [(#exception &lt;&lt; #net &gt;&gt; '*exception*')] level: #FTPException.			FTPChallenge raise ].	self socket writeAll: line</body></methods><methods><class-id>Net.MacFTPProtocolInterpreter class</class-id> <category>class initialization</category><body package="FTP">initialize	CrLf := String with: Character cr with: Character lf</body></methods><methods><class-id>Net.FTPUser</class-id> <category>accessing</category><body package="FTP">account	^account</body><body package="FTP">account: aString	account := aString</body></methods><methods><class-id>Net.FTPUser</class-id> <category>instance creation</category><body package="FTP">createUser: nameString password: passwdString account: acctString	self username: nameString.	self password: passwdString.	self account: acctString.</body></methods><methods><class-id>Net.FTPUser class</class-id> <category>instance creation</category><body package="FTP">createUser: nameString password: passwdString account: acctString	^self new createUser: nameString password: passwdString account: acctString</body></methods><methods><class-id>Net.Settings class</class-id> <category>deprecation</category><body package="FTP">ftpSettings	^#'Net.FTPSettings' asStrictReference valueOrDo: [nil ].</body></methods><methods><class-id>Net.HostSpec class</class-id> <category>instance creation</category><body package="FTP">ftp: host user: user	^self protocol: #FTP host:  host user: user</body><body package="FTP">ftp: host username: username password: password	^self protocol: #FTP host: host username: username password: password</body></methods><methods><class-id>OS.ExternalReadStream</class-id> <category>testing</category><body package="FTP">noPendingBufferredData	^self basicAtEnd</body></methods><methods><class-id>Core.EncodedStream</class-id> <category>testing</category><body package="FTP">noPendingBufferredData	^stream noPendingBufferredData</body></methods><initialize><class-id>Net.FTPProtocolInterpreter</class-id></initialize><initialize><class-id>Net.FTPResponse</class-id></initialize><initialize><class-id>Net.MacFTPProtocolInterpreter</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>NetClient</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>user hostName portNumber clientPI state </inst-vars><class-inst-vars>defaultProtocolInterpreterClass </class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><class><name>URLwithAuthority</name><environment>OS</environment><super>OS.URLwithPath</super><private>false</private><indexed-type>none</indexed-type><inst-vars>host port </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Resources</category><attributes><package>URISupport</package></attributes></class><class><name>NetError</name><environment>Net</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><class><name>SocketAccessor</name><environment>OS</environment><super>OS.BlockableIOAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>networkFamily </inst-vars><class-inst-vars>concreteClass </class-inst-vars><imports></imports><category>OS-Sockets</category><attributes><package>OS-Sockets</package></attributes></class><class><name>NetPISettings</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tlsContext tlsSubjectVerifier retries timeout delaySeconds </inst-vars><class-inst-vars>defaultDelaySeconds defaultRetries defaultTimeout </class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><class><name>NetUser</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>username password fullName account mailAddress </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><class><name>ExternalReadStream</name><environment>OS</environment><super>OS.BufferedExternalStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.IOConstants.*			</imports><category>OS-Streaming</category><attributes><package>OS-Streaming</package></attributes></class><class><name>NetProtocolInterpreter</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>connection settings </inst-vars><class-inst-vars>defaultNetConnection </class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><class><name>EncodedStream</name><environment>Core</environment><super>Core.PeekableStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>binary stream encoder policy lineEndConvention lineEndCharacter skipSize </inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.IOConstants.*			</imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class></st-source>