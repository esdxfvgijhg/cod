<?xml version="1.0"?><st-source><!-- Name: MQ-DLLCCFixesNotice: Copyright 1999-2016 Cincom Systems, Inc.  All rights reserved.Comment: DllCC  Overrides that were put in By Heeg. this package may go away if Fixes to DLLCC are implemented. These are fixes for finding the external libary to load and should not affect other DLLCC interfaces.DbIdentifier: bear73DbTrace: 492294DbUsername: hguhlDbVersion: 8.1 - 2DevelopmentPrerequisites: #(#(#any 'DLLCC' ''))PackageName: MQ-DLLCCFixesParcel: #('MQ-DLLCCFixes')ParcelName: MQ-DLLCCFixesPrerequisiteParcels: #(#('DLLCC' ''))PrintStringCache: (8.1 - 2,hguhl)Version: 8.1 - 2Date: 12:48:25 PM June 24, 2016 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.2 (jun16.4) of June 24, 2016 on June 24, 2016 at 12:48:25 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><methods><class-id>External.ExternalMethod class</class-id> <category>private</category><body package="MQ-DLLCCFixes">mapVirtualAddressFor: anExternal in: theClass	"Answer true if the receiver can be mapped into the context of the argument; otherwise answer false.  The argument is typically an external interface class.  Mapping is the process of searching for the receiver's entry-point handle either in the argument's dynamic-link libraries or statically linked into the run-time system.  The dynamic-link library search starts at the argument and continues up its superclass chain.  If this search is exhausted then a check for a statically linked entry-point is performed."	| aHandle newVirtuals |	theClass instanceBehavior libraryFiles		detect: [:aLibrary |			aHandle := ([self mapAddressFor: anExternal library: aLibrary]				on: anExternal owner libraryFilesSearchSignals				do: [:ex | ex return: nil]).			aHandle notNil]		ifNone:			[aHandle := self mapStaticFor: anExternal.			aHandle isNil				ifTrue: [self externalObjectNotFoundSignal raiseWith: self. ^nil]].	newVirtuals := (anExternal virtuals isNil		ifTrue: [#()]		ifFalse: [anExternal virtuals]), (Array with: theClass with: aHandle).	anExternal virtuals: newVirtuals.	^newVirtuals</body></methods><methods><class-id>External.ExternalLibraryHolder</class-id> <category>finding</category><body package="MQ-DLLCCFixes">findFile: fileName inDirectories: directoryNames 	"Search for the file indicated by the argument fileName in the directories indicated by the argument, 	 directoryNames. FileName is a String; directoryNames is an array of Strings indicating the directory 	 paths to search, in order. Answer a String indicating the full path of the argument, fileName, if a	 readable copy is found. If the file could not be found, raise libraryNotFoundSignal.	 There are two useful conventions for both the fileName and each directoryName.	 1. If either the fileName or a directory name includes brackets then the string within the brackets	 is taken to be a pattern which is matched against the current platform id. If it matches then	 the attempt to search will occur.  For example, if directoryNames included the following names		'[alpha_osf]dllcc.adux' '[solaris]dllcc.solaris' '[win32*i386]dllcc.nt' '[win32*AXP]dllcc.ant'	 then dllcc.solaris would only be searched if the OSHandle's currentPlatformId matched *solaris*.	 Note that underscores are mapped to spaces, so dllcc.adux is searched if the platform id matches	 '*alpha osf*'.	 2. Environment varaibles are expanded within both the fileName and each directory name.  The	 unix convention is used, that is an environment variable is some alphanumeric string delimited by	$().  So the following directory name expands to the system32 subdirectrory of	 the current windows directory on Windows:			$(windir)\system32	Here's a realistic example that attempts to get at the C library on a number of platforms.  If an ExternalInterface	class's attributes included:		#(#libraryFiles: #('[hp-ux]libc.sl' '[unix]libc.so' '[win]msvcrt.dll'))		#(#libraryDirectories #('[unix]/lib' '[unix]/usr/shlib' '[unix]/usr/lib' '[win]$(windir)\system' '[win]$(windir)\system32'))	then matching against OSHandle currentPlatformID		search for libc.sl if it matches '*hp-ux*',		search for libc.so if it matches '*unix*',		search for msvcrt.dll in if it matches '*win*',		search in directories /lib /usr/shlib /usr/lib if it matches '*unix*', and		search in %windir%\system and %windir%\system32 if it matches '*win*'."	"anExternalLibraryHolder findFile: 'stdio.h' inDirectories: (Array with: '/tmp' with: '/usr/include')"	"First check for a patterned fileName and attempt to match it against the platform."	| file fixedFile |	(fileName includes: $[) 		ifTrue: 			[| pattern |			pattern := fileName copyFrom: (fileName indexOf: $[)						to: (fileName indexOf: $]).			file := fileName copyReplaceAll: pattern with: ''.			pattern replaceAll: $_ with: Character space.			pattern at: 1 put: (pattern at: pattern size put: $*).			"If the platform does not match, answer nil, which will cause the load not to happen."			(pattern match: OSHandle currentPlatformID) ifFalse: [^nil]]		ifFalse: [file := fileName].	file := Filename expandEnvironmentIn: file.	directoryNames size = 0 ifTrue: [^file].	"Support AIX's archive library loading of the form archive.a(object.o)"	('*.a(*.o)' match: file) 		ifTrue: 			[fixedFile := file 						copyReplaceFrom: (file lastIndexOf: $()						to: (file lastIndexOf: $))						with: ''].	"Second, enumerate over each directory searching for an expanded path."	directoryNames do: 			[:dirSpec | 			| dir pattern filePath |			(dirSpec includes: $[) 				ifTrue: 					[pattern := dirSpec copyFrom: (dirSpec indexOf: $[)								to: (dirSpec indexOf: $]).					dir := dirSpec copyReplaceAll: pattern with: ''.					pattern replaceAll: $_ with: Character space.					pattern at: 1 put: (pattern at: pattern size put: $*)]				ifFalse: 					[pattern := '*'.					dir := dirSpec].			(pattern match: OSHandle currentPlatformID) 				ifTrue: 					["Allow empty string as library path to indicate that the filename should be used as is 					and no test for existence should be done, let the OS do its magic to find the file. 					Normally no library path is used for this purpose, but then it is not possible to specify 					this behavior for some platforms only (e.g. MQInterface uses '[win32*]' '[hp*hp-ux]/opt/mqm/lib')."					dir isEmpty ifTrue: [^file].					filePath := (Filename expandEnvironmentIn: dir) asFilename construct: file.					(filePath isReadable or: 							[fixedFile notNil and: 									[((Filename expandEnvironmentIn: dir) asFilename construct: fixedFile) 										isReadable]]) 						ifTrue: [^filePath asString]]].	^self class libraryNotFoundSignal raiseWith: fileName</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>ExternalLibraryHolder</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name directories library owner </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>External-Interface</category><attributes><package>External-Interface</package></attributes></class></st-source>