<?xml version="1.0"?><st-source><!-- Name: MIMENotice: Copyright 1999-2017 Cincom Systems, Inc.  All rights reserved.Comment: This package provides the core framework allowing to manipulate (parse, decode) internet mail messages. Internet messaging and electronic mail standards were defined initially to consist exclusively of plain, US-ASCII text. Such text messaging standards are defined in RFC 822, which is the basis for almost all subsequent internet mail and messaging standards. A text message, as defined in RFC 822, consists of two parts: a header and a body. The header is a collection of fields (date, from, subject). The body, which is optional, consists simply of lines of text.This representation is too limiting for many purposes, however, so internet messaging standards have been extended beyond the capabilities of plain text. MIME, defined in RFCs 2045-2048, provides a standard for embedding other kinds of message body content, such as non-US-ASCII text, binary data, such as executables and images, and multi-part messages. In short, MIME	- defines the structure of multi-part messages	- provides a mechanism for specifying the type of information in the message (content-type)	- describes how non-ASCII information can be transported	- describes how non-ASCII information can be encoded in message headers	- defines 7-bit transport and content transfer encoding	Creating Mime EntitiesA MIME entity is either a header element or a body element in some enclosing message, either a mail message or an HTTP message. Accordingly, they are created for inclusion in some top-level container, the message. For example, you might start with a basic RFC 822 style message:	message := RFC822Message newThis creates a very basic message. You can inspect the result to examine its structure. To this basic structure you add MIME entities as needed. MailMessage provides support for additional message entities that are typically used only by mail messages, such as attachments. Of particular interest is that it has a header instance variable, which holds a set of header entities (initially empty), and a value instance variable, which holds its body, if any.A better way to create a new MIME entity is to send one of these instance creation messages to MimeEntity or a subclass:	#source: aStream - Creates a simple MIME entity from the contents of the Stream.	#fileName: fileNameOrString withEncoding: aSymbol - Creates a simple MIME entity containing the contents of the file, guessing at the MIME type from the aFileName extension. If aFileName does not have an extension, returns default 'application/octet-stream'.	#newTextHTML - Creates a new entity with type text/html.	#newTextPlain - Creates a new entity with type text/plain.	#readFrom: aStream - Creates a new entity from aStream, parsing the information, such as message headers, based on its structure.	#readHeaderFrom:  aStream -  Creates a new entity from aStream, parsing the header information only.The result is a new MimeEntity with the appropriate MIME type specified in the entity header. These will be used in later examples.	Adding Header fieldsMIME defines a few specific header fields and permits others. Net Clients supports adding any of these to the header. Headers that are defined by MIME are supported by specific set/get accessors. A sampling of the setters is (browse the MimeEntity accessing method category for more, and for getters):	#charset: aString - Set the 'charset=aString' to the Content-type header.	#contentId: aString - Add or set the 'ContentId:' header to aString.	#contentLength: anInteger - Add or set the 'Content-length:' header to anInteger.	#contentTransferEncoding: encodingNameString - Add or set the 'Content-transfer-encoding:' header to encodingNameString.	#contentType: aString - Add or set the 'Content-type:' header to aString, with the default charset.	#mimeVersion: aString - Add or set the 'Mime-version:' header to aString.	#addMimeVersion - Add or set the 'Mime-version:' header with the default version string.Any of these can be sent to the message already created to set the header. For example:	message contentType: 'text/xml'.The messages create the appropriate instances of HeaderField subclasses and add them to the header.Some header fields take optional parameters and other information. These are implemented as subclasses of ValueWithParametersField, and provide additional messages for supplying the additional information. For example, ContentTypeField represents the content-type field in MIME and HTTP protocols, which may specify a type, a subtype, may specify a character set for text types, and boundary for multipart subtypes, and so on. If you use these header fields, browse the class for supporting messages.Additional fields can be added to the header for informational purposes. This is done by creating a HeaderField with a value and adding that to the message header. For example:	header := HeaderField name: 'MyField'.	header value: 'dummy'.	message addField: header.Another useful message is getFieldAt:, which takes a field name as a String for its argument. If the field already exists, the message returns the field and its value. If the field does not yet exist, it is created, and you can then provide a value for it. The following expression checks for a field's existence, creates it if necessary, and sets its value:	(message getFieldAt: 'bogus' ) value isNil		ifTrue: [ message fieldValueAt: 'bogus' put: 'stuff' ]The Mail and HTTP packages provide protocol for adding headers that are meaningful for specific types of messages.	Adding a bodyInstances of MimeEntity and its subclasses include a value instance variable that contains the message body, which holds either a SimpleBody or a MultipartBody (which are subclasses of MimeMessageBody).	Simple BodyInitially value holds an empty SimpleBody. To access the body, send a body message to the message:	message bodyTo give the body a simple content, such as a String, send a value: message to it:	message contents:: 'web text'A better way to specify the body is when the message is created initially, by using the source: instance creation method:	message := MimeEntity source: 'some text' readStream.There are a couple other instance creation methods, defined in MimeEntity (such as readFrom: illustrated below), that do the same. This has the advantage of creating the message with the correct content type, and creating the SimpleBody with value 'some text'.The following is a more complete example of creating a MIME mail message using this last approach:	string :='Date: 27 Aug 76 09:32 PDTFrom: Jon Doe <JDoe@This-Host.This-net>Subject: Re: The Syntax in the RFCSender: KSecy@Other-HostReply-To: Sam.Irving@Reg.OrganizationTo: George Jones <Group@Some-Reg.An-Org>,Al.Neuman@MAD.PublisherMessage-ID: <4231.629.XYzi-What@Other-Host>A bunch of text.'.	message := MimeEntity readFrom: string readStream.This specifies the entire message, including message headers (Date,From, Subject, etc.) as a String in the form specified for a MIME message. The last line uses the readFrom: instance creation method to create the MIME message from the String.	Multipart BodyMIME provides the capability of multipart messages, consisting of multiple MIME body elements preceded, followed, and separated by a boundary marker. NetClients represents a multipart message as a message with a MultipartBody, which holds a collection of MimeEnties as body parts. To create a multipart body, simply send an addPart: message to the MIME message with a MimeEntity as the argument:	message := MimeEntity source: 'some text' readStream.	newEntity := MimeEntity source: 'some other text' readStream.	message addPart: newEntity.If the MIME message currently has a SimpleBody, addPart: mutates the current body to a MultipartBody, with the original body as the first body part, and adds the new element to the collection of body parts. If the body is already a MultipartBody, the new part is simply added to the collection. As explained above, using the source:, or other MimeEntity instance creation methods, invokes the MIME framework to provide the correct content type.Body parts are separated by a 'boundary'. A default boundary is provided, but you probably want to specify your own. After the body has been converted to multipart, you can specify the boundary by sending aboundary: message to the MIME message:	message boundary: 'some_string_that_will_not_occur_naturally'The boundary delimiter begins with -  (two hyphens), which are provided by VisualWorks. The String may be up to 70 characters, and must be such that it does not occur in any of the embedded elements. Any strategy to create such a String can be used.	Creating a File AttachmentYou can create a file attachment for an external file by sending the fileName: instance creation message to MimeEntity. For example:	attachment := MimeEntity fileName: 'visual.im' withEncoding: #'Windows-1252'.The entity is created with the proper content type. You can then add the entity to a message as a part, as described above.	Reading and Writing a MIME Message.If you have a message in MIME format, whether simple or multipart, in a file, you can create a MIME message from it directly. To do so, you pass the message through the parser by sending readFrom: with aReadStream on the file:	stream := String new readWriteStream.	message writeOn: stream.	stream reset.	message := MimeEntity readFrom: stream.If your text file properly defines a message, the result is a message with all the parts defined in the file. This differs from:	MimeEntity source: streamwhich will create a new, single part, text/plain message with the stream being the source of its body.	Accessing headersSeveral messages are provided for accessing header fields. The following messages, and variations of them, are defined in the accessing field and body parts message category in MimeEntity. Theseprovide general access to fields in MIME entities.	#fieldValueAt: aString - Returns the value of the header field named aString, or nil if it doesn't exist or is empty.	#fieldsAt: aString - Returns a List of all header fields named aString. This is useful if there are multiple header fields with the same name, as is permitted by MIME.	#getFieldAt: aString - Returns the value of header field aString if it exists; otherwise creates the field.Notice that the header fields have initial lower-case names. There are specific messages for accessing particular fields as well, especially content related fields. These are implemented using the above methods, providing an easier to use interface.	#contentId - Returns the value of the content-id field.	#contentLength - Returns the value of the content-length field.	#contentType - Returns the value of the content-type field.RFC822Message defines additional messages for accessing headers of specific interest in mail messages. Browse the accessing method category for the complete set. The following is a small sample of the available messages.	#to - Returns the contents of the to field.	#from - Returns the contents of the from field.	#bcc - Returns the contents of the bcc field.	#cc - Returns the contents of the cc field.	#date - Returns the value of the date field.	#replyTo - Returns the value of the reply-to field.	Accessing bodiesA MIME message may have a single-part (SimpleBody) or multipart (MultipartBody) body, or no body at all. The basic MimeEntity protocol for accessing bodies consists of thesemessages:	#contents - For a simple message, returns a ByteString containing the message body. For a multi-part message, returns an OrderedCollection of the parts, which are instances of MimeEntity.	#parts - Returns an OrderedCollection of the message parts of a multi-part message (same as contents). The collection is empty for a simple message.	#partAt: partIndex - Returns the MimeEntity at the specified partIndex of the collection returned by parts.To test whether the body is simple or multi-part, send an isMultipart message to the message. The response is a Boolean which you can use to choose how to process the message. For example, this returns themessage text as a ByteString for either:	message isMultipart ifTrue: [ ^(message partAt: 1) contents ].	^message contents.Given a multi-part message, which will be an instance of MailMessage, there are additional messages you can send it to operate on its text part or parts. Browse the accessing and utility method categories for these operations. For example, texts are often included in a variety of formats, such as text/plain or text/html, providing the mail reader a choice of text formats to use for display purposes. When there are alternatives, the text type itself is multipart/alternative, and each format is provided as a part. The following messages allow you access these formats and parts.	#allAlternativeTextFormats - Returns a collection of all alternative text formats.	#allTextParts - Returns a collection of all text parts.	#prepareForTransport - Verifies that fields are in proper order, that required fields are present, that assigned boundaries are present, and that attachments are base64 encoded.	#replaceTextWith: aString - Replaces the message body with aString, and resets the content type.	#saveAttachment: aMimeEntity on: aStream - Writes aMimeEntity on aStream using appropriate encoding.	#saveAttachmentAt: anIndex on: aStream - Writes the message attachment at anIndex on aStream with appropriate encoding.	#saveTextOn: aStream - Writes the message text on aStream. If the text includes alternates, all are written in the order they occur.	#saveTextOn: aString inPreferenceOrder: anArrary - Writes all alternate message texts on aStream in the order specified by anArray, e.g., #('html' 'plain' '*')	#text - Returns the plain text part of a message text.	#textInPreferenceOrder: - Returns text in all alternative formats, in the specified order.	Getting content information of a message partMessage parts are MIME entities, and so you can get the usual MIME information from it. For example, the following code checks a multi-part message to verify that the first part is plain text, and if so, returns the text:	(message isMultipart and: [ ( message partAt: 1 ) contentType = 'text/plain' ])		ifTrue: [ ( message partAt: 1 ) contents ].	Header fields transfer encodingTo send header fields in non-ASCII character sets you will need to specify a character set for the message header ( MimeEntity>>headerCharset:).stream := String new writeStream.(MailMessage new).....		charset: 'iso-8859-2';		date: Timestamp now; 		headerCharset: 'iso-8859-2';		writeOn: stream.stream contentsThe header fields will get encoded asFrom: =?iso-8859-2?Q?=AElva=20?= =?iso-8859-2?Q?=E1belsk=E9=20?= =?iso-8859-2?Q?=F3dy?=<zzz@m.com>Subject: =?iso-8859-2?B?UO1sabkgvmx1b3Vr/V9ubyBoZWFkZXJDaGFyc2V0IA==?=To: =?iso-8859-2?Q?Bo=BEidar=20?= 	Message transfer encodingMIME entities can be encoded using the encoding scheme specified in the content-transfer-encoding field. Encoding is necessary to encode data for transfer over some transfer protocols, such as SNMP which restricts mail message data to 7-bit US-ASCII.Net Clients supports the two standard encoding schemes, base64 and quoted-printable, which transform messages to conform to the 7-bit USASCII restriction. Other encodings can be specified, but Net Clients does not provide the encoding.Quoted-printable is used for message bodies that are mostly 7-bit USASCII, but may contain a few 8-bit characters. Any 8-bit characters are transformed to be represented as character $= followed by the two-digit hexadecimal representation.Base64 encoding is used for message bodies if quoted-printable is not appropriate. It represents arbitrary octets in a 65 character subset of USASCII. Base64 encoding can be used, for example, to include binary data in a mail message, such as in an attachment.Net Clients protocol for encoding and decoding is very simple. These messages are sent to a MimeEntity, typically a SimpleBody:	#addContentTranferEncoding: anEncoding - Modifies the receiver MimeEntity to include the content-transfer-encoding header for anEncoding, and encodes the body as appropriate. The String specifying anEncoding is not validated, but must be either 'base64' or 'quoted-printable' (case sensitive) for the body to be encoded. If you do not add the content transfer encoding for mail message attachments that are not plain text, the mail client adds default encoding 'base64' when the message is sent.	#removeContentTransferEncoding - Removes the content-transfer-encoding header and decodes the body if it had been either base64 or quoted-printable encoded.For example, if you added a part that should be encoded (and did not use a message like addFileAttachment: that handles the encoding), you can access the part and apply the encoding:	( message parts at: 2 ) addContentTransferEncoding: 'base64'Removing content transfer encoding is a configurable setting.	MimeBuildHandler mailRemoveContentTransferEncoding: true.The default setting is false. If set to true, content transfer encoding is removed while parsing the message. To remove the encoding from a part of a received message, send:	( message parts at: 2 ) removeContentTransferEncoding	Working with AttachmentsAttachments are files included in a message, but typically in a format recognizable to an application other than the reader. The following messages for handling attachments is provided by MailMessage.	#addFileAttachment: aFilename - Adds a part to the message containing the specified aFilename, and encodes it appropriately.	#attachments - Returns an OrderedCollection of MimeEntity instances containing the attachments.	#attachmentAt: index - Returns the MimeEntity containing the attachment at index.	#attachmentNames - Returns a List of the file names of the attachments.	#saveAttachment: aMimeEntity on: aStream - Writes the attachment aMimeEntity on aStream.	#saveAttachmentAt: index on: aStream - Writes the attachment at index on aStream.There is an configurable setting MimeParserHandler class>>saveAttachmentsAsFiles that allows saving attachements in to external files while parsing a mail messages. If the option is true the builder will save attachments in to an external file. The external file name will be create from 'Content-Disposition' field filename attribute if any. If there is no filename in the attachment the random name will be generated. The AttachmentFilename notification will be raised allowing to provide a new file name. If the #saveAttachmentAsFile option is false (default for mime entities) the attachment will be save in to internal stream. Attachment files are saved in a directory, which is by default named mail-temp-files located in the image directory. To change the default directory use the following expression:MimeParserHandler defaultAttachmentDirectory:  'myDirectory'.AttachmentFilename, allowing the user to override the file name on the fly.Here is an example:Saving attachments directly into external files while parsing a message (streams the attachment directly into a file 'my-budd.jpg' in the current directory; the corresponding message part's source becomes an external stream on that file)	input := 'From: zz@holcim.comContent-Type: multipart/related;	boundary="- 11"- - 11Content-Type: image/jpg; name="budd.jpg"Content-Disposition: attachment; filename="budd.jpg"Content-Transfer-Encoding: base64QWxhZGRpbjpvcGVuIHNlc2FtZQ==- - 11- ' readStream.	[	message := MailBuildHandler new				saveAttachmentsAsFiles: true;				removeContentTransferEncoding: true;				readFrom: input. 	] 		on: AttachmentFilename		do:  [ :ex | ex resume: 'my-', ex filename asFilename tail ].DbIdentifier: bear73DbTrace: 500255DbUsername: tkoganDbVersion: 8.3 - 2DevelopmentPrerequisites: #(#(#any 'NetClientBase' '') #(#package 'Protocols-Common' '') #(#package 'Compression-ZLib' ''))PackageName: MIMEParcel: #('MIME')ParcelName: MIMEPrerequisiteParcels: #(#('NetClientBase' '') #('Protocols-Common' '') #('Compression-ZLib' ''))PrintStringCache: (8.3 - 2,tkogan)Version: 8.3 - 2Date: 2:30:29 PM April 28, 2017 --><time-stamp>From VisualWorks®, Pre-Release 8.3 (apr17.3) of April 28, 2017 on April 28, 2017 at 2:30:29 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>InvalidHeaderField</name><environment>Net</environment><super>Net.NetNotification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>MIME</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.InvalidHeaderField</class-id><body>Raised when the a parsed header field doesn't conform to it's required structure.</body></comment><class><name>HeaderField</name><environment>Net</environment><super>Net.MessageElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.HeaderField</class-id><body>This class represents header fields in RFC822 and MIME messages. Related RFCs numbers are 822, 2045-2048 and 2183.Each field has name and value. The general syntax of RFC822 fields is	name: value&lt;CrLf&gt;Fields can occupy more than one line using line folding techniques. Values can be structured or unstructured. Unstructured value is considered to be text (RFC822 defines text as any sequence terminated by CrLf, but MIME specifies how non-ASCII characters can be encoded into text, so there is some decoding involved when text lexems are parsed or composed. This class provides enough logic to processunstructured fields. Its subclasses implement structure fields.Structured fields have defined syntax. For each structured field a subclass of HeaderField is created to capture its syntax and semantics. Many fields share common syntax (i.e. address fields in RFC822, date and version fields across a number of protocols. All fields with the same syntax can be handled with signle class unless semantical differences justify introduction of a separate class.Fields are responsible for parsing themselves from a stream and composing (writing) themselves on stream. Parsing is done with a help of a scanner which has interface of RFC822Scanner.  Fields specific to protocols derived from RFC822 use specialized scanners that support protocol-specific syntax. A field can parse itself from a string, stream or RFC822 scanner. 	Examples:	ContentTypeField fromLine: 'content-type: text/html'	HeaderField readFrom: 'content-type: text/html' readStream	HeaderField parse: (RFC822Scanner on: 'content-type: text/html' readStream)	Handling non ASCII characters:	string := 'Content-Disposition: attachment; filename="PÅ™ÃÅ™Ã"'. 	HeaderField readFrom: string readStream signalNonAsciiCharacters: false. - will allow parsing non ASCII characters	HeaderField readFrom: string readStream -  will raise the NonASCIICharacter exception	Internally, string is wrapped in a stream, stream is wrapped in RFC822 scanner. Parsing is invoked  by calling #parse:.Parsing and composing is always done on the instance side; class methods create new instance and invoke instance side method to complete parsing. The only processing done on the class side is reading field name and finding proper header field class for specified field name (field factory).Note: the current factory scheme is based on scanning subclasses and might need a little more work because each protocol may need its own field factory. Currently a subclass implements class method #fieldNames that answers an array of field types that this class recognizes.Each field also stores its source. This is significant for mail protocol because it allows to reproduce fields verbatim if a message containing the field is to be resent, forwarded, etc. RFC822 and other standards strongly advise against any rewriting of message fields if it is not absolutely necessary. Source is stored in inherited instance variable source which is a stream; the value is the stream's contents. Subclasses may disable storing source. See MessageElement for more details.Typically fields are built not by MimeEntity itself, but rather by MimeParserHandler. MimeParserHandler decides whether to store source in a field. One other application of storing source -- if a message is read from mail file containing multiple message, a MailFileReader stores StreamSegment as method source. This way each message element knows its exact location in the file and fields can be changed and written back to the file in place one-by-one.Instance Variables:	name	&lt;String&gt; the field nameShared Class Variables:	FieldsRegistry	&lt;Dictionary key: String value: Class&gt; maps header field names to corresponding classes used to represent those fieldsClass Variables:	FieldsRegistry	&lt;IdentityDictionary&gt;	 used to store field factory bindings;</body></comment><class><name>StructuredHeaderField</name><environment>Net</environment><super>Net.HeaderField</super><private>false</private><indexed-type>none</indexed-type><inst-vars>comment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.StructuredHeaderField</class-id><body>This class is an abstract class for all structured fields. Each specific structured field type has to implement its own parsing by overriding #parse: method. This class only provides some utility method to help parse some common constructs such as parameters.Instance Variables:	comment	&lt;String&gt; stores the optional field comment</body></comment><class><name>CollectionField</name><environment>Net</environment><super>Net.StructuredHeaderField</super><private>false</private><indexed-type>none</indexed-type><inst-vars>separator </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.CollectionField</class-id><body>CollectionField is super class for header fields which value is collection.Instance Variables:	separator	&lt;Character&gt; the character used to separate field value elements</body></comment><class><name>InvalidParameterValue</name><environment>Net</environment><super>Net.NetNotification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.InvalidParameterValue</class-id><body>InvalidParameterValue notification is raised if a parser detected invalid parameter. The default action skips the invalid parameter.</body></comment><class><name>ScalarField</name><environment>Net</environment><super>Net.StructuredHeaderField</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.ScalarField</class-id><body>This class is the superclass for all fields whose value represents a scalar value. Examples are date field, maibox field, version field, etc. So for the date field field's value will be parsed date object, not a string representation of date (field's source would still hold the string representation). Each specific field type should implement method #parse:</body></comment><class><name>NumericField</name><environment>Net</environment><super>Net.ScalarField</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.NumericField</class-id><body>I represent numeric fields such as content-length. My value is a number. String representation of value can be accessed using #asStringExample:	Content-length: 1123Instance Variables:</body></comment><class><name>MimeDispatcher</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>handler </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.MimeDispatcher</class-id><body>This class is an abstract superclass for all classes that traverse structure of RFC822, Mime, HTTP, etc. messages. Subclasses perform tasks such as printing, searching, etc. Structure traversing is implemented via visitor pattern. Visitor pattern (GoF, p 331-344) allows to separate concerns and tasks from the hierarchical message structure. We can do some very sophisticated searches and data mining inside complex messages, develop nice printing mechanisms, message transformation schemes (answers, forwarding, etc).Instance Variables:	handler &lt;DispatcherHandler&gt; writes/prints the message</body></comment><class><name>MimeMessageBody</name><environment>Net</environment><super>Net.MessageElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.IOConstants.*			</imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.MimeMessageBody</class-id><body>This is an abstract superclass for Mime message bodies. Message bodies can be simple or multi-part.  Mail messages can be complex and deeply nested and their parts can be very large. In many cases we may not need contents of one or more message parts, so it makes sense not to parse messages too deep and only read data into memory when we actually need it. For this reason parsing and value initialization is done lazily. Source stream is remembered so that parsing can be done at later time.Messages can also have external parts where data can be retrieved from external sources (e.g. from external file or FTP servers). Because streams are a universal mean of accessing external resources, storing source stream also encapsulates part access logic.</body></comment><class><name>SinglepartBody</name><environment>Net</environment><super>Net.MimeMessageBody</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.SinglepartBody</class-id><body>Abstract superclass for simple bodies.</body></comment><class><name>SimpleBody</name><environment>Net</environment><super>Net.SinglepartBody</super><private>false</private><indexed-type>none</indexed-type><inst-vars>byteSource </inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.IOConstants.*			</imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.SimpleBody</class-id><body>This class represents simple message bodies. Simple message body's value is its contents, which is a string. Simple message bodies make no attempt to decode or transform its contents, it is responsibility of higher-level code. Parsing and value initialization is done lazily. Source stream is remembered so that parsing can be done at any time.Instance Variables:	byteSource &lt;Stream of ByteArray&gt; it will always contain row bytes parsed by a parser handler and the #source stream will always contain decompressed or decoded ByteString. The MailBuildReader set the #byteSource to a StreamSegment pointing to an original mail file and the #source is set as stacks of streams that are built on top of the #byteSource to completely decode the body.</body></comment><class><name>NetworkEntityDescriptor</name><environment>Net</environment><super>Net.MessageElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>alias comment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.NetworkEntityDescriptor</class-id><body>This class is an abstract class for mailbox address and mail group address descriptors as defined in RFC5322. All addresses may have an address part and alias part. Address part defines the actual networ address while alias is a human-readable name associated with the address.Main purpose of descriptors is to be able to parse and compose address string into indivudual components, check syntax, provide canonical value and decode non-ascii characters in alias.While address syntax is defined in rfc822, the individual tokens (namely, phrase representing alias) are further developed in Mime (rfc2048) to provide for non-ascii characters. Therefore, message is parsed using rfc822 syntactic rules including rfc822 character table. Once parsed, individual lexical tokens are scanned using Mime rules.http://www.rfc-editor.org/rfc/rfc5322.txtSubclasses must implement the following messages:	printing	printCanonicalValueOn:Instance Variables	alias	&lt;OrderedCollection&gt;  Collection of words comprising alias. Access alias using #aliasString	comment	&lt;String&gt;  Comment string if present as part of the address	parsingErrorDescription &lt;String&gt; if there is a problem parsing the network address this inst. var. is going to hold the parsing error description. If the address is valid the #parsingErrorDescription is nil</body></comment><class><name>MessageStream</name><environment>Net</environment><super>Core.Stream</super><private>true</private><indexed-type>none</indexed-type><inst-vars>stream position readLimit </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HTTP</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.MessageStream</class-id><body>MessageStream is the super class for message streams. The streams help to parse MIME and HTTP messages.Instance Variables:	position	&lt;Integer&gt;	current position	readLimit	&lt;Integer&gt;	maximum number bytes to read	stream	&lt;Stream&gt;	external, socket or internal stream to parse</body></comment><class><name>NetworkAddressDescriptor</name><environment>Net</environment><super>Net.NetworkEntityDescriptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>domain localPart route </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.NetworkAddressDescriptor</class-id><body>This class represents RFC5322 network addresses. An address may have address part, alias and comment. Each one is optional. http://www.rfc-editor.org/rfc/rfc5322.txtInstance Variables	domain	&lt;SequencableCollection of Strings&gt;  Domain parts domainString answers domain string	localPart	&lt;SequencableCollection of Strings&gt;  Parts of local part. localPartString answers string	route	&lt;Collection | EncodedStream | PositionableStream&gt;  Route part of the address. routeString answers route stringThe formal grammar is as follows:return          =   "Return-Path:" path CRLFpath            =   angle-addr / ([CFWS] "&lt;" [CFWS] "&gt;" [CFWS])resent-sender   =   "Resent-Sender:" mailbox CRLFsender          =   "Sender:" mailbox CRLF   FWS             =   ([*WSP CRLF] 1*WSP) /  obs-FWS                                          ; Folding white space   comment         =   "(" *([FWS] ccontent) [FWS] ")"   CFWS            =   (1*([FWS] comment) [FWS]) / FWSaddress         =   mailbox / groupmailbox         =   name-addr / addr-specname-addr       =   [display-name] angle-addrangle-addr      =   [CFWS] "&lt;" addr-spec "&gt;" [CFWS] / obs-angle-addrgroup           =   display-name ":" [group-list] ";" [CFWS]display-name    =   phrasemailbox-list    =   (mailbox *("," mailbox)) / obs-mbox-listaddress-list    =   (address *("," address)) / obs-addr-listgroup-list      =   mailbox-list / CFWS / obs-group-listaddr-spec       =   local-part "@" domainlocal-part      =   dot-atom / quoted-string / obs-local-partdomain          =   dot-atom / domain-literal / obs-domaindomain-literal  =   [CFWS] "[" *([FWS] dtext) [FWS] "]" [CFWS]dtext           =   %d33-90 /          ; Printable US-ASCII                       %d94-126 /         ;  characters not including                       obs-dtext          ;  "[", "]", or "\" word            =   atom / quoted-string phrase          =   1*word / obs-phrase  atext           =   ALPHA / DIGIT /    ; Printable US-ASCII                       "!" / "#" /        ;  characters not including                       "$" / "%" /        ;  specials.  Used for atoms.                       "&amp;" / "'" /                       "*" / "+" /                       "-" / "/" /                       "=" / "?" /                       "^" / "_" /                       "`" / "{" /                       "|" / "}" /                       "~"  atom            =   [CFWS] 1*atext [CFWS] specials        =   "(" / ")" /        ; Special characters that do                       "&lt;" / "&gt;" /        ;  not appear in atext                       "[" / "]" /                       ":" / ";" /                       "@" / "\" /                       "," / "." /                       DQUOTE4.4.  Obsolete Addressing   There are four primary differences in addressing.  First, mailbox   addresses were allowed to have a route portion before the addr-spec   when enclosed in "&lt;" and "&gt;".  The route is simply a comma-separated   list of domain names, each preceded by "@", and the list terminated   by a colon.  Second, CFWS were allowed between the period-separated   elements of local-part and domain (i.e., dot-atom was not used).  In   addition, local-part is allowed to contain quoted-string in addition   to just atom.  Third, mailbox-list and address-list were allowed to   have "null" members.  That is, there could be two or more commas in   such a list with nothing in between them, or commas at the beginning   or end of the list.  Finally, US-ASCII control characters and quoted-   pairs were allowed in domain literals and are added here.   obs-angle-addr  =   [CFWS] "&lt;" obs-route addr-spec "&gt;" [CFWS]   obs-route       =   obs-domain-list ":"   obs-domain-list =   *(CFWS / ",") "@" domain                       *("," [CFWS] ["@" domain])   obs-mbox-list   =   *([CFWS] ",") mailbox *("," [mailbox / CFWS])   obs-addr-list   =   *([CFWS] ",") address *("," [address / CFWS])   obs-group-list  =   1*([CFWS] ",") [CFWS]   obs-local-part  =   word *("." word)   obs-domain      =   atom *("." atom)   obs-dtext       =   obs-NO-WS-CTL / quoted-pair   When interpreting addresses, the route portion SHOULD be ignored.</body></comment><class><name>ValueWithParametersField</name><environment>Net</environment><super>Net.StructuredHeaderField</super><private>false</private><indexed-type>none</indexed-type><inst-vars>separators </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.ValueWithParametersField</class-id><body>This class is an  abstract class that provides infrastructure for Mime and HTTP fields that have value and optional parameters. The class defines logic for parsing and composition. Subclasses may perform more detailed parsing of field value. Subclasses also add accessor methods to access specific parameters (such as 'charset' or 'boundary' in content-type field or 'fileName' in content-disposition fieldFor example, the syntax of content-type field as defined in rfc2045 is as follows:  content := "Content-Type" ":" type "/" subtype             *(";" parameter)             ; Matching of media type and subtype             ; is ALWAYS case-insensitive.  parameter := attribute "=" value  value := token / quoted-stringSome of the most important fields, namely content-type and content-disposition types are value with parameters fields.</body></comment><class><name>SingleValueWithParametersField</name><environment>Net</environment><super>Net.ValueWithParametersField</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.SingleValueWithParametersField</class-id><body>SingleValueWithParametersField is an abstract class that provides infrastructure for Mime and HTTP fields that have value and an one parameter</body></comment><class><name>ContentDispositionField</name><environment>Net</environment><super>Net.SingleValueWithParametersField</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.ContentDispositionField</class-id><body>This class represents content-disposition field as defined by RFC2183.Content-disposition field designates Mime entity as 'inline' or ''attachment'. 'Inline' parts can be displayed automatically whereas 'attachments' are located externally and require some action from the user. These can be displayed as iconized images. Content-disposition field also provides fiel name and essential file attributes to help in saving file and determining its Mime type of its contents.Default setting is 'attachment' and can be reset as	ContentDispositionField defaultContentDisposition: 'inline'.This class provides accessor methods for standard parameters of this field. These methods are also provided in MimeEntity class (category content-disposition)Excerpts from RFC2183:   MIME specifies a standard format for encapsulating multiple pieces of   data into a single Internet message. That document does not address   the issue of presentation styles; it provides a framework for the   interchange of message content, but leaves presentation issues solely   in the hands of mail user agent (MUA) implementors.   Two common ways of presenting multipart electronic messages are as a   main document with a list of separate attachments, and as a single   document with the various parts expanded (displayed) inline. The   display of an attachment is generally construed to require positive   action on the part of the recipient, while inline message components   are displayed automatically when the message is viewed. A mechanism   is needed to allow the sender to transmit this sort of presentational   information to the recipient; the Content-Disposition header provides   this mechanism, allowing each component of a message to be tagged   with an indication of its desired presentation semantics.   Tagging messages in this manner will often be sufficient for basic   message formatting. However, in many cases a more powerful and   flexible approach will be necessary. The definition of such   approaches is beyond the scope of this memo; however, such approaches   can benefit from additional Content-Disposition values and   parameters, to be defined at a later date.   In addition to allowing the sender to specify the presentational   disposition of a message component, it is desirable to allow her to   indicate a default archival disposition; a filename. The optional   "filename" parameter provides for this.  Further, the creation-date,   modification-date, and read-date parameters allow preservation of   those file attributes when the file is transmitted over MIME email.2.  The Content-Disposition Header Field   Content-Disposition is an optional header field. In its absence, the   MUA may use whatever presentation method it deems suitable.   It is desirable to keep the set of possible disposition types small   and well defined, to avoid needless complexity. Even so, evolving   usage will likely require the definition of additional disposition   types or parameters, so the set of disposition values is extensible;   see below.   In the extended BNF notation of [RFC 822], the Content-Disposition   header field is defined as follows:     disposition := "Content-Disposition" ":"                    disposition-type                    *(";" disposition-parm)     disposition-type := "inline"                       / "attachment"                       / extension-token                       ; values are not case-sensitive     disposition-parm := filename-parm                       / creation-date-parm                       / modification-date-parm                       / read-date-parm                       / size-parm                       / parameter     filename-parm := "filename" "=" value     creation-date-parm := "creation-date" "=" quoted-date-time     modification-date-parm := "modification-date" "=" quoted-date-time     read-date-parm := "read-date" "=" quoted-date-time     size-parm := "size" "=" 1*DIGIT     quoted-date-time := quoted-string                      ; contents MUST be an RFC 822 `date-time'                      ; numeric timezones (+HHMM or -HHMM) MUST be usedShared Class Variables:	DefaultContentDisposition	&lt;String&gt; default contents disposition. The default value is 'attachment'</body></comment><class><name>MessageHeader</name><environment>Net</environment><super>Net.MessageElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>registry </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.MessageHeader</class-id><body>I represent header fields in rfc822 messages. RFC822 messages may have repeated fields, order of field appearance is significant, and there are manadatory rules that certain fields should precede all other fields. This class encapsulates all this logic. Fields are represented by an instance of Dictionary. Value at a key is always an ordered collection of values. Each occurrence of the field adds another element to this collection. When a field is removed and its value is an empty collection, the whole entry is removed. Usually, when fields are parsed from a message, their sequence is already correct. If fields are added dynamically, some fields may appear in the wrong order, so part of preparing a message for transport is re-arranging fields to ensure correct sequenceInstance Variables:	registry 	&lt;Dictionary&gt; header fields</body></comment><class><name>MessageScanner</name><environment>Net</environment><super>Net.SimpleScanner</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.MessageScanner</class-id><body>This class is an abstract class for all mail-related scanners. It provides some common printing methods for lexical types that are used by all subclasses -- atom, text, quoted text</body></comment><class><name>RFC822Scanner</name><environment>Net</environment><super>Net.MessageScanner</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.RFC822Scanner</class-id><body>This class performs scanning/parsing of rfc822 messages. It implements scanning routines for rfc822 lexical types (see 'multi-character scans') and general tokenization logic. Shared Variables:	AtomMask	&lt;Integer&gt;  Mask for rfc822 Atoms	CommentMask	&lt;Integer&gt;  Mask for rfc822 Comments ()	DomainTextMask	&lt;Integer&gt;  Mask for rfc822 Domain Text	HeaderNameDelimiterChar	&lt;Character&gt;  $:	HeaderNameMask	&lt;Integer&gt;  Mask for rfc822 header field names	QuotedPairChar	&lt;Character&gt;  $\	QuotedPairMask	&lt;Integer&gt;  Mask for rfc822 quoted-pair (\x)	QuotedTextMask	&lt;Integer&gt;  Mask for rfc822 quoted-text	SimpleTimeZones	&lt;Dictionary key: ?type? value: ?type?&gt;  comment	TextMask	&lt;Integer&gt;  Mask for rfc822 text	TokenMask	&lt;Integer&gt;  Mask for rfc822 tokens</body></comment><class><name>BlockBody</name><environment>Net</environment><super>Net.SinglepartBody</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.IOConstants.*			</imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.BlockBody</class-id><body>This is a special type of simple body whose contents are generated at the time when the message is being written, by invoking its source as a block, with the fully prepared socket stream as the argument. It is especially useful to implement "content streaming" for web applications.</body></comment><class><name>MimeEntity</name><environment>Net</environment><super>Net.MessageElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>header headerCharset readingOptions writingOptions </inst-vars><class-inst-vars>defaultTextCharset defaultTextType </class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.MimeEntity</class-id><body>I represent Mime entity as defined by RFC2045. Mime entities form a basis for mail messages and HTTP. A Mime entity is basically and object that has header and a body. Header consists of fields each of which has a name and (potentially complex) value. A body can be either a simple or multipart body. Simple body has contents, which is either a string, or byte array. Multipart body consists of multiple parts, each of which is a Mime entity in itself.Header fields describe entity contents or provide additional information. Header fields are represented by hierarchy of classes starting at HeaderFields. Some fields have known structure and syntax, the rest are considered to be just a text field. Mime defines a few standard fields, they all start with content-*. The most important field is content-type field. It defines type of information that entity represents (see rfc2045 for details). MimeEntity provides methods to access/set aspects of content-type field:	type		(default 'text')	subtype		('plain')	contentType (=type/subtype	default 'text/plain')	charset		(default charset from parent entity (RFC822Message/HttpEntity) or if the parent is nil - 'iso-8859-1')	boundary	(default nil, should be specified for multipart entities)	headerCharset (default nil, is used to encode header fields that have non ASCII characters)Other notable fields include content-length (contentLength) and content-disposition (fileName).Fields may occur more than once and sometimes have to occur in particular sequence. MimeEntity allows multiple fields with the same name and remembers field order. There are various methods that allow to manipulate fields.Methods are provide to access and travers entity body and parts. Mime entity allows to add and remove parts. An entity is created as a simple entity by default. As parts are added, it will mutate itself into multipart entity transparently. It is also possible to convert multiupart entity back into a single-part one, merging fields in the process.MimeEntity also supports Visitor patterns. Nodes can be traversed by an outside visitor. This allows to put domain- and application-specific logic into the visitor and create visitors specific to Mail, HTTP, etc. Instance Variables	header	&lt;MessageHeader&gt; Message header contains header fields	headerCharset	&lt;Symbol&gt; is used to encode destination addressesClass Instance Variables	defaultTextCharset	&lt;String&gt; default charset for content-type field when assigning text contents	defaultTextType	&lt;String&gt; default type for content-type field when assigning text contents</body></comment><class><name>MimeParser</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>handler </inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.IOConstants.*			</imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.MimeParser</class-id><body>This class parses Mime entities usually coming from some external sources. As it parses various elements from the input it keeps notifying its handler. Handler is the one that actually contructs the message elements in response to parser callbacks. This division of labor is designed so that different strategies can be employed at the handler level. For example, we may choose to process some parts of the message as they are decoded without waiting for the whole message to be fully parsed; we may choose to create different entities to represent the parsed entity (e.g. MimeEntity vs. MailMessage), etc. The parsing process can be controlled by various parameters coming from the handler. Instance Variables:	handler &lt;MimeParserHandler&gt; constructs the message</body></comment><class><name>HeaderFieldValue</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>separators value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.HeaderFieldValue</class-id><body>HeaderFieldValue parses, composes and holds values for header fieldsInstance Variables:	separators	&lt;SequenceableCollection&gt;	field separators	value	&lt;String&gt;	parameter  value</body></comment><class><name>ValueWithParams</name><environment>Net</environment><super>Net.HeaderFieldValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars>params </inst-vars><class-inst-vars>defaultParameterValueEncoding </class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.ValueWithParams</class-id><body>ValueWithParams parses, composes and holds values for header fields that have value and parameters.  Instance Variables:	params	&lt;Dictionary&gt;	filed parametersClass Instance Variables:	defaultParameterValueEncoding	&lt;Symbol&gt; if set, the specified encoding will be applied if we encounter non-ascii characters in parameter values (technically this is against the MIME specification, but seems to be a widespread practice, e.g. many web browsers do that with filenames of uploaded files)For example, Content-Type field  content := "Content-Type" ":" type "/" subtype             *(";" parameter)             ; Matching of media type and subtype             ; is ALWAYS case-insensitive.  parameter := attribute "=" value  value := token / quoted-stringIf while parsing parameter value non-ASCII characters would be detected the parser is going to raise NonASCIIFieldParamException. If there is no handler for this exception the parameter value will be set to stream bytes.</body></comment><class><name>MimeDispatcherHandler</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dispatcher options </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.MimeDispatcherHandler</class-id><body>This class is strategy class for MimeDispatcher. When mime dispatcher traverses message, it calls back its message handler notifying it where it is in the message. All possible callbacks are declared in 'action callbacks' protocol. Subclasses override these methods to implement such tasks as printing and searching of messages.Instance Variables	dispatcher	&lt;MimeDispatcher&gt;	my dispatcher. Handler typically initialtes work by invoking dispatcher's method visit:. Dispatcher then executes series of callbacks to the hahdler	options 	&lt;MimeDispatcherWritingOptions&gt; a message writing/printing options</body></comment><class><name>MailGroupDescriptor</name><environment>Net</environment><super>Net.NetworkEntityDescriptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>addresses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.MailGroupDescriptor</class-id><body>This class represents mail group specification as defined in rfc822. It is capable of parsing and composing group specs to/from a stream and provides access to group components. A group spec may be parsed from a source stream, or created by invoking mutator methods and then written on a stream. Mime-encoded fields are handled transparentlyExamples:    Reply-To: The Committee: Jones@Host.Net,                                     Smith@Other.Org,                                     Doe@Somewhere-Else;    Reply-To :  Sam.Irving@Reg.Organization       :  George Jones &lt;Group@Some-Reg.An-Org&gt;,          Al.Neuman@MAD.Publisher       :  Important folk:            Tom Softwood &lt;Balsa@Tree.Root&gt;,            "Sam Irving"@Other-Host;,          Standard Distribution:                   /main/davis/people/standard@Other-Host,                   "&lt;Jones&gt;standard.dist.3"@Tops-20-Host&gt;;Group syntax from rfc822 is given below     group       =  phrase ":" [#mailbox] ";"     mailbox     =  addr-spec                    ; simple address                 /  phrase route-addr            ; name &amp; addr-spec     route-addr  =  "&lt;" [route] addr-spec "&gt;"     route       =  1#("@" domain) ":"           ; path-relative     addr-spec   =  local-part "@" domain        ; global address     local-part  =  word *("." word)             ; uninterpreted                                                 ; case-preserved     domain      =  sub-domain *("." sub-domain)     sub-domain  =  domain-ref / domain-literal     domain-ref  =  atom                         ; symbolic referenceInstance Variables:	addresses	&lt;SequencableCollection&gt;  Collection of NetworkAddressDescriptors constituting group</body></comment><class><name>ContentTypeField</name><environment>Net</environment><super>Net.SingleValueWithParametersField</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.ContentTypeField</class-id><body>This class represents content-type field in MIME and HTTP protocols. RFC2045 implements content-type field syntax defined in RFC2045.The field performs parsing/compisition for content-type field and exposesaccessor methods to access individual components:	contetType ('type/subtype', example 'text/html')	type	subType	charset	boundaryOther parameters can be accessed using #parameterAt:, #parameterAt:put:Syntax (abbreviated) from RFC2045 (ftp.uu.net/inet/rfcs/rfc2045.Z):      content := "Content-Type" ":" type "/" subtype                *(";" parameter)                ; Matching of media type and subtype                ; is ALWAYS case-insensitive.     type := discrete-type / composite-type     discrete-type := "text" / "image" / "audio" / "video" /                      "application" / extension-token     composite-type := "message" / "multipart" / extension-token     parameter := attribute "=" value</body></comment><class><name>MimeParserHandler</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream lineEndConvention initialEntity parser binaryMode options </inst-vars><class-inst-vars>saveAttachmentsAsFiles defaultAttachmentDirectory </class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.MimeParserHandler</class-id><body>This class is responsible for putting message together from pieces parsed by the mime parser. Specifically, this class knows what type of entity to create based on the context (parent entity, content type, etc.) and what to do with message body.Instance Variables	stream	&lt;Stream&gt; a stream to parse an entity	lineEndConvention	&lt;Number&gt; original stream line end convention	initialEntity	&lt;MimeEntity&gt; initial entity to build	parser	&lt;MimeParser&gt; my parser. Parser then executes series of callbacks to the hahdler	binaryMode	&lt;Boolean&gt; indicates the original mode of the input stream	options &lt;MimeReadingOptions&gt; options to build a messageClass Instance Variables</body></comment><class><name>MessageBuildHandler</name><environment>Net</environment><super>Net.MimeParserHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.MessageBuildHandler</class-id><body>Obsolete class. </body></comment><class><name>MimeBuildHandler</name><environment>Net</environment><super>Net.MimeParserHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>removeContentTransferEncoding </class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.MimeBuildHandler</class-id><body>This class adds handling of transfer encodings on body parts.Instance VariablesClass Instance Variables</body></comment><class><name>QuotedPrintableDecoder</name><environment>Net</environment><super>Core.StreamEncoder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>digit octet offset lineLength </inst-vars><class-inst-vars>defaultLineLength </class-inst-vars><imports>			OS.IOConstants.*			</imports><category>MIMETests</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.QuotedPrintableDecoder</class-id><body>QuotedPrintableDecoder is a simplified encoder for the quoted-printable Content-Transfer-Encoding for MIME message bodies (RFC#2045). It is to be used with the DecodedStream and therefore expects to convert bytes into characters of quoted-printable encoding. It is simplified because it deviates from the RFC by mapping the line-breaks into CRs (as opposed to CRLFs). This is because this encoder operates at the level where the underlying stream is a character stream and once strings are brought into the image all line end conventions should have been converted to CRs only by then. If this encoder encounters an LF character it will pass it through as byte 10 when reading and vice versa when writing. Note that DecodedStream does perfom line-end conversion on the CR and LF characters according to its line end setting. Another simplification is that this encoder is only expected to be used with textual media types with regards to line-break processing (point 4 in the RFC), i.e it will always preserve line ends literally. As such it is unsuitable for binary media types where bytes need to be preserved exactly. Use base-64 encoding for binary media types instead.Example - Writing:	| encoded stream |	encoded := String new writeStream.	stream := DecodedStream on: encoded encodedBy: QuotedPrintableDecoder asEncoder.	stream := EncodedStream on: stream encodedBy: (StreamEncoder new: #iso8859_2).	stream nextPutAll: 'Příliš žluťoučký kúň úpěl ďábelské ódy.\PŘÍLIŠ ŽLUŤOUČKÝ KŮŇ ÚPĚL ĎÁBELSKÉ ÓDY.\' withCRs.	stream flush.	encoded contentsExample - Reading:	| encoded stream |	encoded := 'P=F8=EDli=B9 =BElu=BBou=E8k=FD k=FA=F2 =FAp=ECl =EF=E1belsk=E9 =F3dy.\'.	encoded := encoded, 'P=D8=CDLI=A9 =AELU=ABOU=C8K=DD K=D9=D2 =DAP=CCL =CF=C1BELSK=C9 =D3DY.\'.	encoded := encoded withCRs readStream.	stream := DecodedStream on: encoded encodedBy: QuotedPrintableDecoder asEncoder.	stream := EncodedStream on: stream encodedBy: (StreamEncoder new: #iso8859_2).	stream contents.RFC 2045: Internet Message Bodies; chapter 6.7  Quoted-Printable Content-Transfer-Encoding:The Quoted-Printable encoding is intended to represent data that largely consists of octets that correspond to printable characters in the US-ASCII character set.  It encodes the data in such a way that the resulting octets are unlikely to be modified by mail transport. If the data being encoded are mostly US-ASCII text, the encoded form of the data remains largely recognizable by humans.  A body which is entirely US-ASCII may also be encoded in Quoted-Printable to ensure the integrity of the data should the message pass through a character-translating, and/or line-wrapping gateway.In this encoding, octets are to be represented as determined by the following rules:	(1)	(General 8bit representation) Any octet, except a CR or LF that is part of a CRLF line break of the canonical (standard) form of the data being encoded, may be represented by an "=" followed by a two digit hexadecimal representation of the octet's value.  The digits of the hexadecimal alphabet, for this purpose, are "0123456789ABCDEF".  Uppercase letters must be used; lowercase letters are not allowed.  Thus, for example, the decimal value 12 (US-ASCII form feed) can be represented by "=0C", and the decimal value 61 (US- ASCII EQUAL SIGN) can be represented by "=3D".  This rule must be followed except when the following rules allow an alternative encoding.	(2)	(Literal representation) Octets with decimal values of 33 through 60 inclusive, and 62 through 126, inclusive, MAY be represented as the US-ASCII characters which correspond to those octets (EXCLAMATION POINT through LESS THAN, and GREATER THAN through TILDE, respectively).	(3)	(White Space) Octets with values of 9 and 32 MAY be represented as US-ASCII TAB (HT) and SPACE characters, respectively, but MUST NOT be so represented at the end of an encoded line.  Any TAB (HT) or SPACE characters on an encoded line MUST thus be followed on that line by a printable character.  In particular, an "=" at the end of an encoded line, indicating a soft line break (see rule #5) may follow one or more TAB (HT) or SPACE characters.  It follows that an octet with decimal value 9 or 32 appearing at the end of an encoded line must be represented according to Rule #1.  This rule is necessary because some MTAs (Message Transport Agents, programs which transport messages from one user to another, or perform a portion of such transfers) are known to pad lines of text with SPACEs, and others are known to remove "white space" characters from the end of a line.  Therefore, when decoding a Quoted-Printable body, any trailing white space on a line must be deleted, as it will necessarily have been added by intermediate transport agents.	(4)	(Line Breaks) A line break in a text body, represented as a CRLF sequence in the text canonical form, must be represented by a (RFC 822) line break, which is also a CRLF sequence, in the Quoted-Printable encoding.  Since the canonical representation of media types other than text do not generally include the representation of line breaks as CRLF sequences, no hard line breaks (i.e. line breaks that are intended to be meaningful and to be displayed to the user) can occur in the quoted-printable encoding of such types.  Sequences like "=0D", "=0A", "=0A=0D" and "=0D=0A" will routinely appear in non-text data represented in quoted- printable, of course.	(5)	(Soft Line Breaks) The Quoted-Printable encoding REQUIRES that encoded lines be no more than 76 characters long.  If longer lines are to be encoded with the Quoted-Printable encoding, "soft" line breaks must be used.  An equal sign as the last character on a encoded line indicates such a non-significant ("soft") line break in the encoded This provides a mechanism with which long lines are encoded in such a way as to be restored by the user agent.  The 76 character limit does not count the trailing CRLF, but counts all other characters, including any equal signs.Since the hyphen character ("-") may be represented as itself in the Quoted-Printable encoding, care must be taken, when encapsulating a quoted-printable encoded body inside one or more multipart entities, to ensure that the boundary delimiter does not appear anywhere in the encoded body.  (A good strategy is to choose a boundary that includes a character sequence such as "=_" which can never appear in a quoted-printable body.  See the definition of multipart messages in RFC 2046.)NOTE: The quoted-printable encoding represents something of a compromise between readability and reliability in transport.  Bodies encoded with the quoted-printable encoding will work reliably over most mail gateways, but may not work perfectly over a few gateways, notably those involving translation into EBCDIC.  A higher level of confidence is offered by the base64 Content-Transfer-Encoding.  A way to get reasonably reliable transport through EBCDIC gateways is to also quote the US-ASCII characters !"#$@[\]^`{|}~ according to rule #1.Because quoted-printable data is generally assumed to be line-oriented, it is to be expected that the representation of the breaks between the lines of quoted-printable data may be altered in transport, in the same manner that plain text mail has always been altered in Internet mail when passing between systems with differing newline conventions.  If such alterations are likely to constitute a corruption of the data, it is probably more sensible to use the base64 encoding rather than the quoted-printable encoding.NOTE: Several kinds of substrings cannot be generated according to the encoding rules for the quoted-printable content-transfer- encoding, and hence are formally illegal if they appear in the output of a quoted-printable encoder. This note enumerates these cases and suggests ways to handle such illegal substrings if any are encountered in quoted-printable data that is to be decoded.    (1)   An "=" followed by two hexadecimal digits, one or both of which are lowercase letters in "abcdef", is formally illegal. A robust implementation might choose to recognize them as the corresponding uppercase letters.    (2)   An "=" followed by a character that is neither a hexadecimal digit (including "abcdef") nor the CR character of a CRLF pair is illegal.  This case can be the result of US-ASCII text having been included in a quoted-printable part of a message without itself having been subjected to quoted-printable encoding.  A reasonable approach by a robust implementation might be to include the "=" character and the following character in the decoded data without any transformation and, if possible, indicate to the user that proper decoding was not possible at this point in the data.    (3)   An "=" cannot be the ultimate or penultimate character in an encoded object.  This could be handled as in case (2) above.    (4)   Control characters other than TAB, or CR and LF as parts of CRLF pairs, must not appear. The same is true for octets with decimal values greater than 126.  If found in incoming quoted-printable data by a decoder, a robust implementation might exclude them from the decoded data and warn the user that illegal characters were discovered.    (5)   Encoded lines must not be longer than 76 characters, not counting the trailing CRLF. If longer lines are found in incoming, encoded data, a robust implementation might nevertheless decode the lines, and might report the erroneous encoding to the user.WARNING TO IMPLEMENTORS:  If binary data is encoded in quoted-printable, care must be taken to encode CR and LF characters as "=0D" and "=0A", respectively.  In particular, a CRLF sequence in binary data should be encoded as "=0D=0A".  Otherwise, if CRLF were represented as a hard line break, it might be incorrectly decoded on platforms with different line break conventions.Instance Variables:	digit	&lt;Integer&gt; indicates the index of the current hexadecimal digit of the =XX encoding; 0 means we're not encoding current octet; {0,1,2}	octet	&lt;Integer&gt; currently processed octet	offset	&lt;Integer&gt; zero based offset of the next character on current line	lineLength	&lt;Integer&gt; specifies the line length where to emit CR and wrap to the next line when encodingClass Instance Variables:	defaultLineLength	&lt;Integer&gt; specifies the default line length where to emit CR and wrap to the next line when encoding</body></comment><class><name>BodyStream</name><environment>Net</environment><super>Net.MessageStream</super><private>true</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HTTP</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.BodyStream</class-id><body>BodyStream allows to read only up to a specified number of bytes (readLimit) from the underlying stream.</body></comment><class><name>MimeDispatcherWritingOptions</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>headerOnly printerClass writerClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.MimeDispatcherWritingOptions</class-id><body>MimeDispatcherWritingOptions is superclass for Mime writing optionsInstance Variables	headerOnly	&lt;Boolean&gt;	if true only message header will be written	printerClass	&lt;Class&gt;  class of dispatcher handler to use for simplified (digest) printing of entities of this class	writerClass	&lt;Class&gt;  class of dispatcher handler to use for writing entities of this class into files and sockets</body></comment><class><name>RFC822Message</name><environment>Net</environment><super>Net.MimeEntity</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.RFC822Message</class-id><body>This class represents top-level RFC822 messages. It adds accessor methods for all fields postulated in rfc822 (to, from, cc, bcc, data, etc.).</body></comment><class><name>BoundedStream</name><environment>Net</environment><super>Net.MessageStream</super><private>true</private><indexed-type>none</indexed-type><inst-vars>boundary boundaryDashes </inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.IOConstants.*			</imports><category>HTTP</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.BoundedStream</class-id><body>BoundedStream is an abstract class for the bounded read and write streams. Bounded streams help parsing multipart MIME bodies, where individual parts are separated by boundary strings.Instance Variables:	boundary	&lt;ByteArray&gt;	bytes that defines pattern to search for	boundaryDashes &lt;ByteArray&gt; boundary dashes</body></comment><class><name>MailboxListField</name><environment>Net</environment><super>Net.ScalarField</super><private>false</private><indexed-type>none</indexed-type><inst-vars>addresses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.MailboxListField</class-id><body>This class represents field whose value is a list of mailboxes as defined by RFC5322. Several field types in RFC5322 messages (from, cc, to, etc) are mailbox list fields. Mailbox specs allows to specify address-spec as well as an alias. MIME allows to encode non-ASCII characters in the alias part. Addresses can be mailbox or mail group addresses.Value of this field is list of addresses (strings). Addresses can be read or set using messages:	addresses	addresses:Instance Variables	addresses &lt;Collection of NetworkAddressDescriptor&gt; When setting addresses, caller specified a collection of strings. Each string can be a single address or a sequence of comma-separated addresses. Among other things, this handles non-ascii characters in the alias part of the address. Address strings are always parsed and canonicalized inside. This class uses NetworkAddressDescriptor class to parse and compose address strings.Mailbox list examples:	Gourmets:  Pompous Person &lt;WhoZiWhatZit@Cordon-Bleu&gt;,                Childs@WGBH.Boston, Galloping Gourmet@                ANT.Down-Under (Australian National Television),                Cheapie@Discount-Liquors;,       Cruisers:  Port@Portugal, Jones@SEA;,         Another@Somewhere.SomeOrgSee formal grammar in SingleMailboxField class comments</body></comment><class><name>SingleMailboxField</name><environment>Net</environment><super>Net.MailboxListField</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.SingleMailboxField</class-id><body>This class represents field whose value is a mailbox-spec as defined by RFC5322. Several field types in RFC5322 messages are single mailbox fields. Mailbox allows to specify address-spec as well as an alias. MIME allows to encode non-ASCII characters in the alias part.http://www.rfc-editor.org/rfc/rfc5322.txtMailbox examples:	Alfred Neuman &lt;Neuman@BBN-TENEXA&gt;	"George, Ted" &lt;Shared@Group.Arpanet&gt;The formal grammar is as follows:return          =   "Return-Path:" path CRLFpath            =   angle-addr / ([CFWS] "&lt;" [CFWS] "&gt;" [CFWS])resent-sender   =   "Resent-Sender:" mailbox CRLFsender          =   "Sender:" mailbox CRLF   FWS             =   ([*WSP CRLF] 1*WSP) /  obs-FWS                                          ; Folding white space   comment         =   "(" *([FWS] ccontent) [FWS] ")"   CFWS            =   (1*([FWS] comment) [FWS]) / FWSaddress         =   mailbox / groupmailbox         =   name-addr / addr-specname-addr       =   [display-name] angle-addrangle-addr      =   [CFWS] "&lt;" addr-spec "&gt;" [CFWS] / obs-angle-addrgroup           =   display-name ":" [group-list] ";" [CFWS]display-name    =   phrasemailbox-list    =   (mailbox *("," mailbox)) / obs-mbox-listaddress-list    =   (address *("," address)) / obs-addr-listgroup-list      =   mailbox-list / CFWS / obs-group-listaddr-spec       =   local-part "@" domainlocal-part      =   dot-atom / quoted-string / obs-local-partdomain          =   dot-atom / domain-literal / obs-domaindomain-literal  =   [CFWS] "[" *([FWS] dtext) [FWS] "]" [CFWS]dtext           =   %d33-90 /          ; Printable US-ASCII                       %d94-126 /         ;  characters not including                       obs-dtext          ;  "[", "]", or "\"4.4.  Obsolete Addressing   There are four primary differences in addressing.  First, mailbox   addresses were allowed to have a route portion before the addr-spec   when enclosed in "&lt;" and "&gt;".  The route is simply a comma-separated   list of domain names, each preceded by "@", and the list terminated   by a colon.  Second, CFWS were allowed between the period-separated   elements of local-part and domain (i.e., dot-atom was not used).  In   addition, local-part is allowed to contain quoted-string in addition   to just atom.  Third, mailbox-list and address-list were allowed to   have "null" members.  That is, there could be two or more commas in   such a list with nothing in between them, or commas at the beginning   or end of the list.  Finally, US-ASCII control characters and quoted-   pairs were allowed in domain literals and are added here.   obs-angle-addr  =   [CFWS] "&lt;" obs-route addr-spec "&gt;" [CFWS]   obs-route       =   obs-domain-list ":"   obs-domain-list =   *(CFWS / ",") "@" domain                       *("," [CFWS] ["@" domain])   obs-mbox-list   =   *([CFWS] ",") mailbox *("," [mailbox / CFWS])   obs-addr-list   =   *([CFWS] ",") address *("," [address / CFWS])   obs-group-list  =   1*([CFWS] ",") [CFWS]   obs-local-part  =   word *("." word)   obs-domain      =   atom *("." atom)   obs-dtext       =   obs-NO-WS-CTL / quoted-pair   When interpreting addresses, the route portion SHOULD be ignored.</body></comment><class><name>EncodingFailure</name><environment>Net</environment><super>Net.NetError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>MIME</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.EncodingFailure</class-id><body>EncodingFailure will be raised in case of failure to encode body source </body></comment><class><name>MimeReadingOptions</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fieldFactory messageHeaderClass scannerType saveAttachmentsAsFiles headerOnly acceptNonAsciiCharacters attachmentDirectory builderClass removeContentTransferEncoding </inst-vars><class-inst-vars>saveAttachmentsAsFiles defaultAttachmentDirectory removeContentTransferEncoding </class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.MimeReadingOptions</class-id><body>MimeReadingOptions holds MimeBuildHandler optrions and knows how create an instance of MimeBuildHandlerInstance Variables	builderClass	&lt;Class&gt; default class of parser handler to use for parsing entities of this class	fieldFactory	&lt;HeaderField&gt; field factory or default field factory if none is specified. Different protocols may have different field factories (i.e. Mime vs. HTTP)	messageHeaderClass	&lt;MessageHeader&gt; message header class	stream	&lt;Stream&gt; a stream to parse an entity	lineEndConvention	&lt;Number&gt; original stream line end convention	initialEntity	&lt;MimeEntity&gt; initial entity to build	saveAttachmentsAsFiles	&lt;Boolean&gt; if true the builder will save attachments in to an external file. The external file name will be create from 'Content-Disposition' field falename attribute if any. If there is no filename in the attachment the random name will be generated. The AttachmentFilename notification will be raised allowing to provide a new file name. If the #saveAttachmentAsFile option is false the attachment will be save in to internal stream	headerOnly	&lt;Boolean&gt; if true, dispatcher will stop after processing message header	binaryMode	&lt;Boolean&gt; indicates the original mode of the input stream	attachmentDirectory	&lt;Filename&gt;	 directory where the attachments will be saved	removeContentTransferEncoding	&lt;Boolean&gt; should the builder automatically remove transfer encoding from parsed messages and their partsClass Instance Variables	saveAttachmentsAsFiles	&lt;Boolean&gt; if true, save attachments in to the upload directory.	defaultAttachmentDirectory	&lt;String&gt; default directory to upload attachments	removeContentTransferEncoding	&lt;Boolean&gt; the default value for removeContentTransferEncoding	removeContentTransferEncoding	&lt;Boolean&gt; the default value for removeContentTransferEncoding</body></comment><class><name>BoundedWriteStream</name><environment>Net</environment><super>Net.BoundedStream</super><private>true</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.IOConstants.*			</imports><category>HTTP</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.BoundedWriteStream</class-id><body>BoundedWriteStream writes MIME part boundaries for multipart messages. This version is used by the MimeWriteHandlers. To ensure proper specification compliance of the output it writes them as bytes, therefore the underlying stream has to be a binary stream.</body></comment><class><name>BoundedWriteCharacterStream</name><environment>Net</environment><super>Net.BoundedWriteStream</super><private>true</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HTTP</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.BoundedWriteCharacterStream</class-id><body>BoundedWriteCharacterStream writes MIME part boundaries for multipart messages. This version is used by the MimePrintHandlers so it writes them as strings to accomodate any kind of character stream setup. Consequently the underlying stream has to be a pure character stream or it has to be set to the text mode.</body></comment><class><name>EntityException</name><environment>Net</environment><super>Net.NetError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>MIME</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.EntityException</class-id><body>EntityException will be raise while constructing a new mime entity from a file stream in case when the mime entity expects the stream in binary mode. The assumption is based on the file name extension</body></comment><class><name>ReturnPath</name><environment>Net</environment><super>Net.SingleMailboxField</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.ReturnPath</class-id><body>This class represents trace field as defines in RFC5322. The "Return-Path:" header field contains a pair of angle brackets that enclose an optional addr-spec. http://www.rfc-editor.org/rfc/rfc5322.txtreturn          =   "Return-Path:" path CRLFpath            =   angle-addr / ([CFWS] "&lt;" [CFWS] "&gt;" [CFWS])</body></comment><class><name>MimeOutputHandler</name><environment>Net</environment><super>Net.MimeDispatcherHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>streams fieldStream </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.MimeOutputHandler</class-id><body>This is a common superclass for printing and writing of messages on a stream according to rfc822 syntax rules. Writing renders messages on the output stream in full conformance with rfc822 syntax, so it can be used to send message directly to SMTP server, for example. Printing is rendering messages for inspection during development. Therefore the logic is slightly different to enhance readability of the output, entities are indented and binary data is only sumarized.Instance Variables:	streams	&lt;OrderedCollection of: Stream&gt; stack of various stream compositions used at different levels of the entity being written	fieldStream	&lt;WriteStream&gt; caches a stream used to convert field values into streams, it is reused for performance reasons</body></comment><class><name>MimeWriteHandler</name><environment>Net</environment><super>Net.MimeOutputHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>originalStream binaryMode </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.MimeWriteHandler</class-id><body>This class implements writing messages on output stream in full conformance of rfc822 syntax. If some constituent entities require content transfer encoding, it is applied dynamically and transfer-encoded output is written directly on output stream with no intermediate buffers created. Header fields are arranged in the order imposed by rfc822.Instance Variables	originalStream	&lt;EncodedStream&gt; original stream or wrapper for internal streams to print a message	binaryMode	&lt;Boolean&gt; preserves the output stream mode. It will be changed to binary while writing a messageClass Instance Variables</body></comment><class><name>MimeWritingOptions</name><environment>Net</environment><super>Net.MimeDispatcherWritingOptions</super><private>false</private><indexed-type>none</indexed-type><inst-vars>preferFieldSource applyTransferEncoding </inst-vars><class-inst-vars>applyTransferEncoding </class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.MimeWritingOptions</class-id><body>MimeWritingOptions is holding the MimeWriteHandler&amp;MimePrintHandler options and knows how to create an instance of MimeWriteHandler&amp;MimePrintHandler.Instance Variables	preferFieldSource	&lt;Boolean&gt; if true , a header field source will be used to print instead of parsed values. If application resends, routes of forwards messages, all mail protocols strongly advise against and changes in message header fields. These changes are unavoidable if all fields are to be parsed and later composed when a message is resent/forwarded. In this situation a wise approach is to prefer source, so fields are copied to the output exactly the way thay have been received	applyTransferEncoding	&lt;Boolean&gt; flag allowing to suppress transfer encoding	applyTransferEncoding	&lt;Boolean&gt; flag allowing to suppress transfer encoding; it is used for #writeContentsOn:Class Instance Variables	applyTransferEncoding	&lt;Boolean&gt; default value for the applyTransferEncoding flag</body></comment><class><name>MimeEntityBot</name><environment>Net</environment><super>Net.MimeDispatcherHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>shouldCallback doCallback keepSearching entityStack </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.MimeEntityBot</class-id><body>This class is a 'robot' that can be used to search Mime entities for information and to perform some transformations of Mime entities.Methods in 'enumeration' provide search facilities to find and collect parts matching certain criteria. Searches can be restricted to some level of nesting, which is convenient when searching for message text parts and attachments.Methods in 'tasks' provides facilities to check message structure, add/remove transfer encoding and also to correctly mutate message. Examples include adding part to a simple message which mutates it froma simple message to multi-part message. Another example is dropping all representations of message text except plain text one, which may require to mutate message from multipart/alternative to simple, or replacing multipart/alternative part with a simple part. This class encapsulates all the logistics and complexity involved in these transformations providing easy to use high-level methods.Instance Variables:	shouldCallback	&lt;BlockContext&gt; invoked with a part to decide if it should be processed or not	doCallback	&lt;BlockContext&gt; invoked with a part to process it	keepSearching	&lt;Boolean&gt; internal - terminates message traversal when set	entityStack	&lt;OrderedCollection of: MimeEntity&gt; internal - a stack of message parts representing the path to the currently processed part</body></comment><class><name>NonClosingReadStream</name><environment>Net</environment><super>Core.Stream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>MIME</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.NonClosingReadStream</class-id><body>I protect the underlying stream from being written into or flushed (raise an error). I suppress closing too (no error). I'm a helper stream for mail archive use protecting the message bodies stored in the archive.Instance Variables:	stream	&lt;Stream&gt; protected stream</body></comment><class><name>NetworkAddressParser</name><environment>Net</environment><super>Net.RFC822Scanner</super><private>false</private><indexed-type>none</indexed-type><inst-vars>descriptor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.NetworkAddressParser</class-id><body>This class parses string representing mailbox and group addresses and answers a instances of address descriptors -- either NetworkAddressDescriptor or MailGroupDescriptor -- depending on the nature of the address.Instance Variables:	descriptor	&lt;NetwordAddressDescriptor or MailGroupDescriptor&gt;  descriptor to put parsed info in</body></comment><class><name>VersionField</name><environment>Net</environment><super>Net.ScalarField</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.VersionField</class-id><body>This class represents version fields. Version is used in MIME and in HTTP. Version field syntax for MIME messages is as follows:     version := "MIME-Version" ":" 1*DIGIT "." 1*DIGIT     MIME-Version: 1.0</body></comment><class><name>WritingInvalidHeader</name><environment>Net</environment><super>Net.NetError</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>MIME</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.WritingInvalidHeader</class-id><body>WritingInvalidHeader is raised when someone is trying to write UnparsedHeaderValue.Instance Variables	stream	&lt;Stream&gt;	stream to write UnparsedHeaderValue</body></comment><class><name>UnparsedHeaderValue</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>errorDescription source errorPosition </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.UnparsedHeaderValue</class-id><body>UnparsedHeaderValue is created as a result of default action on InvalidHeaderField notification. When printed the UnparsedHeaderValue uses the source to print the field value. If the #writeOn: method is used the UnparsedHeaderValue raises WritingInvalidHeader exception.Instance Variables	errorDescription	&lt;String&gt;	error description	errorPosition	&lt;Number&gt;	error position	source	&lt;Stream&gt;	unparsed header field source</body></comment><class><name>BoundedReadStream</name><environment>Net</environment><super>Net.BoundedStream</super><private>true</private><indexed-type>none</indexed-type><inst-vars>buffer bufferPosition atEnd endOfLastPart </inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.IOConstants.*			</imports><category>HTTP</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.BoundedReadStream</class-id><body>BoundedStream reads bytes up to a specified boundary. The stream helps to parse multipart messages.Instance Variables:	atEnd	&lt;Boolean&gt;	is true when the stream is positioned at the boundary and means end of the part. 	buffer	&lt;ByteArray&gt;	data buffer	endOfLastPart	&lt;Boolean&gt;	is true when stream is positioned at the end of the last part. </body></comment><class><name>MimePrintHandler</name><environment>Net</environment><super>Net.MimeOutputHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>indentation indentLines </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.MimePrintHandler</class-id><body>This class implements printing of messages on a stream in a shortened (digest) mode to enhance readability of the output. To accomodate any kind of character stream for output, the stream is expected to be able to accept characters right away, i.e. be a pure character stream or be set to the text mode. First, nested entities are indented according to their nesting level. Secondly, binary data is not shown and in general only a digest of each entity's contents is displayed. The stream to print on expected to be a character stream or an error will be raised.Instance Variables:	indentation	&lt;Number&gt; the level of indention	indentLines	&lt;Boolean&gt; if true, add tab while printing lines</body></comment><class><name>AttachmentFileExists</name><environment>Net</environment><super>Net.NetError</super><private>false</private><indexed-type>none</indexed-type><inst-vars>filename </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>MIME</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.AttachmentFileExists</class-id><body>This error will be raised if the file name provided by the AttachmentFilename notification already exists. This exception is resumable with a new file name to use for the attachment file. If it is resumed without parameter or the new filename also exists that file will then be deleted and reused for the attachment. Obviously if this exception is not resumed, the attachment will not be saved and parsing of the enclosing message containing this attachment will end here, unfinished.Instance Variables:	filename	&lt;Filename&gt; the existing file	Example:	input := 'From: zz@holcim.comContent-Type: multipart/related;	boundary="--11"----11Content-Type: text/plain; name="budd.txt"Content-Disposition: attachment; filename="budd.txt"Content-Transfer-Encoding: base64QWxhZGRpbjpvcGVuIHNlc2FtZQ==----11--' .	[[	message := MailBuildHandler new				saveAttachmentsAsFiles: true;				readFrom: input readStream. 	]	on: AttachmentFilename		do:  [ :ex | ex resume: 'temp-', ex filename tail ].	] on: AttachmentFileExists do: [ :ex | ex resume: 'anotherTemp.txt' ]</body></comment><class><name>UnparsedBody</name><environment>Net</environment><super>Net.SinglepartBody</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.IOConstants.*			</imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.UnparsedBody</class-id><body>UnparsedBody is used as a temporary object while parsing a mime entity for the brief period between the time when a MimeEntity is created and until its header is parsed (so that the right type of body is created). It is primarily meant for debugging purposes, because due to the lazy initialization, inspection of an entity while debugging the parsing process can cause creation of wrong body object.</body></comment><class><name>DateField</name><environment>Net</environment><super>Net.ScalarField</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.DateField</class-id><body>This class represents date fields as defines in RFC5322. Value of the field is an instance of date, not a string. See rfc5322 for the exact syntax of dateshttp://www.rfc-editor.org/rfc/rfc5322.txt	Examples:		HeaderField fromLine: 'Date : Tue, 18 Apr 89 23:29:47 +0900	' 		HeaderField fromLine: 'Date : 26 Aug 76 14:30 EDT' 		HeaderField fromLine: 'Expired : 0' -  the data filed value will be the number zero. HTTP/1.1 clients MUST treat other invalid date formats, especially including the value 0, as in the past (i.e., already expired). date-time       =   [ day-of-week "," ] date time [CFWS]day-of-week     =   ([FWS] day-name) / obs-day-of-weekday-name        =   "Mon" / "Tue" / "Wed" / "Thu" /                       "Fri" / "Sat" / "Sun"date            =   day month yearday             =   ([FWS] 1*2DIGIT FWS) / obs-daymonth           =   "Jan" / "Feb" / "Mar" / "Apr" /                       "May" / "Jun" / "Jul" / "Aug" /                       "Sep" / "Oct" / "Nov" / "Dec"year            =   (FWS 4*DIGIT FWS) / obs-yeartime            =   time-of-day zonetime-of-day     =   hour ":" minute [ ":" second ]hour            =   2DIGIT / obs-hourminute          =   2DIGIT / obs-minutesecond          =   2DIGIT / obs-secondzone            =   (FWS ( "+" / "-" ) 4DIGIT) / obs-zone4.3.  Obsolete Date and Time   The syntax for the obsolete date format allows a 2 digit year in the   date field and allows for a list of alphabetic time zone specifiers   that were used in earlier versions of this specification.  It also   permits comments and folding white space between many of the tokens.   obs-day-of-week =   [CFWS] day-name [CFWS]   obs-day         =   [CFWS] 1*2DIGIT [CFWS]   obs-year        =   [CFWS] 2*DIGIT [CFWS]   obs-hour        =   [CFWS] 2DIGIT [CFWS]   obs-minute      =   [CFWS] 2DIGIT [CFWS]   obs-second      =   [CFWS] 2DIGIT [CFWS]   obs-zone        =   "UT" / "GMT" /     ; Universal Time                                          ; North American UT                                          ; offsets                       "EST" / "EDT" /    ; Eastern:  - 5/ - 4                       "CST" / "CDT" /    ; Central:  - 6/ - 5                       "MST" / "MDT" /    ; Mountain: - 7/ - 6                       "PST" / "PDT" /    ; Pacific:  - 8/ - 7                       %d65-73 /          ; Military zones - "A"                       %d75-90 /          ; through "I" and "K"                       %d97-105 /         ; through "Z", both                       %d107-122          ; upper and lower case</body></comment><class><name>ParsingSimpleBodyError</name><environment>Net</environment><super>Net.NetError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>MIME</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.ParsingSimpleBodyError</class-id><body>ParsingSimpleBodyError is raised when any error is detected while parsing the message body. The exception parameter holds the original error.</body></comment><class><name>MimeScanner</name><environment>Net</environment><super>Net.RFC822Scanner</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>base64Decoder codeChars </class-inst-vars><imports>			private OS.IOConstants.*			</imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.MimeScanner</class-id><body>MimeScanner implements Mime encoding rules specified in RFC2047 (Message Header Extensions for Non-Ascii Text). The notation extends RFC822 describing encoding lexical elements text, phrase and word. MimeScanner extends RFC822 scanner. It has the same set of lexems. When either text, phrase or word is scanned, it is scanned using rfc822 syntax but Mime character  table. Once lexem is scanned, then Mime encoding rules for this lexem are applied so that non-ASCII characters can be decoded.Class Variables:	base64Decoder &lt;Array&gt; the base64 encoding map	codeChars &lt;String&gt; base64 characters. The only characters used are the upper- and lower-case Roman alphabet characters (A–Z, a–z), the numerals (0–9), and the "+" and "/" symbols, with the "=" symbol as a special suffix code.</body></comment><class><name>AttachmentFilename</name><environment>Net</environment><super>Net.NetNotification</super><private>false</private><indexed-type>none</indexed-type><inst-vars>originalFilename </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.AttachmentFilename</class-id><body>This notification is raised whenever an external files for attachements is about to be created. The notification provides access to the suggested filename, and allows to override it by resuming the notication with a different file name. If the notification is not handled the original suggested filename will be used. For example:	input := 'From: zz@holcim.comContent-Type: multipart/related;	boundary="--11"----11Content-Type: image/jpg; name="budd.jpg"Content-Disposition: attachment; filename="budd.jpg"Content-Transfer-Encoding: base64QWxhZGRpbjpvcGVuIHNlc2FtZQ==----11--' readStream.	[	message := MimeParserHandler new				saveAttachmentsAsFiles: true;				readFrom: input. 	] 		on: AttachmentFilename		do:  [ :ex | ex resume: 'my-', ex filename asFilename tail ].</body></comment><class><name>MultipartBody</name><environment>Net</environment><super>Net.MimeMessageBody</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.IOConstants.*			</imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.MultipartBody</class-id><body>This class represents multi-part MIME message bodies. Multi-part bodies contain one or more body parts, each preceded by a boundary line, and the last one followed by a closing boundary line. After the opening boundary line, each body part consists of a header area, a blank line, and a body area.  Thus a body part is similar to an RFC 822 message in syntax, but different in meaning.This class is responsible for parsing body structure from source stream and composing body structure to output stream. It parses out individual entities and lets entities parse themselves. Value of multi-part body is an array of Mime entities. Value is initialized lazily to avoid unnecessary parsing.Multi-part bodies are defined in section 5.1 of RFC2046 (http://www.ietf.org/rfc/rfc2046.txt). Here is an example of a multi-part message:     From: Nathaniel Borenstein &lt;nsb@bellcore.com&gt;     To: Ned Freed &lt;ned@innosoft.com&gt;     Date: Sun, 21 Mar 1993 23:56:48 -0800 (PST)     Subject: Sample message     MIME-Version: 1.0     Content-type: multipart/mixed; boundary="simple boundary"     This is the preamble.  It is to be ignored, though it     is a handy place for composition agents to include an     explanatory note to non-MIME conformant readers.     --simple boundary     This is implicitly typed plain US-ASCII text.     It does NOT end with a linebreak.     --simple boundary     Content-type: text/plain; charset=us-ascii     This is explicitly typed plain US-ASCII text.     It DOES end with a linebreak.     --simple boundary--     This is the epilogue.  It is also to be ignored.</body></comment><class><name>MimeEncodedWordCoDec</name><environment>Net</environment><super>Net.SimpleScanner</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><comment><class-id>Net.MimeEncodedWordCoDec</class-id><body>This class encodes and decodes Mime encoded words. These may occur in header fields of Mime entities. Mime (rfc2047) defines encoding for the following lexical elements: comments, text and phrase. So when each of them is read from a stream, it has to be decoded according to its lexical type by invoking an appropriate method on an instance of MimeEncodedWordCoDec.Shared Variables:	AvailableEncodings &lt;OrderedCollection&gt; available encodings is used to define encoding for strings</body></comment><shared-variable><name>CommentMask</name><environment>Net.RFC822Scanner</environment><private>false</private><constant>false</constant><category>masks</category><initializer>512</initializer><attributes><package>MIME</package></attributes></shared-variable><shared-variable><name>QuotedPairChar</name><environment>Net.RFC822Scanner</environment><private>false</private><constant>false</constant><category>masks</category><initializer>$\</initializer><attributes><package>MIME</package></attributes></shared-variable><shared-variable><name>HeaderNameMask</name><environment>Net.RFC822Scanner</environment><private>false</private><constant>false</constant><category>masks</category><initializer>2048</initializer><attributes><package>MIME</package></attributes></shared-variable><shared-variable><name>HeaderNameDelimiterChar</name><environment>Net.RFC822Scanner</environment><private>false</private><constant>false</constant><category>masks</category><initializer>$:</initializer><attributes><package>MIME</package></attributes></shared-variable><shared-variable><name>DomainTextMask</name><environment>Net.RFC822Scanner</environment><private>false</private><constant>false</constant><category>masks</category><initializer>1024</initializer><attributes><package>MIME</package></attributes></shared-variable><shared-variable><name>QuotedTextMask</name><environment>Net.RFC822Scanner</environment><private>false</private><constant>false</constant><category>masks</category><initializer>4096</initializer><attributes><package>MIME</package></attributes></shared-variable><shared-variable><name>TokenMask</name><environment>Net.RFC822Scanner</environment><private>false</private><constant>false</constant><category>masks</category><initializer>16384</initializer><attributes><package>MIME</package></attributes></shared-variable><shared-variable><name>QuotedPairMask</name><environment>Net.RFC822Scanner</environment><private>false</private><constant>false</constant><category>masks</category><initializer>"(QuotedTextMask bitOr: CommentMask)  bitOr: DomainTextMask"</initializer><attributes><package>MIME</package></attributes></shared-variable><shared-variable><name>AtomMask</name><environment>Net.RFC822Scanner</environment><private>false</private><constant>false</constant><category>masks</category><initializer>256</initializer><attributes><package>MIME</package></attributes></shared-variable><shared-variable><name>TextMask</name><environment>Net.RFC822Scanner</environment><private>false</private><constant>false</constant><category>masks</category><initializer>8192</initializer><attributes><package>MIME</package></attributes></shared-variable><shared-variable><name>SimpleTimeZones</name><environment>Net.RFC822Scanner</environment><private>false</private><constant>false</constant><category>masks</category><attributes><package>MIME</package></attributes></shared-variable><shared-variable><name>DefaultCharsetEncoder</name><environment>Net.SimpleBody</environment><private>false</private><constant>false</constant><category>defaults</category><initializer></initializer><attributes><package>MIME</package></attributes></shared-variable><shared-variable><name>DefaultContentDisposition</name><environment>Net.ContentDispositionField</environment><private>false</private><constant>false</constant><category>defaults</category><initializer></initializer><attributes><package>MIME</package></attributes></shared-variable><shared-variable><name>AvailableEncodings</name><environment>Net.MimeEncodedWordCoDec</environment><private>false</private><constant>false</constant><category>encoding</category><initializer>nil</initializer><attributes><package>MIME</package></attributes></shared-variable><shared-variable><name>FieldsRegistry</name><environment>Net.HeaderField</environment><private>false</private><constant>false</constant><category>registry</category><initializer>Dictionary new: 50</initializer><attributes><package>MIME</package></attributes></shared-variable><shared-variable><name>MimeQuotedTextMask</name><environment>Net.MimeScanner</environment><private>false</private><constant>false</constant><category>masks</category><initializer>32768</initializer><attributes><package>MIME</package></attributes></shared-variable><methods><class-id>Net.InvalidHeaderField</class-id> <category>initialize-release</category><body package="MIME">errorDescription: errorString source: aStream errorPosition: aNumber	self unparsedHeaderValue: ( UnparsedHeaderValue new								errorDescription: errorString;								source: aStream;								errorPosition: aNumber;								yourself )</body></methods><methods><class-id>Net.InvalidHeaderField</class-id> <category>private</category><body package="MIME">defaultResumeValue	^self unparsedHeaderValue</body></methods><methods><class-id>Net.InvalidHeaderField</class-id> <category>accessing</category><body package="MIME">unparsedHeaderValue		^self parameter</body><body package="MIME">unparsedHeaderValue: anUnparsedHeaderValue		parameter := anUnparsedHeaderValue</body></methods><methods><class-id>Net.InvalidHeaderField</class-id> <category>private - actions</category><body package="MIME">defaultAction	^self unparsedHeaderValue</body></methods><methods><class-id>Net.InvalidHeaderField class</class-id> <category>instance creation</category><body package="MIME">errorDescription: errorString source: aStream	^self errorDescription: errorString source: aStream errorPosition: nil</body><body package="MIME">errorDescription: errorString source: aStream errorPosition: position	^self new		errorDescription: errorString source: aStream errorPosition: position;		yourself</body></methods><methods><class-id>Net.HeaderField</class-id> <category>accessing</category><body package="MIME">canMerge	^false</body><body package="MIME">canonicalFieldName	| s |	s := name copy.	(s isNil or: [ s isEmpty]) ifTrue: [ ^String new ].	s at: 1 put: s first asUppercase.			" Capitalize first letter "	^ s</body><body package="MIME">canonicalValue" Override as necessary "	^self value</body><body package="MIME">name	^name</body><body package="MIME">name: aString	name := aString</body><body package="MIME">values" Multi-valued fields override this method "	^Array with: self value</body><body package="MIME">values: anArray" Multi-valued fields override this method "	anArray size ~= 1 ifTrue: [ ^self error: (#CantSetMultipleValuesInField &lt;&lt; #net &gt;&gt; 'Can''t set multiple values in this field') ].	self value: anArray first</body></methods><methods><class-id>Net.HeaderField</class-id> <category>private-initialize</category><body package="MIME">valueFrom: aString " Swazoo compatibility"	^self readFrom: aString readStream</body></methods><methods><class-id>Net.HeaderField</class-id> <category>visiting</category><body package="MIME">acceptVisit: aVisitor  with: argument	^aVisitor acceptHeaderField: self with: argument</body></methods><methods><class-id>Net.HeaderField</class-id> <category>printing</category><body package="MIME">printNameOn: aStream	self writeNameOn: aStream</body><body package="MIME">printOn: aStream indent: level	aStream tab: level.	value isUnparsedHeaderValue ifTrue: [^value printOn: aStream].	self  printNameOn: aStream.	[self printValueOn: aStream ] 		on: Error 		do: [ :ex | aStream nextPutAll: '[printing error]'. ex return]</body><body package="MIME">printValueOn: aStream	| val | 	(val := self value) notNil		ifTrue: 			[ (val isKindOf: String) 				ifTrue: [ aStream nextPutAll:  val]				ifFalse: [ val printOn: aStream ] ]</body></methods><methods><class-id>Net.HeaderField</class-id> <category>composing</category><body package="MIME">writeNameOn: aStream	aStream		nextPutAll: self canonicalFieldName;		nextPut: $: ;		space.</body><body package="MIME">writeOn: aStream	| val |	((val := self value) notNil and: [val isUnparsedHeaderValue]) ifTrue: [^val writeOn: aStream ].	self writeOn: aStream encoding:  (self parent ifNil: [nil ] ifNotNil: [ :entity| entity headerCharset ])</body><body package="MIME">writeOn: aStream encoding: aString"Encoding should be added to value if needed "	self  writeNameOn: aStream.	self writeValueOn: aStream encoding: aString</body><body package="MIME">writeValueOn: aStream encoding: aString	| val rfcString |	(val := self value) notNil		ifTrue: 			[ rfcString :=  (MimeEncodedWordCoDec shouldBeEncoded: val)				ifTrue: [ (MimeEncodedWordCoDec encodeText: val asBase64Using: aString) ]				ifFalse: [ val ].			aStream nextPutAll: rfcString]</body></methods><methods><class-id>Net.HeaderField</class-id> <category>private</category><body package="MIME">doParse: rfc822Stream" Generic parser for unstructured fields. This method is typically overridden for fields with known syntax to do more detailed parsing.Skip white spaces only "	rfc822Stream scanWhile: [rfc822Stream matchCharacterType: Net.SimpleScanner.WhiteSpaceMask].	^rfc822Stream scanText</body><body package="MIME">getValue	^(value isNil and: [self source notNil])		ifTrue: [[value := self doParse: (self scannerOn: self source)]				ensure: [self source close]]		ifFalse: [value]</body></methods><methods><class-id>Net.HeaderField</class-id> <category>parsing</category><body package="MIME">parse: rfc822Stream" Generic parser for unstructured fields. Copy everything up to CRLF. Scanner handles end of line rules and answers cr when end of line is seen. Scanner also folds linear white space answering space character in place of &lt;CRLF space+&gt; "	self source: rfc822Stream asStream.	value := [ self doParse: rfc822Stream]			on: Error			do: [ :ex |				(NetNotification handles: ex) 					ifTrue: [ex pass]					ifFalse: [(InvalidHeaderField 								errorDescription: ex description 								source: self source 								errorPosition: rfc822Stream position ) raise]].	self validateValue: rfc822Stream.</body><body package="MIME">validateValue: rfc822Stream</body></methods><methods><class-id>Net.HeaderField class</class-id> <category>parsing</category><body package="MIME">defaultFieldClass	^HeaderField</body><body package="MIME">fieldClassForName: fieldName	^self fieldsRegistry at:  fieldName asLowercase ifAbsent: [self defaultFieldClass].</body><body package="MIME">fieldNames	^#()</body><body package="MIME">fromLine: aString " For compatibility with Swazoo "	^self readFrom: aString readStream</body><body package="MIME">readFrom: aStream 	"Reads and parses message header contents from the message stream; answers an instance of header field"	^self readFrom: aStream acceptNonAsciiCharacters: nil</body><body package="MIME">readFrom: aStream acceptNonAsciiCharacters: aBoolen	"Reads and parses message header contents from the message stream; answers an instance of header field"	| fname scanner |	scanner := self scannerOn: aStream.	scanner acceptNonAsciiCharacters: aBoolen.	^(fname := scanner readFieldName) ifNotNil: 		[(self name: fname) parse: scanner]</body><body package="MIME">scannerType	^MimeScanner</body></methods><methods><class-id>Net.HeaderField class</class-id> <category>instance creation</category><body package="MIME">default	^self new</body><body package="MIME">name: aname" Answer new instance of field corresponding to field's name. For now, treat all fields as unstructured "	^(self fieldClassForName: aname) new name: aname; yourself</body><body package="MIME">new	^super new initialize</body></methods><methods><class-id>Net.HeaderField class</class-id> <category>class initialization</category><body package="MIME">fieldsRegistry	"(self fieldsRegistry)"	FieldsRegistry isEmpty		ifTrue: [ self registerClassFields].	^FieldsRegistry</body><body package="MIME">initialize	"(((self initialize)))"	self resetRegistry.</body><body package="MIME">registerClassFields	(HeaderField allSubclasses select: [ :cl | cl class includesSelector: #fieldNames ])		do: [ :cl | 			cl fieldNames do: [ :fname | FieldsRegistry at: fname put: cl ]]</body><body package="MIME">resetRegistry	FieldsRegistry := Dictionary new: 5.</body></methods><methods><class-id>Net.HeaderField class</class-id> <category>accessing</category><body package="MIME">acceptNonAsciiCharacters	^self scannerType acceptNonAsciiCharacters</body><body package="MIME">acceptNonAsciiCharacters: aBoolean	self scannerType acceptNonAsciiCharacters: aBoolean</body><body package="MIME">acceptNonAsciiCharactersValue	^self scannerType acceptNonAsciiCharactersValue</body></methods><methods><class-id>Net.StructuredHeaderField</class-id> <category>accessing</category><body package="MIME">canonicalValue" Canonical value removes all white space and comments from the source "	^self tokenizedValueFrom: (self scannerOn: self source readStream)</body><body package="MIME">comment	^comment</body><body package="MIME">comment: aString	comment := aString</body></methods><methods><class-id>Net.StructuredHeaderField</class-id> <category>printing</category><body package="MIME">printCommentOn: aStream	self class scannerType printComment: self comment on: aStream</body><body package="MIME">printStructureOn: aStream" Default implementation is the same as inherited. Subclasses can override it "	super printValueOn: aStream.	self printCommentOn: aStream</body><body package="MIME">printValueOn: aStream	self printStructureOn: aStream</body></methods><methods><class-id>Net.StructuredHeaderField</class-id> <category>private-utility</category><body package="MIME">sanitizeAddress: addressOrString 	"Make addresses is strings"	^addressOrString isString		ifTrue: [addressOrString ]		ifFalse: [addressOrString printString]</body><body package="MIME">sanitizeAddress: addressOrString encoding: aString	"Make addresses as strings"	^addressOrString isString		ifTrue: [MimeEncodedWordCoDec encodeIfRequired: addressOrString using: aString]		ifFalse: 	[addressOrString stringWithEncoding: aString]</body><body package="MIME">tokenize: rfc822Stream 	"Scan field value token by token. Answer an array of tokens"	| result token |	result := (Array new: 2) writeStream.	[rfc822Stream atEnd or: [rfc822Stream peek == Character cr or: [(token := rfc822Stream nextToken) isNil]]]		whileFalse: [result nextPut: token].	^result contents</body><body package="MIME">tokenizedValueFrom: rfc822Stream 	"Scan field value token by token. Answer a string that is a concatenation of all elements in the array. One can view this as a canonicalized field value because this operation eliminates all white space and comments "	| result tokens |	result := (String new: 32) writeStream.	tokens := self tokenize: rfc822Stream.	tokens		do: [:token | token isString				ifTrue: [result nextPutAll: token]				ifFalse: [result nextPut: token]].	^result contents</body></methods><methods><class-id>Net.StructuredHeaderField</class-id> <category>composing</category><body package="MIME">writeCommentOn: aStream encoding: aString	self comment ~~ nil 		ifTrue: 			[aStream nextPutAll: 				(MimeEncodedWordCoDec 					encodeComment: self comment 					asBase64Using: aString)]</body><body package="MIME">writeStructureOn: aStream encoding: aString" Default implementation is the same as inherited. Subclasses can override it "	super  writeValueOn: aStream  encoding: aString.	self writeCommentOn: aStream encoding: aString</body><body package="MIME">writeValueOn: aStream encoding: aString	self writeStructureOn: aStream encoding: aString</body></methods><methods><class-id>Net.StructuredHeaderField</class-id> <category>private</category><body package="MIME">doParse: rfc822Stream" Skip white spaces and comments "	^rfc822Stream skipWhiteSpace; scanText</body></methods><methods><class-id>Net.StructuredHeaderField class</class-id> <category>parsing</category><body package="MIME">fieldNames	^#('received' 'return-path' )</body></methods><methods><class-id>Net.CollectionField</class-id> <category>accessing</category><body package="MIME">separator	separator isNil 		ifTrue: [ separator := self class defaultSeparator].	^separator</body><body package="MIME">separator: aSymbol	separator := aSymbol</body><body package="MIME">value	^value isNil		ifTrue: [ value := OrderedCollection new]		ifFalse: [value]</body><body package="MIME">value: aStringOrCollection	aStringOrCollection isString		ifTrue: [ self value add: aStringOrCollection]		ifFalse: [ self value addAll: aStringOrCollection]</body></methods><methods><class-id>Net.CollectionField</class-id> <category>parsing</category><body package="MIME">doParse: scanner	| coll stream |	coll := OrderedCollection new. 	stream := (String new: 32) writeStream.	[scanner skipWhiteSpace.	scanner nextToken. 	scanner tokenType = #doIt ]		whileFalse: 			[ scanner token ~~ self separator				ifTrue: 					[scanner 						printToken: scanner token 						tokenType: scanner tokenType 						on: stream].			(scanner atEnd or: [scanner token == self separator])				ifTrue: 					[ coll add: (self parseItem: stream contents).					stream := (String new: 20) writeStream]]. 	stream contents notEmpty ifTrue: [ coll add: (self parseItem: stream contents)].	^coll</body><body package="MIME">parseItem: aString	^aString</body></methods><methods><class-id>Net.CollectionField</class-id> <category>printing</category><body package="MIME">printValueOn: aStream 	self writeValueOn: aStream encoding: nil</body></methods><methods><class-id>Net.CollectionField</class-id> <category>composing</category><body package="MIME">writeValueOn: aStream encoding: aString	self value  		do: [ :param |  aStream nextPutAll: param ]		separatedBy: [aStream nextPut: self separator].</body></methods><methods><class-id>Net.CollectionField class</class-id> <category>defaults</category><body package="MIME">defaultSeparator	^$,</body></methods><methods><class-id>Net.CollectionField class</class-id> <category>instant creation</category><body package="MIME">name: nameString value: stringOrCollection	^( self name: nameString)		value: stringOrCollection;		yourself</body></methods><methods><class-id>Net.CollectionField class</class-id> <category>parsing</category><body package="MIME">fieldNames	^#('accept-encoding' 'allow' 'accept-ranges' 'if-match' 'if-none-match' 'public' 'connection' 'upgrade')</body></methods><methods><class-id>Net.ScalarField</class-id> <category>parsing</category><body package="MIME">doParse: rfc822Stream 	^self tokenizedValueFrom: rfc822Stream</body></methods><methods><class-id>Net.ScalarField class</class-id> <category>instant creation</category><body package="MIME">base64" ScalarField base64 "	^self contentTransferEncoding: 'base64'</body><body package="MIME">contentTransferEncoding: encodingName" Answer an instance of this field representing desired content transfer encoding. encodingName is one of 'base64' or 'quoted-printable' "" ScalarField contentTransferEncoding: 'base64' "	^(self name: 'content-transfer-encoding') value: encodingName</body><body package="MIME">quotedPrintable" ScalarField quotedPrintable "	^self contentTransferEncoding: 'quoted-printable'</body></methods><methods><class-id>Net.ScalarField class</class-id> <category>parsing</category><body package="MIME">fieldNames	^#('message-id' 'content-id' 'content-transfer-encoding' 'content-encoding')</body></methods><methods><class-id>Net.NumericField</class-id> <category>accessing</category><body package="MIME">asString	^self value printString</body></methods><methods><class-id>Net.NumericField</class-id> <category>parsing</category><body package="MIME">doParse: rfc822Stream " HeaderField fromLine: 'Content-length : 1024 (This is body length in bytes)' "	rfc822Stream skipWhiteSpace.	^Number readFrom: rfc822Stream asStream</body></methods><methods><class-id>Net.NumericField</class-id> <category>initialization</category><body package="MIME">initialize	super initialize.	value := 0</body></methods><methods><class-id>Net.NumericField</class-id> <category>printing</category><body package="MIME">printStructureOn: aStream	aStream nextPutAll: self asString.	self printCommentOn: aStream.</body></methods><methods><class-id>Net.NumericField</class-id> <category>composing</category><body package="MIME">writeStructureOn: aStream encoding: aString	aStream nextPutAll: self asString.	self writeCommentOn: aStream encoding: aString.</body></methods><methods><class-id>Net.NumericField class</class-id> <category>parsing</category><body package="MIME">fieldNames	^#('content-length' )</body></methods><methods><class-id>Net.NumericField class</class-id> <category>instant creation</category><body package="MIME">contentLength: aNumber" Answer an instance of this field representing content length"	^(self name: 'content-length') value: aNumber</body></methods><methods><class-id>Net.MimeDispatcher</class-id> <category>visiting -- double dispatching</category><body package="MIME">acceptHeaderField: aHeaderField with: argument	^aHeaderField</body><body package="MIME">acceptMessage: aMessage with: argument	(self handler shouldStartMessage: aMessage)		ifTrue: [ 	self handler startMessage: aMessage.				[aMessage header acceptVisit: self  with: argument.				(self handler shouldStartBody: aMessage body) 					ifTrue: [self handler startMessageBody: aMessage.							self handler 								processMessageBody:  aMessage 								do: [aMessage body acceptVisit: self  with: argument	]]					ifFalse: [self handler finishEmptyBodyMessage: aMessage ]				] ensure: [ self handler endMessage: aMessage ] ].	^aMessage</body><body package="MIME">acceptMessageHeader: aMessageHeader with: argument 		[self handler startHeader: aMessageHeader 	]  ensure: [self handler endHeader: aMessageHeader].	^aMessageHeader</body><body package="MIME">acceptMimeEntity: aMimeEntity  with: argument	(self handler shouldStartEntity: aMimeEntity) ifTrue: [		[	self handler startEntity: aMimeEntity.			aMimeEntity header acceptVisit: self with: argument.			aMimeEntity body acceptVisit: self with: argument.		] ensure: [self handler endEntity:  aMimeEntity] ].	^aMimeEntity</body><body package="MIME">acceptMultipartBody: aMultipartBody with: argument	(self handler shouldStartBody: aMultipartBody) 		ifTrue:			[self handler startMultipartBody: aMultipartBody .			[aMultipartBody parts do: 				[ :part | 				self handler startPart:part.				part acceptVisit: self with: nil.				self handler endPart: part ].			] ensure: [self handler endMultipartBody: aMultipartBody]].		^aMultipartBody</body><body package="MIME">acceptSimpleBody: aSimpleBody  with: argument"#shouldStartBody: method opens the stream to check its size. If the stream is empty the #startSimpleBody: won't be executed but the stream should be closed anyway"	[		(self handler shouldStartBody: aSimpleBody) 			ifTrue: [ self handler startSimpleBody: aSimpleBody ]					] ensure: [self handler endSimpleBody: aSimpleBody].		^aSimpleBody</body></methods><methods><class-id>Net.MimeDispatcher</class-id> <category>visiting</category><body package="MIME">visit: aMessageElement with: argument	^aMessageElement notNil 		ifTrue: [aMessageElement acceptVisit: self with: argument]		ifFalse: [nil]</body></methods><methods><class-id>Net.MimeDispatcher</class-id> <category>initialization</category><body package="MIME">initialize</body></methods><methods><class-id>Net.MimeDispatcher</class-id> <category>accessing</category><body package="MIME">handler	^handler</body><body package="MIME">handler: aMessageHandler	handler := aMessageHandler</body></methods><methods><class-id>Net.MimeDispatcher class</class-id> <category>instance creation</category><body package="MIME">handler: aMessageHandler	^self new		handler: aMessageHandler</body><body package="MIME">new	^super new initialize</body></methods><methods><class-id>Net.MimeMessageBody</class-id> <category>testing</category><body package="MIME">isBinary	^self parent isBinary</body><body package="MIME">isBinaryContentType	^self parent isBinaryContentType</body><body package="MIME">isEmpty	^self notEmpty not</body><body package="MIME">isMultipart	^false</body><body package="MIME">isSimple	^true</body><body package="MIME">notEmpty	^self size &gt; 0</body></methods><methods><class-id>Net.MimeMessageBody</class-id> <category>accessing</category><body package="MIME">decodedValue	^self value</body><body package="MIME">decodedValueWith: aSymbol	^self value</body><body package="MIME">mimeType	^self parent mimeType</body><body package="MIME">partAt: anInteger	self subclassResponsibility</body><body package="MIME">removePart: aMimeEntity	self subclassResponsibility</body><body package="MIME">removePartAt: anInteger	self subclassResponsibility</body><body package="MIME">size	^ self sourceSize</body></methods><methods><class-id>Net.MimeMessageBody</class-id> <category>printing</category><body package="MIME">preamble	^nil</body><body package="MIME">printOn: aStream indent: level	(self parent ifNil: [ MimeEntity ]) newPrinter		printMessageElement: self on: aStream indent: level</body></methods><methods><class-id>Net.MimeMessageBody</class-id> <category>parsing</category><body package="MIME">parse: scanner</body></methods><methods><class-id>Net.MimeMessageBody</class-id> <category>mutating</category><body package="MIME">newBody</body></methods><methods><class-id>Net.MimeMessageBody</class-id> <category>composing</category><body package="MIME">writeOn: aStream" Write your contents on a stream. Used to save to a file. etc. "	self subclassResponsibility</body></methods><methods><class-id>Net.MimeMessageBody class</class-id> <category>instance creation</category><body package="MIME">bodyTypeFor: aMimeEntity 	^aMimeEntity isMultipart		ifTrue: [MultipartBody]		ifFalse: [SimpleBody]</body><body package="MIME">newBodyFor: aMimeEntity 	^(self bodyTypeFor: aMimeEntity) new		parent: aMimeEntity;		yourself</body><body package="MIME">readFrom: stream parent: aMimeEntity	^(self newBodyFor: aMimeEntity)		readFrom: stream;		yourself</body></methods><methods><class-id>Net.MimeMessageBody class</class-id> <category>parsing</category><body package="MIME">scannerType	^MimeScanner</body></methods><methods><class-id>Net.SinglepartBody</class-id> <category>transfer encoding</category><body package="MIME">needsContentTransferEncoding	^self isBinary</body></methods><methods><class-id>Net.SimpleBody</class-id> <category>defaults</category><body package="MIME">defaultContentType	^'text/plain'</body></methods><methods><class-id>Net.SimpleBody</class-id> <category>private -- parsing</category><body package="MIME">doParse: rfc822Scanner	^rfc822Scanner contents</body></methods><methods><class-id>Net.SimpleBody</class-id> <category>accessing</category><body package="MIME">anySource	(source isNil and: [byteSource isNil]) 		ifTrue: [^String new readStream].	^(source isNil		ifTrue: [ byteSource ]		ifFalse: [ source ])</body><body package="MIME">byteSource	^byteSource</body><body package="MIME">byteSource: aByteArrayStream	byteSource := aByteArrayStream</body><body package="MIME">byteSourceSize	^byteSource isNil		ifTrue: [ 0 ]		ifFalse: [byteSource size]</body><body package="MIME">byteValueAsStream	"The method is used for message writing.  Answer stream representing value. If value has been set, make stream out of it. Otherwise just use source stream. Reset the stream before returning. If the source contains non-ASCII chars convert it to an EncodedStream."	| stream encoding |	byteSource notNil ifTrue: [		byteSource reset.		^byteSource isSegmented "only mail messages parsed from archives use stream segments"			ifTrue: [ NonClosingReadStream on: byteSource ]			ifFalse: [ (EncodedStream						on: byteSource reset						encodedBy: ( StreamEncoder new: #ISO8859_1 )					) binary]].	^self source == nil		ifTrue: [ByteArray new readStream]		ifFalse: 			[ self source isInternal 				ifTrue: [encoding := self encodingFor:  self source reset contents.					encoding ifNil: [encoding := #ISO8859_1  ].					stream := EncodedStream								on: ( ReadWriteStream on: (ByteArray new: self source size))								encodedBy: (StreamEncoder new: encoding ) initializeForMemory.					self source reset.					[ self source atEnd]						whileFalse: [ stream nextPut: self source next ]. 					stream binary;reset ]				ifFalse: 					[" Attachment " 					self source reset ]]</body><body package="MIME">contentLength" Answer content length in octets, nil if not known "	^self parent contentLength</body><body package="MIME">contentTypeEncoding	" Answer symbolic name of the character encoding for this body "	^self parent notNil		ifTrue: [self parent contentTypeEncoding]		ifFalse: [#default]</body><body package="MIME">contentTypeSpecies	^self parent contentTypeSpecies</body><body package="MIME">contentsSpecies	^self parent contentsSpecies</body><body package="MIME">decodedValue	^self decodedValueWith:  self class defaultCharsetEncoder.</body><body package="MIME">decodedValueWith: aSymbol	^self parent canBeDecoded 		ifTrue: 			[self byteSource notNil				ifTrue: [(self byteSource contents withEncoding: aSymbol) readStream							lineEndAuto;							contents]				ifFalse: 					[(self source encodedContents asByteArray withEncoding: aSymbol ) 						readStream  						lineEndConvention: self source lineEndConvention; 						contents]]		ifFalse: 			[ self value ]</body><body package="MIME">decompressedContents"Returns decompressed body contents. The body contents won't be changed "	| writeStream zippedStream |	self byteSource isNil ifTrue: [ ^String new ].	writeStream := (ByteArray new: 1024) writeStream.	zippedStream := OS.ZLib.GZipReadStream on: self byteSource reset.	[zippedStream atEnd] whileFalse: [ writeStream nextPut: zippedStream next].	^writeStream contents</body><body package="MIME">encoding	" Answer symbolic name of the character encoding for this body "	^self parent notNil		ifTrue: [self parent encoding]		ifFalse: [#default]</body><body package="MIME">partAt: anInteger	self shouldNotImplement</body><body package="MIME">parts	^OrderedCollection new</body><body package="MIME">removePart: aMimeEntity	self shouldNotImplement</body><body package="MIME">removePartAt: anInteger	self shouldNotImplement</body><body package="MIME">size	^source notNil		ifTrue: [ self sourceSize ]		ifFalse: [ self byteSourceSize ]</body><body package="MIME">source: aStream	source := aStream.</body><body package="MIME">sourceForDigest	^self anySource</body><body package="MIME">value: anArray	self source: anArray readStream.	byteSource := nil.</body><body package="MIME">valueAsStream	" Answer stream representing value. If value has been set, make stream out of it. Otherwise just use source stream. Reset the stream before returning. If the source contains non-ASCII chars convert it to an EncodedString."	| encoding contents |	byteSource ifNotNil: [^byteSource reset]. 	^self source == nil		ifTrue: [String new readStream]		ifFalse: 			[ self source isInternal				ifTrue: 					[contents := self source reset contents.					encoding := self encodingFor:  contents.					encoding ifNotNil:						[contents := self 										encodeDo: [ (contents asByteArrayEncoding: encoding) asString ] 										with: encoding ].					contents readStream]				ifFalse: 					[" Attachment " 					self source reset ]]</body></methods><methods><class-id>Net.SimpleBody</class-id> <category>visiting</category><body package="MIME">acceptVisit: aVisitor with: argument	^aVisitor acceptSimpleBody: self with: argument</body></methods><methods><class-id>Net.SimpleBody</class-id> <category>private</category><body package="MIME">encodeDo: aBlock with: encoding	^[ aBlock value ] 		on: Error 		do: [ :ex | 			(EncodingFailure  new 					messageText: ((#FailedToEncodeBodySource &lt;&lt; #net &gt;&gt;'Failed to encode the body source with: &lt;1s&gt; ') expandMacrosWith: encoding printString);					parameter: self;					yourself) raise ]</body><body package="MIME">encodingFor: aByteString	^parent charsetIfNone: [MimeEncodedWordCoDec findEncodingFor: aByteString ].</body><body package="MIME">getValue	^self source isNil		ifTrue: [self getValueFromByteSource]		ifFalse: [[self source reset; contents] ensure: [self source close]]</body><body package="MIME">getValueFromByteSource	| s |	^(s :=self getValueStreamFromByteSource) isNil		ifTrue: [s]		ifFalse: [ [s contents] ensure:[ s close ] ]</body><body package="MIME">getValueStreamFromByteSource	| encoding |	byteSource isNil ifTrue: [ ^nil]."	byteSource isExternalStream ifTrue: [^byteSource reset]."	self parent canBeDecoded		ifTrue:			[encoding := self parent charsetIfNone: [nil ].			encoding isNil				ifTrue: [ byteSource reset ]				ifFalse: 					[^self 						encodeDo: [[ (byteSource contents asByteArray withEncoding: encoding) readStream] ensure: [byteSource close]]  						with: encoding ]].	^byteSource reset</body><body package="MIME">writeFrom: sourceStream to: destStream	| buffer count textMode |	textMode := sourceStream isBinary not.	sourceStream binary.	destStream binary.	buffer := ByteArray new: 1024.	[		[sourceStream atEnd] 			whileFalse: 				[count := sourceStream nextAvailable: buffer size into: buffer startingAt: 1.				destStream next: count putAll: buffer startingAt: 1 ]	] ensure: 		[textMode ifTrue: [sourceStream text].		destStream text ]</body></methods><methods><class-id>Net.SimpleBody</class-id> <category>mutating</category><body package="MIME">addPart: part	(self parent bot		makeMultipart: self parent) 		addPart: part;		yourself</body></methods><methods><class-id>Net.SimpleBody</class-id> <category>transfer encoding</category><body package="MIME">needsContentTransferEncoding	self isBinary ifTrue: [^true].	^self class scannerType 			needsTransferEncoding: self valueAsStream mimeType: self mimeType</body><body package="MIME">removeContentTransferEncoding	(byteSource notNil and: [ byteSource isSegmented ]) ifTrue: [^self ].	self parent newBuilder removeContentTransferEncodingFor: self</body></methods><methods><class-id>Net.SimpleBody</class-id> <category>composing</category><body package="MIME">writeOn: aStream	| input | 	input := self byteValueAsStream.	[	self writeFrom: input to: aStream.	]  ensure: 		[input ~~nil ifTrue: [ input close ]]</body></methods><methods><class-id>Net.SimpleBody class</class-id> <category>accessing settings</category><body package="MIME">defaultCharsetEncoder	^DefaultCharsetEncoder isNil		ifTrue: [ DefaultCharsetEncoder := self defaultCharsetEncoderValue ]		ifFalse: [ DefaultCharsetEncoder ]</body><body package="MIME">defaultCharsetEncoder: aString	DefaultCharsetEncoder := aString</body></methods><methods><class-id>Net.SimpleBody class</class-id> <category>defaults</category><body package="MIME">defaultCharsetEncoderValue	^Locale current defaultEncoding</body></methods><methods><class-id>Net.NetworkEntityDescriptor</class-id> <category>accessing</category><body package="MIME">alias	^alias</body><body package="MIME">alias: aValue	alias := aValue</body><body package="MIME">comment	^comment</body><body package="MIME">comment: aValue	comment := aValue</body><body package="MIME">stringWithEncoding: aString	| stream |	stream := (String new: 256) writeStream.	self writeOn: stream encoding: aString.	^stream contents</body></methods><methods><class-id>Net.NetworkEntityDescriptor</class-id> <category>parsing</category><body package="MIME">scannerType	^self class scannerType</body></methods><methods><class-id>Net.NetworkEntityDescriptor</class-id> <category>composing</category><body package="MIME">writeAliasOn: stream 	alias notNil 		ifTrue: 			[(self scannerType shouldBeQuoted: alias)				ifTrue: [ stream nextPut: $"; nextPutAll: alias; nextPut: $" ]				ifFalse: [stream nextPutAll: alias]].</body><body package="MIME">writeAliasOn: stream encoding: aString	"Encoding is required if alias contains non-ASCII chars."	alias notNil 		ifTrue: 			[(MimeEncodedWordCoDec shouldBeEncoded: alias)				ifTrue: [ stream nextPutAll: (MimeEncodedWordCoDec 									encodeText: alias 									asQuotedPrintableUsing: aString)]				ifFalse: 					[(self scannerType shouldBeQuoted: alias) 						ifTrue: [stream nextPut: $"; nextPutAll: alias; nextPut: $"]						ifFalse: [stream nextPutAll: alias]]]</body><body package="MIME">writeCanonicalValueOn: stream	self subclassResponsibility</body><body package="MIME">writeCanonicalValueOn: stream encoding: aString	self subclassResponsibility</body><body package="MIME">writeCommentOn: stream 	comment notNil ifTrue: [		stream nextPut: $(.		comment			do: 				[:char | 				(RFC822Scanner isCommentChar: char)					ifFalse: [stream nextPut: $\].				stream nextPut: char].		stream nextPut: $).	]</body><body package="MIME">writeCommentOn: stream encoding: aString	self comment ~~ nil 		ifTrue: 			[stream nextPutAll: 				(MimeEncodedWordCoDec 					encodeComment: self comment 					asBase64Using: aString)]</body><body package="MIME">writeOn: stream	self writeCanonicalValueOn: stream.	comment notNil ifTrue: [self writeCommentOn: stream]</body><body package="MIME">writeOn: stream encoding: aString	self writeCanonicalValueOn: stream encoding: aString.</body></methods><methods><class-id>Net.NetworkEntityDescriptor</class-id> <category>testing</category><body package="MIME">isValid	^true</body></methods><methods><class-id>Net.NetworkEntityDescriptor</class-id> <category>printing</category><body package="MIME">printOn: stream indent: level	self writeOn: stream</body></methods><methods><class-id>Net.NetworkEntityDescriptor class</class-id> <category>parsing</category><body package="MIME">scannerType	^NetworkAddressParser</body></methods><methods><class-id>Net.MessageStream</class-id> <category>private</category><body package="MIME">contentsSpecies	^stream contentsSpecies</body><body package="MIME">pastEnd	"The receiver has attempted to read past the end, answer nil."	^self class endOfStreamSignal raiseRequestFrom: self</body></methods><methods><class-id>Net.MessageStream</class-id> <category>accessing</category><body package="MIME">binary	stream binary</body><body package="MIME">contents	^self error: (#NotImplementedYet &lt;&lt; #net &gt;&gt; 'This message has not been implemented yet')</body><body package="MIME">lineEnd	^#[ 13 10]</body><body package="MIME">stream	^stream</body><body package="MIME">text	stream text.</body></methods><methods><class-id>Net.MessageStream class</class-id> <category>instance creation</category><body package="MIME">new	^super new initialize</body><body package="MIME">on: aStream	^self basicNew initializeOn: aStream</body></methods><methods><class-id>Net.NetworkAddressDescriptor</class-id> <category>accessing</category><body package="MIME">addressSpecString	^self printStringSelector: #writeAddressSpecOn:</body><body package="MIME">aliasString	^self printStringSelector: #writeAliasOn:</body><body package="MIME">commentString	^self printStringSelector: #writeCommentOn:</body><body package="MIME">domain	^domain</body><body package="MIME">domain: aValue	domain := aValue</body><body package="MIME">domainString	^self printStringSelector: #writeDomainOn:</body><body package="MIME">localPart	^localPart</body><body package="MIME">localPart: aValue	localPart := aValue</body><body package="MIME">localPartString	^self printStringSelector: #writeLocalPartOn:</body><body package="MIME">route	^route</body><body package="MIME">route: aValue	route := aValue</body><body package="MIME">routeString	^self printStringSelector: #writeRouteOn:</body></methods><methods><class-id>Net.NetworkAddressDescriptor</class-id> <category>testing</category><body package="MIME">hasAddressSpec	^localPart notNil and: [localPart isEmpty not and: [domain notNil and: [domain isEmpty not]]]</body></methods><methods><class-id>Net.NetworkAddressDescriptor</class-id> <category>initialization</category><body package="MIME">initialize	localPart := Array new.</body></methods><methods><class-id>Net.NetworkAddressDescriptor</class-id> <category>private</category><body package="MIME">printStringSelector: sel	| stream |	stream := (String new: 64) writeStream.	self perform: sel with: stream.	^stream contents</body></methods><methods><class-id>Net.NetworkAddressDescriptor</class-id> <category>composing</category><body package="MIME">writeAddressSpecOn: stream 	self hasAddressSpec		ifTrue: 			[self writeLocalPartOn: stream.			stream nextPut: $@.			self writeDomainOn: stream]		ifFalse:			[(alias notNil and: [ alias notEmpty ]) 				ifTrue: [self scannerType printWord: alias on: stream ]]</body><body package="MIME">writeCanonicalValueOn: stream 	alias notNil		ifTrue: 			[self writeAliasOn: stream.			self writeRouteAddressOn: stream]		ifFalse: [self writeAddressSpecOn: stream].</body><body package="MIME">writeCanonicalValueOn: stream encoding: aString "Because some legacy implementations interpret the comment, comments generally SHOULD NOT be used in address fields to avoid confusing such implementations."	alias notNil		ifTrue: 			[self writeAliasOn: stream encoding: aString.			self writeRouteAddressOn: stream]		ifFalse: 	[ self writeAddressSpecOn: stream].</body><body package="MIME">writeDomainOn: stream	self scannerType printDomain: domain on: stream</body><body package="MIME">writeLocalPartOn: stream 	localPart do: [ :token | self scannerType printWord: token on: stream ] separatedBy: [ stream nextPut: $. ]</body><body package="MIME">writeRouteAddressOn: stream 	" RFC 5322  When interpreting addresses, the route portion SHOULD be ignored. "	self hasAddressSpec		ifTrue: 			[stream nextPut: $&lt;.			self writeAddressSpecOn: stream.			stream nextPut: $&gt;]</body><body package="MIME">writeRouteOn: stream 	(route notNil and: [route isEmpty not])		ifTrue: 			[route				do: 					[:domainx | 					stream space; nextPut: $@.					self scannerType printDomain: domainx on: stream.					stream nextPut: $:].			stream space]</body></methods><methods><class-id>Net.NetworkAddressDescriptor class</class-id> <category>utility</category><body package="MIME">addressFrom: aRFC822ScannerOrStream	"self addressesFrom: 'kyasu@crl.fujixerox.co.jp' readStream."	"self addressesFrom: 'Kazuki Yasumatsu &lt;kyasu@crl.fujixerox.co.jp&gt;' readStream."	"self addressesFrom: 'kyasu@crl.fujixerox.co.jp (Kazuki Yasumatsu)' readStream."	"self addressesFrom: ' kyasu1, kyasu2, Kazuki Yasumatsu &lt;kyasu3&gt;, kyasu4 (Kazuki Yasumatsu)' readStream."	"self addressesFrom: ' foo bar, kyasu1, ,  Kazuki Yasumatsu &lt;kyasu2&gt; &lt;kyasu3&gt; (&lt;foo&gt; (foo bar), bar)' readStream."	^self scannerType addressFrom: aRFC822ScannerOrStream</body><body package="MIME">addressesFrom: aRFC822ScannerOrStream	"self addressesFrom: 'kyasu@crl.fujixerox.co.jp' readStream."	"self addressesFrom: 'Kazuki Yasumatsu &lt;kyasu@crl.fujixerox.co.jp&gt;' readStream."	"self addressesFrom: 'kyasu@crl.fujixerox.co.jp (Kazuki Yasumatsu)' readStream."	"self addressesFrom: ' kyasu1, kyasu2, Kazuki Yasumatsu &lt;kyasu3&gt;, kyasu4 (Kazuki Yasumatsu)' readStream."	"self addressesFrom: ' foo bar, kyasu1, ,  Kazuki Yasumatsu &lt;kyasu2&gt; &lt;kyasu3&gt; (&lt;foo&gt; (foo bar), bar)' readStream."	^self scannerType addressesFrom: aRFC822ScannerOrStream</body></methods><methods><class-id>Net.ValueWithParametersField</class-id> <category>accessing</category><body package="MIME">canMerge	^true</body><body package="MIME">defaultSeparators	^self class defaultSeparators</body><body package="MIME">element	self first isNil		ifTrue: [ self value add: self newValue ].	^self first</body><body package="MIME">elementParams 	^self element params</body><body package="MIME">first	^self value first</body><body package="MIME">groupSeparator	^self separators at: 3</body><body package="MIME">newValue	^self valueWithParamsClass newWithSeparators: self separators</body><body package="MIME">parametersSeparator	^self separators at: 2</body><body package="MIME">separators	separators isNil 		ifTrue: [ separators := self defaultSeparators].	^separators</body><body package="MIME">separators: anArray	separators := anArray</body><body package="MIME">value	^value isNil		ifTrue: [ value := OrderedCollection new]		ifFalse: [value]</body><body package="MIME">valueSeparator	^self separators first</body><body package="MIME">valueWithParamsClass	^ValueWithParams</body></methods><methods><class-id>Net.ValueWithParametersField</class-id> <category>adding</category><body package="MIME">add: aValueWithParametersFields	self value addAll: aValueWithParametersFields value</body></methods><methods><class-id>Net.ValueWithParametersField</class-id> <category>composing</category><body package="MIME">writeValueOn: aStream encoding: aString	self value notNil		ifTrue: 			[self value  				do: [ :param |  param writeOn: aStream encoding: aString ]				separatedBy: [aStream nextPut: self groupSeparator ]]		ifFalse: [ aStream nextPutAll: '' ].</body></methods><methods><class-id>Net.ValueWithParametersField</class-id> <category>parsing</category><body package="MIME">doParse: scanner	| list newVal |	list := OrderedCollection new: 5.	[	scanner atEnd	] whileFalse: [		(newVal := self newValueFrom: scanner) readFrom: scanner.		list add: newVal.		(scanner atEnd not and: [self groupSeparator ~~ Character space]) ifTrue: [			scanner skipWhiteSpace. 			(scanner next == self groupSeparator) ifFalse: [				InvalidParameterValue signalWith: scanner contents.				scanner upTo: self groupSeparator]]].	^list</body><body package="MIME">newValueFrom: scanner	^self valueWithParamsClass newWithSeparators: self separators</body></methods><methods><class-id>Net.ValueWithParametersField</class-id> <category>printing</category><body package="MIME">printValueOn: aStream 	self value notNil		ifTrue: 			[self value  				do: [ :param |  param printOn: aStream]				separatedBy: [aStream nextPut: self groupSeparator ]]		ifFalse: [ aStream nextPutAll: '' ].</body></methods><methods><class-id>Net.ValueWithParametersField class</class-id> <category>defaults</category><body package="MIME">defaultSeparators	^self subclassResponsibility</body></methods><methods><class-id>Net.ValueWithParametersField class</class-id> <category>instance creation</category><body package="MIME">newWithSeparators: anArray	^self new		separators: anArray;		yourself</body></methods><methods><class-id>Net.SingleValueWithParametersField</class-id> <category>accessing</category><body package="MIME">canMerge	^false</body><body package="MIME">localValue	^self element value</body><body package="MIME">localValue: aString	self element value: aString</body><body package="MIME">parameterAt: aName 	^self element paramAt: aName</body><body package="MIME">parameterAt: aName ifAbsent: aBlock	^self element paramAt: aName ifAbsent: [aBlock value]</body><body package="MIME">parameterAt: aName put: aValue	self element paramAt: aName put: aValue</body><body package="MIME">value	value isNil 		ifTrue: [ value := OrderedCollection with: self newValue ].	^value</body></methods><methods><class-id>Net.SingleValueWithParametersField</class-id> <category>composing</category><body package="MIME">writeValueOn: aStream encoding: aString" Default implementation is the same as inherited. Subclasses can override it "	self value ~~ nil		ifTrue: 			[self value  				do: [ :param |  param writeOn: aStream encoding: aString ]				separatedBy: [aStream nextPut: self groupSeparator]].</body></methods><methods><class-id>Net.SingleValueWithParametersField</class-id> <category>parsing</category><body package="MIME">validateValue: scanner	value size &gt; 1 ifTrue: 		[^InvalidParameterValue 			raiseRequestWith: value			errorString: (#WrongParametersNumber &lt;&lt; #net &gt;&gt; 'Wrong parameters number').].</body></methods><methods><class-id>Net.ContentDispositionField</class-id> <category>accessing</category><body package="MIME">disposition	^self localValue</body><body package="MIME">disposition: aString" Disposition should be 'inline' or 'attachment' "	self localValue: aString</body><body package="MIME">fileName	^self parameterAt: 'filename'</body><body package="MIME">fileName: aString	^self parameterAt: 'filename' put: aString</body><body package="MIME">size	Integer readFrom: (self parameterAt: 'size' ifAbsent: [^nil]) readStream</body><body package="MIME">size: anInteger	self parameterAt: 'size' put: anInteger printString</body></methods><methods><class-id>Net.ContentDispositionField</class-id> <category>testing</category><body package="MIME">isAttachment" Answer true if content disposition is 'attachments' "	^self disposition asLowercase = 'attachment'</body><body package="MIME">isFormData	^self disposition asLowercase = 'form-data'</body><body package="MIME">isInline" Answer true if content disposition is 'inline' "	^self disposition asLowercase = 'inline'</body></methods><methods><class-id>Net.ContentDispositionField class</class-id> <category>parsing</category><body package="MIME">fieldNames	^#('content-disposition')</body></methods><methods><class-id>Net.ContentDispositionField class</class-id> <category>defaults</category><body package="MIME">defaultContentDispositionValue	^#attachment</body><body package="MIME">defaultSeparators	^#($; $; nil  )</body></methods><methods><class-id>Net.ContentDispositionField class</class-id> <category>instance creation</category><body package="MIME">default	^self fromLine: 'Content-disposition: ', self defaultContentDisposition</body><body package="MIME">formData	^self fromLine: 'Content-disposition: ', 'form-data'.</body></methods><methods><class-id>Net.ContentDispositionField class</class-id> <category>accessing</category><body package="MIME">defaultContentDisposition	^DefaultContentDisposition isNil		ifTrue: [ DefaultContentDisposition := self defaultContentDispositionValue]		ifFalse: [DefaultContentDisposition ]</body><body package="MIME">defaultContentDisposition: aString	DefaultContentDisposition := aString</body></methods><methods><class-id>Net.MessageHeader</class-id> <category>adding</category><body package="MIME">add: field	self register: field.	self fields add: field</body><body package="MIME">add: field after: object	self register: field.	self fields add: field after: object</body><body package="MIME">add: field afterIndex: occurrenceIndex	self register: field.	self fields add: field afterIndex: occurrenceIndex</body><body package="MIME">add: field before: object	self register: field.	self fields add: field before: object</body><body package="MIME">add: field beforeIndex: occurrenceIndex	self register: field.	self fields add: field beforeIndex: occurrenceIndex</body><body package="MIME">addAll: collectionOfFields 	collectionOfFields do: [:field | self add: field]</body><body package="MIME">addField: field	" This method will check if the field exists already; if yes, if it can be merged into the existing field and, if yes, merge it. Otherwise, add as a new field "	(field canMerge and: [(self at: field name) notNil])		ifTrue: [ (self at: field name) add: field]		ifFalse: [ self add: field]</body></methods><methods><class-id>Net.MessageHeader</class-id> <category>sorting</category><body package="MIME">arrangeFieldsInOrder: anArrayOfFieldNames" Make sure specified fields occur before all other fields in specified order "	value := self fieldsInOrder: anArrayOfFieldNames</body><body package="MIME">fieldsInOrder: anArrayOfFieldNames" Answer fields sorted such that specified fields occur before all other fields"	| definedFields |	definedFields := OrderedCollection new: self fields size.	anArrayOfFieldNames do: [ :fieldName | definedFields addAll: (self allAt: fieldName)].	definedFields addAll: (self fields reject: [ :fieldx | definedFields includes: fieldx]).	^definedFields</body></methods><methods><class-id>Net.MessageHeader</class-id> <category>accessing</category><body package="MIME">allAt: name	^self registry at: name asLowercase ifAbsent: [OrderedCollection new]</body><body package="MIME">at: name	^self at: name at: 1</body><body package="MIME">at: name at: occurrenceIndex	^self at: name at: occurrenceIndex ifAbsent: [ nil ]</body><body package="MIME">at: name at: occurrenceIndex ifAbsent: aNiladicBlock	| namedFields |	namedFields := self registry at: name asLowercase ifAbsent: [^aNiladicBlock value ].	^namedFields size &gt;= occurrenceIndex		ifTrue: [namedFields at: occurrenceIndex]		ifFalse: [ aNiladicBlock value ]</body><body package="MIME">at: name ifAbsent: aNiladicBlock	^self at: name at: 1 ifAbsent: aNiladicBlock</body><body package="MIME">at: name ifAbsentPut: aNiladicBlock 	^self at: name ifAbsent: [self at: name put: aNiladicBlock value]</body><body package="MIME">at: name put: field	field name: name.	self 		removeKey: name;		add: field.	^field</body><body package="MIME">fields	^value</body><body package="MIME">fields: aCollection" Replace all fields with new set of fields "	self initialize; addAll: aCollection</body><body package="MIME">indexOf: field	^self fields indexOf: field</body><body package="MIME">parent: aMimeEntity	super parent: aMimeEntity.	self fieldsDo: [ :field | field parent: aMimeEntity ].</body></methods><methods><class-id>Net.MessageHeader</class-id> <category>enumerating</category><body package="MIME">fieldsDo: aMonadicBlock	self fields do: aMonadicBlock</body></methods><methods><class-id>Net.MessageHeader</class-id> <category>copying</category><body package="MIME">postCopy	| oldFields |	oldFields := value.	self initialize.	oldFields do: [ :field | self add: field copy ]</body></methods><methods><class-id>Net.MessageHeader</class-id> <category>private</category><body package="MIME">deregister: field 	"Remove field from registry"	| namedFields | 	namedFields := self registry at: field name asLowercase ifAbsent: [^self].	namedFields remove: field.	namedFields isEmpty ifTrue: [self registry removeKey: field name asLowercase]</body><body package="MIME">register: field" Register field in field registry "	field parent: self parent.	(self registry at: field name asLowercase ifAbsentPut: [ OrderedCollection new ]) add: field</body><body package="MIME">registry	^registry</body></methods><methods><class-id>Net.MessageHeader</class-id> <category>removing</category><body package="MIME">remove: field 	field notNil		ifTrue: 			[self fields remove: field.			self deregister: field]</body><body package="MIME">removeAll: collectionOfFields	collectionOfFields do: [ :field | self remove: field ]</body><body package="MIME">removeAllAt: name	self removeAll: (self allAt: name)</body><body package="MIME">removeKey: fieldName	self removeAll: (self allAt: fieldName)</body></methods><methods><class-id>Net.MessageHeader</class-id> <category>visiting</category><body package="MIME">acceptVisit: aVisitor with: argument	^aVisitor acceptMessageHeader: self with: argument</body></methods><methods><class-id>Net.MessageHeader</class-id> <category>initialization</category><body package="MIME">initialize	registry := Dictionary new: 10.	value := OrderedCollection new: 10.</body></methods><methods><class-id>Net.MessageHeader</class-id> <category>parsing</category><body package="MIME">parse: scanner</body></methods><methods><class-id>Net.MessageHeader</class-id> <category>printing</category><body package="MIME">printOn: aStream indent: level	self fields do: [ :field | 		field printOn: aStream indent: level.		aStream cr]</body></methods><methods><class-id>Net.MessageHeader</class-id> <category>composing</category><body package="MIME">writeOn: aStream 	self fields do: [:field |		field writeOn: aStream.		aStream cr]</body></methods><methods><class-id>Net.MessageHeader class</class-id> <category>instance creation</category><body package="MIME">newFor: aMimeEntity	^self new parent: aMimeEntity</body></methods><methods><class-id>Net.MessageScanner</class-id> <category>printing</category><body package="MIME">printAtom: atom on: stream	self class printAtom: atom on: stream</body><body package="MIME">printQuotedText: qtext on: stream	self class printQuotedText: qtext on: stream</body><body package="MIME">printText: qtext on: stream	self class printText: qtext on: stream</body></methods><methods><class-id>Net.MessageScanner class</class-id> <category>printing</category><body package="MIME">print: char on: aStream	aStream nextPut: char</body><body package="MIME">printQuotedText: str on: stream 	"Print word as quoted text"	stream nextPut: $"; nextPutAll: str; nextPut: $"</body><body package="MIME">printText: text on: stream	stream nextPutAll: text</body><body package="MIME">printTokenList: list on: stream	self printTokenList: list on: stream separatedBy: [ stream space ]</body><body package="MIME">printTokenList: list on: stream separatedBy: aBlock 	list do: [:assoc | self printToken: assoc on: stream]		separatedBy: aBlock</body></methods><methods><class-id>Net.RFC822Scanner</class-id> <category>tokenization</category><body package="MIME">nextToken	^self nextRFC822Token</body><body package="MIME">specials" This method is provided to encapsulate lexical differences between RFC822 on one side, and MIME, HTTP on the other side. MIME definiton of 'tspecials' is the same as the RFC 822 definition of ''specials' with the addition of the three characters &lt;/&gt;, &lt;?&gt;, and &lt;=&gt;, and the removal of &lt;.&gt;. To present uniform tokenization interface, this method is overridden in Mime scanner "	^self class specials</body></methods><methods><class-id>Net.RFC822Scanner</class-id> <category>multi-character scans</category><body package="MIME">scanAtom" atom  =  1*&lt;any CHAR except specials, SPACE and CTLs&gt; "	token := self scanTokenMask: AtomMask.	tokenType := #atom.	^token.</body><body package="MIME">scanComment	"collect comment"	| output decComment |	output := saveComments				ifTrue: [(String new: 64) writeStream]				ifFalse: [nil].	self scanCommentOn: output.	output notNil 		ifTrue: [			decComment := MimeEncodedWordCoDec decodeComment: output contents.			currentComment isNil				ifTrue: [currentComment := OrderedCollection with: decComment]				ifFalse: [currentComment add: decComment]]. 	^token</body><body package="MIME">scanDate	^self class readDateAndTimeFrom: self asStream</body><body package="MIME">scanDomainText	"dtext = &lt;any CHAR excluding &lt;[&gt;, &lt;]&gt;, &lt;\&gt; &amp; CR, &amp; including linear-white-space&gt; ; =&gt; may be folded"	token := self				scanToken: [self scanQuotedChar; matchCharacterType: DomainTextMask]				delimitedBy: '[]'				notify: (#MalformedDomainLiteral &lt;&lt; #net &gt;&gt; 'Malformed domain literal').	tokenType := #domainText.	^token</body><body package="MIME">scanEndOfLine	"Note: this will work only for RFC822 but not for HTTP. Needs more design work"	(self matchCharacterType: CRLFMask)		ifTrue: 			[self shouldFoldLine				ifTrue: [ 	self hereChar: Character space. ^self].				"Otherwise we have an end-of-line condition -- set appropriate masks"			classificationMask := (classificationMask maskClear: WhiteSpaceMask)						maskSet: EndOfLineMask]</body><body package="MIME">scanFieldName	" RFC822, p.9: field-name = 1*&lt;any CHAR excluding CTLs, SPACE and ':'&gt; "	^self scanTokenMask: HeaderNameMask</body><body package="MIME">scanPhrase	"RFC822: phrase = 1*word ; Sequence of words. At the end of scan the scanner has read the first token after phrase "	^self tokenizeWhile: [#(#quotedText #atom) includes: tokenType]</body><body package="MIME">scanQuotedChar	"Scan possible quoted character. If the current char is $\, read in next character and make it a quoted 	string character"	^(hereChar == QuotedPairChar)		ifTrue: 			[self step.			classificationMask := QuotedPairMask.			true]		ifFalse: [false]</body><body package="MIME">scanQuotedText" quoted-string = &lt;""&gt; *(qtext/quoted-pair) &lt;""&gt;; Regular qtext or quoted chars.  qtext    =  &lt;any CHAR excepting &lt;""&gt;, &lt;\&gt; &amp; CR, and including linear-white-space&gt;  ; =&gt; may be folded"	" We are positioned at the first double quote character "	token := self 				scanToken: [ self scanQuotedChar; matchCharacterType: QuotedTextMask ] 				delimitedBy: '""' 				notify: (#UnmatchedQuotedText &lt;&lt; #net &gt;&gt; 'Unmatched quoted text').	tokenType := #quotedText.	^token.</body><body package="MIME">scanText	"RFC822: text = &lt;Any CHAR, including bare CR &amp; bare LF, but not including CRLF. This is a 'catchall' category and cannot be tokenized. Text is used only to read values of unstructured fields"	^MimeEncodedWordCoDec decodeText: (self scanUntil: [ self matchCharacterType: CRLFMask ])</body><body package="MIME">scanWord	self nextToken.	(#(#quotedText #atom) includes: tokenType)			ifFalse: [self error: (#ExpectingWord &lt;&lt; #net &gt;&gt; 'Expecting word')].	^token</body><body package="MIME">skipWhiteSpace	"It is inefficient because intermediate stream is created. Perhaps refactoring scanWhile: can help"	self scanWhile: [hereChar == $(			ifTrue: 				[self stepBack; scanComment.				true]			ifFalse: [self matchCharacterType: WhiteSpaceMask]]</body></methods><methods><class-id>Net.RFC822Scanner</class-id> <category>private</category><body package="MIME">isTokenChar: aMask	^(self matchCharacterType:  aMask)			or: [self acceptNonAsciiCharacters 				and:[self matchCharacterType: AnyTextMask]]</body><body package="MIME">nextRFC822Token	| char |	self skipWhiteSpace.	char := self peek.	char isNil				"end of input"		ifTrue: [tokenType := #doIt.			^token := nil].	char == $( ifTrue: [^self scanComment; nextToken].	char == $" ifTrue: [^self scanQuotedText].	(self specials includes: char)		ifTrue: [tokenType := #special.		" Special character. Make it token value and set token type "				^token := self next.].	^self privateScanTokenMask: AtomMask</body><body package="MIME">privateScanTokenMask: aMask	| stream specials  |	(self isTokenChar: aMask)		ifFalse: [tokenType := #doIt. ^token:= self next ].	tokenType := aMask = AtomMask			ifTrue: [#atom]			ifFalse: [#token].	stream := (String new: 64) writeStream.	specials := self specials, ' '.	[self atEnd		ifTrue: 			[self hereChar: nil.			^token := stream contents].	self step.	((specials includes: hereChar) not and: [self isTokenChar: aMask]) ]		whileTrue: [stream nextPut: hereChar ].	self stepBack.	token := stream contents.	^token</body><body package="MIME">scanCommentOn: streamOrNil 	"scan comment copying on specified stream"	self step ~~ $( ifTrue: [self error: (#UnmatchedComment &lt;&lt; #net &gt;&gt; 'Unmatched comment') ].		" Should never be the case "	token := self				scanUntil: [					((self scanQuotedChar; matchCharacterType: CommentMask)						ifTrue: 							[streamOrNil notNil ifTrue: [streamOrNil nextPut: hereChar].							true]						ifFalse: [hereChar == $(								ifTrue: 									[streamOrNil notNil ifTrue: [streamOrNil space].									self stepBack; scanCommentOn: streamOrNil.									streamOrNil notNil ifTrue: [streamOrNil space].									true]								ifFalse: [false]]) not].	hereChar ~~ $) ifTrue: [ self error: (#UnmatchedComment &lt;&lt; #net &gt;&gt; 'Unmatched comment') ].	^token</body><body package="MIME">shouldFoldLine	"Answers true if next line is to be folded in, that is, if CRLF is followed by at least one white space"	self atEnd ifTrue: [ ^false ].	^((self classificationMaskFor: self peek) anyMask: WhiteSpaceMask)		ifTrue: [self sourceTrailNextPut: source next. true]		ifFalse: [false]</body><body package="MIME">step	super step.	self scanEndOfLine.	^hereChar</body><body package="MIME">writeFoldLineOn: stream	[self atEnd ifTrue: [^hereChar].	self next.	((self matchCharacterType: CRLFMask) and: [self shouldFoldLine])		ifTrue: ["Fold the line " self hereChar: Character space.].	(self matchCharacterType: CRLFMask) ifTrue: [^self hereChar ]. 		stream nextPut: self hereChar.		self peek == $(  ifTrue: [self scanComment ].			] repeat</body></methods><methods><class-id>Net.RFC822Scanner</class-id> <category>converting</category><body package="MIME">phraseAsString: phrase	| stream |	stream := (String new: 64) writeStream.	self class printPhrase: phrase on: stream. 	^stream contents.</body></methods><methods><class-id>Net.RFC822Scanner</class-id> <category>utilities</category><body package="MIME">peekForEndOfLine	((self classificationMaskFor: self peek) anyMask: CRLFMask)		ifTrue: [ source next. ^true].	^false</body><body package="MIME">readFieldName	| fname |	fname := self scanFieldName. 	super skipWhiteSpace.	^(self atEnd or: [(self peekFor: $:) not])		ifTrue: [ nil ]		ifFalse: [fname asLowercase]</body></methods><methods><class-id>Net.RFC822Scanner class</class-id> <category>printing</category><body package="MIME">defaultTokenType	^#word</body><body package="MIME">printComment: comment on: stream 	comment notNil ifTrue: [		stream nextPut: $(.		comment			do: 				[:char | 				(self isCommentChar: char)					ifFalse: [stream nextPut: $\].				stream nextPut: char].		stream nextPut: $).	]</body><body package="MIME">printDomain: domainx on: stream 	"Domainx is an array of domain segments"	domainx notNil ifTrue: [domainx do: [:word | self printWord: word on: stream]			separatedBy: [stream nextPut: $.]]</body><body package="MIME">printPhrase: phrase on: stream	phrase do: [ :word | stream nextPutAll: word] separatedBy: [ stream space ]</body><body package="MIME">printWord: str on: stream 	"Print word as either atom or quoted text"	(self shouldBeQuoted: str)		ifTrue: [stream nextPut: $"; nextPutAll: str; nextPut: $"]		ifFalse: [stream nextPutAll: str]</body></methods><methods><class-id>Net.RFC822Scanner class</class-id> <category>class initialization</category><body package="MIME">initClassificationTable	super initClassificationTable.	self initClassificationTableWith: HeaderNameMask when:		[:c | c &gt; Character space and: [c ~~ $:]].	self initClassificationTableWith: TextMask when:		[:c | c ~~ Character cr ].	self initClassificationTableWith: AtomMask when:		[:c | c &gt; Character space and: [ (self specials includes: c) not ] ].	self initClassificationTableWith: TokenMask when:		[:c | c &gt; Character space and: [ (self tspecials includes: c) not ] ].	self initClassificationTableWith: QuotedTextMask when:		[:c | c ~~ $" and: [ c ~~ $\ and: [ c ~~ Character cr ]]].	self initClassificationTableWith: DomainTextMask when:		[:c | ('[]\' includes: c) not and: [ c ~~ Character cr ]].	self initClassificationTableWith: CommentMask when:		[:c | c ~~ $( and: [ c ~~ $) and: [ c ~~ $\ and: [ c ~~ Character cr ]]]].</body><body package="MIME">initialize	" RFC822Scanner initialize "	self 		initializeConstants; 		initClassificationTable;		initializeTimeZones</body><body package="MIME">initializeConstants	AtomMask := 256.	CommentMask := 512.	DomainTextMask := 1024.	HeaderNameMask := 2048.	QuotedTextMask := 4096.	TextMask := 8192.	TokenMask := 16384.	QuotedPairMask := (QuotedTextMask bitOr: CommentMask) bitOr: DomainTextMask.	QuotedPairChar := $\.	HeaderNameDelimiterChar := $:.</body><body package="MIME">initializeTimeZones	"RFC822Scanner initializeTimeZones."	"Install TimeZone constants.	The dictionary value returns seconds"	SimpleTimeZones := Dictionary new.	"Universal Time"	SimpleTimeZones at: 'UT' put: 0.	SimpleTimeZones at: 'GMT' put: 0.	"For North America."	SimpleTimeZones at: 'EST' put: -5 * 3600.	SimpleTimeZones at: 'EDT' put: -4 * 3600.	SimpleTimeZones at: 'CST' put: -6 * 3600.	SimpleTimeZones at: 'CDT' put: -5 * 3600.	SimpleTimeZones at: 'MST' put: -7 * 3600.	SimpleTimeZones at: 'MDT' put: -6 * 3600.	SimpleTimeZones at: 'PST' put: -8 * 3600.	SimpleTimeZones at: 'PDT' put: -7 * 3600.	"For Europe."	SimpleTimeZones at: 'BST' put: 0.	SimpleTimeZones at: 'WET' put: 0.	SimpleTimeZones at: 'MET' put: 1 * 3600.	SimpleTimeZones at: 'EET' put: 2 * 3600.	"For Japan."	SimpleTimeZones at: 'JST' put: 9 * 3600.</body></methods><methods><class-id>Net.RFC822Scanner class</class-id> <category>character classification</category><body package="MIME">specials	" Note that definition of this set varies from standard to standard, so this method needs to be overridden for specialized parsers " 	^'()&lt;&gt;@,;:\".[]'</body><body package="MIME">tspecials	" tspecials in MIME and HTTP. It is derived from RCC822 specials with addition of &lt;/&gt;, &lt;?&gt;, &lt;=&gt; and removal; of &lt;.&gt; " 	^'()&lt;&gt;@,;:\"/[]?='</body></methods><methods><class-id>Net.RFC822Scanner class</class-id> <category>testing</category><body package="MIME">isAtomChar: char	^((self classificationMaskFor: char)  bitAnd: AtomMask) ~= 0</body><body package="MIME">isCommentChar: char	^[ ((self classificationMaskFor: char) bitAnd: CommentMask) ~= 0	] on: NonASCIICharacter	do: [ :ex | true ]</body><body package="MIME">shouldBeQuoted: string 		^[(string detect: [:char | (self isAtomChar: char) not] ifNone: [nil]) 		notNil] 			on: NonASCIICharacter			do: [:ex | true ]</body></methods><methods><class-id>Net.RFC822Scanner class</class-id> <category>from Network Clients</category><body package="MIME">adjustTime: aTimestamp timezone: timezone	| timezoneSeconds universalTimestamp universalSeconds |	timezoneSeconds := ('#####' match: timezone)			ifTrue: [ | sec |				sec := ((timezone copyFrom: 2 to: 3) asNumber * 60 + (timezone copyFrom: 4 to: 5) asNumber) * 60.				timezone first = $- ifTrue: [sec negated] ifFalse: [sec]]			ifFalse: [SimpleTimeZones at: timezone ifAbsent: [nil]].	timezoneSeconds isNil ifTrue: [^aTimestamp].	universalTimestamp := 		timezoneSeconds isZero			ifTrue: [ aTimestamp ]			ifFalse: [				universalSeconds := TimeZone default timestampToSeconds: aTimestamp.				universalSeconds := universalSeconds - timezoneSeconds.				TimeZone default secondsToTimestamp: universalSeconds ].	^TimeZone default universalToLocal: universalTimestamp</body><body package="MIME">correctDateForY2K: date" Arbitrarily decide that if year is &gt;2050, subtract one century ""RFC 2822Where a two or three digit year occurs in a date, the year is to be   interpreted as follows: If a two digit year is encountered whose   value is between 00 and 49, the year is interpreted by adding 2000,   ending up with a value between 2000 and 2049.  If a two digit year is   encountered with a value between 50 and 99, or any three digit year   is encountered, the year is interpreted by adding 1900. "	date year &gt; 2050 		ifTrue: [date day: date day year: date year - 100].	^date</body><body package="MIME">dateStringFrom: aTimestamp	"Return Date dateAndTimeNow in the Unix mail format"	" self dateAndTimeFrom: (Array with: Date today with: Time now) "	| stream temp indx d seconds hours minutes date |	stream := WriteStream on: (String new: 40).	date := aTimestamp asDate.	indx := date weekdayIndex.	d := #(#Mon #Tue #Wed #Thu #Fri #Sat #Sun) at: indx.	stream nextPutAll: d.	stream nextPutAll: ', '.	date printOn: stream format: #(1 2 3 $  2 1).	stream nextPutAll: ((temp := aTimestamp hour) &lt; 10 				ifTrue: [' 0']				ifFalse: [' ']).	temp printOn: stream.	stream nextPutAll: ((temp := aTimestamp minute) &lt; 10 				ifTrue: [':0']				ifFalse: [':']).	temp printOn: stream.	stream nextPutAll: ((temp := aTimestamp second) &lt; 10 				ifTrue: [':0']				ifFalse: [':']).	temp printOn: stream.	seconds := TimeZone default secondsFromUniversalAtLocal: aTimestamp .	seconds negative 		ifTrue: [stream nextPutAll: ' -']		ifFalse: [stream nextPutAll: ' +'].	hours := seconds abs // 3600.	hours abs &lt; 10 ifTrue: [stream nextPut: $0].	stream print: hours abs.	minutes := seconds abs \\ 3600 // 60.	minutes abs &lt; 10 ifTrue: [stream nextPut: $0].	stream print: minutes.  	^stream contents</body><body package="MIME">readDateAndTimeFrom: aStream" rfc1123-date = wkday '','' SP date1 SP time SP ''GMT''  rfc850-date  = weekday '','' SP date2 SP time SP ''GMT''  asctime-date = wkday SP date3 SP time SP 4DIGIT	  &lt;-- last 4 digits represent a yeardate-time	=  [ day ',' ] date time	day			=  'Mon'  / 'Tue' /  'Wed'  / 'Thu'				/  'Fri'  / 'Sat' /  'Sun'"	"RFC822Scanner readDateAndTimeFrom: '6 Dec 88 10:16:08 +0900 (Tuesday)' readStream."	| date time write char tail |	"While reviewing AR#44558 we decided if the date field is empty to return nil instead of old implementation ^self currentGMTDateAndTime to be able determine if field is valid or not"	aStream atEnd ifTrue: [^nil].	date := self readDateFrom: aStream.	"If we have ANSI C's asctime() format  the date parser has already consumed the first time token. Step back"	(aStream peek == $:) ifTrue: [aStream skip: -2 ].	"time	= hour zone 	hour	= 2DIGIT ':' 2DIGIT [':' 2DIGIT] "	aStream skipSeparators.	time := Time readFrom: aStream.	"Last characters could be a timezone or year "	aStream skipSeparators.	write := WriteStream on: (String new: 8).	[aStream atEnd		or: [char := aStream next.			char isSeparator]]		whileFalse: [write nextPut: char].	tail := write contents asUppercase.	"Check if we got not a time zone but a year from  ANSI C's asctime() format "	(('####' match: tail)  and: [ tail first ~= $+ or: [tail first ~= $-]])		ifTrue: [ date day: date day year: tail asNumber.				tail := '' ].	^tail isEmpty		ifTrue: [Timestamp fromDate: date andTime: time]		ifFalse: 	[self 					adjustTime: (Timestamp fromDate: date andTime: time) 					timezone: tail].</body><body package="MIME">readDateFrom: aStream	"date	=  1*2DIGIT month 2DIGIT	month	=  'Jan'  /  'Feb' /  'Mar'  /  'Apr'			/  'May'  /  'Jun' /  'Jul'  /  'Aug'			/  'Sep'  /  'Oct' /  'Nov'  /  'Dec'"	"RFC822Scanner readDateFrom: '01 Jan 95' readStream."	"RFC822Scanner readDateFrom: '1 Jan 50' readStream."	"RFC822Scanner readDateFrom: '23 Jan 02' readStream."	"RFC822Scanner readDateFrom: '23-Jan-95' readStream."	"RFC822Scanner readDateFrom: 'Jan 23 2095' readStream."	"RFC822Scanner readDateFrom: 'Jan 23 1995' readStream."	| reader position date yearChunk scanner char |	[char := aStream peek.	char isLetter or: [char isDigit]]		whileFalse: [aStream next].	aStream atEnd ifTrue: [^nil].	reader := (TimestampPrintPolicy newFor: #us) reader.	position := aStream position.	scanner := RFC822Scanner on: aStream.	(#('mon' 'tue' 'wed' 'thu' 'thr' 'fri' 'sat' 'sun' 'monday' 'tuesday' 'wednesday' 'thursday' 'friday' 'saturday' 'sunday') 		includes: scanner nextToken asLowercase)			ifFalse: [ aStream position: position ].	date := reader readDateFrom: aStream.	 aStream skip: -4.	 yearChunk := aStream next: 4.	 (('####' match: yearChunk)		 and: [ (yearChunk copyFrom: 1 to: 4) asNumber = date year ])			  ifFalse: [ self correctDateForY2K: date ].	^date</body></methods><methods><class-id>Net.RFC822Scanner class</class-id> <category>private</category><body package="MIME">currentGMTDateAndTime"self  currentGMTDateAndTime"	^TimeZone null		convertGMT: Time secondClock		do:			[:date :seconds |			Array with: date with: (Time fromSeconds: seconds)]</body><body package="MIME">dateAndTimeFrom: aString	"RFC822Scanner dateAndTimeFrom: '6 Dec 88 10:16:08 +0900 (Tuesday)'."	"RFC822Scanner dateAndTimeFrom: '12 Dec 88 10:16:08 +0900 (Tuesday)'."	"RFC822Scanner dateAndTimeFrom: 'Fri, 31 Mar 89 09:13:20 +0900'."	"RFC822Scanner dateAndTimeFrom: 'Tue, 18 Apr 89 23:29:47 +0900'."	"RFC822Scanner dateAndTimeFrom: 'Tue, 23 May 89 13:52:12 JST'."	"RFC822Scanner dateAndTimeFrom: 'Thu, 1 Dec 88 17:13:27 jst'."	"RFC822Scanner dateAndTimeFrom: 'Sat, 15 Jul 95 14:36:22 0900'."	"RFC822Scanner dateAndTimeFrom: '2-Nov-86 10:43:42 PST'."	"RFC822Scanner dateAndTimeFrom: 'Friday, 21-Jul-95 04:04:55 GMT'."	"RFC822Scanner dateAndTimeFrom: 'Jul 10 11:06:40 1995'."	"RFC822Scanner dateAndTimeFrom: 'Jul 10 11:06:40 JST 1995'."	"RFC822Scanner dateAndTimeFrom: 'Mon Jul 10 11:06:40 1995'."	"RFC822Scanner dateAndTimeFrom: 'Mon Jul 10 11:06:40 JST 1995'."	"RFC822Scanner dateAndTimeFrom: '(6 December 1988 10:16:08 am )'."	"RFC822Scanner dateAndTimeFrom: '(12 December 1988 10:16:08 am )'."	"RFC822Scanner dateAndTimeFrom: ''."	| rfcString |	aString size &lt;= 10	"may be illegal format"		ifTrue: [^self currentGMTDateAndTime].	rfcString := self normalizeDateAndTimeString: aString.	^self readDateAndTimeFrom: rfcString readStream</body><body package="MIME">normalizeDateAndTimeString: aString	"RFC822 formats"	"RFC822Scanner normalizeDateAndTimeString: '6 Dec 88 10:16:08 +0900 (Tuesday)'."	"RFC822Scanner normalizeDateAndTimeString: 'Tue, 18 Apr 89 23:29:47 +0900'."	"RFC822Scanner normalizeDateAndTimeString: 'Tue, 18 Apr 89 23:29:47 0900'."	"RFC822Scanner normalizeDateAndTimeString: 'Tue, 23 May 89 13:52:12 JST'."	"RFC822Scanner normalizeDateAndTimeString: '2-Nov-86 10:43:42 PST'."	"Other formats"	"RFC822Scanner normalizeDateAndTimeString: 'Jul 10 11:06:40 1995'."	"RFC822Scanner normalizeDateAndTimeString: 'Jul 10 11:06:40 JST 1995'."	"RFC822Scanner normalizeDateAndTimeString: 'Mon Jul 10 11:06:40 1995'."	"RFC822Scanner normalizeDateAndTimeString: 'Mon Jul 10 11:06:40 JST 1995'."	| head tail read str1 str2 write |	aString size &lt; 6 ifTrue: [^aString].	head := aString copyFrom: 1 to: aString size - 5.	(head indexOf: $,) &gt; 0 ifTrue: [^aString].	tail := aString copyFrom: aString size - 4 to: aString size.	read := tail readStream.	(read next = Character space and:	[read next isDigit and:	[read next isDigit and:	[read next isDigit and:	[read next isDigit]]]])		ifFalse: [^aString].	read := head readStream.	str1 := read through: Character space.	str2 := read through: Character space.	(str1 isEmpty or: [str2 isEmpty]) ifTrue: [^aString].	str2 first isDigit		ifFalse:			[str1 := str2.			str2 := read through: Character space.			(str2 isEmpty or: [str2 first isDigit not]) ifTrue: [^aString]].	read atEnd ifTrue: [^aString].	write := WriteStream on: (String new: 32).	write nextPutAll: str2;		nextPutAll: str1;		nextPutAll: (tail copyFrom: 4 to: 5);		space;		nextPutAll: read.	^write contents</body></methods><methods><class-id>Net.BlockBody</class-id> <category>visiting</category><body package="MIME">acceptVisit: aVisitor with: argument	^aVisitor acceptSimpleBody: self with: argument</body></methods><methods><class-id>Net.BlockBody</class-id> <category>composing</category><body package="MIME">writeOn: aStream	source value: aStream</body></methods><methods><class-id>Net.BlockBody</class-id> <category>testing</category><body package="MIME">notEmpty	^source notNil</body></methods><methods><class-id>Net.BlockBody</class-id> <category>private</category><body package="MIME">getValue	^source</body></methods><methods><class-id>Net.BlockBody</class-id> <category>accessing</category><body package="MIME">sourceForDigest	^'[..block body..]' readStream</body></methods><methods><class-id>Net.MimeEntity</class-id> <category>accessing</category><body package="MIME">body	^value isNil		ifTrue: [ value := self newBody ]		ifFalse: [ value ]</body><body package="MIME">body: aMessageBody	value := aMessageBody.	aMessageBody parent: self.</body><body package="MIME">boundary	^self contentTypeField boundary</body><body package="MIME">boundary: aString	^self contentTypeField boundary: aString</body><body package="MIME">charset	^self charsetIfNone: 			[ self parent ~~ nil				ifTrue: [	self parent defaultCharset]				ifFalse: [ self defaultCharset] ]</body><body package="MIME">charset: aName	self isSimple		ifTrue: [ (self getFieldAt: 'content-type') charset: aName ]</body><body package="MIME">charsetIfNone: aBlock	^(self fieldAt: 'content-type' ifAbsent: [ ^aBlock value ]) charsetIfNone: aBlock</body><body package="MIME">contentEncoding	"Http header. The message can be sent from HttpBuildHandler while building multipart message"	^nil</body><body package="MIME">contentId	^self fieldValueAt: 'content-id'</body><body package="MIME">contentId: aString	^self fieldValueAt: 'content-id' put: aString</body><body package="MIME">contentLength	^self fieldValueAt: 'content-length'</body><body package="MIME">contentLength: anInteger	^self fieldValueAt: 'content-length' put: anInteger</body><body package="MIME">contentTransferEncoding	^self fieldValueAt: 'content-transfer-encoding'</body><body package="MIME">contentTransferEncoding: encodingNameString	^self fieldValueAt: 'content-transfer-encoding'  put: encodingNameString</body><body package="MIME">contentType	^(self fieldAt: 'content-type' ifAbsent: [ self defaultContentTypeField  ]) contentType</body><body package="MIME">contentType: aString	^('text/plain' match: aString)		ifTrue: [self  contentType: aString charset: self defaultCharset ]		ifFalse: [self fieldAt: 'content-type' put: (ContentTypeField contentType: aString)]</body><body package="MIME">contentType: aString charset: cString	self fieldAt: 'content-type' put: (ContentTypeField contentType: aString charset: cString)</body><body package="MIME">contentTypeEncoding	" Answer symbolic name of the character encoding for the decoded body of this entity "	^self contentTypeEncodingType</body><body package="MIME">contentTypeEncodingType" Answer symbol representing character encoding that we use to decode the body of this entity. This encoding is entirely determined by the current content type field as follows:	If content type is text or multipart, then value of charset parameter is used		content-type: text/plain; charset = iso-8859-1	If no charset is present, default charset encoding is used	If content type is binary, binary encoding is used"	^self isBinaryContentType		ifTrue: [ #binary ]		ifFalse: [self charset notNil					ifTrue: [self charset]					ifFalse: [#default]]</body><body package="MIME">contentTypeField	^(self fieldAt: 'content-type' ifAbsent: [ self defaultContentTypeField ])</body><body package="MIME">contentTypeSpecies" Answer ByteArray if my Mime type is binary, String otherwise. See also contentsSpecies "	^self isBinaryContentType		ifTrue: [ ByteArray ]		ifFalse: [ String ]</body><body package="MIME">contentsSpecies" Answer ByteArray if I contain bytes, String if I containg character info. Notethat if content transfer encoding is present, it is always String. See also contentTypeSpecies "	^self isBinary		ifTrue: [ ByteArray ]		ifFalse: [ String ]</body><body package="MIME">encoding	" Answer symbolic name of the character encoding for the body of this entity "	^self encodingType ~~ nil		ifTrue: [ self encodingType ]		ifFalse: [ MimeTypeDescriptor encodingForCharset: #default ]</body><body package="MIME">encodingType" Answer symbol representing character encoding that we use to read the body of this entity. This encoding depends on the current content type and content transfer encoding.If transfer encoding is not present, then encoding is determined by content-typefield as follows:	If content type is text or multipart, then value of charset parameter is used		content-type: text/plain; charset = iso-8859-1	If no charset is present, default charset encoding is used	If content type is binary, binary encoding is usedIf transfer encoding is present, default charset encoding is used"	^self isBinary		ifTrue: [ #binary ]		ifFalse: [self charsetIfNone: [#default]]</body><body package="MIME">fields	^self header fields</body><body package="MIME">fields: aValue	self header fields: aValue</body><body package="MIME">headerCharset	^headerCharset</body><body package="MIME">headerCharset: aString	headerCharset := aString</body><body package="MIME">majorType	^self contentTypeField subtype</body><body package="MIME">mimeType	^MimeTypeDescriptor guessFromContentType: self contentType</body><body package="MIME">mimeVersion	^self fieldValueAt: 'mime-version'</body><body package="MIME">mimeVersion: aString	^self fieldValueAt: 'mime-version' put: aString</body><body package="MIME">readingOptions	^readingOptions  ifNil: [ readingOptions := self class defaultReadingOptionsType new]</body><body package="MIME">readingOptions: aMimeReadingOptions	readingOptions := aMimeReadingOptions</body><body package="MIME">setContentFromFile: fileNameOrString withEncoding: aSymbol	| stream filename encoding |	filename := fileNameOrString asFilename.	self setContentTypeForFilename:  filename.	[self isBinary		ifTrue: 			[stream := (filename withEncoding: #binary) readStream.			self body: (SimpleBody new byteSource: stream)]		ifFalse: 			[encoding := aSymbol ifNil: [SimpleBody defaultCharsetEncoder].			stream := (filename withEncoding: encoding) readStream.			self charset: stream encoding asString asLowercase.			self body: (SimpleBody new source: stream)]]			ensure: [stream notNil ifTrue: [stream close]].	^self</body><body package="MIME">subtype	^self contentTypeField subtype</body><body package="MIME">type	^self contentTypeField type</body><body package="MIME">type: aString	^self contentTypeField type: aString</body><body package="MIME">writingOptions	^writingOptions ifNil: [writingOptions := self class defaultWritingOptionsType new]</body><body package="MIME">writingOptions: aMimeWritingOptions	writingOptions := aMimeWritingOptions</body></methods><methods><class-id>Net.MimeEntity</class-id> <category>content-disposition</category><body package="MIME">contentDisposition	^self fieldAt: 'content-disposition' ifAbsent: [nil]</body><body package="MIME">contentDisposition: aString" aString should be 'inline' or 'attachment' "	^(self getFieldAt: 'content-disposition') disposition: aString</body><body package="MIME">contentDispositionSize	^(self fieldAt: 'content-disposition' ifAbsent: [^nil]) size</body><body package="MIME">contentDispositionSize: anInteger	^(self getFieldAt: 'content-disposition') size: anInteger</body><body package="MIME">fileName	| headerField f |	headerField := self 					fieldAt: 'content-disposition' 					ifAbsent: [self fieldAt: 'content-type' ifAbsent:[^nil]].	^((f := headerField fileName) isNil or: [ f isEmpty])		ifTrue: [ nil ]		ifFalse: [ f ]</body><body package="MIME">fileName: aFilename	"Setting of the content-type has been moved entirely to a separate method #setContentTypeForFilename:,	and it is now called from #setContentFromFile:withEncoding:"	self setContentDispositionForFilename: aFilename</body><body package="MIME">setContentDispositionForFilename: aFilenameOrString	(self getFieldAt: 'content-disposition') fileName: aFilenameOrString asFilename tail</body></methods><methods><class-id>Net.MimeEntity</class-id> <category>testing</category><body package="MIME">canBeDecoded	^self contentTransferEncoding isNil</body><body package="MIME">hasBoundary	^self boundary notNil</body><body package="MIME">hasContentTransferEncoding	^self contentTransferEncoding notNil</body><body package="MIME">isApplication	^ self type match: 'application'</body><body package="MIME">isAttachment	| f |	^( f := self contentDisposition) notNil and: [ f isAttachment ]</body><body package="MIME">isBase64Type	| ce |	^(ce := self contentTransferEncoding) notNil		ifTrue: [ ce match: 'base64']		ifFalse: [ false ]</body><body package="MIME">isBinary" Answers true if my contents are represented as text or binary. If contenttransfer encoding is present, my contents are text even though this textencodes binary information "	^self isBinaryContentType and: [self hasContentTransferEncoding not]</body><body package="MIME">isBinaryContentType	^self mimeType isBinary</body><body package="MIME">isChunked	^false</body><body package="MIME">isContentEncodingGZip	| ce |	^((ce := self contentEncoding) notNil and: ['gzip' match: ce ])</body><body package="MIME">isFileAttachment	^self fileName notNil</body><body package="MIME">isFormData	| f |	^( f := self contentDisposition) notNil and: [ f isFormData ]</body><body package="MIME">isHtmlText	^ self isTextContentType and: [self subtype = 'html' ]</body><body package="MIME">isHttpEntity	^false</body><body package="MIME">isInline	| f |	^(f := self contentDisposition) notNil and: [ f  isInline ]</body><body package="MIME">isMimeEntity	^true</body><body package="MIME">isMultipart	^self contentTypeField isMultipart</body><body package="MIME">isMultipartAlternative	^self contentType match: 'multipart/alternative'</body><body package="MIME">isMultipartMixed	^self contentType match: 'multipart/mixed'</body><body package="MIME">isPlainText	^ self isTextContentType and: [ self subtype = 'plain' ]</body><body package="MIME">isPrintedQuotableType	| ce |	^( ce := self contentTransferEncoding) notNil		ifTrue: [ ce match: 'quoted-printable' ]		ifFalse: [ false ]</body><body package="MIME">isSimple	^self isMultipart not</body><body package="MIME">isText" Answers true is message body contains binary data. This method willalways answer true in the presence of content transfer encoding. See alsoisTextContentType "	^ self isBinary not</body><body package="MIME">isTextContentType" Answers true is message content type corresponds to binary data. See alsoisText "	^ self mimeType isText</body><body package="MIME">needsBoundary	^self isMultipart and: [self boundary isNil]</body><body package="MIME">needsContentTransferEncoding	^self hasContentTransferEncoding not and: [self body needsContentTransferEncoding]</body></methods><methods><class-id>Net.MimeEntity</class-id> <category>mutating</category><body package="MIME">fileName: fileNameOrString withEncoding: aSymbol	self fileName: fileNameOrString.	^self setContentFromFile: fileNameOrString withEncoding: aSymbol</body><body package="MIME">replaceFrom: replacementPart" Replace your guts from another entity. Copy all the fields into yourselfreplacing your own fields if same name. Replace your own body withthe replacement entity's body "	" Merge fields from the replacement part into the message "	replacementPart fields do: [ :field | self fieldAt: field name put: field ].	self body: replacementPart body</body><body package="MIME">replacePart: originalPart with: replacementPart	| index |	index := self parts indexOf: originalPart.	index = 0 ifTrue: [ ^self error: (#OriginalPartNotFound &lt;&lt; #net &gt;&gt; 'Original part not found') ].	self partAt: index put: replacementPart</body></methods><methods><class-id>Net.MimeEntity</class-id> <category>transfer encodings</category><body package="MIME">addContentTransferEncoding: encodingNameString" Transfer-encode message. encodingNameString is one of: 'base64', 'quoted-printable', ... "	self isSimple ifFalse: [^self ].	self contentTransferEncoding: encodingNameString.	self newWriter encodeBodySource: self body as: encodingNameString.</body><body package="MIME">removeContentTransferEncoding	"Transfer-encode message. encodingNameString is one of: 'base64', 'quoted-printable', ..."	self hasContentTransferEncoding		ifTrue: [self body removeContentTransferEncoding]</body><body package="MIME">transferFieldOrder" Answer fields that should appear in specific order during transfer "	^OrderedCollection new</body></methods><methods><class-id>Net.MimeEntity</class-id> <category>defaults</category><body package="MIME">defaultBot	^self defaultBotClass new</body><body package="MIME">defaultBotClass	^MimeEntityBot</body><body package="MIME">defaultBuilderType	^self class builderClass</body><body package="MIME">defaultCharset	"Find default charset from MimeTypeDescriptor"	(self fieldAt: 'content-type' ifAbsent: [ nil ])		ifNotNil: [ :field |			(MimeTypeDescriptor guessFromContentType: field contentType) ifNotNil: [ :type |				(type propertyAt: #encoding ) ifNotNil: [ :encoding | ^encoding ]]].	^self class defaultCharset</body><body package="MIME">defaultContentDispositionField	^ContentDispositionField default</body><body package="MIME">defaultContentType" Answer default content type string. Use Mime rules, subclasses may override "	^self parent notNil		ifTrue: [ self parent defaultContentTypeForParts ]		ifFalse: [ MimeTypeDescriptor defaultContentTypeString ]</body><body package="MIME">defaultContentTypeField" Answer default content-type field "	^ContentTypeField contentType: self defaultContentType charset: self defaultCharset</body><body package="MIME">defaultContentTypeForParts" Answer default content-type field for body parts in multipart message. This method uses Mime rules. It can be overridden, i.e. for HTTP. Mime specifies that the default content-type is text/plain; charset = 'us-ascii' except in multipart/digest entities where the default content-type is message/rfc822 "	^self contentType ~= MimeTypeDescriptor contentTypeMultipartDigest		ifTrue: [ MimeTypeDescriptor defaultContentTypeString ]		ifFalse: [ MimeTypeDescriptor contentTypeMessageRfc822 ]</body><body package="MIME">defaultPrinterType	^self class printerClass</body><body package="MIME">defaultTransferEncodingName" Answer default transfer encoding for this entity. Somewhat arbitrarily we use quoted-printablefor text entities (which assumes we have largely ASCII-based text, saving space), and base64for everything else (because it is most likely binary data, so base64 is more appropriate "	^self isTextContentType		ifTrue: [ 'quoted-printable' ]		ifFalse: [ 'base64' ]</body><body package="MIME">defaultWriterType	^self class writerClass</body></methods><methods><class-id>Net.MimeEntity</class-id> <category>visiting</category><body package="MIME">acceptVisit: aVisitor with: argument	^aVisitor acceptMimeEntity: self with: argument</body></methods><methods><class-id>Net.MimeEntity</class-id> <category>accessing fields and body parts</category><body package="MIME">fieldValueAt: fieldName ifAbsent: aBlock	^(self fieldAt: fieldName ifAbsent: [ ^aBlock value ]) value</body><body package="MIME">getFieldAt: aString" Make sure we have either field or its stub so we can put real value in it. Default implementationof #default in HeaderField just creates a new instance of the field. Some subclasses overridethis method to provide more specific stub creation "	^self header 		at: aString 		ifAbsentPut: [(HeaderField fieldClassForName: aString) default name: aString].</body></methods><methods><class-id>Net.MimeEntity</class-id> <category>accessing fields</category><body package="MIME">addField: field	" This method will check if the field exists already; if yes, if it can be merged into the existing field and, if yes, merge it. Otherwise, add as a new field "	self header addField: field.</body><body package="MIME">arrangeFieldsInOrder: anArrayOfFieldNames	self header arrangeFieldsInOrder: anArrayOfFieldNames</body><body package="MIME">fieldAt: aString	^self header at: aString</body><body package="MIME">fieldAt: aString ifAbsent: aNiladicBlock	^self header at: aString ifAbsent: aNiladicBlock</body><body package="MIME">fieldAt: aString ifAbsentPut: aNiladicBlock 	^self header at: aString ifAbsentPut: aNiladicBlock</body><body package="MIME">fieldAt: aString put: field	^self header at: aString put: field</body><body package="MIME">fieldValueAt: fieldName" Answer value of specified field or nil "	^self fieldValueAt: fieldName ifAbsent: [ nil ]</body><body package="MIME">fieldValueAt: fieldName put: aValue" Ensures at least field's placeholder exists and sets field's value "	^(self getFieldAt: fieldName ) value: aValue</body><body package="MIME">fieldValuesAt: aString" Answer all fields with specified names in their order of appearance "	^(self fieldsAt: aString)		inject: OrderedCollection new into: [ :list :field | list addAll: field values. list ]</body><body package="MIME">fieldsAt: aString" Answer all fields with specified names in their order of appearance "	^self header allAt: aString</body><body package="MIME">getValueFor: fieldName	^self getValueFor: fieldName ifAbsent: [ nil ]</body><body package="MIME">getValueFor: fieldName ifAbsent: aBlock" For compatibility only "	^self fieldValueAt: fieldName ifAbsent: [ ^aBlock value ]</body><body package="MIME">header	^header isNil		ifTrue: [ header := self newHeader ]		ifFalse: [ header ]</body><body package="MIME">header: aMessageHeader	header := aMessageHeader.	header parent: self</body><body package="MIME">indexOfField: aField	^self header indexOf: aField</body><body package="MIME">indexOfFieldNamed: aFieldName	^self header indexOf: (self fieldAt: aFieldName ifAbsent: [^0])</body><body package="MIME">newHeader	^MessageHeader newFor: self</body><body package="MIME">removeField: aHeaderField" Remove header field "	^self header remove: aHeaderField</body><body package="MIME">removeFieldAt: fieldName" Remove field with specified name "	^self header removeKey: fieldName</body><body package="MIME">setContentTypeForFilename: aFilenameOrString	"Sets media-type  = type '/' subtype *( ';' parameter ) for Content-Type  field "	self contentType: (self class mimeTypeForFile: aFilenameOrString asFilename).</body></methods><methods><class-id>Net.MimeEntity</class-id> <category>accessing body parts</category><body package="MIME">/ aNumber	^self partAt: aNumber</body><body package="MIME">addPart: part	part parent: self.	self body addPart: part.</body><body package="MIME">contents	^self body value</body><body package="MIME">contents: anObject	^anObject replaceContentsOfMimeEntity: self</body><body package="MIME">contentsStream	^self body byteSource notNil 		ifTrue:  [self decodedByteContentsStream]		ifFalse: [ self body valueAsStream ]</body><body package="MIME">decodedContents	^self body decodedValue</body><body package="MIME">decodedContentsWith: aSymbol	^self body decodedValueWith: aSymbol</body><body package="MIME">indexOfPart: aPart	^self parts indexOf: aPart</body><body package="MIME">newBody	^MimeMessageBody newBodyFor: self</body><body package="MIME">partAt: index	^self parts at: index</body><body package="MIME">partAt: index put: aPart	self parts at: index put: aPart</body><body package="MIME">parts	^ self body parts</body><body package="MIME">removePart: aMimeEntity	^self body removePart: aMimeEntity</body><body package="MIME">removePartAt: index	^self body removePartAt: index</body></methods><methods><class-id>Net.MimeEntity</class-id> <category>private</category><body package="MIME">bot	^self defaultBot</body><body package="MIME">decodedByteContentsStream	^self body getValueStreamFromByteSource</body><body package="MIME">ensureContentTypeForBinaryContent	self fieldAt: 'content-type' ifAbsent: [		self contentType: MimeTypeDescriptor contentTypeApplicationOctetStream ].</body><body package="MIME">ensureContentTypeForTextContent: encoding	self fieldAt: 'content-type' ifAbsent: [		self contentType: self class defaultTextType			charset: (encoding ifNil: [ self class defaultTextCharset ]) ].</body><body package="MIME">replaceContentsWithBlock: aBlockClosure 	"We expect that most of the time, people will want to generate text content (bits of HTML and such).	Moreover the block receives a stream in text mode by default, so the user would have to take explicit action to switch to binary.	Therefore we'll default to text/plain; utf8 for convenience if content-type is not specified yet"	self fieldAt: 'content-type' ifAbsent: [		self contentType: self class defaultTextType			charset: self class defaultTextCharset ].	self body: (BlockBody new source: aBlockClosure; yourself)</body><body package="MIME">replaceContentsWithByteArray: aByteArray		self ensureContentTypeForBinaryContent.	self body: (SimpleBody new byteSource: aByteArray readStream; yourself)</body><body package="MIME">replaceContentsWithFile: aFilename		self fileName: aFilename withEncoding: nil</body><body package="MIME">replaceContentsWithSequence: aSequence	( 'multipart*' match: self contentType )		ifFalse: [self  fieldAt: 'content-type' put: (ContentTypeField contentType: 'multipart/mixed' )].		value := nil.	^aSequence do: [ :part | self addPart: (MimeEntity new contents: part; yourself) ]</body><body package="MIME">replaceContentsWithStream: aReadStream	self fieldAt: 'content-type' ifAbsent: [		[	self fileName: aReadStream fileName.			self setContentTypeForFilename:  aReadStream fileName		] on: Error do: [ :ex |			aReadStream isByteStream				ifTrue: [ self ensureContentTypeForBinaryContent. ]				ifFalse: [ self ensureContentTypeForTextContent: (					(aReadStream isKindOf: EncodedStream)						ifTrue: [ aReadStream encoding ]						ifFalse: [ nil ]) ] ] ].	self body: (		aReadStream isByteStream			ifTrue: [ SimpleBody new byteSource: aReadStream ]			ifFalse: [ SimpleBody new source: aReadStream ] )</body><body package="MIME">replaceContentsWithString: aString	self ensureContentTypeForTextContent: nil.			self body: (SimpleBody new source: aString readStream; yourself)</body><body package="MIME">writeContentsOn: anEncodedStream	"Once we will deprecate this utility self deprecated:  #()."	self isMultipart ifTrue: [		^self error: #UtilityOnlyForSimpleMessages &lt;&lt; #net &gt;&gt; 'This utility only works for simple messages!' ].	^self newWriter writeBodyContents: self body on: anEncodedStream</body></methods><methods><class-id>Net.MimeEntity</class-id> <category>parsing</category><body package="MIME">newBuilder	^self readingOptions newBuilder</body><body package="MIME">parse	^self newBuilder read: self  from: self source</body><body package="MIME">readFrom: aStream	self source: aStream.	^self newBuilder read: self  from: aStream</body></methods><methods><class-id>Net.MimeEntity</class-id> <category>printing</category><body package="MIME">newPrinter	^self writingOptions newPrinter</body><body package="MIME">printHeaderOn: aStream	self newPrinter printMessageElement: self header on: aStream</body><body package="MIME">printOn: aStream indent: level	self newPrinter printMessage: self on: aStream indent: level.</body></methods><methods><class-id>Net.MimeEntity</class-id> <category>attachments</category><body package="MIME">addFileAttachment: fileNameOrString	^self bot addFileAttachmentFor: self fileName: fileNameOrString</body><body package="MIME">addFileAttachment: fileNameOrString withEncoding: aSymbol	^self bot addFileAttachmentFor: self fileName: fileNameOrString withEncoding: aSymbol</body><body package="MIME">attachmentAt: index	^(self bot attachmentsFor: self) at: index</body><body package="MIME">attachmentFiles	^self attachments select: [:each | each fileName ~~ nil ]</body><body package="MIME">attachmentFilesAsDictionary	| dict |	dict := Dictionary new.	self attachments 		do: [:each | 			each fileName ~~ nil				ifTrue: [ dict at: each fileName put: each value value ]].	^dict</body><body package="MIME">attachmentNames	"Return a list of attachments file names  (if any)"	| list fn  |	list := OrderedCollection new.	self attachments do: [:ea | (fn := ea fileName) notNil ifTrue: [ list add: fn]].	^list</body><body package="MIME">attachments	^self bot attachmentsFor: self</body><body package="MIME">beAttachment: aFilenameString	(self getFieldAt: 'content-disposition')		disposition: #attachment;		fileName: aFilenameString</body><body package="MIME">beInline: aFilenameString	(self getFieldAt: 'content-disposition')		disposition: #inline;		fileName: aFilenameString</body></methods><methods><class-id>Net.MimeEntity</class-id> <category>utility</category><body package="MIME">saveAttachment: aMimeEntity on: aStream	^self bot writeContentsOf: aMimeEntity  on: aStream</body><body package="MIME">saveAttachmentAt: anInteger on: aStream	^self saveAttachment: (self attachmentAt: anInteger)  on: aStream</body></methods><methods><class-id>Net.MimeEntity</class-id> <category>writing</category><body package="MIME">newWriter	^self writingOptions newWriter</body><body package="MIME">writeOn: aStream	self newWriter writeMessage: self on: aStream</body></methods><methods><class-id>Net.MimeEntity</class-id> <category>mime version</category><body package="MIME">addMimeVersion</body></methods><methods><class-id>Net.MimeEntity</class-id> <category>copying</category><body package="MIME">postCopy	super postCopy.	header := header ifNotNil: [ header copy parent: self ].	value := value ifNotNil: [ value copy parent: self ].</body></methods><methods><class-id>Net.MimeEntity</class-id> <category>initialization</category><body package="MIME">initialize	headerCharset := #utf8</body></methods><methods><class-id>Net.MimeEntity class</class-id> <category>instance creation</category><body package="MIME">fileName: fileNameOrString	^self fileName: fileNameOrString withEncoding: SimpleBody defaultCharsetEncoder</body><body package="MIME">fileName: fileNameOrString withEncoding: aSymbol	^MimeEntity new		fileName: fileNameOrString withEncoding: aSymbol;		yourself</body><body package="MIME">mimeTypeForFile: fileName	^MimeTypeDescriptor guessFromExtension: fileName asFilename extension</body><body package="MIME">newTextHTML	" self newTextHTML "	^self new		contentType: MimeTypeDescriptor contentTypeHtml; 		charset: self defaultCharset;		yourself.</body><body package="MIME">newTextPlain	" self newTextPlain "	^self new		contentType: MimeTypeDescriptor contentTypePlainText; 		charset: self  defaultCharset;		yourself.</body><body package="MIME">source: aReadStream" Construct new simple Mime entity containing specified streamExample:	self source: 'ftp.st' asFilename readStream lineEndTransparent "	^self new replaceContentsWithStream: aReadStream</body></methods><methods><class-id>Net.MimeEntity class</class-id> <category>parsing</category><body package="MIME">parse: rfc822Scanner 	^self newBuilder parse: rfc822Scanner</body><body package="MIME">readFrom: aStream	^self newBuilder readFrom: aStream</body><body package="MIME">readHeaderFrom: stream	^self newBuilder readHeaderFrom: stream</body><body package="MIME">scannerType	^MimeScanner</body></methods><methods><class-id>Net.MimeEntity class</class-id> <category>documentation</category><body package="MIME">syntaxOfMultiPartMimeBodies" From RFC 2046: Media Types                  November 1996   The Content-Type field for multipart entities requires one parameter,   'boundary'. The boundary delimiter line is then defined as a line   consisting entirely of two hyphen characters ($-, decimal value 45)   followed by the boundary parameter value from the Content-Type header   field, optional linear whitespace, and a terminating CRLF.   WARNING TO IMPLEMENTORS:  The grammar for parameters on the Content-   type field is such that it is often necessary to enclose the boundary   parameter values in quotes on the Content-type line.  This is not   always necessary, but never hurts. Implementors should be sure to   study the grammar carefully in order to avoid producing invalid   Content-type fields.  Thus, a typical 'multipart' Content-Type header   field might look like this:     Content-Type: multipart/mixed; boundary=gc0p4Jq0M2Yt08j34c0p   But the following is not valid:     Content-Type: multipart/mixed; boundary=gc0pJq0M:08jU534c0p   (because of the colon) and must instead be represented as     Content-Type: multipart/mixed; boundary=""gc0pJq0M:08jU534c0p""   This Content-Type value indicates that the content consists of one or   more parts, each with a structure that is syntactically identical to   an RFC 822 message, except that the header area is allowed to be   completely empty, and that the parts are each preceded by the line     --gc0pJq0M:08jU534c0p   The boundary delimiter MUST occur at the beginning of a line, i.e.,   following a CRLF, and the initial CRLF is considered to be attached   to the boundary delimiter line rather than part of the preceding   part.  The boundary may be followed by zero or more characters of   linear whitespace. It is then terminated by either another CRLF and   the header fields for the next part, or by two CRLFs, in which case   there are no header fields for the next part.  If no Content-Type   field is present it is assumed to be 'message/rfc822' in a   'multipart/digest' and 'text/plain' otherwise.   NOTE:  The CRLF preceding the boundary delimiter line is conceptually   attached to the boundary so that it is possible to have a part that   does not end with a CRLF (line  break).  Body parts that must be   considered to end with line breaks, therefore, must have two CRLFs   preceding the boundary delimiter line, the first of which is part of   the preceding body part, and the second of which is part of the   encapsulation boundary."</body></methods><methods><class-id>Net.MimeEntity class</class-id> <category>defaults</category><body package="MIME">defaultBuilderType	^self defaultReadingOptionsType defaultBuilderType</body><body package="MIME">defaultCharset	^MimeTypeDescriptor iso8859x1</body><body package="MIME">defaultPrinterType	^self defaultWritingOptionsType	defaultPrinterType</body><body package="MIME">defaultReadingOptionsType	^MimeParserHandler defaultOptionsType</body><body package="MIME">defaultWriterType	^self defaultWritingOptionsType defaultWriterType</body><body package="MIME">defaultWritingOptionsType	^MimeOutputHandler defaultOptionsType</body></methods><methods><class-id>Net.MimeEntity class</class-id> <category>accessing</category><body package="MIME">builderClass	^self defaultBuilderType</body><body package="MIME">defaultTextCharset	^defaultTextCharset ifNil: [ MimeTypeDescriptor utf8 ]</body><body package="MIME">defaultTextCharset: aString	defaultTextCharset := aString</body><body package="MIME">defaultTextCharsetValue	^MimeTypeDescriptor utf8</body><body package="MIME">defaultTextType	^defaultTextType ifNil: [ self defaultTextTypeValue ].</body><body package="MIME">defaultTextType: aString	defaultTextType := aString</body><body package="MIME">defaultTextTypeValue	^MimeTypeDescriptor contentTypePlainText</body><body package="MIME">newBuilder	^self builderClass new</body><body package="MIME">newPrinter	^self printerClass new</body><body package="MIME">newWriter	^self writerClass new</body><body package="MIME">printerClass	^self defaultPrinterType</body><body package="MIME">writerClass	^self defaultWriterType</body></methods><methods><class-id>Net.MimeParser</class-id> <category>parsing</category><body package="MIME">endMessageBody: aBody from:  aStream	self handler endMessageBody:  aBody</body><body package="MIME">parse:  aStream	| header entity  |	entity := self startMessageFrom: aStream.	header := self parseHeaderFrom: aStream.	entity := self handler addHeader: header toEntity: entity.	self parseMessageBody: entity from: aStream.	self handler endMessage: entity.	^entity</body><body package="MIME">parseBody: unparsedBody from: aStream	| aBody |	aBody := unparsedBody newBody.	self handler startBody: aBody.	[aBody isSimple 		ifTrue: [self parseSimpleBody: aBody from: aStream]		ifFalse: [self parseMultipartBody: aBody from: aStream].	] ensure: [self handler endBody:  aBody].	^aBody</body><body package="MIME">parseHeaderFrom: aStream 	| headerx |	headerx := self handler startHeader: nil.	aStream text.	self privateParseHeader: headerx from: aStream.	^self handler endHeader: headerx.</body><body package="MIME">parseMessageBody: aMessage from: aStream	| stream |	(self handler shouldStartMessageBody:  aMessage body) 		ifTrue: [stream := self handler 							prepareStream: aStream							forMessageBody: aMessage.				self startMessageBody: aMessage body from: stream.				self parseBody: aMessage body from: stream.				self endMessageBody: aMessage body from: aStream].	^aMessage</body><body package="MIME">parseMultipartBody: aMultipartBody from: aStream	| stream parent header part boundedStream |	boundedStream := self handler 						prepareStream: aStream						forMultipartBody: aMultipartBody.	stream := self  handler asEncodedStream: boundedStream.	parent := aMultipartBody parent. 	[part := self handler startPartFor: parent.	header := self parseHeaderFrom: stream.	self handler addHeader: header toEntity: part. 	self parseBody: part body from: stream.	self handler endPart: part. 	boundedStream isEndOfLastPart 	] 		whileFalse</body><body package="MIME">parseSimpleBody: aBody from: aStream 	aBody parent isAttachment ifTrue: [^self handler processAttachment: aBody from:  aStream.  ].	aBody parent isInline ifTrue: [^self handler processInline: aBody from:  aStream. ].	aBody parent isFormData 	ifTrue: [^self handler processFormData: aBody from:  aStream. ].	self handler processPartBody: aBody from:  aStream.</body><body package="MIME">startMessageBody: aBody from:  aStream	self handler startMessageBody:  aBody</body><body package="MIME">startMessageFrom: aStream	^self handler startMessage: nil</body></methods><methods><class-id>Net.MimeParser</class-id> <category>accessing</category><body package="MIME">handler	^handler</body><body package="MIME">handler: aMessageHandler	handler := aMessageHandler</body></methods><methods><class-id>Net.MimeParser</class-id> <category>initialize-release</category><body package="MIME">initialize</body></methods><methods><class-id>Net.MimeParser</class-id> <category>defaults</category><body package="MIME">encodingself halt.	^#UTF_8</body></methods><methods><class-id>Net.MimeParser</class-id> <category>private</category><body package="MIME">captureLineStart: inputStream	^nil</body><body package="MIME">copyLineFrom: aStream into: stream	| char |	[	char := aStream next.		char isNil or: [ self endOfLine: char ]	] whileFalse: [ stream nextPut: char ]</body><body package="MIME">endOfLine: char	^#(10 13 ) includes: char asInteger</body><body package="MIME">parseFieldsFrom: inputStream do: aBlock	| char lineStream start |	lineStream := String new writeStream.	char := inputStream next.	[	"Note that we have already read the first character of the line from the inputStream at this point."		start := self captureLineStart: inputStream.		char isNil or: [ self endOfLine: char ]	] whileFalse: [		[	( self shouldFold: char)				ifTrue: [lineStream nextPut: Character space]				ifFalse: [lineStream nextPut: char].			self copyLineFrom: inputStream into: lineStream.			char := inputStream next.			char notNil and: [ self shouldFold: char ]		] whileTrue.		aBlock value: lineStream contents readStream value: start value: inputStream.		lineStream := String new writeStream ]</body><body package="MIME">privateParseHeader: header from: aStream	| factory  |	factory := self handler fieldFactory.	self 		parseFieldsFrom: aStream 		do: [ :lineStream :start :inputStream |			(factory readFrom: lineStream acceptNonAsciiCharacters: self handler acceptNonAsciiCharacters) 				ifNotNil: [ :field | header addField: field. field ] ]</body><body package="MIME">shouldFold: char	^#(32 9 ) includes: char asInteger</body></methods><methods><class-id>Net.MimeParser class</class-id> <category>instance creation</category><body package="MIME">handler: aMessageHandler	^self new		handler: aMessageHandler</body><body package="MIME">new	^super new initialize</body><body package="MIME">readFrom: aStream	^self readFrom: aStream builder: MimeEntity newBuilder</body><body package="MIME">readFrom: aStream builder: aMessageBuildHandler	^self new 		handler: aMessageBuildHandler;		readFrom: aStream</body></methods><methods><class-id>Net.HeaderFieldValue</class-id> <category>accessing</category><body package="MIME">groupSeparator	^self separators last</body><body package="MIME">separators	^separators</body><body package="MIME">separators: anArray	separators := anArray</body><body package="MIME">value	^value</body><body package="MIME">value: aString	value := aString</body><body package="MIME">valueSeparator	^self separators first</body></methods><methods><class-id>Net.HeaderFieldValue</class-id> <category>parsing</category><body package="MIME">doParse: scanner	" Canonical value removes all white space and comments from the source "	| str |	str := scanner scanUntil: 			[ scanner hereChar == self valueSeparator 				or: [ scanner hereChar == self groupSeparator] ].	^self  tokenizedValueFrom: (self scannerOn: str readStream).</body><body package="MIME">parse: scanner	self parseValue: scanner.</body><body package="MIME">parseValue: scanner	scanner skipWhiteSpace. 	value := self doParse: scanner.	^value</body><body package="MIME">readFrom: aStream	^self parse: (self scannerOn: aStream)</body><body package="MIME">scannerOn: aStream	^self class scannerOn: aStream</body></methods><methods><class-id>Net.HeaderFieldValue</class-id> <category>printing</category><body package="MIME">printOn: aStream	self printValueOn: aStream.</body><body package="MIME">printValueOn: aStream	self value isUnparsedHeaderValue		ifTrue: [ self value printOn: aStream ]		ifFalse: [ self writeValueOn: aStream ]</body></methods><methods><class-id>Net.HeaderFieldValue</class-id> <category>private-utility</category><body package="MIME">tokenize: rfc822Stream 	"Scan field value token by token. Answer an array of tokens"	| result token |	result := (Array new: 2) writeStream.	[rfc822Stream atEnd or: [rfc822Stream peek == Character cr or: [(token := rfc822Stream nextToken) isNil]]]		whileFalse: [result nextPut: token].	^result contents</body><body package="MIME">tokenizedValueFrom: rfc822Stream 	"Scan field value token by token. Answer a string that is a concatenation of all elements in the array. One can view this as a canonicalized field value because this operation eliminates all white space and comments "	| result tokens |	result := (String new: 20) writeStream.	tokens := self tokenize: rfc822Stream.	tokens		do: [:token | token isString				ifTrue: [result nextPutAll: token]				ifFalse: [result nextPut: token]].	^result contents</body></methods><methods><class-id>Net.HeaderFieldValue</class-id> <category>initialize-release</category><body package="MIME">initialize</body></methods><methods><class-id>Net.HeaderFieldValue</class-id> <category>composing</category><body package="MIME">writeOn: aStream	| val |	((val := self value) notNil and: [val isUnparsedHeaderValue ]) ifTrue: [ ^val writeOn: aStream ].	self writeOn: aStream encoding: nil</body><body package="MIME">writeOn: aStream encoding: aString	self writeValueOn: aStream</body><body package="MIME">writeValueOn: aStream	value ~~ nil ifTrue: [aStream nextPutAll: self value]</body></methods><methods><class-id>Net.HeaderFieldValue class</class-id> <category>instance creation</category><body package="MIME">new	^super new initialize</body><body package="MIME">newWithSeparators: anArray	^self new		separators: anArray;		yourself</body></methods><methods><class-id>Net.HeaderFieldValue class</class-id> <category>parsing</category><body package="MIME">scannerOn: aStream 	^(aStream isKindOf: self scannerType)		ifTrue: [aStream]		ifFalse: [self scannerType on: aStream asStream]</body><body package="MIME">scannerType	^MimeScanner</body></methods><methods><class-id>Net.ValueWithParams</class-id> <category>accessing</category><body package="MIME">paramAt: aString	^self paramAt: aString asLowercase ifAbsent: [ nil ]</body><body package="MIME">paramAt: aString ifAbsent: aBlock	^self params at: aString ifAbsent: [ aBlock value ]</body><body package="MIME">paramAt: aName put: aValue	^self params at: aName put: aValue</body><body package="MIME">parametersSeparator	^self separators at: 2</body><body package="MIME">params	^params ifNil: [ self resetParams ].</body><body package="MIME">removeParamAt: aName	^self params removeKey: aName ifAbsent: [nil]</body></methods><methods><class-id>Net.ValueWithParams</class-id> <category>printing</category><body package="MIME">printOn: aStream	super printOn: aStream.	self printParamsOn: aStream</body><body package="MIME">printParameter: assoc on: aStream 	self class scannerType printWord: assoc key on: aStream.	self printParameter: assoc key value: assoc value on: aStream.</body><body package="MIME">printParameter: name value: anObject on: aStream		self writeParameter: name value: anObject on: aStream</body><body package="MIME">printParamsOn: aStream	self params notEmpty		ifTrue:			[aStream nextPut: self valueSeparator.			params associations				do: [ :assoc | self printParameter: assoc on: aStream ]				separatedBy: [self writeParametersSeparatorOn: aStream  ]]</body></methods><methods><class-id>Net.ValueWithParams</class-id> <category>parsing</category><body package="MIME">addParameterNamed: valString value: parString	self params 		at: valString asLowercase		put: parString</body><body package="MIME">addRFC5987Parameter: aString scanner: scanner" http://tools.ietf.org/html/rfc5987 ext-parameter = parmname '*' LWSP '=' LWSP ext-valueCharacter Set and Language Encoding for HTTPHeader Field Parametersext-value     = charset  ' [ language ] ' value-chars   value-chars   = *( pct-encoded / attr-char )     pct-encoded   = '%' HEXDIG HEXDIG     attr-char     = ALPHA / DIGIT / ! / # / $ / &amp; / + / - / . / ^ / _/ ` / { / }  / ~ "	| paramValue paramName encoding |	paramName := aString copyFrom: 1 to: aString size - 1. 	encoding := scanner upTo: $'. 	" skip language " scanner  upTo: $'. 	paramValue := (URLEncoder new charset: encoding asSymbol) decode: scanner nextToken.	paramValue ifNil: [^nil].	self addParameterNamed: paramName value: paramValue.</body><body package="MIME">finishParse</body><body package="MIME">parse: scanner	self parseValue: scanner.	scanner atEnd ifTrue: [ ^self]. 	scanner hereChar ~~ self valueSeparator		ifTrue: [ scanner stepBack. ^self ].	self parseParameters: scanner.	self finishParse.</body><body package="MIME">parseParamNameFrom: scanner 	^scanner nextToken</body><body package="MIME">parseParamValueFrom: scanner 	| paramValue encoding |	encoding := self class defaultParameterValueEncoding.	paramValue :=		(encoding isNil or: [ encoding isEmpty ])			ifTrue: [ scanner nextToken ]			ifFalse: [ self parseParamValueFrom: scanner allowing: encoding ].	paramValue ifNil: [^nil].	^MimeEncodedWordCoDec decodeText: paramValue.</body><body package="MIME">parseParamValueFrom: scanner allowing: encoding	| acceptNonASCIICharacter paramValue hasNonASCIICharacter |	acceptNonASCIICharacter := scanner acceptNonAsciiCharacters.	hasNonASCIICharacter := false.	scanner acceptNonAsciiCharacters: false.	[	[	(paramValue := scanner nextToken)  ifNil: [ ^nil].		]	on: NonASCIICharacter 			do: [ :ex | 				hasNonASCIICharacter := true.				acceptNonASCIICharacter 					ifTrue: [ scanner acceptNonAsciiCharacters: acceptNonASCIICharacter. 							ex resume: SimpleScanner  anyTextMask]					ifFalse: [ ex pass ] ].	] ensure: [ scanner acceptNonAsciiCharacters: acceptNonASCIICharacter].	hasNonASCIICharacter ifTrue: [		paramValue := (paramValue asByteArrayEncoding: #'iso8859-1') asStringEncoding: encoding].	^paramValue.</body><body package="MIME">parseParameters: scanner	| paramName |	scanner atEnd ifFalse: [		scanner			tokenizeList: [				(paramName := self parseParamNameFrom: scanner ) notNil ifTrue: [					scanner skipWhiteSpace.					(self validateNextToken: scanner for: paramName) ifFalse: [							^(InvalidHeaderField 								errorDescription: (( #WrongToken1sExpected &lt;&lt; #net &gt;&gt; 'Wrong token: &lt;1s&gt;. Expected token: $=' ) expandMacrosWith: scanner token printString)								source: scanner asStream 								errorPosition: scanner position) raise ].  					paramName last = $* 						ifTrue: [self addRFC5987Parameter: paramName scanner: scanner ]						ifFalse: [ self 									addParameterNamed: paramName  									value: (self parseParamValueFrom: scanner)]]]			separatedBy: [scanner token == self parametersSeparator ] ]</body><body package="MIME">validateNextToken: scanner for: parName	^scanner next == $=</body></methods><methods><class-id>Net.ValueWithParams</class-id> <category>initialize-release</category><body package="MIME">resetParams	^params := Struct new</body></methods><methods><class-id>Net.ValueWithParams</class-id> <category>composing</category><body package="MIME">writeOn: aStream encoding: aString	super writeOn: aStream encoding: aString.	self	writeParamsOn: aStream encoding: aString.</body><body package="MIME">writeParameter: assoc on: aStream encoding: aString	| rfcString |	self class scannerType			printWord: assoc key on: aStream;			print: $= on: aStream.	assoc value isEmpty ifTrue: [^aStream nextPut: $"; nextPut: $"].	assoc value ~~ nil		ifTrue: 			[(MimeEncodedWordCoDec shouldBeEncoded: assoc value)				ifTrue: 					[rfcString := MimeEncodedWordCoDec 									encodeText: assoc value 									asBase64Using: aString. 					aStream nextPut: $"; nextPutAll:  rfcString; nextPut: $" ]				ifFalse: [ self class scannerType printWord: assoc value on: aStream ]]</body><body package="MIME">writeParameter: name value: anObject on: aStream	anObject isNil ifTrue: [^nil].	self class scannerType print: $= on: aStream.	[self class scannerType printWord: anObject on: aStream	] 	on: NonASCIICharacter 		do: [ :ex | aStream nextPut: $"; nextPutAll: anObject; nextPut: $"]</body><body package="MIME">writeParametersSeparatorOn: aStream	aStream nextPut: self parametersSeparator</body><body package="MIME">writeParamsOn: aStream encoding: aString	(params ~~ nil and: [ params notEmpty])		ifTrue:			[aStream nextPut: self valueSeparator.			params associations				do: [ :assoc | self writeParameter: assoc on: aStream encoding: aString ]				separatedBy: [ self writeParametersSeparatorOn: aStream ]]</body></methods><methods><class-id>Net.ValueWithParams class</class-id> <category>accessing</category><body package="MIME">defaultParameterValueEncoding	^defaultParameterValueEncoding ifNil: [self defaultParameterValueEncodingValue ]</body><body package="MIME">defaultParameterValueEncoding: aString"If set, the specified encoding will be applied if we encounter non-ascii characters in parameter values (technically this is against the HTTP specification, but seems to be a widespread practice, e.g. many web browsers do that with filenames of uploaded files).	self defaultParameterValueEncoding: nil	self defaultParameterValueEncoding: #utf8"	defaultParameterValueEncoding := aString ifNotNil: [ aString asSymbol ]</body><body package="MIME">defaultParameterValueEncodingValue	^nil</body></methods><methods><class-id>Net.MimeDispatcherHandler</class-id> <category>accessing</category><body package="MIME">dispatcher	^dispatcher isNil 		ifTrue: [dispatcher := self defaultDispatcher]		ifFalse: [dispatcher]</body><body package="MIME">dispatcher: aMessageDispatcher 	aMessageDispatcher handler: self.	dispatcher := aMessageDispatcher</body><body package="MIME">headerOnly	^self options headerOnly</body><body package="MIME">headerOnly: aBoolean 	self options headerOnly: aBoolean</body><body package="MIME">options	^options ifNil: [options := self class defaultOptionsType new]</body><body package="MIME">options: aMimeDispatcherWritingOptions	options := aMimeDispatcherWritingOptions</body></methods><methods><class-id>Net.MimeDispatcherHandler</class-id> <category>action callbacks</category><body package="MIME">endEntity: aMimeEntityOrNil	^aMimeEntityOrNil</body><body package="MIME">endHeader: aMessageHeader	^aMessageHeader parent</body><body package="MIME">endMessage: aMessage	^aMessage</body><body package="MIME">endMultipartBody: aMultipartBody	^aMultipartBody</body><body package="MIME">endPart: aMimeEntity	^aMimeEntity</body><body package="MIME">endSimpleBody: aMessageBody 	^aMessageBody</body><body package="MIME">processMessageBody:  aMessage do: aBlock	aBlock value</body><body package="MIME">shouldStartBody: aMimeEntity 	^self headerOnly not</body><body package="MIME">shouldStartEntity: aMimeEntityOrNil	^true</body><body package="MIME">shouldStartMessage: aMimeEntityOrNil	^true</body><body package="MIME">startEntity: aMimeEntityOrNil	^aMimeEntityOrNil</body><body package="MIME">startHeader: aMessageHeader	^aMessageHeader</body><body package="MIME">startMessage: aMessage	^aMessage</body><body package="MIME">startMultipartBody: aMultipartBody	^aMultipartBody</body><body package="MIME">startPart: aMimeEntity	^aMimeEntity</body><body package="MIME">startSimpleBody: aSimpleBody	^aSimpleBody</body></methods><methods><class-id>Net.MimeDispatcherHandler</class-id> <category>defaults</category><body package="MIME">defaultDispatcher	^self dispatcherClass handler: self</body><body package="MIME">dispatcherClass	^MimeDispatcher</body></methods><methods><class-id>Net.MimeDispatcherHandler</class-id> <category>dispatcher interface</category><body package="MIME">visit: anObject	self dispatcher visit: anObject</body></methods><methods><class-id>Net.MimeDispatcherHandler</class-id> <category>private</category><body package="MIME">defaultBoundaryFor: aMimeEntity" Compute default boundary for specified Mime entity. Boundary is a string thatcould not occur inside any of the parts. For now just use constant plus a random number "	^'=_vw', Random new next printString, '_='</body></methods><methods><class-id>Net.MimeDispatcherHandler class</class-id> <category>instance creation</category><body package="MIME">new	^super new initialize</body><body package="MIME">with: aMimeDispatcherWritingOptions	^self new		options: aMimeDispatcherWritingOptions;		yourself</body></methods><methods><class-id>Net.MimeDispatcherHandler class</class-id> <category>defaults</category><body package="MIME">defaultOptionsType	^MimeDispatcherWritingOptions</body></methods><methods><class-id>Net.MailGroupDescriptor</class-id> <category>accessing</category><body package="MIME">addresses	^addresses</body><body package="MIME">addresses: anArray	addresses := anArray</body><body package="MIME">alias	^alias</body><body package="MIME">alias: aString	alias := aString</body></methods><methods><class-id>Net.MailGroupDescriptor</class-id> <category>initialization</category><body package="MIME">initialize	addresses := Array new.</body></methods><methods><class-id>Net.MailGroupDescriptor</class-id> <category>printing</category><body package="MIME">writeAddressesOn: stream	stream nextPut: $:.	self addresses do: [ :address | address printOn: stream ] separatedBy: [ stream nextPut: $, ].	stream nextPut: $;</body><body package="MIME">writeCanonicalValueOn: stream	self writeAliasOn: stream.	self writeAddressesOn: stream</body></methods><methods><class-id>Net.MailGroupDescriptor</class-id> <category>composing</category><body package="MIME">writeCanonicalValueOn: stream encoding: aString	self writeAliasOn: stream encoding: aString.	stream nextPut: $:.	self 		addresses do: [:addr | addr  writeCanonicalValueOn: stream encoding: aString]		separatedBy: [stream nextPut: MailboxListField addressSeparator ].	stream nextPut: $;</body></methods><methods><class-id>Net.ContentTypeField</class-id> <category>accessing</category><body package="MIME">boundary	^self parameterAt: 'boundary'</body><body package="MIME">boundary: aString	^self parameterAt: 'boundary' put: aString</body><body package="MIME">charset	| charset |	charset := self parameterAt: 'charset' ifAbsent: [nil]. 	^(charset == nil		ifTrue: 			[ ('text*' match: self contentType)				ifTrue: [ self class defaultCharset]				ifFalse: [ nil ]]		ifFalse: [ charset asLowercase ])</body><body package="MIME">charset: aName	^aName ~~ nil		ifTrue: [self parameterAt: 'charset' put: aName ]		ifFalse: [ nil]</body><body package="MIME">charsetIfNone: aBlock	| v |	v := self parameterAt: 'charset' ifAbsent: [aBlock value].	^v notNil		ifTrue: [ v asLowercase ]		ifFalse: [ nil ]</body><body package="MIME">contentType	^self localValue</body><body package="MIME">contentType: aString	self localValue:  aString</body><body package="MIME">fileName	^(self parameterAt: 'name' ifAbsent: [^String new ]) asLowercase</body><body package="MIME">fileName: aName	^self parameterAt: 'name' put: aName</body><body package="MIME">subtype	^(self contentType tokensBasedOn: $/) last.</body><body package="MIME">subtype: aString	self type: self type subtype: aString.</body><body package="MIME">type	^(self contentType tokensBasedOn: $/) first.</body><body package="MIME">type: aString	self type: aString subtype: self subtype</body><body package="MIME">type: typeString subtype: subtypeString	self  localValue: (typeString, '/', subtypeString)</body></methods><methods><class-id>Net.ContentTypeField</class-id> <category>testing</category><body package="MIME">isBinary	^(MimeTypeDescriptor contentType: self contentType) isBinary</body><body package="MIME">isMultipart	^'multipart' match: self type</body></methods><methods><class-id>Net.ContentTypeField</class-id> <category>parsing</category><body package="MIME">validateValue: scanner"The charset value should be quoted string but the Microsoft-IIS/6.0 server produces:Content-type: text/xml;charset='UTF-8' This hack is trying to set correct charset from the wrong parameter.Another server with another bug:Server: Yaws/1.56 Yet Another Web Server &gt;&gt;  'Content-Type: text/xml;charset=' Remove this empty charset!"	| cs |	super validateValue: scanner."Matching of media type and subtype is ALWAYS case-insensitive.type := discrete-type / composite-typediscrete-type := 'text' / 'image' / 'audio' / 'video' / 'application' / extension-tokencomposite-type := 'message' / 'multipart' / extension-token "	self localValue: self localValue asLowercase.	cs := self  parameterAt: 'charset' ifAbsent: [^nil].	(cs isNil or: [cs isEmpty]) ifTrue: [self element removeParamAt: 'charset'. ^nil].	(cs first = $' and: [ cs last = $' ])		ifTrue: [self charset: ( cs copyFrom: 2 to: cs size - 1) ]</body></methods><methods><class-id>Net.ContentTypeField class</class-id> <category>parsing</category><body package="MIME">fieldNames	^#('content-type')</body></methods><methods><class-id>Net.ContentTypeField class</class-id> <category>instance creation</category><body package="MIME">applicationOctetStream	" self applicationOctetStream "	^self contentType: MimeTypeDescriptor contentTypeApplicationOctetStream</body><body package="MIME">contentType: aString	^self contentType: aString charset: nil</body><body package="MIME">contentType: aString charset: cString	^self new 		name: 'content-type';		contentType: aString;		charset: cString;		yourself</body><body package="MIME">default	^self iso8859x1Default</body><body package="MIME">iso8859x1Default	^self new		name: 'content-type';		contentType: self defaultContentType;		charset: self iso8859x1;		yourself</body><body package="MIME">messageRfc822	" self messageRfc822 "	^self contentType: MimeTypeDescriptor contentTypeMessageRfc822 charset: self defaultCharset</body><body package="MIME">textPlain	" self textPlain "	^self contentType: MimeTypeDescriptor contentTypePlainText charset: self defaultCharset</body><body package="MIME">usAsciiDefault	^self new		name: 'content-type';		contentType: self defaultContentType;		charset: self usAscii;		yourself</body></methods><methods><class-id>Net.ContentTypeField class</class-id> <category>defaults</category><body package="MIME">defaultCharset	^self iso8859x1</body><body package="MIME">defaultContentType	^MimeTypeDescriptor defaultContentTypeString</body><body package="MIME">defaultSeparators	^#($; $; nil  )</body><body package="MIME">defaultUnsupportedContentType	^MimeTypeDescriptor defaultUnsupportedContentType</body><body package="MIME">iso8859x1	^MimeTypeDescriptor iso8859x1</body><body package="MIME">usAscii	^MimeTypeDescriptor usAscii</body></methods><methods><class-id>Net.MimeParserHandler</class-id> <category>tasks</category><body package="MIME">on: aStream	stream := aStream.	lineEndConvention := stream lineEndConvention.</body><body package="MIME">read: aMimeEntity from: aStream	^self 		setEntity: aMimeEntity;		parse:  aStream</body><body package="MIME">readBody	initialEntity ifNil: [ ^self error: #ThereIsNoEntity &lt;&lt; #net &gt;&gt; 'There is no entity created to parse the body. Use #readHeader to create an entity before parsing the body' ].	self headerOnly: false.	self parser parseMessageBody: initialEntity from: stream.	^initialEntity</body><body package="MIME">readFrom: aStream	^self parse:  aStream</body><body package="MIME">readHeader	stream ifNil: [ ^self error: #ThereIsNoStream &lt;&lt; #net &gt;&gt; 'There is no stream specified to parse the header. Use #on: to set the stream' ].	^self readHeaderFrom: stream</body><body package="MIME">readHeaderFor: aMimeEntity from: aStream	self setEntity: aMimeEntity.	^self readHeaderFrom: aStream</body><body package="MIME">readHeaderFrom: aStream	self headerOnly: true.	^self parse: aStream</body></methods><methods><class-id>Net.MimeParserHandler</class-id> <category>defaults</category><body package="MIME">defaultEncoding	^self options defaultEncoding</body><body package="MIME">defaultParser	^self parserClass handler: self</body><body package="MIME">defaultPartEntityType	^self options defaultPartEntityType</body><body package="MIME">defaultRootEntityType	^self options defaultRootEntityType</body><body package="MIME">parserClass	^MimeParser</body></methods><methods><class-id>Net.MimeParserHandler</class-id> <category>action callbacks</category><body package="MIME">addHeader: aMessageHeader toEntity: anEntity	| ent |	ent := anEntity isNil		ifTrue: [ self defaultPartEntityType new ]		ifFalse: [anEntity].	self setEntity: ent.	ent header: aMessageHeader.	^ent</body><body package="MIME">endBody: aMessageBody 		(aMessageBody isSimple and: [aMessageBody byteSource notNil ])		ifTrue: [ aMessageBody byteSource close ].	^aMessageBody parent</body><body package="MIME">endHeader: aHeader	^aHeader</body><body package="MIME">endMessage: aMessage	"restore the stream original mode"	binaryMode ifTrue: [ stream binary] ifFalse: [stream text].	^aMessage</body><body package="MIME">endMessageBody:  aBody	^aBody</body><body package="MIME">endPart: aMimeEntity	^aMimeEntity</body><body package="MIME">shouldStartBody: aMimeEntity 	^self headerOnly not</body><body package="MIME">shouldStartMessageBody: aMessageBody 	^self shouldStartBody: aMessageBody</body><body package="MIME">startBody:  aBody	^aBody</body><body package="MIME">startHeader: aMessageHeaderOrNil 	^aMessageHeaderOrNil isNil		ifTrue: [self messageHeaderClass new]		ifFalse: [aMessageHeaderOrNil]</body><body package="MIME">startMessage: anObjectOrNil	^initialEntity ifNil: [ initialEntity := self defaultRootEntityType new.						initialEntity body: UnparsedBody new.						initialEntity ].</body><body package="MIME">startMessageBody: aBody	^aBody</body><body package="MIME">startPartFor: aParentEntity	| part |	part := self defaultPartEntityType new.	part body: UnparsedBody new.	aParentEntity addPart: part.	^part</body></methods><methods><class-id>Net.MimeParserHandler</class-id> <category>private</category><body package="MIME">fileNameFrom: aString	| fn |	[fn := aString asFilename.]		on: UnsupportedCharacterError do: [ :ex | ^self randomExtension asFilename].	^(fn exists 		ifTrue:[ self randomExtension, '_', fn tail ] 		ifFalse: [fn tail]).</body><body package="MIME">handleStartBody: aBody exception: exception	ParsingSimpleBodyError new		messageText: exception class name asString, ': ',exception messageText;		parameter: exception;		raiseSignal</body><body package="MIME">parse: aStream 	self prepareStream: aStream.	binaryMode := stream isBinary.	lineEndConvention := stream lineEndConvention.	^self parser parse: stream</body><body package="MIME">randomExtension	^(Random new next * 10000000000000000) asInteger printString</body><body package="MIME">safelyRead: aBody from: sourceStream into: resultStream	sourceStream binary.	[ [sourceStream atEnd ] 		whileFalse: [resultStream nextPut: sourceStream next].	 ]		on: Error 		do: [ :ex | self handleStartBody: aBody exception: ex ].	sourceStream text.</body><body package="MIME">setBodySource: aBody	| source |	aBody byteSource notNil		ifTrue: [	source := EncodedStream 					on: aBody byteSource					encodedBy: (StreamEncoder new: aBody parent charset) initializeForMemory.				source					lineEndAuto;					close.				aBody source: source.]</body><body package="MIME">setEntity: anEntity	initialEntity ifNil: [ initialEntity := anEntity ]</body></methods><methods><class-id>Net.MimeParserHandler</class-id> <category>private prepare streams</category><body package="MIME">asEncodedStream: aStream	^(EncodedStream on: aStream		encodedBy: (StreamEncoder new: self defaultEncoding))		lineEndConvention: lineEndConvention.</body><body package="MIME">openBodyStream: aMessageBody	aMessageBody byteSource:  (ReadWriteStream on: (ByteArray new: 1024)).	^aMessageBody byteSource</body><body package="MIME">prepareStream: aStream 	^stream := (aStream 					asEncodedStreamWithEncoding: self defaultEncoding 					lineEndConvention: LineEndCRLF )				lineEndCRLF;				text.</body><body package="MIME">prepareStream: aStream forMessageBody: anEntity	^stream</body><body package="MIME">prepareStream: aStream forMultipartBody: aMultipartBody	^BoundedReadStream on: aStream boundary: aMultipartBody boundary.</body><body package="MIME">prepareStream: aStream forSimpleBody: aBody	^aStream</body><body package="MIME">setAttachmentSource: aBody to: aStream	"The attachment was not saved into an external file  "	aBody byteSource ifNotNil: [^aBody].	" Setting the body source to an external stream "	aBody isBinaryContentType ifFalse: [		aStream			text;			lineEndAuto ].	aStream close.	aBody source: aStream.	^aBody</body></methods><methods><class-id>Net.MimeParserHandler</class-id> <category>accessing</category><body package="MIME">acceptNonAsciiCharacters	^self options acceptNonAsciiCharacters</body><body package="MIME">acceptNonAsciiCharacters: aBoolean	self options acceptNonAsciiCharacters: aBoolean</body><body package="MIME">attachmentDirectory	^self options attachmentDirectory</body><body package="MIME">attachmentDirectory: aStringOrFilename	self options attachmentDirectory: aStringOrFilename asFilename</body><body package="MIME">fieldFactory" Answer field factory or default field factory if none is specified. Different protocols may have different field factories  "	^self options fieldFactory</body><body package="MIME">fieldFactory: anObject" Set field factory. Different protocols may have different field factories. Field factory should respond to messages:	readFrom: 	readNameFrom:	scannerType	fieldClassForName:"	self options fieldFactory: anObject</body><body package="MIME">headerOnly	^self options headerOnly</body><body package="MIME">headerOnly: aBoolean 	self options headerOnly: aBoolean</body><body package="MIME">messageHeaderClass" Answer message header class "	^self options messageHeaderClass</body><body package="MIME">messageHeaderClass: aClass" Set message header class "	self options messageHeaderClass: aClass</body><body package="MIME">options	^options ifNil: [options := self class defaultOptionsType new]</body><body package="MIME">options: aaMimeReadingOptions	options := aaMimeReadingOptions</body><body package="MIME">parser	^parser isNil 		ifTrue: [parser := self defaultParser]		ifFalse: [parser]</body><body package="MIME">parser: aMessageDispatcher 	aMessageDispatcher handler: self.	parser := aMessageDispatcher</body><body package="MIME">saveAttachmentsAsFiles	^self options saveAttachmentsAsFiles</body><body package="MIME">saveAttachmentsAsFiles: aBoolean	self options saveAttachmentsAsFiles: aBoolean</body><body package="MIME">scannerType	^self options scannerType</body><body package="MIME">scannerType: aClass	self options scannerType:  aClass</body></methods><methods><class-id>Net.MimeParserHandler</class-id> <category>body callbacks</category><body package="MIME">openAttachmentStream: aBody	| loadDir fn name |	self saveAttachmentsAsFiles ifFalse: [^self openBodyStream: aBody ].	loadDir := self attachmentDirectory.	fn := aBody parent fileName.	name := loadDir construct: (			fn 				ifNotNil: [self fileNameFrom: fn]				ifNil: [self randomExtension]).	name := AttachmentFilename newException				originalFilename: fn;				filename: name;				raiseRequest.	name asFilename exists		ifTrue: [ name := AttachmentFileExists new filename: name asFilename; raiseRequest].	name asFilename exists ifTrue: [name asFilename delete].	^self openAttachmentStream: aBody filename: name asFilename</body><body package="MIME">openAttachmentStream: aBody filename: aFilename	| encoding |	^((encoding := aBody parent charsetIfNone: [nil ]) isNil		ifTrue: [ aFilename ]		ifFalse: [aFilename withEncoding: encoding ] ) readWriteStream binary</body><body package="MIME">processAttachment: aBody from: aStream	| resultStream |	resultStream := self openAttachmentStream: aBody.	[		self safelyRead: aBody 			from:  ( self prepareStream: aStream forSimpleBody: aBody)  			into: resultStream.	] ensure: [ resultStream close].	self setAttachmentSource: aBody to: resultStream .</body><body package="MIME">processBody: aBody from: aStream	self 		safelyRead: aBody 		from: ( self prepareStream: aStream forSimpleBody: aBody) 		into: ( self openBodyStream: aBody) .</body><body package="MIME">processFormData: aBody from: aStream	^self processBody: aBody from: aStream</body><body package="MIME">processInline: aBody from: aStream	^self processBody: aBody from: aStream</body><body package="MIME">processPartBody: aBody from: aStream 	self processBody: aBody from: aStream</body></methods><methods><class-id>Net.MimeParserHandler class</class-id> <category>instance creation</category><body package="MIME">new	^super new initialize</body><body package="MIME">on: aStream	^self new on: aStream; yourself</body><body package="MIME">read: entity from: aStream	"Builds specified entity from the stream  "	^self new read: entity from: aStream</body><body package="MIME">readFrom: aStream	"Creates and builds the entity from the stream  " 	^self new readFrom: aStream</body><body package="MIME">readHeaderFor: aMimeEntity from: aStream	"Builds headers for the specified entity from  the stream "	^self new readHeaderFor: aMimeEntity from: aStream</body><body package="MIME">readHeaderFrom: aStream	"Creates an entity and builds headers for the entity from the stream "	^self new readHeaderFrom: aStream</body><body package="MIME">with: aMimeReadingOptions	"Creates an instance with provided options  " 	^self new 		options: aMimeReadingOptions;		yourself</body></methods><methods><class-id>Net.MimeParserHandler class</class-id> <category>defaults</category><body package="MIME">defaultAttachmentDirectory		^self defaultOptionsType defaultAttachmentDirectory</body><body package="MIME">defaultAttachmentDirectory: aString	self defaultOptionsType defaultAttachmentDirectory: aString</body><body package="MIME">defaultAttachmentDirectoryString		^self defaultOptionsType defaultAttachmentDirectoryString</body><body package="MIME">defaultAttachmentDirectoryString: aString	self defaultOptionsType defaultAttachmentDirectoryString: aString</body><body package="MIME">saveAttachmentsAsFiles	" (self  saveAttachmentsAsFiles) "	^self defaultOptionsType saveAttachmentsAsFiles</body><body package="MIME">saveAttachmentsAsFiles: aBoolean	" (self  saveAttachmentsAsFiles: nil) "	self defaultOptionsType saveAttachmentsAsFiles: aBoolean</body></methods><methods><class-id>Net.MimeParserHandler class</class-id> <category>default values</category><body package="MIME">defaultAttachmentDirectoryValue	^self defaultOptionsType defaultAttachmentDirectoryValue</body><body package="MIME">defaultOptionsType	^MimeReadingOptions</body><body package="MIME">saveAttachmentsAsFilesValue	^self defaultOptionsType saveAttachmentsAsFilesValue</body></methods><methods><class-id>Net.MimeBuildHandler</class-id> <category>private prepare streams</category><body package="MIME">prepareStream: aStream forSimpleBody: aBody	(self shouldRemoveBase64EncodingFor: aBody)		ifTrue: [ ^DecodedStream on: aStream  encodedBy: B64StreamDecoder asEncoder.].	(self shouldRemoveQuotedPrintableEncodingFor: aBody)		ifTrue: [ ^DecodedStream on: aStream  encodedBy: QuotedPrintableDecoder asEncoder. ].	^aStream</body></methods><methods><class-id>Net.MimeBuildHandler</class-id> <category>testing</category><body package="MIME">shouldRemoveBase64EncodingFor: aBody	^self removeContentTransferEncoding		and: [aBody parent isBase64Type ]</body><body package="MIME">shouldRemoveContentTransferEncodingFor: aBody	^(self shouldRemoveBase64EncodingFor: aBody)		or: [self shouldRemoveQuotedPrintableEncodingFor: aBody]</body><body package="MIME">shouldRemoveQuotedPrintableEncodingFor: aBody	^self removeContentTransferEncoding		and: [ aBody parent isPrintedQuotableType]</body></methods><methods><class-id>Net.MimeBuildHandler</class-id> <category>action callbacks</category><body package="MIME">endBody: aBody	(self shouldRemoveContentTransferEncodingFor: aBody)		ifTrue: [aBody parent removeFieldAt: 'content-transfer-encoding'].	aBody isSimple 	ifTrue: [self setBodySource: aBody ].	^super endBody: aBody</body></methods><methods><class-id>Net.MimeBuildHandler</class-id> <category>accessing</category><body package="MIME">removeContentTransferEncoding	^self options removeContentTransferEncoding</body><body package="MIME">removeContentTransferEncoding: aBoolean	self options removeContentTransferEncoding: aBoolean</body></methods><methods><class-id>Net.MimeBuildHandler</class-id> <category>tasks</category><body package="MIME">removeContentTransferEncodingFor: aBody		self removeContentTransferEncoding: true.	(self shouldRemoveContentTransferEncodingFor: aBody) ifFalse: [ ^aBody ].	self processBody: aBody from: aBody anySource reset.	self endBody: aBody.</body></methods><methods><class-id>Net.MimeBuildHandler class</class-id> <category>defaults</category><body package="MIME">removeContentTransferEncoding	^self defaultOptionsType removeContentTransferEncoding</body><body package="MIME">removeContentTransferEncoding: aBoolean	self defaultOptionsType removeContentTransferEncoding: aBoolean</body></methods><methods><class-id>Net.MimeBuildHandler class</class-id> <category>default values</category><body package="MIME">removeContentTransferEncodingValue	^self defaultOptionsType removeContentTransferEncodingValue</body></methods><methods><class-id>Net.QuotedPrintableDecoder</class-id> <category>private</category><body package="MIME">checkAtEnd"This is called at the end of the underlying stream and is meant to check that the encoding of the last bytes was complete, that there isn't anything left over unfinished."		digit isZero ifFalse: [ self incompleteHexEncoding ].	^true</body><body package="MIME">incompleteHexEncoding	EncodingFailure new 		messageText: (			#IncompleteQuotedPrintableEncoding &lt;&lt; #net &gt;&gt;			'Hexadecimal character code must have two digits in quoted-printable encoding!');		parameter: octet;		raise</body><body package="MIME">invalidHexEncoding: char	EncodingFailure new 		messageText: (			(#InvalidQuotedPrintableEncoding1p &lt;&lt; #net &gt;&gt;			'&lt;1p&gt; is not a valid hexadecimal digit in quoted-printable encoding!')				expandMacrosWith: char);		parameter: char;		raise</body><body package="MIME">shouldBeRepresentedLiterally: byte	"we need to quote initial periods on the line, because if it happens to be the only character on the line, an SMTP server will interpret it as end of DATA"	(byte == 46 "$." and: [ offset == 1 ]) ifTrue: [^false].	^((byte between: 33 and: 126) and: [ byte ~~ 61 "$=" ])	or: [ byte ==  32 "SPC" or: [ byte == 9 "TAB" ]]</body></methods><methods><class-id>Net.QuotedPrintableDecoder</class-id> <category>accessing</category><body package="MIME">lineLength	^lineLength ifNil: [ self class defaultLineLength ]</body><body package="MIME">lineLength: length"	&lt;Integer&gt; specifies the line length where to emit CR and wrap to the next line when encoding"	lineLength := length</body><body package="MIME">nextFrom: aStream	offset &lt; 0 ifTrue: [ "finish soft line break"		offset := 0.		^CR ].	digit &gt; 0	ifTrue: [ | char | "finish encoding a non ASCII character"		char := digit = 1				ifTrue: [ octet bitShift: -4 ]				ifFalse: [ octet bitAnd: 16rF ].		char := '0123456789ABCDEF' at: (char + 1).		digit := (digit + 1) \\ 3.		offset := offset + 1.		^char ].	offset &lt; self lineLength ifFalse: [ "start a soft line break"		offset := -1.		^$= ].	octet := aStream next.	octet = 13 "CR" ifTrue: [ "preserve hard line break"		offset := 0.		^CR].	octet = 10 "LF" ifTrue: [ "preserve hard line break"		offset := 0.		^LF].	offset := offset + 1.	^(self shouldBeRepresentedLiterally: octet)		ifTrue: [ octet asCharacter ]		ifFalse: [ digit := 1. $= ]</body><body package="MIME">nextPut: char on: stream	digit &gt; 0		ifTrue: [			(digit = 1 and: [ char = CR or: [ char = LF] ]) ifTrue: [ digit := 0. ^char ].			('0123456789ABCDEFabcdef' includes: char)				ifFalse: [ ^self invalidHexEncoding: char ].			octet := (octet bitShift: 4) + char digitValue.			digit := digit + 1.			digit &gt; 2 ifTrue: [				stream nextPut: octet.				octet := digit := 0 ] ]		ifFalse: [			char = $=				ifTrue: [ digit := 1 ]				ifFalse: [ stream nextPut: char asInteger ] ]</body><body package="MIME">reset	digit := 0.	octet := 0.	offset := 0.</body></methods><methods><class-id>Net.QuotedPrintableDecoder</class-id> <category>printing</category><body package="MIME">encoding	^#'quoted-printable'</body></methods><methods><class-id>Net.QuotedPrintableDecoder class</class-id> <category>accessing</category><body package="MIME">defaultLineLength	^defaultLineLength ifNil: [ self defaultLineLengthValue ]</body><body package="MIME">defaultLineLength: length"	length &lt;Integer&gt; specifies the default line length where to emit CR and wrap to the next line when encoding"	defaultLineLength := length</body><body package="MIME">defaultLineLengthValue	^76</body><body package="MIME">streamEncodingType	^nil</body></methods><methods><class-id>Net.QuotedPrintableDecoder class</class-id> <category>instance creation</category><body package="MIME">new: symbol	^symbol = #'quoted-printable'		ifTrue: [ self asEncoder ]		ifFalse: [ super new: symbol ]</body></methods><methods><class-id>Net.BodyStream</class-id> <category>testing</category><body package="MIME">atEnd	^position &gt;= readLimit  or: [ stream atEnd ]</body><body package="MIME">isReadable	^true</body><body package="MIME">isWritable	"Answer whether the stream implements #nextPut:."	^false</body></methods><methods><class-id>Net.BodyStream</class-id> <category>printing</category><body package="MIME">printDetailsOn: aStream	aStream nextPutAll: ' position: ', position printString.	16rFFFFFFFF = readLimit 		ifFalse: [ aStream nextPutAll:  ' readLimit: ', readLimit printString ]</body></methods><methods><class-id>Net.BodyStream</class-id> <category>accessing</category><body package="MIME">next	(self atEnd or: [ stream atEnd ]) ifTrue: [self pastEnd].	position := position + 1.	^stream next</body></methods><methods><class-id>Net.BodyStream</class-id> <category>initialize-release</category><body package="MIME">initializeOn: aStream length: aNumber	stream := aStream.	stream binary.	readLimit := (aNumber isNil		ifTrue: [16rFFFFFFFF]		ifFalse: [ aNumber ]).	position := 0.</body></methods><methods><class-id>Net.BodyStream class</class-id> <category>instance creation</category><body package="MIME">on: aStream length: aNumber	^self basicNew initializeOn: aStream length: aNumber</body></methods><methods><class-id>Net.MimeDispatcherWritingOptions</class-id> <category>accessing</category><body package="MIME">headerOnly	^headerOnly ifNil: [self class defaultHeaderOnlyValue ]</body><body package="MIME">headerOnly: aBoolean		headerOnly := aBoolean</body><body package="MIME">newPrinter	^self printerClass with: self</body><body package="MIME">newWriter	^self writerClass with: self</body><body package="MIME">printerClass	^printerClass ifNil: [printerClass := self class defaultPrinterType]</body><body package="MIME">printerClass: aMimePrintHandler	^printerClass := aMimePrintHandler</body><body package="MIME">writerClass	^writerClass ifNil: [writerClass := self class defaultWriterType]</body><body package="MIME">writerClass: aMimeWriteHandler	^writerClass := aMimeWriteHandler</body></methods><methods><class-id>Net.MimeDispatcherWritingOptions class</class-id> <category>defaults</category><body package="MIME">defaultPrinterType	^MimePrintHandler</body><body package="MIME">defaultWriterType	^MimeWriteHandler</body></methods><methods><class-id>Net.MimeDispatcherWritingOptions class</class-id> <category>default values</category><body package="MIME">defaultHeaderOnlyValue	^false</body></methods><methods><class-id>Net.RFC822Message</class-id> <category>accessing</category><body package="MIME">bcc	^self getValueFor: 'bcc' ifAbsent: [ OrderedCollection new ]</body><body package="MIME">bcc: aStringOrList	^self setAddressesAt: 'bcc' to: aStringOrList</body><body package="MIME">bccSendStrings	^self encodedStringAt: 'bcc'</body><body package="MIME">cc	^self getValueFor: 'cc' ifAbsent: [ OrderedCollection new ]</body><body package="MIME">cc: aStringOrList	^self setAddressesAt: 'cc' to: aStringOrList</body><body package="MIME">ccSendStrings	^self encodedStringAt: 'cc'</body><body package="MIME">comments	^self getValueFor: 'comments'</body><body package="MIME">date	^self fieldValueAt: 'date'</body><body package="MIME">date: aTimestampOrString	^(self getFieldAt: 'date') value: aTimestampOrString</body><body package="MIME">dateSendString	^self encodedStringAt: 'cc'</body><body package="MIME">destinationAddresses" Answer collection of destination addresses. These addresses have been preprocessedto make them good for SMTP transport. This means removing everything but address-spec and encoding alias based on the message charset "	| coll f |	coll := OrderedCollection new.	self destinationFields 		do: [ :fn |  			(f := self fieldAt: fn ifAbsent: [nil]) ~~ nil				ifTrue: [ coll addAll: (f addressesEncodedWith: self headerCharset)]].	^coll</body><body package="MIME">destinationFields" Answer collection of fields that contain message destination addresses "	^#('to' 'cc' 'bcc')</body><body package="MIME">encrypted	^self getValueFor: 'encrypted'</body><body package="MIME">from	^self getValueFor: 'from' ifAbsent: [ OrderedCollection new ]</body><body package="MIME">from: aStringOrList	^self setAddressesAt: 'from' to: aStringOrList</body><body package="MIME">fromSendStrings	^self encodedStringAt: 'from'</body><body package="MIME">id	^self fieldValueAt: 'message-id'</body><body package="MIME">id: aString	^(self getFieldAt: 'message-id') value: aString</body><body package="MIME">inReplyTo	^self getValueFor: 'in-reply-to' ifAbsent: [ OrderedCollection new ]</body><body package="MIME">inReplyTo: aStringOrList	^self setAddressesAt: 'in-reply-to' to: aStringOrList</body><body package="MIME">inReplyToSendString	^self encodedStringAt: 'in-reply-to'</body><body package="MIME">keywords	^self getValueFor:  'keywords'</body><body package="MIME">messageID	^self getValueFor: 'message-id'</body><body package="MIME">reference	^self getValueFor: 'reference'</body><body package="MIME">replyTo	^self getValueFor: 'reply-to' ifAbsent: [ OrderedCollection new ]</body><body package="MIME">replyTo: aStringOrList	^self setAddressesAt: 'reply-to' to: aStringOrList</body><body package="MIME">replyToSendStrings	^self encodedStringAt: 'reply-to'</body><body package="MIME">resentBcc	^self getValueFor: 'resent-bcc' ifAbsent: [ OrderedCollection new ]</body><body package="MIME">resentBcc: aStringOrList	^self setAddressesAt: 'resent-bcc' to: aStringOrList</body><body package="MIME">resentBccSendStrings	^self encodedStringAt: 'resent-bcc'</body><body package="MIME">resentCc	^self getValueFor: 'resent-cc' ifAbsent: [ OrderedCollection new ]</body><body package="MIME">resentCc: aStringOrList	^self setAddressesAt: 'resent-cc' to: aStringOrList</body><body package="MIME">resentCcSendStrings	^self encodedStringAt: 'resent-cc'</body><body package="MIME">resentDate	^self getValueFor: 'resent-date'</body><body package="MIME">resentFrom	^self getValueFor: 'resent-from'</body><body package="MIME">resentFrom: aStringOrList	^self setAddressesAt: 'resent-from' to: aStringOrList</body><body package="MIME">resentFromSendStrings	^self encodedStringAt: 'resent-from'</body><body package="MIME">resentMessageID	^self getValueFor: 'resent-message-id'</body><body package="MIME">resentReplyTo	^self getValueFor: 'resent-reply-to'</body><body package="MIME">resentReplyTo: aStringOrList	^self setAddressesAt: 'resent-reply-to' to: aStringOrList</body><body package="MIME">resentReplyToSendStrings	^self encodedStringAt: 'resent-reply-to'</body><body package="MIME">resentSender	^self getValueFor: 'resent-sender'</body><body package="MIME">resentSender: aStringOrList	^self setAddressesAt: 'resent-sender' to: aStringOrList</body><body package="MIME">resentTo	^self getValueFor: 'resent-to' ifAbsent: [ OrderedCollection new ]</body><body package="MIME">resentTo: aStringOrList	^self setAddressesAt: 'resent-to' to: aStringOrList</body><body package="MIME">resentToSendStrings	^self encodedStringAt: 'resent-to'</body><body package="MIME">returnPath	^self getValueFor: 'return-path'</body><body package="MIME">sender	^self getValueFor: 'sender'</body><body package="MIME">setAddressesAt: fieldName to: aStringOrList	| addresses |	addresses := self addressesFrom: aStringOrList. 	^(self getFieldAt: fieldName) addresses: addresses</body><body package="MIME">status	^self getValueFor: 'status'</body><body package="MIME">subject	^self getValueFor: 'subject'</body><body package="MIME">subject: aString	^self fieldValueAt: 'subject' put: aString</body><body package="MIME">subjectSendString	^self encodedStringAt: 'subject'</body><body package="MIME">timestamp	^(self fieldAt: 'date' ifAbsent: [^nil]) timestamp</body><body package="MIME">timestamp: aTimestamp	^(self getFieldAt: 'date') timestamp: aTimestamp</body><body package="MIME">to	^self getValueFor: 'to' ifAbsent: [ OrderedCollection new ]</body><body package="MIME">to: aStringOrList	^self setAddressesAt: 'to' to: aStringOrList</body><body package="MIME">toSendStrings	^self encodedStringAt: 'to'</body></methods><methods><class-id>Net.RFC822Message</class-id> <category>transfer encodings</category><body package="MIME">transferFieldOrder" rfc822 recommends field order (if present) to be as follows. Order for remaining fiedls does not matter "	^#('return-path' 'received' 'date' 'from' 'subject' 'sender' 'to' 'cc' 'mime-version' 'content-type' 'content-length' 'content-transfer-encoding' )</body></methods><methods><class-id>Net.RFC822Message</class-id> <category>private</category><body package="MIME">encodedStringAt: fieldName	^(self getFieldAt: fieldName) addressesEncodedWith: self headerCharset</body></methods><methods><class-id>Net.RFC822Message</class-id> <category>visiting</category><body package="MIME">acceptVisit: aVisitor with: argument	^aVisitor acceptMessage: self with: argument</body></methods><methods><class-id>Net.RFC822Message</class-id> <category>parsing</category><body package="MIME">addressesFrom: aListOrString" RFC822Message new addressesFrom: 'George Jones &lt;Group@Some-Reg.An-Org&gt;,                 Al.Neuman@MAD.Publisher' "	" Canonicalize addresses "	| coll addresses scanner addrDescr |	coll := aListOrString isString		ifTrue: [ OrderedCollection with: aListOrString]		ifFalse: [ aListOrString ].	addresses := OrderedCollection new.	coll do: 		[ :addr |		addr isString			ifTrue: [(scanner := NetworkAddressDescriptor scannerType on: addr readStream) 						acceptNonAsciiCharacters: true.					addrDescr := [ scanner parseAddressesSeparatedBy: $,]									on: Error									do: [ :ex | 										(InvalidAddressSpec 											raiseRequestWith: scanner											errorString: ((#ErrorParsingAddressString &lt;&lt; #net &gt;&gt; 'Error parsing address string: &lt;1s&gt; &lt;2s&gt;') expandMacrosWith: addr with:ex description)) 											ifNotNil: [ :addColl | addColl ]											ifNil: [ OrderedCollection  with: ( UnparsedHeaderValue new																			errorDescription: ex description;																			source: scanner source;																			errorPosition: scanner position;																			yourself ) ]].					addresses addAll: addrDescr ]			ifFalse: [addresses add: addr]]. 	^addresses</body></methods><methods><class-id>Net.BoundedStream</class-id> <category>accessing</category><body package="MIME">boundary	^boundary</body><body package="MIME">boundaryDashes	^boundaryDashes</body><body package="MIME">flush	stream flush</body></methods><methods><class-id>Net.BoundedStream</class-id> <category>initialize-release</category><body package="MIME">initializeOn: aStream boundary: aString	stream := aStream. 	stream binary.	boundaryDashes := MultipartBody boundaryDashes asByteArrayEncoding: NetConnection defaultEncoding.	self setBoundary:aString.</body><body package="MIME">setBoundary: aString	boundary := (self lineEnd asString, MultipartBody boundaryDashes , aString) 					asByteArrayEncoding: #'ISO8859_1'.</body></methods><methods><class-id>Net.BoundedStream class</class-id> <category>instance creation</category><body package="MIME">on: aStream boundary: aString	^self basicNew initializeOn: aStream boundary: aString</body></methods><methods><class-id>Net.MailboxListField</class-id> <category>private</category><body package="MIME">sanitize: aCollection" Make sure collection of addresses is comprised of strings "	^aCollection collect: [:address | self sanitizeAddress: address]</body><body package="MIME">sanitize: aCollection encoding: aString" Make sure collection of addresses is comprised of strings "	^aCollection collect: [:address | self sanitizeAddress: address encoding: aString ]</body></methods><methods><class-id>Net.MailboxListField</class-id> <category>parsing</category><body package="MIME">doParse: rfc822Stream " HeaderField fromLine: 'To       :  George Jones &lt;Group@Some-Reg.An-Org&gt;,                 Al.Neuman@MAD.Publisher' "	| pos scanner stream |	pos := rfc822Stream position.	[scanner := self parseAddresses: rfc822Stream.	scanner currentComment ifNotNil: [ :comm |		stream := (String new: 64) writeStream.		comm do: [:part | stream nextPutAll: part]			separatedBy: [stream space].			comment := stream contents].	]		on: Error		do: [ :ex | self 					handleError: ex 					stream: rfc822Stream 					position: pos ]. 	^(self sanitize: addresses) asOrderedCollection</body><body package="MIME">handleError: ex stream: rfc822Stream position: position	addresses := OrderedCollection with: (UnparsedHeaderValue new								errorDescription: ex description;								source: (rfc822Stream position: position; nextLine) readStream;								yourself )</body><body package="MIME">newScannerFrom: rfc822Stream	^NetworkAddressDescriptor scannerType newFrom: rfc822Stream.</body><body package="MIME">parseAddresses: rfc822Stream " HeaderField fromLine: 'To       :  George Jones &lt;Group@Some-Reg.An-Org&gt;,                 Al.Neuman@MAD.Publisher' "	| scanner |	scanner := self newScannerFrom: rfc822Stream.	addresses := scanner parseAddressesSeparatedBy: $,.	^scanner</body></methods><methods><class-id>Net.MailboxListField</class-id> <category>accessing</category><body package="MIME">addAddress: aString	^self addAddresses: (OrderedCollection with: aString)</body><body package="MIME">addAddresses: aCollection	addresses addAll: aCollection.	self values addAll: (self sanitize: aCollection)</body><body package="MIME">addresses	^addresses</body><body package="MIME">addresses: aCollection	 addresses := aCollection.	self values: (self sanitize: aCollection)</body><body package="MIME">addressesEncodedWith: aString	^self addresses collect: [ :addressDesc | addressDesc stringWithEncoding: aString ]</body><body package="MIME">values" Multi-valued fields override this method "	^value</body><body package="MIME">values: aCollection" Multi-valued fields override this method "	value := aCollection</body></methods><methods><class-id>Net.MailboxListField</class-id> <category>composing</category><body package="MIME">writeAddressesOn: aStream encoding: aString	self addresses		do: [:addr | addr writeOn: aStream encoding: aString ]		separatedBy: [aStream nextPut: self class addressSeparator].</body><body package="MIME">writeStructureOn: aStream encoding: aString	self writeAddressesOn: aStream encoding: aString.</body></methods><methods><class-id>Net.MailboxListField</class-id> <category>printing</category><body package="MIME">printAddressesOn: aStream	self class printAddressList: (self sanitize: self addresses) on: aStream.	self printCommentOn: aStream</body><body package="MIME">printStructureOn: aStream	self printAddressesOn: aStream.</body></methods><methods><class-id>Net.MailboxListField</class-id> <category>initialization</category><body package="MIME">initialize	super initialize.	value := OrderedCollection new.	addresses := OrderedCollection new</body></methods><methods><class-id>Net.MailboxListField class</class-id> <category>printing</category><body package="MIME">addressSeparator	^$,</body><body package="MIME">printAddressList: collection on: aStream	collection		do: [:addr | aStream nextPutAll: addr]		separatedBy: [aStream nextPut: self addressSeparator]</body></methods><methods><class-id>Net.MailboxListField class</class-id> <category>parsing</category><body package="MIME">fieldNames	^#('from' 'to' 'reply-to' 'cc' 'bcc' 'resent-reply-to' 'resent-from' 'resent-to' 'resent-cc' 'resent-bcc' )</body></methods><methods><class-id>Net.SingleMailboxField</class-id> <category>printing</category><body package="MIME">addressString	^self asString</body><body package="MIME">asString	^self address printString</body></methods><methods><class-id>Net.SingleMailboxField</class-id> <category>accessing</category><body package="MIME">address	^self addresses isEmpty		ifTrue: [nil]		ifFalse: [self addresses first]</body><body package="MIME">address: aNetworkAddressDescriptor	addresses := Array with: aNetworkAddressDescriptor.	self value: (Array with: (self sanitizeAddress: aNetworkAddressDescriptor))</body><body package="MIME">value" Multi-valued fields override this method "	^value isEmpty		ifTrue: [ nil ]		ifFalse: [ value first ]</body><body package="MIME">value: aString	value := OrderedCollection with: aString</body></methods><methods><class-id>Net.SingleMailboxField</class-id> <category>parsing</category><body package="MIME">parseAddresses: rfc822Stream " HeaderField fromLine: 'Sender :		Phil Campbell (The great) &lt;philc@yahoo.com&gt;' "	| scanner |	scanner := self newScannerFrom: rfc822Stream.	addresses := (Array with: scanner parseAddress).	^scanner</body></methods><methods><class-id>Net.SingleMailboxField class</class-id> <category>parsing</category><body package="MIME">fieldNames"resent-sender   =   'Resent-Sender:' mailbox CRLFsender          =   'Sender:' mailbox CRLF "	^#('sender' 'resent-sender' )</body></methods><methods><class-id>Net.MimeReadingOptions</class-id> <category>accessing</category><body package="MIME">acceptNonAsciiCharacters	^acceptNonAsciiCharacters ifNil: [self scannerType acceptNonAsciiCharacters]</body><body package="MIME">acceptNonAsciiCharacters: aBoolean	acceptNonAsciiCharacters := aBoolean</body><body package="MIME">attachmentDirectory	^attachmentDirectory ifNil: [ self defaultAttachmentDirectory asFilename ]</body><body package="MIME">attachmentDirectory: aStringOrFilename	attachmentDirectory := aStringOrFilename asFilename</body><body package="MIME">builderClass	^builderClass ifNil: [builderClass := self class defaultBuilderType ]</body><body package="MIME">builderClass: aMimeBuildHandler		builderClass := aMimeBuildHandler</body><body package="MIME">fieldFactory" Answer field factory or default field factory if none is specified. Different protocols may have different field factories  "	^fieldFactory ifNil: [fieldFactory := self defaultFieldFactory ]</body><body package="MIME">fieldFactory: anObject" Set field factory. Different protocols may have different field factories. Field factory should respond to messages:	readFrom: 	readNameFrom:	scannerType	fieldClassForName:"	fieldFactory := anObject</body><body package="MIME">headerOnly	^headerOnly ifNil: [ self class defaultHeaderOnlyValue]</body><body package="MIME">headerOnly: aBoolean 	headerOnly := aBoolean</body><body package="MIME">messageHeaderClass" Answer message header class "	^messageHeaderClass ifNil: [ messageHeaderClass := self defaultMessageHeaderClass ]</body><body package="MIME">messageHeaderClass: aClass" Set message header class "	messageHeaderClass := aClass</body><body package="MIME">newBuilder	^self builderClass with: self</body><body package="MIME">removeContentTransferEncoding	^removeContentTransferEncoding ifNil: [removeContentTransferEncoding := self class removeContentTransferEncoding].</body><body package="MIME">removeContentTransferEncoding: aBoolean	removeContentTransferEncoding := aBoolean</body><body package="MIME">saveAttachmentsAsFiles	^saveAttachmentsAsFiles ifNil: [saveAttachmentsAsFiles := self class saveAttachmentsAsFiles]</body><body package="MIME">saveAttachmentsAsFiles: aBoolean	saveAttachmentsAsFiles := aBoolean</body><body package="MIME">scannerType	^scannerType  ifNil: [ scannerType := self defaultScannerType ]</body><body package="MIME">scannerType: aClass	scannerType := aClass</body></methods><methods><class-id>Net.MimeReadingOptions</class-id> <category>defaults</category><body package="MIME">defaultAttachmentDirectory	^self class defaultAttachmentDirectory.</body><body package="MIME">defaultEncoding	^#ISO8859_1</body><body package="MIME">defaultFieldFactory	^HeaderField</body><body package="MIME">defaultMessageHeaderClass	^MessageHeader</body><body package="MIME">defaultPartEntityType	^MimeEntity</body><body package="MIME">defaultRootEntityType	^MimeEntity</body><body package="MIME">defaultScannerType	^MimeScanner</body></methods><methods><class-id>Net.MimeReadingOptions class</class-id> <category>defaults</category><body package="MIME">defaultAttachmentDirectory	defaultAttachmentDirectory ifNil: [defaultAttachmentDirectory := LogicalFilename named: self defaultAttachmentDirectoryValue].	defaultAttachmentDirectory asFilename ensureDirectory.	^defaultAttachmentDirectory</body><body package="MIME">defaultAttachmentDirectory: aLogicalFilenameOrString	aLogicalFilenameOrString isString		ifTrue: [ defaultAttachmentDirectory := LogicalFilename named: aLogicalFilenameOrString ]		ifFalse: [ defaultAttachmentDirectory := aLogicalFilenameOrString ]</body><body package="MIME">defaultAttachmentDirectoryString	^self defaultAttachmentDirectory asString</body><body package="MIME">defaultAttachmentDirectoryString: aString 	^self defaultAttachmentDirectory: aString</body><body package="MIME">defaultBuilderType	^MimeBuildHandler</body><body package="MIME">removeContentTransferEncoding	^removeContentTransferEncoding ifNil: [ self removeContentTransferEncodingValue ]</body><body package="MIME">removeContentTransferEncoding: aBoolean	removeContentTransferEncoding := aBoolean</body><body package="MIME">saveAttachmentsAsFiles	" (self  saveAttachmentsAsFiles) "	^saveAttachmentsAsFiles ifNil: [saveAttachmentsAsFiles := self saveAttachmentsAsFilesValue]</body><body package="MIME">saveAttachmentsAsFiles: aBoolean	" (self  saveAttachmentsAsFiles: nil) "	saveAttachmentsAsFiles := aBoolean</body></methods><methods><class-id>Net.MimeReadingOptions class</class-id> <category>default values</category><body package="MIME">defaultAttachmentDirectoryValue	^'temp-files'</body><body package="MIME">defaultHeaderOnlyValue	^false</body><body package="MIME">removeContentTransferEncodingValue	^false</body><body package="MIME">saveAttachmentsAsFilesValue	^false</body></methods><methods><class-id>Net.BoundedWriteStream</class-id> <category>accessing</category><body package="MIME">endPart	stream 		binary;		nextPutAll: self lineEnd.</body><body package="MIME">nextPut: anObject 		stream nextPut: anObject</body><body package="MIME">startPart	stream 		binary;		nextPutAll: self boundary;		nextPutAll: self lineEnd.</body><body package="MIME">stream	^stream</body><body package="MIME">writeConclusion	stream 		binary;		nextPutAll:  self boundary;		nextPutAll: self boundaryDashes;		nextPutAll: self lineEnd</body></methods><methods><class-id>Net.BoundedWriteStream</class-id> <category>testing</category><body package="MIME">isReadable	^false</body><body package="MIME">isWritable	"Answer whether the stream implements #nextPut:."	^true</body></methods><methods><class-id>Net.BoundedWriteStream</class-id> <category>status</category><body package="MIME">finish	stream finish.</body></methods><methods><class-id>Net.BoundedWriteStream</class-id> <category>initialize-release</category><body package="MIME">setBoundary: aString	boundary := (MultipartBody boundaryDashes , aString) 					asByteArrayEncoding: NetConnection defaultEncoding.</body></methods><methods><class-id>Net.BoundedWriteCharacterStream</class-id> <category>accessing</category><body package="MIME">endPart	stream cr.</body><body package="MIME">startPart	stream 		nextPutAll: self boundary;		cr</body><body package="MIME">writeConclusion	stream 		nextPutAll:  self boundary;		nextPutAll: self boundaryDashes;		cr</body></methods><methods><class-id>Net.BoundedWriteCharacterStream</class-id> <category>initialize-release</category><body package="MIME">initializeOn: aStream boundary: aString	stream := aStream. 	boundaryDashes := MultipartBody boundaryDashes.	self setBoundary:aString.</body><body package="MIME">setBoundary: aString	boundary := MultipartBody boundaryDashes , aString</body></methods><methods><class-id>Net.EntityException class</class-id> <category>testing</category><body package="MIME">mayResume	^true</body></methods><methods><class-id>Net.ReturnPath</class-id> <category>printing</category><body package="MIME">asString	^self address printString</body></methods><methods><class-id>Net.ReturnPath</class-id> <category>private</category><body package="MIME">sanitize: aCollection		^self isEmptyAddress 		ifTrue: [ self values ]		ifFalse: [ super sanitize: aCollection ]</body></methods><methods><class-id>Net.ReturnPath</class-id> <category>testing</category><body package="MIME">isEmptyAddress		^self value = self emptyAddress</body></methods><methods><class-id>Net.ReturnPath</class-id> <category>parsing</category><body package="MIME">handleError: error stream: rfc822Stream position: position	(InvalidAddressSpec handles: error)		ifTrue: [value := addresses := OrderedCollection with: self emptyAddress]		ifFalse: [super handleError: error stream: rfc822Stream position: position]</body></methods><methods><class-id>Net.ReturnPath</class-id> <category>composing</category><body package="MIME">writeStructureOn: aStream encoding: aString		self isEmptyAddress		ifTrue: [ aStream nextPutAll: self value ]		ifFalse: [ super writeStructureOn: aStream encoding: aString].</body></methods><methods><class-id>Net.ReturnPath</class-id> <category>accessing</category><body package="MIME">emptyAddress		^'&lt;&gt;'</body></methods><methods><class-id>Net.ReturnPath class</class-id> <category>parsing</category><body package="MIME">fieldNames"return          =   'Return-Path:' path CRLFpath            =   angle-addr / ([CFWS] '&lt;' [CFWS] '&gt;' [CFWS])"	^#( 'return-path' )</body></methods><methods><class-id>Net.MimeOutputHandler</class-id> <category>printing utilities</category><body package="MIME">printHeader: aMessageHeader	(self  selectFieldsFrom: aMessageHeader )		do: [ :field | self printHeaderField: field ]</body><body package="MIME">printHeaderField: aHeaderField" Get string representation of the field, make sure all lines are withing max line length and write all this on output stream. Lines may be folded to fit into max length (cr followed by tab is inserted). Field itself may fold lines, so field's representation is first broken into lines and then each line is folded if necessary. a cr is written at the end even if the field's source did not have cr "	(self fieldValueAsStreamFor: aHeaderField)		linesDo: [ :line | self printLine: line]</body><body package="MIME">printLine: aString	self stream nextPutAll: aString.	self stream cr</body><body package="MIME">printPreambule: aMessageBody" Print preamble if any "	| aStream |	(aStream := aMessageBody preamble) notNil		ifTrue: [ aStream linesDo: [:line | self printLine: line ]].	^true</body></methods><methods><class-id>Net.MimeOutputHandler</class-id> <category>private</category><body package="MIME">fieldStream" field stream is used to convert field values into streams. field stream is reused for performance reasons "	^fieldStream ifNil: [fieldStream := (String new: 256) writeStream]</body><body package="MIME">fieldValueAsStreamFor: aHeaderField	aHeaderField printOn: self fieldStream reset.	^self fieldStream contents readStream</body><body package="MIME">finishEmptyBodyMessage: anEntity</body><body package="MIME">prepareHeader: aMimeEntity	self setBoundary: aMimeEntity</body><body package="MIME">selectFieldsFrom: aMessageHeader	^aMessageHeader fieldsInOrder: aMessageHeader parent transferFieldOrder</body><body package="MIME">setBoundary: aMimeEntity 	aMimeEntity needsBoundary		ifTrue: [aMimeEntity boundary: (self defaultBoundaryFor: aMimeEntity)].</body><body package="MIME">writeFrom: sourceStream to: destStream	| buffer count textMode |	textMode := sourceStream isBinary not.	sourceStream binary.	destStream binary.	buffer := ByteArray new: 1024.	[		[sourceStream atEnd] 			whileFalse: 				[count := sourceStream nextAvailable: buffer size into: buffer startingAt: 1.				destStream next: count putAll: buffer startingAt: 1 ]	] ensure: 		[textMode ifTrue: [sourceStream text].		destStream text ]</body></methods><methods><class-id>Net.MimeOutputHandler</class-id> <category>accessing</category><body package="MIME">popStream	^self streams size &gt; 0 ifTrue: [ self streams removeFirst ]</body><body package="MIME">pushStream: aStream	^self streams addFirst: aStream</body><body package="MIME">stream	^self streams first</body><body package="MIME">streams	^streams ifNil: [ streams := OrderedCollection new]</body></methods><methods><class-id>Net.MimeOutputHandler</class-id> <category>action callbacks</category><body package="MIME">endHeader: aMessageHeader	self stream cr.	^aMessageHeader parent</body><body package="MIME">endMessage: aMessage	"finish stream output but do not close the stream" 	self stream finish</body><body package="MIME">endMultipartBody: aMessageBody" Prints end of boundary for a multipart message "	self stream writeConclusion.	self popStream.</body><body package="MIME">endPart: aMimeEntity	self stream endPart.</body><body package="MIME">shouldStartBody: aMessageBody	^self headerOnly not and: [aMessageBody notEmpty ]</body><body package="MIME">startEntity: aMimeEntityOrNil	^aMimeEntityOrNil</body><body package="MIME">startHeader: aMessageHeader 	"Print header fields"	self 		prepareHeader: aMessageHeader parent;		printHeader: aMessageHeader.</body><body package="MIME">startMessageBody: aMessage	| streamx |	streamx := self prepareStream: self stream forMessageBody: aMessage.	self popStream.	self pushStream: streamx.	"print preambule if any "	self printPreambule: aMessage body.</body><body package="MIME">startMultipartBody: aMultipartBody	| bodyStream |	bodyStream :=		BoundedWriteStream			on: self stream			boundary: aMultipartBody parent boundary.	self pushStream: bodyStream.</body><body package="MIME">startPart: aMimeEntity	self stream startPart.</body></methods><methods><class-id>Net.MimeOutputHandler</class-id> <category>private prepare streams</category><body package="MIME">prepareStream: aStream	self pushStream: ( aStream 							asEncodedStreamWithEncoding: self defaultEncoding 							lineEndConvention: LineEndCRLF ).	self stream text; lineEndCRLF.</body><body package="MIME">prepareStream: aStream forMessageBody: aMessage	^aStream</body></methods><methods><class-id>Net.MimeOutputHandler</class-id> <category>defaults</category><body package="MIME">defaultEncoding		^NetConnection defaultEncoding</body></methods><methods><class-id>Net.MimeOutputHandler class</class-id> <category>defaults</category><body package="MIME">defaultOptionsType	^MimeWritingOptions</body></methods><methods><class-id>Net.MimeWriteHandler</class-id> <category>private</category><body package="MIME">contentTransferEncodingFor: aMimeEntity	^aMimeEntity isBinary ifTrue: [ 'base64' ] ifFalse: [ 'quoted-printable' ]</body><body package="MIME">fieldValueAsStreamFor: aHeaderField	^(self preferFieldSource and: [aHeaderField source notNil])		ifTrue: [ aHeaderField source ]		ifFalse: [			aHeaderField writeOn: self fieldStream reset.			self fieldStream contents readStream ]</body><body package="MIME">prepareHeader: aMimeEntity"  http://www.faqs.org/rfcs/rfc1521.html Therefore, this document defines a new header field, MIME-Version,  which is to be used to declare the version of the Internet message body format standard in use. Messages composed in accordance with this document MUST include such a header field, with the following verbatim text:  MIME-Version: 1.0The version field will be added only for instances of the MailMessage class"	super prepareHeader: aMimeEntity.	aMimeEntity addMimeVersion.</body><body package="MIME">writeBodyContents: aBody on: aStream	| sourceStream destStream |	self pushStream: aStream. 	sourceStream :=  aBody parent notNil		ifTrue:  [aBody parent contentsStream]		ifFalse: [ aBody valueAsStream]. 	destStream := self stream.	sourceStream isByteStream ifTrue: [ destStream binary ].	sourceStream isCharacterStream ifTrue: [ destStream text ].	[		[sourceStream atEnd] 			whileFalse: 				[destStream nextPut: sourceStream next ]	] ensure: 		[sourceStream close ]</body></methods><methods><class-id>Net.MimeWriteHandler</class-id> <category>tasks</category><body package="MIME">writeMessage: aMimeEntity on: aStream 	self writeMessageElement: aMimeEntity on: aStream</body><body package="MIME">writeMessageElement: aMessageElement on: aStream	self prepareStream: aStream.	aMessageElement acceptVisit: self dispatcher with: nil.</body><body package="MIME">writeMessageHeaderFor: aMimeEntity on: aStream	self 		headerOnly: true; 		writeMessage: aMimeEntity on: aStream</body></methods><methods><class-id>Net.MimeWriteHandler</class-id> <category>printing utilities</category><body package="MIME">encodeBodySource: aSimpleBody as: encodingName"the method is used by SimpleBody to add transfer encoding "	| aStream outStream decStream | 	(#('base64' 'quoted-printable') includes: encodingName) ifFalse: [^self].	outStream := (ByteArray new 					withEncoding: aSimpleBody parent charset )					readWriteStream.	outStream lineEndCRLF.	aStream := aSimpleBody byteValueAsStream.	[decStream := (encodingName = 'base64' asLowercase		ifTrue: [	DecodedStream on: outStream  encodedBy: B64StreamDecoder asEncoder]		ifFalse: [ DecodedStream on: outStream encodedBy: QuotedPrintableDecoder asEncoder ]).	self writeFrom: aStream to: decStream. 	decStream finish.	]  ensure: 		[aStream ~~nil ifTrue: [ aStream close ]].	outStream reset.	aSimpleBody source: outStream</body><body package="MIME">printHeader: aMessageHeader	self stream text.	super printHeader: aMessageHeader</body></methods><methods><class-id>Net.MimeWriteHandler</class-id> <category>private prepare streams</category><body package="MIME">prepareStream: aStream		aStream isInternal ifFalse: [binaryMode := aStream isBinary].	super prepareStream: aStream.	originalStream := self stream</body><body package="MIME">prepareStream: aStream forSimpleBody: aMimeEntity	(self applyTransferEncoding not or: [ aMimeEntity hasContentTransferEncoding ]) ifTrue: [^aStream].	^aMimeEntity isTextContentType		ifTrue: [ (EncodedStream 					on: (DecodedStream on: aStream encodedBy: QuotedPrintableDecoder asEncoder) 					encodedBy: (StreamEncoder new: aMimeEntity charset  asSymbol)) 				lineEndConvention: LineEndCRLF ]		ifFalse: [ DecodedStream on: aStream encodedBy: B64StreamDecoder asEncoder.]</body></methods><methods><class-id>Net.MimeWriteHandler</class-id> <category>action callbacks</category><body package="MIME">endHeader: aMessageHeader	(aMessageHeader parent isSimple		and: [ self applyTransferEncoding  			and: [ aMessageHeader parent hasContentTransferEncoding not ]])			 ifTrue: [(ScalarField contentTransferEncoding: (self contentTransferEncodingFor: aMessageHeader parent)) writeOn: self stream.					self stream cr ].	self stream cr.	^aMessageHeader parent</body><body package="MIME">endMessage: aMessage	super endMessage: aMessage.	"restore the print stream original mode"	binaryMode ifNotNil: [ :mode |  mode ifFalse: [originalStream text]].</body><body package="MIME">startSimpleBody: aSimpleBody	| output |	output := self prepareStream: self stream forSimpleBody: aSimpleBody parent.	aSimpleBody writeOn: output.	output finish.</body></methods><methods><class-id>Net.MimeWriteHandler</class-id> <category>accessing</category><body package="MIME">applyTransferEncoding	^self options applyTransferEncoding</body><body package="MIME">applyTransferEncoding: aBoolean	self options applyTransferEncoding: aBoolean</body><body package="MIME">preferFieldSource" Answers true if field's source is preferred to its parsed values, false otherwise. If application resends, routes of forwards messages, all mail protocols strongly advise against and changes in message header fields. These changes are unavoidable if all fields are to be parsed and later composed when a message is resent/forwarded. In this situation a wise approach is to prefer source, so fields are copied to the output exactly the way thay have been received "	^self options preferFieldSource</body><body package="MIME">preferFieldSource: aBoolean	self options preferFieldSource: aBoolean</body></methods><methods><class-id>Net.MimeWriteHandler class</class-id> <category>instance creation</category><body package="MIME">write: message on: aStream	^self writeMessage: message on: aStream</body><body package="MIME">writeHeaderFor: message on: aStream	^self writeMessageHeaderFor: message on: aStream</body><body package="MIME">writeMessage: message on: aStream	^self new writeMessage: message on: aStream</body><body package="MIME">writeMessageHeaderFor: message on: aStream	^self new writeMessageHeaderFor: message on: aStream</body></methods><methods><class-id>Net.MimeWriteHandler class</class-id> <category>deprecated</category><body package="MIME">on: aStream" will be removed"	^self new		prepareStream: aStream</body></methods><methods><class-id>Net.MimeWriteHandler class</class-id> <category>defaults</category><body package="MIME">applyTransferEncoding	^self defaultOptionsType applyTransferEncoding</body><body package="MIME">applyTransferEncoding: aBoolean	self defaultOptionsType applyTransferEncoding: aBoolean</body><body package="MIME">defaultApplyTransferEncoding	^self defaultOptionsType  defaultApplyTransferEncoding</body></methods><methods><class-id>Net.MimeWritingOptions</class-id> <category>accessing</category><body package="MIME">applyTransferEncoding	^applyTransferEncoding  ifNil: [self class applyTransferEncoding ]</body><body package="MIME">applyTransferEncoding: anObject	applyTransferEncoding := anObject</body><body package="MIME">preferFieldSource" Answers true if field's source is preferred to its parsed values, false otherwise. If application resends, routes of forwards messages, all mail protocols strongly advise against and changes in message header fields. These changes are unavoidable if all fields are to be parsed and later composed when a message is resent/forwarded. In this situation a wise approach is to prefer source, so fields are copied to the output exactly the way thay have been received "	^preferFieldSource ifNil: [false]</body><body package="MIME">preferFieldSource: aBoolean	preferFieldSource := aBoolean</body></methods><methods><class-id>Net.MimeWritingOptions class</class-id> <category>accessing</category><body package="MIME">applyTransferEncoding	^applyTransferEncoding ifNil: [ self defaultApplyTransferEncoding ]</body><body package="MIME">applyTransferEncoding: aBoolean	applyTransferEncoding := aBoolean</body></methods><methods><class-id>Net.MimeWritingOptions class</class-id> <category>default values</category><body package="MIME">defaultApplyTransferEncoding	^true</body></methods><methods><class-id>Net.MimeEntityBot</class-id> <category>tasks</category><body package="MIME">addFileAttachmentFor: aMessage fileName: aFilename	| part |	aMessage addPart: (part := MimeEntity fileName: aFilename).	^part</body><body package="MIME">addFileAttachmentFor: aMessage fileName: aFilename withEncoding: aString	| part |	aMessage addPart: (part := MimeEntity fileName: aFilename withEncoding: aString).	^part</body><body package="MIME">applyTransferEncodingTo: part	self applyTransferEncodingTo: part encodeAs: self defaultEncodingName</body><body package="MIME">applyTransferEncodingTo: part encodeAs: encodingNameOrNil	| encoding |	encoding := encodingNameOrNil isNil 					ifTrue: [ part defaultTransferEncodingName ]					ifFalse: [encodingNameOrNil].	part addContentTransferEncoding: encoding.</body><body package="MIME">attachmentsFor: aMimeEntity 	^aMimeEntity isMultipart		ifTrue: [ aMimeEntity parts ]		ifFalse: [ OrderedCollection new ]</body><body package="MIME">checkStructure: aMimeEntity	" Make sure all fields are in order mandated by RFC822 "	self for: aMimeEntity partsDo: 		[ :part | part arrangeFieldsInOrder: aMimeEntity transferFieldOrder ].	aMimeEntity mimeVersion isNil		ifTrue: [aMimeEntity addMimeVersion].	" Make sure all parts have assigned boundaries "	self for: aMimeEntity partsDo: [ :part |		part needsBoundary			ifTrue: [part boundary: (self defaultBoundaryFor: part)]].</body><body package="MIME">defaultEncodingName	^'base64'</body><body package="MIME">makeMultipart: rfc822Message" Make single-part mail message a multipart one. Assumption that is madehere: aMimeEntity is a top-level RFC822 message. We create a new Mimeentity to contain message text and Mime fields (content-type, content-length, etc).These fields are removed from the top-level message and new content-type isset. This content type is somewhat arbitrarily set to miltipart/mixed. The messageis then given new miltipart body and new part is added to the body "	| messagePart |	messagePart := self makeSinglepartFrom: rfc822Message.	" Remove non-mime fields from the top-level message "	rfc822Message 		fields: (rfc822Message fields reject: [ :field |  'content*' match: field name ]);		contentType: 'multipart/mixed';		body: MultipartBody new.	messagePart ~~ nil		ifTrue: [ rfc822Message addPart: messagePart].	^rfc822Message</body><body package="MIME">makeSinglepart: rfc822Message textPart: textPart" Mutate multipart mail message into a single-part one. Assumption that is madehere: rfc822Message is a top-level RFC822 message that has only one part. We create new simple part and copy the part's contents into message contents.We then copy and all the part's fields into the top-level message fields. Simple bodybecomes the top level message's body "	" Merge fields from the part into the message "	textPart fields do: [ :field | rfc822Message addField: field ].	rfc822Message 		body: SimpleBody new;		contents: textPart contents.	^rfc822Message</body><body package="MIME">makeSinglepartFrom: aMimeEntity" Make single-part from mime entity. Return nil if mime entity has empty body and  header fields "	| messagePart chSet |	messagePart := MimeEntity new.	" Copy Mime fields from the message "	aMimeEntity fields 		do: [ :field | 			('content*' match: field name)				ifTrue: [ messagePart addField: field copy] ].	aMimeEntity contents notNil 		ifTrue: [ 	messagePart contents: aMimeEntity contents].	^(messagePart fields isEmpty and: [ messagePart contents == nil ])		ifTrue: [nil]		ifFalse: 			[(chSet := messagePart charset ) ~~ nil ifTrue: [ aMimeEntity charset: chSet ]. 			messagePart fields isEmpty ifTrue: [ messagePart charset: aMimeEntity defaultCharset].			messagePart]</body><body package="MIME">validate: aMimeEntity " Run sanity checks on an entity "	" 1. Validate structure "	self		for: aMimeEntity		partsDo: [:part | 			part body parent == part ifFalse: [ self error: (#BodyParentIsWrong &lt;&lt; #net &gt;&gt; 'Body parent is wrong') ].			part fields do: [ :field | field parent == part ifFalse: [ self error: (#FieldParentIsWrong &lt;&lt; #net &gt;&gt; 'Field parent is wrong') ]].			part parent notNil 				ifTrue: [ (part parent isMultipart and: [ part parent parts includes: part ])						ifFalse: [self error: (#InvalidMessageStructure &lt;&lt; #net &gt;&gt; 'Invalid message structure') ]].			(part isMultipart 				ifTrue: [ part body isMultipart ]				ifFalse: [ part body isSimple ])					ifFalse: [self error: (#BodyTypeMismatch &lt;&lt; #net &gt;&gt; 'Body type mismatch') ].			part isMultipart 				ifTrue: [part boundary notNil					ifFalse: [self error: (#ShouldHaveBoundary &lt;&lt; #net &gt;&gt; 'Should have boundary') ]].		].</body><body package="MIME">writeContentsOf: aMimeEntity on: anEncodedStream	aMimeEntity removeContentTransferEncoding.	aMimeEntity isBinary		ifTrue: [anEncodedStream binary]		ifFalse: [anEncodedStream text].	aMimeEntity writeContentsOn: anEncodedStream.</body></methods><methods><class-id>Net.MimeEntityBot</class-id> <category>enumerating</category><body package="MIME">for: aMimeEntity maxDepth: depthLimit partsDo: aBlock	self 		for: aMimeEntity 		while: [ :part | self level &lt;= (depthLimit - 1) ]		partsDo: aBlock</body><body package="MIME">for: aMimeEntity partsDetect: aBlock ifNone: exceptionBlock 	self		for: aMimeEntity		partsDo: [:part | (aBlock value: part) ifTrue: [^part]].	^exceptionBlock value</body><body package="MIME">for: aMimeEntity partsDo: aBlock	self for: aMimeEntity while: [ :part | true ] partsDo: aBlock</body><body package="MIME">for: aMimeEntity while: condBlock partsDo: aBlock 	self shouldCallback: [ :part |			(condBlock value: part)				ifTrue: [ true ]				ifFalse: [ self keepSearching: false. false] ];		doCallback: aBlock;		traverse: aMimeEntity.	^aMimeEntity</body><body package="MIME">traverse: aMimeEntity	self	initializeEntityStack;		keepSearching: true.	self dispatcher acceptMimeEntity: aMimeEntity with: nil.</body></methods><methods><class-id>Net.MimeEntityBot</class-id> <category>initialization</category><body package="MIME">initialize	super initialize.	keepSearching := true.	self initializeEntityStack</body><body package="MIME">initializeEntityStack	entityStack := OrderedCollection new.</body></methods><methods><class-id>Net.MimeEntityBot</class-id> <category>accessing</category><body package="MIME">doCallback	^doCallback</body><body package="MIME">doCallback: aMonadicBlock"		aMonadicBlock &lt;BlockContext&gt; invoked with a part to process it"	doCallback := aMonadicBlock</body><body package="MIME">entity"Returns currently processed entity."	^entityStack first</body><body package="MIME">level"Returns 'depth' of the currently processed part in the message structure."	^entityStack size</body><body package="MIME">shouldCallback	^shouldCallback</body><body package="MIME">shouldCallback: aMonadicBlock"		aMonadicBlock  &lt;BlockContext&gt; boolean block invoked with a part to decide if it should be processed or not"	shouldCallback := aMonadicBlock</body></methods><methods><class-id>Net.MimeEntityBot</class-id> <category>private</category><body package="MIME">entityStack	^entityStack</body><body package="MIME">keepSearching	^keepSearching</body><body package="MIME">keepSearching: aBoolean	keepSearching := aBoolean</body><body package="MIME">popEntity	^entityStack removeFirst</body><body package="MIME">pushEntity: entity	^entityStack addFirst: entity</body></methods><methods><class-id>Net.MimeEntityBot</class-id> <category>action callbacks</category><body package="MIME">endEntity: aMimeEntityOrNil		^self popEntity</body><body package="MIME">shouldStartEntity: aMimeEntityOrNil	^self shouldCallback isNil 		ifTrue: [true]		ifFalse: [self shouldCallback value: aMimeEntityOrNil]</body><body package="MIME">startEntity: aMimeEntityOrNil	self pushEntity: aMimeEntityOrNil.	self doCallback value: aMimeEntityOrNil.	^aMimeEntityOrNil</body></methods><methods><class-id>Net.NonClosingReadStream</class-id> <category>accessing</category><body package="MIME">binary	stream binary</body><body package="MIME">contents	^stream contents</body><body package="MIME">contentsSpecies	^stream contentsSpecies</body><body package="MIME">encoding	^stream encoding</body><body package="MIME">flush	self error: 'This stream is not writable!'</body><body package="MIME">next	^stream next</body><body package="MIME">nextPut: anObject	self error: 'This stream is not writable!'</body><body package="MIME">position	^stream position</body><body package="MIME">position: integer	stream position: integer</body><body package="MIME">reset	stream reset</body><body package="MIME">size	^stream size</body><body package="MIME">text	stream text</body></methods><methods><class-id>Net.NonClosingReadStream</class-id> <category>testing</category><body package="MIME">atEnd	^stream atEnd</body><body package="MIME">isBinary	^stream isBinary</body><body package="MIME">isReadable		^true</body><body package="MIME">isWritable	^false</body><body package="MIME">lineEndConvention	^stream lineEndConvention</body></methods><methods><class-id>Net.NonClosingReadStream</class-id> <category>initialize-release</category><body package="MIME">on: aStream	stream := aStream</body></methods><methods><class-id>Net.NonClosingReadStream class</class-id> <category>instance creation</category><body package="MIME">on: aStream	^self basicNew on: aStream</body></methods><methods><class-id>Net.NetworkAddressParser</class-id> <category>accessing</category><body package="MIME">descriptor	^descriptor</body><body package="MIME">descriptor: aValue	descriptor := aValue</body></methods><methods><class-id>Net.NetworkAddressParser</class-id> <category>private</category><body package="MIME">completeScanOfAddressSpecWith: partial" addr-spec   =  local-part &lt;@&gt; domain        ; global address  local-part = word *(&lt;.&gt; word) ; uninterpreted, case-preserved First local-part token was already scanned; we are now scanning *(&lt;.&gt; word) group and domain part.Partial is an array of tokens already read "	self stepBack.	token = $. 				"phil.campbell.wise@acme.com&gt;"		ifTrue:	["phrase is the first local part of the address"				self 					tokenizeWhile: [token == $.] 					do: [self nextToken.						(#(#quotedText #atom) includes: tokenType)							ifFalse: [self error: (#LocalPartExpectsDotAtom &lt;&lt; #net &gt;&gt; 'The local-part expects dot-atom or quoted-string')].						partial add: self currentTokenStruct]].	self setLocalPart:  partial.	self nextRFC822Token == $@ 		ifTrue: [self setDomain. ]		ifFalse:["an @ character must separate the local and domain parts"				^self notify: ((#AtCharacterMustSeparateLocalDomainParts &lt;&lt; #net &gt;&gt; 'An @ character must separate the local: (&lt;1s&gt;) and domain parts (&lt;2s&gt;)') expandMacrosWith: self descriptor localPartString with: token printString)].</body><body package="MIME">currentTokenStruct	^Struct new 		token: token; 		tokenType: tokenType; 		separator: hereChar; 		yourself</body><body package="MIME">decodePhrase: collOfStruct	| stream |	stream := String new writeStream.	MimeEncodedWordCoDec 		decodePhrase: (collOfStruct collect: [ :struct | struct token ])		printOn: stream.	^stream contents</body><body package="MIME">newAddressDescriptor	^NetworkAddressDescriptor new</body><body package="MIME">parseAddrSpec: phrase"  https://tools.ietf.org/html/rfc5322#section-3.4.1   addr-spec       =   local-part ''@'' domain   local-part      =   dot-atom / quoted-string / obs-local-part   domain          =   dot-atom / domain-literal / obs-domain   domain-literal  =   [CFWS] ''['' *([FWS] dtext) [FWS] '']'' [CFWS]   dtext           =   %d33-90 /          ; Printable US-ASCII                       %d94-126 /         ;  characters not including"	|  tok stream comment |	tok := self nextRFC822Token.	"Variations of mailbox spec"	tok = $&lt; 		ifTrue:							"Phil Campbell&lt;philc@acme.com&gt;"			["angle-addr. The phrasex is alias "			phrase notEmpty ifTrue: [ self descriptor alias: (self decodePhrase: phrase )].			self stepBack; scanRouteAndAddress]		ifFalse: "These ones should have a non-empty local part to the left of delimiter"			[('.@' includes: tok)				ifTrue: ["phil.campbell.wise@acme.com&gt;"						"philc@acme.com&gt;"						self completeScanOfAddressSpecWith: phrase.]				ifFalse: [(',;' includes: tok) "End of group-spec or mailbox-list" 							ifTrue: [self descriptor domain ifNil: [self notify: (#AddrSpecMissingDomain &lt;&lt; #net &gt;&gt; 'The addr-spec is missing a domain or there is a wrong local-part')].								self stepBack]							ifFalse: [self notify: (#AddrSpecMissingDomain &lt;&lt; #net &gt;&gt; 'The addr-spec is missing a domain or there is a wrong local-part') ]]].	comment := currentComment == nil				ifTrue: [nil]				ifFalse: 					[stream := (String new: 64) writeStream.					currentComment do: [:part | stream nextPutAll: part]						separatedBy: [stream space].					stream contents].	currentComment := nil.	self descriptor comment: comment.	^self descriptor</body><body package="MIME">parseGroupSpecWith: phrase 	"group           =   display-name '':'' [group-list] '';'' [CFWS]   display-name    =   phrase   mailbox-list    =   (mailbox *('','' mailbox))    address-list    =   (address *('','' address))    group-list      =   mailbox-list / CFWS "	| group mailboxes phrasex comment stream |	mailboxes := self tokenizeList: [self parseAddress] separatedBy: [token == $,].	self nextRFC822Token == $; ifFalse: [^self notify: (#GroupDescriptorShouldBeTerminated &lt;&lt; #net &gt;&gt; 'Group descriptor should be terminated by &lt;:&gt;')].	self skipWhiteSpace.	group := MailGroupDescriptor new.	" If phrase is non-empty, an alias was specified "	phrasex := phrase isEmpty ifTrue: [nil] ifFalse: [phrase].	comment := currentComment isNil				ifTrue: [nil]				ifFalse: 					[stream := (String new: 64) writeStream.					currentComment do: [:part | stream nextPutAll: part]						separatedBy: [stream space].					stream contents].	currentComment := nil.	group alias: phrasex; addresses: mailboxes; comment: comment.	^group</body><body package="MIME">parseMailboxSpecWith: phrasex"  http://www.rfc-editor.org/rfc/rfc5322.txt   mailbox         =   name-addr / addr-spec   name-addr       =   [display-name] angle-addr   angle-addr      =   [CFWS] '&lt;' addr-spec '&gt;' [CFWS] / obs-angle-addr   addr-spec       =   local-part ''@'' domain   local-part      =   dot-atom / quoted-string / obs-local-part   domain          =   dot-atom / domain-literal / obs-domain   domain-literal  =   [CFWS] ''['' *([FWS] dtext) [FWS] '']'' [CFWS]   dtext           =   %d33-90 /          ; Printable US-ASCII                       %d94-126 /         ;  characters not including"	self descriptor: self newAddressDescriptor.	(self class newFrom: source ) 		descriptor: self descriptor;		parseAddrSpec: phrasex.	^self descriptor</body><body package="MIME">scanRoute"The route is obsolete http://tools.ietf.org/html/rfc5322#section-4.4   obs-route       =   obs-domain-list ':'   obs-domain-list =   *(CFWS / ',') '@' domain                       *(',' [CFWS] ['@' domain])"	| stream |	stream := (Array new: 2) writeStream.	[self nextRFC822Token == $@]		whileTrue: 			[stream nextPut: self scanDomain.			self nextToken = $: ifFalse: [self error: (#InvalidRouteSpec &lt;&lt; #net &gt;&gt; 'Invalid route spec')]].	stream size = 0 ifTrue: [self error: (#InvalidRouteSpec &lt;&lt; #net &gt;&gt; 'Invalid route spec')].	^stream contents</body><body package="MIME">scanRouteAndAddress"     route-addr  =  &lt;&lt;&gt; [route] addr-spec &lt;&gt;&gt;Obsolete Addressing  obs-angle-addr  =   [CFWS] ''&lt;'' obs-route addr-spec ''&gt;'' [CFWS]   obs-route       =   obs-domain-list '':''   obs-domain-list =   *(CFWS / '','') ''@'' domain                       *('','' [CFWS] [''@'' domain])"	| firstLocalPart |	self mustMatch: $&lt; notify: (#InvalidRouteAddressSpec &lt;&lt; #net &gt;&gt; 'Invalid route address spec').		self nextRFC822Token == $@ ifTrue: [ self stepBack. self descriptor route: self scanRoute ].	token == $&gt; ifTrue: 		[^InvalidAddressSpec raiseRequestWith: descriptor errorString: ((#DetectedEmptyAddressSpec &lt;&lt; #net &gt;&gt; 'Detected an empty address spec in field: &lt;1s&gt;') expandMacrosWith: self source contents).].	firstLocalPart := self currentTokenStruct.	self nextRFC822Token.	self completeScanOfAddressSpecWith: ( OrderedCollection with: firstLocalPart ).	self mustMatch: $&gt; notify: (#InvalidRouteAddressSpec &lt;&lt; #net &gt;&gt; 'Invalid route address spec').</body><body package="MIME">setDomain"  http://www.rfc-editor.org/rfc/rfc5322.txt   domain          =   dot-atom / domain-literal / obs-domain   domain-literal  =   [CFWS] ''['' *([FWS] dtext) [FWS] '']'' [CFWS]   dtext           =   %d33-90 /          ; Printable US-ASCII                       %d94-126 /         ;  characters not including"	self descriptor domain: self scanDomain.	hereChar ifNotNil: [		(hereChar ~= $&gt; and: [hereChar ~= $, and: [ hereChar ~= $;]])			ifTrue: [self notify: (#AddrSpecHasInvalidDomain &lt;&lt; #net &gt;&gt; 'The addr-spec has invalid domain')]]</body><body package="MIME">setLocalPart: localParts"  http://www.rfc-editor.org/rfc/rfc5322.txt      local-part      =   dot-atom / quoted-string / obs-local-partThe local-part of the email address may use any of these ASCII characters RFC 5322 Section 3.2.3:    Character . (dot, period, full stop) (ASCII: 46) provided that it is not the first or last character, and provided also that it does not appear two or more times consecutively (e.g. John..Doe@example.com is not allowed.).    Special characters are allowed with restrictions.    The restrictions for special characters are that they must only be used when contained between quotation marks, and that 3 of them (The space, backslash \ and quotation mark  (ASCII: 32, 92, 34)) must also be preceded by a backslash \A quoted string may exist as a dot separated entity within the local-part, or it may exist when the outermost quotes are the outermost characters of the local-part (e.g. abc.''defghi''.xyz@example.com or ''abcdefghixyz''@example.com are allowed. Conversely, abc''defghi''xyz@example.com is not; neither is abc\''def\''ghi@example.com). Quoted strings and characters however, are not commonly used. RFC 5321 also warns that ''a host that expects to receive mail SHOULD avoid defining mailboxes where the Local-part requires (or uses) the Quoted-string form"	| tokens |	localParts isEmpty ifTrue: [self notify: (#LocalPartNetworkAddressEmpty &lt;&lt; #net &gt;&gt; 'The local-part of the network address is empty')].	tokens := (localParts collect: [ :struct | 				self verifyPart: struct localParts: localParts.				struct token]).	self descriptor localPart: tokens asArray.</body><body package="MIME">tryScanSubdomain	self nextRFC822Token.	tokenType = #atom ifTrue: [ ^true ].	(token = $[) ifTrue: [ self stepBack; scanDomainText. ^true ].	^false.</body><body package="MIME">verifyPart: aStruct localParts: aColl	| stream localPart |	(aStruct separator = $. 					"next part"		or: [aStruct separator = $@ 			"domain "			or: [aStruct separator = $(		" comment "				or: [aStruct separator = $" and: [aStruct tokenType = #quotedText ]]]]) ifTrue: [^true].	"Something is wrong with the loval part. Recreate the local part phrase for the error string "	stream :=String new writeStream.	aColl do: [ :struct | 		stream nextPutAll: struct token.		 struct separator ifNotNil: [ stream nextPut: struct separator]].	localPart := stream contents.	aStruct separator ifNil:		[^self notify: ((#AtCharMustSeparateLocalDomain&lt;&lt; #net &gt;&gt; 'The addr-spec doesn''t have domain followed by local-part: &lt;1s&gt; ') expandMacrosWith: localPart )].		(aStruct separator = $" and: [aStruct tokenType = #atom ])		ifTrue: [^self notify: ((#QuotedStringsMustBeDotSeparated &lt;&lt; #net &gt;&gt; 'Quoted strings must be dot separated, or the only element making up the local-part: &lt;1s&gt;') expandMacrosWith: localPart )].	self notify: ((#LocalPart1sHasWrongSeparator2s &lt;&lt; #net &gt;&gt; 'The local-part: &lt;1s&gt; has a wrong separator: &lt;2s&gt; ') expandMacrosWith: localPart with: aStruct separator printString)</body></methods><methods><class-id>Net.NetworkAddressParser</class-id> <category>initialize-release</category><body package="MIME">initialize	super initialize.	descriptor := self newAddressDescriptor</body></methods><methods><class-id>Net.NetworkAddressParser</class-id> <category>public</category><body package="MIME">addressesFrom: stream	^(self on: stream) parseAddressesSeparatedBy: $,</body><body package="MIME">parse: aString 	^self on: aString readStream; parseAddress</body><body package="MIME">parseAddress"  http://www.rfc-editor.org/rfc/rfc5322.txt   address         =   mailbox / group   mailbox         =   name-addr / addr-spec   name-addr       =   [display-name] angle-addr   angle-addr      =   [CFWS] '&lt;' addr-spec '&gt;' [CFWS] / obs-angle-addr   group           =   display-name ':' [group-list] ';' [CFWS]   display-name    =   phrase   mailbox-list    =   (mailbox *(',' mailbox)) / obs-mbox-list   address-list    =   (address *(',' address)) / obs-addr-list   group-list      =   mailbox-list / CFWS / obs-group-list"	| phrase | 	"Decode phrase. Could be mailbox (name-addr / addr-spec)  or group (display-name)"	phrase := OrderedCollection new.	self 		tokenizeWhile: [#(#quotedText #atom) includes: tokenType]		do: [phrase add: self currentTokenStruct ].	(phrase isEmpty and: [self atEnd]) ifTrue: [ ^nil ].   	^self nextRFC822Token = $: 		ifTrue: [self parseGroupSpecWith: (self decodePhrase: phrase )]		ifFalse: [self stepBack; parseMailboxSpecWith:  phrase ].</body><body package="MIME">parseAddressesSeparatedBy: separatorChar	^self 		tokenizeList: [self parseAddress]		separatedBy: [token == separatorChar].</body><body package="MIME">scanDomain	"domain = sub-domain *(&lt;.&gt; sub-domain)"	"Answers an array of domain seqments, from least significant to most significant"	^self tokenizeList: [self nextRFC822Token.		tokenType = #atom			ifTrue: [token]			ifFalse: [token = $[					ifTrue: [self stepBack; scanDomainText]					ifFalse: [^self notify: (#InvalidDomainSpecification &lt;&lt; #net &gt;&gt; 'Invalid domain specification')]]]		separatedBy: [token == $.]</body><body package="MIME">scanLocalAddress	"local-part = word *(&lt;.&gt; word) ; uninterpreted, case-preserved"	^self		tokenizeList: 			[self nextRFC822Token.			(#(#quotedText #atom) includes: tokenType)				ifFalse: [^self notify: (#LocalPartcanOnlyIncludeWords &lt;&lt; #net &gt;&gt; 'Local part can only include words')].			token]		separatedBy: [token == $.]</body></methods><methods><class-id>Net.NetworkAddressParser</class-id> <category>converting</category><body package="MIME">phraseAsString: phrase	| stream |	stream := (String new: 64) writeStream.	MimeScanner printPhrase: phrase on: stream. 	^stream contents.</body></methods><methods><class-id>Net.NetworkAddressParser class</class-id> <category>instance creation</category><body package="MIME">parse: string	^self new parse: string</body></methods><methods><class-id>Net.NetworkAddressParser class</class-id> <category>utility</category><body package="MIME">addressFrom: aRFC822ScannerOrStream	"self addressFrom: 'kyasu@crl.fujixerox.co.jp'."	"self addressFrom: 'Kazuki Yasumatsu &lt;kyasu@crl.fujixerox.co.jp&gt;'."	"self addressFrom: 'kyasu@crl.fujixerox.co.jp (Kazuki Yasumatsu)'."	^(self newFrom: aRFC822ScannerOrStream )  parseAddress</body><body package="MIME">addressesFrom: aRFC822ScannerOrStream	"self addressesFrom: 'kyasu@crl.fujixerox.co.jp' readStream."	"self addressesFrom: 'Kazuki Yasumatsu &lt;kyasu@crl.fujixerox.co.jp&gt;' readStream."	"self addressesFrom: 'kyasu@crl.fujixerox.co.jp (Kazuki Yasumatsu)' readStream."	"self addressesFrom: ' kyasu1, kyasu2, Kazuki Yasumatsu &lt;kyasu3&gt;, kyasu4 (Kazuki Yasumatsu)' readStream."	"self addressesFrom: ' foo bar, kyasu1, ,  Kazuki Yasumatsu &lt;kyasu2&gt; &lt;kyasu3&gt; (&lt;foo&gt; (foo bar), bar)' readStream."	^(self newFrom: aRFC822ScannerOrStream ) 			parseAddressesSeparatedBy: $,</body></methods><methods><class-id>Net.NetworkAddressParser class</class-id> <category>private</category><body package="MIME">newFrom: aRFC822ScannerOrStream	| scanner |	scanner := self new.	(aRFC822ScannerOrStream isKindOf: SimpleScanner)		ifTrue: [scanner acceptNonAsciiCharacters: aRFC822ScannerOrStream acceptNonAsciiCharacters ].	^(scanner on: aRFC822ScannerOrStream )</body></methods><methods><class-id>Net.VersionField</class-id> <category>accessing</category><body package="MIME">majorVersion	^(self parseVersion: self value) first</body><body package="MIME">majorVersion: numberOrString	| arr |	arr := self parseVersion: self value.	arr at: 1 put: numberOrString.	self versionStringFrom: arr.</body><body package="MIME">minorVersion	^(self parseVersion: self value) last</body><body package="MIME">minorVersion: numberOrString	| arr |	arr := self parseVersion: self value.	arr at: 2 put: numberOrString.	self versionStringFrom: arr.</body><body package="MIME">version	^self value</body><body package="MIME">version: string	self value: string</body><body package="MIME">versionStringFrom: arr	^(arr first printString), $., (arr last printString)</body></methods><methods><class-id>Net.VersionField</class-id> <category>parsing</category><body package="MIME">parseVersion: string	| arr |	(string isNil or: [ string isEmpty ]) ifTrue: [ ^Array new: 2 ].	arr := string tokensBasedOn: $..	arr size &lt; 2 		ifTrue: [^(InvalidHeaderField 					errorDescription: (#VersionShouldBeSpecifiedAs &lt;&lt; #net &gt;&gt; 'Version should be specified as &lt;major version&gt;.&lt;minor version&gt;')					source: string readStream  ) raise ].	^arr</body></methods><methods><class-id>Net.VersionField class</class-id> <category>parsing</category><body package="MIME">fieldNames	^#('mime-version' 'http-version')</body></methods><methods><class-id>Net.WritingInvalidHeader</class-id> <category>accessing</category><body package="MIME">header		^parameter</body><body package="MIME">header: anUnparsedHeaderValue		parameter := anUnparsedHeaderValue</body><body package="MIME">stream		^stream</body><body package="MIME">stream: aStream		stream := aStream</body></methods><methods><class-id>Net.WritingInvalidHeader class</class-id> <category>testing</category><body package="MIME">mayResume	^true</body></methods><methods><class-id>Net.UnparsedHeaderValue</class-id> <category>accessing</category><body package="MIME">comment	^self source contents</body><body package="MIME">errorDescription	^errorDescription</body><body package="MIME">errorDescription: aString	errorDescription := aString</body><body package="MIME">errorPosition	^errorPosition</body><body package="MIME">errorPosition: aNumber	errorPosition := aNumber</body><body package="MIME">parsingErrorDescription"Old api from MailboxField. Should be used #errorDescription instead "		^self errorDescription</body><body package="MIME">source	^source</body><body package="MIME">source: anObject	source := anObject</body><body package="MIME">stringWithEncoding: aString		^self errorDescription</body></methods><methods><class-id>Net.UnparsedHeaderValue</class-id> <category>composing</category><body package="MIME">createError	^WritingInvalidHeader new		messageText: ((#HeaderValueIsInvalidParserRaisedError &lt;&lt; #net &gt;&gt; 'The header value is invalid. The error: &lt;1s&gt; ' ) expandMacrosWith: self errorDescription );		header: self;		yourself</body><body package="MIME">writeOn: aStream	self writeOn: aStream encoding: nil</body><body package="MIME">writeOn: aStream encoding: aString"Can not write invalid headers! "	self createError		stream: aStream;		raise</body></methods><methods><class-id>Net.UnparsedHeaderValue</class-id> <category>testing</category><body package="MIME">isEmpty		^false</body><body package="MIME">isUnparsedHeaderValue		^true</body></methods><methods><class-id>Net.UnparsedHeaderValue</class-id> <category>printing</category><body package="MIME">printOn: aStream"Print the unparsed header source "	aStream nextPutAll: self source contents, ' (unparsed)'</body></methods><methods><class-id>Net.BoundedReadStream</class-id> <category>testing</category><body package="MIME">atEnd	^atEnd</body><body package="MIME">endOfLastPart	^endOfLastPart</body><body package="MIME">isReadable	^true</body><body package="MIME">isWritable	"Answer whether the stream implements #nextPut:."	^false</body></methods><methods><class-id>Net.BoundedReadStream</class-id> <category>accessing</category><body package="MIME">isEndOfLastPart	stream atEnd ifTrue: [ ^true].	self endOfLastPart ifFalse: [	self fillBuffer ].	^self endOfLastPart</body><body package="MIME">next	| c | 	stream atEnd ifTrue: [^self pastEnd].	c := buffer at: bufferPosition. 	buffer at: bufferPosition put: stream next.	bufferPosition := bufferPosition + 1.	bufferPosition &gt; buffer size ifTrue: [bufferPosition := 1].	self isBufferAtBoundary ifTrue: [self skipToEnd ].	^c</body></methods><methods><class-id>Net.BoundedReadStream</class-id> <category>initialize-release</category><body package="MIME">initializeOn: aStream boundary: aString	super initializeOn: aStream boundary: aString.	endOfLastPart := false.	[buffer := stream next: self boundary size.	]	on: EndOfStreamNotification		do: [ :ex | "resignal the notification as hard error"			ex resignalAs: (				IncompleteNextCountError new					messageText: ex messageText;					parameter: self boundary size					yourself ) ].	atEnd := (boundary = buffer).	bufferPosition := 1.	atEnd 		ifTrue: [self skipToEnd. self fillBuffer]		ifFalse: 			["First boundary right after the line end that separates the message header and body "			(buffer copyFrom: 1 to: buffer size - 2) = (self boundary copyFrom: 3 to: self boundary size) 				ifTrue: [self fillBuffer ]				ifFalse: [ self skipUpToFirstBoundary]].	atEnd := (boundary = buffer).</body><body package="MIME">skipUpToFirstBoundary	"Skip everything before the first boundary "	[self atEnd ] whileFalse: [self next].	self fillBuffer.</body></methods><methods><class-id>Net.BoundedReadStream</class-id> <category>private</category><body package="MIME">fillBuffer	stream atEnd ifTrue: [self pastEnd].	[ buffer :=  stream next: self boundary size ] 		on: Stream incompleteNextCountSignal		do: [:ex |  self pastEnd ].	bufferPosition := 1.	atEnd := (self boundary = buffer).	atEnd ifTrue: [self skipToEnd].</body><body package="MIME">isBufferAtBoundary	| boundaryIndex |	bufferPosition = 1		ifTrue: [^buffer = boundary].	boundaryIndex := 1.	bufferPosition to: buffer size do:		[:idx |		(buffer at: idx) = (boundary at: boundaryIndex)			ifFalse: [^false].		boundaryIndex := boundaryIndex + 1].	1 to: bufferPosition - 1 do:		[:idx |		(buffer at: idx) = (boundary at: boundaryIndex)			ifFalse: [^false].		boundaryIndex := boundaryIndex + 1].	^true</body><body package="MIME">skipToEnd	| bytes |	stream atEnd ifTrue: [ ^self pastEnd ].	[ bytes := stream next: 2 ]		on: Stream incompleteNextCountSignal		do: [:ex | ^self pastEnd ].	bytes  =  self lineEnd ifTrue: [ atEnd := true ].	bytes = self boundaryDashes 		ifTrue: [ stream atEnd ifFalse: [ stream next: 2.].				atEnd := endOfLastPart := true ].</body></methods><methods><class-id>Net.MimePrintHandler</class-id> <category>accessing</category><body package="MIME">indentLines	^indentLines ifNil: [false]</body><body package="MIME">indentLines: aBoolean	indentLines := aBoolean</body><body package="MIME">indentation	^indentation ifNil: [indentation := 0]</body><body package="MIME">indentation: anInteger	^indentation := anInteger</body></methods><methods><class-id>Net.MimePrintHandler</class-id> <category>tasks</category><body package="MIME">printMessage: aMimeEntity on: aStream	self printMessageElement: aMimeEntity on: aStream indent: 0</body><body package="MIME">printMessage: aMimeEntity on: aStream indent: level	^self printMessageElement: aMimeEntity on: aStream indent: level</body><body package="MIME">printMessageElement: aMessageElement on: aStream	^self printMessageElement: aMessageElement on: aStream indent: 0</body><body package="MIME">printMessageElement: aMessageElement on: aStream indent: level	self indentLines: true;		indentation: level;		prepareStream: aStream.	aMessageElement acceptVisit: self dispatcher with: nil.</body></methods><methods><class-id>Net.MimePrintHandler</class-id> <category>action callbacks</category><body package="MIME">endEntity: aMimeEntityOrNil	self indentation &gt; 0 ifTrue: [self indentation: self indentation - 1].	^super endEntity: aMimeEntityOrNil</body><body package="MIME">endSimpleBody: aSimpleBody	"74876: Sending #printString to MailMessage instances with empty file attachments leaves an open file handle"	aSimpleBody ifNotNil: [  :body | body sourceForDigest ifNotNil: [ :s | s close ]].			^super endSimpleBody: aSimpleBody</body><body package="MIME">startEntity: aMimeEntityOrNil	(aMimeEntityOrNil notNil		and: [ aMimeEntityOrNil parent notNil ])		ifTrue: [ self indentation: self indentation + 1].	^aMimeEntityOrNil</body><body package="MIME">startMultipartBody: aMultipartBody	| bodyStream |	bodyStream := BoundedWriteCharacterStream						on: self stream						boundary: aMultipartBody parent boundary.	self pushStream: bodyStream.</body><body package="MIME">startSimpleBody: aSimpleBody	| aStream |	aStream := aSimpleBody sourceForDigest.	[			self printDigestOf: aStream entity: aSimpleBody parent	] 	on: Error 		do: [ :ex |				self printLine:  ( #errorPrintingBodyContents &lt;&lt; #net &gt;&gt; 'ERROR printing body contents: ' ) asString.				self printLine: ex errorString].</body></methods><methods><class-id>Net.MimePrintHandler</class-id> <category>printing utilities</category><body package="MIME">printDigestOf: aStream entity: anEntity	" Print short digest from source stream onto aStream "	| contents binary fname size position |	binary := self isBinaryContent: aStream entity: anEntity.	fname := anEntity fileName.	size := aStream size.	fname notNil 		ifTrue: [self printLine: '------ from ', fname, ' (', size printString, ' bytes) -----']		ifFalse: [binary ifTrue: [self printLine: '------ (', size printString, ' bytes) -----']].	binary not		ifTrue: 			[ position := aStream position. 			aStream reset.				[contents := (aStream nextAvailable: 512) asString. 				aStream atEnd ifFalse: [contents := contents, '...']. 				contents readStream linesDo: [ :line | self printLine: line ].				] ensure: [ aStream position: position]			].	(fname notNil and: [binary not]) ifTrue: [self printLine: '---------------------------------------------------']</body><body package="MIME">printLine: aString	self indentLines ifTrue: [ self stream tab: self indentation ].	super printLine: aString</body></methods><methods><class-id>Net.MimePrintHandler</class-id> <category>private</category><body package="MIME">isBinaryContent: aStream entity: anEntity	^anEntity isBinaryContentType</body></methods><methods><class-id>Net.MimePrintHandler</class-id> <category>private prepare streams</category><body package="MIME">prepareStream: aStream	self pushStream:  aStream.</body></methods><methods><class-id>Net.AttachmentFileExists</class-id> <category>constants</category><body package="MIME">defaultResumeValue	"delete the file."	^self filename</body></methods><methods><class-id>Net.AttachmentFileExists</class-id> <category>accessing</category><body package="MIME">filename	^filename</body><body package="MIME">filename: aFilename	filename := aFilename</body></methods><methods><class-id>Net.AttachmentFileExists</class-id> <category>printing</category><body package="MIME">defaultMessageText	^(#FilenameExist &lt;&lt; #net &gt;&gt; 'The file name: &lt;1s&gt; already exists' ) expandMacrosWith:  filename tail</body></methods><methods><class-id>Net.AttachmentFileExists class</class-id> <category>Testing</category><body package="MIME">mayResume	^true</body></methods><methods><class-id>Net.UnparsedBody</class-id> <category>mutating</category><body package="MIME">newBody	| body |	body := (self isMultipart		ifTrue: [MultipartBody]		ifFalse: [SimpleBody] ) new.	source ifNotNil: [ body source: source].	self parent body: body.	^body</body></methods><methods><class-id>Net.UnparsedBody</class-id> <category>private</category><body package="MIME">getValue	^nil</body></methods><methods><class-id>Net.UnparsedBody</class-id> <category>printing</category><body package="MIME">printOn: aStream indent: level		| string |	string := 'Unparsed body'.	self isSimple ifTrue: [string := 'Unparsed simple body'].	self isMultipart ifTrue: [string := 'Unparsed multipart body'].		aStream nextPutAll: string</body></methods><methods><class-id>Net.UnparsedBody</class-id> <category>testing</category><body package="MIME">isMultipart	^self parent notNil		ifTrue: [ self parent isMultipart ]		ifFalse: [false]</body><body package="MIME">isSimple	^self parent notNil		ifTrue: [ self parent isSimple ]		ifFalse: [false]</body></methods><methods><class-id>Net.UnparsedBody</class-id> <category>composing</category><body package="MIME">writeOn: aStream	^self shouldNotImplement</body></methods><methods><class-id>Net.DateField</class-id> <category>converting</category><body package="MIME">asDateAndTime	^self value</body><body package="MIME">fromDateAndTime: dateAndTime	^Timestamp fromDate: dateAndTime first andTime: dateAndTime last.</body></methods><methods><class-id>Net.DateField</class-id> <category>accessing</category><body package="MIME">asString	^self dateString</body><body package="MIME">dateString	^self value		ifNil: [ 'nil' ]		ifNotNil: [ RFC822Scanner dateStringFrom: self value ]</body><body package="MIME">timestamp	^self value</body><body package="MIME">timestamp: aTimestamp	self value: aTimestamp</body><body package="MIME">value: aTimestampOrStringOrArray 	"We allow to set date from either string, timestamp or a two-element array (date, time) "	(aTimestampOrStringOrArray isKindOf: Timestamp)		ifTrue: [value := aTimestampOrStringOrArray]		ifFalse: [aTimestampOrStringOrArray isString				ifTrue: [value := self doParse: (self scannerOn: aTimestampOrStringOrArray readStream)]				ifFalse: [value := self fromDateAndTime: aTimestampOrStringOrArray]]</body></methods><methods><class-id>Net.DateField</class-id> <category>printing</category><body package="MIME">printStructureOn: aStream	self writeStructureOn: aStream encoding: nil</body></methods><methods><class-id>Net.DateField</class-id> <category>composing</category><body package="MIME">writeStructureOn: aStream encoding: aString	aStream nextPutAll: self writeValue.	self writeCommentOn: aStream encoding: aString</body><body package="MIME">writeValue	| v |	v := self value.	^ v respondsToArithmetic		ifTrue: [  v printString ]		ifFalse: [ self dateString].</body></methods><methods><class-id>Net.DateField</class-id> <category>parsing</category><body package="MIME">doParse: rfc822Scanner " HeaderField fromLine: 'Date : Tue, 18 Apr 89 23:29:47 +0900	' "" HeaderField fromLine: 'Date : (Tue, 18 Apr 89 23:29:47 +0900)	' "" HeaderField fromLine: 'Expires : 1' "" HeaderField fromLine: 'Expires :   1' "" HTTP/1.1 clients MUST treat other invalid date formats, especially including the value 0, as in the past (i.e., already expired). That is why the value can be a number :-("	| string stream |	stream := ReadWriteStream on: String new.	rfc822Scanner writeFoldLineOn: stream. 	^[rfc822Scanner class readDateAndTimeFrom: stream reset.		] on: Error		 do: [ :ex | 			stream reset.			string := stream upToEnd trimBlanks.			ex return: (Number readFrom: string readStream ) ]</body></methods><methods><class-id>Net.DateField class</class-id> <category>parsing</category><body package="MIME">fieldNames	^#('date' 'expires' 'last-modified' 'retry-after')</body></methods><methods><class-id>Net.DateField class</class-id> <category>instance creation</category><body package="MIME">default	^self new value: Timestamp now</body></methods><methods><class-id>Net.ParsingSimpleBodyError class</class-id> <category>testing</category><body package="MIME">mayResume	^true</body></methods><methods><class-id>Net.MimeScanner</class-id> <category>tokenization</category><body package="MIME">nextToken	^self nextMimeToken</body><body package="MIME">specials" This method is provided to encapsulate lexical differences between RFC822 on one side, and MIME, HTTP on the other side. MIME definiton of 'tspecials' is the same as the RFC 822 definition of ''specials' with the addition of the three characters &lt;/&gt;, &lt;?&gt;, and &lt;=&gt;, and the removal of &lt;.&gt;. To present uniform tokenization interface, this method is overridden in Mime scanner "	^self class tspecials</body></methods><methods><class-id>Net.MimeScanner</class-id> <category>multi-character scans</category><body package="MIME">scanQuotedText"RFC 2183: `tspecials' and `value' are defined according to RFC 2045. RFC2045 defines     parameter := attribute '=' value     value := token / quoted-string     token := 1*&lt;any (US-ASCII) CHAR except SPACE, CTLs, or tspecials&gt;     tspecials :=  (  ) &lt;  &gt;  @  ,  ;  :  \   /  [ ] ? =     - Must be in quoted-string  to use within parameter values"	" We are positioned at the first double quote character "	token := self 				scanToken: [ self matchCharacterType: MimeQuotedTextMask ] 				delimitedBy: '""' 				notify: (#UnmatchedQuotedText &lt;&lt; #net &gt;&gt; 'Unmatched quoted text').	tokenType := #quotedText. 	^token.</body><body package="MIME">scanToBoundary: boundary" Scan for specified boundary (RFC2046, p5.1). Answer scanned text from current position up to the beginning of the boundary. Stream is positioned after end of the boundary lineSecond element is either #next or #last. #next means the boundary found is not the last one. #last means the boundary is the closing boundary for the multi-part body (that is, it looks like '--&lt;boundary&gt;--) "	| string |	string := self upToAll: (self boundaryDashes , boundary).	self upTo: Character cr.					" Skip to the end of line "	^string.</body><body package="MIME">scanToken" MIME and HTTP: token  =  1*&lt;any CHAR except tspecials, SPACE and CTLs&gt;. That is, 'token' is analogous to RFC822 'atom' except set of Mime's set of tspecials characters includes three more characters as compared to set of 'specials' in RFC822"	token := self scanTokenMask: TokenMask.	tokenType := #token.	^token</body></methods><methods><class-id>Net.MimeScanner</class-id> <category>printing</category><body package="MIME">printPhrase: phrase on: stream	self class printPhrase: phrase on: stream</body></methods><methods><class-id>Net.MimeScanner</class-id> <category>constants</category><body package="MIME">boundaryDashes	^MultipartBody boundaryDashes</body></methods><methods><class-id>Net.MimeScanner</class-id> <category>private</category><body package="MIME">nextMimeToken" MIME and HTTP: token  =  1*&lt;any CHAR except tspecials, SPACE and CTLs&gt;. That is, 'token' is analogous to RFC822 'atom' except set of Mime's set of tspecials characters includes three more characters as compared to set of 'specials' in RFC822"	| char |	self skipWhiteSpace.	char := self peek.	char isNil				"end of input"		ifTrue: [tokenType := #doIt.			^token := nil].	char == $( ifTrue: [^self scanComment; nextToken].	char == $" ifTrue: [^self scanQuotedText].	(self specials includes: char)		ifTrue: [tokenType := #special.		" Special character. Make it token value and set token type "				^token := self next.].	^self privateScanTokenMask: TokenMask</body></methods><methods><class-id>Net.MimeScanner class</class-id> <category>testing</category><body package="MIME">isTokenChar: char	^((self classificationMaskFor: char ) bitAnd: TokenMask) ~= 0</body><body package="MIME">needsTransferEncoding: aStream mimeType: aMimeTypeDescriptor	"Answer true if the object needs to be transfer-encoded because it contains 	8-bit values or lines are too long, etc. 	For now on, answer true for non-binary streams. Scan character strings looking for 8-bit characters 	and answer true if one is found. Otherwise answer false"	| savePos |	aMimeTypeDescriptor isBinary ifTrue: [ ^true ].	((aStream respondsTo: #isBinary) and: [aStream isBinary])		ifTrue: [^true].	savePos := aStream position.	[aStream reset.	[aStream atEnd]		whileFalse: [aStream next asInteger &gt; 127 ifTrue: [^true]]]		ensure: [aStream position: savePos].	^false</body><body package="MIME">shouldBeQuoted: string	^(string detect: [ :char | (self isTokenChar: char) not ] ifNone: [ nil ]) notNil</body></methods><methods><class-id>Net.MimeScanner class</class-id> <category>printing</category><body package="MIME">printPhrase: phrase on: stream	MimeEncodedWordCoDec decodePhrase: phrase printOn: stream</body><body package="MIME">printToken: value tokenType: aSymbol on: stream	aSymbol == #special 		ifTrue: [stream nextPut: value]		ifFalse: 			[aSymbol == #token				ifTrue: [stream nextPutAll: value]				ifFalse: [stream nextPutAll: '"', value, '"' ]]</body></methods><methods><class-id>Net.MimeScanner class</class-id> <category>class initialization</category><body package="MIME">initClassificationTable	super initClassificationTable.	self initClassificationTableWith: MimeQuotedTextMask when:		[:c | c ~~ $" and: [ c ~~ Character cr ]].</body><body package="MIME">initialize	" MimeScanner initialize "	self 		initializeConstants; 		initClassificationTable;		initializeBase64Decoder</body><body package="MIME">initializeBase64Decoder	" (MimeScanner initializeBase64Decoder )"	codeChars := 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.	base64Decoder := (0 to: 255) collect: [:n| (codeChars indexOf: (n + 1) asCharacter) - 1].	base64Decoder replaceAll: -1 with: 0.</body><body package="MIME">initializeConstants	MimeQuotedTextMask := 32768.</body></methods><methods><class-id>Net.AttachmentFilename</class-id> <category>accessing</category><body package="MIME">filename	^parameter</body><body package="MIME">filename: aString	parameter := aString</body><body package="MIME">originalFilename	^originalFilename</body><body package="MIME">originalFilename: aString	originalFilename := aString</body></methods><methods><class-id>Net.AttachmentFilename</class-id> <category>private</category><body package="MIME">defaultResumeValue	^self filename</body></methods><methods><class-id>Net.AttachmentFilename</class-id> <category>private - actions</category><body package="MIME">defaultAction	| s |	self class logToTranscript 		ifTrue: [s := (#TheAttachmentIsSavedInTo &lt;&lt; #net &gt;&gt; 'the attachment is saved in to ') asString.				Transcript cr; show:'&lt;', self class fullName , '&gt; ', s, self parameter  asString ].	^self defaultResumeValue</body></methods><methods><class-id>Net.MultipartBody</class-id> <category>accessing</category><body package="MIME">addPart: part	self parts add: part</body><body package="MIME">boundary	^self parent boundary</body><body package="MIME">parent: aMimeEntity	super parent: aMimeEntity.	" Re-parent all my parts "	self parts do: [ :part | part parent: aMimeEntity ]</body><body package="MIME">partAt: anInteger	^self parts at: anInteger</body><body package="MIME">parts	^value</body><body package="MIME">parts: aCollection	value := aCollection.	value do: [ :part | part parent: self ].</body><body package="MIME">removePart: aMimeEntity	self parts remove: aMimeEntity</body><body package="MIME">removePartAt: anInteger	self parts remove: (self partAt: anInteger)</body></methods><methods><class-id>Net.MultipartBody</class-id> <category>initialization</category><body package="MIME">initialize	self parts: (OrderedCollection new: 4)</body></methods><methods><class-id>Net.MultipartBody</class-id> <category>testing</category><body package="MIME">isMultipart	^true</body><body package="MIME">isSimple	^false</body><body package="MIME">notEmpty	^true</body></methods><methods><class-id>Net.MultipartBody</class-id> <category>transfer encoding</category><body package="MIME">needsContentTransferEncoding	^false</body></methods><methods><class-id>Net.MultipartBody</class-id> <category>copying</category><body package="MIME">postCopy	super postCopy.	value := value collect: [ :part | part copy ].</body></methods><methods><class-id>Net.MultipartBody</class-id> <category>visiting</category><body package="MIME">acceptVisit: aVisitor with: argument	^aVisitor acceptMultipartBody: self with: argument</body></methods><methods><class-id>Net.MultipartBody</class-id> <category>printing</category><body package="MIME">preamble	^'This message is in Mime format\\' withCRs readStream</body><body package="MIME">printLine: aString on: aStream indent: level	aStream 		tab: level;		nextPutAll: aString;		cr</body></methods><methods><class-id>Net.MultipartBody</class-id> <category>constants</category><body package="MIME">boundaryDashes	^self class boundaryDashes</body></methods><methods><class-id>Net.MultipartBody</class-id> <category>composing</category><body package="MIME">writeOn: aStream	self shouldNotImplement</body></methods><methods><class-id>Net.MultipartBody class</class-id> <category>documentation</category><body package="MIME">fromRFC2046" From RFC2046: Multipurpose Internet Mail Extensions (MIME) Part Two:                              Media Types5.1.  Multipart Media Type   In the case of multipart entities, in which one or more different   sets of data are combined in a single body, a 'multipart' media type   field must appear in the entity's header.  The body must then contain   one or more body parts, each preceded by a boundary delimiter line,   and the last one followed by a closing boundary delimiter line.   After its boundary delimiter line, each body part then consists of a   header area, a blank line, and a body area.  Thus a body part is   similar to an RFC 822 message in syntax, but different in meaning.   A body part is an entity and hence is NOT to be interpreted as   actually being an RFC 822 message.  To begin with, NO header fields   are actually required in body parts.  A body part that starts with a   blank line, therefore, is allowed and is a body part for which all   default values are to be assumed.  In such a case, the absence of a   Content-Type header usually indicates that the corresponding body has   a content-type of 'text/plain; charset=US-ASCII'.   The only header fields that have defined meaning for body parts are   those the names of which begin with 'Content-'.  All other header   fields may be ignored in body parts.  Although they should generally   be retained if at all possible, they may be discarded by gateways if   necessary.  Such other fields are permitted to appear in body parts   but must not be depended on.  'X-' fields may be created for   experimental or private purposes, with the recognition that the   information they contain may be lost at some gateways.   NOTE:  The distinction between an RFC 822 message and a body part is   subtle, but important.  A gateway between Internet and X.400 mail,   for example, must be able to tell the difference between a body part   that contains an image and a body part that contains an encapsulated   message, the body of which is a JPEG image.  In order to represent   the latter, the body part must have 'Content-Type: message/rfc822',   and its body (after the blank line) must be the encapsulated message,   with its own 'Content-Type: image/jpeg' header field.  The use of   similar syntax facilitates the conversion of messages to body parts,   and vice versa, but the distinction between the two must be   understood by implementors.  (For the special case in which parts   actually are messages, a 'digest' subtype is also defined.)   As stated previously, each body part is preceded by a boundary   delimiter line that contains the boundary delimiter.  The boundary   delimiter MUST NOT appear inside any of the encapsulated parts, on a   line by itself or as the prefix of any line.  This implies that it is   crucial that the composing agent be able to choose and specify a   unique boundary parameter value that does not contain the boundary   parameter value of an enclosing multipart as a prefix.   All present and future subtypes of the 'multipart' type must use an   identical syntax.  Subtypes may differ in their semantics, and may   impose additional restrictions on syntax, but must conform to the   required syntax for the 'multipart' type.  This requirement ensures   that all conformant user agents will at least be able to recognize   and separate the parts of any multipart entity, even those of an   unrecognized subtype.   As stated in the definition of the Content-Transfer-Encoding field   [RFC 2045], no encoding other than '7bit', '8bit', or 'binary' is   permitted for entities of type 'multipart'.  The 'multipart' boundary   delimiters and header fields are always represented as 7bit US-ASCII   in any case (though the header fields may encode non-US-ASCII header   text as per RFC 2047) and data within the body parts can be encoded   on a part-by-part basis, with Content-Transfer-Encoding fields for   each appropriate body part.5.1.1.  Common Syntax   This section defines a common syntax for subtypes of 'multipart'.   All subtypes of 'multipart' must use this syntax.  A simple example   of a multipart message also appears in this section.  An example of a   more complex multipart message is given in RFC 2049.   The Content-Type field for multipart entities requires one parameter,   'boundary'. The boundary delimiter line is then defined as a line   consisting entirely of two hyphen characters ('-', decimal value 45)   followed by the boundary parameter value from the Content-Type header   field, optional linear whitespace, and a terminating CRLF.   NOTE:  The hyphens are for rough compatibility with the earlier RFC   934 method of message encapsulation, and for ease of searching for   the boundaries in some implementations.  However, it should be noted   that multipart messages are NOT completely compatible with RFC 934   encapsulations; in particular, they do not obey RFC 934 quoting   conventions for embedded lines that begin with hyphens.  This   mechanism was chosen over the RFC 934 mechanism because the latter   causes lines to grow with each level of quoting.  The combination of   this growth with the fact that SMTP implementations sometimes wrap   long lines made the RFC 934 mechanism unsuitable for use in the event   that deeply-nested multipart structuring is ever desired.   WARNING TO IMPLEMENTORS:  The grammar for parameters on the Content-   type field is such that it is often necessary to enclose the boundary   parameter values in quotes on the Content-type line.  This is not   always necessary, but never hurts. Implementors should be sure to   study the grammar carefully in order to avoid producing invalid   Content-type fields.  Thus, a typical 'multipart' Content-Type header   field might look like this:     Content-Type: multipart/mixed; boundary=gc0p4Jq0M2Yt08j34c0p   But the following is not valid:     Content-Type: multipart/mixed; boundary=gc0pJq0M:08jU534c0p   (because of the colon) and must instead be represented as     Content-Type: multipart/mixed; boundary='gc0pJq0M:08jU534c0p'   This Content-Type value indicates that the content consists of one or   more parts, each with a structure that is syntactically identical to   an RFC 822 message, except that the header area is allowed to be   completely empty, and that the parts are each preceded by the line     --gc0pJq0M:08jU534c0p   The boundary delimiter MUST occur at the beginning of a line, i.e.,   following a CRLF, and the initial CRLF is considered to be attached   to the boundary delimiter line rather than part of the preceding   part.  The boundary may be followed by zero or more characters of   linear whitespace. It is then terminated by either another CRLF and   the header fields for the next part, or by two CRLFs, in which case   there are no header fields for the next part.  If no Content-Type   field is present it is assumed to be 'message/rfc822' in a   'multipart/digest' and 'text/plain' otherwise.   NOTE:  The CRLF preceding the boundary delimiter line is conceptually   attached to the boundary so that it is possible to have a part that   does not end with a CRLF (line  break).  Body parts that must be   considered to end with line breaks, therefore, must have two CRLFs   preceding the boundary delimiter line, the first of which is part of   the preceding body part, and the second of which is part of the   encapsulation boundary.   Boundary delimiters must not appear within the encapsulated material,   and must be no longer than 70 characters, not counting the two   leading hyphens.   The boundary delimiter line following the last body part is a   distinguished delimiter that indicates that no further body parts   will follow.  Such a delimiter line is identical to the previous   delimiter lines, with the addition of two more hyphens after the   boundary parameter value.     --gc0pJq0M:08jU534c0p--   NOTE TO IMPLEMENTORS:  Boundary string comparisons must compare the   boundary value with the beginning of each candidate line.  An exact   match of the entire candidate line is not required; it is sufficient   that the boundary appear in its entirety following the CRLF.   There appears to be room for additional information prior to the   first boundary delimiter line and following the final boundary   delimiter line.  These areas should generally be left blank, and   implementations must ignore anything that appears before the first   boundary delimiter line or after the last one.   NOTE:  These 'preamble' and 'epilogue' areas are generally not used   because of the lack of proper typing of these parts and the lack of   clear semantics for handling these areas at gateways, particularly   X.400 gateways.  However, rather than leaving the preamble area   blank, many MIME implementations have found this to be a convenient   place to insert an explanatory note for recipients who read the   message with pre-MIME software, since such notes will be ignored by   MIME-compliant software.   NOTE:  Because boundary delimiters must not appear in the body parts   being encapsulated, a user agent must exercise care to choose a   unique boundary parameter value.  The boundary parameter value in the   example above could have been the result of an algorithm designed to   produce boundary delimiters with a very low probability of already   existing in the data to be encapsulated without having to prescan the   data.  Alternate algorithms might result in more 'readable' boundary   delimiters for a recipient with an old user agent, but would require   more attention to the possibility that the boundary delimiter might   appear at the beginning of some line in the encapsulated part.  The   simplest boundary delimiter line possible is something like '---',   with a closing boundary delimiter line of '-----'.   As a very simple example, the following multipart message has two   parts, both of them plain text, one of them explicitly typed and one   of them implicitly typed:     From: Nathaniel Borenstein &lt;nsb@bellcore.com&gt;     To: Ned Freed &lt;ned@innosoft.com&gt;     Date: Sun, 21 Mar 1993 23:56:48 -0800 (PST)     Subject: Sample message     MIME-Version: 1.0     Content-type: multipart/mixed; boundary='simple boundary'     This is the preamble.  It is to be ignored, though it     is a handy place for composition agents to include an     explanatory note to non-MIME conformant readers.     --simple boundary     This is implicitly typed plain US-ASCII text.     It does NOT end with a linebreak.     --simple boundary     Content-type: text/plain; charset=us-ascii     This is explicitly typed plain US-ASCII text.     It DOES end with a linebreak.     --simple boundary--     This is the epilogue.  It is also to be ignored.   The use of a media type of 'multipart' in a body part within another   'multipart' entity is explicitly allowed.  In such cases, for obvious   reasons, care must be taken to ensure that each nested 'multipart'   entity uses a different boundary delimiter.  See RFC 2049 for an   example of nested 'multipart' entities.   The use of the 'multipart' media type with only a single body part   may be useful in certain contexts, and is explicitly permitted.   NOTE: Experience has shown that a 'multipart' media type with a   single body part is useful for sending non-text media types.  It has   the advantage of providing the preamble as a place to include   decoding instructions.  In addition, a number of SMTP gateways move   or remove the MIME headers, and a clever MIME decoder can take a good   guess at multipart boundaries even in the absence of the Content-Type   header and thereby successfully decode the message.   The only mandatory global parameter for the 'multipart' media type is   the boundary parameter, which consists of 1 to 70 characters from a   set of characters known to be very robust through mail gateways, and   NOT ending with white space. (If a boundary delimiter line appears to   end with white space, the white space must be presumed to have been   added by a gateway, and must be deleted.)  It is formally specified   by the following BNF:     boundary := 0*69&lt;bchars&gt; bcharsnospace     bchars := bcharsnospace / ' '     bcharsnospace := DIGIT / ALPHA / ''' / '(' / ')' /                      '+' / '_' / ',' / '-' / '.' /                      '/' / ':' / '=' / '?'   Overall, the body of a 'multipart' entity may be specified as   follows:     dash-boundary := '--' boundary                      ; boundary taken from the value of                      ; boundary parameter of the                      ; Content-Type field.     multipart-body := [preamble CRLF]                       dash-boundary transport-padding CRLF                       body-part *encapsulation                       close-delimiter transport-padding                       [CRLF epilogue]     transport-padding := *LWSP-char                          ; Composers MUST NOT generate                          ; non-zero length transport                          ; padding, but receivers MUST                          ; be able to handle padding                          ; added by message transports.     encapsulation := delimiter transport-padding                      CRLF body-part     delimiter := CRLF dash-boundary     close-delimiter := delimiter '--'     preamble := discard-text     epilogue := discard-text     discard-text := *(*text CRLF) *text                     ; May be ignored or discarded.     body-part := MIME-part-headers [CRLF *OCTET]                  ; Lines in a body-part must not start                  ; with the specified dash-boundary and                  ; the delimiter must not appear anywhere                  ; in the body part.  Note that the                  ; semantics of a body-part differ from                  ; the semantics of a message, as                  ; described in the text.     OCTET := &lt;any 0-255 octet value&gt;   IMPORTANT:  The free insertion of linear-white-space and RFC 822   comments between the elements shown in this BNF is NOT allowed since   this BNF does not specify a structured header field.   NOTE:  In certain transport enclaves, RFC 822 restrictions such as   the one that limits bodies to printable US-ASCII characters may not   be in force. (That is, the transport domains may exist that resemble   standard Internet mail transport as specified in RFC 821 and assumed   by RFC 822, but without certain restrictions.) The relaxation of   these restrictions should be construed as locally extending the   definition of bodies, for example to include octets outside of the   US-ASCII range, as long as these extensions are supported by the   transport and adequately documented in the Content- Transfer-Encoding   header field.  However, in no event are headers (either message   headers or body part headers) allowed to contain anything other than   US-ASCII characters.   NOTE:  Conspicuously missing from the 'multipart' type is a notion of   structured, related body parts. It is recommended that those wishing   to provide more structured or integrated multipart messaging   facilities should define subtypes of multipart that are syntactically   identical but define relationships between the various parts. For   example, subtypes of multipart could be defined that include a   distinguished part which in turn is used to specify the relationships   between the other parts, probably referring to them by their   Content-ID field.  Old implementations will not recognize the new   subtype if this approach is used, but will treat it as   multipart/mixed and will thus be able to show the user the parts that   are recognized.5.1.2.  Handling Nested Messages and Multiparts   The 'message/rfc822' subtype defined in a subsequent section of this   document has no terminating condition other than running out of data.   Similarly, an improperly truncated 'multipart' entity may not have   any terminating boundary marker, and can turn up operationally due to   mail system malfunctions.   It is essential that such entities be handled correctly when they are   themselves imbedded inside of another 'multipart' structure.  MIME   implementations are therefore required to recognize outer level   boundary markers at ANY level of inner nesting.  It is not sufficient   to only check for the next expected marker or other terminating   condition."</body></methods><methods><class-id>Net.MultipartBody class</class-id> <category>constants</category><body package="MIME">boundaryDashes	^'--'</body></methods><methods><class-id>Net.MimeEncodedWordCoDec</class-id> <category>parsing</category><body package="MIME">decode: word 	| stream |	stream := String new writeStream.	self decode: word on: stream.	^stream contents</body><body package="MIME">decodePhrase: words" decode phrase word by word; concatenate decoded words and answer concatenated string "	| output |	output := (String new: words size) writeStream.	self decodePhrase: words printOn: output.	^output contents</body><body package="MIME">decodePhrase: words printOn: stream 	| str |	str := WriteStream on: String new.	words 		do: [ :word | str nextPutAll: word ]		separatedBy: [str nextPut: Character space].	stream nextPutAll: (self decodeText: str contents).</body><body package="MIME">decodeText: text " Decoding of text is similar to decoding of comment, but RFC2047 requires that an encoded word that appears in in *text token MUST be separated from any adjacent encoded word or text by a linear-white-spaceRFC 2047:  When displaying a particular header field that contains multiple 'encoded-word's, any 'linear-white-space' that separates a pair of adjacent 'encoded-word's is ignored.  (This is to allow the use of multiple 'encoded-word's to represent long strings of unencoded text,  without having to separate 'encoded-word's where spaces occur in the  unencoded text.)"	| output word spaces |	(text indexOfSubCollection: '=?' startingAt: 1) = 0 		ifTrue: [^text].		self on: text readStream.	output := (String new: text size) writeStream.	[self atEnd]		whileFalse: 			[word := self scanWord. 			self decode: word on: output.			spaces := self scanSpaces.			self shouldAddSpaces ifTrue: [output nextPutAll: spaces]]. 	^output contents</body></methods><methods><class-id>Net.MimeEncodedWordCoDec</class-id> <category>private</category><body package="MIME">decode: word on: output 	| aStream char pos |	aStream := word readStream. 	[aStream atEnd] 		whileFalse: 			[pos := aStream position.			char := aStream next. 			(char = $= and: [aStream peekFor:  $?]) 				ifTrue: 					[self 						decodeFrom: aStream 						on: output 						onError: [aStream position: pos. ^output nextPutAll: aStream upToEnd].					tokenType := #encoded]				ifFalse: 					[char ~= CRLF 						ifTrue: [output nextPut: char. tokenType := #notEncoded.]]]</body><body package="MIME">decodeEncodedWord: contents charset: charset encoding: encodingString	| encoding  | 	encoding := encodingString asLowercase.	(#('b' base64) includes: encoding) 		ifTrue: [ ^self class decodeBase64From: contents charset: charset].	(#('q' 'quoted-printable') includes: encoding) 		ifTrue: [^self class decodeQuotedPrintable: contents charset: charset ].	(#('uue' 'uuencode' 'x-uue' 'x-uuencode') includes: encoding)		ifTrue: [^self class 				decodeUUEncodedFrom: 1				to: contents size				in: contents].	^nil.									" Failed to decode "</body><body package="MIME">decodeFrom: aStream on: output onError: aBlock	|  charset encoding scanner word |	scanner := SimpleScanner on: aStream.	charset := scanner scanUntil: [ scanner hereChar = $? ].	(charset isEmpty 		or: [	[ StreamEncoder new: charset. false ] on: KeyNotFoundError do: [ :ex | true ] ]	) ifTrue: [ ^aBlock value].	encoding := scanner scanUntil: [ scanner hereChar = $? ].	(encoding = 'Q' or: [encoding = 'B']) ifFalse: [ ^aBlock value]. 	word := scanner upToAndSkipThroughAll:  '?='. 	[word := self  			decodeEncodedWord: word			charset: charset			encoding: encoding	] on: Error do: [ :ex | word := nil. ex return].	word ifNil: [^aBlock value].	output nextPutAll: word</body><body package="MIME">scanSpaces	| spaces |	spaces := self scanWhile: [self matchCharacterType: WhiteSpaceMask].	self scanWhile: [self matchCharacterType: CRLFMask].	^spaces, (self scanWhile: [self matchCharacterType: WhiteSpaceMask]).</body><body package="MIME">scanWord	^self scanWhile: [(self matchCharacterType: WhiteSpaceMask) not].</body><body package="MIME">shouldAddSpaces	| pos mask |	pos := self position.	self atEnd ifFalse: [mask := self next: 2].	self position: pos.		^(('=?' = mask) and: [tokenType = #encoded]) not</body></methods><methods><class-id>Net.MimeEncodedWordCoDec class</class-id> <category>encoding</category><body package="MIME">encodeAsBase64: aString charset: charset	| stream  |	stream := DecodedStream 				on: (String new: 32) writeStream 				encodedBy:  (B64StreamDecoder asEncoder lineLength: 100000; yourself). 	(EncodedStream on: stream encodedBy: (StreamEncoder new: charset))		nextPutAll: aString;		close.	^stream encodedContents.</body><body package="MIME">encodeComment: aString asBase64Using: anEncodingString	^'(' , (self encodeText: aString asBase64Using: anEncodingString) , ')'</body><body package="MIME">encodeIfRequired: string using: anEncoding	^self 		encodeIfRequired: string 		using: anEncoding 		do: [ :encoding | self encodeWord: string asQuotedPrintableUsing: encoding]</body><body package="MIME">encodeIfRequired: string using: anEncoding do: aBlock	| wordEncoding |	wordEncoding := (anEncoding == nil		ifTrue: [(self findEncodingFor: string) asString]		ifFalse: [ anEncoding ]).	('us-ascii' match: wordEncoding) ifTrue: [ ^string].	^wordEncoding notNil 		ifTrue: [aBlock value: wordEncoding  ]		ifFalse: [string]</body><body package="MIME">encodeQuotedPrintable: aString on: aStream charset: charset	| quoted streamx |	streamx := DecodedStream 				on: String new readWriteStream				encodedBy: QuotedPrintableDecoder asEncoder. 	streamx nextPutAll: (aString asByteArrayEncoding: charset).	streamx close.	quoted := streamx encodedContents. 	quoted first = $" ifTrue: [ quoted := quoted copyFrom: 2 to: quoted size].	quoted do: [ :ch |		ch = $_			ifTrue: [aStream  nextPutAll: '=5F' ]			ifFalse: [aStream nextPut: ch]]</body><body package="MIME">encodeText: aString asBase64Using: anEncodingString"Encoding *text token separated from any adjacent encoded word or text by a linear-white-space"	| result tokens stream contents |	^self 		encodeIfRequired: aString 		using: anEncodingString		do: 			[ :encoding | 			result := (String new: 256) writeStream.			tokens := OrderedCollection new.			aString size &gt; 44				ifTrue: 					[stream := aString readStream.					[stream atEnd ]									whileFalse: 							[ tokens add: ( stream next: 44 ). 							stream position + 44 &gt; aString size								ifTrue: [ tokens add: stream upToEnd]]]				ifFalse: [ tokens add: aString].				tokens 					do: [ :token | 						result nextPutAll: (self encodeWord: token asBase64Using: encoding).						result cr; tab. ].				contents := result contents. 				contents copyFrom: 1 to: contents size - 2. ]</body><body package="MIME">encodeText: aString asQuotedPrintableUsing: anEncodingString"Encoding *text token separated from any adjacent encoded word or text by a linear-white-space"	| result contents |	^self 		encodeIfRequired: aString 		using: anEncodingString		do: 			[ :encoding | 			result := (String new: 256) writeStream.			aString 				piecesCutWhere: [:each :next | each = Character space ] 				do: [ :each | 					(self encodeWord: each asQuotedPrintableUsing: encoding)						do: [ :ch |							ch ~= Character space								ifTrue: [ result nextPut: ch]								ifFalse: [result nextPutAll: '=20' ]].					result nextPut: Character space]. 			contents := result contents.			contents copyFrom: 1 to: contents size -1  ]</body><body package="MIME">encodeWord: aString asBase64Using: charset	^self 		getEncodedWordDo: [ :stream | stream nextPutAll: (self encodeAsBase64: aString charset: charset)]		charset: charset 		encoding: 'B'</body><body package="MIME">encodeWord: aString asQuotedPrintableUsing: charset	^self 		getEncodedWordDo: [ :stream | self encodeQuotedPrintable: aString on: stream charset: charset ]		charset: charset 		encoding: 'Q'</body><body package="MIME">getEncodedWordDo: aBlock charset: charset encoding: aString	| result |	result := (String new: 256)  writeStream. 	result 		nextPutAll: '=?';		nextPutAll: charset;		nextPutAll: '?';		nextPutAll: aString;		nextPutAll: '?'.	aBlock value: result.	result nextPutAll: '?='.	^result contents</body></methods><methods><class-id>Net.MimeEncodedWordCoDec class</class-id> <category>testing</category><body package="MIME">shouldBeEncoded: aString	^(aString detect: [:char | char asInteger &gt; 128] ifNone: [nil]) ~~ nil</body></methods><methods><class-id>Net.MimeEncodedWordCoDec class</class-id> <category>utility</category><body package="MIME">findEncodingFor: aString 	(self shouldBeEncoded: aString) ifFalse: [^'us-ascii'].	^AvailableEncodings 		detect: 			[:encoding | 				[aString asByteArrayEncoding: encoding. 				true] on: Error do: [:ex | false]]		ifNone: [].</body></methods><methods><class-id>Net.MimeEncodedWordCoDec class</class-id> <category>decoding</category><body package="MIME">decode: word 	^self new decode: word</body><body package="MIME">decodeBase64From: aString charset: charset 	| stream |	stream := DecodedStream 						on: aString readStream 						encodedBy: B64StreamDecoder asEncoder.	^(EncodedStream on: stream encodedBy: (StreamEncoder new: charset)) contents</body><body package="MIME">decodeComment: commentString	^self decodeText: commentString</body><body package="MIME">decodePhrase: words" decode phrase word by word; concatenate decoded words and answer concatenated string "	^self new decodePhrase: words</body><body package="MIME">decodePhrase: words printOn: stream 	self new decodePhrase: words printOn: stream</body><body package="MIME">decodeQuotedPrintable: aString charset: charset"RFC2047 (2) The 8-bit hexadecimal value 20 (e.g., ISO-8859-1 SPACE) may be		       represented as '_' (underscore, ASCII 95.).  "	| contents stream |	contents := aString copyReplaceAll: '_' with: (String with: (Character value: 16r20)). 	stream := DecodedStream 				on: contents readStream 				encodedBy: QuotedPrintableDecoder asEncoder.	^(EncodedStream on: stream encodedBy: (StreamEncoder new: charset)) contents</body><body package="MIME">decodeText: text 	^self new decodeText: text</body><body package="MIME">decodeUUEncodedFrom: startIndex to: farEndIndex in: aString	"decode aString from startIndex to farEndIndex as uuencode-encoded"	| endIndex i cr space output data |	endIndex := farEndIndex - 2.	[endIndex &lt;= startIndex	or: [(aString at: endIndex + 1) = $e		and: [(aString at: endIndex + 2) = $n		and: [(aString at: endIndex + 3) = $d]]]]		whileFalse:			[endIndex := endIndex - 1].	i := (aString			findString: 'begin'			startingAt: startIndex			ignoreCase: true			useWildcards: false) first.	i = 0 ifTrue: [i := startIndex].	cr := Character cr.	space := Character space asInteger.	output := (data := ByteString new: endIndex - startIndex * 3 // 4) writeStream.	[[i &lt; endIndex	and: [(aString at: i) ~= cr]] whileTrue: [i := i + 1].	i &lt; endIndex] whileTrue:		[| count |		count := (aString at: (i := i + 1)) asInteger - space bitAnd: 8r77.		i := i + 1.		count = 0			ifTrue: [i := endIndex]			ifFalse:				[[count &gt; 0] whileTrue:					[| m n o p |					m := (aString at: i) asInteger - space bitAnd: 8r77.					n := (aString at: i + 1) asInteger - space bitAnd: 8r77.					o :=  (aString at: i + 2) asInteger - space bitAnd: 8r77.					p :=  (aString at: i + 3) asInteger - space bitAnd: 8r77.					count &gt;= 1 ifTrue:						[output nextPut: (Character value: (m bitShift: 2) + (n bitShift: -4)).						count &gt;= 2 ifTrue:							[output nextPut: (Character value: ((n bitShift: 4) + (o bitShift: -2) bitAnd: 16rFF)).							count &gt;= 3 ifTrue:								[output nextPut: (Character value: ((o bitShift: 6) + p bitAnd: 16rFF))]]].					i := i + 4.					count := count - 3]]].	^data copyFrom: 1 to: output position</body></methods><methods><class-id>Net.MimeEncodedWordCoDec class</class-id> <category>initialize-release</category><body package="MIME">initialize	self initializeAvalibleEncoding</body><body package="MIME">initializeAvalibleEncoding	"self initializeAvalibleEncoding"	AvailableEncodings := ((1 to: 15) collect: [:i | ('iso8859-' , i printString) asSymbol]) asOrderedCollection.	AvailableEncodings addAll: ((1 to: 15) collect: [:i | ('iso-8859-' , i printString) asSymbol]) asOrderedCollection.	AvailableEncodings 		addFirst: #'us-ascii';		addLast: Locale current defaultEncoding;		addLast: #'utf-8'.	^AvailableEncodings</body></methods><methods><class-id>OS.Filename</class-id> <category>net clients</category><body package="MIME">replaceContentsOfMimeEntity: aNetMimeEntity 	^aNetMimeEntity replaceContentsWithFile: self</body></methods><methods><class-id>Core.String</class-id> <category>private - mime</category><body package="MIME">replaceContentsOfMimeEntity: aNetMimeEntity		^aNetMimeEntity replaceContentsWithString: self</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>private - mime</category><body package="MIME">replaceContentsOfMimeEntity: aNetMimeEntity		^aNetMimeEntity replaceContentsWithSequence: self</body></methods><methods><class-id>Core.ByteArray</class-id> <category>private - mime</category><body package="MIME">replaceContentsOfMimeEntity: aNetMimeEntity 		^aNetMimeEntity replaceContentsWithByteArray: self</body></methods><methods><class-id>Kernel.BlockClosure</class-id> <category>private - mime</category><body package="MIME">replaceContentsOfMimeEntity: aNetMimeEntity 	^aNetMimeEntity replaceContentsWithBlock: self</body></methods><methods><class-id>Core.Stream</class-id> <category>private - mime</category><body package="MIME">replaceContentsOfMimeEntity: aNetMimeEntity "Use the receiver as the source of the MimeEntity, it must be readable and provide bytes or characters."	^aNetMimeEntity replaceContentsWithStream: self</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="MIME">isMimeEntity	^false</body><body package="MIME">isUnparsedHeaderValue		^false</body></methods><initialize><class-id>Net.HeaderField</class-id></initialize><initialize><class-id>Net.RFC822Scanner</class-id></initialize><initialize><class-id>Net.MimeScanner</class-id></initialize><initialize><class-id>Net.MimeEncodedWordCoDec</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Stream</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private IOConstants.*			</imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>SequenceableCollection</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>Filename</name><environment>OS</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>osName publicName logicalName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Support</category><attributes><package>OS-Support</package></attributes></class><class><name>SimpleScanner</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>source hereChar token tokenType saveComments currentComment classificationMask sourceTrailStream acceptNonAsciiCharacters </inst-vars><class-inst-vars>classificationTable acceptNonAsciiCharacters </class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><class><name>ByteArray</name><environment>Core</environment><super>Core.IntegerArray</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>NetError</name><environment>Net</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><class><name>StreamEncoder</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>encoder errorPolicy skipRecord </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>MessageElement</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>source parent value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><class><name>BlockClosure</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method outerContext copiedValues </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>NetNotification</name><environment>Net</environment><super>Core.Notification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class></st-source>