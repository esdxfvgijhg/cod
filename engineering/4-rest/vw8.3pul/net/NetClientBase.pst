<?xml version="1.0"?><st-source><!-- Name: NetClientBaseNotice: Copyright 1999-2016 Cincom Systems, Inc.  All rights reserved.Comment: Provides the core classes shared by the various protocol implementations in the Internet Connectivity Toolkit. If you want to load the entire Internet Connectivity Toolkit, load the NetClients package.The most interesting classes from the user point of view are HostSpec, NetClient and NetUser. Some are subclassed for specific protocol aspects, but there is a fair amount of shared protocol and capabilities coming directly from these clases.DbIdentifier: bear73DbTrace: 496862DbUsername: tkoganDbVersion: 8.3 - 3DevelopmentPrerequisites: #(#(#any 'Protocols-Common' ''))PackageName: NetClientBaseParcel: #('NetClientBase')ParcelName: NetClientBasePrerequisiteParcels: #(#('Protocols-Common' ''))PrintStringCache: (8.3 - 3,tkogan)Version: 8.3 - 3Date: 2:30:29 PM April 28, 2017 --><time-stamp>From VisualWorks®, Pre-Release 8.3 (apr17.3) of April 28, 2017 on April 28, 2017 at 2:30:29 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>Net</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			private OS.IOConstants.*			Protocols.*			</imports><category>Net-Namespace</category><attributes><package>NetClientBase</package></attributes></name-space><comment><name-space-id>Net</name-space-id><body>Net is the namespace for the the Net clients.</body></comment><class><name>NetError</name><environment>Net</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><comment><class-id>Net.NetError</class-id><body>NetError is supert class for all Net client errors</body></comment><class><name>MessageElement</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>source parent value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><comment><class-id>Net.MessageElement</class-id><body>MessageElement is abstract class for MIME header and body components.Subclasses must implement the following messages:	parsing		parse:Instance Variables:	parent	&lt;MimeEntity&gt;	the message body parent or mime entity parent if the message if multipart	source	&lt;Stream&gt;	the message source stream	value	&lt;MimeEntity|SimpleBody|MultipartBody&gt; the contents of the message element</body></comment><class><name>NetClientState</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>client </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><comment><class-id>Net.NetClientState</class-id><body>NetClientState is the abstract superclass for client protocol states.Subclasses must implement the following messages:	accessing		stateErrorClassInstance Variables:	client	&lt;NetClient&gt;	 a mail client </body></comment><class><name>NetNotification</name><environment>Net</environment><super>Core.Notification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><comment><class-id>Net.NetNotification</class-id><body>NetNotification is super class for all Net client notificationsShared Variables	LogToTranscript &lt;Boolean&gt; if it is true all notifications will printed to Transcript. It is false by default.</body></comment><class><name>MailIncrementNotification</name><environment>Tools</environment><super>Net.NetNotification</super><private>false</private><indexed-type>none</indexed-type><inst-vars>endingCount </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><comment><class-id>Tools.MailIncrementNotification</class-id><body>This notification is signaled by the mail protocol implementations to allow monitoring of progress in longer operations.Instance Variables:	endingCount	&lt;Integer&gt; final count expected against which to measure the progress</body></comment><class><name>UnsupportedCharacterReplacement</name><environment>Net</environment><super>Net.NetNotification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Support</category><attributes><package>NetClientBase</package></attributes></class><comment><class-id>Net.UnsupportedCharacterReplacement</class-id><body>UnsupportedCharacterReplacement is signaled by the ReplaceUnsupportedCharacters stream error policy. This allows mime parsers to recover when encountering characters that are not supported by the parser encoder. This notification can be resumed with specific replacement character. By default, the invalid characters will be replaced with ASCII character NUL (code 0).	Example (in this case the trademark character is not valid in ISO-8859-1 encoding (the default encoding for header fields) and gets replaced with an underscore):	string := 'Date: Mon, 19 May 2003 13:52:36 +0200Subject: hello Content-Type: multipart/mixed; boundary="----------lNT1O53UKi8GkFrVZPze3O"------------lNT1O53UKi8GkFrVZPze3OContent-Disposition: attachment; filename="Cinom™.txt"Content-Type: application/octet-stream; name="Cinom™.txt"some bytes------------lNT1O53UKi8GkFrVZPze3O--'.	[	MimeBuildHandler new			removeContentTransferEncoding: true;			readFrom: string readStream. 	]	on: UnsupportedCharacterReplacement 		do: [ :ex | ex resume: $_  ].</body></comment><class><name>SimpleScanner</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>source hereChar token tokenType saveComments currentComment classificationMask sourceTrailStream acceptNonAsciiCharacters </inst-vars><class-inst-vars>classificationTable acceptNonAsciiCharacters </class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><comment><class-id>Net.SimpleScanner</class-id><body>Scanners are used to tokenize the contents of individual protocol messages.Subclasses must implement the following messages:	tokenization		nextTokenInstance Variables:	buffer	&lt;WriteStream&gt;	buffer	classificationMask	&lt;Integer&gt;	classification mask for the current character (hereChar)	currentComment	&lt;String&gt;	current comment	hereChar	&lt;Character&gt;	current character	lineEndCRLF	&lt;Number&gt;	 lineEndCRLF	saveComments	&lt;Boolean&gt;	defines whether or not to save comments	source	&lt;EncodedStream&gt;	stream to parse	sourceTrailStream	&lt;WriteStream&gt;	can hold a copy of parsed source if it is set on (#sourceTrailOn)	token	&lt;String&gt;	current token	tokenType	&lt;ByteSymbol&gt;	token type	acceptNonAsciiCharacters &lt;Boolean&gt; if the option is false the NonASCIICharacter exception will be raised in cases if there is no classification mask in the classification table. If the option is true the hereChar will be set to the non ascii character.Class Instance Variables:	acceptNonAsciiCharacters &lt;Boolean&gt; the default value 	classificationTable &lt;WordArray&gt; the table is used to validate types of scanned characters. </body></comment><class><name>UTF7StreamEncoder</name><environment>Net</environment><super>Protocols.Base64StreamEncoder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>shifting specialCharacters </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><comment><class-id>Net.UTF7StreamEncoder</class-id><body>UTF7StreamEncoder is used in the context of EncodedStreams to encode/decode UTF7 character encoding.</body></comment><class><name>NetClientError</name><environment>Net</environment><super>Net.NetError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><comment><class-id>Net.NetClientError</class-id><body>NetClientErrors are raised by the mail clients for various protocol related errors.</body></comment><class><name>MimeTypeDescriptor</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>contentType binary properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><comment><class-id>Net.MimeTypeDescriptor</class-id><body>MimeTypeDescriptor is used to set the Content-Type field for a MimeEntity. Instance Variables:	contentType	&lt;String&gt; 'type/subtype' string. Should be lowercase	binary	&lt;Boolean&gt; answers whether or not this type is binary	properties	&lt;Dictionary&gt; can hold additional descriptionShared Class Variables:	FileExtensionToMimeTypeMap	&lt;Dictonary key: String value: String&gt; maps file extensions to mime type strings	MimeCharsetToEncodingMap	&lt;Dictionary key: Symbol value: Symbol&gt; maps encoding symbols used by VW to Mime charset identifiers	MimeTypeRegistry	&lt;Dictionary key: String value: MimeTypeDescriptor&gt; maps Mime type strings to descriptor instances</body></comment><class><name>StreamSegment</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>source offset size position </inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.IOConstants.*			</imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><comment><class-id>Net.StreamSegment</class-id><body>StreamSegment are used to delimit portions of readable streams and representing them as virtual substreams. A segment will not allow reading or writing outside of its boundaries and ensures that the underlying streams is properly positioned for any stream operation performed on the segment.Instance Variables:	offset	&lt;SmallInteger&gt;	the parent stream position the segment starts from	position	&lt;SmallInteger&gt;	current segment position	size	&lt;SmallInteger&gt;	the segment size	source	&lt;Stream&gt;	the parent stream</body></comment><class><name>NetConnection</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream settings </inst-vars><class-inst-vars>encoding </class-inst-vars><imports>			private OS.IOConstants.*			</imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><comment><class-id>Net.NetConnection</class-id><body>This is an abstract superclass for NetClient connections. It maintains its connection/socket streamSubclasses must implement the following messages:	class default values		defaultPortNumberInstance Variables	stream	&lt;ExternalReadAppendStream&gt;	external connection stream	settings  	&lt;NetPISettings&gt;  communication environmentClass Instance Variables	encoding &lt;Symbol&gt; default stream encoding</body></comment><class><name>InvalidAddressSpec</name><environment>Net</environment><super>Net.NetError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>NetClientBase</category><attributes><package>NetClientBase</package></attributes></class><comment><class-id>Net.InvalidAddressSpec</class-id><body>The exception is raised is the NetworkAddressParser detected an error in the network address. The exception is proceedable.</body></comment><class><name>HostSpec</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name netUser type port isSecure useSTARTTLS </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><comment><class-id>Net.HostSpec</class-id><body>HostSpec describes a network server and an associated user account. There are convenience instance creation methods on the class side that allow to create an instance easily just by providing host string (which can include the port number as for example 'localhost:20'), and user name and passwordInstance Variables:	name	&lt;String&gt;	the server host name (the DNS address)	netUser	&lt;NetUser&gt;	the user information used for authentication with the server	port	&lt;Number&gt;	the server port number	type	&lt;String&gt;	the protocol that the server supports such as 'http'/'imap'	isSecure	&lt;Boolean&gt; should we use SSL tunneling ?	useSTARTTLS &lt;Boolean&gt; should we upgrade connection to TLS/SSL if it is available. SMTPClient is the only client that supports this option right now.</body></comment><class><name>NetProtocolInterpreter</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>connection settings </inst-vars><class-inst-vars>defaultNetConnection </class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><comment><class-id>Net.NetProtocolInterpreter</class-id><body>Protocol interpreters implement the specific mechanics of the various protocols. They represent and execute the rules controlling the communication with the server. They are internal components used by the clients to perform their communications. The communication is conducted over a network connection represented by NetConnection classes.The only interface between the PI and NetConnection is through 	connectToHost: port: timeout: 	disconnect The #useSecureConnection/#useDefaultConnection messages will switch between secured and unsecured connection.Instance Variables:	connection	&lt;NetConnection&gt; client's connection to the serverClass Instance Variables:	defaultNetConnection	&lt;Class&gt; the default connection classShared Class Variables:	CRLF	&lt;String&gt; constant string containing the CRLF character sequence</body></comment><class><name>Settings</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>dependents </class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><comment><class-id>Net.Settings</class-id><body>Settings is a central repository for various configurable parameters of Internet Connectivity clients.Shared Class Variables:	Registry	&lt;IdentityDictionary&gt; holds all settings</body></comment><class><name>ScannedLineSkipped</name><environment>Net</environment><super>Net.NetNotification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><comment><class-id>Net.ScannedLineSkipped</class-id><body>ScannedLineSkipped warns that the scanner skipped a line</body></comment><class><name>NetClient</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>user hostName portNumber clientPI state </inst-vars><class-inst-vars>defaultProtocolInterpreterClass </class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><comment><class-id>Net.NetClient</class-id><body>NetClient is the abstract superclass for specific clients. However, a good deal of useful protocol, especially with respect to connections, is inherited from NetClient. Net clients do not not handle the connections directly, that is done by the associated "protocol interpreter" (PI). Subclasses must implement the following messages:	accessing		protocolInterpreterClass	connection		isConnected		closeInstance Variables	user	&lt;NetUser&gt; net user authorization information	hostName	&lt;String&gt; the host name to connect to	portNumber	&lt;Number&gt; the host port number	clientPI	&lt;NetProtocolInterpreter&gt; protocol interpreter	state	&lt;NetClientState&gt; current state of the mail clientClass Instance Variables	defaultProtocolInterpreterClass	&lt;NetProtocolInterpreter&gt; the default PI class to use for given client typeShared Class Variables:	DefaultIncomingMailClient	&lt;POP3Client | IMAPClient&gt; default client to use for outgoing mail	DefaultOutgoingMailClient	&lt;SMTPClient&gt; default client to use for incoming mail	MailRegistry	&lt;Dictionary key: Symbol value: Symbol&gt; maps mail protocol monikers to mail client class namesNetClient provides instance creation methods:	#connectToHost: hostName	#connectToHost: hostName port: portNum		- Creates a client instance and establishes a connection to hostName, a String, on the default port for the protocol. If portNum is specified, that port is used instead of the default.	#host: hostName	#host: hostName port: portNum		- Creates a client instance targeted on hostName, a String, on the default port for the protocol. If portNum is specified, that port is used instead of the default.Instance methods provide connection support, and allow you to set or get user and host information. Browse the accessing and connection method categories for useful messages.There are some exceptions but general protocol to connect and disconnect a client is as follows:	#connect - establish socket connection with a server	#login - a client authenticates itself	#close - a client signs off and closes socket connection 	#disconnect - close socket connectionThe exception is the IMAPClient with the following differences:	#logout - the connection is being terminated, and the server will close the connection	#close - command permanently removes from the currently selected mailbox all messages that have the \Deleted flag set, and returns to authenticated state from selected stateClients use two types of connection:	a) NetConnection which is a stream wrapper for a regular socket connection and	b) SSLConnection which provides a connection protected by the secure socket layer (SSL). To make the client use the SSL connection send #useSecureConnection message to it. Message #useDefaultConnection will change the connection back to simple/unprotected socket connection.	Examples1. POP3 client with plain socket connection:	pop3Client := Pop3Client new.	pop3Client user: (NetUser username: 'username' password: 'password' ).	pop3Client hostName: 'hostname'.	pop3Client connect.2. POP3 client with secure connection	pop3Client := Pop3Client new.	pop3Client user: (NetUser username: 'username' password: 'password' ).	pop3Client hostName: 'hostname'.	pop3Client useSSLConnection.	pop3Client connect.HttpClient will open the connection based on the protocol part of the URL being accessed: http or https.</body></comment><class><name>NetUser</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>username password fullName account mailAddress </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><comment><class-id>Net.NetUser</class-id><body>NetUser holds a client authentication information. Most internet services require a user ID, and usually a password, to gain access (log in) to the service. For very simple services, such as FTP, the user name and password are simply String data. Most of the clients, however, require the user ID and password to be specified by an instance of NetUser. A NetUser instance is a convenient holder for several pieces of user information, as is done by the Network Settings tool. It holds at least the user ID and password, but also the user's full name, an account name and an email address.To create a NetUser instance, send a username:password: message to the class, with the user name and password specified as strings:	user := NetUser username: 'Fred' password: 'dont_ask'To add other information items, send the appropriate set message:	user fullName: 'Frederick P. User';		mailAddress: 'fpuser@someplace.net'.There are also setter methods for changing the user name and password, as well as getter methods for all of these data items.Instance Variables:	account	&lt;String&gt;	account	fullName	&lt;String&gt;	full user name	mailAddress	&lt;String&gt;	mail address	password	&lt;String&gt;	password	savePassword	&lt;Boolean&gt;	defines whether or not to remember the password in the Net Settings	username	&lt;String&gt;	username</body></comment><class><name>INIScanner</name><environment>Net</environment><super>Net.SimpleScanner</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><comment><class-id>Net.INIScanner</class-id><body>INIScanner is used to parse *.ini files</body></comment><class><name>NonASCIICharacter</name><environment>Net</environment><super>Net.NetError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>NetClientBase</category><attributes><package>NetClientBase</package></attributes></class><comment><class-id>Net.NonASCIICharacter</class-id><body>This exception is raised when a scanner encounters a character outside of the ASCII character range.</body></comment><class><name>NetPISettings</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tlsContext tlsSubjectVerifier retries timeout delaySeconds </inst-vars><class-inst-vars>defaultDelaySeconds defaultRetries defaultTimeout </class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><comment><class-id>Net.NetPISettings</class-id><body>The class is the NetProtocolInterpreter settingsInstance Variables	tlsContext	&lt;TLSContext&gt;	description of tlsContext	tlsSubjectVerifier &lt;BlockClosure&gt; certificate validation blockClass Instance Variables	defaultDelaySeconds	&lt;Integer&gt; default time to wait between retrying to establish a connection	defaultRetries	&lt;Integer&gt; default number of times to retry establishing a connection	defaultTimeout	&lt;Integer&gt; default wait time for a response (millisecond)</body></comment><class><name>ReplaceUnsupportedCharacters</name><environment>Net</environment><super>Core.IllegalCharacterStreamErrorPolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Support</category><attributes><package>NetClientBase</package></attributes></class><comment><class-id>Net.ReplaceUnsupportedCharacters</class-id><body>ReplaceUnsupportedCharacters raises the UnsupportedCharacterReplacement exception is there is an invalid character</body></comment><shared-variable><name>CRLF</name><environment>Net.NetProtocolInterpreter</environment><private>false</private><constant>true</constant><category>constants</category><initializer>Core.String with: (Core.Character cr) with: (Core.Character lf)</initializer><attributes><package>NetClientBase</package></attributes></shared-variable><shared-variable><name>DefaultOutgoingMailClient</name><environment>Net.NetClient</environment><private>false</private><constant>false</constant><category>defaults</category><initializer></initializer><attributes><package>NetClientBase</package></attributes></shared-variable><shared-variable><name>MailRegistry</name><environment>Net.NetClient</environment><private>false</private><constant>false</constant><category>mailRegistry</category><initializer></initializer><attributes><package>NetClientBase</package></attributes></shared-variable><shared-variable><name>DefaultIncomingMailClient</name><environment>Net.NetClient</environment><private>false</private><constant>false</constant><category>defaults</category><initializer></initializer><attributes><package>NetClientBase</package></attributes></shared-variable><shared-variable><name>TokenMask</name><environment>Net.INIScanner</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><initializer>16384</initializer><attributes><package>NetClientBase</package></attributes></shared-variable><shared-variable><name>CommentChars</name><environment>Net.INIScanner</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><initializer>Array with: Character cr with: $# with: Character lf</initializer><attributes><package>NetClientBase</package></attributes></shared-variable><shared-variable><name>EndOfLineMask</name><environment>Net.SimpleScanner</environment><private>false</private><constant>false</constant><category>masks</category><initializer>16</initializer><attributes><package>NetClientBase</package></attributes></shared-variable><shared-variable><name>AnyTextMask</name><environment>Net.SimpleScanner</environment><private>false</private><constant>false</constant><category>masks</category><initializer>37376</initializer><attributes><package>NetClientBase</package></attributes></shared-variable><shared-variable><name>CRLFMask</name><environment>Net.SimpleScanner</environment><private>false</private><constant>false</constant><category>masks</category><initializer>8</initializer><attributes><package>NetClientBase</package></attributes></shared-variable><shared-variable><name>DigitMask</name><environment>Net.SimpleScanner</environment><private>false</private><constant>false</constant><category>masks</category><initializer>2</initializer><attributes><package>NetClientBase</package></attributes></shared-variable><shared-variable><name>WhiteSpaceMask</name><environment>Net.SimpleScanner</environment><private>false</private><constant>false</constant><category>masks</category><initializer>4</initializer><attributes><package>NetClientBase</package></attributes></shared-variable><shared-variable><name>CRLF</name><environment>Net.SimpleScanner</environment><private>false</private><constant>false</constant><category>masks</category><initializer>Array with: Character cr with: Character lf</initializer><attributes><package>NetClientBase</package></attributes></shared-variable><shared-variable><name>Cr</name><environment>Net.SimpleScanner</environment><private>false</private><constant>false</constant><category>masks</category><initializer>Character cr</initializer><attributes><package>NetClientBase</package></attributes></shared-variable><shared-variable><name>Lf</name><environment>Net.SimpleScanner</environment><private>false</private><constant>false</constant><category>masks</category><initializer>Character lf</initializer><attributes><package>NetClientBase</package></attributes></shared-variable><shared-variable><name>NilMask</name><environment>Net.SimpleScanner</environment><private>false</private><constant>false</constant><category>masks</category><initializer>0</initializer><attributes><package>NetClientBase</package></attributes></shared-variable><shared-variable><name>AlphabeticMask</name><environment>Net.SimpleScanner</environment><private>false</private><constant>false</constant><category>masks</category><initializer>1</initializer><attributes><package>NetClientBase</package></attributes></shared-variable><shared-variable><name>LastUser</name><environment>Net.NetUser</environment><private>false</private><constant>false</constant><category>local globals</category><attributes><package>NetClientBase</package></attributes></shared-variable><shared-variable><name>LogToTranscript</name><environment>Net.NetNotification</environment><private>false</private><constant>false</constant><category>default</category><initializer>false</initializer><attributes><package>NetClientBase</package></attributes></shared-variable><shared-variable><name>Registry</name><environment>Net.Settings</environment><private>false</private><constant>false</constant><category>registry</category><attributes><package>NetClientBase</package></attributes></shared-variable><shared-variable><name>MimeTypeRegistry</name><environment>Net.MimeTypeDescriptor</environment><private>false</private><constant>false</constant><category>registries</category><attributes><package>NetClientBase</package></attributes></shared-variable><shared-variable><name>FileExtensionToMimeTypeMap</name><environment>Net.MimeTypeDescriptor</environment><private>false</private><constant>false</constant><category>registries</category><attributes><package>NetClientBase</package></attributes></shared-variable><shared-variable><name>MimeCharsetToEncodingMap</name><environment>Net.MimeTypeDescriptor</environment><private>false</private><constant>false</constant><category>registries</category><attributes><package>NetClientBase</package></attributes></shared-variable><shared-variable><name>FileURL</name><environment>Net</environment><private>false</private><constant>true</constant><category>Compatibility</category><initializer> OS.FileURL </initializer><attributes><package>NetClientBase</package></attributes></shared-variable><shared-variable><name>URLwithAuthority</name><environment>Net</environment><private>false</private><constant>true</constant><category>Compatibility</category><initializer> OS.URLwithAuthority </initializer><attributes><package>NetClientBase</package></attributes></shared-variable><shared-variable><name>URLwithPath</name><environment>Net</environment><private>false</private><constant>true</constant><category>Compatibility</category><initializer> OS.URLwithPath </initializer><attributes><package>NetClientBase</package></attributes></shared-variable><shared-variable><name>URI</name><environment>Net</environment><private>false</private><constant>true</constant><category>Compatibility</category><initializer> OS.URI </initializer><attributes><package>NetClientBase</package></attributes></shared-variable><shared-variable><name>UnknownURLType</name><environment>Net</environment><private>false</private><constant>true</constant><category>Compatibility</category><initializer> OS.UnknownURLType </initializer><attributes><package>NetClientBase</package></attributes></shared-variable><shared-variable><name>URL</name><environment>Net</environment><private>false</private><constant>true</constant><category>Compatibility</category><initializer> OS.URL </initializer><attributes><package>NetClientBase</package></attributes></shared-variable><methods><class-id>Net.MessageElement</class-id> <category>accessing</category><body package="NetClientBase">parent	^parent</body><body package="NetClientBase">parent: anObject	parent := anObject</body><body package="NetClientBase">source	^source</body><body package="NetClientBase">source: anObject	source := anObject</body><body package="NetClientBase">sourceContents	^self source contents</body><body package="NetClientBase">sourceSize	^self source size</body><body package="NetClientBase">value	^self getValue</body><body package="NetClientBase">value: anObject	value := anObject</body></methods><methods><class-id>Net.MessageElement</class-id> <category>parsing</category><body package="NetClientBase">parse	^self parse: (self scannerOn: self source)</body><body package="NetClientBase">parse: scanner" Each message element has responsibility to parse itself. The argument is an appropriate scanner. Scanners for RFC822, Mime and HTTP messages are stream wrappers, so they can be used to read and tokenize input stream "	^self subclassResponsibility</body><body package="NetClientBase">readFrom: aStream" Each message element has responsibility to read itself from input stream. Reading usually involves parsing, so implementations of this method typically create an instance of lexical scanner and invoke a parser (see explanation for parse: method) "	self source: aStream.	^self parse</body><body package="NetClientBase">scannerOn: aStream" Each element should know what the underlying syntax is. For example, structured fields would mostly use MIME syntax and tokenize input streams into MIME 'tokens' while &lt;address-spec&gt; which is part of many standards, has to be tokenized using RFC822 syntax (using RFC822 'atoms') "	^self class scannerOn: aStream</body><body package="NetClientBase">valueFrom: aString " Swazoo compatibility"	^self readFrom: aString readStream</body></methods><methods><class-id>Net.MessageElement</class-id> <category>visiting</category><body package="NetClientBase">acceptVisit: aVisitor with: argument" Override by invoking appropriate message on the visitor "</body></methods><methods><class-id>Net.MessageElement</class-id> <category>printing</category><body package="NetClientBase">printOn: aStream	self printOn: aStream indent: 0</body><body package="NetClientBase">printOn: aStream indent: level	^self subclassResponsibility</body><body package="NetClientBase">storeOn: aStream 	self printOn: aStream</body></methods><methods><class-id>Net.MessageElement</class-id> <category>copying</category><body package="NetClientBase">postCopy	super postCopy.	parent := nil.</body></methods><methods><class-id>Net.MessageElement</class-id> <category>private</category><body package="NetClientBase">getValue	^value</body></methods><methods><class-id>Net.MessageElement</class-id> <category>composing</category><body package="NetClientBase">writeOn: aStream" Writing can be different from printing. Printing may be indented, abbreviatedand otherwise formatted for readability. Writing is used to actually send message.Default implementation is the same "	self subclassResponsibility</body></methods><methods><class-id>Net.MessageElement class</class-id> <category>instance creation</category><body package="NetClientBase">new	^super new initialize</body></methods><methods><class-id>Net.MessageElement class</class-id> <category>parsing</category><body package="NetClientBase">readFrom: aStream" Each message element has responsibility to read itself from input stream. Reading usually involves parsing, so implementations of this method create an instance of lexical scanner and invoke a parser (see explanation for parse: method) "	^self new readFrom: aStream</body><body package="NetClientBase">scannerOn: aStream 	^(aStream isKindOf: self scannerType)		ifTrue: [aStream]		ifFalse: [self scannerType on: aStream asStream]</body><body package="NetClientBase">scannerType	self subclassResponsibility</body></methods><methods><class-id>Net.NetClientState</class-id> <category>accessing</category><body package="NetClientBase">client	^client</body><body package="NetClientBase">client: aMailClient	client := aMailClient</body><body package="NetClientBase">stateErrorClass	^self subclassResponsibility</body></methods><methods><class-id>Net.NetClientState</class-id> <category>errors</category><body package="NetClientBase">signalError	^self stateErrorClass raiseSignal</body></methods><methods><class-id>Net.NetNotification</class-id> <category>private - actions</category><body package="NetClientBase">defaultAction	self class logToTranscript ifTrue: [		Transcript cr; show: (			'%&lt;&lt;1s&gt;%&gt; &lt;2s&gt; [^&lt;3p&gt;]'				expandMacrosWith: self class fullName				with: self description				with: self defaultResumeValue ) ].	^self defaultResumeValue</body></methods><methods><class-id>Net.NetNotification class</class-id> <category>accessing</category><body package="NetClientBase">logToTranscript	^LogToTranscript</body><body package="NetClientBase">logToTranscript: aBoolean	LogToTranscript := aBoolean</body></methods><methods><class-id>Tools.MailIncrementNotification</class-id> <category>accessing</category><body package="NetClientBase">endingCount: aNumber	endingCount := aNumber</body><body package="NetClientBase">ticks	"Answer the number of ticks were signalled."	^parameter == nil		ifTrue: [ 1 ]		ifFalse: [ parameter ]</body></methods><methods><class-id>Tools.MailIncrementNotification class</class-id> <category>signalling</category><body package="NetClientBase">signalWith: aParameter endingCount: endingCount	"Raise an an exception with parameter set to aParameter."	^self new 		searchFrom: thisContext sender;		originator: thisContext sender homeReceiver;		parameter: aParameter;		endingCount: endingCount;		raiseSignal.</body></methods><methods><class-id>Net.UnsupportedCharacterReplacement</class-id> <category>private</category><body package="NetClientBase">defaultResumeValue	^0</body></methods><methods><class-id>Net.UnsupportedCharacterReplacement</class-id> <category>private - actions</category><body package="NetClientBase">defaultAction	| s |	self class logToTranscript 		ifTrue: [ s := (#WillBeReplacedBy &lt;&lt; #net &gt;&gt; ' will be replaced by ') asString.				Transcript cr; show:'&lt;', self class fullName , '&gt; ', self parameter printString, s,  self defaultResumeValue printString ].	^self defaultResumeValue</body></methods><methods><class-id>Net.SimpleScanner</class-id> <category>stream interface -- reading</category><body package="NetClientBase">atEnd	^source atEnd</body><body package="NetClientBase">binary	source binary</body><body package="NetClientBase">contents	^source contents</body><body package="NetClientBase">contentsSpecies	^source contentsSpecies</body><body package="NetClientBase">next	self hereChar: source next.	self sourceTrailNextPut: hereChar.	^hereChar</body><body package="NetClientBase">next: anInteger 	"Answer the next anInteger elements of the receiver."	| newCollection res |	newCollection := self contentsSpecies new: anInteger.	res := self next: anInteger into: newCollection startingAt: 1.	self sourceTrailNextPutAll: res.	^res</body><body package="NetClientBase">next: anInteger into: aSequenceableCollection startingAt: startIndex 	"Store the next anInteger elements of the receiver into aSequenceableCollection 	starting at startIndex in aSequenceableCollection. Answer aSequenceableCollection."	| index stopIndex |	index := startIndex.	stopIndex := index + anInteger.	[[index &lt; stopIndex and: [self atEnd not ]]				whileTrue: [aSequenceableCollection at: index put: source next.							index := index + 1]]		on: Stream endOfStreamSignal		do: 			[:ex | ex retryUsing:					[(Stream incompleteNextCountSignal newExceptionFrom: self)						parameter: index - startIndex;						raiseRequest]].	^aSequenceableCollection</body><body package="NetClientBase">nextLine	^self scanUntil: [ self matchCharacterType: CRLFMask ]</body><body package="NetClientBase">nextLineWithoutTerminator" Answer next line. Do not inlude cr. Stream is positioned before terminating cr "	^self scanWhile: [ (self matchCharacterType: CRLFMask) not ].</body><body package="NetClientBase">peek	^source peek</body><body package="NetClientBase">peekFor: anObject 	"Answer false and do not move the position if self next ~= anObject or if the	receiver is at the end. Answer true and increment position if self next = anObject."	| nextObject |	self atEnd ifTrue: [^false].	nextObject := self next.	"peek for matching element"	anObject = nextObject ifTrue: [^true].	"gobble it if found"	self stepBack.	^false</body><body package="NetClientBase">position	^source position</body><body package="NetClientBase">position: anInt	source position: anInt</body><body package="NetClientBase">skip: integer	source skip: integer.	self sourceTrailSkip: integer.</body><body package="NetClientBase">text	^source text</body><body package="NetClientBase">throughAll: pattern	| str |	str := source throughAll: pattern.	self sourceTrailNextPutAll: str.	^str</body><body package="NetClientBase">upTo: anObject	"Answer a subcollection from position to the occurrence (if any, exclusive) of anObject.	 The stream is left positioned after anObject.	If anObject is not found answer everything."	| newStream element |	newStream := (self contentsSpecies new: 64) writeStream.	[self atEnd]		whileFalse:			[element := self next.			element = anObject				ifTrue: [^newStream contents].			newStream nextPut: element.].	^newStream contents</body><body package="NetClientBase">upToAll: pattern 	| str |	str := source upToAll: pattern.	self sourceTrailNextPutAll: str.	^str</body><body package="NetClientBase">upToAndSkipThroughAll: pattern	| str |	str := source upToAndSkipThroughAll: pattern.	self sourceTrailNextPutAll: str.	^str</body><body package="NetClientBase">upToEnd	| str |	str := source upToEnd.	self sourceTrailNextPutAll: str.	^str</body></methods><methods><class-id>Net.SimpleScanner</class-id> <category>expression types</category><body package="NetClientBase">classificationMaskFor: charOrNil 	^self class 		classificationMaskFor: charOrNil 		acceptNonAsciiCharacters:  self acceptNonAsciiCharacters</body><body package="NetClientBase">classificationMaskFor: charOrNil acceptNonAsciiCharacters:  aBoolean	^self class classificationMaskFor: charOrNil acceptNonAsciiCharacters:  aBoolean</body><body package="NetClientBase">matchCharacterType: mask	^self classificationMask anyMask: mask</body><body package="NetClientBase">mustMatch: char	^self mustMatch: char notify: [self expected: (String with: char)]</body><body package="NetClientBase">mustMatch: char notify: message	self skipWhiteSpace.	(self next == char)		ifFalse: [self notify: message]</body><body package="NetClientBase">scanTokenMask: tokenMask 	"Scan token based on character mask. Answers token's value. Stream is positioned before trhe character that terminated scan"	^self scanWhile: [self matchCharacterType: tokenMask]</body><body package="NetClientBase">scanUntil: aNiladicBlock 	^self scanUntil: aNiladicBlock do: [:stream :char | stream nextPut: char]</body><body package="NetClientBase">scanUntil: aNiladicBlock do: actionBlock	"Scan token using a block until match is found. At the end of scan the stream is positioned after the 	matching character. Answers token value"	| stream |	stream := (String new: 64) writeStream.		[self atEnd		ifTrue: 			[self hereChar: nil.			^stream contents].	self step.	aNiladicBlock value]		whileFalse: [actionBlock value: stream value: hereChar].	^stream contents</body><body package="NetClientBase">scanWhile: aNiladicBlock 	"Scan token using a block. At the end of scan the stream is positioned at the first character that does not match. hereChar is nil. Answers token value"	| str |	str := self scanUntil: [ aNiladicBlock value not ].	hereChar notNil ifTrue: [ self stepBack ].	^str</body><body package="NetClientBase">scanWhile: aNiladicBlock do: actionBlock	"Scan token using a block. At the end of scan the stream is positioned at the first character that does not match. hereChar is nil. Answers token value"	| str |	str := self scanUntil: [ aNiladicBlock value not ] do: actionBlock.	hereChar notNil ifTrue: [ self stepBack ].	^str</body><body package="NetClientBase">step	^self next.</body><body package="NetClientBase">stepBack	self skip: -1.</body></methods><methods><class-id>Net.SimpleScanner</class-id> <category>accessing</category><body package="NetClientBase">acceptNonAsciiCharacters	^acceptNonAsciiCharacters ifNil: [ acceptNonAsciiCharacters := self class acceptNonAsciiCharacters ]</body><body package="NetClientBase">acceptNonAsciiCharacters: aBoolean	acceptNonAsciiCharacters := aBoolean</body><body package="NetClientBase">classificationMask	^classificationMask</body><body package="NetClientBase">currentComment	^currentComment</body><body package="NetClientBase">hereChar	^hereChar</body><body package="NetClientBase">hereChar: char	hereChar := char.	classificationMask := self classificationMaskFor: hereChar</body><body package="NetClientBase">saveComments	^saveComments</body><body package="NetClientBase">saveComments: aValue	saveComments := aValue</body><body package="NetClientBase">size	^source size</body><body package="NetClientBase">source	^source</body><body package="NetClientBase">source: aStreamSegment	source := aStreamSegment</body><body package="NetClientBase">stream	^source stream</body><body package="NetClientBase">token	^token</body><body package="NetClientBase">tokenType	^tokenType</body></methods><methods><class-id>Net.SimpleScanner</class-id> <category>source trail</category><body package="NetClientBase">sourceTrail	| res |	sourceTrailStream notNil ifTrue: [res := sourceTrailStream contents].	sourceTrailStream := nil.	^res</body><body package="NetClientBase">sourceTrailNextPut: char 	(sourceTrailStream notNil and: [char notNil])		ifTrue: [sourceTrailStream nextPut: char]</body><body package="NetClientBase">sourceTrailNextPutAll: string	(sourceTrailStream notNil and: [string notNil])		ifTrue: [sourceTrailStream nextPutAll: string]</body><body package="NetClientBase">sourceTrailOff	sourceTrailStream := nil</body><body package="NetClientBase">sourceTrailOn	sourceTrailStream := (String new: 64) writeStream.</body><body package="NetClientBase"> sourceTrailSkip: integer	sourceTrailStream notNil		ifTrue: [sourceTrailStream skip: integer]</body></methods><methods><class-id>Net.SimpleScanner</class-id> <category>instance creation</category><body package="NetClientBase">asStream	^source</body><body package="NetClientBase">from: start to: end	^self newSize: end - start startingAt: start</body><body package="NetClientBase">newSize: size	^self species on: (self asStream newSize: size )</body><body package="NetClientBase">newSize: sizeNumber startingAt: aNumber 	^self species on: (self asStream newSize: sizeNumber startingAt: aNumber)</body></methods><methods><class-id>Net.SimpleScanner</class-id> <category>tokenization</category><body package="NetClientBase">nextToken	self subclassResponsibility</body><body package="NetClientBase">nextTokenAsAssociation" Read next token and and answer tokenType-&gt;token "	self nextToken.	^tokenType-&gt;token</body><body package="NetClientBase">scanToken: aNiladicBlock delimitedBy: anArray notify: errorMessageString " Scan next lexical token based on the criteria defined by NiladicBlock. The block is evaluated for every character read from input stream until it yields false. Stream is positioned before character that terminated scan""Example: self scanToken: [ self scanQuotedChar; matchCharacterType: DomainTextMask ] 	delimitedBy: '[]' notify: 'Malformed domain text'."	| string |	self mustMatch: anArray first.	string := self scanWhile: aNiladicBlock.	self mustMatch: anArray last notify: errorMessageString.	^string</body><body package="NetClientBase">scanTokens: textOrString 	"Answer with an Array which has been tokenized"	^self on: (ReadStream on: textOrString asString); tokenize.</body><body package="NetClientBase">tokenize	| s |	s := WriteStream on: (Array new: 16).	[self nextToken. tokenType = #doIt]		whileFalse: [s nextPut: token].	^s contents</body><body package="NetClientBase">tokenizeList: aBlock separatedBy: comparisonBlock" list = token *( separator token) "	| stream block v |	stream := (Array new: 4) writeStream.	block := [(v := aBlock value) notNil ifTrue: [stream nextPut: v]].	block value.									" Evaluate for the first element "	self tokenizeWhile: [comparisonBlock value ] do: block.	^stream contents</body><body package="NetClientBase">tokenizeUntil: aBlock do: actionBlock	[self skipWhiteSpace. self position. self nextToken. tokenType == #doIt or: aBlock]		whileFalse:  			[actionBlock value].</body><body package="NetClientBase">tokenizeWhile: aBlock	| s |	s := WriteStream on: (Array new: 16).	self tokenizeWhile: [aBlock value]		do: [s nextPut: token].	^s contents</body><body package="NetClientBase">tokenizeWhile: aBlock do: actionBlock 	| pos |		[self skipWhiteSpace.	pos := self position.	self nextToken.	tokenType ~= #doIt and: aBlock value]		whileTrue: [actionBlock value].	self position: pos	"Reset position to the beginning of the token that did not match"</body></methods><methods><class-id>Net.SimpleScanner</class-id> <category>error handling</category><body package="NetClientBase">expected: aString 	"Notify that there is a problem at current token."	^ self notify: ((#expected &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; expected')expandMacrosWith: aString)</body><body package="NetClientBase">notify: string	"Subclasses may wish to override this"	self error: string</body><body package="NetClientBase">offEnd: aString 	"Parser overrides this"	^self notify: aString</body></methods><methods><class-id>Net.SimpleScanner</class-id> <category>initialize-release</category><body package="NetClientBase">initialize	saveComments := true.	self hereChar: nil</body><body package="NetClientBase">on: inputStream 	"Bind the input stream"	self hereChar: nil.	self source: inputStream asStream</body><body package="NetClientBase">on: inputStream from: startPositionNumber to: sizeNumber 	self on: (StreamSegment			on: inputStream asStream			offset: startPositionNumber			size: sizeNumber)</body><body package="NetClientBase">scan: inputStream 	"Bind the input stream, fill the character buffers and first token buffer"	self on: inputStream.	^self nextToken</body></methods><methods><class-id>Net.SimpleScanner</class-id> <category>sunit test helpers</category><body package="NetClientBase">testScanTokens	| s st |	s := WriteStream on: (Array new: 16).	st  := WriteStream on: (Array new: 16).	[tokenType = #doIt]		whileFalse: 			[s nextPut: token. st nextPut: tokenType.			self nextToken].	^Array with: s contents with: st contents</body><body package="NetClientBase">testScanTokens: textOrString 	"Answer with an Array which has been tokenized"	self scan: (ReadStream on: textOrString asString).	^self testScanTokens.</body></methods><methods><class-id>Net.SimpleScanner</class-id> <category>positioning</category><body package="NetClientBase">close	source close</body><body package="NetClientBase">reset	"Set the receiver's position to start position."	source reset</body></methods><methods><class-id>Net.SimpleScanner</class-id> <category>printing</category><body package="NetClientBase">printToken: assoc on: stream	self class printToken: assoc on: stream</body><body package="NetClientBase">printToken: value tokenType: aSymbol on: stream	self class printToken: value tokenType: aSymbol on: stream</body></methods><methods><class-id>Net.SimpleScanner</class-id> <category>private</category><body package="NetClientBase">resetToken	token := tokenType := nil</body></methods><methods><class-id>Net.SimpleScanner</class-id> <category>testing</category><body package="NetClientBase">isScanner		^true</body></methods><methods><class-id>Net.SimpleScanner</class-id> <category>multi-character scans</category><body package="NetClientBase">skipWhiteSpace	self scanWhile: [self matchCharacterType: WhiteSpaceMask]</body></methods><methods><class-id>Net.SimpleScanner class</class-id> <category>instance creation</category><body package="NetClientBase">new	^super new initialize</body><body package="NetClientBase">on: stream	^self new on: stream</body><body package="NetClientBase">on: stream from: startPositionNumber to: sizeNumber 	^self new		on: stream		from: startPositionNumber		to: sizeNumber</body></methods><methods><class-id>Net.SimpleScanner class</class-id> <category>class initialization</category><body package="NetClientBase">initClassificationTable	classificationTable := WordArray new: 256.	self initClassificationTableWith: AlphabeticMask when:		[:c | ($a &lt;= c and: [c &lt;= $z]) or: [$A &lt;= c and: [c &lt;= $Z]]].	self initClassificationTableWith: DigitMask when:		[:c | c &gt;= $0 and: [c &lt;= $9]].	self initClassificationTableWith: WhiteSpaceMask when:		[:c | #(32 "space" 9  "tab") includes: c asInteger].	self initClassificationTableWith: CRLFMask when:		[:c | c == Character cr or: [ c == Character lf ] ].	self initClassificationTableWith: EndOfLineMask when: [:c | c == Character cr ].</body><body package="NetClientBase">initClassificationTableWith: mask when: aBlock	"Set the mask in all entries of the classificationTable for which	aBlock answers true."	0 to: classificationTable size-1 do: 		[:i |		(aBlock value: (Character value: i)) 			ifTrue:				[classificationTable 					at: i + 1 					put: ((classificationTable at: i+1) maskSet: mask)]]</body><body package="NetClientBase">initialize	"SimpleScanner initialize"	self initializeConstants; initClassificationTable</body><body package="NetClientBase">initializeConstants	AnyTextMask := 37376.	AlphabeticMask := 1.	DigitMask := 2.	WhiteSpaceMask := 4.	CRLFMask := 8.	EndOfLineMask := 16.	NilMask := 0.	Cr := Character cr.	Lf := Character lf.	CRLF := Array with: Character cr with: Character lf.</body></methods><methods><class-id>Net.SimpleScanner class</class-id> <category>accessing</category><body package="NetClientBase">acceptNonAsciiCharacters	^acceptNonAsciiCharacters ifNil: [acceptNonAsciiCharacters := self acceptNonAsciiCharactersValue ]</body><body package="NetClientBase">acceptNonAsciiCharacters: aBoolean	acceptNonAsciiCharacters := aBoolean</body><body package="NetClientBase">acceptNonAsciiCharactersValue	^false</body><body package="NetClientBase">anyTextMask		^AnyTextMask</body><body package="NetClientBase">classificationMaskFor: charOrNil 	^self 		classificationMaskFor: charOrNil 		acceptNonAsciiCharacters: self acceptNonAsciiCharacters</body><body package="NetClientBase">classificationMaskFor: charOrNil acceptNonAsciiCharacters: aBoolean	| ind |	^charOrNil isNil		ifTrue: [NilMask]		ifFalse: 			[ind := charOrNil asInteger + 1.			ind &gt; 127				ifTrue: [ ^aBoolean							ifTrue: [ AnyTextMask]							ifFalse: [ NonASCIICharacter signalWith: charOrNil] ].			self classificationTable at: ind ]</body><body package="NetClientBase">classificationTable	^classificationTable isNil		ifTrue: [ superclass classificationTable ]		ifFalse: [ classificationTable ]</body><body package="NetClientBase">classificationTable: aValue	classificationTable := aValue</body><body package="NetClientBase">cr	^Cr</body><body package="NetClientBase">crlf	^CRLF</body><body package="NetClientBase">lf	^Lf</body></methods><methods><class-id>Net.SimpleScanner class</class-id> <category>printing</category><body package="NetClientBase">defaultTokenType	self subclassResponsibility</body><body package="NetClientBase">printToken: assocOrValue on: stream 	| tokenType token |	(assocOrValue isKindOf: Association)		ifTrue: 			[tokenType := assocOrValue key.			token := assocOrValue value]		ifFalse: 			[tokenType := self defaultTokenType.			token := assocOrValue].	self printToken: token tokenType: tokenType on: stream</body><body package="NetClientBase">printToken: value tokenType: aSymbol on: stream	self subclassResponsibility</body></methods><methods><class-id>Net.SimpleScanner class</class-id> <category>character classification</category><body package="NetClientBase">whiteSpace	^String with: Character space with: Character tab</body></methods><methods><class-id>Net.UTF7StreamEncoder</class-id> <category>testing</category><body package="NetClientBase">isASCII: code	^(self isNotASCII: code) not</body><body package="NetClientBase">isNotASCII: code	^(code &lt; 31 or: [ code &gt; 127])</body></methods><methods><class-id>Net.UTF7StreamEncoder</class-id> <category>accessing</category><body package="NetClientBase">nextFrom: aStream	"Decode the next byte(s) in the stream and answer the code."	| code c1 |	aStream peek isNil ifTrue: [^nil]. 	code := aStream peek.	(self shifting not and: [(code = self shiftInCode)])		ifTrue: 			[ code := aStream next. 			((code = self shiftInCode) and: [ aStream peek = self shiftOutCode])				ifTrue:					[ aStream next.	"eat the shift out code"					^code asCharacter].			self shifting: true].	((code = self shiftOutCode) and: [ self shifting])		ifTrue: 			[ c1 := self shiftInNextFrom: aStream.			aStream next.	"eat the shift out code"			self shifting: false.			c1 notNil ifTrue: [ ^c1 asCharacter].			aStream peek isNil ifTrue: [aStream pastEnd. ^nil]].		(self shifting and: [specialCharacters includes: code])  ifTrue: [ 			 c1 := self shiftInNextFrom: aStream.			self shifting: false.			c1 notNil ifTrue: [ ^c1 asCharacter].			^code asCharacter].	^(self shifting		ifTrue: [ self shiftInNextFrom: aStream]		ifFalse:  [aStream next ]) 			ifNil: [ self error: 'Error decoding UTF7 encoded bytes' ]			ifNotNil: [ :b | b asCharacter ]</body><body package="NetClientBase">nextPut: aCharacter on: aStream	"Encode aCharacter and write it to encoded stream."	|  col c |	c := self encoder encode: aCharacter.	col := OrderedCollection with: c.	c = self shiftInCode		ifTrue: [ col add: self shiftOutCode].	col do: [ :code |  			( (self isNotASCII: code)  and: [ self shifting not ])				ifTrue: 					[ self shiftIn: aStream.					self shifting: true].			( (self isASCII: code)  and: [ self shifting ])				ifTrue: 					[ self prepareToClose: aStream.					self shifting: false ].			self shifting				ifTrue: [ self shiftInNextPut: code on: aStream]				ifFalse: [ aStream nextPut: code]			]</body><body package="NetClientBase">prepareToClose: aStream	self shifting		ifTrue: 			[super prepareToClose: aStream.			 self shiftOut: aStream]</body></methods><methods><class-id>Net.UTF7StreamEncoder</class-id> <category>private</category><body package="NetClientBase">charsToPad	^0</body><body package="NetClientBase">shiftIn: aStream	aStream nextPut: self shiftInCode</body><body package="NetClientBase">shiftInCode	^$+ asInteger</body><body package="NetClientBase">shiftInNextFrom: aStream 	|  c1 c2 | 	c1 := super nextFrom: aStream.	c1 == nil ifTrue: [^nil].	c2 := super nextFrom: aStream.	c2 == nil ifTrue: [^nil].	^(c1 bitShift: 8) + c2.</body><body package="NetClientBase">shiftInNextPut: code on: aStream	| c1 c2 |	c1 := code bitShift: -8.	c2 := code bitAnd: 16rFF.	self privateNextPut: c1 on: aStream.	self privateNextPut: c2 on: aStream.</body><body package="NetClientBase">shiftOut: aStream	aStream nextPut: self shiftOutCode</body><body package="NetClientBase">shiftOutCode	^$- asInteger</body><body package="NetClientBase">shifting	^shifting isNil		ifTrue: [ shifting := false ]		ifFalse: [ shifting ]</body><body package="NetClientBase">shifting: aBoolean	shifting := aBoolean</body></methods><methods><class-id>Net.UTF7StreamEncoder</class-id> <category>manipulating sextets</category><body package="NetClientBase">fillNibbleFrom: aStream	|  nSextets enc |	enc := self class octetMap.	nibble := 0.	nSextets := 0.	1 to: 4 do: [ :idx |		aStream peek ifNotNil: [ :code | 			(specialCharacters includes: code) 				ifTrue: [self shifting: false. 						^nSextets ]].		aStream next			ifNil: [ ^nSextets ]			ifNotNil: [ :code | 				code == self shiftOutCode ifTrue: [ self shifting: false. ^nSextets ].				nibble := nibble bitOr: ((enc at: code ) bitShift: (self shiftValueAt: idx)).				nSextets := nSextets + 1].	].	^nSextets</body></methods><methods><class-id>Net.UTF7StreamEncoder</class-id> <category>initialization</category><body package="NetClientBase">initialize	super initialize.	specialCharacters := Array		with: 9 "Character tab"		with: 10 "Character lf"		with: 13 "Character cr"		with: 32 "Character space"</body></methods><methods><class-id>Net.UTF7StreamEncoder class</class-id> <category>private</category><body package="NetClientBase">defaultCharacterEncoder	^UnicodeCharacterEncoder new</body></methods><methods><class-id>Net.UTF7StreamEncoder class</class-id> <category>accessing</category><body package="NetClientBase">streamEncodingType	^#UTF_7</body></methods><methods><class-id>Net.UTF7StreamEncoder class</class-id> <category>class initialization</category><body package="NetClientBase">initialize	"Initialize class variables"	super initialize</body><body package="NetClientBase">obsolete	StreamEncoder.EncoderDirectory removeKey: #utf_7 ifAbsent: [].	super obsolete</body></methods><methods><class-id>Net.NetClientError class</class-id> <category>signalling</category><body package="NetClientBase">signalWith: aParameter message: aString	"Raise an an exception with parameter set to aParameter and message set to aString."	^self new 		searchFrom: thisContext sender;		originator: thisContext sender homeReceiver;		parameter: aParameter;		messageText: aString;		raiseSignal.</body></methods><methods><class-id>Net.MimeTypeDescriptor</class-id> <category>testing</category><body package="NetClientBase">isBinary	^binary</body><body package="NetClientBase">isMultipart	^self type = 'multipart'</body><body package="NetClientBase">isText	^self type = 'text'</body></methods><methods><class-id>Net.MimeTypeDescriptor</class-id> <category>accessing</category><body package="NetClientBase">binary	^binary</body><body package="NetClientBase">binary: aBoolean	binary := aBoolean</body><body package="NetClientBase">contentType	^contentType</body><body package="NetClientBase">contentType: aString" aString is 'type/subtype'. Should be lowercase "	contentType := aString</body><body package="NetClientBase">hasPropertyAt: aString 	properties isNil ifTrue: [^false].	properties findKey: aString ifAbsent: [^false].	^true</body><body package="NetClientBase">properties	^properties isNil		ifTrue: [properties := Dictionary new]		ifFalse: [properties]</body><body package="NetClientBase">propertyAt: aString 	^self propertyAt: aString ifAbsent: [ nil ]</body><body package="NetClientBase">propertyAt: aString ifAbsent: aBlock	^properties isNil 		ifTrue: [aBlock value]		ifFalse: [properties at: aString ifAbsent: aBlock]</body><body package="NetClientBase">propertyAt: aString put: aValue	self properties at: aString put: aValue</body><body package="NetClientBase">subtype	^(self contentType tokensBasedOn: $/) last.</body><body package="NetClientBase">type	^(self contentType tokensBasedOn: $/) first.</body></methods><methods><class-id>Net.MimeTypeDescriptor</class-id> <category>printing</category><body package="NetClientBase">printOn: aStream	super printOn: aStream.	contentType notNil		ifTrue: [aStream nextPut: $(; nextPutAll: contentType; nextPut: $)]</body></methods><methods><class-id>Net.MimeTypeDescriptor class</class-id> <category>accessing mime types</category><body package="NetClientBase">contentType: aString" Answer Mime type descriptor for specified type/subtype "	^self contentType: aString ifAbsent: [nil]</body><body package="NetClientBase">contentType: aString ifAbsent: aBlock" Answer Mime type descriptor for specified type/subtype "	^MimeTypeRegistry at: aString asLowercase ifAbsent: aBlock</body><body package="NetClientBase">contentTypeApplicationOctetStream	^'application/octet-stream'</body><body package="NetClientBase">contentTypeFormData	^'application/x-www-form-urlencoded'</body><body package="NetClientBase">contentTypeHtml	^'text/html'</body><body package="NetClientBase">contentTypeMessageRfc822	^'message/rfc822'</body><body package="NetClientBase">contentTypeMultipartDigest	^'multipart/digest'</body><body package="NetClientBase">contentTypeMultipartFormData	^'multipart/form-data'</body><body package="NetClientBase">contentTypeMultipartMixed	^'multipart/mixed'</body><body package="NetClientBase">contentTypePlainText	^'text/plain'</body><body package="NetClientBase">contentTypeXml	^'text/xml'</body><body package="NetClientBase">defaultContentType	^self contentType: self defaultContentTypeString</body><body package="NetClientBase">defaultContentTypeString	^self contentTypePlainText</body><body package="NetClientBase">defaultUnsupportedContentType	^self contentTypeApplicationOctetStream</body><body package="NetClientBase">extension: aString" Answer Mime type descriptor for specified file extension "	^self extension: aString ifAbsent: [nil]</body><body package="NetClientBase">extension: aString ifAbsent: aBlock" Answer Mime type descriptor for specified file extension "	| contentType |	contentType := FileExtensionToMimeTypeMap at: aString asLowercase ifAbsent: [^aBlock value].	^contentType isNil		ifTrue: [ nil ]		ifFalse: [ MimeTypeDescriptor contentType: contentType ]</body><body package="NetClientBase">guessFromContentType: aString	"guesses a content type from the extension"	^self 		guessFromContentType: aString 		ifAbsent: [self contentType: self defaultUnsupportedContentType].</body><body package="NetClientBase">guessFromContentType: aString ifAbsent: aBlock	"guesses a content type from the extension"	^ MimeTypeRegistry 		at: aString asLowercase 		ifAbsent: aBlock.</body><body package="NetClientBase">mimeTypeForFile: fileName"Returns content type string, guessing at the MIME type from the fileName extension. If the fileName doesn't have an extension returns default - 'application/octet-stream' "        ^self  guessFromExtension: fileName asFilename extension</body></methods><methods><class-id>Net.MimeTypeDescriptor class</class-id> <category>class initialization</category><body package="NetClientBase">defaultFileExtensionMap 	^#(		#('3dm' 'x-world/x-3dmf')		#('3dmf' 'x-world/x-3dmf')		#('a' 'application/octet-stream')		#('aab' 'application/x-authorware-bin')		#('aam' 'application/x-authorware-map')		#('aas' 'application/x-authorware-seg')		#('abc' 'text/vndabc')		#('acgi' 'text/html')		#('afl' 'video/animaflex')		#('ai' 'application/postscript')		#('aif' 'audio/aiff')		#('aif' 'audio/x-aiff')		#('aifc' 'audio/aiff')		#('aifc' 'audio/x-aiff')		#('aiff' 'audio/aiff')		#('aiff' 'audio/x-aiff')		#('aim' 'application/x-aim')		#('aip' 'text/x-audiosoft-intra')		#('ani' 'application/x-navi-animation')		#('aos' 'application/x-nokia-9000-communicator-add-on-software')		#('aps' 'application/mime')		#('arc' 'application/octet-stream')		#('arj' 'application/arj')		#('arj' 'application/octet-stream')		#('art' 'image/x-jg')		#('asf' 'video/x-ms-asf')		#('asm' 'text/x-asm')		#('asp' 'text/asp')		#('asx' 'application/x-mplayer2')		#('asx' 'video/x-ms-asf')		#('asx' 'video/x-ms-asf-plugin')		#('au' 'audio/basic')		#('au' 'audio/x-au')		#('avi' 'application/x-troff-msvideo')		#('avi' 'video/avi')		#('avi' 'video/msvideo')		#('avi' 'video/x-msvideo')		#('avs' 'video/avs-video')		#('bcpio' 'application/x-bcpio')		#('bin' 'application/mac-binary')		#('bin' 'application/macbinary')		#('bin' 'application/octet-stream')		#('bin' 'application/x-binary')		#('bin' 'application/x-macbinary')		#('bm' 'image/bmp')		#('bmp' 'image/bmp')		#('bmp' 'image/x-windows-bmp')		#('boo' 'application/book')		#('book' 'application/book')		#('boz' 'application/x-bzip2')		#('bsh' 'application/x-bsh')		#('bz' 'application/x-bzip')		#('bz2' 'application/x-bzip2')		#('c' 'text/plain')		#('c' 'text/x-c')		#('c++' 'text/plain')		#('cat' 'application/vndms-pkiseccat')		#('cc' 'text/plain')		#('cc' 'text/x-c')		#('ccad' 'application/clariscad')		#('cco' 'application/x-cocoa')		#('cdf' 'application/cdf')		#('cdf' 'application/x-cdf')		#('cdf' 'application/x-netcdf')		#('cer' 'application/pkix-cert')		#('cer' 'application/x-x509-ca-cert')		#('cha' 'application/x-chat')		#('chat' 'application/x-chat')		#('class' 'application/java')		#('class' 'application/java-byte-code')		#('class' 'application/x-java-class')		#('com' 'application/octet-stream')		#('com' 'text/plain')		#('conf' 'text/plain')		#('cpio' 'application/x-cpio')		#('cpp' 'text/x-c')		#('cpt' 'application/mac-compactpro')		#('cpt' 'application/x-compactpro')		#('cpt' 'application/x-cpt')		#('crl' 'application/pkcs-crl')		#('crl' 'application/pkix-crl')		#('crt' 'application/pkix-cert')		#('crt' 'application/x-x509-ca-cert')		#('crt' 'application/x-x509-user-cert')		#('csh' 'application/x-csh')		#('csh' 'text/x-scriptcsh')		#('css' 'application/x-pointplus')		#('css' 'text/css')		#('cxx' 'text/plain')		#('dcr' 'application/x-director')		#('deepv' 'application/x-deepv')		#('def' 'text/plain')		#('der' 'application/x-x509-ca-cert')		#('dif' 'video/x-dv')		#('dir' 'application/x-director')		#('dl' 'video/dl')		#('dl' 'video/x-dl')		#('doc' 'application/msword')		#('dot' 'application/msword')		#('dp' 'application/commonground')		#('drw' 'application/drafting')		#('dump' 'application/octet-stream')		#('dv' 'video/x-dv')		#('dvi' 'application/x-dvi')		#('dwf' '(old)')		#('dwf' 'model/vnddwf')		#('dwg' 'application/acad')		#('dwg' 'image/vnddwg')		#('dwg' 'image/x-dwg')		#('dxf' 'application/dxf')		#('dxf' 'image/vnddwg')		#('dxf' 'image/x-dwg')		#('dxr' 'application/x-director')		#('el' 'text/x-scriptelisp')		#('elc' 'ELisp)')		#('elc' 'application/x-elc')		#('env' 'application/x-envoy')		#('eps' 'application/postscript')		#('es' 'application/x-esrehber')		#('etx' 'text/x-setext')		#('evy' 'application/envoy')		#('evy' 'application/x-envoy')		#('exe' 'application/octet-stream')		#('f' 'text/plain')		#('f' 'text/x-fortran')		#('f77' 'text/x-fortran')		#('f90' 'text/plain')		#('f90' 'text/x-fortran')		#('fdf' 'application/vndfdf')		#('fif' 'application/fractals')		#('fif' 'image/fif')		#('fli' 'video/fli')		#('fli' 'video/x-fli')		#('flo' 'image/florian')		#('flx' 'text/vndfmiflexstor')		#('fmf' 'video/x-atomic3d-feature')		#('for' 'text/plain')		#('for' 'text/x-fortran')		#('fpx' 'image/vndfpx')		#('fpx' 'image/vndnet-fpx')		#('frl' 'application/freeloader')		#('funk' 'audio/make')		#('g' 'text/plain')		#('g3' 'image/g3fax')		#('gif' 'image/gif')		#('gl' 'video/gl')		#('gl' 'video/x-gl')		#('gsd' 'audio/x-gsm')		#('gsm' 'audio/x-gsm')		#('gsp' 'application/x-gsp')		#('gss' 'application/x-gss')		#('gtar' 'application/x-gtar')		#('gz' 'application/x-compressed')		#('gz' 'application/x-gzip')		#('gzip' 'application/x-gzip')		#('gzip' 'multipart/x-gzip')		#('h' 'text/plain')		#('h' 'text/x-h')		#('hdf' 'application/x-hdf')		#('help' 'application/x-helpfile')		#('hgl' 'application/vndhp-HPGL')		#('hh' 'text/plain')		#('hh' 'text/x-h')		#('hlb' 'text/x-script')		#('hlp' 'application/hlp')		#('hlp' 'application/x-helpfile')		#('hlp' 'application/x-winhelp')		#('hpg' 'application/vndhp-HPGL')		#('hpgl' 'application/vndhp-HPGL')		#('hqx' 'application/binhex')		#('hqx' 'application/binhex4')		#('hqx' 'application/mac-binhex')		#('hqx' 'application/mac-binhex40')		#('hqx' 'application/x-binhex40')		#('hqx' 'application/x-mac-binhex40')		#('hta' 'application/hta')		#('htc' 'text/x-component')		#('htm' 'text/html')		#('html' 'text/html')		#('htmls' 'text/html')		#('htt' 'text/webviewhtml')		#('htx' 'text/html')		#('ice' 'x-conference/x-cooltalk')		#('ico' 'image/x-icon')		#('idc' 'text/plain')		#('ief' 'image/ief')		#('iefs' 'image/ief')		#('iges' 'application/iges')		#('iges' 'model/iges')		#('igs' 'application/iges')		#('igs' 'model/iges')		#('ima' 'application/x-ima')		#('imap' 'application/x-httpd-imap')		#('inf' 'application/inf')		#('ins' 'application/x-internett-signup')		#('ip' 'application/x-ip2')		#('isu' 'video/x-isvideo')		#('it' 'audio/it')		#('iv' 'application/x-inventor')		#('ivr' 'i-world/i-vrml')		#('ivy' 'application/x-livescreen')		#('jam' 'audio/x-jam')		#('jav' 'text/plain')		#('jav' 'text/x-java-source')		#('java' 'text/plain')		#('java' 'text/x-java-source')		#('jcm' 'application/x-java-commerce')		#('jfif' 'image/jpeg')		#('jfif' 'image/pjpeg')		#('jfif-tbnl' 'image/jpeg')		#('jpe' 'image/jpeg')		#('jpe' 'image/pjpeg')		#('jpeg' 'image/jpeg')		#('jpeg' 'image/pjpeg')		#('jpg' 'image/jpeg')		#('jpg' 'image/pjpeg')		#('jps' 'image/x-jps')		#('js' 'application/x-javascript')		#('jut' 'image/jutvision')		#('kar' 'audio/midi')		#('kar' 'music/x-karaoke')		#('ksh' 'application/x-ksh')		#('ksh' 'text/x-scriptksh')		#('la' 'audio/nspaudio')		#('la' 'audio/x-nspaudio')		#('lam' 'audio/x-liveaudio')		#('latex' 'application/x-latex')		#('lha' 'application/lha')		#('lha' 'application/octet-stream')		#('lha' 'application/x-lha')		#('lhx' 'application/octet-stream')		#('list' 'text/plain')		#('lma' 'audio/nspaudio')		#('lma' 'audio/x-nspaudio')		#('log' 'text/plain')		#('lsp' 'application/x-lisp')		#('lsp' 'text/x-scriptlisp')		#('lst' 'text/plain')		#('lsx' 'text/x-la-asf')		#('ltx' 'application/x-latex')		#('lzh' 'application/octet-stream')		#('lzh' 'application/x-lzh')		#('lzx' 'application/lzx')		#('lzx' 'application/octet-stream')		#('lzx' 'application/x-lzx')		#('m' 'text/plain')		#('m' 'text/x-m')		#('m1v' 'video/mpeg')		#('m2a' 'audio/mpeg')		#('m2v' 'video/mpeg')		#('m3u' 'audio/x-mpequrl')		#('man' 'application/x-troff-man')		#('map' 'application/x-navimap')		#('mar' 'text/plain')		#('mbd' 'application/mbedlet')		#('mc$' 'application/x-magic-cap-package-10')		#('mcd' 'application/mcad')		#('mcd' 'application/x-mathcad')		#('mcf' 'image/vasa')		#('mcf' 'text/mcf')		#('mcp' 'application/netmc')		#('me' 'application/x-troff-me')		#('mht' 'message/rfc822')		#('mhtml' 'message/rfc822')		#('mid' 'application/x-midi')		#('mid' 'audio/midi')		#('mid' 'audio/x-mid')		#('mid' 'audio/x-midi')		#('mid' 'music/crescendo')		#('mid' 'x-music/x-midi')		#('midi' 'application/x-midi')		#('midi' 'audio/midi')		#('midi' 'audio/x-mid')		#('midi' 'audio/x-midi')		#('midi' 'music/crescendo')		#('midi' 'x-music/x-midi')		#('mif' 'application/x-frame')		#('mif' 'application/x-mif')		#('mime' 'message/rfc822')		#('mime' 'www/mime')		#('mjf' 'audio/x-vndAudioExplosionMjuiceMediaFile')		#('mjpg' 'video/x-motion-jpeg')		#('mm' 'application/base64')		#('mm' 'application/x-meme')		#('mme' 'application/base64')		#('mod' 'audio/mod')		#('mod' 'audio/x-mod')		#('moov' 'video/quicktime')		#('mov' 'video/quicktime')		#('movie' 'video/x-sgi-movie')		#('mp2' 'audio/mpeg')		#('mp2' 'audio/x-mpeg')		#('mp2' 'video/mpeg')		#('mp2' 'video/x-mpeg')		#('mp2' 'video/x-mpeq2a')		#('mp3' 'audio/mpeg3')		#('mp3' 'audio/x-mpeg-3')		#('mp3' 'video/mpeg')		#('mp3' 'video/x-mpeg')		#('mpa' 'audio/mpeg')		#('mpa' 'video/mpeg')		#('mpc' 'application/x-project')		#('mpe' 'video/mpeg')		#('mpeg' 'video/mpeg')		#('mpg' 'audio/mpeg')		#('mpg' 'video/mpeg')		#('mpga' 'audio/mpeg')		#('mpp' 'application/vndms-project')		#('mpt' 'application/x-project')		#('mpv' 'application/x-project')		#('mpx' 'application/x-project')		#('mrc' 'application/marc')		#('ms' 'application/x-troff-ms')		#('mv' 'video/x-sgi-movie')		#('my' 'audio/make')		#('mzz' 'application/x-vndAudioExplosionmzz')		#('nap' 'image/naplps')		#('naplps' 'image/naplps')		#('nc' 'application/x-netcdf')		#('ncm' 'application/vndnokiaconfiguration-message')		#('nif' 'image/x-niff')		#('niff' 'image/x-niff')		#('nix' 'application/x-mix-transfer')		#('nsc' 'application/x-conference')		#('nvd' 'application/x-navidoc')		#('o' 'application/octet-stream')		#('oda' 'application/oda')		#('omc' 'application/x-omc')		#('omcd' 'application/x-omcdatamaker')		#('omcr' 'application/x-omcregerator')		#('p' 'text/x-pascal')		#('p10' 'application/pkcs10')		#('p10' 'application/x-pkcs10')		#('p12' 'application/pkcs-12')		#('p12' 'application/x-pkcs12')		#('p7a' 'application/x-pkcs7-signature')		#('p7c' 'application/pkcs7-mime')		#('p7c' 'application/x-pkcs7-mime')		#('p7m' 'application/pkcs7-mime')		#('p7m' 'application/x-pkcs7-mime')		#('p7r' 'application/x-pkcs7-certreqresp')		#('p7s' 'application/pkcs7-signature')		#('part' 'application/pro_eng')		#('pas' 'text/pascal')		#('pbm' 'image/x-portable-bitmap')		#('pcl' 'application/vndhp-PCL')		#('pcl' 'application/x-pcl')		#('pct' 'image/x-pict')		#('pcx' 'image/x-pcx')		#('pdb' 'chemical/x-pdb')		#('pdf' 'application/pdf')		#('pfunk' 'audio/make')		#('pfunk' 'audio/makemyfunk')		#('pgm' 'image/x-portable-graymap')		#('pgm' 'image/x-portable-greymap')		#('pic' 'image/pict')		#('pict' 'image/pict')		#('pkg' 'application/x-newton-compatible-pkg')		#('pko' 'application/vndms-pkipko')		#('pl' 'text/plain')		#('pl' 'text/x-scriptperl')		#('plx' 'application/x-PiXCLscript')		#('pm' 'image/x-xpixmap')		#('pm' 'text/x-scriptperl-module')		#('pm4' 'application/x-pagemaker')		#('pm5' 'application/x-pagemaker')		#('png' 'image/png')		#('pnm' 'application/x-portable-anymap')		#('pnm' 'image/x-portable-anymap')		#('pot' 'application/mspowerpoint')		#('pot' 'application/vndms-powerpoint')		#('pov' 'model/x-pov')		#('ppa' 'application/vndms-powerpoint')		#('ppm' 'image/x-portable-pixmap')		#('pps' 'application/mspowerpoint')		#('pps' 'application/vndms-powerpoint')		#('ppt' 'application/mspowerpoint')		#('ppt' 'application/powerpoint')		#('ppt' 'application/vndms-powerpoint')		#('ppt' 'application/x-mspowerpoint')		#('ppz' 'application/mspowerpoint')		#('pre' 'application/x-freelance')		#('prt' 'application/pro_eng')		#('ps' 'application/postscript')		#('psd' 'application/octet-stream')		#('pvu' 'paleovu/x-pv')		#('pwz' 'application/vndms-powerpoint')		#('py' 'text/x-scriptphyton')		#('pyc' 'applicaiton/x-bytecodepython')		#('qcp' 'audio/vndqcelp')		#('qd3' 'x-world/x-3dmf')		#('qd3d' 'x-world/x-3dmf')		#('qif' 'image/x-quicktime')		#('qt' 'video/quicktime')		#('qtc' 'video/x-qtc')		#('qti' 'image/x-quicktime')		#('qtif' 'image/x-quicktime')		#('ra' 'audio/x-pn-realaudio')		#('ra' 'audio/x-pn-realaudio-plugin')		#('ra' 'audio/x-realaudio')		#('ram' 'audio/x-pn-realaudio')		#('ras' 'application/x-cmu-raster')		#('ras' 'image/cmu-raster')		#('ras' 'image/x-cmu-raster')		#('rast' 'image/cmu-raster')		#('rexx' 'text/x-scriptrexx')		#('rf' 'image/vndrn-realflash')		#('rgb' 'image/x-rgb')		#('rm' 'application/vndrn-realmedia')		#('rm' 'audio/x-pn-realaudio')		#('rmi' 'audio/mid')		#('rmm' 'audio/x-pn-realaudio')		#('rmp' 'audio/x-pn-realaudio')		#('rmp' 'audio/x-pn-realaudio-plugin')		#('rng' 'application/ringing-tones')		#('rng' 'application/vndnokiaringing-tone')		#('rnx' 'application/vndrn-realplayer')		#('roff' 'application/x-troff')		#('rp' 'image/vndrn-realpix')		#('rpm' 'audio/x-pn-realaudio-plugin')		#('rt' 'text/richtext')		#('rt' 'text/vndrn-realtext')		#('rtf' 'application/rtf')		#('rtf' 'application/x-rtf')		#('rtf' 'text/richtext')		#('rtx' 'application/rtf')		#('rtx' 'text/richtext')		#('rv' 'video/vndrn-realvideo')		#('s' 'text/x-asm')		#('s3m' 'audio/s3m')		#('saveme' 'application/octet-stream')		#('sbk' 'application/x-tbook')		#('scm' 'application/x-lotusscreencam')		#('scm' 'text/x-scriptguile')		#('scm' 'text/x-scriptscheme')		#('scm' 'video/x-scm')		#('sdml' 'text/plain')		#('sdp' 'application/sdp')		#('sdp' 'application/x-sdp')		#('sdr' 'application/sounder')		#('sea' 'application/sea')		#('sea' 'application/x-sea')		#('set' 'application/set')		#('sgm' 'text/sgml')		#('sgm' 'text/x-sgml')		#('sgml' 'text/sgml')		#('sgml' 'text/x-sgml')		#('sh' 'application/x-bsh')		#('sh' 'application/x-sh')		#('sh' 'application/x-shar')		#('sh' 'text/x-scriptsh')		#('shar' 'application/x-bsh')		#('shar' 'application/x-shar')		#('shtml' 'text/html')		#('shtml' 'text/x-server-parsed-html')		#('sid' 'audio/x-psid')		#('sit' 'application/x-sit')		#('sit' 'application/x-stuffit')		#('skd' 'application/x-koan')		#('skm' 'application/x-koan')		#('skp' 'application/x-koan')		#('skt' 'application/x-koan')		#('sl' 'application/x-seelogo')		#('smi' 'application/smil')		#('smil' 'application/smil')		#('snd' 'audio/basic')		#('snd' 'audio/x-adpcm')		#('sol' 'application/solids')		#('spc' 'application/x-pkcs7-certificates')		#('spc' 'text/x-speech')		#('spl' 'application/futuresplash')		#('spr' 'application/x-sprite')		#('sprite' 'application/x-sprite')		#('src' 'application/x-wais-source')		#('ssi' 'text/x-server-parsed-html')		#('ssm' 'application/streamingmedia')		#('sst' 'application/vndms-pkicertstore')		#('step' 'application/step')		#('stl' 'application/sla')		#('stl' 'application/vndms-pkistl')		#('stl' 'application/x-navistyle')		#('stp' 'application/step')		#('sv4cpio' 'application/x-sv4cpio')		#('sv4crc' 'application/x-sv4crc')		#('svf' 'image/vnddwg')		#('svf' 'image/x-dwg')		#('svr' 'application/x-world')		#('svr' 'x-world/x-svr')		#('swf' 'application/x-shockwave-flash')		#('t' 'application/x-troff')		#('talk' 'text/x-speech')		#('tar' 'application/x-tar')		#('tbk' 'application/toolbook')		#('tbk' 'application/x-tbook')		#('tcl' 'application/x-tcl')		#('tcl' 'text/x-scripttcl')		#('tcsh' 'text/x-scripttcsh')		#('tex' 'application/x-tex')		#('texi' 'application/x-texinfo')		#('texinfo' 'application/x-texinfo')		#('text' 'application/plain')		#('text' 'text/plain')		#('tgz' 'application/gnutar')		#('tgz' 'application/x-compressed')		#('tif' 'image/tiff')		#('tif' 'image/x-tiff')		#('tiff' 'image/tiff')		#('tiff' 'image/x-tiff')		#('tr' 'application/x-troff')		#('tsi' 'audio/tsp-audio')		#('tsp' 'application/dsptype')		#('tsp' 'audio/tsplayer')		#('tsv' 'text/tab-separated-values')		#('turbot' 'image/florian')		#('txt' 'text/plain')		#('uil' 'text/x-uil')		#('uni' 'text/uri-list')		#('unis' 'text/uri-list')		#('unv' 'application/i-deas')		#('uri' 'text/uri-list')		#('uris' 'text/uri-list')		#('ustar' 'application/x-ustar')		#('ustar' 'multipart/x-ustar')		#('uu' 'application/octet-stream')		#('uu' 'text/x-uuencode')		#('uue' 'text/x-uuencode')		#('vcd' 'application/x-cdlink')		#('vcs' 'text/x-vCalendar')		#('vda' 'application/vda')		#('vdo' 'video/vdo')		#('vew' 'application/groupwise')		#('viv' 'video/vivo')		#('viv' 'video/vndvivo')		#('vivo' 'video/vivo')		#('vivo' 'video/vndvivo')		#('vmd' 'application/vocaltec-media-desc')		#('vmf' 'application/vocaltec-media-file')		#('voc' 'audio/voc')		#('voc' 'audio/x-voc')		#('vos' 'video/vosaic')		#('vox' 'audio/voxware')		#('vqe' 'audio/x-twinvq-plugin')		#('vqf' 'audio/x-twinvq')		#('vql' 'audio/x-twinvq-plugin')		#('vrml' 'application/x-vrml')		#('vrml' 'model/vrml')		#('vrml' 'x-world/x-vrml')		#('vrt' 'x-world/x-vrt')		#('vsd' 'application/x-visio')		#('vst' 'application/x-visio')		#('vsw' 'application/x-visio')		#('w60' 'application/wordperfect60')		#('w61' 'application/wordperfect61')		#('w6w' 'application/msword')		#('wav' 'audio/wav')		#('wav' 'audio/x-wav')		#('wb1' 'application/x-qpro')		#('wbmp' 'image/vndwapwbmp')		#('web' 'application/vndxara')		#('wiz' 'application/msword')		#('wk1' 'application/x-123')		#('wmf' 'windows/metafile')		#('wml' 'text/vndwapwml')		#('wmlc' 'application/vndwapwmlc')		#('wmls' 'text/vndwapwmlscript')		#('wmlsc' 'application/vndwapwmlscriptc')		#('word' 'application/msword')		#('wp' 'application/wordperfect')		#('wp5' 'application/wordperfect')		#('wp5' 'application/wordperfect60')		#('wp6' 'application/wordperfect')		#('wpd' 'application/wordperfect')		#('wpd' 'application/x-wpwin')		#('wq1' 'application/x-lotus')		#('wri' 'application/mswrite')		#('wri' 'application/x-wri')		#('wrl' 'application/x-world')		#('wrl' 'model/vrml')		#('wrl' 'x-world/x-vrml')		#('wrz' 'model/vrml')		#('wrz' 'x-world/x-vrml')		#('wsc' 'text/scriplet')		#('wsrc' 'application/x-wais-source')		#('wtk' 'application/x-wintalk')		#('xbm' 'image/x-xbitmap')		#('xbm' 'image/x-xbm')		#('xbm' 'image/xbm')		#('xdr' 'video/x-amt-demorun')		#('xgz' 'xgl/drawing')		#('xif' 'image/vndxiff')		#('xl' 'application/excel')		#('xla' 'application/excel')		#('xla' 'application/x-excel')		#('xla' 'application/x-msexcel')		#('xlb' 'application/excel')		#('xlb' 'application/vndms-excel')		#('xlb' 'application/x-excel')		#('xlc' 'application/excel')		#('xlc' 'application/vndms-excel')		#('xlc' 'application/x-excel')		#('xld' 'application/excel')		#('xld' 'application/x-excel')		#('xlk' 'application/excel')		#('xlk' 'application/x-excel')		#('xll' 'application/excel')		#('xll' 'application/vndms-excel')		#('xll' 'application/x-excel')		#('xlm' 'application/excel')		#('xlm' 'application/vndms-excel')		#('xlm' 'application/x-excel')		#('xls' 'application/excel')		#('xls' 'application/vndms-excel')		#('xls' 'application/x-excel')		#('xls' 'application/x-msexcel')		#('xlt' 'application/excel')		#('xlt' 'application/x-excel')		#('xlv' 'application/excel')		#('xlv' 'application/x-excel')		#('xlw' 'application/excel')		#('xlw' 'application/vndms-excel')		#('xlw' 'application/x-excel')		#('xlw' 'application/x-msexcel')		#('xm' 'audio/xm')		#('xml' 'application/xml')		#('xml' 'text/xml')		#('xmz' 'xgl/movie')		#('xpix' 'application/x-vndls-xpix')		#('xpm' 'image/x-xpixmap')		#('xpm' 'image/xpm')		#('x-png' 'image/png')		#('xsr' 'video/x-amt-showrun')		#('xwd' 'image/x-xwd')		#('xwd' 'image/x-xwindowdump')		#('xyz' 'chemical/x-pdb')		#('z' 'application/x-compress')		#('z' 'application/x-compressed')		#('zip' 'application/x-compressed')		#('zip' 'application/x-zip-compressed')		#('zip' 'application/zip')		#('zip' 'multipart/x-zip')		#('zoo' 'application/octet-stream')		#('zsh' 'text/x-scriptzsh')		#('jsp' 'text/html')		#('ssp' 'text/html')	)</body><body package="NetClientBase">defaultMimeTypes "List of MIME content types. The second item defines whether or not this type will be considered as a binary type"	^#(		#('application/octet-stream' 1)		#('application/postscript' 1)		#('application/oda' 1)		#('application/atomicmail' 1)		#('application/andrew-inset' 1)		#('application/slate' 1)		#('application/wita' 1)		#('application/dec-dx' 1)		#('application/dca-rft' 1)		#('application/activemessage' 1)		#('application/rtf' 1)		#('application/applefile' 1)		#('application/mac-binhex40' 1)		#('application/news-message-id' 1)		#('application/news-transmission' 1)		#('application/wordperfect5.1' 1)		#('application/pdf' 1 #(#encoding 'base64'))		#('application/zip' 1)		#('application/macwriteii' 1)		#('application/msword' 1)		#('application/remote-printing' 1)		#('application/mathematica' 1)		#('application/cybercash' 1)		#('application/commonground' 1)		#('application/iges' 1)		#('application/riscos' 1)		#('application/eshop' 1)		#('application/x400-bp' 1)		#('application/sgml' 1)		#('application/cals-1840' 1)		#('application/pgp-encrypted' 1)		#('application/pgp-signature' 1)		#('application/pgp-keys' 1)		#('application/vnd.framemaker' 1)		#('application/vnd.mif' 1)		#('application/vnd.ms-excel' 1)		#('application/vnd.ms-powerpoint' 1)		#('application/vnd.ms-project' 1)		#('application/vnd.ms-works' 1)		#('application/vnd.ms-tnef' 1)		#('application/vnd.svd' 1)		#('application/vnd.music-niff' 1)		#('application/vnd.ms-artgalry' 1)		#('application/vnd.truedoc' 1)		#('application/vnd.koan' 1)		#('application/vnd.street-stream' 1)		#('application/vnd.fdf' 1)		#('application/set-payment-initiation' 1)		#('application/set-payment' 1)		#('application/set-registration-initiation' 1)		#('application/set-registration' 1)		#('application/vnd.seemail' 1)		#('application/vnd.businessobjects' 1)		#('application/vnd.meridian-slingshot' 1)		#('application/vnd.xara' 1)		#('application/sgml-open-catalog' 1)		#('application/vnd.rapid' 1)		#('application/vnd.enliven' 1)		#('application/vnd.japannet-registration-wakeup' 1)		#('application/vnd.japannet-verification-wakeup' 1)		#('application/vnd.japannet-payment-wakeup' 1)		#('application/vnd.japannet-directory-service' 1)		#('application/vnd.intertrust.digibox' 1)		#('application/vnd.intertrust.nncp' 1)		#('application/prs.alvestrand.titrax-sheet' 1)		#('application/vnd.noblenet-web' 1)		#('application/vnd.noblenet-sealer' 1)		#('application/vnd.noblenet-directory' 1)		#('application/prs.nprend' 1)		#('application/vnd.webturbo' 1)		#('application/hyperstudio' 1)		#('application/vnd.shana.informed.formtemplate' 1)		#('application/vnd.shana.informed.formdata' 1)		#('application/vnd.shana.informed.package' 1)		#('application/vnd.shana.informed.interchange' 1)		#('application/vnd.$commerce_battelle' 1)		#('application/vnd.osa.netdeploy' 1)		#('application/vnd.ibm.MiniPay' 1)		#('application/vnd.japannet-jpnstore-wakeup' 1)		#('application/vnd.japannet-setstore-wakeup' 1)		#('application/vnd.japannet-verification' 1)		#('application/vnd.japannet-registration' 1)		#('application/vnd.hp-HPGL' 1)		#('application/vnd.hp-PCL' 1)		#('application/vnd.hp-PCLXL' 1)		#('application/vnd.musician' 1)		#('application/vnd.FloGraphIt' 1)		#('application/vnd.intercon.formnet' 1)		#('application/vemmi' 1)		#('application/vnd.ms-asf' 1)		#('application/vnd.ecdis-update' 1)		#('application/vnd.powerbuilder6' 1)		#('application/vnd.powerbuilder6-s' 1)		#('application/vnd.lotus-wordpro' 1)		#('application/vnd.lotus-approach' 1)		#('application/vnd.lotus-1-2-3' 1)		#('application/vnd.lotus-organizer' 1)		#('application/vnd.lotus-screencam' 1)		#('application/vnd.lotus-freelance' 1)		#('application/vnd.fujitsu.oasys' 1)		#('application/vnd.fujitsu.oasys2' 1)		#('application/vnd.swiftview-ics' 1)		#('application/vnd.dna' 1)		#('application/prs.cww' 1)		#('application/vnd.wt.stf' 1)		#('application/vnd.dxr' 1)		#('application/vnd.mitsubishi.misty-guard.trustweb' 1)		#('application/vnd.ibm.modcap' 1)		#('application/vnd.acucobol' 1)		#('application/vnd.fujitsu.oasys3' 1)		#('application/marc' 1)		#('application/vnd.fujitsu.oasysprs' 1)		#('application/vnd.fujitsu.oasysgp' 1)		#('application/vnd.visio' 1)		#('application/vnd.netfpx' 1)		#('application/vnd.audiograph' 1)		#('application/vnd.epson.salt' 1)		#('application/vnd.3M.Post-it-Notes' 1)		#('application/vnd.novadigm.EDX' 1)		#('application/vnd.novadigm.EXT' 1)		#('application/vnd.novadigm.EDM' 1)		#('application/vnd.claymore' 1)		#('application/vnd.comsocaller' 1)		#('application/pkcs7-mime' 1)		#('application/pkcs7-signature' 1)		#('application/pkcs10' 1)		#('application/vnd.yellowriver-custom-menu' 1)		#('application/vnd.ecowin.chart' 1)		#('application/vnd.ecowin.series' 1)		#('application/vnd.ecowin.filerequest' 1)		#('application/vnd.ecowin.fileupdate' 1)		#('application/vnd.ecowin.seriesrequest' 1)		#('application/vnd.ecowin.seriesupdate' 1)		#('application/EDIFACT' 1)		#('application/EDI-X12' 1)		#('application/EDI-Consent' 1)		#('application/vnd.wrq-hp3000-labelled' 1)		#('application/vnd.minisoft-hp3000-save' 1)		#('application/vnd.ffsns' 1)		#('application/vnd.hp-hps' 1)		#('application/vnd.fujixerox.docuworks' 1)		#('application/xml' 1)		#('application/vnd.anser-web-funds-transfer-initiation' 1)		#('application/vnd.anser-web-certificate-issue-initiation' 1)		#('application/vnd.is-xpr' 1)		#('application/vnd.intu.qbo' 1)		#('application/vnd.publishare-delta-tree' 1)		#('application/vnd.cybank' 1)		#('application/batch-SMTP' 1)		#('application/vnd.uplanet.alert' 1)		#('application/vnd.uplanet.cacheop' 1)		#('application/vnd.uplanet.list' 1)		#('application/vnd.uplanet.listcmd' 1)		#('application/vnd.uplanet.channel' 1)		#('application/vnd.uplanet.bearer-choice' 1)		#('application/vnd.uplanet.signal' 1)		#('application/vnd.uplanet.alert-wbxml' 1)		#('application/vnd.uplanet.cacheop-wbmxl' 1)		#('application/vnd.uplanet.list-wbxml' 1)		#('application/vnd.uplanet.listcmd-wbxml' 1)		#('application/vnd.uplanet.channel-wbxml' 1)		#('application/vnd.uplanet.bearer-choice-wbxml' 1)		#('application/vnd.epson.quickanime' 1)		#('application/vnd.commonspace' 1)		#('application/vnd.fut-misnet' 1)		#('application/vnd.xfdl' 1)		#('application/vnd.intu.qfx' 1)		#('application/vnd.epson.ssf' 1)		#('application/vnd.epson.msf' 1)		#('application/vnd.powerbuilder7' 1)		#('application/vnd.powerbuilder7-s' 1)		#('application/vnd.lotus-notes' 1)		#('application/pkixcmp' 1)		#('application/vnd.wap.wmlc' 1)		#('application/vnd.wap.wmlscriptc' 1)		#('application/vnd.motorola.flexsuite' 1)		#('application/vnd.wap.wbxml' 1)		#('application/vnd.motorola.flexsuite.wem' 1)		#('application/vnd.motorola.flexsuite.kmr' 1)		#('application/vnd.motorola.flexsuite.adsi' 1)		#('application/vnd.motorola.flexsuite.fis' 1)		#('application/vnd.motorola.flexsuite.gotap' 1)		#('application/vnd.motorola.flexsuite.ttc' 1)		#('application/vnd.ufdl' 1)		#('application/vnd.accpac.simply.imp' 1)		#('application/vnd.accpac.simply.aso' 1)		#('application/vnd.vcx' 1)		#('application/ipp' 1)		#('application/ocsp-request' 1)		#('application/ocsp-response' 1)		#('application/vnd.previewsystems.box' 1)		#('application/vnd.mediastation.cdkey' 1)		#('application/vnd.pg.format' 1)		#('application/vnd.pg.osasli' 1)		#('application/vnd.hp-hpid' 1)		#('application/pkix-cert' 1)		#('application/pkix-crl' 1)		#('application/vnd.Mobius.TXF' 1)		#('application/vnd.Mobius.PLC' 1)		#('application/vnd.Mobius.DIS' 1)		#('application/vnd.Mobius.DAF' 1)		#('application/vnd.Mobius.MSL' 1)		#('application/vnd.cups-raster' 1)		#('application/vnd.cups-postscript' 1)		#('application/vnd.cups-raw' 1)		#('application/index' 1)		#('application/index.cmd' 1)		#('application/index.response' 1)		#('application/index.obj' 1)		#('application/index.vnd' 1)		#('application/vnd.triscape.mxs' 1)		#('application/vnd.powerbuilder75' 1)		#('application/vnd.powerbuilder75-s' 1)		#('application/vnd.dpgraph' 1)		#('application/http' 0)		#('application/sdp' 1)		#('application/vnd.eudora.data' 1)		#('application/vnd.fujixerox.docuworks.binder' 1)		#('application/vnd.vectorworks' 1)		#('application/vnd.grafeq' 1)		#('application/vnd.bmi' 1)		#('application/vnd.ericsson.quickcall' 1)		#('application/vnd.hzn-3d-crossword' 1)		#('application/vnd.wap.slc' 1)		#('application/vnd.wap.sic' 1)		#('application/vnd.groove-injector' 1)		#('application/vnd.fujixerox.ddd' 1)		#('application/vnd.groove-account' 1)		#('application/vnd.groove-identity-message' 1)		#('application/vnd.groove-tool-message' 1)		#('application/vnd.groove-tool-template' 1)		#('application/vnd.groove-vcard' 1)		#('application/vnd.ctc-posml' 1)		#('application/vnd.canon-lips' 1)		#('application/vnd.canon-cpdl' 1)		#('application/vnd.trueapp' 1)		#('application/vnd.s3sms' 1)		#('application/iotp' 1)		#('application/vnd.mcd' 1)		#('application/vnd.httphone' 1)		#('application/vnd.informix-visionary' 1)		#('application/vnd.msign' 1)		#('application/vnd.ms-lrm' 1)		#('application/vnd.contact.cmsg' 1)		#('application/vnd.epson.esf' 1)		#('application/whoispp-query' 1)		#('application/whoispp-response' 1)		#('application/vnd.mozilla.xul+xml' 1)		#('application/parityfec' 1)		#('application/vnd.palm' 1)		#('application/vnd.fsc.weblaunch' 1)		#('application/vnd.tve-trigger' 1)		#('application/dvcs' 1)		#('application/sieve' 1)		#('application/vnd.vividence.scriptfile' 1)		#('application/ms-word-document' 1)		#('application/mac-binhex40' 1)		#('application/mac-compactpro' 1)		#('application/x-gtar' 1)		#('application/x-shockwave-flash' 1)		#('application/x-stuffit' 1)		#('application/x-tar' 1)		#('application/javascript' 0) 		#('application/x-javascript' 0)		#('application/json' 0 #( #encoding 'utf8'))		#('audio/basic' 1)		#('audio/32kadpcm' 1)		#('audio/vnd.qcelp' 1)		#('audio/vnd.digital-winds' 1)		#('audio/vnd.lucent.voice' 1)		#('audio/vnd.octel.sbc' 1)		#('audio/vnd.rhetorex.32kadpcm' 1)		#('audio/vnd.vmx.cvsd' 1)		#('audio/vnd.nortel.vbk' 1)		#('audio/vnd.cns.anp1' 1)		#('audio/vnd.cns.inf1' 1)		#('audio/L16' 1)		#('audio/vnd.everad.plj' 1)		#('audio/telephone-event' 1)		#('audio/tone' 1)		#('audio/prs.sid' 1)		#('audio/vnd.nuera.ecelp4800' 1)		#('audio/vnd.nuera.ecelp7470' 1)		#('audio/mpeg' 1)		#('audio/parityfec' 1)		#('audio/MP4A-LATM' 1)		#('audio/midi' 1)		#('audio/x-aiff' 1)		#('audio/x-pn-realaudio' 1)		#('audio/x-pn-realaudio' 1)		#('audio/x-pn-realaudio-plugin' 1)		#('audio/x-realaudio' 1)		#('audio/x-wav' 1)		#('image/jpeg' 1)		#('image/gif' 1)		#('image/ief' 1)		#('image/g3fax' 1)		#('image/tiff' 1)		#('image/cgm' 1)		#('image/naplps' 1)		#('image/vnd.dwg' 1)		#('image/vnd.svf' 1)		#('image/vnd.dxf' 1)		#('image/png' 1)		#('image/vnd.fpx' 1)		#('image/vnd.net-fpx' 1)		#('image/vnd.xiff' 1)		#('image/prs.btif' 1)		#('image/vnd.fastbidsheet' 1)		#('image/vnd.wap.wbmp' 1)		#('image/prs.pti' 1)		#('image/vnd.cns.inf2' 1)		#('image/vnd.mix' 1)		#('image/vnd.fujixerox.edmics-rlc' 1)		#('image/vnd.fujixerox.edmics-mmr' 1)		#('image/vnd.fst' 1)		#('image/x-xbitmap' 1)		#('message/delivery-status' 0)		#('message/external-body' 0)		#('message/htpp' 0)		#('message/news' 0)		#('message/partial' 0)		#('message/rfc822' 0)		#('message/s-http' 0)		#('multipart/mixed' 0)		#('multipart/alternative' 0)		#('multipart/digest' 0)		#('multipart/parallel' 0)		#('multipart/appledouble' 0)		#('multipart/header-set' 0)		#('multipart/form-data' 0)		#('multipart/related' 0)		#('multipart/report' 0)		#('multipart/voice-message' 0)		#('multipart/signed' 0)		#('multipart/encrypted' 0)		#('multipart/byteranges' 0)		#('text/plain' 0)		#('text/richtext' 0)		#('text/enriched' 0)		#('text/tab-separated-values' 0)		#('text/html' 0)		#('text/sgml' 0)		#('text/vnd.latex-z' 0)		#('text/vnd.fmi.flexstor' 0)		#('text/uri-list' 0)		#('text/vnd.abc' 0)		#('text/rfc822-headers' 0)		#('text/vnd.in3d.3dml' 0)		#('text/prs.lines.tag' 0)		#('text/vnd.in3d.spot' 0)		#('text/css' 0)		#('text/xml' 0 #(#lineEndConvention 2))		#('text/rtf' 0)		#('text/directory' 0)		#('text/calendar' 0)		#('text/vnd.wap.wml' 0)		#('text/vnd.wap.wmlscript' 0)		#('text/vnd.motorola.reflex' 0)		#('text/vnd.fly' 0)		#('text/vnd.wap.sl' 0)		#('text/vnd.wap.si' 0)		#('text/t140' 0)		#('text/vnd.ms-mediapackage' 0)		#('text/vnd.IPTC.NewsML' 0)		#('text/vnd.IPTC.NITF' 0)		#('text/vnd.curl' 0)		#('text/vnd.DMClientScript' 0)		#('text/parityfec' 0)		#('video/mpeg' 1)		#('video/quicktime' 1)		#('video/vnd.vivo' 1)		#('video/vnd.motorola.video' 1)		#('video/vnd.motorola.videop' 1)		#('video/vnd.fvt' 1)		#('video/pointer' 1)		#('video/parityfec' 1)		#('video/vnd.mpegurl' 1)		#('video/MP4V-ES' 1)		#('video/x-msvideo' 1)		#('video/x-sgi-movie' 1)		#('model/iges' 1)		#('model/vrml' 1)		#('model/mesh' 1)		#('model/vnd.dwf' 1)		#('model/vnd.gtw' 1)		#('model/vnd.flatland.3dml' 1)		#('model/vnd.vtu' 1)		#('model/vnd.mts' 1)		#('model/vnd.gdl' 1)		#('model/vnd.gs-gdl' 1)		#('model/vnd.parasolid.transmit.text' 1)		#('model/vnd.parasolid.transmit.binary' 1)	)</body><body package="NetClientBase">initialize	" MimeTypeDescriptor initialize "	self 		initializeMimeTypes;		initializeFileExtensionToMimeTypeMap;		initializeMimeCharsetToEncodingMap</body><body package="NetClientBase">initializeFileExtensionToMimeTypeMap	FileExtensionToMimeTypeMap := Dictionary new: 32.	self defaultFileExtensionMap do: [ :element | 		FileExtensionToMimeTypeMap at: element first put: element last].	FileExtensionToMimeTypeMap		at: 'html' put: 'text/html';		at: 'htm' put: 'text/html';		at: 'xml' put: 'text/xml';		at: 'txt' put: 'text/plain';		at: 'c' put: 'text/plain';		at: 'cpp' put: 'text/plain';		at: 'h' put: 'text/plain';		at: 'hpp' put: 'text/plain';		at: 'st' put: 'text/plain';		at: 'pst' put: 'text/plain';		at: 'cls' put: 'text/plain';		at: 'gif' put: 'image/gif';		at: 'jpg' put: 'image/jpeg';		at: 'jpeg' put: 'image/jpeg';		at: 'xbm' put: 'image/x-xbitmap';		at: 'mid' put: 'audio/midi';		at: 'doc' put: 'application/ms-word-document';	at: 'hqx' put: 'application/mac-binhex40';	at: 'cpt' put: 'application/mac-compactpro';	at: 'pdf' put: 'application/pdf';	at: 'ps' put: 'application/postscript';	at: 'ai' put: 'application/postscript';	at: 'eps' put: 'application/postscript';	at: 'rtf' put: 'text/rtf';	at: 'bin' put: 'application/octet-stream';	at: 'dms' put: 'application/octet-stream';	at: 'lha' put: 'application/octet-stream';	at: 'lzh' put: 'application/octet-stream';	at: 'exe' put: 'application/octet-stream';	at: 'class' put: 'application/octet-stream';	at: 'pcl' put: 'application/octet-stream';	at: 'im' put: 'application/octet-stream';	at: 'img' put: 'application/octet-stream';	at: 'zip' put: 'application/zip';	at: 'gz' put: 'application/gzip';	at: 'gtar' put: 'application/x-gtar';	at: 'swf' put: 'application/x-shockwave-flash';	at: 'sit' put: 'application/x-stuffit';	at: 'tar' put: 'application/x-tar';	at: 'au' put: 'audio/basic';	at: 'snd' put: 'audio/basic';	at: 'mid' put: 'audio/midi';	at: 'midi' put: 'audio/midi';	at: 'mpga' put: 'audio/mpeg';	at: 'mp2' put: 'audio/mpeg';	at: 'mp3' put: 'audio/mpeg';	at: 'aiff' put: 'audio/x-aiff';	at: 'aif' put: 'audio/x-aiff';	at: 'aifc' put: 'audio/x-aiff';	at: 'rm' put: 'audio/x-pn-realaudio';	at: 'ram' put: 'audio/x-pn-realaudio';	at: 'rpm' put: 'audio/x-pn-realaudio-plugin';	at: 'ra' put: 'audio/x-realaudio';	at: 'wav' put: 'audio/x-wav';	at: 'css' put: 'text/css';	at: 'mpeg' put: 'video/mpeg';	at: 'mpg' put: 'video/mpeg';	at: 'mpe' put: 'video/mpeg';	at: 'qt' put: 'video/quicktime';	at: 'mov' put: 'video/quicktime';	at: 'avi' put: 'video/x-msvideo';	at: 'movie' put: 'video/x-sgi-movie'.</body><body package="NetClientBase">initializeMimeCharsetToEncodingMap	MimeCharsetToEncodingMap := IdentityDictionary new: 5.	#(		#('us-ascii' ISO8859_1"ASCII")		#('default' ISO8859_1"ASCII")		#('iso-8859-1' ISO8859_1)		#('utf-8' utf8)		#('binary' binary)	) do: [ :arr | MimeCharsetToEncodingMap at: arr first asSymbol put: arr last asSymbol ]</body><body package="NetClientBase">initializeMimeTypes	| contentType entity token binary |	MimeTypeRegistry := Dictionary new: 32.	self defaultMimeTypes do: [ :literalArray |		entity := MimeTypeDescriptor new.		contentType := literalArray at: 1.		entity contentType: contentType.		binary := (literalArray at: 2) = 1.		entity binary: binary.		3 to: literalArray size do: [ :idx |			token := literalArray at: idx.			(token isKindOf: Array)				ifTrue: [entity propertyAt: token first put: token last]].		MimeTypeRegistry at: contentType put: entity].</body></methods><methods><class-id>Net.MimeTypeDescriptor class</class-id> <category>Mime character sets</category><body package="NetClientBase">defaultCharacterSet" Answer default character set that we use ""	#todo.			 Rework because we may use different character sets on different platforms "	^self iso8859x1</body><body package="NetClientBase">defaultEncoding" Answer default character encoding that we use "	^self encodingForCharset: self defaultCharacterSet</body><body package="NetClientBase">defaultMimeCharacterSet" Default character set if none is specified "	^self usAscii</body><body package="NetClientBase">encodingForCharset: aCharsetName" 	MimeTypeDescriptor encodingForCharset: #us-ascii	MimeTypeDescriptor encodingForCharset: 'ISO-8859-1' "	^MimeCharsetToEncodingMap 		at: aCharsetName asLowercase asSymbol 		ifAbsent: [ self encodingForCharset: #default ]</body><body package="NetClientBase">iso8859x1	^'iso-8859-1'</body><body package="NetClientBase">iso8859x1Encoding	^self encodingForCharset: self iso8859x1</body><body package="NetClientBase">usAscii" Default canonical character set for Mime messages "	^'us-ascii'</body><body package="NetClientBase">usAsciiEncoding" Encoding name for us-ascii charset "	^self encodingForCharset: self usAscii</body><body package="NetClientBase">utf8	^'utf-8'</body><body package="NetClientBase">utf8Encoding" Encoding name for UTF-8 charset "	^self encodingForCharset: self utf8</body></methods><methods><class-id>Net.MimeTypeDescriptor class</class-id> <category>private</category><body package="NetClientBase">guessFromExtension: aString	"guesses a content type from the extension"	^self guessFromExtension: aString ifAbsent: [self defaultUnsupportedContentType].</body><body package="NetClientBase">guessFromExtension: aString ifAbsent: aBlock"Guesses a content type from the extension. aString represents a file extension. Possible values: '.xxx', 'xxx', nil."	| ext |	aString isNil ifTrue: [^aBlock value].	ext := aString first == $.		ifTrue: [ aString copyFrom: 2 to: aString size ]		ifFalse: [ aString ].	^ FileExtensionToMimeTypeMap at: ext asLowercase ifAbsent: aBlock.</body></methods><methods><class-id>Net.StreamSegment</class-id> <category>initialization</category><body package="NetClientBase">initialize	position := size := 0</body><body package="NetClientBase">offset: integerPos size: integerSize	offset := integerPos.	size := integerSize.</body><body package="NetClientBase">stream: aStream	source := aStream.	size = 0		ifTrue: [ size := aStream size ].	offset isNil		ifTrue: [ offset := aStream position ]		ifFalse: [ aStream position: offset ]</body></methods><methods><class-id>Net.StreamSegment</class-id> <category>positioning</category><body package="NetClientBase">atEnd	^self evaluateWithProperPositioning: [self privateAtEnd]</body><body package="NetClientBase">close	source close</body><body package="NetClientBase">position	^position</body><body package="NetClientBase">position: aNumber	position := aNumber</body><body package="NetClientBase">reset	"Set the receiver's position to start position."	position := 0.</body></methods><methods><class-id>Net.StreamSegment</class-id> <category>instance creation</category><body package="NetClientBase">asStream	^self</body><body package="NetClientBase">from: start to: end	^source from: start + offset to: end + offset</body><body package="NetClientBase">newSize: anInteger 	^self newSize: anInteger startingAt: self position</body><body package="NetClientBase">newSize: anInteger startingAt: localOffset 	^source newSize: anInteger startingAt: localOffset + offset</body></methods><methods><class-id>Net.StreamSegment</class-id> <category>accessing</category><body package="NetClientBase">asEncodedStreamWithEncoding: aSymbol lineEndConvention: aNumber 	^(source asEncodedStreamWithEncoding: aSymbol lineEndConvention: aNumber )		newSize: size startingAt: offset</body><body package="NetClientBase">binary	source binary</body><body package="NetClientBase">contents	| savePos |	savePos := self position.	^[self reset; privateContents]		ensure: [self position: savePos]</body><body package="NetClientBase">finish</body><body package="NetClientBase">flush	source flush</body><body package="NetClientBase">lineEndCRLF	source lineEndCRLF</body><body package="NetClientBase">lineEndConvention	^source lineEndConvention</body><body package="NetClientBase">lineEndConvention: convention	convention = LineEndAuto		ifTrue: [ self setLineEndConventionFromContents ]		ifFalse: [ source lineEndConvention: convention ].</body><body package="NetClientBase">lineEndTransparent	^source lineEndTransparent</body><body package="NetClientBase">needsFileLineEndConversion	^source needsFileLineEndConversion</body><body package="NetClientBase">next	^self 		evaluateWithProperPositioning: 			[self privateAtEnd				ifTrue: [self pastEnd]				ifFalse: [source next]]</body><body package="NetClientBase">next: anInteger 	^self 		evaluateWithProperPositioning: 			[(source atEnd or: [position + anInteger &gt; self size])				ifTrue: [self pastEnd]				ifFalse: [source next: anInteger]]</body><body package="NetClientBase">next: anInteger into: aSequenceableCollection startingAt: startIndex 	"Store the next anInteger elements of the receiver into aSequenceableCollection 	starting at startIndex in aSequenceableCollection. Answer aSequenceableCollection."	| index stopIndex |	^self evaluateWithProperPositioning: 		[		index := startIndex.		stopIndex := index + anInteger.		[[index &lt; stopIndex and: [self privateAtEnd not ]]					whileTrue: [aSequenceableCollection at: index put: source next.								index := index + 1]]			on: Stream endOfStreamSignal			do: 				[:ex | ex retryUsing:						[(Stream incompleteNextCountSignal newExceptionFrom: self)							parameter: index - startIndex;							raiseRequest]].		aSequenceableCollection]</body><body package="NetClientBase">nextAvailable: anInteger 	"Answer the next anInteger elements of the receiver.  If there are not	enough elements available, answer a collection of as many as are available."	^self evaluateWithProperPositioning: [ | newCollection count |		newCollection := self contentsSpecies withSize: anInteger.		count := self nextAvailable: anInteger into: newCollection startingAt: 1.		count = anInteger			ifTrue: [newCollection]			ifFalse: [newCollection copyFrom: 1 to: count]]</body><body package="NetClientBase">nextPut: aByte	^self 		evaluateWithProperPositioning: 			[source atEnd 				ifTrue: [self pastEnd]				ifFalse: [source nextPut: aByte]]</body><body package="NetClientBase">offset	^offset</body><body package="NetClientBase">peek	"Answer what would be returned with a self next, without	changing position.  If the receiver is at the end, answer nil."	| nextObject |	^self evaluateWithProperPositioning: 		[self privateAtEnd ifTrue: [^nil].		nextObject := source next.		source skip: -1.		nextObject]</body><body package="NetClientBase">peekFor: anObject 	"Answer false and do not move the position if self next ~= anObject or if the	receiver is at the end. Answer true and increment position if self next = anObject."	| nextObject |	self evaluateWithProperPositioning:		[self privateAtEnd ifTrue: [^false].		nextObject := source next.		"peek for matching element"		anObject = nextObject ifTrue: [^true].		"gobble it if found"		source skip: -1].	^false</body><body package="NetClientBase">size	^size</body><body package="NetClientBase">skip: integer	self evaluateWithProperPositioning: [source skip: integer]</body><body package="NetClientBase">skipSeparators	"Move the receiver's position past any separators."	[[self next isSeparator] whileTrue.			"We will not reach here if the end-of-stream is encountered"			self skip: -1]		on: EndOfStreamNotification		do:	[:ex | ex return]</body><body package="NetClientBase">skipThroughAll: pattern	"Skip forward to the next occurrence (if any) of aCollection.	If found, leave the stream positioned after the occurrence,	and answer the receiver; if not found, answer nil,	and leave the stream positioned at the end."	^self upToAll: pattern returnMatch: false includePattern: false.</body><body package="NetClientBase">skipToAll: anObject	^self evaluateWithProperPositioning: [source skipToAll: anObject]</body><body package="NetClientBase">text	source text</body><body package="NetClientBase">throughAll: aCollection	" Answer a subcollection from the current position	through the occurrence (if any, inclusive) of aCollection,	and leave the stream positioned after the occurrence.	If no occurrence is found, answer the entire remaining	stream contents, and leave the stream positioned at the end. "	| first length newStream |	self evaluateWithProperPositioning: [	newStream := (self contentsSpecies new: 64) writeStream.	(length := aCollection size) = 0 ifTrue: [^newStream contents].	first := aCollection at: 1.	[self privateAtEnd] whileFalse:		[| element |		element := source next.		newStream nextPut: element.		element = first ifTrue:			[| nonMatch nextPos |			nonMatch := 2.			nextPos := source position.			[nonMatch &gt; length ifTrue:				[" Success. "				newStream skip: -1. "Since the first element has been put in"				newStream nextPutAll: aCollection.				^newStream contents].			self privateAtEnd ifTrue:  " Not found. "				[" Copy the partial match. "				source position: nextPos.				[self privateAtEnd] whileFalse: [newStream nextPut: source next].				^newStream contents].			source next = (aCollection at: nonMatch)]				whileTrue: [nonMatch := nonMatch + 1].			" Didn't match, back up. "			source position: nextPos]]].	" Not found. "	^newStream contents</body><body package="NetClientBase">upTo: anObject	"Answer a subcollection from position to the occurrence (if any, exclusive) of anObject.	 The stream is left positioned after anObject.	If anObject is not found answer everything."	| newStream element |	^self evaluateWithProperPositioning:		[newStream := (source contentsSpecies new: 64) writeStream.		[self privateAtEnd]			whileFalse:				[element := source next.				element = anObject					ifTrue: [^newStream contents].				newStream nextPut: element.].		newStream contents]</body><body package="NetClientBase">upToAll: aCollection	" Answer a subcollection from the current position	up to the occurrence (if any, not inclusive) of aCollection,	and leave the stream positioned before the occurrence.	If no occurrence is found, answer the entire remaining	stream contents, and leave the stream positioned at the end. "	| first length newStream|	self evaluateWithProperPositioning: [	(length := aCollection size) = 0 ifTrue: [^self].	first := aCollection at: 1.	newStream := (source contentsSpecies new: 64) writeStream.	[self privateAtEnd] whileFalse:		[| element |		element := source next.		newStream nextPut: element.		element = first ifTrue:			[| nonMatch |			nonMatch := 2.			[nonMatch &gt; length ifTrue:				[" Success.  Back up over the occurrence. "				source skip: length negated.				newStream skip: -1. "Since the first element has been put in"				^newStream contents].			self privateAtEnd ifTrue:  " Not found. "				[source skip: 2 - nonMatch.				" Copy the partial match. "				[self privateAtEnd] whileFalse: [newStream nextPut: source next].				^newStream contents].			source next = (aCollection at: nonMatch)]				whileTrue: [nonMatch := nonMatch + 1].			" Didn't match, back up. "			source skip: 1 - nonMatch]]].	" Not found. "	^newStream contents</body><body package="NetClientBase">upToAll: pattern returnMatch: returnMatch includePattern: includePattern	"		^		&lt;Integer&gt;	This matches pattern in the stream, starting from the current position. It has a fairly complex API, so you might want to use one of the simpler senders, upToAll:, upToAndSkipThroughAll:, or throughAll:	It uses the Knuth-Morris-Pratt algorithm, from Cormen et al.'s Algorithms, page 871. See also Gusfield's Alorithms on Strings, Trees and Sequences, page 23.	This algorithm has the advantage in stream matching that it reads every character in the the text to be matched against exactly once, and never backtracks."	| current backupArray resultStream numberMatched |	(pattern isEmpty or: [ self atEnd ]) ifTrue: [		^returnMatch ifTrue: [self contentsSpecies new] ifFalse: [self]]. "Empty counts as found"	resultStream := ReadWriteStream on: (self contentsSpecies new: 100).	backupArray := source computePrefixFunctionFor: pattern.	numberMatched := 0.	[self privateAtEnd] whileFalse: [		current := self next.		returnMatch ifTrue: [resultStream nextPut: current].		"Mismatch, back up the previous partial match position, as precalculated"		[numberMatched &gt; 0 and: [ (pattern at: numberMatched + 1) ~= current]]			whileTrue: [numberMatched := backupArray at: numberMatched].		(pattern at: numberMatched + 1) = current			ifTrue: [numberMatched := numberMatched + 1].		"We reached the end of the pattern, return the result, omitting the pattern itself"		numberMatched = pattern size ifTrue: [			returnMatch ifFalse: [^self].			^includePattern 				ifTrue: [resultStream contents]				ifFalse: [					resultStream reset.					resultStream next: resultStream size - pattern size]]].	"We reached the end of the stream without finding a match. Return everything"	^returnMatch ifTrue: [resultStream contents] ifFalse: [nil].</body><body package="NetClientBase">upToAndSkipThroughAll: pattern	" Answer a subcollection from the current position	up to the occurrence (if any, not inclusive) of aCollection,	and leave the stream positioned after the occurrence.	If no occurrence is found, answer the entire remaining	stream contents, and leave the stream positioned at the end. "	^self upToAll: pattern returnMatch: true includePattern: false.</body><body package="NetClientBase">upToEnd	"Answer a collection consisting of all the elements from the current position	to the end of stream."	| newStream |	^self evaluateWithProperPositioning:		[newStream := (source contentsSpecies new: 64) writeStream.		[self privateAtEnd] whileFalse: [newStream nextPut: source next].		newStream contents]</body></methods><methods><class-id>Net.StreamSegment</class-id> <category>private</category><body package="NetClientBase">contentsSpecies	^source contentsSpecies</body><body package="NetClientBase">evaluateWithProperPositioning: aBlock	^[source position: position + offset.	aBlock value]		ensure: 			[ position := source position - offset ]</body><body package="NetClientBase">nextAvailable: anInteger into: aSequenceableCollection startingAt: startIndex	| currentInd endIndex |	self evaluateWithProperPositioning: [		currentInd := startIndex.		endIndex := currentInd + anInteger - 1.		[	self privateAtEnd or: [ currentInd &gt; endIndex ]		] whileFalse: [			aSequenceableCollection at: currentInd put: source next.			currentInd := currentInd + 1 ] ].	^currentInd - startIndex</body><body package="NetClientBase">pastEnd	"The receiver has attempted to read past the end, answer nil."	^Stream endOfStreamSignal raiseRequestFrom: self</body><body package="NetClientBase">privateAtEnd	^source position - offset &gt;= size or: [source atEnd]</body><body package="NetClientBase">privateContents"We need this method because #next: for CRLF line end convention returns more than we need"	| collection |	^self 		evaluateWithProperPositioning: 			[collection := (source contentsSpecies new: self size) writeStream.			[self privateAtEnd ]				whileFalse: 					[ collection nextPut: source next].					collection contents]</body><body package="NetClientBase">setLineEndConventionFromContents	| convention |	self lineEndTransparent.	convention :=		self withPosition: 0			do: [ :ignoredSavedPosition || wasBinary c |				(wasBinary := self isBinary) ifTrue: [ self text ].				[	[	c := self next.						c == LF or: [ c == CR or: [ c == nil ] ]					] whileFalse.					c == CR 						ifTrue: [ self next == LF ifTrue: [LineEndCRLF] ifFalse: [LineEndCR]]						ifFalse: [ c == LF ifTrue: [LineEndLF] ifFalse: [LineEndTransparent] ]				] ensure: [ wasBinary ifTrue: [ self binary ] ]].	self lineEndConvention: convention.</body><body package="NetClientBase">withPosition: aPosition do: aBlock	"Save the current positon of the stream, position the stream to aPosition and	 then evaluate aBlock with the current position of the stream as an argument.	 Then reset the position to the original position.	 Answer the value returned by aBlock."	| savedPosition |	savedPosition := self position.	self position: aPosition.	^[aBlock value: savedPosition] ensure: [self position: savedPosition]</body></methods><methods><class-id>Net.StreamSegment</class-id> <category>testing</category><body package="NetClientBase">isBinary	^source isBinary</body><body package="NetClientBase">isByteStream	^self isCharacterStream not</body><body package="NetClientBase">isCharacterStream	^source isCharacterStream</body><body package="NetClientBase">isInternal	^source isInternal</body><body package="NetClientBase">isSegmented	^true</body></methods><methods><class-id>Net.StreamSegment class</class-id> <category>instance creation</category><body package="NetClientBase">new	^super new initialize</body><body package="NetClientBase">on: aStream 	^(self new) 		stream: aStream; 		yourself</body><body package="NetClientBase">on: aStream offset: offsetNumber size: sizeNumber 	^(self new) 		stream: aStream; 		offset: offsetNumber size: sizeNumber; 		yourself</body></methods><methods><class-id>Net.NetConnection</class-id> <category>stream</category><body package="NetClientBase">close	self disconnect</body><body package="NetClientBase">commit	stream flush.</body><body package="NetClientBase">disconnect	stream notNil		ifTrue: 			[ stream close.			stream := nil.]</body></methods><methods><class-id>Net.NetConnection</class-id> <category>testing</category><body package="NetClientBase">isConnected	^stream notNil</body><body package="NetClientBase">isSecure	^false</body></methods><methods><class-id>Net.NetConnection</class-id> <category>defaults</category><body package="NetClientBase">defaultEncoding	^self class defaultEncoding</body><body package="NetClientBase">defaultLineEndConvention	^self class defaultLineEndConvention</body><body package="NetClientBase">defaultPortNumber	^self class defaultPortNumber</body></methods><methods><class-id>Net.NetConnection</class-id> <category>accessing</category><body package="NetClientBase">getResponseStream	^stream</body><body package="NetClientBase">settings	^settings</body><body package="NetClientBase">settings: aNetPISettings	settings := aNetPISettings</body><body package="NetClientBase">stream	^stream</body></methods><methods><class-id>Net.NetConnection</class-id> <category>initialize-release</category><body package="NetClientBase">initialize		settings := NetPISettings new</body><body package="NetClientBase">openSocketStreamFor: aHost port: aPortNumber timeout: tmNumber encoding: anEncoding	stream := self 				socketStreamWithEncoding: anEncoding 				host: aHost 				port: aPortNumber 				timeout: tmNumber.	^stream</body><body package="NetClientBase">openStreamFor: aHost port: aPortNumber timeout: tmNumber	^self openSocketStreamFor: aHost port: aPortNumber timeout: tmNumber encoding: self defaultEncoding</body></methods><methods><class-id>Net.NetConnection</class-id> <category>private</category><body package="NetClientBase">createSocketTimeout: aNumber forAddress: info	^info asSocketAccessor</body><body package="NetClientBase">socketStreamWithEncoding: aSymbol host: aHost port: aPortNumber timeout: tmNumber   | aSocket exhaustedAllChoices |     exhaustedAllChoices := false.     [    (IPSocketAddress tcpAddressesForHost: aHost port: (aPortNumber ifNil: [self defaultPortNumber]))             detect: [ :info |                 [    aSocket := self createSocketTimeout: tmNumber forAddress: info.                     [ aSocket connectTo: info address ] ifCurtailed: [ aSocket close ].                     true                 ] on: OsError do: [ :ex | false ] ]             ifNone: [ exhaustedAllChoices := true ]     ]    onTimeout: tmNumber milliseconds         do: [ OSErrorHolder operationStartedSignal raiseSignal ].     exhaustedAllChoices ifTrue: [OsInaccessibleError raiseSignal].     ^(aSocket asExternalConnection withEncoding: aSymbol) readAppendStream         lineEndConvention: self defaultLineEndConvention</body></methods><methods><class-id>Net.NetConnection class</class-id> <category>default values</category><body package="NetClientBase">defaultEncodingValue	^#ISO8859_1</body><body package="NetClientBase">defaultLineEndConvention	^LineEndCRLF</body><body package="NetClientBase">defaultPortNumber	^self subclassResponsibility</body></methods><methods><class-id>Net.NetConnection class</class-id> <category>defaults</category><body package="NetClientBase">defaultEncoding	^encoding ifNil: [ encoding :=self defaultEncodingValue ]</body><body package="NetClientBase">defaultEncoding: aSymbol	encoding := aSymbol</body></methods><methods><class-id>Net.NetConnection class</class-id> <category>instance creation</category><body package="NetClientBase">new	^super new initialize</body></methods><methods><class-id>Net.InvalidAddressSpec class</class-id> <category>testing</category><body package="NetClientBase">mayResume	^true</body></methods><methods><class-id>Net.HostSpec</class-id> <category>accessing</category><body package="NetClientBase">beSecure	isSecure := true</body><body package="NetClientBase">dontBeSecure	isSecure := false</body><body package="NetClientBase">name	^name</body><body package="NetClientBase">name: aString	name := aString</body><body package="NetClientBase">netUser	^netUser</body><body package="NetClientBase">netUser: aNetUser	netUser := aNetUser</body><body package="NetClientBase">port	^port</body><body package="NetClientBase">port: aNumber	port := aNumber</body><body package="NetClientBase">registry	^Settings</body><body package="NetClientBase">type	^type</body><body package="NetClientBase">type: aString	type := aString</body><body package="NetClientBase">useSTARTTLS	^useSTARTTLS ifNil: [ false]</body><body package="NetClientBase">useSTARTTLS: aBoolean	useSTARTTLS := aBoolean</body><body package="NetClientBase">useSecureConnectionIfAvailable"STARTTLS is an extension to plain text communication protocols, which offers a way to upgrade a plain text connection to an encrypted (TLS or SSL)  "	self useSTARTTLS:  true</body><body package="NetClientBase">user	^self netUser</body><body package="NetClientBase">user: aNetUser	self netUser: aNetUser</body></methods><methods><class-id>Net.HostSpec</class-id> <category>testing</category><body package="NetClientBase">isDefaultMailHost	^self registry isDefaultMailHost: self</body><body package="NetClientBase">isIncomingTypeMail	^self registry isIncomingTypeHost: self</body><body package="NetClientBase">isMailHost	^self registry isMailHost: self</body><body package="NetClientBase">isOutgoingTypeMail	^self registry isOutgoingTypeHost: self</body><body package="NetClientBase">isSameAs: aHostSpec	^self name asLowercase = aHostSpec name asLowercase		and: [ self type = aHostSpec type ]</body><body package="NetClientBase">isSecure	^isSecure notNil and: [ isSecure ]</body></methods><methods><class-id>Net.HostSpec</class-id> <category>update</category><body package="NetClientBase">updateBy: aHostSpec	self 		name: aHostSpec name;		type: aHostSpec type;		netUser: aHostSpec netUser;		port: aHostSpec port.</body></methods><methods><class-id>Net.HostSpec</class-id> <category>printing</category><body package="NetClientBase">printDefaultDescriptionOn: aStream 	aStream nextPutAll: ' ( Default ', (self registry serverTypeDescriptionFor: self) asString, ')'</body><body package="NetClientBase">printDescriptionOn: aStream 	aStream nextPutAll: ' (', (self registry serverTypeDescriptionFor: self) asString, ')'</body><body package="NetClientBase">printOn: aStream 	aStream nextPutAll: self name.	self isMailHost		ifTrue:			[self isDefaultMailHost				ifTrue: [ self printDefaultDescriptionOn: aStream]				ifFalse: [ self printDescriptionOn: aStream]]</body><body package="NetClientBase">specString	| stream value |	stream := (String new: 32) writeStream.	self class instVarNames 		do: [ :ins | 			value := self instVarAt: ( self class instVarIndexFor: ins).			ins = 'netUser'				ifTrue: [ stream nextPutAll:  ins, ' = ', value name; cr]				ifFalse: 						[value notNil 						ifTrue: 							[stream nextPutAll:  ins, ' = ', value printString; cr]]].	^stream contents.</body></methods><methods><class-id>Net.HostSpec</class-id> <category>services</category><body package="NetClientBase">clientClass	^NetClient allSubclasses		detect: [ :class |			(class class includesSelector: #serverType)			and: [ class serverType = type asUppercase asSymbol ] ]		ifNone: [ self error: (#UnknownServerType1s &lt;&lt; #net &gt;&gt; 'Unknown server type &lt;1s&gt;' expandMacrosWith: type ) ]</body><body package="NetClientBase">newClient	^self clientClass new configureFrom: self</body></methods><methods><class-id>Net.HostSpec class</class-id> <category>instance creation</category><body package="NetClientBase">protocol: type host: host user: user	^self hostPortFrom: host do: [ :hostname :port |		self new			type: type;			name: hostname;			port: port;			netUser: user;			yourself ]</body><body package="NetClientBase">protocol: type host: host username: username password: password	| user |	user :=		self hostPortFrom: host do: [ :hostname |			(NetUser username: username password: password)				mailAddress: ('&lt;1s&gt;@&lt;2s&gt;' expandMacrosWith: username with: hostname);					yourself ].	^self protocol: type host: host user: user</body></methods><methods><class-id>Net.HostSpec class</class-id> <category>utilities</category><body package="NetClientBase">getHostPortFrom: aString	| h ts p |	ts := aString tokensBasedOn: $:.	ts size = 1		ifTrue: [ h := ts first]		ifFalse: [ h := ts first. p := ts last asNumber ].	^h-&gt;p</body><body package="NetClientBase">hostPortFrom: aString do: aBlock	| h ts p |	ts := aString tokensBasedOn: $:.	ts size = 1		ifTrue: [ h := ts first]		ifFalse: [ h := ts first. p := ts last asNumber ].	^aBlock cull: h cull: p</body></methods><methods><class-id>Net.NetProtocolInterpreter</class-id> <category>connection management</category><body package="NetClientBase">connectToHost: aHostName port: aNumber timeout: tmNumber	 ^self connection 			openStreamFor: aHostName			port: aNumber			timeout: tmNumber</body><body package="NetClientBase">disconnect	self connection disconnect.</body></methods><methods><class-id>Net.NetProtocolInterpreter</class-id> <category>debugging</category><body package="NetClientBase">log: aString level: aLevel	self class log: aString level: aLevel</body></methods><methods><class-id>Net.NetProtocolInterpreter</class-id> <category>public</category><body package="NetClientBase">executeCommand: aString</body></methods><methods><class-id>Net.NetProtocolInterpreter</class-id> <category>accessing</category><body package="NetClientBase">connection	connection ifNil: [self useDefaultConnection].	^connection</body><body package="NetClientBase">netConnectionClass	^self class defaultNetConnection</body><body package="NetClientBase">responseStream	^self connection getResponseStream</body><body package="NetClientBase">stream	^self connection stream</body><body package="NetClientBase">timeout	^self settings timeout</body><body package="NetClientBase">timeout: numberOfMilliseconds	self settings timeout: numberOfMilliseconds</body></methods><methods><class-id>Net.NetProtocolInterpreter</class-id> <category>initialize-release</category><body package="NetClientBase">connection: aNetConnection	connection :=  aNetConnection</body><body package="NetClientBase">initialize	settings := self class settings new</body><body package="NetClientBase">useDefaultConnection	connection := self netConnectionClass new.	connection settings: self settings</body></methods><methods><class-id>Net.NetProtocolInterpreter</class-id> <category>settings</category><body package="NetClientBase">settings		^settings</body><body package="NetClientBase">settings: anNetPISettings		settings := anNetPISettings</body></methods><methods><class-id>Net.NetProtocolInterpreter</class-id> <category>testing</category><body package="NetClientBase">isConnected	^self connection notNil and:  [self connection isConnected ]</body></methods><methods><class-id>Net.NetProtocolInterpreter class</class-id> <category>debugging</category><body package="NetClientBase">debugLabelsAndValues	^OrderedCollection new		add: ((#NetClientMessages &lt;&lt; #net &gt;&gt; 'Net Client Messages')-&gt;#NetClient);		yourself</body><body package="NetClientBase">log: aString level: aLevel	#{Tools.LogEnvironment} ifDefinedDo: [ :le | le  default log: aString level: aLevel ]</body><body package="NetClientBase">menuItemName	^(#NetClientMessages &lt;&lt; #net &gt;&gt; 'Net Client Messages')</body><body package="NetClientBase">registerToDebug	#{Tools.LogEnvironment} ifDefinedDo: [ :le | le  default addToDebug: self ]</body><body package="NetClientBase">unregisterFromDebug	#{Tools.LogEnvironment} ifDefinedDo: [ :le | le  default removeFromDebug: self ]</body></methods><methods><class-id>Net.NetProtocolInterpreter class</class-id> <category>instance creation</category><body package="NetClientBase">new	^super new initialize</body><body package="NetClientBase">onNetConnection: aNetConnection	^self new		connection: aNetConnection;		yourself</body></methods><methods><class-id>Net.NetProtocolInterpreter class</class-id> <category>defaults</category><body package="NetClientBase">defaultNetConnection	^defaultNetConnection ifNil: [defaultNetConnection := self defaultNetConnectionValue]</body><body package="NetClientBase">defaultNetConnection: aNetConnection	defaultNetConnection := aNetConnection</body></methods><methods><class-id>Net.NetProtocolInterpreter class</class-id> <category>default values</category><body package="NetClientBase">defaultNetConnectionValue	^self subclassResponsibility</body><body package="NetClientBase">settings		^NetPISettings</body></methods><methods><class-id>Net.Settings class</class-id> <category>accessing settings</category><body package="NetClientBase">defaultIdentity	^self registry at: #defaultIdentity  ifAbsent: [nil ]</body><body package="NetClientBase">defaultIdentity: aNetUser	self registry at: #defaultIdentity  put: aNetUser.	self changed: #changedDefaultIdentity with: aNetUser</body><body package="NetClientBase">defaultIncomingHost	^self registry at: #defaultIncomingServer   ifAbsent: [nil ]</body><body package="NetClientBase">defaultIncomingHost: aHostSpec	self registry at: #defaultIncomingServer  put: aHostSpec.	self changed: #changedDefaultIncomingServer with: aHostSpec</body><body package="NetClientBase">defaultOutgoingHost	^self registry at: #defaultOutgoingServer ifAbsent: [ nil ]</body><body package="NetClientBase">defaultOutgoingHost: aHostSpec	self registry at: #defaultOutgoingServer  put: aHostSpec.	self changed: #changedDefaultOutgoingServer with: aHostSpec</body><body package="NetClientBase">identities	^self registry at: #identities  ifAbsentPut: [OrderedCollection new ]</body><body package="NetClientBase">mailServers	^self registry at: #mailServers  ifAbsentPut: [OrderedCollection new ]</body><body package="NetClientBase">setDefaultMailHost: aHostSpec	( self isIncomingTypeHost: aHostSpec)		ifTrue: [ self defaultIncomingHost: aHostSpec].	(self isOutgoingTypeHost: aHostSpec)		ifTrue: [  self defaultOutgoingHost: aHostSpec].	(self detectMailHost: aHostSpec) == nil		ifTrue: [ self mailServers add: aHostSpec ]</body></methods><methods><class-id>Net.Settings class</class-id> <category>removing</category><body package="NetClientBase">removeDefaultIdentity	self registry removeKey: #defaultIdentity ifAbsent: [ nil ].	self changed: #removedDefaultIdentity.</body><body package="NetClientBase">removeDefaultIncomingHost	self registry removeKey: #defaultIncomingServer ifAbsent: [ nil ].	self changed: #removedDefaultIncomingServer.</body><body package="NetClientBase">removeDefaultOutgoingHost	self registry removeKey: #defaultOutgoingServer ifAbsent: [ nil ].	self changed: #removedDefaultOutgoingServer.</body><body package="NetClientBase">removeIdentity: aNetUser	(self  detectIdentity: aNetUser) ifNotNil: [ :user | self identities remove: user].	self mailServers 	do: [ :ea | ea netUser = aNetUser ifTrue: [ ea netUser: nil ]].		#'Net.HttpSettings' asQualifiedReference ifDefinedDo: [ :value | 		value proxyHost ifNotNil: [ :proxy | proxy netUser = aNetUser ifTrue: [value proxyHost netUser: nil ]].		value user ifNotNil: [ :httpUser | httpUser = aNetUser  ifTrue: [ value user: nil ]]].	self changed: #removedIdentity with: aNetUser.</body><body package="NetClientBase">removeMailHost: aHostSpec	| host |	(host := self  detectMailHost: aHostSpec) notNil		ifTrue: 			[ self mailServers remove: host.			self changed: #removedMailServer with: aHostSpec.			( self isDefaultIncomingHost: aHostSpec)				ifTrue: [ self removeDefaultIncomingHost].			( self isDefaultOutgoingHost: aHostSpec)				ifTrue: [ self removeDefaultOutgoingHost]]</body><body package="NetClientBase">resetIdentities	self removeDefaultIdentity.	^self registry at: #identities put: OrderedCollection new</body><body package="NetClientBase">resetServers	self removeDefaultIncomingHost.	self removeDefaultOutgoingHost.	^self registry at: #mailServers  put: OrderedCollection new</body></methods><methods><class-id>Net.Settings class</class-id> <category>detecting</category><body package="NetClientBase">detectIdentity: aNetUser	^self identities detect: [ :each | each = aNetUser ] ifNone: [ nil ]</body><body package="NetClientBase">detectIdentityByName: aName	^self identities detect: [ :each | each fullName = aName] ifNone: [ nil ]</body><body package="NetClientBase">detectMailClientFor: aHostSpec	aHostSpec type isNil ifTrue: [^nil].	^self supportedMailClients 			detect: [ :ea | ea serverType asSymbol = aHostSpec type asSymbol ] ifNone: [nil].</body><body package="NetClientBase">detectMailHost: aHostSpec	^self mailServers detect: [ :each | each name = aHostSpec name and: [ each type = aHostSpec type ] ] ifNone: [ nil ]</body><body package="NetClientBase">detectMailHostByName: aString	^self mailServers detect: [ :each | each name = aString ] ifNone: [ nil ]</body></methods><methods><class-id>Net.Settings class</class-id> <category>class initialization</category><body package="NetClientBase">initialize	"Settings initialize"	self initializeRegistry.</body><body package="NetClientBase">initializeRegistry	Registry isNil ifTrue: [ self resetRegistry ].</body><body package="NetClientBase">registry	^Registry</body><body package="NetClientBase">resetRegistry	" self resetRegistry "		Registry := Dictionary new.</body></methods><methods><class-id>Net.Settings class</class-id> <category>adding</category><body package="NetClientBase">addIdentity: aNetUser	aNetUser isNil ifTrue: [^nil].	(self  detectIdentity: aNetUser) 		ifNotNil: [ :user | 				user updateBy: aNetUser.				self changed: #updatedIdentity with: aNetUser]		ifNil: [ self identities add: aNetUser.			self changed: #addedIdentity with: aNetUser]</body><body package="NetClientBase">updateMailHost: aHostSpec	| host |	(host := self  detectMailHost: aHostSpec) notNil		ifTrue: 			[ host updateBy: aHostSpec.			self changed: #updatedMailHost with: host]		ifFalse: 			[ self mailServers add: aHostSpec.			self changed: #addedMailHost with: aHostSpec]</body></methods><methods><class-id>Net.Settings class</class-id> <category>mail server types</category><body package="NetClientBase">serverTypeDescriptionFor: aHostSpec	| cl  |	cl := self supportedMailClients 			detect: [ :ea | ea serverType asSymbol = aHostSpec type asSymbol ] ifNone: [nil].	^cl notNil		ifTrue: [ cl description ]		ifFalse: [String new].</body><body package="NetClientBase">supportedMailClients" mail server type and server description"	| col |	col := OrderedCollection new.	NetClient mailRegistry values do:			[ :ea | col add: ((LiteralBindingReference pathString: 'Net.',ea ) value)].	^col</body></methods><methods><class-id>Net.Settings class</class-id> <category>testing</category><body package="NetClientBase">hasIdentityReference: aNetUser	| usr |	self mailServers 		detect: [ :ea | (usr := ea netUser) notNil					ifTrue: [ (usr fullName = aNetUser fullName) ifTrue: [ ^true]].				false] 		ifNone: [nil].	#'Net.HttpSettings' asQualifiedReference ifDefinedDo: [ :value | ^value hasIdentityReference: aNetUser].	^false</body><body package="NetClientBase">isDefaultIdentity: aNetUser	| usr |	^(usr := self registry at: #defaultIdentity ifAbsent: [ nil ]) notNil		ifTrue: [ usr fullName = aNetUser fullName]		ifFalse: [ false ]</body><body package="NetClientBase">isDefaultIncomingHost: aHostSpec	| srv |	^(srv := self registry at: #defaultIncomingServer ifAbsent: [ nil ]) notNil		ifTrue: [ srv name = aHostSpec name]		ifFalse: [ false ]</body><body package="NetClientBase">isDefaultMailHost: aHostSpec	| srv |	(self isMailHost: aHostSpec) ifFalse: [^false].	srv := (( self isIncomingTypeHost: aHostSpec) 				ifTrue: [ self registry at: #defaultIncomingServer ifAbsent: [ nil ]]				ifFalse: [self registry at: #defaultOutgoingServer ifAbsent: [ nil ]]).	^srv notNil		ifTrue: [ srv name = aHostSpec name]		ifFalse: [ true ]</body><body package="NetClientBase">isDefaultOutgoingHost: aHostSpec	| srv |	^(srv := self registry at: #defaultOutgoingServer ifAbsent: [ nil ]) notNil		ifTrue: [ srv name = aHostSpec name]		ifFalse: [ false ]</body><body package="NetClientBase">isIncomingTypeHost: aHostSpec	| cl  |	^(cl := self detectMailClientFor: aHostSpec) notNil		ifTrue: [ cl isIncomingMailClient ]		ifFalse: [false]</body><body package="NetClientBase">isMailHost: aHostSpec	^(self detectMailClientFor: aHostSpec) notNil</body><body package="NetClientBase">isOutgoingTypeHost: aHostSpec	| cl  |	^(cl := self detectMailClientFor: aHostSpec) notNil		ifTrue: [ cl isOutgoingMailClient ]		ifFalse: [false]</body></methods><methods><class-id>Net.Settings class</class-id> <category>private</category><body package="NetClientBase">myDependents	"Answer the receiver's dependents or nil."	^dependents</body><body package="NetClientBase">myDependents: dependentsOrNil	"Set the receivers dependents."	dependents := dependentsOrNil</body></methods><methods><class-id>Net.ScannedLineSkipped</class-id> <category>private</category><body package="NetClientBase">defaultResumeValue	^self parameter asString</body></methods><methods><class-id>Net.NetClient</class-id> <category>accessing</category><body package="NetClientBase">clientPI	^clientPI isNil		ifTrue: [clientPI := self protocolInterpreterClass new]		ifFalse: [clientPI]</body><body package="NetClientBase">clientPI: anProtocolInterpreter 	clientPI := anProtocolInterpreter</body><body package="NetClientBase">connection	^self clientPI connection</body><body package="NetClientBase">delaySeconds	^self settings delaySeconds</body><body package="NetClientBase">delaySeconds: aNumber	self settings delaySeconds: aNumber</body><body package="NetClientBase">hostName	^hostName</body><body package="NetClientBase">hostName: aString	hostName := aString</body><body package="NetClientBase">password	^self user password</body><body package="NetClientBase">portNumber	^portNumber</body><body package="NetClientBase">portNumber: aNumber	portNumber := aNumber</body><body package="NetClientBase">retries	^self settings retries</body><body package="NetClientBase">retries: aNumber	self settings retries: aNumber</body><body package="NetClientBase">settings	^self clientPI settings</body><body package="NetClientBase">settings: aHttpPISettings	self clientPI settings: aHttpPISettings</body><body package="NetClientBase">state	^state</body><body package="NetClientBase">state: aState	state := aState.	state client: self</body><body package="NetClientBase">timeout	^self settings timeout</body><body package="NetClientBase">timeout: numberOfMilliseconds	self settings timeout: numberOfMilliseconds</body><body package="NetClientBase">user	^user</body><body package="NetClientBase">user: aNetUser	user := aNetUser</body><body package="NetClientBase">username	^self user username</body><body package="NetClientBase">username: aString	self user isNil		ifTrue: 			[ self user: 					(NetUser new 						username: aString;						yourself)]		ifFalse: [ self user username: aString]</body></methods><methods><class-id>Net.NetClient</class-id> <category>printing</category><body package="NetClientBase">printOn: aStream	aStream nextPutAll: 'a', self class name.	self hostName notNil		ifTrue: [aStream 					nextPutAll: ' on: ';					nextPutAll: self hostName;					nextPut: $:;					nextPutAll: self portNumber printString].</body></methods><methods><class-id>Net.NetClient</class-id> <category>defaults</category><body package="NetClientBase">defaultDelaySeconds	^self class defaultDelaySeconds</body><body package="NetClientBase">defaultPortNumber	^self class defaultPortNumber</body><body package="NetClientBase">defaultRetries	^self class defaultRetries</body><body package="NetClientBase">defaultTimeout	^self class defaultTimeout</body><body package="NetClientBase">protocolInterpreterClass	^self class defaultProtocolInterpreterClass</body></methods><methods><class-id>Net.NetClient</class-id> <category>initialize-release</category><body package="NetClientBase">configureFrom: aHostSpec	self user: aHostSpec user;		hostName: aHostSpec name;		portNumber: aHostSpec port.	aHostSpec isSecure ifTrue: [ self useSecureConnection ].</body><body package="NetClientBase">initialize	clientPI := self protocolInterpreterClass new .</body><body package="NetClientBase">onNetConnection:  aNetConnection	self clientPI connection: aNetConnection</body><body package="NetClientBase">useDefaultConnection	self clientPI useDefaultConnection</body></methods><methods><class-id>Net.NetClient</class-id> <category>connection management</category><body package="NetClientBase">close	"client sign off and disconnect"	self disconnect</body><body package="NetClientBase">connect	"Establish a connection to the host"	^self clientPI 			connectToHost: self hostName 			port: self portNumber 			timeout: self timeout.</body><body package="NetClientBase">connectIfClosed	self isConnected not		ifTrue: [self connect ]</body><body package="NetClientBase">connectToHost: aString	"Establish a connection to the host &lt;aString&gt;."	self hostName: aString.	self connect.</body><body package="NetClientBase">connectToHost: aString port: aNumber 	"Establish a connection to the host &lt;aString&gt;."	self portNumber: aNumber.	self connectToHost: aString</body><body package="NetClientBase">disconnect	"Disconnect from the host"	self clientPI disconnect.</body><body package="NetClientBase">isConnected	^self clientPI isConnected</body><body package="NetClientBase">login</body><body package="NetClientBase">loginAsUser: userString withPassword: passwdString "Login to the host using the specified user name &lt;aString&gt;  and password&lt;aString&gt;"	user := NetUser username: userString password: passwdString.	self loginToHost</body><body package="NetClientBase">loginToHost"Login to the host"	self login</body><body package="NetClientBase">loginToHost: aHostName asUser: userString withPassword: passwdString "Connect and login to the host &lt;aString&gt;  using the specified user name&lt;aString&gt; and password&lt;aString&gt;"	self connectToHost: aHostName.	self	loginAsUser: userString withPassword: passwdString.</body><body package="NetClientBase">loginToHost: aHostName port: aNumber asUser: userString withPassword: passwdString "Connect and login to the host &lt;aString&gt;  using the specified user name&lt;aString&gt; and password&lt;aString&gt;"	self connectToHost: aHostName port: aNumber.	self loginAsUser: userString withPassword: passwdString.</body><body package="NetClientBase">reconnect	"Reconnect to the host"	self disconnect.	self connect.</body></methods><methods><class-id>Net.NetClient class</class-id> <category>instance creation</category><body package="NetClientBase">connectToHost: aHostname "Create NetClient object, establish a connection to the host &lt;aString&gt;"	^self new connectToHost: aHostname</body><body package="NetClientBase">connectToHost: aHostname port: aPort"Create NetClient object, establish a connection to the host &lt;aString&gt; and port &lt;aString&gt;"	^self new connectToHost: aHostname port: aPort</body><body package="NetClientBase">host: aHostname"Create NetClient object, set up the host &lt;aString&gt;"	^self new 		hostName: aHostname; 		yourself</body><body package="NetClientBase">host: aHostname port: aPort "Create NetClient object, set up the host &lt;aString&gt; and port &lt;aString&gt;"	^self new		hostName: aHostname; 		portNumber: aPort; 		yourself</body><body package="NetClientBase">loginToHost: aHostName asUser: userString withPassword: passwdString "Create NetClient object, connect and login to the host &lt;aString&gt;  using the specified user name&lt;aString&gt;&amp;  password&lt;aString&gt; "	^self new		loginToHost: aHostName		asUser: userString 		withPassword: passwdString</body><body package="NetClientBase">loginToHost: aHostName port: aNumber asUser: userString withPassword: passwdString "Create NetClient object, connect and login to the host &lt;aString&gt;  using the specified user name&lt;aString&gt;,  password&lt;aString&gt; &amp; port &lt;aNumber&gt;"	^self new		loginToHost: aHostName 		port: aNumber 		asUser: userString 		withPassword: passwdString</body><body package="NetClientBase">new	^super new initialize</body><body package="NetClientBase">onNetConnection: aNetConnection	^self new		onNetConnection: aNetConnection;		yourself</body></methods><methods><class-id>Net.NetClient class</class-id> <category>defaults</category><body package="NetClientBase">defaultDelaySeconds	^self settings defaultDelaySeconds</body><body package="NetClientBase">defaultDelaySeconds: aNumber	self settings defaultDelaySeconds: aNumber</body><body package="NetClientBase">defaultIncomingMailClient	DefaultIncomingMailClient isNil		ifTrue: [ self newDefaultIncomingMailClient ].	^DefaultIncomingMailClient</body><body package="NetClientBase">defaultIncomingMailClient: aMailClient	DefaultIncomingMailClient := aMailClient</body><body package="NetClientBase">defaultOutgoingMailClient	DefaultOutgoingMailClient isNil		ifTrue: [ self newDefaultOutgoingMailClient ].	^DefaultOutgoingMailClient</body><body package="NetClientBase">defaultOutgoingMailClient: aMailClient	DefaultOutgoingMailClient := aMailClient</body><body package="NetClientBase">defaultPortNumber	^self subclassResponsibility</body><body package="NetClientBase">defaultProtocolInterpreterClass	^defaultProtocolInterpreterClass ifNil: [defaultProtocolInterpreterClass := self defaultProtocolInterpreterClassValue]</body><body package="NetClientBase">defaultProtocolInterpreterClass: aClass	defaultProtocolInterpreterClass := aClass</body><body package="NetClientBase">defaultRetries	^self settings defaultRetries</body><body package="NetClientBase">defaultRetries: aNumber	self settings defaultRetries: aNumber</body><body package="NetClientBase">defaultTimeout	^self settings defaultTimeout</body><body package="NetClientBase">defaultTimeout: aNumber	self settings defaultTimeout: aNumber</body></methods><methods><class-id>Net.NetClient class</class-id> <category>reset defaults</category><body package="NetClientBase">resetDefaultIncomingMailClient	DefaultIncomingMailClient := nil.</body><body package="NetClientBase">resetDefaultOutgoingMailClient	DefaultOutgoingMailClient := nil.</body><body package="NetClientBase">resetDefaults	self 		resetDefaultIncomingMailClient;		resetDefaultOutgoingMailClient.</body></methods><methods><class-id>Net.NetClient class</class-id> <category>testing</category><body package="NetClientBase">isIncomingMailClient	^false</body><body package="NetClientBase">isMailClient	^false</body></methods><methods><class-id>Net.NetClient class</class-id> <category>registry</category><body package="NetClientBase">mailRegistry	^MailRegistry isNil		ifTrue: [ MailRegistry := IdentityDictionary new]		ifFalse: [ MailRegistry ]</body><body package="NetClientBase">netSettings	^Settings</body><body package="NetClientBase">registerClass</body><body package="NetClientBase">registerClass: aClass	self mailRegistry at: aClass serverType put: aClass name</body></methods><methods><class-id>Net.NetClient class</class-id> <category>private</category><body package="NetClientBase">loadParcelDialog: aText host: host	 ^Dialog warn: ((#SupportParcelShouldBeLoaded &lt;&lt; #net &gt;&gt; 'To create &lt;1s&gt; &lt;n&gt;&lt;2s&gt;Support parcel should be loaded!')			expandMacrosWith: aText			with: host type)</body><body package="NetClientBase">newDefaultIncomingMailClient	| client  host |	(host := self netSettings defaultIncomingHost ) notNil		ifTrue: 			[  ( client := self mailRegistry at: host type asSymbol ifAbsent: [nil]) isNil				ifTrue: [ self loadParcelDialog: (#defaultIncomingMailClient &lt;&lt; #net &gt;&gt; 'default incoming mail client') host: host]				ifFalse: 					[ DefaultIncomingMailClient := (LiteralBindingReference pathString: 'Net.',client) value new												hostName: host name;												portNumber: host port;												user: host netUser;												yourself.					host isSecure ifTrue: [ DefaultIncomingMailClient useSecureConnection]											]]		ifFalse: [ self updateSettingsDialog: (#defaultIncomingMailServer &lt;&lt; #net &gt;&gt; 'default incoming mail server')]</body><body package="NetClientBase">newDefaultOutgoingMailClient	| client  host |	(host := self netSettings defaultOutgoingHost) ifNil: [		self updateSettingsDialog: (#defaultOutgoingMailServer &lt;&lt; #net &gt;&gt; 'default outgoing mail server').		^self ].	(client := self mailRegistry at: host type asSymbol ifAbsent: [nil]) ifNil: [		self loadParcelDialog: (#defaultOutgoingMailClient &lt;&lt; #net &gt;&gt; 'default outgoing mail client') host: host.		^self ].	client := (LiteralBindingReference pathString: 'Net.',client) value new.	client hostName: host name; portNumber: host port.	host netUser		ifNil: [ client useAuthentication: false ]		ifNotNil: [ client user: host netUser ].	DefaultOutgoingMailClient := client</body><body package="NetClientBase">update: anAspect with: arguments from: anObject	anAspect == #changedDefaultOutgoingServer		ifTrue: [self resetDefaultOutgoingMailClient].	anAspect == #changedDefaultIncomingServer		ifTrue: [self resetDefaultIncomingMailClient].	anAspect == #returnFromSnapshot 		ifTrue: [self resetDefaults ].</body><body package="NetClientBase">updateSettingsDialog: aText	 ^Dialog warn: ((#YouNeedToUpdateNetworkSetting &lt;&lt; #net &gt;&gt; 'You need to update Tools-%&gt;Network Setting.. for &lt;1s&gt;')			expandMacrosWith: aText)</body></methods><methods><class-id>Net.NetClient class</class-id> <category>class initialization</category><body package="NetClientBase">initialize	"self initialize"	self registerClass.</body><body package="NetClientBase">obsolete	"Break dependencies"	[self netSettings dependents includes: self] whileTrue:		[self netSettings removeDependent: self].	^super obsolete</body></methods><methods><class-id>Net.NetClient class</class-id> <category>constants</category><body package="NetClientBase">description	^''</body><body package="NetClientBase">serverType</body></methods><methods><class-id>Net.NetClient class</class-id> <category>default values</category><body package="NetClientBase">defaultProtocolInterpreterClassValue	^NetProtocolInterpreter</body></methods><methods><class-id>Net.NetClient class</class-id> <category>accessing</category><body package="NetClientBase">settings	^self defaultProtocolInterpreterClass settings</body></methods><methods><class-id>Net.NetUser</class-id> <category>accessing</category><body package="NetClientBase">account	^account</body><body package="NetClientBase">account: aString	account := aString</body><body package="NetClientBase">asText	^self fullName</body><body package="NetClientBase">fullName	^fullName</body><body package="NetClientBase">fullName: aString	fullName := aString</body><body package="NetClientBase">mailAddress	^mailAddress</body><body package="NetClientBase">mailAddress: aString	mailAddress := aString</body><body package="NetClientBase">name	^self username</body><body package="NetClientBase">password	^password</body><body package="NetClientBase">password: aString 	password := aString</body><body package="NetClientBase">username	^username</body><body package="NetClientBase">username: aString 	username := aString</body></methods><methods><class-id>Net.NetUser</class-id> <category>printing</category><body package="NetClientBase">asString	| stream |	stream := (String new: 64) writeStream.	self printOn: stream.	^stream contents</body><body package="NetClientBase">printDefaultOn: aStream 	aStream nextPutAll: (#Default &lt;&lt; #net &gt;&gt; ' (Default) ') asString</body><body package="NetClientBase">printMailAddressOn: aStream 	self mailAddress notNil			ifTrue: [  aStream nextPutAll: '  &lt;', self mailAddress, '&gt;'].</body><body package="NetClientBase">printNameOn: aStream 	self fullName notNil		ifTrue: [ aStream nextPutAll: self fullName]		ifFalse: 			[ aStream nextPutAll: self class name asString.			username notNil 				ifTrue: 					[aStream space; 						nextPutAll: username; 						nextPutAll: (#PasswordConcealed &lt;&lt; #net &gt;&gt; ' password (concealed)') asString]].</body><body package="NetClientBase">printOn: aStream 	self printNameOn: aStream.	self isDefaultIdentity ifTrue: [	self printDefaultOn: aStream ].	self printMailAddressOn: aStream</body><body package="NetClientBase">specFrom: aDict	aDict keysAndValuesDo:		[ :key :value |			self instVarAt: ( self class instVarIndexFor: key) put: (Compiler evaluate: value readStream)]</body><body package="NetClientBase">specString	| stream value |	stream := (String new: 128) writeStream.	self class instVarNames 		do: [ :ins | 			(value := self instVarAt: ( self class instVarIndexFor: ins)) notNil 				ifTrue: 					[stream nextPutAll:  ins, ' = ', value printString; cr]].	^stream contents.</body></methods><methods><class-id>Net.NetUser</class-id> <category>testing</category><body package="NetClientBase">isDefaultIdentity	^Settings isDefaultIdentity: self</body><body package="NetClientBase">isHttpUser	^false</body></methods><methods><class-id>Net.NetUser</class-id> <category>comparing</category><body package="NetClientBase">= aNetUser	aNetUser ifNil: [^false].	^self  fullName = aNetUser fullName		and: [self username = aNetUser username			and: [self mailAddress = aNetUser mailAddress 				and: [self account = aNetUser account ]]]</body><body package="NetClientBase">hash	^self fullName hash	bitXor: ( self username hash	bitXor: ( self mailAddress hash ) )</body></methods><methods><class-id>Net.NetUser</class-id> <category>update</category><body package="NetClientBase">updateBy: aNetUser	self  fullName: aNetUser fullName;		username: aNetUser username;		account: aNetUser account;		password: aNetUser password;		mailAddress: aNetUser mailAddress.</body></methods><methods><class-id>Net.NetUser class</class-id> <category>accessing</category><body package="NetClientBase">lastUser	^LastUser</body></methods><methods><class-id>Net.NetUser class</class-id> <category>instance creation</category><body package="NetClientBase">request	"NetUser request"	| username password cancel |	username := (LastUser isNil					ifTrue: ['']					ifFalse: [LastUser]) asValue.	password := '' asValue.	cancel := (SimpleDialog initializedFor: nil)				setInitialGap;				addMessage: (#Username &lt;&lt; #net &gt;&gt; 'Username') textLine: username boundary: 0.4;				addGap;				addMessage: (#Password &lt;&lt; #net &gt;&gt; 'Password') textLine: password type: #password boundary: 0.4;				addGap;				addOK: [true];				openDialog;				cancel.	username value isEmpty ifFalse:		[LastUser := username value].	cancel value ifTrue: [^nil].	^self new 		username: username value; 		password: password value;		yourself</body><body package="NetClientBase">request: label	"NetUser request: ('Login to &lt;1s&gt; server &lt;2s&gt;' expandMacrosWith: 'POP3' with: 'sulu.cincom.com')"	| username password cancel |	username := (LastUser isNil					ifTrue: ['']					ifFalse: [LastUser]) asValue.	password := '' asValue.	cancel := (SimpleDialog initializedFor: nil)				setInitialGap;				addMessage: label centered: true;				addGap;				addMessage: (#Username &lt;&lt; #net &gt;&gt; 'Username') textLine: username boundary: 0.4;				addGap;				addMessage: (#Password &lt;&lt; #net &gt;&gt; 'Password') textLine: password type: #password boundary: 0.4;				addGap;				addOK: [true];				openDialog;				cancel.	username value isEmpty ifFalse:		[LastUser := username value].	cancel value ifTrue: [^nil].	^self new 		username: username value; 		password: password value;		yourself</body><body package="NetClientBase">username: aUsername password: aPassword	"PopUser username: 'foo' password: 'foo'"	|user|	user := self new.	LastUser := aUsername.	^user 		fullName: aUsername;		username: aUsername;		password: aPassword;		yourself</body></methods><methods><class-id>Net.INIScanner</class-id> <category>tokenization</category><body package="NetClientBase">nextNVPair	| pos key |	self skipComments.	pos := self position.	key := self nextToken.	key notNil ifTrue: [		self skipWhiteSpace.		(self peekFor: $= )			ifTrue: [ 	^ key -&gt; (self skipWhiteSpace; nextLine) trimBlanks ].		self position: pos.		self warnOnSkippedLine ].	^ nil.</body><body package="NetClientBase">nextSection	| key |	(key := self nextSectionHeader) notNil 		ifTrue: [ ^ key -&gt; self scanSectionBody ].	^ nil.</body><body package="NetClientBase">nextSectionHeader	"Section headers must start at the beginning of the line."	[self atEnd not and: [self peek ~~ $[]]		whileTrue: [ self nextLine ].	self atEnd ifTrue: [		tokenType := #doIt.		^ token := nil ].	token := self 		scanToken: [ self matchCharacterType: TokenMask ] 		delimitedBy: '[]' 		notify: (#errMalformedSectionHeader &lt;&lt; #dialogs &gt;&gt; 'Malformed section header').	self nextLine.	^ token.</body><body package="NetClientBase">nextToken	^self nextIniToken</body><body package="NetClientBase">scanSectionBody	"Answer a Dictionary containing the section's key/value pairs.	 Empty value is allowed.	 No protection against duplicate keys - last entry in stream is installed."	| section nv |	section := Dictionary new.	[self skipComments.	self atEnd not and: [self peek ~~ $[]]		whileTrue: [ 			(nv := self nextNVPair) notNil 				ifTrue: [section add: nv].			self skipComments ].	^ section.</body><body package="NetClientBase">scanToken	" token  =  1*&lt;any CHAR except $[, $], $=, SPACE and CTLs&gt;. "	token := self scanTokenMask: TokenMask.	tokenType := #token.	^token</body><body package="NetClientBase">sectionNamed: aString	| name |	[ name := self nextSectionHeader.	name notNil and: [name asLowercase ~= (aString asLowercase)] ] whileTrue.	^ self scanSectionBody.</body><body package="NetClientBase">skipComments	self skipWhiteSpace.	[CommentChars includes: self peek] 		whileTrue: [self nextLine].</body><body package="NetClientBase">tokenizeAsDictionary	| ini section |	ini := Dictionary new.	[ self atEnd ] 		whileFalse: [			(section := self nextSection) notNil ifTrue: [ ini add: section ] ].	^ ini.</body><body package="NetClientBase">warnOnSkippedLine	^ScannedLineSkipped signalWith: ((#ScannedLine1sSkipped &lt;&lt; #net &gt;&gt; 'Scanned line ''&lt;1s&gt;'' skipped.')			expandMacrosWith: self nextLine).</body></methods><methods><class-id>Net.INIScanner</class-id> <category>private</category><body package="NetClientBase">nextIniToken	| char |	self skipWhiteSpace.	char := self peek.	char isNil		"end of input"		ifTrue: [ 	tokenType := #doIt.			^ token := nil].	token := self scanToken.	" Tokens must be arranged in name = value pairs.		where value is allowed to be empty. "	token isEmpty		ifTrue: [ 	tokenType := #none.			^ token := nil].	^ token.</body></methods><methods><class-id>Net.INIScanner class</class-id> <category>class initialization</category><body package="NetClientBase">initClassificationTable      super initClassificationTable.       self initClassificationTableWith: TokenMask when:           [:c | c &gt; Character space and: [ ('[]=' includes: c) not ] ].       self initClassificationTableWith: EndOfLineMask when:           [:c | c == Character cr or: [ c == Character lf ] ].</body><body package="NetClientBase">initialize	"INIScanner initialize"	self initializeConstants; initClassificationTable</body><body package="NetClientBase">initializeConstants	TokenMask := 16384.</body></methods><methods><class-id>Net.NonASCIICharacter class</class-id> <category>testing</category><body package="NetClientBase">mayResume	^true</body></methods><methods><class-id>Net.NetPISettings</class-id> <category>accessing</category><body package="NetClientBase">delaySeconds	delaySeconds isNil ifTrue: [ delaySeconds := self defaultDelaySeconds].	^ delaySeconds</body><body package="NetClientBase">delaySeconds: aNumber	delaySeconds := aNumber</body><body package="NetClientBase">retries	retries isNil ifTrue: [retries := self defaultRetries].	^retries</body><body package="NetClientBase">retries: aNumber	retries := aNumber</body><body package="NetClientBase">timeout	timeout isNil ifTrue: [ timeout := self defaultTimeout].	^timeout</body><body package="NetClientBase">timeout: numberOfMilliseconds	timeout := numberOfMilliseconds</body></methods><methods><class-id>Net.NetPISettings</class-id> <category>defaults</category><body package="NetClientBase">defaultDelaySeconds	^self class defaultDelaySeconds</body><body package="NetClientBase">defaultRetries	^self class defaultRetries</body><body package="NetClientBase">defaultTimeout	^self class defaultTimeout</body></methods><methods><class-id>Net.NetPISettings class</class-id> <category>defaults</category><body package="NetClientBase">defaultDelaySeconds	^defaultDelaySeconds isNil		ifTrue: [ defaultDelaySeconds := self defaultDelaySecondsValue ]		ifFalse: [ defaultDelaySeconds ]</body><body package="NetClientBase">defaultDelaySeconds: aNumber	defaultDelaySeconds := aNumber</body><body package="NetClientBase">defaultRetries	^defaultRetries isNil		ifTrue: [ defaultRetries := self defaultRetriesValue]		ifFalse: [ defaultRetries ]</body><body package="NetClientBase">defaultRetries: aNumber	defaultRetries := aNumber</body><body package="NetClientBase">defaultTimeout	^defaultTimeout isNil		ifTrue: [ defaultTimeout := self defaultTimeoutValue ]		ifFalse: [ defaultTimeout ]</body><body package="NetClientBase">defaultTimeout: aNumber	defaultTimeout := aNumber</body></methods><methods><class-id>Net.NetPISettings class</class-id> <category>default values</category><body package="NetClientBase">defaultDelaySecondsValue	^10</body><body package="NetClientBase">defaultRetriesValue	^5</body><body package="NetClientBase">defaultTimeoutValue	^20000</body></methods><methods><class-id>Net.ReplaceUnsupportedCharacters</class-id> <category>errors</category><body package="NetClientBase">noEncodingFor: aCharacter in: aStream 	| ch |	ch := UnsupportedCharacterReplacement newException				parameter: aCharacter;				raiseRequest.	aStream nextPut: ch asInteger.	^ch</body></methods><methods><class-id>Core.InternalStream</class-id> <category>accessing</category><body package="NetClientBase">asEncodedStreamWithEncoding: aSymbol lineEndConvention: aNumber 	| stream |	stream := self.	stream isCharacterStream	ifTrue: [		stream := Protocols.DecodedStream on: stream encodedBy:  (StreamEncoder new: aSymbol).		stream lineEndConvention: aNumber.		stream encoder errorPolicy: Net.ReplaceUnsupportedCharacters new].	stream := EncodedStream on: stream encodedBy: (StreamEncoder new: aSymbol).	stream lineEndConvention: aNumber.	stream encoder errorPolicy: Net.ReplaceUnsupportedCharacters new.	^stream</body></methods><methods><class-id>Core.InternalStream</class-id> <category>Mime -- testing</category><body package="NetClientBase">isByteStream	^self isCharacterStream not</body><body package="NetClientBase">isCharacterStream	^collection class inheritsFrom: CharacterArray</body><body package="NetClientBase">isInternal	^true</body></methods><methods><class-id>Core.EncodedStream</class-id> <category>net extensions</category><body package="NetClientBase">from: start to: end	^self newSize: end - start startingAt: start</body><body package="NetClientBase">isByteStream	^self isBinary</body><body package="NetClientBase">isCharacterStream	^self isByteStream not</body></methods><methods><class-id>Core.EncodedStream</class-id> <category>testing</category><body package="NetClientBase">isSegmented	^stream isSegmented</body></methods><methods><class-id>Core.EncodedStream</class-id> <category>net extensions</category><body package="NetClientBase">newSize: anInteger 	^self newSize: anInteger startingAt: self position</body><body package="NetClientBase">newSize: anInteger startingAt: offset	^(self class		on: (stream newSize: anInteger startingAt: offset)		encodedBy: (StreamEncoder new: encoder encoding)	)	lineEndConvention: lineEndConvention;		setBinary: self isBinary;		policy: policy; "hope it's ok to share that"		yourself</body></methods><methods><class-id>Core.PositionableStream</class-id> <category>Mime -- stream segments</category><body package="NetClientBase">from: start to: end	^self newSize: end - start startingAt: start</body><body package="NetClientBase">newSize: anInteger 	^self newSize: anInteger startingAt: self position</body><body package="NetClientBase">newSize: anInteger startingAt: offset	^Net.StreamSegment on: self offset: offset size: anInteger</body></methods><methods><class-id>Core.Stream</class-id> <category>accessing</category><body package="NetClientBase">asEncodedStreamWithEncoding: aSymbol lineEndConvention: aNumber"This is here so that it doesn't have to be duplicated between EncodedStream and ExternalStream"	| stream isBinary |	(self lineEndConvention = aNumber and: [		(StreamEncoder new: aSymbol) encoding = self encoding ]) ifTrue: [^self].	"If the arguments don't match the receiver we need an adaptation layer"	isBinary := self isBinary.	self text.	"decoded stream needs characters"	stream := Protocols.DecodedStream on: self encodedBy:  (StreamEncoder new: aSymbol).	stream lineEndConvention: aNumber.	stream encoder errorPolicy: Net.ReplaceUnsupportedCharacters new.	stream := EncodedStream on: stream encodedBy: (StreamEncoder new: aSymbol).	stream lineEndConvention: aNumber.	stream encoder errorPolicy: Net.ReplaceUnsupportedCharacters new.	stream setBinary: isBinary.	^stream</body></methods><methods><class-id>Core.Stream</class-id> <category>Mime -- stream segments</category><body package="NetClientBase">asStream	^self</body></methods><methods><class-id>Core.Stream</class-id> <category>Mime -- testing</category><body package="NetClientBase">isInternal	^false</body></methods><methods><class-id>Core.Stream</class-id> <category>testing</category><body package="NetClientBase">isSegmented	^false</body></methods><methods><class-id>Core.Stream</class-id> <category>Mime -- enumerating lines</category><body package="NetClientBase">linesDo: aBlock" Enumerate stream line by line "	[self atEnd] 		whileFalse: [aBlock value: self nextLine]</body></methods><methods><class-id>Core.Stream</class-id> <category>accessing</category><body package="NetClientBase">nextLine	^self upTo: Character cr</body></methods><methods><class-id>Core.Text</class-id> <category>accessing</category><body package="NetClientBase">concreteIndexFor: charIndex	^string concreteIndexFor: charIndex</body><body package="NetClientBase">concreteString	^string concreteString</body><body package="NetClientBase">stringEncoding	^string stringEncoding</body></methods><methods><class-id>OS.BufferedExternalStream</class-id> <category>accessing</category><body package="NetClientBase">encoding	^bufferType encoder streamEncodingType</body></methods><methods><class-id>OS.BufferedExternalStream</class-id> <category>character/binary</category><body package="NetClientBase">isByteStream	^self isBinary</body><body package="NetClientBase">isCharacterStream	^self isByteStream not</body></methods><methods><class-id>OS.BufferedExternalStream</class-id> <category>accessing</category><body package="NetClientBase">segmentLineEndSize	^self lineEndConvention = LineEndCRLF ifTrue: [2] ifFalse: [1]</body></methods><initialize><class-id>Net.SimpleScanner</class-id></initialize><initialize><class-id>Net.UTF7StreamEncoder</class-id></initialize><initialize><class-id>Net.MimeTypeDescriptor</class-id></initialize><initialize><class-id>Net.Settings</class-id></initialize><initialize><class-id>Net.NetClient</class-id></initialize><initialize><class-id>Net.INIScanner</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Text</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars>string runs </inst-vars><class-inst-vars></class-inst-vars><imports>			private Graphics.TextConstants.*			</imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>Stream</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private IOConstants.*			</imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>PositionableStream</name><environment>Core</environment><super>Core.PeekableStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>collection position readLimit writeLimit policy </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>BufferedExternalStream</name><environment>OS</environment><super>OS.ExternalStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>lineEndCharacter binary lineEndConvention bufferType ioBuffer ioConnection </inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.IOConstants.*			</imports><category>OS-Streaming</category><attributes><package>OS-Streaming</package></attributes></class><class><name>InternalStream</name><environment>Core</environment><super>Core.PositionableStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>IllegalCharacterStreamErrorPolicy</name><environment>Core</environment><super>Core.StreamErrorPolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>Notification</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>Base64StreamEncoder</name><environment>Protocols</environment><super>Core.StreamEncoder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>index nibble nEncoded </inst-vars><class-inst-vars>sextetMap octetMap </class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>Protocols-Common</package></attributes></class><class><name>EncodedStream</name><environment>Core</environment><super>Core.PeekableStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>binary stream encoder policy lineEndConvention lineEndCharacter skipSize </inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.IOConstants.*			</imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class></st-source>