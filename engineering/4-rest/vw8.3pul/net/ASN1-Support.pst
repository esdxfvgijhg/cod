<?xml version="1.0"?><st-source><!-- Name: ASN1-SupportNotice: Copyright 1999-2015 Cincom Systems, Inc.  All rights reserved.Comment: This package defines basic supporting elements of the ASN.1 framework:	- introduces the notion of Module and the Entities contained in them.	- provides classes that represent values of those standard ASN.1 types that don't have suitable counterparts in Smalltalk class hierarchy, e.g. BitString	- it adds support for global ASN.1 OIDs and maintains a global SMINode tree that associates symbolic description of nodes in the tree with OIDsLIMITATIONS:	- Module exporting/importing is not supported yet	- global Module tagging and extensibility is not supported yetCopyright: Copyright (c) 2004-2005 Cincom Systems, Inc.All Rights ReservedDbIdentifier: bear73DbTrace: 455704DbUsername: tkoganDbVersion: 8.1 - 2DevelopmentPrerequisites: #(#(#any 'Protocols-Common' ''))PackageName: ASN1-SupportParcel: #('ASN1-Support')ParcelName: ASN1-SupportPrerequisiteParcels: #(#('Protocols-Common' ''))PrintStringCache: (8.1 - 2,tkogan)Version: 8.1 - 2Date: 3:07:41 PM April 21, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (apr17.2) of April 21, 2017 on April 21, 2017 at 3:07:41 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>ASN1</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			</imports><category>ASN1</category><attributes><package>ASN1-Support</package></attributes></name-space><comment><name-space-id>ASN1</name-space-id><body>ASN1 is the namespace for constants and classes involved in the implementation of ASN.1 elements, types, parsers, encoders, and decoders.</body></comment><class><name>Asn1Error</name><environment>ASN1</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Support</package></attributes></class><comment><class-id>ASN1.Asn1Error</class-id><body>Asn1Exception is an abstract class.  It is the superclass of all ASN.1-specific exceptions.</body></comment><class><name>SMIConflict</name><environment>ASN1</environment><super>ASN1.Asn1Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Support</package></attributes></class><comment><class-id>ASN1.SMIConflict</class-id><body>An Asn1ExcSMIConflict is raised when in inconsistency is noted during an attempt to update a tree of SMINodes.</body></comment><class><name>Asn1Warning</name><environment>ASN1</environment><super>Core.Warning</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Support</package></attributes></class><comment><class-id>ASN1.Asn1Warning</class-id><body>Abstract superclass of all ASN.1 warnings.</body></comment><class><name>TypeRealizationError</name><environment>ASN1</environment><super>ASN1.Asn1Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Support</package></attributes></class><comment><class-id>ASN1.TypeRealizationError</class-id><body>An Asn1ExcTypeRealization is raised when a constraint or semantic violation is noted in the realization of an Asn1Type as an imported type.</body></comment><class><name>SMINode</name><environment>ASN1</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>children integer oid parent symbol type value </inst-vars><class-inst-vars>root </class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Support</package></attributes></class><comment><class-id>ASN1.SMINode</class-id><body>An SMINode represents a node in a 'structure of manangement information' (SMI) as defined in RFC 1155 (Structure of Management Information) and expanded in RFC 1212 (Concise MIB Definitions).  In the context of an ASN.1 implementation, this class is used to derive the symbolic names associated with ASN.1 OBJECT_IDENTIFIERS.  It has a more extensive use in the implementation of the SNMP protocol, and some of the declared instVars look forward to its use in that context.Instance Variables:	children	&lt;Dictionary&gt;					the children of the SMINode	integer	&lt;Object&gt;						the integer associated with the SMINode	oid		&lt;Asn1OID | UndefinedObject&gt;	the Asn1OID associated with the SMINode	parent	&lt;SMINode | UndefinedObject&gt;	the parent of the SMINode	symbol	&lt;Symbol&gt;						the name associated with the SMINode	type	&lt;Asn1Type | UndefinedObject&gt;	the type of the SMINode's value	value	&lt;Object | UndefinedObject&gt;		the value of the SMINodeClass Instance Variables:	root		&lt;SMINode&gt;						the default root node</body></comment><class><name>SMIInvalidPath</name><environment>ASN1</environment><super>ASN1.Asn1Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Support</package></attributes></class><comment><class-id>ASN1.SMIInvalidPath</class-id><body>An Asn1ExcSMIPathSpecification is raised when an error is detected in the specification of a path in a tree of SMINodes.</body></comment><class><name>Entity</name><environment>ASN1</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>symbol module </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Support</package></attributes></class><comment><class-id>ASN1.Entity</class-id><body>This is an abstract superclass of all ASN.1 entities like types, values, information classes, information objects, etc. All entities have a name and are defined in an ASN.1 module.Instance Variables:	symbol	&lt;Symbol&gt; the name of the type, presumed to be unique	module	&lt;Asn1Module&gt; the module that the type belongs to</body></comment><class><name>Struct</name><environment>ASN1</environment><super>Protocols.Struct</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>encoding </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1-Support</category><attributes><package>ASN1-Support</package></attributes></class><comment><class-id>ASN1.Struct</class-id><body>Instances of this class are used as results of decoding of ASN.1 SEQUENCEs and SETs (unless they are mapped to specific Smalltalk classes). Note that two structs with equal set of elements are equal even if their particular element order doesn't match. This is to support the diverse set of ASN.1 encodings.Instance Variables:	encoding	&lt;Encoding&gt; an ASN.1 encoding of the Struct</body></comment><class><name>Imported</name><environment>ASN1</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Support</package></attributes></class><comment><class-id>ASN1.Imported</class-id><body>Imported is the abstract superclass of those types, native to ASN.1, that have been explicitly imported into VisualWorks because of their special semantics.  Note that the Imported hierarchy is functionally distinct from the Asn1Type hierarchy.  The latter is used to represent those characteristics of foreign types relevant to encoding and decoding.  The classes in the Imported hierarchy, in contrast, may be the end result of decoding, usually have a determinate encoding, and otherwise function like application classes.Instance Variables:	value	&lt;Object&gt;	the Smalltalk object wrapped in the special semantics of the imported type</body></comment><class><name>BitString</name><environment>ASN1</environment><super>ASN1.Imported</super><private>false</private><indexed-type>none</indexed-type><inst-vars>unused </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Support</package></attributes></class><comment><class-id>ASN1.BitString</class-id><body>Asn1BitString is an imported type that implements the ASN.1 semantics for a bit string with a specified number of unused bits.  The inherited 'value' instVar is expected to contain a ByteArray.Instance Variables:	unused	&lt;Integer&gt;	the number of bits considered to be 'unused' in the ByteArray value</body></comment><class><name>ObjectIdentifier</name><environment>ASN1</environment><super>ASN1.Imported</super><private>false</private><indexed-type>none</indexed-type><inst-vars>encoding </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Support</package></attributes></class><comment><class-id>ASN1.ObjectIdentifier</class-id><body>An Asn1OID is the Smalltalk representation of an ASN.1 OBJECT_IDENTIFIER.  ASN.1 OBJECT_IDENTIFIERs are guaranteed to frequently recur in any sustained interoperation, and, in protocols like SNMP, constitute a significant fraction of the marshaling budget.  So, an Asn1OID always retains its original encoding to minimize marshaling time, and its representation is as close as possible to its bare encoding in order to push that minimization.Instance Variables:	encoding				&lt;ByteArray | Asn1Encoding&gt;	the encoding of the OIDShared Variables:	BEREncodingCache		&lt;Dictionary&gt;					the cache of encodings used to optimize marshaling of OIDs</body></comment><class><name>Module</name><environment>ASN1</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name oid definitions exports imports tagging extensibility </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Support</package></attributes></class><comment><class-id>ASN1.Module</class-id><body>A module gathers related type definitions into a single identifiable entity. It also serves as a context within witch the name lookups are performed. A module can import entities from other modules and can itself export its own entities. Modules allow to reuse definitions among different applications.Instance Variables:	name	&lt;Symbol&gt; module name	oid	&lt;Asn1OID&gt; a module can be identified with a globally unique OID	definitions	&lt;Dictionary key: Symbol value: Asn1Type&gt; the contained definitions	exports	&lt;Set of: Asn1Type&gt; exported definitions	imports	&lt;Dictionary key: Symbol value: Asn1Type&gt; imported definitions	tagging	&lt;Symbol&gt; the tagging mode of the module (#explicit | #implicit | #automatic) '	extensibility	&lt;Boolean&gt; is extensibility of constructed types implied ? 'EXTENSIBILITY IMPLIED'</body></comment><class><name>TypeRedefinition</name><environment>ASN1</environment><super>ASN1.Asn1Warning</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Support</package></attributes></class><comment><class-id>ASN1.TypeRedefinition</class-id><body>Raised when and existing type is being redefined</body></comment><class><name>OIDError</name><environment>ASN1</environment><super>ASN1.Asn1Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1-Support</category><attributes><package>ASN1-Support</package></attributes></class><comment><class-id>ASN1.OIDError</class-id><body>Signals errors related to ObjectIdentifiers, i.e conversion errors, invalid OIDs, etc.</body></comment><class><name>SMIUnknownPath</name><environment>ASN1</environment><super>ASN1.Asn1Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Support</package></attributes></class><comment><class-id>ASN1.SMIUnknownPath</class-id><body>An Asn1ExcSMIPathUnknown is raised when a specified path cannot be found in a tree of SMINodes.</body></comment><class><name>Encoding</name><environment>ASN1</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>source headerStart bodyStart bodyStop </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Support</package></attributes></class><comment><class-id>ASN1.Encoding</class-id><body>An Asn1Encoding is used to store the encoding of some decoded element.  Within some 'source' ByteArray' it retains offsets to the beginning of the encoding header (contianing the tag(s) and the length), the beginning of the encoding body, and the end of the encoding body.Instance Variables:	bodyStart	&lt;Integer&gt;		the beginning of the encoding's 'body'	bodyStop	&lt;Integer&gt;		the end of the encoding's 'body'	headerStart	&lt;Integer&gt;		the beginning of the encoding's 'header'	source		&lt;ByteArray&gt;	description of source</body></comment><shared-variable><name>BEREncodingCache</name><environment>ASN1.ObjectIdentifier</environment><private>false</private><constant>false</constant><category>encoding caches</category><initializer>Dictionary new: 1024</initializer><attributes><package>ASN1-Support</package></attributes></shared-variable><shared-variable><name>BitMasksTerminal</name><environment>ASN1</environment><private>false</private><constant>false</constant><category>bit masks</category><attributes><package>ASN1-Support</package></attributes></shared-variable><methods><class-id>ASN1.SMINode</class-id> <category>adding</category><body package="ASN1-Support">addNode: anSMINode	"... answers anSMINode or an exception."	| old |	old := children at: anSMINode integer ifAbsent: [].	^( old == nil )		ifTrue:	[ self privateAddNode: anSMINode ]		ifFalse:	[ self privateReviseNode: old with: anSMINode ]</body><body package="ASN1-Support">addNode: anSMINode atPath: anArray	"... the path should include the 'integer' of the node as its last element."	( anSMINode integer ~~ anArray last )		ifTrue:	[ ^self smiPathAndNodeConflict ].	^self		privateReviseNode: ( self addPath: anArray )		with: anSMINode</body><body package="ASN1-Support">addNodes: aCollection 	aCollection do: [ :x | self addNode: x ]</body><body package="ASN1-Support">addPath: anArray	"... expects an Array of Integers, and instantiates the path, treating the receiver as the root."	"... answers the leaf."	| leaf |	self privateCheckPathSpecification: anArray.	leaf := self.	anArray do: [ :n | leaf := leaf at: n ifAbsent: [ ( SMINode integer: n ) parent: leaf ] ].	^leaf</body><body package="ASN1-Support">atPath: anArray setSymbol: aSymbol 	^( self addPath: anArray ) symbol: aSymbol</body><body package="ASN1-Support">setSymbol: aSymbol atPath: anArray	^( self addPath: anArray ) symbol: aSymbol</body></methods><methods><class-id>ASN1.SMINode</class-id> <category>printing</category><body package="ASN1-Support">printOn: aStream	aStream		nextPutAll: self class name;		nextPut: $(;		nextPut: Character space.	self printStandardFormatOn: aStream.	aStream		nextPut: Character space;		nextPut: $).</body><body package="ASN1-Support">printStandardFormatOn: aStream	"... makes allowances for the evil of a missing 'integer'."	aStream		nextPutAll: ( ( symbol ~~ nil )						ifTrue:	[ symbol asString ]						ifFalse:	[ self class unknownSymbolString ] );		nextPut: Character space;		nextPut: $(;		nextPutAll: ( ( integer ~~ nil )						ifTrue:	[ integer printString ]						ifFalse:	[ self class unknownIntegerString ] );		nextPut: $)</body></methods><methods><class-id>ASN1.SMINode</class-id> <category>class initialization</category><body package="ASN1-Support">decodeFromTriplets: anArray	"... called by the alternative, class-side initialization protocol."	| cc |	self		integer: (anArray at: 1);		symbol: (anArray at: 2).	cc := ( ( anArray at: 3 ) collect: [ :x | self class decodeFromTriplets: x ] ).	( cc isEmpty not ) ifTrue: [ self addNodes: cc ].</body></methods><methods><class-id>ASN1.SMINode</class-id> <category>accessing - derived</category><body package="ASN1-Support">alphabeticSymbol	^( ( symbol ~~ nil )			ifTrue:	[ symbol ]			ifFalse:	[ self class unknownSymbolString asSymbol ] )</body><body package="ASN1-Support">fullAlphabeticSymbol	| oc str |	oc :=  OrderedCollection new: 11.	self ascendWithBlock: [ :x | oc addFirst: x symbolPreferredAsString  ].	str := WriteStream on: ( String new: 64 ).	oc 		do: [ :x | str nextPutAll: x ]		separatedBy: [ str nextPut: $. ].	^str contents asSymbol</body><body package="ASN1-Support">fullAlphabeticSymbolAtPath: anArray	| oc str |	oc :=  OrderedCollection new: anArray size.	self descendPath: anArray withBlock: [ :x | oc add: x symbolPreferredAsString ].	str := WriteStream on: ( String new: 64 ).	oc 		do: [ :x | str nextPutAll: x ]		separatedBy: [ str nextPut: $. ].	^str contents asSymbol</body><body package="ASN1-Support">integerPreferred	^( integer ~~ nil )		ifTrue:	[ integer ]		ifFalse:	[ symbol ]</body><body package="ASN1-Support">nodeSymbol	^( ( symbol ~~ nil )			ifTrue:	[ symbol ]			ifFalse:	[ self class unknownSymbolString asSymbol ] )</body><body package="ASN1-Support">numericSymbol	^( ( symbol ~~ nil )			ifTrue:	[ symbol ]			ifFalse:	[ self class unknownSymbolString asSymbol ] )</body><body package="ASN1-Support">symbolPreferred	^( symbol ~~ nil )		ifTrue:	[ symbol ]		ifFalse:	[ integer ]</body><body package="ASN1-Support">symbolPreferredAsString	^( symbol ~~ nil )		ifTrue:	[ symbol asString ]		ifFalse:	[ integer printString]</body></methods><methods><class-id>ASN1.SMINode</class-id> <category>accessing</category><body package="ASN1-Support">children	^children</body><body package="ASN1-Support">children: aDictionary	children := aDictionary</body><body package="ASN1-Support">integer	^integer</body><body package="ASN1-Support">integer: anInteger	self privateReviseParentKeyFrom: integer to: anInteger.	integer := anInteger.</body><body package="ASN1-Support">oid	^oid</body><body package="ASN1-Support">oid: anAsn1OID	oid := anAsn1OID</body><body package="ASN1-Support">parent	^parent</body><body package="ASN1-Support">parent: anSMINode	( parent ~~ nil )		ifTrue:	[ parent privateRemoveNode: self ].	parent := anSMINode.	( anSMINode ~~ nil )		ifTrue:	[ anSMINode privateAddNode: self ]</body><body package="ASN1-Support">symbol	^symbol</body><body package="ASN1-Support">symbol: aSymbol	| s |	s := ( aSymbol == nil )			ifTrue:	[ nil ]			ifFalse:	[ aSymbol asSymbol ].	self privateReviseParentKeyFrom: symbol to: s.	symbol := s</body><body package="ASN1-Support">type	^type</body><body package="ASN1-Support">type: anObject	type := anObject</body><body package="ASN1-Support">value	^value</body><body package="ASN1-Support">value: anObject	value := anObject</body></methods><methods><class-id>ASN1.SMINode</class-id> <category>private</category><body package="ASN1-Support">privateAddNode: anSMINode	( anSMINode integer ~~ nil )		ifTrue:	[ children at: anSMINode integer put: anSMINode ].	( anSMINode symbol ~~ nil )		ifTrue:	[ children at: anSMINode symbol put: anSMINode ].	^anSMINode</body><body package="ASN1-Support">privateCheckChildren: aDictionary1 againstChildren: aDictionary2	" ... checks size and key membership only."	| k1 k2 |	( aDictionary1 size == aDictionary2 size )		ifFalse:	[ ^self smiChildConflict ].	k1 := aDictionary1 keys.	k2 := aDictionary2 keys.	k1 do: [ :k | ( k2 includes: k ) ifFalse: [ ^self smiChildConflict ] ].	^true</body><body package="ASN1-Support">privateCheckPathSpecification: anArray	anArray do: [ :x | ( x isKindOf: Integer ) ifFalse: [ ^self smiPathSpecification ] ]</body><body package="ASN1-Support">privateRemoveNode: anSMINode	| b1 b2 |	b1 := b2 := false.	children removeKey: anSMINode integer ifAbsent: [ b1 := true ].	children removeKey: anSMINode symbol ifAbsent: [ b2 := true ].	^( b1 &amp; b2 )		ifTrue:	[ self smiPathUnknown ]		ifFalse:	[ anSMINode ]</body><body package="ASN1-Support">privateReplaceNode: anSMINode1 with: anSMINode2	"... dangerous, as it does not preserve the existing node's children."	self privateRemoveNode: anSMINode1.	^self privateAddNode: anSMINode2</body><body package="ASN1-Support">privateReviseNode: anSMINode1 with: anSMINode2	"... preserves the existing node's children, and warns if there is a conflict."	| children1 children2 |	children1 := anSMINode1 children.	children2 := anSMINode2 children.	( children2 isEmpty or: [ self privateCheckChildren: children1 againstChildren: children2 ] )		ifTrue: [ anSMINode2 children: children1 ].	self privateRemoveNode: anSMINode1.	^self privateAddNode: anSMINode2</body><body package="ASN1-Support">privateReviseParentKeyFrom: anIntegerOrSymbol1 to: anIntegerOrSymbol2	"... should handle possible 'nil' values."	( parent ~~ nil )		ifTrue:	[	( anIntegerOrSymbol1 ~~ nil )						ifTrue:	[ parent children removeKey: anIntegerOrSymbol1 ifAbsent: [] ].					( anIntegerOrSymbol2 ~~ nil )						ifTrue:	[ parent children at: anIntegerOrSymbol2 put: self ]								]</body></methods><methods><class-id>ASN1.SMINode</class-id> <category>initialize-release</category><body package="ASN1-Support">initialize	children := Dictionary new: 3</body></methods><methods><class-id>ASN1.SMINode</class-id> <category>removing</category><body package="ASN1-Support">removeLeafNodeAtPath: anArray	"... answers an exception or the removed node."	"The Array may contain a mix of Integers and Symbols."	| leaf |	leaf := self.	anArray do: [ :n | leaf := leaf at: n ifAbsent: [ ^self smiPathUnknown  ] ].	leaf parent privateRemoveNode: leaf.	^leaf</body><body package="ASN1-Support">removeNode: anSMINode	^self privateRemoveNode: anSMINode</body></methods><methods><class-id>ASN1.SMINode</class-id> <category>accessing - traversal</category><body package="ASN1-Support">ascendWithBlock: aBlockClosure	( integer ~~ self class rootInteger )		ifTrue:	[	aBlockClosure value: self.					parent ascendWithBlock: aBlockClosure				]</body><body package="ASN1-Support">at: anIntegerOrSymbol	^children		at: anIntegerOrSymbol		ifAbsent: []</body><body package="ASN1-Support">at: anIntegerOrSymbol ifAbsent: aBlockClosure	^children		at: anIntegerOrSymbol		ifAbsent: aBlockClosure</body><body package="ASN1-Support">atAsn1OID: anAsn1OID	^self root atPath: anAsn1OID value</body><body package="ASN1-Support">atPath: anArray	"... expects an Array of Integers."	"... answers the leaf or nil, treating the receiver as the root of the path."	| leaf |	self privateCheckPathSpecification: anArray.	leaf := self.	anArray do: [ :n | leaf := leaf at: n ifAbsent: [ ^nil ] ].	^leaf</body><body package="ASN1-Support">descendPath: anArray withBlock: aBlockClosure	| leaf |	leaf := self.	self privateCheckPathSpecification: anArray.	anArray do: [ :n |	leaf := leaf at: n ifAbsent: [ ^self smiPathUnknown ].						aBlockClosure value: leaf				].</body></methods><methods><class-id>ASN1.SMINode</class-id> <category>accessing - root</category><body package="ASN1-Support">root	"((( SMINode root )))"	^self class root</body></methods><methods><class-id>ASN1.SMINode</class-id> <category>utility</category><body package="ASN1-Support">smiChildConflict	^SMIConflict raiseSignal: (#SMIChildConflict &lt;&lt; #asn1 &gt;&gt; 'There is an existing node with different children.')</body><body package="ASN1-Support">smiPathAndNodeConflict	^SMIConflict raiseSignal: (#SMIPathAndNodeConflict &lt;&lt; #asn1 &gt;&gt; 'The node''s integer index does not match the last element in the path.')</body><body package="ASN1-Support">smiPathSpecification	^SMIInvalidPath raiseSignal: (#SMIPathSpecificationError &lt;&lt; #asn1 &gt;&gt; 'SMI path specifications must contain only Integers.')</body><body package="ASN1-Support">smiPathUnknown	^SMIUnknownPath raiseSignal: (#SMIPathUnknown &lt;&lt; #asn1 &gt;&gt; 'The indicated SMI node was not found.')</body></methods><methods><class-id>ASN1.SMINode class</class-id> <category>instance creation</category><body package="ASN1-Support">integer: anInteger	^self		integer: anInteger		parent: nil		symbol: nil</body><body package="ASN1-Support">integer: anInteger parent: anSMINode	^self		integer: anInteger		parent: anSMINode		symbol: nil</body><body package="ASN1-Support">integer: anInteger parent: anSMINode symbol: aSymbol	^( super new initialize )		integer: anInteger;		parent: anSMINode;		symbol: aSymbol;		yourself</body><body package="ASN1-Support">integer: anInteger symbol: aSymbol	^self		integer: anInteger		parent: nil		symbol: aSymbol</body><body package="ASN1-Support">new	"... a gesture to discourage the creation of SMINodes without a value for 'integer'."	^self shouldNotImplement</body></methods><methods><class-id>ASN1.SMINode class</class-id> <category>class initialization</category><body package="ASN1-Support">decodeFromTriplets: anArray	"... unused."	"... a alternative initalization method."	^( self basicNew initialize )		decodeFromTriplets: anArray</body><body package="ASN1-Support">defaultRootData	"... unused."	"... included to exemplify the alternative initialization strategy."	"... invoked thus:				self root: ( self decodeFromTriplets: self defaultRootData )	"	^Array		with: self rootInteger		with: self rootSymbol		with:		#(	#( 1 #iso				#(	#( 3 #org						#(	#( 6 #dod								#(	#( 1 #internet										#(	#( 1 #directory #() )											#( 2 #mgmt												#(	#( 1 #'mib-2'														#(	#( 1 #system																#(	#( 1 #sysDescr #() )																	#( 2 #sysObjectID #() )																	#( 3 #sysUpTime #() )																	#( 4 #sysContact #() )																	#( 5 #sysName #() )																	#( 6 #sysLocation #() )																	#( 7 #sysServices #() )																)															)															#( 2 #interfaces #() )															#( 3 #at #() )															#( 4 #ip #() )															#( 5 #icmp () )															#( 6 #tcp #() )															#( 7 #udp #() )															#( 8 #egp #() )															#( 11 #snmp #() )														)													)												)											)											#( 3 #experimental #() )											#( 4 #private #() )										)									)								)							)						)					)				)			)			#( 0 #itu #() )			#( 2 #'joint-iso-itu' 				#(	#( 5 #ds						#(	#( 1 #module								#(	#( 7 #authFrame										#(	#( 3 #x509 #() )										)									)								)							)						)					)				)			)		)</body><body package="ASN1-Support">initialize	"((( SMINode initialize )))"	self initializeRoot.</body><body package="ASN1-Support">initializeRoot	SMINode root: ( SMINode integer: self rootInteger symbol: self rootSymbol ).	( SMINode root )		atPath: #( 0 )						setSymbol: 'itu-t';		atPath: #( 0 0 )						setSymbol: 'recommendation';		atPath: #( 0 1 )						setSymbol: 'question';		atPath: #( 0 2 )						setSymbol: 'administration';		atPath: #( 0 3 )						setSymbol: 'network-operator';		atPath: #( 0 4 )						setSymbol: 'identified-organization';		atPath: #( 0 5 )						setSymbol: 'r-recommendation';		atPath: #( 0 9 )						setSymbol: 'data';		atPath: #( 1 )						setSymbol: 'iso';		atPath: #( 1 0 )						setSymbol: 'standard';		atPath: #( 1 1 )						setSymbol: 'registration-authority';		atPath: #( 1 2 )						setSymbol: 'member-body';		atPath: #( 1 3 )						setSymbol: 'identified-organization';		atPath: #( 1 2 840 )					setSymbol: 'us';		atPath: #( 1 3 6 )					setSymbol: 'dod';		atPath: #( 1 3 6 1 )					setSymbol: 'internet';		atPath: #( 1 3 6 1 1 )				setSymbol: 'directory';		atPath: #( 1 3 6 1 2 )				setSymbol: 'mgmt';		atPath: #( 1 3 6 1 3 )				setSymbol: 'experimental';		atPath: #( 1 3 6 1 4 )				setSymbol: 'private';		atPath: #( 1 3 6 1 5 )				setSymbol: 'security';		atPath: #( 1 3 6 1 6 )				setSymbol: 'snmpV2';		atPath: #( 1 3 6 1 7 )				setSymbol: 'mail';		atPath: #( 1 3 6 1 7 )				setSymbol: 'features';		atPath: #( 1 3 6 1 2 1 )				setSymbol: 'mib-2';		atPath: #( 1 3 6 1 2 2 )				setSymbol: 'pib';		atPath: #( 1 3 6 1 2 9 )				setSymbol: 'http';		atPath: #( 1 3 6 1 2 148 )			setSymbol: 'ipMIB';		atPath: #( 1 3 6 1 2 1 1 )				setSymbol: 'system';		atPath: #( 1 3 6 1 2 1 2 )				setSymbol: 'interface';		atPath: #( 1 3 6 1 2 1 3 )				setSymbol: 'at';		atPath: #( 1 3 6 1 2 1 4 )				setSymbol: 'ip';		atPath: #( 1 3 6 1 2 1 5 )				setSymbol: 'icmp';		atPath: #( 1 3 6 1 2 1 6 )				setSymbol: 'tcp';		atPath: #( 1 3 6 1 2 1 7 )				setSymbol: 'udp';		atPath: #( 1 3 6 1 2 1 8 )				setSymbol: 'egp';		atPath: #( 1 3 6 1 2 1 9 )				setSymbol: 'cmot';		atPath: #( 1 3 6 1 2 1 10 )			setSymbol: 'transmission';		atPath: #( 1 3 6 1 2 1 1 1 )			setSymbol: 'sysDescr';		atPath: #( 1 3 6 1 2 1 1 2 )			setSymbol: 'sysObjectID';		atPath: #( 1 3 6 1 2 1 1 3 )			setSymbol: 'sysUpTime';		atPath: #( 1 3 6 1 2 1 1 4 )			setSymbol: 'sysContact';		atPath: #( 1 3 6 1 2 1 1 5 )			setSymbol: 'sysName';		atPath: #( 1 3 6 1 2 1 1 6 )			setSymbol: 'sysLocation';		atPath: #( 1 3 6 1 2 1 1 7 )			setSymbol: 'sysServices';		atPath: #( 1 3 14 )					setSymbol: 'oiw';		atPath: #( 2 )						setSymbol: 'joint-iso-itu-t';		atPath: #( 2 0 )						setSymbol: 'presentations';		atPath: #( 2 1 )						setSymbol: 'asn1';		atPath: #( 2 2 )						setSymbol: 'association-control';		atPath: #( 2 3 )						setSymbol: 'reliable-transfer';		atPath: #( 2 4 )						setSymbol: 'remote-operations';		atPath: #( 2 5 )						setSymbol: 'ds';		atPath: #( 2 5 8 )					setSymbol: 'algorithm';		atPath: #( 2 5 8 1 )					setSymbol: 'encryptionAlgorithm';		atPath: #( 2 5 8 1 1 )				setSymbol: 'rsa';		atPath: #( 2 5 8 2 )					setSymbol: 'hashAlgorithm';		atPath: #( 2 5 8 3 )					setSymbol: 'signatureAlgorithm';		yourself</body><body package="ASN1-Support">initializeRootAlternative	"((( SMINode initializeRootAlternative )))"	self root: ( self decodeFromTriplets: self defaultRootData )</body></methods><methods><class-id>ASN1.SMINode class</class-id> <category>utility</category><body package="ASN1-Support">rootInteger	"Zero is not allowed as the index of a substantive SMI node.  We use it for the root."	^0</body><body package="ASN1-Support">rootSymbol	^#'&lt;root&gt;'</body><body package="ASN1-Support">unknownIntegerString	^'?'</body><body package="ASN1-Support">unknownSymbolString	^'&lt;unknown&gt;'</body></methods><methods><class-id>ASN1.SMINode class</class-id> <category>accessing</category><body package="ASN1-Support">root	"((( SMINode root )))"	^root</body><body package="ASN1-Support">root: anSMINode	root := anSMINode</body></methods><methods><class-id>ASN1.Entity</class-id> <category>accessing</category><body package="ASN1-Support">module	^module</body><body package="ASN1-Support">module: aModule	aModule add: self.	self setModule: aModule.</body><body package="ASN1-Support">name	^self symbol</body><body package="ASN1-Support">name: aSymbol	self symbol: aSymbol</body><body package="ASN1-Support">setModule: aModule	module := aModule</body><body package="ASN1-Support">symbol	^symbol</body><body package="ASN1-Support">symbol: aSymbol	"... do ensure that it will be aSymbol."	symbol := aSymbol ifNotNil: [ :sym | sym asSymbol ]</body></methods><methods><class-id>ASN1.Entity</class-id> <category>testing</category><body package="ASN1-Support">isTypeReference	^false</body></methods><methods><class-id>ASN1.Entity</class-id> <category>private</category><body package="ASN1-Support">typeFrom: aTypeSpec"Turn an acceptable form of type specification into the real type instance.	aTypeSpect &lt;Symbol | Asn1Type&gt;	^&lt;Asn1Type&gt;"	^module		ifNil: [ aTypeSpec isBehavior				ifTrue: [ aTypeSpec new ]				ifFalse: [ aTypeSpec ] ]		ifNotNil: [ module typeFrom: aTypeSpec ]</body></methods><methods><class-id>ASN1.Entity</class-id> <category>comparing</category><body package="ASN1-Support">equals: anObject"Implements 'structural equivalence' in the spirit of 'type compatibility' described in the ASN.1 semantic model (Dubuisson p.121)."	^anObject class == self class</body></methods><methods><class-id>ASN1.Entity class</class-id> <category>instance creation</category><body package="ASN1-Support">name: aSymbol	^self new		name: aSymbol;		yourself</body><body package="ASN1-Support">name: aSymbol in: aModule	^aModule register: (self name: aSymbol)</body><body package="ASN1-Support">symbol: aSymbol	^self name: aSymbol</body><body package="ASN1-Support">symbol: aSymbol in: aModule	^self name: aSymbol in: aModule</body></methods><methods><class-id>ASN1.Struct</class-id> <category>printing</category><body package="ASN1-Support">fullPrintOn: aStream	self fullPrintOn: aStream offset: 1</body><body package="ASN1-Support">fullPrintOn: aStream offset: offset	self printNameOn: aStream.	aStream nextPutAll: ' {'.	self associationsDo: [ :elem |		aStream cr; tab: offset;			nextPutAll: elem key; nextPutAll: ': '.			(elem value respondsTo: #fullPrintOn:offset:)				ifTrue: [ elem value fullPrintOn: aStream offset: offset + 1 ]				ifFalse: [ elem value printOn: aStream ] ].	aStream nextPutAll: ' }'.</body><body package="ASN1-Support">fullPrintString	| aStream |	aStream := WriteStream on: (String new: 16).	self fullPrintOn: aStream offset: 1.	^aStream contents</body><body package="ASN1-Support">printNameOn: aStream	( name notNil ) ifTrue: [ aStream nextPutAll: name; space ]</body><body package="ASN1-Support">printOn: aStream	self shortPrintOn: aStream</body><body package="ASN1-Support">shortPrintOn: aStream	self printNameOn: aStream.	aStream nextPut: ${.	self 	associationsDo: [ :elem |			aStream nextPutAll: elem key; space.				(elem value respondsTo: #shortPrintOn:)					ifTrue: [ elem value shortPrintOn: aStream ]					ifFalse: [ elem value printOn: aStream ] ]		separatedBy: [ aStream nextPutAll: ', ' ].	aStream nextPut: $}.</body></methods><methods><class-id>ASN1.Struct</class-id> <category>comparing</category><body package="ASN1-Support">contentsEquals: aStruct"Anwer true if  the receiver and aStruct contain the same key/values disregarding order."	self structSize == aStruct structSize ifFalse: [ ^false ].	self keysAndValuesDo: [ :key :value |		( aStruct at: key ifAbsent: [ ^false ] ) = value			ifFalse: [ ^false ] ].	^true</body></methods><methods><class-id>ASN1.Struct</class-id> <category>accessing</category><body package="ASN1-Support">_encoding	^encoding</body><body package="ASN1-Support">_encoding: anEncoding	encoding := anEncoding</body><body package="ASN1-Support">accessKeys	| keys |	keys := OrderedCollection new.	1 to: lastIndex do: [ :i | keys add: (self basicAt: i) key ].	^keys</body><body package="ASN1-Support">associations	| oc |	oc := OrderedCollection new.	1 to: lastIndex do: [ :i | oc add: (self basicAt: i) ].	^oc</body></methods><methods><class-id>ASN1.Imported</class-id> <category>comparing</category><body package="ASN1-Support">= anObject	^( anObject class == self class )		and: [ anObject value = self value ]</body><body package="ASN1-Support">hash	^value hash</body></methods><methods><class-id>ASN1.Imported</class-id> <category>accessing</category><body package="ASN1-Support">value	^value</body><body package="ASN1-Support">value: anObject	value := anObject</body></methods><methods><class-id>ASN1.Imported class</class-id> <category>instance creation</category><body package="ASN1-Support">value: anObject	"((( Asn1ImportedTOC value: ( OrderedCollection with: 1 with: 2 ) )))"	^( self new )		value: anObject;		yourself</body></methods><methods><class-id>ASN1.BitString</class-id> <category>accessing</category><body package="ASN1-Support">bitAt: anInteger"Test the value of the bit at given index (1-based indexing).	anInteger &lt;Integer&gt; index of the bit to query, one based	^&lt;Boolean&gt;	true if set, false if clearedNote that within each byte the bits are ordered from the most significant bit to the least significant.So bit (0) of a bit string is actually the most significant bit of the first byte, bit (9) is the most significant bit of second byte, etc.	((self unused: 0 bytes: #[64 1]) bitAt: 8) = false	((self unused: 0 bytes: #[64 1]) bitAt: 2) = true	((self unused: 0 bytes: #[64 1]) bitAt: 16) = true	((self unused: 0 bytes: #[64 1]) bitAt: 9) = false"	| slot mask |	slot := (anInteger - 1 bitShift: -3) + 1.	slot &gt; value size ifTrue: [^false].	mask := 2**(7 - (anInteger - 1 bitAnd: 7)).	^((value at: slot) bitAnd: mask) ~~ 0.</body><body package="ASN1-Support">bitAt: anInteger put: aBoolean"Set the value of the bit at index anInteger (1-based indexing).	anInteger &lt;Integer&gt;	index of the bit to set, one based	aBoolean &lt;Boolean&gt; set to 1 if true, set to 0 if false	^&lt;Boolean&gt;Note that within each byte the bits are ordered from the most significant bit to the least significant.So bit (0) of a bit string is actually the most significant bit of the first byte, bit (9) is the most significant bit of second byte, etc.	(((self unused: 0 bytes: #[64 1] copy) bitAt: 8 put: true; yourself) bitAt: 8) = true	(((self unused: 0 bytes: #[64 1] copy) bitAt: 8 put: true; yourself) bitAt: 7) = false	(((self unused: 0 bytes: #[64 1] copy) bitAt: 8 put: true; yourself) bitAt: 2) = true	(((self unused: 0 bytes: #[65 1] copy) bitAt: 2 put: false; yourself) bitAt: 2) = false	(((self unused: 0 bytes: #[65 1] copy) bitAt: 2 put: false; yourself) bitAt: 8) = true	(((self unused: 0 bytes: #[65 1] copy) bitAt: 2 put: false; yourself) bitAt: 7) = false"	| slot mask bits |	slot := (anInteger - 1 bitShift: -3) + 1.	mask := 2**(7- (anInteger - 1 bitAnd: 7)).	bits := value at: slot.	value at: slot put: (		aBoolean			ifTrue: [bits bitOr: mask]			ifFalse: [bits bitAnd: (255 bitXor: mask)] ).	^aBoolean</body><body package="ASN1-Support">bytes	^value</body><body package="ASN1-Support">bytes: aByteArray	self value: aByteArray</body><body package="ASN1-Support">unused	^unused</body><body package="ASN1-Support">unused: anInteger	unused := anInteger</body></methods><methods><class-id>ASN1.BitString</class-id> <category>comparing</category><body package="ASN1-Support">= anObject	^( anObject class == self class )		and: [ anObject value = self value 			and: [ anObject unused == self unused ] ]</body><body package="ASN1-Support">hash	^( value hash bitShift: 7 ) bitXor: unused hash</body></methods><methods><class-id>ASN1.BitString</class-id> <category>testing</category><body package="ASN1-Support">isEmpty	^( unused == 0 ) and: [ value = #[] ]</body></methods><methods><class-id>ASN1.BitString</class-id> <category>printing</category><body package="ASN1-Support">printOn: aStream	aStream		nextPutAll: self class name;		nextPut: $(;		nextPutAll: value size printString;		nextPut: $/;		nextPutAll: unused printString;		nextPut: $/;		nextPutAll: value first printString;		nextPutAll: '...';		nextPutAll: value last printString;		nextPut: $)</body></methods><methods><class-id>ASN1.BitString class</class-id> <category>instance creation</category><body package="ASN1-Support">empty	^( self new )		unused: 0;		value: #[];		yourself</body><body package="ASN1-Support">unused: anInteger bytes: aByteArray	| n |	n := ( self new )			unused: anInteger;			value: aByteArray;			yourself.	self validate: n.	^n</body></methods><methods><class-id>ASN1.BitString class</class-id> <category>class initialization</category><body package="ASN1-Support">initialize	self initializeASN1BitMasks.</body><body package="ASN1-Support">initializeASN1BitMasks	"((( self initializeASN1BitMasks )))"	ASN1.BitMasksTerminal :=		#(	02r00000000			02r00000001			02r00000011 			02r00000111			02r00001111			02r00011111			02r00111111			02r01111111			02r11111111 )</body></methods><methods><class-id>ASN1.BitString class</class-id> <category>validation</category><body package="ASN1-Support">validate: anAsn1ImportedBitString	"... ensures that 'unused' is in the valid range and that the unused bits are '0', in accord with the stronger, DER requirement.  (BER allows '1's among the unused bits.)"	| uu vu vl mc |	uu := anAsn1ImportedBitString unused.	( ( uu &gt;= 0 ) and: [ uu &lt;= 7 ] )		ifFalse: [ ^TypeRealizationError raiseSignal: (#UnusedBitsError &lt;&lt; #asn1 &gt;&gt; 'The number of unused bits must be between zero and seven!') ].	( ( vu := anAsn1ImportedBitString value ) ~= #[] )		ifTrue:	[	vl := vu last.					mc := vl maskClear: ( ASN1.BitMasksTerminal at: ( uu + 1 ) ).					( vl = mc )						ifFalse:	[ ^TypeRealizationError raiseSignal: (#UnusedBitsMustBeZero &lt;&lt; #asn1 &gt;&gt; 'Unused bits must be zero!') ]				]</body></methods><methods><class-id>ASN1.ObjectIdentifier</class-id> <category>printing</category><body package="ASN1-Support">printIntegersOn: aStream	self value		do: [ :x | aStream nextPutAll: x printString ]		separatedBy: [ aStream nextPut: $. ]</body><body package="ASN1-Support">printOn: aStream	aStream nextPutAll: 'OID:'.	self leafSymbol ifNotNil: [ :sym |		aStream nextPutAll: sym; nextPut: $/ ].	self printIntegersOn: aStream</body></methods><methods><class-id>ASN1.ObjectIdentifier</class-id> <category>accessing</category><body package="ASN1-Support">encoding	^encoding</body><body package="ASN1-Support">encoding: aByteArray	encoding := aByteArray</body></methods><methods><class-id>ASN1.ObjectIdentifier</class-id> <category>other representations</category><body package="ASN1-Support">alphabeticSymbol	^SMINode root fullAlphabeticSymbolAtPath: value.</body><body package="ASN1-Support">leafSymbol	^( SMINode root atAsn1OID: self ) ifNotNil: [ :node | node symbol ]</body><body package="ASN1-Support">numericSymbol	| str |	str := WriteStream on: ( String new: ( value size * 2 ) ).	self printIntegersOn: str.	^str contents asSymbol</body></methods><methods><class-id>ASN1.ObjectIdentifier</class-id> <category>converting</category><body package="ASN1-Support">asAsn1OID	^self</body></methods><methods><class-id>ASN1.ObjectIdentifier class</class-id> <category>class initialization</category><body package="ASN1-Support">initialize	self initializeBEREncodingCache</body><body package="ASN1-Support">initializeBEREncodingCache	BEREncodingCache := Dictionary new: 1024.</body><body package="ASN1-Support">resetBEREncodingCache	"((( Asn1ImportedOID resetBEREncodingCache )))"	self initializeBEREncodingCache</body></methods><methods><class-id>ASN1.ObjectIdentifier class</class-id> <category>instance management</category><body package="ASN1-Support">new	^self shouldNotImplement</body><body package="ASN1-Support">value: integers"Convert an array of integers into an OID. Preserve object identity at creation.	integers &lt;Array of: Integer&gt;	^&lt;ObjectIdentifier&gt;"	(	integers isEmpty or: [		integers anySatisfy: [ :x | x isInteger not or: [ x &lt; 0 ] ] ]	) ifTrue: [ self cannotConvert: integers ].	^( self findOIDValue: integers ) ifNil: [ | oid |		oid := super new value: integers; yourself.		self addOID: oid.		oid ].</body></methods><methods><class-id>ASN1.ObjectIdentifier class</class-id> <category>private</category><body package="ASN1-Support">addOID: anAsn1ImportedOID	BEREncodingCache		at: anAsn1ImportedOID value		put: anAsn1ImportedOID</body><body package="ASN1-Support">berEncodingCache	"((( Asn1ImportedOID berEncodingCache )))"	^BEREncodingCache</body><body package="ASN1-Support">cannotConvert: integers	OIDError		raiseWith: (Array with: integers)		errorPattern:			#Asn1OIDConversionError1p &lt;&lt; #security &gt;&gt;			'&lt;1p&gt; cannot be converted to an OID!'</body><body package="ASN1-Support">findOIDValue: anArray	^BEREncodingCache		at: anArray		ifAbsent: []</body><body package="ASN1-Support">removeOID: anAsn1ImportedOID	BEREncodingCache		removeKey: anAsn1ImportedOID value</body></methods><methods><class-id>ASN1.Module</class-id> <category>accessing</category><body package="ASN1-Support">add: aType	| old |	old := self find: aType symbol ifAbsent: [ nil ].	(old isNil or: [ old isTypeReference ]) ifFalse: [		TypeRedefinition new			messageText: (				#RedefiningType1s2s &lt;&lt; #asn1 &gt;&gt; 'An already existing ASN1 type &lt;1s&gt;.&lt;2s&gt; is being redefined!'					expandMacrosWith: (old module name ifNil: ['nil'])					with: old name);			parameter: aType;			raise ].	aType setModule: self.	old ifNotNil: [ old oneWayBecome: aType ].	^self addToDefinitions: aType</body><body package="ASN1-Support">definitions	^definitions</body><body package="ASN1-Support">exports	^exports</body><body package="ASN1-Support">extensibility	^extensibility</body><body package="ASN1-Support">imports	^imports</body><body package="ASN1-Support">name	^name</body><body package="ASN1-Support">oid	^oid</body><body package="ASN1-Support">remove: aType	self removeFromDefinitions: aType.	aType setModule: nil.	^aType</body><body package="ASN1-Support">tagging	^tagging</body><body package="ASN1-Support">tagging: mode"Set the default tagging mode for the module.	mode &lt;Symbol&gt; one of #explicit, #implicit"	tagging := mode</body></methods><methods><class-id>ASN1.Module</class-id> <category>services</category><body package="ASN1-Support">find: aSymbol ifAbsent: aBlock	^definitions at: aSymbol ifAbsent: aBlock</body><body package="ASN1-Support">register: aType	^self add: aType</body><body package="ASN1-Support">unregister: aType	^self remove: aType</body></methods><methods><class-id>ASN1.Module</class-id> <category>private</category><body package="ASN1-Support">addToDefinitions: aType	^definitions at: aType symbol put: aType</body><body package="ASN1-Support">removeFromDefinitions: aType	^definitions removeKey: aType symbol</body></methods><methods><class-id>ASN1.Module</class-id> <category>initialize-release</category><body package="ASN1-Support">initialize	definitions := Dictionary new.	extensibility := false.	tagging := #explicit</body><body package="ASN1-Support">name: aSymbol	name := aSymbol</body><body package="ASN1-Support">oid: anObject	oid := anObject</body></methods><methods><class-id>ASN1.Module class</class-id> <category>instance creation</category><body package="ASN1-Support">new	^super new initialize</body><body package="ASN1-Support">new: aSymbol	^self new		name: aSymbol</body><body package="ASN1-Support">new: aSymbol oid: anOID	^self new		name: aSymbol;		oid: anOID</body></methods><methods><class-id>ASN1.TypeRedefinition class</class-id> <category>initialize-release</category><body package="ASN1-Support">initialize	notifierString := #TypeRedefinition &lt;&lt; #asn1 &gt;&gt; 'An ASN.1 entity is being redefined!'</body></methods><methods><class-id>ASN1.Encoding</class-id> <category>accessing</category><body package="ASN1-Support">bodyStart	^bodyStart</body><body package="ASN1-Support">bodyStart: anInteger	bodyStart := anInteger</body><body package="ASN1-Support">bodyStop	^bodyStop</body><body package="ASN1-Support">bodyStop: anInteger	bodyStop := anInteger</body><body package="ASN1-Support">headerStart	^headerStart</body><body package="ASN1-Support">headerStart: anInteger	headerStart := anInteger</body><body package="ASN1-Support">source	^source</body><body package="ASN1-Support">source: aByteArray	source := aByteArray</body></methods><methods><class-id>ASN1.Encoding</class-id> <category>printing</category><body package="ASN1-Support">printOn: aStream	aStream		nextPut: $&lt;;		print: headerStart;		nextPut: $(;		print: bodyStart;		nextPut: $);		print: bodyStop;		nextPut: $&gt;</body></methods><methods><class-id>ASN1.Encoding</class-id> <category>api</category><body package="ASN1-Support">bodyEncoding	^source copyFrom: bodyStart to: bodyStop</body><body package="ASN1-Support">fullEncoding	^source copyFrom: headerStart to: bodyStop</body><body package="ASN1-Support">headerEncoding	^source copyFrom: headerStart to: bodyStart - 1</body><body package="ASN1-Support">size	^bodyStop - headerStart + 1</body><body package="ASN1-Support">writeOn: aMarshaler	aMarshaler next: self size putAll: source startingAt: headerStart.</body></methods><methods><class-id>ASN1.Encoding class</class-id> <category>instance creation</category><body package="ASN1-Support">source: aByteArray	^( self basicNew )		source: aByteArray;		yourself</body><body package="ASN1-Support">with: aByteArray	^(self source: aByteArray)		headerStart: 1;		bodyStop: aByteArray size;		yourself</body></methods><methods><class-id>Core.Collection</class-id> <category>printing</category><body package="ASN1-Support">fullPrintOn: aStream offset: offset	| tooMany |	tooMany := aStream position + self maxPrint.	aStream print: self class; nextPutAll: ' ('.	self do: [:element | 				aStream cr; tab: offset.				( aStream position &gt; tooMany )					ifTrue: [ aStream nextPutAll: (#etc &lt;&lt; #dialogs &gt;&gt; '...etc...') asString, ')'. ^self ].				( element respondsTo: #fullPrintOn:offset:)					ifTrue:	[ element fullPrintOn: aStream offset: offset + 1 ]					ifFalse: [ element printOn: aStream ] ]		separatedBy: [ aStream space ].	aStream nextPut: $)</body></methods><methods><class-id>Core.String</class-id> <category>printing</category><body package="ASN1-Support">fullPrintOn: aStream offset: offset	aStream nextPut: $'.	1 to: self size do:		[:i |		(aStream nextPut: (self at: i)) == $' ifTrue: [aStream nextPut: $']].	"embedded quotes get doubled"	aStream nextPut: $'</body></methods><methods><class-id>Core.ByteArray</class-id> <category>printing</category><body package="ASN1-Support">fullPrintOn: aStream offset: offset 	| printSize |	printSize := self size.	printSize &gt; self maxPrintElements		ifTrue: [printSize := self maxPrintElements].	aStream nextPutAll: '#['.	(1 to: printSize)		do: [:index | (self at: index) printOn: aStream]		separatedBy: [aStream space].	printSize &lt; self size ifTrue: [aStream nextPutAll: (#etc &lt;&lt; #dialogs &gt;&gt; '...etc...') asString].	aStream nextPut: $]</body></methods><methods><class-id>Core.Array</class-id> <category>converting</category><body package="ASN1-Support">asAsn1OID"Convert array of integers into an Asn1OID instance.	#(2 5 29 37) asAsn1OID"	^ASN1.ObjectIdentifier value: self</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>converting</category><body package="ASN1-Support">asAsn1OID"Convert dotted OID notation into an Asn1OID instance.	'2.5.29.37' asAsn1OID"	(	self isEmpty or: [		self anySatisfy: [ :c | ('0123456789.' includes: c) not ] ]	) ifTrue: [ ^ASN1.ObjectIdentifier cannotConvert: self ].	^ASN1.ObjectIdentifier		value: (			(self tokensBasedOn: $.) collect: [ :token | Number readFrom: token readStream ]		) asArray</body></methods><initialize><class-id>ASN1.SMINode</class-id></initialize><initialize><class-id>ASN1.BitString</class-id></initialize><initialize><class-id>ASN1.ObjectIdentifier</class-id></initialize><initialize><class-id>ASN1.TypeRedefinition</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Collection</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>Struct</name><environment>Protocols</environment><super>Protocols.ProtoObject</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>name lastIndex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Protocols-Common</category><attributes><package>Protocols-Common</package></attributes></class><class><name>Array</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>ByteArray</name><environment>Core</environment><super>Core.IntegerArray</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>Warning</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>CharacterArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class></st-source>