<?xml version="1.0"?><st-source><!-- Name: URISupportNotice: Copyright 1999-2017 Cincom Systems, Inc.  All rights reserved.Comment: URISupport includes a framework for working with URIs (Uniform Resource Identifiers) and URLs (Universal Resource Locators). The framework provides an easy-to-use mechanism to create URL objects from a String, as well as a simple interface for performing some operations on the URL, such as reading and writing, if permitted by the resource.A URI is a string that represents the address of a piece of information on the Internet. A URL is a type of URI that specifies the protocol type, such as FTP, HTTP, and MailTo. Additional packages may need to be loaded other URL types beyond FILE, for example, FTP, HTTP, HTTPS.The implementation is based on https://url.spec.whatwg.org/Creating a URI:In VisualWorks, a URI is an object that is created by parsing a String specifying the URI. To parse the String, send it an asURI message:'ftp://download.cincom.com/documents/public/some.doc' asURI'ftp://ABC.com/%7Esmith/home.html' encodedStringAsURIor use #fromEncodedString/#fromString methods:OS.URI fromEncodedString: 'http://localhost:9999/a%C4%B1b'OS.URI fromString: 'http://localhost:9999/aıb'The result in this case is an FtpURL object, which was determined from the protocol prefix. If the prefix had been 'http:' the result would be an HttpURL. If the protocol were an unknown type, such as 'MailTo:', the result would be an UnknownURLType.The protocol is determined by reading from the beginning of the string to the colon (FTP). The host is read immediately following the double slash (//) up to the first single slash (download.cincom.com). Everything else is the path, query and fragment.For local files, you can generate a URI from a Filename:	'visual.im' asFilename asURILikewise, file URLs can be turned in to Filenames:	'file:///./visual.im' asURI asFilenameA URI object can be turned back into a String by sending #asString to it.HideSource: falsePackageName: URISupportParcel: #('URI')SaveSource: trueVersion: 8.3 - 2Date: 12:05:13 PM July 28, 2017 --><time-stamp>From VisualWorks®, 8.3 of July 28, 2017 on July 28, 2017 at 12:05:13 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>URI</name><environment>OS</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>encoder </class-inst-vars><imports></imports><category>Net-Resources</category><attributes><package>URISupport</package></attributes></class><comment><class-id>OS.URI</class-id><body>URI represents a Uniform Resource Identifier, which is a standardized string representation of the address of data on the net. These can be broken down into URLs and URNs. In general, an URL specifies an address which specifically names the computer which supplies the resource, and an URN specifies an abstract name which must be resolved to a specific computer name by the client at runtime, but this distinction is not necessarily followed in detail by the various URI types in use.In this framework, only URLs have been implemented, since currently the design and implementation of URNs is in flux, and the infrastructure is not fully developed.Subclasses must implement the following messages:	accessing		asString		resource	stream creation		binaryReadStream		binaryWriteStream		readStreamDo:		writeStreamDo:Subclasses must implement the following class side messages:	accessing		protocol</body></comment><class><name>URL</name><environment>OS</environment><super>OS.URI</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Resources</category><attributes><package>URISupport</package></attributes></class><comment><class-id>OS.URL</class-id><body>URL is a class which represents those URIs that, usually, explicitly or implicitly identify the host computer which supplies the named resource, as opposed to URNs which require the host computer to be resolved at runtime via an unspecified mechanism. However, there have been some URLs developed which do not explicitly identify the server, so that this distinction is not rigid. However, URNs begin with "urn:" and usually use : as the separator between fields, and URLs may or may not begin with "url:", and usually use / to separate fields.</body></comment><class><name>HelpURL</name><environment>OS</environment><super>OS.URL</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>URISupport</package></attributes></class><comment><class-id>OS.HelpURL</class-id><body>HelpURL represents URLs into the Help system. The format is: "topic:id.for.topic".Usage	'topic:vw.inspect.inspectObject' asURI openInstance Variables:	id	&lt;String&gt;		the id of the topic</body></comment><class><name>AboutURI</name><environment>OS</environment><super>OS.URI</super><private>false</private><indexed-type>none</indexed-type><inst-vars>service query </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>URISupport</package></attributes></class><comment><class-id>OS.AboutURI</class-id><body>AboutURI represents an URI with the protocol 'about:', representing a resource provided by a local image service. The protocol is unofficial but is used widely by web browsers.http://en.wikipedia.org/wiki/About_URI_schemeThe about: URI is essentially a services lookup mechanism. The 'data' portion of the URI is handled by the Services shared variable and a developer can add their own unique services to the dictionary by calling AboutURI class&gt;&gt;services. The services can be anything and are not governed by any specification.Instance Variables	query	&lt;String&gt;	The portion of the URI after the ?	service	&lt;String&gt;	The service requestedShared Variables	Services		&lt;Dictionary of: &lt;String&gt; to: &lt;BlockClosure&gt;&gt;	Code to handle returning a resource for a unique about uri</body></comment><class><name>URLwithPath</name><environment>OS</environment><super>OS.URL</super><private>false</private><indexed-type>none</indexed-type><inst-vars>path query fragment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Resources</category><attributes><package>URISupport</package></attributes></class><comment><class-id>OS.URLwithPath</class-id><body>URLwithPath uses the general syntax "protocol://host/path?query#fragment", where path may be composed of multiple segments separated by /, and where the host is usually the DNS name of a computer, but in subclasses such as FtpURL, the host may be more complex. The query and fragment strings are not encoded while writing or decoded while parsing. If the string contains special characters they have to be encoded before setting the query or fragment. Subclasses must implement the following messages:	initialize		parseHost:Instance Variables	fragment	&lt;String&gt;	When the URL contains #, what follows is an address to a specific location within the resource. 	path	&lt;Array of: String&gt;	The components of the path which tells the server where to find the resource	query	&lt;String&gt;	If the URL contains a ?, what follows is the argument for the resource. In this case, the assumption is that the resource is a program of some type, such as a CGI or a database query, and the query part of the URL specifies the arguments.  URI         = scheme ":" hier-part [ "?" query ] [ "#" fragment ]         foo://example.com:8042/over/there?name=ferret#nose         \_/   \______________/\_________/ \_________/ \__/          |           |            |            |        |       scheme     authority       path        query   fragment          |   _____________________|__         / \ /                        \         urn:example:animal:ferret:nosehttp://tools.ietf.org/html/rfc3986#section-3.43.4.  Query   The query component contains non-hierarchical data that, along with   data in the path component (Section 3.3), serves to identify a   resource within the scope of the URI's scheme and naming authority   (if any).  The query component is indicated by the first question   mark ("?") character and terminated by a number sign ("#") character   or by the end of the URI.3.5.  Fragment   The fragment identifier component of a URI allows indirect   identification of a secondary resource by reference to a primary   resource and additional identifying information.  The identified   secondary resource may be some portion or subset of the primary   resource, some view on representations of the primary resource, or   some other resource defined or described by those representations.  A   fragment identifier component is indicated by the presence of a   number sign ("#") character and terminated by the end of the URI.</body></comment><class><name>UriEncodedStreamConstructor</name><environment>OS</environment><super>Core.EncodedStreamConstructor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Resources</category><attributes><package>URISupport</package></attributes></class><comment><class-id>OS.UriEncodedStreamConstructor</class-id><body>This class supports composing the description of a stream (which is named by a URI) with its encoding and any other interesting attributes, then creating the stream.</body></comment><class><name>URLwithAuthority</name><environment>OS</environment><super>OS.URLwithPath</super><private>false</private><indexed-type>none</indexed-type><inst-vars>host port </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Resources</category><attributes><package>URISupport</package></attributes></class><comment><class-id>OS.URLwithAuthority</class-id><body>URLwithAuthority is super class for URL subclasses that are supporting host and port protocol	server        = [ [ userinfo "@" ] hostport ]Subclasses must implement the following messages:	accessing		clientInstance Variables:	host	&lt;String&gt;	 host name	port		&lt;Number&gt;	 port number</body></comment><class><name>UnknownURLType</name><environment>OS</environment><super>OS.URL</super><private>false</private><indexed-type>none</indexed-type><inst-vars>protocol data </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Resources</category><attributes><package>URISupport</package></attributes></class><comment><class-id>OS.UnknownURLType</class-id><body>UnknownURLType is created when there is no URL class matching the protocol of a URI string. It can be manipulated to limited extents but cannot retrieve any data.Instance Variables:	data	&lt;String&gt;	 everything in the URL after the protocol	protocol	&lt;String&gt;	the data transfer protocol name requested</body></comment><class><name>PartialURL</name><environment>OS</environment><super>OS.URLwithPath</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>RelativeURL</category><attributes><package>URISupport</package></attributes></class><comment><class-id>OS.PartialURL</class-id><body>Represents a URL without a protocol part, eg: 'path/file.ext' asURI or 'relativepath/file.ext?query#fragment' asURI. These partial URLs can be combined with other partial URLs or full URLs so long as the URL scheme includes a path (ie: subclasses from URLwithPath).https://url.spec.whatwg.org/#syntax-url-path-relativeA path-relative URL must be zero or more path segments, separated from each other by "/", and not start with "/".Examples:'http://localhost/' asURI, 'images/example.jpg''http://localhost/subdirectory/' asURI, 'myfile.ext'</body></comment><class><name>URLEncoder</name><environment>OS</environment><super>Core.StreamEncoder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>urlSpecials urlEncodedSpecials </inst-vars><class-inst-vars>urlSpecials urlEncodedSpecials </class-inst-vars><imports></imports><category>URISupport</category><attributes><package>URISupport</package></attributes></class><comment><class-id>OS.URLEncoder</class-id><body>This encodes and decodes strings using the W3C url-encoded format. Examples of use are    URLEncoder new encode: 'fee fie ** foe	fum'    (URLEncoder new charset: #'utf-16') encode: 'fee fie ** foe	fum'    URLEncoder new decode: 'fee+fie+%2A%2A+foe%09fum'    (URLEncoder new charset: #'utf-16') decode: 'fee+fie+%2A%00%2A%00+foe%09%00fum'The implementation is quite complicated.</body></comment><class><name>FileURL</name><environment>OS</environment><super>OS.URLwithPath</super><private>false</private><indexed-type>none</indexed-type><inst-vars>missingSlashes host </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Resources</category><attributes><package>URISupport</package></attributes></class><comment><class-id>OS.FileURL</class-id><body>FileURL represents an URL with the protocol 'file:', representing a file on the local hard disk or, rarely, on another computer on the LAN. Accessing the resource is done by converting the URL to a Filename and opening the file.Instance Variables:	host	&lt;String | nil&gt;	File URL syntax ideally is file://host/path. Usually, the host is empty, and the file name starts with three / characters, but (especially on Windows) we support a non-empty host, which translates to file names of the form "\\host\path".	missingSlashes	&lt;Boolean&gt;	true if, when the URL was created, the syntax used was host file syntax, and false if the URL used the portable, platform independent syntax that uses / as the separator.</body></comment><class><name>DataURI</name><environment>OS</environment><super>OS.URI</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mimeType data parameters </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>URISupport</package></attributes></class><comment><class-id>OS.DataURI</class-id><body>DataURI represents an URI with the protocol 'data:', representing a resource provided by a the URI data itself.http://en.wikipedia.org/wiki/Data_URI_schemeA DataURI can return a resource based on its mimeType. For example: 'data:text/plain,Hello World' asURI resource. The MimeTypes shared variable holds on to block closures that handle the mime type resource resolution. If you load ImageReaders, the image/* mime types are mapped to Image objects. A developer can send DataURI class&gt;&gt;mimeTypes to get the dictionary and add their own handler code (or replace the existing handlers) for different mime types.Instance Variables	data		&lt;ByteArray&gt;	binary data	mimeType	&lt;String&gt;	kind of data	parameters	&lt;OrderedCollection of: &lt;String&gt;&gt;	parameters describing the data mediaShared Variables	MimeTypes	&lt;Dictionary of: &lt;String&gt; to: &lt;BlockClosure&gt;&gt;	Dictionary of mime type handlers for returning an object when #resource is called</body></comment><class><name>ComponentNotLoaded</name><environment>OS</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars>defaultValueBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Resources</category><attributes><package>URISupport</package></attributes></class><comment><class-id>OS.ComponentNotLoaded</class-id><body>ComponentNotLoaded exception will be raised when the Http or Ftp url is created and one of the component HTTP or FTP is not loaded.Instance Variables:	defaultValueBlock	&lt;aBlock&gt;	default value block</body></comment><shared-variable><name>Services</name><environment>OS.AboutURI</environment><private>false</private><constant>false</constant><category>accessing</category><attributes><package>URISupport</package></attributes></shared-variable><shared-variable><name>MimeTypes</name><environment>OS.DataURI</environment><private>false</private><constant>false</constant><category>accessing</category><attributes><package>URISupport</package></attributes></shared-variable><shared-variable><name>AutoloadHttps</name><environment>OS.URI</environment><private>false</private><constant>false</constant><category>Autoload</category><initializer></initializer><attributes><package>URISupport</package></attributes></shared-variable><shared-variable><name>ProtocolToClassCache</name><environment>OS.URI</environment><private>false</private><constant>true</constant><category>Optimization</category><initializer>Dictionary new: 5</initializer><attributes><package>URISupport</package></attributes></shared-variable><shared-variable><name>AutoloadHttp</name><environment>OS.URI</environment><private>false</private><constant>false</constant><category>Autoload</category><initializer></initializer><attributes><package>URISupport</package></attributes></shared-variable><shared-variable><name>AutoloadFtp</name><environment>OS.URI</environment><private>false</private><constant>false</constant><category>Autoload</category><initializer></initializer><attributes><package>URISupport</package></attributes></shared-variable><methods><class-id>OS.URI</class-id> <category>comparing</category><body package="URISupport">= aURI"Current implementation considers that two URLs:  '&lt;schema&gt;://example.com/pub'  and  '&lt;schema&gt;://example.com/pub/'  are not equivalent  as they behave differently with respect to: #resolvePath:"	^self class = aURI class		and: [self stringRepresentationPartsMatch: aURI]</body><body package="URISupport">hash	^self asString hash</body><body package="URISupport">sameAs:  aURI	^self = aURI</body><body package="URISupport">stringRepresentationPartsMatch: aURI	"Subclasses should reference all instance variables used by asString,	but without creating new strings to avoid heavy performance penalties"	^self asString = aURI asString</body></methods><methods><class-id>OS.URI</class-id> <category>accessing</category><body package="URISupport">asString	^self subclassResponsibility</body><body package="URISupport">asURI	^self</body><body package="URISupport">protocol	^self class protocol</body><body package="URISupport">protocol: p	"Ignored by those protocols that only go by one name."	^self</body><body package="URISupport">resource	^self subclassResponsibility</body></methods><methods><class-id>OS.URI</class-id> <category>stream creation</category><body package="URISupport">binaryReadStream	"Create a binary readStream on the data that the URI accesses.	Some URIs such as MailTo will not support this."</body><body package="URISupport">binaryWriteStream	"Create a binary readStream on the data that the URI accesses.	Some URIs such as MailTo will not support this."</body><body package="URISupport">readStream	^(self withEncoding: #default) readStream</body><body package="URISupport">readStreamDo: aBlock	"Create a binary readStream on the data that the URI accesses.	Evaluate the block with the stream as the first argument, and with	a Dictionary as the second argument. The Dictionary will describe	any additional information that the protocol can supply about the	resource, such as its file extension (using the key #extension) or	its MIME type (using the key #MIME). This method is responsible	for closing the stream after the block ends, as well as any other	cleanup.	Some URIs such as MailTo will not support this."</body><body package="URISupport">withEncoding: aStreamEncoderName	^UriEncodedStreamConstructor		on: self		encoding: aStreamEncoderName</body><body package="URISupport">writeStream	^(self withEncoding: #default) writeStream</body><body package="URISupport">writeStreamDo: aBlock	"Create a binary writeStream on the data that the URI accesses.	Evaluate the block with the stream as the argument. This method	is responsible for closing the stream after the block ends, as well	as any other cleanup.	Some URIs such as Http or News may not support this."</body></methods><methods><class-id>OS.URI</class-id> <category>private</category><body package="URISupport">copyFromURI: aURI	self writeStreamDo: [:dest |		aURI readStreamDo: [:src :parms |			src binary.			[src atEnd] whileFalse:				[dest nextPutAll: (src nextAvailable: 1024)]]]</body><body package="URISupport">relativePathNotSupportedError	self error: ((#RelativePathsAreNotSupported &lt;&lt; #net &gt;&gt; 'Relative paths are not supported for the "&lt;1s&gt;" protocol') expandMacrosWith: self protocol)</body></methods><methods><class-id>OS.URI</class-id> <category>utilities</category><body package="URISupport">copyTo: aURI	aURI asURI copyFromURI: self</body></methods><methods><class-id>OS.URI</class-id> <category>resolution</category><body package="URISupport">resolveEncodedPath: path	^(path includes: $:)		ifTrue: [URI fromEncodedString:  path]		ifFalse: [self relativePathNotSupportedError]</body><body package="URISupport">resolvePath: path	^(path includes: $:)		ifTrue: [URI fromString: path]		ifFalse: [self relativePathNotSupportedError]</body></methods><methods><class-id>OS.URI</class-id> <category>printing</category><body package="URISupport">printOn: aStream	| str |	str := [self asString] on: Error do: [:ex | ex return: nil].	str == nil		ifTrue: [super printOn: aStream]		ifFalse: [aStream nextPutAll: '&lt;', str, '&gt;'].</body><body package="URISupport">printProtocolOn: aStream"https://url.spec.whatwg.org/#url-serializing"	aStream nextPutAll: self protocol, '://'.</body></methods><methods><class-id>OS.URI</class-id> <category>testing</category><body package="URISupport">isPartial	^false</body></methods><methods><class-id>OS.URI class</class-id> <category>accessing</category><body package="URISupport">allowedChar	^self unreservedChar, ';?:@&amp;=+$,'</body><body package="URISupport">autoloadFtp	^AutoloadFtp isNil		ifTrue: [AutoloadFtp := true]		ifFalse: [ AutoloadFtp ]</body><body package="URISupport">autoloadFtp: aBoolean	AutoloadFtp := aBoolean</body><body package="URISupport">autoloadHttp	^AutoloadHttp isNil		ifTrue: [AutoloadHttp := true]		ifFalse: [ AutoloadHttp ]</body><body package="URISupport">autoloadHttp: aBoolean	AutoloadHttp := aBoolean</body><body package="URISupport">autoloadHttps	^AutoloadHttps isNil		ifTrue: [AutoloadHttps := true]		ifFalse: [ AutoloadHttps ]</body><body package="URISupport">autoloadHttps: aBoolean	AutoloadHttps := aBoolean</body><body package="URISupport">classForProtocol: aProtocol	| prot class res | 	prot := aProtocol asLowercase. 	class := ProtocolToClassCache at: prot ifAbsent: [].	(class ~~ nil and: [class protocol = prot]) ifTrue:		[^class].	self allSubclasses do:		[:cls |		cls protocol = prot ifTrue: [^ProtocolToClassCache at: prot put: cls]].	^(res := self tryToLoad: aProtocol) isNil		ifTrue: [ UnknownURLType ]		ifFalse: [ res ]</body><body package="URISupport">encoder	^encoder ifNil: [ encoder := URLEncoder new 								urlSpecials: self unreservedChar; 								urlEncodedSpecials: self urlEncodedSpecials;								yourself ]</body><body package="URISupport">obsolete	self resetProtocolToClassCache.	super obsolete.</body><body package="URISupport">pathAllowedChars	^self unreservedChar, ':@&amp;=+$,'</body><body package="URISupport">protocol	^self subclassResponsibility</body><body package="URISupport">resetProtocolToClassCache	"(self resetProtocolToClassCache)"	ProtocolToClassCache keys do: [ :k | ProtocolToClassCache removeKey: k].</body><body package="URISupport">unreservedChar" http://www.ietf.org/rfc/rfc3986.txt2.3.  Unreserved Characters   Characters that are allowed in a URI but do not have a reserved   purpose are called unreserved.  These include uppercase and lowercase   letters, decimal digits, hyphen, period, underscore, and tilde.unreserved  = ALPHA / DIGIT / - / . /_ / ~"	^'-._~'</body><body package="URISupport">urlEncodedSpecials" 	Return an empty string telling the encoder do not do any special decoding for any character"	^''</body></methods><methods><class-id>OS.URI class</class-id> <category>instance creation</category><body package="URISupport">fromEncodedString: aString	(self isRelativeReference: aString ) ifTrue:  [^PartialURL fromEncodedString: aString ].	^self 		fromString: aString 		do: [ :cl :data | cl fromEncodedString: data ]</body><body package="URISupport">fromString: aString	"Parse the string in to URI components. Encode components:http://www.ietf.org/rfc/rfc3986.txtWhen a new URI scheme defines a component that represents textual data consisting of characters from the Universal Character Set [UCS],    the data should first be encoded as octets according to the UTF-8 character encoding [STD63]; then only those octets that do not correspond to characters in the unreserved set should be percent-encoded. URI fromString: 'ftp://abc.com:21/~smith/home.html' "	(self isRelativeReference: aString ) ifTrue: [^PartialURL fromString: aString].	^self 		fromString: aString 		do: [ :cl :data | cl fromString: data ]</body></methods><methods><class-id>OS.URI class</class-id> <category>encoding/decoding</category><body package="URISupport">decode: aString 	^self encoder decode: aString</body><body package="URISupport">decode: aString on: stream	^self encoder decode: aString onto: stream</body><body package="URISupport">encode: aString	^self encoder encode: aString</body><body package="URISupport">encode: aString on: stream	^self encoder encode: aString onto: stream</body></methods><methods><class-id>OS.URI class</class-id> <category>private</category><body package="URISupport">fromString: aString do: aBlock	| index protocol data uri |	index := aString indexOf: $:.	protocol := aString copyFrom: 1 to: index-1.	data := aString copyFrom: index+1 to: aString size.	uri := aBlock value: (self classForProtocol: protocol)  value: data.	uri protocol: protocol.	^uri</body><body package="URISupport">isRelativeReference: aString"http://tools.ietf.org/html/rfc3986#section-4.2 relative-ref  = relative-part [ '?' query ] [ '#' fragment ]	"	| iColon iQuery iFragment |	iColon := aString indexOf: $:.	iQuery := aString indexOf: $?.	iFragment := aString indexOf: $#.	^(iColon = 0 		or: [( iQuery &gt; 0 and: [ iColon &gt; iQuery ])			or: [ iFragment &gt; 0 and: [ iColon &gt; iFragment ]]])</body><body package="URISupport">loadNetParcel: aString autoload: aBoolean"FTP, HTTP and HTTPS parcels have to be in the ..\net directory"	(LogicalFilename fromComponents: (Array		with: '$(VISUALWORKS)'		with: 'net'		with: aString, '.pcl')) exists		ifFalse: [^nil ].	^aBoolean		ifTrue: [ self loadParcel: aString ]		ifFalse: 				[ComponentNotLoaded newException					parameter: aString;					defaultValueBlock: [ self loadParcel: aString ];					makeSureResumable;					raiseSignal]</body><body package="URISupport">loadParcel: aString	^[	Parcel ensureLoadedParcel: aString  withVersion:  nil.      	self classForProtocol: aString	] on: Error	do: [ :ex |  ex return: nil ]</body><body package="URISupport">tryToLoad: protocolString	( 'http' match: protocolString)		ifTrue: [ ^self loadNetParcel: 'HTTP' autoload: self autoloadHttp].	( 'https' match: protocolString)		ifTrue: [	^self loadNetParcel: 'HTTPS' autoload: self autoloadHttps].	( 'ftp' match: protocolString)		ifTrue: [ 	^self loadNetParcel: 'FTP' autoload: self autoloadFtp ].	^nil</body></methods><methods><class-id>OS.URL</class-id> <category>printing</category><body package="URISupport">printOn: aStream	| str |	str := [self asString] on: Error do: [:ex | ex return: nil].	str == nil		ifTrue: [super printOn: aStream]		ifFalse: [aStream nextPutAll: '&lt;URL:', str, '&gt;'].</body></methods><methods><class-id>OS.URL class</class-id> <category>accessing</category><body package="URISupport">protocol	^'url'</body></methods><methods><class-id>OS.HelpURL</class-id> <category>accessing</category><body package="URISupport">asString	^'&lt;1s&gt;:&lt;2s&gt;' expandMacrosWith: self class protocol with: id</body><body package="URISupport">open	#{Help.HelpBrowser} bindingOrNil == nil ifTrue: [ 		URI loadParcel: 'Help-UI'].			#{Help.HelpBrowser} ifDefinedDo: [:browser | browser openOnTopicWithID: id]</body><body package="URISupport">resource	self shouldNotImplement</body><body package="URISupport">withID: aString	id := aString</body></methods><methods><class-id>OS.HelpURL class</class-id> <category>accessing</category><body package="URISupport">protocol	^'topic'</body></methods><methods><class-id>OS.HelpURL class</class-id> <category>instance creation</category><body package="URISupport">fromString: aString	^self new withID: aString</body></methods><methods><class-id>OS.AboutURI</class-id> <category>accessing</category><body package="URISupport">asString	^(self protocol, ':', service), (query == nil ifTrue: [''] ifFalse: ['?', query])</body><body package="URISupport">query	^query</body><body package="URISupport">query: anObject	query := anObject</body><body package="URISupport">resource	^(Services at: service) cull: query</body><body package="URISupport">service	^service</body><body package="URISupport">service: anObject	service := anObject</body></methods><methods><class-id>OS.AboutURI class</class-id> <category>accessing</category><body package="URISupport">protocol		^'about'</body><body package="URISupport">services	^Services</body></methods><methods><class-id>OS.AboutURI class</class-id> <category>class initialization</category><body package="URISupport">initialize	"self initialize"	(Services := Dictionary new)		at: '' put: [Services];		at: 'about' put: [Services];		at: 'blank' put: [''];		at: 'version' put: [SystemUtils version];		at: 'asset' put: [:query | self findAsset: query];		at: 'logo' put: [Image cincomSmalltalkLogo]</body></methods><methods><class-id>OS.AboutURI class</class-id> <category>instance creation</category><body package="URISupport">fromEncodedString: aString	^self fromString: aString</body><body package="URISupport">fromString: aString	"Error checking is somewhat minimal at this time."	| index |	index := aString indexOf: $?.	^self new		service: (self decode: (index = 0 ifTrue: [aString] ifFalse: [aString copyFrom: 1 to: index - 1]));		query: (index = 0 ifTrue: [nil] ifFalse: [self decode: (aString copyFrom: index + 1 to: aString size)]);		yourself</body></methods><methods><class-id>OS.AboutURI class</class-id> <category>private</category><body package="URISupport">findAsset: aName	| className selectorName class |	className := (aName tokensBasedOn: $/) first.	selectorName := (aName tokensBasedOn: $/) last.	class := Assets allSubclasses detect: [:each | each name = className asSymbol or: [each fullName = className]] ifNone: [^nil].	(class respondsTo: selectorName asSymbol) ifFalse: [^nil].	^class visualFor: selectorName asSymbol</body></methods><methods><class-id>OS.URLwithPath</class-id> <category>resolution</category><body package="URISupport">addComponent: aComponent"Encode and add path component "	self privateAddComponent: aComponent encode: true</body><body package="URISupport">addEncodedComponent: aComponent"Add already encoded path component "	self privateAddComponent: aComponent encode: false</body><body package="URISupport">construct:  aFileComponent"Encode and add path component "	^self copy 		addComponent: aFileComponent;		yourself</body><body package="URISupport">removeLastComponent	path := path copyFrom: 1 to: path size-1</body><body package="URISupport">resolveEncodedPath: aPath	| aURI |	aURI := URI fromEncodedString:  aPath.	aURI isPartial ifFalse: [^aURI copy].	^self copy		mergePartial: aURI;		yourself</body><body package="URISupport">resolvePath: aPath	| aURI |	aURI := aPath asURI.	aURI isPartial ifFalse: [^aURI copy].	^self copy		mergePartial: aURI;		yourself</body><body package="URISupport">withComponent: component	"Create a new URL with the argument component appended.	The new component will be encoded."	^self privateWithComponent: component encode: true</body><body package="URISupport">withComponents: components	"Create a new URL with the argument components appended.	The new components will be encoded."	^self privateWithComponent: components encode: true</body><body package="URISupport">withEncodedComponent: aComponent	"Create a new URL with the argument component appended."	^self privateWithComponent: aComponent encode: false</body><body package="URISupport">withEncodedComponents: components	"Create a new URL with the argument components appended.	The new components will be encoded."	^self privateWithComponent: components encode: false</body></methods><methods><class-id>OS.URLwithPath</class-id> <category>utilities</category><body package="URISupport">directory	^self withComponent: '..'</body><body package="URISupport">queryKeysAndValuesDo: aBlock	| stream field mid key val |	query ifNil: [^nil].	stream := query readStream.	[ stream atEnd ] whileFalse: [ 		field := stream upTo: $&amp;.		(mid := field indexOf: $=) isZero			ifTrue: [ key := field. val := '' ]			ifFalse: [ key := field copyFrom: 1 to: mid - 1.				val := field copyFrom: mid+1 to: field size ].		aBlock value: key value: val ]</body><body package="URISupport">tail	| index |	path isEmpty ifTrue: [^''].	index := path last = ''		ifTrue: [path size-1]		ifFalse: [path size].	index = 0 ifTrue: [^''].	^self pathAt: index</body></methods><methods><class-id>OS.URLwithPath</class-id> <category>accessing</category><body package="URISupport">decodedPath	^self path collect: [ :token | self class decode: token ]</body><body package="URISupport">fragment	^fragment</body><body package="URISupport">fragment: f	fragment := f</body><body package="URISupport">path	^path</body><body package="URISupport">path: aPath	path := aPath</body><body package="URISupport">pathAt: index	^self class decode: (path at: index)</body><body package="URISupport">query	^query</body><body package="URISupport">query: q	query := q</body></methods><methods><class-id>OS.URLwithPath</class-id> <category>private</category><body package="URISupport">guessMimeType	"To do move Net.MimeTypeDescriptor to base classes and return:  		 Net.MimeTypeDescriptor contentType: mimeType"	^#{Net.MimeTypeDescriptor} 		ifDefinedDo: [ :mimeTypeDescriptor | mimeTypeDescriptor guessFromExtension: self tail asFilename extension]		elseDo: ['text/plain']</body><body package="URISupport">mergeAbsolutePath: aPath	self path: (aPath allButFirst: 1)</body><body package="URISupport">mergePartial: aPartialURL	self fragment: aPartialURL fragment.	aPartialURL hasNoPath ifTrue: [^aPartialURL query ifNotNil: [self query: aPartialURL query]].	self query: aPartialURL query.	aPartialURL isPathAbsolute		ifTrue: [self mergeAbsolutePath: aPartialURL path copy]		ifFalse: [self mergeRelativePath: aPartialURL path copy].	self normalize.</body><body package="URISupport">mergeRelativePath: relativePath	path isEmpty ifTrue: [^path := relativePath].	path := (path allButLast: 1), relativePath</body><body package="URISupport">normalize"http://www.ietf.org/rfc/rfc3986.txtThe path segments '.' and '..', also known as dot-segments, are defined for relative reference within the path name hierarchy.  They are intended for use at the beginning of a relative-path reference  (Section 4.2) to indicate relative position within the hierarchical tree of names.  This is similar to their role within some operating systems' file directory structures to indicate the current directory and parent directory, respectively.  However, unlike in a file   system, these dot-segments are only interpreted within the URI path hierarchy and are removed as part of the resolution process (Section 5.2)."	| normPath normInd token |	normPath := OrderedCollection new.	normInd := 0.	1 to: path size do: [ :i |		token := path at: i.		(token ~= '.' 			and:[ token ~= '..' ]) 				ifTrue: [ normPath add: token.						normInd := normInd + 1 ]				ifFalse: [ (token = '..' and: [ normInd &gt; 0])							ifTrue: [normPath removeAtIndex: normInd. 									normInd :=  normInd - 1]]].						path := normPath</body><body package="URISupport">printExtrasOn: aStream	query == nil ifFalse: [aStream nextPutAll: '?', query].	fragment == nil ifFalse: [aStream nextPutAll: '#', fragment].</body><body package="URISupport">privateAddComponent: aComponent encode: aBoolean	path := path copyWith: (aBoolean							ifTrue: [ self class encode: aComponent ]							ifFalse: [aComponent ]).								self normalize</body><body package="URISupport">privateWithComponent: aComponentOrCollection encode: aBoolean	"Create a new URL with the argument component appended.	The new component will be encoded."	| p comps uri |	p := (self path isEmpty not and: [self path last = ''])		ifTrue: [self path copyFrom: 1 to: self path size-1]		ifFalse: [self path].	comps := aComponentOrCollection isString				ifTrue: [OrderedCollection with: aComponentOrCollection]				ifFalse: [aComponentOrCollection].	uri := self copy		query: nil;		fragment: nil;		path: p.	comps do: [:s | uri privateAddComponent: s encode: aBoolean].	^uri</body><body package="URISupport">safelyExecuteBlock: aBlock	^aBlock value</body><body package="URISupport">validateHost: aString	| parts |	('[*:*:*]' match: aString)		ifTrue:			["Hope it's a valid IPv6 literal... More error checking would be nice."			^aString copyFrom: 2 to: aString size-1].	aString do: [:ch |		(ch isAlphaNumeric or: ['.-_' includes: ch])			ifFalse: [self error: ((#InvalidHostName1s &lt;&lt; #net &gt;&gt; 'Invalid host name: &lt;1s&gt;') expandMacrosWith: aString)]].	parts := aString tokensBasedOn: $..	parts do: [:str1 |		str1 isEmpty			ifTrue: [self error: ((#InvalidHostName1s &lt;&lt; #net &gt;&gt; 'Invalid host name: &lt;1s&gt;') expandMacrosWith: aString)].		(str1 first = $- or: [str1 last = $-])			ifTrue: [self error: ((#InvalidHostName1s &lt;&lt; #net &gt;&gt; 'Invalid host name: &lt;1s&gt;') expandMacrosWith: aString)]].	^aString</body><body package="URISupport">validatePort: aString	| port |	port := 0.	aString do: [:c |		(c between: $0 and: $9)			ifTrue: [port := port * 10 + c digitValue]			ifFalse: [self error: ((#InvalidPort1s &lt;&lt; #net &gt;&gt; 'Invalid port: &lt;1s&gt;') expandMacrosWith: aString).]].	^port</body></methods><methods><class-id>OS.URLwithPath</class-id> <category>comparing</category><body package="URISupport">hash	^self path hash bitXor:		(self query hash bitXor: self fragment hash)</body><body package="URISupport">sameAs:  aURI"Current implementation considers that two URLs are equivalent only when their path size is equal and therefore the method returns false for URLs: '&lt;schema&gt;://example.com/pub'  and  '&lt;schema&gt;://example.com/pub/' "	self path size = aURI path size ifFalse: [^false].	1 to: self path size 		do: [ :ind | (self pathAt: ind) = (aURI pathAt: ind ) ifFalse: [ ^false ]].	^true</body><body package="URISupport">stringRepresentationPartsMatch: aURI	"Subclasses should reference all instance variables used by asString,	but without creating new strings to avoid heavy performance penalties"	^self path = aURI path		and: [self query = aURI query			and: [self fragment = aURI fragment]]</body></methods><methods><class-id>OS.URLwithPath</class-id> <category>printing</category><body package="URISupport">printEncodedPathOn: aStream "Print encoded path "	self 		printPathTokenOn: aStream 		do: [ :stream :token | stream nextPutAll: token ]</body><body package="URISupport">printOn: aStream	aStream nextPutAll: '&lt;URL:'.	self printProtocolOn: aStream.	self printPathOn: aStream.	self printExtrasOn: aStream.	aStream nextPutAll: '&gt;'.</body><body package="URISupport">printPathOn: aStream " Print decoded path" 	self 		printPathTokenOn: aStream 		do: [ :stream :token | 			(self class decode: token) do: [ :char |				('?#%' includes: char)					ifTrue: [aStream								nextPut: $%;								nextPutAll: (char asInteger printStringRadix: 16)]					ifFalse: [aStream nextPut: char]]]</body><body package="URISupport">printPathTokenOn: aStream do: aBlock"https://url.spec.whatwg.org/#url-serializing4. If url\u2019s cannot-be-a-base-URL flag is set, append the first string in url\u2019s path to output.5. Otherwise, append '/', followed by the strings in url\u2019s path (including empty strings), separated from each other by '/', to output."	| first current |	(self path isNil or: [self path size = 0]) ifTrue: [^aStream nextPut: $/ ].	self isPathAbsolute ifTrue: [ aStream nextPutAll: '/' ].		first := true.	self path 		do: [ :token | current := token. aBlock value: aStream value: token]		separatedBy: [			first				ifTrue: [					first := false.					current notEmpty ifTrue: [ aStream nextPutAll: '/' ]					]				ifFalse: [ aStream nextPutAll: '/' ] ]</body></methods><methods><class-id>OS.URLwithPath</class-id> <category>converting</category><body package="URISupport">, aURI	^self resolvePath: aURI</body><body package="URISupport">asPartial	^PartialURL new		path: (path copy addFirst: ''; yourself);		query: query;		fragment: fragment;		yourself</body></methods><methods><class-id>OS.URLwithPath</class-id> <category>copying</category><body package="URISupport">postCopy	super postCopy.	path := path copy.	query := query copy.	fragment := fragment copy</body></methods><methods><class-id>OS.URLwithPath</class-id> <category>testing</category><body package="URISupport">isPathAbsolute"https://url.spec.whatwg.org/#syntax-url-path-absolute	A path-absolute URL must be '/' followed by a path-relative URL."	^path size &gt; 1 and: [path first isEmpty]</body><body package="URISupport">isPathRelative"https://url.spec.whatwg.org/#syntax-url-path-relative	A path-relative URL must be zero or more path segments, separated from each other by '/', and not start with '/'"	^self isPathAbsolute not</body></methods><methods><class-id>OS.URLwithPath class</class-id> <category>instance creation</category><body package="URISupport">fromEncodedString: aString" The parameter is encoded string:  utf-8 + percent-encoded. The string will be parsed and components stored encoded"	^self parseUrl: aString encode: false</body><body package="URISupport">fromString: aString"The parameter is unencoded string. The string will be parsed in to URL components and encoded"	^self parseUrl: aString encode: true</body><body package="URISupport">host: aHost encodedPath: aPath"The path collection has to include encoded tokens  "	^self new 		path: aPath;		parseHost: aHost;		yourself</body><body package="URISupport">host: aHost encodedPathString: aPathString"The path is encoded string. The string will be parsed in to URL components "	^(self parsePath: aPathString encode: false )		parseHost: aHost;		yourself</body><body package="URISupport">host: aHost path: aPath	^(self newWithPath: aPath)		parseHost: aHost;		yourself</body><body package="URISupport">host: aHost pathString: aPathString"The path is unencoded string. The string will be parsed in to URL components and path tokens will be encoded "	^(self parsePath: aPathString encode: true )		parseHost: aHost;		yourself</body><body package="URISupport">newWithPath: aCollection"The path collection has to include encoded tokens  "	^self new 		path: (aCollection collect: [ :component | self encode: component ]) ;		yourself</body></methods><methods><class-id>OS.URLwithPath class</class-id> <category>accessing</category><body package="URISupport">protocol	^String new</body></methods><methods><class-id>OS.URLwithPath class</class-id> <category>private</category><body package="URISupport">parsePath: aString encode: aBoolean	|  idx pString url val |	url := self new.	pString := aString.	(pString includes: $#)		ifTrue:			[idx := pString indexOf: $#.			url fragment: (pString copyFrom: idx+1 to: pString size).			pString := pString copyFrom: 1 to: idx-1].	(pString includes: $?)		ifTrue:			[idx := pString indexOf: $?.			url query: (pString copyFrom: idx+1 to: pString size).			pString := pString copyFrom: 1 to: idx-1].	val := (pString notEmpty 			ifTrue: [ pString tokensBasedOn: $/ ]			ifFalse: [OrderedCollection new]).	url path: (aBoolean 		ifTrue: [val collect: [ :p | self encoder encode: p ]]		ifFalse: [val]).	^url</body><body package="URISupport">parseUrl: aString encode: aBoolean	"Error checking is somewhat minimal at this time."	| index pString host |	('//*' match: aString)		ifFalse: [self error: (#URLDoesNotBeginWithProtocol &lt;&lt; #net &gt;&gt; 'URL does not begin with "protocol://"')].	index := (3 to: aString size) detect: [:i | '/?#' includes: (aString at: i)] ifNone: [].	index = nil		ifTrue:			[host := (aString copyFrom: 3 to: aString size).			pString := '']		ifFalse:			[host := (aString copyFrom: 3 to: index-1).			(aString at: index ) = $/				ifTrue: [pString := (aString copyFrom: index+1 to: aString size) ]				ifFalse: [pString := (aString copyFrom: index to: aString size )]].	^(self parsePath: pString encode: aBoolean)		parseHost: host;		yourself.</body></methods><methods><class-id>OS.UriEncodedStreamConstructor</class-id> <category>streams</category><body package="URISupport">appendStream	"Answer a write stream connected to the file represented by	the receiver."	^self notImplemented</body><body package="URISupport">newReadAppendStream	"Answer a new readAppend stream connected to the file represented by	the receiver."	^self notImplemented</body><body package="URISupport">newReadWriteStream	"Answer a new readWrite stream connected to the file represented by	the receiver."	^self notImplemented</body><body package="URISupport">readAppendStream	"Answer a readAppend stream connected to the file represented by	the receiver."	^self notImplemented</body><body package="URISupport">readStream	"Answer a read stream connected to the file represented by	the receiver."	^self addEncodingTo: dataRepository binaryReadStream</body><body package="URISupport">readWriteStream	"Answer a readWrite stream connected to the file represented by	the receiver."	^self notImplemented</body><body package="URISupport">writeStream	"Answer a write stream connected to the file represented by	the receiver."	^self addEncodingTo: dataRepository binaryWriteStream</body></methods><methods><class-id>OS.URLwithAuthority</class-id> <category>accessing</category><body package="URISupport">asString	| str |	str := (String new: 64) writeStream.	self printProtocolOn: str.	self printAuthorityOn: str.	^str contents</body><body package="URISupport">client	^self subclassResponsibility</body><body package="URISupport">defaultPortNumber	^self class defaultPortNumber</body><body package="URISupport">host	^host</body><body package="URISupport">port	^port isNil 		ifTrue: [ port := self defaultPortNumber]		ifFalse: [ port ]</body></methods><methods><class-id>OS.URLwithAuthority</class-id> <category>comparing</category><body package="URISupport">hash	^super hash bitXor: (self host hash bitXor: self port hash)</body><body package="URISupport">sameAs: aURI	^(super sameAs: aURI)		and: [ ( host match: aURI host )			and: [ self port = aURI port ]]</body><body package="URISupport">stringRepresentationPartsMatch: aURI	"Subclasses should reference all instance variables used by asString,	but without creating new strings to avoid heavy performance penalties"	^(super stringRepresentationPartsMatch: aURI)		and: [self host = aURI host			and: [self port = aURI port]]</body></methods><methods><class-id>OS.URLwithAuthority</class-id> <category>initialize</category><body package="URISupport">host: aString port: aNumber	host := aString.	port := aNumber.</body><body package="URISupport">parseHost: aHostSpecification	self parseHostPort: aHostSpecification</body><body package="URISupport">parseHostPort: fullHost	| idx pString |	"Test for literal IPv6 hosts."	('[*]*' match: fullHost)		ifTrue:			[idx := fullHost nextIndexOf: $: from: (fullHost indexOf: $]) + 1 to: fullHost size.			idx == nil ifTrue: [idx := 0]]		ifFalse: [idx := fullHost indexOf: $:].	idx &gt; 0		ifTrue:			[host := self validateHost: (fullHost copyFrom: 1 to: idx-1).			(pString := fullHost copyFrom: idx+1 to: fullHost size) isEmpty				ifTrue: [ port := self defaultPortNumber ]				ifFalse: [ port := self validatePort: pString ]]		ifFalse:			[host := self validateHost: fullHost.			port := self defaultPortNumber]</body></methods><methods><class-id>OS.URLwithAuthority</class-id> <category>printing</category><body package="URISupport">printAuthorityOn: aStream	self printHostAndPortOn: aStream.	self printEncodedPathOn: aStream.	self printExtrasOn: aStream.</body><body package="URISupport">printHostAndPortOn: aStream	"IPv6 literal addresses use $: as the separator,	therefore need to be bracketted to distinguish those from the port separator."	host ifNil: [^self ].	(host includes: $:)		ifTrue: [aStream nextPut: $[; nextPutAll: host; nextPut: $]]		ifFalse: [aStream nextPutAll: host].	self port ~= self defaultPortNumber ifTrue: [aStream nextPutAll: ':'; print: self port]</body><body package="URISupport">printOn: aStream	aStream nextPutAll: '&lt;URL:'.	self printProtocolOn: aStream.	self printHostAndPortOn: aStream.	self printPathOn: aStream.	self printExtrasOn: aStream.	aStream nextPutAll: '&gt;'.</body></methods><methods><class-id>OS.URLwithAuthority</class-id> <category>testing</category><body package="URISupport">isPathAbsolute	^ self host notNil</body></methods><methods><class-id>OS.URLwithAuthority class</class-id> <category>defaults</category><body package="URISupport">defaultPortNumber	^80</body></methods><methods><class-id>OS.UnknownURLType</class-id> <category>accessing</category><body package="URISupport">asString	^protocol, ':', data</body><body package="URISupport">extraData: extraData	data := extraData</body><body package="URISupport">protocol	^protocol</body><body package="URISupport">protocol: p	protocol := p</body><body package="URISupport">resource	^self error: (#UnrecognizedTransferProtocol &lt;&lt; #net &gt;&gt; 'Unrecognized transfer protocol')</body></methods><methods><class-id>OS.UnknownURLType</class-id> <category>comparing</category><body package="URISupport">hash	^self protocol hash bitXor: self data hash</body><body package="URISupport">stringRepresentationPartsMatch: aURI	"Subclasses should reference all instance variables used by asString,	but without creating new strings to avoid heavy performance penalties"	^self protocol = aURI protocol		and: [self data = aURI data]</body></methods><methods><class-id>OS.UnknownURLType</class-id> <category>private</category><body package="URISupport">data	^data</body></methods><methods><class-id>OS.UnknownURLType class</class-id> <category>instance creation</category><body package="URISupport">fromEncodedString: aString	^self fromString: aString</body><body package="URISupport">fromString: aString	"Error checking is somewhat minimal at this time."	^self new extraData: aString</body></methods><methods><class-id>OS.UnknownURLType class</class-id> <category>accessing</category><body package="URISupport">protocol	^nil</body></methods><methods><class-id>OS.PartialURL</class-id> <category>testing</category><body package="URISupport">hasNoPath	^path isEmpty or: [path size = 1 and: [path first isEmpty]]</body><body package="URISupport">isPartial	^true</body></methods><methods><class-id>OS.PartialURL</class-id> <category>private</category><body package="URISupport">mergeAbsolutePath: aPath	self path: aPath</body></methods><methods><class-id>OS.PartialURL</class-id> <category>printing</category><body package="URISupport">printEncodedPathOn: aStream	self path isEmpty ifTrue: [^self].	super printEncodedPathOn: aStream</body><body package="URISupport">printPathOn: aStream	self path isEmpty ifTrue: [^self].	super printPathOn: aStream</body><body package="URISupport">printProtocolOn: aStream</body></methods><methods><class-id>OS.PartialURL</class-id> <category>accessing</category><body package="URISupport">asString	| stream |	stream := String new writeStream.	self printEncodedPathOn: stream.	self printExtrasOn: stream.	^stream contents</body><body package="URISupport">resource	^nil</body></methods><methods><class-id>OS.PartialURL class</class-id> <category>instance creation</category><body package="URISupport">fromEncodedString: aString" The parameter is encoded string:  utf-8 + percent-encoded. The string will be parsed and components stored encoded"	^self parsePath: aString encode: false.</body><body package="URISupport">fromString: aString"The parameter is unencoded string. The string will be parsed in to URL components "	^self parsePath: aString encode: true.</body></methods><methods><class-id>OS.URLEncoder</class-id> <category>utility</category><body package="URISupport">decode: aString	"This is frightening. We want to advance the inner stream unless we see %, in which case we go to the outer stream. And for state-changing encoders, we need to know that nil character doesn't necessarily indicate an error"	| result  |	result := WriteStream on: (String new: aString size).	self decode: aString onto: result.	^result contents.</body><body package="URISupport">decode: aString onto: resultStream	"This is frightening. We want to advance the inner stream unless we see %, in which case we go to the outer stream. And for state-changing encoders, we need to know that nil character doesn't necessarily indicate an error"	| outermostDecoder urlDecoder realCharacterStream |	outermostDecoder := self decodingStreamOn: aString.	urlDecoder := outermostDecoder stream.	realCharacterStream := urlDecoder stream.	[urlDecoder atEnd]		whileFalse:			[| nextThing mode |			mode := outermostDecoder encoder readMode.			nextThing := realCharacterStream peek = $%				ifTrue: [outermostDecoder next]				ifFalse: [urlDecoder next].				(outermostDecoder encoder readMode == mode)				ifTrue:					[nextThing isNil 	ifTrue: [						nextThing := (UnsupportedCharacterError new)							messageText: #errNoCharacter &lt;&lt; #dialogs &gt;&gt; 'No character available';							raise]].			nextThing isNil ifFalse: [resultStream nextPut: nextThing asCharacter]].</body><body package="URISupport">encode: aString	^(self encodingStream) nextPutAll: aString; close; encodedContents.</body><body package="URISupport">encode: aString onto: aStream	^(self encodingStreamOn: aStream) nextPutAll: aString; close.</body></methods><methods><class-id>OS.URLEncoder</class-id> <category>querying</category><body package="URISupport">characterSize: char	"Return the size in bytes of &lt;char&gt;."	^(self isValidURLCharacter: char) ifTrue: [1] ifFalse: [3].</body><body package="URISupport">isValidURLCharacter: aCharacter	"Return true if this character is one we can expect to see in a URL when decoding it. Note that this excludes the escapes, because we expect them to have been translated away before this is asked. See http://www.w3.org/Addressing/URL/5_BNF.html"	| char |	char := aCharacter asCharacter.	char isAlphaNumeric ifTrue: [^true].	(self urlSpecials includes: aCharacter) ifTrue: [^true].	^false.</body></methods><methods><class-id>OS.URLEncoder</class-id> <category>accessing</category><body package="URISupport">charset	"Return a symbol indicating the encoding we will use."	^encoder encoding.</body><body package="URISupport">charset: aCharsetName	self setEncoder: (StreamEncoder new: aCharsetName).</body><body package="URISupport">decodeHexNumberFrom: aStream	^Number readIntegerFrom: (aStream next: 2) readStream radix: 16.</body><body package="URISupport">encodingStream	^self encodingStreamOn: (WriteStream on: String new).</body><body package="URISupport">encodingStreamOn: innerStream	| outerStream |	outerStream := EncodedStream on: innerStream encodedBy: self.	^outerStream.</body><body package="URISupport">nextFrom: aStream	"Decode the next byte(s) in the stream and answer the character."	| c |	c := aStream next.	(c = $+ and: [ self urlEncodedSpecials includes: c ]) ifTrue: [^Character space asInteger].	c = $% ifTrue: [^self decodeHexNumberFrom: aStream].	^c isNil ifTrue: [c] ifFalse: [c asInteger].</body><body package="URISupport">nextPut: aCharacterOrByte on: aStream	"Encode the character according to the encoding, and if necessary URL encode it"	| digits digits2 aCharacter |	aCharacter := aCharacterOrByte asCharacter.	(aCharacter = Character space and: [ self urlSpecials includes: aCharacter ]) ifTrue: [^aStream nextPut: $+].	"The doubling up is needing for encodings that switch character interpretations in the middle, using escape sequences. Specifically, JIS. Rather than hard-coding knowledge of these encodings, encode twice and if it's different, that means there's a prelude"	digits := self bytesFor: aCharacter.	digits2 := self bytesFor: aCharacter.	digits size = digits2 size		ifTrue:			[(self isValidURLCharacter: aCharacter)				ifTrue: [aStream nextPut: aCharacter]				ifFalse: [digits do: [:each | self printHex: each on: aStream]]]		ifFalse:			[self				printDigits: aCharacter				withPreludeFor: digits				and: digits2				on: aStream].</body><body package="URISupport">setEncoder: aCharacterEncoder	encoder := aCharacterEncoder.	"For encodings with Big-Endian and Little-Endian variations, network order is specified as Big-Endian, so force that to be used."	encoder bigEndian: true.</body><body package="URISupport">urlEncodedSpecials	urlEncodedSpecials ifNil: [urlEncodedSpecials := self class urlEncodedSpecials].	^urlEncodedSpecials.</body><body package="URISupport">urlEncodedSpecials: aString	urlEncodedSpecials:= aString</body><body package="URISupport">urlSpecials	urlSpecials == nil ifTrue: [urlSpecials := self class urlSpecials].	^urlSpecials.</body><body package="URISupport">urlSpecials: aString	urlSpecials:= aString</body></methods><methods><class-id>OS.URLEncoder</class-id> <category>private</category><body package="URISupport">bytesFor: aCharacter	| bitStream |	bitStream := (ByteArray new: 8) writeStream.	encoder nextPut: aCharacter on: bitStream.	^bitStream contents.</body><body package="URISupport">decodingStreamOn: aString	| innerStream outerStream |	innerStream := EncodedStream on: (ReadStream on: aString) encodedBy: self.	outerStream := EncodedStream on: innerStream encodedBy: (self encoder ifNil: [UTF8StreamEncoder new]).	^outerStream.</body><body package="URISupport">printDigits: aCharacter withPreludeFor: bytesWithPrelude and: basicBytes on: aStream	"This is used for encodings that switch character interpretations in the middle, using escape sequences. Specifically, JIS. Rather than hard-coding knowledge of these encodings, encode twice and if it's different, that means there's a prelude. Figure out what the prelude is and print it differently"	| prelude preludeSize |	preludeSize := bytesWithPrelude size - basicBytes size.	prelude := bytesWithPrelude copyFrom: 1 to: preludeSize.	prelude do: [:each | 		(self isValidURLCharacter: each asCharacter)			ifTrue: [aStream nextPut: each asCharacter]			ifFalse: [self printHex: each on: aStream]].	(self isValidURLCharacter: aCharacter) 		ifTrue: [	aStream nextPut: aCharacter]		ifFalse: [basicBytes do: [:each | self printHex: each on: aStream]].</body><body package="URISupport">printDigitsNoPrelude: aCharacterOrDigit on: aStream	| aCharacter |	aCharacter := aCharacterOrDigit asCharacter.	(self isValidURLCharacter: aCharacter) 		ifTrue: [	aStream nextPut: aCharacter]		ifFalse: [self printHex: aCharacter asInteger on: aStream].</body><body package="URISupport">printHex: each on: aStream	aStream nextPut: $%.	^each		printOn: aStream		base: 16		digitsToPad: 2		highDigit: 2.</body></methods><methods><class-id>OS.URLEncoder</class-id> <category>status</category><body package="URISupport">prepareToClose: aStream	"This is truly horrible. We need to make a new stream, because we don't have the old one."	| newStream |	newStream := (ByteArray new: 5) writeStream.	encoder prepareToClose: newStream.	newStream contents do: [:each | self printDigitsNoPrelude: each on: aStream].	super prepareToClose: aStream.</body></methods><methods><class-id>OS.URLEncoder class</class-id> <category>defaults</category><body package="URISupport">defaultCharacterEncoder	^UTF8StreamEncoder new</body><body package="URISupport">urlEncodedSpecials"	The decoder will use this characters for special decoding. 	https://url.spec.whatwg.org/#application/x-www-form-urlencoded	While decoding the + will be replaced with the space"	urlEncodedSpecials isNil ifTrue: [urlEncodedSpecials := '+'].	^urlEncodedSpecials.</body><body package="URISupport">urlSpecials	urlSpecials isNil ifTrue: [urlSpecials := ' _'].	^urlSpecials.</body></methods><methods><class-id>OS.URLEncoder class</class-id> <category>encoding</category><body package="URISupport">decode: aString	^self new decode: aString.</body><body package="URISupport">encode: aString	^self new encode: aString.</body></methods><methods><class-id>OS.URLEncoder class</class-id> <category>instance creation</category><body package="URISupport">new	^super new initialize.</body></methods><methods><class-id>OS.URLEncoder class</class-id> <category>accessing</category><body package="URISupport">streamEncodingType	^#URL</body></methods><methods><class-id>OS.FileURL</class-id> <category>resolution</category><body package="URISupport">addComponent: aFileComponent	path := path copyWith: aFileComponent.	self normalize</body><body package="URISupport">addEncodedComponent: aFileComponent	self addComponent: aFileComponent</body></methods><methods><class-id>OS.FileURL</class-id> <category>accessing</category><body package="URISupport">asFilename	| path2 fn |	^missingSlashes		ifTrue: [self path asFilename]		ifFalse:			[path2 := (1 to: path size) collect: [:i | self pathAt: i].			host == nil				ifTrue: [Filename rootComponents: path2]				ifFalse:					[fn := (Filename pathForRemoteHost: host) asFilename.					path2 do: [:s | fn := fn construct: (fn class decodePortableComponent: s)].					fn]]</body><body package="URISupport">asFilename: filenameClass	"Useful for doing testing"	| path2 fn |	^missingSlashes		ifTrue: [filenameClass named: self path]		ifFalse:			[path2 := (1 to: path size) collect: [:i | self pathAt: i].			host == nil				ifTrue: [filenameClass rootComponents: path2]				ifFalse:					[fn := filenameClass named: (filenameClass pathForRemoteHost: host).					path2 do: [:s | fn := fn construct: (fn class decodePortableComponent: s)].					fn]]</body><body package="URISupport">asString	| str |	str := (String new: 64) writeStream.	^missingSlashes		ifTrue: [str nextPutAll: 'file:'; nextPutAll: self path asString.			self printExtrasOn: str.			str contents]		ifFalse:			[str nextPutAll: 'file://'.			host == nil ifFalse: [str nextPutAll: host].			str nextPutAll: '/'.			path do: [:i | str nextPutAll:  i ] separatedBy: [str nextPutAll: '/'].			self printExtrasOn: str.			str contents]</body><body package="URISupport">host: aHost	host := aHost</body><body package="URISupport">missingSlashes: aBoolean	missingSlashes := aBoolean</body><body package="URISupport">path: aPath	super path: aPath.	missingSlashes := false</body><body package="URISupport">resource	^XML.InputSource		uri: self		encoding: nil		stream: (self asFilename withEncoding: #UTF_8) readStream lineEndTransparent</body></methods><methods><class-id>OS.FileURL</class-id> <category>stream creation</category><body package="URISupport">binaryReadStream	^(self asFilename withEncoding: #binary) readStream</body><body package="URISupport">binaryWriteStream	^(self asFilename withEncoding: #binary) writeStream</body><body package="URISupport">readStreamDo: aBlock	| stream params | 	stream := (self asFilename withEncoding: #binary) readStream.	params := Dictionary new.	params at: #MIME put: self guessMimeType.	^[aBlock value: stream value: params] ensure: [stream close]</body><body package="URISupport">writeStreamDo: aBlock	| stream  |	stream := (self asFilename withEncoding: #binary) writeStream.	^[aBlock value: stream] ensure: [stream close]</body></methods><methods><class-id>OS.FileURL</class-id> <category>utilities</category><body package="URISupport">delete	self asFilename delete</body><body package="URISupport">fileSize	^self asFilename fileSize</body><body package="URISupport">makeDirectory	self asFilename makeDirectory</body><body package="URISupport">tail	^self asFilename tail</body></methods><methods><class-id>OS.FileURL</class-id> <category>file utilities</category><body package="URISupport">directoryContents	^self asFilename directoryContents		collect: [:s | self withComponent: s]</body></methods><methods><class-id>OS.FileURL</class-id> <category>testing</category><body package="URISupport">exists	^self asFilename exists</body><body package="URISupport">isDirectory	^self asFilename isDirectory</body><body package="URISupport">isPathAbsolute	^true</body></methods><methods><class-id>OS.FileURL</class-id> <category>private</category><body package="URISupport">host	^host</body><body package="URISupport">normalize	2 to: path size do: [:i |		((path at: i) = '..' and: [(path at: i-1) ~= '.' and: [(path at: i-1) ~= '..']])			ifTrue:				[path := (path copyFrom: 1 to: i-2), (path copyFrom: i+1 to: path size).				^self normalize].		(path at: i) = '.'			ifTrue:				[path := (path copyFrom: 1 to: i-1), (path copyFrom: i+1 to: path size).				^self normalize]].</body></methods><methods><class-id>OS.FileURL</class-id> <category>comparing</category><body package="URISupport">hash	^super hash bitXor: self host hash</body><body package="URISupport">stringRepresentationPartsMatch: aURI	"Subclasses should reference all instance variables used by asString,	but without creating new strings to avoid heavy performance penalties"	^(super stringRepresentationPartsMatch: aURI)		and: [self host = aURI host]</body></methods><methods><class-id>OS.FileURL</class-id> <category>initialize</category><body package="URISupport">parseHost: aHost	^(#('' 'localhost') includes: aHost)		ifFalse: [ host := aHost ]</body></methods><methods><class-id>OS.FileURL class</class-id> <category>instance creation</category><body package="URISupport">fromFilename: aFilename	| p |	p := aFilename uriComponents.	^(p respondsTo: #key)		ifTrue: 			[ (self newWithPath: p value)					host: p key; 					yourself]		ifFalse:[self newWithPath: p]</body><body package="URISupport">fromString: aString	"Error checking is somewhat minimal at this time."	"Lame override of the superclass because tests	supplied by Sun to OASIS use wierd syntax with	file: protocol."	"This approach puts a String in the path, which	should only be a Filename. This is required to	avoid canonicalizing the file name, but results in	an URL that can do nothing other than answer	the string which created it."	('//*' match: aString)		ifFalse: [^self new path: aString; missingSlashes: true].	^super fromString: aString</body><body package="URISupport">host: aHost path: aPath	^(#('' 'localhost') includes: aHost)		ifTrue: [ self newWithPath: aPath]		ifFalse: [ (self newWithPath: aPath) host: aHost; yourself ]</body></methods><methods><class-id>OS.FileURL class</class-id> <category>accessing</category><body package="URISupport">protocol	^'file'</body></methods><methods><class-id>OS.DataURI</class-id> <category>accessing</category><body package="URISupport">asString	| stream |	stream := String new writeStream.	stream nextPutAll: self protocol; nextPutAll: ':'.	mimeType == nil ifFalse: [		stream nextPutAll: mimeType.		parameters do: [:each | stream nextPutAll: ';'; nextPutAll: each]].	stream nextPutAll: ','.	(parameters includes: 'base64')		ifTrue: [			| base64stream |			base64stream := (String new withEncoding: #base64) writeStream.			base64stream nextPutAll: data.			base64stream close.			stream nextPutAll: (base64stream stream contents copyWithout: Character cr)]		ifFalse: [stream nextPutAll: data ].	^stream contents</body><body package="URISupport">characterSet		parameters do: [:each |		| parts |		parts := each tokensBasedOn: $=.		parts first = 'charset' ifTrue: [^parts last asSymbol]].	^#default</body><body package="URISupport">data	^data</body><body package="URISupport">data: anObject	data := anObject</body><body package="URISupport">encoder	^self class encoder		charset: self characterSet;		yourself</body><body package="URISupport">mimeType	^mimeType</body><body package="URISupport">mimeType: anObject	mimeType := anObject</body><body package="URISupport">parameters	^parameters</body><body package="URISupport">parameters: anObject	parameters := anObject</body><body package="URISupport">resource	| type subtype |	type := (mimeType tokensBasedOn: $/) first.	subtype := (mimeType tokensBasedOn: $/) last.	^(MimeTypes at: type ifAbsent: [^nil]) value: self value: subtype</body></methods><methods><class-id>OS.DataURI</class-id> <category>stream creation</category><body package="URISupport">binaryReadStream	^self readStream contents asByteArray readStream</body><body package="URISupport">readStream	^(self encoder decode: data) readStream</body><body package="URISupport">readStreamDo: aBlock		^aBlock value: self readStream</body></methods><methods><class-id>OS.DataURI class</class-id> <category>accessing</category><body package="URISupport">mimeTypes	^MimeTypes</body><body package="URISupport">protocol		^'data'</body></methods><methods><class-id>OS.DataURI class</class-id> <category>class initialization</category><body package="URISupport">initialize	"self initialize"	(MimeTypes := Dictionary new)		at: 'text' put: [:uri :subtype | uri readStream contents]</body></methods><methods><class-id>OS.DataURI class</class-id> <category>instance creation</category><body package="URISupport">fromEncodedString: aString	^self fromString: aString</body><body package="URISupport">fromString: aString	| index mediaType mimeType parameters data |	index := aString indexOf: $,.	index = 0 ifTrue: [^self error: (#InvalidDataURI &lt;&lt; #net &gt;&gt; 'Invalid data: url. Comma expected.')].	mediaType := (self decode: (aString copyFrom: 1 to: index - 1)) tokensBasedOn: $;.	mimeType := mediaType first.	parameters := mediaType allButFirst: 1.	data := aString copyFrom: index + 1 to: aString size.	(parameters includes: 'base64')		ifTrue: [data := (data withEncoding: #base64) readStream contents].	^self new		data: data;		mimeType: mimeType;		parameters: parameters;		yourself</body></methods><methods><class-id>OS.ComponentNotLoaded</class-id> <category>constants</category><body package="URISupport">defaultResumeValue	"Answer the default value to resume with."	^defaultValueBlock value</body></methods><methods><class-id>OS.ComponentNotLoaded</class-id> <category>accessing</category><body package="URISupport">defaultValueBlock: aBlock	defaultValueBlock := aBlock</body></methods><methods><class-id>OS.ComponentNotLoaded</class-id> <category>printing</category><body package="URISupport">defaultMessageText	^(#CannotCreateURL &lt;&lt; #net &gt;&gt; 'Can not create URL, &lt;1s&gt; parcel is not loaded') expandMacrosWith: self parameter</body></methods><methods><class-id>OS.ComponentNotLoaded class</class-id> <category>testing</category><body package="URISupport">mayResume	^true</body></methods><methods><class-id>OS.Filename</class-id> <category>private</category><body package="URISupport">uriComponents	| list |	list := (self class components: self asString) asArray.	self isRelative		ifTrue: [list := #('.'), list].	^list</body></methods><methods><class-id>OS.UnixFilename</class-id> <category>private</category><body package="URISupport">uriComponents	"#('/' '/a/b/c' 'a/b/c' '../a/b')		collect: [:i || f |			f := (UnixFilename named: i).			f asString = (f asURI asFilename: UnixFilename) asString]"	| list |	list := super uriComponents.	list size = 0		ifFalse: [list first = '/'			ifTrue: [list := list copyFrom: 2 to: list size]].	^list</body></methods><methods><class-id>OS.Filename</class-id> <category>converting</category><body package="URISupport">asURI	^FileURL fromFilename: self</body></methods><methods><class-id>OS.Filename class</class-id> <category>instance creation</category><body package="URISupport">rootComponents: path	"Answer a new Filename with the supplied path.	Unless the first element of the path explicitly specifies	the local directory as the starting point of the path, the	resulting name should be modified to be an absolute	path name. For portability, '.' will be used to specify	the local directory as the starting point, even though on	Mac OS and possibly others a different convention is	used. Using '.' allows the path to refer to relative path	names in a platform independent way."	| stream filename |	path isEmpty ifTrue: [^self concreteClass fromRootComponent: ''].	stream := path readStream.	filename := self concreteClass fromRootComponent: stream next.	[stream atEnd] whileFalse:		[filename := filename construct:				(self concreteClass decodePortableComponent: stream next)].	^filename</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>converting</category><body package="URISupport">asURI	"Answer a URI named the receiver. The string should not include any percent-encoded characters. All special characters will be percent-encoded after parsing the string"	^URI fromString: self string</body></methods><methods><class-id>OS.Filename class</class-id> <category>private</category><body package="URISupport">decodePortableComponent: aString	"Translate portable path notation (which for example uses '..'	to represent the parent directory) into the host equivalent"	^aString</body></methods><methods><class-id>OS.PCFilename</class-id> <category>private</category><body package="URISupport">uriComponents	"#('\' '\a\b\c' 'a\b\c' 'c:\a\b' '\\romulan' '\\romulan\'			'\\romulan\disk' '\\romulan\disk\' '\\romulan\disk\a' '..\a\b')		collect: [:i || f |			f := (PCFilename named: i).			f asString = (f asURI asFilename: PCFilename) asString]"	| list idx host |	list := super uriComponents.	list size = 0		ifFalse: [list first = '\'			ifTrue: [list := list copyFrom: 2 to: list size]			ifFalse: [('#:\' match: list first)				ifTrue: [list at: 1 put: (list first copyWithout: $\)]				ifFalse: [('\\*\*\' match: list first)					ifTrue:						[idx := list first nextIndexOf: $\ from: 3 to: list first size.						host := list first copyFrom: 3 to: idx-1.						list at: 1 put: (list first copyFrom: idx+1 to: list first size-1).						list := host -&gt; list]					ifFalse: [('\\*\' match: list first)					ifTrue:						[host := list first copyFrom: 3 to: list first size-1.						list := host -&gt; (list copyFrom: 2 to: list size)]]]]].	^list</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>converting</category><body package="URISupport">encodedStringAsURI"Decodes the string and answer a URI named the receiver.'ftp://ABC.com/%7Esmith/%C5%99%20%C5%BE.html'  encodedStringAsURI "	^URI fromEncodedString: self string</body></methods><initialize><class-id>OS.AboutURI</class-id></initialize><initialize><class-id>OS.DataURI</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>EncodedStreamConstructor</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dataRepository encoding </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>Exception</name><environment>Core</environment><super>Core.GenericException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>StreamEncoder</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>encoder errorPolicy skipRecord </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>Filename</name><environment>OS</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>osName publicName logicalName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Support</category><attributes><package>OS-Support</package></attributes></class><class><name>UnixFilename</name><environment>OS</environment><super>OS.Filename</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Unix</category><attributes><package>OS-Unix</package></attributes></class><class><name>CharacterArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>PCFilename</name><environment>OS</environment><super>OS.Filename</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-PC</category><attributes><package>OS-PC</package></attributes></class></st-source>