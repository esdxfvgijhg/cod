<?xml version="1.0"?><st-source><!-- Name: ASN1-TypesNotice: Copyright 1999-2013 Cincom Systems, Inc.  All rights reserved.Comment: This packages gathers the elements used in ASN.1 type definitions. Various kinds of 'types' are represented as instances of Type subclasses. Types are derived from other types often by adding some 'constraint' to the parent type definition. Various kinds of constraints are represented as instances of Asn1Constraint subclasses. Definitions of StructuredTypes are mostly comprised of a list of their 'elements' which are expressed in terms of AbstractElement subclasses.Types are primarily used to drive the marshaling machinery from ASN1 package, however another important capability of types is the ability to 'validate' objects, i.e. validate if a particular Object is a valid value of a given ASN.1 type. This capability is accessible as Type>>permits: message.LIMITATIONS:	- no support for ANY DEFINED BY	- no support for ASN.1 values: name Type ::= ...	- no support for parameterization of types: Name { Type param } ::= ...	- no support for information classes and objects: CLASS	- no support for presentation context switching types EXTERNAL, EMBEDDED PDV, CHARACTER STRINGDbIdentifier: bear73DbTrace: 479046DbUsername: tkoganDbVersion: 8.2 - 1DevelopmentPrerequisites: #(#(#package 'ASN1-Constraints' ''))PackageName: ASN1-TypesParcel: #('ASN1-Types')PrerequisiteParcels: #(#('ASN1-Constraints' ''))PrintStringCache: (8.2 - 1,tkogan)Version: 8.2 - 1Date: 3:07:41 PM April 21, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (apr17.2) of April 21, 2017 on April 21, 2017 at 3:07:41 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>Type</name><environment>ASN1</environment><super>ASN1.Entity</super><private>false</private><indexed-type>none</indexed-type><inst-vars>constraint retainEncoding tag tagging </inst-vars><class-inst-vars>defaultConstraint </class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><comment><class-id>ASN1.Type</class-id><body>Asn1Type is an abstract class.  Instances of Asn1Type are used to represent the information needed to encode and decode an ASN.1 type and to support the double-dipatch protocol used during 'type-in-hand' encoding or decoding.Subclasses must implement the following messages:	encoding		tagBERInstance Variables:	constraint	&lt;Asn1Constraint&gt; the constraint structure delimiting the Asn1Type	retainEncoding	&lt;Boolean&gt; controls retention of encodings	tag	&lt;Integer&gt; a specific tag for this type	tagging	&lt;Symbol&gt; the tagging mode for this type '#implicit', or '#explicit'Class Instance Variables:	defaultConstraint	&lt;Asn1Constraint&gt; the default constraint for the respective class of types</body></comment><class><name>ConstructedType</name><environment>ASN1</environment><super>ASN1.Type</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><comment><class-id>ASN1.ConstructedType</class-id><body>Asn1TypeConstructed is the abstract superclass of the ASN.1 'constructed' types: SEQUENCE, SEQUENCE_OF, SET, SET_OF, and CHOICE.  It stands in contrast with Asn1TypeBasic.</body></comment><class><name>StructuredType</name><environment>ASN1</environment><super>ASN1.ConstructedType</super><private>false</private><indexed-type>none</indexed-type><inst-vars>elements defaultOrOptionalCount extensionMarkerCount minLength </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><comment><class-id>ASN1.StructuredType</class-id><body>Asn1TypeStructured is the abstract superclass of those constructed types that contained named, typed elements.  It is defined in contrast to Asn1TypeUnstructured.Instance Variables:	defaultOrOptionalCount	&lt;Integer&gt;								number of elements either with defaults or optional	elements				&lt;(OrderedCollection of: Asn1Element)&gt;	the elements of the structured type	extensionMarkerCount	&lt;Integer&gt;								the number of extension markers among the elements	minLength				&lt;Integer&gt;								the minimum element count</body></comment><class><name>BasicType</name><environment>ASN1</environment><super>ASN1.Type</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><comment><class-id>ASN1.BasicType</class-id><body>Asn1TypeBasic is the abstract superclass of the ASN.1 'basic' types, including the ASN.1 string types.  It stands in constrast with Asn1ConstructedType.</body></comment><class><name>StringType</name><environment>ASN1</environment><super>ASN1.BasicType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><comment><class-id>ASN1.StringType</class-id><body>Abstract superclass of all string types.</body></comment><class><name>VideotexString</name><environment>ASN1</environment><super>ASN1.StringType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><comment><class-id>ASN1.VideotexString</class-id><body>Asn1TypeVideotexString represents the ASN.1 VideotexString type.</body></comment><class><name>BOOLEAN</name><environment>ASN1</environment><super>ASN1.BasicType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><comment><class-id>ASN1.BOOLEAN</class-id><body>Asn1TypeBOOLEAN represents the ASN.1 BOOLEAN type.</body></comment><class><name>TypeWrapper</name><environment>ASN1</environment><super>Protocols.MessageForwarder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>encoding type </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><comment><class-id>ASN1.TypeWrapper</class-id><body>An Asn1TypeWrapper is an optional result of decoding that retains the source encoding, the Asn1Type that regulated the decoding, and the decoded value.Instance Variables:	encoding	&lt;ByteArray | Asn1Encoding&gt;	the encoding of the value	type		&lt;Asn1Type&gt;					the type of the value	value		&lt;Object&gt;						the decoded value</body></comment><class><name>NULL</name><environment>ASN1</environment><super>ASN1.BasicType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><comment><class-id>ASN1.NULL</class-id><body>Asn1TypeNULL represents the ASN.1 NULL type.</body></comment><class><name>AbstractElement</name><environment>ASN1</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><comment><class-id>ASN1.AbstractElement</class-id><body>Asn1AbstractElement is the abstract superclass of the elements found in ASN.1 constructed types and enumerations.  This class and its subclasses implement selectors that facilitate the analysis of collections of such elements.</body></comment><class><name>EnumerationElement</name><environment>ASN1</environment><super>ASN1.AbstractElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>integer symbol explicit </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><comment><class-id>ASN1.EnumerationElement</class-id><body>An Asn1Enumeration represents one of the elements -- like the two in '{ female(0), male(1) }' -- that are found in the definition of ENUMERATEDs.  Note that #asAsn1EnumerationElement is implemented (1) in Asn1Enumeration, (2) in Asn1MarkerExtension, because ENUMERATEDs may include extension marker, and (3) in Association, so that Associations may be easily converted.  This is not an 'imported' type because it is only used to represent an Asn1Type element, though it is like Asn1ImportedEnumeration, which latter may figure in application-level VisualWorks code.Instance Variables:	integer	&lt;Integer&gt; the integer part of the element	symbol	&lt;Symbol&gt; the symbolic part of the element	explicit	&lt;Boolean&gt; was the integral value assigned automatically or explicitly ?</body></comment><class><name>TeletexString</name><environment>ASN1</environment><super>ASN1.StringType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><comment><class-id>ASN1.TeletexString</class-id><body>Asn1TypeTeletexString represents the ASN.1 TeletexString type.</body></comment><class><name>IA5String</name><environment>ASN1</environment><super>ASN1.StringType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><comment><class-id>ASN1.IA5String</class-id><body>Asn1TypeIA5String represents the ASN.1 IA5String type.</body></comment><class><name>VisibleString</name><environment>ASN1</environment><super>ASN1.IA5String</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><comment><class-id>ASN1.VisibleString</class-id><body>Asn1TypeVisibleString represents the ASN.1 VisibleString type.</body></comment><class><name>UTCTime</name><environment>ASN1</environment><super>ASN1.VisibleString</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><comment><class-id>ASN1.UTCTime</class-id><body>Asn1TypeUTCTime represents the ASN.1 UTCTime type.</body></comment><class><name>UnstructuredType</name><environment>ASN1</environment><super>ASN1.ConstructedType</super><private>false</private><indexed-type>none</indexed-type><inst-vars>elementType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><comment><class-id>ASN1.UnstructuredType</class-id><body>Asn1TypeUnstructured is an abstract class.  It is the superclass of those constructed types that contain unnamed elements of the same type.  It is defined in contrast with Asn1TypeStructured.Instance Variables:	elementType	&lt;Asn1Type&gt;	the common type of the contained elements</body></comment><class><name>SEQUENCE_OF</name><environment>ASN1</environment><super>ASN1.UnstructuredType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><comment><class-id>ASN1.SEQUENCE_OF</class-id><body>Asn1TypeSEQUENCE_OF represents the ASN.1 SEQUENCE OF type.</body></comment><class><name>ChoiceElement</name><environment>ASN1</environment><super>ASN1.AbstractElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>owner symbol type </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><comment><class-id>ASN1.ChoiceElement</class-id><body>This is the element found in the definitions of CHOICEs.Instance Variables:	owner	&lt;StructuredType&gt; the owning type	symbol	&lt;ByteSymbol&gt; the symbol identifying the element	type	&lt;Asn1Type&gt; the type of the element</body></comment><class><name>MappableType</name><environment>ASN1</environment><super>ASN1.StructuredType</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mapping </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><comment><class-id>ASN1.MappableType</class-id><body>Asn1TypeMappable is the abstract superclass of those structured, constructed types that can usefully be mapped to user-defined, Smalltalk classes.</body></comment><class><name>SET</name><environment>ASN1</environment><super>ASN1.MappableType</super><private>false</private><indexed-type>none</indexed-type><inst-vars>decodingDictionary encodingDictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><comment><class-id>ASN1.SET</class-id><body>Asn1TypeSET represents the ASN.1 SET type.  Note that an ASN.1 SET is not  a set in the mathematical sense.  It is a SEQUENCE with an unconstrained transmission order.Instance Variables:	decodingDictionary	&lt;Dictionary&gt;	maps element tags to Asn1Elements	encodingDictionary	&lt;Dictionary&gt;	maps element symbols to Asn1Elements</body></comment><class><name>BIT_STRING</name><environment>ASN1</environment><super>ASN1.BasicType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><comment><class-id>ASN1.BIT_STRING</class-id><body>Asn1TypeBIT_STRING represents the ASN.1 BIT STRING type.</body></comment><class><name>GraphicString</name><environment>ASN1</environment><super>ASN1.StringType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><comment><class-id>ASN1.GraphicString</class-id><body>Asn1TypeGraphicString represents the ASN.1 GraphicString type.</body></comment><class><name>INTEGER</name><environment>ASN1</environment><super>ASN1.BasicType</super><private>false</private><indexed-type>none</indexed-type><inst-vars>identifiers </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><comment><class-id>ASN1.INTEGER</class-id><body>Asn1TypeINTEGER represents the ASN.1 INTEGER type.Instance Variables:	identifiers	&lt;Dictionary&gt; maps specified identifiers to values</body></comment><class><name>SET_OF</name><environment>ASN1</environment><super>ASN1.UnstructuredType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><comment><class-id>ASN1.SET_OF</class-id><body>Asn1TypeSET_OF represents the ASN.1 SET OF type.  Note that an ASN.1 SET OF is not  a set in the mathematical sense.  It is a SEQUENCE OF with an unconstrained transmission order, that may contain multiple occurrences of the same value..</body></comment><class><name>ENUMERATED</name><environment>ASN1</environment><super>ASN1.BasicType</super><private>false</private><indexed-type>none</indexed-type><inst-vars>elements extensibleAt useEnumeration complete </inst-vars><class-inst-vars>defaultUseEnumeration </class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><comment><class-id>ASN1.ENUMERATED</class-id><body>Asn1TypeENUMERATED represents the ASN.1 ENUMERATED type.Instance Variables:	elements	&lt;(OrderedCollection of: (Association))&gt; the symbol-to-integer mappings that define the enumeration	extensibleAt	&lt;Integer&gt; the index of element after which there's an extension marker	useEnumeration	&lt;Boolean&gt; should wrap unmarshaled values in Enumeration instances ?	complete	&lt;Boolean&gt; private indicator that the type definition is complete and all elements have valuesClass Instance Variables:	defaultUseEnumeration	&lt;Boolean&gt; should enumerations unmarshal as Enumeration instances by default ?</body></comment><class><name>OCTET_STRING</name><environment>ASN1</environment><super>ASN1.BasicType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><comment><class-id>ASN1.OCTET_STRING</class-id><body>Asn1TypeOCTET_STRING represents the ASN.1 OCTET STRING type.</body></comment><class><name>TypeReference</name><environment>ASN1</environment><super>ASN1.Entity</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><comment><class-id>ASN1.TypeReference</class-id><body>Asn1TypeReference is used to implement forward referencing during type declaration and registration.  If a compound type is registered before one of its subtypes, the subtype is stored -- in the type registry and in the compound type being defined -- as an Asn1TypeReference.  Later, whenever the Asn1TypeReference is sent a message implemented in Asn1Type or any of its subtypes, then, by way of a reimplemented 'doesNotUnderstand:', the Asn1TypeReference is replaced with the concrete type using 'oneWayBecome:'.  If that type cannot be found, a runtime exception is raised.</body></comment><class><name>PrintableString</name><environment>ASN1</environment><super>ASN1.IA5String</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><comment><class-id>ASN1.PrintableString</class-id><body>Asn1TypePrintableString represents the ASN.1 PrintableString type.</body></comment><class><name>GeneralString</name><environment>ASN1</environment><super>ASN1.StringType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><comment><class-id>ASN1.GeneralString</class-id><body>Asn1TypeGeneralString represents the ASN.1 GeneralString type.</body></comment><class><name>RELATIVE_OID</name><environment>ASN1</environment><super>ASN1.BasicType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><comment><class-id>ASN1.RELATIVE_OID</class-id><body>Asn1TypeRELATIVE_OID represents the ASN.1 RELATIVE OID type.</body></comment><class><name>GeneralizedTime</name><environment>ASN1</environment><super>ASN1.VisibleString</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><comment><class-id>ASN1.GeneralizedTime</class-id><body>Asn1TypeGeneralizedTime represents the ASN.1 GeneralizedTime type.</body></comment><class><name>Enumeration</name><environment>ASN1</environment><super>ASN1.TypeWrapper</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><comment><class-id>ASN1.Enumeration</class-id><body>An ImportedEnumeration is an imported type used to represent an ASN.1 ENUMERATED.</body></comment><class><name>BMPString</name><environment>ASN1</environment><super>ASN1.StringType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><comment><class-id>ASN1.BMPString</class-id><body>Asn1TypeBMPString represents the ASN.1 BMPString type.</body></comment><class><name>Choice</name><environment>ASN1</environment><super>ASN1.TypeWrapper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>choice </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><comment><class-id>ASN1.Choice</class-id><body>Asn1Choice is an imported type, optionally used to represent ASN.1 CHOICE's in the decoded form of an object.Instance Variables:	choice	&lt;ChoiceElement&gt; the element representing the chosen alternative</body></comment><class><name>NumericString</name><environment>ASN1</environment><super>ASN1.IA5String</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><comment><class-id>ASN1.NumericString</class-id><body>Asn1TypeNumericString represents the ASN.1 NumericString type.</body></comment><class><name>MarkerElement</name><environment>ASN1</environment><super>ASN1.AbstractElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><comment><class-id>ASN1.MarkerElement</class-id><body>Asn1Marker is the abstract superclass of those classes used to represent the special markers defined in ASN.1.</body></comment><class><name>ExceptionMarker</name><environment>ASN1</environment><super>ASN1.MarkerElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>integer symbol </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><comment><class-id>ASN1.ExceptionMarker</class-id><body>Asn1MarkerException is intended to be used to represent ASN.1 exception markers.  It is not currently used.Instance Variables:	integer	&lt;Integer&gt;	the integer error code associated with the exception	symbol	&lt;Symbol&gt;	the name of the exception</body></comment><class><name>ObjectDescriptor</name><environment>ASN1</environment><super>ASN1.BasicType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><comment><class-id>ASN1.ObjectDescriptor</class-id><body>Asn1TypeObjectDescriptor represents the ASN.1 ObjectDescriptor type.</body></comment><class><name>SubType</name><environment>ASN1</environment><super>ASN1.Type</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parent </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><comment><class-id>ASN1.SubType</class-id><body>Asn1SubType denotes types derived from other Asn1Types.Subclasses must implement the following messages:	encoding		tagBERInstance Variables:	parent	&lt;Asn1Type&gt; the parent of the Asn1Type</body></comment><class><name>REAL</name><environment>ASN1</environment><super>ASN1.BasicType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><comment><class-id>ASN1.REAL</class-id><body>Asn1TypeREAL represents the ASN.1 REAL type.</body></comment><class><name>ANY</name><environment>ASN1</environment><super>ASN1.BasicType</super><private>false</private><indexed-type>none</indexed-type><inst-vars>definedBy typeMap </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><comment><class-id>ASN1.ANY</class-id><body>Asn1TypeANY represents the ASN.1 ANY type.Instance Variables:	definedBy	&lt;String | StructureElement&gt; the element used by the DEFINED BY clause	typeMap	&lt;Dictionary key: Object value: Type&gt; the mapping for the DEFINED BY clause</body></comment><class><name>OBJECT_IDENTIFIER</name><environment>ASN1</environment><super>ASN1.BasicType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><comment><class-id>ASN1.OBJECT_IDENTIFIER</class-id><body>Asn1TypeOBJECT_IDENTIFIER represents the ASN.1 OBJECT IDENTIFIER type.</body></comment><class><name>UniversalString</name><environment>ASN1</environment><super>ASN1.StringType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><comment><class-id>ASN1.UniversalString</class-id><body>Asn1TypeUniversalString represents the ASN.1 UniversalString type.</body></comment><class><name>UTF8String</name><environment>ASN1</environment><super>ASN1.StringType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><comment><class-id>ASN1.UTF8String</class-id><body>Asn1TypeUTF8String represents the ASN.1 UTF8String type.</body></comment><class><name>InvalidTypeSpecification</name><environment>ASN1</environment><super>ASN1.Asn1Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><comment><class-id>ASN1.InvalidTypeSpecification</class-id><body>An Asn1ExcTypeSpecification is raised when an error is detected in the specification of an Asn1Type.</body></comment><class><name>SEQUENCE</name><environment>ASN1</environment><super>ASN1.MappableType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><comment><class-id>ASN1.SEQUENCE</class-id><body>Asn1TypeSEQUENCE represents the ASN.1 SEQUENCE type.</body></comment><class><name>CHOICE</name><environment>ASN1</environment><super>ASN1.StructuredType</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tags useChoice </inst-vars><class-inst-vars>defaultUseChoice </class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><comment><class-id>ASN1.CHOICE</class-id><body>Asn1TypeCHOICE represents the ASN.1 CHOICE type.Instance Variables:	tags	&lt;Set&gt; the tags associated with the elements, used in decoding	useChoice	&lt;Boolean&gt; should wrap unmarshaled values in Choice instances ?Class Instance Variables:	defaultUseChoice	&lt;Boolean&gt; should choices unmarshal as Choice instances by default ?</body></comment><class><name>StructureElement</name><environment>ASN1</environment><super>ASN1.ChoiceElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>default optional </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><comment><class-id>ASN1.StructureElement</class-id><body>StructureElement implements the elements found in the definitions of constructed types SET and SEQUENCE. It adds the notion of OPTIONAL and DEFAULT. Note that an element cannot be both OPTIONAL and have DEFAULT.Instance Variables:	default	&lt;Object | UndefinedObject&gt; the default value, that could be nil	optional	&lt;Boolean&gt; indicates whether the element is optional</body></comment><class><name>InvalidTypeReference</name><environment>ASN1</environment><super>ASN1.Asn1Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><comment><class-id>ASN1.InvalidTypeReference</class-id><body>This exception is raised for type references that cannot be resolved.</body></comment><class><name>ExtensionMarker</name><environment>ASN1</environment><super>ASN1.MarkerElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>default </class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><comment><class-id>ASN1.ExtensionMarker</class-id><body>An Asn1MarkerExtension represents an ASN.1 extension marker.  There is only one privileged, default instance.  Asn1MarkerExtension implements the selectors 'integer' and 'symbol' both of which return 'nil', so that ENUMERATED element collections -- which can contain extension markers -- may be processed without type checking.Class Instance Variables:	default	&lt;Asn1MarkerExtension&gt;	the sole instance</body></comment><shared-variable><name>UniversalBOOLEAN</name><environment>ASN1</environment><private>false</private><constant>false</constant><category>tags</category><initializer>1</initializer><attributes><package>ASN1-Types</package></attributes></shared-variable><shared-variable><name>ConstructedSET</name><environment>ASN1</environment><private>false</private><constant>false</constant><category>tags</category><initializer>2r00110001</initializer><attributes><package>ASN1-Types</package></attributes></shared-variable><shared-variable><name>UniversalENUMERATED</name><environment>ASN1</environment><private>false</private><constant>false</constant><category>tags</category><initializer>10</initializer><attributes><package>ASN1-Types</package></attributes></shared-variable><shared-variable><name>UniversalUTCTime</name><environment>ASN1</environment><private>false</private><constant>false</constant><category>tags</category><initializer>23</initializer><attributes><package>ASN1-Types</package></attributes></shared-variable><shared-variable><name>PrivateClass</name><environment>ASN1</environment><private>false</private><constant>false</constant><category>tag classes</category><initializer>2r11000000</initializer><attributes><package>ASN1-Types</package></attributes></shared-variable><shared-variable><name>UniversalOCTET_STRING</name><environment>ASN1</environment><private>false</private><constant>false</constant><category>tags</category><initializer>4</initializer><attributes><package>ASN1-Types</package></attributes></shared-variable><shared-variable><name>UniversalUTF8String</name><environment>ASN1</environment><private>false</private><constant>false</constant><category>tags</category><initializer>12</initializer><attributes><package>ASN1-Types</package></attributes></shared-variable><shared-variable><name>ConstructedSEQUENCE_OF</name><environment>ASN1</environment><private>false</private><constant>false</constant><category>tags</category><initializer>2r00110000</initializer><attributes><package>ASN1-Types</package></attributes></shared-variable><shared-variable><name>UniversalGeneralString</name><environment>ASN1</environment><private>false</private><constant>false</constant><category>tags</category><initializer>27</initializer><attributes><package>ASN1-Types</package></attributes></shared-variable><shared-variable><name>UniversalREAL</name><environment>ASN1</environment><private>false</private><constant>false</constant><category>tags</category><initializer>9</initializer><attributes><package>ASN1-Types</package></attributes></shared-variable><shared-variable><name>UniversalUniversalString</name><environment>ASN1</environment><private>false</private><constant>false</constant><category>tags</category><initializer>28</initializer><attributes><package>ASN1-Types</package></attributes></shared-variable><shared-variable><name>UniversalNumericString</name><environment>ASN1</environment><private>false</private><constant>false</constant><category>tags</category><initializer>18</initializer><attributes><package>ASN1-Types</package></attributes></shared-variable><shared-variable><name>UniversalPrintableString</name><environment>ASN1</environment><private>false</private><constant>false</constant><category>tags</category><initializer>19</initializer><attributes><package>ASN1-Types</package></attributes></shared-variable><shared-variable><name>UniversalSET_OF</name><environment>ASN1</environment><private>false</private><constant>false</constant><category>tags</category><initializer>17</initializer><attributes><package>ASN1-Types</package></attributes></shared-variable><shared-variable><name>UniversalT61String</name><environment>ASN1</environment><private>false</private><constant>false</constant><category>tags</category><initializer>20</initializer><attributes><package>ASN1-Types</package></attributes></shared-variable><shared-variable><name>UniversalNULL</name><environment>ASN1</environment><private>false</private><constant>false</constant><category>tags</category><initializer>5</initializer><attributes><package>ASN1-Types</package></attributes></shared-variable><shared-variable><name>PrimitiveForm</name><environment>ASN1</environment><private>false</private><constant>false</constant><category>tag forms</category><initializer>2r00000000</initializer><attributes><package>ASN1-Types</package></attributes></shared-variable><shared-variable><name>TagMaskNumber</name><environment>ASN1</environment><private>false</private><constant>false</constant><category>tag masks</category><initializer>2r00011111</initializer><attributes><package>ASN1-Types</package></attributes></shared-variable><shared-variable><name>UniversalTeletexString</name><environment>ASN1</environment><private>false</private><constant>false</constant><category>tags</category><initializer>20</initializer><attributes><package>ASN1-Types</package></attributes></shared-variable><shared-variable><name>UniversalOBJECT_IDENTIFIER</name><environment>ASN1</environment><private>false</private><constant>false</constant><category>tags</category><initializer>6</initializer><attributes><package>ASN1-Types</package></attributes></shared-variable><shared-variable><name>UniversalSEQUENCE</name><environment>ASN1</environment><private>false</private><constant>false</constant><category>tags</category><initializer>16</initializer><attributes><package>ASN1-Types</package></attributes></shared-variable><shared-variable><name>UniversalRELATIVE_OID</name><environment>ASN1</environment><private>false</private><constant>false</constant><category>tags</category><initializer>13</initializer><attributes><package>ASN1-Types</package></attributes></shared-variable><shared-variable><name>UniversalClass</name><environment>ASN1</environment><private>false</private><constant>false</constant><category>tag classes</category><initializer>2r00000000</initializer><attributes><package>ASN1-Types</package></attributes></shared-variable><shared-variable><name>UniversalSET</name><environment>ASN1</environment><private>false</private><constant>false</constant><category>tags</category><initializer>17</initializer><attributes><package>ASN1-Types</package></attributes></shared-variable><shared-variable><name>ConstructedForm</name><environment>ASN1</environment><private>false</private><constant>false</constant><category>tag forms</category><initializer>2r00100000</initializer><attributes><package>ASN1-Types</package></attributes></shared-variable><shared-variable><name>UniversalEMBEDDED_PDV</name><environment>ASN1</environment><private>false</private><constant>false</constant><category>tags</category><initializer>11</initializer><attributes><package>ASN1-Types</package></attributes></shared-variable><shared-variable><name>UniversalINSTANCE_OF</name><environment>ASN1</environment><private>false</private><constant>false</constant><category>tags</category><initializer>8</initializer><attributes><package>ASN1-Types</package></attributes></shared-variable><shared-variable><name>UniversalVisibleString</name><environment>ASN1</environment><private>false</private><constant>false</constant><category>tags</category><initializer>26</initializer><attributes><package>ASN1-Types</package></attributes></shared-variable><shared-variable><name>UniversalBMPString</name><environment>ASN1</environment><private>false</private><constant>false</constant><category>tags</category><initializer>30</initializer><attributes><package>ASN1-Types</package></attributes></shared-variable><shared-variable><name>UniversalISO646String</name><environment>ASN1</environment><private>false</private><constant>false</constant><category>tags</category><initializer>26</initializer><attributes><package>ASN1-Types</package></attributes></shared-variable><shared-variable><name>UniversalVideotexString</name><environment>ASN1</environment><private>false</private><constant>false</constant><category>tags</category><initializer>21</initializer><attributes><package>ASN1-Types</package></attributes></shared-variable><shared-variable><name>UniversalGeneralizedTime</name><environment>ASN1</environment><private>false</private><constant>false</constant><category>tags</category><initializer>24</initializer><attributes><package>ASN1-Types</package></attributes></shared-variable><shared-variable><name>UniversalIA5String</name><environment>ASN1</environment><private>false</private><constant>false</constant><category>tags</category><initializer>22</initializer><attributes><package>ASN1-Types</package></attributes></shared-variable><shared-variable><name>ContextSpecificClass</name><environment>ASN1</environment><private>false</private><constant>false</constant><category>tag classes</category><initializer>2r10000000</initializer><attributes><package>ASN1-Types</package></attributes></shared-variable><shared-variable><name>UniversalEXTERNAL</name><environment>ASN1</environment><private>false</private><constant>false</constant><category>tags</category><initializer>8</initializer><attributes><package>ASN1-Types</package></attributes></shared-variable><shared-variable><name>ConstructedSEQUENCE</name><environment>ASN1</environment><private>false</private><constant>false</constant><category>tags</category><initializer>2r00110000</initializer><attributes><package>ASN1-Types</package></attributes></shared-variable><shared-variable><name>UniversalINTEGER</name><environment>ASN1</environment><private>false</private><constant>false</constant><category>tags</category><initializer>2</initializer><attributes><package>ASN1-Types</package></attributes></shared-variable><shared-variable><name>ApplicationClass</name><environment>ASN1</environment><private>false</private><constant>false</constant><category>tag classes</category><initializer>2r01000000</initializer><attributes><package>ASN1-Types</package></attributes></shared-variable><shared-variable><name>UniversalObjectDescriptor</name><environment>ASN1</environment><private>false</private><constant>false</constant><category>tags</category><initializer>7</initializer><attributes><package>ASN1-Types</package></attributes></shared-variable><shared-variable><name>TagMaskClass</name><environment>ASN1</environment><private>false</private><constant>false</constant><category>tag masks</category><initializer>2r11000000</initializer><attributes><package>ASN1-Types</package></attributes></shared-variable><shared-variable><name>UniversalGraphicString</name><environment>ASN1</environment><private>false</private><constant>false</constant><category>tags</category><initializer>25</initializer><attributes><package>ASN1-Types</package></attributes></shared-variable><shared-variable><name>UniversalSEQUENCE_OF</name><environment>ASN1</environment><private>false</private><constant>false</constant><category>tags</category><initializer>16</initializer><attributes><package>ASN1-Types</package></attributes></shared-variable><shared-variable><name>TagMaskForm</name><environment>ASN1</environment><private>false</private><constant>false</constant><category>tag masks</category><initializer>2r00100000</initializer><attributes><package>ASN1-Types</package></attributes></shared-variable><shared-variable><name>ConstructedSET_OF</name><environment>ASN1</environment><private>false</private><constant>false</constant><category>tags</category><initializer>2r00110001</initializer><attributes><package>ASN1-Types</package></attributes></shared-variable><shared-variable><name>UniversalBIT_STRING</name><environment>ASN1</environment><private>false</private><constant>false</constant><category>tags</category><initializer>3</initializer><attributes><package>ASN1-Types</package></attributes></shared-variable><shared-variable><name>UniversalCHARACTER_STRING</name><environment>ASN1</environment><private>false</private><constant>false</constant><category>tags</category><initializer>29</initializer><attributes><package>ASN1-Types</package></attributes></shared-variable><methods><class-id>ASN1.Type</class-id> <category>testing</category><body package="ASN1-Types">isBasic	^false</body><body package="ASN1-Types">isConstructed	^false</body><body package="ASN1-Types">isExtensible	"Indicates whether the type may be extended in revisions of an originating ASN.1 type specifciation and include an ASN.1 extension marker."	^false</body><body package="ASN1-Types">isImplicitlyTagged	^tagging		ifNil: [ module				ifNil: [ false ]				ifNotNil: [ module tagging = #implicit ] ]		ifNotNil: [ tagging = #implicit ]</body><body package="ASN1-Types">isMappable	^false</body><body package="ASN1-Types">isScoping	"Indicates whether the type may override default tags by creating context-specific tags.  In principle, 'universal' and 'context-specific' tag classes are sufficient to disambiguate all tags.  Any ASN.1 compiler that produces instances or structures of Asn1Type is expected to do its job without relying on contexts that represent 'application' or 'private' tag classes."	^false</body><body package="ASN1-Types">isStructured	^false</body></methods><methods><class-id>ASN1.Type</class-id> <category>printing</category><body package="ASN1-Types">fullPrintOn: aStream	self name ifNotNil: [ :n | aStream nextPutAll: n; nextPutAll: ' ::= ' ].	self tag ifNotNil: [		aStream nextPut: $[;			print: self tag;			nextPut: $].		self tagging ifNotNil: [			aStream space;				nextPutAll: self tagging asString asUppercase ].		aStream space ].	aStream nextPutAll: self class defaultSymbol.	self constraint isNull ifFalse: [		aStream nextPutAll: ' ('.		self constraint shortPrintOn: aStream.		aStream nextPut: $) ]</body><body package="ASN1-Types">fullPrintString	| stream |	stream := (String new: 100) writeStream.	self fullPrintOn: stream.	^stream contents</body><body package="ASN1-Types">printOn: aStream	self shortPrintOn: aStream	"aStream		nextPutAll: ( self class name );		nextPutAll: '( ';		nextPutAll: self symbol;		nextPutAll: ' / ';		print: self constraint;		nextPutAll: ' )'"</body><body package="ASN1-Types">shortPrintOn: aStream	self tag ifNotNil: [		aStream nextPut: $[;			print: self tag;			nextPut: $].		self tagging ifNotNil: [			aStream space;				nextPutAll: self tagging asString asUppercase ].		aStream space ].	self name		ifNil: [ aStream nextPutAll: self class defaultSymbol ]		ifNotNil: [ :n | aStream nextPutAll: n ].	self constraint isNull ifFalse: [		aStream nextPutAll: ' ('.		self constraint shortPrintOn: aStream.		aStream nextPut: $) ]</body></methods><methods><class-id>ASN1.Type</class-id> <category>accessing</category><body package="ASN1-Types">constraint	^constraint ifNil: [ constraint := NullConstraint default ]</body><body package="ASN1-Types">constraint: anAsn1Constraint	constraint := anAsn1Constraint</body><body package="ASN1-Types">retainEncoding	^retainEncoding</body><body package="ASN1-Types">retainEncoding: aBoolean	retainEncoding := aBoolean</body><body package="ASN1-Types">tag	^tag</body><body package="ASN1-Types">tag: aTag"	aTag &lt;Integer&gt; a specific tag for this type"	tag := aTag</body><body package="ASN1-Types">tagging	^tagging</body><body package="ASN1-Types">tagging: aMode"	aMode &lt;Symbol&gt; tagging mode for this type '#implicit', or '#explicit'"	tagging := aMode</body></methods><methods><class-id>ASN1.Type</class-id> <category>utilities</category><body package="ASN1-Types">inspectorExtraAttributes	^#{Tools.Trippy.TextAttribute}		ifDefinedDo: [ :class | Array with: (class  label: 'ASN.1' text: self fullPrintString) ]		elseDo: [ Array new ]</body></methods><methods><class-id>ASN1.Type</class-id> <category>type construction</category><body package="ASN1-Types">named: aSymbol	^(SubType name: aSymbol)		parent: self</body><body package="ASN1-Types">named: aSymbol in: aModule	^(SubType name: aSymbol in: aModule)		parent: self</body></methods><methods><class-id>ASN1.Type</class-id> <category>initialize-release</category><body package="ASN1-Types">initialize	"By default, do not retain encodings."	retainEncoding := false.</body></methods><methods><class-id>ASN1.Type</class-id> <category>comparing</category><body package="ASN1-Types">equals: anObject"Implements 'structural equivalence' in the spirit of 'type compatibility' described in the ASN.1 semantic model (Dubuisson p.121)."	^	self == anObject	"Do not waste time comparing structure if we're identical."		or: [	( super equals: anObject )			and: [ ( anObject constraint equals: self constraint )				and: [ ( anObject tag = self tag )					and: [ anObject tagging = self tagging ] ] ] ]</body></methods><methods><class-id>ASN1.Type</class-id> <category>error</category><body package="ASN1-Types">obsoleteType	self error: (#TypeIsObsolete &lt;&lt; #asn1 &gt;&gt; 'This ASN.1 type is obsolete and no longer used.')</body></methods><methods><class-id>ASN1.Type</class-id> <category>validation</category><body package="ASN1-Types">permits: anObject	^	(self class defaultConstraint permits: anObject)		and: [self constraint permits: anObject ]</body></methods><methods><class-id>ASN1.Type</class-id> <category>private</category><body package="ASN1-Types">usedInElement: element"Callback from the element that uses the type, allows for any additional activity for proper hook-up to the containting type,necessary for example for ANY DEFINED BY type of construct."</body></methods><methods><class-id>ASN1.Type class</class-id> <category>defaults</category><body package="ASN1-Types">defaultConstraint"	^&lt;Asn1Constraint&gt; constraint that applies to all instances of this type class"	^defaultConstraint ifNil: [ defaultConstraint := self defaultConstraintValue ]</body><body package="ASN1-Types">defaultConstraint: aConstraint"	aConstraint &lt;Asn1Constraint&gt; the default constraint for the respective class of types	^&lt;Asn1Constraint&gt; constraint that applies to all instances of this type class"	defaultConstraint := aConstraint</body><body package="ASN1-Types">defaultConstraintValue"	^&lt;Asn1Constraint&gt; constraint that applies to all instances of this type class	... should, in all but a few cases, be overridden."	^ASN1.NullConstraint default</body><body package="ASN1-Types">defaultSymbol	^self subclassResponsibility</body><body package="ASN1-Types">flushDefaultConstraint	defaultConstraint := nil</body></methods><methods><class-id>ASN1.Type class</class-id> <category>instance creation</category><body package="ASN1-Types">new	^super new initialize</body></methods><methods><class-id>ASN1.Type class</class-id> <category>testing</category><body package="ASN1-Types">isConcrete	^( self class includesSelector: #defaultSymbol )		"and: [ self class includesSelector: #defaultConstraintValue ]"</body></methods><methods><class-id>ASN1.ConstructedType</class-id> <category>testing</category><body package="ASN1-Types">isConstructed	^true</body></methods><methods><class-id>ASN1.StructuredType</class-id> <category>accessing</category><body package="ASN1-Types">defaultOrOptionalCount	^( defaultOrOptionalCount isNil )		ifTrue:	[ self setDefaultOrOptionalCount ]		ifFalse:	[ defaultOrOptionalCount ]</body><body package="ASN1-Types">extensionMarkerCount	^( extensionMarkerCount isNil )		ifTrue:	[ self setExtensionMarkerCount ]		ifFalse:	[ extensionMarkerCount ]</body><body package="ASN1-Types">minLength	^( minLength isNil )		ifTrue:	[ self setMinLength ]		ifFalse:	[ minLength ]</body><body package="ASN1-Types">optionalOrDefaultSymbols	^( ( ( self elements select: [ :ele | ele isExtensionMarker not ] )		select: [ :ele | ( ele hasDefault ) or: [ ele isOptional ] ] )			collect: [ :ele | ele symbol ] ) asSet</body><body package="ASN1-Types">requiredSymbols	^( ( ( self elements select: [ :ele | ele isExtensionMarker not ] )		select: [ :ele | ( ele hasDefault not ) and: [ ele isOptional not ] ] )			collect: [ :ele | ele symbol ] ) asSet</body><body package="ASN1-Types">symbols	^( ( self elements select: [ :ele | ele isExtensionMarker not ] )		collect: [ :ele | ele symbol ] ) asSet</body></methods><methods><class-id>ASN1.StructuredType</class-id> <category>private</category><body package="ASN1-Types">clearPredicates	defaultOrOptionalCount := extensionMarkerCount := minLength := nil</body><body package="ASN1-Types">doesNotUnderstand: aMessage"Allow using an element name as a message to a structured type to make type building easier"	aMessage arguments isEmpty ifTrue: [		( self elements			detect: [ :e | e symbol = aMessage selector ]			ifNone: [ nil ]		) ifNotNil: [ :e | ^e ] ].	^super doesNotUnderstand: aMessage</body><body package="ASN1-Types">indexOfFirstExtensionMarkerOrEnd	| es |	es := elements size.	1 to: elements size do: [ :n | ( ( elements at: n ) isExtensionMarker ) ifTrue: [ ^n ] ].	^es</body><body package="ASN1-Types">newElement	^StructureElement new</body><body package="ASN1-Types">setDefaultOrOptionalCount	| n |	n := 0.	elements do: [ :e | ( e hasDefaultOrIsOptional ) ifTrue: [ n := n + 1 ] ].	^defaultOrOptionalCount := n</body><body package="ASN1-Types">setExtensionMarkerCount	| n |	n := 0.	elements do: [ :e | ( e isExtensionMarker ) ifTrue: [ n := n + 1 ] ].	^extensionMarkerCount := n</body><body package="ASN1-Types">setMinLength	"... sets the minimum length for aCollection marshaled under this type.  ... allows the marshaling of 'old' type definitions without subsequent extensions."	| num ind |	num := ind := self indexOfFirstExtensionMarkerOrEnd.	1 to: ind do:		[ :ndx |	| ele |				ele := elements at: ndx.				( ( ele hasDefaultOrIsOptional ) or: [ ele isExtensionMarker ] )					ifTrue:	[ num := num - 1 ]		].	^minLength := num</body></methods><methods><class-id>ASN1.StructuredType</class-id> <category>accessing - element constructors</category><body package="ASN1-Types">addElement: aSymbol type: aTypeSpec"	aSymbol &lt;Symbol&gt; element name	aTypeSpec &lt;Symbol | Asn1Type&gt; the element type"	^self addElement: (		self newElement			symbol: aSymbol;			type: (self typeFrom: aTypeSpec))</body><body package="ASN1-Types">addElement: aSymbol type: aTypeSpec tag: anInteger"	aSymbol &lt;Symbol&gt; element name	aTypeSpec &lt;Symbol | Asn1Type&gt; the element type	anInteger &lt;SmallInteger&gt; assign context-specific tag to the element"	^(self addElement: aSymbol type: aTypeSpec)		tag: anInteger;		yourself</body><body package="ASN1-Types">addElement: aSymbol type: aTypeSpec tag: anInteger tagging: aMode"	aSymbol &lt;Symbol&gt; element name	aTypeSpec &lt;Symbol | Asn1Type&gt; the element type	anInteger &lt;SmallInteger&gt; assign context-specific tag to the element	aMode &lt;Symbol&gt; set specific tagging mode for this element (#implict | #explicit)"	^(self addElement: aSymbol type: aTypeSpec tag: anInteger)		taggingMode: aMode;		yourself</body></methods><methods><class-id>ASN1.StructuredType</class-id> <category>accessing - elements</category><body package="ASN1-Types">addElement: anAbstractElement	self clearPredicates.	elements addLast: anAbstractElement.	anAbstractElement addedTo: self.	^anAbstractElement</body><body package="ASN1-Types">elementAtIndex: anInteger	^self elements at: anInteger</body><body package="ASN1-Types">elementWithSymbol: aSymbol	^self elements detect: [ :x | x symbol == aSymbol ]</body><body package="ASN1-Types">elementWithTag: anInteger	"... use constant to avoid namespace lookup."	^self elements detect: [ :x | ( x tagBER bitAnd: 02r00011111 "ASN1.TagMaskNumber" ) == 									( anInteger bitAnd: 02r00011111 "ASN1.TagMaskNumber" ) ]</body><body package="ASN1-Types">elementWithTag: anInteger ifNone: aBlock	^self elements		detect: [ :x | x matchesTag: anInteger ]		ifNone: aBlock</body><body package="ASN1-Types">elements	^elements</body><body package="ASN1-Types">elements: aSequenceableCollection	elements := aSequenceableCollection.	self clearPredicates</body><body package="ASN1-Types">removeElement: anAbstractElement	elements remove: anAbstractElement.	anAbstractElement removedFrom: self.	self clearPredicates.	^anAbstractElement</body></methods><methods><class-id>ASN1.StructuredType</class-id> <category>testing - elements</category><body package="ASN1-Types">hasDefaultsOrOptionals	^( self defaultOrOptionalCount &gt; 0 )</body><body package="ASN1-Types">hasExtensionMarkers	^( self extensionMarkerCount &gt; 0 )</body><body package="ASN1-Types">permitsLength: anInteger	"... used only when marshaling OrderedCollections as SEQUENCEs."	^( ( anInteger &lt;= self sizeSansExtensionMarkers )		and: [ anInteger &gt;= self minLength ] )</body><body package="ASN1-Types">sizeSansExtensionMarkers	^( elements size - self extensionMarkerCount )</body></methods><methods><class-id>ASN1.StructuredType</class-id> <category>testing</category><body package="ASN1-Types">isExtensible	"Indicates whether the type may be extended in revisions of an originating ASN.1 type specifciation and include an ASN.1 extension marker."	^true</body><body package="ASN1-Types">isScoping	"Indicates whether the type may override default tags by creating context-specific tags.  In principle, 'universal' and 'context-specific' tag classes are sufficient to disambiguate all tags.  Any ASN.1 compiler that produces instances or structures of Asn1Type is expected to do its job without relying on contexts that represent 'application' or 'private' tag classes."	^true</body><body package="ASN1-Types">isStructured	^true</body></methods><methods><class-id>ASN1.StructuredType</class-id> <category>initialize-release</category><body package="ASN1-Types">initialize	super initialize.	elements := OrderedCollection new: 7.</body></methods><methods><class-id>ASN1.StructuredType</class-id> <category>printing</category><body package="ASN1-Types">fullPrintOn: aStream	self shortPrintOn: aStream.	aStream space; nextPut: ${; cr.	self elements		do: [ :e | aStream tab.			e shortPrintOn: aStream ]		separatedBy: [ aStream nextPut: $,; cr ].	aStream space; nextPut: $}</body></methods><methods><class-id>ASN1.StructuredType</class-id> <category>comparing</category><body package="ASN1-Types">equals: anObject"Implements 'structural equivalence' in the spirit of 'type compatibility' described in the ASN.1 semantic model (Dubuisson p.121)."	^	self == anObject	"Do not waste time comparing structure if we're identical."		or: [	( super equals: anObject )			and: [ self hasEqualElementsWith: anObject ] ]</body><body package="ASN1-Types">hasEqualElementsWith: anObject	^	( anObject elements size = self elements size )		and: [ anObject elements allSatisfy: [ :e1 |				self elements anySatisfy: [ :e2 | e1 equals: e2 ] ] ]</body></methods><methods><class-id>ASN1.BasicType</class-id> <category>testing</category><body package="ASN1-Types">isBasic	^true</body></methods><methods><class-id>ASN1.VideotexString class</class-id> <category>defaults</category><body package="ASN1-Types">defaultSymbol	^#'VideotexString'</body></methods><methods><class-id>ASN1.BOOLEAN class</class-id> <category>defaults</category><body package="ASN1-Types">defaultConstraintValue	^BlockConstraint		with: [ :x | x == true or: [ x == false ] ]</body><body package="ASN1-Types">defaultSymbol	^#'BOOLEAN'</body></methods><methods><class-id>ASN1.TypeWrapper</class-id> <category>accessing</category><body package="ASN1-Types">_encoding	^encoding</body><body package="ASN1-Types">_encoding: aByteArrayOrAsn1Encoding	encoding := aByteArrayOrAsn1Encoding</body><body package="ASN1-Types">_type	^type</body><body package="ASN1-Types">_type: anAsn1Type	type := anAsn1Type</body><body package="ASN1-Types">_value	^object</body><body package="ASN1-Types">_value: anObject	object := anObject</body><body package="ASN1-Types">yourself"We don't want to unwrap unintentionally."	^self</body></methods><methods><class-id>ASN1.TypeWrapper</class-id> <category>comparing</category><body package="ASN1-Types">= anObject	^anObject _isTypeWrapper		ifTrue: [ object = anObject _object and: [ self _isEqualType: anObject ] ]		"We don't want the wrapper to get in the way of comparisons,		so if the other thing doesn't have a type we fall back to simple value comparison."		ifFalse: [ object = anObject ]</body><body package="ASN1-Types">hash	"Note that we can't include type in the hash because of the relaxed definition of #="	^object hash</body></methods><methods><class-id>ASN1.TypeWrapper</class-id> <category>converting</category><body package="ASN1-Types">asAsn1Choice: aCHOICE"Simpler version of Choice constructor for unambiguous CHOICEs. If in doubt use #asAsnChoice:symbol: instead."	^Choice		type: aCHOICE		value: self</body><body package="ASN1-Types">asAsn1Choice: aCHOICE symbol: choice	^Choice		type: aCHOICE		choiceSymbol: choice		value: self</body><body package="ASN1-Types">withAsn1Type: anAsn1Type	^ASN1.TypeWrapper		type: anAsn1Type		value: self</body></methods><methods><class-id>ASN1.TypeWrapper</class-id> <category>printing</category><body package="ASN1-Types">printOn: aStream	aStream		print: type;		nextPut: $&lt;;		print: object;		nextPut: $&gt;</body><body package="ASN1-Types">printString	"Answer a String whose characters are a description of the receiver."	| aStream |	aStream := WriteStream on: (String new: 16).	self printOn: aStream.	^aStream contents</body></methods><methods><class-id>ASN1.TypeWrapper</class-id> <category>validation</category><body package="ASN1-Types">isPermissible	^type permits: object</body></methods><methods><class-id>ASN1.TypeWrapper</class-id> <category>private</category><body package="ASN1-Types">_isEqualType: aTypeWrapper	^type equals: aTypeWrapper _type</body></methods><methods><class-id>ASN1.TypeWrapper</class-id> <category>testing</category><body package="ASN1-Types">_isChoice	^false</body><body package="ASN1-Types">_isTypeWrapper	^true</body></methods><methods><class-id>ASN1.TypeWrapper class</class-id> <category>instance creation</category><body package="ASN1-Types">type: aType value: anObject	^(aType permits: anObject)		ifTrue: [ self new				_type: aType;				_value: anObject;				yourself ]		ifFalse: [ TypeRealizationError new				messageText: (					#InvalidTypeCast1p2p &lt;&lt; #asn1 &gt;&gt; 'Invalid type cast of &lt;1p&gt; to &lt;2p&gt;!'						expandMacrosWith: anObject with: aType);				parameter: aType;				raise ]</body></methods><methods><class-id>ASN1.NULL class</class-id> <category>defaults</category><body package="ASN1-Types">defaultConstraintValue	^SingleValueConstraint		with: nil</body><body package="ASN1-Types">defaultSymbol	^#'NULL'</body></methods><methods><class-id>ASN1.AbstractElement</class-id> <category>testing</category><body package="ASN1-Types">hasDefault	"Answers whether the receiver contains a default value."	^false</body><body package="ASN1-Types">hasDefaultOrIsOptional	"Answers whether the receiver contains a default value or is optional."	^false</body><body package="ASN1-Types">isElement	"Answers whether the receiver is an element."	^false</body><body package="ASN1-Types">isExceptionMarker	"Answers whether the receiver is an exception marker."	^false</body><body package="ASN1-Types">isExplicit	"Answers whether the receiver is explicitly tagged."	^false</body><body package="ASN1-Types">isExtensionMarker	"Answers whether the receiver is an extension marker."	^false</body><body package="ASN1-Types">isImplicit	"Answers whether the receiver is implicitly tagged."	^false</body><body package="ASN1-Types">isMarker	"Answers whether the receiver is a marker."	^false</body><body package="ASN1-Types">isOptional	"Answers whether the receiver is optional."	^false</body><body package="ASN1-Types">isUniversal	"Answers whether the receiver is 'universally' tagged, that is, neither implicitly nor explicitly tagged."	^true</body></methods><methods><class-id>ASN1.AbstractElement</class-id> <category>initialize-release</category><body package="ASN1-Types">initialize</body></methods><methods><class-id>ASN1.AbstractElement</class-id> <category>printing</category><body package="ASN1-Types">printOn: aStream	aStream		nextPutAll: ( self class name )</body></methods><methods><class-id>ASN1.AbstractElement</class-id> <category>comparing</category><body package="ASN1-Types">equals: anObject"Implements 'structural equivalence' in the spirit of 'type compatibility' described in the ASN.1 semantic model (Dubuisson p.121)."	^	anObject class == self class</body></methods><methods><class-id>ASN1.AbstractElement</class-id> <category>private-adding</category><body package="ASN1-Types">addedTo: aStructuredType</body><body package="ASN1-Types">removedFrom: aStructuredType</body></methods><methods><class-id>ASN1.EnumerationElement</class-id> <category>comparing</category><body package="ASN1-Types">= anObject	^( anObject class == self class )		and: [ ( anObject integer = integer )			and: [ anObject symbol = symbol ] ]</body><body package="ASN1-Types">equals: anObject"Implements 'structural equivalence' in the spirit of 'type compatibility' described in the ASN.1 semantic model (Dubuisson p.121)."	^( super equals: anObject )		and: [ ( anObject integer = integer )			and: [ anObject symbol = symbol ] ]</body><body package="ASN1-Types">hash	^integer hash bitXor: symbol hash</body></methods><methods><class-id>ASN1.EnumerationElement</class-id> <category>accessing</category><body package="ASN1-Types">explicit	^explicit ifNil: [ explicit := false ]</body><body package="ASN1-Types">identifier	^self symbol</body><body package="ASN1-Types">integer	^integer</body><body package="ASN1-Types">integer: anInteger	self setValue: anInteger.	explicit := true</body><body package="ASN1-Types">symbol	^symbol</body><body package="ASN1-Types">symbol: aSymbolOrString	symbol := aSymbolOrString asSymbol</body><body package="ASN1-Types">value	^self integer</body></methods><methods><class-id>ASN1.EnumerationElement</class-id> <category>testing</category><body package="ASN1-Types">isExplicit	^self explicit</body></methods><methods><class-id>ASN1.EnumerationElement</class-id> <category>converting</category><body package="ASN1-Types">asAsn1EnumerationElement	^self</body></methods><methods><class-id>ASN1.EnumerationElement</class-id> <category>printing</category><body package="ASN1-Types">printOn: aStream	self shortPrintOn: aStream</body><body package="ASN1-Types">shortPrintOn: aStream	aStream nextPutAll: self identifier.	self isExplicit ifTrue: [		aStream nextPut: $(;			print: self value;			nextPut: $) ].</body></methods><methods><class-id>ASN1.EnumerationElement</class-id> <category>private</category><body package="ASN1-Types">setValue: anInteger	integer := anInteger</body></methods><methods><class-id>ASN1.EnumerationElement</class-id> <category>validation</category><body package="ASN1-Types">permits: anObject	^symbol = anObject or: [ integer = anObject ]</body></methods><methods><class-id>ASN1.EnumerationElement class</class-id> <category>instance creation</category><body package="ASN1-Types">integer: anInteger symbol: aSymbol	^( super new )		integer: anInteger;		symbol: aSymbol;		yourself</body><body package="ASN1-Types">symbol: aSymbol	^( super new )		symbol: aSymbol;		yourself</body><body package="ASN1-Types">symbol: aSymbol integer: anInteger	^( super new )		integer: anInteger;		symbol: aSymbol;		yourself</body></methods><methods><class-id>ASN1.TeletexString class</class-id> <category>defaults</category><body package="ASN1-Types">defaultSymbol	^#'TeletexString'</body></methods><methods><class-id>ASN1.IA5String class</class-id> <category>defaults</category><body package="ASN1-Types">defaultConstraintValue	"... the set CO of 32 control characters, plus ISOReg entry #6 (94 graphical characters), plus 'space' and 'delete'."	| charset |	charset := Set new: 32 + 94 + 2.	0 to: 31 do: [ :x | charset add: x asCharacter ].	charset addAll: '!"#$%&amp;''()*+,-./'.	charset addAll: '0123456789:;&lt;=&gt;?'.	charset addAll: '@ABCDEFGHIJKLMNO'.	charset addAll: 'PQRSTUVWXYZ[\]^_'.	charset addAll: '`abcdefghijkl;mno'.	charset addAll: 'pqrstuvwxyz{|}~'.	charset add: Character space.	charset add: Character del.	^AlphabetConstraint		with: ( ValueUnionConstraint				withAll: charset )</body><body package="ASN1-Types">defaultSymbol	^#'IA5String'</body></methods><methods><class-id>ASN1.VisibleString class</class-id> <category>defaults</category><body package="ASN1-Types">defaultConstraintValue	"... ISOReg entry #6 (94 characters), plus the space character."	| charset |	charset := Set new: 95.	charset addAll: '!"#$%&amp;''()*+,-./'.	charset addAll: '0123456789:;&lt;=&gt;?'.	charset addAll: '@ABCDEFGHIJKLMNO'.	charset addAll: 'PQRSTUVWXYZ[\]^_'.	charset addAll: '`abcdefghijkl;mno'.	charset addAll: 'pqrstuvwxyz{|}~'.	charset add: Character space.	^AlphabetConstraint		with: ( ValueUnionConstraint				withAll: charset )</body><body package="ASN1-Types">defaultSymbol	^#'VisibleString'</body></methods><methods><class-id>ASN1.UTCTime class</class-id> <category>defaults</category><body package="ASN1-Types">defaultConstraintValue	^BlockConstraint		with: [ :x | x class == Timestamp ]</body><body package="ASN1-Types">defaultSymbol	^#'UTCTime'</body></methods><methods><class-id>ASN1.UnstructuredType</class-id> <category>accessing</category><body package="ASN1-Types">elementType	^elementType</body><body package="ASN1-Types">elementType: aTypeSpec	elementType := self typeFrom: aTypeSpec</body></methods><methods><class-id>ASN1.UnstructuredType</class-id> <category>printing</category><body package="ASN1-Types">fullPrintOn: aStream	self name ifNotNil: [ :n | aStream nextPutAll: n; nextPutAll: ' ::= ' ].	self tag ifNotNil: [		aStream nextPut: $[;			print: self tag;			nextPut: $].		self tagging ifNotNil: [			aStream space;				nextPutAll: self tagging asString asUppercase ].		aStream space ].	aStream nextPutAll: (self class defaultSymbol copyUpTo: $ ).	self constraint isNull ifFalse: [		aStream nextPutAll: ' ('.		self constraint shortPrintOn: aStream.		aStream nextPut: $) ].	aStream nextPutAll: ' OF ';		nextPutAll: elementType name</body><body package="ASN1-Types">shortPrintOn: aStream	self tag ifNotNil: [		aStream nextPut: $[;			print: self tag;			nextPut: $].		self tagging ifNotNil: [			aStream space;				nextPutAll: self tagging asString asUppercase ].		aStream space ].	self name		ifNil: [ aStream nextPutAll: (self class defaultSymbol copyUpTo: $ ).			self constraint isNull ifFalse: [				aStream nextPutAll: ' ('.				self constraint shortPrintOn: aStream.				aStream nextPut: $) ].			aStream nextPutAll: ' OF ';				nextPutAll: elementType name ]		ifNotNil: [ :n | aStream nextPutAll: n ].</body></methods><methods><class-id>ASN1.UnstructuredType</class-id> <category>comparing</category><body package="ASN1-Types">equals: anObject"Implements 'structural equivalence' in the spirit of 'type compatibility' described in the ASN.1 semantic model (Dubuisson p.121)."	^	self == anObject	"Do not waste time comparing structure if we're identical."		or: [	( super equals: anObject )			and: [ self elementType equals: anObject elementType ] ]</body></methods><methods><class-id>ASN1.UnstructuredType</class-id> <category>validation</category><body package="ASN1-Types">permits: anObject	^(super permits: anObject)	and: [ anObject allSatisfy: [ :e | elementType permits: e ] ]</body></methods><methods><class-id>ASN1.SEQUENCE_OF class</class-id> <category>defaults</category><body package="ASN1-Types">defaultConstraintValue	^BlockConstraint		with: [ :x | x class == OrderedCollection ]</body><body package="ASN1-Types">defaultSymbol	^#'SEQUENCE OF'</body></methods><methods><class-id>ASN1.ChoiceElement</class-id> <category>printing</category><body package="ASN1-Types">printOn: aStream	self shortPrintOn: aStream</body><body package="ASN1-Types">shortPrintOn: aStream	self symbol ifNotNil: [ 		aStream nextPutAll: self symbol; tab ].	self type shortPrintOn: aStream</body></methods><methods><class-id>ASN1.ChoiceElement</class-id> <category>testing</category><body package="ASN1-Types">isElement	^true</body><body package="ASN1-Types">isExplicit	^self taggingMode == #explicit</body><body package="ASN1-Types">isImplicit	^self taggingMode == #implicit</body><body package="ASN1-Types">matchesTag: anInteger	^type matchesTag: anInteger</body></methods><methods><class-id>ASN1.ChoiceElement</class-id> <category>accessing</category><body package="ASN1-Types">owner	^owner</body><body package="ASN1-Types">symbol	^symbol ifNil: [ symbol := self type symbol ]</body><body package="ASN1-Types">symbol: aSymbol	symbol := aSymbol</body><body package="ASN1-Types">tag	^type tag</body><body package="ASN1-Types">tag: anInteger	self ensurePrivateType.	type tag: anInteger</body><body package="ASN1-Types">taggingMode	^type tagging</body><body package="ASN1-Types">taggingMode: aSymbolOrNil	self ensurePrivateType.	type tagging: aSymbolOrNil</body><body package="ASN1-Types">type	^type</body><body package="ASN1-Types">type: aAsn1Type	type := aAsn1Type</body></methods><methods><class-id>ASN1.ChoiceElement</class-id> <category>validation</category><body package="ASN1-Types">permits: anObject	^anObject asn1ChoiceType		ifNil: [ type permits: anObject ]		ifNotNil: [ :ctype | ctype = type ]</body></methods><methods><class-id>ASN1.ChoiceElement</class-id> <category>comparing</category><body package="ASN1-Types">equals: anObject"Implements 'structural equivalence' in the spirit of 'type compatibility' described in the ASN.1 semantic model (Dubuisson p.121)."	^( super equals: anObject )		and: [ anObject type equals: type ]</body></methods><methods><class-id>ASN1.ChoiceElement</class-id> <category>private-adding</category><body package="ASN1-Types">addedTo: aStructuredType	owner := aStructuredType.	type usedInElement: self.</body><body package="ASN1-Types">removedFrom: aStructuredType	(owner == aStructuredType) ifTrue: [ owner := nil ]</body></methods><methods><class-id>ASN1.ChoiceElement</class-id> <category>private</category><body package="ASN1-Types">ensurePrivateType	type name ifNotNil: [		type := type named: nil.		owner ifNotNil: [ type setModule: owner module ] ]</body></methods><methods><class-id>ASN1.ChoiceElement class</class-id> <category>instance creation</category><body package="ASN1-Types">new	^super new initialize</body></methods><methods><class-id>ASN1.MappableType</class-id> <category>accessing</category><body package="ASN1-Types">mapping	^mapping</body><body package="ASN1-Types">mapping: aClassOrUndefinedObject	mapping := aClassOrUndefinedObject</body></methods><methods><class-id>ASN1.MappableType</class-id> <category>accessing - element constructors</category><body package="ASN1-Types">addElement: aSymbol type: aTypeSpec default: anObject"	aSymbol &lt;Symbol&gt; element name	aTypeSpec &lt;Symbol | Asn1Type&gt; the element type	anObject &lt;Object&gt; default value for the element"	^(self addElement: aSymbol type: aTypeSpec)		default: anObject;		yourself</body><body package="ASN1-Types">addElement: aSymbol type: aTypeSpec tag: anInteger default: anObject"	aSymbol &lt;Symbol&gt; element name	aTypeSpec &lt;Symbol | Asn1Type&gt; the element type	anInteger &lt;SmallInteger&gt; assign context-specific tag to the element	anObject &lt;Object&gt; default value for the element"	^(self addElement: aSymbol type: aTypeSpec tag: anInteger)		default: anObject;		yourself</body><body package="ASN1-Types">addElement: aSymbol type: aTypeSpec tag: anInteger tagging: aMode default: anObject"	aSymbol &lt;Symbol&gt; element name	aTypeSpec &lt;Symbol | Asn1Type&gt; the element type	anInteger &lt;SmallInteger&gt; assign context-specific tag to the element	aMode &lt;Symbol&gt; set specific tagging mode for this element (#implict | #explicit)	anObject &lt;Object&gt; default value for the element"	^(self addElement: aSymbol type: aTypeSpec tag: anInteger tagging: aMode)		default: anObject;		yourself</body><body package="ASN1-Types">addOptionalElement: aSymbol type: aTypeSpec"	aSymbol &lt;Symbol&gt; element name	aTypeSpec &lt;Symbol | Asn1Type&gt; the element type"	^(self addElement: aSymbol type: aTypeSpec)		optional: true;		yourself</body><body package="ASN1-Types">addOptionalElement: aSymbol type: aTypeSpec tag: anInteger"	aSymbol &lt;Symbol&gt; element name	aTypeSpec &lt;Symbol | Asn1Type&gt; the element type	anInteger &lt;SmallInteger&gt; assign context-specific tag to the element"	^(self addElement: aSymbol type: aTypeSpec tag: anInteger)		optional: true;		yourself</body><body package="ASN1-Types">addOptionalElement: aSymbol type: aTypeSpec tag: anInteger tagging: aMode"	aSymbol &lt;Symbol&gt; element name	aTypeSpec &lt;Symbol | Asn1Type&gt; the element type	anInteger &lt;SmallInteger&gt; assign context-specific tag to the element	aMode &lt;Symbol&gt; set specific tagging mode for this element (#implict | #explicit)"	^(self addElement: aSymbol type: aTypeSpec tag: anInteger tagging: aMode)		optional: true;		yourself</body></methods><methods><class-id>ASN1.MappableType</class-id> <category>testing</category><body package="ASN1-Types">isMappable	^true</body></methods><methods><class-id>ASN1.MappableType</class-id> <category>initialize-release</category><body package="ASN1-Types">initialize	super initialize.	mapping := nil</body></methods><methods><class-id>ASN1.MappableType</class-id> <category>validation</category><body package="ASN1-Types">permits: anObjectOrAsn1Struct	"... used when marshaling Asn1Structs or mapped user classes as SEQUENCEs.  Ensures that the argument contains all of the minimally required element type symbols.  The phrasing implicitly requires that the argument have selectors for all OPTIONALs and DEFAULTs."	(mapping notNil and: [ anObjectOrAsn1Struct class == mapping ]) ifTrue: [ ^true ].	^	(super permits: anObjectOrAsn1Struct)		and: [ ( anObjectOrAsn1Struct class == Struct )				ifTrue:	[ (self requiredSymbols - anObjectOrAsn1Struct accessKeys) isEmpty ]				ifFalse:	[ self requiredSymbols allSatisfy: [ :sym |						anObjectOrAsn1Struct class canUnderstand: sym ] ] ]</body></methods><methods><class-id>ASN1.SET</class-id> <category>private</category><body package="ASN1-Types">clearPredicates	super clearPredicates.	decodingDictionary := encodingDictionary := nil</body><body package="ASN1-Types">setDecodingDictionary	| dict |	dict := Dictionary new: elements size.	elements do: [ :ele | dict add: ( ( ele tagBER bitAnd: 02r00011111 ) -&gt; ele ) ].	^decodingDictionary := dict</body><body package="ASN1-Types">setEncodingDictionary	| dict |	dict := Dictionary new: elements size.	elements do: [ :ele | dict add: ele symbol -&gt; ele ].	^encodingDictionary := dict</body></methods><methods><class-id>ASN1.SET</class-id> <category>accessing</category><body package="ASN1-Types">decodingDictionary	^( decodingDictionary isNil )		ifTrue:	[ self setDecodingDictionary ]		ifFalse:	[ decodingDictionary ]</body><body package="ASN1-Types">encodingDictionary	^( encodingDictionary isNil )		ifTrue:	[ self setEncodingDictionary ]		ifFalse:	[ encodingDictionary ]</body></methods><methods><class-id>ASN1.SET</class-id> <category>configuration api</category><body package="ASN1-Types">addElement: anAsn1AbstractElement	| result |	result := super addElement: anAsn1AbstractElement.	self class validate: self.	^result</body></methods><methods><class-id>ASN1.SET class</class-id> <category>defaults</category><body package="ASN1-Types">defaultSymbol	^#'SET'</body></methods><methods><class-id>ASN1.SET class</class-id> <category>validation</category><body package="ASN1-Types">validate: anAsn1TypeSET	"SET elements must have unique tags."	| s |	s := ( anAsn1TypeSET elements collect: [ :x | x tagBER ] ) asSet.	( s size =  anAsn1TypeSET elements size )		ifFalse:	[ ^InvalidTypeSpecification raiseSignal: (#SetElementsMustHaveUniqueTags &lt;&lt; #asn1 &gt;&gt; 'Asn1TypeSET elements must have unique tags!') ]</body></methods><methods><class-id>ASN1.BIT_STRING class</class-id> <category>defaults</category><body package="ASN1-Types">defaultConstraintValue	^BlockConstraint		with: [ :x | x class == BIT_STRING ]</body><body package="ASN1-Types">defaultSymbol	^#'BIT STRING'</body></methods><methods><class-id>ASN1.GraphicString class</class-id> <category>defaults</category><body package="ASN1-Types">defaultSymbol	^#'GraphicString'</body></methods><methods><class-id>ASN1.INTEGER</class-id> <category>printing</category><body package="ASN1-Types">fullPrintOn: aStream	super fullPrintOn: aStream.	self printIdentifiersOn: aStream</body><body package="ASN1-Types">printIdentifiersOn: aStream	self identifiers isEmpty ifTrue: [^self].	aStream nextPutAll: ' { '.	self identifiers keys		do: [ :id | aStream nextPutAll: id;				nextPut: $(;				print: (self identifiers at: id);				nextPut: $) ]		separatedBy: [ aStream nextPutAll: ', ' ].	aStream nextPutAll: ' }'.</body><body package="ASN1-Types">shortPrintOn: aStream	super shortPrintOn: aStream.	self printIdentifiersOn: aStream</body></methods><methods><class-id>ASN1.INTEGER</class-id> <category>accessing</category><body package="ASN1-Types">identifiers	^identifiers ifNil: [ identifiers := Dictionary new ]</body><body package="ASN1-Types">identifiers: aMap"	aMap &lt; (Dictionary key: Symbol value: Integer) | (Collection of: (Association key: Symbol value: Integer)) &gt;"	(aMap isKindOf: Dictionary)		ifTrue: [ aMap keysAndValuesDo: [ :id :val | self identify: val as: id ] ]		ifFalse: [ aMap do: [ :asc | self identify: asc value as: asc key ] ]</body><body package="ASN1-Types">identify: anInteger as: aSymbol	(self permits: anInteger)		ifTrue: [ self identifiers at: aSymbol put: anInteger ]		ifFalse: [ InvalidTypeSpecification new				messageText: (					#ValueNotPermissible1p &lt;&lt; #asn1 &gt;&gt; 'Value &lt;1p&gt; is not permissible for this type!'						expandMacrosWith: anInteger);				parameter: anInteger;				raise ]</body></methods><methods><class-id>ASN1.INTEGER class</class-id> <category>defaults</category><body package="ASN1-Types">defaultConstraintValue	^BlockConstraint		with: [ :x | x isKindOf: Integer ]</body><body package="ASN1-Types">defaultSymbol	^#'INTEGER'</body></methods><methods><class-id>ASN1.SET_OF class</class-id> <category>defaults</category><body package="ASN1-Types">defaultConstraintValue	^BlockConstraint		with: [ :x | x class == OrderedCollection ]</body><body package="ASN1-Types">defaultSymbol	^#'SET OF'</body></methods><methods><class-id>ASN1.ENUMERATED</class-id> <category>accessing - elements</category><body package="ASN1-Types">elementAtIndex: anInteger	^self elements at: anInteger</body><body package="ASN1-Types">elementWithInteger: anInteger	^self elements detect: [ :x | x integer = anInteger ] ifNone: []</body><body package="ASN1-Types">elementWithSymbol: aSymbol	^self elements detect: [ :x | x symbol = aSymbol ] ifNone: []</body></methods><methods><class-id>ASN1.ENUMERATED</class-id> <category>accessing</category><body package="ASN1-Types">add: anElement	| element |	element := anElement asAsn1EnumerationElement.	element isExtensionMarker ifTrue: [ ^self addExtensionMarker ].	complete := false.	^elements addLast: element.</body><body package="ASN1-Types">addExtensionMarker	^extensibleAt		ifNil: [ extensibleAt := elements size ]		ifNotNil: [ InvalidTypeSpecification new				messageText: (					#EnumSingleExtMarker1s &lt;&lt; #asn1 &gt;&gt; 'Only one extension marker is allowed in ENUMERATED &lt;1s&gt;!'						expandMacrosWith: self name);				parameter: self;				raise ]</body><body package="ASN1-Types">elements	self ensureComplete.	^elements</body><body package="ASN1-Types">elements: aSequenceableCollection	aSequenceableCollection do: [ :x | self add: x ]</body><body package="ASN1-Types">extensibleAt	^extensibleAt</body><body package="ASN1-Types">useEnumeration	^useEnumeration ifNil: [ self class defaultUseEnumeration ]</body><body package="ASN1-Types">useEnumeration: aBoolean"	aBoolean &lt;Boolean&gt; should wrap unmarshaled values in Enumeration instances ?"	useEnumeration := aBoolean</body></methods><methods><class-id>ASN1.ENUMERATED</class-id> <category>printing</category><body package="ASN1-Types">fullPrintOn: aStream	super fullPrintOn: aStream.	self printElementsOn: aStream</body><body package="ASN1-Types">printElementsOn: aStream	aStream nextPutAll: ' { '.	(1 to: (self extensibleAt ifNil: [ elements size ]))		do: [ :i | (elements at: i) shortPrintOn: aStream ]		separatedBy: [ aStream nextPutAll: ', ' ].	self extensibleAt ifNotNil: [ :m |		aStream nextPutAll: ', ..., '.		(m + 1 to: elements size)			do: [ :i | (elements at: i) shortPrintOn: aStream ]			separatedBy: [ aStream nextPutAll: ', ' ] ].	aStream nextPutAll: ' }'.</body><body package="ASN1-Types">shortPrintOn: aStream	super shortPrintOn: aStream.	self printElementsOn: aStream</body></methods><methods><class-id>ASN1.ENUMERATED</class-id> <category>initialize-release</category><body package="ASN1-Types">initialize	super initialize.	complete := true.	elements := OrderedCollection new: 7.</body></methods><methods><class-id>ASN1.ENUMERATED</class-id> <category>private</category><body package="ASN1-Types">ensureComplete"Make sure that elements that don't have explicitly specified value are auto-numbered.The root elements (before an extension marker) have different numbering rules than additional elements (after an extension marker)."	| counter root taken |	complete ifTrue: [^self].	"The root elements (before an extension marker) have simple numbering rules"	root := self extensibleAt ifNil: [ elements ] ifNotNil: [ :i | elements copyFrom: 1 to: i ].	taken := root inject: Set new into: [ :set :e |			e isExplicit ifTrue: [				(set includes: e value)					ifTrue: [ ^self errorValueNotUnique: e ]					ifFalse: [ set add: e value ] ].			set ].	counter := 0.	[ taken includes: counter ] whileTrue: [ counter := counter + 1].	root do: [ :e |		e isExplicit ifFalse: [			e setValue: counter.			[ counter := counter + 1. taken includes: counter ] whileTrue ] ].	"Now process any additional elements (after an extension marker"	self extensibleAt ifNotNil: [ :i || additional |		additional := elements copyFrom: i + 1 to: elements size.		additional do: [ :e |			e explicit				ifTrue: [ (taken includes: e value) ifTrue: [						^self errorValueNotUnique: e ].					taken add: e value.					e value &lt; counter						ifTrue: [ ^self errorInvalidValue: e ]						ifFalse: [ counter := e value ] ]				ifFalse: [ e setValue: counter ].			[ counter := counter + 1. taken includes: counter ] whileTrue ] ].	complete := true</body><body package="ASN1-Types">errorInvalidValue: anElement	^InvalidTypeSpecification new		messageText: (			#EnumInvalidValue1p2s3s &lt;&lt; #asn1 &gt;&gt; 'Value &lt;1p&gt; assigned to &lt;2s&gt; in ENUMERATED &lt;3s&gt; is not valid!'				expandMacrosWith: anElement value with: anElement identifier with: self name);		parameter: anElement;		raise</body><body package="ASN1-Types">errorValueNotUnique: anElement	^InvalidTypeSpecification new		messageText: (			#EnumNotUniqueValues1p2s3s &lt;&lt; #asn1 &gt;&gt; 'Value &lt;1p&gt; assigned to &lt;2s&gt; in ENUMERATED &lt;3s&gt; is not unique!'				expandMacrosWith: anElement value with: anElement identifier with: self name);		parameter: anElement;		raise</body><body package="ASN1-Types">errorValuesNotUnique	^InvalidTypeSpecification new		messageText: (			#EnumValuesNotUnique &lt;&lt; #asn1 &gt;&gt; 'Assigned values in ENUMERATED &lt;1s&gt; are not unique !'				expandMacrosWith: self name);		raise</body></methods><methods><class-id>ASN1.ENUMERATED</class-id> <category>testing</category><body package="ASN1-Types">includes: aValue"Is the value specified as either a symbol or an integer included in the receiver ?	aValue &lt;Symbol | Integer&gt;	^&lt;Boolean&gt;"	^self elements anySatisfy: [ :e | e permits: aValue ]</body><body package="ASN1-Types">isExtensible	"Indicates whether the type may be extended in revisions of an originating ASN.1 type specifciation and include an ASN.1 extension marker."	^self extensibleAt notNil</body></methods><methods><class-id>ASN1.ENUMERATED</class-id> <category>validation</category><body package="ASN1-Types">permits: anObject	^	(super permits: anObject)		and: [ self includes: anObject ]</body></methods><methods><class-id>ASN1.ENUMERATED class</class-id> <category>defaults</category><body package="ASN1-Types">defaultConstraintValue	^BlockConstraint with: [ :x | x isSymbol or: [ x isKindOf: Integer ] ]</body><body package="ASN1-Types">defaultSymbol	^#'ENUMERATED'</body><body package="ASN1-Types">defaultUseEnumeration	^defaultUseEnumeration ifNil: [ self defaultUseEnumerationValue ]</body><body package="ASN1-Types">defaultUseEnumeration: aBoolean"	aBoolean &lt;Boolean&gt; should enumerations unmarshal as Enumeration instances by default ?"	defaultUseEnumeration := aBoolean</body><body package="ASN1-Types">defaultUseEnumerationValue	^true</body></methods><methods><class-id>ASN1.OCTET_STRING class</class-id> <category>defaults</category><body package="ASN1-Types">defaultConstraintValue	^BlockConstraint		with: [ :x | x isKindOf: ByteArray ]</body><body package="ASN1-Types">defaultSymbol	^#'OCTET STRING'</body></methods><methods><class-id>ASN1.TypeReference</class-id> <category>type construction</category><body package="ASN1-Types">named: aSymbol	^(SubType name: aSymbol)		parent: self</body><body package="ASN1-Types">named: aSymbol in: aModule	^(SubType name: aSymbol in: aModule)		parent: self</body></methods><methods><class-id>ASN1.TypeReference</class-id> <category>testing</category><body package="ASN1-Types">isTypeReference	^true</body></methods><methods><class-id>ASN1.TypeReference</class-id> <category>printing</category><body package="ASN1-Types">printOn: aStream	aStream nextPutAll: (module name ifNil: ['']);		nextPut: $.;		nextPutAll: self name</body></methods><methods><class-id>ASN1.TypeReference</class-id> <category>redirection / tree patching</category><body package="ASN1-Types">doesNotUnderstand: aMessage	| type |	type := module find: symbol ifAbsent: [nil].	(type isNil or: [ type == self ]) ifTrue: [		^InvalidTypeReference new			messageText: (#UnknownType1s2s &lt;&lt; #asn1 &gt;&gt; 'Unknown ASN.1 type &lt;1s&gt;.&lt;2s&gt;!'							expandMacrosWith: (module name ifNil: [ 'nil' ])							with: symbol);			parameter: self;			raise ].	self oneWayBecome: type.	^type perform: aMessage selector withArguments: aMessage arguments</body></methods><methods><class-id>ASN1.TypeReference</class-id> <category>private</category><body package="ASN1-Types">usedInElement: element"Callback from the element that uses the type, allows for any additional activity for proper hook-up to the containting type,necessary for example for ANY DEFINED BY type of construct."</body></methods><methods><class-id>ASN1.TypeReference class</class-id> <category>instance creation</category><body package="ASN1-Types">name: aSymbol	^self new		name: aSymbol;		yourself</body><body package="ASN1-Types">name: aSymbol in: aModule	^(self name: aSymbol)		module: aModule;		yourself</body><body package="ASN1-Types">symbol: aSymbol	^( super new )		symbol: aSymbol;		yourself</body><body package="ASN1-Types">symbol: aSymbol in: aModule	^(self symbol: aSymbol)		module: aModule;		yourself</body></methods><methods><class-id>ASN1.PrintableString class</class-id> <category>defaults</category><body package="ASN1-Types">defaultConstraintValue	| charset |	charset := Set new: 74.	charset addAll: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.	charset addAll: 'abcdefghijklmnopqrstuvwxyz'.	charset addAll: '0123456789'.	charset add: Character space.	charset addAll: '''()+,-./:=?'.	^AlphabetConstraint		with: ( ValueUnionConstraint				withAll: charset )</body><body package="ASN1-Types">defaultSymbol	^#'PrintableString'</body></methods><methods><class-id>ASN1.GeneralString class</class-id> <category>defaults</category><body package="ASN1-Types">defaultSymbol	^#'GeneralString'</body></methods><methods><class-id>ASN1.RELATIVE_OID class</class-id> <category>defaults</category><body package="ASN1-Types">defaultSymbol	^#'RELATIVE-OID'</body></methods><methods><class-id>ASN1.GeneralizedTime class</class-id> <category>defaults</category><body package="ASN1-Types">defaultConstraintValue	^BlockConstraint		with: [ :x | x class == Timestamp ]</body><body package="ASN1-Types">defaultSymbol	^#'GeneralizedTime'</body></methods><methods><class-id>ASN1.Enumeration</class-id> <category>accessing - translational</category><body package="ASN1-Types">_integer	^object</body><body package="ASN1-Types">_symbol	^( type elementWithInteger: object ) symbol</body></methods><methods><class-id>ASN1.Enumeration</class-id> <category>conversion</category><body package="ASN1-Types">asAsn1Enumeration: anENUMERATED	^anENUMERATED == type		ifTrue: [ self ]		ifFalse: [ Enumeration type: anENUMERATED value: object ]</body></methods><methods><class-id>ASN1.Enumeration class</class-id> <category>instance creation</category><body package="ASN1-Types">type: anENUMERATED symbol: aSymbol	^(anENUMERATED elementWithSymbol: aSymbol)		ifNil: [ TypeRealizationError new				messageText: (					#InvalidEnumeration1p2p &lt;&lt; #asn1 &gt;&gt; 'Symbol &lt;1p&gt; is not valid element of ENUMERATED &lt;2p&gt;!'						expandMacrosWith: aSymbol with: anENUMERATED);				parameter: anENUMERATED;				raise ]		ifNotNil: [ :e | self new _type: anENUMERATED; _value: e integer; yourself ]</body></methods><methods><class-id>ASN1.BMPString class</class-id> <category>defaults</category><body package="ASN1-Types">defaultSymbol	^#'BMPString'</body></methods><methods><class-id>ASN1.Choice</class-id> <category>private</category><body package="ASN1-Types">_isEqualType: aTypeWrapper	^(super _isEqualType: aTypeWrapper) and: [	aTypeWrapper _isChoice not or: [ choice equals: aTypeWrapper _choice ] ]</body></methods><methods><class-id>ASN1.Choice</class-id> <category>accessing</category><body package="ASN1-Types">_choice	^choice</body><body package="ASN1-Types">_choice: aChoiceElement	choice :=  aChoiceElement</body><body package="ASN1-Types">_symbol	^choice symbol</body><body package="ASN1-Types">_tag	^choice tag ifNil: [ choice type tagBER ]</body></methods><methods><class-id>ASN1.Choice</class-id> <category>testing</category><body package="ASN1-Types">_isChoice	^true</body></methods><methods><class-id>ASN1.Choice</class-id> <category>printing</category><body package="ASN1-Types">printOn: aStream	aStream		print: type;		nextPut: $&lt;.	self shortPrintOn: aStream.	aStream nextPut: $&gt;</body><body package="ASN1-Types">shortPrintOn: aStream	aStream		nextPutAll: self _symbol;		nextPut: $:;		print: object</body></methods><methods><class-id>ASN1.Choice class</class-id> <category>instance creation</category><body package="ASN1-Types">type: anAsn1Type choice: anElement value: anObject	^self new		_type: anAsn1Type;		_choice: anElement;		_value: anObject;		yourself</body><body package="ASN1-Types">type: aCHOICE choiceSymbol: aSymbol value: anObject	^(aCHOICE elementWithSymbol: aSymbol)		ifNil: [ TypeRealizationError new				messageText: (					#IncompatibleChoiceAlternative1p2p &lt;&lt; #asn1 &gt;&gt; 'Object &lt;1p&gt; is not compatible with CHOICE alternative &lt;2p&gt;!'						expandMacrosWith: anObject with: aSymbol);				parameter: aCHOICE;				raise ]		ifNotNil: [ :e |			self 	type: aCHOICE				choice: e				value: anObject ]</body><body package="ASN1-Types">type: aCHOICE choiceTag: anInteger value: anObject	^(aCHOICE elementWithTag: anInteger)		ifNil: [ TypeRealizationError new				messageText: (					#IncompatibleChoiceTag1p2p &lt;&lt; #asn1 &gt;&gt; 'Object &lt;1p&gt; is not compatible with CHOICE tag &lt;2p&gt;!'						expandMacrosWith: anObject with: anInteger);				parameter: aCHOICE;				raise ]		ifNotNil: [ :e |			self 	type: aCHOICE				choice: e				value: anObject ]</body><body package="ASN1-Types">type: aCHOICE value: anObject	^(aCHOICE elementPermitting: anObject)		ifNil: [ TypeRealizationError new				messageText: (					#IncompatibleChoice1p2p &lt;&lt; #asn1 &gt;&gt; 'Object &lt;1p&gt; is not compatible with CHOICE &lt;2p&gt;!'						expandMacrosWith: anObject with: aCHOICE);				parameter: aCHOICE;				raise ]		ifNotNil: [ :e |			self 	type: aCHOICE				choice: e				value: anObject ]</body></methods><methods><class-id>ASN1.NumericString class</class-id> <category>defaults</category><body package="ASN1-Types">defaultConstraintValue	| charset |	charset := Set new: 11.	charset addAll: '0123456789'.	charset add: Character space.	^AlphabetConstraint		with: ( ValueUnionConstraint				withAll: charset )</body><body package="ASN1-Types">defaultSymbol	^#'NumericString'</body></methods><methods><class-id>ASN1.MarkerElement</class-id> <category>testing</category><body package="ASN1-Types">isMarker	^true</body></methods><methods><class-id>ASN1.ExceptionMarker</class-id> <category>accessing</category><body package="ASN1-Types">integer	^integer</body><body package="ASN1-Types">integer: anInteger	integer := anInteger</body><body package="ASN1-Types">symbol	^symbol</body><body package="ASN1-Types">symbol: aSymbol	symbol := aSymbol</body></methods><methods><class-id>ASN1.ExceptionMarker</class-id> <category>testing</category><body package="ASN1-Types">isExceptionMarker	^true</body></methods><methods><class-id>ASN1.ExceptionMarker</class-id> <category>comparing</category><body package="ASN1-Types">equals: anObject"Implements 'structural equivalence' in the spirit of 'type compatibility' described in the ASN.1 semantic model (Dubuisson p.121)."	^( super equals: anObject )		and: [ ( anObject integer = integer )			and: [ anObject symbol = symbol ] ]</body></methods><methods><class-id>ASN1.ExceptionMarker class</class-id> <category>instance creation</category><body package="ASN1-Types">integer: anInteger symbol: aSymbol	^( self new )		integer: anInteger;		symbol: aSymbol;		yourself</body><body package="ASN1-Types">symbol: aSymbol integer: anInteger	^( self new )		integer: anInteger;		symbol: aSymbol;		yourself</body></methods><methods><class-id>ASN1.ObjectDescriptor class</class-id> <category>defaults</category><body package="ASN1-Types">defaultSymbol	^#'ObjectDescriptor'</body></methods><methods><class-id>ASN1.SubType</class-id> <category>printing</category><body package="ASN1-Types">fullPrintOn: aStream	self name ifNotNil: [ :n | aStream nextPutAll: n; nextPutAll: ' ::= ' ].	self tag ifNotNil: [		aStream nextPut: $[;			print: self tag;			nextPut: $].		self tagging ifNotNil: [			aStream space;				nextPutAll: self tagging asString asUppercase ].		aStream space ].	aStream nextPutAll: parent name.	self constraint isNull ifFalse: [		aStream nextPutAll: ' ('.		self constraint shortPrintOn: aStream.		aStream nextPut: $) ]</body><body package="ASN1-Types">shortPrintOn: aStream	self tag ifNotNil: [		aStream nextPut: $[;			print: self tag;			nextPut: $].		self tagging ifNotNil: [			aStream space;				nextPutAll: self tagging asString asUppercase ].		aStream space ].	self name		ifNil: [ aStream nextPutAll: parent name ]		ifNotNil: [ :n | aStream nextPutAll: n ].	self constraint isNull ifFalse: [		aStream nextPutAll: ' ('.		self constraint shortPrintOn: aStream.		aStream nextPut: $) ]</body></methods><methods><class-id>ASN1.SubType</class-id> <category>accessing</category><body package="ASN1-Types">parent	^parent</body><body package="ASN1-Types">parent: anAsn1Type	parent := anAsn1Type</body></methods><methods><class-id>ASN1.SubType</class-id> <category>testing</category><body package="ASN1-Types">matchesTag: anInteger	^tag ifNil: [ parent matchesTag: anInteger ]		ifNotNil: [ ((tag bitXor: anInteger) bitAnd: TagMaskNumber) isZero ]</body></methods><methods><class-id>ASN1.SubType</class-id> <category>comparing</category><body package="ASN1-Types">equals: anObject"Implements 'structural equivalence' in the spirit of 'type compatibility' described in the ASN.1 semantic model (Dubuisson p.121)."	^	self == anObject	"Do not waste time comparing structure if we're identical."		or: [	( super equals: anObject )			and: [ self parent equals: anObject parent ] ]</body></methods><methods><class-id>ASN1.SubType</class-id> <category>validation</category><body package="ASN1-Types">permits: anObject	^	(self parent permits: anObject)		and: [self constraint permits: anObject ]</body></methods><methods><class-id>ASN1.REAL class</class-id> <category>defaults</category><body package="ASN1-Types">defaultConstraintValue	^BlockConstraint		with: [ :x | x isKindOf: LimitedPrecisionReal ]</body><body package="ASN1-Types">defaultSymbol	^#'REAL'</body></methods><methods><class-id>ASN1.ANY</class-id> <category>testing</category><body package="ASN1-Types">isImplicitlyTagged	^false</body><body package="ASN1-Types">matchesTag: anInteger	^tag ifNil: [ (TagMaskClass bitAnd: anInteger) = UniversalClass ]		ifNotNil: [ ((tag bitXor: anInteger) bitAnd: TagMaskNumber) isZero ]</body></methods><methods><class-id>ASN1.ANY</class-id> <category>accessing</category><body package="ASN1-Types">at: key	^self typeMap at: key</body><body package="ASN1-Types">at: key ifAbsent: aBlock	^self typeMap at: key ifAbsent: aBlock</body><body package="ASN1-Types">at: key put: aType	^self typeMap at: key put: aType</body><body package="ASN1-Types">definedBy	^definedBy</body><body package="ASN1-Types">definedBy: anElement	definedBy := anElement</body><body package="ASN1-Types">removeKey: key	^self typeMap removeKey: key</body><body package="ASN1-Types">typeMap	^typeMap ifNil: [ typeMap := Dictionary new ]</body></methods><methods><class-id>ASN1.ANY</class-id> <category>private</category><body package="ASN1-Types">usedInElement: element"Callback from the element that uses the type, allows for any additional activity for proper hook-up to the containting type,necessary for example for ANY DEFINED BY type of construct."	definedBy ifNotNil: [		definedBy := element owner elementWithSymbol: definedBy asSymbol ]</body></methods><methods><class-id>ASN1.ANY</class-id> <category>printing</category><body package="ASN1-Types">shortPrintOn: aStream	super shortPrintOn: aStream.	definedBy ifNotNil: [		aStream			nextPutAll: ' DEFINED BY '; 			nextPutAll: definedBy symbol ]</body></methods><methods><class-id>ASN1.ANY class</class-id> <category>defaults</category><body package="ASN1-Types">defaultSymbol	^#ANY</body></methods><methods><class-id>ASN1.ANY class</class-id> <category>instance creation</category><body package="ASN1-Types">definedBy: aSymbol	^self new definedBy: aSymbol; yourself</body></methods><methods><class-id>ASN1.OBJECT_IDENTIFIER</class-id> <category>accessing</category><body package="ASN1-Types">retainEncoding	^false</body><body package="ASN1-Types">retainEncoding: aBoolean	"... intentionally null.  ASN.1 OBJECT_IDENTIFIERS should never retain encodings using the mechanism employed in Asn1Structs or mapped classes and should always retain them using their native mechanism because they very frequently recur in any sustained interoperation, and they account for a significant part of the marshaling budget.  Optimizing the marshaling of ASN.1 OIDs rarely, if ever, fails to have a significant pay off.  And, the closer their Smalltalk representation is to their encoding, the better the pay off will be."</body></methods><methods><class-id>ASN1.OBJECT_IDENTIFIER class</class-id> <category>defaults</category><body package="ASN1-Types">defaultConstraintValue	^BlockConstraint		with: [ :x | x class == ObjectIdentifier ]</body><body package="ASN1-Types">defaultSymbol	^#'OBJECT IDENTIFIER'</body></methods><methods><class-id>ASN1.UniversalString class</class-id> <category>defaults</category><body package="ASN1-Types">defaultSymbol	^#'UniversalString'</body></methods><methods><class-id>ASN1.UTF8String class</class-id> <category>defaults</category><body package="ASN1-Types">defaultSymbol	^#'UTF8String'</body></methods><methods><class-id>ASN1.SEQUENCE</class-id> <category>comparing</category><body package="ASN1-Types">hasEqualElementsWith: anObject	^	( anObject elements size = self elements size ) and: [			anObject elements with: self elements do: [ :e1 :e2 |				(e1 equals: e2) ifFalse: [ ^false ] ].			true ]</body></methods><methods><class-id>ASN1.SEQUENCE class</class-id> <category>defaults</category><body package="ASN1-Types">defaultSymbol	^#'SEQUENCE'</body></methods><methods><class-id>ASN1.CHOICE</class-id> <category>accessing</category><body package="ASN1-Types">tags	^( tags isNil )		ifTrue:	[ self setTags ]		ifFalse:	[ tags ]</body><body package="ASN1-Types">useChoice	^useChoice ifNil: [ self class defaultUseChoice ]</body><body package="ASN1-Types">useChoice: aBoolean"	aBoolean	&lt;Boolean&gt; should wrap unmarshaled values in Choice instances ?"	useChoice := aBoolean</body></methods><methods><class-id>ASN1.CHOICE</class-id> <category>private</category><body package="ASN1-Types">clearPredicates	super clearPredicates.	tags := nil</body><body package="ASN1-Types">newElement	^ChoiceElement new</body><body package="ASN1-Types">setTags	"... sweat to avoid a 'grow'."	| s |	s := Set new: ( elements size * 3 // 2 ).	elements do: [ :e | ( e isExtensionMarker ) ifFalse: [ s add: e tagBER ] ].	^tags := s</body></methods><methods><class-id>ASN1.CHOICE</class-id> <category>testing</category><body package="ASN1-Types">isImplicitlyTagged	^false</body><body package="ASN1-Types">matchesTag: anInteger	^tag ifNil: [ elements anySatisfy: [ :e | e matchesTag: anInteger ] ]		ifNotNil: [ ((tag bitXor: anInteger) bitAnd: TagMaskNumber) isZero ]</body></methods><methods><class-id>ASN1.CHOICE</class-id> <category>validation</category><body package="ASN1-Types">permits: anObject	^(super permits: anObject)	and: [ elements anySatisfy: [ :e | e permits: anObject ] ]</body></methods><methods><class-id>ASN1.CHOICE</class-id> <category>accessing - elements</category><body package="ASN1-Types">elementPermitting: anObject	^elements detect: [ :e | e permits: anObject ] ifNone: [ nil ]</body></methods><methods><class-id>ASN1.CHOICE class</class-id> <category>defaults</category><body package="ASN1-Types">defaultSymbol	^#'CHOICE'</body><body package="ASN1-Types">defaultUseChoice	^defaultUseChoice ifNil: [ self defaultUseChoiceValue ]</body><body package="ASN1-Types">defaultUseChoice: aBoolean"	aBoolean &lt;Boolean&gt; should choices unmarshal as Choice instances by default ?"	defaultUseChoice := aBoolean</body><body package="ASN1-Types">defaultUseChoiceValue	^true</body></methods><methods><class-id>ASN1.StructureElement</class-id> <category>accessing</category><body package="ASN1-Types">default	^default</body><body package="ASN1-Types">default: anObject	default := anObject</body><body package="ASN1-Types">optional	^optional</body><body package="ASN1-Types">optional: aBoolean	optional := aBoolean</body></methods><methods><class-id>ASN1.StructureElement</class-id> <category>decoding</category><body package="ASN1-Types">mutator	^(self accessor copyWith: $:) asSymbol</body></methods><methods><class-id>ASN1.StructureElement</class-id> <category>printing</category><body package="ASN1-Types">shortPrintOn: aStream	super shortPrintOn: aStream.	self optional ifTrue: [		aStream nextPutAll: ' OPTIONAL' ].	self hasDefault ifTrue: [		aStream nextPutAll: ' DEFAULT ';			print: self default ]</body></methods><methods><class-id>ASN1.StructureElement</class-id> <category>testing</category><body package="ASN1-Types">hasDefault	^default notNil</body><body package="ASN1-Types">hasDefaultOrIsOptional	^default notNil or: [ optional ]</body><body package="ASN1-Types">isOptional	^optional</body></methods><methods><class-id>ASN1.StructureElement</class-id> <category>encoding</category><body package="ASN1-Types">accessor"ASN.1 allows dashes in element names.  All element names should begin with a lower-case letter, so we do not do more than the following"	^(	( symbol includes: $- )			ifTrue: [ symbol copyReplaceAll: '-' with: '_' ]			ifFalse: [ symbol ]	) asSymbol</body></methods><methods><class-id>ASN1.StructureElement</class-id> <category>initialize-release</category><body package="ASN1-Types">initialize	super initialize.	optional := false</body></methods><methods><class-id>ASN1.StructureElement</class-id> <category>comparing</category><body package="ASN1-Types">equals: anObject"Implements 'structural equivalence' in the spirit of 'type compatibility' described in the ASN.1 semantic model (Dubuisson p.121)."	^( super equals: anObject )		and: [ anObject optional = optional 			and: [ anObject default = default ] ]</body></methods><methods><class-id>ASN1.StructureElement class</class-id> <category>validation</category><body package="ASN1-Types">validate: anAsn1Element	( anAsn1Element optional and: [ anAsn1Element default notNil ] )		ifTrue:	[ ^InvalidTypeSpecification raiseSignal: (#InvalidElementSpecification &lt;&lt; #asn1 &gt;&gt; 'ASN.1 type elements may not be both OPTIONAL and have a DEFAULT value!') ]</body></methods><methods><class-id>ASN1.ExtensionMarker</class-id> <category>protocol compatibility</category><body package="ASN1-Types">integer	^nil</body><body package="ASN1-Types">symbol	^nil</body></methods><methods><class-id>ASN1.ExtensionMarker</class-id> <category>testing</category><body package="ASN1-Types">isExtensionMarker	^true</body></methods><methods><class-id>ASN1.ExtensionMarker</class-id> <category>converting</category><body package="ASN1-Types">asAsn1EnumerationElement	^self</body></methods><methods><class-id>ASN1.ExtensionMarker</class-id> <category>As yet unclassified</category><body package="ASN1-Types">shortPrintOn: aStream	aStream nextPutAll: '...'</body></methods><methods><class-id>ASN1.ExtensionMarker class</class-id> <category>instance creation</category><body package="ASN1-Types">default	^self new</body><body package="ASN1-Types">new	^( default isNil )		ifTrue:	[ default := super new ]		ifFalse:	[ default ]</body></methods><methods><class-id>Core.Integer</class-id> <category>ASN.1</category><body package="ASN1-Types">asAsn1Enumeration: anENUMERATED	^ASN1.Enumeration type: anENUMERATED value: self</body></methods><methods><class-id>ASN1.Module</class-id> <category>definitions</category><body package="ASN1-Types">ANY: aSymbol	^ANY name: aSymbol in: self</body><body package="ASN1-Types">BIT_STRING: aSymbol	^BIT_STRING name: aSymbol in: self</body><body package="ASN1-Types">BMPString: aSymbol	^BMPString name: aSymbol in: self</body><body package="ASN1-Types">BOOLEAN: aSymbol	^BOOLEAN name: aSymbol in: self</body><body package="ASN1-Types">CHOICE: aSymbol	^CHOICE name: aSymbol in: self</body></methods><methods><class-id>ASN1.Module</class-id> <category>private</category><body package="ASN1-Types">doesNotUnderstand: aMessage"Allow finding a type by using its name as a message to the module instance.Allow using a name of an already existing type as a single keyword message, to mimic behavior of messages for standard types #SEQUENCE:, #BOOLEAN:, etc"	| type |	aMessage selector first isUppercase ifFalse: [ ^super doesNotUnderstand: aMessage ].	aMessage arguments isEmpty ifTrue: [ ^self find: aMessage selector ].	aMessage arguments size &gt; 1 ifTrue: [ ^super doesNotUnderstand: aMessage ].	type := (aMessage selector asString copyWithout: $:) asSymbol.	type := self find: type ifAbsent: [ ^super doesNotUnderstand: aMessage ].	^type named: aMessage arguments first in: self</body></methods><methods><class-id>ASN1.Module</class-id> <category>definitions</category><body package="ASN1-Types">ENUMERATED: aSymbol	^ENUMERATED name: aSymbol in: self</body></methods><methods><class-id>ASN1.Module</class-id> <category>services</category><body package="ASN1-Types">find: aSymbol"	aSymbol &lt;Symbol&gt; the name of the type	^&lt;Asn1Entity&gt;	"	^self find: aSymbol		ifAbsent: [ | defaultSymbol |			"Allow specifying basic types using the #defaultSymbol with spaces or underscores"			defaultSymbol := (aSymbol includes: $_)				ifTrue: [ (aSymbol asString replaceAll: $_ with: $ ) asSymbol ]				ifFalse: [ aSymbol ].			( Type allSubclasses				detect: [ :class | class isConcrete and: [ class defaultSymbol = defaultSymbol ] ]				ifNone: [ nil ]			)	ifNil: [ TypeReference name: aSymbol in: self ]				ifNotNil: [ :class |					(class inheritsFrom: BasicType) "only basic types can be referenced this way"						ifTrue: [ class new setModule: self ]						ifFalse: [ InvalidTypeReference new								messageText: (#InvalidType1s &lt;&lt; #asn1 &gt;&gt; '&lt;1s&gt; is not a valid type!'											expandMacrosWith: aSymbol);								parameter: aSymbol;								raise ] ] ]</body></methods><methods><class-id>ASN1.Module</class-id> <category>definitions</category><body package="ASN1-Types">GeneralizedTime: aSymbol	^GeneralizedTime name: aSymbol in: self</body><body package="ASN1-Types">GeneralString: aSymbol	^GeneralString name: aSymbol in: self</body><body package="ASN1-Types">GraphicString: aSymbol	^GraphicString name: aSymbol in: self</body><body package="ASN1-Types">IA5String: aSymbol	^IA5String name: aSymbol in: self</body><body package="ASN1-Types">INTEGER: aSymbol	^INTEGER name: aSymbol in: self</body></methods><methods><class-id>ASN1.Module</class-id> <category>services</category><body package="ASN1-Types">new: aTypeSpec named: aSymbol	^(self typeFrom: aTypeSpec) named: aSymbol in: self</body></methods><methods><class-id>ASN1.Module</class-id> <category>definitions</category><body package="ASN1-Types">NULL: aSymbol	^NULL name: aSymbol in: self</body><body package="ASN1-Types">NumericString: aSymbol	^NumericString name: aSymbol in: self</body><body package="ASN1-Types">OBJECT_IDENTIFIER: aSymbol	^OBJECT_IDENTIFIER name: aSymbol in: self</body><body package="ASN1-Types">OCTET_STRING: aSymbol	^OCTET_STRING name: aSymbol in: self</body><body package="ASN1-Types">PrintableString: aSymbol	^PrintableString name: aSymbol in: self</body><body package="ASN1-Types">SEQUENCE: aSymbol	^SEQUENCE name: aSymbol in: self</body><body package="ASN1-Types">SEQUENCE: aSymbol OF: aTypeSpec"	aSymbol &lt;Symbol&gt;	aTypeSpect &lt;Symbol | Asn1Type&gt;	^&lt;Asn1TypeSEQUENCE_OF&gt;"	^(SEQUENCE_OF name: aSymbol in: self)		elementType: aTypeSpec;		yourself</body><body package="ASN1-Types">SET: aSymbol	^SET name: aSymbol in: self</body><body package="ASN1-Types">SET: aSymbol OF: aTypeSpec"	aSymbol &lt;Symbol&gt;	aTypeSpect &lt;Symbol | Asn1Type&gt;	^&lt;Asn1TypeSET_OF&gt;"	^(SET_OF name: aSymbol in: self)		elementType: aTypeSpec;		yourself</body></methods><methods><class-id>ASN1.Module</class-id> <category>services</category><body package="ASN1-Types">typeFrom: aTypeSpec"Turn an acceptable form of type specification into the real type instance.	aTypeSpect &lt;Symbol | Asn1Type | Class&gt; a type name, or basic type #defaultSymbol or class, or the type instance itself	^&lt;Asn1Type&gt;"	"Allow specifying type with a type instance itself"	(aTypeSpec isKindOf: Type) ifTrue: [ ^aTypeSpec ].	"Allow specifying basic types using type class"	aTypeSpec isBehavior ifTrue: [ ^aTypeSpec new ].	"Otherwise expect a type name and look it up"	^self find: aTypeSpec</body></methods><methods><class-id>ASN1.Module</class-id> <category>definitions</category><body package="ASN1-Types">UniversalString: aSymbol	^UniversalString name: aSymbol in: self</body><body package="ASN1-Types">UTCTime: aSymbol	^UTCTime name: aSymbol in: self</body><body package="ASN1-Types">UTF8String: aSymbol	^UTF8String name: aSymbol in: self</body><body package="ASN1-Types">VisibleString: aSymbol	^VisibleString name: aSymbol in: self</body></methods><methods><class-id>Core.Association</class-id> <category>converting</category><body package="ASN1-Types">asAsn1EnumerationElement	"... assumes the key is aSymbol and the value is anInteger."	^ASN1.EnumerationElement		symbol: key		integer: value</body></methods><methods><class-id>ASN1.Struct</class-id> <category>testing</category><body package="ASN1-Types">_isTypeWrapper	^false</body></methods><methods><class-id>ASN1.Struct</class-id> <category>converting</category><body package="ASN1-Types">asAsn1Choice: aCHOICE"Simpler version of Choice constructor for unambiguous CHOICEs. If in doubt use #asAsnChoice:symbol: instead."	^ASN1.Choice		type: aCHOICE		value: self</body><body package="ASN1-Types">asAsn1Choice: aCHOICE symbol: choice	^Choice		type: aCHOICE		choiceSymbol: choice		value: self</body><body package="ASN1-Types">withAsn1Type: anAsn1Type	^ASN1.TypeWrapper		type: anAsn1Type		value: self</body></methods><methods><class-id>Core.Object</class-id> <category>ASN.1</category><body package="ASN1-Types">_isTypeWrapper	^false</body><body package="ASN1-Types">asAsn1Choice: aCHOICE"Simpler version of Choice constructor for unambiguous CHOICEs. If in doubt use #asAsnChoice:symbol: instead."	^ASN1.Choice		type: aCHOICE		value: self</body><body package="ASN1-Types">asAsn1Choice: aCHOICE symbol: choice	^ASN1.Choice		type: aCHOICE		choiceSymbol: choice		value: self</body><body package="ASN1-Types">withAsn1Type: anAsn1Type	^ASN1.TypeWrapper		type: anAsn1Type		value: self</body></methods><methods><class-id>Core.Symbol</class-id> <category>ASN.1</category><body package="ASN1-Types">asAsn1Enumeration: anENUMERATED	^ASN1.Enumeration type: anENUMERATED symbol: self</body></methods><methods><class-id>Core.Symbol</class-id> <category>converting</category><body package="ASN1-Types">asAsn1EnumerationElement	^ASN1.EnumerationElement symbol: self</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Asn1Error</name><environment>ASN1</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Support</package></attributes></class><class><name>Integer</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Entity</name><environment>ASN1</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>symbol module </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Support</package></attributes></class><class><name>Struct</name><environment>ASN1</environment><super>Protocols.Struct</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>encoding </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1-Support</category><attributes><package>ASN1-Support</package></attributes></class><class><name>Association</name><environment>Core</environment><super>Core.LookupKey</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Support</category><attributes><package>Collections-Support</package></attributes></class><class><name>Module</name><environment>ASN1</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name oid definitions exports imports tagging extensibility </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Support</package></attributes></class><class><name>MessageForwarder</name><environment>Protocols</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars>object </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Protocols-Common</category><attributes><package>Protocols-Common</package></attributes></class><class><name>Symbol</name><environment>Core</environment><super>Core.String</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class></st-source>