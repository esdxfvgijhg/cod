<?xml version="1.0"?><st-source><!-- Name: HTTPNotice: Copyright 1999-2017 Cincom Systems, Inc.  All rights reserved.Comment: HTTP support provides the ability to make connections to servers in order to request resources via the HTTP protocol, which is a superset of MIME.NTLM authentication is deprecated and NTLM related code is moved to /obsolete/Obsolete-HTTP parcel.	Attachment filenamesIt seems to be a widespread practice to encode filenames directly into the 'filename' parameter of the corresponding HTTP header field (e.g. many web browsers do that with filenames of uploaded files). This is technically a violation of the HTTP protocol, however in order to deal with the reality it is possible to suppress strict compliance by setting #defaultParameterValueEncoding on ValueWithParam class. If set, the specified encoding (e.g. #utf8) will be automatically applied to any parameter value in which we encounter raw non-ascii characters. Note that this is different from properly quoted, non-ascii values as in =?iso-8859-2?Q?Bo=BEidar=20?=. Here's an example with raw, utf8 encoded filename in cyrilics:	source := (ByteArray new withEncoding:  #iso8859_1) readWriteStream lineEndCRLF.	source nextPutAll: 'Content-Disposition: form-data; name="43"; filename= "'.	filename := 'F:\текст1.текст'.	source binary; nextPutAll: (filename asByteArrayEncoding: #utf8).	source text; nextPut: $".	source reset.	setting := ValueWithParams defaultParameterValueEncoding.	ValueWithParams defaultParameterValueEncoding: #utf8.		[	(Net.HeaderField 			readFrom: source			acceptNonAsciiCharacters: true		) fileName  	] ensure: [ ValueWithParams defaultParameterValueEncoding: setting ].DbIdentifier: bear73DbTrace: 499487DbUsername: tkoganDbVersion: 8.3 - 5DevelopmentPrerequisites: #(#(#any 'Compression-ZLib' '') #(#any 'MD5' '') #(#any 'MIME' '') #(#any 'Protocols-Common' '') #(#any 'NetClientBase' '') #(#any 'HashesBase' ''))PackageName: HTTPParcel: #('HTTP')ParcelName: HTTPPrerequisiteDescriptions: #(#(#name 'Compression-ZLib') #(#name 'MD5') #(#name 'MIME') #(#name 'Protocols-Common' #componentType #package) #(#name 'NetClientBase' #componentType #package) #(#name 'HashesBase' #componentType #package))PrerequisiteParcels: #(#('Compression-ZLib' '') #('MD5' '') #('MIME' '') #('Protocols-Common' '') #('NetClientBase' '') #('HashesBase' ''))PrintStringCache: (8.3 - 5,tkogan)Version: 8.3 - 5Date: 2:30:30 PM April 28, 2017 --><time-stamp>From VisualWorks®, Pre-Release 8.3 (apr17.3) of April 28, 2017 on April 28, 2017 at 2:30:30 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>HttpDispatcher</name><environment>Net</environment><super>Net.MimeDispatcher</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpDispatcher</class-id><body>HttpDispatcher is controlling Http message printing/writing</body></comment><class><name>HttpSocketAccessor</name><environment>Net</environment><super>OS.SocketAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>time timeout </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpSocketAccessor</class-id><body>This class overrides its superclass to allow timeouts on reads, and also to choose a different kind of IOBuffer (indirectly through its choice of ExternalConnection class).Instance Variables:	time	&lt;Integer&gt;	time of the last successful read, in milliseconds	timeout	&lt;Integer&gt;	how long we should wait while reading a buffer, before assuming the connection died.</body></comment><class><name>AuthenticateField</name><environment>Net</environment><super>Net.ValueWithParametersField</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.AuthenticateField</class-id><body>This class represents the structure of the www-authenticate/proxy-authenticate field as it described in RFC2616. This is a parametrized field with a single value followed by parameters, but it does not follow the usual practise of separating the paramters by semicolons. Instead it uses commas, and does not require a comma before the first (realm) parameter.WWW-Authenticate  = "WWW-Authenticate" ":" 1#challengeProxy-Authenticate  = "Proxy-Authenticate" ":" 1#challengeThe HTTP access authentication process is described in "HTTP Authentication: Basic and Digest Access Authentication". User agents are advised to take special care in parsing the WWW- Authenticate field value as it might contain more than one challenge, or if more than one WWW-Authenticate header field is provided, the contents of a challenge itself can contain a comma-separated list of authentication parameters. To avoid problems with parsing multiple challenges we write/print one challenge per Authenticate field.</body></comment><class><name>AuthorizationField</name><environment>Net</environment><super>Net.AuthenticateField</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.AuthorizationField</class-id><body>AuthorizationField represents 'authorization'  header field as it described in RFC2616. The client is expected to retry the request, passing an Authorization  header line, which is defined according to the server authentication challenge</body></comment><class><name>HttpEntity</name><environment>Net</environment><super>Net.MimeEntity</super><private>false</private><indexed-type>none</indexed-type><inst-vars>nextNamespaceId </inst-vars><class-inst-vars></class-inst-vars><imports>			OS.ZLib.*			</imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpEntity</class-id><body>Represents HttpEntity super class. Supports protocol to parse and compose chunked http entity.API to handle message contens: #byteContents - returns row bytes as ByteArray#contents - retuns decoded message contents based on the message charset as ByteString. If the message was not decompresssed returns row bytes as string.#decompressedContents - returns decompress row bytes if the message includes "Content-Encoding: gzip" header field. The header fields will not be removed and the message contents will not be changed. It will still contain row bytes.#decodedContents - returns decoded message contents based on the message charset encoding. The message contents will not be changed.Options to write message contens: #useGZipTransfer#chunkSize#shouldChunkThe 'mandatory extension' category represents implementation of RFC2774 			An HTTP Extention FrameworkInstance Variables	nextNamespaceId	&lt;Number&gt; represents two-digit header prefix for extention declaration</body></comment><class><name>UnspecifiedBodySize</name><environment>Net</environment><super>Core.Notification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.UnspecifiedBodySize</class-id><body>The notification is raised if HttpBuildHandler is not able to determine where does a message body end. The resumption value of the notification is a Boolean. If the notification resumes with false (the default, unhandled behavior), the message is assumed to not have a body, and so the handler will stop parsing the message right after the end of the header. If the notification resumes with true, the handler will assume that the body ends at the end of the input stream and attempt to parse the rest of the stream as such.</body></comment><class><name>BodyWriteStream</name><environment>Net</environment><super>Net.MessageStream</super><private>true</private><indexed-type>none</indexed-type><inst-vars>buffer onFinishDo </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HTTP</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.BodyWriteStream</class-id><body>The purpose of this stream is to replace the chunked write stream in the case the user wants to avoid chunking (see #doNotChunk). We still need to buffer the contents to compute the correct Content-Length value.Instance Variables	buffer	&lt;ReadWriteStream on: ByteArray&gt; internal stream to buffer the contents	onFinishDo	&lt;BlockClosure&gt; a callback exectuted when the stream is being #finished; will receive buffer position as argument</body></comment><class><name>HttpException</name><environment>Net</environment><super>Net.NetError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpException</class-id><body>This class reports errors which are reported by the HTTP server being accessed.Shared Class Variables:	Preferences	&lt;OrderedCollection of Association &gt; list of Http errors with description</body></comment><class><name>HttpRedirectionError</name><environment>Net</environment><super>Net.HttpException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpRedirectionError</class-id><body>This class reports redirection errors which are reported by the HTTP server being accessed.3xx: Redirection - Further action must be taken in order to        complete the requestInstance Variables:</body></comment><class><name>HttpMovedError</name><environment>Net</environment><super>Net.HttpRedirectionError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpMovedError</class-id><body>This class reports 301/302 errors which are reported by the HTTP server being accessed."301"   ; Moved Permanently"302"   ; Moved TemporarilyInstance Variables:</body></comment><class><name>HttpAuthentication</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>authChallenge state pathString authPolicy authValue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpAuthentication</class-id><body>HttpAuthentication is an abstract class for different authentication schemes. The subclasses must provided implementation for the authorization field value.Subclasses must implement the following messages:	authorization		setNewAuthorizationValueInstance Variables:	authChallenge	&lt;AuthenticationValue&gt;	the server challenge (authentication field value)	authValue	&lt;AuthenticationValue&gt;	the authorization field value	authPolicy	&lt;AuthenticationPolicy&gt;	authentication policy	pathString	&lt;String&gt;	the request url 	state	&lt;ByteSymbol&gt;	the authetication state. Depending on a scheme it can have values:  #authorized #isNotAuthorized #authorizationInProgress. 	user	&lt;HttpUser&gt;	the http user that is used to authorize the message</body></comment><class><name>DigestAuthentication</name><environment>Net</environment><super>Net.HttpAuthentication</super><private>false</private><indexed-type>none</indexed-type><inst-vars>nonceCount md5SessData defaultAlgorithm </inst-vars><class-inst-vars>defaultAlgorithm </class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.DigestAuthentication</class-id><body>DigestAuthentication creates user credentials based on Digest Authentication Scheme (RFC2617). The Digest scheme challenges using a nonce value. A valid response contains a checksum (by default, the MD5 checksum) of the username, the password, the given  nonce value, the HTTP method, and the requested URI.Limitations: &lt;qop=auth-int&gt; - option has not been implemented.  If the option is used the hash of the entity body has to be calculated.Instance Variables:	md5SessData	&lt;String&gt;	MD5 checksum	nonceCount	&lt;SmallInteger&gt;	description of nonceCount	defaultAlgorithm &lt;String&gt;  the value can be 'MD5' or 'MD5-sess'.Class Instance Variables:	defaultAlgorithm &lt;String&gt;  default algorithm  (MD5)</body></comment><class><name>HttpPrintHandler</name><environment>Net</environment><super>Net.MimePrintHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpPrintHandler</class-id><body>This class implements printing of HTTP messages on a stream in a shortened (digest) mode to enhance readability of the output.</body></comment><class><name>HttpParser</name><environment>Net</environment><super>Net.MimeParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.IOConstants.*			</imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpParser</class-id><body>This class is parser for HTTP messages. It's knows how to parse chunked HTTP message bodies, the first line of the Http message and messages with gzipped contents.To be able to read a message and parse it at the same time the parser creates a few layers of streams that wrap an underlaying stream.A possible stack of streams can include the layers in the following order:- to parse an internal stream it is wrapped in to DecodedStream- a chunked message stream is wrapped in to ChunkedStream- then the message stream is wrapped in to BodyStream which reads the number of bytes as it is specified by the message contents length- if the message transfer encoding indicates that compression (gzip) was applied the stream is wrapped in to OS.ZLib.GZipReadStream- the multipart message stream is wrapped in to BoundedStreamInstance Variables:	readBoundary &lt;String&gt;  a multipart message boundary	atEnd &lt; Boolean&gt;  indicates whether or not the last part of a multipart message has being parsed</body></comment><class><name>AcceptHeaderFields</name><environment>Net</environment><super>Net.ValueWithParametersField</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.AcceptHeaderFields</class-id><body>AcceptHeaderFields is abstract class for "Accept.." header fields.</body></comment><class><name>ManOptField</name><environment>Net</environment><super>Net.AcceptHeaderFields</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.ManOptField</class-id><body>ManOptField represents a mandatory field. For example:Man: http://www.copyright.org/rights-management; ns=16</body></comment><class><name>DigestAuthenticationValue</name><environment>Net</environment><super>Net.ValueWithParams</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HTTP</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.DigestAuthenticationValue</class-id><body>DigestAuthenticationValue parses, composes and holds values for Digest authorization and authenication header fields </body></comment><class><name>CookieField</name><environment>Net</environment><super>Net.CollectionField</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HTTP</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.CookieField</class-id><body>CookieField represents 'Cookie' field. http://tools.ietf.org/html/rfc6265#section-4.2Instance Variables	value &lt;Collection of Association&gt; collection of associations where key is "cookie-name" and value is "cookie-value"Sample how to create cookie fields see in CookieAgent comments   cookie-header = "Cookie:" OWS cookie-string OWS   cookie-string = cookie-pair *( ";" SP cookie-pair )	Each cookie-pair represents a cookie stored by the user agent. The cookie-pair contains the cookie-name and cookie-value the user agent received in the Set-Cookie header.	Notice that the cookie attributes are not returned.  In particular, the server cannot determine from the Cookie header alone when a cookie will expire, for which hosts the cookie is valid, for which  paths the cookie is valid, or whether the cookie was set with the Secure or HttpOnly attributes.Examples:Creating Cookie:	cookie := CookieField new.	cookie addName: 'Customer' value: 'WILE_E_COYOTE'.	cookie addName: 'Part_Number' value: 'Rocket_Launcher_0001'.Created: 'Cookie: Customer=WILE_E_COYOTE; Part_Number=Rocket_Launcher_0001'  Parsing Cookie:	header := HeaderField readFrom: 'Cookie: SID=31d4d96e407aad42; lang=en-US' readStream.	header isKindOf: CookieField. 	(val := header value first) isKindOf: Association.	val key = 'SID'.	val value = '31d4d96e407aad42'.	</body></comment><class><name>HttpConnection</name><environment>Net</environment><super>Net.NetConnection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.IOConstants.*			</imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpConnection</class-id><body>HttpConnection is the HTTP connection stream wrapper</body></comment><class><name>SetCookieValue</name><environment>Net</environment><super>Net.ValueWithParams</super><private>false</private><indexed-type>none</indexed-type><inst-vars>setSelectors printSelectors creationTime lastAccessTime persistent </inst-vars><class-inst-vars>policy </class-inst-vars><imports></imports><category>HTTP</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.SetCookieValue</class-id><body>SetCookieValue represents value of 'Set-Cookie' header field.  Implementation is based on specification: http://tools.ietf.org/html/rfc6265Instance Variables	printSelectors	&lt;Dictionary&gt;	print selectors for cookie field parameters	setSelectors	&lt;Dictionary&gt;	set selectors for cookie field parameters	creationTime 	&lt;Timestamp&gt; is set to current date and time when created	lastAccessTime 	&lt;timestamp&gt;  is set to current date and time when created	persistent &lt;Boolean&gt; is true if the the set cookie field specifies maxAge &gt;0 or expiration timehttp://tools.ietf.org/html/rfc6265#section-4.1.1 set-cookie-header = "Set-Cookie:" SP set-cookie-string set-cookie-string = cookie-pair *( ";" SP cookie-av ) cookie-pair       = cookie-name "=" cookie-value cookie-name       = token cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE ) cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E                       ; US-ASCII characters excluding CTLs,                       ; whitespace DQUOTE, comma, semicolon,                       ; and backslash token             = &lt;token, defined in [RFC2616], Section 2.2&gt; cookie-av         = expires-av / max-age-av / domain-av /                     path-av / secure-av / httponly-av /                     extension-av expires-av        = "Expires=" sane-cookie-date sane-cookie-date  = &lt;rfc1123-date, defined in [RFC2616], Section 3.3.1&gt; max-age-av        = "Max-Age=" non-zero-digit *DIGIT                       ; In practice, both expires-av and max-age-av                       ; are limited to dates representable by the                       ; user agent. non-zero-digit    = %x31-39                       ; digits 1 through 9 domain-av         = "Domain=" domain-value domain-value      = &lt;subdomain&gt;                       ; defined in [RFC1034], Section 3.5, as                       ; enhanced by [RFC1123], Section 2.1 path-av           = "Path=" path-value path-value        = &lt;any CHAR except CTLs or ";"&gt; secure-av         = "Secure" httponly-av       = "HttpOnly" extension-av      = &lt;any CHAR except CTLs or ";"&gt;</body></comment><class><name>HttpClientError</name><environment>Net</environment><super>Net.HttpException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpClientError</class-id><body>This class reports http client errors which are reported by the HTTP server being accessed.4xx: Client Error - The request contains bad syntax or cannot be        fulfilledInstance Variables:</body></comment><class><name>HttpAuthenticationExc</name><environment>Net</environment><super>Net.HttpClientError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpAuthenticationExc</class-id><body>HttpAuthenticationExc will be raise if there is no support the challenge scheme received from a server</body></comment><class><name>AuthenticationPolicy</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>user rejected authentication authOrder </inst-vars><class-inst-vars>authOrder </class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.AuthenticationPolicy</class-id><body>AuthenticationPolicy handles different types of authentication for Http messages. The policy will select supported authentication scheme from the server challenge, create an instance of the specific authentication and add an authorization field to a request.The policy will try to handle the server challenge if 	- a user name and password is provided	- the server challenge includes supported authentication schemeCurrently supported authentication schemes: Basic, Digest and NTLM. The client side preferences for authetication mechanism are controlled by the authentication order (#authOrder), which can be specified either at the global level (class side) or at the individual instance level.Instance Variables	authOrder	&lt;OrderedCollection of HttpAuthentication&gt;	authOrder defines supported authentication schemes and order to select a scheme to authorize a message. 	authentication	&lt;HttpAuthentication&gt;	authentication instance to authorize a message	rejected	&lt;Collection of HttpAuthentication&gt;	collection of schemes a server rejected to accept. The authentication policy will make an attempt to use another auth scheme from the server  challenge list if the first one failed. If the rejected list and the same as the challenge list the auth policy passes the exception.	user	&lt;HttpUser&gt;	the user that holds user name, password and collection of realms where this authentication token is validClass Instance Variables	authOrder	&lt;OrderedCollection of HttpAuthentication&gt;	authOrder. Default order is #(NTLMAuthentication DigestAuthentication BasicAuthentication)Samples how to use AuthenticationPolicy. More samples can be found in HttpAuthPolicyTest class (HTTPTests package). To run tests see the NetClientsSupportInternal bundle comments.1.request := HttpRequest readFrom: 'GET http://www.cincomx.com/en/index.asp HTTP/1.1Host: www.cincom.com:4545Connection: Keep-Alive' readStream.reply := HttpResponse readFrom: 'HTTP/1.1 401 UnauthorizedWWW-Authenticate: NegotiateWWW-Authenticate: NTLMWWW-Authenticate: Basic realm="testrealm@host.com"' readStream.polBuilder := AuthenticationPolicy new.polBuilder policiesOrder: (Array 		with: BasicAuthentication		with: DigestAuthentication 		with: NTLMAuthentication).polBuilder username: 'aUser' password:  'password'.polBuilder acceptChallenge: reply request: request.polBuilder addAuthorizationTo: request.2.cl := HttpClient new.cl username: 'winUsername' password: 'winPass'.reply := cl get: html.3.cl := HttpClient new.cl username: 'winUsername' password: 'winPass'.cl useBasicAuth.reply := cl get: html4. cl := HttpClient new.[reply := cl get: html.] on: Net.HttpUnauthorizedErrordo: [ :ex | 	cl username: 'winUsername' password: 'winPass'.	ex retry]5.proxy := (HostSpec new					name: 'ntlmAuthProxyServer';					type: 'http';					yourself).proxy netUser: (NetUser username: 'winUsername' password: 'winPass').cl := HttpClient new.cl 	proxyHost: proxy;	useProxy: true.reply := cl get: 'http://www.yahoo.com/'.</body></comment><class><name>HttpEntityError</name><environment>Net</environment><super>Net.HttpException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpEntityError</class-id><body>This exception is raised if the error was detected while parsing the http entity. </body></comment><class><name>AcceptCharsetField</name><environment>Net</environment><super>Net.AcceptHeaderFields</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.AcceptCharsetField</class-id><body>AcceptCharsetField represents "Accept-Charset" header field as it described in RFC2616. The Accept-Charset request-header field can be used to indicate what character sets are acceptable for the response. </body></comment><class><name>HttpURL</name><environment>Net</environment><super>OS.URLwithAuthority</super><private>false</private><indexed-type>none</indexed-type><inst-vars>user decompressContents decodeContents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpURL</class-id><body>This URL describes resources accessed using the HTTP protocol.Instance Variables:	user	&lt;NetUser&gt;	an user ID authorized to access the proxy server	decompressContents 	&lt;Boolean&gt; defines whether or not to decompess the reponse contents	decodeContents &lt;Boolean&gt; defines whether or not to decode the response contents</body></comment><class><name>ProxyAuthenticationPolicy</name><environment>Net</environment><super>Net.AuthenticationPolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.ProxyAuthenticationPolicy</class-id><body>ProxyAuthenticationPolicy  handles proxy authentication for Http messages.</body></comment><class><name>AcceptLanguageField</name><environment>Net</environment><super>Net.AcceptHeaderFields</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.AcceptLanguageField</class-id><body>AcceptLanguageField represents Accept-Language header field as it described in RFC2616. The Accept-Language request-header field is similar to Accept, but restricts the set of natural languages that are preferred as a response to the request. </body></comment><class><name>HttpResponse</name><environment>Net</environment><super>Net.HttpEntity</super><private>false</private><indexed-type>none</indexed-type><inst-vars>statusLine </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpResponse</class-id><body>Represents the responce that a server replies after receiving and interpreting a request message. The first line of a HttpResponse message is the status line.Instance Variables:	statusLine	&lt;HttpStatusLine&gt;	an instance of HttpStatusLine</body></comment><class><name>HttpInformationalError</name><environment>Net</environment><super>Net.HttpException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpInformationalError</class-id><body>This class reports http informational errors which are reported by the HTTP server being accessed.1xx: Informational - Request received, continuing processInstance Variables:</body></comment><class><name>HttpStatusLineError</name><environment>Net</environment><super>Net.HttpException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpStatusLineError</class-id><body>HttpStatusLineError is raised if the Http parser read an empty response status line</body></comment><class><name>SetCookieField</name><environment>Net</environment><super>Net.ValueWithParametersField</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HTTP</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.SetCookieField</class-id><body>SetCookieField represents 'Set-Cookie' field.  Implementation is based on specification: http://tools.ietf.org/html/rfc6265. The field value is collection of SetCookieValue How to create the field:	header := SetCookieField new.	value :=header addName: 'Customer' value: 'WILE_E_COYOTE'.	value		secure: true;		httponly: true;		domain: 'cincom.com';		maxAge: 0.Parsing Set-Cookie field:	header := HeaderField readFrom: 'Set-cookie: sessionKey=97247325257256121017153; expires=Mon, 26 Jan 2044 18:22:41 GMT; path=/cgi-bin/axis.exe/submit;' readStream. 	header isKindOf: SetCookieField.	(val := header value first) isKindOf: SetCookieValue.	val path = '/cgi-bin/axis.exe/submit'.	val name = 'sessionKey'.	val nameValue = '97247325257256121017153'.	val expires year =  2044.	val expires month = 1.	val expires day = 26.	expires hour = 10.	val expires minute = 22.	val secure = false. 	val persistent = true.</body></comment><class><name>AuthenticationValue</name><environment>Net</environment><super>Net.HeaderFieldValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars>data realm </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HTTP</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.AuthenticationValue</class-id><body>AuthenticationValue parses, composes and holds values for Basic and NTLM authorization and authenication header fieldsInstance Variables:	data	&lt;String&gt; authetication data	realm	&lt;Object&gt; realm identifier (for Basic Authentication)</body></comment><class><name>HttpUnauthorizedError</name><environment>Net</environment><super>Net.HttpClientError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpUnauthorizedError</class-id><body>This class reports 401 error which are reported by the HTTP server being accessed."401"   ; UnauthorizedInstance Variables:</body></comment><class><name>HttpResponseStatusLine</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>code message protocol version </inst-vars><class-inst-vars>messages </class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpResponseStatusLine</class-id><body>Represents the first line of an HttpResponse message that consists of the protocol, version followed by a numeric status code and its associated textual phrase.	Status-Line = HTTP-Version SP Status-Code SP Reason-Phrase CRLFInstance Variables:	code	&lt;String&gt; the response code	message	&lt;String&gt; the code phrase part of the line	protocol	&lt;String&gt; the protocol part of the line	version	&lt;String&gt; the version part of the lineClass Instance Variables:	messages	&lt;Dictionary key: String value: String&gt; maps codes to status line messages#code method returns element is a 3-digit integer result code of the  attempt to understand and satisfy the request. (Status-Code)#message method is return a short textual description of the code (Reason-Phrase)</body></comment><class><name>HttpBuildHandler</name><environment>Net</environment><super>Net.MimeParserHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>decompressContents decodeContents </class-inst-vars><imports>			OS.ZLib.*			</imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpBuildHandler</class-id><body>This class builds Http messages.  Depending on parsing option the builder writes raw socket bytes in to the message body or decompressed and decoded string. See the option description in the HttpClient class comments. The builder allows to deal with large attachments by saving them directly into files.Instance VariablesClass Instance VariablesSamples1. Creating a request or response entity	httpEntity :=  HttpBuildHandler readFrom: stream.2. Creating an http entity with header parsed only	builder  := HttpBuildHandler on: stream. 	request := builder readHeader.	"Parsing the message body"	builder readBody.3. Saving an attachment with the specified file name	filename := HttpBuildHandler defaultAttachmentDirectory, 'temp.txt'.	client := HttpClient new.	[[response2 := client executeRequest: request.] 		on: AttachmentFilename 		do: [ :ex | ex resume: filename ].	] ensure: [ client close ] ].4. Writing a message with specified chunk size	response := HttpResponse code: '200'. 	response contents: 'sometext'.	response addFileAttachment: someAttachmentFile.	response newWriter			chunkSize: 25;			writeMessage: response on: stream.5. Writing a message in GZip format.		response := HttpResponse code: '200'. 	response contents: 'sometext'.	response newWriter			useGZipTransfer: true;			writeMessage: response on: stream.</body></comment><class><name>HttpServerError</name><environment>Net</environment><super>Net.HttpException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpServerError</class-id><body>This class reports server errors which are reported by the HTTP server being accessed.5xx: Server Error - The server failed to fulfill an apparently        valid requestInstance Variables:</body></comment><class><name>HttpSettings</name><environment>Net</environment><super>Net.NetPISettings</super><private>false</private><indexed-type>none</indexed-type><inst-vars>useProxy redirectRequest proxyExceptions connectionPersists proxyHost enableCookieProcessing domain user </inst-vars><class-inst-vars>useProxy redirectRequest proxyExceptions connectionPersists proxyHost enableCookieProcessing domain user </class-inst-vars><imports></imports><category>HTTP</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpSettings</class-id><body>HttpPISettings defines HttpPI optionsInstance Variables	domain	&lt;String&gt;	NTLM server domain	enableCookies	&lt;Boolean&gt; defines whether or not to enable cookie processing	usePersistentConnection	&lt;Boolean&gt;	sets the "Connection" header field value as "close" for Http 1.1. The option is true by default.	proxyExceptions &lt;OrderedCollection of String&gt; server names excluded from the connection via a proxy server	proxyHost	&lt;SpecHost&gt; the proxy server	redirectRequest	&lt;Boolean&gt;	the option defines how to handle the HttpMovedException	useProxy	&lt;Boolean&gt; defines whether or not use proxy connection	user	&lt;NetUser&gt;	the PI userClass Instance Variables	domain	&lt;String&gt;	NTLM server domain	enableCookies	&lt;Boolean&gt; defines whether or not to enable cookie processing	usePersistentConnection	&lt;Boolean&gt;	sets the "Connection" header field value as "close" for Http 1.1. The option is true by default.	proxyExceptions	&lt;OrderedCollection of String&gt; server names to access without proxy 	proxyHost	&lt;SpecHost&gt;	proxy server	redirectRequest	&lt;Boolean&gt;	the option defines how to handle the HttpMovedException	useProxy	&lt;Boolean&gt; defines whether or not use proxy connection	user	&lt;NetUser&gt;	default user</body></comment><class><name>HttpObjectNotFound</name><environment>Net</environment><super>Net.HttpClientError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpObjectNotFound</class-id><body>HttpObjectNotFound reports 404 errors. The server has not found anything matching the Request-URI. No indication is given of whether the condition is temporary or permanent.</body></comment><class><name>ChunkedStream</name><environment>Net</environment><super>Net.MessageStream</super><private>true</private><indexed-type>none</indexed-type><inst-vars>buffer </inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.IOConstants.*			</imports><category>HTTP</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.ChunkedStream</class-id><body>ChunkedStream is an abstract class for read write chunked streams. Instance Variables:	buffer		&lt;ByteArray&gt;	buffer holds a chunk of bytes	lineEnd		&lt;ByteArray&gt; 	stream line end conventionFrom RFC2616:The chunked encoding modifies the body of a message in order to transfer it as a series of chunks, each with its own size indicator, followed by an OPTIONAL trailer containing entity-header fields. This allows dynamically produced content to be transferred along with the information necessary for the recipient to verify that it has received the full message.       Chunked-Body   = *chunk                        last-chunk                        trailer                        CRLF       chunk          = chunk-size [ chunk-extension ] CRLF                        chunk-data CRLF       chunk-size     = 1*HEX       last-chunk     = 1*("0") [ chunk-extension ] CRLF       chunk-extension= *( ";" chunk-ext-name [ "=" chunk-ext-val ] )       chunk-ext-name = token       chunk-ext-val  = token | quoted-string       chunk-data     = chunk-size(OCTET)       trailer        = *(entity-header CRLF)   The chunk-size field is a string of hex digits indicating the size of   the chunk. The chunked encoding is ended by any chunk whose size is   zero, followed by the trailer, which is terminated by an empty line.</body></comment><class><name>CacheControl</name><environment>Net</environment><super>Net.CollectionField</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.CacheControl</class-id><body>CacheControl represents 'cache-control' Http header field. The Cache-Control general-header field is used to specify directives that MUST be obeyed by all caching mechanisms along the request/response chain. http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.htmlCache-Control   = "Cache-Control" ":" 1#cache-directive	cache-directive = cache-request-directive  | cache-response-directive	cache-request-directive =                            "no-cache" [ "=" &lt;"&gt; 1#field-name &lt;"&gt; ]                          | "no-store"                          | "max-age" "=" delta-seconds                          | "max-stale" [ "=" delta-seconds ]                          | "min-fresh" "=" delta-seconds                          | "only-if-cached"                          | cache-extension	cache-response-directive =                            "public"                          | "private" [ "=" &lt;"&gt; 1#field-name &lt;"&gt; ]                          | "no-cache" [ "=" &lt;"&gt; 1#field-name &lt;"&gt; ]                          | "no-store"                          | "no-transform"                          | "must-revalidate"                          | "proxy-revalidate"                          | "max-age" "=" delta-seconds                          | cache-extension    cache-extension = token [ "=" ( token | quoted-string ) ]no-cache  Indicates that all or part of the response message MUST NOT be cached  anywhere. This allows an origin server to prevent caching even by  caches that have been configured to return stale responses to client  requestsNote: Most HTTP/1.0 caches will not recognize or obey this  directive.</body></comment><class><name>ChunkedReadStream</name><environment>Net</environment><super>Net.ChunkedStream</super><private>true</private><indexed-type>none</indexed-type><inst-vars>firstChunk </inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.IOConstants.*			</imports><category>HTTP</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.ChunkedReadStream</class-id><body>ChunkedReadStream helps to read chunked messages. Instance Variables:</body></comment><class><name>ChunkedWriteStream</name><environment>Net</environment><super>Net.ChunkedStream</super><private>true</private><indexed-type>none</indexed-type><inst-vars>writeLimit useChunks bufferNumber onFinishWithOneBufferDo onReadyToWriteFirstBufferDo </inst-vars><class-inst-vars>defaultWriteLimit </class-inst-vars><imports>			private OS.IOConstants.*			</imports><category>HTTP</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.ChunkedWriteStream</class-id><body>ChunkedWriteStream helps to read and write chunked messages. The ChunkedStream collects the message body bytes in a buffer until the buffer is filled. The buffer size is settable and the default size is 4K. If the message body fits entirely into a single buffer the message won't be chunked, it will be sent as is and the message header will include the "Content-length" field with corresponding byte size value. If the body is longer than the buffer then when the ChunkedStream is about to write the first chunk into the underlying stream it notifies the higher levels of the framework (using callback #onReadyToWriteFirstBufferDo) which will add a "transfer-encoding: chunked" header field instead and the body will be written out in the chunked format. Instance Variables	writeLimit &lt;Number&gt; chunk size	useChunks &lt;Boolean&gt; defines whether or not use chunks to write in to the underlying stream. 	bufferNumber &lt;Number&gt; if the fist buffer is ready to be flushed in to the underlying stream the ChuckedWriteStream raises an exception. The exception is used by the HttpPrinter to add "Transfer-encoding" field to the message	onFinishWithOneBufferDo	&lt;BlockClosure&gt; callback executed when the entire message fits into one buffer and I'm being #finished; called with buffer position as an argument	onReadyToWriteFirstBufferDo	&lt;BlockClosure&gt; callback executed when the first buffer is full, and we're about to write the first chunk</body></comment><class><name>HttpBadRequest</name><environment>Net</environment><super>Net.HttpClientError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpBadRequest</class-id><body>HttpBadRequest reports 400 Http errors. The request could not be understood by the server due to malformed syntax. The client SHOULD NOT repeat the request without modifications</body></comment><class><name>HttpRequestLine</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method url version prefix path useProxy </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpRequestLine</class-id><body>Represents the requst line of Http message.	Request-Line   = Method SP Request-URI SP HTTP-Version CRLFInstance Variables:	method	&lt;String&gt; the method to be applied to the resource	url	&lt;URI&gt; the resorce locator	version	&lt;String&gt; HTTP protocol version to use	prefix	&lt;String&gt; the request line prefix	path	&lt;URI&gt; the request line path	useProxy	&lt;Boolean&gt; defines whether or not the server is proxy</body></comment><class><name>BasicAuthentication</name><environment>Net</environment><super>Net.HttpAuthentication</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.BasicAuthentication</class-id><body>BasicAuthentication creates user credentials based on Basic Authentication Scheme (RFC2617). The "basic" authentication scheme is based on the model that the client must authenticate itself with a user-ID and a password for each realm. The Basic authentication scheme is not a secure method of user authentication, nor does it in any way protect the entity, which is transmitted in cleartext across the physical network used as the carrier.</body></comment><class><name>AcceptField</name><environment>Net</environment><super>Net.AcceptHeaderFields</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.AcceptField</class-id><body>AcceptField represents "Accept" header field as it described in RFC2616. The Accept request-header field can be used to specify certain media types which are acceptable for the response. Accept headers can be used to indicate that the request is specifically limited to a small set of desired types, as in the case of a request for an in-line image.</body></comment><class><name>QuotedPrintRequired</name><environment>Net</environment><super>Net.NetNotification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.QuotedPrintRequired</class-id><body>QuotedPrintRequired exception is raised to notify about printing ports for cookie header fields. The syntax requires quotes around the optional port list even if there is only one port number in the port list</body></comment><class><name>HttpProxyAuthenticationError</name><environment>Net</environment><super>Net.HttpClientError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpProxyAuthenticationError</class-id><body>This class reports 407 error which are reported by the HTTP server being accessed."407"   ; Proxy Authentication RequiredInstance Variables:</body></comment><class><name>HttpTimeout</name><environment>Net</environment><super>Net.HttpException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpTimeout</class-id><body>Timeout exception is raised after the time we wait while reading a buffer in HttpSockedAccessor is expired.  Instance Variables:</body></comment><class><name>TransferEncoding</name><environment>Net</environment><super>Net.CollectionField</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.TransferEncoding</class-id><body>TransferEncoding represents transfer encoding field as defines in RFC2616. Value of the field is an ordered collection of string tokens.14.41 Transfer-Encoding   The Transfer-Encoding general-header field indicates what (if any)   type of transformation has been applied to the message body in order   to safely transfer it between the sender and the recipient. This   differs from the content-coding in that the transfer-coding is a   property of the message, not of the entity.     Transfer-Encoding       = "Transfer-Encoding" ":" 1#transfer-coding   Transfer-codings are defined in section 3.6. An example is:     Transfer-Encoding: chunked   If multiple encodings have been applied to an entity, the transfer-   codings MUST be listed in the order in which they were applied.   Additional information about the encoding parameters MAY be provided   by other entity-header fields not defined by this specification.   Many older HTTP/1.0 applications do not understand the Transfer-   Encoding header.</body></comment><class><name>HttpReadingOptions</name><environment>Net</environment><super>Net.MimeReadingOptions</super><private>false</private><indexed-type>none</indexed-type><inst-vars>decompressContents decodeContents </inst-vars><class-inst-vars>decompressContents decodeContents </class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpReadingOptions</class-id><body>HttpReadingOptions holds HttpBuildHandler optrions and knows how create an instance of HttpBuildHandlerInstance Variables	decompressContents	&lt;Boolean&gt; should we decompress message contents if it is compressed	decodeContents	&lt;Boolean&gt; should we decode message contents into charactersClass Instance Variables	decompressContents	&lt;Boolean&gt; should we decompress message contents if it is compressed	decodeContents &lt;Boolean&gt; should we decode message contents into characters</body></comment><class><name>HttpRequest</name><environment>Net</environment><super>Net.HttpEntity</super><private>false</private><indexed-type>none</indexed-type><inst-vars>requestLine </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpRequest</class-id><body>Represent Http request message from client to a server. A request message from a client to a server includes, within the first line of that message, the method to be applied to the resource,  the identifier of the resource, and the protocol version in use. The rest of the message is standard MIME entity.  The methods in low-level command interface protocol allow to execute the request and get a response.Instance Variables:	requestLine	&lt;HttpRequstLine&gt;	an instance of HttpRequestLineSamples:	"To decompress contents of a response with compressed transfer encoding"	url := 'http://www.fark.com' asURI.	req := HttpRequest get: url.	req fieldValueAt: 'Accept-Encoding' put: 'gzip'.	req decompressContents: true.	resp := req execute.	"To send a binary file as a post request, compressed and not chunked"	file := (Filename fromComponents: ('$(VISUALWORKS)/net/HTTP.pcl' tokensBasedOn: $/)) asFilename readStream binary.	(request := HttpRequest post: 'http://localhost:4461/')		byteSource: file.	stream := ((ByteArray new: 1024) withEncoding: #ISO8859_1) readWriteStream lineEndCRLF.	HttpWriteHandler new		doNotChunk;		useGZipTransfer: true;		writeMessage: request on: stream.	stream reset; contents</body></comment><class><name>HttpUser</name><environment>Net</environment><super>Net.NetUser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>realms </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpUser</class-id><body>HttpUser holds a Http client authentication informationInstance Variables:	realms	&lt;OrderedCollection of String&gt;	 realms where the user token is accepted. The realm value in combination with the canonical root URL of the server being accessed, defines the protection space.</body></comment><class><name>HttpWritingOptions</name><environment>Net</environment><super>Net.MimeWritingOptions</super><private>false</private><indexed-type>none</indexed-type><inst-vars>useGZipTransfer chunkSize shouldChunk logAsPrintString setContentLength addUserAgentField userAgentFieldValue </inst-vars><class-inst-vars>useGZipTransfer shouldChunk logAsPrintString setContentLength addUserAgentField userAgentFieldValue </class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpWritingOptions</class-id><body>HttpWritingOptions is holding the HttpWriteHandler/HttpPrintHandler options and knows how to create an instance of HttpWriteHandler/HttpPrintHandler.Instance Variables	chunkSize	&lt;Number&gt; specifies at what body size to start chunking the message	logAsPrintString	&lt;Boolean&gt; defines how a request is printed in the Logging Tool. If the option is set to true the message is using #printString for log. If the option is false the message will be written to the log as it send to a socket stream.	shouldChunk &lt;Boolean&gt; to switch the automatic body chunking on and off. See HttpWriteHandler for more details about the chunking option	useGZipTransfer	&lt;Boolean&gt; defines whether to transfer a message in gzip format. Adds gzip to the transfer-encoding field	setContentLength &lt;Boolean&gt; if the option is false the "Content-Length' field is not added to a message	addUserAgentField  &lt;Boolean &gt; defines if the User-Agent field should be added to a request	userAgentFieldValue &lt;String&gt; the User-Agent field valueClass Instance Variables	useGZipTransfer	&lt;Boolean&gt; default value for message transfer compression	shouldChunk &lt;Boolean&gt; default value for a message chunking	logAsPrintString	&lt;Boolean&gt; default for logging messages	setContentLength &lt;Boolean&gt; default setContentLength value	addUserAgentField  &lt;Boolean &gt; defines if the User-Agent field should be added to a request	userAgentFieldValue &lt;String&gt; the User-Agent field default value</body></comment><class><name>HttpProtocolInterpreter</name><environment>Net</environment><super>Net.NetProtocolInterpreter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>authPolicy proxyAuthPolicy cookieAgent request hostName portNumber readingOptions writingOptions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HTTP</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpProtocolInterpreter</class-id><body>HttpProtocolInterpreter communicates with the Http/Https server via the HttpStreamHandler or HttpsStreamHandler. The HttpProtocolInterpreter creates connection based on URL protocol which can be http or https.  Supports cookie state management and authorization. HttpProtocolInterpreter receives server replies or client requests, parses them into the HttpResponse or HttpRequest and handles them where appropriate. Instance Variables	authPolicy	&lt;AuthenticationPolicy&gt; will handle the authentication challenge from a server and add user credentials to requests. The client enables cookie managment as soon as it receives the 401 exceptions. To validate authorized requests some servers require authorization field and reply cookies.	proxyAuthPolicy	&lt;ProxyAuthenticationPolicy&gt; will handle the authentication challenge from a proxy server and add user credentials to requests. 	cookieAgent	&lt;CookieAgent&gt; provides cookie management	request	&lt;HttpRequest&gt; the HttpRequest object	hostName	&lt;String&gt; the host to connect to	portNumber	&lt;Number&gt; the host port number	settings	 &lt;HttpPISettings&gt; PI optionsClass Instance Variables	settings 	&lt;HttpPISettings&gt; default http PI options</body></comment><class><name>AuthenticationInfoField</name><environment>Net</environment><super>Net.AuthenticateField</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.AuthenticationInfoField</class-id><body>AuthenticationInfoField represents "Authentication-Info" header field as it described in RFC2617. The Authentication-Info header is used by the server to communicate some information regarding the successful digest authentication in the  response.</body></comment><class><name>CookieAgent</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>registry cacheCookies useCachedCookies enableLimits </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HTTP</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.CookieAgent</class-id><body>CookieAgent provides cookie management during a session with Http requests and responses. Implementation based on RFC6265 specification http://tools.ietf.org/html/rfc6265.Instance Variables	cacheCookies	&lt;Boolean&gt;	specifies whether or not to cache cookies	enableLimits	&lt;Boolean&gt;	specifies whether or not to check registry limits	registry	&lt;Dictionary&gt; cookie registry	useCachedCookies	&lt;Boolean&gt;	specifies whether or not to use cached cookie when a session startsShared variable Registry &lt;Dictionary &gt;  holds cached cookies.cookie := CookieField new.val := cookie addName: 'Customer' value: 'WILE_E_COYOTE'.val := cookie addName: 'Part_Number' value: 'Rocket_Launcher_0001'.'Cookie: Customer=WILE_E_COYOTE; Part_Number=Rocket_Launcher_0001'header := SetCookieValue name: 'Customer' value: 'WILE_E_COYOTE'.header 		secure: true;		domain: 'cincom.com';		maxAge: 0.'Customer=WILE_E_COYOTE;max-age=0;domain=cincom.com;secure'</body></comment><class><name>RegistryLimitationExc</name><environment>Net</environment><super>Net.HttpException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.RegistryLimitationExc</class-id><body>RegistryLimitationExc exception is raised when one of the registry limits was exceeded</body></comment><class><name>HttpClient</name><environment>Net</environment><super>Net.NetClient</super><private>false</private><indexed-type>none</indexed-type><inst-vars>request protocol </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpClient</class-id><body>This client makes http/https connections to servers in order to request resources via HTTP protocol, which is a superset of MIME. The HttpClient creates connection based on URL protocol which can be http or https.  Supports cookie state management.If the Http client receives the https URL protocol and detects that the HTTPS support is not loaded, the client does the following:1. if the URL Settings allows to auto load the HTTPS parcel, the parcel will be loaded and and created SSL connection2. if the URL Settings Https auto load is turned off (default behavior), the HttpClient raises the ComponentNotLoaded exception. The exception is resumable and resuming the exception by default loads the HTTPS parcel.How to send authorized messages see samples in the AuthenticationPolicy class.Instance Variables	request	&lt;HttpRequest&gt;	the HttpRequest object	protocol &lt;String&gt; 'http' or 'https' based on the protocol will be created an instance of HttpStreamHandlerShared Variables	Protocol &lt;String&gt; 'http' or 'https'	Connectionconnection stream  is persistent		if  #keepAlive method for the HttpClient instance or request returns  trueconnection stream  is closed after each request		if  #keepAlive method for the HttpClient instance and request returns  falseIf server sends a response with closed connection the HttpClient closes the connection stream but doesn't change the #keepAlive variable.	Error handlingIf user application doesn't provide error handling for HttpClient the HttpClient is going to try handle some exceptions by itself. The exceptions that client can handle are located in the HttpProtocolInterpreter processing category.Sample how to create cookie fields see in CookieAgent commentsThe client will turn on the cookie processing if a server response require authentication. 	</body></comment><class><name>HttpWriteHandler</name><environment>Net</environment><super>Net.MimeWriteHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bodySize </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpWriteHandler</class-id><body>This is the writer for HTTP messages. It allows to use compression for message transfer (#useGZipTransfer flag, false by default). It also allows to write messages in a simple continious form with content-length header field specifying the actual message body size in bytes, or in a "chunked" form splitting the body in a number of pieces which doesn't require knowing the full body size upfront (and therefore doesn't include the content-length header). In chunked form the message body is terminated with an "empty" chunk instead. Messages are chunked by default, but this behavior can be controlled using the #shouldChunk option in the following way: If #shouldChunk is true (default)	- if message body size exceeds the size specified by the #chunkSize option (#defaultChunkSize is set to 4K), the message will be chunked	- if message body size has fewer bytes than the specified #chunkSize, the messages will not be chunked and will use the content-length header insteadIf #shouldChunk is false	- the message will not be chunked regardless of body size and will use the content-length header instead.Note that, when #shouldChunk is false, the writer needs to be able to determine the exact, *final* byte size of the message body (i.e. if the body is to be compressed it has to be the compressed size). The size has to be known before it starts writing the body, so that it can inject the correct content-length field into the header. In general in this mode the body is first written into an internal stream to determine the correct byte count, then the header is finished with the right content-length and finally the body bytes are copied from the internal stream. As an optimization, if the body is simple (i.e. not multi-part) and the size of the body is known upfront, the writer will use that body size for the content-length field and then write the body bytes to the outging stream directly. This doesn't change the behavior in any way, it just may be useful to know that this particular case is handled in more efficient manner than the other non-chunked cases.Instance VariablesClass Instance Variables	Examples:1. 	Writing a message with contens-length field. Message body size doesn't exceeds the default #chunkSize 	(request := HttpRequest post: 'http://localhost:4461/')		contents: HttpWriteHandler xmlDefinition.	stream := ((ByteArray new: 100) withEncoding: #ISO8859_1) readWriteStream lineEndCRLF.	HttpWriteHandler write: request on: stream.	stream reset; contents. 2. Writing a message in chunked format. 	contents := (Filename fromComponents: ('$(VISUALWORKS)/net/HTTP.pcl' tokensBasedOn: $/)) asFilename contentsOfEntireFile.	(request := HttpRequest post: 'http://localhost:4461/')		contents: contents;		charset: 'utf-8'.	stream := ((ByteArray new: 1024) withEncoding: #ISO8859_1) readWriteStream lineEndCRLF.	HttpWriteHandler write: request on: stream.	stream reset; contents. 3. Writing a message with "Content-length:" field. 	(request := HttpRequest post: 'http://localhost:4461/')		contents: contents;		charset: 'utf-8'.	stream := ((ByteArray new: 1024) withEncoding: #ISO8859_1) readWriteStream lineEndCRLF.	HttpWriteHandler new		doNotChunk;		writeMessage: request on: stream.	stream reset; contents. 4. Writing a message in gzipped and chunked format	(request := HttpRequest post: 'http://localhost:4461/')		contents: contents;		charset: 'utf-8'.	stream := ((ByteArray new: 1024) withEncoding: #ISO8859_1) readWriteStream lineEndCRLF.	HttpWriteHandler new		useGZipTransfer: true;		writeMessage: request on: stream.	stream reset; contents. 5. Writing a message with specified chunked size	(request := HttpRequest post: 'http://localhost:4461/')		contents: contents;		charset: 'utf-8'.	stream := ((ByteArray new: 1024) withEncoding: #ISO8859_1) readWriteStream lineEndCRLF.	HttpWriteHandler new		chunkSize: 10;		writeMessage: request on: stream.	stream reset; contents. 6. Writing a message in gzipped format with "Contents-length"	(request := HttpRequest post: 'http://localhost:4461/')		contents: contents;		charset: 'utf-8'.	stream := ((ByteArray new: 1024) withEncoding: #ISO8859_1) readWriteStream lineEndCRLF.	HttpWriteHandler new		doNotChunk;		useGZipTransfer: true;		writeMessage: request on: stream.	stream reset; contents. </body></comment><class><name>HttpNotExtendedError</name><environment>Net</environment><super>Net.HttpException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><comment><class-id>Net.HttpNotExtendedError</class-id><body>HttpNotExtendedError reports 510 errors. The server does not support the functionality required to fulfill the request. This is the appropriate response when the server does not recognize the request method and is not capable of supporting it for any resource</body></comment><shared-variable><name>Protocol</name><environment>Net.HttpClient</environment><private>false</private><constant>false</constant><category>protocol</category><attributes><package>HTTP</package></attributes></shared-variable><shared-variable><name>UseCachedCookies</name><environment>Net.CookieAgent</environment><private>false</private><constant>false</constant><category>defaults</category><initializer></initializer><attributes><package>HTTP</package></attributes></shared-variable><shared-variable><name>CacheCookies</name><environment>Net.CookieAgent</environment><private>false</private><constant>false</constant><category>defaults</category><initializer></initializer><attributes><package>HTTP</package></attributes></shared-variable><shared-variable><name>Registry</name><environment>Net.CookieAgent</environment><private>false</private><constant>false</constant><category>registry</category><initializer></initializer><attributes><package>HTTP</package></attributes></shared-variable><shared-variable><name>NumberEntries</name><environment>Net.CookieAgent</environment><private>false</private><constant>false</constant><category>registry</category><initializer></initializer><attributes><package>HTTP</package></attributes></shared-variable><shared-variable><name>NumberBytesPerCookie</name><environment>Net.CookieAgent</environment><private>false</private><constant>false</constant><category>registry</category><initializer></initializer><attributes><package>HTTP</package></attributes></shared-variable><shared-variable><name>ServersCacheCookiesFrom</name><environment>Net.CookieAgent</environment><private>false</private><constant>false</constant><category>defaults</category><initializer></initializer><attributes><package>HTTP</package></attributes></shared-variable><shared-variable><name>NumberEntriesPerServer</name><environment>Net.CookieAgent</environment><private>false</private><constant>false</constant><category>registry</category><initializer></initializer><attributes><package>HTTP</package></attributes></shared-variable><shared-variable><name>EnableLimits</name><environment>Net.CookieAgent</environment><private>false</private><constant>false</constant><category>defaults</category><initializer></initializer><attributes><package>HTTP</package></attributes></shared-variable><shared-variable><name>Preferences</name><environment>Net.HttpException</environment><private>false</private><constant>false</constant><category>preferences</category><attributes><package>HTTP</package></attributes></shared-variable><methods><class-id>Net.HttpDispatcher</class-id> <category>visiting -- double dispatching</category><body package="HTTP">acceptMessage: aHttpEntity  with: argument	aHttpEntity messageLine ifNotNil: [ :line | line acceptVisit: self  with: aHttpEntity].	super acceptMessage: aHttpEntity  with: argument.	^aHttpEntity</body><body package="HTTP">acceptRequestLine: aRequestLine with: aHttpEntity	self handler startRequestLine: aRequestLine with: aHttpEntity.	^aRequestLine</body><body package="HTTP">acceptResponseLine: aResponseStatusLine with: aHttpEntity	self handler startResponseStatusLine:  aResponseStatusLine with: aHttpEntity.	^aResponseStatusLine</body></methods><methods><class-id>Net.HttpSocketAccessor</class-id> <category>private</category><body package="HTTP">primReadInto: buffer startingAt: index for: count 	"buffer is a byte-object, the place where IO is performed. 	index is a SmallInteger, the starting-point in the buffer. 	count is a SmallInteger, the number of bytes to be read."	"Returns a SmallInteger, which is the count of the bytes read."	"WouldBlock is a potential error condition."	time := Time millisecondClockValue.	^super primReadInto: buffer startingAt: index for: count</body><body package="HTTP">privateReadInto: buffer startingAt: index for: count 	"buffer is a byte-object, the place where IO is performed. 	index is a SmallInteger, the starting-point in the buffer. 	count is a SmallInteger, the number of bytes to be read."	"Returns a SmallInteger, which is the count of the bytes read."	"WouldBlock is a potential error condition."	&lt;primitive: 679 errorCode: _ec&gt;	| newTime |	(self class restartableError: _ec)		ifTrue: 			[self readWaitWithTimeoutMs: self timeout.			newTime := Time millisecondClockValue. 			newTime - time &gt; self timeout ifTrue: [ HttpTimeout raiseRequest. time := Time millisecondClockValue ].			^OSErrorHolder needRetrySignal raise].	^self reportError: _ec</body></methods><methods><class-id>Net.HttpSocketAccessor</class-id> <category>accessing</category><body package="HTTP">timeout	timeout == nil ifTrue: [timeout := 6000].	^timeout</body><body package="HTTP">timeout: numberOfMilliseconds	timeout := numberOfMilliseconds</body></methods><methods><class-id>Net.HttpSocketAccessor</class-id> <category>defaults</category><body package="HTTP">connectionClass	"Answer a default connection class for the receiver."	^ExternalConnection</body></methods><methods><class-id>Net.AuthenticateField</class-id> <category>adding </category><body package="HTTP">addBasic	^self addScheme: 'Basic'</body><body package="HTTP">addBasicRealm: rString	^self addBasic realm: rString</body><body package="HTTP">addBearer: aValue	^(self addScheme: 'Bearer') data: aValue</body><body package="HTTP">addBearer: aValue realm: rString	^(self addBearer: aValue) realm: rString</body><body package="HTTP">addDigest	^self addScheme: 'Digest'</body><body package="HTTP">addDigestRealm: aString	^self addDigest realm: aString</body><body package="HTTP">addNegotiate	^self addScheme: 'Negotiate'</body><body package="HTTP">addScheme: aString	| valWithParams newVal |	valWithParams := self valueWithParamsClass newWithSeparators: self separators.	valWithParams value: aString.	self value add: (newVal := self privateNewValueFrom:  valWithParams).	^newVal</body><body package="HTTP">addScheme: vString realm: rString	| valWithParams |	valWithParams := self addScheme: vString.	rString ifNotNil: [ valWithParams realm: rString].	^valWithParams</body></methods><methods><class-id>Net.AuthenticateField</class-id> <category>accessing</category><body package="HTTP">basicScheme	^self value select: [ :each | each isBasic ]</body><body package="HTTP">bearerScheme	^self value select: [ :each | each isBearer ]</body><body package="HTTP">detectRealm	| coll val |	coll := self basicScheme.	coll addAll: self digestScheme.	val := coll detect: [ :each | each realm notNil ] ifNone: [ nil ].	^val realm</body><body package="HTTP">digestScheme	^self value select: [ :each | each isDigest ]</body><body package="HTTP">scheme	^self schemes first</body><body package="HTTP">schemes	| coll |	coll := OrderedCollection new.	self value do: [ :each | ('negotiate' match: each scheme asLowercase) ifFalse: [coll add: each scheme] ].	^coll</body><body package="HTTP">valueWithParamsClass	^AuthenticationValue</body></methods><methods><class-id>Net.AuthenticateField</class-id> <category>testing</category><body package="HTTP">canNegotiate	^'negotiate' match: self first scheme asLowercase</body><body package="HTTP">hasBasicAuth	^self basicScheme notEmpty</body><body package="HTTP">hasBearerAuth	^self bearerScheme notEmpty</body><body package="HTTP">hasDigestAuth	^self digestScheme notEmpty</body></methods><methods><class-id>Net.AuthenticateField</class-id> <category>parsing</category><body package="HTTP">newValueFrom: scanner	| authVal | 	authVal := self valueWithParamsClass newWithSeparators: self separators.	authVal parseValue: scanner.	^self privateNewValueFrom: authVal</body></methods><methods><class-id>Net.AuthenticateField</class-id> <category>private parsing</category><body package="HTTP">privateNewValueFrom: authValue	authValue isDigest		ifTrue: 			[ ^DigestAuthenticationValue new					separators: authValue separators;					yourself ].	^authValue</body></methods><methods><class-id>Net.AuthenticateField</class-id> <category>composing</category><body package="HTTP">writeOn: aStream encoding: aString"Write one challenge per header field "		| val |	self value ifNotNil: [ :v | val := v ] ifNil: [val := OrderedCollection with: nil].	val do: [ :param |  		self  writeNameOn: aStream.		param			ifNil: [ aStream nextPutAll: '']			ifNotNil: [ param writeOn: aStream encoding: aString ].		aStream cr. ].</body></methods><methods><class-id>Net.AuthenticateField</class-id> <category>printing</category><body package="HTTP">printOn: aStream indent: level"Print one challenge per header field "	| val |	self value ifNotNil: [ :v | val := v ] ifNil: [val := OrderedCollection with: nil].	val keysAndValuesDo: [ :ind :param |		aStream tab: level.		self  printNameOn: aStream.		param 			ifNil: [ aStream nextPutAll: '' ]			ifNotNil: [ [param printOn: aStream ]							on: Error 							do: [ :ex | aStream nextPutAll: '[printing error]'. ex return]].			"Print cr after each challenge but not after the last one. The last cr is printed in #printOn:indent: "			ind ~= val size ifTrue: [ aStream cr]]</body></methods><methods><class-id>Net.AuthenticateField class</class-id> <category>defaults</category><body package="HTTP">defaultSeparators	^#($  $, $  )</body></methods><methods><class-id>Net.AuthenticateField class</class-id> <category>parsing</category><body package="HTTP">fieldNames	^#('www-authenticate' 'proxy-authenticate')</body></methods><methods><class-id>Net.AuthorizationField</class-id> <category>accessing</category><body package="HTTP">basicValue	| s |	^(s := self basicScheme) notEmpty 		ifTrue: [ s first basicValue ]		ifFalse: [ nil ]</body><body package="HTTP">bearerValue	| s |	^(s := self bearerScheme) notEmpty 		ifTrue: [ s first bearerValue ]		ifFalse: [ nil ]</body><body package="HTTP">digestValue	| s |	^(s := self digestScheme) notEmpty 		ifTrue: [ s first params ]		ifFalse: [ nil ]</body></methods><methods><class-id>Net.AuthorizationField class</class-id> <category>parsing</category><body package="HTTP">fieldNames	^#('authorization' 'proxy-authorization')</body></methods><methods><class-id>Net.AuthorizationField class</class-id> <category>instance creation</category><body package="HTTP">bearerB64Token: aString"https://tools.ietf.org/html/rfc6750credentials = Bearer 1*SP b64token"	^(self name: 'authorization') 		addBearer: aString;		yourself</body><body package="HTTP">bearerToken: aString"https://tools.ietf.org/html/rfc6750credentials = Bearer 1*SP b64token"	^self bearerB64Token: aString asByteArray asBase64String</body></methods><methods><class-id>Net.HttpEntity</class-id> <category>testing</category><body package="HTTP">canBeDecoded	^(self transferEncoding isNil and: [ self contentEncoding isNil ])</body><body package="HTTP">hasBody	^value isNil</body><body package="HTTP">hasConnectionClose"Does the receiver have a Connection: close header field ?	^&lt;Boolean&gt;"	self connection isNil ifTrue: [ ^false].	^(self connection detect: [ :val | 'close' match: val ] ifNone: [ nil ]) notNil</body><body package="HTTP">hasConnectionKeepAlive"Does the receiver have a Connection: keep-alive header field ?	^&lt;Boolean&gt;"	self connection isNil ifTrue: [ ^false].	^(self connection detect: [ :val |'keep-alive' match: val ] ifNone: [ nil ]) notNil</body><body package="HTTP">hasTransferEncoding	^self transferEncoding ~~ nil</body><body package="HTTP">isChunked	| coll |	^(coll := self transferEncoding) notNil 		and: [coll anySatisfy: [:vx | 'chunked' match: vx]]</body><body package="HTTP">isCompressed		^self isContentEncodingGZip or: [ self isTransferEncodingGZip ]</body><body package="HTTP">isConnectionPersistent"Does the receiver indicate a persistent connection.	^&lt;Boolean&gt;"	^self isConnectionTransient not</body><body package="HTTP">isConnectionTransient"Does the receiver indicate a transient connection.	^&lt;Boolean&gt;"	^self isHttp10		ifTrue: [ self hasConnectionKeepAlive not ]		ifFalse: [ self hasConnectionClose ].</body><body package="HTTP">isExtended	^(self fields detect: [ :field | self extendedFieldNames includes: field name] ifNone: [ nil] ) notNil</body><body package="HTTP">isHttp10	^self subclassResponsibility</body><body package="HTTP">isHttp11	^self isHttp10 not</body><body package="HTTP">isHttpEntity	^true</body><body package="HTTP">isMandatory	^self isExtended</body><body package="HTTP">isMimeEntity	^false</body><body package="HTTP">isMultipartByteranges	| v |	^(v := self contentType ) ~~ nil		and: ['multipart/byteranges' match: v ]</body><body package="HTTP">isRequest	^false</body><body package="HTTP">isResponse	^false</body><body package="HTTP">isTransferEncodingGZip	| coll |	^(coll := self transferEncoding) notNil 		and: [coll anySatisfy: [:vx | 'gzip' match: vx]]</body><body package="HTTP">isValid	^self subclassResponsibility</body><body package="HTTP">keepAlive"Persistent connections are the default for HTTP/1.1 messages; HTTP/1.1 spec introduce a new keyword (Connection: close) for declaring non-persistence. HTTP/1.1 defines the 'close' connection option  for the sender to signal that the connection will be closed after completion of the response. Persistent connections in HTTP/1.0 must be explicitly negotiated as they are not the default behavior. When it connects to an origin server, an HTTP/1.0 client MAY send the Keep-Alive connection-token : Connection: Keep-Alive  An HTTP/1.0 server would then respond with the Keep-Alive connection token and the client may proceed with an HTTP/1.0 (or Keep-Alive) persistent connection.A client MUST NOT send the Keep-Alive connection token to a proxy server as HTTP/1.0 proxy servers do not obey the rules of HTTP/1.1 for parsing the Connection header field."	self connection isNil ifTrue: [ ^false].	^(self connection detect: [ :val |'keep-alive' match: val ] ifNone: [ nil ]) notNil</body><body package="HTTP">needsContentTransferEncoding	^false</body></methods><methods><class-id>Net.HttpEntity</class-id> <category>mandatory extensions</category><body package="HTTP">addFor: fieldName namespace: nsString"Add new mandatory field  - man		with specified namespace - http://www.copyright.org/rights-managementnamespace id is generated dynamically""Man: http://www.copyright.org/rights-management; ns= xx"	| id |	id := self assignNextNamespaceId.	self addFor: fieldName namespace: nsString id: id.	^id</body><body package="HTTP">addFor: fieldName namespace: nsString id: idString"Add new mandatory field  - man		with specified namespace - http://www.copyright.org/rights-management		and id -  16""Man: http://www.copyright.org/rights-management; ns=16"	self addField: ( ManOptField field: fieldName namespace: nsString id: idString).	^idString</body><body package="HTTP">allExtendedFieldsForNamespace: nsString"Returns collection of extended fields for the specified namespace""Man: http://www.copyright.org/rights-management; ns=16C-Opt: http://www.copyright.org/rights-management; ns=15"	| list list1 |	list := OrderedCollection new: 10.	(list1 :=  self allMandatoryFieldsForNamespace:  nsString) isEmpty not		ifTrue: [ list addAll: list1 ].	(list1 :=  self allOptionalFieldsForNamespace: nsString) isEmpty not		ifTrue: [ list addAll: list1 ].	^list</body><body package="HTTP">allFieldsFor: fieldName namespace:  nsString"Returns collection of specified extended fields for the specified namespace""Man: http://www.copyright.org/rights-management; ns=16Man: http://www.copyright.org/rights-management; ns=15"	^(self fieldsAt: fieldName)		select: [ :field | (field namespaceMapAt: nsString) notNil ]</body><body package="HTTP">allFieldsWithId: idString"Returns collection of fields with the same header prefix ( namespace id)""16-copyright: http:/www.org/copyright.html16-contributions: http:/www.org/patches.html"	^self fields select: [ :field | (idString, '-*') match: field name]</body><body package="HTTP">allIdsForNamespace: nsString"Returns collection of namespace id's for all extended fields""Man: http://www.copyright.org/rights-management; ns=16Opt:  http://www.copyright.org/rights-management; ns=15""#( '16' '15')"	| list |	list := OrderedCollection new: 10.	self extendedFieldNames 		do: [ :fname | 			(self namespaceMapFor: fname) 				keysAndValuesDo: 					[ :k :v | 					(k equivalentTo: nsString ignoreCase: true) 						ifTrue: [ list add: v]]].	^list</body><body package="HTTP">allMandatoryFieldsForNamespace:  nsString"Returns collection of namespace id's for mandatory fields""Man: http://www.copyright.org/rights-management; ns=16C-Man:  http://www.copyright.org/rights-management; ns=15""#( '16' '15')"	| list1 list |	list := OrderedCollection new: 10.	self mandatoryFieldNames 		do: [ :fieldName |			(list1 := (self fieldsAt: fieldName)				select: [ :field | (field namespaceMapAt: nsString) notNil ]) isEmpty not		ifTrue: [ list addAll: list1]].	^list</body><body package="HTTP">allOptionalFieldsForNamespace:  nsString"Returns collection of namespace id's for optional fields""Opt: http://www.copyright.org/rights-management; ns=16C-Opt:  http://www.copyright.org/rights-management; ns=15""#( '16' '15')"	| list1 list |	list := OrderedCollection new: 10.	self optionalFieldNames		do: [ :fieldName |				(list1 := (self fields at: fieldName) select: [ :field | (field namespaceMapAt: nsString) notNil ]) isEmpty not					ifTrue: [ list addAll: list1]].	^list</body><body package="HTTP">assignNextNamespaceId"Dynamically creates next namespace id and returns it as a string" 	self nextNamespaceId: self nextNamespaceId + 1.	^self nextNamespaceId printString</body><body package="HTTP">extendedFieldForId: idString"Returns an extended field with the specified namespace id""Man: http://www.copyright.org/rights-management; ns=16"	| field |	(field :=  self mandatoryFieldForId: idString) notNil		ifTrue: [ ^field ].	(field :=  self optionalFieldForId: idString) notNil		ifTrue: [ ^field ].	^nil</body><body package="HTTP">extendedFieldNames	^#('man' 'c-man' 'opt' 'c-opt')</body><body package="HTTP">fieldAt: fieldName id: idString"Returns field with the specified namespace id (prefix)if this field is absent creates new header field ""16-copyright: http:/www.org/copyright.html"	^self getFieldAt: ( idString, '-', fieldName)</body><body package="HTTP">fieldAt: fieldName put: aValue id: idString"Set value (http:/www.org/copyright.html) 	for the specified field name (copyright)  	with namespace id (16)""16-copyright: http:/www.org/copyright.html"	(self getFieldAt: ( idString, '-', fieldName)) value: aValue</body><body package="HTTP">fieldValueAt: fieldName id: idString"Returns value (http:/www.org/copyright.html) for the specified field (16-copyright)""16-copyright: http:/www.org/copyright.html"	^self getValueFor: ( idString, '-', fieldName)</body><body package="HTTP">idFor: fieldName namespace: nsString"Returns namespace id for the specified mandatory(optional) field name and namespace""Man: http://www.copyright.org/rights-management; ns=16"" self idFor: 'man' namespace: 'http://www.copyright.org/rights-management' 	returns 16 "	^(self namespaceMapFor: fieldName) at: nsString</body><body package="HTTP">mandatoryFieldForId:  idString"Returns mandatory field for the specified id""Man: http://www.copyright.org/rights-management; ns=16""C-Man: http://www.copyright.org/rt; ns=15"	| field |	self mandatoryFieldNames do:		[ :fieldName |		(field := (self fieldsAt: fieldName)					detect: [ :fd | (fd namespaceMapKeyAtValue: idString) notNil ] ifNone: [nil]) notNil			ifTrue: [ ^field ]].	^nil</body><body package="HTTP">mandatoryFieldNames	^#('man' 'c-man')</body><body package="HTTP">namespaceFor: fieldName id:  idString"Returns namespace for the specified mandatory field and id""Man: http://www.copyright.org/rights-management; ns=16"" self namespaceFor: 'man' id: '16'	returns 'http://www.copyright.org/rights-management'  "	(self namespaceMapFor: fieldName)		keysAndValuesDo: 			[:aKey :aValue | aValue = idString ifTrue: [^aKey]].	^nil</body><body package="HTTP">namespaceForId:  idString"Returns namespace for the specified id""Man: http://www.copyright.org/rights-management; ns=16"" self namespaceForId: '16'  returns: 'http://www.copyright.org/rights-management'  "	self namespaceMap		keysAndValuesDo: 			[:aKey :aValue | aValue = idString ifTrue: [^aKey]].	^nil</body><body package="HTTP">namespaceMap"Returns a dictionary all namespaces and id'snamespace is a keynamespace id is a value"	| dict |	dict := Dictionary new.	self extendedFieldNames do: [ :fname |		(self namespaceMapFor: fname) associations do: [ :ea | dict add: ea] ].	^dict</body><body package="HTTP">namespaceMapFor: fnString"Returns a dictionary namespaces and id's for the specified field name ('man' 'opt' ...)namespace is a keynamespace id is a value"	| dict |	dict := Dictionary new.	(self fieldsAt: fnString) 		do: [ :field |   field namespaceMap associations do: [ :ea | dict add: ea] ].	^dict</body><body package="HTTP">nextNamespaceId"Returns namespace id (header-prefix)"	^nextNamespaceId isNil		ifTrue: [ nextNamespaceId := 10]		ifFalse: [ nextNamespaceId ]</body><body package="HTTP">nextNamespaceId: aNumber"Sets namespace id (header-prefix)"		nextNamespaceId := aNumber</body><body package="HTTP">optionalFieldForId:  idString"Returns optional field for the specified id""Opt: http://www.copyright.org/rights-management; ns=16""C-Opt: http://www.copyright.org/rt; ns=15"	| field |	self optionalFieldNames do:		[ :fieldName |		(field := (self fieldsAt: fieldName)					detect: [ :fd | (fd namespaceMapKeyAtValue: idString) notNil ] ifNone: [nil]) notNil			ifTrue: [ ^field ]].	^nil</body><body package="HTTP">optionalFieldNames	^#('opt' 'c-opt')</body><body package="HTTP">removeNamespace: nsString"Removes all fields for the specified namespace"	(self allIdsForNamespace: nsString)		do: [ :id | self removeNamespaceId: id ].</body><body package="HTTP">removeNamespaceId: idString"Removes all fields for the specified namespace id""Man: 'http://www.copyright.org/rights-management'; ns=14Man: 'http://www.copyright.org/rights-mgt'; ns=15, 'http://www.copyright.org/rt13'; ns=1314-Credentials: 'g5gj262jdw@4df'13-Credentials: 'QQQQ'  self removeNamespaceId: '13'.Result:Man: http://www.copyright.org/rights-management; ns=14Man: 'http://www.copyright.org/rights-mgt'; ns=1514-Credentials: 'g5gj262jdw@4df'  "	| field |	(self allFieldsWithId: idString)		do: [ :fd |  self removeFieldAt: fd name].	field := self extendedFieldForId: idString.	field removeId: idString.	field value isEmpty ifTrue: [ self removeField: field ].</body></methods><methods><class-id>Net.HttpEntity</class-id> <category>accessing fields</category><body package="HTTP">allow	^self fieldValueAt: 'allow'</body><body package="HTTP">allow: stringOrCollection	(self getFieldAt: 'allow') value: stringOrCollection</body><body package="HTTP">cacheControl	^self fieldAt: 'cache-control'</body><body package="HTTP">cacheControl: aStringOrAssociationOrCacheControl	(aStringOrAssociationOrCacheControl isKindOf: CacheControl) 		ifTrue: 			[self removeFieldAt: 'cache-control'.			self addField: aStringOrAssociationOrCacheControl]		ifFalse: [(self getFieldAt: 'cache-control') addDirective: aStringOrAssociationOrCacheControl]</body><body package="HTTP">connection	^self fieldValueAt: 'connection'</body><body package="HTTP">connection: aString	(self getFieldAt: 'connection') value: aString</body><body package="HTTP">contentBase	^self fieldValueAt: 'content-base'</body><body package="HTTP">contentBase: aString	(self getFieldAt: 'content-base') value: aString</body><body package="HTTP">contentEncoding	^self fieldValueAt: 'content-encoding'</body><body package="HTTP">contentEncoding: aCollectionField	(self getFieldAt: 'content-encoding') value: aCollectionField</body><body package="HTTP">contentLanguage	^self fieldValueAt: 'content-language'</body><body package="HTTP">contentLanguage: aString	(self getFieldAt: 'content-language') value: aString</body><body package="HTTP">contentLocation	^self fieldValueAt: 'content-location'</body><body package="HTTP">contentLocation: aString	(self getFieldAt: 'content-location') value: aString</body><body package="HTTP">contentMD5	^self fieldValueAt: 'content-md5'</body><body package="HTTP">contentMD5: aString	(self getFieldAt: 'content-md5') value: aString</body><body package="HTTP">contentRange	^self fieldValueAt: 'content-range'</body><body package="HTTP">contentRange: aString	(self getFieldAt: 'content-range') value: aString</body><body package="HTTP">cookie	^self fieldAt: 'cookie'</body><body package="HTTP">cookie2	^self fieldAt: 'cookie2'</body><body package="HTTP">cookie2: aCookie2Field 	(self getFieldAt: 'cookie2') value: aCookie2Field</body><body package="HTTP">cookie: aCookieField 	self fieldAt: 'cookie' put: aCookieField</body><body package="HTTP">date	^self fieldValueAt: 'date'</body><body package="HTTP">date: aTimestampOrStringOrArray	(self getFieldAt: 'date') value: aTimestampOrStringOrArray</body><body package="HTTP">etag	^self fieldValueAt: 'etag'</body><body package="HTTP">etag: aString	(self getFieldAt: 'etag') value: aString</body><body package="HTTP">expires	^self fieldValueAt: 'expires'</body><body package="HTTP">expires: aTimestampOrStringOrArray	(self getFieldAt: 'expires') value: aTimestampOrStringOrArray</body><body package="HTTP">from	^self fieldValueAt: 'from'</body><body package="HTTP">from: aString	(self getFieldAt: 'from') value: aString</body><body package="HTTP">lastModified	^self fieldValueAt: 'last-modified'</body><body package="HTTP">lastModified: aTimestampOrStringOrArray	(self getFieldAt: 'last-modified') value: aTimestampOrStringOrArray</body><body package="HTTP">pragma	^self fieldValueAt: 'pragma'</body><body package="HTTP">pragma: aString	(self getFieldAt: 'pragma') value: aString</body><body package="HTTP">removeFromCacheControl: aString	(self getFieldAt: 'cache-control') removeDirective: aString</body><body package="HTTP">setCookie	^self fieldAt: 'set-cookie'</body><body package="HTTP">setCookie: aSetCookieField 	(self getFieldAt: 'set-cookie') value: aSetCookieField</body><body package="HTTP">setCookieFields	| coll sc |	coll := OrderedCollection new.	(sc := self fieldAt: 'set-cookie') notNil ifTrue: [ coll add: sc ].	^coll</body><body package="HTTP">transferCoding	^self fieldValueAt: 'transfer-coding'</body><body package="HTTP">transferCoding: aString	^self fieldValueAt: 'transfer-coding' put: aString</body><body package="HTTP">transferEncoding	^self fieldValueAt: 'transfer-encoding'</body><body package="HTTP">transferEncoding: aStringOrColl	| val |	val := aStringOrColl isString 			ifTrue: [ OrderedCollection with: aStringOrColl]			ifFalse: [ aStringOrColl ].			^self fieldValueAt: 'transfer-encoding' put: val</body><body package="HTTP">via	^self fieldValueAt: 'via'</body><body package="HTTP">via: aString	(self getFieldAt: 'via') value: aString</body></methods><methods><class-id>Net.HttpEntity</class-id> <category>accessing</category><body package="HTTP">keepAlive: aBoolean	| val  token |	token := aBoolean ifTrue: ['Keep-Alive'] ifFalse: ['close'].	val := (self getFieldAt: 'connection') value.	#('Keep-Alive' 'close') do: [ :t | val removeAllSuchThat:[ :elem | t match:  elem ]].	val add: token.</body><body package="HTTP">messageLine	^self subclassResponsibility</body><body package="HTTP">messageLine: anObject	self subclassResponsibility</body></methods><methods><class-id>Net.HttpEntity</class-id> <category>accessing body parts</category><body package="HTTP">byteContents	| s |	^(s := self byteSource)  isNil		ifTrue: [ nil ]		ifFalse: [ s reset; contents ]</body><body package="HTTP">byteSource	^self body byteSource</body><body package="HTTP">byteSource: aByteArrayStream	self body byteSource: aByteArrayStream</body><body package="HTTP">contents"Returns the message body contents. If the entity still has compressed body contents the method returns the compressed bytes  "	| v ce |	^((ce := self contentEncoding) notNil and: ['gzip' match: ce ])		ifTrue: [self byteContents]		ifFalse: [(v := self body value) ifNotNil: [ v asString ]]</body><body package="HTTP">decodedContents"Returns decoded body contents. If the entity still has compressed body contents the method decompresses the body and returns decoded body contents  "	| ce |	^((ce := self contentEncoding) notNil and: ['gzip' match: ce ])		ifTrue: [(self body decompressedContents withEncoding: self charset ) readStream contents]		ifFalse: 	[self decodedContentsWith: self charset ]</body><body package="HTTP">decompressedContents"Returns decompressed body contents. The body contents won't be changed "	| ce |	ce := self contentEncoding.	^(ce notNil and: ['gzip' match: ce ])		ifTrue: [self body decompressedContents]		ifFalse: 	[self decodedContents]</body></methods><methods><class-id>Net.HttpEntity</class-id> <category>private</category><body package="HTTP">decodedByteContentsStream	| ce |	^((ce := self contentEncoding) notNil and: ['gzip' match: ce ])		ifTrue: [(self body decompressedContents withEncoding: self charset ) readStream ]		ifFalse: 	[super decodedByteContentsStream]</body><body package="HTTP">hasByteSource	^self byteSource notNil</body></methods><methods><class-id>Net.HttpEntity</class-id> <category>visiting</category><body package="HTTP">acceptVisit: aVisitor with: argument	^aVisitor acceptMessage: self with: argument</body></methods><methods><class-id>Net.HttpEntity</class-id> <category>printing options</category><body package="HTTP">chunkSize	^self writingOptions chunkSize</body><body package="HTTP">chunkSize: aNumber	self writingOptions chunkSize: aNumber</body><body package="HTTP">doChunk	self shouldChunk: true</body><body package="HTTP">doNotChunk	self shouldChunk: false</body><body package="HTTP">shouldChunk	^self writingOptions shouldChunk</body><body package="HTTP">shouldChunk: aBoolean	self writingOptions shouldChunk: aBoolean</body><body package="HTTP">useGZipTransfer	^self writingOptions useGZipTransfer</body><body package="HTTP">useGZipTransfer: aBoolean	self writingOptions useGZipTransfer: aBoolean</body></methods><methods><class-id>Net.HttpEntity</class-id> <category>parsing options</category><body package="HTTP">decodeContents	^self readingOptions decodeContents</body><body package="HTTP">decodeContents: aBoolean	self readingOptions decodeContents: aBoolean</body><body package="HTTP">decompressContents	^self readingOptions decompressContents</body><body package="HTTP">decompressContents: aBoolean	self readingOptions decompressContents: aBoolean</body></methods><methods><class-id>Net.HttpEntity class</class-id> <category>defaults</category><body package="HTTP">defaultReadingOptionsType	^HttpBuildHandler defaultOptionsType</body><body package="HTTP">defaultWritingOptionsType	^HttpWriteHandler defaultOptionsType</body></methods><methods><class-id>Net.UnspecifiedBodySize</class-id> <category>constants</category><body package="HTTP">defaultResumeValue	"Answer the default value to resume with."	^false</body></methods><methods><class-id>Net.UnspecifiedBodySize</class-id> <category>printing</category><body package="HTTP">defaultMessageText	^(#MessageBodySizeIsNotSpecified &lt;&lt; #net &gt;&gt; 'The message body size is not specified &lt;n&gt; &lt;1s&gt;' ) expandMacrosWith: parameter printStatusLineMessage</body></methods><methods><class-id>Net.BodyWriteStream</class-id> <category>accessing</category><body package="HTTP">buffer		^buffer</body><body package="HTTP">flush</body><body package="HTTP">nextPut: anObject 		buffer nextPut: anObject</body><body package="HTTP">onFinishDo	^onFinishDo</body><body package="HTTP">onFinishDo: aBlock	onFinishDo := aBlock</body></methods><methods><class-id>Net.BodyWriteStream</class-id> <category>initialize-release</category><body package="HTTP">initializeOn: aStream	stream := aStream.	buffer := (ByteArray new: 1024) readWriteStream</body></methods><methods><class-id>Net.BodyWriteStream</class-id> <category>status</category><body package="HTTP">finish	self onFinishDo ifNotNil: [ :block | block value: buffer position ].	stream binary.	buffer reset. 	stream nextPutAll: buffer contents.	stream flush</body></methods><methods><class-id>Net.HttpException</class-id> <category>printing</category><body package="HTTP">defaultMessageText	^super defaultMessageText, '\(' withCRs, parameter printStatusLineMessage, ')'</body></methods><methods><class-id>Net.HttpException class</class-id> <category>handling http responses</category><body package="HTTP">handleResponse: resp	"trigger exceptions for all responses but 2xx (success) "	| exp |	resp isSuccess 		ifFalse: 			[ exp := (self preferences detect: [ :ea | ea key match: resp code ]) value.			exp signalWith: resp].	^resp</body><body package="HTTP">initializePreferences	"self initializePreferences "	Preferences := (OrderedCollection new: 13)		add: '400' -&gt; HttpBadRequest;		add: '401' -&gt; HttpUnauthorizedError;		add: '404' -&gt; HttpObjectNotFound;		add: '407' -&gt; HttpProxyAuthenticationError;		add: '301' -&gt;  HttpMovedError;		add: '302' -&gt;  HttpMovedError;		add: '510' -&gt; HttpNotExtendedError;		add: '1*' -&gt; HttpInformationalError;		add: '3*' -&gt;  HttpRedirectionError;		add: '4*' -&gt; HttpClientError;		add: '5*' -&gt; HttpServerError;		add: '*' -&gt; HttpException;		yourself.</body><body package="HTTP">preferences	Preferences isNil ifTrue: [ self initializePreferences].	^Preferences</body></methods><methods><class-id>Net.HttpException class</class-id> <category>testing</category><body package="HTTP">mayResume	^true</body></methods><methods><class-id>Net.HttpMovedError</class-id> <category>accessing</category><body package="HTTP">location	^self parameter location</body></methods><methods><class-id>Net.HttpAuthentication</class-id> <category>accessing</category><body package="HTTP">authChallenge	^authChallenge</body><body package="HTTP">authChallenge: anAuthenticateChallenge	authChallenge := anAuthenticateChallenge.</body><body package="HTTP">authPolicy	^authPolicy</body><body package="HTTP">authValue	^authValue</body><body package="HTTP">authValue: anAuthenticationValue	authValue := anAuthenticationValue</body><body package="HTTP">password	^self user password</body><body package="HTTP">pathString	 ^pathString</body><body package="HTTP">realm	^self user realm</body><body package="HTTP">scheme	^self class scheme</body><body package="HTTP">user			^authPolicy user</body><body package="HTTP">username	^self user username</body></methods><methods><class-id>Net.HttpAuthentication</class-id> <category>authorization</category><body package="HTTP">acceptAuthInfoFrom: anAuthInfo</body><body package="HTTP">addAuthorizationTo: aHttpRequest for: headerString	| header |	self setPathStringFrom: aHttpRequest.	header := aHttpRequest getFieldAt: headerString.  	(self isAuthorized or: [self isAuthorizationInProgress])		ifTrue: [ self setNextAuthorizationValueFor: header ]		ifFalse: 			[self authValue: (header addScheme: self scheme).			self setNewAuthorizationValue.]</body><body package="HTTP">setNewAuthorizationValue	self subclassResponsibility</body><body package="HTTP">setNextAuthorizationValueFor: header	header value add: self authValue.</body><body package="HTTP">setPathStringFrom: aHttpRequest	pathString := aHttpRequest requestLine pathString</body></methods><methods><class-id>Net.HttpAuthentication</class-id> <category>state</category><body package="HTTP">setAuthorizationInProgressState	state := #authorizationInProgress</body><body package="HTTP">setAuthorizedState	state := #authorized</body><body package="HTTP">setNotAuthorizedState	authValue := nil.	state := #notAuthorized</body></methods><methods><class-id>Net.HttpAuthentication</class-id> <category>testing</category><body package="HTTP">canAccept: anAuthorizationField	^false</body><body package="HTTP">canProceedWith: anAuthorizationField	^anAuthorizationField isNil		or: [ self username ~= self authPolicy username and: [self password ~= self authPolicy password]]</body><body package="HTTP">isAuthorizationInProgress	^state = #authorizationInProgress</body><body package="HTTP">isAuthorized	^state = #authorized</body><body package="HTTP">isNotAuthorized	^state = #isNotAuthorized</body></methods><methods><class-id>Net.HttpAuthentication</class-id> <category>initialize-release</category><body package="HTTP">initialize	self setNotAuthorizedState</body><body package="HTTP">setAuthPolicy: anAuthPolicyHolder	authPolicy := anAuthPolicyHolder.</body></methods><methods><class-id>Net.HttpAuthentication</class-id> <category>select challenge</category><body package="HTTP">proceedWith: authenticate	| challenges |	challenges := authenticate value select: [ :val | self class acceptScheme: val scheme].	self setAuthChallengeFrom: challenges. 	^challenges notEmpty</body><body package="HTTP">selectAuthChallenge: aCollOfAuthenticateChallenge	^self realm isNil		ifTrue: [ aCollOfAuthenticateChallenge first ]		ifFalse: [ aCollOfAuthenticateChallenge 					detect: [ :chall | self user acceptsRealm: chall realm ] 					ifNone: [ HttpAuthenticationExc 								raiseRequestWith: aCollOfAuthenticateChallenge								errorString: (#CannotFindRealm &lt;&lt; #net &gt;&gt; 'Can not find realm &lt;1s&gt; in &lt;2s&gt;' expandMacrosWith:  self realm with: aCollOfAuthenticateChallenge printString) ]]</body><body package="HTTP">setAuthChallenge: anAuthenticateChallenge	self authChallenge: anAuthenticateChallenge.	self setNotAuthorizedState.</body><body package="HTTP">setAuthChallengeFrom: anAuthenticateChallengeOrCollection	| ch |	anAuthenticateChallengeOrCollection isEmpty ifTrue: [ ^nil].	(ch := self selectAuthChallenge: anAuthenticateChallengeOrCollection) isNil		ifTrue: 			[ HttpAuthenticationExc 				raiseRequestWith: anAuthenticateChallengeOrCollection				errorString: (#CanNotProcessAuthChallenge &lt;&lt; #net &gt;&gt; 'Can not process authentication challege: &lt;1s&gt;' expandMacrosWith:  anAuthenticateChallengeOrCollection printString) ].	self setAuthChallenge:  ch.</body></methods><methods><class-id>Net.HttpAuthentication class</class-id> <category>accessing</category><body package="HTTP">acceptScheme: aString	^aString match: self scheme</body><body package="HTTP">scheme	^self subclassResponsibility</body></methods><methods><class-id>Net.HttpAuthentication class</class-id> <category>instance creation</category><body package="HTTP">new	^super new initialize</body><body package="HTTP">policy: anAuthPolicy	^self new		setAuthPolicy: anAuthPolicy;		yourself</body></methods><methods><class-id>Net.DigestAuthentication</class-id> <category>accessing</category><body package="HTTP">defaultAlgorithm	^defaultAlgorithm ifNil: [defaultAlgorithm := self class defaultAlgorithm]</body><body package="HTTP">defaultAlgorithm: aString	defaultAlgorithm :=  aString</body><body package="HTTP">nextNonceCount	self nonceCount: self nonceCount + 1.	^self nonceCount</body><body package="HTTP">nonceCount	^nonceCount ifNil: [ self resetNonceCount]</body><body package="HTTP">nonceCount: aNumber	nonceCount := aNumber</body><body package="HTTP">resetNonceCount	nonceCount := 0.</body></methods><methods><class-id>Net.DigestAuthentication</class-id> <category>private authorization</category><body package="HTTP">H: data"Apply the H function (hash) to the argument as defined in section 3.2.1 The WWW-Authenticate Response Header.	data &lt;String&gt; ascii string of data to hash	^&lt;String&gt;	the hash value converted to a hex string [0-9a-f]"	^self LHEX: (Security.MD5 hash: data asByteArray)</body><body package="HTTP">LHEX: bytes"Convert bytes to the LHEX format as specified in RFC 2617, section 3.1.3 Representation of digest values	bytes &lt;ByteArray&gt; binary value	^&lt;String&gt;	the binery value converted into a hex string [0-9a-f]"	| lookup s ws |	lookup := '0123456789abcdef'.	s := String new: bytes size * 2.	ws := s writeStream.	bytes do: [ :b |		ws nextPut: (lookup at: (b bitShift: -4) + 1).		ws nextPut: (lookup at: (b bitAnd: 15) + 1) ].	^s</body><body package="HTTP">a1Value	^self authValue algorithm = 'MD5-sess' 		ifTrue: [self md5SessData]		ifFalse: [self md5Data].</body><body package="HTTP">a2Value"If the 'qop' directive's value is 'auth' or is unspecified, then A2  is:A2   = Method ':' digest-uri-valueIf the 'qop' value is 'auth-int', then A2 is:A2   = Method ':' digest-uri-value ':' H(entity-body) "	| string |	string := 'GET:', self pathString.	^self H: (		self authValue qop = 'auth'			ifTrue: [string]			ifFalse: [string, ':', self entityHash])</body><body package="HTTP">cnonce: aString	self authValue cnonce:  aString</body><body package="HTTP">entityHash"Also note that if integrity protection is applied (qop=auth-int), the H(entity-body) is the hash of the entity body, not the message body -   it is computed before any transfer encoding is applied by the sender and after it has been removed by the recipient. Note that this includes multipart boundaries and embedded headers in each part of any multipart content-type. ""	authorizationHeader parent  "	^self error: (#AuthIntNotImplemented &lt;&lt; #net &gt;&gt; '&lt;qop=auth-int&gt; option has not been implemented in this release.')</body><body package="HTTP">md5Data"   If the 'algorithm' directive's value is MD5 or is unspecified, then A1 is: A1       = unq(username-value) ':' unq(realm-value) ':' passwd   where passwd   = &lt; user's password &gt; "	| stream |	stream := WriteStream on: String new.	stream nextPutAll: self username, ':', self authValue realm, ':', self password.	^self H: stream contents</body><body package="HTTP">md5SessData" If the 'algorithm' directive's value is 'MD5-sess',   then A1 is calculated only once - on the first request by the client following   receipt of a WWW-Authenticate challenge from the server.  It uses the server nonce from that challenge, and the first client nonce value to construct A1 as follows:   A1  = H( unq(username-value) ':' unq(realm-value) ':' passwd ) ':' unq(nonce-value) ':' unq(cnonce-value) "	| stream |	md5SessData ifNil:		[stream := WriteStream on: String new.		stream nextPutAll: self username, ':', self authValue realm, ':', self password.		md5SessData := ((self H: stream contents), 							':', self authValue nonce, 							':', self authValue cnonce) ].	^md5SessData</body><body package="HTTP">setDigestResponse"If the 'qop' value is 'auth' or 'auth-int'         KD(secret, data) = H(concat(secret, ':', data))      request-digest  = &lt;''&gt; &lt; KD ( H(A1),  			unq(nonce-value) ':' nc-value ':' unq(cnonce-value) ':' unq(qop-value) ':' H(A2)  ) &lt;''&gt;  If the 'qop' directive is not present (this construction is for compatibility with RFC 2069):     request-digest  = &lt;''&gt; &lt; KD ( H(A1), unq(nonce-value) ':' H(A2) ) &gt; &lt;''&gt;"	| hashStream data |	hashStream := WriteStream on: String new.	hashStream nextPutAll: self authValue nonce.	self authValue qop ifNotNil:		[hashStream nextPut: $:.		self authValue writeNonceCountOn: hashStream.		hashStream nextPut: $:.		hashStream nextPutAll: self authValue cnonce.		hashStream nextPut: $:.		hashStream nextPutAll: self authValue qop].	hashStream nextPut: $:.	hashStream nextPutAll: self a2Value.	data := hashStream contents.	^self H: (self a1Value, ':', data)</body><body package="HTTP">setQopValue" 'auth'- authentication; 'auth-int' - authentication with integrity protection. Unrecognized options MUST be ignored."	| qop |	self authValue nc: self nextNonceCount.	self authValue cnonce ifNil:		[ self authValue cnonce: (self H: Timestamp now asSeconds printString) ].	(qop := self authChallenge qop detect: [ :each | each  = 'auth' ] ifNone: [nil]) notNil			ifTrue: [^self authValue qop: qop].	(self authValue qop detect: [ :each | each  = 'auth-int' ] ifNone: [nil]) notNil		ifTrue: [ " raise not implemented exception " self entityHash ]</body></methods><methods><class-id>Net.DigestAuthentication</class-id> <category>select challenge</category><body package="HTTP">selectAuthChallenge: aCollOfAuthenticateChallenge	^aCollOfAuthenticateChallenge 		detect: [ :auth | 				(self user acceptsRealm: auth realm )					and: [auth algorithm isNil							or: [( 'MD5' match: auth algorithm) 								or: [( 'MD5-sess' match: auth algorithm)]]]] 		ifNone: [nil]</body></methods><methods><class-id>Net.DigestAuthentication</class-id> <category>authorization</category><body package="HTTP">acceptAuthInfoFrom: aHttpResponse	| anAuthInfo v next |	anAuthInfo := aHttpResponse fieldAt: 'authentication-info' ifAbsent: [^nil].	((v := anAuthInfo value) notEmpty and: [(next :=  v  first nextNonce) notNil ]) 		ifTrue: 			[self authValue nonce: next.			self resetNonceCount ].</body><body package="HTTP">setNewAuthorizationValue	self resetNonceCount.	self authValue 		username: self username;		realm: self authChallenge realm;		nonce: self authChallenge nonce;		uri: self pathString.	self authChallenge opaque 		ifNotNil: [ self authValue opaque: self authChallenge opaque].	self authValue algorithm 		ifNil: [ self authValue algorithm: self defaultAlgorithm ]. 	self authChallenge qop ifNotNil: [self setQopValue ]. 	self authValue response: self setDigestResponse.	self setAuthorizedState</body><body package="HTTP">setNextAuthorizationValueFor: header	self authValue qop ifNotNil: [		"increase the nonce count"		self authValue			nc: self nextNonceCount;			response: self setDigestResponse ].	super setNextAuthorizationValueFor: header</body><body package="HTTP">setPathStringFrom: aHttpRequest	aHttpRequest requestLine pathString ~= self pathString		ifTrue: 			[pathString := aHttpRequest requestLine pathString.			self setNotAuthorizedState  ].</body></methods><methods><class-id>Net.DigestAuthentication</class-id> <category>testing</category><body package="HTTP">canAccept: anAuthentication	| ch challenge |	((challenge := anAuthentication value 					select: [ :val | self class acceptScheme: val scheme]) notEmpty 		and: [(ch := self selectAuthChallenge: challenge ) notNil			and: [ch realm ~= authValue realm or: [ch isStaleTrue] ]])		ifTrue: [self setAuthChallenge:  ch. ^true].	^false</body></methods><methods><class-id>Net.DigestAuthentication class</class-id> <category>defaults</category><body package="HTTP">defaultAlgorithm	^defaultAlgorithm ifNil: [ defaultAlgorithm := self defaultAlgorithmValue ]</body><body package="HTTP">defaultAlgorithm: aString	defaultAlgorithm := aString</body><body package="HTTP">defaultAlgorithmValue	^'MD5'</body><body package="HTTP">scheme	^'Digest'</body></methods><methods><class-id>Net.HttpPrintHandler</class-id> <category>printing utilities</category><body package="HTTP">printPreambule: aMessageBody	^true</body></methods><methods><class-id>Net.HttpPrintHandler</class-id> <category>defaults</category><body package="HTTP">dispatcherClass	^HttpDispatcher</body></methods><methods><class-id>Net.HttpPrintHandler</class-id> <category>private</category><body package="HTTP">isBinaryContent: aStream entity: anEntity	^(super isBinaryContent: aStream entity: anEntity)		or: [anEntity isContentEncodingGZip ]</body></methods><methods><class-id>Net.HttpPrintHandler class</class-id> <category>defaults</category><body package="HTTP">defaultOptionsType	^HttpWritingOptions</body></methods><methods><class-id>Net.HttpParser</class-id> <category>parsing</category><body package="HTTP">endMessageBody:  aBody from:  aStream	"Apparently when chunking it is allowed to append additional header fields after the chunked body, referred to as a 'trailer'.	Go figure, I wonder how many HTTP stacks can handle that. In any case we will handle it too."	aBody parent isChunked ifTrue: [		aStream text.		"Read an optional trailer containing additional entity-header for chunked messages.				There must be at least the terminating CRLF of the chunked body still left on aStream.			       Chunked-Body   = *chunk                  		      last-chunk		                        trailer            		            CRLF		"		self privateParseHeader: aBody parent header from: aStream ].	super endMessageBody: aBody from:  aStream</body><body package="HTTP">startMessageFrom: aStream	| fLine aString |	aStream text.	aString := aStream nextLine.	aString isEmpty 		ifTrue: [^HttpStatusLineError new				messageText: (#EmptyHttpResponseStatusLine &lt;&lt; #net &gt;&gt; 'Can not read external stream, returns empty the Http response status line') asString;				raiseSignal].	fLine := ('http' = (aString copyFrom: 1 to: 4) asLowercase)		ifTrue: [HttpResponseStatusLine readFrom: aString readStream]		ifFalse: [HttpRequestLine readFrom: aString readStream ].	(fLine isNil or: [ fLine isValid not ])		ifTrue: [ ^HttpEntityError new messageText: ((#WrongResponseStatusLine &lt;&lt; #net &gt;&gt; 'Wrong response status line: &lt;1s&gt;')			expandMacrosWith: fLine printString); raiseSignal ].	^self handler startMessage: fLine.</body></methods><methods><class-id>Net.HttpParser class</class-id> <category>defaults</category><body package="HTTP">encoder	^HttpConnection defaultEncoding</body></methods><methods><class-id>Net.AcceptHeaderFields</class-id> <category>accessing</category><body package="HTTP">qValueAt: index	^(self value at: index) paramAt: 'q'</body></methods><methods><class-id>Net.AcceptHeaderFields</class-id> <category>adding  range</category><body package="HTTP">addValue: vString qValue: qString	| valWithParams |	valWithParams := ValueWithParams newWithSeparators: self separators.	valWithParams value: vString.	qString notNil ifTrue: [ valWithParams paramAt: 'q' put: qString].	self value add: valWithParams.	^valWithParams</body></methods><methods><class-id>Net.AcceptHeaderFields class</class-id> <category>defaults</category><body package="HTTP">defaultSeparators	^#($; $; $,  )</body></methods><methods><class-id>Net.ManOptField</class-id> <category>accessing</category><body package="HTTP">addNamespace: urlString id: idNumber		| valWithParams |	valWithParams := ValueWithParams newWithSeparators: self separators.	valWithParams value: urlString.	idNumber notNil ifTrue: [valWithParams paramAt: 'ns' put: idNumber].	self value add: valWithParams.	^valWithParams</body><body package="HTTP">id	^self element paramAt: 'ns'</body><body package="HTTP">id: idNumber		self element paramAt: 'ns' put: idNumber</body><body package="HTTP">namespace	^self element value</body><body package="HTTP">namespace: urlString		self element value: urlString</body><body package="HTTP">namespace: urlString id: idNumber		self 		namespace: urlString;		id: idNumber</body></methods><methods><class-id>Net.ManOptField</class-id> <category>queries</category><body package="HTTP">idForNamespace: urlString	^self idForNamespace: urlString ifAbsent: [nil]</body><body package="HTTP">idForNamespace: urlString ifAbsent: aBlock	| param |	param := self value detect: [ :ea | ea value = urlString] ifNone: [ nil].	^param notNil 		ifTrue: [ param paramAt: 'ns']		ifFalse: [ aBlock value]</body><body package="HTTP">namespaceForId: idNumber	^self namespaceForId: idNumber ifAbsent: [nil]</body><body package="HTTP">namespaceForId: idNumber ifAbsent: aBlock	| param |	param := self value detect: [ :ea | (ea paramAt: 'ns') = idNumber] ifNone: [ nil].	^param notNil 		ifTrue: [ param value ]		ifFalse: [ aBlock value ]</body><body package="HTTP">namespaceMap	|dict|	dict := Dictionary new.	self value do: [ :ea | dict at: ea value put: (ea paramAt: 'ns')].	^dict</body><body package="HTTP">namespaceMapAt: nsString	^self namespaceMapAt: nsString ifAbsent: nil</body><body package="HTTP">namespaceMapAt: nsString ifAbsent: aBlock	^self namespaceMap at: nsString ifAbsent: [aBlock].</body><body package="HTTP">namespaceMapKeyAtValue: idString	^self namespaceMapKeyAtValue: idString ifAbsent: nil</body><body package="HTTP">namespaceMapKeyAtValue: idString ifAbsent: aBlock	self namespaceMap keysAndValuesDo: 		[:aKey :aValue |  idString = aValue ifTrue: [^aKey]].	^aBlock value</body><body package="HTTP">removeId: idString	self value removeAllSuchThat: 		 [ :valWithParams |			(valWithParams paramAt: 'ns')  = idString ]</body></methods><methods><class-id>Net.ManOptField class</class-id> <category>parsing</category><body package="HTTP">fieldNames	^#('man' 'opt' 'c-man' 'c-opt' )</body></methods><methods><class-id>Net.ManOptField class</class-id> <category>instant creation</category><body package="HTTP">field: aFieldName namespace: nsString id: idString	^(self name: aFieldName) 		addNamespace: nsString id: idString;		yourself</body></methods><methods><class-id>Net.DigestAuthenticationValue</class-id> <category>accessing</category><body package="HTTP">algorithm 	^self paramAt:  'algorithm'</body><body package="HTTP">algorithm: aString	^self paramAt:  'algorithm' put: aString</body><body package="HTTP">authParam"This directive allows for future extensions."	^self paramAt:  'auth-param'</body><body package="HTTP">authParam: aString	^self paramAt:  'auth-param' put: aString</body><body package="HTTP">cnonce"This MUST be specified if a qop directive is sent "	^self paramAt:  'cnonce'</body><body package="HTTP">cnonce: aString	^self paramAt:  'cnonce' put: aString</body><body package="HTTP">digestUri"The URI from Request-URI of the Request-Line; duplicated here because proxies are allowed to change the Request-Line in transit."	^self paramAt:  'digest-uri'</body><body package="HTTP">digestUri: aString	^self paramAt:  'digest-uri' put: aString</body><body package="HTTP">nc	^self paramAt:  'nc'</body><body package="HTTP">nc: aNumber	^self paramAt:  'nc' put: aNumber</body><body package="HTTP">nonce	^self paramAt:  'nonce'</body><body package="HTTP">nonce: aString	self paramAt:  'nonce' put: aString</body><body package="HTTP">opaque"A string of data, specified by the server, which should be returned by the client unchanged in the Authorization header of subsequent requests with URIs in the same protection space. It is recommended that this string be base64 or hexadecimal data."	^self paramAt:  'opaque'</body><body package="HTTP">opaque: aString	^self paramAt:  'opaque' put: aString</body><body package="HTTP">qop"Indicates what 'quality of protection' the client has applied to the message"	^self paramAt:  'qop'</body><body package="HTTP">qop: aCollection"      qop-options       = qop = &lt;''&gt; 1#qop-value &lt;''&gt;      qop-value         = auth | auth-int | token"	self paramAt:  'qop' put: aCollection</body><body package="HTTP">realm	^self paramAt:  'realm'</body><body package="HTTP">realm: aString	^self paramAt:  'realm' put: aString</body><body package="HTTP">response" A string of 32 hex digits, which proves  that the user knows a password"	^self paramAt:  'response'</body><body package="HTTP">response: aString	^self paramAt:  'response' put: aString</body><body package="HTTP">scheme	^self value</body><body package="HTTP">stale"A flag, indicating that the previous request from the client was rejected because the nonce value was stale. If stale is TRUE (case-insensitive), the client may wish to simply retry the request  with a new encrypted response, without reprompting the user for a new username and password. "	^self paramAt:  'stale'</body><body package="HTTP">stale: aBoolean	^self paramAt:  'stale' put: aBoolean</body><body package="HTTP">uri	^self paramAt:  'uri'</body><body package="HTTP">uri: aString	^self paramAt:  'uri' put: aString</body><body package="HTTP">username"The user's name in the specified realm"	^self paramAt:  'username'</body><body package="HTTP">username: aString	^self paramAt:  'username' put: aString</body></methods><methods><class-id>Net.DigestAuthenticationValue</class-id> <category>accessing auth-info</category><body package="HTTP">nextNonce 	^self paramAt:  'nextnonce'</body><body package="HTTP">nextNonce: aString 	self paramAt:  'nextnonce' put: aString</body><body package="HTTP">responseAuth       	^self paramAt:  'rspauth'</body><body package="HTTP">responseAuth: aString       	^self paramAt:  'rspauth' put: aString</body></methods><methods><class-id>Net.DigestAuthenticationValue</class-id> <category>testing</category><body package="HTTP">isBasic	^false</body><body package="HTTP">isDigest	^true</body><body package="HTTP">isNTLM	^false</body><body package="HTTP">isNTLMType2	^false</body><body package="HTTP">isStaleTrue	^self stale = true</body></methods><methods><class-id>Net.DigestAuthenticationValue</class-id> <category>initialize-release</category><body package="HTTP">initialize	value := 'Digest'</body></methods><methods><class-id>Net.DigestAuthenticationValue</class-id> <category>composing</category><body package="HTTP">writeNonceCount: aNumber on: aStream	aNumber printOn: aStream paddedWith: $0 to: 8 base: 10.</body><body package="HTTP">writeNonceCountOn: aStream	| number |	(number := self nc) ifNotNil: 		[ self writeNonceCount: number on: aStream]</body><body package="HTTP">writeParameter: assoc on: aStream encoding: aString	self printParameter: assoc on: aStream</body><body package="HTTP">writeParameter: name value: anObject on: aStream	anObject isNil ifTrue: [^nil].	self class scannerType print: $= on: aStream.	name = 'qop' ifTrue: [^self writeQop: anObject on: aStream].	name = 'nc' ifTrue: [^self writeNonceCount: anObject on: aStream].	name = 'stale' ifTrue: [ ^self writeQuotedValue: anObject printString on: aStream ].	self writeQuotedValue: anObject on: aStream.</body><body package="HTTP">writeParametersSeparatorOn: aStream	aStream nextPut: self parametersSeparator; crtab</body><body package="HTTP">writeQop: anObject on: aStream	anObject isString		ifTrue: [aStream nextPutAll: anObject]		ifFalse: 			[ aStream nextPut: $".			anObject 				do: [ :each | aStream nextPutAll: each]				separatedBy: [aStream nextPut: $,].			aStream nextPut: $".].</body><body package="HTTP">writeQuotedValue: anObject on: aStream	aStream 		nextPut: $"; 		nextPutAll: anObject; 		nextPut: $"</body></methods><methods><class-id>Net.DigestAuthenticationValue</class-id> <category>parsing</category><body package="HTTP">finishParse	| coll sc val |	coll := OrderedCollection new.	(val := self qop) ifNotNil:		[sc := self scannerOn: val readStream.		sc 			tokenizeList: [ coll add: sc nextToken ]			separatedBy: [sc token == $, or: [sc token == Character space ]].		self qop: coll.		 ].	(val := self stale) ifNotNil: [self stale: (Boolean readFrom: val asLowercase readStream) ].	(val := self nc) ifNotNil: [self nc: (Number readFrom: val readStream) ].</body><body package="HTTP">parse: scanner	scanner atEnd ifTrue: [ ^self]. 	scanner hereChar ~~ self valueSeparator		ifTrue: [ scanner stepBack. ^self ].	self parseParameters: scanner.	self finishParse.</body></methods><methods><class-id>Net.CookieField</class-id> <category>initialization</category><body package="HTTP">initialize	name := self class fieldNames first</body></methods><methods><class-id>Net.CookieField</class-id> <category>initialize-release</category><body package="HTTP">addName: nameString value: valString	| assoc |	self value add: (assoc := Association key: nameString value: valString).	^assoc</body></methods><methods><class-id>Net.CookieField</class-id> <category>composing</category><body package="HTTP">writeOn: aStream encoding: aString"Encoding should be added to value if needed "	self value isEmpty ifTrue: [^nil].	super writeOn: aStream encoding: aString</body><body package="HTTP">writeValueOn: aStream encoding: aString	self value  		do: [ :assoc |  			aStream nextPutAll: assoc key,'='. 			assoc value ifNil: [self error: (#CookieValueNil &lt;&lt; #net &gt;&gt; 'Cookie name-value-pair can not have nil value.')].			self class scannerType printWord: assoc value on: aStream]		separatedBy: [aStream nextPut: self separator; nextPut: Character space ]</body></methods><methods><class-id>Net.CookieField</class-id> <category>parsing</category><body package="HTTP">doParse: scanner"   cookie-header = Cookie: OWS cookie-string OWS   cookie-string = cookie-pair *( ; SP cookie-pair )"	| list str |	list := OrderedCollection new: 5.	[scanner skipWhiteSpace. 	scanner atEnd ] 		whileFalse: [			str := scanner scanUntil: [ scanner hereChar == self separator ].			list add: (self parseItem: str )].	^list</body><body package="HTTP">parseItem: aString	| tokens val |	tokens := self tokenize: (self scannerOn: aString readStream).	(tokens at: 2) ~= $=		ifTrue: [ self error: (#FailedParsingCookie &lt;&lt; #net &gt;&gt; 'Failed parsing Cookie field name-value-pair.')].	tokens size = 3 ifTrue: [val := tokens last ].	^Association key: tokens first value: val</body></methods><methods><class-id>Net.CookieField</class-id> <category>printing</category><body package="HTTP">printValueOn: aStream 	self value  		do: [ :assoc |  			aStream nextPutAll: assoc key,'='. 			assoc value 	ifNotNil: [self class scannerType printWord: assoc value on: aStream]]		separatedBy: [aStream nextPut: self separator; nextPut: Character space ]</body></methods><methods><class-id>Net.CookieField class</class-id> <category>parsing</category><body package="HTTP">fieldNames	^#('cookie' )</body></methods><methods><class-id>Net.CookieField class</class-id> <category>instant creation</category><body package="HTTP">name: nameString value: aString	^( self name: 'Cookie')		value: (OrderedCollection with: nameString -&gt; aString);		yourself</body></methods><methods><class-id>Net.CookieField class</class-id> <category>defaults</category><body package="HTTP">defaultSeparator	^$;</body></methods><methods><class-id>Net.CookieField class</class-id> <category>instance creation</category><body package="HTTP">new	^super new		initialize;		yourself</body></methods><methods><class-id>Net.HttpConnection</class-id> <category>testing</category><body package="HTTP">accepts: url	^url protocol = 'http'</body></methods><methods><class-id>Net.HttpConnection</class-id> <category>private</category><body package="HTTP">createSocketTimeout: aNumber forAddress: info	| s |	s :=	HttpSocketAccessor family: info family type: info socketType protocol: info protocol.	s timeout: aNumber.	^s</body></methods><methods><class-id>Net.HttpConnection class</class-id> <category>default values</category><body package="HTTP">defaultPortNumber	^SocketAccessor IPPORT_HTTP</body></methods><methods><class-id>Net.SetCookieValue</class-id> <category>testing</category><body package="HTTP">isExpired	^self isPersistent not		or: [ Timestamp now &gt; self expires]</body><body package="HTTP">isNotExpired	^self isExpired not</body><body package="HTTP">isPersistent	^self persistent</body></methods><methods><class-id>Net.SetCookieValue</class-id> <category>parsing-printing params</category><body package="HTTP">domain: aString	self params at: #domain put: aString</body><body package="HTTP">expiresPrintString	"Return a properly formatted date string using GMT."    | gMTSeconds policy |      gMTSeconds := Timestamp fromSeconds: (TimeZone reference convertLocalSecondsToGMT: self expires asSeconds).	policy := TimestampPrintPolicy formatTokensFor: 'ddd, dd-mmm-yyyy hh:mm:ss GMT'.	^(Locale named: #C) timePolicy print: gMTSeconds policy: policy</body><body package="HTTP">httponlyPrintString	^nil</body><body package="HTTP">maxAgePrintString	^self maxAge printString</body><body package="HTTP">path: aString	self params at: #path put: aString</body><body package="HTTP">securePrintString	^nil</body><body package="HTTP">setDomain: aString"   If the attribute-value is empty, the behavior is undefined.  However, the user agent SHOULD ignore the cookie-av entirely.If the first character of the attribute-value string is %x2E  $.: Let cookie-domain be the attribute-value without the leading %x2E #. character.Otherwise: 	Let cookie-domain be the entire attribute-value.	Convert the cookie-domain to lower case."	aString isEmpty  ifTrue: [ ^nil ].	self domain: aString asLowercase</body><body package="HTTP">setExpires: aString"http://tools.ietf.org/html/rfc6265#section-5.2.1The Expires directive tells the browser when to delete the cookie. Derived from the format used in RFC 1123, the date is specified in the form of “Wdy, DD Mon YYYY HH:MM:SS GMT”,[30] indicating the exact date/time this cookie will expire.   Let the expiry-time be the result of parsing the attribute-value as cookie-date (see Section 5.1.1).   If the attribute-value failed to parse as a cookie date, ignore the cookie-av."	[self expires: (RFC822Scanner readDateAndTimeFrom: aString readStream)]		on:Error do: [ :ex | nil ].</body><body package="HTTP">setHttponly: aBoolean" If the attribute-name case-insensitively matches the string HttpOnly, the user agent MUST append an attribute to the cookie-attribute-list with an attribute-name of HttpOnly and an empty attribute-value. "	self httponly: aBoolean</body><body package="HTTP">setMaxAge: aString"RFC 6265 allows the use of the Max-Age attribute to set the cookie’s expiration as an interval of seconds in the future, relative to the time the browser received the cookie."	"If the first character of the attribute-value is not a DIGIT or a -  character, ignore the cookie-av"	aString first = $- ifTrue: [^nil].	" If the remainder of attribute-value contains a non-DIGIT character, ignore the cookie-av."	(aString anySatisfy: [ :ch | ch isDigit not]) ifTrue: [ ^nil].	"Let delta-seconds be the attribute-value converted to an integer"	self maxAge:  aString asNumber</body><body package="HTTP">setPath: aString" If the attribute-value is empty or if the first character of the attribute-value is not %x2F $/:	      Let cookie-path be the default-path.   Otherwise:	      Let cookie-path be the attribute-value."	self path: aString</body><body package="HTTP">setSecure: aBoolean" If the attribute-name case-insensitively matches the string Secure, the user agent MUST append an attribute to the cookie-attribute-list with an attribute-name of Secure and an empty attribute-value."	self secure: aBoolean</body></methods><methods><class-id>Net.SetCookieValue</class-id> <category>private-utility</category><body package="HTTP">expireAfterDays: aNumber	"Mark this cookie for expiration after aNumber of days from now."	| now |	now := Time dateAndTimeNow.	self expires:		(Timestamp			fromDate: ((now at: 1) addDays: aNumber)			andTime: (now at: 2))</body><body package="HTTP">expireAfterHours: aNumber	"Mark this cookie for expiration after aNumber of hours from now."	| now increment |	now := Time dateAndTimeNow.	increment := Time new hours: aNumber minutes: 0 seconds: 0.	self expires:		(Timestamp			fromDate: (now at: 1)			andTime: ((now at: 2) addTime: increment))</body><body package="HTTP">expireImmediately	"Mark this cookie for immediate expiration."	| now |	now := Time dateAndTimeNow.	self expires:		(Timestamp			fromDate: ((now at: 1) addDays: -1)			andTime: (now at: 2))</body><body package="HTTP">tokenizedValueFrom: rfc822Stream "The Name=Value is required and must be the first pair in Set-Cookie field"	| nx vx |	nx := rfc822Stream upTo: $=. 	rfc822Stream hereChar = $=		ifFalse:			[^(InvalidHeaderField 				errorDescription: ((#FaildedParsingCookieNAMEParameter &lt;&lt; #net &gt;&gt; 'Failed parsing SetCookie name-value-pair. Received string: &lt;1s&gt;') expandMacrosWith: nx) 				source: rfc822Stream asStream 				errorPosition: rfc822Stream position ) raise].	vx := rfc822Stream peek = $"		ifTrue: [rfc822Stream nextToken]		ifFalse: [rfc822Stream upToEnd].	^nx -&gt; vx</body><body package="HTTP">validateNextToken: scanner for: parName	| tok |	tok := scanner peek. 	^tok == $=		ifTrue: [ scanner next. true]		ifFalse: 	[tok = $; or: [tok isNil ]]</body></methods><methods><class-id>Net.SetCookieValue</class-id> <category>accessing</category><body package="HTTP">creationTime	^creationTime</body><body package="HTTP">creationTime: aTimestamp	creationTime := aTimestamp</body><body package="HTTP">defaultPath	| p |	^((p := self path) isEmpty or: [p first = $/])		ifTrue: [ p ]		ifFalse: [ nil ]</body><body package="HTTP">domain	^self params at: #domain ifAbsent: [nil]</body><body package="HTTP">expires	^self params at: #expires ifAbsent: [nil]</body><body package="HTTP">expires: aTimestamp	self params at: #expires put: aTimestamp</body><body package="HTTP">httponly	^self params at: #httponly ifAbsent: [false]</body><body package="HTTP">httponly: aBoolean	aBoolean 		ifTrue: [self params  at: #httponly put: aBoolean]		ifFalse: [self params removeKey: #httponly ifAbsent: [nil]].</body><body package="HTTP">lastAccessTime	^lastAccessTime</body><body package="HTTP">lastAccessTime: aTimestamp	lastAccessTime := aTimestamp</body><body package="HTTP">maxAge	^self params at: #'max-age' ifAbsent: [ nil ]</body><body package="HTTP">maxAge: aNumber	self params 	at: #'max-age' put: aNumber</body><body package="HTTP">name	^self value key</body><body package="HTTP">nameValue	^self value value</body><body package="HTTP">path	^self params at: #path ifAbsent: [nil]</body><body package="HTTP">persistent	^persistent ifNil: [ persistent := false ]</body><body package="HTTP">persistent: aBoolean	persistent := aBoolean</body><body package="HTTP">secure	^self params at: #secure ifAbsent: [false]</body><body package="HTTP">secure: aBoolean	aBoolean 		ifTrue: [self params  at: #secure put: aBoolean]		ifFalse: [self params removeKey: #secure ifAbsent: [nil]].</body><body package="HTTP">separators	separators isNil 	ifTrue: [separators := SetCookieField defaultSeparators ].	^separators</body></methods><methods><class-id>Net.SetCookieValue</class-id> <category>converting</category><body package="HTTP">acceptDomain: aString	^'*', self domain asLowercase match: aString asLowercase</body><body package="HTTP">acceptPath: aString	^'*', self path match: aString</body><body package="HTTP">asCookie	^CookieField name: self name value: self nameValue.</body></methods><methods><class-id>Net.SetCookieValue</class-id> <category>parsing</category><body package="HTTP">addParameterNamed: valString value: parString	(setSelectors at: valString asLowercase asSymbol ifAbsent: [nil]) 		ifNotNil: [ :sel | self params 							at: valString asLowercase asSymbol							ifAbsent: [self perform: sel with: parString]]		ifNil: [self params at: valString asLowercase ifAbsentPut: [ parString ] ]</body><body package="HTTP">doParse: scanner	" Canonical value removes all white space and comments from the source "	| str |	str := scanner scanUntil: [ scanner hereChar == self valueSeparator ].	^self  tokenizedValueFrom: (self scannerOn: str readStream).</body><body package="HTTP">parseParamValueFrom: scanner 	| val |	^(scanner hereChar == $; or: [scanner hereChar isNil ])		ifTrue: 			["no value param (secure)" 			 true ]		ifFalse: 	[ val := scanner scanWhile: [ scanner hereChar ~= self parametersSeparator].				(val first = $" and: [val last = $"])					ifTrue: [val copyFrom: 2 to: val size - 1]					ifFalse: [val]]</body><body package="HTTP">setCurrentTime: aTimestamp"   If Max-Age Attribute delta-seconds is less than or equal to zero (0), let expiry-time be the earliest representable date and time.  Otherwise, let the expiry-time be the current date and time plus delta-seconds seconds.   Append an attribute to the cookie-attribute-list with an attribute-name of Max-Age and an attribute-value of expiry-time."	creationTime := aTimestamp.	lastAccessTime := aTimestamp.	persistent := (self maxAge notNil or: [ self expires notNil ]).	persistent ifFalse: [^nil].	self maxAge ifNotNil: [ :ma |		ma &gt; 0			ifTrue: [ self expires: (aTimestamp addSeconds: ma)  ]			ifFalse: [self expires ifNil: [self expires: aTimestamp]]]</body></methods><methods><class-id>Net.SetCookieValue</class-id> <category>comparing</category><body package="HTTP">= aCookieValue	| d dv p pv |	d := self domain isNil		ifTrue: [ nil]		ifFalse: [ self domain asLowercase ].	dv := aCookieValue domain isNil		ifTrue: [ nil]		ifFalse: [ aCookieValue domain asLowercase ].	p := self path isNil		ifTrue: [ nil]		ifFalse: [ self path asLowercase ].	pv := aCookieValue path isNil		ifTrue: [ nil]		ifFalse: [ aCookieValue path asLowercase ].			^self name = aCookieValue name 		and: [ d = dv and:  [ p = pv ] ]</body><body package="HTTP">hash	^self name hash</body></methods><methods><class-id>Net.SetCookieValue</class-id> <category>composing</category><body package="HTTP">writeParameter: assoc on: aStream encoding: aString	self class scannerType printWord: assoc key on: aStream.	self writeParameter: assoc key value: assoc value on: aStream.</body><body package="HTTP">writeParameter: name value:  anObject on: aStream	|  printValue |	printValue := anObject.	(printSelectors at: name asSymbol ifAbsent: [nil]) 		ifNotNil: [ :printSel | printValue := self perform:  printSel ]. 	printValue ifNotNil: [ aStream nextPutAll: '=', printValue ]</body><body package="HTTP">writeParameterAsQuotedText: name value: anObject on: aStream	self class scannerType print: $= on: aStream.	[self class scannerType printQuotedText: anObject on: aStream	] 	on: NonASCIICharacter 		do: [ :ex | aStream nextPut: $"; nextPutAll: anObject; nextPut: $"]</body><body package="HTTP">writeValueOn: aStream	value ifNotNil: [		aStream nextPutAll: self value key,'='. 		self class scannerType printWord: self value value on: aStream]</body></methods><methods><class-id>Net.SetCookieValue</class-id> <category>initialize-release</category><body package="HTTP">initialize	super initialize.	setSelectors := Struct new.	setSelectors		at: #secure put: #setSecure:;		at: #httponly put: #setHttponly:;		at: #'max-age'  put: #setMaxAge:;		at: #'domain'  put: #setDomain:;		at: #'path'  put: #setPath:;		at: #expires put: #setExpires:.	printSelectors := Struct new.	printSelectors 		at: #'max-age' put: #maxAgePrintString;		at: #expires put: #expiresPrintString;		at: #secure put: #securePrintString;				at: #httponly put: #httponlyPrintString.</body><body package="HTTP">name: aString value: vString	self setValueName: aString value: vString.</body><body package="HTTP">setValueName: aString value: vString	value := Association key: aString value: vString.</body></methods><methods><class-id>Net.SetCookieValue class</class-id> <category>accessing</category><body package="HTTP">policy	^policy ifNil: [policy := TimestampPrintPolicy formatTokensFor: 'ddd, dd-mmm-yyyy hh:mm:ss GMT'.]</body></methods><methods><class-id>Net.SetCookieValue class</class-id> <category>instance creation</category><body package="HTTP">name: nString value: vString	^self new		name: nString value: vString;		yourself</body></methods><methods><class-id>Net.SetCookieValue class</class-id> <category>defaults</category><body package="HTTP">restoreValueFrom: anXMLElement	^(SetCookieField readFrom: ( 'Set-Cookie: ', anXMLElement elements first text ) readStream) value first</body></methods><methods><class-id>Net.AuthenticationPolicy</class-id> <category>accept challenge</category><body package="HTTP">acceptAuthInfoFrom: aHttpResponse	self resetRejected.	self authentication ifNotNil: [ self authentication acceptAuthInfoFrom: aHttpResponse ]</body><body package="HTTP">acceptChallenge: aHttpResponse	^self acceptChallenge: aHttpResponse request: nil</body><body package="HTTP">acceptChallenge: aHttpResponse request: aHttpRequest"1. no user/pass ----  pass exc2. no authenticate field -----  pass exc3. authorization is provided but not accepted. 	a. wrong user/pass	b. wrong scheme 	c. different realm- try another scheme if there is a choice- there is no scheme that accepts the challenge - pass exc- retry for diff. realm if the scheme auth depends on it"	| authenticate |	"if there is a user name and password provided or challenge in the response"	(self canBeAuthorized not		or: [(authenticate := self authenticateFieldFrom: aHttpResponse) isNil])			 ifTrue: [ ^false].	"some scheme's (NTLM) may require additional replies to complete authorization "	(self isAuthorizationInProgress and: [self authentication proceedWith: authenticate ])		ifTrue: [^true].	"the request has being authorized "	self isAuthorized 		ifTrue: [	"check if there is a different realm in the challenge"				(self authentication canAccept: authenticate) ifTrue: [ ^true].				"try another scheme if any"				^self tryAnotherAuthFrom: authenticate].	"it has not being authorized yet "	^(authentication := self newPolicyFrom: authenticate) notNil</body></methods><methods><class-id>Net.AuthenticationPolicy</class-id> <category>accessing</category><body package="HTTP">authOrder	^authOrder ifNil: [ authOrder := self class authOrder ]</body><body package="HTTP">authOrder: aCollectionOfHttpAuth	authOrder := aCollectionOfHttpAuth</body><body package="HTTP">authentication	^authentication</body><body package="HTTP">authentication: anHttpAuthentication	authentication := anHttpAuthentication</body><body package="HTTP">header	^'authorization'</body><body package="HTTP">password	^self user password</body><body package="HTTP">realm	^self user realm</body><body package="HTTP">realm: aString	self user addRealm: aString.</body><body package="HTTP">rejected	rejected ifNil: [ self resetRejected ].	^rejected</body><body package="HTTP">resetRejected	rejected := OrderedCollection new</body><body package="HTTP">user	^user ifNil: [ user := HttpUser new]</body><body package="HTTP">username	^self user username</body></methods><methods><class-id>Net.AuthenticationPolicy</class-id> <category>testing</category><body package="HTTP">canBeAuthorized	^self username notNil and: [ self password notNil]</body><body package="HTTP">isAuthorizationInProgress	^self authentication notNil  and: [ self authentication isAuthorizationInProgress]</body><body package="HTTP">isAuthorized	^self authentication notNil and: [self authentication isAuthorized]</body></methods><methods><class-id>Net.AuthenticationPolicy</class-id> <category>initialize-release</category><body package="HTTP">setNotAuthorizedState	self authentication ifNotNil: [ self authentication setNotAuthorizedState ].	self resetRejected</body><body package="HTTP">useBasicAuth	authentication := BasicAuthentication policy: self</body><body package="HTTP">user: aHttpUser	aHttpUser ifNil: [^nil].	self username: aHttpUser username password: aHttpUser password realm:nil</body><body package="HTTP">username: aString password: pString	self username: aString password: pString realm: nil</body><body package="HTTP">username: aString password: pString realm: rString	(self username = aString and: [self password = pString]) ifTrue: [^nil].	self setNotAuthorizedState.	user := HttpUser username: aString password: pString.	user addRealm: rString.</body></methods><methods><class-id>Net.AuthenticationPolicy</class-id> <category>private</category><body package="HTTP">authenticateFieldFrom: aHttpResponse	| field |	^(field := aHttpResponse wwwAuthenticate) isEmpty 		ifTrue: [nil]		ifFalse: [ field first  ].</body><body package="HTTP">detectSupportedPolicy: anAuthentication	|  polCl challenge |	polCl := self authOrder 		detect: 			[ :scheme | 				(challenge := anAuthentication value 					select: [ :val | scheme acceptScheme: val scheme]) notEmpty ] 		ifNone: [HttpAuthenticationExc 				raiseRequestWith: anAuthentication				errorString: (#ThereIsNoSupportedAuthentication &lt;&lt; #net &gt;&gt; 'There is no supported authentication detected in: &lt;1s&gt;' expandMacrosWith:  anAuthentication printString)].	^polCl-&gt;challenge</body><body package="HTTP">newPolicyFrom: anAuthenticate	|  policyChallenge |	anAuthenticate  ifNil: [ ^nil ].	policyChallenge := self detectSupportedPolicy: anAuthenticate.	(authentication := policyChallenge key policy: self )		setAuthChallengeFrom: policyChallenge value.	^authentication</body><body package="HTTP">tryAnotherAuthFrom: anAuthentication		| challenge polClass |	self rejected add: self authentication class.	self authOrder size = self rejected size ifTrue: [^false].	polClass := self authOrder 		detect: 			[ :scheme | 			(self rejected includes: scheme) not 				and: [(challenge := anAuthentication value 						select: [ :val | scheme acceptScheme: val scheme]) notEmpty ]] 		ifNone: [nil].	polClass isNil ifTrue: [ ^false].	(authentication := polClass policy: self ) setAuthChallengeFrom: challenge.	^authentication notNil</body></methods><methods><class-id>Net.AuthenticationPolicy</class-id> <category>add authorization</category><body package="HTTP">addAuthorizationTo: aHttpRequest	(self canBeAuthorized not or: [self authentication isNil]) ifTrue: [ ^nil].	aHttpRequest removeFieldAt: self header.	self authentication addAuthorizationTo: aHttpRequest for: self header.</body></methods><methods><class-id>Net.AuthenticationPolicy class</class-id> <category>accessing</category><body package="HTTP">authOrder	^authOrder ifNil: [ authOrder := self defaultAuthOrder ]</body><body package="HTTP">authOrder: aCollection	authOrder := aCollection</body></methods><methods><class-id>Net.AuthenticationPolicy class</class-id> <category>instance creation</category><body package="HTTP">username: aString password: pString	^self new		username: aString password: pString;		yourself</body></methods><methods><class-id>Net.AuthenticationPolicy class</class-id> <category>default values</category><body package="HTTP">defaultAuthOrder	^Array 		with: DigestAuthentication 		with: BasicAuthentication</body></methods><methods><class-id>Net.HttpEntityError</class-id> <category>printing</category><body package="HTTP">description	^self messageText</body></methods><methods><class-id>Net.AcceptCharsetField</class-id> <category>adding charset</category><body package="HTTP">addCharset: cString	self addCharset: cString qValue: nil</body><body package="HTTP">addCharset: cString qValue: qString 	self addValue: cString qValue: qString.</body></methods><methods><class-id>Net.AcceptCharsetField</class-id> <category>accessing</category><body package="HTTP">charsetAt: index	^self value at: index</body><body package="HTTP">charsetTypeAt: index	^(self charsetAt: index) value</body></methods><methods><class-id>Net.AcceptCharsetField class</class-id> <category>parsing</category><body package="HTTP">fieldNames	^#('accept-charset')</body></methods><methods><class-id>Net.AcceptCharsetField class</class-id> <category>instant creation</category><body package="HTTP">charset: cString	^self charset: cString qValue: nil</body><body package="HTTP">charset: cString qValue: qString	^(self name: 'accept-charset') 		addCharset: cString qValue: qString;		yourself</body></methods><methods><class-id>Net.HttpURL</class-id> <category>stream -- guarded</category><body package="HTTP">envelopeReadStreamDo: aBlock	^self safelyExecuteBlock: 			[self clientDo: [ :client | 				client 					readStreamCmd: 'GET' 					url: self 					do: [ :connection |  aBlock value: connection ]]]</body><body package="HTTP">envelopeWriteStreamDo: aBlock	^self shouldNotImplement</body><body package="HTTP">readByteStreamDo: aBlock"Returns not decoded byte array stream and the response header fields "	| message dictionary  |	self safelyExecuteBlock: 		[message := self clientDo: [ :client |						client 							decodeContents: false; 							get: self ]].	self checkMultipart: message.	dictionary := Dictionary new.	message fields 		do: [:fld | dictionary at: fld name put: fld ].	message byteSource ifNil: [ 		self error: #MessageContentsIsNotBinary &lt;&lt; #net &gt;&gt; 'The message contents is not binary'  ].	^aBlock 		value: message byteSource reset		value: dictionary</body><body package="HTTP">readStreamDo: aBlock"Returns the response contents stream and the response header fields."	| message dictionary |	self safelyExecuteBlock: [message := self get ].	self checkMultipart: message.	dictionary := Dictionary new.	message fields 		do: [:fld | dictionary at: fld name put: fld ].	^aBlock 		value: message body anySource reset		value: dictionary</body><body package="HTTP">writeStreamDo: aBlock	^self shouldNotImplement</body></methods><methods><class-id>Net.HttpURL</class-id> <category>stream -- unguarded</category><body package="HTTP">binaryReadStream"Returns stream on ByteArray"	| message |	self safelyExecuteBlock: [message := self get ].	self checkMultipart: message. 	^message byteSource 		ifNil: [ self error: #MessageContentsIsNotBinary &lt;&lt; #net &gt;&gt; 'The message contents is not binary'  ]		ifNotNil: [ :byteSource| byteSource reset ]</body><body package="HTTP">binaryWriteStream	^self shouldNotImplement</body><body package="HTTP">envelopeReadStream		^self safelyExecuteBlock: 		[self client readStreamCmd: 'GET' url: self]</body><body package="HTTP">envelopeWriteStream	^self shouldNotImplement</body><body package="HTTP">readStream"Returns stream on ByteString"	| message |	self safelyExecuteBlock: [message := self get ].	self checkMultipart: message.	^message body anySource reset</body><body package="HTTP">writeStream	^self shouldNotImplement</body></methods><methods><class-id>Net.HttpURL</class-id> <category>accessing</category><body package="HTTP">clientDo: aBlock	| client |	client := self client.	^[ aBlock value: client  ] 		ensure: [ client ifNotNil: [ client  close]]</body><body package="HTTP">decodeContents	^decodeContents ifNil: [decodeContents := HttpBuildHandler decodeContents]</body><body package="HTTP">decodeContents: aBoolean	decodeContents := aBoolean</body><body package="HTTP">decompressContents	^decompressContents ifNil: [decompressContents := HttpBuildHandler decompressContents]</body><body package="HTTP">decompressContents: aBoolean	decompressContents := aBoolean</body><body package="HTTP">hostAddress	^self socketAddress hostAddress</body><body package="HTTP">hostAndPort	| stream |	stream := String new writeStream.	self printHostAndPortOn: stream.	^stream contents</body><body package="HTTP">pathString	| stream |	stream := (String new: 32) writeStream.	self printEncodedPathOn: stream.	self printExtrasOn: stream.	^stream contents</body><body package="HTTP">resource	| message  data |	self safelyExecuteBlock: [message := self get ].	self checkMultipart: message. 	data := message body source notNil 			ifTrue: [message charset asSymbol = #'utf-8'					ifTrue: [message body source]					ifFalse: [message body source encoder: (StreamEncoder new: #UTF_8)]]			ifFalse: [ (EncodedStream 						on: message body byteSource						encodedBy: (StreamEncoder new: #UTF_8))					lineEndConvention: LineEndTransparent].	data reset.	^XML.InputSource		uri: self		encoding: nil		stream:  data</body><body package="HTTP">socketAddress	^IPSocketAddress hostName: self host port: self port</body><body package="HTTP">user	^user</body><body package="HTTP">user: aNetUser	user := aNetUser</body><body package="HTTP">username: nameString password: passString	user := HttpUser username: nameString password: passString</body></methods><methods><class-id>Net.HttpURL</class-id> <category>private</category><body package="HTTP">checkMultipart: aHttpEntity	aHttpEntity isMultipart		ifTrue: 			[self error: (#MultipartBodiesAreNotYetSupported &lt;&lt; #net &gt;&gt; 'Multipart bodies are not yet supported')].</body><body package="HTTP">client	| client |	client := HttpClient new.	self user ifNotNil: [ client user: self user ].	client 		decodeContents: self decodeContents;		decompressContents: self decompressContents.	^client</body><body package="HTTP">safelyExecuteBlock: aBlock	^aBlock on: HttpUnauthorizedError		do: [ :ex |  			self user notNil				ifTrue: [ ex pass]				ifFalse: 					[HttpSettings user 						ifNotNil: [ :usr | self user: usr.								ex retry ]						ifNil: [ ex pass]]]</body></methods><methods><class-id>Net.HttpURL</class-id> <category>commands</category><body package="HTTP">delete"Send a request with the DELETE method on the resource identified by the receiver.	^&lt;HttpResponse&gt;"	^self clientDo: [ :client | client  delete: self ]</body><body package="HTTP">get"Send a request with the GET method on the resource identified by the receiver.	^&lt;HttpResponse&gt;"	^self clientDo: [ :client | client  get: self ]</body><body package="HTTP">post: aContents"Post aContents as the value of the resource identified by the receiver. aContents can be any of the valid values accepted by MimeEntity&gt;&gt;contents:, i.e. String, ByteArray, Filename, ReadStream or a block.	^&lt;HttpResponse&gt;"	^self clientDo: [ :client | client  post: self contents: aContents]</body><body package="HTTP">put: aContents"PUT aContents as the value of the resource identified by the receiver. aContents can be any of the valid values accepted by MimeEntity&gt;&gt;contents:, i.e. String, ByteArray, Filename, ReadStream or a block.	^&lt;HttpResponse&gt;"	^self clientDo: [ :client | client  put: self contents: aContents]</body></methods><methods><class-id>Net.HttpURL class</class-id> <category>accessing</category><body package="HTTP">protocol	^'http'</body></methods><methods><class-id>Net.HttpURL class</class-id> <category>defaults</category><body package="HTTP">defaultPortNumber	^SocketAccessor IPPORT_HTTP</body></methods><methods><class-id>Net.ProxyAuthenticationPolicy</class-id> <category>accessing</category><body package="HTTP">header	^'proxy-authorization'</body></methods><methods><class-id>Net.ProxyAuthenticationPolicy</class-id> <category>private</category><body package="HTTP">authenticateFieldFrom: aHttpResponse	| field |	^(field := aHttpResponse proxyAuthenticate) isEmpty		ifTrue: [ nil]		ifFalse: [ field first].</body></methods><methods><class-id>Net.AcceptLanguageField</class-id> <category>adding language</category><body package="HTTP">addLanguage: cString  	self addValue: cString qValue: nil</body><body package="HTTP">addLanguage: cString qValue: qString 	self addValue: cString qValue: qString.</body></methods><methods><class-id>Net.AcceptLanguageField class</class-id> <category>parsing</category><body package="HTTP">fieldNames	^#('accept-language')</body></methods><methods><class-id>Net.AcceptLanguageField class</class-id> <category>instant creation</category><body package="HTTP">language: cString 	^self language: cString qValue: nil</body><body package="HTTP">language: cString qValue: qString	^(self name: 'accept-language') 		addLanguage: cString qValue: qString;		yourself</body></methods><methods><class-id>Net.HttpResponse</class-id> <category>testing</category><body package="HTTP">authenticateNTLMType2	| f |	(f := self proxyAuthenticate detect: [:hdr | hdr isType2 ] ifNone: [nil]) isNil		ifTrue: [ f := self wwwAuthenticate detect: [:hdr | hdr isType2 ] ifNone: [nil]].	^f</body><body package="HTTP">canBeNTLMAuthorized	^(self proxyAuthenticate anySatisfy: [:hdr | hdr canBeNTLMAuthorized ])		or: [self wwwAuthenticate anySatisfy: [:hdr | hdr canBeNTLMAuthorized ]]</body><body package="HTTP">failed	^self isSuccess not</body><body package="HTTP">headerOnly	^self statusLine headerOnly</body><body package="HTTP">isClientError	"Informational- Request received, continuing the process"	^self statusLine isClientError</body><body package="HTTP">isError	"Informational- Request received, continuing the process"	^self statusLine isError</body><body package="HTTP">isHttp10	^self statusLine isHttp10</body><body package="HTTP">isInformationalReply	"Informational - Request received, continuing the process"	^self statusLine isInformationalReply</body><body package="HTTP">isMoved	"Moved permanently/temporarily"		^self statusLine isMoved</body><body package="HTTP">isNTLMType2	^(self proxyAuthenticate anySatisfy: [:hdr | hdr isType2 ])		or: [self wwwAuthenticate anySatisfy: [:hdr | hdr isType2 ]]</body><body package="HTTP">isProxyAuthorizedRequired	"Proxy Authorized Required"	^self statusLine isProxyAuthorizedRequired</body><body package="HTTP">isRedirectionReply	"Informational- Request received, continuing the process"	^self statusLine isRedirectionReply</body><body package="HTTP">isResponse	^true</body><body package="HTTP">isServerError	"Informational- Request received, continuing the process"	^self statusLine isServerError</body><body package="HTTP">isSuccess	^self statusLine isSuccess</body><body package="HTTP">isUnauthorized	"unauthorized"	^self statusLine isUnauthorized</body><body package="HTTP">isValid	^self statusLine isValid</body><body package="HTTP">successful	^self isSuccess</body></methods><methods><class-id>Net.HttpResponse</class-id> <category>accessing</category><body package="HTTP">basicProxyAuthenticationHeader	^(self fieldsAt: 'proxy-authenticate') detect: [:hdr | hdr scheme = 'basic'] ifNone: [nil]</body><body package="HTTP">basicWwwAuthenticationHeader	^(self fieldsAt: 'www-authenticate') detect: [:hdr | hdr scheme = 'basic'] ifNone: [nil]</body><body package="HTTP">code	^self statusLine code</body><body package="HTTP">descriptionString	^self printStatusLineMessage</body><body package="HTTP">messageLine	^self statusLine</body><body package="HTTP">messageLine: aHttpResponseStatusLine	self statusLine: aHttpResponseStatusLine</body><body package="HTTP">protocol	^self statusLine protocol</body><body package="HTTP">statusLine	^statusLine</body><body package="HTTP">statusLine: aHttpResponseStatusLine	statusLine := aHttpResponseStatusLine</body><body package="HTTP">version	^self statusLine version</body></methods><methods><class-id>Net.HttpResponse</class-id> <category>accessing fields</category><body package="HTTP">acceptRanges	^self fieldValueAt: 'accept-ranges'</body><body package="HTTP">acceptRanges: aStringOrCollection	(self getFieldAt: 'accept-ranges') value: aStringOrCollection</body><body package="HTTP">age	^self fieldValueAt: 'age'</body><body package="HTTP">age: aString	(self getFieldAt: 'age') value: aString</body><body package="HTTP">location	^self fieldValueAt: 'location'</body><body package="HTTP">location: aString	(self getFieldAt: 'location') value: aString</body><body package="HTTP">proxyAuthenticate	^self fieldsAt: 'proxy-authenticate'</body><body package="HTTP">proxyAuthenticate: aStringOrAuthenticateChallengeField"Sets a value the parameter can be a string or instance of AuthenticateChallengeField"		aStringOrAuthenticateChallengeField isString		ifTrue: [ (self getFieldAt: 'proxy-authenticate') 				addScheme: aStringOrAuthenticateChallengeField]		ifFalse:			[ self removeFieldAt: 'proxy-authenticate'.			self addField: aStringOrAuthenticateChallengeField]</body><body package="HTTP">public	^self fieldValueAt: 'public'</body><body package="HTTP">public: aValue	(self getFieldAt:  'public') value: aValue</body><body package="HTTP">retryAfter	^self fieldValueAt: 'retry-after'</body><body package="HTTP">retryAfter: aTimestampOrStringOrArray	(self getFieldAt:  'retry-after') value: aTimestampOrStringOrArray</body><body package="HTTP">wwwAuthenticate"Returns all AuthenticateChallengeField"	^self fieldsAt:  'www-authenticate'</body><body package="HTTP">wwwAuthenticate: aStringOrAuthenticateChallengeField"Sets a value the parameter can be a string or instance of AuthenticateChallengeField"		^aStringOrAuthenticateChallengeField isString		ifTrue: [ (self getFieldAt: 'www-authenticate') 					addScheme: aStringOrAuthenticateChallengeField]		ifFalse:			[ self removeFieldAt: 'www-authenticate'.			self addField: aStringOrAuthenticateChallengeField]</body></methods><methods><class-id>Net.HttpResponse</class-id> <category>private</category><body package="HTTP">log	HttpProtocolInterpreter log: 			[| s |			s := (String new: 128) writeStream.			self printHeaderOn: s.			s contents] 		level: #HTTPServerHeader.	HttpProtocolInterpreter log: [self printString]  level: #HTTPServerMessage.</body><body package="HTTP">statusCode: aString	statusLine := HttpResponseStatusLine code: aString</body></methods><methods><class-id>Net.HttpResponse</class-id> <category>printing</category><body package="HTTP">printHeaderOn: aStream	self newPrinter printMessageElement: self statusLine on: aStream.		self newPrinter printMessageElement: self header on: aStream.</body><body package="HTTP">printStatusLineMessage	| stream |	stream := (String new: 32) writeStream.	self statusLine printMessageOn: stream.	^stream contents</body></methods><methods><class-id>Net.HttpResponse class</class-id> <category>instance creation</category><body package="HTTP">code: aString	^self new		statusCode: aString;		yourself</body></methods><methods><class-id>Net.SetCookieField</class-id> <category>accessing</category><body package="HTTP">valueWithParamsClass	^SetCookieValue</body></methods><methods><class-id>Net.SetCookieField</class-id> <category>composing</category><body package="HTTP">writeOn: aStream encoding: aString	self value 		do: [ :vx | 			self writeNameOn: aStream.			vx writeOn: aStream]		separatedBy: [ aStream cr ]</body></methods><methods><class-id>Net.SetCookieField</class-id> <category>printing</category><body package="HTTP">printOn: aStream indent: level	aStream tab: level.	value isUnparsedHeaderValue ifTrue: [^value printOn: aStream].	self value 		do: [ :vx | 			self  printNameOn: aStream.			vx printOn: aStream]		separatedBy: [ aStream cr ]</body></methods><methods><class-id>Net.SetCookieField</class-id> <category>initialization</category><body package="HTTP">initialize	name := self class fieldNames first</body></methods><methods><class-id>Net.SetCookieField</class-id> <category>initialize-release</category><body package="HTTP">addName: nameString value: valString	| cookie |	cookie := self valueWithParamsClass name: nameString value: valString.	self value add: cookie.	^cookie</body></methods><methods><class-id>Net.SetCookieField</class-id> <category>parsing</category><body package="HTTP">validateValue: aScanner"	Create a new cookie with name cookie-name, value cookie-value.        Set the creation-time and the last-access-time to the current        date and time."	| currentTime |	(value isKindOf: UnparsedHeaderValue) ifTrue: [^nil ].	currentTime := Timestamp now.	self value do: [ :val | val setCurrentTime: currentTime]</body></methods><methods><class-id>Net.SetCookieField</class-id> <category>adding</category><body package="HTTP">add: aCookieField	aCookieField value isUnparsedHeaderValue 		ifTrue: [self value add: aCookieField value]		ifFalse: [ 			self value isUnparsedHeaderValue ifTrue: [ value := OrderedCollection with: self value].			self value addAll: aCookieField value ]</body><body package="HTTP">addValue: aCookieValueWithParams	self value add: aCookieValueWithParams</body></methods><methods><class-id>Net.SetCookieField</class-id> <category>testing</category><body package="HTTP">shouldTerminateSession	^(self value detect: [ :vx | vx isUnparsedHeaderValue not and: [ vx maxAge = 0] ] ifNone: [nil]) notNil</body></methods><methods><class-id>Net.SetCookieField class</class-id> <category>instance creation</category><body package="HTTP">add: aSetCookieValue	^self new		add:  aSetCookieValue;		yourself</body><body package="HTTP">addName: nameString value: valString	^self new		addName: nameString value: valString;		yourself</body><body package="HTTP">new	^super new initialize</body></methods><methods><class-id>Net.SetCookieField class</class-id> <category>parsing</category><body package="HTTP">fieldNames	^#('set-cookie' )</body></methods><methods><class-id>Net.SetCookieField class</class-id> <category>defaults</category><body package="HTTP">defaultSeparators	^#($; $; $,  )</body></methods><methods><class-id>Net.AuthenticationValue</class-id> <category>accessing</category><body package="HTTP">basicValue	^self data</body><body package="HTTP">basicValue: aString	^self data: aString</body><body package="HTTP">realm	^realm</body><body package="HTTP">realm: aString	^realm := aString</body><body package="HTTP">scheme	^self value</body><body package="HTTP">scheme: aString	^self value: aString</body></methods><methods><class-id>Net.AuthenticationValue</class-id> <category>testing</category><body package="HTTP">isBasic	^self scheme asLowercase = 'basic'</body><body package="HTTP">isBearer	^self scheme asLowercase = 'bearer'</body><body package="HTTP">isDigest	^self scheme asLowercase = 'digest'</body></methods><methods><class-id>Net.AuthenticationValue</class-id> <category>private</category><body package="HTTP">data	^data</body><body package="HTTP">data: aString	data := aString</body></methods><methods><class-id>Net.AuthenticationValue</class-id> <category>parsing</category><body package="HTTP">parse: scanner	scanner atEnd ifTrue: [ ^self]. 	scanner hereChar ~~ self valueSeparator		ifTrue: [ scanner stepBack. ^self ].	self parseDataFrom: scanner</body><body package="HTTP">parseBearerDataFrom: scanner "https://tools.ietf.org/html/rfc6750#section-3"" WWW-Authenticate: Bearer realm=example,                       error=invalid_token,                       error_description=The access token expired"	| paramName pos paramVal |		pos := scanner position.	data := Dictionary new.	scanner atEnd ifFalse: [		scanner			tokenizeList: [				scanner skipWhiteSpace.				paramName := scanner nextToken.				scanner skipWhiteSpace.				( scanner nextToken = $=) ifFalse: [					^(InvalidHeaderField 						errorDescription:  (#WrongBearerParameter &lt;&lt; #net &gt;&gt; 'Wrong Bearer parameter')						source: scanner asStream 					errorPosition: pos ) raise].				paramVal := scanner nextToken.				paramName = 'realm'					ifTrue: [realm := paramVal]					ifFalse: [data at: paramName put: paramVal ]				] 			separatedBy: [scanner token == $, ] ]</body><body package="HTTP">parseDataFrom: scanner 	| pos str |		self isBearer ifTrue: [^self parseBearerDataFrom: scanner ].	pos := scanner position.	str := scanner nextToken.	"Basic auth response has realm parameter.	#nextToken  will stop at $= char. If it's not 'realm' parameter we need all characters "	^('realm' match: str )		ifTrue: [			scanner skipWhiteSpace.			( scanner nextToken = $=) ifFalse: [				^(InvalidHeaderField 					errorDescription:  (#RealmIsNotDefined &lt;&lt; #net &gt;&gt; 'Realm is not defined')					source: scanner asStream 					errorPosition: pos ) raise].  			realm := scanner nextToken  ]		ifFalse: [			scanner position: pos.			data := scanner upToEnd ]</body></methods><methods><class-id>Net.AuthenticationValue</class-id> <category>composing</category><body package="HTTP">writeDataOn: aStream	aStream nextPut: self valueSeparator.	realm isNil		ifTrue: [aStream nextPutAll: self data]		ifFalse: 	[aStream nextPutAll: 'realm="', self realm, '"']</body><body package="HTTP">writeValueOn: aStream	super writeValueOn: aStream.	(self realm notNil  or: [self data notNil])		ifTrue: [	self writeDataOn: aStream ]</body></methods><methods><class-id>Net.HttpResponseStatusLine</class-id> <category>testing</category><body package="HTTP">headerOnly		^(self code notNil 	and: [self code isEmpty not 	and: [self isInformationalReply or: [#('204' '304') includes: self code]]])		ifTrue: [true]		ifFalse: [false]</body><body package="HTTP">isChallenge	^self isProxyAuthorizedRequired or: [ self isUnauthorized ]</body><body package="HTTP">isClientError	"Informational- Request received, continuing the process"	^self responseTypeIs: $4</body><body package="HTTP">isError	"Informational- Request received, continuing the process"	^(self isClientError or: [ self isServerError])</body><body package="HTTP">isHttp10	^self version = '1.0'</body><body package="HTTP">isInformationalReply	"Informational - Request received, continuing the process"	^self responseTypeIs: $1</body><body package="HTTP">isMoved	"Moved permanently/temporarily"		^(self responseEquals: '301') or: [ self responseEquals: '302']</body><body package="HTTP">isProxyAuthorizedRequired	"Proxy Authorized Required"	^self responseEquals: '407'</body><body package="HTTP">isRedirectionReply	"Informational- Request received, continuing the process"	^self responseTypeIs: $3</body><body package="HTTP">isServerError	"Informational- Request received, continuing the process"	^self responseTypeIs: $5</body><body package="HTTP">isSuccess	"Success - The action was received, understood and accepted"	^self responseTypeIs: $2</body><body package="HTTP">isUnauthorized	"unauthorized"	^self responseEquals: '401'</body><body package="HTTP">isValid	^(( 'HTTP*' match: self protocol) and: [ self status &gt; 99 and: [ self status &lt; 600 ]])</body></methods><methods><class-id>Net.HttpResponseStatusLine</class-id> <category>accessing</category><body package="HTTP">code	^code</body><body package="HTTP">code: anObject	code := anObject</body><body package="HTTP">entityType	^HttpResponse</body><body package="HTTP">message	^message</body><body package="HTTP">message: anObject	message := anObject</body><body package="HTTP">parent	^nil</body><body package="HTTP">protocol	(protocol isNil or: [ protocol isEmpty])		ifTrue: [ protocol := self class defaultProtocol].	^protocol</body><body package="HTTP">protocol: anObject	protocol := anObject</body><body package="HTTP">version	(version isNil or: [ version isEmpty])		ifTrue: [ version := self class defaultVersion].	^version</body><body package="HTTP">version: anObject	version := anObject</body></methods><methods><class-id>Net.HttpResponseStatusLine</class-id> <category>printing</category><body package="HTTP">printMessageOn: aStream	self code isNil ifTrue: [ ^super printOn: aStream ].	aStream nextPutAll: self code; space.	self message notNil 		ifTrue: [aStream nextPutAll: self message].	aStream cr.</body><body package="HTTP">printOn: aStream	self code isNil ifTrue: [ ^super printOn: aStream ].	aStream 		nextPutAll: self protocol, '/', self version; space;		nextPutAll: self code; space.	self message ifNotNil: [aStream nextPutAll: self message].</body></methods><methods><class-id>Net.HttpResponseStatusLine</class-id> <category>private</category><body package="HTTP">responseEquals: threeDigitString 	^code asNumber =  threeDigitString asNumber</body><body package="HTTP">responseTypeIs: char 	^code isEmpty not		ifTrue: [ code first == char ]</body><body package="HTTP">setCode: aString	code := aString.		message := self class messages at: code ifAbsent: [''].</body><body package="HTTP">status" Answer code as a number " 	^code notNil		ifTrue: [ Integer readFrom: code readStream]		ifFalse: [ 0 ]</body><body package="HTTP">supportedVersions	^#('1.0' '1.1')</body></methods><methods><class-id>Net.HttpResponseStatusLine</class-id> <category>parsing</category><body package="HTTP">readFrom: stream	| scanner |	scanner := MimeScanner on: stream. 	protocol := scanner nextToken.	scanner nextToken.	version := scanner nextToken.	(self supportedVersions includes: version)		ifFalse: [HttpEntityError new				messageText: ((#UnexpectedHTTPVersion &lt;&lt; #net &gt;&gt; 'Unexpected HTTP version (&lt;1s&gt;)')						expandMacrosWith: version);				raiseSignal].	code := scanner nextToken.	scanner skipWhiteSpace.	message := scanner scanText.</body></methods><methods><class-id>Net.HttpResponseStatusLine</class-id> <category>visiting</category><body package="HTTP">acceptVisit: aVisitor with: argument	^aVisitor acceptResponseLine: self with: argument</body></methods><methods><class-id>Net.HttpResponseStatusLine class</class-id> <category>defaults</category><body package="HTTP">defaultMessages	^Dictionary new		add: '100'-&gt;'Continue';		add: '101'-&gt;'Switching Protocols';		add: '200'-&gt;'OK';		add: '201'-&gt;'Created';		add: '202'-&gt;'Accepted';		add: '203'-&gt;'Non-Authoritative Information';		add: '204'-&gt;'No Content';		add: '205'-&gt;'Reset Content';		add: '206'-&gt;'Partial Content';		add: '300'-&gt;'Multiple Choices';		add: '301'-&gt;'Moved Permanently';		add: '302'-&gt;'Found';		add: '303'-&gt;'See Other';		add: '304'-&gt;'Not Modified';		add: '305'-&gt;'Use Proxy';		add: '307'-&gt;'Temporary Redirect';		add: '400'-&gt;'Bad Request';		add: '401'-&gt;'Unauthorized';		add: '402'-&gt;'Payment Required';		add: '403'-&gt;'Forbidden';		add: '404'-&gt;'Not Found';		add: '405'-&gt;'Method Not Allowed';		add: '406'-&gt;'Not Acceptable';		add: '407'-&gt;'Proxy Authentication Required';		add: '408'-&gt;'Request Time-out';		add: '409'-&gt;'Conflict';		add: '410'-&gt;'Gone';		add: '411'-&gt;'Length Required';		add: '412'-&gt;'Precondition Failed';		add: '413'-&gt;'Request Entity Too Large';		add: '414'-&gt;'Request-URI Too Large';		add: '415'-&gt;'Unsupported Media Type';		add: '416'-&gt;'Requested range not satisfiable';		add: '417'-&gt;'Expectation Failed';		add: '500'-&gt;'Internal Server Error';		add: '501'-&gt;'Not Implemented';		add: '502'-&gt;'Bad Gateway';		add: '503'-&gt;'Service Unavailable';		add: '504'-&gt;'Gateway Time-out';		add: '505'-&gt;'HTTP Version not supported';		yourself</body><body package="HTTP">defaultProtocol	^'HTTP'</body><body package="HTTP">defaultVersion	^'1.1'</body></methods><methods><class-id>Net.HttpResponseStatusLine class</class-id> <category>instance creation</category><body package="HTTP">code: aString	^self new		setCode: aString;		yourself</body><body package="HTTP">readFrom: stream	^self new readFrom: stream</body></methods><methods><class-id>Net.HttpResponseStatusLine class</class-id> <category>accessing</category><body package="HTTP">messages	messages ifNil: [ messages := self defaultMessages].	^messages</body><body package="HTTP">messages: aDictionary	messages := aDictionary</body></methods><methods><class-id>Net.HttpBuildHandler</class-id> <category>private</category><body package="HTTP">decodeBody: aBody	| ce |	(aBody isMultipart 		or: [ aBody isBinary			or: [aBody byteSource isNil ]]) ifTrue: [^aBody].	(((ce := aBody parent contentEncoding) notNil 			and: [ce notEmpty]) 				or: [self decodeContents not])		ifFalse: [self setBodySource: aBody]</body><body package="HTTP">handleStartBody: aBody exception: exception	(HttpTimeout handles: exception)		ifTrue: 			[exception parameter: aBody parent.			exception pass]		ifFalse: [ super handleStartBody: aBody exception: exception ]</body></methods><methods><class-id>Net.HttpBuildHandler</class-id> <category>testing</category><body package="HTTP">shouldBeDecompressed: anEntity	^(self decompressContents 		and: [anEntity isContentEncodingGZip ])</body></methods><methods><class-id>Net.HttpBuildHandler</class-id> <category>action callbacks</category><body package="HTTP">endBody: aBody	(self shouldBeDecompressed: aBody parent)		ifTrue: [aBody parent removeFieldAt: 'content-encoding'].		aBody parent isContentEncodingGZip 		ifFalse: [ self decodeBody: aBody].	^super endBody: aBody</body><body package="HTTP">endMessageBody: aBody	| message |	message := aBody parent.	(message isChunked		or: [message isTransferEncodingGZip])			ifTrue: [ message removeFieldAt: 'transfer-encoding']. 		^message</body><body package="HTTP">shouldStartMessageBody: aMessageBody 	| message |	message := aMessageBody parent.	message isMimeEntity  ifTrue: [^true].	(self headerOnly or: [message headerOnly]) ifTrue: [ ^false ]." In particular, the convention has been established that the GET and   HEAD methods SHOULD NOT have the significance of taking an action   other than retrieval."	(message isResponse not and: [ message method asSymbol == #GET]) ifTrue: [^false].	^message contentLength		ifNil: [	message isChunked or: [				message isConnectionTransient  or: [				UnspecifiedBodySize new parameter: message; raiseRequest ] ] ]		ifNotNil: [ :length | length &gt; 0 ]</body><body package="HTTP">startMessage: aLineObject	initialEntity isNil ifTrue: [ initialEntity := aLineObject entityType new].	initialEntity messageLine: aLineObject.	^initialEntity</body></methods><methods><class-id>Net.HttpBuildHandler</class-id> <category>private prepare streams</category><body package="HTTP">prepareStream: aStream forMessageBody: anEntity	stream := aStream.	lineEndConvention :=  aStream lineEndConvention.	 anEntity isChunked ifTrue: [ stream := ChunkedReadStream on:  stream ].	stream := BodyStream on: stream length: anEntity contentLength.	anEntity isTransferEncodingGZip 		ifTrue: [ stream := OS.ZLib.GZipReadStream on:  stream ].	^stream</body><body package="HTTP">prepareStream: aStream forSimpleBody: aBody	^(self shouldBeDecompressed: aBody parent)		ifTrue: [ OS.ZLib.GZipReadStream on:  aStream ]		ifFalse: [aStream]</body><body package="HTTP">setAttachmentSource: aBody to: aStream	aBody byteSource: aStream</body></methods><methods><class-id>Net.HttpBuildHandler</class-id> <category>accessing</category><body package="HTTP">decodeContents	^self options decodeContents</body><body package="HTTP">decodeContents: aBoolean	self options decodeContents: aBoolean</body><body package="HTTP">decompressContents	^self options decompressContents</body><body package="HTTP">decompressContents: aBoolean	self options decompressContents: aBoolean</body></methods><methods><class-id>Net.HttpBuildHandler</class-id> <category>defaults</category><body package="HTTP">parserClass	^HttpParser</body></methods><methods><class-id>Net.HttpBuildHandler class</class-id> <category>defaults</category><body package="HTTP">decodeContents	^self defaultOptionsType decodeContents</body><body package="HTTP">decodeContents: aBoolean	self defaultOptionsType decodeContents: aBoolean</body><body package="HTTP">decompressContents	^self defaultOptionsType decompressContents</body><body package="HTTP">decompressContents: aBoolean	self defaultOptionsType decompressContents: aBoolean</body></methods><methods><class-id>Net.HttpBuildHandler class</class-id> <category>default values</category><body package="HTTP">decodeContentsValue	^self defaultOptionsType decodeContentsValue</body><body package="HTTP">defaultAttachmentDirectoryValue	^self defaultOptionsType defaultAttachmentDirectoryValue</body><body package="HTTP">defaultDecompressContents	^self defaultOptionsType defaultDecompressContents</body><body package="HTTP">defaultOptionsType	^HttpReadingOptions</body><body package="HTTP">saveAttachmentsAsFilesValue	^self defaultOptionsType saveAttachmentsAsFilesValue</body></methods><methods><class-id>Net.HttpSettings</class-id> <category>accessing</category><body package="HTTP">connectionPersists	^connectionPersists ifNil: [self class connectionPersists ]</body><body package="HTTP">connectionPersists: aBoolean	connectionPersists := aBoolean</body><body package="HTTP">domain	^domain ifNil: [self class domain]</body><body package="HTTP">domain: anObject	domain := anObject</body><body package="HTTP">enableCookieProcessing	^enableCookieProcessing ifNil: [ self class enableCookieProcessing ]</body><body package="HTTP">enableCookieProcessing: anObject	enableCookieProcessing := anObject</body><body package="HTTP">proxyExceptions	^proxyExceptions  ifNil: [ self class proxyExceptions ]</body><body package="HTTP">proxyExceptions: anObject	proxyExceptions := anObject</body><body package="HTTP">proxyHost	^proxyHost  ifNil: [ self class proxyHost ]</body><body package="HTTP">proxyHost: anObject	proxyHost := anObject</body><body package="HTTP">redirectRequest	^redirectRequest ifNil: [ self class redirectRequest ]</body><body package="HTTP">redirectRequest: anObject	redirectRequest := anObject</body><body package="HTTP">useProxy	^useProxy ifNil: [ self class useProxy ]</body><body package="HTTP">useProxy: anObject	useProxy := anObject</body><body package="HTTP">user	^user ifNil: [ self class user ]</body><body package="HTTP">user: anObject	user := anObject</body></methods><methods><class-id>Net.HttpSettings class</class-id> <category>accessing</category><body package="HTTP">connectionPersists	^connectionPersists ifNil: [connectionPersists := self connectionPersistsDefault]</body><body package="HTTP">connectionPersists: aBoolean	connectionPersists := aBoolean</body><body package="HTTP">domain		^domain ifNil: [domain := self domainDefault ]</body><body package="HTTP">domain: aString		domain := aString</body><body package="HTTP">enableCookieProcessing	^enableCookieProcessing ifNil: [enableCookieProcessing := self enableCookieProcessingDefault]</body><body package="HTTP">enableCookieProcessing: aBoolean	enableCookieProcessing := aBoolean</body><body package="HTTP">proxyExceptions	^proxyExceptions ifNil: [ proxyExceptions := OrderedCollection new ]</body><body package="HTTP">proxyExceptions: aCollection	proxyExceptions := aCollection</body><body package="HTTP">proxyHost	^proxyHost</body><body package="HTTP">proxyHost: aHostSpec	proxyHost := aHostSpec.	Settings addIdentity: proxyHost netUser.</body><body package="HTTP">redirectRequest	^redirectRequest ifNil: [ redirectRequest := self redirectRequestDefault ]</body><body package="HTTP">redirectRequest: aBoolean	redirectRequest := aBoolean</body><body package="HTTP">useProxy	^useProxy ifNil: [ useProxy := self useProxyDefault ]</body><body package="HTTP">useProxy: aBoolean	useProxy := aBoolean</body><body package="HTTP">user	^user</body><body package="HTTP">user: aNetUser	user :=  aNetUser</body></methods><methods><class-id>Net.HttpSettings class</class-id> <category>defaults</category><body package="HTTP">connectionPersistsDefault	^true</body><body package="HTTP">domainDefault		^CEnvironment getenv: 'USERDOMAIN'</body><body package="HTTP">enableCookieProcessingDefault		^true</body><body package="HTTP">keepAliveDefault	^true</body><body package="HTTP">redirectRequestDefault	^true</body><body package="HTTP">useProxyDefault	^false</body></methods><methods><class-id>Net.HttpSettings class</class-id> <category>testing</category><body package="HTTP">hasIdentityReference: aNetUser	(self proxyHost notNil and: [ self proxyHost netUser notNil])		ifTrue: [ self proxyHost netUser fullName = aNetUser fullName ifTrue: [^true]].	self user ifNotNil: [ :usr | usr fullName = aNetUser fullName ifTrue: [^true]].	^false</body></methods><methods><class-id>Net.ChunkedStream</class-id> <category>accessing</category><body package="HTTP">binary</body><body package="HTTP">text</body></methods><methods><class-id>Net.ChunkedStream</class-id> <category>initialize-release</category><body package="HTTP">initializeOn: aStream	stream := aStream.	stream binary.</body></methods><methods><class-id>Net.ChunkedStream</class-id> <category>testing</category><body package="HTTP">isReadable	^self subclassResponsibility</body><body package="HTTP">isWritable	^self subclassResponsibility</body></methods><methods><class-id>Net.ChunkedStream</class-id> <category>private</category><body package="HTTP">contentsSpecies	^ByteArray</body><body package="HTTP">signalError: aString	HttpException raiseSignal: aString</body></methods><methods><class-id>Net.CacheControl</class-id> <category>accessing</category><body package="HTTP">addMustRevalidate"must-revalidate"	self addDirective:  'must-revalidate'-&gt;nil</body><body package="HTTP">addNoCache" 'no-cache' [ '= &lt;''&gt; 1#field-name &lt;''&gt; ] "	self addDirective: 'no-cache'-&gt;nil</body><body package="HTTP">addNoStore"no-store"	self addDirective: 'no-store'-&gt;nil</body><body package="HTTP">addNoTransform"no-transform"	self addDirective:  'no-transform'-&gt;nil</body><body package="HTTP">addOnlyIfCached"only-if-cached "	self addDirective: 'only-if-cached'-&gt;nil</body><body package="HTTP">addPrivate"private [ ''='' &lt;''&gt; 1#field-name &lt;''&gt; ]"	self addDirective: 'private'-&gt;nil</body><body package="HTTP">addProxyRevalidate"proxy-revalidate"	self addDirective: 'proxy-revalidate'-&gt;nil</body><body package="HTTP">addPublic"public "	self addDirective: 'public'-&gt;nil</body><body package="HTTP">maxAge"'max-age' ''='' delta-seconds "	^self detectValueFor: 'max-age'</body><body package="HTTP">maxAge: aNumber"'max-age' ''='' delta-seconds "	self addDirective: 'max-age'-&gt;aNumber</body><body package="HTTP">maxStale"'max-stale' ''='' delta-seconds "	^self detectValueFor: 'max-stale'</body><body package="HTTP">maxStale: aNumber"'max-stale' ''='' delta-seconds "	self addDirective:  'max-stale'-&gt;aNumber</body><body package="HTTP">minFresh"'min-fresh' ''='' delta-seconds "	^self detectValueFor: 'min-fresh'</body><body package="HTTP">minFresh: aNumber"'min-fresh' ''='' delta-seconds "	self addDirective: 'min-fresh'-&gt;aNumber</body><body package="HTTP">mustRevalidate"must-revalidate"	^self anySatisfy: 'must-revalidate'</body><body package="HTTP">noCache" 'no-cache' [ '= &lt;''&gt; 1#field-name &lt;''&gt; ] "	^self detectValueFor: 'no-cache'</body><body package="HTTP">noCache: aCollOfStringsOrNil" 'no-cache' [ '= &lt;''&gt; 1#field-name &lt;''&gt; ] "	self addDirective: 'no-cache'-&gt;aCollOfStringsOrNil</body><body package="HTTP">noStore"no-store"	^self anySatisfy: 'no-store'</body><body package="HTTP">noTransform"no-transform"	^self anySatisfy:  'no-transform'</body><body package="HTTP">onlyIfCached"only-if-cached "	^self anySatisfy:  'only-if-cached'</body><body package="HTTP">private"private [ ''='' &lt;''&gt; 1#field-name &lt;''&gt; ]"	^self detectValueFor: 'private'</body><body package="HTTP">private: aCollOfStringsOrNil"private [ ''='' &lt;''&gt; 1#field-name &lt;''&gt; ]"	self addDirective: 'private'-&gt;aCollOfStringsOrNil</body><body package="HTTP">proxyRevalidate"proxy-revalidate"	^self anySatisfy: 'proxy-revalidate'</body><body package="HTTP">public"public "	^self anySatisfy: 'public'</body><body package="HTTP">values	^value isNil		ifTrue: [ value := OrderedCollection new]		ifFalse: [ value ]</body></methods><methods><class-id>Net.CacheControl</class-id> <category>private</category><body package="HTTP">anySatisfy: aString	^self values anySatisfy: [ :val | val key asLowercase = aString ]</body><body package="HTTP">detectValueFor: aString 	| v |	^(v := self value detect: [ :val | val key asLowercase = aString ] ifNone: [nil]) notNil		ifTrue: 			[ v value notNil				ifTrue: [ v value]				ifFalse: [true]]		ifFalse: [false]</body></methods><methods><class-id>Net.CacheControl</class-id> <category>parsing</category><body package="HTTP">parseItem: aString	| scanner token |	scanner := self scannerOn: aString readStream. 	token := scanner nextToken.	^(scanner hereChar == $= )		ifTrue: [token -&gt;(self parseParameters: scanner key: token asLowercase)]		ifFalse: [token-&gt;nil]</body><body package="HTTP">parseParameters: scanner key: aString	| paramColl newScanner t |	paramColl := OrderedCollection new.	scanner next.	scanner nextToken. 	^scanner tokenType == #quotedText 			ifTrue: 			[newScanner := scanner 							newSize: scanner token size 							startingAt: (scanner position - scanner token size - 1).			newScanner tokenizeList: [ t := newScanner nextToken. 										paramColl add: (t ifNil: [String new])]						separatedBy: [ newScanner token == self separator ].			scanner next.			paramColl]		ifFalse: 			[(scanner tokenType == #token and: [ self isDeltaSeconds: aString])				ifTrue: [ scanner token asNumber]				ifFalse: [scanner token]]</body></methods><methods><class-id>Net.CacheControl</class-id> <category>directives</category><body package="HTTP">addDirective: anAssocOrString	| val |	val := (anAssocOrString isString				ifTrue: [ anAssocOrString-&gt;nil]				ifFalse: 	[anAssocOrString]).	self removeDirective: val key.	self values add: val</body><body package="HTTP">directiveAt: aString	^self detectValueFor: aString</body><body package="HTTP">removeDirective: aString	self values removeAllSuchThat: [ :v | v key = aString ].</body></methods><methods><class-id>Net.CacheControl</class-id> <category>testing</category><body package="HTTP">isDeltaSeconds: aString	^#( 'max-age' 'max-stale' 'min-fresh' ) includes: aString</body></methods><methods><class-id>Net.CacheControl</class-id> <category>composing</category><body package="HTTP">writeParameters: anObject on: aStream 		aStream nextPut: $=.	(anObject isKindOf: OrderedCollection)		ifTrue:			[aStream nextPut: $".			anObject 				do: [ :param |  aStream nextPutAll: param]				separatedBy: [aStream nextPut: $, ].			aStream nextPut: $"  ]		ifFalse: 			[anObject respondsToArithmetic 				ifTrue: [anObject printOn: aStream]				ifFalse: [ aStream nextPutAll: anObject]]</body><body package="HTTP">writeValueOn: aStream encoding: aString		self values		do: 	[ :val |			aStream nextPutAll: val key.			val value notNil				ifTrue:					[self writeParameters: val value on: aStream]]		separatedBy: [aStream nextPut: self separator].</body></methods><methods><class-id>Net.CacheControl class</class-id> <category>parsing</category><body package="HTTP">fieldNames	^#('cache-control')</body></methods><methods><class-id>Net.ChunkedReadStream</class-id> <category>status</category><body package="HTTP">close	stream close.</body></methods><methods><class-id>Net.ChunkedReadStream</class-id> <category>initialize-release</category><body package="HTTP">initializeOn: aStream	super initializeOn: aStream.	firstChunk := true</body><body package="HTTP">reset	buffer := nil.	position := nil.</body></methods><methods><class-id>Net.ChunkedReadStream</class-id> <category>testing</category><body package="HTTP">atEnd	position = readLimit  ifTrue: [ self nextChunk ].	^readLimit = 0</body><body package="HTTP">isReadable	^true</body><body package="HTTP">isWritable	"Answer whether the stream implements #nextPut:."	^false</body></methods><methods><class-id>Net.ChunkedReadStream</class-id> <category>accessing</category><body package="HTTP">next	buffer ifNil: [ self nextChunk].	self atEnd ifTrue: [^self pastEnd].	position := position + 1.	^buffer at: position</body><body package="HTTP">next: aNumber	| line |	self atEnd ifTrue: [^self pastEnd].	line := self contentsSpecies new: aNumber.	1 to: aNumber do: [ :ind | line at: ind put: self next].	^line</body></methods><methods><class-id>Net.ChunkedReadStream</class-id> <category>private</category><body package="HTTP">nextChunk	self nextChunkSize &gt; 0		ifTrue: 			[position := 0.			[buffer := stream next: readLimit ] 				on: Stream incompleteNextCountSignal				do: [:ex | 					self signalError: (#IncompleteChunkCount &lt;&lt;#net &gt;&gt; 'Incomplete chunk count').					^ex return ].			(stream next = self lineEnd first ) ifFalse: [ self signalError: (#WrongChunkFormat &lt;&lt;#net &gt;&gt; 'Wrong chunk format')].			stream peekFor: self lineEnd last]</body><body package="HTTP">nextChunkSize	| line lineStream |	line := (stream upTo: self lineEnd first) asString.	firstChunk  		ifTrue: [firstChunk := false.			lineStream := line trimBlanks readStream.			readLimit := Integer readFrom: lineStream radix: 16.			lineStream atEnd ifFalse: [				 ^HttpEntityError new 					messageText: ((#FirstChunkHasInvalidChunkValue &lt;&lt; #net &gt;&gt; 'The first chunk has invalid size value: &lt;1s&gt;')			expandMacrosWith: line printString); 					raiseSignal ]]		ifFalse:[	readLimit := Integer readFrom: line readStream radix: 16.].	self lineEnd size &gt; 1 ifTrue: [stream peekFor: self lineEnd last ].	readLimit = 0 ifTrue: [self reset].	^readLimit</body></methods><methods><class-id>Net.ChunkedWriteStream</class-id> <category>accessing</category><body package="HTTP">bufferNumber	^bufferNumber</body><body package="HTTP">chunkSize: aNumber	self writeLimit: aNumber</body><body package="HTTP">flush	"Write any unwritten information  "	useChunks := true.	buffer ifNotNil: [		self signalReadyToWrite.		self writeChunkUnconditionally ].	stream flush</body><body package="HTTP">nextPut: anObject 	"Put the argument, anObject, at the next position in the receiver.	Answer anObject."	position = self writeLimit ifTrue: [ self writeChunk ].	buffer ifNil: [self initializeWriteBuffer ].	position := position + 1.	buffer at: position put: anObject asInteger.	^anObject</body><body package="HTTP">onFinishWithOneBufferDo	^onFinishWithOneBufferDo</body><body package="HTTP">onFinishWithOneBufferDo: aBlock	onFinishWithOneBufferDo := aBlock</body><body package="HTTP">onReadyToWriteFirstBufferDo	^onReadyToWriteFirstBufferDo</body><body package="HTTP">onReadyToWriteFirstBufferDo: aBlock	onReadyToWriteFirstBufferDo := aBlock</body><body package="HTTP">useChunks	^useChunks ifNil: [ true]</body><body package="HTTP">useChunks: aBoolean	useChunks := aBoolean</body><body package="HTTP">writeLimit	^writeLimit ifNil: [writeLimit := self class defaultWriteLimit ]</body><body package="HTTP">writeLimit: aNumber	writeLimit := aNumber</body></methods><methods><class-id>Net.ChunkedWriteStream</class-id> <category>status</category><body package="HTTP">close	self finish.	stream close.</body><body package="HTTP">finish	"Write any unwritten information and last chunk       last-chunk     = 1*('0') [ chunk-extension ] CRLF       chunk-extension= *( ';' chunk-ext-name [ '=' chunk-ext-val ] )       chunk-ext-name = token       chunk-ext-val  = token | quoted-string       chunk-data     = chunk-size(OCTET)       trailer        = *(entity-header CRLF) "	buffer ifNotNil: 		[bufferNumber == 0			ifTrue: [self onFinishWithOneBufferDo 						ifNotNil: [ :block | 								block value: position.								self useChunks: false.								bufferNumber := 1.]]].		self useChunks			ifTrue: [self writeChunk.					self writeLastChunk]			ifFalse: [ self writeBuffer ].	stream finish.</body></methods><methods><class-id>Net.ChunkedWriteStream</class-id> <category>private</category><body package="HTTP">beginWriteChunk	self useChunks 		ifTrue:			[| s | 			s := EncodedStream 					on: (ByteArray new: 100) writeStream 					encodedBy: (StreamEncoder new: #ascii).			position printOn: s  base: 16. 			stream 				nextPutAll: s encodedContents;				nextPutAll: self lineEnd].</body><body package="HTTP">endWriteChunk	self useChunks ifTrue: [stream nextPutAll: self lineEnd].</body><body package="HTTP">initializeWriteBuffer	buffer :=  self contentsSpecies new: self writeLimit. 	position := 0</body><body package="HTTP">signalReadyToWrite"We signal the first chunck is ready to write and parent has to add the header: Transfer-Encoding: chunked HttpWriteHandler: onReadyToWriteFirstBufferDo: [ self addTransferChunked ] "	bufferNumber == 0 		ifTrue: [	self onReadyToWriteFirstBufferDo ifNotNil: [ :block | block value]. 				 self useChunks: true]</body><body package="HTTP">writeBuffer	position &gt; 0 ifTrue: [		stream next: position putAll: buffer startingAt: 1.		position := 0.		bufferNumber := bufferNumber + 1.		buffer := nil ]</body><body package="HTTP">writeChunk	buffer ifNotNil: [		self signalReadyToWrite.		self writeChunkUnconditionally ]</body><body package="HTTP">writeChunkUnconditionally	stream binary.	self beginWriteChunk.	self writeBuffer.	self endWriteChunk.</body><body package="HTTP">writeLastChunk	self useChunks		ifTrue:			[stream nextPut: $0 asInteger.			stream nextPutAll: self lineEnd.			stream nextPutAll: self lineEnd ].</body></methods><methods><class-id>Net.ChunkedWriteStream</class-id> <category>testing</category><body package="HTTP">isReadable	^false</body><body package="HTTP">isWritable	"Answer whether the stream implements #nextPut:."	^true</body></methods><methods><class-id>Net.ChunkedWriteStream</class-id> <category>initialize-release</category><body package="HTTP">initializeOn: aStream	super initializeOn: aStream.	bufferNumber := 0.</body></methods><methods><class-id>Net.ChunkedWriteStream class</class-id> <category>defaults</category><body package="HTTP">defaultWriteLimit	^defaultWriteLimit ifNil: [defaultWriteLimit := self defaultWriteLimitValue]</body><body package="HTTP">defaultWriteLimit: aNumber	defaultWriteLimit := aNumber</body><body package="HTTP">defaultWriteLimitValue	^4096</body></methods><methods><class-id>Net.HttpRequestLine</class-id> <category>visiting</category><body package="HTTP">acceptVisit: aVisitor with: argument	^aVisitor acceptRequestLine: self with: argument</body></methods><methods><class-id>Net.HttpRequestLine</class-id> <category>accessing</category><body package="HTTP">entityType	^HttpRequest</body><body package="HTTP">extendedMethod	^self prefix notNil		ifTrue: [ self prefix, self method]		ifFalse: [self method]</body><body package="HTTP">headerOnly	^self method asSymbol == #HEAD		or: [ self method asSymbol == #CONNECT ]</body><body package="HTTP">host	^self url ~~ nil 		ifTrue: [ self url host ]		ifFalse: [ nil ]</body><body package="HTTP">hostAndPort	^self url ~~ nil		ifTrue: [self url hostAndPort ]		ifFalse: [ nil ]</body><body package="HTTP">method	^method</body><body package="HTTP">method: aString	method := aString</body><body package="HTTP">parent	^nil</body><body package="HTTP">path	^path</body><body package="HTTP">pathString	^url isNil		ifTrue: [ path]		ifFalse: 			[self useProxy				ifTrue: [self url asString]				ifFalse: [self url pathString]].</body><body package="HTTP">port	^self url ~~ nil 		ifTrue: [ self url port ]		ifFalse: [ nil ]</body><body package="HTTP">prefix	^prefix</body><body package="HTTP">prefix: aString	prefix := aString</body><body package="HTTP">protocol	^self url ~~ nil		ifTrue: [ self url protocol asLowercase ]		ifFalse: 			[self version ~~ nil				ifTrue: [ (self version copyFrom: 1 to: (self version indexOf: $/ ) - 1) asLowercase ]				ifFalse: ['http']]</body><body package="HTTP">url	^url</body><body package="HTTP">url: anURL	url := anURL asURI</body><body package="HTTP">useProxy	useProxy ifNil: [ useProxy := HttpSettings useProxy ].	^useProxy</body><body package="HTTP">useProxy: aBoolean	useProxy := aBoolean</body><body package="HTTP">version	(version isNil or: [ version isEmpty])		ifTrue: [ version := self class defaultVersion].	^version</body><body package="HTTP">version: aString	version := aString</body></methods><methods><class-id>Net.HttpRequestLine</class-id> <category>composing</category><body package="HTTP">writeOn: aStream	self printOn: aStream</body></methods><methods><class-id>Net.HttpRequestLine</class-id> <category>testing</category><body package="HTTP">hasAbsoluteURI	^self url ~~ nil</body><body package="HTTP">isHttp10	^'*1.0*' match: self version</body><body package="HTTP">isValid	^((#( 'POST' 'PUT' 'OPTIONS' 'GET' 'HEAD' 'DELETE' 'TRACE' 'CONNECT' ) includes: self method)		and: [ 'HTTP*' match: self version])</body></methods><methods><class-id>Net.HttpRequestLine</class-id> <category>parsing</category><body package="HTTP">readFrom: stream	| scanner index strUrl |	scanner := MimeScanner on: stream.	method := scanner nextToken.	(index := method indexOf: $-) &gt; 0		ifTrue: 			[prefix := method copyFrom: 1 to: index.			method := method copyFrom: index + 1 to: method size].	scanner skipWhiteSpace.	strUrl  := scanner upTo: Character space.	('http*' match: strUrl)		ifTrue: [url := strUrl asURI ]		ifFalse: [path := strUrl].	version := scanner scanText.</body></methods><methods><class-id>Net.HttpRequestLine</class-id> <category>printing</category><body package="HTTP">printOn: aStream	method = 'CONNECT'		ifTrue: [	aStream 					nextPutAll: self extendedMethod;					space;					nextPutAll: url host, ':', url port printString ; 					space;					nextPutAll: self version. ]		ifFalse: [aStream nextPutAll: self extendedMethod;					space;					nextPutAll: self pathString;					space;					nextPutAll: self version ]</body></methods><methods><class-id>Net.HttpRequestLine class</class-id> <category>instance creation</category><body package="HTTP">method: aMethodString url: requestURI	^self new 		method: aMethodString;		url: requestURI;		yourself</body><body package="HTTP">readFrom: stream	^self new readFrom: stream</body></methods><methods><class-id>Net.HttpRequestLine class</class-id> <category>defaults</category><body package="HTTP">defaultVersion	^'HTTP/1.1'</body></methods><methods><class-id>Net.BasicAuthentication</class-id> <category>authorization</category><body package="HTTP">setNewAuthorizationValue	self authValue basicValue: 		 (self class encodeUser: self username password: self password).	self setAuthorizedState</body></methods><methods><class-id>Net.BasicAuthentication class</class-id> <category>defaults</category><body package="HTTP">scheme	^'Basic'</body></methods><methods><class-id>Net.BasicAuthentication class</class-id> <category>utilities</category><body package="HTTP">encodeUser: username password: password	^MimeEncodedWordCoDec encodeAsBase64: (username, ':', password)  charset: #ISO8859_1</body></methods><methods><class-id>Net.AcceptField</class-id> <category>accessing</category><body package="HTTP">levelAt: index	^(self mediaRangeAt: index) paramAt: 'level'</body><body package="HTTP">mediaRangeAt: index	^self value at: index</body><body package="HTTP">mediaTypeAt: index	^(self mediaRangeAt: index) value</body></methods><methods><class-id>Net.AcceptField</class-id> <category>adding media range</category><body package="HTTP">addMedia: vString	self addMedia: vString qValue: nil</body><body package="HTTP">addMedia: vString level: lString	self addMedia: vString qValue: nil level: lString</body><body package="HTTP">addMedia: vString qValue: qString	self addMedia: vString qValue: qString level: nil</body><body package="HTTP">addMedia: vString qValue: qString level: lString	| valWithParams |	valWithParams := self addValue: vString qValue: qString.	lString notNil ifTrue: [ valWithParams paramAt: 'level' put: lString].</body></methods><methods><class-id>Net.AcceptField class</class-id> <category>parsing</category><body package="HTTP">fieldNames	^#('accept')</body></methods><methods><class-id>Net.AcceptField class</class-id> <category>instant creation</category><body package="HTTP">media: vString	^self media: vString qValue: nil level: nil</body><body package="HTTP">media: mString level: lString	^self media: mString qValue: nil level: lString</body><body package="HTTP">media: vString qValue: qString	^self media: vString qValue: qString level: nil</body><body package="HTTP">media: mString qValue: qString level: lString" Answer an instance of this field representing media range"	^(self name: 'accept') 		addMedia: mString qValue: qString level: lString;		yourself</body></methods><methods><class-id>Net.HttpTimeout</class-id> <category>private</category><body package="HTTP">defaultMessageText	^(#TimeoutConnectionNotResponding &lt;&lt; #net &gt;&gt; 'Timeout   Connection is not responding') asString</body></methods><methods><class-id>Net.TransferEncoding</class-id> <category>accessing</category><body package="HTTP">add: aTransferEncoding	self value addAll: aTransferEncoding value</body><body package="HTTP">canMerge	^true</body></methods><methods><class-id>Net.TransferEncoding</class-id> <category>testing</category><body package="HTTP">isChunked	^self value anySatisfy: [ :vx | 'chunked' match: vx ]</body><body package="HTTP">isGZipped	^self value anySatisfy: [ :vx | 'gzip' match: vx ]</body></methods><methods><class-id>Net.TransferEncoding class</class-id> <category>instant creation</category><body package="HTTP">chunkedTransfer" Answer an instance of this field representing chunked transfer encoding for Http mesagesTransfer-Encoding: chunked "	^(self name: 'transfer-encoding') value:  'chunked'</body><body package="HTTP">gzipTransfer" Answer an instance of this field representing compressed transfer encoding for Http messagesTransfer-encoding: gzip "	^(self name: 'transfer-encoding') value:  'gzip'</body></methods><methods><class-id>Net.TransferEncoding class</class-id> <category>parsing</category><body package="HTTP">fieldNames	^#( 'transfer-encoding'  )</body></methods><methods><class-id>Net.HttpReadingOptions</class-id> <category>accessing</category><body package="HTTP">decodeContents	^decodeContents ifNil: [ self class decodeContents ]</body><body package="HTTP">decodeContents: aBoolean	decodeContents := aBoolean</body><body package="HTTP">decompressContents	^decompressContents ifNil: [ self class decompressContents ]</body><body package="HTTP">decompressContents: aBoolean	decompressContents := aBoolean</body></methods><methods><class-id>Net.HttpReadingOptions</class-id> <category>defaults</category><body package="HTTP">defaultRootEntityType	^HttpEntity</body></methods><methods><class-id>Net.HttpReadingOptions class</class-id> <category>defaults</category><body package="HTTP">decodeContents	^decodeContents isNil		ifTrue: [decodeContents := self decodeContentsValue]		ifFalse: [decodeContents]</body><body package="HTTP">decodeContents: aBoolean	decodeContents := aBoolean</body><body package="HTTP">decompressContents	^decompressContents isNil		ifTrue: [decompressContents := self defaultDecompressContents ]		ifFalse: [decompressContents]</body><body package="HTTP">decompressContents: aBoolean	decompressContents := aBoolean</body><body package="HTTP">defaultBuilderType	^HttpBuildHandler</body></methods><methods><class-id>Net.HttpReadingOptions class</class-id> <category>default values</category><body package="HTTP">decodeContentsValue	^true</body><body package="HTTP">defaultAttachmentDirectoryValue	^'http-temp-files'</body><body package="HTTP">defaultDecompressContents	^true</body><body package="HTTP">saveAttachmentsAsFilesValue	^true</body></methods><methods><class-id>Net.HttpRequest</class-id> <category>accessing</category><body package="HTTP">headerOnly	^self requestLine ifNil: [false] ifNotNil: [ :line | line headerOnly ]</body><body package="HTTP">hostName	^self hostPortToConnect first</body><body package="HTTP">messageLine	^self requestLine</body><body package="HTTP">messageLine: aRequestLine	self requestLine: aRequestLine</body><body package="HTTP">method	^self requestLine method</body><body package="HTTP">port	^self hostPortToConnect last</body><body package="HTTP">protocol	^self requestLine protocol</body><body package="HTTP">requestLine	^requestLine</body><body package="HTTP">requestLine: aRequestLine	requestLine := aRequestLine.</body><body package="HTTP">url	| path |	^self requestLine hasAbsoluteURI		ifTrue: [self requestLine url ]		ifFalse: 	[ path := self requestLine path.				path first = $/ ifTrue: [ path := path allButFirst: 1. ].				HttpURL host: self host encodedPathString: path ]</body><body package="HTTP">url: aURI	self requestLine url: aURI.	(self fieldAt: 'host') ifNotNil: [ :field | self removeField: field ].</body><body package="HTTP">useProxy	^self requestLine useProxy</body><body package="HTTP">useProxy: aBoolean	self requestLine useProxy: aBoolean</body><body package="HTTP">version	^self requestLine version</body><body package="HTTP">version: aString	^self requestLine version: aString</body><body package="HTTP">writingOptions	^writingOptions ifNil: [ (writingOptions := HttpWritingOptions new) headerOnly: self headerOnly ]</body></methods><methods><class-id>Net.HttpRequest</class-id> <category>mandatory extensions</category><body package="HTTP">extendedMethod	^self requestLine extendedMethod</body></methods><methods><class-id>Net.HttpRequest</class-id> <category>accessing fields</category><body package="HTTP">accept	" Returns all AcceptFields "	^self fieldsAt: 'accept'</body><body package="HTTP">accept: aStringOrAcceptField"Sets a value the parameter can be a string or instance of AcceptField"		aStringOrAcceptField isString		ifTrue:  [ (self getFieldAt: 'accept') addMedia: aStringOrAcceptField]		ifFalse: 	[ self removeFieldAt: 'accept'.				self addField: aStringOrAcceptField]</body><body package="HTTP">acceptCharset"Returns collection of AcceptCharsetFields"	^self fieldsAt: 'accept-charset'</body><body package="HTTP">acceptCharset: aStringOrAcceptCharsetField"Sets a value the parameter can be a string or instance of AcceptCharsetField"		aStringOrAcceptCharsetField isString		ifTrue: [ (self getFieldAt: 'accept-charset') addCharset: aStringOrAcceptCharsetField]		ifFalse:			[ self removeFieldAt: 'accept-charset'.			self addField: aStringOrAcceptCharsetField]</body><body package="HTTP">acceptEncoding	^self fieldValueAt: 'accept-encoding'</body><body package="HTTP">acceptEncoding: aStringOrCollection	(self getFieldAt: 'accept-encoding') value: aStringOrCollection</body><body package="HTTP">acceptLanguage" Returns all AcceptLanguageFields "	^self fieldsAt: 'accept-language'</body><body package="HTTP">acceptLanguage: aStringOrAcceptLanguageField"Sets a value the parameter can be a string or instance of AcceptLanguage"		aStringOrAcceptLanguageField isString		ifTrue: 			[ (self getFieldAt: 'accept-language') 			addLanguage: aStringOrAcceptLanguageField]		ifFalse:			[ self removeFieldAt: 'accept-language'.			self addField: aStringOrAcceptLanguageField]</body><body package="HTTP">authorization	^self fieldAt: 'authorization'</body><body package="HTTP">authorization: aStringOrAuthorizationField"Sets a value the parameter can be a string or instance of AuthenticateChallengeField"		aStringOrAuthorizationField isString		ifTrue: [ (self getFieldAt: 'authorization') addScheme: aStringOrAuthorizationField]		ifFalse:			[ self removeFieldAt: 'authorization'.			self addField: aStringOrAuthorizationField]</body><body package="HTTP">host	^self fieldValueAt: 'host'</body><body package="HTTP">host: aString	(self getFieldAt: 'host') value: aString</body><body package="HTTP">ifMatch	^self fieldValueAt: 'if-match'</body><body package="HTTP">ifMatch: aStringOrCollection	(self getFieldAt: 'if-match') value: aStringOrCollection</body><body package="HTTP">ifModifiedSince	^self fieldValueAt: 'if-modified-since'</body><body package="HTTP">ifModifiedSince: aString	(self getFieldAt: 'if-modified-since') value: aString</body><body package="HTTP">ifNoneMatch	^self fieldValueAt: 'if-none-match'</body><body package="HTTP">ifNoneMatch: aStringOrCollection	(self getFieldAt: 'if-none-match') value: aStringOrCollection</body><body package="HTTP">ifRange	^self fieldValueAt: 'if-range'</body><body package="HTTP">ifRange: aString	(self getFieldAt:'if-range') value: aString</body><body package="HTTP">ifUnModifiedSince	^self fieldValueAt: 'if-unmodified-since'</body><body package="HTTP">ifUnModifiedSince: aString	(self getFieldAt: 'if-unmodified-since') value: aString</body><body package="HTTP">maxForwards	^self fieldValueAt: 'max-forwards'</body><body package="HTTP">maxForwards: aString	(self getFieldAt:  'max-forwards') value: aString</body><body package="HTTP">proxyAuthorization	^self fieldValueAt: 'proxy-authorization'</body><body package="HTTP">proxyAuthorization: aString	(self getFieldAt:  'proxy-authorization' ) value: aString</body><body package="HTTP">referer	^self fieldValueAt: 'referer'</body><body package="HTTP">referer: aString	(self getFieldAt: 'referer') value: aString</body><body package="HTTP">upgrade	^self fieldValueAt: 'upgrade'</body><body package="HTTP">userAgent"  User-Agent     = 'User-Agent: 1*( product | comment ) "	^self fieldValueAt: 'user-agent'</body><body package="HTTP">userAgent: aString	(self getFieldAt: 'user-agent') value: aString</body></methods><methods><class-id>Net.HttpRequest</class-id> <category>testing</category><body package="HTTP">hasBody	^(#('GET' 'HEAD' 'DELETE') includes: self method) not</body><body package="HTTP">hasHostField	^self host notNil</body><body package="HTTP">isConnectionClose	"Note that this does the right thing even if the field is missing"	| connection |	connection := self connection ifNil: [Array new].	^self isVersion10		ifTrue: [ ( connection includes: 'keep-alive') not ]		ifFalse: [ connection includes: 'close' ]</body><body package="HTTP">isHttp10	^self requestLine isHttp10</body><body package="HTTP">isRequest	^true</body><body package="HTTP">isValid	^(self requestLine isValid and: [ self host notNil])</body><body package="HTTP">isVersion10	^self requestLine version = 'HTTP/1.0'</body></methods><methods><class-id>Net.HttpRequest</class-id> <category>transfer encodings</category><body package="HTTP">transferFieldOrder" HTTP request  recommends field order (if present) to be as follows. Order for remaining fiedls does not matter "	^#('host')</body></methods><methods><class-id>Net.HttpRequest</class-id> <category>low-level command interface</category><body package="HTTP">execute" Create http client, connect, send request and answer HttpResponse "	| client |	client := self newClient.	^[client executeRequest: self]		ensure: [ client ifNotNil: [ client close]]</body><body package="HTTP">executeDo: aBlock" Create http client, connect, send request and pass http connection stream to the specified block "	^self newClient		executeRequest: self		do: aBlock.</body><body package="HTTP">newClient	^HttpClient new		readingOptions: self readingOptions;		writingOptions: self writingOptions;		yourself</body></methods><methods><class-id>Net.HttpRequest</class-id> <category>private</category><body package="HTTP">hostPortToConnect"1.If Request-URI is an absoluteURI, the host is part of the        Request-URI. Any Host header field value in the request MUST be        ignored.2. If the Request-URI is not an absoluteURI, and the request        includes a Host header field, the host is determined by the Host        header field value.3. If the host as determined by rule 1 or 2 is not a valid host on        the server, the response MUST be a 400 (Bad Request) error        message."	| host str port |	self requestLine hasAbsoluteURI		ifTrue: 			[ ^Array with: self requestLine host with: self requestLine port]		ifFalse:			[ (host := self host) ~~ nil				ifTrue: 					[ str := host readStream.					host := str upTo: $:.					(port := Number readFrom: str) = 0 ifTrue: [ port := nil].					^Array with: host with: port]].		HttpBadRequest new messageText: (#HostIsNotSpecified &lt;&lt; #net &gt;&gt; 'Host is not specified'); raiseSignal</body><body package="HTTP">method: aMethodString url: requestURI	requestLine := HttpRequestLine new					method: aMethodString; 					url: requestURI asURI;					yourself.	self hasHostField 		ifFalse: [self host: requestLine hostAndPort]</body></methods><methods><class-id>Net.HttpRequest class</class-id> <category>Http commands</category><body package="HTTP">connect: urlString	^self method: 'CONNECT' url: urlString</body><body package="HTTP">delete: urlString	^self method: 'DELETE' url: urlString</body><body package="HTTP">get: urlString	^self method: 'GET' url: urlString</body><body package="HTTP">headers: urlString	^self method: 'HEAD' url: urlString</body><body package="HTTP">post: urlString	^self method: 'POST' url: urlString</body><body package="HTTP">put: urlString	^self method: 'PUT' url: urlString</body></methods><methods><class-id>Net.HttpRequest class</class-id> <category>defaults</category><body package="HTTP">defaultContentType	^MimeTypeDescriptor contentTypeHtml</body></methods><methods><class-id>Net.HttpRequest class</class-id> <category>instance creation</category><body package="HTTP">method: aMethodString url: requestURI	^self new 		method: aMethodString url: requestURI;		yourself</body></methods><methods><class-id>Net.HttpUser</class-id> <category>testing</category><body package="HTTP">acceptsRealm: aString	^self realms isEmpty		or: [self realms anySatisfy: [ :each | each = aString ]]</body><body package="HTTP">isHttpUser	^false</body></methods><methods><class-id>Net.HttpUser</class-id> <category>accessing</category><body package="HTTP">realm	^self realms notEmpty		ifTrue: [ self realms  first ]		ifFalse: [ nil ]</body><body package="HTTP">realms	^realms ifNil: [ realms := OrderedCollection new].</body><body package="HTTP">realms: aCollection	realms := aCollection</body></methods><methods><class-id>Net.HttpUser</class-id> <category>adding</category><body package="HTTP">addRealm: aString	aString ifNotNil: [ self realms add: aString]</body></methods><methods><class-id>Net.HttpWritingOptions</class-id> <category>accessing</category><body package="HTTP">addUserAgentField	^addUserAgentField ifNil: [addUserAgentField := self class addUserAgentField]</body><body package="HTTP">addUserAgentField: aBoolean	addUserAgentField := aBoolean</body><body package="HTTP">chunkSize	^chunkSize</body><body package="HTTP">chunkSize: aNumber	chunkSize := aNumber.	"a nil is a valid input and means use default settings for chunking"	aNumber ifNotNil: [ self doChunk ]</body><body package="HTTP">doChunk	self shouldChunk: true</body><body package="HTTP">doNotChunk	self shouldChunk: false</body><body package="HTTP">logAsPrintString	^logAsPrintString  ifNil: [logAsPrintString := self class logAsPrintString]</body><body package="HTTP">logAsPrintString: aBoolean	logAsPrintString := aBoolean</body><body package="HTTP">setContentLength	^setContentLength ifNil: [ self class setContentLength ]</body><body package="HTTP">setContentLength: anObject	setContentLength := anObject</body><body package="HTTP">shouldChunk	^shouldChunk ifNil: [shouldChunk := self class shouldChunk]</body><body package="HTTP">shouldChunk: aBoolean	shouldChunk := aBoolean</body><body package="HTTP">useGZipTransfer	^useGZipTransfer ifNil: [useGZipTransfer := self class useGZipTransfer]</body><body package="HTTP">useGZipTransfer: aBoolean	useGZipTransfer := aBoolean</body><body package="HTTP">userAgentFieldValue	^userAgentFieldValue ifNil: [userAgentFieldValue := self class userAgentFieldValue]</body><body package="HTTP">userAgentFieldValue: aString	userAgentFieldValue := aString</body></methods><methods><class-id>Net.HttpWritingOptions class</class-id> <category>printing options</category><body package="HTTP">addUserAgentField	^addUserAgentField ifNil: [ self addUserAgentFieldValue ]</body><body package="HTTP">addUserAgentField: aBoolean	addUserAgentField := aBoolean</body><body package="HTTP">setContentLength	^setContentLength ifNil: [setContentLength := self defaultSetContentLength ]</body><body package="HTTP">setContentLength: aBoolean	setContentLength := aBoolean</body><body package="HTTP">shouldChunk	^shouldChunk ifNil: [shouldChunk := self shouldChunkValue]</body><body package="HTTP">shouldChunk: aBoolean	shouldChunk := aBoolean</body><body package="HTTP">useGZipTransfer	^useGZipTransfer ifNil: [useGZipTransfer := self useGZipTransferValue]</body><body package="HTTP">useGZipTransfer: aBoolean	useGZipTransfer := aBoolean</body><body package="HTTP">userAgentFieldValue		^userAgentFieldValue ifNil: [self userAgentFieldDefaultValue]</body><body package="HTTP">userAgentFieldValue: aString		userAgentFieldValue := aString</body></methods><methods><class-id>Net.HttpWritingOptions class</class-id> <category>defaults</category><body package="HTTP">defaultPrinterType	^HttpPrintHandler</body><body package="HTTP">defaultWriterType	^HttpWriteHandler</body></methods><methods><class-id>Net.HttpWritingOptions class</class-id> <category>default values</category><body package="HTTP">addUserAgentFieldValue	^false</body><body package="HTTP">defaultChunkSize	^ChunkedWriteStream defaultWriteLimit</body><body package="HTTP">defaultLogAsPrintString	^false</body><body package="HTTP">defaultSetContentLength	^true</body><body package="HTTP">shouldChunkValue	^true</body><body package="HTTP">useGZipTransferValue	^false</body><body package="HTTP">userAgentFieldDefaultValue	^SystemUtils version</body></methods><methods><class-id>Net.HttpWritingOptions class</class-id> <category>debugging</category><body package="HTTP">logAsPrintString	^logAsPrintString ifNil: [logAsPrintString := self defaultLogAsPrintString]</body><body package="HTTP">logAsPrintString: aBoolean	logAsPrintString := aBoolean</body></methods><methods><class-id>Net.HttpProtocolInterpreter</class-id> <category>cookie management</category><body package="HTTP">addCookieTo: aRequest	self getCookieAgent isNil ifTrue: [ ^nil ].	^self cookieAgent setCookieFieldForRequest: aRequest.</body><body package="HTTP">cookieAgent	^cookieAgent</body><body package="HTTP">enableCookies	^self settings enableCookieProcessing</body><body package="HTTP">enableCookies: aBoolean 	self settings enableCookieProcessing: aBoolean</body><body package="HTTP">getCookieAgent	self enableCookies ifFalse: [^nil].	cookieAgent isNil ifTrue: [cookieAgent := CookieAgent new].	^cookieAgent</body><body package="HTTP">registerCookiesFromResponse: aHttpResponse 	self getCookieAgent isNil ifTrue: [ ^nil ]. 	(aHttpResponse setCookieFields detect: [ :f | f shouldTerminateSession ] ifNone: [nil]) notNil		ifTrue: [self terminateCookieAgent. ^nil ].	^self cookieAgent addCookiesFrom: aHttpResponse requestUrl: self request url</body><body package="HTTP">terminateCookieAgent	self cookieAgent notNil		ifTrue: 			[ self cookieAgent terminate.			cookieAgent := nil].</body></methods><methods><class-id>Net.HttpProtocolInterpreter</class-id> <category>connection management</category><body package="HTTP">close	self terminateCookieAgent.	self disconnect.</body><body package="HTTP">connect	self setHostPort.	self setConnection.	^(self useProxyForCurrentHost and: [ self connection isSecure])		ifTrue: [self establishSSLConnectionViaProxy ]		ifFalse: [super connectToHost: self hostName port: self portNumber timeout: self timeout ]</body><body package="HTTP">connectToHost: aHostName port: aNumber timeout: tmNumber		self hostName: aHostName.	self portNumber: aNumber.	self timeout: tmNumber.	^self connect.</body><body package="HTTP">establishSSLConnectionViaProxy	| originalRequest |	originalRequest := self request.	request := HttpRequest connect: self request url.	self request useProxy: true.	self openSocketStreamForProxy.	self executeWithConnection: self stream.	self readResponse isSuccess		ifTrue: [self connection hostName: originalRequest hostName; startTLS. 				request := originalRequest].	^self connection stream</body><body package="HTTP">openSocketStreamForProxy	self connection 		openSocketStreamFor: self hostName		port: (self proxyHost port ifNil: [HttpConnection defaultPortNumber])		timeout: self timeout		encoding: self connection defaultEncoding.</body><body package="HTTP">setConnection	(self request notNil and: [self connection isNil])		ifTrue: [^self streamHandlerClassFor: self request url protocol].	self request isNil ifTrue: [ ^self connection].	(self request notNil and: [self connection notNil and: [(self connection accepts: self request url ) not]])		ifTrue: 			[self disconnect.			^self streamHandlerClassFor: self request url protocol].</body><body package="HTTP">setHostPort	self useProxyForCurrentHost ifTrue: [		self proxyHost ifNil: [ HttpException  raiseSignal: (#ProxyHostIsNotDefined &lt;&lt; #net &gt;&gt; 'Proxy host is not defined in Settings')].		self hostName: self proxyHost name. 		self portNumber:  self proxyHost port ].	self hostName ifNil: [ | arr |		arr := self request hostPortToConnect.		self hostName: arr first.		self portNumber: arr last].</body><body package="HTTP">streamHandlerClassFor: aString	('http' match: aString)		ifTrue: [ ^self connection: self netConnectionClass new ].	('https' match: aString)		ifFalse: 			[^HttpException  raiseSignal:  ((#UnsupportedProtocol1s &lt;&lt; #net &gt;&gt; 'Unsupported protocol: &lt;1s&gt;')			expandMacrosWith: aString)].	#{Net.HttpsConnection} valueOrDo: [URI tryToLoad: 'HTTPS'].	^self useSecureConnection</body><body package="HTTP">useProxyForCurrentHost	^self useProxy and: [	(self proxyExceptions anySatisfy: [ :addr | addr match: self request hostName ]) not ]</body></methods><methods><class-id>Net.HttpProtocolInterpreter</class-id> <category>authorization</category><body package="HTTP">acceptAuthInfoFrom: aHttpResponse	self authPolicy acceptAuthInfoFrom:  aHttpResponse</body><body package="HTTP">authPolicy	^authPolicy ifNil: [ authPolicy := AuthenticationPolicy new ]</body><body package="HTTP">authPolicy: aHttpAuthPolicy	authPolicy := aHttpAuthPolicy</body><body package="HTTP">proxyAuthPolicy	^proxyAuthPolicy ifNil: [ proxyAuthPolicy := ProxyAuthenticationPolicy new ]</body><body package="HTTP">proxyPassword	^self proxyUser notNil		ifTrue: [ self proxyUser password]		ifFalse: [nil]</body><body package="HTTP">proxyUser	^self proxyHost notNil		ifTrue: [ self proxyHost netUser]		ifFalse: [nil]</body><body package="HTTP">proxyUser: aNetUser	self proxyAuthPolicy user: aNetUser.	self proxyHost user: aNetUser</body><body package="HTTP">proxyUsername		^self proxyUser notNil		ifTrue: [ self proxyUser username]		ifFalse: [nil]</body><body package="HTTP">realm: rString	self authPolicy realm: rString</body><body package="HTTP">useBasicAuth	self authPolicy useBasicAuth.	self useProxy ifTrue: [self proxyAuthPolicy username: self proxyUsername password: self proxyPassword]</body><body package="HTTP">useNTLMAuth	self authPolicy useNTLMAuth.	self useProxy ifTrue: [self proxyAuthPolicy username: self proxyUsername password: self proxyPassword]</body><body package="HTTP">user	^self authPolicy user</body><body package="HTTP">user: aNetUser	self authPolicy user: aNetUser</body><body package="HTTP">username: unString password: pString	self authPolicy username: unString password: pString</body><body package="HTTP">username: aString password: pString realm: rString	self authPolicy username: aString password: pString realm: rString</body></methods><methods><class-id>Net.HttpProtocolInterpreter</class-id> <category>accessing</category><body package="HTTP">hostName	^hostName</body><body package="HTTP">hostName: aString	hostName := aString</body><body package="HTTP">logAsPrintString	^self writingOptions logAsPrintString</body><body package="HTTP">logAsPrintString: aBoolean	self writingOptions logAsPrintString: aBoolean</body><body package="HTTP">portNumber	^portNumber</body><body package="HTTP">portNumber: aNumber	portNumber := aNumber</body><body package="HTTP">proxyHostName	^self proxyHost notNil		ifTrue: [ self proxyHost  name]		ifFalse: [ nil ]</body><body package="HTTP">proxyHostPort	^(self proxyHost isNil or: [self proxyHost port isNil ]) 		ifTrue: [ nil ]		ifFalse: [ self proxyHost port ]</body><body package="HTTP">readingOptions	^readingOptions ifNil: [readingOptions := self class defaultReadingOptionsType new]</body><body package="HTTP">readingOptions: anHttpReadingOptions	readingOptions := anHttpReadingOptions</body><body package="HTTP">request	^request</body><body package="HTTP">request: anHttpRequst	request := anHttpRequst</body><body package="HTTP">writingOptions	^writingOptions ifNil: [ writingOptions := self class defaultWritingOptionsType new]</body><body package="HTTP">writingOptions: anHttpWritingOptions	writingOptions := anHttpWritingOptions</body></methods><methods><class-id>Net.HttpProtocolInterpreter</class-id> <category>exception processing</category><body package="HTTP">handleResponseException: ex	| selector response |	^(response := ex parameter ) notNil		ifTrue: 			[ selector := (('process', response code ), ':') asSymbol .			^(self respondsTo: selector)				ifTrue: [self perform: selector with: ex ]				ifFalse: [nil]]		ifFalse: [nil]</body><body package="HTTP">policy: aAuthPolicy acceptChallengeFrom: exception 	exception parameter setCookie ifNotNil: [self registerCookiesFromResponse: exception parameter].	^(aAuthPolicy acceptChallenge: exception parameter request: self request )		ifTrue: [aAuthPolicy addAuthorizationTo: self request.				self addCookieTo: self request.				self isConnected ifFalse: [ self connect ].				self execute: self  request withConnection: self stream.				self readResponse]		ifFalse: [nil]</body><body package="HTTP">process100: ex	^ex retry</body><body package="HTTP">process301: ex	| newUrl |	self redirectRequest ifFalse: [^nil].	ex parameter setCookie ifNotNil: [self registerCookiesFromResponse: ex parameter].	(#('GET' 'HEAD') includes: self request method )		ifFalse: [^nil].	newUrl := self request url resolvePath: ex location.	^self request url = newUrl 		ifTrue: [ ex parameter ]		ifFalse: 			[( self hostName ~= newUrl host 				or: [self portNumber ~= newUrl port ])				ifTrue: 					[ self hostName: newUrl host.					self portNumber: newUrl port.					self disconnect].			self request url: newUrl.			self authPolicy setNotAuthorizedState.			self executeAndGetResponse]</body><body package="HTTP">process302: ex	^self process301: ex</body><body package="HTTP">process401: exception	"Authorization required"	^self policy: self authPolicy acceptChallengeFrom: exception</body><body package="HTTP">process407: exception	"Proxy Authentication required"	exception parameter hasConnectionClose ifTrue: [self close; openSocketStreamForProxy ].	^self policy: self proxyAuthPolicy acceptChallengeFrom: exception</body></methods><methods><class-id>Net.HttpProtocolInterpreter</class-id> <category>response</category><body package="HTTP">readResponse	^self readFrom: self responseStream</body></methods><methods><class-id>Net.HttpProtocolInterpreter</class-id> <category>execute request</category><body package="HTTP">executeAndGetResponse" Connect, send request, parse response and answer instance of HttpResponse class "	self request ifNil: [^nil].	self isConnected ifFalse: [ self connect ].	self executeWithConnection: self stream.	^self readResponse</body><body package="HTTP">executeRequest: aRequest	request := aRequest.	self isConnected ifFalse: [ self connect ].	^self executeWithConnection: self stream</body></methods><methods><class-id>Net.HttpProtocolInterpreter</class-id> <category>initialize-release</category><body package="HTTP">readEntityFrom: stream	^self newBuilder readFrom: stream.</body><body package="HTTP">readFrom: stream	^self 		readFrom: stream 		onError:  [ :ex | (HttpStatusLineError handles: ex)  ifTrue: [ self  close ]]</body><body package="HTTP">readFrom: stream onError: aBlock	| message |	^[ message := self  readEntityFrom: stream.	message log.	message isResponse 		ifTrue: 			["Keep the connection always alive  for 1.0 proxy and CONNECT method"			(message isHttp10 and: [self request method = 'CONNECT' ])				ifFalse: [ (message isConnectionTransient or: [self request isConnectionTransient]) 							ifTrue: [ self close ]]. 			HttpException handleResponse: message.			"response is success "			self registerCookiesFromResponse: message.			self acceptAuthInfoFrom: message. ]		ifFalse: [ request := message ].	message	] on: HttpException	 do:  [ :ex | 		aBlock value: ex. 		(self handleResponseException: ex )			ifNil: [ ex pass ]			ifNotNil: [ :msg | msg ]].</body></methods><methods><class-id>Net.HttpProtocolInterpreter</class-id> <category>private</category><body package="HTTP">execute: aRequest withConnection: aConnectionStream	self log: aRequest.	self newWriter writeMessage: aRequest on: aConnectionStream.	aConnectionStream flush.	^aConnectionStream</body><body package="HTTP">executeWithConnection: aConnectionStream	self prepareRequestToSend.	^self execute: self  request withConnection: aConnectionStream</body><body package="HTTP">log: message	self log: 		[self logAsPrintString			ifTrue: [message printString]			ifFalse: [ | s |					s := ((ByteArray new: 1024) withEncoding: #ISO8859_1) writeStream lineEndCRLF. 					message newWriter						useGZipTransfer: self useGZipTransfer;						chunkSize: self chunkSize;						writeMessage: message on: s.					s encodedContents asString]		]		level: #HTTPClientRequest.</body><body package="HTTP">prepareRequestToSend	self useProxyForCurrentHost 		ifTrue: [ 	self proxyAuthPolicy user:  self proxyUser.				 self proxyAuthPolicy addAuthorizationTo: self request  ].	self request useProxy: self useProxyForCurrentHost.	self authPolicy addAuthorizationTo: self request.	self addCookieTo: self request.</body></methods><methods><class-id>Net.HttpProtocolInterpreter</class-id> <category>printing options</category><body package="HTTP">chunkSize	^self writingOptions chunkSize</body><body package="HTTP">chunkSize: aNumber	self writingOptions chunkSize: aNumber</body><body package="HTTP">newPrinter	^self writingOptions  newPrinter</body><body package="HTTP">newWriter	^self writingOptions  newWriter</body><body package="HTTP">shouldChunk	^self writingOptions shouldChunk</body><body package="HTTP">shouldChunk: aBoolean	self writingOptions shouldChunk: aBoolean</body><body package="HTTP">useGZipTransfer	^self writingOptions useGZipTransfer</body><body package="HTTP">useGZipTransfer: aBoolean	self writingOptions useGZipTransfer: aBoolean</body></methods><methods><class-id>Net.HttpProtocolInterpreter</class-id> <category>parsing options</category><body package="HTTP">decodeContents	^self readingOptions decodeContents</body><body package="HTTP">decodeContents: aBoolean	self readingOptions decodeContents: aBoolean</body><body package="HTTP">decompressContents	^self readingOptions decompressContents</body><body package="HTTP">decompressContents: aBoolean	self readingOptions decompressContents: aBoolean</body><body package="HTTP">newBuilder	^self readingOptions newBuilder 			headerOnly: self request headerOnly; 			yourself</body></methods><methods><class-id>Net.HttpProtocolInterpreter</class-id> <category>settings</category><body package="HTTP">proxyExceptions	^self settings proxyExceptions</body><body package="HTTP">proxyHost	^self settings proxyHost</body><body package="HTTP">proxyHost: aHostSpec	self settings proxyHost: aHostSpec.	self proxyAuthPolicy user: aHostSpec user</body><body package="HTTP">redirectRequest	^self settings redirectRequest</body><body package="HTTP">useProxy	^self settings useProxy</body><body package="HTTP">useProxy: aBoolean	self settings useProxy: aBoolean.</body></methods><methods><class-id>Net.HttpProtocolInterpreter class</class-id> <category>debugging</category><body package="HTTP">debugLabelsAndValues	^OrderedCollection new		add: ((#HTTPClientRequest &lt;&lt; #net &gt;&gt; 'HTTP Client Request')-&gt;#HTTPClientRequest);		add: (#HTTPServerHeader &lt;&lt; #net &gt;&gt; 'HTTP Server Header')-&gt;#HTTPServerHeader;		add: (#HTTPServerMessage &lt;&lt; #net &gt;&gt; 'HTTP Server Message')-&gt;#HTTPServerMessage;		yourself</body><body package="HTTP">menuItemName	^(#HTTPClientMessages &lt;&lt; #net &gt;&gt; 'HTTP Client Messages')</body></methods><methods><class-id>Net.HttpProtocolInterpreter class</class-id> <category>instance creation</category><body package="HTTP">readFrom: aStream	^self new		readFrom: aStream</body></methods><methods><class-id>Net.HttpProtocolInterpreter class</class-id> <category>class initialization</category><body package="HTTP">initialize	"self initialize."	self registerToDebug.</body></methods><methods><class-id>Net.HttpProtocolInterpreter class</class-id> <category>default values</category><body package="HTTP">defaultNetConnectionValue	^HttpConnection</body><body package="HTTP">defaultReadingOptionsType	^HttpBuildHandler defaultOptionsType</body><body package="HTTP">defaultWritingOptionsType	^HttpWriteHandler defaultOptionsType</body><body package="HTTP">settings		^HttpSettings</body></methods><methods><class-id>Net.HttpProtocolInterpreter class</class-id> <category>cookie management</category><body package="HTTP">enableCookieProcessing	^self settings enableCookieProcessing</body><body package="HTTP">enableCookieProcessing: aBoolean	self settings enableCookieProcessing: aBoolean</body></methods><methods><class-id>Net.HttpProtocolInterpreter class</class-id> <category>accessing</category><body package="HTTP">proxyExceptions	^self settings proxyExceptions</body><body package="HTTP">proxyHost	^self settings proxyHost</body><body package="HTTP">redirectRequest	^self settings redirectRequest</body><body package="HTTP">useProxy	^self settings useProxy</body></methods><methods><class-id>Net.AuthenticationInfoField</class-id> <category>accessing</category><body package="HTTP">valueWithParamsClass	^DigestAuthenticationValue</body></methods><methods><class-id>Net.AuthenticationInfoField class</class-id> <category>parsing</category><body package="HTTP">fieldNames	^#('authentication-info' )</body></methods><methods><class-id>Net.CookieAgent</class-id> <category>utilities</category><body package="HTTP">cookiesAt: anUrl	^self registry 			at: (self keyFrom: anUrl)			ifAbsentPut: [ OrderedCollection new ].</body><body package="HTTP">setCookieFieldForRequest: aHttpRequest	| f |	(f := self cookieFieldForUrl: aHttpRequest url ) notNil		ifTrue:  [aHttpRequest cookie: f ].	^f</body></methods><methods><class-id>Net.CookieAgent</class-id> <category>testing limits</category><body package="HTTP">exceedNumberBytesPerCookie: aSetCookieValue	aSetCookieValue printString size &gt; self class numberBytesPerCookie		ifTrue: 			[ RegistryLimitationExc raiseRequestFrom: (#exceedNumberBytesPerCookie &lt;&lt; #net &gt;&gt; 'Exceed number bytes per cookie &lt;1s&gt;' expandMacrosWith: aSetCookieValue printString)  ].	^false</body><body package="HTTP">exceedNumberEntries	self exceedNumberEntries: self registry</body><body package="HTTP">exceedNumberEntries: aRegistry	| size |	size := 0.	aRegistry values do: [ :vx | size := size + vx size ].	size &gt; self class numberEntries		ifTrue: 			[ RegistryLimitationExc raiseRequestFrom: (#exceedNumberEntries &lt;&lt; #net &gt;&gt; 'Exceed  total cookie number') ].	^false</body><body package="HTTP">exceedNumberEntriesPerServer: aString	self exceedNumberEntriesPerServer: aString registry: self registry</body><body package="HTTP">exceedNumberEntriesPerServer: aString registry: aRegistry	| coll |	coll := aRegistry at: aString ifAbsent: [ ^false ].	coll size &gt; self class numberEntriesPerServer		ifTrue: 			[ RegistryLimitationExc raiseRequestFrom: (#exceedNumberEntriesPerServer &lt;&lt; #net &gt;&gt; 'Exceed number entries per server &lt;1s&gt;' expandMacrosWith: aString)  ].	^false</body><body package="HTTP">shouldUpdateServer: aString	^(self class serversCacheCookiesFrom isEmpty		or: [ self class serversCacheCookiesFrom notEmpty 			and: [ self class serversCacheCookiesFrom includes: aString ]]).</body><body package="HTTP">testCookieBytesLimit: aSetCookieValue	self enableLimits		ifTrue: [ self exceedNumberBytesPerCookie: aSetCookieValue]</body><body package="HTTP">testRegistryAndServerLimits: aString	self enableLimits		ifTrue: 			[ self exceedNumberEntriesPerServer: aString.			self exceedNumberEntries ].</body></methods><methods><class-id>Net.CookieAgent</class-id> <category>managing cookies</category><body package="HTTP">getValidCookieValuesFrom: aCookieCollection requestUrl: anUrl	| coll |	coll := OrderedCollection new.	aCookieCollection do: 		[ :cx | 		cx value 			do: [ :vx | 				(self rejectCookieValue: vx requestUrl: anUrl) 					ifFalse: 						[self testCookieBytesLimit: vx.						coll add: vx]]].	^coll</body><body package="HTTP">registryAdd: aCollection forUrl: anUrl	| setCookiesColl cookie k |	aCollection isEmpty ifTrue: [^nil].	setCookiesColl := self  registry 						at: (k := self keyFrom: anUrl)						ifAbsentPut: [ OrderedCollection new ].	aCollection 		do: [ :newCookie |			(cookie := setCookiesColl detect: [ :cx | cx = newCookie ] ifNone: [ nil]) notNil				ifTrue: [ setCookiesColl remove: cookie]].	setCookiesColl addAll: aCollection.	self testRegistryAndServerLimits: k.	^setCookiesColl</body><body package="HTTP">rejectCookieValue: aSetCookieValue requestUrl: anUrl	aSetCookieValue isUnparsedHeaderValue ifTrue: [^true].	self removeExistingCookieValue: aSetCookieValue requestUrl: anUrl. 	^(self validateDomain: aSetCookieValue domain host: anUrl host) not		or: [ (self validatePathFrom: aSetCookieValue path  path: anUrl pathString ) not ]</body><body package="HTTP">removeExistingCookieValue: aSetCookieValue requestUrl: anUrl	| vx coll |	coll := self registry at: ( self keyFrom:anUrl) ifAbsent: [^nil ].	vx := coll  detect: [ :cx | cx value key = aSetCookieValue value key] ifNone: [ nil].	vx ifNotNil: [coll remove: vx ].</body><body package="HTTP">validateDomain: aCookieDomain host: aHostString	| reqHost  ind cookieDomain |	reqHost := aHostString asLowercase.	cookieDomain := aCookieDomain.	cookieDomain notNil		ifTrue: 			[(cookieDomain at: 1) ~= $. ifTrue: [ cookieDomain := '.', cookieDomain].			"The request-host has the form HD, where D is value of the domain attribute"			(( '*', cookieDomain) match: reqHost) ifFalse: [ ^false ].			ind := reqHost indexOfSubCollection:  cookieDomain startingAt: 1.			"The request-host contains embedded dots or  the domain attribute contains no embedded dots"			(((reqHost copyFrom: 1 to: ind - 1 ) includes: $.) 				or: [ ('.*.*' match: cookieDomain) not					and: [ ('.local' match: cookieDomain) not ]])				ifTrue: [^false].			].	^true.</body><body package="HTTP">validatePathFrom: aCookiePath path: requestPath	aCookiePath notNil		ifTrue: 			["the value for the path attribute has to be a prefix of the request url "			(( aCookiePath, '*' ) match: requestPath )				ifFalse: [ ^false ]].	^true</body></methods><methods><class-id>Net.CookieAgent</class-id> <category>accessing</category><body package="HTTP">cacheCookies	^cacheCookies isNil		ifTrue: [cacheCookies := self class cacheCookies]		ifFalse: [ cacheCookies ]</body><body package="HTTP">cacheCookies: aBoolean	cacheCookies := aBoolean</body><body package="HTTP">classRegistry	^self class registry</body><body package="HTTP">classRegistryAt: aServerString put: aCollection	self classRegistry at: aServerString put: aCollection.	self enableLimits		ifTrue: 			[ self exceedNumberEntriesPerServer: aServerString registry: self classRegistry.			self exceedNumberEntries: self classRegistry ].</body><body package="HTTP">enableLimits	^enableLimits isNil		ifTrue: [ enableLimits := self class enableLimits]		ifFalse: [ enableLimits ]</body><body package="HTTP">enableLimits: aBoolean	enableLimits := aBoolean</body><body package="HTTP">keyFrom: anUrl	^self class keyFrom: anUrl</body><body package="HTTP">registry	^registry</body><body package="HTTP">useCachedCookies	^useCachedCookies isNil		ifTrue: [ useCachedCookies := self class useCachedCookies]		ifFalse: [ useCachedCookies ]</body><body package="HTTP">useCachedCookies: anObject	useCachedCookies := anObject</body></methods><methods><class-id>Net.CookieAgent</class-id> <category>initialize-release</category><body package="HTTP">addCookiesFrom: aHttpResponse requestUrl: anUrl	self setCacheCookieFrom: aHttpResponse.	^self 		registryAdd: (self getValidCookieValuesFrom: aHttpResponse setCookieFields requestUrl: anUrl) 		forUrl: anUrl.</body><body package="HTTP">initialize	registry := Dictionary  new.	self start.</body><body package="HTTP">start	"Starts cookie session"	| vColl |	self class useCachedCookies		ifTrue: 			[ self classRegistry keysAndValuesDo:				[ :key :values | 				vColl := values select: [ :vx | vx isNotExpired ].				self registry at: key put: vColl copy ]].</body><body package="HTTP">terminate	"Terminates cookie session. Saves session cookies to the class registry"	| coll vColl newColl |	self cacheCookies		ifTrue:			[ self registry keysAndValuesDo:				[ :key :values | 				(self shouldUpdateServer: key)					ifTrue: 						[vColl := values select: [ :vx | vx isPersistent and: [ vx isNotExpired ] ].						 vColl notEmpty ifTrue: [							(coll := self classRegistry at: key ifAbsent: [ nil ]) isNil								ifTrue: [self classRegistryAt: key put: vColl ]								ifFalse: 									[ newColl := OrderedCollection new: ( coll size + vColl size).									coll do: [ :vclass |  vColl detect: [ :vx | vx = vclass ] ifNone: [ newColl add: vclass]].									newColl addAll: vColl.									self classRegistryAt: key put: newColl ]]]]].</body></methods><methods><class-id>Net.CookieAgent</class-id> <category>converting</category><body package="HTTP">accept: anUrl for: aSetCookieValue key: keyUrl	^((self cookieDomain: aSetCookieValue domain accept: anUrl host)			and: [(self cookiePath: aSetCookieValue path accept: anUrl pathString)])</body><body package="HTTP">cookieDomain: aSetCookieDomain accept: aString	^aSetCookieDomain isNil		or: [ aSetCookieDomain notNil 				and: ['*', aSetCookieDomain match: aString asLowercase]]</body><body package="HTTP">cookieFieldForUrl: anUrl	"Creates 'Cookie' field for the specified url from registered 'Set-Cookie' fields "	| coll sc xInd yInd f |	coll := OrderedCollection new.	self registry		keysAndValuesDo:			[ :key :value | 			value 				do: [ :vx |				(self accept: anUrl for: vx key: key) ifTrue: [coll add: vx ]]].	coll isEmpty ifTrue: [ ^nil ].	sc := SortedCollection 			withAll: coll			sortBlock: [ :x : y |						xInd := x path notNil							ifTrue: [x path occurrencesOf: $/ ]							ifFalse: [0].						yInd := y path notNil							ifTrue: [y path occurrencesOf: $/ ]							ifFalse: [0].						xInd &gt;= yInd ].	f := CookieField name: 'Cookie'.	f value: (sc collect: [ :cx | cx value ]).	^f</body><body package="HTTP">cookiePath: aCookiePath accept: requestPath	^aCookiePath isNil 		or: [aCookiePath notNil 				and: [( aCookiePath, '*' ) match: requestPath ]]</body></methods><methods><class-id>Net.CookieAgent</class-id> <category>caching</category><body package="HTTP">setCacheCookieFrom: aHttpResponse	| noCache |	aHttpResponse cacheControl notNil		ifTrue: 			[noCache := aHttpResponse cacheControl noCache.			(noCache isKindOf: Boolean) ifTrue: [ ^nil ].			('set-cookie' match: noCache first )				ifTrue: [ self cacheCookies: false ]].</body></methods><methods><class-id>Net.CookieAgent class</class-id> <category>accessing</category><body package="HTTP">cookiesAt: anUrl	^self registry 			at: (self keyFrom: anUrl)			ifAbsentPut: [ OrderedCollection new ].</body><body package="HTTP">keyFrom: anUrl	^anUrl host, ':', anUrl port printString</body><body package="HTTP">registry	Registry ifNil: [ self resetRegistry ].	^Registry</body><body package="HTTP">resetRegistry	Registry := Dictionary new</body></methods><methods><class-id>Net.CookieAgent class</class-id> <category>instance creation</category><body package="HTTP">addCookiesFrom: aHttpEntity requestUrl: anUrl	^self new		addCookiesFrom: aHttpEntity requestUrl: anUrl;		yourself</body><body package="HTTP">new	^super new initialize</body></methods><methods><class-id>Net.CookieAgent class</class-id> <category>defaults</category><body package="HTTP">defaultCacheCookies	^false</body><body package="HTTP">defaultEnableLimits	^false</body><body package="HTTP">defaultNumberBytesPerCookie	^4096</body><body package="HTTP">defaultNumberEntries	^300</body><body package="HTTP">defaultNumberEntriesPerServer	^20</body><body package="HTTP">defaultServersCacheCookiesFrom	^OrderedCollection new</body><body package="HTTP">defaultUseCachedCookies	^false</body></methods><methods><class-id>Net.CookieAgent class</class-id> <category>accessing settings</category><body package="HTTP">cacheCookies	^CacheCookies isNil		ifTrue: [self defaultCacheCookies]		ifFalse: [CacheCookies]</body><body package="HTTP">cacheCookies: aBoolean	CacheCookies := aBoolean</body><body package="HTTP">enableLimits	^EnableLimits isNil		ifTrue: [self defaultEnableLimits]		ifFalse: [EnableLimits]</body><body package="HTTP">enableLimits: aBoolean	EnableLimits := aBoolean</body><body package="HTTP">numberBytesPerCookie	^NumberBytesPerCookie isNil		ifTrue: [NumberBytesPerCookie := self defaultNumberBytesPerCookie ]		ifFalse: [NumberBytesPerCookie]</body><body package="HTTP">numberBytesPerCookie: aNumber	NumberBytesPerCookie := aNumber</body><body package="HTTP">numberEntries	^NumberEntries isNil		ifTrue: [NumberEntries := self defaultNumberEntries]		ifFalse: [NumberEntries]</body><body package="HTTP">numberEntries: aNumber	NumberEntries := aNumber</body><body package="HTTP">numberEntriesPerServer	^NumberEntriesPerServer isNil		ifTrue: [NumberEntriesPerServer := self defaultNumberEntriesPerServer]		ifFalse: [NumberEntriesPerServer]</body><body package="HTTP">numberEntriesPerServer: aNumber	NumberEntriesPerServer := aNumber</body><body package="HTTP">serversCacheCookiesFrom	^ServersCacheCookiesFrom isNil		ifTrue: [ServersCacheCookiesFrom := self defaultServersCacheCookiesFrom]		ifFalse: [ServersCacheCookiesFrom]</body><body package="HTTP">serversCacheCookiesFrom: aCollection	ServersCacheCookiesFrom := aCollection</body><body package="HTTP">useCachedCookies	^UseCachedCookies isNil		ifTrue: [self defaultUseCachedCookies]		ifFalse: [UseCachedCookies]</body><body package="HTTP">useCachedCookies: aBoolean	UseCachedCookies := aBoolean</body></methods><methods><class-id>Net.RegistryLimitationExc</class-id> <category>printing</category><body package="HTTP">defaultMessageText	^'Cookie implementation limits'</body></methods><methods><class-id>Net.HttpClient</class-id> <category>accessing</category><body package="HTTP">hostName	^self clientPI hostName</body><body package="HTTP">hostName: aString	self clientPI hostName: aString</body><body package="HTTP">logAsPrintString: aBoolean	self clientPI logAsPrintString: aBoolean</body><body package="HTTP">portNumber	^self clientPI portNumber</body><body package="HTTP">portNumber: aNumber	self clientPI portNumber: aNumber</body><body package="HTTP">protocol	^protocol ifNil: 		[protocol := request notNil						ifTrue: [ self request protocol ]						ifFalse: [self class protocol ]		]</body><body package="HTTP">protocol: aString	protocol := aString</body><body package="HTTP">proxyHost	^self settings proxyHost</body><body package="HTTP">proxyHost: aHostSpec	self settings proxyHost: aHostSpec</body><body package="HTTP">proxyHostName	^self clientPI proxyHostName</body><body package="HTTP">proxyHostPort	^self clientPI proxyHostPort</body><body package="HTTP">readingOptions	^self clientPI readingOptions</body><body package="HTTP">readingOptions: anHttpReadingOptions	self clientPI readingOptions: anHttpReadingOptions</body><body package="HTTP">request	^request</body><body package="HTTP">requestClass	^HttpRequest</body><body package="HTTP">useProxy	^self settings useProxy</body><body package="HTTP">useProxy: aBoolean	self settings useProxy: aBoolean.</body><body package="HTTP">writingOptions	^self clientPI writingOptions</body><body package="HTTP">writingOptions: anHttpWritingOptions	self clientPI writingOptions: anHttpWritingOptions</body></methods><methods><class-id>Net.HttpClient</class-id> <category>authorization</category><body package="HTTP">authPolicy	^self clientPI authPolicy</body><body package="HTTP">authPolicy: aHttpAuthPolicy	self clientPI authPolicy: aHttpAuthPolicy</body><body package="HTTP">proxyPassword	^self clientPI proxyPassword</body><body package="HTTP">proxyUser	^self clientPI proxyUser</body><body package="HTTP">proxyUser: aNetUser	self clientPI proxyUser: aNetUser</body><body package="HTTP">proxyUsername	^self clientPI proxyUsername</body><body package="HTTP">realm: rString	self authPolicy realm: rString</body><body package="HTTP">useBasicAuth	self clientPI useBasicAuth.</body><body package="HTTP">useNTLMAuth	self clientPI useNTLMAuth.</body><body package="HTTP">user	^self authPolicy user</body><body package="HTTP">user: aNetUser	self authPolicy user: aNetUser</body><body package="HTTP">username: unString password: pString	self authPolicy username: unString password: pString</body><body package="HTTP">username: aString password: pString realm: rString	self authPolicy username: aString password: pString realm: rString</body></methods><methods><class-id>Net.HttpClient</class-id> <category>commands</category><body package="HTTP">delete: urlString	request := (self requestClass delete: urlString ).	^self  executeAndGetResponse</body><body package="HTTP">get: urlString"The GET method means retrieve whatever information (in the form of an entity ) is identified by the urlString""Returns an instance of HttpResponse if succeed or exception"	request := (self requestClass get: urlString ). 	^self  executeAndGetResponse</body><body package="HTTP">headers: urlString"The HEAD method is identical to GET except that the server must not return a message body in the response""Returns an instance of HttpResponse if succeed or exception"	request := (self requestClass headers: urlString ).	^self  executeAndGetResponse</body><body package="HTTP">post: urlString contents: aString " The POST method is used to request that the destination server accept the specified aString as a new subordinate of the resource identified by the urlStringReturns an instance of HttpResponse if succeed or exception"	request := (self requestClass post: urlString ).	request contents: aString. 	^self  executeAndGetResponse</body><body package="HTTP">put: urlString contents: aString"The PUT method requests that the specified aString be stored under the supplied urlString.Returns an instance of HttpResponse if succeed or exception"	request := (self requestClass put: urlString ).	request contents: aString.	^self  executeAndGetResponse</body></methods><methods><class-id>Net.HttpClient</class-id> <category>connection management</category><body package="HTTP">close	self clientPI close</body><body package="HTTP">connect	self clientPI 	streamHandlerClassFor: self protocol.	^self clientPI connect</body><body package="HTTP">disconnect	super disconnect.	protocol := nil</body><body package="HTTP">dontUsePersistentConnection		^self settings connectionPersists: false</body><body package="HTTP">usePersistentConnection		^self settings connectionPersists: true</body></methods><methods><class-id>Net.HttpClient</class-id> <category>cookie management</category><body package="HTTP">addCookieToRequest	^self clientPI addCookieTo: self request.</body><body package="HTTP">cookieAgent	^self clientPI cookieAgent</body><body package="HTTP">enableCookies	^self settings enableCookies</body><body package="HTTP">enableCookies: aBoolean 	self settings enableCookieProcessing: aBoolean</body><body package="HTTP">registerCookiesFromResponse: aHttpResponse	^self clientPI registerCookiesFromResponse: aHttpResponse</body><body package="HTTP">terminateCookieAgent	self clientPI terminateCookieAgent</body></methods><methods><class-id>Net.HttpClient</class-id> <category>streams -- guarded</category><body package="HTTP">readStreamCmd:  commandString url: url do: aBlock" Connect, evaluate block, ensure disconnect, answer block evaluation result "	^self 		executeRequest: (self requestClass method: commandString url: url asURI)		do: aBlock</body></methods><methods><class-id>Net.HttpClient</class-id> <category>initialize-release</category><body package="HTTP">initialize	super initialize.	self clientPI timeout: self defaultTimeout.</body></methods><methods><class-id>Net.HttpClient</class-id> <category>low-level command interface</category><body package="HTTP">executeAndGetResponse" Connect, send request, parse response and answer instance of HttpResponse class "	self request ifNil: [^nil].	self executeRequestDo: nil.	^self getResponse</body><body package="HTTP">executeRequest: aRequest" Connect, send request and answer HttpResponse "	request := aRequest.	^self executeAndGetResponse</body><body package="HTTP">executeRequest: aRequest do: aBlock" Connect, send request and pass connection to specified block "	request := aRequest.	^self executeRequestDo: aBlock</body><body package="HTTP">executeRequestDo: aBlock" Connect, send request and pass connection to specified block "	| streamx |	streamx := self privateExecuteRequest.	^aBlock ifNotNil: [ aBlock  value: streamx ]</body><body package="HTTP">getResponse	^self clientPI readResponse</body></methods><methods><class-id>Net.HttpClient</class-id> <category>private -- command interface</category><body package="HTTP">executeWithConnection: aConnectionStream"the method is used for debugging "	self prepareRequestToSend.	self clientPI request: self request.	^self clientPI executeWithConnection: aConnectionStream</body><body package="HTTP">prepareRequestToSend	(self request isHttp11 and: [self settings connectionPersists not])		ifTrue: [self request connection: 'close'].</body><body package="HTTP">privateExecuteRequest	self prepareRequestToSend.	^self clientPI executeRequest: self request</body><body package="HTTP">request: aReq	request := aReq.	self clientPI request: aReq</body></methods><methods><class-id>Net.HttpClient</class-id> <category>utilities</category><body package="HTTP">getUserAndPasswordDialogFor: response	| dialog spec result msg userx passwordx|	dialog := SimpleDialog new.	spec := (dialog class interfaceSpecFor: #emptySpec).	dialog initializeBuilderFor: nil.	dialog builder add: spec window.	dialog builder add: spec component.	dialog initializeWindowFor: nil.	msg := response descriptionString isNil				ifTrue: [(#TheServerRequiresUserPassword &lt;&lt; #net &gt;&gt; 'The server requires a user and password to see this resource.')]				ifFalse: [response descriptionString].	dialog setInitialGap.	dialog addMessage: msg centered: false.	dialog addGap: 8.	dialog addMessage: (#UserNameC &lt;&lt; #net &gt;&gt; 'User Name:') centered: false.	dialog addGap: 4.	dialog addTextLine: (userx := String new asValue).	dialog addGap: 8.	dialog addMessage: (#PasswordC &lt;&lt; #net &gt;&gt; 'Password:') centered: false.	dialog addGap: 4.	dialog addTextLine: (passwordx :=  String new asValue) type: #password.	dialog addGap: 8.	dialog addOK: [true].	dialog addGap: 6.	dialog preOpen.	dialog builder window maximumSize: Screen default bounds width @ dialog builder window displayBox height.	dialog builder window minimumSize: 150 @ dialog builder window displayBox height.	dialog builder openDialogWithExtent: dialog builder window displayBox extent.	result := dialog accept value		ifTrue: [self class encodeUser: userx value password: passwordx value]		ifFalse: [nil].	^result</body></methods><methods><class-id>Net.HttpClient</class-id> <category>streams -- unguarded</category><body package="HTTP">readStreamCmd:  commandString url: url" Connect, send request and answer http connection stream "	request := self requestClass method: commandString url: url asURI.	^self privateExecuteRequest</body></methods><methods><class-id>Net.HttpClient</class-id> <category>printing options</category><body package="HTTP">chunkSize	^self clientPI chunkSize</body><body package="HTTP">chunkSize: aNumber	^self clientPI chunkSize: aNumber</body><body package="HTTP">doChunk	self clientPI shouldChunk: true</body><body package="HTTP">doNotChunk	self clientPI shouldChunk: false</body><body package="HTTP">useGZipTransfer	^self clientPI useGZipTransfer</body><body package="HTTP">useGZipTransfer: aBoolean	self clientPI useGZipTransfer: aBoolean</body></methods><methods><class-id>Net.HttpClient</class-id> <category>parsing options</category><body package="HTTP">decodeContents: aBoolean	self clientPI decodeContents: aBoolean</body><body package="HTTP">decompressContents: aBoolean	self clientPI decompressContents: aBoolean</body></methods><methods><class-id>Net.HttpClient class</class-id> <category>constants</category><body package="HTTP">description	^(#HTTPServer &lt;&lt; #net &gt;&gt; 'HTTP server') asString</body><body package="HTTP">serverType	^#HTTP</body></methods><methods><class-id>Net.HttpClient class</class-id> <category>utilities</category><body package="HTTP">disableProxy	^self settings useProxy: false</body><body package="HTTP">enableProxy	^self settings useProxy:  true</body><body package="HTTP">httpUsername: username password: password	(username notNil and: [ password notNil])		ifTrue: [ self settings user: (NetUser username: username password: password) ].</body><body package="HTTP">proxyHost: host port: port	self proxyHost: host port: port userid: nil password: nil</body><body package="HTTP">proxyHost: host port: port userid: username password: password	| intPort hostSpec |	host isString ifFalse: [self error: (#ProxyHostNameMustBeString &lt;&lt; #net &gt;&gt; 'Proxy host name must be a string')].	intPort := port isCharacters 		ifTrue: [Integer readFrom: port readStream]		ifFalse: [port].	intPort isInteger 		ifFalse: [self error: (#ProxyPortMustBeAnInteger &lt;&lt; #net &gt;&gt; 'Proxy port must be an integer')].	hostSpec := (HostSpec new					name: host;					port:  intPort;					type: 'http';					yourself).	(username notNil and: [ password notNil])		ifTrue: [	hostSpec netUser: (NetUser username: username password: password)].	" set http proxy Settings "	self settings proxyHost: hostSpec.</body></methods><methods><class-id>Net.HttpClient class</class-id> <category>instance creation</category><body package="HTTP">loginToHost: aHostName asUser: userString withPassword: passwdString 	self shouldNotImplement</body><body package="HTTP">loginToHost: aHostName port: aNumber asUser: userString withPassword: passwdString	self shouldNotImplement</body></methods><methods><class-id>Net.HttpClient class</class-id> <category>accessing</category><body package="HTTP">protocol	^Protocol ifNil: [ Protocol := self defaultProtocolValue ]</body><body package="HTTP">protocol: aString	Protocol := aString.</body><body package="HTTP">proxyExceptions	^self settings proxyExceptions</body><body package="HTTP">proxyHost	^self settings proxyHost</body><body package="HTTP">useProxy	^self settings useProxy</body></methods><methods><class-id>Net.HttpClient class</class-id> <category>default values</category><body package="HTTP">defaultProtocolInterpreterClassValue	^HttpProtocolInterpreter</body><body package="HTTP">defaultProtocolValue	^'http'</body></methods><methods><class-id>Net.HttpClient class</class-id> <category>commands</category><body package="HTTP">get: urlString	^self clientDo: [ :client | client  get: urlString]</body><body package="HTTP">headers: urlString	^self clientDo: [ :client | client  headers: urlString]</body><body package="HTTP">post: urlString contents: aString	^self clientDo: [ :client | client  post: urlString contents: aString]</body></methods><methods><class-id>Net.HttpClient class</class-id> <category>private</category><body package="HTTP">clientDo: aBlock	| client |	client := self new.	^[ aBlock value: client  ] 		ensure: [ client ifNotNil: [ client  close]]</body></methods><methods><class-id>Net.HttpClient class</class-id> <category>class initialization</category><body package="HTTP">initialize	"self initialize"	super initialize.	HeaderField resetRegistry.</body></methods><methods><class-id>Net.HttpClient class</class-id> <category>cookie management</category><body package="HTTP">enableCookieProcessing	^self settings enableCookieProcessing</body><body package="HTTP">enableCookieProcessing: aBoolean	self settings enableCookieProcessing: aBoolean</body></methods><methods><class-id>Net.HttpWriteHandler</class-id> <category>action callbacks</category><body package="HTTP">endHeader: aMessageHeader	aMessageHeader parent isHttpEntity ifFalse: [ self stream cr ].	^aMessageHeader parent</body></methods><methods><class-id>Net.HttpWriteHandler</class-id> <category>defaults</category><body package="HTTP">defaultEncoding		^HttpConnection defaultEncoding</body><body package="HTTP">dispatcherClass	^HttpDispatcher</body></methods><methods><class-id>Net.HttpWriteHandler</class-id> <category>printing utilities</category><body package="HTTP">printHeader: aMessageHeader	aMessageHeader removeKey: 'content-length'.	super printHeader: aMessageHeader</body><body package="HTTP">printPreambule: aMessageBody	^true</body></methods><methods><class-id>Net.HttpWriteHandler</class-id> <category>private</category><body package="HTTP">addContentLength: aNumber entity: anEntity	| f |	(aNumber = 0 and: [anEntity isRequest and: [ anEntity messageLine method = 'GET' ]])		ifTrue: [ ^originalStream cr].			[ originalStream text.	(self options setContentLength		and: [ anEntity isMultipartByteranges not ])		ifTrue: [bodySize := aNumber.				(f := HeaderField name: 'Content-length') value:aNumber.				f writeOn: originalStream.				"cr - end of content length field"				originalStream cr].	"cr - end of the message header "	originalStream cr.		] ensure: [ originalStream binary]</body><body package="HTTP">addTransferChunked	| f |	f := TransferEncoding chunkedTransfer.	originalStream text. 	[ f writeOn: originalStream.	"cr - end of transfer encoding field, cr - end of the message header "	originalStream  cr; cr.	] ensure: [ originalStream binary].</body><body package="HTTP">finishEmptyBodyMessage: anEntity		self addContentLength: 0 entity: anEntity</body><body package="HTTP">prepareHeader: aMimeEntity	super prepareHeader: aMimeEntity.	(self addUserAgentField 		and: [aMimeEntity userAgent isNil ])		ifTrue: [ aMimeEntity userAgent: self userAgentFieldValue].</body><body package="HTTP">selectFieldsFrom: aMessageHeader	^(super selectFieldsFrom: aMessageHeader) 		addAll: ( self setTransferContext: aMessageHeader parent);		yourself.</body><body package="HTTP">setTransferContext: aMimeEntity 	"The Internet Assigned Numbers Authority (IANA) acts as a registry for transfer-coding value tokens. Initially, the registry contains the following tokens: 'chunked',  'identity', 'gzip', 'compress', and 'deflate'Transfer-Encoding: gzipTransfer-Encoding: chunkedIf the printer is set to send a message in gzip format, we will send the message as gzipped and chunked.Multipart messages and big messages are sent as chunked ones "	| coll |	coll := OrderedCollection new.	aMimeEntity isHttpEntity ifFalse: [^coll].	self useGZipTransfer ifTrue: [coll add: TransferEncoding gzipTransfer].	^coll</body><body package="HTTP">startSimpleBody: aSimpleBody	aSimpleBody writeOn: self stream</body></methods><methods><class-id>Net.HttpWriteHandler</class-id> <category>private prepare streams</category><body package="HTTP">newBodyWriteStreamOn: aStream for: aMessage	^(Net.BodyWriteStream on: aStream)		onFinishDo: [ :position | self addContentLength: position entity: aMessage.];		yourself</body><body package="HTTP">newChunkedWriteStreamOn: aStream for: aMessage	^(Net.ChunkedWriteStream on: aStream) 		onFinishWithOneBufferDo: [ :position | self addContentLength: position entity: aMessage ];		onReadyToWriteFirstBufferDo: [ self addTransferChunked ];		chunkSize: self chunkSize; 		yourself</body><body package="HTTP">prepareStream: aStream forMessageBody: aMessage	| streamx |	streamx := self shouldChunk 			ifTrue: [ self newChunkedWriteStreamOn: aStream for: aMessage]			ifFalse: [ (aMessage body isSimple and: [aMessage body size &gt; 0 and: [self useGZipTransfer not]])					ifTrue: [	"If we know the size of a simple body upfront we can avoid the cost of buffering the body in the BodyWriteStream"							self addContentLength: aMessage body size entity: aMessage.							^aStream lineEndCRLF ]					ifFalse: [self newBodyWriteStreamOn: aStream for: aMessage ]].	self useGZipTransfer ifTrue: [streamx := OS.ZLib.GZipWriteStream bestCompressionOn: streamx].	streamx := EncodedStream on: streamx encodedBy: (StreamEncoder new: self defaultEncoding).	streamx lineEndCRLF.	aMessage isBinaryContentType ifTrue: [ streamx binary ].	^streamx</body></methods><methods><class-id>Net.HttpWriteHandler</class-id> <category>accessing</category><body package="HTTP">addUserAgentField	^self options addUserAgentField</body><body package="HTTP">addUserAgentField: aBoolean	^self options addUserAgentField: aBoolean</body><body package="HTTP">bodySize	^bodySize</body><body package="HTTP">bodySize: anObject	bodySize := anObject</body><body package="HTTP">chunkSize	^self options chunkSize</body><body package="HTTP">chunkSize: aNumber	self options chunkSize: aNumber.</body><body package="HTTP">doChunk	self options doChunk</body><body package="HTTP">doNotChunk	self options doNotChunk</body><body package="HTTP">shouldChunk	^self options shouldChunk</body><body package="HTTP">shouldChunk: aBoolean	self options shouldChunk: aBoolean</body><body package="HTTP">useGZipTransfer	^self options useGZipTransfer</body><body package="HTTP">useGZipTransfer: aBoolean	self options useGZipTransfer: aBoolean</body><body package="HTTP">userAgentFieldValue	^self options userAgentFieldValue</body><body package="HTTP">userAgentFieldValue: aString	^self options userAgentFieldValue: aString</body></methods><methods><class-id>Net.HttpWriteHandler class</class-id> <category>default values</category><body package="HTTP">shouldChunkValue	^true</body><body package="HTTP">useGZipTransferValue	^false</body></methods><methods><class-id>Net.HttpWriteHandler class</class-id> <category>defaults</category><body package="HTTP">defaultChunkSize	^ChunkedWriteStream defaultWriteLimit</body><body package="HTTP">defaultOptionsType	^HttpWritingOptions</body><body package="HTTP">shouldChunk	^self defaultOptionsType shouldChunk</body><body package="HTTP">shouldChunk: aBoolean	self defaultOptionsType shouldChunk: aBoolean</body><body package="HTTP">useGZipTransfer	^self defaultOptionsType useGZipTransfer</body><body package="HTTP">useGZipTransfer: aBoolean	^self defaultOptionsType useGZipTransfer: aBoolean</body></methods><methods><class-id>Core.String</class-id> <category>private-auth</category><body package="HTTP">md5Hash	"answer a hexadecimal encoded hash"	| stream |	stream := WriteStream on: String new.	self asByteArray md5Value printOn: stream base: 16.	^stream contents</body></methods><methods><class-id>Net.MimeOutputHandler</class-id> <category>action callbacks</category><body package="HTTP">startRequestLine: aRequestLine with: aHttpEntity 	aHttpEntity isExtended 		ifTrue: [aRequestLine prefix: 'm-']		ifFalse: [aRequestLine prefix: nil].	self printLine: aRequestLine printString.	aHttpEntity hasHostField 		ifFalse: [aHttpEntity host: aRequestLine hostAndPort]</body><body package="HTTP">startResponseStatusLine: aResponseStatusLine with: aHttpEntity	self printLine: aResponseStatusLine printString.</body></methods><methods><class-id>OS.ZLib.DeflateStream</class-id> <category>status</category><body package="HTTP">finish	"Write any unwritten information."	self finishBuffer.	self finishOutput.	destinationStream finish</body></methods><methods><class-id>Net.Settings class</class-id> <category>deprecation</category><body package="HTTP">httpSetting	^#'Net.HttpSettings' asStrictReference valueOrDo: [nil ].</body></methods><methods><class-id>Core.TwoByteString</class-id> <category>private-auth</category><body package="HTTP">md5Hash	^self</body></methods><methods><class-id>Net.HostSpec class</class-id> <category>instance creation</category><body package="HTTP">http: host user: user	^self protocol: #HTTP host:  host user: user</body><body package="HTTP">http: host username: username password: password	^self protocol: #HTTP host: host username: username password: password</body></methods><initialize><class-id>Net.HttpProtocolInterpreter</class-id></initialize><initialize><class-id>Net.HttpClient</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>NetUser</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>username password fullName account mailAddress </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><class><name>CollectionField</name><environment>Net</environment><super>Net.StructuredHeaderField</super><private>false</private><indexed-type>none</indexed-type><inst-vars>separator </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><class><name>MimeDispatcher</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>handler </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><class><name>MessageStream</name><environment>Net</environment><super>Core.Stream</super><private>true</private><indexed-type>none</indexed-type><inst-vars>stream position readLimit </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HTTP</category><attributes><package>MIME</package></attributes></class><class><name>SocketAccessor</name><environment>OS</environment><super>OS.BlockableIOAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>networkFamily </inst-vars><class-inst-vars>concreteClass </class-inst-vars><imports></imports><category>OS-Sockets</category><attributes><package>OS-Sockets</package></attributes></class><class><name>MimeEntity</name><environment>Net</environment><super>Net.MessageElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>header headerCharset readingOptions writingOptions </inst-vars><class-inst-vars>defaultTextCharset defaultTextType </class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><class><name>Notification</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>NetNotification</name><environment>Net</environment><super>Core.Notification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><class><name>MimeParser</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>handler </inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.IOConstants.*			</imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><class><name>ValueWithParametersField</name><environment>Net</environment><super>Net.StructuredHeaderField</super><private>false</private><indexed-type>none</indexed-type><inst-vars>separators </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><class><name>HeaderFieldValue</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>separators value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><class><name>ValueWithParams</name><environment>Net</environment><super>Net.HeaderFieldValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars>params </inst-vars><class-inst-vars>defaultParameterValueEncoding </class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>TwoByteString</name><environment>Core</environment><super>Core.String</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-String Support</category><attributes><package>Collections-String Support</package></attributes></class><class><name>URLwithAuthority</name><environment>OS</environment><super>OS.URLwithPath</super><private>false</private><indexed-type>none</indexed-type><inst-vars>host port </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Resources</category><attributes><package>URISupport</package></attributes></class><class><name>NetClient</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>user hostName portNumber clientPI state </inst-vars><class-inst-vars>defaultProtocolInterpreterClass </class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><class><name>NetPISettings</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tlsContext tlsSubjectVerifier retries timeout delaySeconds </inst-vars><class-inst-vars>defaultDelaySeconds defaultRetries defaultTimeout </class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><class><name>MimeReadingOptions</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fieldFactory messageHeaderClass scannerType saveAttachmentsAsFiles headerOnly acceptNonAsciiCharacters attachmentDirectory builderClass removeContentTransferEncoding </inst-vars><class-inst-vars>saveAttachmentsAsFiles defaultAttachmentDirectory removeContentTransferEncoding </class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><class><name>NetError</name><environment>Net</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><class><name>MimeOutputHandler</name><environment>Net</environment><super>Net.MimeDispatcherHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>streams fieldStream </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><class><name>MimeWriteHandler</name><environment>Net</environment><super>Net.MimeOutputHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>originalStream binaryMode </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><class><name>MimeWritingOptions</name><environment>Net</environment><super>Net.MimeDispatcherWritingOptions</super><private>false</private><indexed-type>none</indexed-type><inst-vars>preferFieldSource applyTransferEncoding </inst-vars><class-inst-vars>applyTransferEncoding </class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><class><name>DeflateStream</name><environment>OS.ZLib</environment><super>Core.WriteStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>outputBuffer interface destinationStream compressionLevel </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Compression-ZLib</category><attributes><package>Compression-ZLib</package></attributes></class><class><name>MimePrintHandler</name><environment>Net</environment><super>Net.MimeOutputHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>indentation indentLines </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><class><name>NetConnection</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream settings </inst-vars><class-inst-vars>encoding </class-inst-vars><imports>			private OS.IOConstants.*			</imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><class><name>NetProtocolInterpreter</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>connection settings </inst-vars><class-inst-vars>defaultNetConnection </class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><class><name>MimeParserHandler</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream lineEndConvention initialEntity parser binaryMode options </inst-vars><class-inst-vars>saveAttachmentsAsFiles defaultAttachmentDirectory </class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class></st-source>