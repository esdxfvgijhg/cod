<?xml version="1.0"?><st-source><!-- Name: IMAPNotice: Copyright 1999-2016 Cincom Systems, Inc.  All rights reserved.Comment: IMAPSupport provides support for communicating with the IMAPv4 protocol retreive internet mail messages.Portions © 2001, Les Tyrrell.The IMAP client included with this release is based on code contributedby Les Tyrell.  Cincom has built on top of this contribution, and wouldlike to acknowledge Les as the original authorDbIdentifier: bear73DbTrace: 493277DbUsername: tkoganDbVersion: 8.3 - 0DevelopmentPrerequisites: #(#(#any 'Mail' '') #(#any 'MIME' '') #(#package 'NetClientBase' '') #(#package 'Protocols-Common' ''))PackageName: IMAPParcel: #('IMAP')ParcelName: IMAPPrerequisiteParcels: #(#('Mail' '') #('MIME' '') #('NetClientBase' '') #('Protocols-Common' ''))PrintStringCache: (8.3 - 0,tkogan)Version: 8.3 - 0Post-Load Block: 	[ :pkg |  ]Date: 2:30:30 PM April 28, 2017 --><time-stamp>From VisualWorks®, Pre-Release 8.3 (apr17.3) of April 28, 2017 on April 28, 2017 at 2:30:30 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>IMAPResponse</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cmdName value source parameters </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-IMAP-Support</category><attributes><package>IMAP</package></attributes></class><comment><class-id>Net.IMAPResponse</class-id><body>IMAPResponse is implemented to read and parse responses directly from the IMAP server socket stream.Instance Variables:	cmdName	&lt;String&gt;	The name of a command 	value	&lt;Collection&gt;	The response value	source	&lt;Stream&gt;	Row server response	parameters	&lt;Collection&gt;	 The parameters hold the fetch command message data and represented as a collection. For example: for the fetch command 1 FETCH (BODY[HEADER]) the response parameters are: #(  'BODY[HEADER]'  'Date: Wed, 17 Jul 1996 02:23:25 -0700 (PDT)...')In order to adequately parse a response, response parser has to read up to three tokens. If the first response is a tag, the response is tagged status response and can be parsed immediately. In this case tag becomes response's command name and the rest of response is parsed and placed in response value. Otherwise, second token is read. If this token starts with a letter, this second token becomes response's command name, the remainder or response is deep tokenized and put in value. So for the following response IMAPResponse readFrom: '* FLAGS (\Seen \Answered \Deleted)' readStream cmdName = 'FLAGS' and value = #('\Seen' '\Answered' '\Deleted') If the second token starts with a digit, the third token is read. This third token becomes response command name and the second token becomes reponse value. So for the following response: IMAPResponse readFrom: '* 3 EXPUNGE' readStream cmdName = 'EXPUNGE' and value = 3 Status responses as well as tagged responses may have bracketed status as in '* OK [UIDVALIDITY 11349] UIDVALIDITY value' (pain to handle because brackets syntactically are atom-chars). This bracketed expression is parsed into value. 'OK' is stored into status field. Every parsed response contains 'command name' and response value. Command name is used to match a response to potentially multiple active commands. Command name is also useful for user agent when user agent needs information in specific response or set of responses. A standard situation is when user agent needs values of all responses whose command name is the same as the name of their command. </body></comment><class><name>IMAPResponseStatus</name><environment>Net</environment><super>Net.IMAPResponse</super><private>false</private><indexed-type>none</indexed-type><inst-vars>text status </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-IMAP-Support</category><attributes><package>IMAP</package></attributes></class><comment><class-id>Net.IMAPResponseStatus</class-id><body>IMAPResponseStatus parses IMAP response statusInstance Variables:	status	&lt;String&gt;	the first token from the response	text	&lt;String&gt;	the response text</body></comment><class><name>IMAPClientHandler</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>existingMessages recentMessages expungedMessage mailboxFlags </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-IMAP-Support</category><attributes><package>IMAP</package></attributes></class><comment><class-id>Net.IMAPClientHandler</class-id><body>IMAPClientHandles is implemented to handle unsolicited server responses. Certain server data must be recorded by the client when it is received. Such data conveys critical information which affects the interpretetion of all subsequent commands and responses.Instance Variables:	existingMessages	&lt;Number&gt;	The value of the EXISTS command	recentMessages	&lt;Number&gt;	The value of the RECENT command	expungedMessage	&lt;Number&gt;	The value of the EXPUNGE command	mailboxFlags	&lt;Collection&gt;	The value of the FLAGS command  as: #('\Seen' '\Answered' '\Deleted' )</body></comment><class><name>IMAPState</name><environment>Net</environment><super>Net.NetClientState</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-IMAP-Support</category><attributes><package>IMAP</package></attributes></class><comment><class-id>Net.IMAPState</class-id><body>IMAPState is implemented to support IMAP4rev1 server states. An IMAP4rev1 server is in one of four states. Most commands are valid in only certain states. It is a protocol error for the client to attempt a command while the command is in an inappropriate state. The  NetClientStateError is raised in this case.</body></comment><class><name>IMAPLogoutState</name><environment>Net</environment><super>Net.IMAPState</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-IMAP-Support</category><attributes><package>IMAP</package></attributes></class><comment><class-id>Net.IMAPLogoutState</class-id><body>In logout state, the connection is being terminated, and the server  will close the connection.  This state can be entered as a result of a client request or by unilateral server decision.</body></comment><class><name>IMAPArgumentError</name><environment>Net</environment><super>Net.NetError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-IMAP-Support</category><attributes><package>IMAP</package></attributes></class><comment><class-id>Net.IMAPArgumentError</class-id><body>This error is raised when server refuses provided command arguments, presumably because they are invalid in some way.</body></comment><class><name>IMAPMailbox</name><environment>Net</environment><super>Net.Mailbox</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-IMAP-Mailbox</category><attributes><package>IMAP</package></attributes></class><comment><class-id>Net.IMAPMailbox</class-id><body>IMAPMailbox provides IMAP mail box supportInstance Variables:	name	&lt;String&gt;	mail box name. The default name is "inbox"</body></comment><class><name>IMAPAuthenticatedState</name><environment>Net</environment><super>Net.IMAPState</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-IMAP-Support</category><attributes><package>IMAP</package></attributes></class><comment><class-id>Net.IMAPAuthenticatedState</class-id><body>IMAPAuthenticatedState is implemented to support IMAP4rev1 server authenticated state. In this state the client is authenticated and must select a mailbox to access before commands that affect messages will be permitted.</body></comment><class><name>IMAPSelectedState</name><environment>Net</environment><super>Net.IMAPAuthenticatedState</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-IMAP-Support</category><attributes><package>IMAP</package></attributes></class><comment><class-id>Net.IMAPSelectedState</class-id><body>IMAPSelectedState  is implemented to support IMAP4rev1 server selected state. In this state a mailbox has been selected to access.</body></comment><class><name>IMAPResponseTagged</name><environment>Net</environment><super>Net.IMAPResponseStatus</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-IMAP-Support</category><attributes><package>IMAP</package></attributes></class><comment><class-id>Net.IMAPResponseTagged</class-id><body>IMAPResponseTagged parses tagged response</body></comment><class><name>IMAPCommand</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>client sequenceID name arguments status responses completionResponse promise </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-IMAP-Support</category><attributes><package>IMAP</package></attributes></class><comment><class-id>Net.IMAPCommand</class-id><body>IMAPCommand is implemented to create IMAP4rev1 command, execute it and extract the response data.Instance Variables:	client	&lt;IMAPProtocolInterpreter&gt;	The client manages IMAP server connection and and provides interface for sending IMAP commands and handling IMAP responses. 	sequenceID	&lt;IMAPCommandSequencer&gt;	Creates next command identifier (tag)	name	&lt;String&gt;	the command name	arguments	&lt;Array&gt;	 An array of arguments	status	&lt;Symbol&gt;	The command status as: #sent #done	responses	&lt;Collection&gt;	The IMAPResponses collection	completionResponse	&lt;IMAPResponseTagged&gt;	An instance of the IMAPResponseTagged like: "xxx OK FETCH completed"	promise	&lt;TimedPromise&gt;	An instance of TimedPromiseIMAPCommand support Promise pattern. Each command represents a promise to deliver responses in the future. Once command is queued for IMAP protocol, interpreter, control is returned to the calling code immediately. In order to wait till command execution is complete, send command message #wait. This gives application an easy and flexible means to control the level of concurrency with IMAP server. Most of IMAP API methods execute synchronously -- that is, they create new command, queue it, wait for command's completion and answer the command. Aplication that needs asynchronous execution should create a new command and queue it via IMAPClient&gt;&gt;executeCommand:. IMAPCommand and its responses</body></comment><class><name>IMAPStateError</name><environment>Net</environment><super>Net.NetClientError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-IMAP-Support</category><attributes><package>IMAP</package></attributes></class><comment><class-id>Net.IMAPStateError</class-id><body>NetClientStateError is raised if the client attempts to send a command in inappropriate state</body></comment><class><name>IMAPConnection</name><environment>Net</environment><super>Net.NetConnection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.IOConstants.*			</imports><category>Net-SMTP-Support</category><attributes><package>IMAP</package></attributes></class><comment><class-id>Net.IMAPConnection</class-id><body>IMAPConnection is the IMAP connection stream wrapper</body></comment><class><name>IMAPClient</name><environment>Net</environment><super>Net.NetClient</super><private>false</private><indexed-type>none</indexed-type><inst-vars>handler </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-IMAP-Support</category><attributes><package>IMAP</package></attributes></class><comment><class-id>Net.IMAPClient</class-id><body>IMAPClient implements user agent interface to IMAP services. These all are in category. All methods in this category support synchromous execution of a specific IMAP request. They creates an instance of command, queues it for IMAP protocol interpreter and waits for command's completion. All methods answer IMAPCommand. Utility category provides higher level requests that extract data from a response, i.e. after fetch request. IMAP Client uses state objects to validate if a request is valid in a given state and to handle state transitions. IMAPClient is also responsible for a number of policies such as automatic reconnect, idle timeout, etc. The client #close and #logout methods are different from other clients:#logout - the connection is being terminated, and the server will close the connection#close - command permanently removes from the currently selected mailbox all messages that have the \Deleted flag set, and returns to authenticated state from selected stateInstance Variables:	handler	&lt;IMAPClientHandler&gt;	An instance of IMAPClientHolder handles unsolicited server messages</body></comment><class><name>IMAPNonAuthenticatedState</name><environment>Net</environment><super>Net.IMAPState</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-IMAP-Support</category><attributes><package>IMAP</package></attributes></class><comment><class-id>Net.IMAPNonAuthenticatedState</class-id><body>IMAPNonAuthenticatedState is implemented to support IMAP4rev1 server  non-authenticated state. In this state the client must supply authentication credentials before most commands will be permitted. This state in entered when a connection starts.</body></comment><class><name>IMAPCommandSequencer</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>prefix value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-IMAP-Support</category><attributes><package>IMAP</package></attributes></class><comment><class-id>Net.IMAPCommandSequencer</class-id><body>IMAPCommandSequencer generates unique identifier (tag) for IMAP4rev1 command. Instance Variables:		prefix &lt;String&gt; 		value &lt;Number&gt; </body></comment><class><name>IMAPSettings</name><environment>Net</environment><super>Net.NetPISettings</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-IMAP-Support</category><attributes><package>IMAP</package></attributes></class><comment><class-id>Net.IMAPSettings</class-id><body>IMAPSettings  represents IMAP options</body></comment><class><name>IMAPScanner</name><environment>Net</environment><super>Net.MessageScanner</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-IMAP-Support</category><attributes><package>IMAP</package></attributes></class><comment><class-id>Net.IMAPScanner</class-id><body>IMAPScanner parses IMAP messages</body></comment><class><name>IMAPStreamEncoder</name><environment>Net</environment><super>Net.UTF7StreamEncoder</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-IMAP-Support</category><attributes><package>IMAP</package></attributes></class><comment><class-id>Net.IMAPStreamEncoder</class-id><body>IMAPStreamEncoder is used to encode/decode IMAP messages</body></comment><class><name>IMAPErrorResponse</name><environment>Net</environment><super>Net.IMAPResponse</super><private>false</private><indexed-type>none</indexed-type><inst-vars>exception </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-IMAP-Support</category><attributes><package>IMAP</package></attributes></class><comment><class-id>Net.IMAPErrorResponse</class-id><body>IMAPCommand  is terminated with the IMAPErrorResponse when the exception was raised because the client was disconnected or specified timeout was expired. Instance Variables:	exception	&lt;Exception&gt;	Holds the exception</body></comment><class><name>IMAPProtocolInterpreter</name><environment>Net</environment><super>Net.NetProtocolInterpreter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>commandSequencer readResponseSignal commandsInProgress connectionMutex client </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-IMAP-Support</category><attributes><package>IMAP</package></attributes></class><comment><class-id>Net.IMAPProtocolInterpreter</class-id><body>IMAP Protocol Interpreter manages IMAP server connection and provides interface for sending IMAP commands and handling IMAP responses. Instance Variables:	client	&lt;IMAPClient&gt;	Instance of IMAPClient to handle unsolicited responses	socket	&lt;Socket&gt;	Socket for inter-process communication	connectionStream	&lt;Stream&gt;	Is used to read from and write to the external connection stream.	responseStream	&lt;Stream&gt;	Is used for testing purpose to execute script respresenting complete execution of one or more commands.	commandSequencer	&lt;IMAPCommandSequencer&gt;	Creates for each command identifier called a "tag" 	readResponseMutex	&lt;Semaphore&gt;	Protects access to commandsInProgress	readResponseSignal	&lt;Semaphore&gt;	Is signalled when commandsInProgress is non-empty	commandsInProgress	&lt;List&gt;	List of outstanding commands that has been sent to IMAP server and has not completed yet	connectionMutex	&lt;Semaphore&gt;	Protects access to the connectionStream IMAP Protocol Interpreter owns and controls access to IMAP server socket connection. The only interface between IMAPClient and PI is through 	executeCommand: 	connect 	disconnect  IMAP implements sharing mechanisms as follows: PI's Shared Resources:IMAP Connection (connectionMutex, connectionStream responseStream) - IMAP connection is shared between command sender and response reader loop. A process must own the connection before it accesses the connection. Response List (readResponseSignal commandsInProgress) -- this is a LIFO list of commands waiting for their response. Command Processing Once a command is sent, it is added to the response list and readResponseSignal is signalled. It then adds the command to the list of commands waiting for reply. This list is LIFO list, so the last command will be the first to handle server responses. It is managed by IMAP response reader loop. IMAP Response reader loop is a separate thread that is blocked on the semaphore asociated with the response list. This semaphore's excess signals count is equal to the number of commands in response list. Therefore, when there are outstanding commands waiting for a response, this loop will be constantly reading next response from the server and dispatching it. Responses are read from the server and parsed, so that an appropriate instance is created for the next response. The response is checked with the IMAPClient if this response is one of untagged responses that have to be recorded by the client.The response is then offered to every outstanding command beginning with the most recent. In this sense the most recent command provides 'context' for processing responses, especially for untagged responses containing mailbox and message data. This process continues until a command consumes this response by answering true. Each command, when given a request, tried to process it. If it recognizes the response as its, it typically adds the response to the list of responses associated with this request and answers that it consumed the response. If the response is a completion (tagged) response for this command, the execution of this command is complete. At this point the command is removed from the list of outstanding commands, command's semaphore is signalled and the excess signal counter for the list's semaphore is decremented by one. If the list is empty, the list semaphore's excess counter will be zero and response reader loop will be blocked on the semaphore. Even though this response can be processed by a command in outstanding command list, this command will not indicate it has consumed this response, so it will eventually get to the protocol interpreter. When processing a response, response reader loop should do the following: 	Lock IMAP connection	Read next response	Process the response	If some command is now complete		Remove it from response list		Decrement response loop semaphore Unlock IMAP connection</body></comment><class><name>IMAPAppendError</name><environment>Net</environment><super>Net.IMAPArgumentError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-IMAP-Support</category><attributes><package>IMAP</package></attributes></class><comment><class-id>Net.IMAPAppendError</class-id><body>This error will be raised if the server sends a NO reply which means the server cannot append to that mailbox, or there is an error in the flags, date/time or message text.</body></comment><shared-variable><name>DelaySeconds</name><environment>Net.IMAPProtocolInterpreter</environment><private>false</private><constant>false</constant><category>unclassified</category><attributes><package>IMAP</package></attributes></shared-variable><shared-variable><name>ProtocolErrorSignal</name><environment>Net.IMAPProtocolInterpreter</environment><private>false</private><constant>false</constant><category>signals</category><attributes><package>IMAP</package></attributes></shared-variable><shared-variable><name>ConnectionFailedSignal</name><environment>Net.IMAPProtocolInterpreter</environment><private>false</private><constant>false</constant><category>signals</category><attributes><package>IMAP</package></attributes></shared-variable><shared-variable><name>ConnectionClosedSignal</name><environment>Net.IMAPProtocolInterpreter</environment><private>false</private><constant>false</constant><category>signals</category><attributes><package>IMAP</package></attributes></shared-variable><shared-variable><name>MaxRetries</name><environment>Net.IMAPProtocolInterpreter</environment><private>false</private><constant>false</constant><category>unclassified</category><attributes><package>IMAP</package></attributes></shared-variable><shared-variable><name>NetworkErrorSignal</name><environment>Net.IMAPProtocolInterpreter</environment><private>false</private><constant>false</constant><category>signals</category><attributes><package>IMAP</package></attributes></shared-variable><shared-variable><name>LoginIncorrectSignal</name><environment>Net.IMAPProtocolInterpreter</environment><private>false</private><constant>false</constant><category>signals</category><attributes><package>IMAP</package></attributes></shared-variable><shared-variable><name>ResponseRegistry</name><environment>Net.IMAPCommand</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><initializer>IdentityDictionary new</initializer><attributes><package>IMAP</package></attributes></shared-variable><shared-variable><name>TextMask</name><environment>Net.IMAPScanner</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><initializer>8192</initializer><attributes><package>IMAP</package></attributes></shared-variable><shared-variable><name>QuotedTextMask</name><environment>Net.IMAPScanner</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><initializer>4096</initializer><attributes><package>IMAP</package></attributes></shared-variable><shared-variable><name>QuotedPairChar</name><environment>Net.IMAPScanner</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><initializer>$\</initializer><attributes><package>IMAP</package></attributes></shared-variable><shared-variable><name>AtomMask</name><environment>Net.IMAPScanner</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><initializer>256</initializer><attributes><package>IMAP</package></attributes></shared-variable><methods><class-id>Net.IMAPResponse</class-id> <category>accessing</category><body package="IMAP">cmdName	^cmdName</body><body package="IMAP">cmdName: aString	cmdName := aString</body><body package="IMAP">parameters	^parameters</body><body package="IMAP">parameters: aCollection	parameters := aCollection.	value isNil ifTrue: [ value := parameters ].</body><body package="IMAP">source	^source</body><body package="IMAP">source: aString	source := aString</body><body package="IMAP">tag	^nil</body><body package="IMAP">value	^value</body><body package="IMAP">value: aValue	value := aValue</body></methods><methods><class-id>Net.IMAPResponse</class-id> <category>testing</category><body package="IMAP">hasTag: aString	^false</body><body package="IMAP">terminatesCommand: aCommand	^false</body></methods><methods><class-id>Net.IMAPResponse</class-id> <category>parsing, general</category><body package="IMAP">parse: scanner	" Nothing more to do here "	self parameters: scanner deepTokenize</body><body package="IMAP">parse: scanner with: cmdNameString 	self cmdName: cmdNameString.	self parse: scanner</body><body package="IMAP">parse: scanner with: cmdNameString with: codeValue 	self cmdName: cmdNameString.	self value: codeValue.	self parse: scanner</body></methods><methods><class-id>Net.IMAPResponse</class-id> <category>printing</category><body package="IMAP">printLog	^ self source</body><body package="IMAP">printOn: stream	source notNil ifTrue: [ stream nextPutAll: source ]</body></methods><methods><class-id>Net.IMAPResponse class</class-id> <category>parsing, general</category><body package="IMAP">canParse: cmdName 	^false</body><body package="IMAP">defaultResponseClass	^IMAPResponse</body><body package="IMAP">parse: scanner	| token resp |	scanner sourceTrailOn.	token := scanner nextToken.	resp := ($* = token or: [ '+' = token])		ifTrue: [ self parseUntagged: scanner with: token ]		ifFalse: [ self parseTagged: scanner with: token ].	scanner upTo: Character cr.	resp source: scanner sourceTrail.	^resp</body><body package="IMAP">parse: scanner with: cmdName	^self new			parse: scanner with: cmdName</body><body package="IMAP">parse: scanner with: cmdName with: code 	^self new		parse: scanner		with: cmdName		with: code</body><body package="IMAP">parseContinuationResponse: scanner"Command continuation request responses use the token '+' instead of a tag.  These responses are sent by the server to indicate acceptance of an incomplete client command and readiness for the remainder of the command"		^self new		parse: scanner;		yourself</body><body package="IMAP">parseTagged: scanner with: tag	|   status |		status := scanner nextToken.	^(self parserTypeForTaggedStatus: status) parse: scanner tag: tag status: status.</body><body package="IMAP">parseUntagged: scanner with: starOrPlus 	| token token2 |	starOrPlus = '+' ifTrue: [^self parseContinuationResponse: scanner].	token := scanner nextToken.	^token first isAlphabetic		ifTrue: [(self parserForUntaggedCommand: token)						parse: scanner with: token]		ifFalse: 			[token2 := scanner nextToken.			(self parserForUntaggedCommand: token2)						parse: scanner with: token2 with: token]</body><body package="IMAP">parserForUntaggedCommand: cmdName	^IMAPResponse allSubclasses 				detect: [:each | each canParse: cmdName ]				ifNone: [self defaultResponseClass].</body><body package="IMAP">parserTypeForTaggedStatus: status	^IMAPResponseTagged</body><body package="IMAP">readFrom: stream	^self parse: (self scannerOn: stream)</body><body package="IMAP">scannerOn: stream	^IMAPScanner on: stream</body></methods><methods><class-id>Net.IMAPResponseStatus</class-id> <category>testing</category><body package="IMAP">isBad	^ self status = 'BAD'</body><body package="IMAP">isOK	^ self status = 'OK'</body></methods><methods><class-id>Net.IMAPResponseStatus</class-id> <category>parsing, general</category><body package="IMAP">parse: scanner 	| val key bracketedValue scodeScanner |	scanner skipWhiteSpace.	(scanner peek == $[)		ifTrue: 			[value := OrderedCollection new.			bracketedValue := scanner nextToken.			scodeScanner := IMAPScanner on: ((IMAPScanner tokenizeBracketedGroup: bracketedValue) at: 2) readStream.			key := scodeScanner nextToken asUppercase.						(#('UIDVALIDITY' 'UNSEEN' ) includes: key) ifTrue: [ val := scodeScanner nextToken asNumber ].			'PERMANENTFLAGS' = key ifTrue: [ val := scodeScanner deepNextToken ].			'NEWNAME' = key ifTrue: [ |old new|				old := scodeScanner nextToken.				new := scodeScanner nextToken.				val := Array with: old with: new ].		].	self text: scanner scanText.	(#('ALERT' 'PARSE' 'TRYCREATE' 'READ-ONLY' 'READ-WRITE' ) includes: key) ifTrue: [ val := self text ].	self value: key-&gt;val.</body><body package="IMAP">parse: scanner with: token	self cmdName:  token.	self status: token.	self parse: scanner.</body></methods><methods><class-id>Net.IMAPResponseStatus</class-id> <category>accessing</category><body package="IMAP">status	^status</body><body package="IMAP">status: aString	status := aString</body><body package="IMAP">text	^text</body><body package="IMAP">text: aString	text := aString</body></methods><methods><class-id>Net.IMAPResponseStatus class</class-id> <category>testing</category><body package="IMAP">canParse: cmdName	^#('OK' 'NO' 'BAD' 'BYE') includes: cmdName</body></methods><methods><class-id>Net.IMAPClientHandler</class-id> <category>accessing</category><body package="IMAP">existingMessages	^existingMessages</body><body package="IMAP">existingMessages: aNumber	existingMessages := aNumber</body><body package="IMAP">expungedMessage	^expungedMessage</body><body package="IMAP">expungedMessage: aNumber	expungedMessage := aNumber</body><body package="IMAP">mailboxFlags	^mailboxFlags</body><body package="IMAP">mailboxFlags: aCollection	mailboxFlags := aCollection</body><body package="IMAP">recentMessages	^recentMessages</body><body package="IMAP">recentMessages: aNumber	recentMessages := aNumber</body></methods><methods><class-id>Net.IMAPClientHandler</class-id> <category>private</category><body package="IMAP">exists: aString	self existingMessages: aString asNumber</body><body package="IMAP">expunge: aString	self expungedMessage: aString asNumber</body><body package="IMAP">flags: aCollection	self mailboxFlags: aCollection</body><body package="IMAP">recent: aString	self recentMessages: aString asNumber</body></methods><methods><class-id>Net.IMAPClientHandler</class-id> <category>handle responses</category><body package="IMAP">handle: aResponse "	(#('EXISTS' 'RECENT' 'FLAGS' 'EXPUNGE') includes: aResponse cmdName)	"	^[self perform: (aResponse cmdName asLowercase , ':') asSymbol with: aResponse value. true] 	on: self messageNotUnderstoodSignal 	do: [:ex | ex return: false]</body><body package="IMAP">handle: aResponse for: imapClient 	self handle: aResponse</body></methods><methods><class-id>Net.IMAPState</class-id> <category>commands</category><body package="IMAP">append: message to: aMailboxName flags: flags date: dateString 	self signalError</body><body package="IMAP">authenticate: args	self signalError</body><body package="IMAP">check	self signalError</body><body package="IMAP">close	self signalError</body><body package="IMAP">copy: messageNumbers to: aName 	self signalError</body><body package="IMAP">create: aList	self signalError</body><body package="IMAP">delete: aList	self signalError</body><body package="IMAP">examine: aList	self signalError</body><body package="IMAP">expunge: aClient	self signalError</body><body package="IMAP">fetch: aList	self signalError</body><body package="IMAP">fetch: messageNumbers retrieve: criteria 	self signalError</body><body package="IMAP">list: refName mailbox: name	self signalError</body><body package="IMAP">login	self signalError</body><body package="IMAP">lsub: refName mailbox: name	self signalError</body><body package="IMAP">rename: oldMailBox newName: newMailBox 	self signalError</body><body package="IMAP">rlist: refName mailbox: name	self signalError</body><body package="IMAP">rlsub: refName mailbox: name	self signalError</body><body package="IMAP">search: aLIst	self signalError</body><body package="IMAP">select: aList	self signalError</body><body package="IMAP">status	self signalError</body><body package="IMAP">store: aList	self signalError</body><body package="IMAP">subscribe: aList	self signalError</body><body package="IMAP">uid: aList	self signalError</body><body package="IMAP">unsubscribe: aList	self signalError</body></methods><methods><class-id>Net.IMAPState</class-id> <category>any state valid commands</category><body package="IMAP">capability	^client executeAndWait: 'capability'</body><body package="IMAP">logout	| command |	(command := client executeAndWait: 'logout' ) successful		ifTrue: [  client state: IMAPLogoutState new].	^command</body><body package="IMAP">noop 	^client executeAndWait: 'noop'</body></methods><methods><class-id>Net.IMAPState</class-id> <category>accessing</category><body package="IMAP">stateErrorClass	^IMAPStateError</body></methods><methods><class-id>Net.IMAPState class</class-id> <category>instance creation</category><body package="IMAP">forClient: client	^self new client: client</body></methods><methods><class-id>Net.IMAPLogoutState</class-id> <category>commands</category><body package="IMAP">logout</body></methods><methods><class-id>Net.IMAPMailbox</class-id> <category>private</category><body package="IMAP">clientSpecies	^IMAPClient</body><body package="IMAP">createConnection	super createConnection.	^(connection select: self name) successful		ifTrue: [connection]		ifFalse: 				[self logout.			NetClientError 				signalWith: #select 				message: ((#UnableToSelectMailbox &lt;&lt; #net &gt;&gt; 'Unable to select the mailbox:  &lt;1s&gt;')			expandMacrosWith: self name).].</body><body package="IMAP">deliverMessages: numbers	"Queue up all new messages onto the queue. Clients of this 	method should be aware that the state should be such that there 	is new mail to download."	| messages bundlingFactor n stream msec subSet |	numbers isEmpty ifTrue: [^self].	bundlingFactor := 5.	n := 0.	self		safelyExecute: 			[self log: [(#DownloadingMessages &lt;&lt; #net &gt;&gt; 'Downloading &lt;1p&gt; messages from &lt;2s&gt;') expandMacrosWith: numbers size with: server]				level: #IMAPMailboxDownload.			stream := numbers readStream.			[stream atEnd]				whileFalse: 					[subSet := stream nextAvailable: bundlingFactor.					msec := Time millisecondsToRun: 								[messages := self getMessagesByNumbers: subSet ].					self logMessages: messages position: n from: numbers size time: msec. 					messages do: [ :ms | self deliver: ms].					n := n + messages size]].	self lastMessage: (self lastMessage + n).	self log: [(#DoneDownloaded &lt;&lt; #net &gt;&gt; 'Done; downloaded &lt;1p&gt; messages from &lt;2s&gt;') expandMacrosWith: n with: server]		level: #IMAPMailboxDownload</body><body package="IMAP">getMessageUID: arrayOfMessageNumbers" Read specified messages from IMAP server. Returns an arrray strings representing message uids "	^self safelyExecute: [ connection uidFor: arrayOfMessageNumbers ].</body><body package="IMAP">getMessagesByNumbers: arrayOfMessageNumbers" Read specified messages from IMAP server. arrayOfMessageNumbers isan array of integers or strings representing message numbers "	| fetchedMessages messages uids n each |	fetchedMessages := self safelyExecute: [ connection fetchRFC822Messages: arrayOfMessageNumbers ].	uids := self getMessageUID: arrayOfMessageNumbers.	messages := OrderedCollection new: fetchedMessages size.	n := self lastMessage.  	fetchedMessages isEmpty not		ifTrue: 			[ 1 to: fetchedMessages size 				do: [ :index | 					each := fetchedMessages at: index.					n := n + 1.					messages add: 						(LetterInTransit new									letterText: each value first;									uid: (uids at: index);									server: self serverName;									serverType: self serverType;									deliveryAction: [self saveSettings: n])]].	^messages</body><body package="IMAP">getMessagesFor: criteria 	"Read messages matching specified criteria from the mailbox"	| numbers |	numbers := self messageNumbersFor: criteria.	^self getMessagesByNumbers: numbers</body><body package="IMAP">handleResult: result	result successful ifFalse: [ self error: (#toDoImplementExceptions &lt;&lt; #net &gt;&gt; 'to do: implement exceptions') ].	^result.</body><body package="IMAP">notifyServerMessageRead: uid	| res |	res := self safelyExecute: [connection searchMessagesForUids: (Array with: uid) ]. 	^self safelyExecute: [ connection markAsSeen: res ].</body></methods><methods><class-id>Net.IMAPMailbox</class-id> <category>accessing</category><body package="IMAP">logout	connection notNil		ifTrue: 			[connection logout.			connection := nil]</body><body package="IMAP">name	^name isNil		ifTrue: [name := (#inbox &lt;&lt; #net &gt;&gt; 'inbox') asString]		ifFalse: [name]</body><body package="IMAP">name: aValue	name := aValue</body><body package="IMAP">serverType	^'IMAP4'</body></methods><methods><class-id>Net.IMAPMailbox</class-id> <category>commands</category><body package="IMAP">allHeaders	| numbers headers |	^self		safelyExecute: 			[ (numbers := self messageNumbersFor: 'all') isEmpty				ifTrue: [ numbers ]				ifFalse: 					[connection select: self name.					headers := connection fetchRFC822MessageHeaders: numbers.					headers collect: 						[:header | 						MailIncrementNotification raiseSignal. 						MimeEntity readHeaderFrom: header value first readStream						]]]</body><body package="IMAP">anyNewMail	"Any new mail to get?"	self log: [(#Checking1sForMail &lt;&lt; #net &gt;&gt; 'Checking &lt;1s&gt; for mail') expandMacrosWith: server name ] level: #IMAPMailboxCheck. 	^ (self safelyExecute: [ connection unseenMessages ]) size &gt; 0</body><body package="IMAP">deleteMessageNumbers: aSequenceOfUIDs	"Delete all the letters on the server.  Ignore non-existent ones"	| res |	res := self safelyExecute: [connection searchMessagesForUids: aSequenceOfUIDs ]. 	self safelyExecute: [connection markForDelete: res; expunge. ].	^self messageCount.</body><body package="IMAP">getMessage: number 	"Get the &lt;number&gt; message from the IMAP server"	| coll |	^(coll := self getMessagesByNumbers: (Array with: number)) notEmpty		ifTrue: [ coll first ]		ifFalse: [nil ]</body><body package="IMAP">messageCount	"How many messages are on the server?"	^self safelyExecute:	[connection messageCount]</body><body package="IMAP">messageNumbersFor: criteria	"How many messages are on the server?"	^self safelyExecute: [connection searchMessages: criteria].</body></methods><methods><class-id>Net.IMAPMailbox</class-id> <category>mail delivery</category><body package="IMAP">deliverAllMail	"Queue up all new messages onto the queue. Clients of this 	method should be aware that the state should be such that there 	is new mail to download."	| numbers |	numbers := self messageNumbersFor: 'all'. 	numbers size &gt; 0 		ifTrue: [self deliverMessages: numbers ]</body><body package="IMAP">deliverNewMail	"Queue up all new messages onto the queue. Clients of this 	method should be aware that the state should be such that there 	is new mail to download."	| numbers |	numbers := self messageNumbersFor: 'unseen'. 	numbers size &gt; 0 		ifTrue: [self deliverMessages: numbers ]</body></methods><methods><class-id>Net.IMAPMailbox</class-id> <category>debugging</category><body package="IMAP">logMessages: messages position: position from: total time: downloadTime	| n messageSize |	n := position.	messages size		timesRepeat: 			[n := n + 1.			n \\ 10 = 0 				ifTrue: [self log: [(#DownloadedMessages &lt;&lt; #net &gt;&gt; 'Downloaded &lt;1p&gt; messages from &lt;2s&gt;') expandMacrosWith: n with: server]						level: #IMAPMailboxDownload]].	self 		debug: [messageSize := messages inject: 0 into: [:sum :message | sum + message size].			self class processTransferRate: downloadTime ofSize: messageSize fromServer: server]		level: #IMAPTransferRate</body></methods><methods><class-id>Net.IMAPMailbox class</class-id> <category>debugging</category><body package="IMAP">debugLabelsAndValues	^OrderedCollection new		add: ((#IMAPMailboxCheck &lt;&lt; #net &gt;&gt; 'IMAP Mailbox Check')-&gt;#IMAPMailboxCheck);		add: ((#IMAPMailboxDownload &lt;&lt; #net &gt;&gt; 'IMAP Mailbox Download')-&gt;#IMAPMailboxDownload);		yourself</body><body package="IMAP">initialize	self registerToDebug</body><body package="IMAP">menuItemName	^(#IMAPMailboxMessages &lt;&lt; #net &gt;&gt; 'IMAPMailbox Messages')</body></methods><methods><class-id>Net.IMAPMailbox class</class-id> <category>class initialization</category><body package="IMAP">obsolete	self unregisterFromDebug.	super obsolete.</body></methods><methods><class-id>Net.IMAPAuthenticatedState</class-id> <category>commands</category><body package="IMAP">append: message to: aMailboxName flags: flags date: dateString "APPEND Command. If the destination mailbox does not exist, a server MUST return an error, and MUST NOT automatically create the mailbox.  Unless it is certain that the destination mailbox can not be created, the server MUST send the response code [TRYCREATE] as the prefix of the text of the tagged NO response."	| args |	args := OrderedCollection with: (client canonicalizeMailboxName: aMailboxName).	flags notNil ifTrue: [args add: flags].	dateString notNil ifTrue: [args add: #atom -&gt; dateString].	args add: #literalString -&gt; message.	^client executeAndWait: 'append' arguments: args</body><body package="IMAP">create: aMailboxName	^client		execute: 'create'		arguments: (client canonicalizeMailboxName: aMailboxName)		changeStateTo: [IMAPSelectedState new]</body><body package="IMAP">delete: aMailboxName	^client 		executeAndWait: 'delete' 		arguments: (client canonicalizeMailboxName: aMailboxName)</body><body package="IMAP">examine: aMailBoxName 	^client		execute: 'examine'		arguments: (client canonicalizeMailboxName: aMailBoxName)		changeStateTo: [IMAPSelectedState new]</body><body package="IMAP">list: refName mailbox: name	^client 		executeAndWait: 'list' 		arguments: (Array with: refName with: (client canonicalizeMailboxName: name))</body><body package="IMAP">logout	| command |	(command := client executeAndWait: 'logout' ) successful		ifTrue: [  client state: IMAPLogoutState new].	^command</body><body package="IMAP">lsub: refName mailbox: name	^client 		executeAndWait: 'lsub' 		arguments: (Array with: refName with: (client canonicalizeMailboxName: name))</body><body package="IMAP">rename: oldMailBox newName: newMailBox 	^client 		executeAndWait: 'rename' 		arguments: 			(Array 				with: (client canonicalizeMailboxName: oldMailBox)				with: (client canonicalizeMailboxName: newMailBox))</body><body package="IMAP">rlist: refName mailbox: name	^client 		executeAndWait: 'rlist' 		arguments: (Array with: refName with: (client canonicalizeMailboxName: name))</body><body package="IMAP">rlsub: refName mailbox: name	^client 		executeAndWait: 'rlsub' 		arguments: (Array with: refName with: (client canonicalizeMailboxName: name))</body><body package="IMAP">select: aMailBoxName	^client		execute: 'select'		arguments: (client canonicalizeMailboxName: aMailBoxName)		changeStateTo: [IMAPSelectedState new]</body><body package="IMAP">status: aMailboxName	^client 		executeAndWait: 'status' 		arguments: (client canonicalizeMailboxName: aMailboxName)</body><body package="IMAP">status: aMailboxName criteria: anArrayOfStatusData	| args |	args := OrderedCollection new: 5.	args add:  (client canonicalizeMailboxName: aMailboxName).	args add: 		(#parenthesizedList-&gt;			(anArrayOfStatusData isCharacters				ifTrue: [Array with: (#atom-&gt;anArrayOfStatusData)]				ifFalse: [anArrayOfStatusData])).	^client 		executeAndWait: 'status' 		arguments: args</body><body package="IMAP">subscribe: aMailBoxName	^client 		executeAndWait: 'subscribe' 		arguments: (Array with: (client canonicalizeMailboxName: aMailBoxName))</body><body package="IMAP">unsubscribe: aMailBoxName	^client 		executeAndWait: 'unsubscribe' 		arguments: (Array with: (client canonicalizeMailboxName: aMailBoxName))</body></methods><methods><class-id>Net.IMAPSelectedState</class-id> <category>commands</category><body package="IMAP">check	^client executeAndWait: 'check'</body><body package="IMAP">close	^client		execute: 'close'		arguments: nil		changeStateTo: [IMAPAuthenticatedState new]</body><body package="IMAP">copy: messageNumbers to: aName 	| msgString args |	msgString := client messageSetAsString: messageNumbers.	args := OrderedCollection with: msgString with: (client canonicalizeMailboxName: aName).	^client executeAndWait: 'copy' arguments: args.</body><body package="IMAP">expunge	^client executeAndWait: 'expunge'</body><body package="IMAP">fetch: aCriteria	^client executeAndWait: 'fetch' arguments: aCriteria</body><body package="IMAP">fetch: messageNumbers retrieve: criteria 	| msgString args |	msgString := client messageSetAsString: messageNumbers.	args := OrderedCollection with: msgString. 	args add: (#parenthesizedList-&gt;criteria).	^client executeAndWait: 'fetch' arguments: args.</body><body package="IMAP">search: aCriteria	^client executeAndWait: 'search' arguments: aCriteria</body><body package="IMAP">store: args	^client executeAndWait: 'store' arguments: args</body><body package="IMAP">uid: aString	^client executeAndWait: 'uid' arguments: aString</body></methods><methods><class-id>Net.IMAPResponseTagged</class-id> <category>testing</category><body package="IMAP">hasTag: tagString	^self tag match: tagString</body><body package="IMAP">terminatesCommand: aCommand	^self hasTag: aCommand sequenceID</body></methods><methods><class-id>Net.IMAPResponseTagged</class-id> <category>parsing, general</category><body package="IMAP">parse: scanner tag: tag status: statusString	self cmdName: tag.	self status: statusString.	^self parse: scanner</body></methods><methods><class-id>Net.IMAPResponseTagged</class-id> <category>accessing</category><body package="IMAP">tag	^self cmdName</body></methods><methods><class-id>Net.IMAPResponseTagged class</class-id> <category>testing</category><body package="IMAP">canParse: cmdName	^false</body></methods><methods><class-id>Net.IMAPResponseTagged class</class-id> <category>parsing, general</category><body package="IMAP">parse: scanner tag: tag status: status	^self new			parse: scanner tag: tag status: status</body></methods><methods><class-id>Net.IMAPCommand</class-id> <category>accessing</category><body package="IMAP">arguments	^arguments</body><body package="IMAP">arguments: anObject	arguments := anObject</body><body package="IMAP">client	^client</body><body package="IMAP">client: anObject	client := anObject</body><body package="IMAP">completionResponse	^completionResponse</body><body package="IMAP">completionResponse: anObject	completionResponse := anObject.</body><body package="IMAP">name	^name</body><body package="IMAP">name: anObject	name := anObject</body><body package="IMAP">sequenceID	^sequenceID</body><body package="IMAP">sequenceID: anObject	sequenceID := anObject</body></methods><methods><class-id>Net.IMAPCommand</class-id> <category>status</category><body package="IMAP">beDone	self status: #done.	self client commandIsDone: self.	self value: self completionResponse.</body><body package="IMAP">beSent	self status: #sent.	self client commandIsInProgress: self.</body><body package="IMAP">status	^ status</body><body package="IMAP">status: anObject	status := anObject.</body><body package="IMAP">value	^ self promise value</body><body package="IMAP">value: anObject	self promise value: status.</body></methods><methods><class-id>Net.IMAPCommand</class-id> <category>responses</category><body package="IMAP">commandResponse	| coll |	^(coll := self commandResponses) isEmpty		ifTrue: [ nil ]		ifFalse: [coll first]</body><body package="IMAP">commandResponseValue	| resp |	^(resp := self commandResponse) isNil		ifTrue: [ nil ]		ifFalse: [resp value]</body><body package="IMAP">commandResponses	^self responses select: [:resp | resp cmdName match: self name]</body><body package="IMAP">responseNamed: aName 	^self responsesNamed: aName</body><body package="IMAP">responses	^ responses notNil		ifTrue: [ responses ]		ifFalse: [ responses := OrderedCollection new ]</body><body package="IMAP">responsesNamed: aName	^self responses select: [:resp | resp cmdName = aName ]</body><body package="IMAP">statusResponse	^self statusResponses first</body><body package="IMAP">statusResponses	^self responses select: [:resp | resp isKindOf: IMAPResponseStatus]</body></methods><methods><class-id>Net.IMAPCommand</class-id> <category>handle responses</category><body package="IMAP">definedResponses	^self class definedResponsesAt: self name asUppercase</body><body package="IMAP">handle: aResponse	(aResponse terminatesCommand: self) ifTrue: 		[self terminateWithResponse: aResponse.		^aResponse hasTag: self sequenceID].	(self isDefinedResponse: aResponse)		ifTrue: 			[self responses add: aResponse.			^true].	^false</body><body package="IMAP">isDefinedResponse: aResponse 	^(self name equivalentTo: aResponse cmdName ignoreCase: true)		or: [self definedResponses includes: aResponse cmdName]</body></methods><methods><class-id>Net.IMAPCommand</class-id> <category>execute</category><body package="IMAP">execute	"Send the gived command to the server."	self send.	self beSent</body><body package="IMAP">wait	^ self promise value</body><body package="IMAP">waitFor: ms 	ms notNil ifTrue: [promise := TimedPromise forMilliseconds: ms].	^[self promise value]		on: PromiseExpiredError 		do: 	[:ex |  			self terminateWithException: ex.			NetClientError signalWith: #timeout message: (#Timeout &lt;&lt; #net &gt;&gt; 'Timeout')]</body></methods><methods><class-id>Net.IMAPCommand</class-id> <category>testing</category><body package="IMAP">failed	^self successful not</body><body package="IMAP">isDone	^ self status = #done</body><body package="IMAP">isSent	^ self status = #sent</body><body package="IMAP">successful	^ self isDone		and: [ self completionResponse isOK ].</body></methods><methods><class-id>Net.IMAPCommand</class-id> <category>initialization</category><body package="IMAP">forClient: anIMAPPI name: aString arguments: args	self client: anIMAPPI.	self name: aString.	self arguments: (self canonicalizeArguments: args).</body><body package="IMAP">initialize	responses := OrderedCollection new: 1.</body></methods><methods><class-id>Net.IMAPCommand</class-id> <category>parsing</category><body package="IMAP">parse: scanner 	"Read and parse next command from a stream. This is mainly useful for testing previously stored 	exchange logs"	| tokens |	tokens := scanner deepTokenizeAsAssociation.	self		sequenceID: tokens first value; 		name: (tokens at: 2) value; 		arguments: (tokens copyFrom: 3 to: tokens size).</body></methods><methods><class-id>Net.IMAPCommand</class-id> <category>printing</category><body package="IMAP">printOn: aStream 	self scanner		printTokenList: self asTokenList on: aStream.</body><body package="IMAP">scanner	^IMAPScanner</body></methods><methods><class-id>Net.IMAPCommand</class-id> <category>private</category><body package="IMAP">asTokenList	| list | 	list := OrderedCollection with: (#atom-&gt;self sequenceID) with: (#atom-&gt;name).	self arguments notNil 		ifTrue: [list addAll: self arguments].	^list</body><body package="IMAP">canonicalizeArguments: args" Arguments can one of: integer, string or array of thereof, potentially nested. Scalars areconverted into array with this scalar as a sole element "		args isNil ifTrue: [^Array new].	^(args isCharacters or: [args isSequenceable not])		ifTrue: [^Array with: args]		ifFalse: [ args ]</body><body package="IMAP">promise	^promise isNil		ifTrue: [promise := Promise new]		ifFalse: [promise]</body><body package="IMAP">send	self client sendTokenList: self asTokenList.	self client connectionStream cr.	self client connectionStream commit.</body></methods><methods><class-id>Net.IMAPCommand</class-id> <category>command termination</category><body package="IMAP">terminateWithException: exception	self terminateWithResponse: (IMAPErrorResponse newFor: self exception: exception)</body><body package="IMAP">terminateWithResponse: response 	self completionResponse: response.	self beDone</body></methods><methods><class-id>Net.IMAPCommand class</class-id> <category>defined responses</category><body package="IMAP">definedResponsesAt: aName	^self responseRegistry at: aName asUppercase ifAbsentPut: [IdentityDictionary new].</body><body package="IMAP">responseRegistry	^ResponseRegistry</body></methods><methods><class-id>Net.IMAPCommand class</class-id> <category>instance creation</category><body package="IMAP">forClient: anIMAPPI name: aString arguments: arguments " The intention here is to let users specify the complete string of command arguments. Because this string may contain atom-specials like $(, etc., this line may be sent as quoted string, which would be wrong. So we fool the printing logic to view this string as an atom. It is a hack, but seems like a convenient one "	| args |	args := arguments isCharacters				ifTrue: [#atom -&gt; arguments]				ifFalse: [arguments].	^self new		forClient: anIMAPPI		name: aString		arguments: args</body><body package="IMAP">new	^super new initialize</body><body package="IMAP">parse: scanner 	"Read and parse next command from a stream. This is mainly useful for testing previously stored 	exchange logs"	^self new parse: scanner</body><body package="IMAP">readFrom: aStream" Read and parse next command from a stream. This is mainly useful for testing previously stored exchange logs "	^self parse: (IMAPScanner on: aStream)</body></methods><methods><class-id>Net.IMAPCommand class</class-id> <category>class initialization</category><body package="IMAP">initialize	"IMAPCommand initialize"	(ResponseRegistry := Dictionary new)		at: 'FETCH' put: #('FETCH' 'OK' 'NO' 'BAD');		at: 'SEARCH' put: #('SEARCH' 'OK' 'NO' 'BAD');		at: 'SELECT' put: #('FLAGS' 'EXISTS' 'RECENT' 'OK' 'NO' 'BAD');		at: 'EXAMINE' put: #('FLAGS' 'EXISTS' 'RECENT' 'OK' 'NO' 'BAD');		at: 'LIST' put: #('LIST' 'OK' 'NO' 'BAD');		at: 'RLIST' put: #('LIST' 'OK' 'NO' 'BAD');		at: 'LSUB' put: #('LSUB' 'OK' 'NO' 'BAD');		at: 'RLSUB' put: #('LSUB' 'OK' 'NO' 'BAD');		at: 'STATUS' put: #('STATUS');		at: 'EXPUNGE' put: #('EXPUNGE' 'OK' 'NO' 'BAD');		at: 'STORE' put: #('FETCH' 'OK' 'NO' 'BAD');		at: 'UID' put: #('FETCH' 'SEARCH' 'OK' 'NO' 'BAD');		at: 'CAPABILITY' put: #('CAPABILITY' 'OK' 'BAD');		at: 'STORE' put: #('FETCH');		at: 'LOGOUT' put: #('BYE' 'OK' 'BAD');		at: 'CLOSE' put: #('OK' 'NO' 'BAD');		at: 'CHECK' put: #('OK' 'NO');		at: 'APPEND' put: #('OK' 'NO' 'BAD');		at: 'SUBSCRIBE' put: #('OK' 'NO' 'BAD');		at: 'RENAME' put: #('OK' 'NO' 'BAD');		at: 'DELETE'  put: #('OK' 'NO' 'BAD');		at: 'CREATE'  put: #('OK' 'NO' 'BAD');		at: 'LOGIN'  put: #('OK' 'NO' 'BAD');		at: 'AUTHENTICATE' put: #('OK' 'NO' 'BAD');		at: 'NOOP'  put: #('OK' 'BAD').</body></methods><methods><class-id>Net.IMAPConnection</class-id> <category>accessing</category><body package="IMAP">connectionStream	^stream</body><body package="IMAP">responseStream	^stream</body></methods><methods><class-id>Net.IMAPConnection class</class-id> <category>default values</category><body package="IMAP">defaultPortNumber	^SocketAccessor IPPORT_IMAP</body></methods><methods><class-id>Net.IMAPClient</class-id> <category>commands</category><body package="IMAP">append: aString to: aMailboxName "APPEND CommandResponses:  no specific responses for this commandResult:     OK - append completed               NO - append error: can't append to that mailbox, error in flags or date/time or message text               BAD - command unknown or arguments invalidIf the destination mailbox does not exist, a server MUST return an error, and MUST NOT automatically create the mailbox.  Unless it is certain that the destination mailbox can not be created, the server MUST send the response code [TRYCREATE] as the prefix of the text of the tagged NO response.  This gives a hint to the client that it can attempt a CREATE command and retry the APPEND if the CREATE is successful."	^self state		append: aString		to: aMailboxName		flags: nil		date: nil</body><body package="IMAP">append: aString to: aMailboxName flags: flags date: dateString 	^self state		append: aString		to: aMailboxName		flags: flags		date: dateString</body><body package="IMAP">authenticate: aString	| comm | 	^(comm := self state authenticate: aString) failed		ifTrue: [NetClientError signalWith: #authenticate message: comm completionResponse text]		ifFalse: [comm ]</body><body package="IMAP">capability	^ self state capability</body><body package="IMAP">check	^ self state check</body><body package="IMAP">close"The command permanently removes from the currently selected mailbox all messages that have the \Deleted flag set, and returns to authenticated state from selected state"	^ self state close</body><body package="IMAP">copy: messageNumbers to: aMailboxName 	^self state copy: messageNumbers to: aMailboxName</body><body package="IMAP">create: aMailBoxName	^ self state create: aMailBoxName</body><body package="IMAP">delete: aMailBoxName	^ self state delete: aMailBoxName</body><body package="IMAP">examine: aMailBoxName	^ self state examine: aMailBoxName</body><body package="IMAP">expunge	^ self state expunge</body><body package="IMAP">fetch: aCriteria" Fetch messages based on specified criteria	client fetch: '1:3 (uid Body.Peek[Header.Fields (Message-Id From)])'	client fetch: '1:2 (flags internaldate uid RFC822)'. "	^ self state fetch: aCriteria</body><body package="IMAP">fetch: messageNumbers retrieve: criteria	^ self state fetch: messageNumbers retrieve: criteria</body><body package="IMAP">list: aMailbox" client list: 'inbox' "	^ self state list: #quotedText-&gt;'' mailbox: aMailbox</body><body package="IMAP">list: refName mailbox: name" client list: 'test/'  mailbox: 'mail/*' "	^ self state list: refName mailbox: name</body><body package="IMAP">login	| comm | 	^(comm := self state login) failed		ifTrue: [NetClientError signalWith: #login message: comm completionResponse text]		ifFalse: [comm ]</body><body package="IMAP">logout "  In logout state, the connection is being terminated, and the server  will close the connection.  "	^self state logout</body><body package="IMAP">lsub: refName mailbox: name	^ self state lsub: refName mailbox: name</body><body package="IMAP">noop	^self state noop</body><body package="IMAP">rename: oldMailBox newName: newMailBox 	^self state rename: oldMailBox newName: newMailBox</body><body package="IMAP">rlist: aMailbox" client list: 'inbox' "	^ self state rlist: #quotedText-&gt;'' mailbox: aMailbox</body><body package="IMAP">rlist: refName mailbox: name" client list: 'test/'  mailbox: 'mail/*' "	^ self state rlist: refName mailbox: name</body><body package="IMAP">rlsub: refName mailbox: name	^ self state rlsub: refName mailbox: name</body><body package="IMAP">search: aCriteria	^ self state search: aCriteria</body><body package="IMAP">select: aMailBoxName	^ self state select: aMailBoxName</body><body package="IMAP">status: aMailBoxName" Obtain status of messages in specified mailbox.	client status: 'inbox' "	^ self status: aMailBoxName criteria: 'messages'</body><body package="IMAP">status: aMailBoxName criteria: anArrayOfStatusData" Obtain status of specified mailbox using specified criteria. criterial may be either string or array or strings if multiple criteria is given 	client status: 'inbox' criteria: #('messages' 'unseen'). 	client status: 'sent items' criteria: 'messages'. "	^ self state status: aMailBoxName criteria: anArrayOfStatusData</body><body package="IMAP">store: args	^ self state store: args</body><body package="IMAP">subscribe: aMailBoxName	^ self state subscribe: aMailBoxName</body><body package="IMAP">uid: aString	^ self state uid: aString</body><body package="IMAP">unsubscribe: aMailBoxName	^ self state unsubscribe: aMailBoxName</body></methods><methods><class-id>Net.IMAPClient</class-id> <category>defaults</category><body package="IMAP">defaulfHandler	^ IMAPClientHandler new</body><body package="IMAP">defaultMailbox	^(#inbox &lt;&lt; #net &gt;&gt; 'inbox') asString</body></methods><methods><class-id>Net.IMAPClient</class-id> <category>responses</category><body package="IMAP">handle: aResponse 	"Ask IMAPClientHandler to handle responses that must be recorded by the client"	^self handler handle: aResponse for: self</body></methods><methods><class-id>Net.IMAPClient</class-id> <category>accessing</category><body package="IMAP">handler	^handler isNil		ifTrue: [handler := self defaulfHandler]		ifFalse: [handler]</body><body package="IMAP">handler: imapClientHandler	handler := imapClientHandler</body></methods><methods><class-id>Net.IMAPClient</class-id> <category>private</category><body package="IMAP">canonicalizeMailboxName: aMailboxName" Mailbox names are encoded in UTF-7 format. "	| str |	str := (ByteArray new withEncoding: #UTF_7IMAP) writeStream.	str nextPutAll: aMailboxName.	str close.	^IMAPScanner stringAsAssociation:		(str encodedContents withEncoding: #ASCII) readStream contents</body><body package="IMAP">handlePeerFaultError: exception retry: retry	"The Server we are connecting to might be too busy to handle our	connection request.  In this case, delay for a little while and try again.	Once we have hit our connection retry limit, return true to the client so	that it can handle the error as it sees fit."	retry &gt; 0 ifTrue: 		[(Delay forSeconds: self delaySeconds) wait.		self clientPI log: [(#FailedToConnectWillTryMore &lt;&lt; #net &gt;&gt; 'Failed to connect to &lt;1s&gt;. Will try &lt;2p&gt; more times.') expandMacrosWith: self hostName with: retry]			level: #IMAPClient.		exception retry].	^true</body><body package="IMAP">messageSetAsString: messageNumbers 	| stream |	stream := (String new: 64) writeStream.	messageNumbers 			do: [:messageNumber | stream nextPutAll: messageNumber printString]			separatedBy: [stream nextPut: $,].	^stream contents</body></methods><methods><class-id>Net.IMAPClient</class-id> <category>low-level command interface</category><body package="IMAP">commandClassFor: cmdName 	^self class commandClassFor: cmdName</body><body package="IMAP">createCommand: aString 	^ self createCommand: aString arguments: nil</body><body package="IMAP">createCommand: aString arguments: anArray 	^IMAPCommand		forClient: clientPI		name: aString		arguments: anArray</body><body package="IMAP">execute: cmd arguments: args changeStateTo: aStateBlock	^self 		execute: [self createCommand: cmd arguments: args ] 		changeStateTo: aStateBlock.</body><body package="IMAP">execute: aBlock changeStateTo: aStateBlock	| command |	command := aBlock value.	self executeCommand: command.	command wait.	command successful ifTrue: [self state: aStateBlock value ].	^ command</body><body package="IMAP">executeAndWait: aString 	^self executeAndWait: aString arguments: nil</body><body package="IMAP">executeAndWait: aString arguments: anArray	| command |	command := self createCommand: aString arguments: anArray.	self executeCommand: command.	command waitFor: self timeout.	^ command</body><body package="IMAP">executeAndWait: aString arguments: anArray for: ms	| command |	command := self createCommand: aString arguments: anArray.	self executeCommand: command.	command waitFor: ms.	^ command</body><body package="IMAP">executeAndWait: aString for: ms 	^self		executeAndWait: aString		arguments: nil		for: ms</body><body package="IMAP">executeCommand: aCommand 	^self isConnected not		ifFalse: [self clientPI executeCommand: aCommand]		ifTrue: [NetClientError signalWith: #connection message: (#ServerIsNotAccessible &lt;&lt; #net &gt;&gt; 'Server is not accessible.')]</body></methods><methods><class-id>Net.IMAPClient</class-id> <category>connection management</category><body package="IMAP">connect	"Establish a connection to the host "	| nRetry |	nRetry := self retries.	[super connect.	self state: IMAPNonAuthenticatedState new.	] 	on: OSErrorHolder peerFaultSignal, OsInaccessibleError, OsNeedRetryError	do: 	[:ex | 		ex class = OsInaccessibleError 			ifTrue: [ NetClientError signalWith: #connection message: (#ServerIsNotAccessible &lt;&lt; #net &gt;&gt; 'Server is not accessible.')]			ifFalse: [	nRetry := nRetry - 1. 				 (self handlePeerFaultError: ex retry: nRetry)					ifTrue: [ NetClientError signalWith: #connection message: (#UnableToConnectToServer &lt;&lt; #net &gt;&gt; 'Unable to connect to the server.')]]]</body><body package="IMAP">disconnect	"Disconnect from the host"	self logout.	self clientPI disconnect.</body><body package="IMAP">isConnected	^self clientPI isConnected</body><body package="IMAP">loginToHost	self login successful ifFalse: [ ^nil].</body></methods><methods><class-id>Net.IMAPClient</class-id> <category>utilities</category><body package="IMAP">examineMailbox " Examine default mailbox (inbox) "	^ self examineMailbox: self defaultMailbox</body><body package="IMAP">examineMailbox: mailbox 	^ (self examine: mailbox) responses.</body><body package="IMAP">fetch: anArrayOfNumbers with: qualifierOrListOfQualifiers " Returns an OrderedCollection of  associations which key is the message number and value the message"	| args result dict data messageNumber |	args := qualifierOrListOfQualifiers isCharacters				ifTrue: [Array with: qualifierOrListOfQualifiers]				ifFalse: [qualifierOrListOfQualifiers].	result := self fetch: anArrayOfNumbers retrieve: args.	dict := Dictionary new. 	^result successful 		ifFalse: [self error: result completionResponse text. nil]		ifTrue: [result commandResponses				collect: 					[:response | 					messageNumber := response value.					data := response parameters first.					1 to: data size by: 2						do: [:idx | dict at: (data at: idx) asUppercase put: (data at: idx + 1)].					messageNumber -&gt; (qualifierOrListOfQualifiers collect: [:tag | dict at: tag asUppercase])]]</body><body package="IMAP">fetchMessage: messageNumber " Returns an association which key is the message number and value the message"	| result |	result := self fetch: (Array with: messageNumber) with: #('RFC822').	^result notNil		ifTrue: [result first]		ifFalse: [nil]</body><body package="IMAP">fetchMessageHeaders: anArrayOfNumbers " Returns an OrderedCollection of  associations which key is the message number and value the message header"	^self fetch: anArrayOfNumbers with: #('RFC822.HEADER')</body><body package="IMAP">fetchMessages: anArrayOfNumbers " Returns an OrderedCollection of  associations which key is the message number and value the message"	^self fetch: anArrayOfNumbers with: #('RFC822')</body><body package="IMAP">fetchRFC822MessageHeaders: anArrayOfNumbers " Returns an OrderedCollection of  associations which key is the message number and value the message header"	^self fetchMessageHeaders: anArrayOfNumbers</body><body package="IMAP">fetchRFC822Messages: anArrayOfNumbers " Returns an OrderedCollection of  associations which key is the message number and value the message"	^self fetchMessages: anArrayOfNumbers</body><body package="IMAP">markAsSeen: aCollectionOfNumbers"Sets \Seen  flags for the specified message number"	| string |	string := self messageSetAsString: aCollectionOfNumbers.	^ (self store: (string, ' +FLAGS (\Seen)')) successful</body><body package="IMAP">markForDelete: anArrayOfNumbers"Sets deleted flags for the specified message numbers"	| string |	string := self messageSetAsString: anArrayOfNumbers. 	^ (self store: (string, ' +FLAGS (\Deleted)')) successful</body><body package="IMAP">messageCount	"Returns the number of messages in the default mailbox (inbox).	See messageCount: to retrieve message count from any mailbox "	^self messageCount: self defaultMailbox</body><body package="IMAP">messageCount: mailbox	"Returns the number of messages in specified mailbox "	| resps |	resps := self examineMailbox: mailbox.	^(resps detect: [:each | each cmdName = 'EXISTS']) value asNumber</body><body package="IMAP">newMessages	"Returns the number of recent messages in in the default mailbox (inbox).	See newMessages: to retrieve new messages from any mailbox "	^self newMessages: self defaultMailbox</body><body package="IMAP">newMessages: mailbox	"Returns the number of recent messages in specified mailbox "	| resps |	resps := self examineMailbox: mailbox. 	^(resps detect: [:each | each cmdName = 'RECENT']) value asNumber</body><body package="IMAP">searchMessages: aCriteria" Returns a collection of message numbers that match the given searching criteria"	|  result  resp |	result := self search: aCriteria.	^ result successful 		ifFalse: [ self error: result completionResponse text. ]		ifTrue: 			[  (resp := result commandResponse parameters) isEmpty not				ifTrue: [ resp collect: [ :each | each asNumber]]				ifFalse: [ resp ]			]</body><body package="IMAP">searchMessagesForUids: aCollectionOfUidStrings" Returns a collection of message numbers that match the message uids"	| stream |	stream := (String new: 64) writeStream.	stream nextPutAll: 'uid '.	aCollectionOfUidStrings			do: [:uid | stream nextPutAll: uid]			separatedBy: [stream nextPut: $,].	^ self searchMessages: stream contents</body><body package="IMAP">status: anArrayOfStatusData forMailbox: aName"Returns a list of message numbers"" For example the command: client status: (Array with: 'messages' with: 'unseen') forMailbox: 'inbox'. returns:  #('23' '3') "	| resp result |	resp :=  (self status: aName criteria: anArrayOfStatusData) 				commandResponse				parameters at: 2.	result := OrderedCollection new: anArrayOfStatusData size.	2 to: resp size by: 2 do: [ :each  | result add: ( resp at: each) ]. 	^ result.</body><body package="IMAP">uidFor: anArrayOfMessageNumbers	^(self fetch: anArrayOfMessageNumbers with: #('UID') )		collect: [ :assoc |  assoc  value first ].</body><body package="IMAP">unmarkAsSeen: aCollectionOfNumbers"Sets \Seen  flags for the specified message number"	| string |	string := self messageSetAsString: aCollectionOfNumbers.	^ (self store: (string, ' -FLAGS (\Seen)')) successful</body><body package="IMAP">unmarkForDelete: anArrayOfNumbers"Sets deleted flags for the specified message numbers"	| string |	string := self messageSetAsString: anArrayOfNumbers. 	^ (self store: (string, ' -FLAGS (\Deleted)')) successful</body><body package="IMAP">unseenMessages	"Returns the number of unseen messages in inbox "	^ self searchMessages: 'unseen'</body></methods><methods><class-id>Net.IMAPClient</class-id> <category>initialize-release</category><body package="IMAP">initialize	super initialize.	self state: IMAPLogoutState new.	self clientPI client: self</body></methods><methods><class-id>Net.IMAPClient class</class-id> <category>testing</category><body package="IMAP">isIncomingMailClient	^true</body><body package="IMAP">isMailClient	^true</body><body package="IMAP">isOutgoingMailClient	^false</body></methods><methods><class-id>Net.IMAPClient class</class-id> <category>class initialization</category><body package="IMAP">initialize	super initialize</body><body package="IMAP">registerClass	self mailRegistry at: self serverType put: self name</body></methods><methods><class-id>Net.IMAPClient class</class-id> <category>constants</category><body package="IMAP">description	^(#incomingMailServer &lt;&lt; #net &gt;&gt; 'incoming mail server') asString</body><body package="IMAP">serverType	^#IMAP</body></methods><methods><class-id>Net.IMAPClient class</class-id> <category>default values</category><body package="IMAP">defaultProtocolInterpreterClassValue	^IMAPProtocolInterpreter</body></methods><methods><class-id>Net.IMAPNonAuthenticatedState</class-id> <category>commands</category><body package="IMAP">authenticate: aString	^client		execute: 'authenticate'		arguments: (Array with: aString )		changeStateTo: [IMAPAuthenticatedState new]</body><body package="IMAP">login	^client		execute: 'login'		arguments: (Array with: client user username with: client user password)		changeStateTo: [IMAPAuthenticatedState new]</body></methods><methods><class-id>Net.IMAPCommandSequencer</class-id> <category>private</category><body package="IMAP">increment	self value: ( self value + 1 ).</body></methods><methods><class-id>Net.IMAPCommandSequencer</class-id> <category>initialization</category><body package="IMAP">initialize	value := 0.</body><body package="IMAP">reset	self value: 0.</body></methods><methods><class-id>Net.IMAPCommandSequencer</class-id> <category>accessing</category><body package="IMAP">next	self increment.	^ self prefix, self value printString.</body><body package="IMAP">prefix	^prefix</body><body package="IMAP">prefix: aValue	prefix := aValue</body><body package="IMAP">value	^value</body><body package="IMAP">value: aValue	value := aValue</body></methods><methods><class-id>Net.IMAPCommandSequencer class</class-id> <category>instance creation</category><body package="IMAP">new	^super new initialize</body><body package="IMAP">newPrefix: prefix	^self new prefix: prefix; yourself</body></methods><methods><class-id>Net.IMAPScanner</class-id> <category>tokenization</category><body package="IMAP">deepNextToken	^self nextToken == $(		ifTrue: [self stepBack; scanParenthesizedList]		ifFalse: [token]</body><body package="IMAP">deepNextTokenAsAssociation	^self nextToken == $(		ifTrue: [self stepBack; scanParenthesizedListAsAssociation]		ifFalse: [tokenType-&gt;token].</body><body package="IMAP">deepTokenize	| stream |	stream := (Array new: 4) writeStream.		[self deepNextToken.	tokenType = #doIt or: [token == Character cr]]		whileFalse: [stream nextPut: token].	token == Character cr ifTrue: [ self stepBack ].	^stream contents</body><body package="IMAP">deepTokenizeAsAssociation	| stream assoc |	stream := (Array new: 4) writeStream.		[assoc := self deepNextTokenAsAssociation.	assoc key = #doIt]		whileFalse: [stream nextPut: assoc].	^stream contents</body><body package="IMAP">deepTokenizeAsAssociationUntil: aBlock do: actionBlock 	| assoc |		[self skipWhiteSpace.	assoc := self deepNextTokenAsAssociation.	assoc key = #doIt or: aBlock]		whileFalse: [actionBlock value: assoc]</body><body package="IMAP">deepTokenizeUntil: aBlock do: actionBlock	[self skipWhiteSpace; deepNextToken. tokenType == #doIt or: aBlock]		whileFalse:  			[actionBlock value].</body><body package="IMAP">nextToken	^self nextIMAPToken</body><body package="IMAP">specials	^self class atomSpecials</body></methods><methods><class-id>Net.IMAPScanner</class-id> <category>multi-character scans</category><body package="IMAP">doSpecialScanProcessing	"Hacks that require special handling of IMAP tokens go here. 	The most frustrating one for us was handling of message/mailbox flags that have format \&lt;atom&gt; as 	in \Seen. The problem is that $\ is not an atom-char, so these flags are tokenized as #( $\ 'Seen'). 	We make heuristical decision here if current token is $\ immediately followed by a letter. We will 	then read next token and merge $\ and next token answering a string. This is ONLY applied inside a 	parenthesized list"	(token == $\ and: [(self classificationMaskFor: self peek)			anyMask: AlphabeticMask])		ifTrue: 			[self nextToken.			token := '\' , token.			tokenType := #string]</body><body package="IMAP">scanAtom	"atom = 1*&lt;any CHAR except atom-specials (which includes atomSpecials, space and CTLs)&gt;"	token := self scanAtomToken.	(token match: 'NIL')		ifTrue: 			["RFC2060 defines NIL as a special atom type, atoms are not case-sensitive"			token := nil.			tokenType := #nil]		ifFalse: [tokenType := #atom].	^token</body><body package="IMAP">scanAtomToken	"atom = 1*&lt;any CHAR except atom-specials (which includes atomSpecials, space and CTLs)&gt;"	^self 		scanWhile: [self matchCharacterType: AtomMask]		do: 			[:stream :char | 			stream nextPut: char.			char == $[ 					ifTrue: [stream nextPutAll: self xScanBrackets]]</body><body package="IMAP">scanLiteralText	"&lt;{&gt; nnn &lt;}&gt; &lt;CRLF&gt; &lt;nnn bytes&gt;"	| nbytes string |	nbytes := self scanLiteralTextLength.	string := self nextBytesAsString: nbytes.	token := string copyReplaceAll: (String with: Character cr with: Character lf) with: (String with: Character cr).	tokenType := #literalString.	^token</body><body package="IMAP">scanLiteralTextLength	"&lt;{&gt; nnn &lt;}&gt; &lt;CRLF&gt;"	" We are positioned at the first brace character "	token := self scanToken: [ self matchCharacterType: DigitMask ] delimitedBy: '{}' notify: (#MalformedLiteralLength &lt;&lt; #net &gt;&gt; 'Malformed literal length').	self upTo: Character cr.	^Integer readFrom: token readStream</body><body package="IMAP">scanParenthesizedList	| stream |	stream := (Array new: 4) writeStream.	self mustMatch: $( notify: (#ParenthesizedListShouldBeginWith &lt;&lt; #net &gt;&gt; 'Parenthesized list should begin with (').	self deepTokenizeUntil: [token == $)] 		do: [self doSpecialScanProcessing. stream nextPut: token].	token ~~ $) ifTrue: [self notify: (#NonterminatedParenthsizedList &lt;&lt; #net &gt;&gt; 'Non-terminated parenthsized list')].	token := stream contents.	tokenType := #parenthesizedList.	^token</body><body package="IMAP">scanParenthesizedListAsAssociation	| stream |	stream := (Array new: 4) writeStream.	self mustMatch: $( notify: (#ParenthesizedListShouldBeginWith &lt;&lt; #net &gt;&gt; 'Parenthesized list should begin with (').	self deepTokenizeAsAssociationUntil: [token == $)] 		do: [:assoc | self doSpecialScanProcessing. stream nextPut: (tokenType-&gt;token)].	token ~~ $) ifTrue: [self notify: (#NonterminatedParenthsizedList &lt;&lt; #net &gt;&gt; 'Non-terminated parenthsized list')].	token := stream contents.	tokenType := #parenthesizedList.	^tokenType-&gt;token</body><body package="IMAP">scanQuotedChar	"Scan possible quoted character. If the current char is $\, read in next character and make it a quoted 	string character"	^(hereChar == $\)		ifTrue: 			[self step.			classificationMask := QuotedTextMask.			true]		ifFalse: [false]</body><body package="IMAP">scanQuotedText" quoted-string = &lt;""&gt; *(quoted_char / quoted-pair) &lt;""&gt;  quoted_char    =  &lt;any CHAR except &lt;""&gt; and &lt;\&gt;"	" We are positioned at the first double quote character "	token := self 				scanToken: [ self scanQuotedChar; matchCharacterType: QuotedTextMask ] 				delimitedBy: '""' 				notify: (#UnmatchedQuotedText &lt;&lt; #net &gt;&gt; 'Unmatched quoted text').	tokenType := #quotedText.	^token.</body><body package="IMAP">scanText	"RFC822: text = &lt;Any CHAR, including bare CR &amp; bare LF, but not including CRLF. This is a 'catchall' category and cannot be tokenized. Text is used only to read values of unstructured fields"	^self 		skipWhiteSpace; 		scanWhile: [ (self matchCharacterType: CRLFMask) not ].</body></methods><methods><class-id>Net.IMAPScanner</class-id> <category>private</category><body package="IMAP">nextBytesAsString: nbytes 	| str |	^[	self binary.		str := (source next: nbytes) asString.		self sourceTrailNextPutAll: str.		str	] ensure: [self text]</body><body package="IMAP">nextIMAPToken	| char |	self skipWhiteSpace.	char := self peek.	char isNil				"end of input"		ifTrue: [tokenType := #doIt.			^token := nil].	char == $" ifTrue: [^self scanQuotedText].	char == ${ ifTrue: [^self scanLiteralText].	((char &lt; Character space) or: [self specials includes: char])		ifTrue: [tokenType := #special.		" Special character. Make it token value and set token type "				^token := self next.].	(self matchCharacterType: AtomMask)		ifTrue: [^self scanAtom].	tokenType := #doIt.	token := char.	^token</body><body package="IMAP">xScanBrackets	^(self scanUntil: [hereChar == $] ]), ']'.</body></methods><methods><class-id>Net.IMAPScanner</class-id> <category>printing</category><body package="IMAP">printLiteralString: aString on: stream	self class printLiteralStringLength: aString on: stream.	self class printLiteralStringContents: aString on: stream.</body></methods><methods><class-id>Net.IMAPScanner class</class-id> <category>character classification</category><body package="IMAP">atomSpecials	" These characters cannot occur inside an atom" 	^'(){%*"\'</body><body package="IMAP">specials	^self atomSpecials</body></methods><methods><class-id>Net.IMAPScanner class</class-id> <category>printing</category><body package="IMAP">defaultTokenType	^#string</body><body package="IMAP">printAtom: atom on: stream 	atom isNil		ifTrue: [stream nextPutAll: 'NIL']		ifFalse: [stream nextPutAll: atom ]</body><body package="IMAP">printIMAPString: value on: stream	"Print string as either atom or quoted text"	value isNil ifTrue: [ self printNilOn: stream].	(self shouldBeQuoted: value)		ifTrue: [self printQuotedText: value on: stream ]		ifFalse: [self printAtom: value on: stream]</body><body package="IMAP">printLiteralString: aString on: stream 	"Note that this method is good for printing but not for sending. 	IMAP requires sender to send string length, then wait for continuation response"	self printLiteralStringLength: aString on: stream.	self printLiteralStringContents: aString on: stream</body><body package="IMAP">printLiteralStringContents: aString on: stream 	stream nextPutAll: aString</body><body package="IMAP">printLiteralStringLength: aString on: stream 	stream nextPut: ${.	aString size printOn: stream.	stream nextPut: $}; cr</body><body package="IMAP">printNilOn: stream 	stream nextPutAll: 'NIL'</body><body package="IMAP">printParenthesizedList: arrayOfAssociations on: stream 	"In order to accurately print parenthesized list, we need to know 	token types of every element. This is applied recursively"	stream nextPut: $(.	self printTokenList: arrayOfAssociations on: stream.	stream nextPut: $)</body><body package="IMAP">printToken: value tokenType: aSymbol on: stream 	aSymbol = #string ifTrue: [^self printIMAPString: value on: stream].	aSymbol = #literalString ifTrue: [^self printLiteralString: value on: stream].	aSymbol = #atom ifTrue: [^self printAtom: value on: stream].	aSymbol = #quotedText ifTrue: [^self printQuotedText: value on: stream].	aSymbol = #nil ifTrue: [^self printNilOn: stream].	aSymbol = #parenthesizedList ifTrue: [^self printParenthesizedList: value on: stream].	"Invalid token type"	aSymbol = #special ifTrue: [^stream nextPut: value].	self halt</body><body package="IMAP">stringAsAssociation: string 	(self shouldBeQuoted: string) ifFalse: [^#atom -&gt; string].	(string first == $\ and: 	[string size &gt; 1 and: 	[self shouldBeQuoted: (string copyFrom: 2 to: string size) not]])		ifTrue: [^#atom -&gt; string].	^#quotedText -&gt; string</body><body package="IMAP">tokenAsAssociation: token 	(token isKindOf: Association) ifTrue: [^token].	token isNil ifTrue: [^'NIL'].	token isCharacters ifTrue: [^self stringAsAssociation: token].	(token isKindOf: Number) ifTrue: [^#number -&gt; token].	token isSequenceable ifTrue: [^#parentthesizedList -&gt; token].	^token</body></methods><methods><class-id>Net.IMAPScanner class</class-id> <category>class initialization</category><body package="IMAP">initClassificationTable	super initClassificationTable.	self initClassificationTableWith: TextMask when:		[:c | c ~~ Character cr ].	self initClassificationTableWith: AtomMask when:		[:c | c &gt; Character space and: [ (self atomSpecials includes: c) not] ].	self initClassificationTableWith: QuotedTextMask when:		[:c | c ~~ $" and: [ c ~~ $\ and: [ c ~~ Character cr ]]].</body><body package="IMAP">initialize	" IMAPScanner initialize "	self initializeConstants; initClassificationTable</body><body package="IMAP">initializeConstants	AtomMask := 256.	QuotedTextMask := 4096.	TextMask := 8192.</body></methods><methods><class-id>Net.IMAPScanner class</class-id> <category>testing</category><body package="IMAP">isAtomChar: char	^((self classificationMaskFor: char) bitAnd: AtomMask) ~= 0</body><body package="IMAP">shouldBeQuoted: string	^(string detect: [ :char | (self isAtomChar: char) not ] ifNone: [ nil ]) notNil</body></methods><methods><class-id>Net.IMAPScanner class</class-id> <category>utility, parsing</category><body package="IMAP">tokenizeBracketedGroup: string" If argument contains bracketed group, break it into pre-group, group and post-group. Answer nil if there is no bracketed group or 3-element array if there is one "	| first last |	first := string indexOf: $[.	first = 0 ifTrue: [ ^nil ].	last := string indexOf: $].	^Array		with: (string copyFrom: 1 to: first - 1)		with: (string copyFrom: first + 1 to: last - 1)		with: (string copyFrom: last + 1 to: string size).</body></methods><methods><class-id>Net.IMAPStreamEncoder</class-id> <category>private</category><body package="IMAP">shiftInCode	^$&amp; asInteger</body></methods><methods><class-id>Net.IMAPStreamEncoder class</class-id> <category>accessing</category><body package="IMAP">streamEncodingType	^#UTF_7IMAP</body></methods><methods><class-id>Net.IMAPStreamEncoder class</class-id> <category>private</category><body package="IMAP">sextetMapCharacters	^'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+,'</body></methods><methods><class-id>Net.IMAPStreamEncoder class</class-id> <category>class initialization</category><body package="IMAP">initialize	"Initialize class variables"	super initialize</body></methods><methods><class-id>Net.IMAPErrorResponse</class-id> <category>accessing</category><body package="IMAP">exception	^exception</body><body package="IMAP">exception: anException	exception := anException</body><body package="IMAP">text	^ self exception description</body></methods><methods><class-id>Net.IMAPErrorResponse</class-id> <category>testing</category><body package="IMAP">isOK	^false</body><body package="IMAP">terminatesCommand: aCommand	^true</body></methods><methods><class-id>Net.IMAPErrorResponse class</class-id> <category>instance creation</category><body package="IMAP">newFor: aCommand exception: anException	^self new		cmdName: aCommand name;		exception: anException;		yourself</body></methods><methods><class-id>Net.IMAPProtocolInterpreter</class-id> <category>sending tokens</category><body package="IMAP">argumentAsAssociation: argument	(argument isKindOf: Association) ifTrue: [^argument].	argument isNil ifTrue: [^'NIL'].	argument isCharacters ifTrue: [^#string-&gt;argument].	(argument isKindOf: Number) ifTrue: [^#number-&gt;argument].	argument isSequenceable ifTrue: [^#parentthesizedList-&gt;argument].	^argument.</body><body package="IMAP">literalStringAsBytes: string 	| output input char |	output := (ByteArray new: string size) writeStream.	input := string readStream.	[input atEnd]		whileFalse: 			[char := input next.			output nextPut: char asInteger.			char == Character cr				ifTrue: 					[output nextPut: Character lf asInteger.					input peekFor: Character lf]].	^output contents</body><body package="IMAP">processSendLiteralStringResponse: aString 	| resp |	resp := self defaultResponseClass readFrom: aString readStream.	resp tag ifNil: [ ^nil ].	resp status = 'NO' ifTrue: [ IMAPAppendError raiseWith: resp errorString: resp text ].	IMAPArgumentError raiseWith: resp</body><body package="IMAP">sendLiteralString: string 	| resp bytes continue |	bytes := self literalStringAsBytes: string.	IMAPScanner printLiteralStringLength: bytes on: self connectionStream.	self connectionStream commit.	continue := true.	[continue and: [self responseStream atEnd not]]		whileTrue: 			[resp := self responseStream upTo: Character cr.			self class log: ['S: ' , resp] level: #IMAPClient.			(resp first ~= $+) ifTrue: [self processSendLiteralStringResponse: resp ].			resp first == $+ ifTrue: [				["S: + Ready for additional command text."				self connectionStream binary.				IMAPScanner printLiteralStringContents: bytes on: self connectionStream.				self connectionStream commit.				continue := false]						ensure: [self connectionStream text]]]</body><body package="IMAP">sendToken: token tokenType: tokenType	tokenType = #literalString		ifTrue: [self sendLiteralString: token]		ifFalse: [IMAPScanner printToken: token tokenType: tokenType on: self connectionStream]</body><body package="IMAP">sendTokenList: listOfTokens 	| assoc |	listOfTokens		do: 			[:arg | 			assoc := self argumentAsAssociation: arg.			self sendToken: assoc value tokenType: assoc key]		separatedBy: [self connectionStream space]</body></methods><methods><class-id>Net.IMAPProtocolInterpreter</class-id> <category>events</category><body package="IMAP">commandIsDone: command 	commandsInProgress remove: command ifAbsent: [^self].	readResponseSignal wait</body><body package="IMAP">commandIsInProgress: command 	commandsInProgress addFirst: command.	readResponseSignal signal</body><body package="IMAP">connectionIsClosed	self liveAcrossSnapshot		ifTrue: [ObjectMemory removeDependent: self].</body><body package="IMAP">connectionIsReady	commandSequencer reset.	self liveAcrossSnapshot		ifTrue: [ObjectMemory addDependent: self].</body><body package="IMAP">isAnyCommandInProgress	commandsInProgress isEmpty</body><body package="IMAP">isNoCommandInProgress	"For testing purpose"	^ commandsInProgress isEmpty</body></methods><methods><class-id>Net.IMAPProtocolInterpreter</class-id> <category>accessing</category><body package="IMAP">client	^client</body><body package="IMAP">client: aNetClient	client := aNetClient</body><body package="IMAP">commandPrefix: aString	commandSequencer prefix: aString</body><body package="IMAP">connectionStream	^self stream</body></methods><methods><class-id>Net.IMAPProtocolInterpreter</class-id> <category>private</category><body package="IMAP">commandsInProgress	^commandsInProgress</body><body package="IMAP">createSocket: hostName port: portNumber	"Return a SocketAccessor instance or nil if a connection can not be made."	^SocketAccessor newTCPclientToHost: hostName port: portNumber</body><body package="IMAP">nextCommandSequenceNumber	^ commandSequencer next.</body><body package="IMAP">resetCommandSequence	commandSequencer reset</body><body package="IMAP">responseReaderLoop	^[[[[readResponseSignal wait; signal. 		connectionMutex critical: [self handleNextResponse]	] repeat]		on: Error		do: 			[:exc | 			"An exception is being raised. If it is non-proceedable, 			save it so that the Promise will raise it instead of returning a value."			self terminateCommandsWith: exc.			exc return]]		on: Process terminateSignal		do: 			[:exc | 			self terminateCommandsWith: ((Promise terminateSignal newException) setSignal: Promise terminateSignal; parameter: exc; errorString: nil).			exc return]]</body><body package="IMAP">terminateCommandsWith: exception 	commandsInProgress do: [:command | command terminateWithException: exception]</body></methods><methods><class-id>Net.IMAPProtocolInterpreter</class-id> <category>constants and defaults</category><body package="IMAP">defaultCommandPrefix	^'imapv4_'</body><body package="IMAP">defaultResponseClass	^ IMAPResponse</body></methods><methods><class-id>Net.IMAPProtocolInterpreter</class-id> <category>responses</category><body package="IMAP">getResponse	| resp | 	^ [	resp := self defaultResponseClass readFrom: self responseStream. 		self log: ['S: ' , resp printLog] level: #IMAPServer.		resp]	on: OsInaccessibleError	do: 	[:ex |  			self terminateCommandsWith: ex.			self disconnect.			NetClientError signalWith: #connection message: (#ServerIsNotAccessible &lt;&lt; #net &gt;&gt; 'Server is not accessible.')]</body><body package="IMAP">handle: aResponse	^self client handle: aResponse</body><body package="IMAP">handleNextResponse	| resp |	resp := self getResponse.	self lookAtResponse: resp.	commandsInProgress 			detect: [:command | command handle: resp]			ifNone: [self handle: resp]</body><body package="IMAP">lookAtResponse: resp 	"Some responses must be recorded at all times. Insert logic here"	self client handle: resp</body></methods><methods><class-id>Net.IMAPProtocolInterpreter</class-id> <category>updating</category><body package="IMAP">liveAcrossSnapshot	^false</body><body package="IMAP">update: aSymbol	"Dependents of ObjectMemory are sent update: 	#returnFromSnapshot when a snapshot is started."	self liveAcrossSnapshot		ifTrue:			[aSymbol == #returnFromSnapshot				ifTrue: [self disconnect].			"(aSymbol == #aboutToSnapshot or: [aSymbol == #aboutToQuit])				ifTrue: [self closeConnection]."].	super update: aSymbol</body></methods><methods><class-id>Net.IMAPProtocolInterpreter</class-id> <category>connection management</category><body package="IMAP">connectToHost: hostName port: portNumber timeout: tmNumber	self resetCommandSequence.	super connectToHost: hostName port: portNumber timeout: tmNumber.	self connectionIsReady.	self getResponse.</body><body package="IMAP">disconnect	super disconnect.	readResponseSignal terminateProcess.	self connectionIsClosed</body></methods><methods><class-id>Net.IMAPProtocolInterpreter</class-id> <category>initialize-release</category><body package="IMAP">initialize	super initialize.	connectionMutex := Semaphore forMutualExclusion.	readResponseSignal := Semaphore new.	commandsInProgress := OrderedCollection new: 4.	commandSequencer := IMAPCommandSequencer newPrefix: self defaultCommandPrefix.	self responseReaderLoop fork.</body><body package="IMAP">release	self disconnect.</body></methods><methods><class-id>Net.IMAPProtocolInterpreter</class-id> <category>public</category><body package="IMAP">executeCommand: aCommand 	aCommand sequenceID isNil 		ifTrue: [aCommand sequenceID: self nextCommandSequenceNumber].	self class log: ['----------------------------------'] 	level: #IMAPClient. 	self class log: ['C: ' , aCommand printString] level: #IMAPClient.	^[ connectionMutex critical: 	[ aCommand execute ]] 		on: OsInaccessibleError		do: 	[:ex |  			self terminateCommandsWith: ex.			aCommand terminateWithException: ex.			self disconnect.			NetClientError signalWith: #connection message: (#ServerIsNotAccessible &lt;&lt; #net &gt;&gt; 'Server is not accessible.').			ex return: aCommand]</body></methods><methods><class-id>Net.IMAPProtocolInterpreter class</class-id> <category>debugging</category><body package="IMAP">debugLabelsAndValues	^OrderedCollection new		add: ((#IMAPClientMessages &lt;&lt; #net &gt;&gt; 'IMAP Client Messages')-&gt;#IMAPClient);		add: ((#IMAPServerMessages &lt;&lt; #net &gt;&gt; 'IMAP Server Messages')-&gt;#IMAPServer);		yourself</body><body package="IMAP">menuItemName	^(#IMAPClientMessages &lt;&lt; #net &gt;&gt; 'IMAP Client Messages')</body></methods><methods><class-id>Net.IMAPProtocolInterpreter class</class-id> <category>class initialization</category><body package="IMAP">initialize	"self initialize."	self registerToDebug</body><body package="IMAP">obsolete	self unregisterFromDebug.	super obsolete.</body></methods><methods><class-id>Net.IMAPProtocolInterpreter class</class-id> <category>default values</category><body package="IMAP">defaultNetConnectionValue	^IMAPConnection</body><body package="IMAP">settings		^IMAPSettings</body></methods><methods><class-id>Net.HostSpec class</class-id> <category>instance creation</category><body package="IMAP">imap: host user: user	^self protocol: #IMAP host:  host user: user</body><body package="IMAP">imap: host username: username password: password	^self protocol: #IMAP host: host username: username password: password</body></methods><initialize><class-id>Net.IMAPMailbox</class-id></initialize><initialize><class-id>Net.IMAPCommand</class-id></initialize><initialize><class-id>Net.IMAPClient</class-id></initialize><initialize><class-id>Net.IMAPScanner</class-id></initialize><initialize><class-id>Net.IMAPStreamEncoder</class-id></initialize><initialize><class-id>Net.IMAPProtocolInterpreter</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>NetClient</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>user hostName portNumber clientPI state </inst-vars><class-inst-vars>defaultProtocolInterpreterClass </class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><class><name>NetClientState</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>client </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><class><name>NetConnection</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream settings </inst-vars><class-inst-vars>encoding </class-inst-vars><imports>			private OS.IOConstants.*			</imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><class><name>NetError</name><environment>Net</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><class><name>Mailbox</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>user server lastMessage keepMail deleteMail deliveryQueue pollingProcess delaySemaphore sync settingsSync connection certificateWarningBlock </inst-vars><class-inst-vars>certificateWarningBlock </class-inst-vars><imports></imports><category>Net-Mail</category><attributes><package>Mail</package></attributes></class><class><name>UTF7StreamEncoder</name><environment>Net</environment><super>Protocols.Base64StreamEncoder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>shifting specialCharacters </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><class><name>NetClientError</name><environment>Net</environment><super>Net.NetError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><class><name>NetPISettings</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tlsContext tlsSubjectVerifier retries timeout delaySeconds </inst-vars><class-inst-vars>defaultDelaySeconds defaultRetries defaultTimeout </class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class><class><name>MessageScanner</name><environment>Net</environment><super>Net.SimpleScanner</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>MIME</package></attributes></class><class><name>NetProtocolInterpreter</name><environment>Net</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>connection settings </inst-vars><class-inst-vars>defaultNetConnection </class-inst-vars><imports></imports><category>Net-Clients</category><attributes><package>NetClientBase</package></attributes></class></st-source>