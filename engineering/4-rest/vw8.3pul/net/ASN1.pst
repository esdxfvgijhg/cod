<?xml version="1.0"?><st-source><!-- Name: ASN1Notice: Copyright 1999-2017 Cincom Systems, Inc.  All rights reserved.Comment: This package implements encoding/decoding machinery aimed at two most commong ASN.1 encodings, BER and DER. The framework supports two modes of marshaling (1) type-in-hand marshaling and (2) type-agnostic or raw marshaling. The former is the usual way, because the meta-information represented by the type instances is often necessary to follow the structure of the encoding. In this mode the application provides the root type to use to marshal/unmarshal an object to/from a stream. The API for this mode is #marshalObject:withType: and #unmarshalObjectType:. The "raw" mode can be used for investigation of an encoding produced by an unknown ASN.1 application or to marshal a smalltalk object using a sort of default Smalltalk-to-ASN.1 mapping. This mode will usually be only useful during development and prototyping. The API for this mode is #marshalObject and #unmarshalObject.The marshaling streams (TLVStream hierarchy) can be customized via pluggable EncodingPolicy. The policy will receive callbacks from the stream during the marshaling/unmarshaling process as it follows the driving type structure. The policy can be used for various purposes. This package includes a RetainEncodings policy which will capture the bytes representing particular objects in the structure being (un)marshaled. Another example is the PrettyPrinter encoding which produces an indented textual representation of the encoded contents onto a text stream.LIMITATIONS:	- tags encoded in multiple bytes will probably cause problems	- exception markers are ignored	- some valid BER encodings may not work (indefinite lenght is not supported, etc)	- marshaling of some of the string types, REAL and RELATIVE_OID are not yet supported (see 'encoding/decoding - unimplemented' protocols on BERStreamDefinite)Copyright: Copyright (c) 2004-2005 Cincom Systems, Inc.All Rights ReservedDbIdentifier: bear73DbTrace: 500241DbUsername: tkoganDbVersion: 8.3 - 1DevelopmentPrerequisites: #(#(#package 'ASN1-Types' '') #(#any 'AT MetaNumerics' ''))PackageName: ASN1Parcel: #('ASN1')ParcelName: ASN1PrerequisiteParcels: #(#('ASN1-Types' '') #('AT MetaNumerics' ''))PrintStringCache: (8.3 - 1,tkogan)Version: 8.3 - 1Date: 3:07:41 PM April 21, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (apr17.2) of April 21, 2017 on April 21, 2017 at 3:07:41 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>EncodingPolicy</name><environment>ASN1</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>marshaler </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.EncodingPolicy</class-id><body>This is the abstract superclass for all encoding policies. It enumerates all the interception points where the policies have a chance to act. Its instance can also be used as a dummy policy that takes no actions at all.Instance Variables:	marshaler	&lt;Asn1Stream&gt; </body></comment><class><name>TLVStream</name><environment>ASN1</environment><super>Core.Stream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream </inst-vars><class-inst-vars>tagDispatchTable </class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.TLVStream</class-id><body>TLVStream is an abstract class.  It is the superclass of the marshaling streams for messages employing ASN.1 encoding rules.  The implementation tacitly presupposes that lengths will never be in BER indefinite form, and is otherwise slanted toward BER and DER.  A radically different encoding, like PER, might motivate a more abstract superclass.Instance Variables:	stream	&lt;PositionableStream&gt; underlying byte stream that we read/writeClass Instance Variables:	tagDispatchTable	&lt;Array | UndefinedObject&gt; tag dispatch table for decoding</body></comment><class><name>BERStreamBasic</name><environment>ASN1</environment><super>ASN1.TLVStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>encodingPolicy inImplicitTag utcSliding utcRoundMilliseconds shortTime timezone </inst-vars><class-inst-vars>defaultEncodingPolicy defaultUTCSliding defaultUTCRoundMilliseconds defaultShortTime defaultTimezone </class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.BERStreamBasic</class-id><body>This class is a BER encoding/decoding stream that assumes (1) that lengths will be stored in three bytes and (2) that tags will be one byte.  It is expected to be a suitable superclass for an SNMP encoder/decoder.It also adds machinery for the retention and use of encodings during type-in-hand encoding and decoding.  Note that said machinery is not invoked in type-agnostic marshaling.Instance Variables:	encodingPolicy	&lt;EncodingPolicy&gt; controls the stream behavior with regards to objec encodings; retention, logging, etc.	inImplicitTag	&lt;Boolean&gt; private flag, indicates if we are in the process of encoding an implicit tag	utcSliding	&lt;Boolean&gt; are the 2 digit years interpreted in a "sliding window" manner or fixed to 1950-2049	utcRoundMilliseconds	&lt;Boolean&gt; should the timestamp milliseconds be rounded or turncated for UTCTime	shortTime	&lt;Boolean&gt; should encode timestamps omitting superfluous zero minutes/seconds if permitted	timezone	&lt;TimeZone&gt; the timezone to use for Timestamp conversionsClass Instance Variables:	defaultEncodingPolicy	&lt;Behavior&gt; the default policy for streams of given class	defaultUTCSliding	&lt;Boolean&gt; are the 2 digit years interpreted in a "sliding window" manner or fixed to 1950-2049	defaultUTCRoundMilliseconds	&lt;Boolean&gt; should the timestamp milliseconds be rounded or turncated for UTCTime	defaultShortTime	&lt;Boolean&gt; should encode timestamps omitting superfluous zero minutes/seconds if permitted	defaultTimezone	&lt;TimeZone&gt; the timezone to use for Timestamp conversions</body></comment><class><name>BERStreamDefinite</name><environment>ASN1</environment><super>ASN1.BERStreamBasic</super><private>false</private><indexed-type>none</indexed-type><inst-vars>scratchBuffer utf8 ucs2 </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.BERStreamDefinite</class-id><body>This class is a BER encoding/decoding stream that assumes (1) that lengths are 'definitely' encoded in one or more bytes and (2) that tags may be more than one byte.  It is intended to be a suitable superclass for a DER encoder/decoder.Instance Variables:	scratchBuffer	&lt;PositionableStream&gt; used to encode lengths	utf8	&lt;StreamEncoder&gt; caches an encoder for UTF8, used for UTF8Strings	ucs2	&lt;StreamEncoder&gt; caches and encoder of UCS-2, used for BMPStrings</body></comment><class><name>DERStream</name><environment>ASN1</environment><super>ASN1.BERStreamDefinite</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.DERStream</class-id><body>Asn1StreamDER is an encoder/decoder for DER encoding.</body></comment><class><name>RetainEncodings</name><environment>ASN1</environment><super>ASN1.EncodingPolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars>currentEncoding encodingStack source </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.RetainEncodings</class-id><body>This encoding policy implements retention and use of encodings in type-specific manner. It is activated by sending an Asn1Type the message 'retainEncoding: true'.  The retention of encodings is important is some security applications, where, for example, the encoding of a certificate should be stored, and never programatically regenerated.  Retention is also a useful optimization for frequently transmitted objects.  Note that the encodings of Asn1OIDs are always retained, and that Asn1OIDs are not affected by the machinery implemented in this class, which is intended for user-defined types employed in standard, uncustomized marshalers.Instance Variables:	currentEncoding	&lt;Asn1Encoding&gt; the current encoding	encodingStack	&lt;OrderedCollection&gt; a stack for managing encodings	source	&lt;Collection&gt; a copy of the entire source encoding</body></comment><class><name>RetainAllEncodings</name><environment>ASN1</environment><super>ASN1.RetainEncodings</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.RetainAllEncodings</class-id><body>This policy retains all encodings regardless of the 'retainEncoding' setting of specific types.</body></comment><class><name>MarshalingError</name><environment>ASN1</environment><super>ASN1.Asn1Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.MarshalingError</class-id><body>An Asn1ExcMarshaling is raised when a marshaling error is detected during encoding or decoding.</body></comment><class><name>UTCTimeRange</name><environment>ASN1</environment><super>ASN1.MarshalingError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.UTCTimeRange</class-id><body>This error is raised on attempt to marshal a Timestamp outside of the current UTCTime range.</body></comment><class><name>PrettyPrinter</name><environment>ASN1</environment><super>ASN1.RetainEncodings</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream indent offsets </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.PrettyPrinter</class-id><body>This policy pretty-prints the decoded entities onto the 'stream' as it unmarshals them.Instance Variables:	stream	&lt;WriteStream&gt; the stream to print to	indent	&lt;Integer&gt; current indentation level	offsets	&lt;Boolean&gt; should print offsets of entities</body></comment><class><name>TagUnknown</name><environment>ASN1</environment><super>ASN1.MarshalingError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.TagUnknown</class-id><body>An Asn1ExcUnknownTag is raised when an unknown type tag is encountered.</body></comment><class><name>TagMismatch</name><environment>ASN1</environment><super>ASN1.MarshalingError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1</package></attributes></class><comment><class-id>ASN1.TagMismatch</class-id><body>This error is raised when a tag encountered during decoding doesn't match the expected tag.</body></comment><methods><class-id>ASN1.EncodingPolicy</class-id> <category>decoding</category><body package="ASN1">decodeBeginBodyType: anAsn1Type</body><body package="ASN1">decodeBeginType: anAsn1Type</body><body package="ASN1">decodeEnd: anObject type: anAsn1Type	^anObject</body><body package="ASN1">unmarshalObjectType: anAsn1Type</body></methods><methods><class-id>ASN1.EncodingPolicy</class-id> <category>encoding</category><body package="ASN1">encodeBegin: anObject type: anAsn1Type</body><body package="ASN1">encodeBeginBody: anObject type: anAsn1Type</body><body package="ASN1">encodeEnd: anObject type: anAsn1Type	^anObject</body><body package="ASN1">marshalObject: anObject withType: anAsn1Type</body><body package="ASN1">shiftCurrentBodyStartBy: anInteger</body></methods><methods><class-id>ASN1.EncodingPolicy</class-id> <category>accessing</category><body package="ASN1">marshaler: anAsn1Stream	marshaler := anAsn1Stream</body></methods><methods><class-id>ASN1.EncodingPolicy class</class-id> <category>instance creation</category><body package="ASN1">marshaler: anAsn1Stream	^self new		marshaler: anAsn1Stream;		yourself</body></methods><methods><class-id>ASN1.TLVStream</class-id> <category>decoding - utility</category><body package="ASN1">peekTag	| start |	start := self position.	^[ self nextTag ] ensure: [ self position: start ]</body><body package="ASN1">raiseUnknownTagException	 TagUnknown 		raiseRequestErrorString: (#UnknownTag &lt;&lt; #asn1 &gt;&gt; 'Unknown tag!')</body><body package="ASN1">tagDispatchWith: anInteger	"... to be re-rigged with a proceedable exception."	^[ self class tagDispatchTable at: anInteger ]		on: SubscriptOutOfBoundsError		do: [ :ex | self raiseUnknownTagException ]</body></methods><methods><class-id>ASN1.TLVStream</class-id> <category>decoding - api</category><body package="ASN1">decodeTLV	"... a recursive entry point, not to be invoked without 'local knowledge'."	^( self tagDispatchWith: self nextTag )		value: self nextLength		value: self</body><body package="ASN1">nextLength	"... the method to be directly invoked in decoding APIs.  The implementation may vary depending on the length encoding in use."	self subclassResponsibility</body><body package="ASN1">nextTag	"... the method to be directly invoked in decoding APIs.  The implementation may vary depending on the tag encoding in use."	^self subclassResponsibility</body><body package="ASN1">unmarshalObject	"... the default, top-level, decoding entry point, for type-agnostic decoding."	^[ self decodeTLV ]		on:	Error		do:	[ :ex | MarshalingError raiseSignal: ex errorString ]</body><body package="ASN1">unmarshalObjectType: anAsn1Type	"... the default, top-level, entry point for type-in-hand decoding.  Sets up for encoding retention.  Note that since, at this point, we do not know how much of the 'collection' is taken up by the encoding, the entire 'collection; is retained as the 'source'."	^[ anAsn1Type decodeWith: self ]		on:	Error		do:	[ :ex | MarshalingError raiseSignal: ex errorString ]</body></methods><methods><class-id>ASN1.TLVStream</class-id> <category>testing</category><body package="ASN1">canRetainEncodingWhileMarshaling	^true</body><body package="ASN1">requiresEncodingSort	self subclassResponsibility</body><body package="ASN1">requiresTagSort	self subclassResponsibility</body></methods><methods><class-id>ASN1.TLVStream</class-id> <category>decoding - private</category><body package="ASN1">decodeTaglessWith: aType	self subclassResponsibility</body><body package="ASN1">decodeWith: aType	self subclassResponsibility</body><body package="ASN1">decodeWith: aType explicitTag: aTag	self subclassResponsibility</body><body package="ASN1">decodeWith: aType implicitTag: aTag	self subclassResponsibility</body></methods><methods><class-id>ASN1.TLVStream</class-id> <category>encoding - api</category><body package="ASN1">encodeTLV: anObject	"... a recursive entry point, not to be invoked without 'local knowledge'."	self subclassResponsibility</body><body package="ASN1">marshalObject: anObject	"... the top-level entry point for type-agnostic encoding."	[ self encodeTLV: anObject ]		on:	Error		do:	[ :ex | MarshalingError raiseSignal: ex errorString ]</body><body package="ASN1">marshalObject: anObject withType: anAsn1Type	"... the top-level entry point for type-in-hand encoding."	[ anAsn1Type encode: anObject with: self ]		on:	Error		do:	[ :ex | MarshalingError raiseSignal: ex errorString ]</body></methods><methods><class-id>ASN1.TLVStream</class-id> <category>encoding - private</category><body package="ASN1">encode: anObject with: aType	self subclassResponsibility</body><body package="ASN1">encode: anObject with: aType explicitTag: anInteger	self subclassResponsibility</body><body package="ASN1">encode: anObject with: aType implicitTag: anInteger	self subclassResponsibility</body></methods><methods><class-id>ASN1.TLVStream</class-id> <category>initialize-release</category><body package="ASN1">wrap: aStream	stream := aStream</body></methods><methods><class-id>ASN1.TLVStream</class-id> <category>private</category><body package="ASN1">collection"used by RetainEncodings policy"	^stream collection</body><body package="ASN1">position	^stream position</body><body package="ASN1">position: anInteger	^stream position: anInteger</body></methods><methods><class-id>ASN1.TLVStream</class-id> <category>accessing - stream</category><body package="ASN1">atEnd	^stream atEnd</body><body package="ASN1">contents	^stream contents</body><body package="ASN1">next	^stream next</body><body package="ASN1">nextPut: aByte	^stream nextPut: aByte</body><body package="ASN1">reset	stream reset</body></methods><methods><class-id>ASN1.TLVStream class</class-id> <category>class initialization</category><body package="ASN1">initialize	"((( self initialize )))"	self initializeTagDispatchTable.</body><body package="ASN1">initializeTagDispatchTable	"Initialize the tag table used for unmarshaling or decoding."	self tagDispatchTable: nil.</body></methods><methods><class-id>ASN1.TLVStream class</class-id> <category>accessing</category><body package="ASN1">tagDispatchTable	^tagDispatchTable</body><body package="ASN1">tagDispatchTable: anObject	tagDispatchTable := anObject</body></methods><methods><class-id>ASN1.TLVStream class</class-id> <category>instance creation</category><body package="ASN1">on: aCollection 	^self wrap: (ReadWriteStream on: aCollection)</body><body package="ASN1">with: aCollection 	^self wrap: (ReadWriteStream with: aCollection)</body><body package="ASN1">wrap: aStream	^self basicNew wrap: aStream</body></methods><methods><class-id>ASN1.BERStreamBasic</class-id> <category>decoding - tagged types</category><body package="ASN1">decodeBOOLEAN: anInteger	^( self next == 0 ) not</body><body package="ASN1">decodeENUMERATED: anInteger	"We elect to decode as an INTEGER unless we have a type in hand."	^self decodeINTEGER: anInteger	"^Asn1ImportedEnumeration		type: Asn1TypeENUMERATED default		value: ( self decodeINTEGER: anInteger )"</body><body package="ASN1">decodeINTEGER: anInteger	"Pick off the first octet.  Test for a negative.  Pick off the remaining octets.  Finish off if negative."	| oct val negative m |	val := 0.	oct := self next.	negative := oct allMask: 2r10000000.	val := oct.	( anInteger - 1 ) timesRepeat:			[	oct := self next.				val := ( val bitShift: 8 ) + oct			].	( negative )		ifTrue:	[	val := val - 2r00000001.					m := ( 2 raisedTo: ( 8 * val digitLength ) ) - 1.					val := val bitXor: m.					val := val negated.				].	^val</body><body package="ASN1">decodeNULL: anInteger	^nil</body><body package="ASN1">decodeOBJECT_IDENTIFIER: anInteger	"Record the starting position, so that the encoding may be cached if necessary. Estimate the size assuming that two OID elements are encoded in the first byte and that all subsequent OID elements consume only one byte.  Then read.  (The first two branch identifiers are packed into the first octet.  Some of the decoding logic is repetative, but I'd rather inline.)  Trim the array if necessary when done.  Preserve object identity.  Then, always cache the encoding if we do not already have it."	| ipos estimatedSize reads size array val id oct oid tpos enc |	ipos := self position.	estimatedSize := anInteger + 1.	reads := 0.	size := 0.		array := Array new: estimatedSize.	val := 0.	[ reads := reads + 1. ( oct := self next ) &gt; 127 ]		whileTrue:	[ val := ( val bitShift: 7 ) + ( oct bitAnd: 02r1111111 ) ].	val := ( val bitShift: 7 ) + oct.	size := size + 1.	array at: size put: val // 40.	( ( id := val rem: 40 ) ~~ 0 )		ifTrue:	[ size := size + 1. array at: size put: id ].	[ anInteger &gt; reads ]		whileTrue:	[	val := 0.						[ reads := reads + 1. ( oct := self next ) &gt; 127 ]							whileTrue:	[ val := ( val bitShift: 7 ) + ( oct bitAnd: 02r1111111 ) ].						val := ( val bitShift: 7 ) + oct.						size := size + 1.						array at: size put: val					].	array := self trimCollection: array ofSize: estimatedSize toSize: size.	oid := ObjectIdentifier value: array.		"--- creation method preserves object identity ---"	( oid encoding isNil )		ifTrue:	[	tpos := self position.					self position: ipos.					enc := self							next: ( tpos - ipos )							into: ( ByteArray new: ( tpos - ipos ) )							startingAt: 1.					oid encoding: enc.					self position: tpos				].	^oid</body><body package="ASN1">decodeOCTET_STRING: anInteger	| ba  |	ba := ByteArray new: anInteger.	1 to: anInteger do: [ :x | ba at: x put: self next ].	^ba</body><body package="ASN1">decodeSEQUENCEorSEQUENCE_OF: anInteger	"Note that we use a higher than usual default estimate for the size of the OrderedCollection." 	| col tpos |	col := OrderedCollection new: 11.	tpos := self position + anInteger.	[ self position &lt; tpos ]		whileTrue: [ col add: self decodeTLV ].	^col</body><body package="ASN1">decodeSETorSET_OF: anInteger	"Note that we use a higher than usual default estimate for the size of the OrderedCollection." 	| col tpos |	col := OrderedCollection new: 11.	tpos := self position + anInteger.	[ self position &lt; tpos ]		whileTrue: [ col add: self decodeTLV ].	^col</body><body package="ASN1">decodeVisibleString: anInteger	"... equals 'decodeOCTET_STRING:'."	| ba  |	ba := ByteArray new: anInteger.	1 to: anInteger do: [ :x | ba at: x put: self next ].	^ba asString</body></methods><methods><class-id>ASN1.BERStreamBasic</class-id> <category>encoding - tagged types</category><body package="ASN1">encodeBOOLEAN: aBoolean	"... use the primitive form for 'true' that is optional for BER but required by DER."	( aBoolean )		ifTrue:	[ self nextPut: 02r11111111 ]		ifFalse:	[ self nextPut: 02r00000000 ]</body><body package="ASN1">encodeENUMERATED: anInteger"Note that ENUMERATEDs may use negative integers and that 'Enumeration&gt;&gt;_value' is assumed to return anInteger."	self encodeINTEGER: anInteger</body><body package="ASN1">encodeINTEGER: anInteger	"Note the test using 'allMask:'.  If a positive integer's high order bit is 1, an all-zero octet is written. If a negative integer's high order bit is 1, we extend the size of the mask to get the correct two's complement."	"((( ( Asn1StreamBER on: ( ByteArray new: 2 ) ) encodeINTEGER: 27066 )))"	"((( ( Asn1StreamBER on: ( ByteArray new: 2 ) ) encodeINTEGER: -27066 )))"	| n l m |	n := anInteger.	l := n digitLength.	( n negative )		ifTrue:	[	( ( n digitAt: l ) allMask: 2r10000000 )						ifTrue: [ l := l + 1 ].					m := ( 2 raisedTo: ( 8 * l ) ) - 1.					n := ( anInteger bitXor: m abs ) + 2r00000001.			 	]		ifFalse:	[	( ( n digitAt: l ) allMask: 2r10000000 )						ifTrue: [ self nextPut: 0 ]				].	n digitLength to: 1 by: -1 do: 		[ :ndx | self nextPut: ( n digitAt: ndx ) ]</body><body package="ASN1">encodeNULL	"Do nothing.  An ASN.1 NULL is encoded solely by its tag."</body><body package="ASN1">encodeOBJECT_IDENTIFIER: anAsn1ImportedOID	"Check for a stored encoding.  ....."	| enc ipos val tpos |	"--- write out the stored encoding if possible ---"	( ( enc := anAsn1ImportedOID encoding ) notNil )		ifTrue:	[ ^self nextPutAll: enc ].	"--- otherwise, do the work ---"	ipos := self position.	val := anAsn1ImportedOID value.	"--- first two arcs encoded in first byte ---"	self nextPut: ( ( val at: 1 ) * 40 + ( val at: 2 ) ).	"--- subsequent arcs encoded one per byte ---"	3 to: val size do:		[ :ndx |	| int bitndx places |				int := val at: ndx.				bitndx := int highBit.				places := bitndx - 1 // 7.				places * -7 to: -7 by: 7 do:  [ :i  || nib |					nib := int bitShift: i.					nib := nib bitAnd: 02r1111111. 					self nextPut: ( nib bitOr: 02r10000000 ) ].				self nextPut: ( int bitAnd: 02r1111111 )		].	"--- store encoding ---"	tpos := self position.	self position: ipos.	enc := self			next: ( tpos - ipos )			into: ( ByteArray new: ( tpos - ipos ) )			startingAt: 1.	anAsn1ImportedOID encoding: enc.	self position: tpos</body><body package="ASN1">encodeOCTET_STRING: anObject	anObject asByteArray do: [ :x | self nextPut: x ]</body><body package="ASN1">encodeSEQUENCEorSEQUENCE_OF: aSequenceableCollection	"Note that this method is used when there is no 'type-in-hand'.  Marshaling without type information is dangerous and error-prone in the case of SEQUENCEs, which may contain objects of multiple types, OPTIONAL values, EXTENSION markers, and DEFAULT values that a receiver is expected to fill in if they have not been transmitted."	aSequenceableCollection do: [ :o | self encodeTLV: o ].</body><body package="ASN1">encodeSETorSET_OF: aBag	"Note that this method is used when there is no 'type-in-hand'. Marshaling without type information is dangerous and error-prone in the case of SETs, which may contain objects of multiple types transmitted in arbitrary order, OPTIONAL values, EXTENSION markers, and DEFAULT values that a receiver is expected to fill in if they have not been transmitted."	aBag do: [ :o | self encodeTLV: o ].</body><body package="ASN1">encodeVisibleString: aByteString	"... equals 'encodeOCTET_STRING:'."	aByteString asByteArray do: [ :x | self nextPut: x ]</body></methods><methods><class-id>ASN1.BERStreamBasic</class-id> <category>private</category><body package="ASN1">inImplicitTag	^inImplicitTag</body><body package="ASN1">inImplicitTag: anObject	inImplicitTag := anObject</body><body package="ASN1">notImplemented	self error: (#NotImplemented &lt;&lt; #asn1 &gt;&gt; 'This function has not been implemented in this release.')</body></methods><methods><class-id>ASN1.BERStreamBasic</class-id> <category>encoding - private</category><body package="ASN1">encode3ByteDefiniteLength: anInteger	self nextPut: 02r10000010.	( anInteger digitLength == 2 )		ifTrue:	[ self nextPut: ( anInteger digitAt: 2 ) ]		ifFalse: [ self nextPut: 0 ].	self nextPut: ( anInteger digitAt: 1 )</body><body package="ASN1">encode: anObject with: aType"Called when aType doesn't have a tag. This is also called for root (default) types as those aren't tagged either."	aType parent		ifNil: [ aType canEncodeValue				ifTrue: [ inImplicitTag						ifTrue: [ inImplicitTag := false.							aType encodeBody: anObject with: self ]						ifFalse: [ self nextPut: anObject with: aType tag: aType tagBER ] ]				ifFalse: [ self encodeTagless: anObject with: aType ] ]		ifNotNil: [ :parent | parent encode: anObject with: self ]</body><body package="ASN1">encode: anObject with: aType explicitTag: anInteger"Called when aType has a tag."	inImplicitTag := false.	self	nextPut: anObject		with: aType		tag: ( anInteger bitOr: ConstructedForm )</body><body package="ASN1">encode: anObject with: aType implicitTag: anInteger"Called when aType has a tag.X.690-0207.pdf8.14.3 If implicit tagging was used in the definition of the type, then:a) the encoding shall be constructed if the base encoding is constructed, and shall be primitive otherwise;andb) the contents octets shall be the same as the contents octets of the base encoding."	inImplicitTag		ifTrue: [ self encode: anObject with: aType ]		ifFalse: [ inImplicitTag := true.			self	nextPut: anObject				with: aType				tag: (anInteger bitOr: PrimitiveForm) ]</body><body package="ASN1">encodeTagless: anObject with: anAsn1Type" ... for CHOICE and ANY types"	encodingPolicy encodeBegin: anObject type: anAsn1Type.	encodingPolicy encodeBeginBody: anObject type: anAsn1Type.	anAsn1Type encodeDelegate: anObject with: self.	^encodingPolicy encodeEnd: anObject type: anAsn1Type.</body><body package="ASN1">nextPut: anObject with: aType tag: anInteger	| end |	encodingPolicy encodeBegin: anObject type: aType.	self nextPutTag: anInteger.	self nextPutLengthAndDo: [		encodingPolicy encodeBeginBody: anObject type: aType.		(self isUniversal: anInteger)			ifTrue: [ inImplicitTag := false.				aType encodeBody: anObject with: self ]			ifFalse: [ self encode: anObject with: aType ].		end := self position ].	self position = end ifFalse: [ encodingPolicy shiftCurrentBodyStartBy: (self position - end) ].	encodingPolicy encodeEnd: anObject type: aType.</body><body package="ASN1">nextPutLengthAndDo: aBlock	| lpos vpos |	lpos := self position.	self nextPutAll: #[ 0 0 0 ].  "skip: 3"	aBlock value.	vpos := self position.	self position: lpos.	self encodeLength: vpos - lpos - 3.	self position: vpos</body><body package="ASN1">nextPutTag: anInteger	self nextPut: anInteger</body></methods><methods><class-id>ASN1.BERStreamBasic</class-id> <category>testing</category><body package="ASN1">isConstructedForm: anInteger	^(anInteger bitAnd: ConstructedForm) = ConstructedForm</body><body package="ASN1">isUniversal: anInteger	^(TagMaskClass bitAnd: anInteger) = UniversalClass</body><body package="ASN1">requiresEncodingSort	^false</body><body package="ASN1">requiresTagSort	^false</body></methods><methods><class-id>ASN1.BERStreamBasic</class-id> <category>accessing</category><body package="ASN1">encodingPolicy	^encodingPolicy</body><body package="ASN1">encodingPolicy: aPolicy"	aPolicy &lt;EncodingPolicy&gt; controls the stream behavior with regards to objec encodings; retention, logging, etc."	encodingPolicy := aPolicy.	aPolicy marshaler: self</body><body package="ASN1">shortTime"	^&lt;Boolean&gt; should encode timestamps omitting superfluous zero minutes/seconds if permitted"	^shortTime ifNil: [ self class defaultShortTime ]</body><body package="ASN1">shortTime: short"	short &lt;Boolean&gt; should encode timestamps omitting superfluous zero minutes/seconds if permitted"	shortTime := short</body><body package="ASN1">timezone"	^&lt;TimeZone&gt; the timezone to use for Timestamp conversions"	^timezone ifNil: [ self class defaultTimezone ]</body><body package="ASN1">timezone: tz"	tz &lt;TimeZone&gt; the timezone to use for Timestamp conversions"	timezone := tz</body><body package="ASN1">utcRoundMilliseconds"	^&lt;Boolean&gt; should the timestamp milliseconds be rounded or turncated for UTCTime"	^utcRoundMilliseconds ifNil: [ self class defaultUTCRoundMilliseconds ]</body><body package="ASN1">utcRoundMilliseconds: round"	round &lt;Boolean&gt; should the timestamp milliseconds be rounded or turncated for UTCTime"	utcRoundMilliseconds := round</body><body package="ASN1">utcSliding"	^&lt;Boolean&gt; are the 2 digit years of UTCTime interpreted in a 'sliding window' manner or fixed to 1950-2049"	^utcSliding ifNil: [ self class defaultUTCSliding ]</body><body package="ASN1">utcSliding: slide"	slide &lt;Boolean&gt; are the 2 digit years of UTCTime interpreted in a 'sliding window' manner or fixed to 1950-2049"	utcSliding := slide</body></methods><methods><class-id>ASN1.BERStreamBasic</class-id> <category>decoding - private</category><body package="ASN1">decodeTaglessWith: aType	"... for CHOICE and ANY types only."	| res |	encodingPolicy decodeBeginType: aType.	encodingPolicy decodeBeginBodyType: aType.	res := aType decodeDelegateWith: self.	^encodingPolicy decodeEnd: res type: aType</body><body package="ASN1">decodeWith: aType	| tag len res |	aType parent ifNotNil: [ :parent | ^parent decodeWith: self ].	inImplicitTag		ifTrue: [ inImplicitTag := false ]		ifFalse: [ encodingPolicy decodeBeginType: aType.			tag  := self nextTag.			tag = (self asTag: aType tagBER) ifFalse: [ self tagMismatch: tag with: aType ] ].	len := self nextLength.	encodingPolicy decodeBeginBodyType: aType.	res := aType decodeValue: len with: self.	^encodingPolicy decodeEnd: res type: aType</body><body package="ASN1">decodeWith: aType explicitTag: aTag	| tag len res finishImplicitTag |	finishImplicitTag := false.	inImplicitTag ifTrue: [		inImplicitTag := false.		finishImplicitTag := true.		self nextLength.		encodingPolicy decodeBeginBodyType: aType ].	encodingPolicy decodeBeginType: aType.	tag  := self nextTag.	tag = (self asTag: aTag) ifFalse: [ self tagMismatch: tag with: aType ].	len := self nextLength.	encodingPolicy decodeBeginBodyType: aType.	res := aType parent		ifNil: [ (self isUniversal: aTag)				ifTrue: [ aType decodeValue: len with: self ]				ifFalse: [ aType canEncodeValue						ifTrue: [ self decodeWith: aType explicitTag: aType tagBER ]						ifFalse: [ aType decodeDelegateWith: self ] ] ]		ifNotNil: [ :parent | parent decodeWith: self length: len].	encodingPolicy decodeEnd: res type: aType.	finishImplicitTag ifTrue: [		encodingPolicy decodeEnd: res type: aType ].					^res</body><body package="ASN1">decodeWith: aType implicitTag: aTag	| tag len res |	^inImplicitTag		ifTrue: [			aType parent				ifNil: [ inImplicitTag := false.					len := self nextLength.					encodingPolicy decodeBeginBodyType: aType.					res := aType decodeValue: len with: self.					encodingPolicy decodeEnd: res type: aType ]				ifNotNil: [ :parent | parent decodeWith: self ] ]		ifFalse: [ inImplicitTag := true.			encodingPolicy decodeBeginType: aType.			tag  := self nextTag.			tag = (self asTag: aTag) ifFalse: [ self tagMismatch: tag with: aType ].			aType parent				ifNil: [ self decodeWith: aType implicitTag: aTag ]				ifNotNil: [ :parent | parent decodeWith: self ] ]</body><body package="ASN1">next3OctetDefiniteLength	"... not to be invoked directly in decoding APIs."	"... reads and forgets the first octet, assumed to be '02r10000010', that is, decimal 2 with the long-form bit on, and then processes the next two octets."	self next.	^( self next bitShift: 8 ) + self next</body><body package="ASN1">nextOctetTag	"... read a single octet tag."	"... not to be invoked directly in decoding APIs."	^self next</body><body package="ASN1">nextOctetTagMasked	"... read a single octet tag and masks the first three bits."	"... not to be invoked directly in decoding APIs."	^self asTag: self nextOctetTag</body></methods><methods><class-id>ASN1.BERStreamBasic</class-id> <category>decoding - utility</category><body package="ASN1">invalidLength: anInteger with:aType	MarshalingError new		messageText: (			#InvalidLength1p2p &lt;&lt; #asn1 &gt;&gt; 'Invalid length &lt;1p&gt; for type &lt;2p&gt;!'				expandMacrosWith: anInteger with: aType);		parameter: aType;		raise</body><body package="ASN1">missingElement: anElement with: aType	MarshalingError new		messageText: (			#MissingElement1s2p &lt;&lt; #asn1 &gt;&gt; 'Missing element &lt;1s&gt; in type &lt;2p&gt;!'				expandMacrosWith:anElement symbol with: aType);		parameter: aType;		raise</body><body package="ASN1">tagMismatch: aTag with: aType	TagMismatch new		messageText: (			#DecodingTagMismatch1p2p &lt;&lt; #asn1 &gt;&gt; 'Tag &lt;1p&gt; does not match type &lt;2p&gt;!'				expandMacrosWith: aTag with: aType);		parameter: aTag;		raise</body><body package="ASN1">trimCollection: aCollection ofSize: anInteger1 toSize: anInteger2	^( anInteger1 &gt; anInteger2 )		ifTrue:	[ aCollection copyFrom: 1 to: anInteger2 ]		ifFalse:	[ aCollection ]</body></methods><methods><class-id>ASN1.BERStreamBasic</class-id> <category>decoding - api</category><body package="ASN1">asTag: anInteger	"... a tag-related utility invoked in decoding APIs."	"... if required, masks anInteger, as required by the tag matching scheme in effect."	"... use constant to avoid namespace lookup."	^anInteger bitAnd: 02r00011111 "ASN1.TagMaskNumber"</body><body package="ASN1">nextLength	"... the method to be directly invoked in decoding APIs."	^self next3OctetDefiniteLength</body><body package="ASN1">nextTag	"... the method to be directly invoked in decoding APIs."	^self nextOctetTagMasked</body><body package="ASN1">peekNextTag	"... the method to be directly invoked in decoding APIs."	| start |	start := self position.	^[self nextOctetTag] ensure: [ self position: start ]</body><body package="ASN1">unmarshalObjectType: anAsn1Type	"... the default, top-level, entry point for type-in-hand decoding.  Sets up for encoding retention.  Note that since, at this point, we do not know how much of the 'collection' is taken up by the encoding, the entire 'collection; is retained as the 'source'."	encodingPolicy unmarshalObjectType: anAsn1Type.	^super unmarshalObjectType: anAsn1Type</body></methods><methods><class-id>ASN1.BERStreamBasic</class-id> <category>encoding - api</category><body package="ASN1">encodeLength: anInteger	"... the method to be directly invoked in encoding methods."	self encode3ByteDefiniteLength: anInteger</body><body package="ASN1">encodeTLV: anObject	"... a recursive entry point, not to be invoked without 'local knowledge'."	"... geared for the use of 3-octet definite lengths."	"... assumes anObject responds to both 'tagBER' and 'encodeASN1With:'."	| lpos vpos |	self nextPutTagFrom: anObject.	lpos := self position.	self nextPutAll: #[ 0 0 0 ].  "skip: 3"	anObject encodeASN1With: self.	vpos := self position.	self position: lpos.	self encodeLength: vpos - lpos - 3.	self position: vpos</body><body package="ASN1">marshalObject: anObject withType: anAsn1Type	"... the top-level entry point for type-in-hand encoding."	encodingPolicy marshalObject: anObject withType: anAsn1Type.	super marshalObject: anObject withType: anAsn1Type</body></methods><methods><class-id>ASN1.BERStreamBasic</class-id> <category>encoding - utility</category><body package="ASN1">nextPutTagFrom: anObject	"... should cover both SubclassResponsibilityError and MessageNotUnderstood."	"... assumes single-byte tags." 	[ self nextPut: anObject tagBER ]		on: SubclassResponsibilityError, MessageNotUnderstood		do: [ :ex | ex resignalAs: ( ( MarshalingError new )									messageText: (#TypeNotMarshalable &lt;&lt; #asn1 &gt;&gt; 'The type is not marshalable under ASN.1!');									parameter: ex parameter;									yourself ) ].</body></methods><methods><class-id>ASN1.BERStreamBasic</class-id> <category>initialize-release</category><body package="ASN1">wrap: aStream	super wrap: aStream.	encodingPolicy := self class defaultEncodingPolicy marshaler: self.	inImplicitTag := false.</body></methods><methods><class-id>ASN1.BERStreamBasic</class-id> <category>decoding - types - time</category><body package="ASN1">decodeGeneralizedTime: anInteger	| str date time offset seconds year month day ms |	str := EncodedStream on: stream encodedBy: (StreamEncoder new: #ascii).	year := ( str next: 4 ) asNumber.	month := ( str next: 2 ) asNumber.	day := ( str next: 2 ) asNumber.	date := Date newDay: day monthNumber: month year: year.	time := self decodeTimeFrom: str.	ms := ( str atEnd not and: [ '.,' includes: str peek ] )			ifTrue: [ self decodeMillisecondsFrom: str ]			ifFalse: [ 0 ].	(str atEnd or: [ ('Z+-' includes: str peek) not ]) ifTrue: [		^(Timestamp fromDate: date andTime: time)			addMilliseconds: ms ].	offset := self decodeTZOffsetFrom: str.	seconds := date asSeconds + time asSeconds - (offset * 60).	^(self timezone		convertGMT: seconds		do: [ :localDate :localSeconds | Timestamp fromDate: localDate andTime: (Time fromSeconds: localSeconds) ]	)	addMilliseconds: ms</body><body package="ASN1">decodeMillisecondsFrom: aStream	| digits ms |	aStream next. "drop the dot or comma"	ms := 0.	digits := 0.	[ aStream atEnd or: [ 'Z+-' includes: aStream peek ] ] whileFalse: [		ms := ms * 10 + (aStream next asInteger - "$0 asInteger" 48).		digits := digits + 1 ].	^(ms * (10 ** ( 3 - digits ))) truncated</body><body package="ASN1">decodeTZOffsetFrom: aStream	| sign offset |	sign := aStream next.	sign = $Z ifTrue: [ ^0].	offset := ( aStream next: 2 ) asNumber * 60.	(aStream atEnd not and: [ aStream peek isDigit ])		ifTrue: [ offset := offset + ( aStream next: 2 ) asNumber ].	^sign = $- ifTrue: [ offset negated ] ifFalse: [ offset ]</body><body package="ASN1">decodeTimeFrom: aStream	| hr mn se |	hr := ( aStream atEnd not and: [ aStream peek isDigit ] )			ifTrue:	[ ( aStream next: 2 ) asNumber ]			ifFalse:	[ 0 ].	mn := ( aStream atEnd not and: [ aStream peek isDigit ] )			ifTrue:	[ ( aStream next: 2 ) asNumber ]			ifFalse:	[ 0 ].	se := ( aStream atEnd not and: [ aStream peek isDigit ] )			ifTrue:	[ ( aStream next: 2 ) asNumber ]			ifFalse:	[ 0 ].	^Time new hours: hr minutes: mn seconds: se</body><body package="ASN1">decodeUTCTime: anInteger	"Note that we go out of our way to raise an exception for a UTCTime encoding without a terminal 'Z' or offset."	| str date time offset seconds year month day |	str := EncodedStream on: stream encodedBy: (StreamEncoder new: #ascii).	year := self fromTwoDigitYear: ( str next: 2 ) asNumber.	month := ( str next: 2 ) asNumber.	day := ( str next: 2 ) asNumber.	date := Date newDay: day monthNumber: month year: year.	time := self decodeTimeFrom: str.	(str atEnd or: [ ('Z+-' includes: str peek) not ]) ifTrue: [		^MarshalingError raiseSignal: #InvalidUTCTimeEncoding &lt;&lt; #asn1 &gt;&gt; 'Invalid UTCTime encoding!' ].	offset := self decodeTZOffsetFrom: str.	seconds := date asSeconds + time asSeconds - (offset * 60).	^self timezone		convertGMT: seconds		do: [ :localDate :localSeconds | Timestamp fromDate: localDate andTime: (Time fromSeconds: localSeconds) ]</body><body package="ASN1">fromTwoDigitYear: anInteger"convert a two digit year to four digit year"	^self utcSliding		ifTrue: [ self fromTwoDigitYearSliding: anInteger ]		ifFalse: [ self fromTwoDigitYearFixed: anInteger ]</body><body package="ASN1">fromTwoDigitYearFixed: anInteger"Dubuisson's 'ASN.1' on pp. 203-204, rule &lt;6&gt;:The ITU-T working group on the X.500 directory and the ITU-T Q22/11 question (intelligent networks protocols) propose that an application should be able to sort the UTCTime dates and interpret them in the 1950-2049 interval, which would mean, for example, that the value '0105281429Z' corresponds to the 28th of May 2001."	^anInteger &lt; 50		ifTrue: [ 2000 + anInteger ]		ifFalse: [ 1900 + anInteger ]</body><body package="ASN1">fromTwoDigitYearSliding: anInteger"Dubuisson's 'ASN.1' on pp. 203-204, rule &lt;7&gt;:The ITU-T working group on the X.400 e-mail propose that dates from 10 years backwards and 40 years ahead should be interpreted with respect to the 20th century and that the interpretation of the other years should be left to the programmer's interpretation (for example, for an application that is running in 1998, the values from 88 to 99 stand for the years from 1988 to 1999, the values from 00 to 38 are the years from 2000 to 2038, and the interpretation of the values from 39 to 87 depend on the implementation); this proposition of 'shifting window' is well-adapted for the MHS e-mail systems that manage dates in the past (dates of old messages stored or forwarded) as well as in the future (expiry date).We're forcing the interpretation of the unspecified years by extending the range from -50 to +49."	| currentYear |	"We can safely assume 21st century now (UTCTime will hopefully be obsolete by the next century).	That means anything from 00 all the way up to current year + 49 is 21st and the rest is 20th century."	currentYear := Date today year \\ 100.	^currentYear + 49 &lt; anInteger		ifTrue: [ 1900 + anInteger ]		ifFalse: [ 2000 + anInteger ]</body></methods><methods><class-id>ASN1.BERStreamBasic</class-id> <category>encoding - types - time</category><body package="ASN1">encodeGeneralizedTime: aTimestamp	"We always go for the longest, most specific form.  A GeneralizedTime is unlikely to exceed 23 characters."	"In encoding, [1] a dot is used rather a comma, and [2] there are no meaningless zeros written for fractions of a second.  These practices are optional under BER but required under DER."	| str ms min sec |	str := EncodedStream on: stream encodedBy: (StreamEncoder new: #ascii).	aTimestamp year printOn: str base: 10 digitsToPad: 4 highDigit: 4.	aTimestamp month printOn: str base: 10 digitsToPad: 2 highDigit: 2.	aTimestamp day printOn: str base: 10 digitsToPad: 2 highDigit: 2.	aTimestamp hour printOn: str base: 10 digitsToPad: 2 highDigit: 2.	min := aTimestamp minute. sec := aTimestamp second. ms := aTimestamp millisecond.	(self shortTime and: [ ((min bitOr: sec) bitOr: ms)  = 0 ]) ifFalse: [		min printOn: str base: 10 digitsToPad: 2 highDigit: 2 ].	(self shortTime and: [ (sec bitOr: ms) = 0 ]) ifFalse: [		aTimestamp second printOn: str base: 10 digitsToPad: 2 highDigit: 2 ].	ms = 0 ifFalse:	[ | pad |		str nextPut: $..		pad := 3.		[ ms \\ 10 = 0 ] whileTrue: [ pad := pad - 1. ms := ms // 10 ].		ms printOn: str base: 10 digitsToPad: pad highDigit: pad ].	self encodeTZOffsetFor: aTimestamp on: str short: self shortTime.</body><body package="ASN1">encodeTZOffsetFor: aTimestamp on: aStream short: short	| offset local utc |	local := aTimestamp asSeconds.	utc := self timezone convertLocalSecondsToGMT: local.	offset := (local - utc) // 60. "in minutes"	offset = 0	ifTrue: [ ^aStream nextPut: $Z ].	aStream nextPut: ( offset negative ifTrue: [ $- ] ifFalse: [ $+ ] ).	offset := offset abs.	(offset // 60) printOn: aStream base: 10 digitsToPad: 2 highDigit: 2.	offset := offset \\ 60.	(short and: [offset = 0]) ifFalse: [		offset printOn: aStream base: 10 digitsToPad: 2 highDigit: 2 ].</body><body package="ASN1">encodeUTCTime: aTimestamp	"We always go for the longest, most specific form.  A UTCTime is unlikely to exceed 17 characters."	| str timestamp |	str := EncodedStream on: stream encodedBy: (StreamEncoder new: #ascii).	timestamp :=		(self utcRoundMilliseconds and: [ aTimestamp millisecond &gt; 500 ])			ifTrue: [ aTimestamp addSeconds: 1 ]			ifFalse: [ aTimestamp ].	(self toTwoDigitYear: timestamp year) printOn: str base: 10 digitsToPad: 2 highDigit: 2.	timestamp month printOn: str base: 10 digitsToPad: 2 highDigit: 2.	timestamp day printOn: str base: 10 digitsToPad: 2 highDigit: 2.	timestamp hour printOn: str base: 10 digitsToPad: 2 highDigit: 2.	timestamp minute printOn: str base: 10 digitsToPad: 2 highDigit: 2.	(self shortTime and: [ timestamp second = 0 ]) ifFalse: [		timestamp second printOn: str base: 10 digitsToPad: 2 highDigit: 2 ].	self encodeTZOffsetFor: timestamp on: str short: false.</body><body package="ASN1">toTwoDigitYear: anInteger"Convert the year to two digits."	^self utcSliding		ifTrue: [ self toTwoDigitYearSliding: anInteger ]		ifFalse: [ self toTwoDigitYearFixed: anInteger ]</body><body package="ASN1">toTwoDigitYearFixed: anInteger"Dubuisson's 'ASN.1' on pp. 203-204, rule &lt;6&gt;:The ITU-T working group on the X.500 directory and the ITU-T Q22/11 question (intelligent networks protocols) propose that an application should be able to sort the UTCTime dates and interpret them in the 1950-2049 interval, which would mean, for example, that the value '0105281429Z' corresponds to the 28th of May 2001."	(anInteger between:1950 and: 2049) ifFalse: [		UTCTimeRange			raiseRequestWith: anInteger			errorString: (				#UTCTimeRangeFixed1p &lt;&lt; #asn1 &gt;&gt; 'Year &lt;1p&gt; is out of fixed UTCTime range!'					expandMacrosWith: anInteger ) ].	^anInteger \\ 100</body><body package="ASN1">toTwoDigitYearSliding: anInteger"Dubuisson's 'ASN.1' on pp. 203-204, rule &lt;7&gt;:The ITU-T working group on the X.400 e-mail propose that dates from 10 years backwards and 40 years ahead should be interpreted with respect to the 20th century and that the interpretation of the other years should be left to the programmer's interpretation (for example, for an application that is running in 1998, the values from 88 to 99 stand for the years from 1988 to 1999, the values from 00 to 38 are the years from 2000 to 2038, and the interpretation of the values from 39 to 87 depend on the implementation); this proposition of 'shifting window' is well-adapted for the MHS e-mail systems that manage dates in the past (dates of old messages stored or forwarded) as well as in the future (expiry date).We're forcing the interpretation of the unspecified years by extending the range from -50 to +49."	| thisYear |	thisYear := Date today year.	(anInteger between: thisYear - 50 and: thisYear + 49) ifFalse: [		UTCTimeRange			raiseRequestWith: anInteger			errorString: (				#UTCTimeRange1p &lt;&lt; #asn1 &gt;&gt; 'Year &lt;1p&gt; is out of sliding UTCTime range!'					expandMacrosWith: anInteger) ].	^anInteger \\ 100</body></methods><methods><class-id>ASN1.BERStreamBasic class</class-id> <category>class initialization</category><body package="ASN1">initialize	"((( self initialize )))"	super initialize</body><body package="ASN1">initializeTagDispatchTable	"Initialize the tag table used for unmarshalling."	"((( self initializeTagDispatchTable )))"	self tagDispatchTable: ( Array new: 32 ).	self tagDispatchTable 		at: 1	put: [ :len :m | m decodeBOOLEAN: len ];		at: 2	put: [ :len :m | m decodeINTEGER: len ];		at: 3	put: [ :len :m | m decodeBIT_STRING: len ];		at: 4	put: [ :len :m | m decodeOCTET_STRING: len ];		at: 5	put: [ :len :m | m decodeNULL: len ];		at: 6	put: [ :len :m | m decodeOBJECT_IDENTIFIER: len ];		at: 7	put: [ :len :m | m decodeObjectDescriptor: len ];		at: 8	put: [ :len :m | m decodeEXTERNALorINSTANCE_OF: len ];		at: 9	put: [ :len :m | m decodeREAL: len ];		at: 10	put: [ :len :m | m decodeENUMERATED: len ];		at: 11	put: [ :len :m | m decodeEMBEDDED_PDV: len ];		at: 12	put: [ :len :m | m decodeUTF8String: len ];		at: 13	put: [ :len :m | m decodeRELATIVE_OID: len ];		"14=reserved for future use"		"15=reserved for future use"		at: 16	put: [ :len :m | m decodeSEQUENCEorSEQUENCE_OF: len ];		at: 17	put: [ :len :m | m decodeSETorSET_OF: len ];		at: 18	put: [ :len :m | m decodeNumericString: len ];		at: 19	put: [ :len :m | m decodePrintableString: len ];		at: 20	put: [ :len :m | m decodeTeletexStringOrT61String: len ];		at: 21	put: [ :len :m | m decodeVideotexString: len ];		at: 22	put: [ :len :m | m decodeIA5String: len ];		at: 23	put: [ :len :m | m decodeUTCTime: len ];		at: 24	put: [ :len :m | m decodeGeneralizedTime: len ];		at: 25	put: [ :len :m | m decodeGraphicString: len ];		at: 26	put: [ :len :m | m decodeVisibleStringOrISO646String: len ];		at: 27	put: [ :len :m | m decodeGeneralString: len ];		at: 28	put: [ :len :m | m decodeUniversalString: len ];		at: 29	put: [ :len :m | m decodeCHARACTER_STRING: len ];		at: 30	put: [ :len :m | m decodeBMPString: len ].		"31 ... = reserved for future use"</body></methods><methods><class-id>ASN1.BERStreamBasic class</class-id> <category>accessing</category><body package="ASN1">defaultEncodingPolicy	^defaultEncodingPolicy ifNil: [ defaultEncodingPolicy := self defaultEncodingPolicyValue ]</body><body package="ASN1">defaultEncodingPolicy: aClass"	aClass &lt;Class&gt; the default policy for streams of given class"	defaultEncodingPolicy := aClass</body><body package="ASN1">defaultEncodingPolicyValue	^EncodingPolicy</body><body package="ASN1">defaultShortTime"	^&lt;Boolean&gt; should encode timestamps omitting superfluous zero minutes/seconds if permitted"	^defaultShortTime ifNil: [ self defaultShortTimeValue ]</body><body package="ASN1">defaultShortTime: short"	short &lt;Boolean&gt; should encode timestamps omitting superfluous zero minutes/seconds if permitted"	defaultShortTime := short</body><body package="ASN1">defaultShortTimeValue	^true</body><body package="ASN1">defaultTimezone"	^&lt;TimeZone&gt; the timezone to use for Timestamp conversions"	^defaultTimezone ifNil: [ self defaultTimezoneValue ]</body><body package="ASN1">defaultTimezone: timezone"	timezone &lt;TimeZone&gt; the timezone to use for Timestamp conversions"	defaultTimezone := timezone</body><body package="ASN1">defaultTimezoneValue	^TimeZone reference</body><body package="ASN1">defaultUTCRoundMilliseconds"	^&lt;Boolean&gt; should the timestamp milliseconds be rounded or turncated for UTCTime"	^defaultUTCRoundMilliseconds ifNil: [ self defaultUTCRoundMillisecondsValue ]</body><body package="ASN1">defaultUTCRoundMilliseconds: round"	round &lt;Boolean&gt; should the timestamp milliseconds be rounded or turncated for UTCTime"	defaultUTCRoundMilliseconds := round</body><body package="ASN1">defaultUTCRoundMillisecondsValue"should the timestamp milliseconds be rounded or turncated for UTCTime"	^true</body><body package="ASN1">defaultUTCSliding"	^&lt;Boolean&gt; are the 2 digit years of UTCTime interpreted in a 'sliding window' manner or fixed to 1950-2049"	^defaultUTCSliding ifNil: [ self defaultUTCSlidingValue ]</body><body package="ASN1">defaultUTCSliding: slide"	slide &lt;Boolean&gt; are the 2 digit years of UTCTime interpreted in a 'sliding window' manner or fixed to 1950-2049"	defaultUTCSliding := slide</body><body package="ASN1">defaultUTCSlidingValue"Are the 2 digit years of UTCTime interpreted in a 'sliding window' manner or fixed to 1950-2049."	^true</body></methods><methods><class-id>ASN1.BERStreamDefinite</class-id> <category>accessing</category><body package="ASN1">scratchBuffer	^( scratchBuffer isNil )		ifTrue:	[ scratchBuffer := ReadWriteStream on: ( ByteArray new: 64 ) ]		ifFalse:	[ scratchBuffer ]</body><body package="ASN1">ucs2"P.Guttman's style guide says: The correct format for BMPStrings is: big-endian 16-bit characters, no Unicode byte order marks (BOMs), and no terminating null character (ISO 8825-1 section 8.20)"	^ucs2 ifNil: [		ucs2 := (StreamEncoder new: #ucs_2)				initializeForMemory;				bigEndian: true ]</body><body package="ASN1">utf8	^utf8 ifNil: [ utf8 := (StreamEncoder new: #utf8) initializeForMemory ]</body></methods><methods><class-id>ASN1.BERStreamDefinite</class-id> <category>decoding - tagged types</category><body package="ASN1">decodeBIT_STRING: anInteger	^BitString		unused: self next		bytes: ( stream next: anInteger - 1 )</body><body package="ASN1">decodeBMPString: anInteger	^self	decodeString: anInteger		with: self ucs2</body><body package="ASN1">decodeIA5String: anInteger	"... equals 'decodeOCTET_STRING:'."	"... this is provisional and incorrect."	| ba  |	ba := ByteArray new: anInteger.	1 to: anInteger do: [ :x | ba at: x put: self next ].	^ba asString</body><body package="ASN1">decodeNumericString: anInteger	"... equals 'decodeOCTET_STRING:'."	| ba  |	ba := ByteArray new: anInteger.	1 to: anInteger do: [ :x | ba at: x put: self next ].	^ba asString</body><body package="ASN1">decodePrintableString: anInteger	"... equals 'decodeOCTET_STRING:'."	| ba  |	ba := ByteArray new: anInteger.	1 to: anInteger do: [ :x | ba at: x put: self next ].	^ba asString</body><body package="ASN1">decodeTeletexStringOrT61String: anInteger	"... equals 'decodeOCTET_STRING:'."	"... provisional implementation!"	| ba  |	ba := ByteArray new: anInteger.	1 to: anInteger do: [ :x | ba at: x put: self next ].	^ba asString</body><body package="ASN1">decodeUTF8String: anInteger	^self	decodeString: anInteger		with: self utf8</body><body package="ASN1">decodeVisibleStringOrISO646String: anInteger	"... equals 'decodeOCTET_STRING:'."	| ba  |	ba := ByteArray new: anInteger.	1 to: anInteger do: [ :x | ba at: x put: self next ].	^ba asString</body></methods><methods><class-id>ASN1.BERStreamDefinite</class-id> <category>decoding - private</category><body package="ASN1">decodeString: anInteger with: encoder	| start out |	start := self position.	out := (String new: anInteger) writeStream.	[ self position - start &lt; anInteger ] whileTrue: [		out nextPut: (encoder nextFrom: self) ].	^out contents</body><body package="ASN1">nextDefiniteLength	| oct val |	^( ( oct := self next ) anyMask: 2r10000000 )		ifTrue:	[	val := 0.					( oct maskClear: 2r10000000 ) 						timesRepeat:	[ val := ( val bitShift: 8 ) + self next ].					val 				]		ifFalse:	[ oct ]</body><body package="ASN1">nextGenericTag	"... read a single or multiple octet tag."	"... not to be invoked directly in decoding APIs."	"... assumes that we do not need to represent the tag class or form."	| oct1 numberPart oct tag |	oct1 := self next.	( ( numberPart := self asTag: oct1 ) == 31 )			"--- single-octet tag ---"		ifFalse:	[ 	^numberPart				]			"--- multi-octet tag ---"		ifTrue:	[	tag := 0.					[	tag := tag bitShift: 7.						oct := self next.						tag := tag bitOr: ( oct maskClear: 2r10000000 ).					]	whileTrue:							[ oct anyMask: 2r10000000 ].					^tag				]</body><body package="ASN1">nextShortDefiniteLength	^self next</body></methods><methods><class-id>ASN1.BERStreamDefinite</class-id> <category>encoding - private</category><body package="ASN1">encodeDefiniteLength: anInteger	( anInteger &gt; 127 )		ifTrue:	[	self halt. self nextPut: ( 2r10000000 bitOr: anInteger digitLength ).					anInteger digitLength 						to: 1 						by: -1 						do: [ :idx | self nextPut: ( anInteger digitAt: idx ) ].				]		ifFalse: [ self nextPut: anInteger]</body><body package="ASN1">encodeDefiniteLength: anInteger on: aWriteStream	( anInteger &gt; 127 )		ifTrue:	[	aWriteStream nextPut: ( 2r10000000 bitOr: anInteger digitLength ).					anInteger digitLength 						to: 1 						by: -1 						do: [ :idx | aWriteStream nextPut: ( anInteger digitAt: idx ) ].					aWriteStream contents				]		ifFalse: [ aWriteStream nextPut: anInteger].	^aWriteStream</body><body package="ASN1">nextPutLengthAndDo: aBlock	| lpos vpos len |	lpos := self position.	self nextPut: 0.  "skip: 1"	aBlock value.	vpos := self position.	len := vpos - lpos - 1.	( len &lt;= 127 )		ifTrue:	[		self position: lpos.						self encodeDefiniteLength: len.						self position: vpos				]		ifFalse:	[	| inc |					self scratchBuffer reset.					self encodeDefiniteLength: len on: scratchBuffer.					inc := scratchBuffer position - 1.					self						shift: inc						from: lpos + 2						to: vpos.					self position: lpos.					( scratchBuffer collection copyFrom: 1 to: scratchBuffer position )						do: [ :x | self nextPut: x ].					self position: vpos + inc				].</body><body package="ASN1">shift: increment from: start to: end	stream shift: increment from: start to: end</body></methods><methods><class-id>ASN1.BERStreamDefinite</class-id> <category>encoding - tagged types</category><body package="ASN1">encodeBIT_STRING: anAsn1ImportedBitString	"... only the primitive encoding."	( anAsn1ImportedBitString isEmpty )		ifTrue:	[	self nextPut: 0				]		ifFalse:	[	self nextPut: anAsn1ImportedBitString unused.					self nextPutAll: anAsn1ImportedBitString bytes				]</body><body package="ASN1">encodeBMPString: anObject	self encodeString: anObject with: self ucs2</body><body package="ASN1">encodeIA5String: aByteString	"... equals 'encodeOCTET_STRING:'."	"... this is provisional and incorrect."	aByteString asByteArray do: [ :x | self nextPut: x ]</body><body package="ASN1">encodeNumericString: aByteString	"... equals 'encodeOCTET_STRING:'."	aByteString asByteArray do: [ :x | self nextPut: x ]</body><body package="ASN1">encodePrintableString: aByteString	"... equals 'encodeOCTET_STRING:'."	aByteString asByteArray do: [ :x | self nextPut: x ]</body><body package="ASN1">encodeString: string with: encoder	(EncodedStream on: self encodedBy: encoder)		nextPutAll: string</body><body package="ASN1">encodeUTF8String: anObject	self encodeString: anObject with: self utf8</body><body package="ASN1">encodeVisibleStringOrISO646String: aByteString	"... equals 'encodeOCTET_STRING:'."	aByteString asByteArray do: [ :x | self nextPut: x ]</body></methods><methods><class-id>ASN1.BERStreamDefinite</class-id> <category>decoding - api</category><body package="ASN1">nextLength	"... the method to be directly invoked in decoding APIs."	^self nextDefiniteLength.</body><body package="ASN1">nextTag	"... the method to be directly invoked in decoding APIs."	^self nextGenericTag</body></methods><methods><class-id>ASN1.BERStreamDefinite</class-id> <category>encoding - api</category><body package="ASN1">encodeTLV: anObject	"... a recursive entry point, not to be invoked without 'local knowledge'."	"... hopes for a 1-octet definite length and plays costly copying games otherwise."	"... assumes anObject responds to both 'tagBER' and 'encodeASN1With:'."	| lpos vpos len |	self nextPutTagFrom: anObject.	lpos := self position.	self nextPut: 0.	"skip: 1"	anObject encodeASN1With: self.	vpos := self position.	len := vpos - lpos - 1.	( len &lt;= 127 )		ifTrue:	[		self position: lpos.						self encodeDefiniteLength: len.						self position: vpos				]		ifFalse:	[	| inc |					self scratchBuffer reset.					self encodeDefiniteLength: len on: scratchBuffer.					inc := scratchBuffer position - 1.					self						shift: inc						from: lpos + 2						to: vpos.					self position: lpos.					scratchBuffer contents do: [ :x | self nextPut: x ].					self position: vpos + inc				]</body></methods><methods><class-id>ASN1.BERStreamDefinite</class-id> <category>encoding - lengths</category><body package="ASN1">encodeLength: anInteger	"... the method to be directly invoked in encoding methods."	"... intended to accord with the DER requirement that lengths be encoded in the minimum number of octets."	self encodeDefiniteLength: anInteger</body></methods><methods><class-id>ASN1.BERStreamDefinite</class-id> <category>encoding - unimplemented</category><body package="ASN1">encodeCHARACTER_STRING: anObject	self notImplemented</body><body package="ASN1">encodeEMBEDDED_PDV: anObject	self notImplemented</body><body package="ASN1">encodeEXTERNALorINSTANCE_OF: anObject	self notImplemented</body><body package="ASN1">encodeGeneralString: anObject	self notImplemented</body><body package="ASN1">encodeGraphicString: anObject	self notImplemented</body><body package="ASN1">encodeObjectDescriptor: anObject	self notImplemented</body><body package="ASN1">encodeREAL: anObject	"--- zero is encoded as a REAL of zero length ---"	( anObject = 0 )		ifTrue:	[ ^nil ].	"--- fixed representations for positive and negative infinity ---"	( #{Infinity} isDefined )		ifTrue:	[	( anObject == Infinity positive )						ifTrue:	[ ^self nextPut: 02r01000000 ].					( anObject == Infinity negative )						ifTrue:	[ ^self nextPut: 02r01000001 ].				].	self notImplemented</body><body package="ASN1">encodeRELATIVE_OID: anObject	self notImplemented</body><body package="ASN1">encodeUniversalString: anObject	self notImplemented</body></methods><methods><class-id>ASN1.BERStreamDefinite</class-id> <category>decoding - unimplemented</category><body package="ASN1">decodeCHARACTER_STRING: anInteger	self notImplemented</body><body package="ASN1">decodeEMBEDDED_PDV: anInteger	self notImplemented</body><body package="ASN1">decodeEXTERNALorINSTANCE_OF: anInteger	self notImplemented</body><body package="ASN1">decodeGeneralString: anInteger	self notImplemented</body><body package="ASN1">decodeGraphicString: anInteger	self notImplemented</body><body package="ASN1">decodeObjectDescriptor: anInteger	self notImplemented</body><body package="ASN1">decodeREAL: anInteger	"... going for Doubles when possible."	"--- zero is encoded as a REAL of zero length ---"	( anInteger = 0 )		ifTrue:	[ ^Double zero ].	self notImplemented</body><body package="ASN1">decodeRELATIVE_OID: anInteger	self notImplemented</body><body package="ASN1">decodeUniversalString: anInteger	self notImplemented</body><body package="ASN1">decodeVideotexString: anInteger	self notImplemented</body></methods><methods><class-id>ASN1.BERStreamDefinite</class-id> <category>testing</category><body package="ASN1">canRetainEncodingWhileMarshaling"It seems that the length encoding shifts  that can happen during marshaling for entities longer than 128 bytes can mess up retained encodings of contained elements."	^false</body></methods><methods><class-id>ASN1.BERStreamDefinite class</class-id> <category>class initialization</category><body package="ASN1">initialize	"((( self initialize )))"	super initialize</body></methods><methods><class-id>ASN1.DERStream</class-id> <category>testing</category><body package="ASN1">requiresEncodingSort	^true</body><body package="ASN1">requiresTagSort	^true</body></methods><methods><class-id>ASN1.DERStream</class-id> <category>encoding - tagged types</category><body package="ASN1">encodeSETorSET_OF: aSet	"Note that this method is used when there is no 'type-in-hand'. Marshaling without type information is dangerous and error-prone in the case of SETs, which may contain objects of multiple types transmitted in arbitrary order, OPTIONAL values, EXTENSION markers, and DEFAULT values that a receiver is expected to fill in if they have not been transmitted."	| sc scratch |	scratch := self class on: (ByteArray new: 100).	sc := OrderedCollection new: aSet size.	aSet do: [ :o |		scratch encodeTLV: o.		sc add: scratch contents.		sc reset ].	"now we need to sort all entries based on the value of their encoding (pad with zeros for comparison as necessary)"	(self class sortByteArrays: sc) do: [ :ba | self nextPutAll: ba ]</body></methods><methods><class-id>ASN1.DERStream</class-id> <category>encoding - types - time</category><body package="ASN1">convertToUTC: aTimestamp	| ms timestamp |	ms := aTimestamp millisecond.	timestamp := 		self timezone			convertToGMT: aTimestamp asSeconds			do: [ :date :seconds | Timestamp fromDate: date andTime: (Time fromSeconds: seconds) ].	^timestamp addMilliseconds: ms</body><body package="ASN1">encodeGeneralizedTime: aTimestamp"Timestamps are converted to universal time, as required under DER."	super encodeGeneralizedTime: (self convertToUTC: aTimestamp)</body><body package="ASN1">encodeTZOffsetFor: aTimestamp on: aStream short: short	aStream nextPut: $Z</body><body package="ASN1">encodeUTCTime: aTimestamp"Timestamps are converted to universal time, as required under DER."	super encodeUTCTime: (self convertToUTC: aTimestamp)</body></methods><methods><class-id>ASN1.DERStream class</class-id> <category>accessing</category><body package="ASN1">defaultEncodingPolicyValue	^RetainEncodings</body><body package="ASN1">defaultShortTimeValue	^false</body><body package="ASN1">defaultUTCSlidingValue"Are the 2 digit years of UTCTime interpreted in a 'sliding window' manner or fixed to 1950-2049.Defaulting to fixed because that's what X.509 expects."	^false</body></methods><methods><class-id>ASN1.DERStream class</class-id> <category>class initialization</category><body package="ASN1">initialize	"((( self initialize )))"	super initialize</body></methods><methods><class-id>ASN1.DERStream class</class-id> <category>private</category><body package="ASN1">sortByteArrays: byteArrays	^SortedCollection		withAll: byteArrays		sortBlock: [ :a :b |			(	(1 to: (a size min: b size))					detect: [ :i | (a at: i) ~~ (b at: i) ]					ifNone: [ nil ])				ifNil: [ a size &lt;= b size ]				ifNotNil: [ :i | (a at: i) &lt; (b at: i) ] ]</body></methods><methods><class-id>ASN1.RetainEncodings</class-id> <category>private</category><body package="ASN1">beginEncodings	self pushEncoding.	currentEncoding headerStart: marshaler position + 1</body><body package="ASN1">dropEncodingFor: anObject type: anAsn1Type	self popEncoding.	^anObject</body><body package="ASN1">markEncodingsBodyStart	currentEncoding bodyStart: marshaler position + 1</body><body package="ASN1">retainEncodingFor: anObject type: anAsn1Type	currentEncoding bodyStop: marshaler position.	^anObject _encoding: self popEncoding type: anAsn1Type</body><body package="ASN1">shouldRetainEncodingFor: object type: type	^type retainEncoding</body></methods><methods><class-id>ASN1.RetainEncodings</class-id> <category>encoding</category><body package="ASN1">encodeBegin: anObject type: anAsn1Type	self beginEncodings</body><body package="ASN1">encodeBeginBody: anObject type: anAsn1Type	self markEncodingsBodyStart</body><body package="ASN1">encodeEnd: object type: type	^(	marshaler canRetainEncodingWhileMarshaling and: [		self shouldRetainEncodingFor: object type: type]	)	ifTrue: [self retainEncodingFor: object type: type]		ifFalse: [self dropEncodingFor: object type: type]</body><body package="ASN1">marshalObject: anObject withType: anAsn1Type	source := marshaler collection.</body><body package="ASN1">shiftCurrentBodyStartBy: anInteger	currentEncoding bodyStart: currentEncoding bodyStart + anInteger</body></methods><methods><class-id>ASN1.RetainEncodings</class-id> <category>stack - api</category><body package="ASN1">clearEncoding	encodingStack := OrderedCollection new: 256.	currentEncoding := nil</body><body package="ASN1">popEncoding	| res |	res := self encodingStack removeLast.	currentEncoding := [ self encodingStack last ]							on: Error							do:	[ :ex | nil ].	^res</body><body package="ASN1">pushEncoding	| enc |	enc := Encoding source: source.	self encodingStack addLast: enc.	^currentEncoding := enc</body></methods><methods><class-id>ASN1.RetainEncodings</class-id> <category>decoding</category><body package="ASN1">decodeBeginBodyType: anAsn1Type	self markEncodingsBodyStart</body><body package="ASN1">decodeBeginType: anAsn1Type	self beginEncodings</body><body package="ASN1">decodeEnd: object type: type	^(self shouldRetainEncodingFor: object type: type)		ifTrue: [self retainEncodingFor: object type: type]		ifFalse: [self dropEncodingFor: object type: type]</body><body package="ASN1">unmarshalObjectType: anAsn1Type	source := marshaler collection.</body></methods><methods><class-id>ASN1.RetainEncodings</class-id> <category>accessing</category><body package="ASN1">currentEncoding	^currentEncoding</body><body package="ASN1">encodingStack	^( encodingStack isNil )		ifTrue:	[ encodingStack := OrderedCollection new: 256 ]		ifFalse:	[ encodingStack ]</body></methods><methods><class-id>ASN1.RetainAllEncodings</class-id> <category>private</category><body package="ASN1">shouldRetainEncodingFor: object type: type	^true</body></methods><methods><class-id>ASN1.UTCTimeRange class</class-id> <category>testing</category><body package="ASN1">mayResume	^true</body></methods><methods><class-id>ASN1.PrettyPrinter</class-id> <category>encoding</category><body package="ASN1">encodeBegin: anObject type: anAsn1Type	super encodeBegin: anObject type: anAsn1Type.	stream cr.	self offsets ifTrue: [ stream print: marshaler position ].	stream tab: indent.	anAsn1Type shortPrintOn: stream.	indent := indent + 1</body><body package="ASN1">encodeEnd: anObject type: anAsn1Type	indent := indent - 1.	stream cr.	self offsets ifTrue: [ stream print: marshaler position - 1 ].	stream tab: indent;		print: anObject.	^super encodeEnd: anObject type: anAsn1Type</body></methods><methods><class-id>ASN1.PrettyPrinter</class-id> <category>accessing</category><body package="ASN1">offsets	^offsets ifNil: [ true ]</body><body package="ASN1">offsets: aBoolean"	aBoolean &lt;Boolean&gt; should print offsets of entities"	offsets := aBoolean</body></methods><methods><class-id>ASN1.PrettyPrinter</class-id> <category>initialize-release</category><body package="ASN1">on: aStream	stream := aStream.	indent := 1</body></methods><methods><class-id>ASN1.PrettyPrinter</class-id> <category>decoding</category><body package="ASN1">decodeBeginType: anAsn1Type	super decodeBeginType: anAsn1Type.	stream cr.	self offsets ifTrue: [ stream print: marshaler position ].	stream tab: indent.	anAsn1Type shortPrintOn: stream.	indent := indent + 1</body><body package="ASN1">decodeEnd: anObject type: anAsn1Type	indent := indent - 1.	stream cr.	self offsets ifTrue: [ stream print: marshaler position ].	stream tab: indent;		print: anObject.	^super decodeEnd: anObject type: anAsn1Type</body></methods><methods><class-id>ASN1.PrettyPrinter class</class-id> <category>instance creation</category><body package="ASN1">on: aStream	^self new on: aStream</body></methods><methods><class-id>ASN1.TagUnknown class</class-id> <category>testing</category><body package="ASN1">mayResume	^true</body></methods><methods><class-id>ASN1.UnstructuredType</class-id> <category>decoding</category><body package="ASN1">decodeValue: anInteger with: aMarshaler	"... the method invoked when unmarshaling type-in-hand."	| oc tpos |	oc := OrderedCollection new: 11.	tpos := aMarshaler position + anInteger.	[ aMarshaler position &lt; tpos ] whileTrue: [		oc add: ( elementType decodeWith: aMarshaler ) ].	^oc</body></methods><methods><class-id>ASN1.UnstructuredType</class-id> <category>encoding</category><body package="ASN1">encodeValue: anOrderedCollection with: aMarshaler	"... the method invoked when marshaling type wrappers or marshaling type-in-hand."	anOrderedCollection do: [ :x | elementType encode: x with: aMarshaler ]</body></methods><methods><class-id>ASN1.SET_OF</class-id> <category>encoding</category><body package="ASN1">tagBER	"... avoid the namespace lookup."	^02r00110001	"ASN1.ConstructedSET = 49"</body></methods><methods><class-id>ASN1.OCTET_STRING</class-id> <category>decoding</category><body package="ASN1">decodeValue: anInteger with: aMarshaler	"... the method invoked when unmarshaling type-in-hand."	^aMarshaler decodeOCTET_STRING: anInteger</body></methods><methods><class-id>ASN1.OCTET_STRING</class-id> <category>encoding</category><body package="ASN1">encodeValue: aByteArray with: aMarshaler	"... the method invoked when marshaling type wrappers or marshaling type-in-hand."	aMarshaler encodeOCTET_STRING: aByteArray</body><body package="ASN1">tagBER	"... avoid the namespace lookup."	^02r00000100	"ASN1.UniversalOCTET_STRING = 4"</body></methods><methods><class-id>ASN1.UTF8String</class-id> <category>decoding</category><body package="ASN1">decodeValue: anInteger with: aMarshaler	"... the method invoked when unmarshaling type-in-hand."	^aMarshaler decodeUTF8String: anInteger</body></methods><methods><class-id>ASN1.UTF8String</class-id> <category>encoding</category><body package="ASN1">encodeValue: anObject with: aMarshaler	"... the method invoked when marshaling type wrappers or marshaling type-in-hand."	aMarshaler encodeUTF8String: anObject</body><body package="ASN1">tagBER	"... avoid the namespace lookup."	^02r00001100	"ASN1.UniversalUTF8String = 12"</body></methods><methods><class-id>Core.Object</class-id> <category>marshaling - asn1</category><body package="ASN1">_encoding	^nil</body><body package="ASN1">_encoding: anEncoding type: aType	^ASN1.TypeWrapper new		_type: aType;		_value: self;		_encoding: anEncoding;		yourself</body><body package="ASN1">asn1ChoiceType	^nil</body><body package="ASN1">asn1ChoiceValue	^self</body></methods><methods><class-id>ASN1.SET</class-id> <category>encoding</category><body package="ASN1">orderedElementsFor: aMarshaler	^( aMarshaler requiresTagSort )		ifTrue: [ SortedCollection withAll: elements sortBlock: [:x :y | x tagBER &lt;= y tagBER ] ]		ifFalse: [ elements ]</body><body package="ASN1">tagBER	"... avoid the namespace lookup."	^02r00110001	"ASN1.ConstructedSET = 49"</body></methods><methods><class-id>Core.Timestamp</class-id> <category>marshaling - asn1</category><body package="ASN1">asGeneralizedTime	"By default, aTimestamp is marshaled as a GeneralizedTime."	^self</body><body package="ASN1">asUTCTime	"A Timestamp may be marshaled as a UTCTime by enclosing it in an Asn1TypeWrapper prior to marshaling."	^ASN1.TypeWrapper new		_type: ASN1.UTCTime new;		_value: self;		yourself</body><body package="ASN1">encodeASN1With: aMarshaler	"... the generic, double-dispatch encoding API."	^aMarshaler encodeGeneralizedTime: self</body><body package="ASN1">tagBER	"... avoid the namespace lookup."	^02r00011000	"ASN1.UniversalGeneralizedTime = 24"</body></methods><methods><class-id>ASN1.BOOLEAN</class-id> <category>decoding</category><body package="ASN1">decodeValue: anInteger with: aMarshaler	"... the method invoked when unmarshaling type-in-hand."	^aMarshaler decodeBOOLEAN: anInteger</body></methods><methods><class-id>ASN1.BOOLEAN</class-id> <category>encoding</category><body package="ASN1">encodeValue: aBoolean with: aMarshaler	"... the method invoked when marshaling type wrappers or marshaling type-in-hand."	aMarshaler encodeBOOLEAN: aBoolean</body><body package="ASN1">tagBER	"... avoid the namespace lookup."	^02r00000001	"ASN1.UniversalBOOLEAN = 1"</body></methods><methods><class-id>ASN1.BMPString</class-id> <category>decoding</category><body package="ASN1">decodeValue: anInteger with: aMarshaler	"... the method invoked when unmarshaling type-in-hand."	^aMarshaler decodeBMPString: anInteger</body></methods><methods><class-id>ASN1.BMPString</class-id> <category>encoding</category><body package="ASN1">encodeValue: anObject with: aMarshaler	"... the method invoked when marshaling type wrappers or marshaling type-in-hand."	aMarshaler encodeBMPString: anObject</body><body package="ASN1">tagBER	"... avoid the namespace lookup."	^02r00011110	"ASN1.UniversalBMPString = 30"</body></methods><methods><class-id>Core.ByteString</class-id> <category>marshaling -asn1</category><body package="ASN1">encodeASN1With: aMarshaler	"... the generic, double-dispatch encoding API."	"... this is provisional, as ByteString's range include several of the ISOReg graphical sets."	"... PrintableString is chosen because it is the expected type for X509 certificates."	^aMarshaler encodePrintableString: self</body><body package="ASN1">tagBER	"... this is provisional, as ByteString's range include several of the ISOReg graphical sets."	"... PrintableString is chosen because it is the expected type for X509 certificates."	"... avoid the namespace lookup."	^02r00010011	"ASN1.UniversalPrintableString = 19"</body></methods><methods><class-id>ASN1.Choice</class-id> <category>marshaling - asn1</category><body package="ASN1">asn1ChoiceType	^choice type</body><body package="ASN1">asn1ChoiceValue	^self _value</body><body package="ASN1">encodeASN1With: aMarshaler	"... the generic, double-dispatch encoding API."	aMarshaler encodeTLV: self _value withElement: choice</body></methods><methods><class-id>ASN1.MappableType</class-id> <category>decoding - utility</category><body package="ASN1">completeTarget: anObject	( mapping == nil )		ifTrue:	[ anObject structName: self symbol ].	^anObject</body><body package="ASN1">createTarget	^( mapping == nil )		ifTrue:	[ Struct new: 11 ]		ifFalse:	[ mapping new ]</body></methods><methods><class-id>ASN1.MappableType</class-id> <category>decoding</category><body package="ASN1">decodeValue: anInteger with: aMarshaler	"... the method invoked when unmarshaling type-in-hand.  Since SETs have an unconstrained transmission order, we just take what comes and push it into the target."	| target end elems extension |	end := aMarshaler position + anInteger.	elems := (self orderedElementsFor: aMarshaler) readStream.	target := self createTarget.	extension := false.	[ elems atEnd or: [ aMarshaler position &gt;= end ] ] whileFalse: [ | ele |		ele := elems next.		ele isExtensionMarker ifTrue: [ extension := true ].		ele decode: target with: aMarshaler ].	[ extension or: [ elems atEnd ] ] whileFalse: [ | ele |		ele := elems next.		ele isExtensionMarker ifTrue: [ extension := true  ].		( 	ele isMarker or: [			ele hasDefault ifTrue: [ele value: ele default into: target].			ele hasDefaultOrIsOptional ]		)	ifFalse: [ aMarshaler missingElement: ele with: self ] ].	aMarshaler position &lt; end ifTrue: [		extension			ifTrue: [ aMarshaler position: end ]			ifFalse: [ aMarshaler invalidLength: anInteger with: self ] ].	^self completeTarget: target</body></methods><methods><class-id>ASN1.MappableType</class-id> <category>encoding</category><body package="ASN1">encode: aStruct with: aMarshaler	^aStruct _encoding		ifNil: [ super encode: aStruct with: aMarshaler ]		ifNotNil: [ :encoding | encoding writeOn: aMarshaler ]</body><body package="ASN1">encodeValue: anAsn1Struct with: aMarshaler	"... the method invoked when unmarshaling type-in-hand.  ... branches on whether a retained encoding is present."	( self permits: anAsn1Struct )	ifFalse: [		MarshalingError new			messageText: (#InvalidStructuredValue1s &lt;&lt; #asn1 &gt;&gt; 'Bad object for structured type &lt;1s&gt;!'						expandMacrosWith: symbol);			parameter: anAsn1Struct;			raise ].	(self orderedElementsFor: aMarshaler) do: [ :ele |		ele encode: anAsn1Struct with: aMarshaler ]</body><body package="ASN1">orderedElementsFor: aMarshaler	^elements</body></methods><methods><class-id>ASN1.UTCTime</class-id> <category>decoding</category><body package="ASN1">decodeValue: anInteger with: aMarshaler	"... the method invoked when unmarshaling type-in-hand."	^aMarshaler decodeUTCTime: anInteger</body></methods><methods><class-id>ASN1.UTCTime</class-id> <category>encoding</category><body package="ASN1">encodeValue: aTimestamp with: aMarshaler	"... the method invoked when marshaling type wrappers or marshaling type-in-hand."	aMarshaler encodeUTCTime: aTimestamp</body><body package="ASN1">tagBER	"... avoid the namespace lookup."	^02r00010111	"ASN1.UniversalUTCTime = 23"</body></methods><methods><class-id>ASN1.Struct</class-id> <category>marshaling - asn1</category><body package="ASN1">_encoding: anEncoding type: aType	encoding := anEncoding</body><body package="ASN1">asn1ChoiceType	^nil</body><body package="ASN1">asn1ChoiceValue	^self</body></methods><methods><class-id>Core.OrderedCollection</class-id> <category>marshaling - asn1</category><body package="ASN1">encodeASN1With: aMarshaler	"... the generic, double-dispatch encoding API."	^aMarshaler encodeSEQUENCEorSEQUENCE_OF: self</body><body package="ASN1">tagBER	"... avoid the namespace lookup."	^02r00110000	"ASN1.ConstructedSEQUENCE = 48"</body></methods><methods><class-id>ASN1.VideotexString</class-id> <category>encoding</category><body package="ASN1">encodeValue: anObject with: aMarshaler	"... the method invoked when marshaling type wrappers or marshaling type-in-hand."	self obsoleteType</body><body package="ASN1">tagBER	"... avoid the namespace lookup."	^02r00010101	"ASN1.UniversalVideotexString = 21"</body></methods><methods><class-id>ASN1.ObjectDescriptor</class-id> <category>encoding</category><body package="ASN1">tagBER	"... avoid the namespace lookup."	^02r00000111	"ASN1.UniversalObjectDescriptor = 7"</body></methods><methods><class-id>ASN1.BitString</class-id> <category>marshaling - asn1</category><body package="ASN1">encodeASN1With: aMarshaler	"... the generic, double-dispatch encoding API."	"... only the primitive encoding."	^aMarshaler encodeBIT_STRING: self</body><body package="ASN1">tagBER	"... avoid the namespace lookup."	^02r00000011	"ASN1.UniversalBIT_STRING = 3"</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>marshaling - asn1</category><body package="ASN1">encodeASN1With: aMarshaler	"... the generic, double-dispatch encoding API."	^aMarshaler encodeNULL</body><body package="ASN1">tagBER	"... avoid the namespace lookup."	^02r00000101	"ASN1.UniversalNULL = 5"</body></methods><methods><class-id>ASN1.VisibleString</class-id> <category>encoding</category><body package="ASN1">encodeValue: aByteString with: aMarshaler	"... the method invoked when marshaling type wrappers or marshaling type-in-hand."	aMarshaler encodeVisibleString: aByteString</body><body package="ASN1">tagBER	"... avoid the namespace lookup."	^02r00011010	"ASN1.UniversalVisibleString = 26"</body></methods><methods><class-id>ASN1.GraphicString</class-id> <category>encoding</category><body package="ASN1">tagBER	"... avoid the namespace lookup."	^02r00011001	"ASN1.UniversalGraphicString = 25"</body></methods><methods><class-id>ASN1.ChoiceElement</class-id> <category>decoding</category><body package="ASN1">decodeWith: aMarshaler	^type decodeWith: aMarshaler</body></methods><methods><class-id>ASN1.ChoiceElement</class-id> <category>encoding</category><body package="ASN1">encode: anObject with: aMarshaler	type encode: anObject asn1ChoiceValue		with: aMarshaler</body><body package="ASN1">key	^symbol</body><body package="ASN1">tagBER	"Goes to the type if the tag is nil.  Dubs in the context-specific and constructed tag prefixes if the tagging mode is EXPLICIT."	^self tag		ifNil: 	[ self type tagBER ]		ifNotNil: [ :t | self isExplicit				ifTrue:	[ t bitOr: 2r10100000 ]				ifFalse:	[ t ] ]</body></methods><methods><class-id>ASN1.NULL</class-id> <category>decoding</category><body package="ASN1">decodeValue: anInteger with: aMarshaler	"... the method invoked when unmarshaling type-in-hand."	^aMarshaler decodeNULL: anInteger</body></methods><methods><class-id>ASN1.NULL</class-id> <category>encoding</category><body package="ASN1">encodeValue: anUndefinedObject with: aMarshaler	"... the method invoked when marshaling type wrappers or marshaling type-in-hand."	aMarshaler encodeNULL</body><body package="ASN1">tagBER	"... avoid the namespace lookup."	^02r00000101	"ASN1.UniversalNULL = 5"</body></methods><methods><class-id>Core.Integer</class-id> <category>marshaling - asn1</category><body package="ASN1">encodeASN1With: aMarshaler	"... the generic, double-dispatch encoding API.  This will also work if the Integer is the 'name' of an ENUMERATED."	^aMarshaler encodeINTEGER: self</body><body package="ASN1">tagBER	"... avoid the namespace lookup."	^02r00000010	"ASN1.UniversalINTEGER = 2"</body></methods><methods><class-id>ASN1.SEQUENCE_OF</class-id> <category>encoding</category><body package="ASN1">tagBER	"... avoid the namespace lookup."	^02r00110000	"ASN1.ConstructedSEQUENCE = 48"</body></methods><methods><class-id>ASN1.OBJECT_IDENTIFIER</class-id> <category>decoding</category><body package="ASN1">decodeValue: anInteger with: aMarshaler	"... the method invoked when unmarshaling type-in-hand."	^aMarshaler decodeOBJECT_IDENTIFIER: anInteger</body></methods><methods><class-id>ASN1.OBJECT_IDENTIFIER</class-id> <category>encoding</category><body package="ASN1">encodeValue: anAsn1ImportedOID with: aMarshaler	"... the method invoked when marshaling type wrappers or marshaling type-in-hand."	aMarshaler encodeOBJECT_IDENTIFIER: anAsn1ImportedOID</body><body package="ASN1">tagBER	"... avoid the namespace lookup."	^02r00000110	"ASN1.UniversalOBJECT_IDENTIFIER = 6"</body></methods><methods><class-id>ASN1.Enumeration</class-id> <category>marshaling - asn1</category><body package="ASN1">encodeASN1With: aMarshaler	"... the generic, double-dispatch encoding API."	^aMarshaler encodeENUMERATED: self</body><body package="ASN1">tagBER	"... avoid the namespace lookup."	^02r00001010	"ASN1.UniversalENUMERATED = 10"</body></methods><methods><class-id>Core.Boolean</class-id> <category>marshaling - asn1</category><body package="ASN1">encodeASN1With: aMarshaler	"... the generic, double-dispatch encoding API."	^aMarshaler encodeBOOLEAN: self</body><body package="ASN1">tagBER	"... avoid the namespace lookup."	^02r00000001	"ASN1.UniversalBOOLEAN = 1"</body></methods><methods><class-id>ASN1.SEQUENCE</class-id> <category>encoding</category><body package="ASN1">tagBER	"... avoid the namespace lookup."	^02r00110000	"ASN1.ConstructedSEQUENCE = 48"</body></methods><methods><class-id>ASN1.GeneralString</class-id> <category>encoding</category><body package="ASN1">tagBER	"... avoid the namespace lookup."	^02r00011011	"ASN1.UniversalGeneralString = 27"</body></methods><methods><class-id>ASN1.MarkerElement</class-id> <category>decoding</category><body package="ASN1">decode: anObject with: aMarshaler</body></methods><methods><class-id>ASN1.MarkerElement</class-id> <category>encoding</category><body package="ASN1">encode: anObject with: aMarshaler</body></methods><methods><class-id>ASN1.TeletexString</class-id> <category>encoding</category><body package="ASN1">tagBER	"... avoid the namespace lookup."	^02r00010100	"ASN1.UniversalTeletexString = 20"</body></methods><methods><class-id>ASN1.StructureElement</class-id> <category>decoding</category><body package="ASN1">decode: anObject with: aMarshaler	| tag |	aMarshaler atEnd ifTrue: [		self hasDefault ifTrue: [^self value: self default into: anObject].		self isOptional ifTrue: [^self].		^aMarshaler missingElement: self with: type ].	tag := aMarshaler peekTag.	(self matchesTag: tag)		ifTrue: [ | val |			val := type decodeWith: aMarshaler for: anObject.			(val isNil and: [ self isOptional ]) ifTrue: [				"to be able to distinguish absence from NULL, wrap the nil in a type wrapper"				val := TypeWrapper new _type: type; _value: val; yourself ].			self value: val into: anObject ]		ifFalse: [			self hasDefaultOrIsOptional				ifTrue: [ self hasDefault ifTrue: [						self value: self default into: anObject] ]				ifFalse: [ aMarshaler missingElement: self with: owner ] ]</body></methods><methods><class-id>ASN1.StructureElement</class-id> <category>encoding</category><body package="ASN1">encode: anObject with: aMarshaler	[	| val |		val := self valueFrom: anObject.		(	(self isOptional and: [ val _isTypeWrapper not and: [ val isNil ] ])			or: [ self hasDefault and: [ val = self default ] ]		)	ifFalse: [ type encode: val with: aMarshaler for: anObject ]	]	on: MarshalingError			do: [ :ex | self hasDefaultOrIsOptional ifFalse: [ ex pass ] ].</body></methods><methods><class-id>ASN1.StructureElement</class-id> <category>decoding</category><body package="ASN1">value: aValue into: anObject	"( mapping == nil )		ifTrue:	[ anObject1 add: ( anObject2 -&gt; anObject3 ) ]		ifFalse:	[ anObject1 perform: ( self mutatorFrom: anObject2 ) with: anObject3 ]"	anObject perform: self mutator with: aValue</body></methods><methods><class-id>ASN1.StructureElement</class-id> <category>encoding</category><body package="ASN1">valueFrom: anObject	^[	anObject perform: self accessor	]	on: MessageNotUnderstood		do: [ :ex | ex resignalAs: (				MarshalingError new					messageText: (#MissingElementValue1s &lt;&lt; #asn1 &gt;&gt; 'Missing value for element &lt;1s&gt;'								expandMacrosWith: symbol);					parameter: anObject;					yourself ) ]</body></methods><methods><class-id>Core.PositionableStream</class-id> <category>ASN.1</category><body package="ASN1">shift: increment from: start to: end	| newEnd |	newEnd := end + increment.	collection growToAtLeast: newEnd. "the check for need to grow is done by #growToAtLeast:"	collection		replaceFrom: start + increment		to: newEnd		with: collection		startingAt: start.	readLimit := end + increment max: readLimit</body></methods><methods><class-id>ASN1.INTEGER</class-id> <category>decoding</category><body package="ASN1">decodeValue: anInteger with: aMarshaler	"... the method invoked when unmarshaling type-in-hand."	^aMarshaler decodeINTEGER: anInteger</body></methods><methods><class-id>ASN1.INTEGER</class-id> <category>encoding</category><body package="ASN1">encodeValue: anInteger with: aMarshaler	"... the method invoked when marshaling type wrappers or marshaling type-in-hand."	aMarshaler encodeINTEGER: anInteger</body><body package="ASN1">tagBER	"... avoid the namespace lookup."	^02r00000010	"ASN1.UniversalINTEGER = 2"</body></methods><methods><class-id>ASN1.PrintableString</class-id> <category>decoding</category><body package="ASN1">decodeValue: anInteger with: aMarshaler	"... the method invoked when unmarshaling type-in-hand."	^aMarshaler decodePrintableString: anInteger</body></methods><methods><class-id>ASN1.PrintableString</class-id> <category>encoding</category><body package="ASN1">encodeValue: aByteString with: aMarshaler	"... the method invoked when marshaling type wrappers or marshaling type-in-hand."	aMarshaler encodePrintableString: aByteString</body><body package="ASN1">tagBER	"... avoid the namespace lookup."	^02r00010011	"ASN1.UniversalPrintableString = 19"</body></methods><methods><class-id>ASN1.TypeWrapper</class-id> <category>marshaling - asn1</category><body package="ASN1">_encoding: anEncoding type: aType	encoding := anEncoding</body><body package="ASN1">encodeASN1With: aMarshaler	"... the generic, double-dispatch encoding API."  	"However, this implementation redispatches to the type held by this marshaling wrapper."	type encodeValue: object with: aMarshaler</body><body package="ASN1">tagBER	^type tagBER</body></methods><methods><class-id>ASN1.Type</class-id> <category>testing</category><body package="ASN1">canEncodeValue	^true</body></methods><methods><class-id>ASN1.Type</class-id> <category>encoding</category><body package="ASN1">contextTagFrom: anInteger	^anInteger bitOr: ContextSpecificClass</body></methods><methods><class-id>ASN1.Type</class-id> <category>decoding</category><body package="ASN1">decodeValue: anInteger with: aMarshaler	"... the method invoked when unmarshaling type-in-hand."	self error: (#NotImplemented &lt;&lt; #asn1 &gt;&gt; 'This function has not been implemented in this release.')</body><body package="ASN1">decodeWith: aMarshaler	^self tag		ifNil: [ self canEncodeValue				ifTrue: [ aMarshaler decodeWith: self ]				ifFalse: [ aMarshaler decodeTaglessWith: self ] ]		ifNotNil: [ :t || ct |			ct := self contextTagFrom: t.			self isImplicitlyTagged				ifTrue: [ aMarshaler decodeWith: self implicitTag: ct ]				ifFalse: [ aMarshaler decodeWith: self explicitTag: ct ] ]</body><body package="ASN1">decodeWith: aMarshaler for: anObject"Dispatch from structured type elements."	^self decodeWith: aMarshaler</body><body package="ASN1">decodeWith: aMarshaler length: aNumber"Dispatch from structured type elements."	^self decodeWith: aMarshaler</body></methods><methods><class-id>ASN1.Type</class-id> <category>encoding</category><body package="ASN1">encode: anObject with: aMarshaler	self tag		ifNil: [ aMarshaler encode: anObject with: self ]		ifNotNil: [ :t || ctag |			ctag := self contextTagFrom: t.			self isImplicitlyTagged				ifTrue: [ aMarshaler encode: anObject with: self implicitTag: ctag ]				ifFalse: [ aMarshaler encode: anObject with: self explicitTag: ctag ] ]</body><body package="ASN1">encode: value with: marshaler for: container"Dispatch from structured type elements."	self encode: value with: marshaler</body><body package="ASN1">encodeBody: anObject with: aMarshaler	self encodeValue: anObject with: aMarshaler</body><body package="ASN1">encodeValue: anObject with: aMarshaler	self subclassResponsibility</body></methods><methods><class-id>ASN1.Type</class-id> <category>testing</category><body package="ASN1">matchesTag: anInteger	| ttag |	ttag := 		tag	ifNil: [ self tagBER ]			ifNotNil: [ tag ].	^((ttag bitXor: anInteger) bitAnd: TagMaskNumber) isZero</body></methods><methods><class-id>ASN1.Type</class-id> <category>accessing</category><body package="ASN1">parent	^nil</body></methods><methods><class-id>ASN1.Type</class-id> <category>encoding</category><body package="ASN1">tagBER	self subclassResponsibility</body></methods><methods><class-id>ASN1.RELATIVE_OID</class-id> <category>encoding</category><body package="ASN1">tagBER	"... avoid the namespace lookup."	^02r00001101	"ASN1.UniversalRELATIVE_OID = 13"</body></methods><methods><class-id>ASN1.CHOICE</class-id> <category>testing</category><body package="ASN1">canEncodeValue	^false</body></methods><methods><class-id>ASN1.CHOICE</class-id> <category>decoding</category><body package="ASN1">decodeDelegateWith: aMarshaler	| ele eTag value |	eTag := aMarshaler peekNextTag.	ele := self elementWithTag: eTag ifNone: [ aMarshaler tagMismatch: eTag with: self ].		value := (ele type tag isNil or: [ aMarshaler isConstructedForm: eTag ])		ifTrue: [ ele decodeWith: aMarshaler ]		ifFalse: [ aMarshaler decodeWith: ele type implicitTag: ele type tag ].			^self useChoice		ifTrue: [ Choice				type: self				choice: ele				value: value ]		ifFalse: [ value ]</body></methods><methods><class-id>ASN1.CHOICE</class-id> <category>encoding</category><body package="ASN1">encodeDelegate: anObject with: aMarshaler	(	elements			detect: [ :e | e permits: anObject ]			ifNone: [ MarshalingError new					messageText: (						#InvalidChoice1p2p &lt;&lt; #asn1 &gt;&gt; '&lt;1p&gt; is not valid choice for &lt;2p&gt;!'							expandMacrosWith: anObject with: self);					parameter: anObject;					raise ]	)	encode: anObject		with: aMarshaler</body></methods><methods><class-id>Core.ByteArray</class-id> <category>marshaling - asn1</category><body package="ASN1">encodeASN1With: aMarshaler	"... the generic, double-dispatch encoding API."	^aMarshaler encodeOCTET_STRING: self</body><body package="ASN1">tagBER	"... avoid the namespace lookup."	^02r00000100	"ASN1.UniversalOCTET_STRING = 4"</body></methods><methods><class-id>ASN1.ConstructedType</class-id> <category>decoding</category><body package="ASN1">decodeWith: aMarshaler length: anInteger	^(aMarshaler isConstructedForm: aMarshaler peekNextTag )		ifTrue: [ self decodeWith: aMarshaler ]		ifFalse: [ self decodeValue: anInteger with: aMarshaler ]</body></methods><methods><class-id>ASN1.ANY</class-id> <category>testing</category><body package="ASN1">canEncodeValue	^false</body></methods><methods><class-id>ASN1.ANY</class-id> <category>decoding</category><body package="ASN1">decodeDelegateWith: aMarshaler	^aMarshaler decodeTLV	"| ele eTag |	eTag := aMarshaler peekTag.	ele := self elementWithTag: eTag ifNone: [ aMarshaler tagMismatch: eTag with: self ].	^Asn1Choice		type: self		choiceSymbol:	ele symbol		value: (ele decodeWith: aMarshaler)"</body><body package="ASN1">decodeWith: aMarshaler for: anObject"Dispatch from structured type elements."	^definedBy		ifNil: [ self decodeDelegateWith: aMarshaler ]		ifNotNil: [ | key type |			key := definedBy valueFrom: anObject.			type := typeMap at: key ifAbsent: [ self raiseUnknownDiscriminator: key ].			type decodeWith: aMarshaler for: anObject ]</body></methods><methods><class-id>ASN1.ANY</class-id> <category>encoding</category><body package="ASN1">encode: value with: marshaler for: container"Dispatch from structured type elements."	definedBy		ifNil: [ self encodeDelegate: value with: marshaler ]		ifNotNil: [ | key type |			key := definedBy valueFrom: container.			type := typeMap at: key ifAbsent: [ self raiseUnknownDiscriminator: key ].			type encode: value with: marshaler for: container ]</body><body package="ASN1">encodeDelegate: anObject with: aMarshaler	anObject _isTypeWrapper		ifTrue: [ anObject _type encode: anObject _value with: aMarshaler ]		ifFalse: [ aMarshaler encodeTLV: anObject ]</body></methods><methods><class-id>ASN1.ANY</class-id> <category>decoding</category><body package="ASN1">raiseUnknownDiscriminator: value	^MarshalingError raiseSignal: (		#UnknownANYDiscriminator &lt;&lt; #asn1 &gt;&gt; 'Unknown discriminator value &lt;1p&gt; for &lt;2p&gt; in &lt;3p&gt;!'			expandMacrosWith: value			with: self			with: definedBy owner)</body></methods><methods><class-id>ASN1.ANY</class-id> <category>encoding</category><body package="ASN1">tagBER	^nil</body></methods><methods><class-id>ASN1.IA5String</class-id> <category>decoding</category><body package="ASN1">decodeValue: anInteger with: aMarshaler	"... the method invoked when unmarshaling type-in-hand."	^aMarshaler decodeIA5String: anInteger</body></methods><methods><class-id>ASN1.IA5String</class-id> <category>encoding</category><body package="ASN1">encodeValue: aByteString with: aMarshaler	"... the method invoked when marshaling type wrappers or marshaling type-in-hand."	aMarshaler encodeIA5String: aByteString</body><body package="ASN1">tagBER	"... avoid the namespace lookup."	^02r00010110	"ASN1.UniversalIA5String = 22"</body></methods><methods><class-id>ASN1.ObjectIdentifier</class-id> <category>marshaling - asn1</category><body package="ASN1">encodeASN1With: aMarshaler	"... the generic, double-dispatch encoding API."	^aMarshaler encodeOBJECT_IDENTIFIER: self</body><body package="ASN1">tagBER	"... avoid the namespace lookup."	^02r00000110	"ASN1.UniversalOBJECT_IDENTIFIER = 6"</body></methods><methods><class-id>ASN1.NumericString</class-id> <category>encoding</category><body package="ASN1">encodeValue: aByteString with: aMarshaler	"... the method invoked when marshaling type wrappers or marshaling type-in-hand."	aMarshaler encodeNumericString: aByteString</body><body package="ASN1">tagBER	"... avoid the namespace lookup."	^02r00010010	"ASN1.UniversalNumericString = 18"</body></methods><methods><class-id>ASN1.ENUMERATED</class-id> <category>decoding</category><body package="ASN1">decodeValue: anInteger with: aMarshaler	"... the method invoked when unmarshaling type-in-hand."	| val |	val := aMarshaler decodeENUMERATED: anInteger.	^self useEnumeration		ifTrue: [ val asAsn1Enumeration: self ]		ifFalse: [ val ]</body></methods><methods><class-id>ASN1.ENUMERATED</class-id> <category>encoding</category><body package="ASN1">encodeValue: aValue with: aMarshaler	"... the method invoked when marshaling type wrappers or marshaling type-in-hand."	aMarshaler encodeENUMERATED: (aValue asAsn1Enumeration: self) _integer</body><body package="ASN1">tagBER	"... avoid the namespace lookup."	^02r00001010	"ASN1.UniversalENUMERATED = 10"</body></methods><methods><class-id>ASN1.UniversalString</class-id> <category>decoding</category><body package="ASN1">decodeValue: anInteger with: aMarshaler	"... the method invoked when unmarshaling type-in-hand."	^aMarshaler decodeUniversalString: anInteger</body></methods><methods><class-id>ASN1.UniversalString</class-id> <category>encoding</category><body package="ASN1">encodeValue: anObject with: aMarshaler	"... the method invoked when marshaling type wrappers or marshaling type-in-hand."	aMarshaler encodeUniversalString: anObject</body><body package="ASN1">tagBER	"... avoid the namespace lookup."	^02r00011100	"ASN1.UniversalUniversalString = 28"</body></methods><methods><class-id>ASN1.GeneralizedTime</class-id> <category>decoding</category><body package="ASN1">decodeValue: anInteger with: aMarshaler	"... the method invoked when unmarshaling type-in-hand."	^aMarshaler decodeGeneralizedTime: anInteger</body></methods><methods><class-id>ASN1.GeneralizedTime</class-id> <category>encoding</category><body package="ASN1">encodeValue: vaTimestamp with: aMarshaler	"... the method invoked when marshaling type wrappers or marshaling type-in-hand."	aMarshaler encodeGeneralizedTime: vaTimestamp</body><body package="ASN1">tagBER	"... avoid the namespace lookup."	^02r00011000	"ASN1.UniversalGeneralizedTime = 24"</body></methods><methods><class-id>ASN1.BIT_STRING</class-id> <category>decoding</category><body package="ASN1">decodeValue: anInteger with: aMarshaler	"... the method invoked when unmarshaling type-in-hand."	^aMarshaler decodeBIT_STRING: anInteger</body></methods><methods><class-id>ASN1.BIT_STRING</class-id> <category>encoding</category><body package="ASN1">encodeValue: anAsn1BitString with: aMarshaler	"... the method invoked when marshaling type wrappers or marshaling type-in-hand."	aMarshaler encodeBIT_STRING: anAsn1BitString</body><body package="ASN1">tagBER	"... avoid the namespace lookup."	^02r00000011	"ASN1.UniversalBIT_STRING = 3"</body></methods><methods><class-id>ASN1.REAL</class-id> <category>encoding</category><body package="ASN1">encodeValue: aLimitedPrecisionReal with: aMarshaler	"... the method invoked when marshaling type wrappers or marshaling type-in-hand."	aMarshaler encodeREAL: aLimitedPrecisionReal</body><body package="ASN1">tagBER	"... avoid the namespace lookup."	^02r00001001	"ASN1.UniversalREAL = 9"</body></methods><initialize><class-id>ASN1.TLVStream</class-id></initialize><initialize><class-id>ASN1.BERStreamBasic</class-id></initialize><initialize><class-id>ASN1.BERStreamDefinite</class-id></initialize><initialize><class-id>ASN1.DERStream</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>ByteString</name><environment>Core</environment><super>Core.ByteEncodedString</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-String Support</category><attributes><package>Collections-String Support</package></attributes></class><class><name>Type</name><environment>ASN1</environment><super>ASN1.Entity</super><private>false</private><indexed-type>none</indexed-type><inst-vars>constraint retainEncoding tag tagging </inst-vars><class-inst-vars>defaultConstraint </class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><class><name>ConstructedType</name><environment>ASN1</environment><super>ASN1.Type</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><class><name>MappableType</name><environment>ASN1</environment><super>ASN1.StructuredType</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mapping </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><class><name>ANY</name><environment>ASN1</environment><super>ASN1.BasicType</super><private>false</private><indexed-type>none</indexed-type><inst-vars>definedBy typeMap </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><class><name>MarkerElement</name><environment>ASN1</environment><super>ASN1.AbstractElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><class><name>Stream</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private IOConstants.*			</imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>UniversalString</name><environment>ASN1</environment><super>ASN1.StringType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><class><name>UnstructuredType</name><environment>ASN1</environment><super>ASN1.ConstructedType</super><private>false</private><indexed-type>none</indexed-type><inst-vars>elementType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><class><name>OBJECT_IDENTIFIER</name><environment>ASN1</environment><super>ASN1.BasicType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><class><name>ChoiceElement</name><environment>ASN1</environment><super>ASN1.AbstractElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>owner symbol type </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><class><name>StructureElement</name><environment>ASN1</environment><super>ASN1.ChoiceElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>default optional </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><class><name>SEQUENCE</name><environment>ASN1</environment><super>ASN1.MappableType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><class><name>Integer</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>UTF8String</name><environment>ASN1</environment><super>ASN1.StringType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><class><name>Boolean</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>VideotexString</name><environment>ASN1</environment><super>ASN1.StringType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><class><name>CHOICE</name><environment>ASN1</environment><super>ASN1.StructuredType</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tags useChoice </inst-vars><class-inst-vars>defaultUseChoice </class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><class><name>ObjectIdentifier</name><environment>ASN1</environment><super>ASN1.Imported</super><private>false</private><indexed-type>none</indexed-type><inst-vars>encoding </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Support</package></attributes></class><class><name>TeletexString</name><environment>ASN1</environment><super>ASN1.StringType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><class><name>BOOLEAN</name><environment>ASN1</environment><super>ASN1.BasicType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><class><name>Timestamp</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>year month day hours minutes seconds milliseconds partialNanosecond </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>IA5String</name><environment>ASN1</environment><super>ASN1.StringType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><class><name>VisibleString</name><environment>ASN1</environment><super>ASN1.IA5String</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><class><name>UTCTime</name><environment>ASN1</environment><super>ASN1.VisibleString</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><class><name>GraphicString</name><environment>ASN1</environment><super>ASN1.StringType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><class><name>TypeWrapper</name><environment>ASN1</environment><super>Protocols.MessageForwarder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>encoding type </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><class><name>BIT_STRING</name><environment>ASN1</environment><super>ASN1.BasicType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><class><name>PositionableStream</name><environment>Core</environment><super>Core.PeekableStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>collection position readLimit writeLimit policy </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>NULL</name><environment>ASN1</environment><super>ASN1.BasicType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><class><name>SET_OF</name><environment>ASN1</environment><super>ASN1.UnstructuredType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><class><name>BitString</name><environment>ASN1</environment><super>ASN1.Imported</super><private>false</private><indexed-type>none</indexed-type><inst-vars>unused </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Support</package></attributes></class><class><name>SEQUENCE_OF</name><environment>ASN1</environment><super>ASN1.UnstructuredType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><class><name>INTEGER</name><environment>ASN1</environment><super>ASN1.BasicType</super><private>false</private><indexed-type>none</indexed-type><inst-vars>identifiers </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><class><name>PrintableString</name><environment>ASN1</environment><super>ASN1.IA5String</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><class><name>SET</name><environment>ASN1</environment><super>ASN1.MappableType</super><private>false</private><indexed-type>none</indexed-type><inst-vars>decodingDictionary encodingDictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><class><name>ByteArray</name><environment>Core</environment><super>Core.IntegerArray</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>ENUMERATED</name><environment>ASN1</environment><super>ASN1.BasicType</super><private>false</private><indexed-type>none</indexed-type><inst-vars>elements extensibleAt useEnumeration complete </inst-vars><class-inst-vars>defaultUseEnumeration </class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><class><name>UndefinedObject</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>GeneralizedTime</name><environment>ASN1</environment><super>ASN1.VisibleString</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><class><name>GeneralString</name><environment>ASN1</environment><super>ASN1.StringType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><class><name>OCTET_STRING</name><environment>ASN1</environment><super>ASN1.BasicType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><class><name>Enumeration</name><environment>ASN1</environment><super>ASN1.TypeWrapper</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><class><name>BMPString</name><environment>ASN1</environment><super>ASN1.StringType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><class><name>ObjectDescriptor</name><environment>ASN1</environment><super>ASN1.BasicType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><class><name>OrderedCollection</name><environment>Core</environment><super>Core.SequenceableCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>firstIndex lastIndex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Sequenceable</category><attributes><package>Collections-Sequenceable</package></attributes></class><class><name>RELATIVE_OID</name><environment>ASN1</environment><super>ASN1.BasicType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><class><name>Asn1Error</name><environment>ASN1</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Support</package></attributes></class><class><name>Choice</name><environment>ASN1</environment><super>ASN1.TypeWrapper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>choice </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><class><name>NumericString</name><environment>ASN1</environment><super>ASN1.IA5String</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><class><name>REAL</name><environment>ASN1</environment><super>ASN1.BasicType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1</category><attributes><package>ASN1-Types</package></attributes></class><class><name>Struct</name><environment>ASN1</environment><super>Protocols.Struct</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>encoding </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ASN1-Support</category><attributes><package>ASN1-Support</package></attributes></class></st-source>