<?xml version="1.0"?><st-source><!-- Name: Grid SUnit TestsNotice: Copyright 1999-2013 Cincom Systems, Inc.  All rights reserved.Comment: Unit tests for Grid and supporting classes.DbIdentifier: bear73DbTrace: 400316DbUsername: nrossDbVersion: 7.10 - 1DevelopmentPrerequisites: #(#(#any 'SUnit' ''))PackageName: Grid SUnit TestsParcel: #('Grid SUnit Tests')ParcelName: Grid SUnit TestsPrerequisiteParcels: #(#('SUnit' ''))PrintStringCache: (7.10 - 1,nross)Version: 7.10 - 1Date: 6:45:46 AM April 3, 2013 --><time-stamp>From VisualWorksÂ®, Pre-Release 7.10 (mar13.5) of April 3, 2013 on April 3, 2013 at 6:45:46 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>GridTest</name><environment>Smalltalk</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>grid rows columns gridApp entries </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Smalltalk-Tests</category><attributes><package>Grid SUnit Tests</package></attributes></class><comment><class-id>GridTest</class-id><body>GridTest unit tests access, updates, selection, and model behavior of the Grid widget view.  If possible, tests are run without opening a gridApp window.Instance Variables	columns	&lt;OrderedCollection of: GridColumn&gt;	grid columns to format and display data 	entries 	&lt;Array of: Point&gt;  sample point data for one row and each column	grid		&lt;Grid&gt;	grid under test	gridApp	&lt;ApplicationModel&gt;	ApplicationModel that contains grid widget	rows	&lt;List of: GridRow&gt;	list of sample GridRows</body></comment><class><name>GridVisualSegmentTest</name><environment>Smalltalk</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>a b c x y z </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Smalltalk-Tests</category><attributes><package>Grid SUnit Tests</package></attributes></class><comment><class-id>GridVisualSegmentTest</class-id><body>GridVisualSegmentTest tests access, insertion, removal, enumeration, and combining of a linked list of elements in a GridVisualSegmentInstance Variables:	a	&lt;GridVisualColumn&gt;	GridVisualSegment sample a	b	&lt;GridVisualColumn&gt;	GridVisualSegment sample b	c	&lt;GridVisualColumn&gt;	GridVisualSegment sample c	x	&lt;GridVisualColumn&gt;	GridVisualSegment sample x	y	&lt;GridVisualColumn&gt;	GridVisualSegment sample y	z	&lt;GridVisualColumn&gt;	GridVisualSegment sample z</body></comment><class><name>GridVisualColumnTest</name><environment>Smalltalk</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>grid firstVisibleColumn columns </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Smalltalk-Tests</category><attributes><package>Grid SUnit Tests</package></attributes></class><comment><class-id>GridVisualColumnTest</class-id><body>GridVisualColumnTest tests scrolling, access, resizing, and enumeration behavior of a GridVisualColumnInstance Variables:	columns	&lt;OrderedCollection of: GridColumn&gt;	grid columns to format and display data 	firstVisibleColumn	&lt;GridVisualColumn&gt;	instance of the first visible column in the grid	grid		&lt;Grid&gt;	grid under test</body></comment><class><name>GridInterfaceTest</name><environment>Smalltalk</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>grid gridInterface entries columns gridApp </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Grid SUnit Tests</package></attributes></class><comment><class-id>GridInterfaceTest</class-id><body>GridInterfaceTest unit tests the access and update behavior of the GridInterfaceInstance Variables	grid	&lt;Grid&gt;	Grid used by the GridInterface	gridInterface	&lt;GridInterface&gt;	GridInterface under test	entries 	&lt;Array of: Point&gt;  sample point data for one row and each column	columns	&lt;OrderedCollection of: GridColumn&gt;	grid columns to format and display data </body></comment><class><name>GridDecoratorTest</name><environment>Smalltalk</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>grid rows gridApp gridInterface </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Smalltalk-Tests</category><attributes><package>Grid SUnit Tests</package></attributes></class><comment><class-id>GridDecoratorTest</class-id><body>Tests to ensure grid column and row headers coordinate with scroll and resize of grid proper.  Test that header options don't cause exceptions at a minimum.</body></comment><class><name>SortItem</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value name variable </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Sort Example</category><attributes><package>Grid SUnit Tests</package></attributes></class><comment><class-id>SortItem</class-id><body>SortItem is a simple test object for demonstrating the Grid column sort mechanism Instance Variables:	name	&lt;String&gt;	name of item	value	&lt;Object&gt;	any value	variable	&lt;Object&gt;	any variable</body></comment><class><name>GridVisualRowTest</name><environment>Smalltalk</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>grid firstVisibleRow rows </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Smalltalk-Tests</category><attributes><package>Grid SUnit Tests</package></attributes></class><comment><class-id>GridVisualRowTest</class-id><body>GridVisualRowTest tests scrolling, access, resizing, and enumeration behavior of a GridVisualRowInstance Variables	firstVisibleRow	&lt;GridVisualRow&gt;	instance of the first visible row in the grid	grid		&lt;Grid&gt;	grid under test	rows	&lt;OrderedCollection of: GridRow&gt;	grid rows holding data and width information</body></comment><class><name>GridColumnSortConstraintTest</name><environment>Smalltalk</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>listToSort column1 column2 column3 column4 </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Smalltalk-Tests</category><attributes><package>Grid SUnit Tests</package></attributes></class><comment><class-id>GridColumnSortConstraintTest</class-id><body>GridColumnSortConstraintTest tests grid column sorting and constraint manipulationInstance Variables	column1	&lt;GridColumn&gt;	sample column 1	column2	&lt;GridColumn&gt;	sample column 2	column3	&lt;GridColumn&gt;	sample column 3	column4	&lt;GridColumn&gt;	sample column 4	listToSort	&lt;Collection&gt;	sample list of GridRows to sort</body></comment><class><name>EmptyGridApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>gridInterface </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Smalltalk-Tests</category><attributes><package>Grid SUnit Tests</package></attributes></class><comment><class-id>EmptyGridApp</class-id><body>EmptyGridApp is a sample class for interactive and programmatic Grid tests with headers.Instance Variables	gridInterface &lt;GridInterface&gt; GridInterface control object on Grid, its selection model, and headers.</body></comment><class><name>SelectionInGridTest</name><environment>Smalltalk</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>rows grid selectionInGrid </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Grid SUnit Tests</package></attributes></class><comment><class-id>SelectionInGridTest</class-id><body>SelectionInGridTest tests unit behavior of the Grid selection model.Instance Variables:	grid		&lt;Grid&gt;	grid under test.	rows	&lt;List&gt;	list of GridRows provided to the Grid. 	selectionInGrid	&lt;SelectionInGrid&gt;	grid selection model.</body></comment><class><name>EmptyViewApp</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>grid </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Smalltalk-Tests</category><attributes><package>Grid SUnit Tests</package></attributes></class><comment><class-id>EmptyViewApp</class-id><body>EmptyViewApp is a sample class for interactive and programmatic Grid tests.Instance Variables	grid	&lt;Grid&gt;	Grid view</body></comment><methods><class-id>GridTest</class-id> <category>private</category><body package="Grid SUnit Tests">addColumnIndex: anInteger		| newColumn startIndex |	startIndex := anInteger + 1.	newColumn := GridColumn		spec: (self columnInputSpecIndexedBy: startIndex)		width: 50.	entries keysAndValuesDo:[:index :value| entries at: index put: (value copyWith: (index @ startIndex))].	entries with: rows do:[:item :row| row item: item].	columns add: newColumn beforeIndex: anInteger.</body><body package="Grid SUnit Tests">addColumnsNumbering: anInteger	| newColumns startSize range |	startSize := columns size.	range := startSize + 1 to: startSize + anInteger.	newColumns := range				collect: [:index | GridColumn spec: (self columnInputSpecIndexedBy: index) width: 50].	entries keysAndValuesDo: 			[:index :value |			| addValues |			addValues := range collect: [:x | x @ index].			entries at: index put: value , addValues].	entries with: rows do: [:item :row | row item: item].	columns addAll: newColumns</body><body package="Grid SUnit Tests">addRowIndex: anInteger		| newRow |	newRow := GridRow		on: ((1 to: grid numberOfColumns) collect: [:x | x @ anInteger ])		height: 25.	rows add: newRow beforeIndex: anInteger.	anInteger + 1		to: rows size		do:			[:index | 			| row |			row := rows at: index.			row item do: [:each | each y: index]].</body><body package="Grid SUnit Tests">addRowsFrom: start to: end		| newRows |	newRows := (start to: end)		collect:			[:index | 			GridRow				on: ((1 to: grid numberOfColumns) collect: [:x | x @ index])				height: 25].	rows addAll: newRows beforeIndex: start.	end + 1		to: rows size		do:			[:index | 			| row |			row := rows at: index.			row item do: [:each | each y: index]].</body><body package="Grid SUnit Tests">addRowsNumbering: anInteger		| newRows startSize |	startSize := rows size.	newRows := (startSize + 1 to: startSize + anInteger)		collect:			[:index | 			GridRow				on: ((1 to: grid numberOfColumns) collect: [:x | x @ index])				height: 25].	rows addAll: newRows.</body><body package="Grid SUnit Tests">cellTestColumnPosition: aSymbol 	aSymbol = #right 		ifTrue: [self assert: grid bounds right = grid lastVisibleColumn right].	aSymbol = #left 		ifTrue: [self assert: grid bounds left = grid firstVisibleColumn left].	aSymbol = #center 		ifTrue: 			[| visualMidColumn midColumn |			midColumn := grid columns at: grid numberOfColumns // 2.			visualMidColumn := grid firstVisibleColumn visualForColumn: midColumn						ifNone: [self assert: false].			self assert: grid bounds center x 						= (visualMidColumn left midpoint: visualMidColumn right) rounded]</body><body package="Grid SUnit Tests">cellTestRowPosition: aSymbol 	aSymbol = #top 		ifTrue: [self assert: grid bounds top = grid firstVisibleRow top].	aSymbol = #bottom 		ifTrue: [self assert: grid bounds bottom = grid lastVisibleRow bottom].	aSymbol = #center 		ifTrue: 			[| midRow visualMidRow |			midRow := grid rows at: grid numberOfRows // 2.			visualMidRow := grid firstVisibleRow visualForRow: midRow						ifNone: [self assert: false].			self assert: grid bounds center y 						= (visualMidRow top midpoint: visualMidRow bottom) rounded]</body><body package="Grid SUnit Tests">columnInputSpecIndexedBy: anInteger	^InputFieldSpec new 		name: anInteger;		model: ('_row ', anInteger printString) asSymbol;		type: #object;		yourself</body><body package="Grid SUnit Tests">removeColumnIndex: anInteger		columns removeAtIndex: anInteger.	anInteger		to: columns size		do:			[:index | 			| row |			row := rows at: index.			row item do: [:each | each x: index]].</body><body package="Grid SUnit Tests">removeColumnsFrom: start to: stop		columns removeFrom: start to: stop.	start		to: columns size		do:			[:index | 			| column |			column := columns at: index.			column item do: [:each | each x: index]].</body><body package="Grid SUnit Tests">removeRowIndex: anInteger		rows removeAtIndex: anInteger.	anInteger		to: rows size		do:			[:index | 			| row |			row := rows at: index.			row item do: [:each | each y: index]].</body><body package="Grid SUnit Tests">removeRowsFrom: start to: stop		rows removeFrom: start to: stop.	start		to: rows size		do:			[:index | 			| row |			row := rows at: index.			row item do: [:each | each y: index]].</body></methods><methods><class-id>GridTest</class-id> <category>accessing</category><body package="Grid SUnit Tests">grid	^grid</body><body package="Grid SUnit Tests">gridApp	^gridApp</body><body package="Grid SUnit Tests">rows	^rows</body></methods><methods><class-id>GridTest</class-id> <category>Running</category><body package="Grid SUnit Tests">setUp	| numColumns numRows |	numRows := 20.	numColumns := 20.	entries := (1 to: numRows) 				collect: [:y | (1 to: numColumns) collect: [:x | x @ y]].	rows := entries asList collect: [:item | GridRow on: item height: 25].	grid := Grid new.	grid rows: rows.	1 to: numColumns		do: 			[:i |			GridColumn				spec: (self columnInputSpecIndexedBy: i)				in: grid				width: 50].	columns := grid columns.	gridApp := EmptyViewApp new grid: grid</body><body package="Grid SUnit Tests">tearDown	super tearDown.	gridApp closeRequest.	grid := rows := columns := gridApp := nil.</body></methods><methods><class-id>GridTest</class-id> <category>column tests</category><body package="Grid SUnit Tests">testAddColumn	| column |	grid := Grid new.	column := columns first.	self assert: grid scrollableExtent = (0 @ 0).	grid addColumn: column.	self assert: grid columns asArray = (Array with: column).	self assert: grid scrollableExtent = (column widthWithGap @ 0).	self assert: grid = column grid.</body><body package="Grid SUnit Tests">testColumns	| totalWidth columnsCopy |	grid := Grid new.	self assert: grid scrollableExtent = (0@0).	totalWidth := columns inject: 0 into:[:sofar :each| sofar + each widthWithGap].	grid columns: columns.	self assert: grid columns = columns.	self assert: (columns dependents includes: grid).	columns do: [:column | self assert: grid = column grid].	self assert: grid scrollableExtent = (totalWidth@0).	columnsCopy := columns collect:[:each| each copy].	grid columns: columnsCopy.	self deny: (columns dependents includes: grid).	self assert: (columnsCopy dependents includes: grid).	columns do: [:column | self assert: column grid isNil].</body><body package="Grid SUnit Tests">testMoveColumnIndexToIndex	| col1 col2 col3 col4 |	grid := Grid new.	4 timesRepeat: [grid addColumn: GridColumn new].	columns := grid columns.	col1 := columns at: 1.	col2 := columns at: 2.	col3 := columns at: 3.	col4 := columns at: 4.	grid moveColumnIndex: 1 toIndex: 4.	self assert: (grid columns isSameSequenceAs: (Array with: col2 with: col3 with:col4 with: col1)).	grid moveColumnIndex: 4 toIndex: 1.	self assert: (grid columns isSameSequenceAs: (Array with: col1 with: col2 with: col3 with:col4)).	grid moveColumnIndex: 1 toIndex: 3.	self assert: (grid columns isSameSequenceAs: (Array with: col2 with: col3 with: col1 with:col4)).	grid moveColumnIndex: 3 toIndex: 1.	self assert: (grid columns isSameSequenceAs: (Array with: col1 with: col2 with: col3 with:col4)).	grid moveColumnIndex: 2 toIndex: 4.	self assert: (grid columns isSameSequenceAs: (Array with: col1 with: col3 with:col4 with: col2)).	grid moveColumnIndex: 4 toIndex: 2.	self assert: (grid columns isSameSequenceAs: (Array with: col1 with: col2 with: col3 with:col4)).	grid moveColumnIndex: 2 toIndex: 3.	self assert: (grid columns isSameSequenceAs: (Array with: col1 with: col3 with: col2 with:col4)).	grid moveColumnIndex: 3 toIndex: 2.	self assert: (grid columns isSameSequenceAs: (Array with: col1 with: col2 with: col3 with:col4)).	grid moveColumnIndex: 3 toIndex: 3.	self assert: (grid columns isSameSequenceAs: (Array with: col1 with: col2 with: col3 with:col4)).</body><body package="Grid SUnit Tests">testVisibleColumnCount	self assert: grid visibleColumnCount = grid visibleColumns size.</body></methods><methods><class-id>GridTest</class-id> <category>selection tests</category><body package="Grid SUnit Tests">testCellAddColumnShift	"Test that cell selections shift when columns are added"		| expectedResult |	grid selectByCell: true.	"Select a checkerboard pattern of cells"	grid cellsDo: [:cell | (cell column index + cell row index) even ifTrue: [cell isSelected: true]].	expectedResult := grid selectionRange copy.	"Add column at end"	self addColumnsNumbering: 1.	self assert: (expectedResult - grid selectionRange) isEmpty."Add column at beginning"	self addColumnIndex: 1.	expectedResult := expectedResult		collect: [:range | range translatedBy: 1 @ 0].	self assert: (expectedResult - grid selectionRange) isEmpty.	"Add column at middle"	self addColumnIndex: 10.	expectedResult := expectedResult		collect:			[:range | 			range left &gt;= 10				ifTrue: [range translatedBy: 1 @ 0]				ifFalse: [range]].	self assert: (expectedResult - grid selectionRange) isEmpty</body><body package="Grid SUnit Tests">testCellAddRowShift	"Test that cell selections shift when rows are added"		| expectedResult |	grid selectByCell: true.	"Select a checkerboard pattern of cells"	grid cellsDo: [:cell | (cell column index + cell row index) even ifTrue: [cell isSelected: true]].	expectedResult := grid selectionRange copy.	"Add row at end"	self addRowsNumbering: 1.	self assert: (expectedResult - grid selectionRange) isEmpty.	"Add row at beginning"	self addRowIndex: 1.	expectedResult := expectedResult		collect: [:range | range translatedBy: 0 @ 1].	self assert: (expectedResult - grid selectionRange) isEmpty.	"Add row at middle"	self addRowIndex: 10.	expectedResult := expectedResult		collect:			[:range | 			range top &gt;= 10				ifTrue: [range translatedBy: 0 @ 1]				ifFalse: [range]].	self assert: (expectedResult - grid selectionRange) isEmpty</body><body package="Grid SUnit Tests">testCellRemoveColumnShift	"Test that cell selections shift when columns are removed"		| expectedResult |	grid selectByCell: true.	"Select a checkerboard pattern of cells but with the left and right columns all selected"	grid cellsDo: [:cell | (cell column index + cell row index) even ifTrue: [cell isSelected: true]].	grid addSelectionRange: (1@1 corner: 1@20).	grid addSelectionRange: (20@1 corner: 20@20)."Remove column at end"	expectedResult := grid selectionRange copy.		self removeColumnIndex: 20.	expectedResult := expectedResult reject: [:range | range left = 20].	self assert: (expectedResult - grid selectionRange) isEmpty.	"Remove column at beginning"	self removeColumnIndex: 1.	expectedResult := expectedResult reject: [:range | range left = 1].	expectedResult := expectedResult collect: [:range | range translatedBy:  -1 @ 0 ].	self assert: (expectedResult - grid selectionRange) isEmpty.	"Remove column in middle"		self removeColumnIndex:  7.	expectedResult := expectedResult reject: [:range | range left = 7].	expectedResult := expectedResult collect: [:range | 			range left &gt; 7 ifTrue:[ range translatedBy: -1 @ 0] ifFalse:[range]].	expectedResult := expectedResult reject: [:range | range left = 7].	expectedResult do:[:range| range left = 6 ifTrue:[range right: 7]].	self assert: (expectedResult - grid selectionRange) isEmpty.</body><body package="Grid SUnit Tests">testCellRemoveRowShift	"Test that cell selections shift when rows are removed"		| expectedResult |	grid selectByCell: true.	"Select a checkerboard pattern of cells but with the top and bottom rows all selected"	grid cellsDo: [:cell | (cell column index + cell row index) even ifTrue: [cell isSelected: true]].	grid addSelectionRange: (1@1 corner: 20@1).	grid addSelectionRange: (1@20 corner: 20@20)."Remove row at end"	expectedResult := grid selectionRange copy.		self removeRowIndex: 20.	expectedResult := expectedResult reject: [:range | range top = 20].	self assert: (expectedResult - grid selectionRange) isEmpty.	"Remove row at beginning"	self removeRowIndex: 1.	expectedResult := expectedResult reject: [:range | range top = 1].	expectedResult := expectedResult collect: [:range | range translatedBy: 0 @ -1].	self assert: (expectedResult - grid selectionRange) isEmpty.	"Remove row in middle"		self removeRowIndex:  7.	expectedResult := expectedResult reject: [:range | range top = 7].	expectedResult := expectedResult collect: [:range | 			range top &gt; 7 ifTrue:[ range translatedBy: 0 @ -1] ifFalse:[range]].	expectedResult := expectedResult reject: [:range | range top = 7].	expectedResult do:[:range| range top = 6 ifTrue:[range bottom: 7]].	self assert: (expectedResult - grid selectionRange) isEmpty.</body><body package="Grid SUnit Tests">testCellSelectionAdd		| expectedResult |	grid selectByCell: true.	grid addSelectionRange: (1 @ 13 extent: 0 @ 0).	grid addSelectionRange: (2 @ 14 extent: 0 @ 0).	grid addSelectionRange: (2 @ 13 extent: 0 @ 0).	grid addSelectionRange: (1 @ 14 extent: 0 @ 0).	expectedResult := Set with: (1 @ 13 corner: 2 @ 14).	self assert: (expectedResult - grid selectionRange) isEmpty.	grid		selectionRange:			(Set				with: (2 @ 13 extent: 0 @ 0)				with: (1 @ 14 extent: 0 @ 0)				with: (2 @ 14 extent: 0 @ 0)				with: (1 @ 13 extent: 0 @ 0)).	grid setLineSelectionExtent.	grid mergeSelections.	self assert: (expectedResult - grid selectionRange) isEmpty.	expectedResult := Set with: (1 @ 1 corner: 3 @ 3).	grid selectionRange: expectedResult.	grid addSelectionRange: (2 @ 2 corner: 3 @ 3).	self assert: grid selectionRange = expectedResult.	expectedResult := Set with: (1 @ 4 corner: 4 @ 4).	grid selectionRange: (Set with: (1 @ 4 corner: 2 @ 4)).	grid addSelectionRange: (3 @ 4 corner: 4 @ 4).	self assert: (expectedResult - grid selectionRange) isEmpty.	expectedResult := Set with: (1 @ 1 corner: 1 @ 4).	grid selectionRange: (Set with: (1 @ 1 corner: 1 @ 2)).	grid addSelectionRange: (1 @ 3 corner: 1 @ 4).	self assert: (expectedResult - grid selectionRange) isEmpty</body><body package="Grid SUnit Tests">testCellSelectionRemove		| expectedResult |	grid selectByCell: true.	grid selectionRange: (Set with: (1 @ 13 corner: 2 @ 14)).	self		assert:			(grid removeSelectionRange: (1 @ 13 extent: 0 @ 0))				= (1 @ 13 extent: 0 @ 0).	expectedResult := Set		with: (2 @ 13 corner: 2 @ 13)		with: (1 @ 14 corner: 2 @ 14).	self assert: (expectedResult - grid selectionRange) isEmpty.	self		assert:			(grid removeSelectionRange: (2 @ 14 extent: 0 @ 0))				= (2 @ 14 extent: 0 @ 0).	expectedResult := Set		with: (2 @ 13 extent: 0 @ 0)		with: (1 @ 14 extent: 0 @ 0).	self assert: (expectedResult - grid selectionRange) isEmpty.	self		assert:			(grid removeSelectionRange: (2 @ 13 extent: 0 @ 0))				= (2 @ 13 extent: 0 @ 0).	expectedResult := Set with: (1 @ 14 extent: 0 @ 0).	self assert: (expectedResult - grid selectionRange) isEmpty.	self		assert:			(grid removeSelectionRange: (1 @ 14 extent: 0 @ 0))				= (1 @ 14 extent: 0 @ 0).	self assert: grid selectionRange isEmpty.	grid selectionRange: (Set with: (1 @ 13 corner: 2 @ 14)).	self		assert:			(grid removeSelectionRange: (1 @ 13 extent: 2 @ 2))				= (1 @ 13 extent: 2 @ 2).	self assert: grid selectionRange isEmpty.	grid selectionRange: (Set with: (1 @ 13 corner: 2 @ 14)).	self		assert:			(grid removeSelectionRange: (1 @ 13 corner: 2 @ 14))				= (1 @ 13 corner: 2 @ 14).	self assert: grid selectionRange isEmpty.	grid selectionRange: (Set with: (2 @ 1 corner: 3 @ 4)).	self		assert:			(grid removeSelectionRange: (1 @ 1 corner: 3 @ 3)) = (1 @ 1 corner: 3 @ 3).	self assert: ((Set with: (2 @ 4 corner: 3 @ 4)) - grid selectionRange) isEmpty.	expectedResult := Set with: (2 @ 1 corner: 3 @ 4).	grid selectionRange: expectedResult.	self		assert:			(grid removeSelectionRange: (5 @ 1 extent: 3 @ 3)) = (5 @ 1 extent: 3 @ 3).	self assert: grid selectionRange = expectedResult.	expectedResult := Set with: (1 @ 4 corner: 2 @ 4).	grid selectionRange: (Set with: (1 @ 4 corner: 4 @ 4)).	self		assert:			(grid removeSelectionRange: (3 @ 4 corner: 4 @ 4)) = (3 @ 4 corner: 4 @ 4).	self assert: (expectedResult - grid selectionRange) isEmpty.	expectedResult := Set with: (1 @ 1 corner: 1 @ 2).	grid selectionRange: (Set with: (1 @ 1 corner: 1 @ 4)).	self		assert:			(grid removeSelectionRange: (1 @ 3 corner: 1 @ 4)) = (1 @ 3 corner: 1 @ 4).	self assert: (expectedResult - grid selectionRange) isEmpty</body><body package="Grid SUnit Tests">testCellSelectionReplace		grid selectByCell: true.	grid selectionRange: (Set with: (1 @ 13 corner: 2 @ 14)).	self		assert:			(grid replaceSelectionRange: (1 @ 13 extent: 0 @ 0))				= (1 @ 13 corner: 2 @ 14).	self		assert: ((Set with: (1 @ 13 extent: 0 @ 0)) - grid selectionRange) isEmpty.	grid selectionRange: (Set with: (1 @ 13 corner: 2 @ 14)).	self		assert:			(grid replaceSelectionRange: (1 @ 5 extent: 0 @ 0))				= (1 @ 5 corner: 2 @ 14).	self assert: ((Set with: (1 @ 5 extent: 0 @ 0)) - grid selectionRange) isEmpty.	grid selectionRange: (Set with: (1 @ 13 corner: 2 @ 14)).	self		assert:			(grid replaceSelectionRange: (1 @ 13 corner: 2 @ 14))				= (1 @ 13 corner: 2 @ 14).	self		assert: ((Set with: (1 @ 13 corner: 2 @ 14)) - grid selectionRange) isEmpty.	grid selectionRange: (Set with: (1 @ 13 corner: 3 @ 15)).	self		assert:			(grid replaceSelectionRange: (2 @ 14 corner: 4 @ 16))				= (1 @ 13 corner: 4 @ 16).	self		assert: ((Set with: (2 @ 14 corner: 4 @ 16)) - grid selectionRange) isEmpty</body><body package="Grid SUnit Tests">testClipSelections	"Test that out of bounds selections may be removed"	grid selectByCell: false.	grid selectionRange: (Set with: (1 @ 21 corner: 20 @ 22) with: (1 @ 0 corner: 21 @ 0)).	grid clipSelections.	self assert: grid selectionRange isEmpty.	grid selectionRange: (Set with: (0 @ 0 corner: 21 @ 2) with: (0 @ 20 corner: 21 @ 21)).	grid clipSelections.	self assert: ((Set with: (1 @ 1 corner: 20 @ 2) with: (1 @ 20 corner: 20 @ 20)) - grid selectionRange) isEmpty.	grid selectByCell: true.	grid selectionRange: (Set with: (0 @ 0 corner: 1 @ 1) with: (0 @ 20 corner: 1 @ 22) with: (20 @ 20 corner: 22@22) with: (20 @ 0 corner: 22 @ 1)).	grid clipSelections.	self assert: ((Set with: (1 @ 1 extent: 0 @ 0) with: (1 @ 20 extent: 0 @ 0)  with: (20 @ 20 extent: 0 @ 0) with: (20 @ 1 extent: 0 @ 0)) - grid selectionRange) isEmpty.</body><body package="Grid SUnit Tests">testLineSelectionAdd		| expectedResult |	grid selectByCell: false.	grid addSelectionRange: (1 @ 13 extent: 0 @ 0).	expectedResult := Set with: (1 @ 13 corner: grid numberOfColumns @ 13).	self assert: (expectedResult - grid selectionRange) isEmpty.	grid addSelectionRange: (1 @ 14 extent: 0 @ 0).	expectedResult := Set with: (1 @ 13 corner: grid numberOfColumns @ 14).	self assert: (expectedResult - grid selectionRange) isEmpty.	grid addSelectionRange: (1 @ 16 extent: 0 @ 0).	expectedResult := Set		with: (1 @ 13 corner: grid numberOfColumns @ 14)		with: (1 @ 16 corner: grid numberOfColumns @ 16).	self assert: (expectedResult - grid selectionRange) isEmpty.	grid addSelectionRange: (1 @ 15 extent: 0 @ 0).	expectedResult := Set with: (1 @ 13 corner: grid numberOfColumns @ 16).	self assert: (expectedResult - grid selectionRange) isEmpty.	grid		selectionRange:			(Set				with: (1 @ 13 extent: 0 @ 0)				with: (1 @ 14 extent: 0 @ 0)				with: (1 @ 16 extent: 0 @ 0)				with: (1 @ 15 extent: 0 @ 0)).	grid setLineSelectionExtent.	grid mergeSelections.	self assert: (expectedResult - grid selectionRange) isEmpty.	expectedResult := Set with: (1 @ 1 corner: grid numberOfColumns @ 3).	grid selectionRange: expectedResult.	grid addSelectionRange: (1 @ 2 corner: grid numberOfColumns @ 3).	self assert: grid selectionRange = expectedResult</body><body package="Grid SUnit Tests">testLineSelectionMove	| sourceRange destRange |	grid selectByCell: false.	sourceRange := (1 @ 13 corner: 20 @ 14).	grid selectionRange: (Set with: sourceRange).	"Null move"	grid moveSelectionRange: sourceRange to: sourceRange.	self assert: grid selectionRange = (Set with: sourceRange).	"Shift to overlapping destination down 1 row"	destRange := sourceRange translatedBy: 0@1.	grid moveSelectionRange: sourceRange to: destRange.	self assert: grid selectionRange = (Set with: destRange).	"Shift to non-overlapping destination down 2 rows"	sourceRange := (1 @ 13 corner: 20 @ 14).	destRange := (1 @ 15 corner: 20 @ 16).	grid selectionRange: (Set with: sourceRange).	grid moveSelectionRange: sourceRange to: destRange.	self assert: grid selectionRange = (Set with: destRange).	"Shift to non-overlapping destination to top 2 rows"	sourceRange := destRange.	destRange := (1 @ 1 corner: 20 @ 2).	grid moveSelectionRange: sourceRange to: destRange.	self assert: grid selectionRange = (Set with: destRange).	"Shift to bottom out of range"	sourceRange := destRange.	destRange := (1 @ 21 corner: 20 @ 22).	grid moveSelectionRange: sourceRange to: destRange.	self assert: grid selectionRange = (Set with: destRange).	"Move with unequal size ranges and non-overlapping destination"	sourceRange := (1 @ 13 corner: 20 @ 14).	destRange := (1 @ 15 corner: 20 @ 15).	grid selectionRange: (Set with: sourceRange).	grid moveSelectionRange: sourceRange to: destRange.	self assert: grid selectionRange = (Set with: destRange).	"Select lines in non-overlapping source and destination regions then move"	sourceRange := (1 @ 13 corner: 20 @ 14).	destRange := (1 @ 1 corner: 20 @ 2).	grid selectionRange: (Set with: (1 @ 14 corner:  20 @ 14)).	grid moveSelectionRange: sourceRange to: destRange.	self assert: grid selectionRange = (Set with: (1 @ 2 corner: 20 @ 2))</body><body package="Grid SUnit Tests">testLineSelectionRemove		| expectedResult |	grid selectByCell: false.	grid selectionRange: (Set with: (1 @ 13 corner: grid numberOfColumns @ 16)).	self		assert:			(grid removeSelectionRange: (1 @ 15 extent: 0 @ 0))				= (1 @ 15 corner: grid numberOfColumns @ 15).	expectedResult := Set		with: (1 @ 13 corner: grid numberOfColumns @ 14)		with: (1 @ 16 corner: grid numberOfColumns @ 16).	self assert: (expectedResult - grid selectionRange) isEmpty.	self		assert:			(grid removeSelectionRange: (1 @ 16 extent: 0 @ 0))				= (1 @ 16 corner: grid numberOfColumns @ 16).	expectedResult := Set with: (1 @ 13 corner: grid numberOfColumns @ 14).	self assert: (expectedResult - grid selectionRange) isEmpty.	self		assert:			(grid removeSelectionRange: (1 @ 14 extent: 0 @ 0))				= (1 @ 14 corner: grid numberOfColumns @ 14).	expectedResult := Set with: (1 @ 13 corner: grid numberOfColumns @ 13).	self assert: (expectedResult - grid selectionRange) isEmpty.	self		assert:			(grid removeSelectionRange: (1 @ 13 extent: 0 @ 0))				= (1 @ 13 corner: grid numberOfColumns @ 13).	self assert: grid selectionRange isEmpty.	"Still empty when removing an absent selection"	self		assert:			(grid removeSelectionRange: (1 @ 13 extent: 0 @ 0))				= (1 @ 13 corner: grid numberOfColumns @ 13).	self assert: grid selectionRange isEmpty.	grid selectionRange: (Set with: (1 @ 13 corner: grid numberOfColumns @ 16)).	self		assert:			(grid removeSelectionRange: (1 @ 12 extent: 0 @ 5))				= (1 @ 12 corner: grid numberOfColumns @ 17).	self assert: grid selectionRange isEmpty.	grid selectionRange: (Set with: (1 @ 13 corner: grid numberOfColumns @ 16)).	self		assert:			(grid removeSelectionRange: (1 @ 13 corner: grid numberOfColumns @ 16))				= (1 @ 13 corner: grid numberOfColumns @ 16).	self assert: grid selectionRange isEmpty</body><body package="Grid SUnit Tests">testLineSelectionReplace		grid selectByCell: false.	grid selectionRange: (Set with: (1 @ 13 corner: grid numberOfColumns @ 14)).	self		assert:			(grid replaceSelectionRange: (1 @ 13 extent: 0 @ 1))				= (1 @ 13 corner: grid numberOfColumns @ 14).	self		assert:			((Set with: (1 @ 13 corner: grid numberOfColumns @ 14)) - grid selectionRange)				isEmpty.	grid selectionRange: (Set with: (2 @ 13 corner: grid numberOfColumns @ 14)).	self		assert:			(grid replaceSelectionRange: (2 @ 12 extent: 0 @ 0))				= (1 @ 12 corner: grid numberOfColumns @ 14).	self		assert:			((Set with: (1 @ 12 corner: grid numberOfColumns @ 12)) - grid selectionRange)				isEmpty.	grid selectionRange: (Set with: (1 @ 13 corner: grid numberOfColumns @ 14)).	self		assert:			(grid replaceSelectionRange: (1 @ 15 extent: 0 @ 0))				= (1 @ 13 corner: grid numberOfColumns @ 15).	self		assert:			((Set with: (1 @ 15 corner: grid numberOfColumns @ 15)) - grid selectionRange)				isEmpty.	grid selectionRange: (Set with: (1 @ 13 corner: grid numberOfColumns @ 14)).	self		assert:			(grid replaceSelectionRange: (2 @ 10 corner: 4 @ 16))				= (1 @ 10 corner: grid numberOfColumns @ 16).	self		assert:			((Set with: (1 @ 10 corner: grid numberOfColumns @ 16)) - grid selectionRange)				isEmpty</body><body package="Grid SUnit Tests">testLineSelectionSwap		| sourceRange destRange |	grid selectByCell: false.	sourceRange := 1 @ 13 corner: 20 @ 14.	grid selectionRange: (Set with: sourceRange).	"Null swap"	grid swapSelectionRange: sourceRange with: sourceRange.	self assert: grid selectionRange = (Set with: sourceRange).	"Swap with equal size overlapping destination"	destRange := 1 @ 14 corner: 20 @ 15.	grid swapSelectionRange: sourceRange with: destRange.	self assert: grid selectionRange = (Set with: destRange).	"Swap with equal size non-overlapping destination"	sourceRange := destRange.	destRange := sourceRange translatedBy: 0 @ 2.	grid swapSelectionRange: sourceRange with: destRange.	self assert: grid selectionRange = (Set with: destRange).	"Swap with equal size out of range destination"	sourceRange := destRange.	destRange := 1 @ 21 corner: 20 @ 22.	grid swapSelectionRange: sourceRange with: destRange.	self assert: grid selectionRange = (Set with: destRange).	"Swap with unequal size ranges and non-overlapping destination"	sourceRange := 1 @ 13 corner: 20 @ 14.	destRange := 1 @ 15 corner: 20 @ 15.	grid selectionRange: (Set with: sourceRange).	grid swapSelectionRange: sourceRange with: destRange.	self assert: grid selectionRange = (Set with: destRange).	"Select lines in non-overlapping source and destination regions then swap"	sourceRange := 1 @ 13 corner: 20 @ 14.	destRange := 1 @ 1 corner: 20 @ 2.	grid		selectionRange:			(Set				with: (1 @ 14 corner: 20 @ 14)				with: (1 @ 1 corner: 20 @ 1)).	grid swapSelectionRange: sourceRange with: destRange.	self		assert:			((Set				with: (1 @ 2 corner: 20 @ 2)				with: (1 @ 13 corner: 20 @ 13)) - grid selectionRange) isEmpty</body><body package="Grid SUnit Tests">testRowAddShift	"Test that selections shift from added rows"	| expectedResult |	grid selectAll.	expectedResult := Set with: (1 @ 1 corner: 20 @ 20).	"Add row at end"	self addRowsNumbering: 1.	self assert: (expectedResult - grid selectionRange) isEmpty.	"Add row at beginning"	self addRowIndex: 1.	expectedResult := Set with: (1 @ 2 corner:  20 @ 21).	self assert: (expectedResult - grid selectionRange) isEmpty.	"Add row at middle"	self addRowIndex: 10.	expectedResult := Set with: (1 @ 2 corner:  20 @ 9) with: (1 @ 11 corner:  20 @ 22).	self assert: (expectedResult - grid selectionRange) isEmpty.</body><body package="Grid SUnit Tests">testRowRemoveShift	"Test that selections shift when rows are removed"	| expectedResult |	expectedResult := (Set with: (1@5 corner: 20 @ 10)).	grid selectionRange: expectedResult copy.		"Remove row at end"	self removeRowIndex: 20.	self assert: grid selectionRange = expectedResult.	"Remove 2 rows at end"	self removeRowsFrom: 18 to: 19.	self assert: grid selectionRange = expectedResult.	"Remove row at beginning"	self removeRowIndex:  1.	expectedResult := Set with: (1@4 corner: 20 @ 9).	self assert: grid selectionRange = expectedResult.	"Remove 2 rows at beginning"	self removeRowsFrom: 1 to: 2.	expectedResult := Set with: (1@2 corner: 20 @ 7).	self assert: grid selectionRange = expectedResult.	"Remove row in middle"	self removeRowIndex:  5.	expectedResult := Set with: (1@2 corner: 20 @ 6).	self assert: grid selectionRange = expectedResult.	"Remove rows in middle"	self removeRowsFrom: 2 to: 6.	self assert: grid selectionRange  isEmpty.</body><body package="Grid SUnit Tests">testRowSelections	grid selectByCell: false.	grid addSelectionRange: (1 @ 13 extent: 0 @ 3).	rows keysAndValuesDo: 			[:irow :row | 			(irow between: 13 and: 16) 				ifTrue: [self assert: row isSelected]				ifFalse: [self deny: row isSelected]]</body><body package="Grid SUnit Tests">testRowsAddShift	"Test that selections shift when adding several rows"		| expectedResult |	grid selectAll.	expectedResult := Set with: (1 @ 1 corner: 20 @ 20).	"Add 5 rows at end"	self addRowsNumbering: 5.	self assert: (expectedResult - grid selectionRange) isEmpty.	"Add 5 rows at beginning"	self addRowsFrom: 1 to: 5.	expectedResult := Set with: (1 @ 6 corner: 20 @ 25).	self assert: (expectedResult - grid selectionRange) isEmpty.	"Add 5 rows in the middle"	self addRowsFrom: 15 to: 19.	expectedResult := Set		with: (1 @ 6 corner: 20 @ 14)		with: (1 @ 20 corner: 20 @ 30).	self assert: (expectedResult - grid selectionRange) isEmpty</body><body package="Grid SUnit Tests">testSelectAll		| expectedResult |	grid selectAll.	expectedResult := Set with: grid cellBounds.	self assert: (expectedResult - grid selectionRange) isEmpty</body><body package="Grid SUnit Tests">testSelectionCellDo	| noSelections values ran allValues |	grid selectByCell: true.	self assert: grid selectionRange isEmpty."No Selections"	ran := true.	grid selectionCellDo: [:value | noSelections := false].	self assert: ran."One cell"	ran := false.	grid addSelectionRange: (1 @ 1 extent: 0 @ 0).	grid selectionCellDo: 			[:cell :value | 			ran := true.			self assert: cell value = value.			self assert: entries first first = value].	self assert: ran."One column"	values := OrderedCollection new.	grid addSelectionRange: (1 @ 1 corner: 1 @ entries size).	grid selectionCellDo: 			[:cell :value | 			| cellPoint |			values add: value.			cellPoint := cell cellPoint.			self assert: cell value = value.			self assert: ((entries at: cellPoint y) at: cellPoint x) = value].	self assert: (entries collect:[:each | each first]) asArray = values asArray."One row"	values := OrderedCollection new.	grid initializeSelectionChannel.	grid addSelectionRange: (1 @ 1 corner: entries first size @ 1).	grid selectionCellDo: 			[:cell :value | 			| cellPoint |			values add: value.			cellPoint := cell cellPoint.			self assert: cell value = value.			self assert: ((entries at: cellPoint y) at: cellPoint x) = value].	self assert: entries first = values asArray."All cells"	values := Set new.	allValues := (entries inject: Set new into:[:sofar :next| sofar addAll: next. sofar]).	grid addSelectionRange: (1 @ 1 corner: entries first size @ entries size).	grid selectionCellDo: 			[:cell :value | 			| cellPoint |				values add: value.			cellPoint := cell cellPoint.			self assert: cell value = value.			self assert: ((entries at: cellPoint y) at: cellPoint x) = value].	self assert: (allValues - values ) isEmpty."Single argument block"	values := Set new.	grid selectionCellDo: 			[:cell | 			values add: cell value].	self assert: (allValues - values ) isEmpty.</body><body package="Grid SUnit Tests">testSelectionDo	| noSelections items |	grid selectByCell: false.	self assert: grid selectionRange isEmpty.	noSelections := true.	grid selectionDo: [:row | noSelections := false].	self assert: noSelections.	grid addSelectionRange: (1 @ 1 extent: 0 @ 9).	items := OrderedCollection new.	grid selectionDo: 			[:row :item | 			self assert: row item = item.			self assert: (entries at: row index) = item].	grid addSelectionRange: (1 @ 1 corner: 0 @ entries size).	items := OrderedCollection new.	grid selectionDo: [:row :item | items add: item].	self assert: entries asArray = items asArray</body></methods><methods><class-id>GridTest</class-id> <category>row tests</category><body package="Grid SUnit Tests">testFirstVisibleRow	"Test that first grid row corresponds to its first visible row at all times"	| formerFirst rowArray nextFirst |	formerFirst := rows first.	self assert: formerFirst = grid firstVisibleRow row.	rows addFirst: GridHeaderRow new.	self assert: rows first = grid firstVisibleRow row.	rows removeFirst.	self assert: formerFirst = grid firstVisibleRow row.	rowArray := Array with: GridHeaderRow new with: GridHeaderRow new.	rows addAll: rowArray beforeIndex: 1.	self assert: rows first = grid firstVisibleRow row.	rows removeAll: rowArray.	self assert: formerFirst = grid firstVisibleRow row.	nextFirst := rows at: 3.	rows removeFrom: 1 to: 2.	self assert: nextFirst = grid firstVisibleRow row.</body><body package="Grid SUnit Tests">testRows	| totalHeight rowsCopy |	grid := Grid new.	self assert: grid scrollableExtent = (0 @ 0).	totalHeight := rows inject: 0				into: [:sofar :each | sofar + each heightWithGap].	grid rows: rows.	self assert: grid rows = rows.	rows do: [:row | self assert: grid = row grid].	self assert: grid scrollableExtent = (0 @ totalHeight).	self assert: rows myDependents = grid.	rowsCopy := rows collect:[:each| each copy].	grid rows: rowsCopy.	rows do: [:row | self assert: row grid isNil].</body><body package="Grid SUnit Tests">testVisibleRowCount	self assert: grid visibleRowCount = (grid firstVisibleRow ifNil:[0] ifNotNil:[:value| value last index]).</body></methods><methods><class-id>GridTest</class-id> <category>editing tests</category><body package="Grid SUnit Tests">testAcceptEditAt	"#editAt: edits the cell at the given coordinate position.  The grid editor component and editCell are set for the editing at this position and previous values released"	| editor widget |	gridApp open.	grid checkCells.	self assert: (grid editAt: 1 @ 2).	self assert: grid editCell cellPoint = (1 @ 2).	editor := grid editor.	widget := editor widget.	self assert: widget editValue = (entries at: 2) first.	self assert: (widget hasActionForEvent: #losingFocus).	"Scroll to edit a new position off pane.  The prior editor should be released"	self assert: (grid editAt: 8 @ 2).	self deny: (grid components includes: editor).	self deny: (widget hasActionForEvent: #losingFocus).	self deny: (widget hasActionForEvent: #gettingFocus).	self deny: grid editor == editor.	editor := grid editor.	widget := editor widget.	self assert: widget editValue = ((entries at: 2) at: 8).	self assert: (widget hasActionForEvent: #losingFocus)</body><body package="Grid SUnit Tests">testDenyEditAt	| editor widget |	(grid columns at: 2) spec initiallyDisabled: true.	gridApp open.	self assert: (grid editAt: 1 @ 2).	self assert: grid editCell cellPoint = (1 @ 2).	editor := grid editor.	widget := editor widget.	self assert: widget editValue = (entries at: 2) first.	self assert: (widget hasActionForEvent: #losingFocus).	"Attempt to edit a disabled position off pane.  The prior editor should not be released"	self deny: (grid editAt: 2 @ 2).	self assert: (grid components includes: editor).	self assert: (widget hasActionForEvent: #losingFocus).	self assert: (widget hasActionForEvent: #gettingFocus).	self assert: grid editor == editor.</body></methods><methods><class-id>GridTest</class-id> <category>row list tests</category><body package="Grid SUnit Tests">testAddRowRange	| lastScrollExtent rowsToAdd heightAdded |	lastScrollExtent := grid scrollableExtent copy.	rowsToAdd := (1 to: 6) collect:[:index| GridRow on: ((1 to: grid numberOfColumns) collect:[:column| column @ index]) height: 20].	heightAdded := rowsToAdd inject: 0 into:[:sofar :row| sofar + row heightWithGap].	rows addAll: rowsToAdd beforeIndex: 10.	self assert: grid scrollableExtent = (lastScrollExtent + (0@ heightAdded)).	(10 to: 15) with: rowsToAdd do:[:index :row| self assert: index = row index].</body><body package="Grid SUnit Tests">testMoveRowRange	| myTestGrid lastScrollExtent removed |	lastScrollExtent := grid scrollableExtent copy.	removed := rows removeFrom: 1 to: 14.	self assert: grid scrollableExtent x = lastScrollExtent x.	self assert: grid scrollableExtent y = (6 * removed first heightWithGap).	myTestGrid := Grid new.	myTestGrid rows addAll: removed.	self assert: myTestGrid scrollableExtent = (0 @ 14 * removed first heightWithGap).	removed do:[:row | self assert: row grid = myTestGrid].	(1 to: 14) with: removed do:[:index : row| self assert: index = row index].</body><body package="Grid SUnit Tests">testNewGridRow	| row |	grid := Grid new.	self assert: grid scrollableExtent = (0 @ 0).	row := GridRow on: rows last item height: 25 to: grid.	self assert: grid rows last = row.	self assert: grid scrollableExtent = (0 @ row heightWithGap).	self assert: grid = row grid</body><body package="Grid SUnit Tests">testPutRowAt		| row lastScrollExtent lastRowNumber priorRow |	row := GridRow on: nil height: 50.	lastScrollExtent := grid scrollableExtent copy.	lastRowNumber := grid numberOfRows.	priorRow := rows at: 10.	rows at: 10 put: row.	self assert: lastRowNumber  = rows size.	self assert: (rows at: 10) = row.	self assert: lastScrollExtent + (0 @ row heightWithGap) - (0 @ priorRow heightWithGap) = grid scrollableExtent.	self assert: row grid = grid.	self assert: priorRow index isNil.</body><body package="Grid SUnit Tests">testRemoveEditorRow	"Removing a row with a cell under edit should not cause an exception"	gridApp open.	grid checkCells.	self assert: (grid editAt: 1 @ 2).	grid rows removeAtIndex: 2.	self assert: grid editor isNil.</body><body package="Grid SUnit Tests">testRemoveRowRange	| lastScrollExtent removedHeight removedSet |	lastScrollExtent := grid scrollableExtent copy.	removedSet := rows removeFrom: 1 to: 14.	removedHeight := removedSet inject: 0 into:[:sofar :each| sofar + each heightWithGap].	self assert: grid scrollableExtent = (lastScrollExtent - (0@removedHeight)).	self assert: grid numberOfRows = 6.	removedSet do:[:row| self deny: row isValid].</body><body package="Grid SUnit Tests">testReplaceRows	| lastScrollExtent copiedRows addedHeight removedHeight replacedSet |	lastScrollExtent := grid scrollableExtent copy.	copiedRows := rows collect:[:row| row copy].	replacedSet := copiedRows copyFrom: 1 to: 6.	addedHeight := replacedSet inject: 0 into:[:sofar :each| sofar + each heightWithGap].	removedHeight := (rows copyFrom:10 to: 15) inject: 0 into:[:sofar :each| sofar + each heightWithGap].	rows replaceFrom: 10 to: 15 with:copiedRows startingAt: 1. 	self assert: ((rows copyFrom:10 to: 15) isSameSequenceAs: (copiedRows copyFrom: 1 to: 6)).	self assert: grid scrollableExtent = (lastScrollExtent + addedHeight - removedHeight).	(10 to: 15) with: replacedSet do:[:index :row| index = row index].</body><body package="Grid SUnit Tests">testRowInsert		| row lastScrollExtent lastRowNumber |	row := GridRow on: nil height: 10.	lastScrollExtent := grid scrollableExtent copy.	lastRowNumber := grid numberOfRows.	rows add: row beforeIndex: 10.	self assert: lastRowNumber + 1 = rows size.	self assert: (rows at: 10) = row.	self assert: lastScrollExtent + (0 @ row heightWithGap) = grid scrollableExtent.	self assert: row grid = grid</body></methods><methods><class-id>GridTest</class-id> <category>cell tests</category><body package="Grid SUnit Tests">testVisualCellAtPoint	| visibleOrigin visibleExtent |	gridApp open.	visibleOrigin := grid firstVisibleColumn index @ grid firstVisibleRow index.	visibleExtent := grid lastVisibleColumn index @ grid lastVisibleRow index.	(Array with: visibleOrigin with: visibleExtent) do: 			[:cellPoint |			| visibleCell |			visibleCell := grid visualCellAtPoint: cellPoint.			self assert: visibleCell notNil.			self assert: visibleCell cellPoint = cellPoint].	(Array with: visibleExtent + (1@0) with: visibleExtent + (0@1) with: grid maxCellPosition with: grid maxCellPosition + (1@1)) do: 			[:cellPoint |			| visibleCell |			visibleCell := grid visualCellAtPoint: cellPoint.			self assert: visibleCell isNil]</body></methods><methods><class-id>GridTest</class-id> <category>column list tests</category><body package="Grid SUnit Tests">testAddColumnRange	| lastScrollExtent columnsToAdd widthAdded |	gridApp open.	lastScrollExtent := grid scrollableExtent copy.	columnsToAdd := (1 to: 6) collect:[:index| GridColumn spec: (self columnInputSpecIndexedBy: index) width: 20].	widthAdded := columnsToAdd inject: 0 into:[:sofar :column| sofar + column widthWithGap].	columns addAll: columnsToAdd beforeIndex: 10.	self assert: grid scrollableExtent = (lastScrollExtent + (widthAdded @ 0)).	(10 to: 15) with: columnsToAdd do:[:index :column| self assert: index = column index].</body><body package="Grid SUnit Tests">testColumnInsert		| lastScrollExtent lastColumnNumber column |	column := GridColumn spec: (self columnInputSpecIndexedBy: 9) width: 80.	lastScrollExtent := grid scrollableExtent copy.	lastColumnNumber := grid numberOfColumns.	columns add: column beforeIndex: 10.	self assert: lastColumnNumber + 1 = columns size.	self assert: (columns at: 10) = column.	self assert: lastScrollExtent + (column widthWithGap @ 0) = grid scrollableExtent.	self assert: column grid = grid</body><body package="Grid SUnit Tests">testMoveColumnRange	| myTestGrid lastScrollExtent removed removedSpan |	lastScrollExtent := grid scrollableExtent copy.	removed := columns removeFrom: 1 to: 14.	removedSpan := removed inject: 0 into:[:sofar :each| sofar + each widthWithGap].	self assert: grid scrollableExtent y = lastScrollExtent y.	self assert: grid scrollableExtent x = (lastScrollExtent x - removedSpan).	myTestGrid := Grid new.	myTestGrid columns addAll: removed.	self assert: myTestGrid scrollableExtent = (removedSpan @ 0).	removed do:[:column | self assert: column grid = myTestGrid].	(1 to: 14) with: removed do:[:index :column| self assert: index = column index].</body><body package="Grid SUnit Tests">testNewGridColumn	| column |	grid := Grid new.		self assert: grid scrollableExtent = (0 @ 0).	column := GridColumn spec: (self columnInputSpecIndexedBy: 21) in: grid width: 50.	grid rows: rows.	self assert: grid columns last = column.	self assert: grid scrollableExtent x = column widthWithGap.	self assert: grid = column grid</body><body package="Grid SUnit Tests">testPutColumnAt		| column lastScrollExtent lastColumnNumber priorColumn |	column := GridColumn spec: (self columnInputSpecIndexedBy: 1) width: 50.	lastScrollExtent := grid scrollableExtent copy.	lastColumnNumber := grid numberOfColumns.	priorColumn := columns at: 10.	columns at: 10 put: column.	self assert: lastColumnNumber  = columns size.	self assert: (columns at: 10) = column.	self assert: lastScrollExtent + (column widthWithGap @ 0) - (priorColumn widthWithGap @ 0) = grid scrollableExtent.	self assert: column grid = grid.	self assert: priorColumn index isNil.</body><body package="Grid SUnit Tests">testRemoveColumnRange	| lastScrollExtent removedWidth removedSet |	lastScrollExtent := grid scrollableExtent copy.	removedSet := columns removeFrom: 1 to: 14.	removedWidth := removedSet inject: 0 into:[:sofar :each| sofar + each widthWithGap].	self assert: grid scrollableExtent = (lastScrollExtent - (removedWidth@0)).	self assert: grid numberOfColumns = 6.	removedSet do:[:column| self deny: column isValid].</body><body package="Grid SUnit Tests">testRemoveEditorColumn	"Removing a column with a cell under edit should not cause an exception"	gridApp open.	grid checkCells.	self assert: (grid editAt: 1 @ 2).	grid columns removeAtIndex: 2.	self assert: grid editor isNil.</body><body package="Grid SUnit Tests">testReplaceColumns	| lastScrollExtent copiedColumns addedWidth removedWidth replacedSet |	lastScrollExtent := grid scrollableExtent copy.	copiedColumns := columns collect:[:column| column copy].	replacedSet := copiedColumns copyFrom: 1 to: 6.	addedWidth := replacedSet inject: 0 into:[:sofar :each| sofar + each widthWithGap].	removedWidth := (columns copyFrom:10 to: 15) inject: 0 into:[:sofar :each| sofar + each widthWithGap].	columns replaceFrom: 10 to: 15 with:copiedColumns startingAt: 1. 	self assert: ((columns copyFrom:10 to: 15) isSameSequenceAs: (copiedColumns copyFrom: 1 to: 6)).	self assert: grid scrollableExtent = (lastScrollExtent + addedWidth - removedWidth).	(10 to: 15) with: replacedSet do:[:index :column| index = column index].</body></methods><methods><class-id>GridTest</class-id> <category>scrolling tests</category><body package="Grid SUnit Tests">testCellScrollToView	"Test 	#top: #left, #right, #center, #nearest	#bottom: #left, #right, #center, #nearest	#center:	 #left, #right, #center, #nearest	#nearest: #left, #right, #center, #nearest"	| midColumn columnsPerPage builder bindingsSize midRow rowsPerPage testColumns testRows cellCount window wrapper |	columns do:[:each| each width: 80].	gridApp open.	"Resize so only 7 rows show"	wrapper := gridApp wrapperAt: #grid.	wrapper bounds: (wrapper bounds height: 7 * rows first heightWithGap + 20). 	builder := grid builder.	window := grid topComponent.	grid dropEdit.	bindingsSize := builder bindings size.	cellCount := grid components size.	columnsPerPage := grid firstVisibleColumn successorCount.	rowsPerPage := grid firstVisibleRow successorCount.	midColumn := grid columns at: grid numberOfColumns // 2.	midRow := grid rows at: grid numberOfRows // 2.	testColumns := Dictionary new.	testColumns		at: #center put: midColumn;		at: #right put: (columns at: midColumn index + columnsPerPage);		at: #left put: (columns at: midColumn index - columnsPerPage).	testRows := Dictionary new.	testRows		at: #center put: midRow;		at: #bottom put: (rows at: midRow index + rowsPerPage);		at: #top put: (rows at: midRow index - rowsPerPage).	#(#top #bottom #center) do: 			[:vPosition | 			#(#left #right #center) do: 					[:hPosition | 					grid 						scrollCell: (GridCell column: (testColumns at: hPosition)								row: (testRows at: vPosition))						toRowView: vPosition						andColumnView: hPosition.					self cellTestColumnPosition: hPosition.					self cellTestRowPosition: vPosition.					window repairDamages.					self assert: builder bindings size = bindingsSize.					self assert: 	cellCount = grid components size.]]</body><body package="Grid SUnit Tests">testColumnScrollToView	"Test #left, #bottom, #center, #nearest"	| midColumn visualMidColumn rightmostColumn leftmostColumn lastBounds columnsPerPage builder bindingsSize cellCount |	columns do:[:each| each width: 80].	gridApp open.	builder := grid builder.	grid dropEdit.	bindingsSize := builder bindings size.	cellCount := grid components size.	midColumn := columns at: grid numberOfColumns // 2.	columnsPerPage := grid firstVisibleColumn successorCount.	rightmostColumn := columns at: midColumn index + columnsPerPage.	leftmostColumn := columns at: midColumn index - columnsPerPage.	grid columns last scrollToView: #right.	self assert: grid bounds right = grid lastVisibleColumn right.	self assert: builder bindings size = bindingsSize.	self assert: 	cellCount = grid components size.	grid columns first scrollToView: #left.	self assert: grid bounds left = grid firstVisibleColumn left.	self assert: builder bindings size = bindingsSize.	self assert: 	cellCount = grid components size.	midColumn scrollToView: #center.	visualMidColumn := grid firstVisibleColumn visualForColumn: midColumn				ifNone: [self assert: false].	self assert: grid bounds center x 				= (visualMidColumn left midpoint: visualMidColumn right) rounded.	self assert: builder bindings size = bindingsSize.	self assert: 	cellCount = grid components size.	lastBounds := grid bounds.	midColumn scrollToView: #nearest.	self assert: lastBounds = grid bounds.	self assert: builder bindings size = bindingsSize.	self assert: 	cellCount = grid components size.	rightmostColumn scrollToView: #nearest.	self assert: grid bounds right = grid lastVisibleColumn right.	self assert: builder bindings size = bindingsSize.	self assert: 	cellCount = grid components size.	leftmostColumn scrollToView: #nearest.	self assert: (grid bounds left = grid firstVisibleColumn right 				or: [grid bounds left = grid firstVisibleColumn left]).	self assert: builder bindings size = bindingsSize.	self assert: 	cellCount = grid components size.</body><body package="Grid SUnit Tests">testRowScrollToView	"Test #top, #bottom, #center, #nearest"	| midRow visualMidRow lowerRow upperRow lastBounds rowsPerPage builder bindingsSize cellCount wrapper |	gridApp open.	"Resize so only 7 rows show"	wrapper := gridApp wrapperAt: #grid.	wrapper bounds: (wrapper bounds height: 7 * rows first heightWithGap + 20). 	grid checkCells.	grid dropEdit.	builder := grid builder.	bindingsSize := builder bindings size.	cellCount := grid components size.	midRow := rows at: grid numberOfRows // 2.	rowsPerPage := grid firstVisibleRow successorCount.	lowerRow := rows at: midRow index + rowsPerPage.	upperRow := rows at: midRow index - rowsPerPage.	grid rows last scrollToView: #bottom.	self assert: grid bounds bottom = grid lastVisibleRow bottom.		self assert: builder bindings size  = bindingsSize.	self assert: cellCount = grid components size	.		grid rows first scrollToView: #top.	self assert: grid bounds top = grid firstVisibleRow top.	self assert: builder bindings size  = bindingsSize.	self assert: cellCount = grid components size	.		midRow scrollToView: #center.	visualMidRow := grid firstVisibleRow visualForRow: midRow				ifNone: [self assert: false].	self assert: grid bounds center y 				= (visualMidRow top midpoint: visualMidRow bottom) rounded.	self assert: builder bindings size  = bindingsSize.	self assert: cellCount = grid components size	.		lastBounds := grid bounds.	midRow scrollToView: #nearest.	self assert: lastBounds = grid bounds.	self assert: builder bindings size  = bindingsSize.	self assert: cellCount = grid components size	.		lowerRow scrollToView: #nearest.	self assert: grid bounds bottom = grid lastVisibleRow bottom.	self assert: builder bindings size  = bindingsSize.	self assert: cellCount = grid components size	.		upperRow scrollToView: #nearest.	self assert: (grid bounds top = grid firstVisibleRow bottom 				or: [grid bounds top = grid firstVisibleRow top]).	self assert: builder bindings size  = bindingsSize.	self assert: cellCount = grid components size	.</body></methods><methods><class-id>GridTest</class-id> <category>test-accessing</category><body package="Grid SUnit Tests">testCellBounds	self assert: grid cellBounds = (1@1 corner: grid numberOfColumns @ grid numberOfRows)</body></methods><methods><class-id>GridVisualSegmentTest</class-id> <category>running</category><body package="Grid SUnit Tests">setUp	| column |	column := GridColumn new.	a := (GridVisualColumn new)				index: 1;				column: column copy;				yourself.	b := (GridVisualColumn new)				predecessor: a;				column: column copy;				yourself.	c := (GridVisualColumn new)				predecessor: b;				column: column copy;				yourself.	x := (GridVisualColumn new)				index: 97;				column: column copy;				yourself.	y := (GridVisualColumn new)				predecessor: x;				column: column copy;				yourself.	z := (GridVisualColumn new)				predecessor: y;				column: column copy;				yourself</body><body package="Grid SUnit Tests">tearDown	a := b := c := x := y := z := nil.	Cursor normal show.	super tearDown</body></methods><methods><class-id>GridVisualSegmentTest</class-id> <category>test accessing</category><body package="Grid SUnit Tests">testAtIndex	a , x.	a withSuccessorsDo: 			[:each | 			self assert: (a atIndex: each index) = each.			self assert: (z atIndex: each index) = each.			self assert: (each atIndex: 1) = a.			self assert: (each atIndex: z index) = z]</body><body package="Grid SUnit Tests">testFirst	self assert: a first = a.	self assert: c first = a.</body><body package="Grid SUnit Tests">testIndex	self assert: a index = 1.	self assert: c index = 3.	self assert: b index = 2.	self assert: x index = 97.	self assert: z index = 99.	self assert: y index = 98.</body><body package="Grid SUnit Tests">testLast	self assert: a last = c.	self assert: c last = c.</body><body package="Grid SUnit Tests">testPredecessor	self assert: a predecessor isNil.	self assert: b predecessor = a.</body><body package="Grid SUnit Tests">testPredecessorSize	self assert: c predecessorCount =2.	self assert: b predecessorCount = 1.	self assert: a predecessorCount isZero.</body><body package="Grid SUnit Tests">testPredecessors	self assert: c predecessors = (Array with: a with: b)</body><body package="Grid SUnit Tests">testSuccessor	self assert: a successor = b.	self assert: c successor isNil.</body><body package="Grid SUnit Tests">testSuccessorSize	self assert: c successorCount isZero.	self assert: b successorCount = 1.	self assert: a successorCount = 2.</body><body package="Grid SUnit Tests">testSuccessors	self assert: a successors = (Array with: b with: c)</body><body package="Grid SUnit Tests">testWithPredecessors	self assert: c withPredecessors = (Array with: a with: b with: c)</body><body package="Grid SUnit Tests">testWithSuccessors	self assert: a withSuccessors = (Array with: a with: b with: c)</body></methods><methods><class-id>GridVisualSegmentTest</class-id> <category>test combining</category><body package="Grid SUnit Tests">testCommaCombine	"a-b-c-x-y-z"	self assert: c isLast.	self assert: x isFirst.	c , x.	self assert: a last = z.	self assert: z first = a.</body></methods><methods><class-id>GridVisualSegmentTest</class-id> <category>test insert after</category><body package="Grid SUnit Tests">testInsertAAfterX	"x-a-y-z b-c"	a insertAfter: x.	self assert: a predecessor = x.	self assert: a successor = y.	self assert: x last = z.	self assert: z first = x.	self assert: b successor = c.	self assert: c predecessor = b.</body><body package="Grid SUnit Tests">testInsertAAfterZ	"x-y-z-a-b-c"	a insertAfter: z.	self assert: x last = c.	self assert: c first = x.</body><body package="Grid SUnit Tests">testInsertAfterReflexive	self should:[z insertAfter: z] raise:Error.</body><body package="Grid SUnit Tests">testInsertCAfterX	"a-b x-c-y-z"	c insertAfter: x.	self assert: a successor = b.	self assert: b predecessor = a.	self assert: x last = z.	self assert: z first = x.	self assert: c successor = y.	self assert: c predecessor = x</body><body package="Grid SUnit Tests">testInsertCAfterZ	"a-b x-y-z-c"	c insertAfter: z.	self assert: a successor = b.	self assert: b predecessor = a.	self assert: x last = c.	self assert: c first = x.</body><body package="Grid SUnit Tests">testInsertXAfterA	"a-x-b-c y-z"	x insertAfter: a.	self assert: a successor = x.	self assert: x predecessor = a.	self assert: a last = c.	self assert: c first = a.	self assert: y successor = z.	self assert: z predecessor = y.</body><body package="Grid SUnit Tests">testInsertXAfterC	"a-b-c-x-y-z"	x insertAfter: c.	self assert: a last = z.	self assert: z first = a.</body><body package="Grid SUnit Tests">testInsertZAfterA	"x-y a-z-b-c"	z insertAfter: a.	self assert: z successor = b.	self assert: z predecessor = a.	self assert: a last = c.	self assert: c first = a.	self assert: x successor = y.	self assert: y predecessor = x.</body><body package="Grid SUnit Tests">testInsertZAfterC	"x-y a-b-c-z"	z insertAfter: c.	self assert: z predecessor = c.	self assert: a last = z.	self assert: z first = a.	self assert: x successor = y.	self assert: y predecessor = x.</body></methods><methods><class-id>GridVisualSegmentTest</class-id> <category>test insert prior</category><body package="Grid SUnit Tests">testInsertAPriorX	"a-x-y-z b-c"	a insertPrior: x.	self assert: a last = z.	self assert: z first = a.	self assert: b successor = c.	self assert: c predecessor = b</body><body package="Grid SUnit Tests">testInsertAPriorZ	"b-c x-y-a-z"	a insertPrior: z.	self assert: a successor = z.	self assert: a predecessor = y.	self assert: z first = x.	self assert: x last = z.	self assert: b successor = c.	self assert: c predecessor = b</body><body package="Grid SUnit Tests">testInsertCPriorX	"a-b-c-x-y-z"	c insertPrior: x.	self assert: a last = z.	self assert: z first = a.	self assert: c successor = x.	self assert: x predecessor = c</body><body package="Grid SUnit Tests">testInsertCPriorZ	"x-y-c-z a-b"	c insertPrior: z.	self assert: c successor = z.	self assert: c predecessor = y.	self assert: x last = z.	self assert: z first = x.	self assert: a successor = b.	self assert: b predecessor = a</body><body package="Grid SUnit Tests">testInsertPriorReflexive	self should:[z insertPrior: z] raise:Error.</body><body package="Grid SUnit Tests">testInsertXPriorA	"x-a-b-c y-z"	x insertPrior: a.	self assert: x last = c.	self assert: c first = x.	self assert: y successor = z.	self assert: z predecessor = y</body><body package="Grid SUnit Tests">testInsertXPriorC	"a-b-x-c y-z"	x insertPrior: c.	self assert: x last = c.	self assert: x first = a.	self assert: a last = c.	self assert: c first = a.	self assert: y successor = z.	self assert: z predecessor = y</body><body package="Grid SUnit Tests">testInsertZPriorA	"x-y-z-a-b-c"	z insertPrior: a.	self assert: z successor = a.	self assert: z predecessor = y.	self assert: x last = c.	self assert: c first = x.</body><body package="Grid SUnit Tests">testInsertZPriorC	"a-b-z-c x-y"	z insertPrior: c.	self assert: z successor = c.	self assert: z predecessor = b.	self assert: a last = c.	self assert: c first = a.	self assert: x successor = y.	self assert: y predecessor = x</body></methods><methods><class-id>GridVisualSegmentTest</class-id> <category>test insert with successors prior</category><body package="Grid SUnit Tests">testInsertAWithPredecessorsPriorX	"a-x-y-z b-c"	a insertWithPredecessorsPrior: x.	self assert: a last = z.	self assert: z first = a.	self assert: x successor = y.	self assert: x predecessor = a.	self assert: b successor = c.	self assert: c predecessor = b.</body><body package="Grid SUnit Tests">testInsertAWithPredecessorsPriorZ	"x-y-a-z b-c"	a insertWithPredecessorsPrior: z.	self assert: x last = z.	self assert: z first = x.	self assert: a successor = z.	self assert: a predecessor = y.	self assert: b successor = c.	self assert: c predecessor = b.</body><body package="Grid SUnit Tests">testInsertCWithPredecessorsPriorX	"a-b-c-x-y-z"	c insertWithPredecessorsPrior: x.	self assert: a last = z.	self assert: z first = a.	self assert: x successor = y.	self assert: x predecessor = c.</body><body package="Grid SUnit Tests">testInsertCWithPredecessorsPriorZ	"x-y-a-b-c-z"	c insertWithPredecessorsPrior: z.	self assert: x last = z.	self assert: z first = x.	self assert: c successor = z.	self assert: c predecessor = b.</body><body package="Grid SUnit Tests">testInsertWithSuccessorsPriorReflexive	self should:[z insertWithPredecessorsPrior: z] raise:Error.</body><body package="Grid SUnit Tests">testInsertXWithPredecessorsPriorA	"x-a-b-c y-z"	x insertWithPredecessorsPrior: a.	self assert: x last = c.	self assert: c first = x.	self assert: a successor = b.	self assert: a predecessor = x.	self assert: y successor = z.	self assert: z predecessor = y.</body><body package="Grid SUnit Tests">testInsertXWithPredecessorsPriorC	"a-b-x-c y-z"	x insertWithPredecessorsPrior: c.	self assert: a last = c.	self assert: c first = a.	self assert: x successor = c.	self assert: x predecessor = b.	self assert: y successor = z.	self assert: z predecessor = y.</body><body package="Grid SUnit Tests">testInsertZWithPredecessorsPriorA	"x-y-z-a-b-c"	z insertWithPredecessorsPrior: a.	self assert: x last = c.	self assert: c first = x.	self assert: a successor = b.	self assert: a predecessor = z.</body><body package="Grid SUnit Tests">testInsertZWithPredecessorsPriorC	"a-b-x-y-z-c"	z insertWithPredecessorsPrior: c.	self assert: a last = c.	self assert: c first = a.	self assert: z successor = c.	self assert: z predecessor = y.</body></methods><methods><class-id>GridVisualSegmentTest</class-id> <category>test insert with successors after</category><body package="Grid SUnit Tests">testInsertAWithSuccessorsAfterX	"x-a-b-c-y-z"	a insertWithSuccessorsAfter: x.	self assert: x last = z.	self assert: z first = x.	self assert: a successor = b.	self assert: a predecessor = x.</body><body package="Grid SUnit Tests">testInsertAWithSuccessorsAfterZ	"x-y-z-a-b-c"	a insertWithSuccessorsAfter: z.	self assert: x last = c.	self assert: c first = x.	self assert: a successor = b.	self assert: a predecessor = z.</body><body package="Grid SUnit Tests">testInsertCWithSuccessorsAfterX	"x-c-y-z a-b"	c insertWithSuccessorsAfter: x.	self assert: x last = z.	self assert: z first = x.	self assert: c successor = y.	self assert: c predecessor = x.	self assert: a successor = b.	self assert: b predecessor = a.</body><body package="Grid SUnit Tests">testInsertCWithSuccessorsAfterZ	"x-y-z-c a-b"	c insertWithSuccessorsAfter: z.	self assert: x last = c.	self assert: c first = x.	self assert: a successor = b.	self assert: b predecessor = a.</body><body package="Grid SUnit Tests">testInsertWithSuccessorsAfterReflexive	self should:[z insertWithSuccessorsAfter: z] raise:Error.</body><body package="Grid SUnit Tests">testInsertXWithSuccessorsAfterA	"a-x-y-z-b-c"	x insertWithSuccessorsAfter: a.	self assert: a last = c.	self assert: c first = a.	self assert: x successor = y.	self assert: x predecessor = a.</body><body package="Grid SUnit Tests">testInsertXWithSuccessorsAfterC	"a-b-c-x-y-z"	x insertWithSuccessorsAfter: c.	self assert: a last = z.	self assert: z first = a.	self assert: c successor = x.	self assert: c predecessor = b.</body><body package="Grid SUnit Tests">testInsertZWithSuccessorsAfterA	"x-y a-z-b-c"	z insertWithSuccessorsAfter: a.	self assert: a last = c.	self assert: c first = a.	self assert: z successor = b.	self assert: z predecessor = a.	self assert: x successor = y.	self assert: y predecessor = x.</body><body package="Grid SUnit Tests">testInsertZWithSuccessorsAfterC	"x-y a-b-c-z"	z insertWithSuccessorsAfter: c.	self assert: a last = z.	self assert: z first = a.	self assert: x successor = y.	self assert: y predecessor = x.	self assert: c successor = z.	self assert: c predecessor = b.</body></methods><methods><class-id>GridVisualSegmentTest</class-id> <category>test removing</category><body package="Grid SUnit Tests">testRemoveA	self assert: a isFirst.	self assert: a successor = b.	a remove.	self assert: b isFirst.	self assert: b successor = c.	self assert: a isFirst.	self assert: a isLast.	self assert: a cells isEmpty.</body><body package="Grid SUnit Tests">testRemoveB	self assert: b successor = c.	self assert: b predecessor = a.	b remove.	self assert: a successor = c.	self assert: c predecessor = a.	self assert: b isFirst.	self assert: b isLast.	self assert: b cells isEmpty.</body><body package="Grid SUnit Tests">testRemoveC	self assert: c isLast.	self assert: c predecessor = b.	c remove.	self assert: b isLast.	self assert: a successor = b.	self assert: c isFirst.	self assert: c isLast.	self assert: c cells isEmpty.</body><body package="Grid SUnit Tests">testRemovePredecessorCount	self assert: c first = a.	c removePredecessorCount: 0.	self assert: c first = a.	a removePredecessorCount: 99.	self assert: c first = a.	c removePredecessorCount: 1.	self assert: a successor = c.	self assert: a = c predecessor.	self assert: b isFirst.	self assert: b isLast.	self assert: z first = x.	z removePredecessorCount: 2.	self assert: x isFirst.	self assert: x isLast.		self assert: z isFirst.	self assert: z isLast.</body><body package="Grid SUnit Tests">testRemoveSuccessorCount	self assert: a last = c.	a removeSuccessorCount: 0.	self assert: a last = c.	c removeSuccessorCount: 99.	self assert: a last = c.	a removeSuccessorCount: 1.	self assert: a successor = c.	self assert: a = c predecessor.	self assert: b isFirst.		self assert: b isLast.	self assert: x last = z.	x removeSuccessorCount: 2.	self assert: x isLast.	self assert: x isFirst.	a removeSuccessorCount: 99.	self assert: a isLast.	self assert: a isFirst.</body><body package="Grid SUnit Tests">testRemoveWithPredecessors</body><body package="Grid SUnit Tests">testRemoveWithSuccessors</body><body package="Grid SUnit Tests">testSeverPredecessor	self assert: b predecessor = a.	b severPredecessor.	self deny: b predecessor = a.	self assert: a isLast.	self assert: b isFirst.	self shouldnt: [b severPredecessor] raise: Error</body><body package="Grid SUnit Tests">testSeverSuccessor	self assert: a successor = b.	a severSuccessor.	self deny: a successor = b.	self assert: a isLast.	self assert: b isFirst.	self shouldnt:[a severSuccessor] raise: Error.</body></methods><methods><class-id>GridVisualSegmentTest</class-id> <category>test enumeration</category><body package="Grid SUnit Tests">testWithSuccessorsContains	| count |	count := 0.	self deny: (a withSuccessorsContains: [:each| count := count + 1. false]).	self assert: count = 3.	count := 0.	self assert:(a withSuccessorsContains: [:each| count := count + 1. each index = 1]).	self assert: count = 1.	count := 0.	self assert:(a withSuccessorsContains: [:each| count := count + 1. each index = 2]).	self assert: count = 2.</body><body package="Grid SUnit Tests">testWithSuccessorsDetectIfAbsent	| count |	count := 0.	self 		assert: (a withSuccessorsDetect: 					[:each | 					count := count + 1.					false]				ifNone: [true]).	self assert: count = 3.	count := 0.	self assert: a 				= (a withSuccessorsDetect: 							[:each | 							count := count + 1.							each index = 1]						ifNone: [false]).	self assert: count = 1.	count := 0.	self assert: b 				= (a withSuccessorsDetect: 							[:each | 							count := count + 1.							each index = 2]						ifNone: [false]).	self assert: count = 2</body><body package="Grid SUnit Tests">testWithSuccessorsDo	| indexes |	indexes := OrderedCollection new.	a withSuccessorsDo: [:each | indexes add: each index].	self assert: indexes asArray = #(1 2 3)</body></methods><methods><class-id>GridVisualSegmentTest</class-id> <category>test cells</category><body package="Grid SUnit Tests">testIncludesCell		| grid visualRow cell row column |	grid := Grid new.	row := GridRow on: nil height: nil to: grid.	column := GridColumn spec: nil in: grid width: 20.	visualRow := GridVisualRow on: row in: grid index: 1 top: 0 bottom: nil.	a		grid: grid;		column: column.	cell := GridVisualCell visualColumn: a visualRow: visualRow.	self assert: (a includesCell: cell).	self assert: (visualRow includesCell: cell)</body></methods><methods><class-id>GridVisualSegmentTest</class-id> <category>test releasing</category><body package="Grid SUnit Tests">testReleasePredecessors	| grid row cellA cellB cellC |	grid := Grid new.	row := GridVisualRow 				on: (GridRow on: nil to: grid)				in: grid				index: 1				top: 0				bottom: nil.	a grid: grid.	b grid: grid.	c grid: grid.	cellA := GridVisualCell visualColumn: a visualRow: row.	cellB := GridVisualCell visualColumn: b visualRow: row.	cellC := GridVisualCell visualColumn: c visualRow: row.	self assert: (a includesCell: cellA).	self assert: (b includesCell: cellB).	self assert: (c includesCell: cellC).	c releasePredecessors.	self deny: c grid isNil.	self assert: (c includesCell: cellC).	self assert: b grid isNil.	self assert: b cells isEmpty.	self assert: a grid isNil.	self assert: a cells isEmpty.	self deny: c predecessor = b.</body><body package="Grid SUnit Tests">testReleaseSuccessors	| grid row cellA cellB cellC |	grid := Grid new.	row := GridVisualRow 				on: (GridRow on: nil to: grid)				in: grid				index: 1				top: 0				bottom: nil.	a grid: grid.	b grid: grid.	c grid: grid.	cellA := GridVisualCell visualColumn: a visualRow: row.	cellB := GridVisualCell visualColumn: b visualRow: row.	cellC := GridVisualCell visualColumn: c visualRow: row.	self assert: (a includesCell: cellA).	self assert: (b includesCell: cellB).	self assert: (c includesCell: cellC).	a releaseSuccessors.	self assert: b grid isNil.	self deny: (b includesCell: cellB).	self assert: c grid isNil.	self deny: (c includesCell: cellC).	self deny: a grid isNil.	self assert: (a includesCell: cellA).	self deny: a successor = b.</body><body package="Grid SUnit Tests">testReleaseWithPredecessors	| grid row cellA cellB cellC cellX |	grid := Grid new.	row := GridVisualRow 				on: (GridRow on: nil to: grid)				in: grid				index: 1				top: 0				bottom: nil.	a grid: grid.	b grid: grid.	c grid: grid.	x grid: grid.	cellA := GridVisualCell visualColumn: a visualRow: row.	cellB := GridVisualCell visualColumn: b visualRow: row.	cellC := GridVisualCell visualColumn: c visualRow: row.	cellX := GridVisualCell visualColumn: x visualRow: row.	c, x.	c releaseWithPredecessors.	self assert: c grid isNil.	self deny: (c includesCell: cellC).	self assert: b grid isNil.	self deny: (b includesCell: cellB).	self assert: a grid isNil.	self deny: (a includesCell: cellA).	self deny: x grid isNil.	self assert: (x includesCell: cellX).</body><body package="Grid SUnit Tests">testReleaseWithSuccessors	| grid row cellA cellB cellC cellX |	grid := Grid new.	row := GridVisualRow 				on: (GridRow on: nil to: grid)				in: grid				index: 1				top: 0				bottom: nil.	a grid: grid.	b grid: grid.	c grid: grid.	x grid: grid.	cellA := GridVisualCell visualColumn: a visualRow: row.	cellB := GridVisualCell visualColumn: b visualRow: row.	cellC := GridVisualCell visualColumn: c visualRow: row.	cellX := GridVisualCell visualColumn: x visualRow: row.	x , a.	a releaseWithSuccessors.	self assert: b grid isNil.	self deny: (b includesCell: cellB).	self assert: c grid isNil.	self deny: (c includesCell: cellC).	self assert: a grid isNil.	self deny: (a includesCell: cellA).	self deny: x grid isNil.	self assert: (x includesCell: cellX).</body></methods><methods><class-id>GridVisualColumnTest</class-id> <category>private</category><body package="Grid SUnit Tests">column: aGridVisualColumn1 equivalentTo: aGridVisualColumn2 	^aGridVisualColumn1 column = aGridVisualColumn2 column and: 			[aGridVisualColumn1 index = aGridVisualColumn2 index and: 					[aGridVisualColumn1 predecessor = aGridVisualColumn2 predecessor and: 							[aGridVisualColumn1 successor = aGridVisualColumn2 successor and: 									[aGridVisualColumn1 grid = aGridVisualColumn2 grid and: 											[aGridVisualColumn1 left = aGridVisualColumn2 left 												and: [aGridVisualColumn1 right = aGridVisualColumn2 right]]]]]]</body><body package="Grid SUnit Tests">columnTest: column leftTo: target joining: joinColumn 	| successors allOthers joinedLast refRight joinedFirst |	successors :=column successors.	allOthers := (column withPredecessors, joinColumn first withSuccessors) asSet. 	refRight := column last right.	joinedFirst := column leftTo: target joining: joinColumn.	joinedLast := joinedFirst last.	self assert: joinedFirst isFirst.	self assert: joinedLast right = refRight.	self 		assert: (target between: joinedFirst left and: joinedFirst right).	joinedLast withSuccessorsDo:[:each| self assert: each grid notNil].	successors do:[:each| self assert: (each isFirst and: [each isLast])].	allOthers do:[:each| each right &lt; target ifTrue:[self assert: (each isFirst and: [each isLast])]].	^joinedFirst</body><body package="Grid SUnit Tests">columnTest: column rightTo: target joining: joinColumn 	| predecessors allOthers joinedFirst joinedLast refLeft |	predecessors := column predecessors.	allOthers := (column withSuccessors, joinColumn first withSuccessors) asSet.	refLeft := column left.	joinedFirst := column rightTo: target joining: joinColumn.	self assert: joinedFirst isFirst.	self assert: joinedFirst left = refLeft.	joinedLast := joinedFirst last.	self 		assert: (target between: joinedLast left and: joinedLast right).	joinedFirst withSuccessorsDo:[:each| self assert: each grid notNil].	predecessors do:[:each| self assert: (each isFirst and: [each isLast])].	allOthers do:[:each| each left &gt; target ifTrue:[self assert: (each isFirst and: [each isLast])]].	^joinedFirst</body><body package="Grid SUnit Tests">firstVisibleColumn	^GridVisualColumn 		on: columns first		in: grid		index: 1		left: 0		right: nil</body><body package="Grid SUnit Tests">midpointOf: aGridVisualColumn	^aGridVisualColumn left midpoint: aGridVisualColumn right</body><body package="Grid SUnit Tests">segmentFrom: start to: end 	^start &lt; end 		ifTrue: [(self firstVisibleColumn jumpTo: start) rightTo: end]		ifFalse: [(self lastVisibleColumn jumpTo: start) leftTo: end ]</body></methods><methods><class-id>GridVisualColumnTest</class-id> <category>running</category><body package="Grid SUnit Tests">lastVisibleColumn	^GridVisualColumn 		on: columns last		in: grid		index: columns size		left: nil		right: grid scrollableExtent x</body><body package="Grid SUnit Tests">sampleSpec	^(LabelSpec label: 'TestLabel')</body><body package="Grid SUnit Tests">setUp	grid := Grid new.	columns := (1 to: 20) collect: 					[:i | 					(GridColumn new)						width: 20;						spec: (self sampleSpec name: i);						yourself].	grid columns: columns.	firstVisibleColumn := self firstVisibleColumn.	firstVisibleColumn addSuccessorCount: 19</body><body package="Grid SUnit Tests">tearDown	grid := firstVisibleColumn := nil.</body></methods><methods><class-id>GridVisualColumnTest</class-id> <category>test list maintenance</category><body package="Grid SUnit Tests">testAddSuccessorCount	| successorCount |	successorCount := firstVisibleColumn successorCount.	firstVisibleColumn addSuccessorCount: 100.	self assert: successorCount = firstVisibleColumn successorCount.	firstVisibleColumn := self firstVisibleColumn.	firstVisibleColumn addSuccessorCount: 0.	self assert: firstVisibleColumn successorCount = 0.	1 to: 19		do: 			[:i | 			firstVisibleColumn addSuccessorCount: 1.			self assert: i = firstVisibleColumn successorCount]</body><body package="Grid SUnit Tests">testColumnLeftJoinSelf	"Identity tests"	| row rightBoundary column |	rightBoundary := grid scrollableExtent x.	row := self segmentFrom: rightBoundary to: 360.	self columnTest: row leftTo: 0 joining: row last.	self columnTest: row leftTo: 0 joining: row first.	"Attempt to join the receiver. Should not result in releasing the receiver"	column := self segmentFrom: rightBoundary to: 100.	self columnTest: column leftTo: 0 joining: column.	self assert: column grid notNil.</body><body package="Grid SUnit Tests">testColumnRightJoinSelf	"Identity tests"	| row rightBoundary column |	row := self segmentFrom: 0 to: 360.	rightBoundary := grid scrollableExtent x.	self columnTest: row rightTo: rightBoundary joining: row last.	self columnTest: row rightTo: rightBoundary joining: row first.	"Attempt to join the receiver. Should not result in releasing the receiver"	column := self segmentFrom: 100 to: rightBoundary.	self columnTest: column rightTo: rightBoundary joining: column.	self assert: column grid notNil.</body><body package="Grid SUnit Tests">testLeftTo	| predecessorCount extendedColumn lastVisibleColumn lefts |	lastVisibleColumn := firstVisibleColumn last. 	predecessorCount := lastVisibleColumn predecessorCount.	extendedColumn := lastVisibleColumn leftTo: -10000.	self assert: extendedColumn = lastVisibleColumn.	self assert: extendedColumn predecessorCount = predecessorCount.	self assert: firstVisibleColumn successorCount = predecessorCount.	extendedColumn := lastVisibleColumn leftTo: lastVisibleColumn left.	self assert: extendedColumn = lastVisibleColumn.	self assert: extendedColumn predecessorCount = 0.	self assert: firstVisibleColumn successorCount = 0.		lefts := OrderedCollection new.	firstVisibleColumn := self firstVisibleColumn addSuccessorCount: 19.	firstVisibleColumn withSuccessorsDo:[:each| lefts add: each left].	lefts := lefts reverse.	predecessorCount := 0.	lefts do:[:left | 	lastVisibleColumn := self lastVisibleColumn.	extendedColumn := lastVisibleColumn leftTo: left.	self assert: extendedColumn = lastVisibleColumn.	self assert: predecessorCount = extendedColumn predecessorCount.	predecessorCount := predecessorCount + 1].</body><body package="Grid SUnit Tests">testLeftToJoining	| rightBoundary joined secondSegment firstSegment |	rightBoundary := grid scrollableExtent x.		"Two non-overlapping segments, the receiver preceeds the second."	"Target appears at start of receiver"	joined := self columnTest: (self segmentFrom: rightBoundary to: 360) leftTo: rightBoundary - 1  joining: (self segmentFrom: 200 to: 100).	self assert: joined isLast.	"Target appears at end of receiver"	self columnTest: (self segmentFrom: rightBoundary to: 360) leftTo: 360 joining: (self segmentFrom: 200 to: 100).	"Target appears at midpoint between segments"	self columnTest: (self segmentFrom: rightBoundary to: 360) leftTo: 280 joining: (self segmentFrom: 200 to: 100).	"Target appears at start of segment to join"	secondSegment :=  self segmentFrom: 200 to: 100.	joined := self columnTest: (self segmentFrom: rightBoundary to: 360) leftTo: 200 joining: secondSegment.	self assert: joined = secondSegment.	"Target appears at end of segment to join"	secondSegment :=  self segmentFrom: 200 to: 100.	joined := self columnTest: (self segmentFrom: rightBoundary to: 360) leftTo: 0 joining: secondSegment.	self assert: joined last = secondSegment last.	"Target appears to right of segment to join"	secondSegment := self segmentFrom: 200 to: 0.	self assert: secondSegment isLast.	joined := self columnTest: (self segmentFrom: 360 to: 300) leftTo: 0 joining: secondSegment.	self assert: joined = secondSegment first.	"Two overlapping segments, the receiver preceeds the second."	secondSegment :=  self segmentFrom: 300 to: 100.	"Target within first segment only"	joined := self columnTest: (self segmentFrom: rightBoundary to: 200) leftTo: 350 joining: secondSegment.	self deny: (joined successors includes: secondSegment).	self assert: (secondSegment isFirst and:[secondSegment isLast]).	"Target within second segment only"	secondSegment := self segmentFrom: 300 to: 100.	joined := self columnTest: (self segmentFrom: rightBoundary to: 200) leftTo: 150 joining: secondSegment.	self assert: (joined successors includes: secondSegment).	"Two non-overlapping segments, the second preceeds the receiver."	"Target appears at end of receiver"	secondSegment :=  self segmentFrom: 200 to: 100.	firstSegment := self segmentFrom: rightBoundary to: 300.	joined := self columnTest: firstSegment leftTo: 100 joining: secondSegment.	self assert: secondSegment first = joined.</body><body package="Grid SUnit Tests">testRightTo	| successorCount extendedColumn rights |	"Ensure the receiver successor count does not surpass the number of columns available"	successorCount := firstVisibleColumn successorCount.	extendedColumn := firstVisibleColumn rightTo: 100000.	self assert: extendedColumn = firstVisibleColumn.	self assert: extendedColumn successorCount = successorCount.		"Ensure no successors are added to the receiver if the target boundary does not exceed the receiver right border"	firstVisibleColumn := self firstVisibleColumn.	extendedColumn := firstVisibleColumn rightTo: firstVisibleColumn right.	self assert: extendedColumn = firstVisibleColumn.	self assert: extendedColumn successorCount = 0.		rights := OrderedCollection new.	firstVisibleColumn := self segmentFrom: 0 to: grid scrollableExtent x.	firstVisibleColumn withSuccessorsDo:[:each| rights add: each right].	successorCount := 0.	rights do:[:right | 	firstVisibleColumn := self firstVisibleColumn.	extendedColumn := firstVisibleColumn rightTo: right.	self assert: extendedColumn = firstVisibleColumn.	self assert: successorCount = extendedColumn successorCount.	successorCount := successorCount + 1].</body><body package="Grid SUnit Tests">testRightToJoining	| rightBoundary joined lastIndex firstSegment secondSegment |	rightBoundary := grid scrollableExtent x.	"Two non-overlapping segments, the receiver preceeds the second."	"Target appears at start of receiver"	joined := self columnTest: (self segmentFrom: 100 to: 200) rightTo: 101 joining: (self segmentFrom: 360 to: rightBoundary).	self assert: joined isLast.	"Target appears at end of receiver"	self columnTest: (self segmentFrom: 100 to: 200) rightTo: 200 joining: (self segmentFrom: 360 to: rightBoundary).	"Target appears at midpoint between segments"	self columnTest: (self segmentFrom: 100 to: 200) rightTo: 280 joining: (self segmentFrom: 360 to: rightBoundary).	"Target appears at start of segment to join"	secondSegment :=  self segmentFrom: 360 to: rightBoundary.	joined := self columnTest: (self segmentFrom: 100 to: 200) rightTo: 360 joining: secondSegment.	self assert: joined last = secondSegment.	"Target appears at end of segment to join"	secondSegment :=  self segmentFrom: 360 to: rightBoundary.	joined := self columnTest: (self segmentFrom: 100 to: 200) rightTo: rightBoundary joining: secondSegment.	self assert: joined last = secondSegment last.	"Target appears to right of segment to join"	secondSegment :=  self segmentFrom: 300 to: 360.	lastIndex := secondSegment last index.	joined := self columnTest: (self segmentFrom: 100 to: 200) rightTo: rightBoundary joining: secondSegment.	self assert: joined last index &gt; lastIndex.	self assert: secondSegment last = joined last.	"Two overlapping segments, the receiver preceeds the second."	secondSegment :=  self segmentFrom: 200 to: rightBoundary.	"Target within first segment only"	joined := self columnTest: (self segmentFrom: 100 to: 300) rightTo: 150 joining: secondSegment.	self deny: (joined successors includes: secondSegment).	self assert: (secondSegment isFirst and:[secondSegment isLast]).	"Target within second segment only"	secondSegment :=  self segmentFrom: 200 to: rightBoundary.	joined := self columnTest: (self segmentFrom: 100 to: 300) rightTo: 350 joining: secondSegment.	self assert: (joined successors includes: secondSegment).	"Two non-overlapping segments, the second preceeds the receiver."	"Target appears at end of receiver"	secondSegment :=  self segmentFrom: 100 to: 200.	firstSegment := self segmentFrom: 300 to: rightBoundary.	joined := self columnTest: firstSegment rightTo: rightBoundary joining: secondSegment.	self assert: firstSegment = joined.	self assert: secondSegment isLast.</body></methods><methods><class-id>GridVisualColumnTest</class-id> <category>test accessing</category><body package="Grid SUnit Tests">testGridEnd	self 		assert: (self column: (GridVisualColumn 						on: columns last						in: grid						index: columns size						left: nil						right: grid scrollableExtent x)				equivalentTo: firstVisibleColumn gridEnd)</body><body package="Grid SUnit Tests">testGridOrigin	self 		assert: (self column: (GridVisualColumn 						on: columns first						in: grid						index: 1						left: 0						right: nil)				equivalentTo: firstVisibleColumn gridOrigin)</body><body package="Grid SUnit Tests">testJumpTo	"Test access for a GridVisualColumn at a specific distance in and outside the visual range"	| lastVisibleColumn leftmostColumn rightmostColumn endColumn startColumn midColumn |	lastVisibleColumn := firstVisibleColumn last.	"Try jumping within range"	firstVisibleColumn withSuccessorsDo: 			[:each | | midpoint |			midpoint := self midpointOf: each.			self assert: (firstVisibleColumn jumpTo: midpoint) = each.			self assert: (lastVisibleColumn jumpTo: midpoint) = each.			self assert: (each jumpTo: (self midpointOf: firstVisibleColumn )) = firstVisibleColumn.			self assert: (each jumpTo:  (self midpointOf: lastVisibleColumn )) = lastVisibleColumn].	"Try jumping out of range"	columns := columns , columns.	columns keysAndValuesDo: [:i :each | each spec name: i].	grid columns: columns.	firstVisibleColumn := firstVisibleColumn atIndex: lastVisibleColumn index // 2.	endColumn := firstVisibleColumn gridEnd.	startColumn := firstVisibleColumn gridOrigin.	firstVisibleColumn severPredecessor severSuccessor.	self assert: (firstVisibleColumn jumpTo: (self midpointOf: firstVisibleColumn )) 				= firstVisibleColumn.	"Start at midpoint jump to end"	rightmostColumn := firstVisibleColumn jumpTo: grid scrollableExtent x.	self assert: (self column: rightmostColumn equivalentTo: endColumn).	"Start at midpoint jump to start"	leftmostColumn := firstVisibleColumn jumpTo: 0.	self assert: (self column: leftmostColumn equivalentTo: startColumn).	"Start at end jump to midpoint"	midColumn := endColumn jumpTo: firstVisibleColumn left.	self assert: (self column: midColumn equivalentTo: firstVisibleColumn).	"Start at end jump to start"	leftmostColumn := endColumn jumpTo: 0.	self assert: (self column: leftmostColumn equivalentTo: startColumn).</body><body package="Grid SUnit Tests">testJumpToIndex	"Test access for a GridVisualColumn at a specific column index in and outside the visual range"	| lastVisibleColumn leftmostColumn rightmostColumn endColumn startColumn midColumn |	lastVisibleColumn := firstVisibleColumn last.	"Try jumping within range"	firstVisibleColumn withSuccessorsDo: 			[:each | 			self assert: (firstVisibleColumn jumpToIndex: each index) = each.			self assert: (lastVisibleColumn jumpToIndex: each index) = each.			self assert: (each jumpToIndex: firstVisibleColumn index) = firstVisibleColumn.			self assert: (each jumpToIndex: lastVisibleColumn index) = lastVisibleColumn].	"Try jumping out of range"	columns := columns , columns.	columns keysAndValuesDo: [:i :each | each spec name: i].	grid columns: columns.	firstVisibleColumn := firstVisibleColumn atIndex: lastVisibleColumn index // 2.	endColumn := firstVisibleColumn gridEnd.	startColumn := firstVisibleColumn gridOrigin.	firstVisibleColumn severPredecessor severSuccessor.	self assert: (firstVisibleColumn jumpToIndex: firstVisibleColumn index) 				= firstVisibleColumn.	"Start at midpoint jump to end"	rightmostColumn := firstVisibleColumn jumpToIndex: columns size.	self assert: (self column: rightmostColumn equivalentTo: endColumn).	"Start at midpoint jump to start"	leftmostColumn := firstVisibleColumn jumpToIndex: 1.	self assert: (self column: leftmostColumn equivalentTo: startColumn).	"Start at end jump to midpoint"	midColumn := endColumn jumpToIndex: firstVisibleColumn index.	self assert: (self column: midColumn equivalentTo: firstVisibleColumn).	"Start at end jump to start"	leftmostColumn := endColumn jumpToIndex: startColumn index.	self assert: (self column: leftmostColumn equivalentTo: startColumn).</body><body package="Grid SUnit Tests">testNearest	| lastVisibleColumn |	lastVisibleColumn := firstVisibleColumn last.	firstVisibleColumn withSuccessorsDo: 			[:each | 			self assert: (firstVisibleColumn nearest: each left) 						= (each predecessor ifNil: [each]).			self assert: (firstVisibleColumn nearest: each right) = each.			self assert: (lastVisibleColumn nearest: each right) 						= (each successor ifNil: [each]).			self assert: (lastVisibleColumn nearest: each left) = each].	self assert: (firstVisibleColumn nearest: grid scrollableExtent x + 20) 				= firstVisibleColumn last.	self assert: (firstVisibleColumn nearest: -20) = firstVisibleColumn.</body></methods><methods><class-id>GridVisualColumnTest</class-id> <category>test testing</category><body package="Grid SUnit Tests">testIsFullyVisible</body></methods><methods><class-id>GridVisualColumnTest</class-id> <category>test positioning and size</category><body package="Grid SUnit Tests">testBoundaries	"Test #cellRight, #cellLeft, #right, and #left"	| left |	left := 0.	grid firstVisibleColumn withSuccessorsDo: 			[:each |			| column right|			column := each column.			self assert: column width = 20.			self assert: each cellRight = (each right - column paddingRight).			self assert: each cellLeft = (each left + column paddingLeft).			right := left + column widthWithGap.			self assert: each left = left.			self assert: each right = right.			left := right]</body><body package="Grid SUnit Tests">testMoveLeftSideTo</body><body package="Grid SUnit Tests">testMoveRightSideTo</body><body package="Grid SUnit Tests">testWidth	| grid2 column2 firstVisibleColumn2 |	grid2 := Grid new.	column2 := (GridColumn new)				spec: 1;				width: 100.	grid2 columns: (Array with: column2) 				, ((2 to: 20) collect: 							[:i | 							(GridColumn new)								spec: i;								width: 20]).	self assert: grid2 scrollableExtent x = (grid scrollableExtent x + 80).	firstVisibleColumn2 := grid2 firstVisibleColumn.	firstVisibleColumn2 addSuccessorCount: 19.	self assert: firstVisibleColumn left = firstVisibleColumn2 left.	self deny: firstVisibleColumn right = firstVisibleColumn2 right.	firstVisibleColumn successor withSuccessorsDo: 			[:each | 			| match |			match := firstVisibleColumn2 atIndex: each index.			self deny: each left = match left.			self deny: each right = match right].	firstVisibleColumn2 width: 20.	self assert: grid2 scrollableExtent x = grid scrollableExtent x.	firstVisibleColumn withSuccessorsDo: 			[:each | 			| match |			match := firstVisibleColumn2 atIndex: each index.			self assert: each left = match left.			self assert: each right = match right]</body></methods><methods><class-id>GridVisualColumnTest</class-id> <category>test enumeration</category><body package="Grid SUnit Tests">testWithSuccessorsFromToDo	| indexes extent columnsSubset start end |	extent := grid scrollableExtent x.	"Case 1: Range above all columns"	indexes := OrderedCollection new.	firstVisibleColumn 		withSuccessorsFrom: extent + 1		to: extent + 100		do: [:each | indexes add: each ].	self assert: indexes isEmpty.	"Case 2: Range starts within some columns but ends above all"	indexes := OrderedCollection new.	start := extent.	end := extent + 100.	firstVisibleColumn 		withSuccessorsFrom: start		to: end		do: [:each | indexes add: each].	self assert: indexes = (OrderedCollection with: firstVisibleColumn last).	indexes := OrderedCollection new.	columnsSubset := (firstVisibleColumn atIndex: columns size - 2) successors.	start := columnsSubset first right.	firstVisibleColumn 		withSuccessorsFrom: start		to: end		do: [:each | indexes add: each].	self assert: indexes asArray = columnsSubset.	"Case 3: Range starts and ends within linked list of visuals"	indexes := OrderedCollection new.	columnsSubset := columns copyFrom: 6 to: 13.	start := (firstVisibleColumn atIndex: 6) right.	end := (firstVisibleColumn atIndex: 13) left.	firstVisibleColumn 		withSuccessorsFrom: start		to: end		do: [:each | indexes add: each column].	self assert: indexes asArray = columnsSubset.	"Case 4: Range starts below but ends within linked list of visuals"	indexes := OrderedCollection new.	columnsSubset := columns copyFrom: 6 to: 13.	start := -100.	end := firstVisibleColumn right.	firstVisibleColumn 		withSuccessorsFrom: start		to: end		do: [:each | indexes add: each].	self 		assert: indexes = (OrderedCollection with: firstVisibleColumn						with: firstVisibleColumn successor).	indexes := OrderedCollection new.	end := firstVisibleColumn left.	firstVisibleColumn 		withSuccessorsFrom: start		to: end		do: [:each | indexes add: each].	self assert: indexes = (OrderedCollection with: firstVisibleColumn).	"Case 5: Range below all columns"	indexes := OrderedCollection new.	firstVisibleColumn 		withSuccessorsFrom: -100		to: firstVisibleColumn left - 1		do: [:each | indexes add: each index].	self assert: indexes isEmpty.	"Case 6: Range starts and ends within a single column"	indexes := OrderedCollection new.	firstVisibleColumn 		withSuccessorsFrom: firstVisibleColumn left + 1		to: firstVisibleColumn right - 1		do: [:each | indexes add: each].	self assert: indexes = (OrderedCollection with: firstVisibleColumn).	"Case 7: Reversed range"	indexes := OrderedCollection new.	firstVisibleColumn 		withSuccessorsFrom: firstVisibleColumn last left		to: firstVisibleColumn right		do: [:each | indexes add: each].	self assert: indexes isEmpty.	"Case 8: Range exceeds all columns"	indexes := OrderedCollection new.	firstVisibleColumn 		withSuccessorsFrom: -1		to: firstVisibleColumn last right + 1		do: [:each | indexes add: each].	self assert: indexes = firstVisibleColumn withSuccessors asOrderedCollection.</body></methods><methods><class-id>GridVisualColumnTest</class-id> <category>test private</category><body package="Grid SUnit Tests">testSegmentFromTo	"Test helper method columnFrom:to:"	| segmentStart segmentEnd |	segmentStart := self segmentFrom: 100 to: 200.	segmentEnd := segmentStart last.	self assert: segmentStart isFirst.	self assert: (100 between: segmentStart left and: segmentStart right).	self assert: (200 between: segmentEnd left and: segmentEnd right).		segmentEnd  := self segmentFrom: 200 to: 100.	segmentStart := segmentEnd first.	self assert: segmentEnd isLast.	self assert: (200 between: segmentEnd  left and: segmentEnd  right).	self assert: (100 between: segmentStart left and: segmentStart right).</body></methods><methods><class-id>GridInterfaceTest</class-id> <category>private</category><body package="Grid SUnit Tests">columnInputSpecIndexedBy: anInteger	^InputFieldSpec new 		name: anInteger;		model: ('_row ', anInteger printString) asSymbol;		type: #object;		yourself</body></methods><methods><class-id>GridInterfaceTest</class-id> <category>testing</category><body package="Grid SUnit Tests">testAllowColumnReordering	gridApp allButOpenInterface: #windowSpec.	gridInterface allowColumnReordering: false.	self deny: grid allowColumnReordering.	gridInterface allowColumnReordering: true.	self assert: grid allowColumnReordering.</body><body package="Grid SUnit Tests">testAllowColumnResizing	gridApp allButOpenInterface: #windowSpec.	gridInterface allowColumnResizing: false.	self deny: grid allowColumnResizing.	gridInterface allowColumnResizing: true.	self assert: grid allowColumnResizing.</body><body package="Grid SUnit Tests">testColumnAtNameKey	columns last id: #lastData.	columns first id: #firstData.		self assert: (gridInterface columnAtNameKey: #foobar) isNil.	self assert: (gridInterface columnAtNameKey: #lastData) = columns last.	self assert: (gridInterface columnAtNameKey: #firstData) = columns first.</body><body package="Grid SUnit Tests">testColumns		| newColumns |	self assert: gridInterface columns = columns.	newColumns := List new.	gridInterface columns: newColumns.	self assert: gridInterface columns = newColumns.</body><body package="Grid SUnit Tests">testDataColumnsAndHeaders"Fails because #noHeaderRow releases Grid component and so disposes of its columns and rows"	"gridInterface headerRow: (GridHeaderRow new height: 20).	gridApp allButOpenInterface: #windowSpec.	self assert: gridInterface headerRow notNil.	self assert: gridInterface decorator headerRowGrid notNil.	gridInterface decorator noHeaderRow.	self assert: gridInterface headerRow notNil.	self deny: gridInterface decorator hasHeaderRow."</body><body package="Grid SUnit Tests">testGridView	gridApp allButOpenInterface: #windowSpec.	self assert: grid = gridInterface grid.</body><body package="Grid SUnit Tests">testItemsAndRows	| rows |	rows := grid rows.	gridInterface items: entries.	gridInterface rows: List new.	self assert: gridInterface items = entries.	self assert: gridInterface rows isEmpty.	gridInterface setRowsFromItems.	self assert: (gridInterface rows collect:[:row| row item]) asList = entries .	gridInterface items: List new.	gridInterface rows: rows.	self assert: gridInterface items isEmpty.	self assert: gridInterface rows = rows.	gridInterface setItemsFromRows.	self assert: gridInterface items  = entries.</body><body package="Grid SUnit Tests">testModel	| empty rows |	rows := grid rows.	empty :=  List new.	gridInterface rows: empty.	self assert: gridInterface rows = empty.	self assert: gridInterface selectionInGrid list = empty.	self assert: grid rows = empty.	gridInterface rows: rows.	self assert: gridInterface rows = rows.	self assert: gridInterface selectionInGrid list = rows.	self assert: grid rows = rows.	gridInterface selectionInGrid list: empty.	self assert: gridInterface rows = empty.	self assert: gridInterface selectionInGrid list = empty.	self assert: grid rows = empty.</body><body package="Grid SUnit Tests">testMultiSelectMode	gridApp allButOpenInterface: #windowSpec.	self assert: gridInterface multiSelect = grid multiSelect.	gridInterface multiSelect: grid multiSelect not.	self assert: gridInterface multiSelect = grid multiSelect.</body><body package="Grid SUnit Tests">testRowSize	"Create a Grid from a #windowSpec that specifies row size.  Confirm that the defaultRowHeight is set to the row size"	| specWrapper defaultRowHeight newRowHeight |	gridApp allButOpenInterface: #windowSpec.	specWrapper := gridApp wrapperAt: #Grid1.	defaultRowHeight := specWrapper spec rowSize.	self assert: grid defaultRowHeight = defaultRowHeight.	self assert: gridInterface defaultRowHeight = defaultRowHeight.	newRowHeight := defaultRowHeight + 10.	gridInterface defaultRowHeight: newRowHeight.	self assert: grid defaultRowHeight = newRowHeight.	self assert: gridInterface defaultRowHeight = newRowHeight.</body><body package="Grid SUnit Tests">testRows		gridInterface rows: List new.	self assert: gridInterface rows isEmpty.</body><body package="Grid SUnit Tests">testSelectByCellMode	gridApp allButOpenInterface: #windowSpec.	self assert: gridInterface selectByCell = grid selectByCell.	gridInterface selectByCell: grid selectByCell not.	self assert: gridInterface selectByCell = grid selectByCell.</body><body package="Grid SUnit Tests">testSelectPoint	gridApp allButOpenInterface: #windowSpec.	self deny: gridInterface hasSelections.	self deny: gridInterface selectByCell.	"Single Select"	"Select 2nd row by select by row mode"	gridInterface selectPoint: 2@3.	self assert: ((Set with: (entries at: 3)) - gridInterface selections) isEmpty.	gridInterface clearAll.	self deny: gridInterface hasSelections.	"Select cell 2@3 by select by cell mode"	gridInterface selectByCell: true.	gridInterface selectPoint: 2@3.	self assert: ((Set with: ((entries at: 3) at: 2)) - gridInterface selections) isEmpty.	gridInterface clearAll.	self deny: gridInterface hasSelections.	"Multi Row Select"	gridInterface beMultiSelect.	gridInterface selectByCell: false.	gridInterface selectPoint: 2@3.	gridInterface selectPoint: 4@3.	gridInterface selectPoint: 1@5.	self assert: ((Set with: (entries at: 3) with: (entries at: 5)) - gridInterface selections) isEmpty.	"Multi Cell Select"	gridInterface clearAll.	self deny: gridInterface hasSelections.	gridInterface selectByCell: true.	gridInterface selectPoint: 2@3.	gridInterface selectPoint: 4@3.	gridInterface selectPoint: 1@5.	self assert: ((Set with: ((entries at: 3) at: 2) with: ((entries at: 3) at: 4) with: ((entries at: 5) at: 1)) - gridInterface selections) isEmpty.</body><body package="Grid SUnit Tests">testSelectRange	| setSelections |	gridApp allButOpenInterface: #windowSpec.	self deny: gridInterface hasSelections.	self deny: gridInterface selectByCell.	"Single Select Row range"	gridInterface selectRange: (2@3 corner: 4@5).	self assert: ((Set with: (entries at: 3)) - gridInterface selections) isEmpty.	gridInterface clearAll.	self deny: gridInterface hasSelections.	"Single Select Cell range"	gridInterface selectByCell: true.	gridInterface selectRange: (2@3 corner: 4@5).	self assert: ((Set with: ((entries at: 3) at: 2)) - gridInterface selections) isEmpty.	gridInterface clearAll.	self deny: gridInterface hasSelections.	"Multi Select Cell range"	gridInterface beMultiSelect.	gridInterface selectRange: (2@3 corner: 4@5).	setSelections := Set new.	grid selectionRange do:[:range| grid range: range cellsDo:[:cell| setSelections add: cell cellPoint]].	self assert: (setSelections - gridInterface selections) isEmpty.	gridInterface clearAll.	self deny: gridInterface hasSelections.	"Multi Select Row range"	gridInterface selectByCell: false.	gridInterface selectRange: (2@3 corner: 4@5).	self assert: ((Set with: (entries at: 3) with: (entries at: 4) with: (entries at: 5)) - gridInterface selections) isEmpty.</body><body package="Grid SUnit Tests">testSelections	"Test for correspondence between selected items and rows/cells. Also check #selectAll and #clearAll"	| someItem |	self assert: gridInterface selections isEmpty.	self assert: grid selectionRange isEmpty.	self deny: gridInterface hasSelections.	gridInterface selections: entries.	self assert: (entries asSet - gridInterface selections) isEmpty.	self assert: gridInterface hasSelections.	someItem := entries last.	gridInterface selections: (Array with: someItem).	self assert: ((Set with: someItem) - gridInterface selections) isEmpty.	gridInterface selectAll.	self assert: (entries asSet - gridInterface selections) isEmpty.	gridInterface clearAll.	self deny: gridInterface hasSelections.</body><body package="Grid SUnit Tests">testUpdates	"Tests to ensure that changes to the items list updates the grid rows"	| rows numColumns moreEntries |	gridApp allButOpenInterface: #windowSpec.	rows := grid rows.	numColumns := grid columns size.	moreEntries := (21 to: 25) collect: [:y | (1 to: numColumns) collect: [:x | x @ y ]].	entries add: moreEntries first.	self assert: rows size = entries size.	entries remove: moreEntries first.	self assert: rows size = entries size.	entries addFirst:  moreEntries first.	self assert: rows size = entries size.	entries removeFrom: 1 to: 5.	self assert: rows size = entries size.	entries addAll: moreEntries.	self assert: rows size = entries size.</body></methods><methods><class-id>GridInterfaceTest</class-id> <category>Running</category><body package="Grid SUnit Tests">setUp	| numRows numColumns |	super initialize.	numRows := 20.	numColumns := 20.	gridApp := EmptyGridApp new.	gridInterface := gridApp gridInterface.	entries := (1 to: numRows) asList		collect: [:y | (1 to: numColumns) collect: [:x | x @ y ]].	columns := 	(1 to: numColumns)		collect:			[:i | 			GridColumn				spec: (self columnInputSpecIndexedBy: i)				in: nil				width: 50				label: i printString].	gridInterface 		defaultRowHeight: 25;		columns: columns;		items: entries;		headerRow: (GridHeaderRow new height: 20);		setRowsFromItems.	grid := gridInterface grid.</body><body package="Grid SUnit Tests">tearDown	super tearDown.	entries := columns := grid := gridInterface :=nil.</body></methods><methods><class-id>GridDecoratorTest</class-id> <category>test columns</category><body package="Grid SUnit Tests">testAddColumns	| headerRow headerRowGrid |	gridApp allButOpenInterface: #windowSpec.	headerRow :=  GridHeaderRow new height: 20.	gridInterface headerRow: headerRow.	headerRowGrid := gridInterface decorator headerRowGrid.	self assert: headerRowGrid columns = grid columns.		"Add a new column and confirm that header row and grid column sizes update"	GridColumn				spec: (self columnInputSpecIndexedBy: 21)				in: grid				width: 80.	self assert: headerRowGrid columns = grid columns.		"Remove column and confirm that header row and grid column sizes update"	grid columns removeFirst.	self assert: headerRowGrid columns = grid columns.</body><body package="Grid SUnit Tests">testColumnSizeUpdate</body><body package="Grid SUnit Tests">testColumnUpdate</body><body package="Grid SUnit Tests">testDecorator	gridApp allButOpenInterface: #windowSpec.	self assert: (gridInterface decorator isKindOf: GridDecorator)</body><body package="Grid SUnit Tests">testRemoveColumns</body></methods><methods><class-id>GridDecoratorTest</class-id> <category>Running</category><body package="Grid SUnit Tests">setUp	| numColumns numRows entries |	numRows := 20.	numColumns := 20.	entries := (1 to: numRows) 				collect: [:y | (1 to: numColumns) collect: [:x | x @ y]].	gridApp := EmptyGridApp new.	gridInterface := gridApp gridInterface.	gridInterface 		defaultRowHeight: 25;		items: entries asList;		setRowsFromItems.	grid := gridInterface grid.	rows := grid rows.	(1 to: numColumns)		do:			[:i | 			GridColumn				spec: (self columnInputSpecIndexedBy: i)				in: grid				width: 50				label: i printString].</body><body package="Grid SUnit Tests">tearDown	super tearDown.	gridApp closeRequest.	grid := rows := gridApp := nil.</body></methods><methods><class-id>GridDecoratorTest</class-id> <category>private</category><body package="Grid SUnit Tests">columnInputSpecIndexedBy: anInteger	^InputFieldSpec new 		name: anInteger;		model: ('_row ', anInteger printString) asSymbol;		type: #object;		yourself</body></methods><methods><class-id>GridDecoratorTest</class-id> <category>test rows</category><body package="Grid SUnit Tests">testAddRows</body><body package="Grid SUnit Tests">testRemoveRows</body><body package="Grid SUnit Tests">testRowSizeUpdate</body></methods><methods><class-id>SortItem</class-id> <category>accessing</category><body package="Grid SUnit Tests">name	^name</body><body package="Grid SUnit Tests">value	^value</body><body package="Grid SUnit Tests">variable	^variable</body></methods><methods><class-id>SortItem</class-id> <category>initialize-release</category><body package="Grid SUnit Tests">name: aName variable: aVariable value: aValue	name := aName.	variable := aVariable.	value := aValue</body></methods><methods><class-id>SortItem</class-id> <category>printing</category><body package="Grid SUnit Tests">printString	^name , '.' , variable , '.' , value printString</body></methods><methods><class-id>SortItem class</class-id> <category>instance creation</category><body package="Grid SUnit Tests">name: aName variable: aVariable value: aValue	^self new name: aName variable: aVariable value: aValue</body></methods><methods><class-id>GridVisualRowTest</class-id> <category>private</category><body package="Grid SUnit Tests">firstVisibleRow	^GridVisualRow 		on: rows first		in: grid		index: 1		top: 0		bottom: nil</body><body package="Grid SUnit Tests">lastVisibleRow	^GridVisualRow 		on: rows first		in: grid		index: rows size		top: nil		bottom: grid scrollableExtent y</body><body package="Grid SUnit Tests">midpointOf: aGridVisualRow	^aGridVisualRow top midpoint: aGridVisualRow bottom</body><body package="Grid SUnit Tests">row: aGridVisualRow1 equivalentTo: aGridVisualRow2 	^aGridVisualRow1 row = aGridVisualRow2 row and: 			[aGridVisualRow1 index = aGridVisualRow2 index and: 					[aGridVisualRow1 predecessor = aGridVisualRow2 predecessor and: 							[aGridVisualRow1 successor = aGridVisualRow2 successor and: 									[aGridVisualRow1 grid = aGridVisualRow2 grid and: 											[aGridVisualRow1 top = aGridVisualRow2 top 												and: [aGridVisualRow1 bottom = aGridVisualRow2 bottom]]]]]]</body><body package="Grid SUnit Tests">rowFrom: start to: end 	^start &lt; end 		ifTrue: [(self firstVisibleRow jumpTo: start) downTo: end]		ifFalse: [(self lastVisibleRow jumpTo: start) upTo: end ]</body><body package="Grid SUnit Tests">rowTest: row downTo: target joining: joinRow 	| successors1 successors2 refTop joinTop endRow testCompleted joinBottom |	successors1 := row withSuccessors.	successors2 := joinRow withSuccessors.	refTop := row top.	joinTop := joinRow top.	joinBottom := joinRow last bottom.	testCompleted := false.	endRow := row downTo: target joining: joinRow.	self assert: (target between: endRow last top and: endRow last bottom).	self assert: endRow isFirst.	(target &lt;= joinTop or: [row top &gt;= joinBottom]) 		ifTrue: 			[self assert: endRow = row.			self assert: endRow successorCount = row successorCount.			successors2 do: [:each | self assert: (each isFirst and: [each isLast])].			testCompleted := true].	(joinRow ~= endRow and: [joinTop &lt;= refTop and: [joinBottom &gt; refTop]]) 		ifTrue: 			[self assert: endRow = joinRow.			self assert: endRow successorCount = joinRow successorCount.			joinRow ~= row 				ifTrue: 					[successors1 do: [:each | self assert: (each isFirst and: [each isLast])]].			successors2 do: 					[:each | 					each top &gt; target ifTrue: [self assert: (each isFirst and: [each isLast])]].			testCompleted := true].	joinTop &gt; refTop 		ifTrue: 			[self assert: endRow = row.			self assert: endRow successorCount = row successorCount.			successors1 do: 					[:each | 					each top &gt; joinTop 						ifTrue: [self assert: (each isFirst and: [each isLast])]].			successors2 do: 					[:each | 					each top &gt; target ifTrue: [self assert: (each isFirst and: [each isLast])]].			testCompleted := true].	joinRow = endRow ifTrue: [testCompleted := true].	self assert: testCompleted</body><body package="Grid SUnit Tests">rowTest: row upTo: target joining: joinRow 	| successors1 successors2 joinTop joinBottom endRow testCompleted refBottom |	successors1 := row withSuccessors.	successors2 := joinRow withSuccessors.	refBottom := row last bottom.	joinTop := joinRow first top.	joinBottom := joinRow last bottom.	testCompleted := false.	endRow := row upTo: target joining: joinRow.	self assert: (target between: endRow first top and: endRow first bottom).	(target &gt;= joinBottom or: [row bottom &lt;= joinTop]) 		ifTrue: 			[self assert: endRow first = row first.			self assert: endRow predecessorCount = row successorCount.			successors2 do: [:each | self assert: (each isFirst and: [each isLast])].			testCompleted := true].	(joinRow ~= endRow 		and: [joinBottom &gt;= refBottom and: [joinTop &lt; refBottom]]) 			ifTrue: 				[self assert: endRow last = joinRow.				self assert: endRow predecessorCount = joinRow successorCount.				joinRow ~= row 					ifTrue: 						[successors1 do: [:each | self assert: (each isFirst and: [each isLast])]].				successors2 do: 						[:each | 						each bottom &lt; target 							ifTrue: [self assert: (each isFirst and: [each isLast])]].				testCompleted := true].	joinBottom &lt; refBottom 		ifTrue: 			[self assert: endRow last = row.			self assert: endRow predecessorCount = row successorCount.			successors1 do: 					[:each | 					each bottom &lt; joinBottom 						ifTrue: [self assert: (each isFirst and: [each isLast])]].			successors2 do: 					[:each | 					each bottom &lt; target 						ifTrue: [self assert: (each isFirst and: [each isLast])]].			testCompleted := true].	joinRow = endRow ifTrue: [testCompleted := true].	self assert: testCompleted</body></methods><methods><class-id>GridVisualRowTest</class-id> <category>running</category><body package="Grid SUnit Tests">setUp	grid := Grid new.	rows := (1 to: 20) collect: 					[:i | 					(GridRow new)						item: i;						height: 20].	grid rows: rows.	firstVisibleRow := self firstVisibleRow.	firstVisibleRow addSuccessorCount: 19.</body><body package="Grid SUnit Tests">tearDown	grid := firstVisibleRow := rows := nil.</body></methods><methods><class-id>GridVisualRowTest</class-id> <category>test list maintenance</category><body package="Grid SUnit Tests">testAddSuccessorCount	| successorCount |	successorCount := firstVisibleRow successorCount.	firstVisibleRow addSuccessorCount: 100.	self assert: successorCount = firstVisibleRow successorCount.	firstVisibleRow := self firstVisibleRow.	firstVisibleRow addSuccessorCount: 0.	self assert: firstVisibleRow successorCount = 0.	1 to: 19		do: 			[:i | 			firstVisibleRow addSuccessorCount: 1.			self assert: i = firstVisibleRow successorCount]</body><body package="Grid SUnit Tests">testDownTo	| successorCount extendedRow bottoms |	successorCount := firstVisibleRow successorCount.	extendedRow := firstVisibleRow downTo: 100000.	self assert: extendedRow = firstVisibleRow.	self assert: extendedRow successorCount = successorCount.	self assert: firstVisibleRow successorCount = successorCount.	extendedRow := firstVisibleRow downTo: firstVisibleRow bottom.	self assert: extendedRow = firstVisibleRow.	self assert: extendedRow successorCount = 0.	self assert: firstVisibleRow successorCount = 0.			bottoms := OrderedCollection new.	firstVisibleRow := self firstVisibleRow addSuccessorCount: 19.	firstVisibleRow withSuccessorsDo:[:each| bottoms add: each bottom].	successorCount := 0.	bottoms do:[:bottom | 	firstVisibleRow := self firstVisibleRow.	extendedRow := firstVisibleRow downTo: bottom.	self assert: extendedRow = firstVisibleRow.	self assert: successorCount = extendedRow successorCount.	successorCount := successorCount + 1].</body><body package="Grid SUnit Tests">testDownToJoining	| nextVisibleRow bottomBoundary row lastVisibleRow |	bottomBoundary := grid scrollableExtent y.	firstVisibleRow := self rowFrom: 0 to: 144.	nextVisibleRow := self rowFrom: 200 to: bottomBoundary.	self assert: firstVisibleRow top = 0.		lastVisibleRow :=  firstVisibleRow last.	self assert: (144 between: lastVisibleRow top and: lastVisibleRow bottom).	self assert: (nextVisibleRow bottom between: 200 and: bottomBoundary).	self assert: nextVisibleRow last bottom &lt;= bottomBoundary.	"Case 1. The GridVisualRow to be joined ends after the receiver top border and the target boundary."	self rowTest: (self rowFrom: 200 to: bottomBoundary) downTo: bottomBoundary joining: (self rowFrom: 0 to: 144).	"Case 2.  The GridVisualRow to be joined starts after the target boundary."	self rowTest: (self rowFrom: 0 to: 100) downTo: 144 joining: (self rowFrom: 200 to: bottomBoundary).	"Case 2a. The GridVisualRow to be joined starts after the target boundary."	self rowTest: (self rowFrom: 0 to: 144) downTo: 144 joining: (self rowFrom: 200 to: bottomBoundary).		"Case 2b. Same as above but start at the end of the receiver"	self rowTest: (self rowFrom: 0 to: 144) last downTo: 144 joining: (self rowFrom: 200 to: bottomBoundary).	"Case 2c. The target boundary coincides with the start of the row to be joined"	self rowTest: (self rowFrom: 0 to: 144) downTo: 192 joining: (self rowFrom: 200 to: bottomBoundary).	"Case 3. The GridVisualRow to be joined starts above and ends within the receiver above the target boundary."	self rowTest: (self rowFrom: 200 to: bottomBoundary) downTo: bottomBoundary joining: (self rowFrom: 0 to: 144) .		"Case 4. The GridVisualRow to be joined starts within and ends after the receiver end and target boundary."	self rowTest: (self rowFrom: 0 to: 360) downTo: bottomBoundary - 60 joining: (self rowFrom: 200 to: bottomBoundary).	"Identity tests"	row := self rowFrom: 0 to: 144.	self rowTest: row downTo: bottomBoundary joining: row last.	self rowTest: row downTo: bottomBoundary joining: row first.</body><body package="Grid SUnit Tests">testUpTo	| predecessorCount extendedRow tops lastVisibleRow |	lastVisibleRow := firstVisibleRow last. 	predecessorCount := lastVisibleRow predecessorCount.	extendedRow := lastVisibleRow upTo: -10000.	self assert: extendedRow = lastVisibleRow.	self assert: extendedRow predecessorCount = predecessorCount.	self assert: firstVisibleRow successorCount = predecessorCount.	extendedRow := lastVisibleRow upTo: lastVisibleRow top.	self assert: extendedRow = lastVisibleRow.	self assert: extendedRow predecessorCount = 0.	self assert: firstVisibleRow successorCount = 0.		tops := OrderedCollection new.	firstVisibleRow := self firstVisibleRow addSuccessorCount: 19.	firstVisibleRow withSuccessorsDo:[:each| tops add: each top].	tops := tops reverse.	predecessorCount := 0.	tops do:[:top | 	lastVisibleRow := self lastVisibleRow.	extendedRow := lastVisibleRow upTo: top.	self assert: extendedRow = lastVisibleRow.	self assert: predecessorCount = extendedRow predecessorCount.	predecessorCount := predecessorCount + 1].</body><body package="Grid SUnit Tests">testUpToJoining	| nextVisibleRow bottomBoundary row lastVisibleRow |	bottomBoundary := grid scrollableExtent y.	firstVisibleRow := self rowFrom: 144 to: 0.	nextVisibleRow := self rowFrom:  bottomBoundary to: 200.	self assert: firstVisibleRow first top = 0.	lastVisibleRow := firstVisibleRow last.	self assert: (144 between: lastVisibleRow top and: lastVisibleRow bottom).	self assert: (nextVisibleRow top between: 200 and: bottomBoundary).	self assert: nextVisibleRow last bottom &lt;= bottomBoundary.	"Case 1. The GridVisualRow to be joined ends before the receiver bottom border and the target boundary."	self rowTest: (self rowFrom: 144 to: 0) upTo: 0 joining: (self rowFrom: bottomBoundary to: 200).	"Case 2.  The GridVisualRow to be joined ends on the target boundary."	self rowTest: (self rowFrom: bottomBoundary to: 200) upTo: 144 joining: (self rowFrom: 0 to: 144).	"Case 2a. The GridVisualRow to be joined starts after the target boundary."	self rowTest: (self rowFrom: bottomBoundary to: 200) upTo: 144 joining: (self rowFrom: 0 to: 100).	"Case 2b. Same as above but start at the end of the receiver"	self rowTest: (self rowFrom: 200 to: bottomBoundary) upTo: 144 joining: (self rowFrom: 0 to: 100).	"Case 3. The GridVisualRow to be joined starts below and ends within the receiver below the target boundary."	self rowTest: (self rowFrom: bottomBoundary to: 100) upTo: 0 joining: (self rowFrom: 144 to: 0) .	"Case 4. The GridVisualRow to be joined starts within and ends after the receiver end and target boundary."	self rowTest: (self rowFrom: bottomBoundary to: 100) upTo: 60 joining: (self rowFrom: 200 to: 0).	"Identity tests"	row := self rowFrom: bottomBoundary to: 200.	self rowTest: row upTo: 0 joining: row last.	self rowTest: row upTo: 0 joining: row first.</body></methods><methods><class-id>GridVisualRowTest</class-id> <category>test accessing</category><body package="Grid SUnit Tests">testGridEnd	self 		assert: (self row: (GridVisualRow 						on: rows last						in: grid						index: rows size						top: nil						bottom: grid scrollableExtent y)				equivalentTo: firstVisibleRow gridEnd)</body><body package="Grid SUnit Tests">testGridOrigin	self 		assert: (self row: (GridVisualRow 						on: rows first						in: grid						index: 1						top: 0						bottom: nil)				equivalentTo: firstVisibleRow gridOrigin)</body><body package="Grid SUnit Tests">testJumpTo	"Test access for a GridVisualRow at a specific distance in and outside the visual range"	| lastVisibleRow topmostRow bottommostRow endRow startRow midRow |	lastVisibleRow := firstVisibleRow last.	"Try jumping within range"	firstVisibleRow withSuccessorsDo: 			[:each | | midpoint |			midpoint := self midpointOf: each.			self assert: (firstVisibleRow jumpTo: midpoint) = each.			self assert: (lastVisibleRow jumpTo: midpoint) = each.			self assert: (each jumpTo: (self midpointOf: firstVisibleRow )) = firstVisibleRow.			self assert: (each jumpTo:  (self midpointOf: lastVisibleRow )) = lastVisibleRow].	"Try jumping out of range"	rows := rows , rows.	rows keysAndValuesDo: [:i :each | each item: i].	grid rows: rows.	firstVisibleRow := firstVisibleRow atIndex: lastVisibleRow index // 2.	endRow := firstVisibleRow gridEnd.	startRow := firstVisibleRow gridOrigin.	firstVisibleRow severPredecessor severSuccessor.	self assert: (firstVisibleRow jumpTo: (self midpointOf: firstVisibleRow )) 				= firstVisibleRow.	"Start at midpoint jump to end"	bottommostRow := firstVisibleRow jumpTo: grid scrollableExtent y.	self assert: (self row: bottommostRow equivalentTo: endRow).	"Start at midpoint jump to start"	topmostRow := firstVisibleRow jumpTo: 0.	self assert: (self row: topmostRow equivalentTo: startRow).	"Start at end jump to midpoint"	midRow := endRow jumpTo: firstVisibleRow top.	self assert: (self row: midRow equivalentTo: firstVisibleRow).	"Start at end jump to start"	topmostRow := endRow jumpTo: 0.	self assert: (self row: topmostRow equivalentTo: startRow).</body><body package="Grid SUnit Tests">testJumpToIndex	"Test access for a GridVisualRow by index in and outside the visual range"	| lastVisibleRow bottomRow topRow endRow startRow midRow |	"Try jumping within range"	lastVisibleRow := firstVisibleRow last.	firstVisibleRow withSuccessorsDo: 			[:each | 			self assert: (firstVisibleRow jumpToIndex: each index) = each.			self assert: (lastVisibleRow jumpToIndex: each index) = each.			self assert: (each jumpToIndex: firstVisibleRow index) = firstVisibleRow.			self assert: (each jumpToIndex: lastVisibleRow index) = lastVisibleRow].	"Try jumping out of range"	rows := rows , rows.	rows keysAndValuesDo: [:i :each | each item: i].	grid rows: rows.	firstVisibleRow := firstVisibleRow atIndex: lastVisibleRow index // 2.	endRow := firstVisibleRow gridEnd.	startRow := firstVisibleRow gridOrigin.	firstVisibleRow severPredecessor severSuccessor.	self assert: (firstVisibleRow jumpToIndex: firstVisibleRow index) 				= firstVisibleRow.	"Start at midpoint jump to end"	bottomRow := firstVisibleRow jumpToIndex: rows size.	self assert: (self row: bottomRow equivalentTo: endRow).	"Start at midpoint jump to start"	topRow := firstVisibleRow jumpToIndex: 1.	self assert: (self row: topRow equivalentTo: startRow).	"Start at end jump to midpoint"	midRow := endRow jumpToIndex: firstVisibleRow index.	self assert: (self row: midRow equivalentTo: firstVisibleRow).	"Start at end jump to start"	topRow := endRow jumpToIndex: startRow index.	self assert: (self row: topRow equivalentTo: startRow)</body><body package="Grid SUnit Tests">testNearest	| lastVisibleRow |	lastVisibleRow := firstVisibleRow last.	firstVisibleRow withSuccessorsDo: 			[:each | 			self assert: (firstVisibleRow nearest: each top) 						= (each predecessor ifNil: [each]).			self assert: (firstVisibleRow nearest: each bottom) = each.			self assert: (lastVisibleRow nearest: each bottom) 						= (each successor ifNil: [each]).			self assert: (lastVisibleRow nearest: each top) = each].	self assert: (firstVisibleRow nearest: grid scrollableExtent y + 20) 				= firstVisibleRow last.	self assert: (firstVisibleRow nearest: -20) = firstVisibleRow.	self assert: (lastVisibleRow nearest: firstVisibleRow top) = firstVisibleRow.	self assert: (lastVisibleRow nearest: firstVisibleRow bottom) = firstVisibleRow successor.	self assert: (firstVisibleRow nearest: lastVisibleRow top) = lastVisibleRow predecessor.	self assert: (firstVisibleRow nearest: lastVisibleRow bottom) = lastVisibleRow.	self assert: (firstVisibleRow nearest: firstVisibleRow top) = firstVisibleRow.	self assert: (firstVisibleRow nearest: firstVisibleRow bottom) = firstVisibleRow.	self assert: (lastVisibleRow nearest: lastVisibleRow top) = lastVisibleRow.	self assert: (lastVisibleRow nearest: lastVisibleRow bottom) = lastVisibleRow.</body></methods><methods><class-id>GridVisualRowTest</class-id> <category>test testing</category><body package="Grid SUnit Tests">testIsFullyVisible</body></methods><methods><class-id>GridVisualRowTest</class-id> <category>test positioning and size</category><body package="Grid SUnit Tests">testHeight	| grid2 row2 firstVisibleRow2 |	grid2 := Grid new.	row2 := (GridRow new)				item: 1;				height: 100.	grid2 rows: (Array with: row2) 				, ((2 to: 20) collect: 							[:i | 							(GridRow new)								item: i;								height: 20]).	self assert: grid2 scrollableExtent y = (grid scrollableExtent y + 80).	firstVisibleRow2 := grid2 firstVisibleRow.	firstVisibleRow2 addSuccessorCount: 19.	self assert: firstVisibleRow top = firstVisibleRow2 top.	self deny: firstVisibleRow bottom = firstVisibleRow2 bottom.	firstVisibleRow successor withSuccessorsDo: 			[:each | 			| match |			match := firstVisibleRow2 atIndex: each index.			self deny: each top = match top.			self deny: each bottom = match bottom].	firstVisibleRow2 height: 20.	self assert: grid2 scrollableExtent y = grid scrollableExtent y.	firstVisibleRow withSuccessorsDo: 			[:each | 			| match |			match := firstVisibleRow2 atIndex: each index.			self assert: each top = match top.			self assert: each bottom = match bottom]</body><body package="Grid SUnit Tests">testMoveBottomSideTo</body><body package="Grid SUnit Tests">testMoveTopSideTo	| firstVisibleRow2 |	firstVisibleRow2 := GridVisualRow 				on: rows first				in: grid				index: 1				top: 10				bottom: nil.	firstVisibleRow2 addSuccessorCount: 19.	firstVisibleRow withSuccessorsDo: 			[:each | 	| match |			match := firstVisibleRow2 atIndex: each index.			self assert: each row = match row.			self assert: each index = match index.			self deny: each top = match top.			self deny: each bottom = match bottom].	firstVisibleRow moveTopSideTo: 10.	firstVisibleRow withSuccessorsDo: 			[:each | 	| match |			match := firstVisibleRow2 atIndex: each index.			self assert: each row = match row.			self assert: each index = match index.			self assert: each top = match top.			self assert: each bottom = match bottom]</body></methods><methods><class-id>GridVisualRowTest</class-id> <category>test removing</category><body package="Grid SUnit Tests">testRemove	| first newFirst lastIndex |	first := grid firstVisibleRow.	lastIndex := grid lastVisibleRow index.	first remove.	newFirst := grid firstVisibleRow.	self assert: newFirst index = 1.	self assert: lastIndex = grid lastVisibleRow index.	self assert: newFirst top = 0.	self assert: newFirst bottom = first bottom.</body></methods><methods><class-id>GridVisualRowTest</class-id> <category>test enumeration</category><body package="Grid SUnit Tests">testWithSuccessorsFromToDo	| indexes extent rowsSubset start end |	extent := grid scrollableExtent y.	"Case 1: Range above all rows"	indexes := OrderedCollection new.	firstVisibleRow 		withSuccessorsFrom: extent + 1		to: extent + 100		do: [:each | indexes add: each ].	self assert: indexes isEmpty.	"Case 2: Range starts within some rows but ends above all"	indexes := OrderedCollection new.	start := extent.	end := extent + 100.	firstVisibleRow 		withSuccessorsFrom: start		to: end		do: [:each | indexes add: each].	self assert: indexes = (OrderedCollection with: firstVisibleRow last).	indexes := OrderedCollection new.	rowsSubset := (firstVisibleRow atIndex: rows size - 2) successors.	start := rowsSubset first bottom.	firstVisibleRow 		withSuccessorsFrom: start		to: end		do: [:each | indexes add: each].	self assert: indexes asArray = rowsSubset.	"Case 3: Range starts and ends within linked list of visuals"	indexes := OrderedCollection new.	rowsSubset := rows copyFrom: 6 to: 13.	start := (firstVisibleRow atIndex: 6) bottom.	end := (firstVisibleRow atIndex: 13) top.	firstVisibleRow 		withSuccessorsFrom: start		to: end		do: [:each | indexes add: each row].	self assert: indexes asArray = rowsSubset.	"Case 4: Range starts below but ends within linked list of visuals"	indexes := OrderedCollection new.	rowsSubset := rows copyFrom: 6 to: 13.	start := -100.	end := firstVisibleRow bottom.	firstVisibleRow 		withSuccessorsFrom: start		to: end		do: [:each | indexes add: each].	self 		assert: indexes = (OrderedCollection with: firstVisibleRow						with: firstVisibleRow successor).	indexes := OrderedCollection new.	end := firstVisibleRow top.	firstVisibleRow 		withSuccessorsFrom: start		to: end		do: [:each | indexes add: each].	self assert: indexes = (OrderedCollection with: firstVisibleRow).	"Case 5: Range below all rows"	indexes := OrderedCollection new.	firstVisibleRow 		withSuccessorsFrom: -100		to: firstVisibleRow top - 1		do: [:each | indexes add: each index].	self assert: indexes isEmpty.	"Case 6: Range starts and ends within a single column"	indexes := OrderedCollection new.	firstVisibleRow 		withSuccessorsFrom: firstVisibleRow top + 1		to: firstVisibleRow bottom - 1		do: [:each | indexes add: each].	self assert: indexes = (OrderedCollection with: firstVisibleRow).	"Case 7: Reversed range"	indexes := OrderedCollection new.	firstVisibleRow 		withSuccessorsFrom: firstVisibleRow last top		to: firstVisibleRow bottom		do: [:each | indexes add: each].	self assert: indexes isEmpty.	"Case 8: Range exceeds all rows"	indexes := OrderedCollection new.	firstVisibleRow 		withSuccessorsFrom: -1		to: firstVisibleRow last bottom + 1		do: [:each | indexes add: each].	self assert: indexes = firstVisibleRow withSuccessors asOrderedCollection.</body></methods><methods><class-id>GridColumnSortConstraintTest</class-id> <category>test combining</category><body package="Grid SUnit Tests">testChildConstraint	| sortRank1 sortRank2 sortRank3 sortRank1a sortRank1b |	sortRank1 := column1 sortConstraint.	sortRank2 := column2 sortConstraint.	sortRank3 := column3 sortConstraint.	sortRank1a := sortRank1 childConstraint: sortRank2.	self assert: sortRank1a == sortRank1.	sortRank1b := sortRank1 				childConstraint: (sortRank2 childConstraint: sortRank3).	self assert: sortRank1b == sortRank1.	self assert: sortRank1b == (sortRank1a childConstraint: sortRank3)</body><body package="Grid SUnit Tests">testCombine	| sortRank1 sortRank2 sortRank3 sortRank1a sortRank1b |	sortRank1 := column1 sortConstraint.	sortRank2 := column2 sortConstraint.	sortRank3 := column3 sortConstraint.	sortRank1a := sortRank1 &amp; sortRank2.	self deny: sortRank1a == sortRank1.	sortRank1b := sortRank1 &amp; sortRank2 &amp; sortRank3.	self deny: sortRank1b == sortRank1.	self deny: sortRank1b == sortRank1a &amp; sortRank3.</body></methods><methods><class-id>GridColumnSortConstraintTest</class-id> <category>test multisort</category><body package="Grid SUnit Tests">testMultiSortAscend	| sortedList |	sortedList := listToSort copy.	column1 sortDirection: #ascending.	column2 sortDirection: #ascending.	column3 sortDirection: #ascending.	(SequenceableCollectionSorter on: sortedList		using: column1 sortConstraint &amp; column2 sortConstraint 				&amp; column3 sortConstraint) 			sort.	self assert: sortedList 				= (listToSort asSortedCollection: [:a :b | a printString &lt; b printString]) 						asOrderedCollection</body><body package="Grid SUnit Tests">testMultiSortDescend	| sortedList |	sortedList := listToSort copy.	column1 sortDirection: #descending.	column2 sortDirection: #descending.	column3 sortDirection: #descending.	(SequenceableCollectionSorter on: sortedList		using: column1 sortConstraint &amp; column2 sortConstraint 				&amp; column3 sortConstraint) 			sort.	self assert: sortedList 				= (listToSort asSortedCollection: [:a :b | a printString &gt; b printString]) 						asOrderedCollection</body></methods><methods><class-id>GridColumnSortConstraintTest</class-id> <category>test sorting</category><body package="Grid SUnit Tests">testNoSort	| sortedList |	sortedList := listToSort copy.	column1 sortDirection: nil.	(SequenceableCollectionSorter on: sortedList using: column1 sortConstraint) 		sort.	self assert: sortedList = listToSort</body><body package="Grid SUnit Tests">testSortAscend	| sortedList |	sortedList := listToSort copy.	column4 sortDirection: #ascending.	(SequenceableCollectionSorter on: sortedList using: column4 sortConstraint) 		sort.	self assert: sortedList = (listToSort asSortedCollection:[:a :b| a printString &lt; b printString]) asOrderedCollection</body><body package="Grid SUnit Tests">testSortDescend	| sortedList |	sortedList := listToSort copy.	column4 sortDirection: #descending.	(SequenceableCollectionSorter on: sortedList using: column4 sortConstraint) 		sort.	self assert: sortedList = (listToSort asSortedCollection:[:a :b| a printString &gt; b printString]) asOrderedCollection</body></methods><methods><class-id>GridColumnSortConstraintTest</class-id> <category>test accessing</category><body package="Grid SUnit Tests">testSortDirection	self assert: column1 sortDirection isNil.	column1 sortDirection: #ascending.	self assert: column1 sortDirection =  #ascending.	column1 sortDirection: #descending.	self assert: column1 sortDirection =  #descending.	column1 sortDirection: nil.	self assert: column1 sortDirection isNil.</body></methods><methods><class-id>GridColumnSortConstraintTest</class-id> <category>Running</category><body package="Grid SUnit Tests">setUp	| grid |	listToSort := OrderedCollection new.	SimpleDialog subclasses do: 			[:class | 			class instVarNames do: 					[:instName | 					1 to: 5 do: 							[:value | 							listToSort add: (SortItem 										name: class fullName										variable: instName										value: value)]]].	grid := Grid new.	grid builder source: ApplicationModel new.	column1 := (GridColumn spec: (InputFieldSpec new model: #'_row name') in: grid width: 20).	column2 := (GridColumn spec: (InputFieldSpec new model: #'_row variable') in: grid width: 20).	column3 := (GridColumn spec: (InputFieldSpec new model: #'_row value') in: grid width: 20).		column4 := (GridColumn spec: (InputFieldSpec new model: #'_row printString') in: grid width: 20).</body></methods><methods><class-id>EmptyGridApp</class-id> <category>aspects</category><body package="Grid SUnit Tests">gridInterface	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^gridInterface isNil		ifTrue:			[gridInterface := GridInterface new]		ifFalse:			[gridInterface]</body></methods><methods><class-id>SelectionInGridTest</class-id> <category>testing</category><body package="Grid SUnit Tests">testCellSelections	| selections gridSelections |	grid selectByCell: true.	self assert: grid selectByCell."Select all"	selectionInGrid selectAll.	selections := selectionInGrid selections.	gridSelections := Set new.	grid cellsDo:[:cell :value| gridSelections add: value].	self assert: gridSelections = selections."Select none"	selectionInGrid clearAll.	self assert: selectionInGrid selections isEmpty.	self assert: grid selectionRange isEmpty."Select 2 quadrants"	selectionInGrid selectionRange add: (1@1 corner: 10@10).	selectionInGrid selectionRange add: (10@10 corner: 20@20). 	selections := selectionInGrid selections.	grid cellsDo:[:cell :value|  | location |		location := cell cellPoint.		self deny: ((selectionInGrid selectionRange contains:[:any| (any expandedBy: (0 @ 0 corner: 1 @ 1)) containsPoint: location]) xor: (selections includes: value))]</body><body package="Grid SUnit Tests">testClearAll		selectionInGrid clearAll.	self assert: selectionInGrid selectionRange = grid selectionRange.	self assert: selectionInGrid selectionRange isEmpty.</body><body package="Grid SUnit Tests">testList	selectionInGrid list: rows.	self assert: selectionInGrid list = rows.	self assert: selectionInGrid listHolder value = rows.	self assert: grid rows = rows.</body><body package="Grid SUnit Tests">testListHolder	| listHolder oldListHolder |	listHolder := selectionInGrid listHolder.	self assert: (listHolder dependents includes: selectionInGrid).	self assert: grid model = listHolder.	oldListHolder := listHolder.	listHolder := rows asValue.	selectionInGrid listHolder: listHolder.	self deny: (oldListHolder dependents includes: selectionInGrid).	self assert: (listHolder dependents includes: selectionInGrid).</body><body package="Grid SUnit Tests">testRowSelections	| selections gridSelections |	grid selectByCell: false.	self deny: grid selectByCell."Select all"	selectionInGrid selectAll.	selections := selectionInGrid selections.	gridSelections := Set new.	grid rowsDo:[:cell :value| gridSelections add: value].	self assert: gridSelections = selections."Select none"	selectionInGrid clearAll.	self assert: selectionInGrid selections isEmpty.	self assert: grid selectionRange isEmpty."Select 1/2"	selectionInGrid selectionRange add: (1@1 corner: 10@10). 	selections := selectionInGrid selections.	grid rowsDo:[:row :value|  		self deny: ((selectionInGrid selectionRange contains:[:any| (any expandedBy: (0 @ 0 corner: 1 @ 1)) containsPoint: (any left @ row index)]) xor: (selections includes: value))]</body><body package="Grid SUnit Tests">testSelectAll		selectionInGrid selectAll.	self assert: selectionInGrid selectionRange = grid selectionRange.	self assert: selectionInGrid selectionRange = (Set with: grid cellBounds).</body><body package="Grid SUnit Tests">testSelectionCellsDo	| selections gridSelections |	"Select all"	selectionInGrid selectAll.	selections := Set new.	gridSelections := Set new.	selectionInGrid selectionCellsDo: [:cell :value | selections add: value].	grid cellsDo: [:cell :value | gridSelections add: value].	self assert: gridSelections = selections.	"Select none"	selectionInGrid clearAll.	selections := Set new.	selectionInGrid selectionCellsDo: [:cell :value | selections add: value].	self assert: selections isEmpty.	self assert: grid selectionRange isEmpty.	"Select 2 quadrants"	selectionInGrid selectionRange add: (1 @ 1 corner: 10 @ 10).	selectionInGrid selectionRange add: (10 @ 10 corner: 20 @ 20).	selections := Set new.	selectionInGrid selectionCellsDo: [:cell :value | selections add: value].	grid cellsDo: 			[:cell :value |			| location |			location := cell cellPoint.			self				deny: ((selectionInGrid selectionRange						contains: [:any | (any expandedBy: (0 @ 0 corner: 1 @ 1)) containsPoint: location])							xor: (selections includes: value))]</body><body package="Grid SUnit Tests">testSelectionRange	| allRange |	selectionInGrid list: rows.	selectionInGrid selectAll.	allRange := Set with: grid cellBounds.	self assert: selectionInGrid selectionRange = allRange.	self assert: grid selectionRange = allRange.	selectionInGrid clearAll.	self assert: selectionInGrid selectionRange isEmpty.	self assert: grid selectionRange isEmpty.</body><body package="Grid SUnit Tests">testSelectionRangeHolder	| rangeRider oldRangeRider |	rangeRider := selectionInGrid selectionRangeHolder.	self assert: (rangeRider dependents includes: selectionInGrid).	self assert: grid selectionChannel = rangeRider.	oldRangeRider := rangeRider.	rangeRider := rows asValue.	selectionInGrid selectionRangeHolder: rangeRider.	self deny: (oldRangeRider dependents includes: selectionInGrid).	self assert: (rangeRider dependents includes: selectionInGrid).</body><body package="Grid SUnit Tests">testSelectionRowsDo	"Select all"	| selections gridSelections |	selectionInGrid selectAll.	selections := Set new.	gridSelections := Set new.	selectionInGrid selectionRowsDo: [:row :value | selections add: value].	grid rowsDo: [:row :value | gridSelections add: value].	self assert: gridSelections = selections.	"Select none"	selectionInGrid clearAll.	selections := Set new.	selectionInGrid selectionRowsDo: [:cell :value | selections add: value].	self assert: selections isEmpty.	self assert: grid selectionRange isEmpty.	"Select 2 quadrants"	selectionInGrid selectionRange add: (1 @ 1 corner: 10 @ 10).	selectionInGrid selectionRange add: (10 @ 10 corner: 20 @ 20).	selections := Set new.	selectionInGrid selectionRowsDo: [:row :value | selections add: value].	grid rowsDo: 			[:row :value |			self				deny: ((selectionInGrid selectionRange						contains: [:any | (any expandedBy: (0 @ 0 corner: 1 @ 1)) containsPoint: any left @ row index])							xor: (selections includes: value))]</body><body package="Grid SUnit Tests">testSelections</body><body package="Grid SUnit Tests">testSetListSelecting	self notYetImplemented</body></methods><methods><class-id>SelectionInGridTest</class-id> <category>Running</category><body package="Grid SUnit Tests">setUp		| numColumns numRows entries |	grid := Grid new.	selectionInGrid := SelectionInGrid new.	grid selectionInGrid: selectionInGrid.	numRows := 20.	numColumns := 20.	entries := (1 to: numRows)		collect: [:y | (1 to: numColumns) collect: [:x | x @ y ]].	1 to: numColumns		do: 			[:i |			GridColumn				spec: (self columnInputSpecIndexedBy: i)				in: grid				width: 20].	rows := entries asList collect:[:item| GridRow on: item to: grid].</body><body package="Grid SUnit Tests">tearDown	super tearDown.	rows := 	grid := selectionInGrid :=nil.</body></methods><methods><class-id>SelectionInGridTest</class-id> <category>private</category><body package="Grid SUnit Tests">columnInputSpecIndexedBy: anInteger	^InputFieldSpec new 		name: anInteger;		model: ('_row ', anInteger printString) asSymbol;		type: #object;		yourself</body></methods><methods><class-id>EmptyViewApp</class-id> <category>aspects</category><body package="Grid SUnit Tests">grid		^grid		ifNil:			[self grid: Grid new.			grid]</body><body package="Grid SUnit Tests">grid: aGrid	grid := aGrid.	aGrid builder source: self.</body></methods><methods><class-id>EmptyViewApp class</class-id> <category>instance creation</category><body package="Grid SUnit Tests">openWith: aGrid 	^(self new)		grid: aGrid;		open</body></methods><methods><class-id>EmptyGridApp class</class-id> <category>interface specs</category><body package="Grid SUnit Tests">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Unlabeled Canvas' 			#bounds: #(#{Graphics.Rectangle} 540 395 740 595 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.GridSpec} 					#properties: #(#{UI.PropertyListDictionary} #rowSize 25 #showHorizontalLines false #allowColumnResizing true #allowColumnReordering false #showVerticalLines false ) 					#layout: #(#{Graphics.LayoutFrame} 5 0 5 0 -5 1 -5 1 ) 					#name: #Grid1 					#model: #gridInterface 					#allowRowResizing: true 					#selectByCell: false ) ) ) )</body></methods><methods><class-id>EmptyViewApp class</class-id> <category>interface specs</category><body package="Grid SUnit Tests">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Grid Test Window' 			#min: #(#{Core.Point} 20 20 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 640 512 887 755 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 12 0 12 0 -12 1 -12 1 ) 					#name: #grid					#flags: 11 					#component: #grid ) ) ) )</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>TestCase</name><environment>XProgramming.SUnit</environment><super>XProgramming.SUnit.TestAsserter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnit</package></attributes></class></st-source>