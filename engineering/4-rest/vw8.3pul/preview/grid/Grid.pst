<?xml version="1.0"?><st-source><!-- Name: GridNotice: Copyright 1999-2013 Cincom Systems, Inc.  All rights reserved.Comment: Similar to a DataSetView, a Grid widget uses a sequencable list as a base collection of elements and displays content upon each item in columns.  It allows for dynamic editing of this content.DbIdentifier: bear73DbTrace: 400315DbUsername: nrossDbVersion: 7.10 - 1PackageName: GridParcel: #('Grid')PrintStringCache: (7.10 - 1,nross)Version: 7.10 - 1Date: 6:45:44 AM April 3, 2013 --><time-stamp>From VisualWorksÂ®, Pre-Release 7.10 (mar13.5) of April 3, 2013 on April 3, 2013 at 6:45:44 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>GridColumnDraggingTracker</name><environment>UI</environment><super>UI.ColumnDraggingTracker</super><private>false</private><indexed-type>none</indexed-type><inst-vars>allowDrop </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Events-Trackers</category><attributes><package>Grid</package></attributes></class><comment><class-id>UI.GridColumnDraggingTracker</class-id><body>The GridColumnDraggingTracker is used exclusively by the Grid. If the user clicks *on* a column button label (vs between labels) this tracker comes into play. If the user didn't move the mouse more than 2 pixels, then the click is seen as not dragging, and the sort column behavior is called (in the finishSelection: method). If the user does move the mouse, then enter drag mode.  In drag mode, send #allowColumnMoveFrom:toIndex: to the Grid application to query if a drop is permitted from the source column index to the column index the mouse is dragged to.  If the application does not forbid the drop on a target column then swap the source and target columns.Instance Variables:	allowDrop	&lt;Boolean&gt;	if true, permit a swap between the source and drop target columns. </body></comment><class><name>Grid</name><environment>UI</environment><super>UI.CompositeView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>scrollableExtent columns rows selectionChannel firstVisibleColumn firstVisibleRow builder scrollOffset gridLineColor showRowLines showColumnLines allowSorting allowColumnResizing allowRowResizing allowColumnReordering verticalPolicy horizontalPolicy selectByCell state defaultRowHeight targetIndex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Grids</category><attributes><package>Grid</package></attributes></class><comment><class-id>UI.Grid</class-id><body>Similar to a DataSetView, a Grid widget uses a sequencable list as a base collection of elements and displays content upon each item in columns.  It allows for dynamic editing of this content.All GridRow instances in a Grid's rows should be unique.  Never use a GridRow instance more than once in 'rows' or for more than one Grid.  Copy or create a new GridRow instance for whatever item it represents.Instance Variables	columns	&lt;List of: GridColumn&gt;	Collection of GridColumn instances for the Grid.	rows	&lt;List of: GridRow&gt;	List of GridRow instances as derived from the model.  	firstVisibleColumn	&lt;GridVisualColumn | nil&gt;	Leftmost column visible in the Grid.	firstVisibleRow	&lt;GridVisualRow | nil&gt;	Topmost row visible in the Grid.	selections	&lt;Set of: Rectangle&gt;	Areas selected in the receiver.	scrollableExtent	&lt;Point&gt;		Maximum scroll extent to view last column and row.	builder		&lt;UIBuilder&gt;		Builder for widgets appearing in cells.	scrollOffset	&lt;ScrollValueHolder&gt;		Contains the current scrolling offset and the current scroll grid	showRowLines	&lt;Boolean&gt;	(Default = true)  If true, display a dividing line between rows.	showColumnLines &lt;Boolean&gt; (Default = true)  If true, display a dividing line between columns.	defaultRowHeight	&lt;Integer | nil&gt; 	Default height for rows added without specified height.	allowSorting &lt;Boolean&gt;  (Default = true)  If true, allow column sorting.	allowColumnResizing &lt;Boolean&gt; (Default = true)  If true, allow columns may be resized by dragging.	allowRowResizing &lt;Boolean&gt; (Default = true)  If true, allow rows may be resized by dragging.	allowColumnReordering	&lt;Boolean&gt;	(Default = true)  If true, allow column reordering.	verticalPolicy &lt;Symbol&gt;	The vertical policy to use for tabbing through a DataSetView.  It should be one of: #(#none #wrap #noWrap).  #none - disables the Shift-&lt;upArrow | downArrow&gt;.  #wrap - if the top or bottom most indicies are exceeded, wrap to the other extreme.  #noWrap - do not allow the limits to be exceeded.	horizontalPolicy &lt;Symbol&gt;	The horizontal policy to use for tabbing through a DataSetView.  It should be one of: #(#none #wrapNext #wrapSame #noWrap).  #none - tab will not tab to the next index of a DataSetView, but the next field on the canvas.  #wrapNext - when the left or right most indicies are exceeded, move to the next/previous row (dependent upon tab or backTab). #wrapSame - When a left or right index is exceeded, wrap around on the same row. #noWrap - do not allow the right and left limits to be exceeded.	exitPolicy &lt;Symbol&gt;  Navigation method upon &lt;Tab&gt; keypress in the first/last grid cell.  Choices include #exitPane (default) and #stop.	targetIndex	&lt;Integer | Fraction | nil&gt; The index of the row with the traversal highlight when visible, otherwise nil.  When the view is a target of a drop, the value may an integer for a drop over an element or a fraction for a drop insertion between rows.  For a drop insertion the value represents the midpoint between the two elements by the sum of their indicies divided by 2.  </body></comment><class><name>GridColumn</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>grid width label defaultHeight showColumnLine allowResizing allowSorting sortConstraint id spec </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Grids</category><attributes><package>Grid</package></attributes></class><comment><class-id>UI.GridColumn</class-id><body>GridColumn defines the properties of column appearing in a Grid as well as what widget the Grid will build within its cells and its model.Instance Variables	grid 	&lt;Grid&gt;	Grid containing this instance.	defaultHeight	&lt;Number&gt;	The initial minimum estimated height for the column's display pane. The actual height adopted may be larger since the grid chooses the larger of all its column heights as its initial height.	width	&lt;Number&gt;	The current column width. 	showColumnLine	&lt;Boolean&gt;	If true, display a line to the RIGHT of the column.	allowResizing	&lt;Boolean&gt;	If true, allow column resizing.	allowSorting		&lt;Boolean&gt; If true, allow the user to sort rows by this column in the direction determined by sortDirection. 	sortConstraint &lt;GridColumnSortConstraint | nil&gt;  Rule used to sort my rows.	spec	&lt;NamedSpec&gt;	UISpecification used to build widget appearing in cell.	id		&lt;Symbol | nil&gt;	 Optional unique identifier for this column.	</body></comment><class><name>GridHeaderColumn</name><environment>UI</environment><super>UI.GridColumn</super><private>false</private><indexed-type>none</indexed-type><inst-vars>lineNumbers offset gridBody </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Grids</category><attributes><package>Grid</package></attributes></class><comment><class-id>UI.GridHeaderColumn</class-id><body>GridHeaderColumn defines a column of GridRowHeaderViews that label each Grid row. A GridHeaderColumn is typically added as a leftmost column that will caption each row with a line number.  Selecting a GridRowHeaderView button toggles selection of its row in the Grid.Instance Variables	lineNumbers	&lt;Boolean&gt;	(Default = false)  If true, show the row line number.	offset	&lt;Integer&gt;	(Default = 0) Apply this offset to the actual row line index to obtain the number shown as line number when lineNumbers is true.</body></comment><class><name>GridColumnHeaderAgent</name><environment>UI</environment><super>UI.ColumnResizeAgent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>buttonController </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Datasets</category><attributes><package>Grid</package></attributes></class><comment><class-id>UI.GridColumnHeaderAgent</class-id><body>GridColumnHeaderAgent is used to handle column sorting or resize by interaction to its header.  When the GridController sees that a gesture for column resize has been made, an instance of this class is created and handed control.Instance Variables:	buttonController	&lt;GridColumnHeaderController&gt;	controller to handle sorting for header button presses</body></comment><class><name>GridColumnHeaderView</name><environment>UI</environment><super>UI.LabeledButtonView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>ascendingImage descendingImage </class-inst-vars><imports></imports><category>UIBasics-Grids</category><attributes><package>Grid</package></attributes></class><comment><class-id>UI.GridColumnHeaderView</class-id><body>GridColumnHeaderView is an abstract superclass for column header button views that appear in a GridHeaderRow to caption each column in a Grid.  Each GridColumnHeaderView has a Label and a TextStyle or other Visual for displaying a label and a button that if enabled sorts Grid rows by its column's contents.  Concrete subclasses will display the label and background for specific UILooks.</body></comment><class><name>MacOSXGridColumnHeaderView</name><environment>UI</environment><super>UI.GridColumnHeaderView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Grids</category><attributes><package>Grid</package></attributes></class><class><name>SelectionInGrid</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>listHolder selectionRangeHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Grid</package></attributes></class><comment><class-id>UI.SelectionInGrid</class-id><body>A SelectionInGrid supports a Grid widget, holding its collection of rows as well as keeping track of which range of its cells are selected.  For the Grid, a selection range is a Rectangle that defines the origin and extent of a selection by row and column inidicies.  The Grid widget itself determines whether multiple or single selections by cells or rows may be made.Instance Variables	listHolder	&lt;ValueModel with: List&gt;  List of GridRows 	selectionRangeHolder	&lt;ValueModel with: Set&gt;	Selection ranges (rectangles) in Grid</body></comment><class><name>GridController</name><environment>UI</environment><super>UI.DataSetController</super><private>false</private><indexed-type>none</indexed-type><inst-vars>targetPoint sweepOrigin multiSelect selectedCell </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Grids</category><attributes><package>Grid</package></attributes></class><comment><class-id>UI.GridController</class-id><body>A GridController manages mouse and keyboard interaction to columns and rows of a Grid as well as determines Grid selection mode, scrolling, drag-drop, and callback behavior.  Instance Variables:	multiSelect	&lt;Boolean&gt;	If true, multiple items may be selected in the Grid (Default = false).	sweepOrigin	&lt;Point | nil&gt;	The cell origin of a sweep selection.	targetPoint	&lt;Point | nil&gt;	The current cell position for a target selection.</body></comment><class><name>GridRowHeaderSpec</name><environment>UI</environment><super>UI.ButtonSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Specifications</category><attributes><package>Grid</package></attributes></class><comment><class-id>UI.GridRowHeaderSpec</class-id><body>GridRowHeaderSpec describes a component that is an instance of a GridRowHeader.  No additional properties are added beyond those already inherited from ButtonSpec.  The view's button model will toggle selection of a Grid row.</body></comment><class><name>GridRow</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>height grid item </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Grids</category><attributes><package>Grid</package></attributes></class><comment><class-id>UI.GridRow</class-id><body>GridRow represents row items in a Grid.  A GridRow instance may be contained by only one (or none) Grid instance at a time.  Instance Variables	grid 	&lt;Grid | nil&gt;	Grid containing this instance, if any.	item	&lt;Object&gt;	Item for this grid row.	height	&lt;Integer&gt;	The current display height of this row.</body></comment><class><name>GridHeaderRow</name><environment>UI</environment><super>UI.GridRow</super><private>false</private><indexed-type>none</indexed-type><inst-vars>constraintColumns sortSize gridBody </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Grids</category><attributes><package>Grid</package></attributes></class><comment><class-id>UI.GridHeaderRow</class-id><body>GridHeaderRow defnes a row of GridColumnHeaderViews that label each Grid column.  A GridHeaderRow normally appears as the topmost row of a Grid to caption columns.  Buttons in each column optionally sort Grid rows by content based on a GridColumn sort constraint. When GridColumns allow sorting, the GridHeaderRow sortSize defines the number of columns that may be added to participate in a row sort all at once.Instance Variables	constraintColumns	&lt;(Collection of: GridColumn)&gt;	Collection of GridColumns whose sort constraint is used to sort rows within the Grid the receiver appears in.  If the collection contains more than one column, the first column has highest sort priority, the next has second priority, ... etc., until the final column which has lowest sort priority.	sortSize	&lt;Integer&gt;	The maximum number,  0 or greater, of columns that may be added for sorting to constraintColumns.	gridBody	&lt;Grid | nil&gt;	Grid to sort rows of, if different from Grid to display receiver.</body></comment><class><name>GridColumnHeaderController</name><environment>UI</environment><super>UI.RadioButtonController</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Grids</category><attributes><package>Grid</package></attributes></class><comment><class-id>UI.GridColumnHeaderController</class-id><body>GridColumnHeaderController handles Grid column header interaction to begin a drag or perform the column sort action.</body></comment><class><name>GridVisualSegment</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>prior next index cells grid </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Grids</category><attributes><package>Grid</package></attributes></class><comment><class-id>UI.GridVisualSegment</class-id><body>GridVisualSegment is an abstract class containing behavior that manages a linked list of segments (e.g. rows or columns) of cells currently visible in a Grid.   A GridVisualSegment must be released whenever it leaves visual scope of a Grid.Subclasses must implement the following messages:	private		checkCells		createCellsInstance Variables:	cells	&lt;(Collection of: GridVisualCell)&gt;	cells visible in the grid for this segment.	index	&lt;Integer&gt;	grid index of segment	next	&lt;GridVisualSegment | nil&gt;	successor segment visible in grid, if any.	prior	&lt;GridVisualSegment | nil&gt;	predecessor segment visible in grid, if any.	grid		&lt;Grid&gt;	Grid this instance appears in.</body></comment><class><name>GridVisualRow</name><environment>UI</environment><super>UI.GridVisualSegment</super><private>false</private><indexed-type>none</indexed-type><inst-vars>top bottom row </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Grids</category><attributes><package>Grid</package></attributes></class><comment><class-id>UI.GridVisualRow</class-id><body>GridVisualRow represents the position and content of a single row currently visible in a Grid.  It has access to adjacent rows visible in the Grid, if any, and may create a new one as needed.Instance Variables:	row	&lt;Row&gt;	 grid row	top	&lt;Integer&gt;	top margin in pixels	bottom	&lt;Integer&gt;	bottom margin in pixels</body></comment><class><name>GridTracker</name><environment>UI</environment><super>UI.SelectionTracker</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cleared </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Grids</category><attributes><package>Grid</package></attributes></class><comment><class-id>UI.GridTracker</class-id><body>The GridTracker processes events on behalf of a GridController between the time the user presses a mouse button and releases it.Instance Variables	cleared	&lt;Boolean&gt;		private--flag to invalidate selection</body></comment><class><name>GridColumnHeaderSpec</name><environment>UI</environment><super>UI.ButtonSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Specifications</category><attributes><package>Grid</package></attributes></class><comment><class-id>UI.GridColumnHeaderSpec</class-id><body>GridColumnHeaderSpec describes a component that is an instance of a GridColumnHeader.  No additional properties are added beyond those already inherited from ButtonSpec.  The view's model will receive the sortDirection symbol (#ascending | #descending | nil) from the column to determine the direction to sort the column contents, if not nil.</body></comment><class><name>Win95GridColumnHeaderView</name><environment>UI</environment><super>UI.GridColumnHeaderView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Grids</category><attributes><package>Grid</package></attributes></class><class><name>GridVisualColumn</name><environment>UI</environment><super>UI.GridVisualSegment</super><private>false</private><indexed-type>none</indexed-type><inst-vars>left right column </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Grids</category><attributes><package>Grid</package></attributes></class><comment><class-id>UI.GridVisualColumn</class-id><body>GridVisualColumn represents the position and content of a single column currently visible in a Grid.  It has access to  adjacent columns visible in the Grid, if any, and may create a new one as needed.Instance Variables:	column	&lt;Column | RowHeaderColumn&gt;	grid column	left	&lt;Integer&gt;	left margin in pixels from grid scroll origin	right	&lt;Integer&gt;	right margin in pixels from grid scroll origin</body></comment><class><name>GridColumnResizeAgent</name><environment>UI</environment><super>UI.ColumnResizeAgent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selectedColumn </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Grids</category><attributes><package>Grid</package></attributes></class><comment><class-id>UI.GridColumnResizeAgent</class-id><body>GridColumnResizeAgent handles interactive resizing of a Grid column width.  When the GridController sees that a gesture for resizing the column has been made, an instance of this class is created and handed control.Instance Variables:	selectedColumn	&lt;GridVisualColumn&gt;	Visible column selected for resize.</body></comment><class><name>GridRowResizeTracker</name><environment>UI</environment><super>UI.SelectionTracker</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Grids</category><attributes><package>Grid</package></attributes></class><comment><class-id>UI.GridRowResizeTracker</class-id><body>GridRowResizeTracker is used by the Grid for interactive resize of a GridRow. If the user clicks on the bottom border of a row this tracker comes into play along with its GridRowResizeAgent to resize row height by dragging..</body></comment><class><name>MacGridColumnHeaderView</name><environment>UI</environment><super>UI.GridColumnHeaderView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Grids</category><attributes><package>Grid</package></attributes></class><class><name>GridIcons</name><environment>UI</environment><super>AlphaBlendedIcons</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Grid</package></attributes></class><class><name>GridRowHeaderView</name><environment>UI</environment><super>UI.LabeledButtonView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>rowSelectionImage </class-inst-vars><imports></imports><category>UIBasics-Grids</category><attributes><package>Grid</package></attributes></class><comment><class-id>UI.GridRowHeaderView</class-id><body>GridRowHeaderView is a generic class for Grid row header button views that appear in a GridHeaderColumn to caption each row in a Grid.  Each GridRowHeaderView has a Label and a TextStyle or other Visual for displaying a label and a button which when selected toggles selection of its row in a Grid. Concrete subclasses, if any, will display the label and background in specific ways.</body></comment><class><name>MotifGridColumnHeaderView</name><environment>UI</environment><super>UI.GridColumnHeaderView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Grids</category><attributes><package>Grid</package></attributes></class><class><name>GridColumnSortConstraint</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>childConstraint columnAdaptor printAdaptor sortDirection </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Grids</category><attributes><package>Grid</package></attributes></class><comment><class-id>UI.GridColumnSortConstraint</class-id><body>GridColumnSortConstraint defines a rule used to sort rows in a Grid according to a GridColumn aspect.  It may act as a direct substitute for the sortBlock definition of a SortedCollection.  A GridColumnSortConstraint may use a child GridColumnSortConstraint instance to define a secondary sort constraint in case two elements tie for position.  In this matter, secondary, tertiary, etc. constraints may be combined for multiple column sorting.Instance Variables	childConstraint	&lt;BlockClosure | GridColumnSortConstraint | MessageChannel | nil&gt;	Additional sort constraint to satisfy, if any.	columnAdaptor	&lt;ValueModel&gt;	Adaptor used to obtain the cell value for a GridColumn given a Grid Row. 	printAdaptor	&lt;BlockClosure&gt;		Adaptor used to obtain a sortable value from a cell in a GridColumn.  This is typically the same conversion necessary to obtain a cell printable value. 	sortDirection &lt;#ascending | #descending | nil&gt; Direction to sort grid rows starting from the column top. If nil, rows will not be sorted.</body></comment><class><name>GridHilightRow</name><environment>UI</environment><super>UI.GridRow</super><private>false</private><indexed-type>none</indexed-type><inst-vars>alternateBackgroundColor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Grids</category><attributes><package>Grid</package></attributes></class><comment><class-id>UI.GridHilightRow</class-id><body>GridHilightRow adds behavior to a GridRow to enhance readability of a Grid rows by highlighting the background of alternate odd numbered rows.Instance Variables:	alternateBackgroundColor	&lt;ColorValue | nil&gt;	Color to be used to highlight alternate Grid rows.</body></comment><class><name>GridColumnDraggingAgent</name><environment>UI</environment><super>UI.ColumnResizeAgent</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Datasets</category><attributes><package>Grid</package></attributes></class><comment><class-id>UI.GridColumnDraggingAgent</class-id><body>GridColumnDraggingAgent is used by the Grid to handle the dragging of columns, and the clicking of the labels for sorting.  When the GridController sees that a gesture for dragging the column has been made, an instance of this class is created and handed control. </body></comment><class><name>GridCell</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>row column </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Grids</category><attributes><package>Grid</package></attributes></class><comment><class-id>UI.GridCell</class-id><body>A GridCell is a convenience accessor for the row, column, and coordinates of a cell in a Grid. It typically is used as a handle to a Grid selection.  A GridCell also has a convenience #value method, that retrieves the current value for the cell in question.Instance Variables:	column	&lt;GridColumn&gt;	Column containing the Grid cell represented.	row	&lt;GridRow&gt;	Row containing the Grid cell represented.</body></comment><class><name>GridInterface</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>defaultRowHeight defaultColumnWidth selectionInGrid grid items headerRow headerColumn </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Collections</category><attributes><package>Grid</package></attributes></class><comment><class-id>UI.GridInterface</class-id><body>GridInterface is an central access and control object for the Grid and its selection model.  Set the items of a GridInterface to create the rows with default properties for a Grid or obtain items from rows. Likewise, adding, removing, or modifying a GridInterface item will update the corresponding Grid row. Much of the GridInterface functionality requires an operating Grid instance.Instance Variables	defaultRowHeight	&lt;Integer | nil&gt;	create grid rows with this initial height in pixels.	defaultColumnWidth	&lt;Integer | nil&gt;	create grid columns with this initial width in pixels.	headerRow &lt;GridHeaderRow | nil&gt;	Topmost non-vertically scrolling row, if any, that labels columns.	headerColumn &lt;GridHeaderColumn | nil&gt;	Leftmost non-horizontally scrolling column, if any, that labels rows.	grid		&lt;Grid&gt;	grid view this instance accesses and modifies.	items	&lt;List&gt;	items adapted for each row of data in the grid.	selectionInGrid	&lt;SelectionInGrid&gt;	selection model for grid.</body></comment><class><name>GridSpec</name><environment>UI</environment><super>UI.DataSetSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>headerColumn headerRow allowRowResizing selectByCell </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Specifications</category><attributes><package>Grid</package></attributes></class><comment><class-id>UI.GridSpec</class-id><body>GridSpec is a specialization of UISpecification used to recreate/store a Grid instance from/to its literal property specification.Instance Variables	headerColumn	&lt;GridHeaderColumn | nil&gt;	Topmost non-vertically scrolling row that labels columns, if any.	headerRow		&lt;GridHeaderRow | nil&gt;	Leftmost non-horizontally scrolling column that labels rows, if any.	allowRowResizing	&lt;Boolean&gt;	If true, rows may be resized interactively if each row permits (Default = true).	selectByCell	&lt;Boolean&gt;	If true, allow interactive selection by cell.  If false, (default) select whole rows only.</body></comment><class><name>GridVisualCell</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>component visualRow visualColumn cellBindingKey backgroundColor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Grids</category><attributes><package>Grid</package></attributes></class><comment><class-id>UI.GridVisualCell</class-id><body>GridVisualCell displays the content of a grid cell for the row and column it appears in.Instance Variables:	visualColumn	&lt;GridVisualColumn&gt;	containing grid column	visualRow		&lt;GridVisualRow&gt;		containing grid row	component	&lt;VisualComponent&gt;		pane containing content of cell	cellBindingKey	&lt;Symbol&gt;		the model of the component is identified by this binding name to the grid's builder.	backgroundColor 	&lt;Paint | nil&gt;		background color of cell to restore after showing selection highlighting.</body></comment><class><name>GridHeaderBorder</name><environment>UI</environment><super>UI.BeveledBorder</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Grid</package></attributes></class><class><name>WinXPGridColumnHeaderView</name><environment>UI</environment><super>UI.Win95GridColumnHeaderView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>flyingOver </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Grids</category><attributes><package>Grid</package></attributes></class><class><name>GridDecorator</name><environment>UI</environment><super>UI.BorderDecorator</super><private>false</private><indexed-type>none</indexed-type><inst-vars>headerRowComponent headerColumnComponent borderHeaderRow borderHeaderColumn gridInterface </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Grid</category><attributes><package>Grid</package></attributes></class><comment><class-id>UI.GridDecorator</class-id><body>A GridDecorator implements the artwork associated with showing a Grid together with its column and row headers.  It is also responsible for fielding updates from the GridInterface and updating its components.Instance Variables	borderHeaderColumn	&lt;Boolean&gt;	whether header column should have a border	borderHeaderRow	&lt;Boolean&gt;	whether the header row should have a border	gridInterface	&lt;GridInterface&gt;	the GridInterface 	headerColumnComponent	&lt;SlaveScrollWrapper&gt;	 the scroll wrapper for vertical header for grid rows.	headerRowComponent	&lt;SlaveScrollWrapper&gt;	the scroll wrapper for the horizontal header for grid columns.</body></comment><class><name>GridRowResizeAgent</name><environment>UI</environment><super>UI.ColumnResizeAgent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selectedRow </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Grids</category><attributes><package>Grid</package></attributes></class><comment><class-id>UI.GridRowResizeAgent</class-id><body>GridRowResizeAgent is used to handle the interactive resizing of a row.  When the GridController sees that a gesture for resizing a row has been made, an instance of this class is created and handed control.Instance Variables	selectedRow	&lt;GridVisualRow&gt;	Row being resized.</body></comment><methods><class-id>UI.GridColumnDraggingTracker</class-id> <category>sorting</category><body package="Grid">finishSelectionForSortingAt: aPoint	self controller selectUpAt: aPoint.</body></methods><methods><class-id>UI.GridColumnDraggingTracker</class-id> <category>private</category><body package="Grid">displayFrom: buffer at: displayPoint copyFrom: visualComponentZeroedBounds using: mergedDisplayBounds	backingStore		copyArea: visualComponentZeroedBounds		from: buffer		sourceOffset: displayPoint		destinationOffset: 0 @ 0.	labelPixmap displayOn: buffer at: displayPoint.	allowDrop		ifFalse: 			[| noEntry |			noEntry := self class noEntry.			noEntry displayOn: buffer				at: (displayPoint + dragDisplayOffset - noEntry extent max: displayPoint)].	graphicsContext		copyArea: mergedDisplayBounds		from: buffer		sourceOffset: 0 @ 0		destinationOffset: 0 @ 0</body></methods><methods><class-id>UI.GridColumnDraggingTracker</class-id> <category>events</category><body package="Grid">redButtonPressedEvent: anEvent	startingPoint := self cursorPointFor: anEvent.	(self view firstVisibleColumn atPosition: startingPoint x)		ifNotNil: [:column | originalColumnIndex := column index].	allowDrop := true.	savedEvent := anEvent.	self setUpFor: anEvent.	anEvent isBlue 	ifFalse: [self trackSelectionFor: (self cursorPointFor: anEvent)].	anEvent initiator grabMouseEventFor: self.	^nil</body><body package="Grid">trackSelectionFor: aPoint	self view allowColumnReordering ifFalse: [^self].	originalColumnIndex ifNil: [^self].	(aPoint dist: startingPoint) &lt; 2 ifTrue: [^self].	attemptDragging := true.	startedDragging ifFalse: [self setupForDraggingIndex: originalColumnIndex at: aPoint].	self dragColumnTo: aPoint</body></methods><methods><class-id>UI.GridColumnDraggingTracker</class-id> <category>dragging</category><body package="Grid">dragColumnTo: aPoint	| visualComponentBounds displayPoint visualComponentZeroedBounds mergedDisplayBounds buffer dragIndex |	visualComponentBounds := visual bounds.	displayPoint := aPoint - dragDisplayOffset.	visualComponentZeroedBounds := 0 @ 0 extent: visualComponentBounds extent.	mergedDisplayBounds := self mergeComponentBounds: visualComponentBounds at: displayPoint.	buffer := (Pixmap extent: mergedDisplayBounds extent) graphicsContext.	self gatherOnto: buffer from: visualComponentZeroedBounds and: mergedDisplayBounds.	(self position: aPoint outside: visualComponentBounds) 		ifTrue: [allowDrop := false. 			    ^self restoreBackground].	dragIndex := (self view firstVisibleColumn atPosition: aPoint x) ifNotNil: [:column | column index].	dragIndex = columnIndex		ifFalse: 			[columnIndex := dragIndex.			allowDrop := self gridBody allowColumnMoveFrom: originalColumnIndex toIndex: columnIndex].	self		displayFrom: buffer		at: displayPoint		copyFrom: visualComponentZeroedBounds		using: mergedDisplayBounds.	previousPoint := displayPoint</body><body package="Grid">finishSelectionForDraggingAt: aPoint	self restoreBackground.	columnIndex isNil ifTrue: [^self].	(allowDrop and: [columnIndex ~= originalColumnIndex])		ifTrue: 			[self view moveColumnIndex: originalColumnIndex toIndex: columnIndex.			self view changed: #columnMove				with: (Array with: originalColumnIndex with: columnIndex)].</body><body package="Grid">restoreBackground	super restoreBackground.	self view invalidate.</body><body package="Grid">setupForDraggingIndex: index at: aPoint 	| column visualBounds displayPoint columnHeaderCell |	startedDragging := true.	originalColumnIndex := columnIndex := index.	column := self view firstVisibleColumn atIndex: index.	columnHeaderCell := column cells detect: [:any | any isHeader]				ifNone: [^self].	visual := columnHeaderCell component.	visual widget isInTransition: false. 	visualBounds := visual bounds.	graphicsContext := self view graphicsContext copy clippingRectangle: nil.	dragDisplayOffset := startingPoint - visualBounds origin.	displayPoint := aPoint - dragDisplayOffset.	self createBasicBackingStoreAt: displayPoint from: visualBounds.	labelPixmap displayOn: graphicsContext at: displayPoint.	previousPoint := displayPoint</body></methods><methods><class-id>UI.GridColumnDraggingTracker</class-id> <category>accessing</category><body package="Grid">gridBody	^self controller column grid</body></methods><methods><class-id>UI.GridColumnDraggingTracker class</class-id> <category>resources</category><body package="Grid">noEntry	^ListIconLibrary visualFor: #error</body></methods><methods><class-id>UI.Grid</class-id> <category>columns</category><body package="Grid">addColumn: aGridColumn	aGridColumn grid: self.	columns add: aGridColumn.	self isOpen ifTrue:[self checkCells].	self setLineSelectionExtent.</body><body package="Grid">addColumn: aGridColumn beforeIndex: anInteger	aGridColumn grid: self.	columns add: aGridColumn beforeIndex: anInteger.	self addScrollWidthFor: aGridColumn.	self updateScrollbars.	self setVisibleColumns.	self setLineSelectionExtent.</body><body package="Grid">columns	^columns</body><body package="Grid">columns: aCollection 	columns == aCollection ifTrue: [^self].	columns removeDependent: self.	self dropEdit.	scrollableExtent x: 0.	columns do:[:each | each grid: nil].	aCollection do: 			[:each | 			each grid: self.			self addScrollWidthFor: each].	columns := aCollection.	columns addDependent: self.	self updateScrollbars.	self setVisibleColumns.	self isOpen ifTrue:[self checkCells].	self setLineSelectionExtent.</body><body package="Grid">moveColumnIndex: anIndex toIndex: aTargetIndex 	columns add: (columns removeAtIndex: anIndex) beforeIndex: aTargetIndex.	self setVisibleColumns.	self selectByCell 		ifTrue: 			[self swapSelectionRange: (anIndex @ 1 corner: anIndex @ rows size)				with: (aTargetIndex @ 1 corner: aTargetIndex @ rows size)]</body><body package="Grid">removeColumn: aGridColumn	self removeColumnIndex: aGridColumn index.	self invalidate.</body><body package="Grid">removeColumnIndex: anIndex 	| column |	self editCell 		ifNotNil: [:cell | cell cellPoint x = anIndex ifTrue: [self dropEdit]].	column := columns removeAtIndex: anIndex.	"column removeDependent: self."	self removeScrollWidthFor: column.	self updateScrollbars.	self setVisibleColumns.	self removeSelectionRange: (anIndex @ 1 corner: anIndex @ rows size).	self setLineSelectionExtent</body><body package="Grid">removeColumnsFrom: startIndex to: endIndex 	self editCell ifNotNil: 			[:cell | 			((startIndex to: endIndex) includes: cell cellPoint x) 				ifTrue: [self dropEdit]].	(columns removeFrom: startIndex to: endIndex) 		do: [:each | self removeScrollWidthFor: each].	self updateScrollbars.	self setVisibleColumns.	self removeSelectionRange: (startIndex @ 1 corner: endIndex @ rows size).	self setLineSelectionExtent</body><body package="Grid">selectedColumns	^columns select:[:each| each isSelected]</body><body package="Grid">visualForColumn: aGridColumn do: aBlock 	"There must be a unique GridColumn for each GridVisualColumn to ensure that a single match occurs"	firstVisibleColumn		ifNotNil: [firstVisibleColumn visualForColumn: aGridColumn do: aBlock]</body><body package="Grid">visualForColumn: aGridColumn ifNone: aBlock	"There must be a unique GridColumn for each GridVisualColumn to ensure that a single match occurs"	^(firstVisibleColumn atIndex: aGridColumn index)		ifNil: aBlock		ifNotNil: [:value | value visualForColumn: aGridColumn ifNone: aBlock]</body></methods><methods><class-id>UI.Grid</class-id> <category>accessing-properties</category><body package="Grid">allowColumnReordering	^allowColumnReordering == true</body><body package="Grid">allowColumnReordering: aBoolean	allowColumnReordering := aBoolean</body><body package="Grid">allowColumnResizing	^allowColumnResizing ~= false</body><body package="Grid">allowColumnResizing: aBoolean	allowColumnResizing := aBoolean</body><body package="Grid">allowRowResizing	^allowRowResizing ~= false</body><body package="Grid">allowRowResizing: aBoolean	allowRowResizing := aBoolean</body><body package="Grid">gridLineColor	^gridLineColor isNil		ifTrue: [ColorValue lightGray]		ifFalse: [gridLineColor]</body><body package="Grid">gridLineColor: aColorOrNil 	gridLineColor := aColorOrNil</body><body package="Grid">showColumnLines	^showColumnLines</body><body package="Grid">showColumnLines: aBoolean	showColumnLines := aBoolean</body><body package="Grid">showRowLines	^showRowLines</body><body package="Grid">showRowLines: aBoolean	showRowLines := aBoolean</body></methods><methods><class-id>UI.Grid</class-id> <category>private-legacy</category><body package="Grid">activateEditorAndRequestFocusIn: aBoolean	"Take no action"</body><body package="Grid">allowSorting	^allowSorting</body><body package="Grid">cellIndexFor: cursorPoint 	^(self columnIndexFor: cursorPoint) @ (self rowIndexFor: cursorPoint)</body><body package="Grid">columnDescriptors	^columns</body><body package="Grid">columnIndexFor: cursorPoint 	firstVisibleColumn ifNotNil: 			[(firstVisibleColumn atPosition: cursorPoint x) 				ifNotNil: [:value | ^value index]].	^0</body><body package="Grid">confirmColumnSize	"Take no action"</body><body package="Grid">confirmRowSize	"Take no action"</body><body package="Grid">controllerProxy	^nil</body><body package="Grid">editorFocusOut</body><body package="Grid">editorIsNil	^self editor isNil</body><body package="Grid">editorWantsControl	^false</body><body package="Grid">invalidateSelectionIndex: anIndex</body><body package="Grid">isValidIndex: anPoint	^anPoint y &gt; 0		and: [anPoint  y &lt;= self numberOfRows		and: [anPoint x &gt; 0 		and: [anPoint x &lt;= self numberOfColumns]]]</body><body package="Grid">isValidRow: index	^firstVisibleRow ifNil:[false] ifNotNil:[(firstVisibleRow atIndex: index) notNil]</body><body package="Grid">labelAreaBounds	^self bounds 		bottom: (firstVisibleRow ifNil: [0] ifNotNil: [firstVisibleRow bottom - 4])</body><body package="Grid">loseFocus	self hasFocus: false</body><body package="Grid">requestEditorFocusOut	| editor |	editor := self editor.	editor isNil ifTrue: [^true].	editor widget controller isNil ifTrue: [^true].	editor widget controller view hasFocus ifFalse: [^true].	^editor widget controller requestFocusOut</body><body package="Grid">resetSelection</body><body package="Grid">rowIndexFor: aPoint	^(firstVisibleRow atPosition: aPoint y) ifNil:[0] ifNotNil:[:value| value index]</body><body package="Grid">scrollBy: aPoint</body><body package="Grid">selectionIndex	^0</body><body package="Grid">targetIndex: aNumber	targetIndex := aNumber</body><body package="Grid">visualCellAtPoint: aPoint	"Answer the GridVisualCell at position aPoint if visible"	^(firstVisibleRow atIndex: aPoint y)		ifNotNil: [:row | row cells detect: [:any | any cellPoint = aPoint] ifNone: nil]</body></methods><methods><class-id>UI.Grid</class-id> <category>accessing</category><body package="Grid">allowSorting: aBoolean	allowSorting := aBoolean</body><body package="Grid">builder	^builder</body><body package="Grid">defaultRowHeight: anIntegerOrNil	defaultRowHeight := anIntegerOrNil</body><body package="Grid">grid	^self</body><body package="Grid">horizontalPolicy	^horizontalPolicy</body><body package="Grid">horizontalPolicy: aSymbol	horizontalPolicy := aSymbol</body><body package="Grid">items	| items |	items := rows species new: rows size.	rows do:[:row| row isHeader ifFalse:[items add: row item]].	^items</body><body package="Grid">multiSelect	^controller multiSelect</body><body package="Grid">multiSelect: aBoolean 	^controller multiSelect: aBoolean</body><body package="Grid">selectionChannel	^selectionChannel</body><body package="Grid">selectionChannel: aValueModel	"Set the receiver's selection channel to be aValueModel."	selectionChannel removeDependent: self.	selectionChannel := aValueModel.	selectionChannel addDependent: self.	self resetSelection</body><body package="Grid">selectionInGrid: aSelectionInGrid	self model: aSelectionInGrid listHolder.	self selectionChannel: aSelectionInGrid selectionRangeHolder</body><body package="Grid">state: aWidgetState	state := aWidgetState</body><body package="Grid">verticalPolicy	^verticalPolicy</body><body package="Grid">verticalPolicy: aSymbol	verticalPolicy := aSymbol</body><body package="Grid">widgetState	^state</body><body package="Grid">widgetState: aWidgetState	state := aWidgetState</body><body package="Grid">windowKeyboardProcessor	^super keyboardProcessor</body></methods><methods><class-id>UI.Grid</class-id> <category>selection</category><body package="Grid">addSelectionRange: aRectangle 	"Add aRectangle cell range to the selections merging with existing selections if any.  Answer the range added"	| rectangle |	rectangle := self selectByCell 				ifTrue: [aRectangle]				ifFalse: 					[(aRectangle copy)						left: 1;						right: self numberOfColumns;						yourself].	self range: rectangle visualCellsDo: [:cell | cell showSelected].	self selectionChannelChangeDuring: 			[self mergeSelections: self selectionRange with: rectangle].	^rectangle</body><body package="Grid">cellAt: aPoint beSelected: aBoolean 	aBoolean 		ifTrue: [self addSelectionRange: (aPoint extent: 0 @ 0)]		ifFalse: [self removeSelectionRange: (aPoint extent: 0 @ 0)]</body><body package="Grid">clipSelections	"Clip selections that are out of grid bounds"		| gridBounds clippedSet |	clippedSet := Set new.	gridBounds := self cellBounds.	self selectionRange		do:			[:range | 			| clipped extent |			clipped := gridBounds intersect: range.			extent := clipped extent.			(extent x &lt; 0 or: [extent y &lt; 0]) ifFalse: [clippedSet add: clipped]].	self selectionRange: clippedSet</body><body package="Grid">columnAt: anInteger beSelected: aBoolean 	anInteger ifNil:[^self].	aBoolean 		ifTrue: 			[self 				addSelectionRange: (anInteger @ 1 corner: anInteger @ self numberOfRows)]		ifFalse: 			[self 				removeSelectionRange: (anInteger @ 1 corner: anInteger @ self numberOfRows)]</body><body package="Grid">mergeSelections	| merged |	self selectionRange size &lt; 2 ifTrue: [^self].	merged := Set new.	self selectionRange do: [:each | self mergeSelections: merged with: each].	self selectionRange: merged</body><body package="Grid">moveSelectionRange: sourceRectangle to: destRectangle 	"One way move selections within sourceRectangle to region destRectangle"	| sourceSet sourceOffset |	sourceSet := Set new.	sourceOffset := destRectangle origin - sourceRectangle origin.	self selectionRange do: 			[:range | | clipped extent |			clipped := sourceRectangle intersect: range.			extent := clipped extent.			extent &gt;=  0 ifTrue: [sourceSet add: clipped]].	self removeSelectionRange: sourceRectangle.	self removeSelectionRange: destRectangle.	sourceSet 		do: [:range | self addSelectionRange: ((range moveBy: sourceOffset) intersect: destRectangle)].</body><body package="Grid">range: aRectangle beSelected: aBoolean		^aBoolean		ifTrue:[self addSelectionRange: aRectangle]		ifFalse:[self removeSelectionRange: aRectangle]</body><body package="Grid">removeSelectionRange: aRectangle 	"Remove aRectangle cell range from the selections separating from existing selection ranges if any.  Answer the range removed"	| rectangle |	rectangle := self selectByCell 				ifTrue: [aRectangle]				ifFalse: 					[(aRectangle copy)						left: 1;						right: self numberOfColumns;						yourself].	self range: rectangle visualCellsDo: [:cell | cell hideSelected].	self selectionChannelChangeDuring: 			[self mergeSelections: self selectionRange without: rectangle].	^rectangle</body><body package="Grid">replaceSelectionRange: aRectangle 	"Replace the selections to aRectangle cell range.  Answer the overall range to invalidate"	| rectangle updateRange selections |	rectangle := self selectByCell 				ifTrue: [aRectangle]				ifFalse: 					[(aRectangle copy)						left: 1;						right: self numberOfColumns;						yourself].	selections := self selectionRange.	selections isEmpty 		ifTrue:[updateRange := rectangle]		ifFalse: 			[ selections 				do: [:range | self range: range visualCellsDo: [:cell | cell hideSelected]].			updateRange := selections inject: rectangle into:[:sofar :each| sofar merge: each].			selections := Set new].	selections add: rectangle.	self selectionRange: selections.	self range: rectangle visualCellsDo: [:cell | cell showSelected].	^updateRange</body><body package="Grid">resetSelections	| selections |	selections := self selectionRange.	selections isEmpty 		ifFalse: 			[selections 				do: [:range | self range: range visualCellsDo: [:cell | cell hideSelected]].			self invalidateCellRange: (selections fold: [:a :b | a merge: b]).			self selectionRange: Set new]</body><body package="Grid">rowAt: anInteger beSelected: aBoolean 	aBoolean 		ifTrue: 			[self 				addSelectionRange: (1 @ anInteger corner: self numberOfColumns @ anInteger)]		ifFalse: 			[self removeSelectionRange: (1 @ anInteger 						corner: self numberOfColumns @ anInteger)]</body><body package="Grid">selectAll		| rectangle |	rectangle := self cellBounds.	self		range: rectangle		visualCellsDo: [:cell | cell showSelected].	self selectionRange: (Set with: rectangle)</body><body package="Grid">selectByCell 	^selectByCell</body><body package="Grid">selectByCell: aBoolean	selectByCell:= aBoolean</body><body package="Grid">selectCell: aGridVisualCell	controller selectCell: aGridVisualCell</body><body package="Grid">selectPoint: aPoint	self invalidateCellRange: (self multiSelect				ifTrue: [self addSelectionRange: (aPoint extent: 0 @ 0)]				ifFalse: [self replaceSelectionRange: (aPoint extent: 0 @ 0)])</body><body package="Grid">selectRange: aRectangle	self invalidateCellRange: (self multiSelect				ifTrue: [self addSelectionRange: aRectangle]				ifFalse: [self replaceSelectionRange: (aRectangle extent: 0 @ 0)])</body><body package="Grid">selectedGridElements	"Answer a set of all my selected elements (e.g. GridCell or GridRow)"	| selectedElements |	selectedElements := Set new.	selectByCell 		ifTrue: [self selectionCellDo: [:cell | selectedElements add: cell]]		ifFalse: [self selectionDo: [:row | selectedElements add: row]].	^selectedElements</body><body package="Grid">selectedGridElements: aSet 	"Add elements of aSet (e.g. a GridRow or GridCell) to my selection ranges"	aSet do: [:each | each isSelected: true]</body><body package="Grid">selectionCellDo: aBlock 	self selectionRange do: [:range | self range: range cellsDo: aBlock]</body><body package="Grid">selectionDo: aBlock 	self selectionRange do: [:range | self range: range rowsDo: aBlock]</body><body package="Grid">selectionRange	^self selectionChannel value</body><body package="Grid">selectionRange: aSet	self selectionChannel value: aSet</body><body package="Grid">swapSelectionRange: sourceRectangle with: destRectangle	"Swap selections within sourceRectangle with destRectangle. A swap is a two-way move."		| sourceSet destSet sourceOffset destOffset |	sourceSet := Set new.	destSet := Set new.	sourceOffset := destRectangle origin - sourceRectangle origin.	destOffset := sourceRectangle origin - destRectangle origin.	self selectionRange		do:			[:range | 			(sourceRectangle contains: range)				ifTrue: [sourceSet add: (range intersect: sourceRectangle)]].	self selectionRange		do:			[:range | 			(destRectangle contains: range)				ifTrue: [destSet add: (range intersect: destRectangle)]].	self removeSelectionRange: sourceRectangle.	self removeSelectionRange: destRectangle.	sourceSet		do:			[:range | 			self addSelectionRange: ((range moveBy: sourceOffset) intersect: destRectangle)].	destSet		do:			[:range | 			self	addSelectionRange:	((range moveBy: destOffset) intersect: sourceRectangle)]</body><body package="Grid">toggleSelectionRange: aRectangle 	"Toggle selection state within aRectangle cell range merging with existing selections if any.  Answer the range"	| rectangle |	rectangle := self selectByCell 				ifTrue: [aRectangle]				ifFalse: 					[(aRectangle copy)						left: 1;						right: self numberOfColumns;						yourself].	aRectangle top to: aRectangle bottom		do: 			[:irow | 			self selectByCell 				ifTrue: 					[aRectangle left to: aRectangle right						do: 							[:icol | 							| cellPoint isSelected |							cellPoint := icol @ irow.							isSelected := self isCellPositionSelected: cellPoint.							self cellAt: cellPoint beSelected: isSelected not]]				ifFalse: 					[| cellPoint isSelected |					cellPoint := 1 @ irow.					isSelected := self isCellPositionSelected: cellPoint.					self cellAt: cellPoint beSelected: isSelected not]].	^rectangle</body><body package="Grid">unselectRange: aRectangle 	| unselectRange |	unselectRange := self multiSelect 				ifTrue: [self removeSelectionRange: aRectangle]				ifFalse: 					[self removeSelectionRange: (aRectangle extent: 0 @ 0).					self selectionRange: Set new].	self invalidateCellRange: unselectRange</body></methods><methods><class-id>UI.Grid</class-id> <category>private</category><body package="Grid">changedContainer	super changedContainer.	builder keyboardProcessor parentVisual: container.</body><body package="Grid">checkCells	firstVisibleRow ifNotNil:[firstVisibleRow checkCellsWithSuccessors].</body><body package="Grid">createAllVisibleColumns	| leftGridEdge rightGridEdge |	(columns isNil or:[columns isEmpty]) ifTrue:[^self].	leftGridEdge := self scrollableEdge.	rightGridEdge := self bounds right.	firstVisibleColumn := leftGridEdge &gt; rightGridEdge 				ifTrue: [nil]				ifFalse: 					[(firstVisibleColumn ifNil: 							[GridVisualColumn 								on: columns first								in: self								index: 1								left: 0								right: nil]) 						firstVisibleColumnBetween: leftGridEdge						and: rightGridEdge]</body><body package="Grid">createAllVisibleRows	firstVisibleRow := rows isEmpty 				ifTrue: [nil]				ifFalse: 					[(firstVisibleRow ifNil: 							[GridVisualRow 								on: rows first								in: self								index: 1								top: 0								bottom: nil]) 						firstVisibleRowBetween: self bounds top						and: self bounds bottom].</body><body package="Grid">displayBackgroundIfNeededOn: aGraphicsContext	self displayBackgroundIfNeededOn: aGraphicsContext		in: self bounds</body><body package="Grid">displayBackgroundIfNeededOn: aGraphicsContext in: aRectangle	| p |	(state isOpaque or: [state hasBackgroundColor]) ifFalse: [^self].	p := aGraphicsContext paint.	aGraphicsContext paint: self backgroundColor.	aGraphicsContext displayRectangle: aRectangle.	aGraphicsContext paint: p.</body><body package="Grid">invalidateRectangle: aRectangle 	"Don't add damage rectangles if invalidation is suppressed"	self isOpen 		ifTrue: 			[self topComponent sensor invalidationSuppressed 				ifFalse: [super invalidateRectangle: aRectangle]]</body><body package="Grid">lineGrid	^self firstVisibleRow ifNil:[0] ifNotNil:[:row| row height]</body><body package="Grid">mergeSelections: aSet with: aRectangle 	"Add or merge aRectangle to aSet of selection ranges"	| toMerge |	toMerge := aRectangle.	aSet asArray do: 			[:next | 			(next contains: toMerge) ifTrue: [^self].			((toMerge contains: next) or: 					[((toMerge bottom + 1 = next top or: [next bottom + 1 = toMerge top]) 						and: [next left = toMerge left and: [next right = toMerge right]]) or: 								[(toMerge right + 1 = next left or: [next right + 1 = toMerge left]) 									and: [next top = toMerge top and: [next bottom = toMerge bottom]]]]) 				ifTrue: 					[aSet remove: next.					toMerge := next merge: toMerge]].	aSet add: toMerge</body><body package="Grid">mergeSelections: aSet without: aRectangle 	"Remove or extract aRectangle from aSet of selection ranges"	| depth |	depth := 0 @ 0 extent: 1 @ 1.	aSet asArray do: 			[:next | 			(aRectangle contains: next) 				ifTrue: [aSet remove: next]				ifFalse: 					[| nextWithDepth removalWithDepth |					nextWithDepth := next expandedBy: depth.					removalWithDepth := aRectangle expandedBy: depth.					(nextWithDepth intersects: removalWithDepth) 						ifTrue: 							[aSet remove: next.							aSet addAll: ((nextWithDepth areasOutside: removalWithDepth) 										collect: [:range | range insetBy: depth])]]]</body><body package="Grid">outerBoundsFor: aGraphicsContext	^aGraphicsContext clippingBounds expandedBy: 10</body><body package="Grid">range: aRectangle visualCellsDo: aBlock 	self firstVisibleRow ifNil:[^self].	aRectangle left to: aRectangle right		do: 			[:icol | 			self firstVisibleRow 				withSuccessorsFromIndex: aRectangle top				to: aRectangle bottom				do: 					[:each | 					(each cells detect: [:cell | cell visualColumn index = icol] ifNone: nil) 						ifNotNil: aBlock]]</body><body package="Grid">recreateColumnHeader</body><body package="Grid">resumeEditAtFirstRow	self isEditing ifFalse:[^false].	^self editAt: (self editCell cellPoint y: self firstVisibleRow index)</body><body package="Grid">scrollGridBlock	^[1@self lineGrid]</body><body package="Grid">selectionChannelChangeDuring: aBlock 	"Update the selectionChannel if the selection set contents changes during aBlock evaluation"	| formerSelections |	formerSelections := self selectionRange copy.	aBlock ensure: 			[| newSelections |			newSelections := self selectionRange.			((newSelections - formerSelections) isEmpty 				and: [(formerSelections - newSelections) isEmpty]) 					ifFalse: [selectionChannel changed: #value]]</body><body package="Grid">setLineSelectionExtent	"For line selection mode, extend the cell selection coordinate range for the current number of columns.  Here we set the selectionRange from a new copy because just changing each range alters its hash and therefore indexing into the Set."	self selectByCell ifTrue: [^self].	self		selectionRange: (self selectionRange collect: 					[:range |					range left: 1.					range right: self numberOfColumns])</body><body package="Grid">setModel: aModel	super setModel: aModel.	self rows: aModel value.</body><body package="Grid">setScrollableColumns	"Set the firstVisibleColumn linked list of all columns that are at least partially visible in the Grid. If the current scroll position is closer to the rightmost extreme search left from the last column.  Otherwise begin the search from the origin"	firstVisibleColumn ifNotNil: 			[self dropEdit.			firstVisibleColumn releaseWithSuccessors.			firstVisibleColumn := nil].	columns isEmpty ifFalse: [self createAllVisibleColumns].	self isOpen ifTrue: [self checkCells]</body><body package="Grid">setVisibleColumns	self setScrollableColumns.	self isOpen ifTrue:[self checkCells]</body><body package="Grid">setVisibleRows	firstVisibleRow ifNotNil: 			[self dropEdit.			firstVisibleRow releaseWithSuccessors.			firstVisibleRow := nil].	rows isEmpty ifFalse: [self createAllVisibleRows].	self isOpen ifTrue:[self checkCells].</body><body package="Grid">updateElementPositions	| bounds |	bounds := self bounds.	firstVisibleColumn := firstVisibleColumn				ifNotNil: 					[firstVisibleColumn firstVisibleColumnBetween: self scrollableEdge						and: bounds right].	firstVisibleRow := firstVisibleRow				ifNotNil: 					[firstVisibleRow firstVisibleRowBetween: bounds top and: bounds bottom].	self isOpen		ifTrue: 			[firstVisibleRow				ifNotNil: 					[self topComponent sensor invalidationSuppressWhile: 							[firstVisibleRow checkCellsWithSuccessors]]]</body><body package="Grid">updateScrollableColumns	"The bounds of the Grid has changed but columns have not be reordered.  Grow or shrink the bounds of the firstScrollableColumn linked array for all non-frozen columns at least partially visible in the width of the Grid"	self isOpen ifFalse: [^self].	firstVisibleColumn ifNil: [self setScrollableColumns]		ifNotNil: 			[firstVisibleColumn := firstVisibleColumn 						firstVisibleColumnBetween: self scrollableEdge						and: self bounds right]</body><body package="Grid">updateVisibleColumnsAndHeader	self updateScrollableColumns.	self recreateColumnHeader</body><body package="Grid">useColumns: aCollection	"Access but do not assign ownership of aCollection columns to myself"	columns == aCollection ifTrue: [^self].	self removeColumnDependence.	scrollableExtent x: 0.	aCollection do: [:each | self addScrollWidthFor: each].	columns := aCollection.	columns addDependent: self.	columns do: [:column | column addDependent: self].	self updateScrollbars</body><body package="Grid">useRows: aCollection 	"Access but do not assign ownership of aCollection rows to myself"	rows == aCollection ifTrue: [^self].	rows do:[:row| row removeDependent: self].	scrollableExtent y: 0.	aCollection do: 			[:each | 			self addScrollHeightFor: each].	rows := aCollection.	rows do:[:row| row addDependent: self].	self updateScrollbars.</body><body package="Grid">visualCellAt: aPoint do: aBlock 	| irow |	irow := aPoint y.	firstVisibleRow 		withSuccessorsFromIndex: irow		to: irow		do: 			[:row | 			(row cells detect: [:each | each cellPoint = aPoint] ifNone: nil) 				ifNotNil: aBlock]</body><body package="Grid">visualColumnAtEdge: aPoint	"Answer the GridVisibleColumn whose right boundary borders aPoint, if any"	| dragPosition |	dragPosition := aPoint x - 2.	^dragPosition &gt; self scrollableEdge		ifTrue: 			[firstVisibleColumn				ifNotNil: 					[:column |					column withSuccessorsDetect: 							[:each |							each right between: dragPosition - 4 and: dragPosition + 4]						ifNone: nil]]		ifFalse: [nil]</body><body package="Grid">visualColumnAtPosition: aNumber	"Answer the GridVisibleColumn within which aNumber lies, if any"	^aNumber &gt; self scrollableEdge		ifTrue: [firstVisibleColumn atPosition: aNumber]		ifFalse: [nil]</body><body package="Grid">visualRowAtEdge: aPoint 	"Answer the GridVisibleRow whose bottom boundary borders aPoint, if any"	| dragPosition |	dragPosition := aPoint y - 2.	^firstVisibleRow ifNotNil: 			[:row | 			row withSuccessorsDetect: 					[:each | 					each bottom between: dragPosition - 4 and: dragPosition + 4]				ifNone: nil]</body></methods><methods><class-id>UI.Grid</class-id> <category>controller accessing</category><body package="Grid">defaultControllerClass	^GridController</body></methods><methods><class-id>UI.Grid</class-id> <category>displaying</category><body package="Grid">displayColumnLinesOn: aGraphicsContext 	"Display column lines, if permitted"	| bottom bounds topGridEdge clipBounds |	self showColumnLines ifFalse: [^self].	self firstVisibleRow ifNil: [^self].	self firstVisibleColumn ifNil: [^self].	bounds := self bounds.	topGridEdge := bounds top.	bottom := self lastVisibleRow bottom min: bounds bottom.	aGraphicsContext paint: self gridLineColor.	firstVisibleColumn ifNotNil: 			[| graphicsContext |			graphicsContext := aGraphicsContext copy 						intersectClip: (bounds left: self scrollableEdge).			clipBounds := graphicsContext clippingBounds.			firstVisibleColumn 				withSuccessorsFrom: clipBounds left				to: clipBounds right				do: 					[:each | 					each column showColumnLine 						ifTrue: 							[| columnEdge |							columnEdge := each right.							graphicsContext displayLineFrom: columnEdge @ topGridEdge								to: columnEdge @ bottom]]]</body><body package="Grid">displayOn: aGraphicsContext 	self displayBackgroundIfNeededOn: aGraphicsContext.	self displaySelectionHighlightOn: aGraphicsContext.	super displayOn: aGraphicsContext.	self displayColumnLinesOn: aGraphicsContext.	self displayRowLinesOn:  aGraphicsContext.	self displaySelectionHighlightBorderOn: aGraphicsContext.	self displayTargetSelectionBorderOn: aGraphicsContext.</body><body package="Grid">displayRowLinesOn: aGraphicsContext 	"Display row lines, if permitted"	| bounds leftGridEdge rightGridEdge clipBounds |	self showRowLines ifFalse: [^self].	self firstVisibleRow ifNil: [^self].	self firstVisibleColumn ifNil: [^self].	bounds := self bounds.	clipBounds := aGraphicsContext clippingBounds.	leftGridEdge := bounds left.	rightGridEdge := self lastVisibleColumn right min: bounds right.	aGraphicsContext paint: self gridLineColor.	self firstVisibleRow 		withSuccessorsFrom: clipBounds top		to: clipBounds bottom		do: 			[:each | 			| rowEdge |			rowEdge := each bottom.			aGraphicsContext displayLineFrom: leftGridEdge @ rowEdge				to: rightGridEdge @ rowEdge]</body><body package="Grid">displaySelectionHighlightBorderOn: aGraphicsContext	| outerBounds |	outerBounds := self outerBoundsFor: aGraphicsContext.	self selectionRange do: 			[:rectangle |			| bounds |			bounds := self boundsForRange: rectangle in: outerBounds.			(Border width: 1 color: SymbolicPaint dataTraversalHilite)				displayOn: aGraphicsContext				forDisplayBox: bounds]</body><body package="Grid">displaySelectionHighlightOn: aGraphicsContext 	| graphicsContext symbolicPaint outerBounds |	self selectionRange isEmpty ifTrue:[^self].	graphicsContext := aGraphicsContext copy.	symbolicPaint := graphicsContext 				paintPreferencesMatchAt: SymbolicPaint selectionBackground.	graphicsContext paintPreferencesMatchAt: SymbolicPaint foreground		put: symbolicPaint.	outerBounds := self outerBoundsFor: aGraphicsContext.	self selectionRange do: 			[:rectangle | 			| bounds |			bounds := self boundsForRange: rectangle in: outerBounds.			graphicsContext displayRectangle: bounds]</body><body package="Grid">displayTargetSelectionBorderOn: aGraphicsContext 	| targetBounds targetPoint |	targetPoint := self controller targetPoint.	targetBounds := self selectByCell 				ifTrue: [targetPoint extent: 0 @ 0]				ifFalse: [1 @ targetPoint y corner: self numberOfColumns @ targetPoint y].	self displayTraversalBorderOver: targetBounds on: aGraphicsContext</body><body package="Grid">displayTraversalBorderOver: aRectangle on: aGraphicsContext 	"Display a thin border about the target cell bounds aRectangle"	| bounds |	bounds := self boundsForRange: aRectangle				in: (self outerBoundsFor: aGraphicsContext).	bounds extent = (0 @ 0) ifTrue: [^self].	(Border width: 1 color: SymbolicPaint listDataTraversalHilite) displayOn: aGraphicsContext		forDisplayBox: bounds</body><body package="Grid">invalidateCellRange: aRectangle 	"Invalidate the cell coordinate range aRectangle in my pane bounds"	| clippingBounds |	clippingBounds := self boundsForRange: aRectangle in: self bounds.	clippingBounds extent = (0 @ 0) ifTrue: [^self].	self invalidateRectangle: clippingBounds</body></methods><methods><class-id>UI.Grid</class-id> <category>editing</category><body package="Grid">dropEdit	| namedComponents |	self editor		ifNotNil: 			[:editor |			editor widget removeActionsWithReceiver: self forEvent: #losingFocus.			self editCell 	ifNotNil: [:gridCell | gridCell isEditable ifFalse: [self remove: editor]].			self keyboardProcessor ifNotNil: [:keyboardProcessor | keyboardProcessor focusedView: nil]].	builder bindings removeKey: self editorCellBindingKey ifAbsent: nil.	namedComponents := builder namedComponents.	namedComponents removeKey: self editorKey ifAbsent: nil.	builder namedComponents: namedComponents</body><body package="Grid">editAt: aPoint	"Answer if the cell at position aPoint may be given focus for editing.  If it may, give it focus and update the editCell and editor references to the new location" 	| component accepted gridVisualCell |	(self gridCellAtPoint: aPoint) scrollToView.	gridVisualCell := self visualCellAtPoint: aPoint.	gridVisualCell ifNil:[^false].	gridVisualCell canEdit ifFalse: [^false].	component := gridVisualCell component.	component isEnabled ifFalse: [^false].	accepted := self keyboardProcessor		requestActivationFor: component widget controller.	accepted ifTrue: [self editCell: gridVisualCell].	^accepted</body><body package="Grid">editCell	^builder arbitraryComponentAt: self editorCellBindingKey</body><body package="Grid">editCell: aGridVisualCell	| widget wrapper |	wrapper := aGridVisualCell component.	builder		componentAt: self editorKey put: wrapper;		arbitraryComponentAt: self editorCellBindingKey put: aGridVisualCell asGridCell.	widget := wrapper widget.	(widget canTriggerEvent: #losingFocus)		ifTrue: 			["Emphasize border and background of cell under edit"			| borderWrapper |			borderWrapper := wrapper component.			borderWrapper hasBorder				ifTrue: 					[widget						when: #losingFocus						send: #restoreBorder:						to: self						with: borderWrapper border copy.					borderWrapper						borderWidth: 3;						borderColor: ColorValue black].			widget				when: #losingFocus				send: #restoreColors:				to: self				with: wrapper lookPreferences copy.			wrapper lookPreferences: (wrapper lookPreferences copy						setBackgroundColor: HierarchicalSymbolicPaint buttonBackground).			widget when: #losingFocus send: #dropEdit to: self]</body><body package="Grid">editor	^builder componentAt: self editorKey</body><body package="Grid">restoreBorder: aBorder	self editor ifNotNil: [:editor | editor component border: aBorder].</body><body package="Grid">restoreColors: aLookPreferences	self editor ifNotNil: [:editor | editor lookPreferences: aLookPreferences].</body></methods><methods><class-id>UI.Grid</class-id> <category>private-constants</category><body package="Grid">editorCellBindingKey	^#'_editorCell'</body><body package="Grid">editorKey	^#'_editor'</body></methods><methods><class-id>UI.Grid</class-id> <category>selection-legacy</category><body package="Grid">firstIndex</body><body package="Grid">makeVisible: aPoint</body><body package="Grid">targetLineIndex</body><body package="Grid">zeroIndex	^Point zero</body></methods><methods><class-id>UI.Grid</class-id> <category>accessing-rows and columns</category><body package="Grid">firstVisibleColumn	firstVisibleColumn ifNil: [self setScrollableColumns].	^firstVisibleColumn</body><body package="Grid">firstVisibleRow	firstVisibleRow ifNil: [self setVisibleRows]. 	^firstVisibleRow</body><body package="Grid">gridCellAtPoint: aPoint 	^GridCell column: (columns at: aPoint x) row: (rows at: aPoint y)</body><body package="Grid">lastVisibleColumn	^self firstVisibleColumn last</body><body package="Grid">lastVisibleRow	^self firstVisibleRow last</body><body package="Grid">visibleColumns	^firstVisibleColumn withSuccessors</body></methods><methods><class-id>UI.Grid</class-id> <category>accessing-dimensions</category><body package="Grid">cellBounds	^1 @ 1 corner: self maxCellPosition</body><body package="Grid">defaultRowHeight	^defaultRowHeight ifNil:[0]</body><body package="Grid">fullVisibleRowCount	^self firstVisibleRow 		ifNil: [0]		ifNotNil: 			[| lastVisibleRow |			lastVisibleRow := self lastVisibleRow.			lastVisibleRow isFullyVisible 				ifTrue: [lastVisibleRow index - firstVisibleRow index + 1]				ifFalse: [lastVisibleRow index - firstVisibleRow index]]</body><body package="Grid">maxCellPosition	^self numberOfColumns @ self numberOfRows</body><body package="Grid">numberOfCells	"Answer the number of cells in the receiver."	^self numberOfColumns * self numberOfRows</body><body package="Grid">numberOfColumns	^columns size</body><body package="Grid">numberOfRows	^rows size</body><body package="Grid">scrollableEdge	"Answer the leftmost pane position always visible for scrollable columns"	^self bounds left</body><body package="Grid">scrollableExtent	^scrollableExtent</body><body package="Grid">visibleColumnCount	^firstVisibleColumn		ifNil: [0]		ifNotNil: [:value | value successorCount + 1]</body><body package="Grid">visibleRowCount	^self firstVisibleRow ifNil: [0]		ifNotNil: [:value | value successorCount + 1]</body><body package="Grid">visualRange	^(self firstVisibleColumn index @ self firstVisibleRow index) corner: (self lastVisibleColumn index @ self lastVisibleRow index)</body></methods><methods><class-id>UI.Grid</class-id> <category>initialize-release</category><body package="Grid">initialize	super initialize.	self initializeState.	scrollableExtent := 0 @ 0.	showRowLines := showColumnLines := selectByCell := false.	allowSorting := true.	verticalPolicy := #none.	horizontalPolicy := #wrapNext.	rows := List new.	rows addDependent: self.	columns := List new.	columns addDependent: self.	self initializeSelectionChannel.	builder := UIBuilder new composite: self.	builder aspectAt: #_row put: nil asValue.	builder source: ApplicationModel new.</body><body package="Grid">initializeSelectionChannel	self selectionChannel: (ValueHolder with: Set new).</body><body package="Grid">initializeState	state := WidgetState new.</body><body package="Grid">release	super release.	scrollOffset retractAllInterestsFor: self.	firstVisibleRow ifNotNil:[firstVisibleRow releaseWithSuccessors].	firstVisibleColumn ifNotNil:[firstVisibleColumn releaseWithSuccessors].	self removeColumnDependence.	self removeRowDependence.	columns := rows := List new.</body><body package="Grid">scrollOffset	^scrollOffset</body><body package="Grid">scrollOffsetHolder: aScrollValueHolder 	scrollOffset = aScrollValueHolder ifTrue:[^self].	scrollOffset retractAllInterestsFor: self.	scrollOffset := aScrollValueHolder.	scrollOffset 		expressInterestIn: #value		for: self		sendBack: #updateElementPositions</body><body package="Grid">setScrollOffsetHolder: aValueHolder	self scrollOffsetHolder: aValueHolder</body></methods><methods><class-id>UI.Grid</class-id> <category>testing</category><body package="Grid">isCellFullyVisible: aPoint 	^(self isColumnFullyVisible: aPoint x) 		and: [self isRowFullyVisible: aPoint y]</body><body package="Grid">isCellPositionSelected: aPoint 	^self selectionRange 		contains: [:range | (range expandedBy: (0 @ 0 extent: 1 @ 1)) containsPoint: aPoint]</body><body package="Grid">isCellVisible: aPoint	^(self isColumnVisible: aPoint x) and: [self isRowVisible: aPoint y]</body><body package="Grid">isColumnFullyVisible: anInteger	"Answer if both the left and right borders of the column by index anInteger is fully visible"	^firstVisibleColumn notNil and: 			[(firstVisibleColumn atIndex: anInteger)				ifNil: [false]				ifNotNil: [:value | value isFullyVisible]]</body><body package="Grid">isColumnVisible: anInteger	^(firstVisibleColumn atIndex: anInteger)		ifNil: [false]		ifNotNil: [:visibleColumn | (visibleColumn atIndex: anInteger) notNil]</body><body package="Grid">isEditing	^self editor notNil</body><body package="Grid">isEnabled	^state isEnabled</body><body package="Grid">isHeader	| parent |	parent := container.	[parent isNil or: [parent isKindOf: GridDecorator]]		whileFalse: [parent := parent container].	^parent notNil and: [parent includesHeader: container]</body><body package="Grid">isHeaderRowAt: aPoint	^(firstVisibleRow atPosition: aPoint y)		ifNil: [false]		ifNotNil: [:visual | visual row isHeader]</body><body package="Grid">isRowFullyVisible: anInteger 	"Answer if both the top and bottom of the row by index anInteger is fully visible"	^firstVisibleRow notNil and: 			[(firstVisibleRow atIndex: anInteger) ifNil: [false]				ifNotNil: [:value | value isFullyVisible]]</body><body package="Grid">isRowVisible: anInteger 	^firstVisibleRow notNil and: [(firstVisibleRow atIndex: anInteger) notNil]</body><body package="Grid">mayDisplayCells	^rows notEmpty and:[columns notEmpty]</body><body package="Grid">mayResizeColumnAt: aPoint	^(self isHeaderRowAt: aPoint) and: 			[(self visualColumnAtEdge: aPoint) ifNil: [false] ifNotNil: [:column | column allowResizing]]</body><body package="Grid">mayResizeColumns	^self allowColumnResizing and: [self mayDisplayCells]</body><body package="Grid">mayResizeRows	^self allowRowResizing and: [self mayDisplayCells]</body><body package="Grid">requestFocusOutByBackTab	^horizontalPolicy == #wrapNext and: 			[self editCell notNil				and: [self editCell cellPoint = (1 @ 1) and: [self requestEditorFocusOut]]]</body><body package="Grid">requestFocusOutByNextTab	^horizontalPolicy == #wrapNext and: 			[self editCell notNil				and: [self editCell cellPoint = self maxCellPosition and: [self requestEditorFocusOut]]]</body></methods><methods><class-id>UI.Grid</class-id> <category>navigation</category><body package="Grid">end	self scrollRowIndex: self numberOfRows toView: #bottom.</body><body package="Grid">home	self scrollRowIndex: 1 toView: #top.</body><body package="Grid">lastScrollableRow		^self lastVisibleRow</body><body package="Grid">moveEditHorizontallyBy: delta 	| startCellPosition nextCellPosition increment rowChange |	delta = 0 ifTrue: [^true].	startCellPosition := self editCell ifNil: [^true]				ifNotNil: [:cell | cell cellPoint].	nextCellPosition := startCellPosition.	increment := delta.	rowChange := false.		[| lastCellPosition |	lastCellPosition := nextCellPosition.	nextCellPosition := self 				nextCellPositionHorizontallyFrom: lastCellPosition				by: increment.	nextCellPosition = startCellPosition ifTrue: [^false].	nextCellPosition y = lastCellPosition y 		ifFalse: [controller requestValueChange ifFalse: [^false]. 				rowChange := true].	self editAt: nextCellPosition] 			whileFalse:[increment := delta sign].	rowChange ifTrue:[controller valueChange].	^true</body><body package="Grid">moveEditVerticallyBy: delta 	| startCellPosition nextCellPosition increment |	delta = 0 ifTrue: [^true].	startCellPosition := self editCell ifNil: [^true]				ifNotNil: [:cell | cell cellPoint].	nextCellPosition := startCellPosition.	increment := delta.		[nextCellPosition := self nextCellPositionVerticallyFrom: nextCellPosition				by: increment.	nextCellPosition = startCellPosition ifTrue: [^false].	self editAt: nextCellPosition] 			whileFalse: [increment := delta sign].	^true</body><body package="Grid">nextCellPositionHorizontallyFrom: aPoint by: delta 	delta = 0 ifTrue: [^aPoint].	horizontalPolicy == #none ifTrue: [^aPoint].	horizontalPolicy == #wrapNext 		ifTrue: 			[^((aPoint x + delta - 1) \\ self numberOfColumns + 1) 				@ ((aPoint y + ((aPoint x + delta - 1) // self numberOfColumns) - 1) 						\\ self numberOfRows + 1)].	horizontalPolicy == #wrapSame 		ifTrue: [^((aPoint x + delta - 1) \\ self numberOfColumns + 1) @ aPoint y].	horizontalPolicy == #noWrap 		ifTrue: [^((aPoint x + delta min: 1) max: self numberOfColumns) @ aPoint y]</body><body package="Grid">nextCellPositionVerticallyFrom: aPoint by: delta 	delta = 0 ifTrue: [^aPoint].	verticalPolicy == #none ifTrue: [^aPoint].	verticalPolicy == #wrap 		ifTrue: [^aPoint x @ (aPoint y + delta - 1) \\ self numberOfRows + 1].	verticalPolicy == #noWrap 		ifTrue: [^aPoint x @ ((aPoint y + delta max: 1) min: self numberOfRows)]</body><body package="Grid">pageDown	self lastScrollableRow index = self numberOfRows ifTrue:[^self].	firstVisibleRow := self lastVisibleRow ifNotNil: [:value | value pageDown].	self		scrollRowIndex: self lastVisibleRow index		toView: #bottom</body><body package="Grid">pageUp	firstVisibleRow index = 1 ifTrue:[^self].	firstVisibleRow := firstVisibleRow		ifNil: [^self]		ifNotNil: [:value | value pageUp].	self		scrollRowIndex: firstVisibleRow index		toView: #top</body><body package="Grid">scrollCell: aGridCell toRowView: verticalPosition andColumnView: horizontalPosition		| cellPoint |	cellPoint := aGridCell cellPoint.	self		scrollDo:			[self				moveRowIndex: cellPoint y				toView: verticalPosition.			self				moveColumnIndex: cellPoint x				toView: horizontalPosition]</body><body package="Grid">scrollColumnIndex: anInteger toView: aSymbol 	self scrollDo:[self moveColumnIndex: anInteger toView: aSymbol]</body><body package="Grid">scrollRowIndex: anInteger toView: aSymbol 	self scrollDo:[self moveRowIndex: anInteger toView: aSymbol]</body></methods><methods><class-id>UI.Grid</class-id> <category>private-building</category><body package="Grid">postBuildCell: aGridVisualCell with: aUIBuilder 	"The application is given a chance to modify the cell component built for aGridVisualCell by aUIBuilder for the receiver"	^	[builder source 		perform: #postBuildCell:with:		with: aGridVisualCell		with: aUIBuilder] 			on: MessageNotUnderstood			do: 				[:ex | 				| sel |				sel := ex parameter selector.				sel == #postBuildCell:with: ifTrue: [ex return] ifFalse: [ex pass]]</body><body package="Grid">specForCell: aGridVisualCell appliedTo: aUISpecification 	"The application is given a chance to modify or replace aUISpecification for building the widget appearing in aGridVisualCell for the receiver"	^	[builder source 		perform: #specForCell:appliedTo:		with: aGridVisualCell		with: aUISpecification] 			on: MessageNotUnderstood			do: 				[:ex | 				| sel |				sel := ex parameter selector.				sel == #specForCell:appliedTo: 					ifTrue: [ex return: aUISpecification]					ifFalse: [ex pass]]</body></methods><methods><class-id>UI.Grid</class-id> <category>display box accessing</category><body package="Grid">preferredBounds	"This is my total scrollable bounds"	^0@0 corner: scrollableExtent</body></methods><methods><class-id>UI.Grid</class-id> <category>updating</category><body package="Grid">resetScrollHeight	scrollableExtent y: 0.	self rows do: [:each | self addScrollHeightFor: each]</body><body package="Grid">resetScrollWidth	scrollableExtent x: 0.	self columns do: [:each | self addScrollWidthFor: each]</body><body package="Grid">update: anAspect with: anArg from: anObject	"An object that the receiver's depends on has changed.  Perform an appropriate action."	anAspect == #value		ifTrue: [anObject == selectionChannel					ifTrue: [^self updateSelectionChannel: anArg].				anObject == model					ifTrue: [^self updateModelSelecting: anArg].				^self].	anAspect == #updateColumnWidth: ifTrue:[^self updateWidth: anArg from: anObject]. 	anAspect == #updateRowHeight: ifTrue:[^self updateHeight: anArg from: anObject]. 	anAspect == #selectionChanging ifTrue: [^self triggerEvent: #selectionChanging].	anAspect == #selectionChanged ifTrue: [^self triggerEvent: #selectionChanged].	anObject == rows		ifTrue: [anAspect == #at: ifTrue: [^self updateRowAt: anArg].				anAspect == #add ifTrue: [^self updateRowInsert: rows size].				anAspect == #insert: ifTrue: [^self updateRowInsert: anArg].				anAspect == #replace: ifTrue: [^self updateRowReplace: anArg].				anAspect == #remove: ifTrue: [^self updateRowRemove: anArg].				anAspect == #removeFrom:to: ifTrue: [^self updateRowRemoveRange: anArg].				anAspect == #insertCollection: ifTrue: [^self updateRowInsertCollection: anArg].				anAspect == #appendCollection: ifTrue: [^self updateRowAppendCollection: anArg]].	anObject == columns		ifTrue: [anAspect == #at: ifTrue: [^self updateColumnAt: anArg].				anAspect == #add ifTrue: [^self updateColumnInsert: rows size].				anAspect == #insert: ifTrue: [^self updateColumnInsert: anArg].				anAspect == #replace: ifTrue: [^self updateColumnReplace: anArg].				anAspect == #remove: ifTrue: [^self updateColumnRemove: anArg].				anAspect == #removeFrom:to: ifTrue: [^self updateColumnRemoveRange: anArg].				anAspect == #insertCollection: ifTrue: [^self updateColumnInsertCollection: anArg].				anAspect == #appendCollection: ifTrue: [^self updateColumnAppendCollection: anArg]].	super update: anAspect with: anArg from: anObject.</body><body package="Grid">updateAfterScroll	self updateElementPositions invalidate</body><body package="Grid">updateHeight: anInteger from: aGridRow	self updateScrollHeightBy: anInteger.	self visualForRow: aGridRow do: [:visual | visual updateRowHeight]</body><body package="Grid">updateModelSelecting: anArrayOrNil	self rows = model value ifTrue: [^self].	self rows: model value.</body><body package="Grid">updateScrollHeightBy: anInteger 	anInteger = 0 		ifFalse: 			[scrollableExtent := scrollableExtent + (0 @ anInteger).			self updateScrollbars]</body><body package="Grid">updateScrollWidthBy: anInteger 	anInteger = 0 		ifFalse: 			[scrollableExtent := scrollableExtent + (anInteger @ 0).			self updateScrollbars]</body><body package="Grid">updateScrollbars	scrollOffset value ifNotNil: 			[:scrollValue | 			| limitedScrollValue |			limitedScrollValue := scrollValue 						max: (self bounds extent - scrollableExtent min: 0 @ 0).			scrollValue = limitedScrollValue 				ifFalse: [scrollOffset value: limitedScrollValue]].	self changedPreferredBounds: nil</body><body package="Grid">updateSelectionChannel: anIndexOrNil	self notYetImplemented.</body><body package="Grid">updateWidth: anInteger from: aGridColumn	self updateScrollWidthBy: anInteger.	self visualForColumn: aGridColumn do: [:visual | visual updateColumnWidth]</body></methods><methods><class-id>UI.Grid</class-id> <category>rows</category><body package="Grid">addRow: aGridRow	aGridRow grid: self.	rows add: aGridRow.</body><body package="Grid">addRow: aGridRow beforeIndex: anInteger	aGridRow grid: self.	rows add: aGridRow beforeIndex: anInteger</body><body package="Grid">removeRow: aGridRow	rows remove: aGridRow.	self invalidate</body><body package="Grid">rows	^rows</body><body package="Grid">rows: aCollection		rows removeDependent: self.	rows do:[:each| each grid: nil].	rows := aCollection.	(rows dependents select: [:dependent | dependent class = Grid])		do: [:dependent | rows removeDependent: dependent].	rows addDependent: self.	self dropEdit.	scrollableExtent y: 0.	aCollection		do:			[:each | 			each grid: self.			self addScrollHeightFor: each].	self resetSelections.	self updateScrollbars.	self setVisibleRows</body><body package="Grid">visualForRow: aGridRow do: aBlock	firstVisibleRow 		ifNotNil:[firstVisibleRow visualForRow: aGridRow do: aBlock]</body><body package="Grid">visualForRow: aGridRow ifNone: aBlock	^firstVisibleRow 		ifNil: aBlock		ifNotNil:[firstVisibleRow visualForRow: aGridRow ifNone: aBlock]</body></methods><methods><class-id>UI.Grid</class-id> <category>constants</category><body package="Grid">topOffsetForDisplay	^firstVisibleRow ifNil:[0] ifNotNil:[:value| value height]</body></methods><methods><class-id>UI.Grid</class-id> <category>priviledged</category><body package="Grid">changeRowsWithoutUpdate: aBlock		[rows removeDependent: self.	aBlock value] ensure: [rows addDependent: self]</body><body package="Grid">removeColumnDependence	columns ifNil:[^self].	columns removeDependent: self.	columns do: [:column | column removeDependent: self]</body><body package="Grid">removeRowDependence	rows ifNil:[^self].	rows removeDependent: self.	rows do: [:row | row removeDependent: self]</body><body package="Grid">updateRemoveVisualColumn: aGridVisualColumn	aGridVisualColumn == firstVisibleColumn		ifTrue:[firstVisibleColumn := aGridVisualColumn next].</body><body package="Grid">updateRemoveVisualRow: aGridVisualRow	aGridVisualRow == firstVisibleRow		ifTrue:[firstVisibleRow := aGridVisualRow successor].</body><body package="Grid">valueWithoutRowsUpdate: aBlock		[rows removeDependent: self.	aBlock value] ensure: [rows addDependent: self]</body></methods><methods><class-id>UI.Grid</class-id> <category>bounds accessing</category><body package="Grid">bounds: newBounds	super bounds: newBounds.	self createAllVisibleColumns.	firstVisibleRow := newBounds top &gt; newBounds bottom				ifTrue: [nil]				ifFalse: 					[firstVisibleRow						ifNotNil: 							[| gridBounds |							gridBounds := self bounds.							firstVisibleRow firstVisibleRowBetween: gridBounds top and: gridBounds bottom]].	firstVisibleRow ifNotNil: [firstVisibleRow checkCellsWithSuccessors]</body><body package="Grid">hScrollBounds	"Answer the rectangle in which the model can be displayed--this 	is the displayBox inset by the height of a line for an item."	^0 @ 0 corner: self bounds corner</body><body package="Grid">vScrollBounds	"Answer the rectangle in which the model can be displayed--this 	is the displayBox inset by the height of a line for an item."	| box |	box := 0 @ 0 extent: self bounds extent.	box top: self topOffsetForDisplay.	^box</body></methods><methods><class-id>UI.Grid</class-id> <category>private-scrolling</category><body package="Grid">moveColumnIndex: anInteger toView: aSymbol 	"Move column index anInteger into view at preferred location aSymbol without updating the display"	| targetVisualColumn index direction |	columns isEmpty ifTrue: [^self].	index := (anInteger max: 1) min: self numberOfColumns.	targetVisualColumn := firstVisibleColumn jumpToIndex: index.	direction := aSymbol.	direction == #nearest 		ifTrue: 			[| xLeft xRight |			targetVisualColumn isFullyVisible ifTrue: [^self].			xLeft := self bounds left - targetVisualColumn left.			xRight := self bounds right - targetVisualColumn right.			direction := xLeft abs &lt; xRight abs ifTrue: [#left] ifFalse: [#right]].	direction == #left 		ifTrue: 			[scrollOffset value x: targetVisualColumn left negated.			firstVisibleColumn := targetVisualColumn rightTo: self bounds right						joining: firstVisibleColumn.			^self].	direction == #right 		ifTrue: 			[scrollOffset value 				x: (self bounds width - targetVisualColumn right min: 0).			firstVisibleColumn := targetVisualColumn leftTo: self bounds left						joining: firstVisibleColumn.			^self].	direction == #center 		ifTrue: 			[scrollOffset value 				x: ((self bounds width 						- (targetVisualColumn left + targetVisualColumn right)) // 2 						min: 0).			firstVisibleColumn := targetVisualColumn leftTo: self bounds left						joining: firstVisibleColumn.			firstVisibleColumn rightTo: self bounds right.			^self].	self 		error: (#unknownPositionName &lt;&lt; #dialogs 				&gt;&gt; 'Unknown scroll preference: &lt;1s&gt;' expandMacrosWith: aSymbol)</body><body package="Grid">moveRowIndex: anInteger toView: aSymbol 	"Move row index anInteger into view at preferred location aSymbol without updating the display"	| targetVisualRow index direction |	rows isEmpty ifTrue: [^self].	index := (anInteger max: 1) min: self numberOfRows.	targetVisualRow := self firstVisibleRow jumpToIndex: index.	direction := aSymbol.	direction == #nearest 		ifTrue: 			[| xTop xBottom |			targetVisualRow isFullyVisible ifTrue: [^self].			xTop := self bounds top - targetVisualRow top.			xBottom := self bounds bottom - targetVisualRow bottom.			direction := xTop abs &lt; xBottom abs ifTrue: [#top] ifFalse: [#bottom]].	direction == #top 		ifTrue: 			[scrollOffset value y: targetVisualRow top negated.			firstVisibleRow := targetVisualRow downTo: self bounds bottom						joining: firstVisibleRow.			^self].	direction == #bottom 		ifTrue: 			[scrollOffset value y: (self bounds height - targetVisualRow bottom min: 0).			firstVisibleRow := targetVisualRow upTo: self bounds top						joining: firstVisibleRow.			^self].	direction == #center 		ifTrue: 			[scrollOffset value 				y: ((self bounds height - (targetVisualRow top + targetVisualRow bottom)) 						// 2 min: 0).			firstVisibleRow := targetVisualRow upTo: self bounds top						joining: firstVisibleRow.			firstVisibleRow downTo: self bounds bottom.			^self].	self 		error: (#unknownPositionName &lt;&lt; #dialogs 				&gt;&gt; 'Unknown scroll preference: &lt;1s&gt;' expandMacrosWith: aSymbol)</body><body package="Grid">scrollDo: aBlock	"Perform aBlock and update scroll afterward"		| old |	old := scrollOffset value copy. 	aBlock value.		"self updateAfterScroll."	"Presumes scrollOffsetHolder has a dependency to #updateElementPositions"	scrollOffset value = old		ifFalse:			[scrollOffset changed: #value with: old.			self invalidate]</body></methods><methods><class-id>UI.Grid</class-id> <category>enumeration</category><body package="Grid">cellsDo: aBlock		self		range: self cellBounds		cellsDo: aBlock</body><body package="Grid">range: aRectangle cellsDo: aBlock 	aRectangle left to: aRectangle right		do: 			[:icol | 			aRectangle top to: aRectangle bottom				do: 					[:irow | 					| cell |					cell := self gridCellAtPoint: icol @ irow.					aBlock cull: cell cull: cell value]]</body><body package="Grid">range: aRectangle columnsDo: aBlock 	aRectangle left to: aRectangle right		do: 			[:icolumn | 			| column |			column := self columns at: icolumn.			aBlock cull: column cull: column spec]</body><body package="Grid">range: aRectangle rowsDo: aBlock 	aRectangle top to: aRectangle bottom		do: 			[:irow | 			| row |			row := self rows at: irow.			aBlock cull: row cull: row item]</body><body package="Grid">rowsDo: aBlock		self		range: self cellBounds		rowsDo: aBlock</body></methods><methods><class-id>UI.Grid</class-id> <category>private-updating</category><body package="Grid">updateColumnAppendCollection: anInteger	"Update scroll width and invalidate the visible region that intersects anInteger columns appended to the column collection"	| startIndex endIndex |	startIndex := self numberOfColumns - anInteger + 1.	endIndex := self numberOfColumns.	startIndex		to: endIndex		do:			[:index | 			| column |			column := columns at: index.			column grid: self.			self addScrollWidthFor: column].	self isOpen		ifTrue:			[self updateScrollbars.			self setVisibleColumns.			self updateRangeAndBelow: (self cellBounds left: startIndex)]</body><body package="Grid">updateColumnAt: anIndex		(columns at: anIndex) grid: self.	self resetScrollWidth.	self isOpen		ifTrue:			[self updateScrollbars.			self setVisibleColumns.			self updateRange: (anIndex @ 1 corner: anIndex @ self numberOfRows)]</body><body package="Grid">updateColumnInsert: anInteger	"Update scroll width and invalidate the visible region that intersects the column inserted to the column collection at anInteger"	| range column |	column := columns at: anInteger.	self isHeader ifFalse:[column grid: self].	self addScrollWidthFor: column.	range := anInteger @ 1 corner: self numberOfColumns @ self numberOfRows.	self		moveSelectionRange: range		to: (range translatedBy: 1 @ 0).	self setVisibleColumns.	self isOpen		ifTrue:			[self updateScrollbars.			self updateRangeAndBelow: range]</body><body package="Grid">updateColumnInsertCollection: anArray	"A collection has been inserted into the receiver's sequence. Update the display scroll and visible region changed"	"aCollection = #('index to insert before' 'total size of collection afterward')"		| startIndex insertSize range endIndex |	startIndex := anArray first.	insertSize := anArray last.	endIndex := startIndex + insertSize - 1.	startIndex		to: endIndex		do:			[:index | 			| column |			column := columns at: index.			column grid: self.			self addScrollWidthFor: column].	range := startIndex @ 1corner: self numberOfColumns @ self numberOfRows.	self		moveSelectionRange: range		to: (range translatedBy: insertSize @ 0).	(startIndex between: self firstVisibleColumn index and: self lastVisibleColumn index) ifTrue:[self setVisibleColumns].	self isOpen		ifTrue:			[self updateScrollbars.			self updateRangeAndBelow: range]</body><body package="Grid">updateColumnRemove: anInteger	"Update scroll width and invalidate the visible region that intersects the column at anInteger removed from the column collection"	| range |	self editCell 	ifNotNil: [:cell | cell isEditable ifFalse: [self dropEdit]].	self resetScrollWidth.	range := (anInteger + 1) @ 1corner: (self numberOfColumns + 1) @ self numberOfRows.	self moveSelectionRange: range 	to: (range translatedBy: -1 @ 0).	self setVisibleColumns.	self isOpen		ifTrue:[self updateScrollbars.			   self updateRangeAndBelow: (range top: anInteger)]</body><body package="Grid">updateColumnRemoveRange: anArray	"Update scroll width and invalidate the visible region that intersects the columns removed from the column collection"	| startIndex endIndex range |	startIndex := anArray first.	endIndex := anArray last.	self editCell ifNotNil: [:cell | cell isEditable ifFalse: [self dropEdit]].	self resetScrollWidth.	range := startIndex @ 1corner: self numberOfColumns @ self numberOfRows.	self moveSelectionRange: (range translatedBy: (endIndex - startIndex + 1) @ 0)		to: range.	self firstVisibleColumn		ifNotNil: 			[(startIndex &gt; self lastVisibleColumn index				or: [endIndex &lt; self firstVisibleColumn index]) ifFalse: [self setVisibleColumns]].	self isOpen		ifTrue: 			[self updateScrollbars.			self updateRangeAndBelow: range]</body><body package="Grid">updateColumnReplace: anArray	| startIndex endIndex |	startIndex := anArray first.	endIndex := anArray last.	startIndex		to: endIndex		do: [:index | (columns at: index) grid: self].	self resetScrollWidth.	self firstVisibleColumn		ifNotNil: 			[(startIndex &lt;= self firstVisibleColumn index				and: [endIndex &gt;= self lastVisibleColumn index]) ifTrue: [self setVisibleColumns]].	self isOpen		ifTrue:			[self updateScrollbars]</body><body package="Grid">updateRange: aRectangle	"Update cells and invalidate the grid within the visible cell range aRectangle"	"self setVisibleRows.	self invalidate."		| invalidationRectangle clippedRange |	clippedRange := (self visualRange intersect: aRectangle).	clippedRange extent &gt;= 0 ifFalse:[^self].	invalidationRectangle := self boundsForRange: clippedRange in: self bounds.	self setVisibleRows.	self invalidateRectangle: invalidationRectangle</body><body package="Grid">updateRangeAndBelow: aRectangle	"Update cells and invalidate the grid to its corner within the visible cell range aRectangle"	"self setVisibleRows.	self invalidate."	| invalidationRectangle clippedRange |	self columns isEmpty ifTrue: [^self].	clippedRange := self visualRange intersect: aRectangle.	clippedRange extent &gt;= 0 ifFalse: [^self].	invalidationRectangle := self bounds.	(self firstVisibleColumn atIndex: clippedRange left)		ifNotNil: [:column | invalidationRectangle left: column left].	(self firstVisibleRow atIndex: clippedRange top)		ifNotNil: [:row | invalidationRectangle top: row top].	self setVisibleRows.	self invalidateRectangle: invalidationRectangle</body><body package="Grid">updateRowAppendCollection: anInteger	"Update scroll height and invalidate the visible region that intersects anInteger rows appended to the row collection"	| startIndex endIndex |	startIndex := self numberOfRows - anInteger + 1.	endIndex := self numberOfRows.	startIndex		to: endIndex		do:			[:index | 			| row |			row := rows at: index.			row grid: self.			self addScrollHeightFor: row].	self isOpen		ifTrue:			[self updateScrollbars.			self setVisibleRows.			self updateRangeAndBelow: (self cellBounds top: startIndex)]</body><body package="Grid">updateRowAt: anIndex		(rows at: anIndex) grid: self.	self resetScrollHeight.	self isOpen		ifTrue:			[self updateScrollbars.			self setVisibleRows.			self updateRange: (1 @ anIndex corner: self numberOfColumns @ anIndex)]</body><body package="Grid">updateRowInsert: anInteger	"Update scroll height and invalidate the visible region that intersects the row inserted to the row collection at anInteger"	| range row |	row := rows at: anInteger.	row grid: self.	self addScrollHeightFor: row.	range := 1 @ anInteger corner: self numberOfColumns @ self numberOfRows.	self		moveSelectionRange: range		to: (range translatedBy: 0 @ 1).	self setVisibleRows.	self isOpen		ifTrue:			[self updateScrollbars.			self updateRangeAndBelow: range]</body><body package="Grid">updateRowInsertCollection: anArray	"A collection has been inserted into the receiver's sequence. Update the display scroll and visible region changed"	"aCollection = #('index to insert before' 'total size of collection afterward')"		| startIndex insertSize range endIndex |	startIndex := anArray first.	insertSize := anArray last.	endIndex := startIndex + insertSize - 1.	startIndex		to: endIndex		do:			[:index | 			| row |			row := rows at: index.			row grid: self.			self addScrollHeightFor: row].	range := 1 @ startIndex corner: self numberOfColumns @ self numberOfRows.	self		moveSelectionRange: range		to: (range translatedBy: 0 @ insertSize).	(startIndex between: self firstVisibleRow index and: self lastVisibleRow index) ifTrue:[self setVisibleRows].	self isOpen		ifTrue:			[self updateScrollbars.			self updateRangeAndBelow: range]</body><body package="Grid">updateRowRemove: anInteger	"Update scroll height and invalidate the visible region that intersects the row at anInteger removed from the row collection"	| range |	self editCell 	ifNotNil: [:cell | cell isEditable ifFalse: [self dropEdit]].	self resetScrollHeight.	range := 1 @ (anInteger + 1) corner: self numberOfColumns @ (self numberOfRows + 1).	self moveSelectionRange: range 	to: (range translatedBy: 0 @ -1).	self setVisibleRows.	self isOpen		ifTrue:[self updateScrollbars.			   self updateRangeAndBelow: (range top: anInteger)]</body><body package="Grid">updateRowRemoveRange: anArray	"Update scroll height and invalidate the visible region that intersects the rows removed from the row collection"	| startIndex endIndex range |	startIndex := anArray first.	endIndex := anArray last.	self editCell ifNotNil: [:cell | cell isEditable ifFalse: [self dropEdit]].	self resetScrollHeight.	range := 1 @ startIndex corner: self numberOfColumns @ self numberOfRows.	self moveSelectionRange: (range translatedBy: 0 @ (endIndex - startIndex + 1))		to: range.	self firstVisibleRow		ifNotNil: 			[(startIndex &gt; self lastVisibleRow index				or: [endIndex &lt; self firstVisibleRow index]) ifFalse: [self setVisibleRows]].	self isOpen		ifTrue: 			[self updateScrollbars.			self updateRangeAndBelow: range]</body><body package="Grid">updateRowReplace: anArray	| startIndex endIndex |	startIndex := anArray first.	endIndex := anArray last.	startIndex		to: endIndex		do: [:index | (rows at: index) grid: self].	self resetScrollHeight.	self firstVisibleRow		ifNotNil: 			[(startIndex &lt;= self firstVisibleRow index				and: [endIndex &gt;= self lastVisibleRow index]) ifTrue: [self setVisibleRows]].	self isOpen		ifTrue:			[self updateScrollbars]</body></methods><methods><class-id>UI.Grid</class-id> <category>drag and drop</category><body package="Grid">allowColumnMoveFrom: columnIndex toIndex: destIndex	^	[builder source 		perform: #allowColumnMoveFrom:toIndex:		with: columnIndex		with: destIndex] 			on: MessageNotUnderstood			do: 				[:ex | 				| sel |				sel := ex parameter selector.				sel == #allowColumnMoveFrom:toIndex: ifTrue: [ex return: true] ifFalse: [ex pass]]</body><body package="Grid">displayInsertionCueAt: anIndex	(firstVisibleRow atIndex: anIndex)		ifNotNil: 			[:visibleRow |			| y box |			box := self bounds.			y := visibleRow top.			self graphicsContext				displayLineFrom: box left @ y to: box right @ y]</body><body package="Grid">displayInsertionOrReplacementCueAt: anIndex	anIndex isInteger		ifTrue: [self displayReplacementCueAt: anIndex]		ifFalse: [self displayInsertionCueAt: anIndex ceiling]</body><body package="Grid">displayReplacementCueAt: anIndex	(firstVisibleRow atIndex: anIndex)		ifNotNil: [:visibleRow | self graphicsContext displayRectangularBorder: visibleRow bounds]</body><body package="Grid">eraseInsertionCueAt: anIndex	(firstVisibleRow atIndex: anIndex)		ifNotNil: 			[:visibleRow |			| y box |			box := self bounds.			y := visibleRow top.			self				invalidateRectangle: (box left @ (y - 1) corner: box right @ (y + 1))				repairNow: true]</body><body package="Grid">eraseInsertionOrReplacementCueAt: anIndex	anIndex isInteger		ifTrue: [self eraseReplacementCueAt: anIndex]		ifFalse: [self eraseInsertionCueAt: anIndex ceiling]</body><body package="Grid">eraseReplacementCueAt: anIndex	(firstVisibleRow atIndex: anIndex)		ifNotNil: [:visibleRow | self invalidateRectangle: visibleRow bounds repairNow: true]</body><body package="Grid">insertionIndexFor: aPoint 	"Answer an index for insertion between the indicies of the two elements closest to the drop point aPoint in increments of (1/2), so for N elements the answer will range between (1/2) and N+(1/2)."	^((self controller findElementFor: aPoint) min: self numberOfRows) + (1/2)</body><body package="Grid">insertionOrReplacementIndexFor: aPoint	"Answer the insert/replace index at the argument point. 	If the answer is an integer, it is a replacement index. 	If the answer is not an integer, it is an insertion index between elements."	| topMargin bottomMargin index row y |	row := firstVisibleRow atPosition: aPoint.	topMargin := row top + (row height / 4).	bottomMargin := row top +  (row height * 3 / 4).	y := aPoint y.	index := y &lt; topMargin				ifTrue: [row index - (1 / 2)]				ifFalse: 					[y &lt; bottomMargin ifTrue: [row index] ifFalse: [row index + (1 / 2)]].	^index min: self numberOfRows</body><body package="Grid">replacementIndexFor: aPoint	"Answer the index for replacement if dropped at the argument aPoint. Replacement is assumed to occur at anIndex, so for N elements the range is between 1 and N+1."	^((self controller findElementFor: aPoint) min: self numberOfRows) + 1</body><body package="Grid">showDropFeedbackIn: aDragContext allowScrolling: scrollBoolean 	"Show a default form of drop feedback by moving the target index indication.	If scrollBoolean is true, allow the receiver to be scrolled so that a target can	be chosen from those elements not currently visible. If scrollBoolean is false,	track the mouse with the target index but do not scroll the receiver. 	aDragContext contains the data for the drag. This implementation does not	use the drag context because it assumes that the drop target application has	verified that a drop can occur in the receiver.		If a different form of indication is required, this method can be changed or	overridden, or the drop target application can produce the desired indication."	| ctrl index topY bottomY fullBounds maxY scrollDelay |	scrollDelay := Delay forMilliseconds: 25.	"Determine where the target index should end up"	ctrl := self controller.	index := ctrl findElementFor: ctrl sensor cursorPoint.	index = 0 		ifTrue: 			[index := self numberOfRows.			index = 0 ifTrue: [^self]].	"Compute the bounds of the widget for (possible) scrolling"	topY := self bounds top.	bottomY := self bounds bottom.	fullBounds := super bounds.	"these bounds include possibly clipped last line"	maxY := bottomY max: fullBounds height + topY.	scrollBoolean 		ifTrue: 			["While the mouse is pressed and the cursor is within a narrow region 	at the bottom of the list, scroll the target index down (if scrollBoolean is true)."						[ctrl sensor anyButtonPressed 				and: [ctrl sensor cursorPoint y between: bottomY - 5 and: maxY]] 					whileTrue: 						[index := index + 1 min: self numberOfRows.						self useTargetIndex: index.						topY := self bounds top.						bottomY := self bounds bottom.						maxY := bottomY max: fullBounds height + topY.						scrollDelay wait].			"While the mouse is pressed and the cursor is within a narrow region 	at the top of the list, scroll the target index up (if scrollBoolean is true)."						[ctrl sensor anyButtonPressed 				and: [ctrl sensor cursorPoint y between: topY and: topY + 5]] 					whileTrue: 						[index := index - 1 max: 1.						self useTargetIndex: index.						topY := self bounds top.						scrollDelay wait]].	"Target the final index"	targetIndex := index</body><body package="Grid">showInsertDropFeedbackIn: aDragContext allowScrolling: scrollBoolean 	| ctrl topY bottomY fullBounds maxY lastTargetIndex scrollDelay |	scrollDelay := Delay forMilliseconds: 25.	"Determine where the target index should end up"	ctrl := self controller.	lastTargetIndex := targetIndex.	targetIndex := self insertionIndexFor: ctrl sensor cursorPoint.	"Erase former drop cue, if any"	(lastTargetIndex isNil or: [lastTargetIndex = targetIndex]) 		ifFalse: [self eraseInsertionCueAt: lastTargetIndex].	"Compute the bounds of the widget for (possible) scrolling"	topY := self bounds top.	bottomY := self bounds bottom.	fullBounds := super bounds.	"these bounds include possibly clipped last line"	maxY := bottomY max: fullBounds height + topY.		scrollBoolean 		ifTrue: 			["While the mouse is pressed and the cursor is within a narrow region 	at the bottom of the list, scroll the target index down (if scrollBoolean is true)."[ctrl sensor anyButtonPressed 				and: [ctrl sensor cursorPoint y between: bottomY - 5 and: maxY]] whileTrue: 					[targetIndex := targetIndex + 1 min: self numberOfRows + (1 / 2).					self makeVisible: targetIndex ceiling.					topY := self bounds top.					bottomY := self bounds bottom.					maxY := bottomY max: fullBounds height + topY.					scrollDelay wait].			"While the mouse is pressed and the cursor is within a narrow region 	at the top of the list, scroll the target index up (if scrollBoolean is true)."			[ctrl sensor anyButtonPressed 				and: [ctrl sensor cursorPoint y between: topY and: topY + 5]] whileTrue: 					[targetIndex := targetIndex - 1 max: 1.					self makeVisible: targetIndex ceiling.					topY := self bounds top.					scrollDelay wait]].	lastTargetIndex = targetIndex 		ifFalse: [self displayInsertionCueAt: targetIndex]</body><body package="Grid">showInsertReplaceDropFeedbackIn: aDragContext allowScrolling: scrollBoolean 	"Show a default form of drop feedback by moving the target index indication.	If scrollBoolean is true, allow the receiver to be scrolled so that a target can	be chosen from those elements not currently visible. If scrollBoolean is false,	track the mouse with the target index but do not scroll the receiver. 	aDragContext contains the data for the drag. This implementation does not	use the drag context because it assumes that the drop target application has	verified that a drop can occur in the receiver.		If a different form of indication is required, this method can be changed or	overridden, or the drop target application can produce the desired indication."	| ctrl topY bottomY fullBounds maxY lastTargetIndex scrollDelay |	scrollDelay := Delay forMilliseconds: 25.	"Determine where the target index should end up"	ctrl := self controller.	lastTargetIndex := targetIndex.	targetIndex := self insertionOrReplacementIndexFor: ctrl sensor cursorPoint.	"Erase former drop cue, if any"	(lastTargetIndex isNil or: [lastTargetIndex = targetIndex]) 		ifFalse: [self eraseInsertionOrReplacementCueAt: lastTargetIndex].	"Compute the bounds of the widget for (possible) scrolling"	topY := self bounds top.	bottomY := self bounds bottom.	fullBounds := super bounds.	"these bounds include possibly clipped last line"	maxY := bottomY max: fullBounds height + topY.	scrollBoolean 		ifTrue: 			["While the mouse is pressed and the cursor is within a narrow region 	at the bottom of the list, scroll the target index down (if scrollBoolean is true)."						[ctrl sensor anyButtonPressed 				and: [ctrl sensor cursorPoint y between: bottomY - 5 and: maxY]] 					whileTrue: 						[targetIndex := targetIndex + 1 min: self numberOfRows + (1 / 2).						self makeVisible: targetIndex.						bottomY := self bounds bottom.						maxY := bottomY max: fullBounds height + topY.						scrollDelay wait].			"While the mouse is pressed and the cursor is within a narrow region 	at the top of the list, scroll the target targetIndex up (if scrollBoolean is true)."						[ctrl sensor anyButtonPressed 				and: [ctrl sensor cursorPoint y between: topY and: topY + 5]] 					whileTrue: 						[targetIndex := targetIndex - 1 max: 1.						self makeVisible: targetIndex.						topY := self bounds top.						scrollDelay wait]].	lastTargetIndex = targetIndex 		ifFalse: [self displayInsertionOrReplacementCueAt: targetIndex]</body><body package="Grid">showReplaceDropFeedbackIn: aDragContext allowScrolling: scrollBoolean 	"Determine where the target index should end up"	| ctrl topY bottomY fullBounds maxY lastTargetIndex scrollDelay |	scrollDelay := Delay forMilliseconds: 25.	ctrl := self controller.	lastTargetIndex := targetIndex.	targetIndex := self replacementIndexFor: ctrl sensor cursorPoint.	targetIndex = 0 ifTrue: [^self].	"Erase former drop cue, if any"	(lastTargetIndex isNil or: [lastTargetIndex = targetIndex]) 		ifFalse: [self eraseReplacementCueAt: lastTargetIndex].	"Compute the bounds of the widget for (possible) scrolling"	topY := self bounds top.	bottomY := self bounds bottom.	fullBounds := super bounds.	"these bounds include possibly clipped last line"	maxY := bottomY max: fullBounds height + topY.	scrollBoolean 		ifTrue: 			[| nextIndex |			nextIndex := targetIndex.			"While the mouse is pressed and the cursor is within a narrow region 	at the bottom of the list, scroll the target index down (if scrollBoolean is true)."						[ctrl sensor anyButtonPressed 				and: [ctrl sensor cursorPoint y between: bottomY - 5 and: maxY]] 					whileTrue: 						[nextIndex := nextIndex + 1 min: self numberOfRows.						self makeVisible: nextIndex.						topY := self bounds top.						bottomY := self bounds bottom.						maxY := bottomY max: fullBounds height + topY.						scrollDelay wait].			"While the mouse is pressed and the cursor is within a narrow region 	at the top of the list, scroll the target index up (if scrollBoolean is true)."						[ctrl sensor anyButtonPressed 				and: [ctrl sensor cursorPoint y between: topY and: topY + 5]] 					whileTrue: 						[nextIndex := nextIndex - 1 max: 1.						self makeVisible: nextIndex.						topY := self bounds top.						scrollDelay wait].			targetIndex := nextIndex].	lastTargetIndex = targetIndex 		ifFalse: [self displayReplacementCueAt: targetIndex]</body></methods><methods><class-id>UI.Grid</class-id> <category>private-rows and columns</category><body package="Grid">addScrollHeightFor: aGridRow 	scrollableExtent := scrollableExtent + (0 @ aGridRow heightWithGap)</body><body package="Grid">addScrollWidthFor: aGridColumn 	scrollableExtent := scrollableExtent + (aGridColumn widthWithGap @ 0)</body><body package="Grid">remove: aSpecWrapper 	^(self contains: aSpecWrapper) 		ifTrue: 			[aSpecWrapper widget controller removeFromKeyboard.			super remove: aSpecWrapper]		ifFalse: [nil]</body><body package="Grid">removeScrollHeightFor: aRow 	scrollableExtent := scrollableExtent - (0 @ aRow heightWithGap)</body><body package="Grid">removeScrollWidthFor: aColumn 	scrollableExtent := scrollableExtent - (aColumn widthWithGap @ 0)</body></methods><methods><class-id>UI.Grid</class-id> <category>focus accessing</category><body package="Grid">hasFocus	"| editor |	^(editor := self editor) notNil and:[editor widgetState hasKeyboardFocus]"	^state hasKeyboardFocus</body><body package="Grid">hasFocus: aBoolean	state hasKeyboardFocus == aBoolean ifTrue: [^self].	self triggerEvent: (aBoolean ifTrue: [#gettingFocus] ifFalse: [#losingFocus]).	state hasKeyboardFocus: aBoolean</body><body package="Grid">takeFocus	self hasFocus: true</body></methods><methods><class-id>UI.Grid</class-id> <category>event driven</category><body package="Grid">componentForMouseEvent: aMouseEvent	components do: 			[:each |			(each handlerForMouseEvent: aMouseEvent)				ifNotNil: [:component | ^component]].	^nil</body><body package="Grid">handlerForMouseEvent: aMouseEvent	"Allow the Grid to intervene on mouse select events"	(self isEnabled		and: [controller viewHasCursorWithEvent: aMouseEvent])			ifFalse: [^nil].	^(aMouseEvent isButtonPressedEvent and:[aMouseEvent isRed])				ifTrue: [controller]				ifFalse: [super handlerForMouseEvent: aMouseEvent].</body></methods><methods><class-id>UI.Grid</class-id> <category>sorting</category><body package="Grid">sortUsing: aBlock	| selectedElements |	selectedElements := self selectedGridElements.	self initializeSelectionChannel.	self valueWithoutRowsUpdate: 			[SequenceableCollectionSorter sort: rows				using: aBlock].	self selectedGridElements: selectedElements.	self setVisibleRows.	self invalidate</body></methods><methods><class-id>UI.Grid</class-id> <category>private-coordinate translations</category><body package="Grid">boundsForRange: aRectangle in: clippingBounds	"Answer the pane bounds of cell coordinates aRectangle bound by clippingBounds"	| left top right bottom |	self firstVisibleRow ifNil: [^clippingBounds extent: 0 @ 0].	(self firstVisibleRow index &gt; aRectangle bottom or: 			[self lastVisibleRow index &lt; aRectangle top or: 					[self firstVisibleColumn index &gt; aRectangle right						or: [self lastVisibleColumn index &lt; aRectangle left]]])		ifTrue: [^clippingBounds extent: 0 @ 0].	left := (firstVisibleColumn atIndex: aRectangle left)				ifNil: [clippingBounds left]				ifNotNil: [:column | column left].	top := (self firstVisibleRow atIndex: aRectangle top)				ifNil: [clippingBounds top]				ifNotNil: [:row | row top].	right := (firstVisibleColumn atIndex: aRectangle right)				ifNil: [clippingBounds right]				ifNotNil: [:column | column right].	bottom := (self firstVisibleRow atIndex: aRectangle bottom)				ifNil: [clippingBounds bottom]				ifNotNil: [:row | row bottom].	^left @ top corner: right @ bottom</body><body package="Grid">cellAtCursor: cursorPoint ifNone: aBlock 	"Answer the cell visible at cursor position aPoint. Evaluate aBlock if aPoint is outside any visible cell"	| containingRow containingCell |	containingRow := (firstVisibleRow atPosition: cursorPoint y) ifNil: [^aBlock value].	containingCell := containingRow cells detect: 					[:cell | 					| containingColumn |					containingColumn := cell visualColumn.					cursorPoint x between: containingColumn left and: containingColumn right]				ifNone: aBlock.	^containingCell</body></methods><methods><class-id>UI.Grid class</class-id> <category>private-events</category><body package="Grid">constructEventsTriggered	^super constructEventsTriggered		remove: #changed;		remove: #changing;		add: #tabbed;		add: #backTabbed;		add: #gettingFocus;		add: #losingFocus;		add: #selectionChanging;		add: #selectionChanged;		add: #selectionListChanged;		add: #popupMenuCreated;		add: #popupMenuItemSelected:;		yourself</body></methods><methods><class-id>UI.Grid class</class-id> <category>instance creation</category><body package="Grid">forHeaderColumn: aGridHeaderColumn and: aScrollWrapper	^self new		addColumn: aGridHeaderColumn;		useRows: aScrollWrapper component rows;		scrollOffsetHolder: aScrollWrapper scrollOffsetHolder;		yourself</body><body package="Grid">forHeaderRow: aGridHeaderRow and: aScrollWrapper	| gridBody |	gridBody := aScrollWrapper component.	^self new		addRow: aGridHeaderRow;		useColumns: gridBody columns;		scrollOffsetHolder: aScrollWrapper scrollOffsetHolder;		allowColumnReordering: gridBody allowColumnReordering;		allowSorting: gridBody allowSorting;		yourself</body></methods><methods><class-id>UI.GridColumn</class-id> <category>adding</category><body package="Grid">addToGrid: aGrid 	aGrid addColumn: self</body></methods><methods><class-id>UI.GridColumn</class-id> <category>testing</category><body package="Grid">allowResizing	^allowResizing</body><body package="Grid">allowResizing: aBoolean	allowResizing := aBoolean</body><body package="Grid">allowSorting	^allowSorting and: [(grid ifNil: [true] ifNotNil: [grid allowSorting]) and:[self specAllowsSorting]]</body><body package="Grid">allowSorting: aBoolean	allowSorting := aBoolean</body><body package="Grid">canEdit	^spec notNil and:[spec initiallyEnabled]</body><body package="Grid">isHeader	^false</body><body package="Grid">isSelected	^grid ifNil: [false]		ifNotNil: 			[| index |			grid selectionRange isEmpty ifTrue: [^false].			index := self index.			grid selectionRange 				contains: [:range | index between: range left and: range right]]</body><body package="Grid">isValid	^self index notNil</body></methods><methods><class-id>UI.GridColumn</class-id> <category>sorting</category><body package="Grid">clearSortDirection	"Avoid updates if aleady clear"	self sortDirection ifNotNil: [self sortDirection: nil]</body><body package="Grid">sortDirectionToggled	^self allowSorting 		ifTrue: [self sortConstraint sortDirectionToggled]		ifFalse: [nil]</body></methods><methods><class-id>UI.GridColumn</class-id> <category>accessing</category><body package="Grid">defaultHeight	^defaultHeight</body><body package="Grid">defaultHeight: aNumber	defaultHeight := aNumber</body><body package="Grid">enabled	^spec initiallyEnabled</body><body package="Grid">enabled: aBoolean 	spec initiallyDisabled: aBoolean not.	grid ifNotNil: 			[grid visualForColumn: self do: [:visual | visual isEnabled: aBoolean]]</body><body package="Grid">grid	^grid</body><body package="Grid">grid: aGrid	self removeDependent: grid.	grid := aGrid.	self addDependent: aGrid.</body><body package="Grid">id	^id</body><body package="Grid">id: aSymbol	id := aSymbol</body><body package="Grid">index	^grid ifNotNil: [grid columns indexOf: self ifAbsent: nil]</body><body package="Grid">label	^label</body><body package="Grid">label: aStringOrComposedText	label := aStringOrComposedText</body><body package="Grid">showColumnLine	^showColumnLine</body><body package="Grid">showColumnLine: aBoolean	showColumnLine := aBoolean</body><body package="Grid">sortConstraint	sortConstraint ifNil: 			[sortConstraint := GridColumnSortConstraint on: self.			self converter ifNotNil: 					[:converter | 					sortConstraint printAdaptor: [:value | converter printStringFor: value]]].	^sortConstraint</body><body package="Grid">sortDirection	^self sortConstraint sortDirection</body><body package="Grid">sortDirection: aSymbolOrNil 	self sortDirection == aSymbolOrNil 		ifFalse: 			[self sortConstraint sortDirection: aSymbolOrNil.			self changed: #sortDirection]</body><body package="Grid">spec	^spec</body><body package="Grid">spec: aWidgetSpec	spec := aWidgetSpec</body><body package="Grid">width	^width</body><body package="Grid">width: anInteger 	width = anInteger 		ifFalse: 			[ | delta |			delta := anInteger - self width.			width := anInteger.			self changed: #updateColumnWidth: with: delta]</body><body package="Grid">widthWithGap	^self width + self paddingLeft + self paddingRight</body></methods><methods><class-id>UI.GridColumn</class-id> <category>constants</category><body package="Grid">defaultWidth	^20</body><body package="Grid">minimumDefaultRowHeight	^10</body><body package="Grid">paddingLeft	^1 + (showColumnLine ifTrue:[1] ifFalse:[0])</body><body package="Grid">paddingRight	^1</body></methods><methods><class-id>UI.GridColumn</class-id> <category>builder access</category><body package="Grid">adaptor	^spec ifNotNil:[spec modelInBuilder: grid builder]</body><body package="Grid">converter	^spec ifNotNil:[spec converterWith: grid builder]</body><body package="Grid">postBuildCell: aGridVisualCell with: aUIBuilder	"This message is sent by the Grid builder when it has completed work on 	a complete cell component"</body><body package="Grid">specForCell: aGridVisualCell 	"The receiver is given a chance to prepare the spec for the component that will be built by aGridVisualCell by means of its Grid's builder"	^spec copy</body></methods><methods><class-id>UI.GridColumn</class-id> <category>printing</category><body package="Grid">printOn: aStream 	aStream		nextPutAll: self class name;		nextPutAll: ' on: '.	spec printOn: aStream</body></methods><methods><class-id>UI.GridColumn</class-id> <category>initialize-release</category><body package="Grid">initialize	showColumnLine := allowResizing := allowSorting := true.	defaultHeight := self minimumDefaultRowHeight.	width := self defaultWidth.</body><body package="Grid">release	super release.	grid := nil.</body><body package="Grid">spec: aWidgetSpec in: aGrid width: anInteger label: aStringOrComposedText	width := anInteger.	spec := aWidgetSpec.	grid := aGrid.	label := aStringOrComposedText.	grid ifNotNil: [grid addColumn: self]</body></methods><methods><class-id>UI.GridColumn</class-id> <category>enumerating</category><body package="Grid">rowsDo: aBlock 	grid ifNotNil: 			[grid rows 				do: [:each | aBlock value: each value: (GridCell column: self row: each) value]]</body></methods><methods><class-id>UI.GridColumn</class-id> <category>scrolling</category><body package="Grid">scrollToView	self scrollToView: #nearest</body><body package="Grid">scrollToView: aSymbol	"Scroll the Grid pane to make the receiver visible in the preferred position aSymbol.  Possible values are #right, #left, #center, or #nearest (scroll the minimum distance to make the receiver fully visible at any border)"		grid		ifNotNil:			[grid				scrollColumnIndex: self index				toView: aSymbol]</body></methods><methods><class-id>UI.GridColumn</class-id> <category>private</category><body package="Grid">literalArrayEncoding	| omitted class default array |	omitted := #('grid' 'sortConstraint' 'dependents' 'gridBody').	class := self class.	default := class new.	array := OrderedCollection with: class fullyQualifiedReference.	class allInstVarNames keysAndValuesDo: 			[:i :name | 			| value |			value := self instVarAt: i.			((omitted includes: name) or: [value == (default instVarAt: i)]) 				ifFalse: 					[array add: (name , ':') asSymbol.					array add: value literalArrayEncoding]].	self sortDirection ifNotNil: 			[:value | 			array add: #sortDirection:.			array add: value].	^array asArray</body><body package="Grid">specAllowsSorting	^((Array with: CheckBoxSpec with: RadioButtonSpec) includes: spec class) not</body><body package="Grid">updateWidthAndScroll: anInteger 	grid updateScrollWidthBy: anInteger - self width.	width := anInteger</body></methods><methods><class-id>UI.GridColumn</class-id> <category>selection</category><body package="Grid">isSelected: aBoolean	grid 		ifNotNil: [grid columnAt: self index beSelected: aBoolean]</body></methods><methods><class-id>UI.GridColumn</class-id> <category>keyboard dispatching</category><body package="Grid">insertKeyboardFocusInterestTo: aView for: aGridController	"Setup all of the UICallbacks for the Grid columns.  Also install the keyboard hooks needed for keyboard traversal"	| widgetController |	widgetController := aView controller.	(widgetController respondsTo: #tabBlock:) 		ifTrue: [widgetController tabBlock: [:ev | aGridController processEditorShortcutKey: ev]].	(widgetController respondsTo: #keyboardHook:) 		ifTrue: 			[widgetController 				keyboardHook: [:ev :c | aGridController processEditorShortcutKey: ev]]</body></methods><methods><class-id>UI.GridColumn</class-id> <category>removing</category><body package="Grid">remove	grid ifNotNil:[grid removeColumn: self].	grid := nil.</body></methods><methods><class-id>UI.GridColumn class</class-id> <category>private</category><body package="Grid">decodeFromLiteralArray: anArray	| gridColumn |	gridColumn := self new.	2 to: anArray size by: 2 do:		[:index |		gridColumn perform: (anArray at: index) with: (anArray at: index + 1) decodeAsLiteralArray].	^gridColumn</body></methods><methods><class-id>UI.GridColumn class</class-id> <category>instance creation</category><body package="Grid">new	^super new initialize.</body><body package="Grid">spec: aWidgetSpec 	^self new spec: aWidgetSpec</body><body package="Grid">spec: aWidgetSpec in: aGrid width: anInteger	^self new spec: aWidgetSpec in: aGrid width: anInteger label: nil</body><body package="Grid">spec: aWidgetSpec in: aGrid width: anInteger label: aStringOrComposedText	^self new spec: aWidgetSpec in: aGrid width: anInteger label: aStringOrComposedText</body><body package="Grid">spec: aWidgetSpec width: anInteger	^self new spec: aWidgetSpec in: nil width: anInteger label: nil</body></methods><methods><class-id>UI.GridHeaderColumn</class-id> <category>testing</category><body package="Grid">allowSorting	^false</body><body package="Grid">isHeader	^true</body></methods><methods><class-id>UI.GridHeaderColumn</class-id> <category>accessing</category><body package="Grid">grid: aGrid 	grid := aGrid.</body><body package="Grid">gridBody	^gridBody ifNil:[self grid]</body><body package="Grid">gridBody: aGrid	gridBody := aGrid</body><body package="Grid">label	^String new</body><body package="Grid">lineNumbers	^lineNumbers</body><body package="Grid">lineNumbers: aBoolean	lineNumbers := aBoolean</body><body package="Grid">offset	^offset</body><body package="Grid">offset: aNumber	offset := aNumber</body><body package="Grid">sortDirection	"Header columns are not sortable"	^nil</body></methods><methods><class-id>UI.GridHeaderColumn</class-id> <category>builder access</category><body package="Grid">labelForCell: aGridVisualCell	^lineNumbers		ifTrue: 			[(aGridVisualCell visualRow index + offset) printString asComposedText]		ifFalse: [nil]</body><body package="Grid">postBuildCell: aGridVisualCell with: aUIBuilder	| widget row |	row := aGridVisualCell visualRow row.	row isHeader ifTrue: [^self].	widget := aGridVisualCell component widget.	widget model: ((PluggableAdaptor on: row)				getBlock: [:m | m isSelected]				putBlock: 					[:m :v |					v == MessageNotUnderstood						ifFalse: 							[self selectCellsFor: aGridVisualCell widget: widget]]				updateBlock: [:m :a :p | false])</body><body package="Grid">specForCell: aGridVisualCell 	^ActionButtonSpec new		hasCharacterOrientedLabel: false;		label: (self labelForCell: aGridVisualCell);		yourself.</body></methods><methods><class-id>UI.GridHeaderColumn</class-id> <category>initialize-release</category><body package="Grid">initialize	super initialize.	lineNumbers := false.	offset := 0.</body></methods><methods><class-id>UI.GridHeaderColumn</class-id> <category>private</category><body package="Grid">select: selected grid: aGrid at: cellPoint sensor: sensor	"Single and sweep select row at cellPoint in aGrid"	| selectRange controller |	controller := aGrid controller.	sensor shiftDown		ifTrue: 			[controller sweepSelectToTarget: (cellPoint x: aGrid numberOfColumns).			controller valueChange.			^self].	selectRange := cellPoint corner: aGrid numberOfColumns @ cellPoint y.	sensor ctrlDown		ifTrue: 			[aGrid range: selectRange beSelected: selected not.			controller valueChange.			^self].	aGrid resetSelections.	(selected and: [controller sweepOrigin = cellPoint])		ifFalse: [aGrid addSelectionRange: selectRange].	controller targetPoint: cellPoint.	controller sweepOrigin: cellPoint.	controller valueChange</body><body package="Grid">selectCellsFor: aGridVisualCell widget: widget	"Row button single and sweep select action definition"	| cellPoint sensor selected |	cellPoint := aGridVisualCell cellPoint.	sensor := widget controller sensor.	selected := aGridVisualCell isSelected.	grid = self gridBody		ifTrue: 			[grid controller requestValueChange ifFalse: [^self].			self select: selected grid: grid at: cellPoint sensor: sensor.			grid invalidate]		ifFalse: 			[(grid controller requestValueChange				and: [self gridBody controller requestValueChange]) ifFalse: [^self].			self select: selected grid: grid at: cellPoint sensor: sensor. 			self select: selected grid: self gridBody at: cellPoint sensor: sensor.			grid invalidate.			self gridBody invalidate]</body></methods><methods><class-id>UI.GridHeaderColumn</class-id> <category>keboard dispatching</category><body package="Grid">insertKeyboardFocusInterestTo: aView for: aGridController	"Setup all of the UICallbacks for the Grid header column.  Also install the keyboard hooks needed for keyboard traversal"	| widgetController |	widgetController := aView controller.	(widgetController respondsTo: #tabBlock:)		ifTrue: 			[widgetController				tabBlock: [:ev | self gridBody controller processEditorShortcutKey: ev]].	(widgetController respondsTo: #keyboardHook:)		ifTrue: 			[widgetController				keyboardHook: [:ev :c | self gridBody controller processEditorShortcutKey: ev]]</body></methods><methods><class-id>UI.GridColumnHeaderAgent</class-id> <category>interaction</category><body package="Grid">selectUpAt: aPoint	buttonController selectUpAt: aPoint</body></methods><methods><class-id>UI.GridColumnHeaderAgent</class-id> <category>initialize-release</category><body package="Grid">controller: aController	super controller: aController view grid controller.	buttonController := aController</body></methods><methods><class-id>UI.GridColumnHeaderAgent</class-id> <category>accessing</category><body package="Grid">column	^buttonController model subject</body></methods><methods><class-id>UI.GridColumnHeaderView</class-id> <category>private</category><body package="Grid">ascending	^self class ascendingImage</body><body package="Grid">descending	^self class descendingImage</body><body package="Grid">getBorder	^GridHeaderBorder width: 1</body><body package="Grid">getReferenceValue	^[self column sortDirectionToggled] on: MessageNotUnderstood do:[:ex| ex return: MessageNotUnderstood]</body><body package="Grid">redisplayFocusChange	"Do not redisplay the receiver because of a change in keyboard focus."</body><body package="Grid">redisplayForTransitionChange	"Redisplay the receiver during a transition between being pressed/unpressed."	self invalidate</body></methods><methods><class-id>UI.GridColumnHeaderView</class-id> <category>accessing</category><body package="Grid">column	^model subject</body><body package="Grid">grid	^self container container container</body></methods><methods><class-id>UI.GridColumnHeaderView</class-id> <category>controller accessing</category><body package="Grid">defaultControllerClass	^GridColumnHeaderController</body></methods><methods><class-id>UI.GridColumnHeaderView</class-id> <category>displaying</category><body package="Grid">displayLabelOn: aGraphicsContext in: aRectangle	"Display the label visual on aGraphicsContext centered in aRectangle"	label ifNil: [^self].	self setPaintOn: aGraphicsContext.	label displayOn: aGraphicsContext		at: aRectangle center - (label bounds extent // 2)</body><body package="Grid">displayOn: aGraphicsContext 	| box |	box := self bounds.	self getBorder ifNotNil: 			[:border | 			border 				displayOn: aGraphicsContext				forDisplayBox: box				using: self.			box := border insetDisplayBoxFor: box].	self displayBackgroundIfNeededOn: aGraphicsContext in: box.	self displayLabelOn: aGraphicsContext in: box.	model value ifNotNil: 			[:sortDirection | 						[self displaySortArrowImage: (self perform: sortDirection)				on: aGraphicsContext] 					on: MessageNotUnderstood					do: [:ex | ex return]]</body><body package="Grid">displaySortArrowImage: anImage on: aGraphicsContext	| bounds imageExtent |	self column allowSorting ifFalse:[^self].	bounds := self bounds.	imageExtent := self class descendingImage extent.	anImage		displayOn: aGraphicsContext		at: (bounds right - imageExtent x - 5)@(bounds center y - (imageExtent y // 2))</body></methods><methods><class-id>UI.GridColumnHeaderView</class-id> <category>display box accessing</category><body package="Grid">preferredBounds	"Answer the rectangle of the preferredBounds for the receiver"	| labelExtent imageExtent |	labelExtent := label preferredBounds extent.	imageExtent := self class descendingImage extent.	^Rectangle origin: 0 @ 0		corner: (imageExtent x + labelExtent x + 6) 				@ (imageExtent y max: labelExtent y) + (2 @ 2)</body></methods><methods><class-id>UI.GridColumnHeaderView</class-id> <category>initialize-release</category><body package="Grid">release	model release.	super release.</body></methods><methods><class-id>UI.GridColumnHeaderView</class-id> <category>updating</category><body package="Grid">update: aspectSymbol with: parameter from: sender 	"Some aspect of the model has changed."	aspectSymbol == #value 		ifTrue: [sender == model ifTrue: [self redisplayForTransitionChange]].	^super 		update: aspectSymbol		with: parameter		from: sender</body></methods><methods><class-id>UI.GridColumnHeaderView</class-id> <category>private-visual properties</category><body package="Grid">specificShadowColor	^SymbolicPaint buttonShadow</body></methods><methods><class-id>UI.GridColumnHeaderView class</class-id> <category>accessing</category><body package="Grid">ascendingImage	ascendingImage ifNil: [ascendingImage := self privateAscendingImage].	^ascendingImage</body><body package="Grid">descendingImage	descendingImage ifNil: [descendingImage := self privateDescendingImage].	^descendingImage</body><body package="Grid">privateAscendingImage	^OpaqueImage figure: self sortAscendingIndicatorImage shape: self sortAscendingIndicatorMask</body><body package="Grid">privateDescendingImage	^OpaqueImage figure: self sortDescendingIndicatorImage shape: self sortDescendingIndicatorMask</body></methods><methods><class-id>UI.SelectionInGrid</class-id> <category>accessing</category><body package="Grid">list	"Answer the receiver's SequencableCollection."	^listHolder value</body><body package="Grid">list: aSequenceableCollection	"Set the receiver's aSequenceableCollection."	listHolder value: aSequenceableCollection</body><body package="Grid">listHolder	"Answer the ListHolder."	^listHolder</body><body package="Grid">listHolder: aValueModel	"Set the listHolder"	listHolder removeDependent: self.	listHolder := aValueModel.	listHolder addDependent: self</body><body package="Grid">selectionRange	^selectionRangeHolder value</body><body package="Grid">selectionRangeHolder	"Answer the selectionRangeHolder"	^selectionRangeHolder</body><body package="Grid">selectionRangeHolder: aValueModel	"Set the selectionRangeHolder"	selectionRangeHolder removeDependent: self.	selectionRangeHolder := aValueModel.	selectionRangeHolder addDependent: self</body><body package="Grid">selections	"Answer the set of cell values or row items selected depending on the select mode for the grid"	| grid |	self list isEmpty ifTrue:[^Set new].	grid := self list first grid.	^grid selectByCell		ifTrue: [grid selectedGridElements collect: [:cell | cell value]]		ifFalse: [grid selectedGridElements collect: [:row | row item]]</body></methods><methods><class-id>UI.SelectionInGrid</class-id> <category>initialize-release</category><body package="Grid">initialize	self listHolder:  List new asValue.	self selectionRangeHolder: Set new asValue</body></methods><methods><class-id>UI.SelectionInGrid</class-id> <category>utility</category><body package="Grid">clearAll	selectionRangeHolder value: selectionRangeHolder value species new</body><body package="Grid">refreshList: newList 	self notYetImplemented</body><body package="Grid">selectAll	self list isEmpty ifTrue: [^self].	selectionRangeHolder		value: (selectionRangeHolder value species with: (1 @ 1						corner: self list first grid numberOfColumns @ self list size))</body><body package="Grid">setList: newList selecting: aCollection	"Replace the list of the receiver with newList and make aCollection its new selection set.  Scroll the list widget so that the first visible selection matching any in aCollection during this transition appears stationary. If there is no matching selection in aCollection then scroll to make the aCollection's first selection visible in its place.  Finally, if newList has fewer items scroll the list widget back as needed so that at least one list item (e.g. the last) remains visible"		self notYetImplemented</body></methods><methods><class-id>UI.SelectionInGrid</class-id> <category>private</category><body package="Grid">range: aRectangle cellsDo: aBlock	aRectangle left to: aRectangle right		do: 			[:icol |			self range: aRectangle				rowsDo: 					[:gridRow :row |					| cell |					cell := GridCell column: (gridRow grid columns at: icol) row: gridRow.					aBlock cull: cell cull: cell value]]</body><body package="Grid">range: aRectangle rowsDo: aBlock 	aRectangle top to: aRectangle bottom		do: 			[:irow | 			| row |			row := self list at: irow.			aBlock cull: row cull: row item]</body></methods><methods><class-id>UI.SelectionInGrid</class-id> <category>selections in list</category><body package="Grid">selectionCellsDo: aBlock	"Evaluate the block passing it the receiver's cells selection as the argument.	Do not evaluate the block if there is no selection."	self selectionRange do: [:range | self range: range cellsDo: aBlock]</body><body package="Grid">selectionDo: aBlock	self selectionRowsDo: aBlock</body><body package="Grid">selectionRowsDo: aBlock	"Evaluate the block passing it the receiver's rows selection as the argument.	Do not evaluate the block if there is no selection."	self selectionRange do: [:range | self range: range rowsDo: aBlock]</body></methods><methods><class-id>UI.SelectionInGrid class</class-id> <category>instance creation</category><body package="Grid">new	^super new initialize</body></methods><methods><class-id>UI.GridController</class-id> <category>private</category><body package="Grid">columnResizeCursor	^ResizingSplitterController leftRightCursor</body><body package="Grid">doubleClickAt: mousePoint	"Handle entry callbacks, update the grid target selection, and handle its double click callbacks. Currently ignore underlying cells for the event"	| index |	view triggerEvent: #doubleClicked.	(view windowKeyboardProcessor requestActivationFor: self) ifFalse: [^nil].	view rows isEmpty ifTrue: [^nil].	self isDoubleClickable ifFalse: [^nil].	(index := self findElementFor: mousePoint) = 0 ifTrue: [^nil].	view targetIndex: index.	self requestDoubleClick ifTrue: [self doubleClick].	^nil</body><body package="Grid">focusOut	view editor		ifNotNil: 			[:editor |			editor widget controller deactivate.			view dropEdit].	super focusOut</body><body package="Grid">requestFocusOut	view editor		ifNotNil: [:editor | editor widget controller requestFocusOut ifFalse: [^false]].	^super requestFocusOut</body><body package="Grid">resizeCursors	^Array with: self rowResizeCursor with: self columnResizeCursor</body><body package="Grid">rowResizeCursor	^ResizingSplitterController upDownCursor</body><body package="Grid">showGridResizeCursor: aCursorOrNil 	| isResize beResize |	isResize := self resizeCursors includes: Cursor currentCursor.	beResize := aCursorOrNil notNil.	(isResize and: [beResize not]) 		ifTrue: [oldCursor ifNotNil: 					[oldCursor show.					oldCursor := nil]].	(isResize not and: [beResize]) 		ifTrue: 			[oldCursor := Cursor currentCursor.			aCursorOrNil show].	(isResize and: [beResize and: [Cursor currentCursor ~= aCursorOrNil]]) 		ifTrue: [aCursorOrNil show]</body></methods><methods><class-id>UI.GridController</class-id> <category>event driven</category><body package="Grid">acceptSelectDownWithEvent: event	self keyboardProcessor		ifNotNil: [:keyboardProcessor | keyboardProcessor requestActivationFor: self].	^true</body><body package="Grid">desiresFocus	^true</body><body package="Grid">doubleClickEvent: aDoubleClickEvent	"Handle entry callbacks and direct red button double clicks to the underlying cell, if any. Otherwise update the grid target selection and handle its double click callbacks"	| index mousePoint |	aDoubleClickEvent redButtonPressed ifFalse: [^nil].	view triggerEvent: #doubleClicked.	(view windowKeyboardProcessor requestActivationFor: self) ifFalse: [^nil].	view rows isEmpty ifTrue: [^nil].	(view componentForMouseEvent: aDoubleClickEvent) ifNotNil: [:component | ^component handleEvent: aDoubleClickEvent].	self isDoubleClickable ifFalse: [^nil].	mousePoint := self sensor cursorPointFor: aDoubleClickEvent.	(index := self findElementFor: mousePoint) = 0 ifTrue: [^nil].	view targetIndex: index.	self requestDoubleClick ifTrue: [self doubleClick].	^nil</body><body package="Grid">exitEvent: event 	self showGridResizeCursor: nil.	super exitEvent: event.</body><body package="Grid">mouseMovedEvent: event	"Show resize cursors"	| point |	self view mayResizeColumns		ifTrue: 			[point := self sensor mousePointForEvent: event.			(view mayResizeColumnAt: point)				ifTrue: [^self showGridResizeCursor: self columnResizeCursor]].	self view mayResizeRows		ifTrue: 			[point := self sensor mousePointForEvent: event.			view lastVisibleColumn right &gt; point x				ifTrue: 					[(view visualRowAtEdge: point)						ifNotNil: 							[:candidateRow |							candidateRow allowResizing ifTrue: [^self showGridResizeCursor: self rowResizeCursor]]]].	self showGridResizeCursor: nil</body><body package="Grid">redButtonPressedEvent: event	"Handle entry callbacks and forward mouse select event to underlying cell, if any"	(view windowKeyboardProcessor requestActivationFor: self) ifFalse: [^nil].	selectedCell := view cellAtCursor: (self sensor cursorPointFor: event) ifNone: nil.	selectedCell		ifNotNil: 			[(selectedCell isSelected or:[selectedCell isEditor not])				ifTrue: 					[(view componentForMouseEvent: event)						ifNotNil: [:component | ^component handleEvent: event]].				self selectEvent: event]</body><body package="Grid">selectionTracker	^GridTracker on: self</body></methods><methods><class-id>UI.GridController</class-id> <category>accessing</category><body package="Grid">activate	"Make this Grid be the keyboard focus"	view takeFocus.	self focusIn.	self hasControl.</body><body package="Grid">multiSelect	^multiSelect</body><body package="Grid">multiSelect: aBoolean	multiSelect := aBoolean</body><body package="Grid">selectedCell	^selectedCell</body><body package="Grid">targetPoint	^targetPoint</body><body package="Grid">targetPoint: aPoint	targetPoint := aPoint</body></methods><methods><class-id>UI.GridController</class-id> <category>keyboard</category><body package="Grid">keyPressedEvent: aKeyboardEvent 	| keyValue selectExtent oldTargetPoint |	aKeyboardEvent isBackTab 		ifTrue: 			[view triggerEvent: #backTabbed.			view requestFocusOutByBackTab				ifTrue: 					["view editor widget controller deactivate."					self keyboardProcessor prevField.					^nil]				ifFalse: 					[(view moveEditHorizontallyBy: -1)						ifTrue: [^nil]]].	keyValue := aKeyboardEvent keyValue.	keyValue == Character tab 		ifTrue: 			[view triggerEvent: #tabbed.			view requestFocusOutByNextTab				ifTrue: 					["view editor widget controller deactivate."					self keyboardProcessor nextField.					^nil]				ifFalse: 					[(view moveEditHorizontallyBy: 1)						ifTrue: [^nil]]].	selectExtent := 0 @ 0.	keyValue == #Up 		ifTrue: 			[view scrollRowIndex: targetPoint y - 1 toView: #nearest.			selectExtent := 0 @ -1].	keyValue == #Down 		ifTrue: 			[view scrollRowIndex: targetPoint y + 1 toView: #nearest.			selectExtent := 0 @ 1].	keyValue == #Left 		ifTrue: 			[view scrollColumnIndex: targetPoint x - 1 toView: #nearest.			selectExtent := -1 @ 0].	keyValue == #Right 		ifTrue: 			[view scrollColumnIndex: targetPoint x + 1 toView: #nearest.			selectExtent := 1 @ 0].	keyValue == #PageUp 		ifTrue: 			[view pageUp.			selectExtent := 0 @ view firstVisibleRow index - targetPoint].	keyValue == #PageDown 		ifTrue: 			[view pageDown.			selectExtent := 0 @ view firstVisibleRow index - targetPoint].	keyValue == #Home 		ifTrue: 			[view home.			selectExtent := 0 @ view firstVisibleRow index - targetPoint].	keyValue == #End 		ifTrue: 			[view end.			selectExtent := 0 @ view firstVisibleRow index - targetPoint].	oldTargetPoint := targetPoint.	targetPoint := (targetPoint + selectExtent max: 1 @ 1) 				min: view maxCellPosition.	keyValue == Character space 		ifTrue: [view toggleSelectionRange: (targetPoint extent: 0 @ 0)].	aKeyboardEvent ctrlDown 		ifTrue: 			[view updateAfterScroll.			^self].	aKeyboardEvent shiftDown 		ifTrue: 			[self sweepSelectFrom: oldTargetPoint toTarget: targetPoint.			view updateAfterScroll.			^self].	self sweepOrigin: targetPoint.	selectExtent = (0 @ 0) 		ifFalse: [view replaceSelectionRange: (targetPoint extent: 0 @ 0).				view updateAfterScroll].	^aKeyboardEvent</body><body package="Grid">processEditorShortcutKey: aKeyboardEvent	| keyValue |	keyValue := aKeyboardEvent keyValue.	(keyValue == #BackTab or: 			[keyValue == Character tab				and: [aKeyboardEvent hasShift]])		ifTrue: 			[view requestFocusOutByBackTab				ifTrue: 					[view editor widget controller deactivate.					self keyboardProcessor prevField.					^nil]				ifFalse: 					[(view moveEditHorizontallyBy: -1)						ifTrue: [^nil]]].	keyValue == Character tab		ifTrue: 			[view requestFocusOutByNextTab				ifTrue: 					[view editor widget controller deactivate.					self keyboardProcessor nextField.					^nil]				ifFalse: 					[(view moveEditHorizontallyBy: 1)						ifTrue: [^nil]]].	keyValue == #Up		ifTrue: 			[(view moveEditVerticallyBy: -1)				ifTrue: [^nil]].	keyValue == #Down		ifTrue: 			[(view moveEditVerticallyBy: 1)				ifTrue: [^nil]].	keyValue == #PageUp		ifTrue: 			[view pageUp.			view resumeEditAtFirstRow. ^nil].	keyValue == #PageDown		ifTrue: 			[view pageDown.			view resumeEditAtFirstRow. ^nil].	aKeyboardEvent hasCtrl		ifTrue: 			[keyValue == #Home				ifTrue: 					[view home.					view resumeEditAtFirstRow ifTrue: [^nil]].			keyValue == #End				ifTrue: 					[view end.					view resumeEditAtFirstRow ifTrue: [^nil]]].	^aKeyboardEvent</body><body package="Grid">processHeaderShortcutKey: aKeyboardEvent 	^self processEditorShortcutKey: aKeyboardEvent</body></methods><methods><class-id>UI.GridController</class-id> <category>selection</category><body package="Grid">selectCell: aGridVisualCell 	targetPoint := aGridVisualCell cellPoint.	multiSelect 		ifTrue: 			[| sensor |			sensor := self sensor.			sensor ctrlDown 				ifTrue: 					[view toggleSelectionRange: (targetPoint extent: 0 @ 0).					^view invalidate].			sensor shiftDown 				ifTrue: 					[self sweepSelectFrom: sweepOrigin toTarget: targetPoint.					^view invalidate]].	view selectPoint: targetPoint.	self sweepOrigin: targetPoint</body><body package="Grid">sweepOrigin	^sweepOrigin</body><body package="Grid">sweepOrigin: aPoint 	"Set the origin for the next sweep selection"	sweepOrigin := aPoint</body><body package="Grid">sweepSelectFrom: lastTargetPoint toTarget: aPoint 	"Select the area bound by verticies from lastTargetPoint to aPoint.  Answer the area to invalidate"	| lastSelectionArea newSelectionArea removeRange addRange |	lastTargetPoint = aPoint ifTrue: [^0 @ 0 extent: 0 @ 0].	sweepOrigin ifNil: [sweepOrigin := lastTargetPoint].	(view selectByCell not and: [aPoint y = lastTargetPoint y]) 		ifTrue: [^0 @ 0 extent: 0 @ 0].	lastSelectionArea := Rectangle vertex: sweepOrigin vertex: lastTargetPoint.	newSelectionArea := Rectangle vertex: sweepOrigin vertex: aPoint.	removeRange := (newSelectionArea contains: lastSelectionArea) 				ifTrue: [0 @ 0 extent: 0 @ 0]				ifFalse: [view removeSelectionRange: lastSelectionArea].	addRange := view addSelectionRange: newSelectionArea.	^addRange merge: removeRange</body><body package="Grid">sweepSelectToTarget: aPoint 	self sweepSelectFrom: targetPoint toTarget: aPoint.	targetPoint := aPoint.</body><body package="Grid">toggleSelection	selectedCell ifNotNil:[self selectCell: selectedCell]</body></methods><methods><class-id>UI.GridController</class-id> <category>initialize-release</category><body package="Grid">initialize	super initialize.	multiSelect :=  false.	targetPoint := 0@0.</body></methods><methods><class-id>UI.GridRowHeaderSpec</class-id> <category>private</category><body package="Grid">defaultModel	^AspectAdaptor forAspect: #isSelected</body><body package="Grid">dispatchTo: policy with: builder	policy gridRowHeaderBox: self into: builder</body></methods><methods><class-id>UI.GridRow</class-id> <category>testing</category><body package="Grid">allowResizing	^true</body><body package="Grid">isHeader	^false</body><body package="Grid">isSelected	^grid ifNil: [false]		ifNotNil: 			[| index |			grid selectionRange isEmpty ifTrue: [^false].			index := self index.			grid selectionRange 				contains: [:range | index between: range top and: range bottom]]</body><body package="Grid">isValid	^self index notNil</body></methods><methods><class-id>UI.GridRow</class-id> <category>enumerating</category><body package="Grid">columnsDo: aBlock 	grid ifNotNil: 			[grid columns 				do: [:each | aBlock value: each value: (GridCell column: each row: self) value]]</body></methods><methods><class-id>UI.GridRow</class-id> <category>printing</category><body package="Grid">displayString	^item displayString</body><body package="Grid">printOn: aStream	aStream 		nextPutAll: self class name;		nextPutAll: ' on: ';		nextPutAll: self displayString</body></methods><methods><class-id>UI.GridRow</class-id> <category>accessing</category><body package="Grid">grid	^grid</body><body package="Grid">grid: aGrid 	self removeDependent: grid.	grid := aGrid.	self addDependent: aGrid.</body><body package="Grid">height		^height		ifNil:			[grid				ifNil: [0]				ifNotNil: [grid defaultRowHeight]]</body><body package="Grid">height: anInteger 	height = anInteger 		ifFalse: 			[ | delta |			delta :=  anInteger  - self height.			height := anInteger.			self changed: #updateRowHeight: with: delta]</body><body package="Grid">heightWithGap	^self height + self paddingTop + self paddingBottom</body><body package="Grid">index	^grid ifNotNil: [grid rows indexOf: self ifAbsent: nil]</body><body package="Grid">item	^item</body><body package="Grid">item: anItem 	item := anItem</body><body package="Grid">value	^self item ifNil:[self modelDo:[:list :index| list at: index]]</body><body package="Grid">value: anObject 	item := anObject.	self modelDo: [:list :index | list at: index put: anObject]		or: [grid changed: #item with: anObject]</body></methods><methods><class-id>UI.GridRow</class-id> <category>private</category><body package="Grid">modelDo: aBlock 	^grid ifNotNil: 			[| index |			index := grid rows indexOf: self ifAbsent: [^nil].			aBlock value: grid model value value: index]</body><body package="Grid">modelDo: modelBlock or: noModelBlock	^grid 		ifNil: noModelBlock		ifNotNil: 			[| index |			index := grid rows indexOf: self ifAbsent: [^noModelBlock value].			modelBlock value: grid model value value: index]</body><body package="Grid">updateHeightAndScroll: anInteger 	grid updateScrollHeightBy: anInteger - self height.	height := anInteger</body></methods><methods><class-id>UI.GridRow</class-id> <category>private-building</category><body package="Grid">postBuildCell: aGridVisualCell with: aUIBuilder	"This message is sent by the Grid builder when it has completed work on 	a complete cell component"</body><body package="Grid">specForCell: aGridVisualCell appliedTo: aUISpecification 	"The receiver is given a chance to modify or replace aUISpecification for building the widget appearing in aGridVisualCell for this row in the Grid"	^aUISpecification</body></methods><methods><class-id>UI.GridRow</class-id> <category>private-height management</category><body package="Grid">rawHeight	^height</body></methods><methods><class-id>UI.GridRow</class-id> <category>initialize-release</category><body package="Grid">on: anObject height: anInteger	height := anInteger.	item := anObject.</body><body package="Grid">on: anObject height: anInteger to: aGrid		height := anInteger.	item := anObject.	self grid: aGrid.	aGrid addRow: self</body><body package="Grid">release	super release.	item := grid := nil.</body></methods><methods><class-id>UI.GridRow</class-id> <category>scrolling</category><body package="Grid">scrollToView	self scrollToView: #nearest</body><body package="Grid">scrollToView: aSymbol	"Scroll the Grid pane to make the receiver visible in the preferred position aSymbol.  Possible values are #top, #bottom, #center, or #nearest (scroll the minimum distance to make the receiver fully visible at any border)"		grid		ifNotNil:			[grid				scrollRowIndex: self index				toView: aSymbol]</body></methods><methods><class-id>UI.GridRow</class-id> <category>privileged</category><body package="Grid">setHeight: anInteger	height := anInteger</body></methods><methods><class-id>UI.GridRow</class-id> <category>selection</category><body package="Grid">isSelected: aBoolean 	grid ifNotNil: [grid rowAt: self index beSelected: aBoolean]</body></methods><methods><class-id>UI.GridRow</class-id> <category>constants</category><body package="Grid">paddingBottom	^1</body><body package="Grid">paddingTop	^1</body></methods><methods><class-id>UI.GridRow</class-id> <category>removing</category><body package="Grid">remove	grid ifNotNil:[grid removeRow: self].	grid := nil.</body></methods><methods><class-id>UI.GridRow class</class-id> <category>instance creation</category><body package="Grid">new	^super new initialize</body><body package="Grid">on: anObject 	^self new item: anObject</body><body package="Grid">on: anObject height: anInteger	^self new on: anObject height: anInteger</body><body package="Grid">on: anObject height: anInteger to: aGrid		^self new on: anObject height: anInteger to: aGrid</body><body package="Grid">on: anObject to: aGrid		^self new on: anObject height: nil to: aGrid</body></methods><methods><class-id>UI.GridRow class</class-id> <category>private</category><body package="Grid">decodeFromLiteralArray: anArray	| gridRow |	gridRow := self new.	2 to: anArray size by: 2 do:		[:index |		gridRow perform: (anArray at: index) with: (anArray at: index + 1) decodeAsLiteralArray].	^gridRow</body></methods><methods><class-id>UI.GridHeaderRow</class-id> <category>building constraints</category><body package="Grid">addConstraintColumn: aGridColumn 	aGridColumn allowSorting ifFalse: [^self].	constraintColumns size &gt; sortSize ifTrue: [self clearConstraints].	(constraintColumns includes: aGridColumn) ifTrue: [^self].	constraintColumns size = sortSize ifTrue: [self clearConstraints].	sortSize = 0 		ifTrue: [aGridColumn clearSortDirection]		ifFalse: [constraintColumns add: aGridColumn]</body><body package="Grid">clearConstraints	constraintColumns do:[:each| each clearSortDirection].	constraintColumns := OrderedCollection new</body><body package="Grid">compoundConstraint	^(constraintColumns size &gt; 1 		ifTrue: 			[constraintColumns fold: [:a :b | a sortConstraint &amp; b sortConstraint]]		ifFalse: [constraintColumns first sortConstraint]) gridRowConstraint</body></methods><methods><class-id>UI.GridHeaderRow</class-id> <category>accessing</category><body package="Grid">constraintColumns	^constraintColumns</body><body package="Grid">constraintColumns: anOrderedCollection 	constraintColumns := anOrderedCollection</body><body package="Grid">grid: aGrid 	grid := aGrid.</body><body package="Grid">gridBody	^gridBody ifNil:[self grid]</body><body package="Grid">gridBody: aGrid	gridBody := aGrid</body><body package="Grid">sortSize	^sortSize</body><body package="Grid">sortSize: anInteger	sortSize := anInteger</body></methods><methods><class-id>UI.GridHeaderRow</class-id> <category>testing</category><body package="Grid">hasConstraints	^constraintColumns notEmpty</body><body package="Grid">isHeader	^true</body></methods><methods><class-id>UI.GridHeaderRow</class-id> <category>initialize-release</category><body package="Grid">initialize	super initialize.	constraintColumns := OrderedCollection new.	sortSize := 1.</body></methods><methods><class-id>UI.GridHeaderRow</class-id> <category>constants</category><body package="Grid">paddingBottom	^0</body><body package="Grid">paddingTop	^0</body></methods><methods><class-id>UI.GridHeaderRow</class-id> <category>private-building</category><body package="Grid">specForCell: aGridVisualCell appliedTo: aUISpecification 	"The receiver is given a chance to modify or replace aUISpecification for building the widget appearing in aGridVisualCell for the header row in the Grid"	| column model |	column := aGridVisualCell gridColumn.	column isHeader ifTrue: [		^LabelSpec new			layout: aGridVisualCell preferredBounds;			colors: (LookPreferences new setBackgroundColor: SymbolicPaint menuBarBackground asColorValue);			yourself ].	model := (AspectAdaptor forAspect: #sortDirection)				subject: column;				subjectSendsUpdates: true;				compute: 						[:value | 						self addConstraintColumn: column.						self sort];				yourself.	^(GridColumnHeaderSpec new)		label: column label;		layout: aGridVisualCell preferredBounds;		colors: (LookPreferences new setBackgroundColor: SymbolicPaint menuBarBackground asColorValue);		model: model;		yourself</body></methods><methods><class-id>UI.GridHeaderRow</class-id> <category>sorting</category><body package="Grid">sort	self hasConstraints ifFalse: [^self].	self gridBody sortUsing: self compoundConstraint</body></methods><methods><class-id>UI.GridHeaderRow</class-id> <category>private</category><body package="Grid">literalArrayEncoding	| omitted class default array |	omitted := #('grid' 'gridBody' 'dependents').	class := self class.	default := class new.	array := OrderedCollection with: class fullyQualifiedReference.	class allInstVarNames keysAndValuesDo: 			[:i :name | 			| value |			value := self instVarAt: i.			((omitted includes: name) or: [value = (default instVarAt: i)]) 				ifFalse: 					[array add: (name , ':') asSymbol.					array add: value literalArrayEncoding]].	^array asArray</body></methods><methods><class-id>UI.GridColumnHeaderController</class-id> <category>private</category><body package="Grid">pressAction	"Do the action associated with pressing the button."	view column allowSorting ifTrue:[super pressAction]</body></methods><methods><class-id>UI.GridColumnHeaderController</class-id> <category>event driven</category><body package="Grid">selectionTracker	^GridColumnDraggingTracker 		on: (GridColumnHeaderAgent new controller: self)</body></methods><methods><class-id>UI.GridColumnHeaderController</class-id> <category>events</category><body package="Grid">enterEvent: event	([view column respondsTo: #sortDirection] on: MessageNotUnderstood		do: [:ex | false]) ifFalse: [view isEnabled: false].	^super enterEvent: event</body></methods><methods><class-id>UI.GridVisualSegment</class-id> <category>combining</category><body package="Grid">, aGridVisualRow	self last successor: aGridVisualRow</body><body package="Grid">addSuccessorCount: anInteger 	| nextSuccessor |	nextSuccessor := self last.	anInteger timesRepeat: 			[nextSuccessor := nextSuccessor newSuccessor ifNil: [^self]						ifNotNil: [:successor | successor predecessor: nextSuccessor]]</body><body package="Grid">predecessor: aGridVisualSegment 	prior == aGridVisualSegment ifTrue: [^self].	prior ifNotNil: [prior severSuccessor].	prior := aGridVisualSegment.	aGridVisualSegment ifNotNil: [aGridVisualSegment successor: self].</body><body package="Grid">successor: aGridVisualSegment 	next == aGridVisualSegment ifTrue: [^self].	next ifNotNil: [next severPredecessor].	next := aGridVisualSegment.	aGridVisualSegment ifNotNil: [aGridVisualSegment predecessor: self].</body></methods><methods><class-id>UI.GridVisualSegment</class-id> <category>accessing</category><body package="Grid">allowResizing	self subclassResponsibility</body><body package="Grid">anyBoundsDefinedFromPredecessors	self subclassResponsibility</body><body package="Grid">anyBoundsDefinedFromSuccessors	self subclassResponsibility</body><body package="Grid">atIndex: anInteger 	self index = anInteger ifTrue:[^self].	next ifNotNil: [self index &lt; anInteger ifTrue: [^next atIndex: anInteger]].	prior ifNotNil: [self index &gt; anInteger ifTrue: [^prior atIndex: anInteger]].	^nil</body><body package="Grid">atPosition: aNumber 	"Answer the GridVisualSegment which includes position aNumber"	self 		withSuccessorsFrom: aNumber		to: aNumber		do: [:each | ^each].	^nil</body><body package="Grid">first	^prior ifNil:[self] ifNotNil:[prior first]</body><body package="Grid">grid	^grid</body><body package="Grid">grid: aGrid	grid := aGrid</body><body package="Grid">gridEnd	self subclassResponsibility</body><body package="Grid">gridOrigin	self subclassResponsibility</body><body package="Grid">index	^index ifNil: 			[index := prior ifNotNil: [prior index + 1]						ifNil: [next ifNotNil: [next index - 1]]]</body><body package="Grid">index: anInteger	index := anInteger</body><body package="Grid">jumpTo: aNumber	self subclassResponsibility</body><body package="Grid">jumpToIndex: anInteger 	self subclassResponsibility</body><body package="Grid">last	^next ifNil:[self] ifNotNil:[next last]</body><body package="Grid">nearest: aNumber	self subclassResponsibility</body><body package="Grid">predecessor	^prior</body><body package="Grid">predecessorCount	^prior ifNil:[0] ifNotNil:[prior predecessorCount + 1]</body><body package="Grid">predecessors	^prior ifNil:[Array new]		ifNotNil:[prior predecessors , (Array with: prior)]</body><body package="Grid">successor	^next</body><body package="Grid">successorCount	^next ifNil:[0] ifNotNil:[next successorCount + 1]</body><body package="Grid">successors	^next ifNil:[Array new]		ifNotNil:[(Array with: next), next successors]</body><body package="Grid">withPredecessors	^self predecessors , (Array with: self)</body><body package="Grid">withSuccessors	^(Array with: self), self successors</body></methods><methods><class-id>UI.GridVisualSegment</class-id> <category>cells</category><body package="Grid">cells	^cells</body><body package="Grid">includesCell: aGridVisualCell	^cells includes: aGridVisualCell</body><body package="Grid">registerCell: aGridVisualCell	cells add: aGridVisualCell</body><body package="Grid">removeCell: aGridVisualCell 	cells remove: aGridVisualCell ifAbsent: nil</body></methods><methods><class-id>UI.GridVisualSegment</class-id> <category>private</category><body package="Grid">checkCells	self subclassResponsibility</body><body package="Grid">createCells	self subclassResponsibility</body><body package="Grid">dropPredecessor	prior := nil</body><body package="Grid">dropSuccessor	next := nil</body><body package="Grid">moveIndexTo: anIntegerOrNil 	"Set the index of the receiver to anIntegerOrNil and adjust successor indexes accordingly.  If anIntegerOrNil is nil then determine my index from a predecessor later."	index := anIntegerOrNil.	next ifNotNil: [next moveIndexTo: (index ifNotNil: [index + 1])]</body><body package="Grid">removeUnusedCells	cells copy do: [:each | each isNeeded ifFalse: [each release]]</body><body package="Grid">resetBorders	self subclassResponsibility</body><body package="Grid">resetPredecessors	prior ifNotNil: 			[prior successor: self.			prior index: self index - 1.			prior resetBorders.			prior resetPredecessors]</body><body package="Grid">resetSuccessors	"Reset my successors to prepare them for update."	next ifNotNil: 			[next predecessor: self.			next index: self index + 1.			next resetBorders.			next resetSuccessors]</body></methods><methods><class-id>UI.GridVisualSegment</class-id> <category>updating</category><body package="Grid">checkCellsWithSuccessors	self withSuccessorsDo: [:each | each checkCells]</body><body package="Grid">notifyHideSelected: aGridVisualCell	"This message is sent by aGridVisualCell when it has changed to hide selection"</body><body package="Grid">updateCells	self releaseCells.	self createCells.</body><body package="Grid">updateLayout	cells do:[:each| each updateLayout]</body><body package="Grid">updateSuccessorVisibility	self subclassResponsibility</body></methods><methods><class-id>UI.GridVisualSegment</class-id> <category>initialize-release</category><body package="Grid">initialize	cells := OrderedCollection new.</body><body package="Grid">release	super release.	self releaseCells.	prior := next := grid := nil</body><body package="Grid">releaseAll	self releaseSuccessors.	self releasePredecessors.	self release.</body><body package="Grid">releaseCells	cells copy do: [:each | each release]</body><body package="Grid">releasePredecessors	prior ifNotNil: 			[prior releaseWithPredecessors.			prior := nil]</body><body package="Grid">releaseSuccessors	next ifNotNil: 			[next releaseWithSuccessors.			next := nil]</body><body package="Grid">releaseWithPredecessors	self releasePredecessors.	self release</body><body package="Grid">releaseWithSuccessors	self releaseSuccessors.	self release</body></methods><methods><class-id>UI.GridVisualSegment</class-id> <category>insertion</category><body package="Grid">insertAfter: aGridVisualSegment 	aGridVisualSegment == self ifTrue:[^self error:#cannotInsertToReceiver &lt;&lt; #dialogs &gt;&gt; 'Cannot insert receiver to itself'].	aGridVisualSegment successor ifNotNil:[:successor| successor predecessor: self].	aGridVisualSegment successor: self.	self resetSuccessors</body><body package="Grid">insertPrior: aGridVisualSegment	aGridVisualSegment == self ifTrue:[^self error:#cannotInsertToReceiver &lt;&lt; #dialogs &gt;&gt; 'Cannot insert receiver to itself'].	aGridVisualSegment predecessor ifNotNil:[:predecessor| predecessor successor: self].	aGridVisualSegment predecessor: self.	self resetSuccessors.</body><body package="Grid">insertWithPredecessorsPrior: aGridVisualSegment 	aGridVisualSegment == self ifTrue:[^self error:#cannotInsertToReceiver &lt;&lt; #dialogs &gt;&gt; 'Cannot insert receiver to itself'].	self first predecessor: aGridVisualSegment predecessor.	aGridVisualSegment predecessor: self.	self first resetSuccessors.</body><body package="Grid">insertWithSuccessorsAfter: aGridVisualSegment 	aGridVisualSegment == self ifTrue:[^self error:#cannotInsertToReceiver &lt;&lt; #dialogs &gt;&gt; 'Cannot insert receiver to itself'].	self last successor: aGridVisualSegment successor.	aGridVisualSegment successor: self.	self resetSuccessors.</body></methods><methods><class-id>UI.GridVisualSegment</class-id> <category>enablement</category><body package="Grid">isEnabled: aBoolean	cells do:[:each| each component isEnabled: aBoolean]</body></methods><methods><class-id>UI.GridVisualSegment</class-id> <category>testing</category><body package="Grid">isFirst	^prior isNil</body><body package="Grid">isFullyVisible	self subclassResponsibility</body><body package="Grid">isHeader	self subclassResponsibility</body><body package="Grid">isLast	^next isNil</body></methods><methods><class-id>UI.GridVisualSegment</class-id> <category>removing</category><body package="Grid">remove	self releaseCells.	prior := next := nil</body><body package="Grid">removeAtIndex: anInteger 	(self atIndex: anInteger) ifNotNil: [self remove]</body><body package="Grid">removePredecessorCount: anInteger 	anInteger &gt; 0 ifFalse: [^self].	prior ifNotNil: 			[prior removePredecessorCount: anInteger - 1.			prior remove]</body><body package="Grid">removeSuccessorCount: anInteger 	anInteger &gt; 0 ifFalse: [^self].	next ifNotNil: 			[next removeSuccessorCount: anInteger - 1.			next remove]</body><body package="Grid">removeWithPredecessors	self severSuccessor.	self releaseWithPredecessors</body><body package="Grid">removeWithSuccessors	self severPredecessor.	self releaseWithSuccessors</body><body package="Grid">severPredecessor	prior ifNotNil:[prior dropSuccessor].	prior := nil.</body><body package="Grid">severSuccessor	next ifNotNil:[next dropPredecessor].	next := nil.</body></methods><methods><class-id>UI.GridVisualSegment</class-id> <category>scrolling</category><body package="Grid">scrollToFullView	self subclassResponsibility</body></methods><methods><class-id>UI.GridVisualSegment</class-id> <category>enumerating</category><body package="Grid">withSuccessorsContains: aBlock 	| nextElement |	nextElement := self.	[aBlock value: nextElement] 		whileFalse: [nextElement := nextElement successor ifNil: [^false]].	^true</body><body package="Grid">withSuccessorsDetect: aBlock ifNone: exceptionBlock	| nextElement |	nextElement := self.	[aBlock value: nextElement] 		whileFalse: [nextElement := nextElement successor ifNil: [^exceptionBlock value]].	^nextElement</body><body package="Grid">withSuccessorsDo: aBlock 	| nextElement |	nextElement := self.		[aBlock value: nextElement.	nextElement := nextElement successor.	nextElement isNil] 			whileFalse</body><body package="Grid">withSuccessorsDoWhile: aBlock 	| nextElement |	nextElement := self.	[nextElement notNil and: [aBlock value: nextElement]] 		whileTrue: [nextElement := nextElement successor]</body><body package="Grid">withSuccessorsFrom: start to: end do: aBlock 		self subclassResponsibility</body><body package="Grid">withSuccessorsFromIndex: startIndex to: endIndex do: aBlock 		self withSuccessorsDo:[:each| 		each index &gt; endIndex ifTrue:[^self].		each index &lt; startIndex ifFalse:[aBlock value: each]]</body></methods><methods><class-id>UI.GridVisualSegment</class-id> <category>list creation and access</category><body package="Grid">newPredecessor	self subclassResponsibility</body><body package="Grid">newSuccessor	self subclassResponsibility</body></methods><methods><class-id>UI.GridVisualSegment class</class-id> <category>instance creation</category><body package="Grid">new	^super new initialize</body></methods><methods><class-id>UI.GridVisualRow</class-id> <category>accessing</category><body package="Grid">allowResizing	^row allowResizing</body><body package="Grid">bottom	^bottom ifNil: 		[top 			ifNotNil: [bottom := top + row heightWithGap]			ifNil: 				[self anyBoundsDefinedFromPredecessors ifTrue: [^bottom].				self anyBoundsDefinedFromSuccessors ifTrue: [^bottom].				bottom := self top + row heightWithGap]]</body><body package="Grid">bottom: aNumber	bottom := aNumber</body><body package="Grid">cellBottom	^self bottom - row paddingBottom</body><body package="Grid">cellTop	^self top + row paddingTop</body><body package="Grid">gridEnd	^(self class new)		row: grid rows last;		grid: grid;		index: grid rows size;		bottom: grid scrollableExtent y;		yourself</body><body package="Grid">gridOrigin	^(self class new)		row: grid rows first;		grid: grid;		index: 1;		top: 0;		yourself</body><body package="Grid">height	^row rawHeight ifNil: 		[grid isOpen 			ifTrue: 				[self createCells.				row height]			ifFalse: [grid defaultRowHeight]]</body><body package="Grid">height: aNumber 	"Set the height for the visible row and update. Limit to a minimum visible value"	row height: aNumber</body><body package="Grid">row	^row</body><body package="Grid">row: anObject	row := anObject</body><body package="Grid">top	^top ifNil: 			[bottom ifNotNil: [top := bottom - row heightWithGap max: 0]				ifNil: 					[self anyBoundsDefinedFromPredecessors ifTrue: [^top].					self anyBoundsDefinedFromSuccessors ifTrue: [^top].					top := 0]]</body><body package="Grid">top: aNumber	top := aNumber</body><body package="Grid">visualForRow: aRow do: aBlock 	"There must be a unique GridRow for each GridVisualRow to ensure that a single match occurs"	aBlock 		value: (self withSuccessorsDetect: [:each | each row = aRow] ifNone: [^self])</body><body package="Grid">visualForRow: aRow ifNone: aBlock	"There must be a unique GridRow for each GridVisualRow to ensure that a single match occurs"	^self withSuccessorsDetect: [:each | each row = aRow] ifNone: aBlock</body></methods><methods><class-id>UI.GridVisualRow</class-id> <category>private</category><body package="Grid">anyBoundsDefinedFromPredecessors	"Find the first visible row prior the receiver with defined bounds and recursively set the bounds of rows up to the receiver"	| result |	(top isNil or: [bottom isNil]) ifFalse: [^true].	(top notNil and: [bottom isNil]) 		ifTrue: 			[bottom := top + row heightWithGap.			^true].	(top isNil and: [bottom notNil]) 		ifTrue: 			[top := bottom - row heightWithGap max: 0.			^true].	prior ifNil: [^false].	result := prior anyBoundsDefinedFromPredecessors.	result 		ifTrue: 			[top := prior bottom.			bottom := top + row heightWithGap].	^result</body><body package="Grid">anyBoundsDefinedFromSuccessors	"Find the first visible row after the receiver with defined bounds and recursively set the bounds of rows back to the receiver"	| result |	(top isNil or: [bottom isNil]) ifFalse: [^true].	(top notNil and: [bottom isNil]) ifTrue: 		[bottom := top + row heightWithGap.		^true].	(top isNil and: [bottom notNil]) ifTrue: 		[top := bottom - row heightWithGap max: 0.		^true].	next ifNil: [^false].	result := next anyBoundsDefinedFromSuccessors.	result ifTrue: 		[bottom := next top.		top := bottom - row heightWithGap max: 0].	^result</body><body package="Grid">checkCells	"Create or remove cells as needed to fill the row in the grid"	| gridBounds |	grid ifNil: [^self].	cells size = grid visibleColumnCount ifTrue: [^self].	gridBounds := grid bounds.	self removeUnusedCells.	(self top &lt; gridBounds bottom and: [self bottom &gt; gridBounds top]) 		ifTrue: [self createCells]</body><body package="Grid">createCells	grid firstVisibleColumn ifNotNil: 			[:visible | 			visible 				withSuccessorsDo: [:column | GridVisualCell visualColumn: column visualRow: self]].</body><body package="Grid">invalidateGridBelow: aNumber	grid invalidateRectangle: (grid bounds top: aNumber)</body><body package="Grid">resetBorders	top := bottom := nil</body><body package="Grid">updateRowHeight	self moveBottomSideTo: top + row heightWithGap.	self updateSuccessorVisibility.	self invalidateGridBelow: top</body></methods><methods><class-id>UI.GridVisualRow</class-id> <category>resizing</category><body package="Grid">downTo: aNumber 	"Add to or trim successors from the linked collection of GridVisualRows such that the endpoints of the last GridVisualRow stride aNumber"	| endRow |	endRow := self nearest: aNumber.	[endRow top &lt; aNumber and: [endRow bottom &gt;= aNumber]] whileFalse: 			[endRow := endRow newSuccessor ifNil: [^self]						ifNotNil: [:nextRow | nextRow predecessor: endRow]].	endRow releaseSuccessors</body><body package="Grid">moveBottomSideTo: aNumber 	"Move the bottom position of the receiver to aNumber and recursively shift down all rows below it accordingly. Note this must be preceeded by a change in the top position or height of the row to make its layout consistent."	bottom := aNumber.	next ifNotNil: [next moveTopSideTo: bottom].	self updateLayout</body><body package="Grid">moveTopSideTo: aNumberOrNil 	"Shift the top position of the receiver to aNumber and recursively shift down all columns below it accordingly. If nil, my position and those of successor rows will be determined later."	top := aNumberOrNil.	self moveBottomSideTo: (top ifNotNil: [top + row heightWithGap])</body></methods><methods><class-id>UI.GridVisualRow</class-id> <category>list creation and access</category><body package="Grid">downTo: aNumber joining: aGridVisualRow 	"Answer a GridVisualRow that extends down to span aNumber joining with any portion of aGridVisualRow below the receiver but above aNumber.  Release all unused portions of the receiver or aGridVisualRow."	| firstRowToJoin |	aNumber &lt; self top 		ifTrue: 			[self 				error: (#targetPreceedsBorder &lt;&lt; #dialogs 						&gt;&gt; 'Target &lt;1p&gt; preceeds receiver' expandMacrosWith: aNumber)].	self == (aGridVisualRow nearest: self top) ifTrue:[^self releasePredecessors downTo: aNumber].	firstRowToJoin := aGridVisualRow first.	(self top &gt; aGridVisualRow last bottom or: [aNumber &lt;= firstRowToJoin top]) 		ifTrue: 			[aGridVisualRow releaseAll.			^self releasePredecessors downTo: aNumber].	^firstRowToJoin top &lt; self top 		ifTrue: 			[(aGridVisualRow nearest: self bottom)				releasePredecessors;				downTo: aNumber]		ifFalse: 			[self downTo: firstRowToJoin top.			firstRowToJoin predecessor: self last.			firstRowToJoin downTo: aNumber.			self]</body><body package="Grid">firstVisibleRowBetween: topGridEdge and: bottomGridEdge 	"Answer the lowest index GridVisualRow that heads a new linked collection of GridVisualRows visible between topGridEdge and bottomGridEdge upward of the receiver.  Trim and release GridVisualRows outside of topGridEdge and bottomGridEdge"	| startRow |	startRow := self jumpTo: topGridEdge.	startRow := startRow downTo: bottomGridEdge joining: self.	^startRow releasePredecessors</body><body package="Grid">jumpTo: aNumber 	"Answer a new instance without ancestors whose endpoints stride aNumber. Start from a known position: the receiver, the grid's last row, or the grid's first row, whichever is closer to aNumber"	| endRow |	endRow := self nearest: aNumber.	(aNumber between: endRow top and: endRow bottom) ifTrue: [^endRow].	grid scrollableExtent y - endRow bottom &lt;= (aNumber - endRow bottom) abs 		ifTrue: [endRow := self gridEnd].	endRow top &lt;= (aNumber - endRow top) abs 		ifTrue: [endRow := self gridOrigin].	[aNumber between: endRow top and: endRow bottom] whileFalse: 			[endRow bottom &lt; aNumber 				ifTrue: 					[endRow := endRow newSuccessor ifNil: [^endRow]								ifNotNil: [:value | value severPredecessor]].			endRow top &gt; aNumber 				ifTrue: 					[endRow := endRow newPredecessor ifNil: [^endRow]								ifNotNil: [:value | value severSuccessor]]].	^endRow</body><body package="Grid">jumpToIndex: anInteger 	"Answer a new instance without ancestors at index anInteger. Start from a known position: the receiver, the grid's last row, or the grid's first row, whichever is closer to anInteger"	| firstIndex lastIndex endRow |	firstIndex := self first index.	lastIndex := self last index.	(anInteger between: firstIndex and: lastIndex) 		ifTrue: [^self atIndex: anInteger].	endRow := anInteger &gt; lastIndex ifTrue: [self last] ifFalse: [self first].	grid rows size - anInteger &lt; (anInteger - lastIndex) abs 		ifTrue: [endRow := self gridEnd].	anInteger &lt; (firstIndex - anInteger) abs 		ifTrue: [endRow := self gridOrigin].	[endRow index = anInteger] whileFalse: 			[endRow index &lt; anInteger 				ifTrue: 					[endRow newSuccessor ifNil: [^endRow]						ifNotNil: [:value | endRow := value severPredecessor]].			endRow index &gt; anInteger 				ifTrue: 					[endRow newPredecessor ifNil: [^endRow]						ifNotNil: [:value | endRow := value severSuccessor]]].	^endRow</body><body package="Grid">nearest: aNumber 	"Answer the row in the linked list between or nearest aNumber height"	(aNumber between: self top and: self bottom) ifTrue: [^self].	next ifNotNil: [self bottom &lt; aNumber ifTrue: [^next nearest: aNumber]].	prior ifNotNil: [self top &gt; aNumber ifTrue: [^prior nearest: aNumber]]</body><body package="Grid">newPredecessor	| rows priorIndex |	(index = 1 or: [(rows := grid rows) isEmpty]) ifTrue: [^nil].	priorIndex := index - 1.	^GridVisualRow 		on: (rows at: priorIndex)		in: grid		index: priorIndex		top: nil		bottom: self top</body><body package="Grid">newSuccessor	| rows nextIndex |	rows := grid rows.	(rows isEmpty or: [index &gt;= rows size]) ifTrue: [^nil].	nextIndex := index + 1.	^GridVisualRow 		on: (rows at: nextIndex)		in: grid		index: nextIndex		top: self bottom		bottom: nil</body><body package="Grid">upTo: aNumber 	"Add to or trim predecessors from the linked collection of GridVisualRows such that the endpoints of the last GridVisualRow stride aNumber"	| startRow |	startRow := self nearest: aNumber.	[startRow top &lt;= aNumber and: [startRow bottom &gt; aNumber]] whileFalse: 			[startRow := startRow newPredecessor ifNil: [^self]						ifNotNil: [:priorRow | priorRow successor: startRow]].	startRow releasePredecessors</body><body package="Grid">upTo: aNumber joining: aGridVisualRow 	"Answer a GridVisualRow that extends up to span aNumber joining with any portion of aGridVisualRow above the receiver but below aNumber.  Release all unused portions of the receiver or aGridVisualRow."	| lastRowToJoin |	aNumber &gt; self bottom 		ifTrue: 			[self 				error: (#targetPreceedsBorder &lt;&lt; #dialogs 						&gt;&gt; 'Target &lt;1p&gt; preceeds receiver' expandMacrosWith: aNumber)].	self == (aGridVisualRow nearest: self bottom) ifTrue:[^(self releaseSuccessors upTo: aNumber) first].	lastRowToJoin := aGridVisualRow last.	(self bottom &lt; aGridVisualRow first top 		or: [aNumber &gt;= lastRowToJoin bottom]) 			ifTrue: 				[aGridVisualRow releaseAll.				^(self releaseSuccessors upTo: aNumber) first].	^(lastRowToJoin bottom &gt; self bottom 		ifTrue: 			[(aGridVisualRow nearest: self top)				releaseSuccessors;				upTo: aNumber]		ifFalse: 			[self upTo: lastRowToJoin bottom.			lastRowToJoin successor: self first.			lastRowToJoin upTo: aNumber.			lastRowToJoin]) 			first</body></methods><methods><class-id>UI.GridVisualRow</class-id> <category>testing</category><body package="Grid">isFullyVisible	| bounds |	bounds := grid bounds.	^self bottom &lt;= bounds bottom and: [self top &gt;= bounds top]</body><body package="Grid">isHeader	^self row isHeader</body></methods><methods><class-id>UI.GridVisualRow</class-id> <category>scrolling</category><body package="Grid">pageDown	"Answer the head of the linked collection of GridVisualRows shifting the collection down to make the next page visible in the Grid."	^self firstVisibleRowBetween: self bottom and: self bottom + grid bounds height</body><body package="Grid">pageUp	"Answer the head of the linked collection of GridVisualRows shifting the collection up to make the next page visible in the Grid."	^self firstVisibleRowBetween: self top - grid bounds height and: self top</body><body package="Grid">scrollToFullView	row scrollToView: #nearest</body><body package="Grid">shiftDown	"Answer the head of the linked collection of GridVisualRows shifting the collection down to make them visible in the Grid."	| bounds |	bounds := grid bounds.	^self firstVisibleRowBetween: bounds top and: bounds bottom</body><body package="Grid">shiftUp	"Answer the head of the linked collection of GridVisualRows shifting the collection up to make them visible in the Grid."	| bounds |	bounds := grid bounds.	^self firstVisibleRowBetween: bounds top and: bounds bottom</body></methods><methods><class-id>UI.GridVisualRow</class-id> <category>initialize-release</category><body package="Grid">release	grid ifNotNil:[grid builder bindings removeKey: self rowBindingKey ifAbsent: nil].	row := nil.	super release.</body></methods><methods><class-id>UI.GridVisualRow</class-id> <category>removing</category><body package="Grid">remove	next ifNil: [prior ifNotNil: [prior severSuccessor]]		ifNotNil: 			[prior ifNil: [grid ifNotNil: [grid updateRemoveVisualRow: self]].			next				moveTopSideTo: top;				moveIndexTo: index;				predecessor: prior;				updateSuccessorVisibility].	super remove</body></methods><methods><class-id>UI.GridVisualRow</class-id> <category>privileged</category><body package="Grid">rowBindingKey	^('row' , self index printString) asSymbol</body></methods><methods><class-id>UI.GridVisualRow</class-id> <category>updating</category><body package="Grid">updateSuccessorVisibility	"The receiver is visible but has changed its dimensions. 	Remove any successor that has dropped from visibility or add successor(s) that have come into visibiliy"	grid ifNil: [^self].	self downTo: grid bounds bottom.	self checkCellsWithSuccessors.</body><body package="Grid">visibleHeightValue: anInteger 	"Answer anInteger or the minimum visible column default height, whichever is larger"	^cells 		inject: anInteger 		into: [:sofar :each | sofar max: each visualColumn column defaultHeight]</body></methods><methods><class-id>UI.GridVisualRow</class-id> <category>enumerating</category><body package="Grid">withSuccessorsFrom: start to: end do: aBlock 	self withSuccessorsDo: 			[:each | 			each top &gt; end ifTrue: [^self].			each bottom &lt; start ifFalse:[aBlock value: each]]</body></methods><methods><class-id>UI.GridVisualRow</class-id> <category>bounds accessing</category><body package="Grid">bounds	^(self grid bounds left @ self top) corner: (self grid bounds right @ self bottom)</body></methods><methods><class-id>UI.GridVisualRow class</class-id> <category>instance creation</category><body package="Grid">on: aRow in: aGrid index: index top: top bottom: bottom 	^(self new)		row: aRow;		grid: aGrid;		index: index;		top: top;		bottom: bottom;		yourself</body></methods><methods><class-id>UI.GridTracker</class-id> <category>private</category><body package="Grid">finishSelectionFor: aPoint 	cleared ifTrue: [self view invalidateSelectionIndex: self view selectionIndex].	self controller selectUpAt: aPoint.	controller unlockCallbacks</body><body package="Grid">moveColumnFrom: aPoint pressedEvent: aMouseButtonEvent	"Drag resize or reorder columns" 	| tempColumnResizeAgent columnTracker |	self view editorFocusOut.	tempColumnResizeAgent := GridColumnResizeAgent new controller: controller.	columnTracker := (tempColumnResizeAgent okayToStartUpAt: aPoint)				ifTrue: [ColumnResizeTracker on: tempColumnResizeAgent]				ifFalse: 					[GridColumnDraggingTracker						on: (GridColumnDraggingAgent new controller: controller)].	columnTracker redButtonPressedEvent: aMouseButtonEvent</body><body package="Grid">moveRow: visualRow pressedEvent: aMouseButtonEvent	"Drag resize row visualRow"	visualRow allowResizing		ifTrue: 			[self view editorFocusOut.			(GridRowResizeTracker on: (GridRowResizeAgent new controller: controller))				redButtonPressedEvent: aMouseButtonEvent]</body><body package="Grid">outside	^controller outside</body><body package="Grid">outside: aBoolean	controller outside: aBoolean</body><body package="Grid">setUpFor: aMouseButtonEvent 	"Do the setup work for selection tracking"	| aPoint indx |	aPoint := self cursorPointFor: aMouseButtonEvent.	self controller outside: false.	indx := self controller findElementFor: aPoint.	self view dropEdit.	self view targetIndex: indx.	cleared := true</body><body package="Grid">startSelectingAt: aPoint 	((self view preferredBounds containsPoint: aPoint) and: [self view numberOfRows &gt; 0])		ifFalse: [^false].	[self controller lockCallbacks.	self view requestEditorFocusOut		ifTrue: 			[self view editorFocusOut.			^true]		ifFalse: [^false]] 	ensure: [self controller unlockCallbacks]</body><body package="Grid">trackSelectionFor: pt 	| box isInside |	box := self view bounds.	isInside := box containsPoint: pt.	self outside 		ifFalse: 			[isInside ifFalse: 				[self controller mouseExited.				self outside: true]]		ifTrue: 			[isInside ifTrue: 				[self controller mouseEnteredAt: pt.				self outside: false]].	cleared		ifFalse: 			[self view invalidateSelectionIndex: self view selectionIndex.			cleared := true].	self controller mouseMovedTo: pt.	self controller checkScrollingFrom: pt</body></methods><methods><class-id>UI.GridTracker</class-id> <category>events</category><body package="Grid">redButtonPressedEvent: aMouseButtonEvent	"Handle mouse select events to grid"	| aPoint |	(controller keyboardProcessor requestActivationFor: controller) ifFalse:[^self].	aPoint := self cursorPointFor: aMouseButtonEvent.	"Column resize or dragging"	(self view mayResizeColumnAt: aPoint)		ifTrue: [^self moveColumnFrom: aPoint pressedEvent: aMouseButtonEvent].	"Row resize"	self view allowRowResizing		ifTrue: 			[(self view visualRowAtEdge: aPoint)				ifNotNil: [:visualRow | ^self moveRow: visualRow pressedEvent: aMouseButtonEvent]].	"Toggle selection in cell"	controller toggleSelection</body></methods><methods><class-id>UI.GridColumnHeaderSpec</class-id> <category>private</category><body package="Grid">defaultModel	^AspectAdaptor forAspect: #sortDirection</body><body package="Grid">dispatchTo: policy with: builder	policy gridColumnHeaderBox: self into: builder</body></methods><methods><class-id>UI.GridVisualColumn</class-id> <category>testing</category><body package="Grid">canEdit	^column canEdit</body><body package="Grid">isFrozen	^grid notNil and:[index &lt;= grid frozen]</body><body package="Grid">isFullyVisible	| bounds |	bounds := grid bounds.	^self right &lt;= bounds right and: [self left &gt;= bounds left]</body><body package="Grid">isHeader	^self column isHeader</body></methods><methods><class-id>UI.GridVisualColumn</class-id> <category>private</category><body package="Grid">anyBoundsDefinedFromPredecessors	"Find the first visible column prior the receiver with defined bounds and recursively set the bounds of columns up to the receiver"	| result |	(left isNil or:[right isNil]) ifFalse:[^true].	(left notNil and: [right isNil]) 		ifTrue: 			[right := left + column widthWithGap.			^true].	(left isNil and: [right notNil]) 		ifTrue: 			[left := right - column widthWithGap max: 0.			^true].	prior ifNil: [^false].	result := prior anyBoundsDefinedFromPredecessors.	result 		ifTrue: 			[left := prior right.			right := left + column widthWithGap].	^result</body><body package="Grid">anyBoundsDefinedFromSuccessors	"Find the first visible column after the receiver with defined bounds and recursively set the bounds of columns back to the receiver"	| result |	(left isNil or:[right isNil]) ifFalse:[^true].	(left notNil and: [right isNil]) 		ifTrue: 			[right := left + column widthWithGap.			^true].	(left isNil and: [right notNil]) 		ifTrue: 			[left := right - column widthWithGap max: 0.			^true].	next ifNil: [^false].	result := next anyBoundsDefinedFromSuccessors.	result 		ifTrue: 			[right := next left.			left := right - column widthWithGap max: 0].	^result</body><body package="Grid">checkCells	"Create or remove cells as needed to fill the column in the grid"	| gridBounds |	grid ifNil: [^self].	cells size = grid visibleRowCount ifTrue: [^self].	gridBounds := grid bounds.	self removeUnusedCells.	(self right &gt; gridBounds left and: [self left &lt; gridBounds right]) 		ifTrue: [self createCells]</body><body package="Grid">createCells	grid firstVisibleRow 		withSuccessorsDo: [:row | GridVisualCell visualColumn: self visualRow: row]</body><body package="Grid">invalidateGridRight: aNumber	grid invalidateRectangle: (grid bounds left: aNumber)</body><body package="Grid">resetBorders	left := right := nil</body><body package="Grid">updateColumnWidth	self moveRightSideTo: left + column widthWithGap.	self updateSuccessorVisibility.	self invalidateGridRight: left</body></methods><methods><class-id>UI.GridVisualColumn</class-id> <category>accessing</category><body package="Grid">allowResizing	^column allowResizing and: [column showColumnLine]</body><body package="Grid">backgroundColor	^(cells detect:[:each| each isHeader not] ifNone:[^nil]) backgroundColor</body><body package="Grid">cellLeft	^self left + column paddingLeft</body><body package="Grid">cellRight	^self right - column paddingRight</body><body package="Grid">column	^column</body><body package="Grid">column: aGridColumn	column := aGridColumn</body><body package="Grid">gridEnd	^(self class new)		column: grid columns last;		grid: grid;		index: grid columns size;		right: grid scrollableExtent x;		yourself</body><body package="Grid">gridOrigin	^(self class new)		column: grid columns first;		grid: grid;		index: 1;		left: 0;		yourself</body><body package="Grid">left	^left ifNil: 			[right ifNotNil: 					[left := right - column widthWithGap max: 0]				ifNil: 					[self anyBoundsDefinedFromPredecessors ifTrue: [^left].					self anyBoundsDefinedFromSuccessors ifTrue: [^left].					nil]]</body><body package="Grid">left: aNumber	left := aNumber</body><body package="Grid">paneLeft	^self left + grid leftOffset</body><body package="Grid">paneRight	^self right + grid leftOffset</body><body package="Grid">right	^right ifNil: 			[left ifNotNil: 					[right := left + column widthWithGap]				ifNil: 					[self anyBoundsDefinedFromPredecessors ifTrue: [^right].					self anyBoundsDefinedFromSuccessors ifTrue: [^right].					nil]]</body><body package="Grid">right: aNumber	right := aNumber</body><body package="Grid">visualForColumn: aGridColumn do: aBlock 	"There must be a unique GridColumn for each GridVisualColumn to ensure that a single match occurs"	aBlock 		value: (self withSuccessorsDetect: [:each | each column = aGridColumn]				ifNone: [^self])</body><body package="Grid">visualForColumn: aGridColumn ifNone: aBlock	^self withSuccessorsDetect: [:each | each column = aGridColumn] ifNone: aBlock</body><body package="Grid">width	^column width</body><body package="Grid">width: aNumber 	column width: aNumber</body></methods><methods><class-id>UI.GridVisualColumn</class-id> <category>list creation and access</category><body package="Grid">firstVisibleColumnBetween: leftGridEdge and: rightGridEdge 	"Answer the lowest index GridVisualColumn that heads a linked collection of GridVisualColumns visible between leftGridEdge and rightGridEdge left of the receiver.  Trim and release GridVisualColumns outside of leftGridEdge and rightGridEdge"	| startColumn |	startColumn := self jumpTo: leftGridEdge.	startColumn rightTo: rightGridEdge joining: self.	^startColumn releasePredecessors</body><body package="Grid">jumpTo: aNumber 	"Answer a new instance without ancestors whose endpoints stride aNumber. Start from a known position: the receiver, the grid's last column, or the grid's first column, whichever is closer to aNumber"	| endColumn |	endColumn := self nearest: aNumber.	(aNumber between: endColumn left and: endColumn right) 		ifTrue: [^endColumn].	grid scrollableExtent x - endColumn right 		&lt;= (aNumber - endColumn right) abs ifTrue: [endColumn := self gridEnd].	endColumn left &lt;= (aNumber - endColumn left) abs 		ifTrue: [endColumn := self gridOrigin].	[aNumber between: endColumn left and: endColumn right] whileFalse: 			[endColumn right &lt; aNumber 				ifTrue: 					[endColumn newSuccessor ifNil: [^endColumn]						ifNotNil: [:value | endColumn := value severPredecessor]].			endColumn left &gt; aNumber 				ifTrue: 					[endColumn newPredecessor ifNil: [^endColumn]						ifNotNil: [:value | endColumn := value severSuccessor]]].	^endColumn</body><body package="Grid">jumpToIndex: anInteger 	"Answer a new instance without ancestors at index anInteger. Start from a known position: the receiver, the grid's last row, or the grid's first row, whichever is closer to anInteger"	| firstIndex lastIndex endColumn |	firstIndex := self first index.	lastIndex := self last index.	(anInteger between: firstIndex and: lastIndex) 		ifTrue: [^self atIndex: anInteger].	endColumn := anInteger &gt; lastIndex 				ifTrue: [self last]				ifFalse: [self first].	grid columns size - anInteger &lt; (anInteger - lastIndex) abs 		ifTrue: [endColumn := self gridEnd].	anInteger &lt; (firstIndex - anInteger) abs 		ifTrue: [endColumn := self gridOrigin].	[endColumn index = anInteger] whileFalse: 			[endColumn index &lt; anInteger 				ifTrue: 					[endColumn newSuccessor ifNil: [^endColumn]						ifNotNil: [:value | endColumn := value severPredecessor]].			endColumn index &gt; anInteger 				ifTrue: 					[endColumn newPredecessor ifNil: [^endColumn]						ifNotNil: [:value | endColumn := value severSuccessor]]].	^endColumn</body><body package="Grid">leftTo: aNumber 	"Add to or trim predecessors from the linked collection of GridVisualColumns such that the endpoints of the first GridVisualColumn stride aNumber"	| startColumn |	startColumn := self nearest: aNumber.	[startColumn left &lt;= aNumber and: [startColumn right &gt; aNumber]] whileFalse: 			[startColumn := startColumn newPredecessor ifNil: [^self]						ifNotNil: [:priorColumn | priorColumn successor: startColumn]].	startColumn releasePredecessors</body><body package="Grid">leftTo: aNumber joining: aGridVisualColumn 	"Answer a GridVisualColumn that extends left to span aNumber joining with any portion of aGridVisualColumn left of the receiver but before aNumber.  Release all unused portions of the receiver or aGridVisualColumn."	| lastColumnToJoin |	aNumber &gt; self right 		ifTrue: 			[self 				error: (#targetPreceedsBorder &lt;&lt; #dialogs 						&gt;&gt; 'Target &lt;1p&gt; preceeds receiver' expandMacrosWith: aNumber)].	self == (aGridVisualColumn nearest: self right) ifTrue:[^(self releaseSuccessors leftTo: aNumber) first].	lastColumnToJoin := aGridVisualColumn last.	(self right &lt; aGridVisualColumn first left 		or: [aNumber &gt;= lastColumnToJoin right]) 			ifTrue: 				[aGridVisualColumn releaseAll.				^(self releaseSuccessors leftTo: aNumber) first].	^(lastColumnToJoin right &gt; self right 		ifTrue: 			[(aGridVisualColumn nearest: self left)				releaseSuccessors;				leftTo: aNumber]		ifFalse: 			[self leftTo: lastColumnToJoin right.			lastColumnToJoin successor: self first.			lastColumnToJoin leftTo: aNumber.			lastColumnToJoin]) 			first</body><body package="Grid">nearest: aNumber 	"Answer the column in the linked list between or nearest aNumber width"	(aNumber between: self left and: self right) ifTrue: [^self].	next ifNotNil: [self right &lt; aNumber ifTrue: [^next nearest: aNumber]].	prior ifNotNil: [self left &gt; aNumber ifTrue: [^prior nearest: aNumber]]</body><body package="Grid">newPredecessor	| columns priorIndex priorColumn |	(index = 1 or: [(columns := grid columns) isEmpty]) ifTrue: [^nil].	priorIndex := index - 1.	priorColumn := columns at: priorIndex.	^GridVisualColumn 		on: priorColumn		in: grid		index: priorIndex		left: nil		right: self left</body><body package="Grid">newSuccessor	| columns nextIndex |	columns := grid columns.	(columns isEmpty or: [index &gt;= columns size]) ifTrue: [^nil].	nextIndex := index + 1.	^GridVisualColumn 		on: (columns at: nextIndex)		in: grid		index: nextIndex		left: self right		right: nil</body><body package="Grid">rightTo: aNumber 	"Add to or trim successors from the linked collection of the receiver such that the endpoints of the last GridVisualColumn stride aNumber"	| endColumn |	endColumn := self nearest: aNumber.	[endColumn left &lt; aNumber and: [endColumn right &gt;= aNumber]] whileFalse: 			[endColumn := endColumn newSuccessor ifNil: [^self]						ifNotNil: [:nextColumn | nextColumn predecessor: endColumn]].	endColumn releaseSuccessors.</body><body package="Grid">rightTo: aNumber joining: aGridVisualColumn 	"Answer a GridVisualColumn that extends right to span aNumber joining with any portion of aGridVisualColumn below the receiver but above aNumber.  Release all unused portions of the receiver or aGridVisualColumn."	| firstColumnToJoin |	aNumber &lt; self left 		ifTrue: 			[self 				error: (#targetPreceedsBorder &lt;&lt; #dialogs 						&gt;&gt; 'Target &lt;1p&gt; preceeds receiver' expandMacrosWith: aNumber)].	self == (aGridVisualColumn nearest: self left) 		ifTrue: [^self releasePredecessors rightTo: aNumber].	firstColumnToJoin := aGridVisualColumn first.	(self left &gt; aGridVisualColumn last right 		or: [aNumber &lt;= firstColumnToJoin left]) 			ifTrue: 				[aGridVisualColumn releaseAll.				^self releasePredecessors rightTo: aNumber].	^firstColumnToJoin left &lt; self left 		ifTrue: 			[(aGridVisualColumn nearest: self right)				releasePredecessors;				rightTo: aNumber]		ifFalse: 			[self rightTo: firstColumnToJoin left.			firstColumnToJoin predecessor: self last.			firstColumnToJoin rightTo: aNumber.			self]</body></methods><methods><class-id>UI.GridVisualColumn</class-id> <category>resizing</category><body package="Grid">moveLeftSideTo: aNumberOrNil	"Shift the left position of the receiver to aNumberOrNil and recursively shift right all columns to its right accordingly.  If nil, my position and those of successor columns will be determined later."	left := aNumberOrNil.	self moveRightSideTo: (left ifNotNil:[left + column widthWithGap]).</body><body package="Grid">moveRightSideTo: aNumberOrNil	"Move the right position of the receiver to aNumber and recursively shift right all columns to its right accordingly. Note this must be accompanied by a change in the left position or width of the column to make its layout consistent .If nil, my position and those of successor columns will be determined later."	right := aNumberOrNil.	next ifNotNil:[next moveLeftSideTo: right].	self updateLayout</body></methods><methods><class-id>UI.GridVisualColumn</class-id> <category>initialize-release</category><body package="Grid">release	super release.	column := nil.</body><body package="Grid">releaseCellsIndexedFrom: anInteger 	cells copy 		do: [:cell | cell cellPoint y &gt;= anInteger ifTrue: [cell release]]</body></methods><methods><class-id>UI.GridVisualColumn</class-id> <category>removing</category><body package="Grid">remove	next ifNil: [prior ifNotNil: [prior severSuccessor]]		ifNotNil: 			[prior ifNil: [grid ifNotNil: [grid updateRemoveVisualColumn: self]].			next				moveLeftSideTo: left;				moveIndexTo: index;				predecessor: prior;				updateSuccessorVisibility].	super remove</body></methods><methods><class-id>UI.GridVisualColumn</class-id> <category>scrolling</category><body package="Grid">scrollToFullView	"Scroll as required to make the column fully visible"	column scrollToView: #nearest</body><body package="Grid">shiftLeft	"Answer the head of the linked collection of GridVisualColumns shifting the collection left to make them visible in the Grid."	| bounds |	bounds := grid bounds.	^self firstVisibleColumnBetween: bounds left and: bounds right</body><body package="Grid">shiftRight	"Answer the head of the linked collection of GridVisualColumns shifting the collection right to make them visible in the Grid."	^self firstVisibleColumnBetween: grid scrollableEdge		and: grid bounds right</body></methods><methods><class-id>UI.GridVisualColumn</class-id> <category>enumerating</category><body package="Grid">withSuccessorsFrom: start to: end do: aBlock 	self withSuccessorsDo: 			[:each | 			each left &gt; end ifTrue: [^self].			each right &lt; start ifFalse:[aBlock value: each]]</body></methods><methods><class-id>UI.GridVisualColumn</class-id> <category>updating</category><body package="Grid">updateSuccessorVisibility	"The receiver is visible but has changed its dimensions. Remove any successor that has dropped from visibility or add a successor that has come into visibiliy"	grid ifNil: [^self].	self rightTo: grid bounds right.	self checkCellsWithSuccessors</body></methods><methods><class-id>UI.GridVisualColumn class</class-id> <category>instance creation</category><body package="Grid">on: aSimpleColumn in: aGrid index: index left: left right: right 	^(self new)		column: aSimpleColumn;		grid: aGrid;		index: index;		left: left;		right: right;		yourself</body></methods><methods><class-id>UI.GridColumnResizeAgent</class-id> <category>event driven</category><body package="Grid">adjustTo: anInteger 	| delta |	delta := anInteger - selectedColumn right.	delta isZero ifTrue: [^self].	selectedColumn width: selectedColumn width + delta</body><body package="Grid">checkScrollingFrom: cursorPoint 	"Scroll up or down if needed"	| bounds cursorElevation |		self notYetImplemented.	bounds := controller view bounds.	cursorElevation := cursorPoint y.	cursorElevation &lt; bounds top ifTrue:[].	cursorElevation &gt; bounds bottom ifTrue:[].</body><body package="Grid">mouseMovedTo: aPoint 	| horizontalPosition |	horizontalPosition := aPoint x.	horizontalPosition &gt; selectedColumn left ifFalse: [^self].	self adjustTo: horizontalPosition</body><body package="Grid">okayToStartUpAt: aPoint 	selectedColumn := controller view visualColumnAtEdge: aPoint.	^selectedColumn ifNil: [false] ifNotNil: [selectedColumn allowResizing]</body></methods><methods><class-id>UI.GridRowResizeTracker</class-id> <category>private</category><body package="Grid">finishSelectionFor: aPoint	self controller selectUpAt: aPoint.	self controller unlockCallBacks.</body><body package="Grid">outside	^self controller outside</body><body package="Grid">outside: aBoolean	self controller outside: aBoolean</body><body package="Grid">setUpFor: aMouseButtonEvent 	self outside: (self controller controlBounds containsPoint: (self cursorPointFor: aMouseButtonEvent)) not</body><body package="Grid">trackSelectionFor: aPoint 	| isInside |	isInside := self controller controlBounds containsPoint: aPoint.	self outside 		ifFalse: 			[isInside ifFalse: 				[self controller mouseExited.				self outside: true]]		ifTrue: 			[isInside ifTrue: 				[self controller mouseEnteredAt: aPoint.				self outside: false]].	self controller mouseMovedTo: aPoint.	self controller checkScrollingFrom: aPoint</body></methods><methods><class-id>UI.GridRowResizeTracker</class-id> <category>events</category><body package="Grid">redButtonPressedEvent: aMouseButtonEvent 	| cursorPoint resizing |	cursorPoint := self cursorPointFor: aMouseButtonEvent.	controller view allowRowResizing ifFalse: [^self].	resizing := controller okayToStartUpAt: cursorPoint.	resizing ifTrue: 		[controller lockCallBacks.		super redButtonPressedEvent: aMouseButtonEvent]</body></methods><methods><class-id>UI.GridRowHeaderView</class-id> <category>updating</category><body package="Grid">update: aspectSymbol with: parameter from: sender 	"Some aspect of the model has changed."	aspectSymbol == #value 		ifTrue: [sender == model ifTrue: [self redisplayForTransitionChange]].	^super 		update: aspectSymbol		with: parameter		from: sender</body></methods><methods><class-id>UI.GridRowHeaderView</class-id> <category>controller accessing</category><body package="Grid">defaultControllerClass	^ToggleButtonController</body></methods><methods><class-id>UI.GridRowHeaderView</class-id> <category>private</category><body package="Grid">getBorder	^GridHeaderBorder width: 1</body><body package="Grid">redisplayFocusChange	" Do not redisplay the receiver during a keyboard focus change."</body><body package="Grid">redisplayForTransitionChange	"Do not redisplay the receiver during the transition between being pressed/unpressed."</body></methods><methods><class-id>UI.GridRowHeaderView</class-id> <category>initialize-release</category><body package="Grid">release	model release.	super release.</body></methods><methods><class-id>UI.GridRowHeaderView</class-id> <category>display box accessing</category><body package="Grid">preferredBounds	"Answer the rectangle of the preferredBounds for the receiver"	| labelExtent |	labelExtent := label preferredBounds extent.	^Rectangle origin: 0 @ 0		corner: (labelExtent x + 6) @ labelExtent y + (2 @ 2)</body></methods><methods><class-id>UI.GridRowHeaderView</class-id> <category>displaying</category><body package="Grid">displayLabelOn: aGraphicsContext in: aRectangle	"Display the label visual on aGraphicsContext centered in aRectangle"	label ifNil: [^self].	self setPaintOn: aGraphicsContext.	label displayOn: aGraphicsContext		at: aRectangle center - (label bounds extent // 2)</body><body package="Grid">displayOn: aGraphicsContext	| box |	box := self bounds.	self getBorder		ifNotNil: 			[:border |			border displayOn: aGraphicsContext forDisplayBox: box using: self.			box := border insetDisplayBoxFor: box].	self displayBackgroundIfNeededOn: aGraphicsContext in: box.	self displayLabelOn: aGraphicsContext in: box.</body></methods><methods><class-id>UI.GridRowHeaderView class</class-id> <category>accessing</category><body package="Grid">rowSelectionImage	rowSelectionImage ifNil: [rowSelectionImage := GridIcons RightArrow1].	^rowSelectionImage</body></methods><methods><class-id>UI.GridRowHeaderView class</class-id> <category>resources</category><body package="Grid">rowSelectionArrowImage	^GridIcons RightArrow1</body></methods><methods><class-id>UI.GridColumnSortConstraint</class-id> <category>combining</category><body package="Grid">&amp; aGridColumnSortConstraint 	^self copy 		childConstraint: (childConstraint ifNil: [aGridColumnSortConstraint]				ifNotNil: [childConstraint &amp; aGridColumnSortConstraint])</body><body package="Grid">childConstraint: aGridColumnSortConstraint	childConstraint := aGridColumnSortConstraint</body></methods><methods><class-id>UI.GridColumnSortConstraint</class-id> <category>initialize-release</category><body package="Grid">clearSortDirection	sortDirection := nil</body><body package="Grid">column: aGridColumn	columnAdaptor := aGridColumn adaptor.</body><body package="Grid">initialize	printAdaptor := [:a | a]</body></methods><methods><class-id>UI.GridColumnSortConstraint</class-id> <category>evaluating</category><body package="Grid">gridRowConstraint	^[:a :b | self value: a item value: b item]</body><body package="Grid">value: a value: b 	sortDirection == #ascending ifTrue: [^self sortAscending: a and: b].	sortDirection == #descending ifTrue: [^self sortDescending: a and: b].	^true</body></methods><methods><class-id>UI.GridColumnSortConstraint</class-id> <category>private</category><body package="Grid">literalArrayEncoding	| omitted class default array value |	omitted := #('grid' 'sortConstraint').	class := self class.	default := class new.	array := OrderedCollection with: class fullyQualifiedReference.	class allInstVarNames keysAndValuesDo: 			[:i :name | 			value := self instVarAt: i.			((omitted includes: name) or: [value == (default instVarAt: i)]) 				ifFalse: 					[array add: (name , ':') asSymbol.					array add: value literalArrayEncoding]].	^array asArray</body><body package="Grid">sortAscending: item1 and: item2 	| cellSortValue1 cellSortValue2 |	cellSortValue1 := printAdaptor value: (columnAdaptor valueUsingSubject: item1).	cellSortValue2 := printAdaptor value: (columnAdaptor valueUsingSubject: item2).	^cellSortValue1 &lt; cellSortValue2 or: 			[childConstraint notNil and: 					[cellSortValue1 = cellSortValue2 						and: [childConstraint value: item1 value: item2]]]</body><body package="Grid">sortDescending: item1 and: item2 	| cellSortValue1 cellSortValue2 |	cellSortValue1 := printAdaptor value: (columnAdaptor valueUsingSubject: item1).	cellSortValue2 := printAdaptor value: (columnAdaptor valueUsingSubject: item2).	^cellSortValue1 &gt; cellSortValue2 or: 			[childConstraint notNil and: 					[cellSortValue1 = cellSortValue2 						and: [childConstraint value: item1 value: item2]]]</body></methods><methods><class-id>UI.GridColumnSortConstraint</class-id> <category>copying</category><body package="Grid">postCopy	super postCopy.	childConstraint := childConstraint copy</body></methods><methods><class-id>UI.GridColumnSortConstraint</class-id> <category>accessing</category><body package="Grid">printAdaptor: aBlock	printAdaptor := aBlock</body><body package="Grid">sortDirection	^sortDirection</body><body package="Grid">sortDirection: aSymbolOrNil	sortDirection := aSymbolOrNil</body><body package="Grid">sortDirectionToggled	^sortDirection == #descending ifTrue: [#ascending] ifFalse: [#descending]</body></methods><methods><class-id>UI.GridColumnSortConstraint class</class-id> <category>instance creation</category><body package="Grid">on: aGridColumn 	^self new initialize column: aGridColumn</body></methods><methods><class-id>UI.GridHilightRow</class-id> <category>accessing</category><body package="Grid">alternateBackgroundColor	^alternateBackgroundColor ifNil:[ColorValue veryLightGray]</body><body package="Grid">alternateBackgroundColor: aColorValue	alternateBackgroundColor := aColorValue</body></methods><methods><class-id>UI.GridHilightRow</class-id> <category>private-building</category><body package="Grid">specForCell: aGridVisualCell appliedTo: aUISpecification 	"The receiver is given a chance to modify or replace aUISpecification for building the widget appearing in aGridVisualCell for this row in the Grid"	self index odd 		ifTrue: 			[| lineBackgroundPref |			lineBackgroundPref := LookPreferences new 						setBackgroundColor: self alternateBackgroundColor.			aUISpecification colors 				ifNil: [aUISpecification colors: lineBackgroundPref]				ifNotNil: [:colors | lineBackgroundPref applyTo: colors]].	^aUISpecification</body></methods><methods><class-id>UI.GridColumnDraggingAgent</class-id> <category>accessing</category><body package="Grid">grid	^controller view</body></methods><methods><class-id>UI.GridCell</class-id> <category>comparing</category><body package="Grid">= aGridCell 	^self species = aGridCell species 		and: [column = aGridCell column and: [row = aGridCell row]]</body><body package="Grid">hash	^column hash bitXor: row hash</body></methods><methods><class-id>UI.GridCell</class-id> <category>accessing</category><body package="Grid">cellPoint	^column ifNotNil: [row ifNotNil: [column index @ row index]]</body><body package="Grid">column	^column</body><body package="Grid">column: aGridColumn	column := aGridColumn</body><body package="Grid">grid	^column grid</body><body package="Grid">peerForColumn: aGridColumn	"Answer the GridCell intersecting aGridColumn and my row"	^GridCell		column: aGridColumn		row: self row</body><body package="Grid">peerForRow: aGridRow	"Answer the GridCell intersecting aGridRow and my column"		^GridCell		column: self column		row: aGridRow</body><body package="Grid">row	^row</body><body package="Grid">row: aGridRow	row := aGridRow</body><body package="Grid">value	^self isHeader 		ifTrue: [nil]		ifFalse: 			[column adaptor ifNotNil: [:adaptor | adaptor valueUsingSubject: row item]]</body><body package="Grid">value: anObject	"For now I make no attempt to restore the original subject"	(column adaptor subject: row item) value: anObject</body></methods><methods><class-id>UI.GridCell</class-id> <category>initialize-release</category><body package="Grid">column: aGridColumn row: aGridRow	row := aGridRow.	column := aGridColumn.</body><body package="Grid">release	super release.	row := column := nil.</body></methods><methods><class-id>UI.GridCell</class-id> <category>testing</category><body package="Grid">isEditable	^self isValid and:[self isVisible]</body><body package="Grid">isHeader	^column isHeader or:[row isHeader]</body><body package="Grid">isSelected	| cellPoint |	cellPoint := self cellPoint.	^self grid selectionRange contains: [:range | (range expandedBy: (0 @ 0 extent: 1 @ 1)) containsPoint: cellPoint]</body><body package="Grid">isValid	"Answer if either my column or row is present in my grid"	^column isValid and:[row isValid]</body><body package="Grid">isVisible		"Answer if the cell position is currently visible in the Grid"	^self grid ifNil: [false]		ifNotNil: [:grid | grid isCellVisible: self cellPoint]</body></methods><methods><class-id>UI.GridCell</class-id> <category>scrolling</category><body package="Grid">scrollToRowView: verticalPosition andColumnView: horizontalPosition 	"Scroll the Grid pane to make the receiver visible in the preferred position aSymbol.  Possible values are #top, #bottom, #center, or #nearest for verticalPosition or #left, #right, #center, or #nearest for horizontalPosition."	self grid ifNotNil: 			[:grid | 			grid 				scrollCell: self				toRowView: verticalPosition				andColumnView: horizontalPosition]</body><body package="Grid">scrollToView	self scrollToRowView: #nearest andColumnView: #nearest</body></methods><methods><class-id>UI.GridCell</class-id> <category>selection</category><body package="Grid">isSelected: aBoolean		self grid cellAt: self cellPoint beSelected: aBoolean</body></methods><methods><class-id>UI.GridCell</class-id> <category>visibility</category><body package="Grid">ifVisibleDo: aBlock	"If the receiver is visible in the grid perform aBlock with the receiver's GridVisualCell"	self grid ifNotNil:[:grid| (grid visualCellAtPoint: self cellPoint) ifNotNil: aBlock]</body></methods><methods><class-id>UI.GridCell class</class-id> <category>instance creation</category><body package="Grid">column: aGridColumn row: aGridRow 	^self new column: aGridColumn row: aGridRow</body></methods><methods><class-id>UI.GridInterface</class-id> <category>accessing-columns</category><body package="Grid">columnAtNameKey: aSymbol	^self columns detect:[:each| each id = aSymbol] ifNone: nil</body><body package="Grid">columns	^grid columns</body><body package="Grid">columns: aList	grid columns: aList</body><body package="Grid">headerColumn	^headerColumn</body><body package="Grid">headerColumn: aGridHeaderColumnOrNil	headerColumn := aGridHeaderColumnOrNil.	headerColumn		ifNotNil: 			[headerColumn gridBody: self grid.			headerColumn width				ifNil: [headerColumn width: self defaultColumnWidth]].	self changed: #headerColumn with: aGridHeaderColumnOrNil</body></methods><methods><class-id>UI.GridInterface</class-id> <category>selection</category><body package="Grid">clearAll	selectionInGrid clearAll</body><body package="Grid">selectAll	selectionInGrid selectAll</body><body package="Grid">selectPoint: aPoint 	grid selectPoint: aPoint</body><body package="Grid">selectRange: aRectangle 	grid selectRange: aRectangle</body><body package="Grid">selectedElements	"Answer all selected GridRows or GridCells in the grid"	^grid selectedGridElements</body><body package="Grid">selection	"If the grid is in row select mode answer the item for the first selected row in the grid. If the grid is in cell select mode answer the value for the first cell selected. Answer nil if there are no selections"		grid selectByCell		ifTrue: [grid selectionCellDo: [:value | ^value]]		ifFalse: [grid selectionDo: [:row | ^row item]].	^nil</body><body package="Grid">selections	"For row select mode answer the items for rows with cell selections in the grid. For cell select mode answer the values of selected cells"		^grid selectByCell		ifTrue: [self selectedElements collect: [:cell | cell value]]		ifFalse: [self selectedElements collect: [:row | row item]]</body><body package="Grid">selections: aCollection	"Select the rows that represent the items in aCollection"	self rows do: [:row| row isSelected: (aCollection includes: row item)]</body></methods><methods><class-id>UI.GridInterface</class-id> <category>indirection</category><body package="Grid">allowColumnReordering	^grid allowColumnReordering</body><body package="Grid">allowColumnReordering: aBoolean	grid allowColumnReordering: aBoolean.	self decorator hasHeaderRow ifTrue:[self decorator headerRowGrid allowColumnReordering: aBoolean]</body><body package="Grid">allowColumnResizing	^grid allowColumnResizing</body><body package="Grid">allowColumnResizing: aBoolean	grid allowColumnResizing: aBoolean.	self decorator hasHeaderRow ifTrue:[self decorator headerRowGrid allowColumnResizing: aBoolean]</body><body package="Grid">allowRowResizing	^grid allowRowResizing</body><body package="Grid">allowRowResizing: aBoolean	grid allowRowResizing: aBoolean</body><body package="Grid">multiSelect	^grid multiSelect</body><body package="Grid">multiSelect: aBoolean 	grid multiSelect: aBoolean</body><body package="Grid">selectByCell 	^grid selectByCell</body><body package="Grid">selectByCell: aBoolean	grid selectByCell: aBoolean</body></methods><methods><class-id>UI.GridInterface</class-id> <category>accessing-rows</category><body package="Grid">headerRow	^headerRow</body><body package="Grid">headerRow: aGridHeaderRowOrNil	headerRow := aGridHeaderRowOrNil.	headerRow		ifNotNil: 			[headerRow gridBody: self grid.			headerRow rawHeight ifNil: [headerRow height: self defaultRowHeight]].	self changed: #headerRow with: aGridHeaderRowOrNil</body><body package="Grid">rows	^self selectionInGrid list</body><body package="Grid">rows: aList	self selectionInGrid list: aList.</body></methods><methods><class-id>UI.GridInterface</class-id> <category>accessing</category><body package="Grid">defaultColumnWidth	^defaultColumnWidth</body><body package="Grid">defaultColumnWidth: aNumberOrNil	defaultColumnWidth := aNumberOrNil</body><body package="Grid">defaultRowHeight	^defaultRowHeight ifNil:[grid ifNotNil:[grid defaultRowHeight]]</body><body package="Grid">defaultRowHeight: aNumberOrNil	defaultRowHeight := aNumberOrNil.	grid ifNotNil:[grid defaultRowHeight: aNumberOrNil].</body><body package="Grid">grid	^grid</body><body package="Grid">grid: aGrid	"Need to update components such as headers to reference new aGrid here"	grid := aGrid.	aGrid selectionInGrid: selectionInGrid.</body><body package="Grid">items	^items</body><body package="Grid">items: aList		items removeDependent: self.	items := aList.	items addDependent: self</body><body package="Grid">selectionInGrid	^selectionInGrid</body><body package="Grid">selectionInGrid: aSelectionInGrid	selectionInGrid := aSelectionInGrid.	grid ifNotNil:[grid selectionInGrid: selectionInGrid].</body></methods><methods><class-id>UI.GridInterface</class-id> <category>updating</category><body package="Grid">update: anAspect with: anArg from: anObject	"An object that the receiver's depends on has changed.  Perform an appropriate action."		(grid notNil and:[anObject == self items]) 		ifTrue:			[anAspect == #at: ifTrue: [^self updateAt: anArg].			anAspect == #add ifTrue: [^self updateInsert: self items size].			anAspect == #insert:				ifTrue:					[^self updateInsert: anArg].			anAspect == #replace: ifTrue: [^self updateReplace: anArg].			anAspect == #remove: ifTrue: [^self updateRemove: anArg].			anAspect == #removeFrom:to: ifTrue: [^self updateRemoveRange: anArg].			anAspect == #insertCollection:				ifTrue: [^self updateInsertCollection: anArg].			anAspect == #appendCollection:				ifTrue: [^self updateAppendCollection: anArg]].	super update: anAspect with: anArg from: anObject</body><body package="Grid">updateAppendCollection: anInteger		| numberOfItems |	numberOfItems := self items size.	self rows		addAll:			((numberOfItems - anInteger + 1 to: numberOfItems)				collect: [:index | self gridRowFor: (self items at: index)])</body><body package="Grid">updateAt: anInteger		(self rows at: anInteger) item: (self items at: anInteger).	grid setVisibleRows</body><body package="Grid">updateInsert: anIndex		self rows		add: (self gridRowFor: (self items at: anIndex))		beforeIndex: anIndex</body><body package="Grid">updateInsertCollection: anArray	"A collection of items have been inserted. Update the rows."	"anArray = #('index to insert before' 'total size of collection afterward')"		| insertPosition |	insertPosition := anArray first.	self rows		addAll:			((insertPosition to: insertPosition + anArray last - 1)				collect:					[:index | self rowWithItem: (self items at: index)])		beforeIndex: insertPosition</body><body package="Grid">updateRemove: anInteger	self rows removeAtIndex: anInteger</body><body package="Grid">updateRemoveRange: anArray	self rows removeFrom: anArray first to: anArray last.</body><body package="Grid">updateReplace: anArray	anArray first to: anArray last		do: [:index | (self rows at: index) item: (self items at: index)].	grid setVisibleRows</body></methods><methods><class-id>UI.GridInterface</class-id> <category>private</category><body package="Grid">decorator	^grid ifNotNil:[grid container container container]</body><body package="Grid">defaultHeaderRow	^GridHeaderRow new height: self defaultRowHeight; gridBody: self grid; yourself</body><body package="Grid">gridRowFor: anObject	^GridRow on: anObject height: self defaultRowHeight</body><body package="Grid">rowWithItem: anObject	^grid rows detect:[:row| row item = anObject] ifNone: nil</body></methods><methods><class-id>UI.GridInterface</class-id> <category>modes</category><body package="Grid">beMultiSelect	grid multiSelect: true</body><body package="Grid">beSingleSelect	grid multiSelect: false</body></methods><methods><class-id>UI.GridInterface</class-id> <category>testing</category><body package="Grid">hasSelections	^selectionInGrid selectionRange notEmpty</body></methods><methods><class-id>UI.GridInterface</class-id> <category>initialize-release</category><body package="Grid">initialize	selectionInGrid := SelectionInGrid new.	self items: List new.	self grid: Grid new.</body></methods><methods><class-id>UI.GridInterface</class-id> <category>list maintenance</category><body package="Grid">setItemsFromRows	"Set my items from the data (non-header) rows of my grid"	self items: (self rows collect:[:row| row item])</body><body package="Grid">setRowsFromItems	"Set the rows of my grid from my items list"	self selectionInGrid		list: (self items collect: [:each | self gridRowFor: each])</body></methods><methods><class-id>UI.GridInterface class</class-id> <category>instance creation</category><body package="Grid">new	^super new initialize</body></methods><methods><class-id>UI.GridSpec</class-id> <category>accessing</category><body package="Grid">addRowIndicator	self rowIndicator ifTrue: [^self].	columns addFirst: GridHeaderColumn new</body><body package="Grid">allowRowResizing	^allowRowResizing</body><body package="Grid">allowRowResizing: aBoolean	allowRowResizing := aBoolean</body><body package="Grid">hasHeaderColumn	^headerColumn notNil</body><body package="Grid">hasHeaderColumn: aBoolean	headerColumn := aBoolean				ifTrue: [self defaultHeaderColumn]				ifFalse: [nil]</body><body package="Grid">hasHeaderRow	^headerRow notNil</body><body package="Grid">hasHeaderRow: aBoolean	headerRow := aBoolean				ifTrue: [self defaultHeaderRow]				ifFalse: [nil]</body><body package="Grid">headerColumn	^headerColumn</body><body package="Grid">headerColumn: encodingOrHeaderColumn	headerColumn := (encodingOrHeaderColumn isSymbol not and: [encodingOrHeaderColumn size &gt; 0 and: [encodingOrHeaderColumn isLiteral]])				ifTrue: [encodingOrHeaderColumn decodeAsLiteralArray]				ifFalse: [encodingOrHeaderColumn]</body><body package="Grid">headerRow	^headerRow</body><body package="Grid">headerRow: encodingOrHeaderRow	headerRow := (encodingOrHeaderRow isSymbol not and: [encodingOrHeaderRow size &gt; 0 and: [encodingOrHeaderRow isLiteral]])				ifTrue: [encodingOrHeaderRow decodeAsLiteralArray]				ifFalse: [encodingOrHeaderRow]</body><body package="Grid">lineNumberOffset	^self hasHeaderColumn ifTrue: [columns first offset] ifFalse: [nil]</body><body package="Grid">lineNumberOffset: aNumber	self rowIndicator ifTrue:[columns first offset: aNumber].</body><body package="Grid">removeRowIndicator	self rowIndicator ifFalse:[^self].	columns removeFirst.</body><body package="Grid">rowIndicator	^columns size &gt; 0 and: [columns first isHeader]</body><body package="Grid">selectByCell	^selectByCell</body><body package="Grid">selectByCell: aBoolean	selectByCell := aBoolean</body><body package="Grid">showLineNumbers	^self hasHeaderColumn ifTrue: [columns first lineNumbers] ifFalse: [false]</body><body package="Grid">showLineNumbers: aBooleanOrNil	self rowIndicator ifTrue:[columns first lineNumbers: aBooleanOrNil = true].</body></methods><methods><class-id>UI.GridSpec</class-id> <category>building</category><body package="Grid">dispatchTo: policy with: builder 	policy gridView: self into: builder</body></methods><methods><class-id>UI.GridSpec</class-id> <category>private</category><body package="Grid">addColumn: aGridColumn	columns := columns copyWith: aGridColumn.</body><body package="Grid">defaultHeaderColumn	^GridHeaderColumn new width: 20</body><body package="Grid">defaultHeaderRow	^GridHeaderRow new</body><body package="Grid">deleteColumnIndex: anInteger	columns := columns copyWithout: (columns at: anInteger).</body></methods><methods><class-id>UI.GridSpec</class-id> <category>initialize-release</category><body package="Grid">initialize	super initialize.		self showVerticalLines: false.	self showHorizontalLines: false.	columns := List new.	selectByCell := false.	allowRowResizing := true.</body></methods><methods><class-id>UI.GridSpec class</class-id> <category>private-interface building</category><body package="Grid">addLocalBindingsTo: env for: inst channel: aChannel 	env at: #allowRowResizing		put: (self 				adapt: inst				forAspect: #allowRowResizing				channel: aChannel).	env at: #lineNumberOffset		put: (self 				adapt: inst				forAspect: #lineNumberOffset				channel: aChannel).	env at: #specChannel put: aChannel.	aChannel removeDependent: (env removeKey: #webHelpText ifAbsent: nil).	aChannel removeDependent: (env removeKey: #helpField ifAbsent: nil) model</body></methods><methods><class-id>UI.GridVisualCell</class-id> <category>comparing</category><body package="Grid">= aGridVisualCell 	^self species = aGridVisualCell species 		and: [self cellPoint = aGridVisualCell cellPoint]</body><body package="Grid">hash	^self cellPoint hash</body></methods><methods><class-id>UI.GridVisualCell</class-id> <category>converting</category><body package="Grid">asGridCell	^GridCell column: visualColumn column row: visualRow row</body></methods><methods><class-id>UI.GridVisualCell</class-id> <category>accessing</category><body package="Grid">backgroundColor	^backgroundColor</body><body package="Grid">bounds	^visualColumn left @ visualRow top		corner: visualColumn right @ visualRow bottom</body><body package="Grid">cellPoint	^visualColumn ifNotNil: [visualRow ifNotNil: [visualColumn index @ visualRow index]]</body><body package="Grid">component	^component</body><body package="Grid">grid	^visualColumn ifNil: [visualRow ifNotNil: [visualRow grid]]		ifNotNil: [visualColumn grid]</body><body package="Grid">gridColumn	^visualColumn column</body><body package="Grid">gridRow	^visualRow row</body><body package="Grid">model		^self grid builder aspectAt: cellBindingKey</body><body package="Grid">peerForColumn: aGridColumn	"Answer the GridVisualCell intersecting aGridColumn and my row, if it is currently visible"	^visualRow cells detect:[:cell| cell visualColumn column  = aGridColumn] ifNone: nil</body><body package="Grid">peerForColumnID: aSymbol	"Answer the GridVisualCell intersecting a GridColumn named aSymbol and my row, if it is currently visible"	^visualRow cells detect:[:cell| cell visualColumn column id = aSymbol] ifNone: nil</body><body package="Grid">peerForRow: aGridRow	"Answer the GridVisualCell intersecting aGridRow and my column, if it is currently visible"	^visualColumn cells detect:[:cell| cell visualRow row = aGridRow] ifNone: nil</body><body package="Grid">preferredBounds	^visualColumn cellLeft @ visualRow cellTop 		corner: visualColumn cellRight @ visualRow cellBottom</body><body package="Grid">visualColumn	^visualColumn</body><body package="Grid">visualRow	^visualRow</body><body package="Grid">widget	^component widget</body></methods><methods><class-id>UI.GridVisualCell</class-id> <category>testing</category><body package="Grid">canEdit	^self canTakeFocus and: [component widget controller requestFocusIn]</body><body package="Grid">canTakeFocus	^component notNil		and: [component isEnabled and: [component widgetState canTakeFocus]]</body><body package="Grid">desiresFocus	^component notNil and:[component isEnabled]</body><body package="Grid">isEditing	^self grid		ifNil: [false]		ifNotNil: [:grid | grid editCell = self asGridCell]</body><body package="Grid">isEditor	^component notNil and:[component widget isKindOf: TextEditorView]</body><body package="Grid">isHeader	^self gridRow isHeader or:[self gridColumn isHeader]</body><body package="Grid">isNeeded	^self grid ifNil: [false]		ifNotNil: [:grid | grid bounds intersects: self preferredBounds]</body><body package="Grid">isSelected	| depth |	depth := 0 @ 0 extent: 1 @ 1.	^self grid selectionRange 		contains: [:each | (each expandedBy: depth) containsPoint: self cellPoint]</body></methods><methods><class-id>UI.GridVisualCell</class-id> <category>private-building</category><body package="Grid">createCellPane	| spec column model builder grid widget row |	column := self gridColumn.	row := self gridRow.	grid := self grid.	builder := grid builder.	grid editCell ifNotNil: 			[:gridCell | 			(gridCell column = column and: [gridCell row = row]) 				ifTrue: 					[component := grid editor.					self updateLayout.					column postBuildCell: self with: builder.					row postBuildCell: self with: builder.					grid postBuildCell: self with: builder.					self insertFocusInterestTo: component widget forEntryNotifying: grid.					^self]].	spec := column specForCell: self.	spec := row specForCell: self appliedTo: spec.	spec := grid specForCell: self appliedTo: spec.	spec ifNil: [^self].	model := spec model.	model isSymbol 		ifTrue: 			[| rowBindingKey |			rowBindingKey := visualRow rowBindingKey.			cellBindingKey := (model copyReplaceAll: '_row' with: rowBindingKey) 						asSymbol.			spec model: cellBindingKey.			builder bindings at: rowBindingKey ifAbsentPut: [self gridRow item asValue]]		ifFalse: 			[model ifNotNil: [model subject ifNil: [model subject: self gridRow item]]].	spec layout: self preferredBounds.	component := builder add: spec.	backgroundColor := spec colors ifNotNil:[:value| value backgroundColor].	self isSelected ifTrue: [self showSelected].	widget := component widget.	widget controller desiresFocus 		ifTrue: 			[self canTakeFocus				ifTrue: 					[column insertKeyboardFocusInterestTo: widget for: grid controller.					self insertFocusInterestTo: widget forEntryNotifying: grid]]		ifFalse: [self insertSelectionInterestTo: widget forEntryNotifying: grid].	column postBuildCell: self with: builder.	row postBuildCell: self with: builder.	grid postBuildCell: self with: builder.</body><body package="Grid">insertFocusInterestTo: widget forEntryNotifying: grid 	(widget canTriggerEvent: #gettingFocus) 		ifTrue: 			[widget 				when: #gettingFocus				send: #editCell:				to: grid				with: self]</body><body package="Grid">insertSelectionInterestTo: widget forEntryNotifying: grid 	(widget canTriggerEvent: #clicked) 		ifTrue: 			[widget 				when: #clicked				send: #selectCell:				to: grid				with: self]</body><body package="Grid">rowBindingKey	^visualRow rowBindingKey</body></methods><methods><class-id>UI.GridVisualCell</class-id> <category>printing</category><body package="Grid">printOn: aStream 	super printOn: aStream.	aStream nextPut: $(.	(visualColumn ifNotNil: [visualColumn index]) printOn: aStream.	aStream nextPut: $@.	(visualRow ifNotNil: [visualRow index]) printOn: aStream.	aStream nextPut: $)</body></methods><methods><class-id>UI.GridVisualCell</class-id> <category>initialize-release</category><body package="Grid">release	super release.	component		ifNotNil: 			[self widget controller removeFromKeyboard.			self grid				ifNotNil: 					[:grid |					grid editor == component						ifTrue: [self widget removeActionsWithReceiver: grid forEvent: #gettingFocus]						ifFalse: 							[grid remove: component.							component release].					grid builder bindings removeKey: cellBindingKey ifAbsent: nil]].	visualRow ifNotNil: [visualRow removeCell: self].	visualColumn ifNotNil: [visualColumn removeCell: self].	visualColumn := visualRow := component := nil</body><body package="Grid">visualColumn: aGridVisualColumn visualRow: aGridVisualRow 	"No need in continuing if either column or row has a cell registered for this position"	visualColumn := aGridVisualColumn.	visualRow := aGridVisualRow.	(aGridVisualColumn includesCell: self) ifTrue: [^self].	(aGridVisualRow includesCell: self) ifTrue: [^self].	aGridVisualRow grid == aGridVisualColumn grid 		ifFalse: 			[self error: #inconsistentGrid &lt;&lt; #dialogs 						&gt;&gt; 'Row and Column belong to different Grid instance'].	aGridVisualColumn registerCell: self.	aGridVisualRow registerCell: self.	self createCellPane</body></methods><methods><class-id>UI.GridVisualCell</class-id> <category>updating</category><body package="Grid">updateLayout	component ifNotNil:[component bounds: self preferredBounds].</body></methods><methods><class-id>UI.GridVisualCell</class-id> <category>displaying</category><body package="Grid">hideSelected	component ifNil:[^self].	component widgetState colors 		ifNotNil: [:colors | colors setBackgroundColor: backgroundColor].	"self container class == ReversingWrapper ifTrue:[self container reverse value: false]."	self triggerEvent: #hideSelected</body><body package="Grid">showSelected	| selectionBackground cellColors currentBackground cellSelectionColors |	component ifNil:[^self].	selectionBackground := component selectionBackgroundColor.	cellColors := component widgetState colors.	currentBackground := cellColors ifNotNil: [cellColors backgroundColor].	currentBackground = selectionBackground 		ifFalse: 			[backgroundColor := currentBackground.			cellSelectionColors := LookPreferences new 						setBackgroundColor: selectionBackground.			cellColors ifNil: [component widgetState colors: cellSelectionColors]				ifNotNil: [cellSelectionColors applyTo: cellColors]].	"self container class == ReversingWrapper		ifFalse:[| former |		former := self container.		(ReversingWrapper on: self) container: former].	self container reverse value: true."	self triggerEvent: #showSelected</body></methods><methods><class-id>UI.GridVisualCell class</class-id> <category>private-events</category><body package="Grid">constructEventsTriggered	^super constructEventsTriggered		add:#hideSelected;		add:#showSelected;		yourself</body></methods><methods><class-id>UI.GridVisualCell class</class-id> <category>instance creation</category><body package="Grid">visualColumn: aGridVisualColumn visualRow: aGridVisualRow 	^self new		visualColumn: aGridVisualColumn		visualRow: aGridVisualRow</body></methods><methods><class-id>UI.GridHeaderBorder</class-id> <category>private</category><body package="Grid">shadowFor: colorSource 	"Answer the top paint using the specified color source. Nil means to use a 	default."	^colorSource == nil		ifTrue:	[ColorValue black]		ifFalse:	[colorSource shadowColor]</body></methods><methods><class-id>UI.WinXPGridColumnHeaderView</class-id> <category>accessing</category><body package="Grid">flyingOver: aBoolean	| oldValue |	oldValue := flyingOver.	flyingOver := aBoolean.	oldValue = flyingOver		ifFalse: [self redisplayForEnabledChange]</body></methods><methods><class-id>UI.WinXPGridColumnHeaderView</class-id> <category>private</category><body package="Grid">getBorder	^GridHeaderBorder width: 1</body></methods><methods><class-id>UI.GridDecorator</class-id> <category>private</category><body package="Grid">computeDisplayBoxFor: aComponent inDisplayBox: aRectangle	"Answer a rectangle for aComponent to use as its display box."	| box |  	box := (aRectangle insetBy: self edgeDecorationPolicy inset).	(headerRowComponent notNil and: [aComponent component ~~ headerRowComponent])		ifTrue: [box top: box top + headerRowComponent container preferredBounds height + 2.				headerColumnComponent == aComponent component					ifTrue: [						self hasMenuBar ifTrue: [box top: box top + self edgeDecorationPolicy menuBarHeight].						self hasBorder ifTrue: [ box top: box top + 2] 			]].	(headerColumnComponent notNil and: [aComponent component ~~ headerColumnComponent])		ifTrue: [box left: box left + headerColumnComponent container preferredBounds width + 2].		^aComponent rectangleRelativeTo: box</body><body package="Grid">flushComponents	"Discard all the old components."	| count | 	count := 2.	headerRowComponent == nil ifFalse: [count := count + 1].	headerColumnComponent == nil ifFalse: [count := count + 1].	count to: components size do:		[:i |		(components at: i) release].	components := OrderedCollection new.	preferredBounds := nil.</body><body package="Grid">labelsBorder	^SimpleBorder new</body><body package="Grid">resetComponents	"Discard the old components, and add new ones."	self flushComponents.	self edgeDecorationPolicy layout: self.	self resetHeaderComponents.</body><body package="Grid">resetHeaderComponents	"Set the receiver's bounds to newBounds."	| f wc | 	f := components first layout.	headerRowComponent == nil		ifFalse: [	borderHeaderRow					ifTrue: [wc := BorderedWrapper on: headerRowComponent.							wc border: self labelsBorder.							wc inset: 0]					ifFalse: [wc := BoundedWrapper on: headerRowComponent].				wc layout: (LayoutFrame new					rightFraction: f rightFraction;					rightOffset: f rightOffset;					bottomOffset: headerRowComponent component scrollableExtent y ).				self addWrapper: wc. 				components addFirst: components removeLast].	headerColumnComponent == nil		ifFalse: [	borderHeaderColumn					ifTrue: [wc := BorderedWrapper on: headerColumnComponent.							wc border: self labelsBorder.							wc inset: 0]					ifFalse: [wc := BoundedWrapper on: headerColumnComponent].					wc layout: (LayoutFrame new					bottomFraction: f bottomFraction;					bottomOffset: f bottomOffset;					rightOffset: headerColumnComponent component scrollableExtent x).				self addWrapper: wc.				components addFirst: components removeLast]</body><body package="Grid">setUpHeaderColumn: aGridHeaderColumn	aGridHeaderColumn		ifNotNil: 			[| grid |			aGridHeaderColumn addDependent: self.			grid := Grid forHeaderColumn: aGridHeaderColumn and: component.			headerColumnComponent := SlaveScrollWrapper new.			headerColumnComponent setComponent: grid scrollOffsetHolder: component scrollOffsetHolder.			headerColumnComponent noScrollHorizontally.			headerColumnComponent container: self]</body><body package="Grid">setUpHeaderRow: aGridHeaderRow	aGridHeaderRow		ifNotNil: 			[| grid |			aGridHeaderRow addDependent: self.			grid := Grid forHeaderRow: aGridHeaderRow and: component.			headerRowComponent := SlaveScrollWrapper new.			headerRowComponent setComponent: grid scrollOffsetHolder: component scrollOffsetHolder.			headerRowComponent noScrollVertically.			headerRowComponent container: self]</body><body package="Grid">setVisibility: aBoolean	self component widgetState isVisible == aBoolean ifTrue: [^self].	self component widgetState isVisible: aBoolean.	self invalidate</body><body package="Grid">updateHeaderColumnWidth: anInteger from: aGridColumn	self headerColumnGrid updateWidth: anInteger from: aGridColumn.	self resetComponents</body><body package="Grid">updateHeaderRowHeight: anInteger from: aGridRow	self headerRowGrid updateHeight: anInteger from: aGridRow.	self resetComponents</body></methods><methods><class-id>UI.GridDecorator</class-id> <category>initialize-release</category><body package="Grid">initialize	super initialize.	borderHeaderRow := borderHeaderColumn := false.</body><body package="Grid">release	gridInterface removeDependent: self.	super release</body><body package="Grid">setGrid: aGrid interface: aGridInterface	gridInterface := aGridInterface.	gridInterface addDependent: self.	self setComponent: (ScrollWrapper on: aGrid).	self setUpHeaderRow: gridInterface headerRow.	self setUpHeaderColumn: gridInterface headerColumn</body></methods><methods><class-id>UI.GridDecorator</class-id> <category>private-visual properties</category><body package="Grid">isEnabled: aBoolean	self component widgetState isEnabled == aBoolean ifTrue: [^self].	self component widgetState isEnabled: aBoolean.	self invalidate</body></methods><methods><class-id>UI.GridDecorator</class-id> <category>accessing</category><body package="Grid">borderHeaderColumn: aBoolean	borderHeaderColumn := aBoolean.	self checkComponents</body><body package="Grid">borderHeaderRow: aBoolean	borderHeaderRow := aBoolean.	self checkComponents</body><body package="Grid">grid	^gridInterface grid</body><body package="Grid">gridInterface 	^gridInterface</body><body package="Grid">headerColumn: aGridHeaderColumn	aGridHeaderColumn		ifNil: [self noHeaderColumn]		ifNotNil: [self setUpHeaderColumn: aGridHeaderColumn]</body><body package="Grid">headerColumnGrid	^headerColumnComponent component</body><body package="Grid">headerRow: aGridHeaderRow	aGridHeaderRow		ifNil: [self noHeaderRow]		ifNotNil: [self setUpHeaderRow: aGridHeaderRow.]</body><body package="Grid">headerRowGrid	^headerRowComponent component</body><body package="Grid">isVisible: aBoolean	self upcastEvent: #setVisibility with: aBoolean</body><body package="Grid">noHeaderColumn	headerColumnComponent		ifNotNil: 			[self headerColumnGrid removeRowDependence.			self headerRowGrid columns do: [:column | column removeDependent: self]].	headerColumnComponent := nil.	self checkComponents</body><body package="Grid">noHeaderRow	headerRowComponent		ifNotNil: 			[self headerRowGrid removeColumnDependence.			self headerRowGrid rows do: [:row | row removeDependent: self]].	headerRowComponent := nil.	self checkComponents</body></methods><methods><class-id>UI.GridDecorator</class-id> <category>updating</category><body package="Grid">update: anAspect with: aParameter from: anObject	anAspect == #headerRow ifTrue:[^self headerRow: aParameter].	anAspect == #headerColumn ifTrue:[^self headerColumn: aParameter].	anAspect == #updateColumnWidth: ifTrue:[^self updateHeaderColumnWidth: aParameter from: anObject]. 	anAspect == #updateRowHeight: ifTrue:[^self updateHeaderRowHeight: aParameter from: anObject]. 	super update: anAspect with: aParameter from: anObject</body></methods><methods><class-id>UI.GridDecorator</class-id> <category>testing</category><body package="Grid">hasHeaderColumn	^headerColumnComponent notNil</body><body package="Grid">hasHeaderRow	^headerRowComponent notNil</body><body package="Grid">includesHeader: aComponent	^headerColumnComponent == aComponent or:[headerRowComponent == aComponent]</body></methods><methods><class-id>UI.GridDecorator class</class-id> <category>instance creation</category><body package="Grid">on: aGridView interface: aGridInterface	^self new setGrid: aGridView interface: aGridInterface</body></methods><methods><class-id>UI.GridRowResizeAgent</class-id> <category>event driven</category><body package="Grid">adjustTo: anInteger 	| delta |	delta := anInteger - selectedRow bottom.	delta isZero ifTrue: [^self].	selectedRow height: selectedRow height + delta</body><body package="Grid">checkScrollingFrom: cursorPoint 	"Scroll left or right if needed"	| bounds cursorDistance |	self notYetImplemented.	bounds := controller view bounds.	cursorDistance := cursorPoint x.	cursorDistance &lt; bounds left ifTrue:[].	cursorDistance &gt; bounds right ifTrue:[].</body><body package="Grid">mouseMovedTo: aPoint 	| verticalPosition |	verticalPosition := aPoint y.	verticalPosition &gt; selectedRow top ifFalse: [^self].	self adjustTo: verticalPosition</body><body package="Grid">okayToStartUpAt: aPoint 	selectedRow := controller view visualRowAtEdge: aPoint.	^selectedRow ifNil: [false] ifNotNil: [selectedRow allowResizing]</body></methods><methods><class-id>UI.GridRowResizeAgent</class-id> <category>interaction</category><body package="Grid">selectUpAt: aPoint	controller view confirmRowSize</body></methods><methods><class-id>UI.NamedSpec</class-id> <category>accessing</category><body package="Grid">converterWith: aUIBuilder	^nil</body></methods><methods><class-id>UI.UILookPolicy</class-id> <category>building</category><body package="Grid">gridColumnHeaderBox: spec into: builder 	| component model |	model := spec modelInBuilder: builder.	component := self gridColumnHeaderBoxClass model: model.	self gridHeaderBox: component fromSpec: spec into: builder</body></methods><methods><class-id>UI.UILookPolicy</class-id> <category>implementation classes</category><body package="Grid">gridColumnHeaderBoxClass	"Answer the class that implements the column header view for this policy."	^GridColumnHeaderView</body><body package="Grid">gridDecoratorClass	^GridDecorator</body></methods><methods><class-id>UI.UILookPolicy</class-id> <category>building</category><body package="Grid">gridHeaderBox: component fromSpec: spec into: builder	self		setTheLabelFor: spec component: component in: builder;		setHelpTextFor: spec component: component in: builder.	builder component: component.	self setDispatcherOf: component fromSpec: spec builder: builder.	component widgetState isEnabled: spec initiallyEnabled.	builder isEditing		ifFalse: [component widgetState isVisible: spec initiallyVisible].	builder wrapWith: (self simpleWrapperFor: spec).	builder applyLayout: spec layout.	builder wrapWith: (self simpleWidgetWrapperOn: builder spec: spec)</body><body package="Grid">gridRowHeaderBox: spec into: builder	| component model |	model := spec modelInBuilder: builder.	component := self gridRowHeaderBoxClass model: model.	self gridHeaderBox: component fromSpec: spec into: builder</body></methods><methods><class-id>UI.UILookPolicy</class-id> <category>implementation classes</category><body package="Grid">gridRowHeaderBoxClass	"Answer the class that implements the grid row header view for this policy."	^GridRowHeaderView</body></methods><methods><class-id>UI.UILookPolicy</class-id> <category>building</category><body package="Grid">gridView: spec into: builder	"Build a Grid using the builder."	| gridView model bc |	model := spec modelInBuilder: builder.	 builder isEditing		ifTrue: [model grid: self paintedGridViewClass new].	gridView := model grid.	gridView defaultRowHeight: spec rowSize.	spec headerRow ifNotNil:[:headerRow | model headerRow: headerRow].	spec headerColumn ifNotNil:[:headerColumn | model headerColumn: headerColumn].	gridView updateModelSelecting: nil.	(spec getMenuIn: builder)		ifNotNil: [:menu | gridView controller menuHolder: menu].	(spec getPerformerIn: builder)		ifNotNil: [:performer | gridView controller performer: performer].	bc := builder copy.	bc setWindow: nil.	bc composite: CompositePart new.	gridView horizontalPolicy: spec horizontalPolicy.	gridView verticalPolicy: spec verticalPolicy.	gridView showColumnLines: spec showVerticalLines.	gridView showRowLines: spec showHorizontalLines.	"gridView showLineNumbers: spec showLineNumbers."	"gridView rowLabelsAsButtons: spec rowLabelsAsButtons."	gridView allowSorting: spec allowSorting.	gridView allowColumnReordering: spec allowColumnReordering.	gridView allowColumnResizing: spec allowColumnResizing.	gridView allowRowResizing: spec allowRowResizing.	gridView selectByCell: spec selectByCell.	gridView builder source: builder source.	spec columns size &gt; 0 ifTrue:[gridView columns: spec columns asList].	builder isEditing		ifFalse: 			[self setDispatcherOf: gridView fromSpec: spec builder: builder].	builder sendKeyboardTo: gridView.	spec tabable		ifTrue: [gridView widgetState isTabStop: true]		ifFalse: 			[gridView widgetState canTakeFocus: true].	gridView widgetState isEnabled: spec initiallyEnabled.	builder isEditing		ifFalse: [gridView widgetState isVisible: spec initiallyVisible].	builder component: gridView.	builder decorator: (self gridDecoratorClass on: gridView interface: model).	builder wrapper: (BoundedWrapper on: builder decorator).	builder decorator setWidgetFlags: spec scrollingFlags.	builder applyLayout: spec layout.	builder wrapWith: (self				simpleWidgetWrapperOn: builder				spec: spec				state: gridView widgetState)</body></methods><methods><class-id>UI.UILookPolicy</class-id> <category>implementation classes</category><body package="Grid">gridViewClass	^Grid</body><body package="Grid">paintedGridViewClass	^#{PaintedGridView} value</body></methods><methods><class-id>Graphics.VisualPart</class-id> <category>accessing</category><body package="Grid">keyboardProcessor		^container ifNotNil: [:parent | container keyboardProcessor]</body></methods><methods><class-id>UI.GridColumnHeaderView class</class-id> <category>resources</category><body package="Grid">sortAscendingIndicatorImage	"UIMaskEditor new openOnClass: self andSelector: #sortAscendingIndicatorImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 8@8 depth: 1 bitsPerPixel: 1 palette: (MappedPalette withColors: ((Array new: 2) at: 1 put: ColorValue white; at: 2 put: (ColorValue scaledRed: 4111 scaledGreen: 4111 scaledBlue: 4111); yourself)) usingBits: #[255 0 0 0 192 0 0 0 64 0 0 0 96 0 0 0 32 0 0 0 48 0 0 0 16 0 0 0 0 0 0 0])</body><body package="Grid">sortAscendingIndicatorMask	"UIMaskEditor new openOnClass: self andSelector: #sortAscendingIndicatorMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 8@8 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 0 0 0 195 0 0 0 66 0 0 0 70 0 0 0 36 0 0 0 60 0 0 0 24 0 0 0 0 0 0 0])</body><body package="Grid">sortDescendingIndicatorImage	"UIMaskEditor new openOnClass: self andSelector: #sortDescendingIndicatorImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 8@8 depth: 1 bitsPerPixel: 1 palette: (MappedPalette withColors: ((Array new: 2) at: 1 put: ColorValue white; at: 2 put: (ColorValue scaledRed: 4111 scaledGreen: 4111 scaledBlue: 4111); yourself)) usingBits: #[16 0 0 0 48 0 0 0 32 0 0 0 64 0 0 0 64 0 0 0 128 0 0 0 128 0 0 0 0 0 0 0])</body><body package="Grid">sortDescendingIndicatorMask	"UIMaskEditor new openOnClass: self andSelector: #sortDescendingIndicatorMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 8@8 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[24 0 0 0 60 0 0 0 36 0 0 0 66 0 0 0 66 0 0 0 129 0 0 0 255 0 0 0 0 0 0 0])</body></methods><methods><class-id>UI.GridIcons class</class-id> <category>png imports</category><body package="Grid">ArrowDown	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'ArrowDown.png'&gt;	&lt;md5sum: #[4 40 209 27 231 10 226 13 17 216 58 82 60 91 240 156]&gt;	^[AlphaCompositedImage image: ((Image extent: 11@10 depth: 32 bitsPerPixel: 32 palette: (Graphics.FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C?????QDQD?4QDQO=DQDS?QDQD?4QDQO=DQDS?QDQD@O???0C???&lt;@????@O???0CR6]/?QDQD?4QDQO=DQDS?QDQD?4QDQ@CR6M,@????@O???0C???&lt;@????@MOY7@CR6M/?QDQD?4QDQO=DQDP@4=''[@MKY60C???&lt;@????@O???0C???&lt;@4=''\@MKY60CS6]3?QDQD@MKY60CS6]0@4=''\@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;b')))] once</body><body package="Grid">ArrowUp	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'ArrowUp.png'&gt;	&lt;md5sum: #[200 111 52 150 40 112 107 243 30 103 161 202 47 62 186 120]&gt;	^[AlphaCompositedImage image: ((Image extent: 11@10 depth: 32 bitsPerPixel: 32 palette: (Graphics.FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C?????QDQD@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@?????4QDQO=DQDS?QDQD@O???0C???&lt;@????@O???0C???&lt;@????@O????=DQDS?QDQD?4QDQO=DQDS?QDQD@O???0C???&lt;@????@O???0C?????QDQD?4QDQO=DQDS?QDQD?4QDQO=DQDS?QDQD@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;b')))] once</body></methods><methods><class-id>UI.GridIcons class</class-id> <category>gif imports</category><body package="Grid">RightArrow1	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'RightArrow1.gif'&gt;	&lt;md5sum: #[250 68 117 19 196 106 164 1 1 132 199 26 132 141 203 1]&gt;	^[AlphaCompositedImage image: ((Image extent: 16@16 depth: 8 bitsPerPixel: 8 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 0 0)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7516 7516 7516)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6167 6167 6167)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3341 3341 3341)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2441 2441 2441)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 0 0)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: (ByteArray fromPackedString: 'A XFA XFA XFA XFA XFA XF@ HFA XFA XFA XFA XFA L@@ XFA XFA XFA XFA XCAP@BA XFA XFA XFA XF@0TE@@HFA XFA XFA XFA LEAPT@@ XFA XFA XFA XCAPTEAP@BA XFA XFA XF@0TEAPTE@@HFA XFA XFA LEAPTEAP@@A XFA XFA XCAPTEAP@@A XFA XFA XF@0TEAP@@A XFA XFA XFA LEAP@@A XFA XFA XFA XCAP@@A XFA XFA XFA XF@0@@A XFA XFA XFA XFA L@A XFA XFA XFA XFA XDA XFA XFA XFA XFA @a')))] once</body></methods><methods><class-id>Tools.ToolbarIconLibrary class</class-id> <category>resources</category><body package="Grid">gridWidget20x20	"Tools.UIMaskEditor new openOnClass: self andSelector: #gridWidget20x20"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@21 depth: 3 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 0 0)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 0 4491)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4491 0 0)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4227 0 0)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 0 4227)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: (ByteArray fromPackedString: 'L3L3L3L3L3L3L0@@L3L3L3L3L3L3L0@@L@@@@@@@@@@@@0@@LCL3D3L1L3L3@0@@LCH3D3L1L3L3@0@@LCL3D3L1L3L3@0@@LADQDQDQDQDQ@0@@LCL3EDQAL3L3@0@@LCL3EDQAL3L3@0@@LCL3EDQAL3L3@0@@LCT3YDQFL3L3@0@@LCL3EDQAL3L3@0@@LCL3EDQAL3L3@0@@LCL3EDQAL3L3@0@@LADQDQDQDQDQ@0@@LCL3D3L1QDQD@0@@LCH3D3L1QDQD@0@@LCL3D3L1QDQD@0@@L@@@@@@@@@@@@0@@L3L3L3L3L3L3L0@@L3L3L3L3L3L3L0@@'))</body><body package="Grid">gridWidget20x20bw	"Tools.UIMaskEditor new openOnClass: self andSelector: #gridWidget20x20bw"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@21 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 127 255 224 0 66 16 32 0 82 16 32 0 66 16 32 0 127 255 224 0 67 240 32 0 67 240 32 0 67 240 32 0 83 240 32 0 67 240 32 0 67 240 32 0 67 240 32 0 127 255 224 0 66 31 224 0 82 31 224 0 66 31 224 0 127 255 224 0 0 0 0 0 0 0 0 0])</body><body package="Grid">gridWidget20x20mask	"UIMaskEditor new openOnClass: self andSelector: #dataSetWidget20x20mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@21 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 0 0 0 0 0 0 0 0])</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>NamedSpec</name><environment>UI</environment><super>UI.ComponentSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name flags isOpaque colors </inst-vars><class-inst-vars>paletteIcon </class-inst-vars><imports></imports><category>UIBuilder-Specifications</category><attributes><package>UIBuilder-Specifications</package></attributes></class><class><name>ButtonSpec</name><environment>UI</environment><super>UI.WidgetSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>label hasCharacterOrientedLabel style </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Specifications</category><attributes><package>UIBuilder-Specifications</package></attributes></class><class><name>VisualPart</name><environment>Graphics</environment><super>Graphics.VisualComponent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>container eventHandlers properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Visual Objects</category><attributes><package>Graphics-Visual Objects</package></attributes></class><class><name>BorderDecorator</name><environment>UI</environment><super>Graphics.CompositePart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>component policy hasBorder hasHorizontalScrollbar hasVerticalScrollbar </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Support</category><attributes><package>UIBasics-Support</package></attributes></class><class><name>SelectionTracker</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>controller </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Events-Trackers</category><attributes><package>Interface-Events-Trackers</package></attributes></class><class><name>CompositeView</name><environment>UI</environment><super>Graphics.DependentComposite</super><private>false</private><indexed-type>none</indexed-type><inst-vars>controller </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Support</category><attributes><package>UIBasics-Support</package></attributes></class><class><name>Model</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dependents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>AlphaBlendedIcons</name><environment>Smalltalk</environment><super>Core.Assets</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Tools-Resources</package></attributes></class><class><name>ColumnResizeAgent</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>controller outside index leftLimit leftEdge </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Datasets</category><attributes><package>UIBasics-Datasets</package></attributes></class><class><name>BeveledBorder</name><environment>UI</environment><super>UI.SimpleBorder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>isInset </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Support</category><attributes><package>UIBasics-Support</package></attributes></class><class><name>DataSetController</name><environment>UI</environment><super>UI.ControllerWithMenu</super><private>false</private><indexed-type>none</indexed-type><inst-vars>outside dispatcher callbackLock rowSelect clicked oldCursor tabLock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Datasets</category><attributes><package>UIBasics-Datasets</package></attributes></class><class><name>DataSetSpec</name><environment>UI</environment><super>UI.MenuComponentSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>columns verticalPolicy horizontalPolicy multipleSelections labelsAsButtons </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Specifications</category><attributes><package>UIBuilder-Specifications</package></attributes></class><class><name>UILookPolicy</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>systemAttributes systemWidgetAttributes useSystemFontOnWidgets systemMenuAttributes </class-inst-vars><imports></imports><category>UIBuilder-Support</category><attributes><package>UIBuilder-Support</package></attributes></class><class><name>RadioButtonController</name><environment>UI</environment><super>UI.ToggleButtonController</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Controllers</category><attributes><package>UIBasics-Controllers</package></attributes></class><class><name>ColumnDraggingTracker</name><environment>UI</environment><super>UI.ColumnResizeTracker</super><private>false</private><indexed-type>none</indexed-type><inst-vars>startingPoint savedEvent visual graphicsContext backingStore labelPixmap previousPoint columnIndex originalColumnIndex dragDisplayOffset startedDragging attemptDragging </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Events-Trackers</category><attributes><package>Interface-Events-Trackers</package></attributes></class><class><name>LabeledButtonView</name><environment>UI</environment><super>UI.BasicButtonView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>label textStyle </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category><attributes><package>UIBasics-Components</package></attributes></class></st-source>