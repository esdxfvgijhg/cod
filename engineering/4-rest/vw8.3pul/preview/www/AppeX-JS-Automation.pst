<?xml version="1.0"?><st-source><!-- Name: AppeX-JS-AutomationComment: Overview:This package provides a framework for the automation of browser based (web) applications (Refer to the JSAUTOMATOR COMMENTS  immediately below).This package also contains a framework for evaluating arbitrary JavaScript from within Smalltalk (refer to the JSEVALUATOR COMMENTS following the JSAutomator comments).JSAUTOMATOR COMMENTSA test (or automation) script is injected into the application to be tested.The injected JavaScript exercises the web application's functionality and sends  results back to the Smalltalk server.How this works:JSAutomator is an Application that takes the part of a "proxy" in between the client (typically a web browser) and the application to be "automated".  As a man-in-the-middle, the JSAutomator can choose to pass on browser requests essentially unchanged to the automated application, modify the requests, or even handle the requests entirely.  See the JSAutomator>>processRequest: method.The JSAutomatorClient is part of the "injected code" that is sent to the web client.  Its javascript methods provides functionality to keep track of changes in the browser that the tester is interested in and send those results back to the server.  (See the JSAtomatorClient>>sendResultStringToServer() method).  It also provides functionality to simulate user actions on the client, and also to modify the behavior of the "automated client" javascript code (see the clickAnchorWithText() and wrapAfter() methods).The JSAutomatorScript, also downloaded to the client, is included to kick off the the sequence of testing actions by instantiateing an instance of the JSAutomatorClient and also an instance of the automated application specific subclass of JSAutomatorClient in order to kick off the the sequence of testing actions.Instructions for using the automation framework to programmatically open and exercise a web application.Perhaps the easiest way to get a feel for using the framework is to examine one or more of the examples in the package AppeX-Tests-AutomatedExamples.  The steps given below would have to be modified slightly for the case in which the application to be automated is *not* an AppeX application (for instance if it is a web page on the WWW such as google.com).  In the case of a non-AppeX web application, it would be best to closely examine the 'testSearch' or 'testSeaside' test cases for an indication on how to proceed.Example steps for automating the HelloLocalized AppeX application.1.  Create a subclass of AppeX.JSAutomatorClient, e.g. AppeX.HelloLocalizedAutomator, that is specific to the application that is to be automated (in this case AppeX.HelloLocalized).In the initialize() method of this new javascript "class", write the testing steps that you wish to perform on the tested application (or call methods that perform these steps).  Notes on this test-specific automator client:a) This initialize() method of the  automator client will be called when the automatorclient subclass is detected and instantiated by the JSAutomatorScript.b) One way that the initialize method can perform it's functions by "wrappering" javascript methods in the tested application.  For instance, the HelloLocalizedAutomator wrappers the "buildLanguageLinks" method of HelloLocalizeClient in order to detect when the HelloLocalized web page has finished drawing and is ready to be clicked.   The "afterBuildLanguageLinks" function then "clicks" an various anchors at time intervales of 1 second.   The "afterRefreshScreen" wrappering method records details of how the screen looks as the result of each of these simulated user click actions.c) The automator client subclass is responsible for sending the test results to the server (in this case the wording of the greeting as a result of clicking on specific links.  It is also responsible for closing the tested application (by calling window.close()).2. Add the three automator classes to the javascript code library of the application to be automated.E.G. execute:AppeX.HelloLocalized applicationLibrary 	addClass: AppeX.JSAutomatorClient;	addClass:AppeX.JSAutomatorScript;	addClass: HelloLocalizedAutomator. "the test-specific automator"3.  Start the automation server  (for an example of identifying the automation server and its responder and port, refer to AutomatedExamplesTests>>setup).  Also start whatever server runs the automated application (in this cases, the Examples server).E.G. execute:automationServer := SiouX.Server id: 'JSAutomator'.responder := automationServer responders detect: [:e | e path = '/'] ifNone:[nil].portNumber := automationServer listeners first address port. "portnumber will be needed later"automationServer start.(SiouX.Server id: 'AppeXExamples') start.4.  Set  the automated application and it's server (the "automated server")  in the automation server's responder.(for an example of setting the appropriate values in the reponder refer to  AutomatedExamplesTests>>automateApplication: automatorClient:expectedResult:allowingDelay:).E.G. execute: responder automatedApplication: HelloLocalized; automatedServer: (SiouX.Server id: 'AppeXExamples').5.  Get the result from the browser and compare it with the result you expect.E.G. execute:queryAssociation := 'automatorClient' -> 'HelloLocalizedAutomator'."additional parameters is empty"parameters := queryAssociation value -> (OrderedCollection new asArray).result := responder getResultFromBrowserWithQuery: queryAssociation passingParameters:  parameters atPort: portNumber allowingDelay: 12 seconds- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -JSEVALUATOR COMMENTSJSEvaluator uses whatever web browser is available on the server to evaluate javascript.  This package contains some examples of how this capability might be used.Start the JSEvaluator Server to use these examples, either from the Web Configuration tool or by executing in a workspace:(Server id: 'JSEvaluator') start .To try out JavaScript formatting using the open source library jsbeautifier (http://jsbeautifier.org/):a) Make a change to a JavaScript method in the refactoring browserb) Try Menu...Edit...Format to observe the results.Here are a few expressions that you might try in a workspace, and comparing with the result when the JavaScript is evaluated in a browser console:JSEvaluator evaluateJavaScript:  '"a" + "c"'. "ac"JSEvaluator evaluateJavaScript:  ' 1 2 '. "Error"JSEvaluator evaluateJavaScript: 'JSON.stringify(window.location);'.ADDITIONAL NOTES:Useful Lines to comment out for debugging purposes:JSEvaluator>>getResultFromBrowser: anAssociation atPort: anInteger	[snip]...comment out 3 lines	self parameters		removeKey: hash		ifAbsent: [self halt: 'This should never happen!'].JSEvaluatorClient>>buildHTML	[snip]...	window.close();  DbIdentifier: bear73DbTrace: 502916DbUsername: vdegenDbVersion: 8.3 - 5.1DevelopmentPrerequisites: #(#(#any 'AppeX-GenericJavascript' '') #(#any 'Compression-Zip' '') #(#any 'AppeX-Client' '') #(#any 'AppeX-ThirdPartyLibraries' '') #(#any 'AppeX-Tools' ''))PackageName: AppeX-JS-AutomationParcel: #('AppeX-JS-Automation')PrerequisiteDescriptions: #(#(#name 'AppeX-GenericJavascript' #componentType #package) #(#name 'Compression-Zip' #componentType #package) #(#name 'AppeX-Client' #componentType #package) #(#name 'AppeX-ThirdPartyLibraries' #componentType #package) #(#name 'AppeX-Tools' #componentType #bundle))PrerequisiteParcels: #(#('AppeX-GenericJavascript' '') #('Compression-Zip' '') #('AppeX-Client' '') #('AppeX-ThirdPartyLibraries' '') #('AppeX-Tools' ''))PrintStringCache: (8.3 - 5.1,vdegen)Version: 8.3 - 5.1Date: 3:30:54 PM June 30, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (jun17.5) of June 30, 2017 on June 30, 2017 at 3:30:54 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>JSEvaluatorClient</name><environment>AppeX</environment><super>AppeX.ApplicationClient</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AppeX-JS-Automation</package></attributes></class><comment><class-id>AppeX.JSEvaluatorClient</class-id><body>JSEvaluatorClient is used by the JSEvaluator to run javascript code passed from the server and pass the result back to the server.</body></comment><class><name>JSEvaluator</name><environment>AppeX</environment><super>AppeX.Application</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fileResponder parameters results </inst-vars><class-inst-vars>evaluatorDirectory </class-inst-vars><imports>			private Protocols.*			</imports><category></category><attributes><package>AppeX-JS-Automation</package></attributes></class><comment><class-id>AppeX.JSEvaluator</class-id><body>JSEvaluator uses whatever web browser is available on the server to evaluate javascript.  Development only.Instance Variables:	fileResponder		&lt;FileResponder&gt;	description of fileResponder	parameters		&lt;Dictionary&gt;		contains functionName, functionLocation, valueOfThis, and arguments for applying a JavaScript function	results			&lt;Dictionary&gt;		results returned from web browser, keyed to match parameters submitted to browserClass Instance Variables:	evaluatorDirectory	&lt;Directory&gt;		contains files to be used by the JavaScript client</body></comment><class><name>JSAutomator</name><environment>AppeX</environment><super>AppeX.JSEvaluator</super><private>false</private><indexed-type>none</indexed-type><inst-vars>automatedApplication automatedServer externalApplicationPortPath </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AppeX-JS-Automation</package></attributes></class><comment><class-id>AppeX.JSAutomator</class-id><body>JSAutomator enables the automation and testing of JavaScript based applications.JSAutomator is an Application that takes the part of a "proxy" in between the client (typically a web browser) and the application to be "automated".  As a man-in-the-middle, the JSAutomator can choose to pass on browser requests essentially unchanged to the automated application, modify the requests, or even handle the requests entirely.Instance Variables:	automatedApplication		&lt;Application&gt; 		wrappered application to be tested 	automatedServer			&lt;SiouX.Server&gt;	that serves the automatedApplication	externalApplicationPortPath	&lt;String&gt;			adress/port of automated application that is not on this server 				</body></comment><class><name>JSAutomatorScript</name><environment>AppeX</environment><super>AppeX.GenericJavascript</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AppeX-JS-Automation</package></attributes></class><comment><class-id>AppeX.JSAutomatorScript</class-id><body>JSAutomatorScript is used to kick off automation of client application testing.It does so by instantiating an in instance of AppeX.JSAutomatorClient(), and also by identifying (from the querystring of the browser) the  AutomatorClient subclass for this particular automation test and instantiating it.</body></comment><class><name>JSAutomatorClient</name><environment>AppeX</environment><super>AppeX.ApplicationClient</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>examples</category><attributes><package>AppeX-JS-Automation</package></attributes></class><comment><class-id>AppeX.JSAutomatorClient</class-id><body>JSAutomatorClient is the web client (javascript portion) of the JSAutomator.If it is being used to automate a web application, its buildHtml will not be run (the builtHtml of the automated application will be run instead).JSAutomatorClient provides utility methods for automating an application (such as the mapping, navigation, and communication methods).It is meant to be subclassed in order to automate specific web applications (for examples see the "automator" classes in  AppeX-Tests-AutomatedExamples).However, if JSAutomatorClient is opened directly from the server configuration tool, and the AppeX-Tests-AutomatedExamples package is loaded, the then JSAutomatorClient&gt;&gt;buildHtml will run and provide the web browser with a button to launch the various web automation tests.</body></comment><methods><class-id>AppeX.JSEvaluator</class-id> <category>session - services</category><body package="AppeX-JS-Automation">executeRequestFor: aRequestContext	"these files are pulled from cincom FTP server and are served as static files.	aRequestContext response header: 'Cache-Control' value: 'max-age=0, no-cache, no-store'.	If requesting a javasscript resource not starting with AppeX, use the  file responder"	(((aRequestContext request url tail first: 6) ~= 'AppeX.') and: [(aRequestContext request url tail last: 3) = '.js'])		ifTrue: [			fileResponder executeRequestFor: aRequestContext.			^self		].	super executeRequestFor: aRequestContext</body></methods><methods><class-id>AppeX.JSEvaluator</class-id> <category>initialize-release</category><body package="AppeX-JS-Automation">initialize		super initialize.	 	fileResponder := FileResponder new.	fileResponder rootDirectory: self class evaluatorDirectory. 	fileResponder path:  '/js-evaluator' .</body></methods><methods><class-id>AppeX.JSEvaluator</class-id> <category>browser communication</category><body package="AppeX-JS-Automation">acceptResult: anAssociation	"Remove the next line when done with debugging."	Transcript cr; nextPutAll: 'JSEvaluator'.	Transcript cr; nextPutAll: anAssociation printString.	self results		at: anAssociation key asString		ifPresent: [:promise | promise value: anAssociation value ]</body><body package="AppeX-JS-Automation">getResultFromBrowserWithQuery: queryAssociation passingParameters:  passedParameters atPort: anInteger allowingDelay: aDuration	| promise result queryKey queryValue |	queryKey := queryAssociation key.	queryValue := queryAssociation value.	"parameters will be used in bodyTextAreas to pass additional info to the web browser"	self parameters add: passedParameters.	[		"use hostname rather than localhost,  or css will not display correctly"		Smalltalk.ExternalWebBrowser open: (self siteURLFor: anInteger), '?', queryKey, '=', queryValue.		"Smalltalk.ExternalWebBrowser open: 'http ://localhost:', portNumber, '/js-evaluator/'."			self results at: queryValue put: (promise := TimedPromise forMilliseconds: aDuration asMilliseconds).				result := [promise value] on: PromiseExpiredError do: [:ex | ex return: nil]	] ensure: [		"Comment out next three lines to enable debugging in the browser by  re-submitting the same request."		"To keep the browser open to allow opening browser debug tools, comment out window.close() in JSEvaluatorClient&gt;&gt;buildHTML."		self parameters			removeKey: queryValue			ifAbsent: [self halt: 'This should never happen!'].		self results			removeKey: queryValue			ifAbsent: [self halt: 'This should never happen!'].	].		^ result</body></methods><methods><class-id>AppeX.JSEvaluator</class-id> <category>accessing</category><body package="AppeX-JS-Automation">getParameters: hashString	^ self parameters at: hashString ifAbsent: [Array new: 5]</body><body package="AppeX-JS-Automation">parameters	^ parameters ifNil: [ parameters := Dictionary new ]</body><body package="AppeX-JS-Automation">results	^ results ifNil: [ results := Dictionary new ]</body></methods><methods><class-id>AppeX.JSEvaluator class</class-id> <category>api</category><body package="AppeX-JS-Automation">applyJavascriptFunction: aSymbol atLocation: aString toThis: aValueForThis withArguments: anArray	"return the result of the evaluation or nil"	"calculate a unique identifying value for this particular call to the browser"	| parameters hash stream queryAssociation aServer aResponder aPortNumber |	stream := String new writing.	stream		write: Timestamp nowUTC printString;		cr;		write: aSymbol;		cr;		write: (aString ifNil: ['']);		cr.	anArray do: [:each | stream write: each printString]		separatedBy: [stream cr].	hash := (Crypto.Hash algorithm: 'md5' digest: stream contents) asHexString.	queryAssociation := 'hash' -&gt; hash.	parameters := hash -&gt; ((OrderedCollection new)						add: aSymbol;						add: aString;						add: aValueForThis;						add: anArray;						asArray).	aServer := Server id: 'JSEvaluator'.	"brittle?"	aResponder := aServer responders first.	aPortNumber := aServer listeners first address port.	^aResponder		getResultFromBrowserWithQuery: queryAssociation		passingParameters: parameters		atPort: aPortNumber		allowingDelay: 3 seconds</body><body package="AppeX-JS-Automation">applyJavascriptFunction: aSymbol toThis: aValueForThis withArguments: anArray	"location nil will indicate a global function"	^self applyJavascriptFunction: aSymbol atLocation: nil toThis: aValueForThis withArguments: anArray</body><body package="AppeX-JS-Automation">applyJavascriptFunction: aSymbol withArguments: anArrayString	^self applyJavascriptFunction: aSymbol toThis: nil withArguments: anArrayString</body><body package="AppeX-JS-Automation">evaluateJavaScript: aString	"return the result of the evaluation or nil"		^self applyJavascriptFunction: #eval toThis: nil withArguments: (Array with: aString)</body><body package="AppeX-JS-Automation">formatJavaScript: aString	"if result is nil (probably browser did not return result in time, then pass back the original code"		^self applyJavascriptFunction: #formatJavaScript atLocation: 'this' toThis: nil withArguments: (Array with: aString )</body></methods><methods><class-id>AppeX.JSEvaluator class</class-id> <category>configuration</category><body package="AppeX-JS-Automation">ensureEvaluatorDirectoryExists 		"self ensureEvaluatorDirectoryExists"	| zipStream |	self evaluatorDirectory exists ifTrue: [^true].		(Dialog		choose: 'To use the Web Dev JavaScript formatter you need to downloadftp.cincomsmalltalk.com/pub/appex/js-evaluator.zip. Click on Download to download and unzip files in /appex/js-evaluator directory'		labels: (Array with: #Download &lt;&lt; #www &gt;&gt; 'Download' with: #Cancel &lt;&lt; #www &gt;&gt; 'Cancel')		values: #(true false)		default: true)			 ifFalse: [^false].		Cursor execute showWhile: [				'http://ftp.cincomsmalltalk.com/pub/appex/js-evaluator.zip' asURI 			readStreamDo: [ :socketStream :type |				zipStream := OS.Zip.Archive on: socketStream.				zipStream extractTo: Application rootDirectory ]		].	^true</body><body package="AppeX-JS-Automation">registerAnnouncementsFrom: aServer	aServer		when: ListenerStarted		do: [ :announcement | self ensureEvaluatorDirectoryExists ifFalse: [announcement listener stop] ]		for: self.			Server		when: ServerRemoved		do: [ :ann | Server unsubscribe: self. aServer unsubscribe: self ]		for: self.</body></methods><methods><class-id>AppeX.JSEvaluator class</class-id> <category>accessing</category><body package="AppeX-JS-Automation">applicationClientClass	^JSEvaluatorClient</body><body package="AppeX-JS-Automation">evaluatorDirectory	"evaluatorDirectory := nil"	evaluatorDirectory ifNil: [evaluatorDirectory := Application rootDirectory / 'js-evaluator' ].	^evaluatorDirectory</body></methods><methods><class-id>AppeX.JSEvaluator class</class-id> <category>private</category><body package="AppeX-JS-Automation">md5Hash: aString	^Crypto.Hash algorithm: 'md5' digest: aString</body></methods><methods><class-id>AppeX.JSAutomator</class-id> <category>accessing</category><body package="AppeX-JS-Automation">automatedApplication	^automatedApplication</body><body package="AppeX-JS-Automation">automatedApplication: anObject	automatedApplication := anObject</body><body package="AppeX-JS-Automation">automatedServer	^automatedServer</body><body package="AppeX-JS-Automation">automatedServer: anObject	automatedServer := anObject</body><body package="AppeX-JS-Automation">externalApplicationPortPath	^externalApplicationPortPath</body><body package="AppeX-JS-Automation">externalApplicationPortPath: anObject	externalApplicationPortPath := anObject</body></methods><methods><class-id>AppeX.JSAutomator</class-id> <category>NetHttp</category><body package="AppeX-JS-Automation">applicationsUsingNetRequests		^self class applicationsUsingNetRequests</body><body package="AppeX-JS-Automation">automatedResponderForContext: aProtocolContext						| aPath aResponder |		self automatedApplication isNil ifTrue: [^self].		"HACK for SeasideWelcome.  This whole calculation of path is questionable in any case."	(self  automatedApplication  name = #SeasideWelcome and: [aProtocolContext request class = Net.HttpRequest])		 ifTrue: [aPath := '/']		ifFalse: [aPath := (self  automatedApplication configurationPragmasForServer: self automatedServer) first message arguments last.].	aPath isString ifFalse: [aPath := aPath value].	aResponder := self automatedServer responders detect: [:e | e path = aPath.].	^aResponder</body><body package="AppeX-JS-Automation">createNetRequestFrom: aRequestLine	|  statusLine method version request stream |		method := aRequestLine method.	version := aRequestLine version.	request := Net.HttpRequest new.	request body: Net.UnparsedBody new.	statusLine := Net.HttpRequestLine new.	statusLine 		path: aRequestLine path;		method: method;		version: version.		stream := (aRequestLine connection readStream positioning					asEncodedStreamWithEncoding: #ISO8859_1 					lineEndConvention: OS.IOConstants.LineEndCRLF )				lineEndCRLF.	request 		messageLine: statusLine;		readingOptions: "SeasideHttpReadingOptions new" SiouX.NetHttpResponder defaultReadingOptions;		source: stream.	^request</body><body package="AppeX-JS-Automation">createRequestFrom: aRequestLine		(self needsNetRequestFor: aRequestLine)		ifTrue: [^self createNetRequestFrom: aRequestLine].	^super createRequestFrom: aRequestLine</body><body package="AppeX-JS-Automation">needsNetRequestFor: aRequestLine	self automatedApplication ifNil: [^false].	"Requests for acceptResultString or AppeX resources are not external."	(aRequestLine url tail indexOfSubCollection: 'acceptResultString' startingAt: 1) = 0 ifFalse: [^false].	(aRequestLine url tail indexOfSubCollection: 'AppeX' startingAt: 1) = 0 ifFalse: [^false].	(aRequestLine url path includes: 'appex') ifTrue: [^false]. "e.g. occurs in appex-seaside"	"could be external to Smalltalk (e.g. on the web) or just external to AppeX"	^self applicationsUsingNetRequests includes: self automatedApplication name</body><body package="AppeX-JS-Automation">newResponse	| aRequest |		aRequest := self currentRequest .	(aRequest  class = Net.HttpRequest)		ifTrue: [^Net.HttpResponse code: '200'].	^HttpResponse code: 200</body><body package="AppeX-JS-Automation">processExternalApplicationRequest:  aProtocolContext	| aClient aURL aResponse |		aClient := Net.HttpClient new.	"Impartant: keep the http, EG  http:// www. google. com [snip]."	aURL := self externalApplicationPortPath, aProtocolContext request requestLine path.		aResponse := aClient get:aURL.	"Inject the automator code into any response html"	aResponse contentType = 'text/html' ifTrue: [		"Have to set up the request actions"		 JSAutomator htmlTemplate.		aResponse contents: (aResponse contents copyFrom: 1  to: aResponse contents  size - '&lt;/body&gt;&lt;/html&gt;' size),'&lt;script src="AppeX.CoreCode.js"&gt;&lt;/script&gt;&lt;script src="AppeX.JSAutomatorClient.js"&gt;&lt;/script&gt;&lt;script src="//code.jquery.com/jquery-2.2.1.min.js" integrity="sha256-gvQgAFzTH6trSrAWoH1iPo9Xc96QxSZ3feW6kem+O00=" crossorigin="anonymous"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;'.	].			self currentRequestContext response: aResponse.	aResponse signalReady.			"Test returning an image"				"bytes := ByteArray fromBase64String: AppeXHTTP2Demo cincomSmalltalkImageBase64.		self currentResponse	contentType: 'image/png';	contents: bytes;	signalReady"</body><body package="AppeX-JS-Automation">setRequestIn: context from: aRequestLine	(self needsNetRequestFor: aRequestLine)		ifTrue: [^context request: (self createRequestFrom: aRequestLine)].	super setRequestIn: context from: aRequestLine.</body></methods><methods><class-id>AppeX.JSAutomator</class-id> <category>services</category><body package="AppeX-JS-Automation">processRequest:  aProtocolContext			self automatedApplication isNil ifTrue: [^super processRequest: aProtocolContext].	[		(self automatedApplication = self class and: [aProtocolContext request  class = Net.HttpRequest] )			ifTrue: [self processExternalApplicationRequest: aProtocolContext].							(aProtocolContext request url tail = 'acceptResultString') 			ifTrue: [					self applyRequestFilters: aProtocolContext.				self executeRequestFor: aProtocolContext.			]			ifFalse: [				|  aResponder |								aResponder := self automatedResponderForContext: aProtocolContext.				(aResponder class inheritsFrom: AppeX.Application )					ifTrue: [						aResponder checkForSessionFilter.						"Must set the responder before setting the appexAction"						aProtocolContext responder: aResponder.						aProtocolContext appexAction: (self automatedApplication actionFor: aProtocolContext).											aResponder applyRequestFilters: aProtocolContext.					].				(aProtocolContext request url tail = '') ifTrue: [					"this is the first request.  fix the path before  building the html so page has correct &lt;base href="					aProtocolContext request url path: aResponder decodedPath.				].				aResponder executeRequestFor: aProtocolContext.			]			]	on: ResponseReady		do: [ :ex |			"			If, during the previous block, a 'ResponseReady' notification has been signalled, there is no point in continuing,			and we return with the assumption that the context has the response so it can send it back to the client.			"			aProtocolContext response: ex response.			ex return ].</body></methods><methods><class-id>AppeX.JSAutomator class</class-id> <category>accessing</category><body package="AppeX-JS-Automation">applicationClientClass	^JSAutomatorClient</body><body package="AppeX-JS-Automation">applicationsUsingNetRequests		"maybe make this a class variable"	^#(SeasideWelcome JSAutomator)</body></methods><methods><class-id>AppeX.JSAutomator class</class-id> <category>html</category><body package="AppeX-JS-Automation">bodyTextAreas		^'	&lt;textarea id="resultString"&gt;&lt;/textarea&gt;'</body></methods><methods><class-id>AppeX.JavascriptParser</class-id> <category>RefactoringBrowser compatibility</category><body package="AppeX-JS-Automation">format: parseTree		(Server id: 'JSEvaluator') isRunning 		ifTrue: [ ^(AppeX.JSEvaluator formatJavaScript: parseTree sourceCode string) ifNil: [parseTree sourceCode string]].	^parseTree sourceCode string</body></methods><methods><class-id>AppeX.JSEvaluatorClient</class-id> <category>javascript</category><body package="AppeX-JS-Automation">applyFunction() {	//rpc style communication from Smalltalk	//try to limit use of the global function 'eval', since it is hard to debug	var  aFunction,		anArgumentsArray,		aValueForThis;		if (this.functionLocation === "this") {		//functionLocation of "this" is a (hopefully intuitive) shortcut for saying the method is implemented on the JSEvaluator itself		aFunction = this[this.functionName];	} else if (this.functionLocation) {		//functionLocation must be a fully qualified name off of window		aFunction = window[this.functionLocation][this.functionName];	} else {		//look for global function if no location was specified		aFunction = window[this.functionName];	};		 if (!aFunction) {		//function not found		this.resultString = "function " + this.functionName + " not found on " + this.functionLocation + ".";		return;	}		//functionLocation must be a fully qualified name off of window (or null)	aValueForThis = window[this.valueForThis] ;	//argumentsArray = JSON.parse(this.arguments);	//hack for now; only use first argument	anArgumentsArray = new Array(this.functionArguments);	try { 		this.resultString = aFunction.apply(this.valueForThis, anArgumentsArray);	} catch (err)  {		this.resultString = err.toString();			console.log(err);	};	 $('#resultString').val(this.resultString);}</body><body package="AppeX-JS-Automation">formatJavaScript(aString) {	var options = {		brace_style: "collapse",		break_chained_methods: false,		comma_first: false,		e4x: false,		end_with_newline: false,		indent_char: "\t",		indent_inner_html: false,		indent_scripts: "normal",		indent_size: "1",		jslint_happy: true,		keep_array_indentation: false,		max_preserve_newlines: "5",		preserve_newlines: true,		space_before_conditional: true,		unescape_strings: false,		wrap_line_length: "0"	};	//js_beautify is a global function 	return js_beautify(aString, options);}</body></methods><methods><class-id>AppeX.JSEvaluatorClient</class-id> <category>communication with server</category><body package="AppeX-JS-Automation">sendResultStringToServer() {		var response, 			result;		result = {};		debugger;		result[this.hashString] = this.resultString;		response = this.asyncMessageToServer("acceptResultString", result)			.onSuccess(function (data) { 				console.log(data);						});	}</body></methods><methods><class-id>AppeX.JSEvaluatorClient</class-id> <category>html</category><body package="AppeX-JS-Automation">buildHtml() {		this.hashString = $('#hash').val();	this.functionName = $('#functionName').val();	this.functionLocation = $('#functionLocation').val();	this.valueForThis = $('#valueForThis').val();	this.functionArguments = $('#functionArguments').val();		//check to applyFunction	if (this.functionName) {		this.applyFunction();		this.sendResultStringToServer();		//Comment out following line to leave browser window open for easier debugging		window.close();  		return;	}				}</body></methods><methods><class-id>AppeX.JSEvaluator class</class-id> <category>html</category><body package="AppeX-JS-Automation">bodyTextAreas	&lt;body: 40&gt;		"use a textArea tags to transfer to the client strings that represent JavaScript needing formatting, evaluation, etc. 	These strings from Smalltalk often do not conform to JavaScript syntax for a String (does not have a \ terminator on each line) "			| hashString aFunctionName aFunctionLocation aValueForThis anArgument inputs |	self currentRequestContext		ifNil: [			hashString :=  (self md5Hash: '') asHexString.			inputs := Array new: 5.			inputs at: 1 put: hashString]		ifNotNil: [ :context |			|  query |			query := Dictionary new.			context request url queryKeysAndValuesDo: [:key :value | query at: key put: value].			hashString := query at: 'hash' ifAbsent: [^'Refer to the AppeX-Examples-JSEvaluator package comments for usage of the JSEvaluator.'].			inputs := context responder getParameters: hashString ].		inputs := inputs reading.	aFunctionName := inputs get ifNil: [''].	aFunctionLocation := inputs get ifNil: [''].	aValueForThis := inputs get ifNil: [''].	"hack for the moment: only use first argument, and assume it is a string"	anArgument := (inputs get ifNil: [ #('') ]) first.		^'	&lt;input type="hidden" id="hash" value="', hashString, '"&gt;	&lt;textarea id="functionName"&gt;', aFunctionName, '&lt;/textarea&gt;	&lt;div id="smalltalkButtonDiv"&gt;&lt;/div&gt;	&lt;textarea id="functionLocation"&gt;', aFunctionLocation, '&lt;/textarea&gt;	&lt;textarea id="valueForThis"&gt;', aValueForThis, '&lt;/textarea&gt;	&lt;textarea id="functionArguments"&gt;', anArgument, '&lt;/textarea&gt;	&lt;textarea id="resultString"&gt;&lt;/textarea&gt;'</body><body package="AppeX-JS-Automation">headBeautifyJS	&lt;head: 202&gt;		"Dynamically generate the html since this is a generalized jsevaluator."	^'&lt;script src="js-evaluator/beautify.js"&gt;&lt;/script&gt;'</body><body package="AppeX-JS-Automation">headExternalLibraries	&lt;head: 200&gt;	^self jqueryMinTags</body><body package="AppeX-JS-Automation">htmlTitle	&lt;htmlToken: #title&gt;	^ 'JSEvaluator'</body></methods><methods><class-id>AppeX.JSEvaluator class</class-id> <category>configuration</category><body package="AppeX-JS-Automation">serverConfiguration	&lt;server: 'JSEvaluator' path: '/'&gt;</body></methods><methods><class-id>AppeX.JSEvaluator class</class-id> <category>css</category><body package="AppeX-JS-Automation">defaultStyle	&lt;css: 'defaultStyle.css'&gt;	^'textarea { 	 max-width: 100%;	 height: 2em;    	width: 80em;}#functionArguments, #resultString {	 height: 14em;}'</body></methods><methods><class-id>AppeX.JSEvaluator class</class-id> <category>services</category><body package="AppeX-JS-Automation">acceptResultString	&lt;plainText: 'acceptResultString'&gt;		| result |		"putting a breakpoint in here will cause the the workspace evaluateJavaScript: to return nil because of asynchronous processing"		result := self currentRequestArguments.		self responder acceptResult: result associations any.	^ 'OK'</body></methods><methods><class-id>AppeX.JSAutomator class</class-id> <category>configuration</category><body package="AppeX-JS-Automation">serverConfiguration	&lt;server: 'JSAutomator' path: '/'&gt;</body></methods><methods><class-id>AppeX.JSAutomator class</class-id> <category>html</category><body package="AppeX-JS-Automation">bodyToolbar	&lt;body: 45&gt;	^'	&lt;div id="tools" class="ui-corner-all"&gt;	&lt;/div&gt;'</body></methods><methods><class-id>AppeX.JSAutomatorScript</class-id> <category>javascript - initialization</category><body package="AppeX-JS-Automation">initialize() {			//have to build screen before wrappering functions or exercising functionality	document.addEventListener("DOMContentLoaded", function () {			var automatorClient,			applicationAutomator;				//just use new to run initialize code		automatorClient = new AppeX.JSAutomatorClient();		//execute the initialize code in the testingClosure		//HACK for external applications Seaside and Search		applicationAutomator = AppeX.SeasideWelcomeAutomator ||  AppeX.SearchAutomator || AppeX[automatorClient.hashString];		new applicationAutomator(); 		});	}</body></methods><methods><class-id>AppeX.JSAutomatorClient</class-id> <category>accessing</category><body package="AppeX-JS-Automation">appendResultString(aString) {	var firstString = '';	if ( this.getResultString()) {		firstString = this.getResultString() + ',';	}	this.setResultString(firstString + aString);	}</body><body package="AppeX-JS-Automation">setResultString(aString) {	this.resultString = aString;	}</body></methods><methods><class-id>AppeX.JSAutomatorClient</class-id> <category>utility - wrapping</category><body package="AppeX-JS-Automation">wrapAfter (functionLocation, functionName, after) {	functionLocation[functionName] = this.wrapperOf (functionLocation[functionName], null, after, this);	//$t.application.refreshScreen = this.wrapperOf ($t.application.refreshScreen, null, after, $t.application);}</body><body package="AppeX-JS-Automation">wrapperOf (functionToWrap, before, after, thisObject) {	//return the wrapping function  	return function () {       		var args,			result;		//shallow copy		args = Array.prototype.slice.call(arguments);		if (before) {			before.apply(thisObject || this, args);		}		result = functionToWrap.apply(this, args);		if (after) {			after.apply(thisObject || this, args);		}		return result;    };}</body></methods><methods><class-id>AppeX.JSAutomatorClient</class-id> <category>utility - navigation</category><body package="AppeX-JS-Automation">anchorWithText(aString) {	return  [$('a:contains("' + aString + '")')][0][0];	}</body><body package="AppeX-JS-Automation">clickOnAnchorWithText(aString) {	var anAnchor; 	anAnchor = this.anchorWithText(aString);	//record a single click result	this.isRecordingClickResult = true;	anAnchor.click();}</body></methods><methods><class-id>AppeX.JSAutomatorClient</class-id> <category>initialization</category><body package="AppeX-JS-Automation">initialize() {	this.hashString = window.location.search.split('=').pop();	this.url = window.location.origin;			}</body></methods><methods><class-id>AppeX.JSAutomatorClient</class-id> <category>utility - communication</category><body package="AppeX-JS-Automation">getResultString() {	return  this.resultString;	}</body><body package="AppeX-JS-Automation">runTests() {	var result = {}; 	$("#resultString").val("Running Tests"); 		this.asyncMessageToServer("runTests", result)		.onSuccess(function (data) { 			$("#resultString").val(data);  			console.log(data);						})		.onError(function (error) {			console.error("runTests failed",  error)		});}</body><body package="AppeX-JS-Automation">sendResultStringToServer() {	var result;	result = {};	result[this.getClassName()] = this.getResultString();	this.asyncMessageToServer("acceptResultString", result)		.onSuccess(function (data) { 			console.log(data);						})		.onError(function (error) {			console.error("acceptResultString failed",  error)		});}</body></methods><methods><class-id>AppeX.JSAutomatorClient</class-id> <category>js -html</category><body package="AppeX-JS-Automation">buildHtml() {	//this message will be erased in postInstall if the package is loaded.	$("#resultString").val("'Load the package AppeX-Tests-AutomatedExamples in order to run the example tests.'"); }</body></methods><methods><class-id>SiouX.Server class</class-id> <category>configuration</category><body package="AppeX-JS-Automation">configureJSAutomator: aServer	&lt;server: 'JSAutomator'&gt;	aServer listenOn: 8896  for: HttpConnection.</body><body package="AppeX-JS-Automation">configureJSEvaluator: aServer	&lt;server: 'JSEvaluator'&gt;	aServer listenOn: 8894 for: HttpConnection.	AppeX.JSEvaluator registerAnnouncementsFrom: aServer.</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>JavascriptParser</name><environment>AppeX</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector sourceCode </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AppeXTools</package></attributes></class><class><name>Application</name><environment>AppeX</environment><super>SiouX.HttpResponder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>clientSubscriptions session eventStream </inst-vars><class-inst-vars>settings requestActions subscriptionRegistry codeComposer combinedJavascriptLibrary </class-inst-vars><imports>			private Tools.Pragma			private Xtreams.*			private SiouX.*			private Protocols.*			</imports><category></category><attributes><package>AppeX-Server</package></attributes></class><class><name>GenericJavascript</name><environment>AppeX</environment><super>AppeX.JavascriptCode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AppeX-GenericJavascript</package></attributes></class><class><name>ApplicationClient</name><environment>AppeX</environment><super>AppeX.JavascriptObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>javascriptLibrary </class-inst-vars><imports></imports><category>bootstrap</category><attributes><package>AppeX-Client</package></attributes></class></st-source>