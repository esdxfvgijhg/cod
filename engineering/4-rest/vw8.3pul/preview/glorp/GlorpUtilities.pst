<?xml version="1.0"?><st-source><!-- Name: GlorpUtilitiesComment: This contains a class for automating the creation of GLORP distributions. Given a particular set of versions in the image and a target directory it will automatically create fileouts and the corresponding packages for various dialects, preserving the version information where possible.DbIdentifier: bear73DbTrace: 90205DbUsername: aknightDbVersion: 0.5DevelopmentPrerequisites: #(#(#package 'FileOut30' ''))PackageName: GlorpUtilitiesParcel: #('GlorpUtilities')PrerequisiteParcels: #(#('FileOut30' ''))PrintStringCache: (0.5,aknight)Version: 0.5Date: 12:56:03 PM February 5, 2016 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.2 (feb16.1) of February 5, 2016 on February 5, 2016 at 12:56:03 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>GlorpUtilityWindow</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>directoryHolder vw5 vw3 dolphin va squeak </inst-vars><class-inst-vars>lastDir </class-inst-vars><imports></imports><category>UIApplications-New</category><attributes><package>GlorpUtilities</package></attributes></class><comment><class-id>GlorpUtilityWindow</class-id><body>This is a VW 5i UI for filing out Glorp code into the different dialects that are avialable. It relies on support in the FileOut30 package for VA and Dolphin Application/Package formats, as well as other enhancements there.Dolphin files are filed out in .pac format, one per package (no bundle equivalent in Dolphin).VisualAge files are filed out as one file per bundle, creating the applications and the configuration maps. The separate 'versionit.st' file creates configuration maps, versions everything off, and exports it to a .dat file. NOTE: The versioning script uses the same name as comes from Store in VW. If this conflicts with existing names in ENVY, you *WILL GET DUPLICATES*. The repository can handle it, but it's confusing.VW3 files are done as file-outs, one per bundle. Might be better off as per-package fileouts.VW5 files are parcelled out, preserving bundle structure and database links. There is some interesting hacking going on to get the version numbers into the parcel properties.Note Instance Variables:	directoryHolder	&lt;ValueModel on: String&gt;	Holds the directory into which we will file out the code.	dolphin	&lt;ValueModel on: Boolean&gt;	File out Dolphin code?	va	&lt;ValueModel on: Boolean&gt;	File out VisualAge code?	vw3	&lt;ValueModel on: Boolean&gt;	File out VW 3 code?	vw5	&lt;ValueModel on: Boolean&gt; Parcel out VW 5i code?</body></comment><methods><class-id>GlorpUtilityWindow</class-id> <category>stuff</category><body package="GlorpUtilities">basicFileOutPackage: aPackage 	"File out the package on a file corresponding to its name"	| fileName stream dirName |	dirName := self directory asFilename construct: self subDirectory.	dirName exists ifFalse: [dirName makeDirectory].	self isFilingOutNativeVW5 		ifTrue: [			fileName := dirName construct: aPackage name.			^self parcelOut: aPackage on: fileName]		ifFalse: [fileName := dirName construct: aPackage name, self extension].	stream := SourceCodeStream write: fileName.		[Store.Notice 		showProgress: 'Filing out ' , aPackage name		complete: aPackage itemCount		while: 			[stream timeStamp.			stream deferInitializations.			aPackage fileOutOn: stream.			stream finishInitializations]] 			ensure: [stream close]</body><body package="GlorpUtilities">fileOutInFormat: aClassName 	"Dump GLORP in VA and Dolphin format"	| oldSetting |	oldSetting := self fileOutFormat.		[self fileOutFormat: aClassName.	self packageList do: [:each | self fileOutPackage: each].	self] ensure: [self fileOutFormat: oldSetting].</body><body package="GlorpUtilities">fileOutPackage: aPackageName 	| package packages |	package := Store.Registry pundleNamed: aPackageName.	packages := (self formatter requiresIndividualPackages or: [self formatter supportsPackages not])				ifTrue: [self individualPackagesFor: package]				ifFalse: [Array with: package].	packages do: [:each | self basicFileOutPackage: each]</body><body package="GlorpUtilities">individualPackagesFor: aPundleModel 	^aPundleModel isBundle		ifTrue: [aPundleModel allContainedItems select: [:each | each isBundle not]]		ifFalse: [Array with: aPundleModel]</body><body package="GlorpUtilities">packageList	| baseList list |	baseList := self universalPackageList.	list := baseList 				, (self isFilingOutVW ifTrue: [self vwOnlyPackageList] ifFalse: [#()]).	^self isFilingOutNativeVW5 		ifTrue: [list , self vw5OnlyPackageList]		ifFalse: [list]</body><body package="GlorpUtilities">parcelOut: aPackage on: aFilename	| description options |	description := aPackage itemString asString."	aPackage propertyAt: #version put: description."	options := Dictionary new.	options at: #parcelOverwrite put: true.	options at: #parcelSaveSource put: true.	options at: #additionalProperties put: (Dictionary new at: #version put: description; yourself).	aPackage 		saveAsParcel: aFilename		saveStructure: true		saveLinks: true		parcelOptions: options.</body><body package="GlorpUtilities">universalPackageList	^#('Glorp' 'GlorpTest' 'StoreForGlorp' 'StoreForGlorpReplication' 'StoreForGlorpBrowserUI' ).</body><body package="GlorpUtilities">vaPackageList	^#('Glorp' 'GlorpTest' 'GlorpVAPort').</body><body package="GlorpUtilities">vw5OnlyPackageList	^#('GlorpUtilities' 'GlorpVWLauncherTool' 'StoreForGlorpVWUI').</body><body package="GlorpUtilities">vwOnlyPackageList	^#('GlorpVWPort' 'RBPrerequisiteVWPort').</body></methods><methods><class-id>GlorpUtilityWindow</class-id> <category>aspects</category><body package="GlorpUtilities">directory	^self directoryHolder value.</body><body package="GlorpUtilities">directoryHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^directoryHolder isNil		ifTrue:			[directoryHolder := Filename defaultDirectory asString asValue]		ifFalse:			[directoryHolder]</body><body package="GlorpUtilities">dolphin	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^dolphin isNil		ifTrue:			[dolphin := true asValue]		ifFalse:			[dolphin]</body><body package="GlorpUtilities">squeak	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^squeak isNil		ifTrue:			[squeak := true asValue]		ifFalse:			[squeak]</body><body package="GlorpUtilities">va	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^va isNil		ifTrue:			[va := true asValue]		ifFalse:			[va]</body><body package="GlorpUtilities">vw3	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^vw3 isNil		ifTrue:			[vw3 := true asValue]		ifFalse:			[vw3]</body><body package="GlorpUtilities">vw5	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^vw5 isNil		ifTrue:			[vw5 := true asValue]		ifFalse:			[vw5]</body></methods><methods><class-id>GlorpUtilityWindow</class-id> <category>accessing</category><body package="GlorpUtilities">extension	^self formatter defaultExtension</body><body package="GlorpUtilities">fileOutFormat	^UISettings preferenceFor: #fileOutType.</body><body package="GlorpUtilities">fileOutFormat: aSymbol	(UISettings preferenceModelFor: #fileOutType) value: aSymbol.	aSymbol == #always		ifTrue: [ Store.Registry installCallBacksForFileout ]		ifFalse: [ Store.Registry removeCallBacksForFileout ].</body><body package="GlorpUtilities">fileOutOption	"self new fileOutOption"	^Store.UISettings preferenceFor: #fileoutOption.</body><body package="GlorpUtilities">fileOutOption: aSymbol	"self new fileOutOption: #always"	(Store.UISettings preferenceModelFor: #fileoutOption) value: aSymbol.	aSymbol == #always		ifTrue: [ Store.Registry installCallBacksForFileout ]		ifFalse: [ Store.Registry removeCallBacksForFileout ].</body><body package="GlorpUtilities">formatter	"We MUST use basicNew here because otherwise we trash the fileOutOption setting. I don't really care for the way that all works."	^self fileOutFormat asQualifiedReference value basicNew</body><body package="GlorpUtilities">subDirectory	"A hack to put the different fileouts each in their own subdir"	| prefix |	prefix := self formatter syntax.	^prefix readStream upTo: Character space</body></methods><methods><class-id>GlorpUtilityWindow</class-id> <category>ENVY versioning</category><body package="GlorpUtilities">fileOutENVYVersioningScript	| file packages bundles |	file := ((self directory asFilename construct: 'VisualAge') 				construct: 'versionit.st') writeStream.	file nextPutAll: '"   This file contains code to version off all of the GLORP applications, create configurationmaps corresponding to the bundles, and export the whole thing to a new .dat file. NOTE: The version namesused are hard-coded in this file, and if they conflict with existing names in the repository (e.g. if you do thisfile-in process twice for the same version) then you will get duplicate names. The repository can handle it, butit''s confusing.  There''s lots of duplicated code here, but it works."'; cr; cr.	bundles := self universalPackageList				collect: [:each | Store.Registry pundleNamed: each].	bundles := bundles reverse.	"So that prerequisites come first"	packages := bundles inject: OrderedCollection new				into: 					[:sum :each | 					sum addAll: (self individualPackagesFor: each).					sum].	packages reverseDo: [:each | self writeEnvyScriptToVersion: each on: file].	bundles do: [:each | self writeEnvyConfigMapScriptFor: each on: file].	self writeEnvyExportScriptForBundlesNamed: (#('GlorpVAPortMap'), (bundles collect: [:each | each name])) on: file.	file close</body><body package="GlorpUtilities">writeEnvyConfigMapScriptFor: aPackageModel on: aStream	| name versionStream version |	name := aPackageModel name.	versionStream := aPackageModel versionString readStream.	versionStream skipThrough: $(.	version := versionStream upTo: $,.	aStream nextPutAll:( '	| map mapEditions someVersion versionName |	versionName := ''&lt;2s&gt;''.	mapEditions := EmConfigurationMap editionsFor: ''&lt;1s&gt;''.	mapEditions isEmpty ifTrue: [		EmConfigurationMap create: ''&lt;1s&gt;''.		mapEditions := EmConfigurationMap editionsFor: ''&lt;1s&gt;''].	someVersion := mapEditions detect: [:each | each isVersion] ifNone: [mapEditions first].	map := someVersion isVersion 		ifTrue: [			EmLibrary default operationsInterface				configMapNewEditionFor: someVersion				useApplicationEditions: false				ifUnable: [^nil].			(EmConfigurationMap editionsFor: ''&lt;1s&gt;'') first.]		ifFalse: [someVersion].' expandMacrosWith: name with: version).	(self individualPackagesFor: aPackageModel) do: [:each |		aStream 			nextPutAll: '	map addApplication: ';			nextPutAll: each name;			nextPutAll: ' residentApplication.';			cr].	aStream nextPutAll: '	EtTools managerInterface versionConfigMap: map withName: versionName.'.	aStream nextPutAll: ' ! '; cr; cr.</body><body package="GlorpUtilities">writeEnvyExportScriptForBundlesNamed: aCollection on: aStream 	aStream nextPutAll: '	| maps |	maps := '.	aStream print: aCollection asArray.	aStream		nextPutAll: ' collect: [:each | (EmConfigurationMap editionsFor: each) first].';		cr.	aStream 		nextPutAll: '	EtTools exportUsing: [:sourceLibrary :destinationLibrary |		EtTools managerInterface 			moveConfigMaps: maps 			from: sourceLibrary 			to: destinationLibrary			withOptions: EtConfigurationMapsBrowser					currentExportingOptions			withAllRequiredMaps: EtTools moveAllRequiredMapsToo].'.	aStream		nextPutAll: ' !';		cr;		cr</body><body package="GlorpUtilities">writeEnvyScriptToVersion: aPackage on: aStream		| versionStream version|	versionStream := aPackage versionString readStream.	versionStream skipThrough: $(.	version := '''', (versionStream upTo: $, ), ''''.	aStream nextPutAll: '| selectedApp versionName ownedClasses alreadyReleased unReleased|'; cr.	aStream 		nextPutAll: '	selectedApp := ', aPackage name; nextPutAll: '.'; cr;		nextPutAll: '	versionName := ', version; nextPutAll: '.'; cr;		nextPutAll: '	ownedClasses := selectedApp allLoadedClassesOwnedBy: EmUser current.'; cr.	aStream nextPutAll: '	alreadyReleased := selectedApp releasedClassVersions.	unReleased := ownedClasses select: [:cl |		(alreadyReleased at: cl symbol ifAbsent: [nil]) ~= (cl timeStampIn: selectedApp)].		unReleased do: [:each |		    EtTools managerInterface versionClass: each in: selectedApp withName: versionName].	unReleased isEmpty ifFalse: [		EtApplicationManager new releaseEachClassIn: ownedClasses into: selectedApp].	EmInterface current rebuildNamespacesFor: (Array with: selectedApp). 	EtTools managerInterface versionApplication: selectedApp withName: versionName.'.	aStream nextPutAll: ' !'.	aStream cr; cr.</body></methods><methods><class-id>GlorpUtilityWindow</class-id> <category>testing</category><body package="GlorpUtilities">isFilingOutNativeVW5	^(self formatter isKindOf: ChunkSourceFileFormat) not</body><body package="GlorpUtilities">isFilingOutVW	^'VW*' match: self formatter syntax</body></methods><methods><class-id>GlorpUtilityWindow</class-id> <category>actions</category><body package="GlorpUtilities">fileOut	"Dump GLORP in VW5, VW3, VA, Squeak, and Dolphin format"	self directory asFilename exists 		ifFalse: 			[(Dialog confirm: 'Directory ' , self directory asString 						, ' does not exist. Create it?') 				ifTrue: [self directory asFilename makeDirectory]				ifFalse: [^self]].	self vw3 value ifTrue: [self fileOutInFormat: #OldChunkSourceFileFormat].	self dolphin value ifTrue: [		self fileOutInFormat: #'DolphinCompatibility.DolphinPackageSourceFileFormat'].	self va value ifTrue: [		self fileOutInFormat: #'VisualAgeCompatibility.VisualAgeApplicationSourceFileFormat'.		self fileOutENVYVersioningScript.].	self vw5 value ifTrue: [self fileOutInFormat: #XMLSourceFileFormat].	self squeak value ifTrue: [		[self fileOutInFormat: #'SqueakCompatibility.SqueakChangeSetFileFormat'] on: UserNotification do: [:ex | ex resume: true]].</body></methods><methods><class-id>GlorpUtilityWindow class</class-id> <category>defaults</category><body package="GlorpUtilities">fileOutDirectory	lastDir isNil ifTrue: [lastDir := Filename defaultDirectory].	^lastDir.</body><body package="GlorpUtilities">fileOutDirectory: aFilename	lastDir := aFilename asFilename.</body></methods><methods><class-id>GlorpUtilityWindow class</class-id> <category>interface specs</category><body package="GlorpUtilities">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#properties: #(#{UI.PropertyListDictionary} #positionType #cascade #sizeAutoSave true #openType #cascade ) 			#label: 'Glorp Utility Tool' 			#bounds: #(#{Graphics.Rectangle} 840 525 1348 869 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 80 17 432 41 ) 					#name: #InputField1 					#model: #directoryHolder ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 14 18 ) 					#name: #Label1 					#label: 'Directory' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 79 84 219 122 ) 					#name: #ActionButton1 					#model: #fileOut 					#label: 'File-out' 					#defaultable: true ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 287 73 ) 					#name: #CheckBox1 					#model: #vw5 					#label: 'VW5' ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 287 107 ) 					#name: #CheckBox3 					#model: #dolphin 					#label: 'Dolphin' ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 286 140 ) 					#name: #CheckBox4 					#model: #va 					#label: 'VA' ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 288 181 ) 					#name: #CheckBox2 					#model: #vw3 					#label: 'VW3' ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 287 214 ) 					#name: #CheckBox5 					#model: #squeak 					#label: 'Squeak' ) ) ) )</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class></st-source>