<?xml version="1.0"?><st-source><!-- Name: StoreForSqlAzureNotice: Copyright 1999-2015 Cincom Systems, Inc.  All rights reserved.Comment: Store adds team development and version control tools and facilities to the VisualWorks development environment.Load this parcel to use Store with a Microsoft SQL Azure repository -  all other Store parcels will be loaded automatically. Here is a typical repository, after you create a database named NEWBERN1 with your Azure account.  Interface: MS_SQLAzureConnection  Environment: Driver={SQL Server Native Client 10.0};Server=tcp:abcd01xtjm.database.windows.net;Database=NEWBERN1;Uid=myname@abcd01xtjm;Pwd=mypassword;Encrypt=yes  User Name: myname@abcd01xtjm  Password: mypassword  Table Owner: dboLogin as the Store administrator (typically, BERN / BERN for the User Name / Password fields in the above, not changing the Environment field), to enable garbage collection.Further information on Store can be found in the "Source Code Management Guide" (located in the /doc subdirectory of the VisualWorks installation).DbIdentifier: bear73DbTrace: 468307DbUsername: dwallenDbVersion: 8.1 - 1DevelopmentPrerequisites: #(#(#any 'StoreForSqlServer' ''))PackageName: StoreForSqlAzureParcel: #('StoreForSqlAzure')ParcelName: StoreForSqlAzurePrerequisiteDescriptions: #(#(#name 'StoreForSqlServer' #componentType #package))PrerequisiteParcels: #(#('StoreForSqlServer' ''))PrintStringCache: (8.1 - 1,dwallen)Version: 8.1 - 1Date: 1:28:43 PM July 3, 2015 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.1 (jul15.1) of July 3, 2015 on July 3, 2015 at 1:28:43 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>DatabaseIndex</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name fields isClustered </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>MjlGlorp</category><attributes><package>StoreForSqlAzure</package></attributes></class><comment><class-id>Glorp.DatabaseIndex</class-id><body>This describes an index in the database. Glorp doesn't use it internally, other than when creating tables in the database.Instance Variables	fields	&lt;(SequenceableCollection of: DatabaseField)&gt;	The set of fields that are to be indexed.	name	&lt;String&gt;	The name of the index. We will try and generate one based on the table if one is not supplied.	isClustered &lt;Boolean&gt; True if this index needs to have the CLUSTERED attribute in its creation SQL.</body></comment><class><name>MS_SQLAzureConnection</name><environment>Database</environment><super>Database.ODBCConnection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>StoreSqlServer</category><attributes><package>StoreForSqlAzure</package></attributes></class><comment><class-id>Database.MS_SQLAzureConnection</class-id><body>MS_SQLAzureConnection is a specialized class that allows one to connect to the cloud-based MS SQL Azure using Store.</body></comment><class><name>SQLAzurePlatform</name><environment>Glorp</environment><super>Glorp.SQLServerPlatform</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>StoreForSqlAzure</package></attributes></class><comment><class-id>Glorp.SQLAzurePlatform</class-id><body>This is a platform for the Microsoft SQL Azure database. It subclasses from SQL Server, because the two have a number of characteristics in common.</body></comment><methods><class-id>Glorp.DatabaseIndex</class-id> <category>accessing</category><body package="StoreForSqlAzure">beClustered	isClustered := true</body></methods><methods><class-id>Glorp.DatabaseIndex</class-id> <category>testing</category><body package="StoreForSqlAzure">isClustered	^isClustered</body></methods><methods><class-id>Glorp.DatabaseIndex</class-id> <category>initializing</category><body package="StoreForSqlAzure">initialize	fields := OrderedCollection new: 2.	isClustered := false.</body></methods><methods><class-id>Glorp.DatabaseIndex</class-id> <category>comparing</category><body package="StoreForSqlAzure">isTheSameAs: aDatabaseIndex	"Validate that two indexes are exactly the same. Most useful for testing purposes, rather than normal usage, which is why we don't just use the #= method."	self name asUppercase = aDatabaseIndex name asUppercase ifFalse: [^false].	self fields with: aDatabaseIndex fields  do: [:a :b | (a isTheSameAs: b) ifFalse: [^false]].	(self isClustered = aDatabaseIndex isClustered) ifFalse: [^false].		^true.</body></methods><methods><class-id>Database.MS_SQLAzureConnection class</class-id> <category>accessing</category><body package="StoreForSqlAzure">kind	"Answer a symbol representing the type of DMBS the receiver provides services for."	^#'MS_SQL Azure'</body></methods><methods><class-id>Database.MS_SQLAzureConnection class</class-id> <category>glorp</category><body package="StoreForSqlAzure">glorpStoreDatabasePlatformClass	^Glorp.SQLAzurePlatform</body></methods><methods><class-id>Glorp.SQLAzurePlatform</class-id> <category>testing</category><body package="StoreForSqlAzure">isSQLAzurePlatform	^true</body><body package="StoreForSqlAzure">supportsPhysicalSpaces	^false</body><body package="StoreForSqlAzure">supportsTableOwners	"Return true if this platform supports table owners, i.e. expects table names of the form Bern.TW_* rather than just TW_* in its SQL."	"Access, Firebird and PostGreSQL do not, Oracle does, others I know not."	^false</body></methods><methods><class-id>Glorp.SQLAzurePlatform</class-id> <category>constants</category><body package="StoreForSqlAzure">requiresTransactionForTableOperations	^false</body></methods><methods><class-id>Glorp.SQLAzurePlatform</class-id> <category>database-specific</category><body package="StoreForSqlAzure">createStoreSpecificViewsSQLUsingAccessor: aDatabaseAccessor	^Transcript cr; show: 'SQL Azure does not support versions prior to VisualWorks 7.9, so compatible views were not created.'; cr.</body><body package="StoreForSqlAzure">grantStoreSpecificPermissionsSQLUsingAccessor: aDatabaseAccessor		^'GRANT INSERT, SELECT ON TW_ClassRecord TO PUBLIC;GRANT INSERT, SELECT ON TW_NameSpaceRecord TO PUBLIC;GRANT INSERT, SELECT ON TW_Package TO PUBLIC;GRANT UPDATE ON TW_Package ( version, blessingLevel )  TO PUBLIC;GRANT INSERT, SELECT ON TW_ParcelRecord TO PUBLIC;GRANT UPDATE ON TW_ParcelRecord ( version )  TO PUBLIC;GRANT INSERT, SELECT ON TW_PkgClasses TO PUBLIC;GRANT INSERT, SELECT ON TW_PkgNameSpaces TO PUBLIC;GRANT INSERT, SELECT ON TW_Method TO PUBLIC;GRANT UPDATE ON TW_Method ( version )  TO PUBLIC;GRANT INSERT, SELECT ON TW_Methods TO PUBLIC;GRANT UPDATE, DELETE ON TW_Methods TO PUBLIC;GRANT INSERT, SELECT ON TW_Blob TO PUBLIC;GRANT INSERT, SELECT ON TW_BinaryBlob TO PUBLIC;GRANT INSERT, SELECT ON TW_Blessing TO PUBLIC;GRANT UPDATE ON TW_Blessing ( blessingLevel )  TO PUBLIC;GRANT INSERT, SELECT ON TW_Bundle TO PUBLIC;GRANT UPDATE ON TW_Bundle ( version, blessingLevel )  TO PUBLIC;GRANT INSERT, SELECT ON TW_Bundles TO PUBLIC;GRANT INSERT, SELECT ON TW_Packages TO PUBLIC;GRANT INSERT, SELECT ON TW_DataElement TO PUBLIC;GRANT INSERT, SELECT ON TW_Data TO PUBLIC;GRANT UPDATE, DELETE ON TW_Data TO PUBLIC;GRANT SELECT, UPDATE ON TW_DatabaseIdentifier TO PUBLIC;GRANT INSERT, SELECT ON TW_Files TO PUBLIC;GRANT INSERT, SELECT ON TW_FileRecord TO PUBLIC;GRANT UPDATE ON TW_FileRecord ( version )  TO PUBLIC;GRANT INSERT, SELECT ON TW_Properties TO PUBLIC;GRANT INSERT, SELECT ON TW_PropertyRecord TO PUBLIC;GRANT SELECT ON TW_DBUserGroup TO PUBLIC;GRANT SELECT ON TW_DBPundlePrivileges TO PUBLIC;GRANT SELECT, INSERT ON TW_LoadRecord TO PUBLIC;GRANT SELECT, INSERT ON TW_MethodDocs TO PUBLIC'</body></methods><methods><class-id>Store.Glorp.StoreDescriptorSystem class</class-id> <category>schema selection</category><body package="StoreForSqlAzure">platformSpecificSchemaFor: aDatabaseAccessor	| platformSpecificSchema |	platformSpecificSchema := aDatabaseAccessor schema notNil		ifTrue: [aDatabaseAccessor schema]		ifFalse: [''].	(aDatabaseAccessor platform isSQLServerPlatform and: [aDatabaseAccessor platform isSQLAzurePlatform not])		ifTrue: [platformSpecificSchema := Store.Policies tableSpacePolicy defaultTableSpace].	^platformSpecificSchema</body><body package="StoreForSqlAzure">platformSpecificSchemaFor: aDatabaseAccessor tableName: aString	| platformSpecificSchema |	platformSpecificSchema := aDatabaseAccessor schema notNil		ifTrue: [aDatabaseAccessor schema]		ifFalse: [''].	(aDatabaseAccessor platform isSQLServerPlatform and: [aDatabaseAccessor platform isSQLAzurePlatform not]) ifTrue: 		[platformSpecificSchema := (self tableSpacesMap			at: aString asUppercase			ifAbsent: [Store.Policies tableSpacePolicy defaultTableSpace])].	^platformSpecificSchema</body></methods><methods><class-id>Glorp.DatabaseField</class-id> <category>testing</category><body package="StoreForSqlAzure">hasClusteredIndex	"Is this field part of a clustered index?"	| anIndex |	anIndex := self table indexes detect: 			[:index |			index isClustered ifTrue: [index fields includes: self] ifFalse: [false]].	^anIndex notNil</body></methods><methods><class-id>Glorp.DatabaseTable</class-id> <category>indexes</category><body package="StoreForSqlAzure">ensureExistsAClusteredIndex	(self hasPrimaryKeyConstraints not and: [self hasClusteredIndex not])		ifTrue: 			[self indexes isEmpty				ifTrue: [(self addIndexForField: fields first) beClustered]				ifFalse: [self indexes first beClustered]]</body></methods><methods><class-id>Glorp.DatabaseTable</class-id> <category>testing</category><body package="StoreForSqlAzure">hasClusteredIndex	^(indexes detect: [:index| index isClustered] ifNone: [nil]) notNil</body></methods><methods><class-id>Glorp.DatabaseTable</class-id> <category>initialize</category><body package="StoreForSqlAzure">postInitializeIn: aDescriptorSystem	"Any initialization that happens after all the fields have been added"	1 to: fields size do: [:i |		| each | 		"If fields were read from the database, set their position now"		each := fields at: i.		each table: self.		each position: i.		each postInitializeIn: aDescriptorSystem].	"SQLAzure requires a clustered index, which defaults to pkey. If there is no pkey, create a clustered index on the first column."	aDescriptorSystem platform isSQLAzurePlatform		ifTrue: 			[self ensureExistsAClusteredIndex]</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>services tables</category><body package="StoreForSqlAzure">createTableIndexStatementStringsFor: aGLORPDatabaseTable	^aGLORPDatabaseTable indexes		collect:			[:idx | | indexTypeString sqlStatementStream |			sqlStatementStream := WriteStream on: String new.			indexTypeString := idx isClustered ifTrue: ['CLUSTERED '] ifFalse: [''].			sqlStatementStream nextPutAll: 'CREATE ', indexTypeString, 'INDEX '.			sqlStatementStream nextPutAll: idx name.			sqlStatementStream nextPutAll: ' ON '.			self printDDLTableNameFor: aGLORPDatabaseTable on: sqlStatementStream.			idx printStatementOn: sqlStatementStream platform: self.			sqlStatementStream contents].</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>testing</category><body package="StoreForSqlAzure">isSQLAzurePlatform	^false</body></methods><methods><class-id>Glorp.DatabaseAccessor</class-id> <category>executing</category><body package="StoreForSqlAzure">createTableIndexes: aGlorpDatabaseTable ifError: aBlock	"Create all indexes for this table"		aGlorpDatabaseTable isImaginary ifTrue: [^self].	(self platform createTableIndexStatementStringsFor: aGlorpDatabaseTable)		do: [:each | self execute: [self executeSQLStringNoResult: each] ifError: aBlock]</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>ODBCConnection</name><environment>Database</environment><super>Database.ExternalDatabaseConnection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hdbcHolder supportedFunctions generalInformationCache unicodeEncoding sqlConnectionOptionCache </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-ODBC</category><attributes><package>ODBCEXDI</package></attributes></class><class><name>DatabaseTable</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name schema fields foreignKeyConstraints indexes parent lockKeyFields primaryKeyFields isImaginary replacementSubSelect uniqueConstraints </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><class><name>DatabaseField</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>table name isPrimaryKey position type isNullable isUnique isLockKey defaultValue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><class><name>DatabaseAccessor</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>connection currentLogin logging logger logOnly reusePreparedStatements deniedCommands mutex dependents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDatabase</category><attributes><package>GlorpDatabase</package></attributes></class><class><name>DatabasePlatform</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>types converters useBinding reservedWords functions characterEncoding </inst-vars><class-inst-vars>converterRepository </class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><class><name>SQLServerPlatform</name><environment>Glorp</environment><super>Glorp.DatabasePlatform</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class></st-source>