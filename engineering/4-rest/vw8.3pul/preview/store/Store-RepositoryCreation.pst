<?xml version="1.0"?><st-source><!-- Name: Store-RepositoryCreationNotice: Copyright 1999-2017 Cincom Systems, Inc.  All rights reserved.Comment: Contains an improved Store repository creation script builder. It can be accessed by loading this package and then executing the following:	Store.DbRegistry createEnhancedInstallScript.The biggest improvement that this script provides is the ability to GRANT Store repository read and write permissions to a database ROLE onDatabases that support users and roles. At the end of script generation, you can save it to a file.DbIdentifier: bear73DbTrace: 502810DbUsername: trobinsonDbVersion: 8.3 - 4PackageName: Store-RepositoryCreationParcel: #('Store-RepositoryCreation')ParcelName: Store-RepositoryCreationPrintStringCache: (8.3 - 4,trobinson)Version: 8.3 - 4Date: 1:09:48 PM June 23, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (jun17.4) of June 23, 2017 on June 23, 2017 at 1:09:48 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>RoleBuilder</name><environment>Store.Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name shouldCreate </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-RepositoryCreation</package></attributes></class><comment><class-id>Store.Glorp.RoleBuilder</class-id><body>RoleBuilder specifies a database ROLE and whether it should be created by a StoreRepositoryBuilder or notInstance Variables:	name		&lt;String&gt;		Name of a role to be created and/or used when creating a Store repository.	shouldCreate	&lt;Boolean&gt;	True means that the ROLE should be created.</body></comment><class><name>StoreRepositoryBuilder</name><environment>Store.Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>roleDict shouldGenerateScript databaseConnectionClassName tableSpaceDirectory repositoryName shouldInstallManagementPolicies shouldCreateViews </inst-vars><class-inst-vars></class-inst-vars><imports>			private XML.Element			private XML.Attribute			</imports><category></category><attributes><package>Store-RepositoryCreation</package></attributes></class><comment><class-id>Store.Glorp.StoreRepositoryBuilder</class-id><body>StoreRepositoryBuilder generates a SQL script to create a Store repository. The SQL is specific to the database represented by the databaseConnectionClassName. The repository created by this script allows specifying a ROLE different than PUBLIC to be granted the permissions necessary to publish code into the repository AND to load code from the repository.Instance Variables:	databaseConnectionClassName	&lt;Symbol&gt;	The name of DatabaseConnection subclass to be used to specify the database that will host the repo.	repositoryName			&lt;String&gt;		The name of the repository being created. This name should be unique among the repositories you connect to.	roleDict					&lt;Dictionary&gt;	Contains builders for the users and roles to be created or otherwise used in the SQL script.	shouldCreateViews			&lt;Boolean&gt;	True means generate views to allow pre-7.6 versions of VW to use the repository being created.	shouldGenerateScript		&lt;Boolean&gt;	For now always true, meaning generate a script, rather than attempting to create a repository on the fly.	shouldInstallManagementPolicies	&lt;Boolean&gt;	True means initialized the tables that allow for package ownership and created an admin user.	tableSpaceDirectory			&lt;Filename&gt;	Directory to create tablespaces in, if tablespaces are to be created.</body></comment><class><name>StoreUserDialog</name><environment>Store</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>databasePlatform label nameHolder shouldCreateHolder passwordHolder shouldCreateVisibility passwordVisibility </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-RepositoryCreation</package></attributes></class><comment><class-id>Store.StoreUserDialog</class-id><body>StoreUserDialog prompts for a Store database user name, password and whether the user should be created. If the New User check box is unchecked, the password field is hidden. For DB2 which only uses operating system users, only the Name field is shown and used.Instance Variables:	databasePlatform	&lt;Symbol&gt;	The name of the DatabasePlatform subclass being used. Mainly to detect DB2, which can't create users. 	label				&lt;String&gt;		The window title, usually set to a description of the user to be specified or created.	nameHolder		&lt;ValueModel containing String&gt;	Holds the user name.	passwordHolder	&lt;ValueModel containing String&gt;	Holds the user password.	shouldCreateHolder	&lt;ValueModel containing Boolean&gt;	Holds the flag to create the user  or not.	passwordVisibility	&lt;ValueModel containg Boolean&gt;		Holds the flag to determine visibility of the password entry field and label.	shouldCreateVisibility	&lt;ValueModel containingBoolean&gt;	Holds the flag to determine visibility of the shouldCreate check box.</body></comment><class><name>RepositoryBuilderDataCollectionScript</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>repositoryBuilder </inst-vars><class-inst-vars></class-inst-vars><imports>			private Glorp.*			private Store.Glorp.*			</imports><category></category><attributes><package>Store-RepositoryCreation</package></attributes></class><comment><class-id>Store.RepositoryBuilderDataCollectionScript</class-id><body>RepositoryBuilderDataCollectionScript prompts a user for the information necessary to initialize a StoreRepositoryBuilder. The intent is to eventually replace this class with a full-fledged UI to collect the data necessary to create a new Store repository. Instance Variables:	repositoryBuilder	&lt;StoreRepositoryBuilder&gt; The StoreRepositoryBuilder being initialized.</body></comment><class><name>UserBuilder</name><environment>Store.Glorp</environment><super>Store.Glorp.RoleBuilder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>password </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Store-RepositoryCreation</package></attributes></class><comment><class-id>Store.Glorp.UserBuilder</class-id><body>UserBuilder specifies a database USER and whether it should be created by a StoreRepositoryBuilder or not.Instance Variables:	password		&lt;String&gt;		Password specifies that password that the user will be created with.</body></comment><methods><class-id>Store.Glorp.RoleBuilder</class-id> <category>accessing</category><body package="Store-RepositoryCreation">name	^name</body><body package="Store-RepositoryCreation">name: anObject	name := anObject</body><body package="Store-RepositoryCreation">shouldCreate	shouldCreate isNil		ifTrue: [shouldCreate := false].	^shouldCreate</body><body package="Store-RepositoryCreation">shouldCreate: anObject	shouldCreate := anObject</body></methods><methods><class-id>Store.Glorp.RoleBuilder</class-id> <category>actions</category><body package="Store-RepositoryCreation">createInDatabase: databaseName usingAccessor: aDatabaseAccessor	^aDatabaseAccessor platform createRole: self name database: databaseName usingAccessor: aDatabaseAccessor</body><body package="Store-RepositoryCreation">createUsingAccessor: aDatabaseAccessor	^aDatabaseAccessor createRole: self name</body></methods><methods><class-id>Store.Glorp.RoleBuilder</class-id> <category>testing</category><body package="Store-RepositoryCreation">isForRole	^self isForUser not</body><body package="Store-RepositoryCreation">isForUser	^false</body></methods><methods><class-id>Store.Glorp.RoleBuilder class</class-id> <category>instance creation</category><body package="Store-RepositoryCreation">roleName: aRoleName shouldCreate: aBoolean	^self new		name: aRoleName;		shouldCreate: aBoolean</body></methods><methods><class-id>Store.Glorp.StoreRepositoryBuilder</class-id> <category>accessing</category><body package="Store-RepositoryCreation">databaseConnectionClassName	^databaseConnectionClassName</body><body package="Store-RepositoryCreation">databaseConnectionClassName: classNameSymbol	databaseConnectionClassName := classNameSymbol</body><body package="Store-RepositoryCreation">databasePlatform	| connectionClass |	connectionClass := Store.ConnectionProfile concreteDatabaseDriverClasses		detect: [:ea| ea name = self databaseConnectionClassName] ifNone: [nil].	^connectionClass isNil		ifTrue: [nil]		ifFalse: [connectionClass glorpStoreDatabasePlatformClass new]</body><body package="Store-RepositoryCreation">developerRoleName	| roleBuilder |	roleBuilder := self getRoleFor: #developerRoleName ifAbsent: [self error: 'Role not defined'].	^roleBuilder name.</body><body package="Store-RepositoryCreation">getRoleFor: aSymbol ifAbsent: aBlock	^roleDict at: aSymbol ifAbsent: aBlock</body><body package="Store-RepositoryCreation">managementPolicyAdminName	| roleBuilder |	roleBuilder := self getRoleFor: #managementPolicyAdmin ifAbsent: [self error: 'Role not defined'].	^roleBuilder name.</body><body package="Store-RepositoryCreation">repositoryName	^repositoryName</body><body package="Store-RepositoryCreation">repositoryName: anObject	repositoryName := anObject</body><body package="Store-RepositoryCreation">setRoleFor: aSymbol builder: aRoleBuilder	roleDict at: aSymbol put: aRoleBuilder</body><body package="Store-RepositoryCreation">setUserFor: aSymbol builder: aUserBuilder	roleDict at: aSymbol put: aUserBuilder</body><body package="Store-RepositoryCreation">shouldCreateViews	^shouldCreateViews</body><body package="Store-RepositoryCreation">shouldCreateViews: anObject	shouldCreateViews := anObject</body><body package="Store-RepositoryCreation">shouldGenerateScript	^shouldGenerateScript</body><body package="Store-RepositoryCreation">shouldGenerateScript: anObject	shouldGenerateScript := anObject</body><body package="Store-RepositoryCreation">shouldInstallManagementPolicies	^shouldInstallManagementPolicies</body><body package="Store-RepositoryCreation">shouldInstallManagementPolicies: anObject	shouldInstallManagementPolicies := anObject</body><body package="Store-RepositoryCreation">tableOwner	| roleBuilder |	roleBuilder := self getRoleFor: #tableOwner ifAbsent: [self error: 'Role not defined'].	^roleBuilder</body><body package="Store-RepositoryCreation">tableOwnerName	| roleBuilder |	roleBuilder := self getRoleFor: #tableOwner ifAbsent: [self error: 'Role not defined'].	^roleBuilder name.</body><body package="Store-RepositoryCreation">tableSpaceDirectory	^tableSpaceDirectory</body><body package="Store-RepositoryCreation">tableSpaceDirectory: aStringOrFilename	| filenameClass filename |	aStringOrFilename isString		ifTrue: [			filenameClass := (aStringOrFilename includes: $/)				ifTrue: [UnixFilename]				ifFalse: [NTFSFilename].			filename := filenameClass named: aStringOrFilename].	tableSpaceDirectory := filename notNil		ifTrue: [filename]		ifFalse: [aStringOrFilename].</body><body package="Store-RepositoryCreation">tableSpaceNames	^(self defineTableSpacesUsingFileSuffix: '') collect: [:ea| ea value].</body></methods><methods><class-id>Store.Glorp.StoreRepositoryBuilder</class-id> <category>actions</category><body package="Store-RepositoryCreation">createConnectionProfile	| profile |	profile := Store.ConnectionProfile new.	profile driverClassName: self databaseConnectionClassName asSymbol.	self platformSupportsUsers		ifTrue: [profile tableOwner: self tableOwnerName].	^profile</body><body package="Store-RepositoryCreation">createRepositoryInstallScript	| profile descriptorSystem session accessor useBinding script |	profile := self createConnectionProfile.	Store.DbRegistry openLogTool.		descriptorSystem := StoreDescriptorSystem				newRepositoryDescriptorSystemClass.	session := descriptorSystem				sessionForLogin: (StoreLoginFactory convertStoreLogin: profile).	accessor := session accessor.	accessor logOnlyOn: Store.DbRegistry debugger debugStream.	self createUsersUsingAccessor: accessor.	accessor platform supportsPhysicalSpaces		ifTrue: [self installPhysicalSpacesUsing: accessor].	self grantUserPermissionsUsingAccessor: accessor.	self createRolesIfNecessaryUsingAccessor: accessor.	session createTables.	accessor logOnly		ifTrue: 			["We're just writing a script, so ensure we do not bind values"			useBinding := accessor platform useBinding.			accessor platform useBinding: false].	[self createUniqueDatabaseIdentifier: self repositoryName in: session.	self installUserManagementPoliciesIn: session]			ensure: [useBinding isNil ifFalse: [accessor platform useBinding: useBinding]].	self grantRolePermissionsUsingAccessor: accessor.	self shouldCreateViews		ifTrue: [ | developerRole |			developerRole := self platformSupportsUsers				ifTrue: [self developerRoleName]				ifFalse: ['PUBLIC'].			accessor createStoreSpecificViewsAndGrantViewPermissionsToUserOrRole: developerRole].	script := Store.DbRegistry debugger debugStream value string trimBlanks.	^script</body><body package="Store-RepositoryCreation">createRolesIfNecessaryUsingAccessor: aDatabaseAccessor	aDatabaseAccessor platform isSQLServerPlatform ifTrue: [^self].	roleDict keysAndValuesDo: [:functionSymbol :builder|		(builder isForRole and: [builder shouldCreate])			ifTrue: [builder createUsingAccessor: aDatabaseAccessor]		].</body><body package="Store-RepositoryCreation">createRolesInDatabase: databaseName usingAccessor: aDatabaseAccessor	roleDict keysAndValuesDo: [:functionSymbol :builder|		(builder isForRole and: [builder shouldCreate])			ifTrue: [builder createInDatabase: databaseName usingAccessor: aDatabaseAccessor]		].</body><body package="Store-RepositoryCreation">createRolesUsingAccessor: aDatabaseAccessor	roleDict keysAndValuesDo: [:functionSymbol :builder|		(builder isForRole and: [builder shouldCreate])			ifTrue: [builder createUsingAccessor: aDatabaseAccessor]		].</body><body package="Store-RepositoryCreation">createTableSpaceNamed: tableSpaceName onDevice: pathNameString usingAccessor: aDatabaseAccessor	"Don't really need the session here, only the accessor."	| spaceForBlobs size |	spaceForBlobs := Store.Policies tableSpacePolicy blobTableSpace.	size := tableSpaceName = spaceForBlobs				ifTrue: [aDatabaseAccessor platform spaceForBlobs]				ifFalse: [aDatabaseAccessor platform spaceForClasses].	aDatabaseAccessor platform		createTableSpaceNamed: tableSpaceName		onDevice: pathNameString		size: size		in: aDatabaseAccessor.	aDatabaseAccessor platform isSQLServerPlatform		ifTrue: [ | managementPolicyAdmin |			aDatabaseAccessor platform grantStoreTableSpaceAccessTo: self tableOwnerName database: tableSpaceName  usingAccessor: aDatabaseAccessor.						aDatabaseAccessor executeSQLStringNoResult: 				(aDatabaseAccessor platform					sqlStatementToGrantStoreTableOwnerPermissionsTo: self tableOwnerName).			aDatabaseAccessor platform endBatchForScriptIn: aDatabaseAccessor.			managementPolicyAdmin := self getRoleFor: #managementPolicyAdmin ifAbsent: [nil].			(managementPolicyAdmin notNil and: [managementPolicyAdmin shouldCreate])				ifTrue: [aDatabaseAccessor platform grantStoreTableSpaceAccessTo: managementPolicyAdmin name database: tableSpaceName usingAccessor: aDatabaseAccessor].			self createRolesInDatabase: tableSpaceName usingAccessor: aDatabaseAccessor].	aDatabaseAccessor platform createSchemaIfNecessaryIn: tableSpaceName usingAccessor: aDatabaseAccessor</body><body package="Store-RepositoryCreation">createUniqueDatabaseIdentifier: identifier in: aSession	| identifierObject |	identifierObject := StoreDatabaseIdentifier new.	^aSession inUnitOfWorkDo: 			[aSession register: identifierObject.			identifierObject name: identifier]</body><body package="Store-RepositoryCreation">createUsersUsingAccessor: aDatabaseAccessor	| createdUserNames |	createdUserNames := Set new.	roleDict keysAndValuesDo: [:functionSymbol :builder|		(builder isForUser and: [builder shouldCreate and: [(createdUserNames includes: builder name) not]])			ifTrue: [				builder createUsingAccessor: aDatabaseAccessor.				createdUserNames add: builder name]].</body><body package="Store-RepositoryCreation">defineTableSpacesUsingFileSuffix: fileSuffixString	| names name spaceForBlobs defaultTableSpace methodsTableSpace userTableSpace |	names := Set new.	name := self tableSpaceDirectory constructString: (spaceForBlobs := Store.Policies tableSpacePolicy blobTableSpace) , fileSuffixString.	names add: name -&gt; spaceForBlobs.	name := self tableSpaceDirectory constructString: (defaultTableSpace := Store.Policies tableSpacePolicy defaultTableSpace) , fileSuffixString.	names add: name -&gt; defaultTableSpace.	name := self tableSpaceDirectory constructString: (methodsTableSpace := Store.Policies tableSpacePolicy methodsTableSpace) , fileSuffixString.	names add: name -&gt; methodsTableSpace.	name := self tableSpaceDirectory constructString: (userTableSpace := Store.Policies tableSpacePolicy userAndOwnershipTableSpace) , fileSuffixString.	names add: name -&gt; userTableSpace.	^names</body><body package="Store-RepositoryCreation">grantRolePermissionsUsingAccessor: aDatabaseAccessor	(self platformSupportsUsers and: [self developerRoleName notNil])		ifTrue: [aDatabaseAccessor grantStoreDeveloperSpecificPermissionsToUserOrRole: self developerRoleName].</body><body package="Store-RepositoryCreation">grantUserPermissionsUsingAccessor: aDatabaseAccessor	| platform |	platform := aDatabaseAccessor platform.	platform isSQLServerPlatform		ifTrue: [			self tableSpaceNames do: [:eaTableSpaceName|				platform grantStoreTableOwnerPrivilegesOnDB: eaTableSpaceName 				usingAccessor: aDatabaseAccessor]].	platform isOraclePlatform		ifTrue: [ | tableOwnerName managementPolicyAdmin |			 self tableOwner shouldCreate				ifTrue: [					tableOwnerName := self tableOwnerName.					aDatabaseAccessor grantPrivilege: 'CONNECT' toUser: tableOwnerName.					aDatabaseAccessor grantPrivilege: 'RESOURCE' toUser: tableOwnerName.					aDatabaseAccessor grantPrivilege: 'UNLIMITED TABLESPACE' toUser: tableOwnerName].			managementPolicyAdmin := self getRoleFor: #managementPolicyAdmin ifAbsent: [nil].			(managementPolicyAdmin notNil and: [managementPolicyAdmin shouldCreate and: [(tableOwnerName = managementPolicyAdmin name) not]])				ifTrue: [					aDatabaseAccessor grantPrivilege: 'CONNECT' toUser: managementPolicyAdmin name.					aDatabaseAccessor grantPrivilege: 'RESOURCE' toUser: managementPolicyAdmin name]].</body><body package="Store-RepositoryCreation">installPhysicalSpacesUsing: aDatabaseAccessor	| names |	names := self defineTableSpacesUsingFileSuffix: aDatabaseAccessor platform						tableSpaceFileSuffix.	^	[names do: 			[:each |			self				createTableSpaceNamed: each value				onDevice: each key				usingAccessor: aDatabaseAccessor].	true]			on: Error			do: 				[:ex |				ex messageText = aDatabaseAccessor platform installationCanceledMessage					ifTrue: [ex pass]					ifFalse: [nil]]</body><body package="Store-RepositoryCreation">installUserManagementPoliciesIn: aSession	| session admin |	self shouldInstallManagementPolicies		ifFalse: [^self].	session := aSession ifNil: [StoreLoginFactory currentStoreSession].	StoreUserGroup newGroupNamed: StoreUserGroup adminGroupName in: session.	StoreUserGroup newGroupNamed: 'QA' in: session.	admin := self managementPolicyAdminName.	StoreUserGroup newUserNamed: admin inGroupNamed: StoreUserGroup adminGroupName in: session</body></methods><methods><class-id>Store.Glorp.StoreRepositoryBuilder</class-id> <category>serial</category><body package="Store-RepositoryCreation">addXmlElementsTo: anElement	"This is missing the RoleBuilders"	anElement		addNode: (self elementFor: 'database-driver-class-name' with: self databaseConnectionClassName);		addNode: (self elementFor: 'tablespace-directory' with: self tableSpaceDirectory);		addNode: (self elementFor: 'repository-name' with: self repositoryName);		addNode: (self elementFor: 'should-generate-script' with: self shouldGenerateScript);		addNode: (self elementFor: 'should-install-management-policies' with: self shouldGenerateScript);		addNode: (self elementFor: 'should-create-views' with: self shouldCreateViews).</body><body package="Store-RepositoryCreation">asXmlNode	| root |	root := Element		tag: 'store-repository-builder'		attributes: (Array with: (Attribute name: 'version' value: '1.0'))		elements: nil.	self addXmlElementsTo: root.	^root</body><body package="Store-RepositoryCreation">elementFor: tagString with: contentsString	^(XML.Element tag: tagString)		addNode: (XML.Text text: contentsString)</body></methods><methods><class-id>Store.Glorp.StoreRepositoryBuilder</class-id> <category>initialize-release</category><body package="Store-RepositoryCreation">initialize	roleDict := Dictionary new.	shouldInstallManagementPolicies := false.	shouldCreateViews := false.</body></methods><methods><class-id>Store.Glorp.StoreRepositoryBuilder</class-id> <category>testing</category><body package="Store-RepositoryCreation">platformSupportsTableSpaces		| platform |	platform := self databasePlatform.	^platform notNil and: [platform supportsPhysicalSpaces].</body><body package="Store-RepositoryCreation">platformSupportsUsers		| platform |	platform := self databasePlatform.	^platform notNil and: [platform supportsUsers].</body></methods><methods><class-id>Store.Glorp.StoreRepositoryBuilder class</class-id> <category>instance creation</category><body package="Store-RepositoryCreation">createRepositoryScriptUsing: aLogin	"Create the tables for this descriptor system in the given database. This will fail if the tables already exist. Use recreateTables for that."	^(self new)		login: aLogin;		shouldGenerateScript: true;		createRepositoryInstallScript.</body><body package="Store-RepositoryCreation">createRepositoryUsing: aLogin	"Create the tables for this descriptor system in the given database. This will fail if the tables already exist. Use recreateTables for that."	^(self new)		login: aLogin;		createRepository</body><body package="Store-RepositoryCreation">new	^super new initialize.</body></methods><methods><class-id>Store.StoreUserDialog</class-id> <category>accessing</category><body package="Store-RepositoryCreation">databasePlatform	^databasePlatform</body><body package="Store-RepositoryCreation">databasePlatform: aSymbol	databasePlatform := aSymbol</body><body package="Store-RepositoryCreation">defaultLabel	^'Create Store User'</body><body package="Store-RepositoryCreation">label	label isNil		ifTrue: [label := self defaultLabel].	^label</body><body package="Store-RepositoryCreation">label: aString	label := aString</body><body package="Store-RepositoryCreation">nameHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^nameHolder isNil		ifTrue:			[nameHolder := String new asValue]		ifFalse:			[nameHolder]</body><body package="Store-RepositoryCreation">passwordHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^passwordHolder isNil		ifTrue:			[passwordHolder := String new asValue]		ifFalse:			[passwordHolder]</body><body package="Store-RepositoryCreation">shouldCreateHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^shouldCreateHolder isNil		ifTrue:			[shouldCreateHolder := false asValue]		ifFalse:			[shouldCreateHolder]</body></methods><methods><class-id>Store.StoreUserDialog</class-id> <category>actions</category><body package="Store-RepositoryCreation">ok 	self accept value: true.	self requestForWindowClose.</body></methods><methods><class-id>Store.StoreUserDialog</class-id> <category>interface opening</category><body package="Store-RepositoryCreation">openFrom: aSpec	super openFrom: aSpec.	^accept value ifTrue: [self result] ifFalse: [nil]</body><body package="Store-RepositoryCreation">postBuildWith: aBuilder	(self controllerAt: #nameField)		ifNotNil: [:controller| controller continuousAccept: true].			databasePlatform = #DB2Platform		ifTrue: [shouldCreateHolder value: false.			shouldCreateVisibility value: #hidden].</body><body package="Store-RepositoryCreation">result	^Store.Glorp.UserBuilder new 		name: self nameHolder value;		password: self passwordHolder value;		shouldCreate: self shouldCreateHolder value.</body></methods><methods><class-id>Store.StoreUserDialog</class-id> <category>initialize-release</category><body package="Store-RepositoryCreation">initialize	super initialize.	 	nameHolder := String new asValue.	passwordHolder := String new asValue.		shouldCreateHolder := true asValue.	shouldCreateHolder onChangeSend: #changedShouldCreate to: self.		passwordVisibility := #normal asValue.	passwordVisibility onChangeSend: #changedPasswordVisibility to: self.		shouldCreateVisibility := #normal asValue.	shouldCreateVisibility onChangeSend: #changedShouldCreateVisibility to: self.</body></methods><methods><class-id>Store.StoreUserDialog</class-id> <category>validation</category><body package="Store-RepositoryCreation">validateUserInfo	(databasePlatform = #DB2Platform or: [shouldCreateHolder value = false])		ifTrue: [^self nameHolder value notEmpty].			^(self nameHolder value notEmpty		and: [self passwordHolder value notEmpty])</body></methods><methods><class-id>Store.StoreUserDialog</class-id> <category>change messages</category><body package="Store-RepositoryCreation">changedPasswordVisibility	| components desiredState | 	desiredState := passwordVisibility value.	components := #(#passwordLabel #passwordField ).		desiredState = #hidden		ifTrue: [			components do: [:eaComponentName|				(self wrapperAt: eaComponentName) beInvisible]].			desiredState = #normal		ifTrue: [			components do: [:eaComponentName|				(self wrapperAt: eaComponentName) beVisible]].</body><body package="Store-RepositoryCreation">changedShouldCreate	shouldCreateHolder value		ifTrue: [passwordVisibility value: #normal]		ifFalse: [passwordVisibility value: #hidden]</body><body package="Store-RepositoryCreation">changedShouldCreateVisibility	| wrapper1 desiredState | 	wrapper1 := self builder componentAt: #shouldCreateCheckBox.	desiredState := shouldCreateVisibility value.		desiredState = #hidden		ifTrue: [wrapper1 beInvisible.			passwordVisibility value: #hidden].			"desiredState = #normal		ifTrue: [wrapper1 beVisible.			passwordVisibility value: #normal]."</body></methods><methods><class-id>Store.StoreUserDialog class</class-id> <category>instance creation</category><body package="Store-RepositoryCreation">createUserForPlatform: aSymbol	^self new		databasePlatform: aSymbol;		open</body><body package="Store-RepositoryCreation">createUserForPlatform: aSymbol usingTitle: titleString	^self new		databasePlatform: aSymbol;		label: titleString;		open</body></methods><methods><class-id>Store.RepositoryBuilderDataCollectionScript</class-id> <category>actions</category><body package="Store-RepositoryCreation">confirmMessage: messageString withTitle: title	| dialog result spec labels values defaultValue |	labels := UILookPolicy feelPolicy confirmButtonLabels.	values := UILookPolicy feelPolicy confirmAnswerResults.	defaultValue := false.	dialog := SimpleDialog new.	dialog escapeIsCancel: labels size &lt; 2.	result := ValueHolder new.	labels size = 1 ifTrue: [result value: defaultValue].	spec := (dialog class interfaceSpecFor: #emptySpec).	dialog initializeBuilderFor: nil.	dialog builder add: spec window.	dialog builder add: spec component.	dialog initializeWindowFor: nil.		dialog builder window label: title.		dialog setInitialGap.	dialog addTextEditor: messageString asText asValue.	dialog addGap: 8.	dialog addLabels: labels		values: values		default: defaultValue		storeInto: result		takeKeyboard: true		equalize: true.	dialog addGap: 6.	dialog openDialog.	^result value</body><body package="Store-RepositoryCreation">confirmPublicDeveloperRole	| messageString title |	title := 'Are you sure?'.	messageString := 'The developer role for this Store repository is set to PUBLIC. This will allow any user who can login to the database to insert and update records in the Store tables. For multiuser repositories, we recommend creating a role specifically for this purpose. If you intend to have multiple repositories on the same server, you may wish to user different roles for each one.'.	^self confirmMessage: messageString withTitle: title</body><body package="Store-RepositoryCreation">defineRepositoryBuilder	| repositoryName dbDriverClassName |		[repositoryName := self getUniqueDatabaseIdentifier.	repositoryBuilder repositoryName: repositoryName.	dbDriverClassName := self getDatabaseDriverClassName.	dbDriverClassName isNil		ifTrue: [^self userCanceled]		ifFalse: [repositoryBuilder databaseConnectionClassName: dbDriverClassName].	self getTableOwnerUser.	self platformSupportsTableSpaces		ifTrue: 			[| shouldCreateTableSpaces |			shouldCreateTableSpaces := self getShouldCreateTableSpaces.			shouldCreateTableSpaces				ifTrue: 					[| tableSpaceDirectoryString |					tableSpaceDirectoryString := self getTableSpaceDirectory.					tableSpaceDirectoryString isNil						ifTrue: [^self userCanceled]						ifFalse: [repositoryBuilder tableSpaceDirectory: tableSpaceDirectoryString]]].	self platformSupportsUsers		ifTrue: 			[| roleName |			roleName := self getDeveloperRoleName.			repositoryBuilder setRoleFor: #developerRoleName				builder: (RoleBuilder roleName: roleName shouldCreate: true)].	self getShouldInstallManagementPolicies		ifTrue: [repositoryBuilder shouldInstallManagementPolicies: true.			self getManagementPolicyAdminUser].	repositoryBuilder shouldCreateViews: self getShouldCreateViews]			on: Error			do: 				[:ex |					ex messageText = self actionCanceledMessage						ifTrue: [							Transcript cr;								nextPutAll: ex messageText.							ex exit: nil]						ifFalse: [ex pass]].	^repositoryBuilder</body><body package="Store-RepositoryCreation">getDatabaseDriverClassName	| platforms |	platforms := Store.ConnectionProfile concreteDatabaseDriverClassNames.	^SimpleDialog new		choose: 'Select a Database Platform'		fromList: (platforms collect: [:ea| ea asString]) values: platforms		buttons: #() values: #()		lines: platforms size		cancel: [nil].</body><body package="Store-RepositoryCreation">getDeveloperRoleName	| done identifier |	done := false.	[done]		whileFalse: [			identifier := Dialog				request: #EnterDeveloperRoleNameForThisStoreRepository &lt;&lt; #store &gt;&gt; 'Enter the name of the role for publishing permissions for this Store repository:'				initialAnswer: 'public'.			done := identifier asLowercase = 'public'				ifTrue: [self confirmPublicDeveloperRole]				ifFalse: [true]].	^identifier</body><body package="Store-RepositoryCreation">getManagementPolicyAdminUser	| adminUserBuilder |	adminUserBuilder := StoreUserDialog				createUserForPlatform: repositoryBuilder databasePlatform class name				usingTitle: 'Store Mgmt Policy Administrator'.	adminUserBuilder isNil		ifTrue: [self userCanceled]		ifFalse: 			[repositoryBuilder setUserFor: #managementPolicyAdmin				builder: adminUserBuilder]</body><body package="Store-RepositoryCreation">getShouldCreateTableSpaces	| answer |	answer := SimpleDialog new		choose:#CreateTablespacesQ &lt;&lt; #store				&gt;&gt; 'Create tablespaces? (Answer no only if they have already been created)'		labels: (Array with: 'Yes' with: 'No' with: 'Cancel')		values: #(#yes #no #cancel)		default: #yes		for: Dialog defaultParentWindow.	answer = #cancel		ifTrue: [self userCanceled]		ifFalse: [^answer = #yes]</body><body package="Store-RepositoryCreation">getShouldCreateViews	^Dialog confirm: (#VW76CanConnect &lt;&lt; #store &gt;&gt; 'Should VisuaWorks 7.6 and earlier images be able to connect to this database?')</body><body package="Store-RepositoryCreation">getShouldInstallManagementPolicies	^self platformSupportsUsers		ifTrue: [Dialog confirm: #InstallManagementPolicies &lt;&lt; #store &gt;&gt; 'Install management policies?']		ifFalse: [false]</body><body package="Store-RepositoryCreation">getTableOwnerUser	| tableOwnerBuilder |	self platformSupportsUsers		ifTrue: 			[tableOwnerBuilder := StoreUserDialog						createUserForPlatform: repositoryBuilder databasePlatform class name						usingTitle: 'Store Table Owner User'.			tableOwnerBuilder isNil				ifTrue: [self userCanceled]				ifFalse: 					[repositoryBuilder setUserFor: #tableOwner builder: tableOwnerBuilder]]</body><body package="Store-RepositoryCreation">getTableSpaceDirectory	| path baseFilename |	path := Dialog request: #PleaseEnterTableSpaceDirectory &lt;&lt; #store						&gt;&gt; 'Please, enter directory for the table spaces.'				initialAnswer: ''.	path isEmpty ifTrue: [self userCanceled].	baseFilename := (path includes: Filename getSeparator)				ifTrue: [path asFilename]				ifFalse: 					[(path includes: UnixFilename getSeparator)						ifTrue: [UnixFilename named: path]						ifFalse: [PCFilename named: path]].	^baseFilename</body><body package="Store-RepositoryCreation">getUniqueDatabaseIdentifier	| identifier |	[(identifier := Dialog		request: #EnterAUniqueNameForThisStoreRepository &lt;&lt; #store &gt;&gt; 'Enter a unique name for this Store repository:'		initialAnswer: '') notEmpty] whileFalse.	^identifier</body><body package="Store-RepositoryCreation">userCanceled	Error raiseSignal: self actionCanceledMessage</body></methods><methods><class-id>Store.RepositoryBuilderDataCollectionScript</class-id> <category>accessing</category><body package="Store-RepositoryCreation">repositoryBuilder	^repositoryBuilder</body><body package="Store-RepositoryCreation">repositoryBuilder: anObject	repositoryBuilder := anObject</body></methods><methods><class-id>Store.RepositoryBuilderDataCollectionScript</class-id> <category>initialize-release</category><body package="Store-RepositoryCreation">initialize		repositoryBuilder := StoreRepositoryBuilder new.</body></methods><methods><class-id>Store.RepositoryBuilderDataCollectionScript</class-id> <category>messages</category><body package="Store-RepositoryCreation">actionCanceledMessage	^'Data collection for schema creation canceled'</body></methods><methods><class-id>Store.RepositoryBuilderDataCollectionScript</class-id> <category>testing</category><body package="Store-RepositoryCreation">platformSupportsTableSpaces		^repositoryBuilder platformSupportsTableSpaces.</body><body package="Store-RepositoryCreation">platformSupportsUsers	^self repositoryBuilder platformSupportsUsers</body></methods><methods><class-id>Store.RepositoryBuilderDataCollectionScript class</class-id> <category>instance creation</category><body package="Store-RepositoryCreation">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Store.Glorp.UserBuilder</class-id> <category>accessing</category><body package="Store-RepositoryCreation">password	^password</body><body package="Store-RepositoryCreation">password: anObject	password := anObject</body><body package="Store-RepositoryCreation">passwordOrDefault	^password notNil		ifTrue: [password]		ifFalse: [name]</body></methods><methods><class-id>Store.Glorp.UserBuilder</class-id> <category>testing</category><body package="Store-RepositoryCreation">isForUser	^true</body></methods><methods><class-id>Store.Glorp.UserBuilder</class-id> <category>actions</category><body package="Store-RepositoryCreation">createUsingAccessor: aDatabaseAccessor	^aDatabaseAccessor createUser: self name password: self passwordOrDefault</body></methods><methods><class-id>Glorp.SQLServerPlatform</class-id> <category>database-specific</category><body package="Store-RepositoryCreation">createTableSpaceNamed: tableSpaceName onDevice: aFilename size: sizeString in: aDatabaseAccessor	self createDatabase: tableSpaceName onDevice: aFilename size: sizeString in: aDatabaseAccessor.	self endBatchForScriptIn: aDatabaseAccessor</body></methods><methods><class-id>Glorp.OraclePlatform</class-id> <category>database-specific</category><body package="Store-RepositoryCreation">createTableSpaceNamed: tableSpaceName onDevice: aFilename size: sizeString in: aDatabaseAccessor	self createDatabase: tableSpaceName onDevice: aFilename size: sizeString in: aDatabaseAccessor.	self setAutoExtentFor: aFilename in: aDatabaseAccessor</body></methods><methods><class-id>Glorp.OraclePlatform</class-id> <category>services - users and roles</category><body package="Store-RepositoryCreation">sqlStatementToGrantPrivilege: privilegeString toUser: loginName	| writeStream |	writeStream := WriteStream on: String new.	writeStream nextPutAll: 'GRANT ';		nextPutAll: privilegeString;		nextPutAll: ' TO ';		nextPutAll: loginName.	^writeStream contents</body></methods><methods><class-id>Glorp.DatabaseAccessor</class-id> <category>executing</category><body package="Store-RepositoryCreation">grantPrivilege: privilegeString toUser: loginName	| result |	result := self executeInDDLOperation: 					[self						executeSQLStringsNoResult: (self platform sqlStatementToGrantPrivilege: privilegeString								toUser: loginName).					true]				ifError: 					[:ex |					| dbmsError |					dbmsError := ex parameter first.					(self platform isUserDoesNotExistError: dbmsError)						ifTrue: 							["User doesn't exist"							ex return: false]						ifFalse: [ex pass]].	^result</body></methods><methods><class-id>Store.DBAccess</class-id> <category>actions</category><body package="Store-RepositoryCreation">createEnhancedInstallScript	| dataCollectionScript repoBuilder repoInstallScript fileName writeStream |	dataCollectionScript := RepositoryBuilderDataCollectionScript new.	repoBuilder := dataCollectionScript defineRepositoryBuilder.	repoBuilder isNil ifTrue: [^self].	repoInstallScript := repoBuilder createRepositoryInstallScript.	fileName := Dialog 				requestNewFileName: #SaveStoreInstallScriptToFileColon &lt;&lt; #store						&gt;&gt; 'Save the repository install script to file:'				default: 'installScript.sql'.	fileName notEmpty ifTrue: [		writeStream := (Filename named: fileName) writeStream.	[writeStream nextPutAll: repoInstallScript.	writeStream flush]		ensure: [writeStream close]].	^repoInstallScript.</body></methods><methods><class-id>Store.StoreUserDialog class</class-id> <category>interface specs</category><body package="Store-RepositoryCreation">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#properties: #(#{UI.PropertyListDictionary} #sizeType #specifiedSize #positionType #positionSystemDefault #labelFromApplication true #openType #advanced ) 			#label: #label 			#min: #(#{Core.Point} 20 20 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 643 450 1063 590 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutSizedOrigin} 92 0 16 0 230 24 ) 					#name: #nameField 					#model: #nameHolder ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutSizedOrigin} 92 0 56 0 230 24 ) 					#name: #passwordField 					#model: #passwordHolder 					#type: #string ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutSizedOrigin} 91 0 96 0 80 30 ) 					#name: #okButton 					#model: #ok 					#label: 'OK' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutFrame} 16 0 20 0 85 0 38 0 ) 					#name: #nameLabel 					#label: 'User Name:' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 244 0 96 0 324 0 126 0 ) 					#name: #cancelButton 					#model: #cancel 					#label: 'Cancel' ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Graphics.LayoutSizedOrigin} 333 0 20 0 87 12 ) 					#name: #shouldCreateCheckBox 					#model: #shouldCreateHolder 					#label: 'New User' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutSizedOrigin} 25 0 64 0 61 18 ) 					#name: #passwordLabel 					#label: 'Password:' ) ) ) )</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>SQLServerPlatform</name><environment>Glorp</environment><super>Glorp.DatabasePlatform</super><private>false</private><indexed-type>none</indexed-type><inst-vars>supportsGroupWritingValues supportsUnboundRowCount canRecurse </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><class><name>OraclePlatform</name><environment>Glorp</environment><super>Glorp.DatabasePlatform</super><private>false</private><indexed-type>none</indexed-type><inst-vars>supportsGroupWritingValues canRecurse </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><class><name>DBAccess</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>environmentString connection sequenceConnection connectedProfileHolder recentProfile tablePrefix debug log logFile databaseIdentifier installScript debugger cachedNames highestPrimaryKeyChecked subscriptionRegistry currentDatabaseAccessor storeDescriptorSystems </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.Glorp.*			</imports><category>Store-Repository Access</category><attributes><package>Store-Repository Access</package></attributes></class><class><name>DatabaseAccessor</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>connection currentLogin logging logger logOnly reusePreparedStatements deniedCommands mutex dependents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDatabase</category><attributes><package>GlorpDatabase</package></attributes></class><class><name>SimpleDialog</name><environment>UI</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>close accept cancel preBuildBlock postBuildBlock postOpenBlock escapeIsCancel parentView useParentColors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Dialogs</category><attributes><package>Interface-Dialogs</package></attributes></class></st-source>