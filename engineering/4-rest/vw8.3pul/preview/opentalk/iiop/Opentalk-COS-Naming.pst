<?xml version="1.0"?><st-source><!-- Name: Opentalk-COS-NamingNotice: Copyright 1999-2013 Cincom Systems, Inc.  All rights reserved.Comment: This package contains IDL definitions allowing to peruse a remote NamingService.DbIdentifier: bear73DbTrace: 400732DbUsername: nrossDbVersion: 7.10 - 1DevelopmentPrerequisites: #(#(#any 'Opentalk-IDL-Repository' ''))PackageName: Opentalk-COS-NamingParcel: #('Opentalk-COS-Naming')PrerequisiteParcels: #(#('Opentalk-IDL-Repository' ''))PrintStringCache: (7.10 - 1,nross)Version: 7.10 - 1Date: 11:27:09 AM April 12, 2013 --><time-stamp>From VisualWorksÂ®, Pre-Release 7.10 (apr13.2) of April 12, 2013 on April 12, 2013 at 11:27:09 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>DSTBindingIterator</name><environment>Opentalk</environment><super>Core.ReadStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COS-Naming</category><attributes><package>Opentalk-COS-Naming</package></attributes></class><comment><class-id>Opentalk.DSTBindingIterator</class-id><body>Along with DSTName, DSTNameComponent, and DSTNameContext, the DSTBindingIterator class supports the Naming Service that is an extension to the CORBA 1.1 specifications. This naming service associates an object with a name to provide unique identification in a distributed environment.Specifically, instances of DSTBindingIterator allow a client to iterate through the set of bindings contained in a naming context (using inherited methods nextN: and nextOne).For a complete description of the Naming Service, see the class comment for DSTNameContext.</body></comment><class><name>DSTNameContext</name><environment>Opentalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bindings nContexts </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COS-Naming</category><attributes><package>Opentalk-COS-Naming</package></attributes></class><comment><class-id>Opentalk.DSTNameContext</class-id><body>Along with classes DSTName and DSTNameComponent, DSTNameContext supports the Naming Service that is an extension to the CORBA 1.1 specifications. This naming service associates an object with a name to provide unique identification in a distributed environment.  An instance of class DSTNameContext is an object that contains a set of name bindings in which each name is unique.  This object is a non leaf node in a naming graph (as described below).Instance Variables:	bindings		&lt;Dictionary&gt; of name-to-object associations	nContexts	&lt;Set&gt; of naming contexts which have been bound using the method 						contextBindContext.ABOUT  THE  NAMING  SERVICEA name-to-object association is called a NAME BINDING. A NAMING CONTEXT is an object that contains a set of name bindings in which each name is unique. Different names can be bound to an object in the same or different contexts at the same time.A name binding is always defined relative to a naming context.  Methods in protocol NamingContextBind handle binding, rebinding and unbinding.  Unbinding removes a name binding from a context. Rebinding removes a name from its current context and binds it to a new context.To RESOLVE A NAME is to determine the object associated with the name in a given context.  Once an object is bound, it can be found via the methods in protocol NamingContextResolve. NOTE: Naming contexts that are bound using contextBindContext:to: participate in name resolution when compound names are passed to resolve, while naming contexts that are bound using contextBind:to: do not.STRUCTURES OF NAMING CONTEXTSBecause a context is like any other object, it can also be bound to a name in some naming context. By binding contexts in other contexts we can create a NAMING GRAPH -- a directed graph with nodes and labeled edges where the nodes are contexts. We can use more complex names for referring to an object in a naming graph. Given a context in some naming graph, we can use a sequence of names to refer to an object; the sequence of names defines a path in the naming graph to navigate the resolution process. Such a sequence of names is called a compound name.  (A name with a single component is called a simple name.)The  methods that support creating new contexts are newContext and bindNewContext.  The destroyContext method is used to destroy a naming context. The listContext: method iterates through a context's bindings.</body></comment><class><name>DSTNameComponent</name><environment>Opentalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>identifier kind </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COS-Naming</category><attributes><package>Opentalk-COS-Naming</package></attributes></class><comment><class-id>Opentalk.DSTNameComponent</class-id><body>Instances of this class represent an ordered sequence of compound names (DSTNameComponents) as specified by Hewlett Packard Company's and SunSoft Inc.'s  Naming Service extension to CORBA 1.1.  These instances function as Names Libraries that hide the underlying representation of names from clients. This allows name representations to evolve without affecting existing clients. For a complete description of the Naming Service, see the class comment for SunNameContext.Instance variables:	identifier	&lt;String&gt; holding the identifier attribute	kind			&lt;String&gt; holding the kind attributeTo avoid issues of differing name syntax, the naming service always deals with names in their structural form, which consists of two attributes: the IDENTIFIER ATTRIBUTE and the KIND ATTRIBUTE. Both the identifier attribute and the kind attribute are represented as IDL strings.  The kind attribute adds descriptive power to names in a syntax independent way. In the absence of such a feature, users normally resort to syntactic convention. For example, in Unix, suffixes such as ".c", ".o" etc. are used. Applications like the C compiler depend on such syntactic convention to make name transformations such as from foo.c to foo.o. Unfortunately, such syntactic convention is not explicit; software that does not depend on the syntactic conventions for names does not have to be changed to adopt to new conventions. Thus, name components have an attribute called kind to address the needs of such applications. As examples, the value of the kind attribute might be "c_source", "object_code", "executable", "postscript" or "". The naming service does not interpret, assign or manage these values in any way. Higher levels of software may make policies about the use and management of these values.</body></comment><class><name>DSTName</name><environment>Opentalk</environment><super>Core.OrderedCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COS-Naming</category><attributes><package>Opentalk-COS-Naming</package></attributes></class><comment><class-id>Opentalk.DSTName</class-id><body>Instances of this class represent an ordered sequence of compound names (DSTNameComponents) as specified by Hewlett Packard Company's and SunSoft Inc.'s Naming Services extension to CORBA 1.1. For a complete description of the Naming Service, see the class comment for DSTNameContext.A name is an ordered sequence of components. An instance of DSTName with a single component is called a simple name.  A name with multiple components is called a compound name. Each component except the last is used to name a context; the last component denotes the bound object. In the following example,  both component1 and component2 are used to name a context, while the last component refers to the bound object.		&lt;component1 ; component2 ; component3&gt;</body></comment><methods><class-id>Opentalk.DSTBindingIterator</class-id> <category>BindingIterator</category><body package="Opentalk-COS-Naming">nextN: n bindingList: aBindingList 	"return the next element of the receiver"	"Iterators do not raise an exception if they go out of range. Therefore 	we return a result that consists of a nil object ID and an 'invalid' 	number."	self atEnd		ifTrue: 			[aBindingList value: #().			^false]		ifFalse: 			[aBindingList value: (self nextAvailable: n).			^true]</body><body package="Opentalk-COS-Naming">nextOne: aBinding 	"return the next element of the receiver"	"Iterators do not raise an exception if they go out of range. Therefore 	we return a result that consists of a nil object ID and an 'invalid' 	number."	self atEnd		ifTrue: 			[aBinding value: self class dummyBinding.			^false]		ifFalse: 			[aBinding value: self next.			^true]</body></methods><methods><class-id>Opentalk.DSTBindingIterator</class-id> <category>repository</category><body package="Opentalk-COS-Naming">CORBAName	"return the name of my CORBA interface in the repository"	^#'::CosNaming::BindingIterator'</body></methods><methods><class-id>Opentalk.DSTBindingIterator class</class-id> <category>constants</category><body package="Opentalk-COS-Naming">dummyBinding	^Dictionary 			with: #bindingName -&gt; 'nil' asDSTName			with: #bindingType -&gt; (CORBAConstants at: #'::CosNaming::BindingType::nobject')</body></methods><methods><class-id>Opentalk.DSTNameContext</class-id> <category>exceptions</category><body package="Opentalk-COS-Naming">alreadyBoundError	"raises AlreadyBound exception specified in IDL interface"	^(CORBAConstants at: #'::CosNaming::NamingContext::AlreadyBound')		raiseWith: Dictionary new errorString: ' name is already bound'</body><body package="Opentalk-COS-Naming">cannotProceedError: aNamingContext nameComponent: aNameComponent 	"raises CannotProceed exception specified in IDL interface"	^(CORBAConstants at: #'::CosNaming::NamingContext::CannotProceed')		raiseWith: (Dictionary with: #cxt -&gt; aNamingContext with: #restOfName -&gt; aNameComponent)		errorString: ' unable to proceed'</body><body package="Opentalk-COS-Naming">invalidNameError	"raises InvalidName exception specified in IDL interface"	^(CORBAConstants at: #'::CosNaming::NamingContext::InvalidName')		raiseWith: Dictionary new errorString: ' invalid name'</body><body package="Opentalk-COS-Naming">notEmptyError	"raises NotEmpty exception specified in IDL interface"	^(CORBAConstants at: #'::CosNaming::NamingContext::NotEmpty')		raiseWith: Dictionary new errorString: ' naming context contains bindings'</body><body package="Opentalk-COS-Naming">notFoundError: aReason restOfName: aName 	"raises NotFound exception specified in IDL interface"	^(CORBAConstants at: #'::CosNaming::NamingContext::NotFound')		raiseWith: (Dictionary with: #why -&gt; aReason with: #restOfName -&gt; aName)		errorString: ' name not found'</body></methods><methods><class-id>Opentalk.DSTNameContext</class-id> <category>repository</category><body package="Opentalk-COS-Naming">CORBAName	"return the name of my CORBA interface in the repository"	^#'::CosNaming::NamingContext'</body></methods><methods><class-id>Opentalk.DSTNameContext</class-id> <category>NamingContextResolve</category><body package="Opentalk-COS-Naming">contextResolve: aName 	"return the object which is bound to the name in the context of the 	receiver"	| comp rest cxt |	aName isEmpty		ifTrue: [^self invalidNameError]		ifFalse: 			[comp := aName  first.			rest := aName rest: 1.			cxt := bindings at: comp ifAbsent: [^self notFoundError: #'missing_node' restOfName: aName].			rest isEmpty				ifTrue: [^cxt]				ifFalse: [(cxt isKindOf: DSTNameContext)						ifTrue: [(nContexts includes: comp)								ifTrue: [^cxt contextResolve: rest]								ifFalse: [^self notFoundError: #'not_context' restOfName: aName]]						ifFalse: [(cxt isKindOf: DSTName)								ifTrue: [^(self contextResolve: cxt)										contextResolve: rest]								ifFalse: [^self notFoundError: #'not_context' restOfName: aName]]]]</body><body package="Opentalk-COS-Naming">listContext: anInt 	"return a list of binding that is the number of anInt. If there are not 	that many bindings then return as many as there are. If there are 	more bindings then return a binding iterator with the remaining 	bindings."	| res |	res := OrderedCollection new.	bindings associationsDo: [:assoc | res add: (self bInfo: assoc)].	res := res asArray.	res size &gt; anInt &amp; (anInt &gt;= 0)		ifTrue: [^(Dictionary				with: #bl -&gt; (res copyFrom: 1 to: anInt)				with: #bi -&gt; (DSTBindingIterator on: (res copyFrom: anInt + 1 to: res size)))]		ifFalse: [^(Dictionary				with: #bl -&gt; res				with: #bi -&gt; nil)]</body><body package="Opentalk-COS-Naming">listContext: anInt bindingList: aList bindingIterator: anIterator 	"return a list of binding that is the number of anInt. If there are not 	that many bindings then return as many as there are. If there are 	more bindings then return a binding iterator with the remaining 	bindings."	| res |	res := OrderedCollection new.	bindings associationsDo: [:assoc | res add: (self bInfo: assoc)].	res := res asArray.	res size &gt; anInt &amp; (anInt &gt;= 0)		ifTrue: 			[aList value: (res copyFrom: 1 to: anInt).			anIterator value: (DSTBindingIterator on: (res copyFrom: anInt + 1 to: res size))]		ifFalse: 			[aList value: res.			anIterator value: nil]</body></methods><methods><class-id>Opentalk.DSTNameContext</class-id> <category>NamingContextBind</category><body package="Opentalk-COS-Naming">bindNewContext: aName 	"create a new name context and bind it to the name in the receiver"	| nc |	nc := self newContext.	self contextBindContext: aName to: nc.	^nc</body><body package="Opentalk-COS-Naming">contextBind: aName to: anObject 	"Bind the name to the object in the context of the receiver.	Altered in 5i to handle 'kind' correctly."	| comp |	aName isEmpty		ifTrue: [^self invalidNameError]		ifFalse: 			[comp := aName last.			aName size &gt; 1				ifTrue: [^(self contextResolve: (aName base: aName size - 1))						contextBind: (DSTName onComponent: comp)						to: anObject]				ifFalse: [^self						basicBind: comp						to: anObject						rebind: false]]</body><body package="Opentalk-COS-Naming">contextBindContext: aName to: aNameContext 	"bind the name to the naming context in the context of the receiver"	| comp |	aName isEmpty		ifTrue: [^self invalidNameError]		ifFalse: 			[comp := aName last.			aName size &gt; 1				ifTrue: [^(self contextResolve: (aName base: aName size - 1))						contextBindContext: (DSTName onString: comp identifier)						to: aNameContext]				ifFalse: [^self						basicBindContext: comp						to: aNameContext						rebind: false]]</body><body package="Opentalk-COS-Naming">contextReBind: aName to: anObject	"bind the name to the object in the context of the receiver"	| comp |	aName isEmpty		ifTrue: [^self invalidNameError]		ifFalse: 			[comp := aName last.			aName size &gt; 1				ifTrue: [^(self contextResolve: (aName base: aName size - 1))						contextReBind: (DSTName onString: comp identifier)						to: anObject]				ifFalse: [^self						basicBind: comp						to: anObject						rebind: true]]</body><body package="Opentalk-COS-Naming">contextReBindContext: aName to: aNameContext 	"bind the name to the naming context in the context of the receiver"	| comp |	aName isEmpty		ifTrue: [^self invalidNameError]		ifFalse: 			[comp := aName last.			aName size &gt; 1				ifTrue: [^(self contextResolve: (aName base: aName size - 1))						contextReBindContext: (DSTName onString: comp identifier)						to: aNameContext]				ifFalse: [^self						basicBindContext: comp						to: aNameContext						rebind: true]]</body><body package="Opentalk-COS-Naming">contextUnBind: aName 	"unbind the name in the context of the receiver"	| comp |	aName isEmpty		ifTrue: [^self invalidNameError]		ifFalse: 			[comp := aName last.			aName size &gt; 1				ifTrue: [^(self contextResolve: (aName base: aName size - 1))						contextUnBind: (DSTName onString: comp identifier)]				ifFalse: [bindings removeKey: comp ifAbsent: [^self							notFoundError: #missing_node							restOfName: aName].						nContexts remove: comp ifAbsent: []]]</body><body package="Opentalk-COS-Naming">destroyContext	"delete all bindings associated with the receiver"	(bindings isNil or: [bindings isEmpty])		ifTrue: [super destroy]		ifFalse: [^self notEmptyError]</body><body package="Opentalk-COS-Naming">newContext	"return a new name context"	| nc |	nc := self class new initialize.	^nc</body></methods><methods><class-id>Opentalk.DSTNameContext</class-id> <category>private</category><body package="Opentalk-COS-Naming">bInfo: assoc 	"return a binding info record for the association"	| key typ |	key := assoc key.	(nContexts includes: key)		ifTrue: [typ := #ncontext]		ifFalse: [typ := #nobject].	^Dictionary with: #bindingName -&gt; (DSTName onComponent: key) with: #bindingType -&gt; typ</body><body package="Opentalk-COS-Naming">basicBind: aNameComponent to: anObject rebind: reBind	"bind the name to the object in the context of the receiver where the 	name is atomic"	(aNameComponent isKindOf: DSTNameComponent)		ifFalse: [^self invalidNameError].	(bindings includesKey: aNameComponent) &amp; reBind not		ifTrue: [^self alreadyBoundError]		ifFalse: [bindings at: aNameComponent put: anObject]</body><body package="Opentalk-COS-Naming">basicBindContext: aNameComponent to: aNamingContext rebind: reBind	"bind the name to the naming context in the context of the receiver where the 	name is atomic"	(aNameComponent isKindOf: DSTNameComponent)		ifFalse: [^self invalidNameError].	(aNamingContext isKindOf: DSTNameContext)		ifFalse: [^self cannotProceedError: aNamingContext							nameComponent: aNameComponent].						(bindings includesKey: aNameComponent) &amp; reBind not		ifTrue: [^self alreadyBoundError]		ifFalse: [bindings at: aNameComponent put: aNamingContext.				nContexts add: aNameComponent]</body></methods><methods><class-id>Opentalk.DSTNameContext</class-id> <category>initialization</category><body package="Opentalk-COS-Naming">initialize	"initialize the receiver"	bindings := Dictionary new: 500.	nContexts := Set new.</body></methods><methods><class-id>Opentalk.DSTNameContext class</class-id> <category>instance creation</category><body package="Opentalk-COS-Naming">new	^super new initialize</body></methods><methods><class-id>Opentalk.DSTNameContext class</class-id> <category>utilities</category><body package="Opentalk-COS-Naming">findOrCreateContext: aContextName startFrom: root 	"Like mkdir -p. If parent does not exist, create parent first."	| cxt |	aContextName inject: root		into: 			[:parent :rest | 			| nodeName |			nodeName := DSTName onComponent: rest.			[cxt := parent contextResolve: nodeName]				on: DSTNameContext notFoundSignal do: [:ex | cxt := parent bindNewContext: nodeName]].	^cxt</body><body package="Opentalk-COS-Naming">printNameTreeOn: aStream startFrom: aContext 	"ls -lR format"	"self 		printNameTreeOn: String new writeStream 		startFrom: ORBObject namingService"	| iter list |	list := nil asValue.	iter := nil asValue.	aContext listContext: 100 bindingList: list bindingIterator: iter.	aStream nextPutAll: '/'; cr.	list value do: [:binding |		| comp type obj |		comp := (binding value at: #bindingName) first.		type := (binding value at: #bindingType) printString.		obj := aContext contextResolve: (DSTName onComponent: comp).		aStream tab; nextPutAll: '{', comp id, ':', (comp kind notNil ifTrue:[comp kind]), ' , ', type, ', '.		aStream nextPutAll: 			(obj isLocal				ifTrue:['a local ', obj class asString]				ifFalse:[obj printString]).		aStream nextPut: $}; cr].	aStream cr.	list value do: [:binding |		| ctx namebind type |		namebind := binding value at: #bindingName.		type := binding value at: #bindingType.		ctx := aContext contextResolve: namebind.		type == #ncontext ifTrue: [			aStream nextPutAll: namebind first id, ':', (namebind first kind notNil ifTrue:[namebind first kind]).			self printNameTreeOn: aStream startFrom: ctx]].	^aStream contents</body></methods><methods><class-id>Opentalk.DSTNameContext class</class-id> <category>errror handling</category><body package="Opentalk-COS-Naming">alreadyBoundSignal	"Answer the signal used for AlreadyBound errors"	^CORBAConstants at: #'::CosNaming::NamingContext::AlreadyBound'</body><body package="Opentalk-COS-Naming">cannotProceedSignal	"Answer the signal used for Cannot Proceed errors"	^CORBAConstants at: #'::CosNaming::NamingContext::CannotProceed'</body><body package="Opentalk-COS-Naming">invalidNameSignal	"Answer the signal used for InvalidName errors"	^CORBAConstants at: #'::CosNaming::NamingContext::InvalidName'</body><body package="Opentalk-COS-Naming">notEmptySignal	"Answer the signal used for raises NotEmpty errors"	^CORBAConstants at: #'::CosNaming::NamingContext::NotEmpty'</body><body package="Opentalk-COS-Naming">notFoundSignal	"Answer the signal used for NotFound errors"	^CORBAConstants at: #'::CosNaming::NamingContext::NotFound'</body></methods><methods><class-id>Opentalk.DSTNameComponent</class-id> <category>Name Component</category><body package="Opentalk-COS-Naming">id	"return the value of the identifier"	^self identifier</body><body package="Opentalk-COS-Naming">id: anIdentifier 	"set the value of the identifier"	self identifier: anIdentifier</body><body package="Opentalk-COS-Naming">kind	"return the value of the kind"	^kind</body><body package="Opentalk-COS-Naming">kind: aKind	"set the value of the kind"	kind := aKind</body></methods><methods><class-id>Opentalk.DSTNameComponent</class-id> <category>repository</category><body package="Opentalk-COS-Naming">corbaTypeIn: aRepository	"return an instance of the DSTmetaObject subclass which can marshall an 	instance of the receiver."	^aRepository lookupMetaId: #'::CosNaming::NameComponent'</body></methods><methods><class-id>Opentalk.DSTNameComponent</class-id> <category>accessing</category><body package="Opentalk-COS-Naming">identifier	"return the value of the identifier"	^identifier</body><body package="Opentalk-COS-Naming">identifier: anIdentifier 	"set the value of the identifier"	identifier := anIdentifier</body></methods><methods><class-id>Opentalk.DSTNameComponent</class-id> <category>printing</category><body package="Opentalk-COS-Naming">printOn: aStream	identifier isNil ifTrue: [^aStream nextPutAll: '''?'''].	aStream nextPut: $' ; nextPutAll: identifier; nextPut: $: .	kind isNil ifTrue: [^aStream nextPut: $' ].	aStream nextPutAll: kind; nextPut: $' .</body></methods><methods><class-id>Opentalk.DSTNameComponent</class-id> <category>comparing</category><body package="Opentalk-COS-Naming">= anObject 	"Answer whether the receiver and the argument represent the same object.	If = is redefined in any subclass, consider also redefining the message hash."	^( anObject class == self class )		and: [ identifier = anObject identifier &amp; ( kind = anObject kind ) ]</body><body package="Opentalk-COS-Naming">hash	"Answer with a SmallInteger unique to the receiver."	^self printString hash</body></methods><methods><class-id>Opentalk.DSTNameComponent class</class-id> <category>instance creation</category><body package="Opentalk-COS-Naming">id: aString kind: bString	^self new id: aString; kind: bString; yourself</body><body package="Opentalk-COS-Naming">on: aString 	^self new identifier: aString; kind: ''; yourself</body></methods><methods><class-id>Opentalk.DSTName</class-id> <category>conversion</category><body package="Opentalk-COS-Naming">asDSTName	"Return a DSTName on the receiver"	^self</body></methods><methods><class-id>Opentalk.DSTName</class-id> <category>repository</category><body package="Opentalk-COS-Naming">corbaTypeIn: aRepository	"return an instance of the DSTmetaObject subclass which can marshall an 	instance of the receiver."	^aRepository lookupMetaId: #'::CosNaming::Name'</body></methods><methods><class-id>Opentalk.DSTName</class-id> <category>Name</category><body package="Opentalk-COS-Naming">allButLast	^self copyFrom: 1 to: self size - 1</body><body package="Opentalk-COS-Naming">base: number 	"return the first number components of the receiver"	^self copyFrom: 1 to: number</body><body package="Opentalk-COS-Naming">rest: number 	"return the components after number"	^self copyFrom: number + 1 to: self size.</body></methods><methods><class-id>Opentalk.DSTName class</class-id> <category>instance creation</category><body package="Opentalk-COS-Naming">on: aNCArray 	"create a new name given the name components"	| obj |	obj := self new.	1 to: aNCArray size do: [:elem | (aNCArray at: elem) class == DSTNameComponent			ifTrue: [obj add: (aNCArray at: elem)]			ifFalse: [obj add: (DSTNameComponent on: (aNCArray at: elem))]].	^obj</body><body package="Opentalk-COS-Naming">onComponent: aNameComponent 	"create a new name given the name components"	^(self new) add: aNameComponent; yourself</body><body package="Opentalk-COS-Naming">onString: aNameString 	"return a new name on the given name string"	^self with: (DSTNameComponent on: aNameString)</body><body package="Opentalk-COS-Naming">onStrings: aNameArray	| obj |	obj := self new.	aNameArray do: [:st | obj add: (DSTNameComponent on: st)].	^obj</body></methods><methods><class-id>Core.String</class-id> <category>Opentalk</category><body package="Opentalk-COS-Naming">asDSTName	"Return a DSTName on the receiver"	^Opentalk.DSTName onString: self</body></methods><methods><class-id>Opentalk.DSTRepository</class-id> <category>COS</category><body package="Opentalk-COS-Naming">// CosNaming//// This module defines the CORBA COS interfaces for Naming.// module CosNaming  {	#pragma prefix "omg.org/CosNaming"	// An internationalized string, for now	typedef string Istring;	#pragma  class NameComponent DSTNameComponent	struct  NameComponent {Istring id; Istring kind; };	#pragma class Name DSTName	typedef sequence&lt;NameComponent&gt; Name;	enum BindingType {nobject, ncontext};	struct  Binding {Name binding_name; BindingType binding_type; };	typedef sequence&lt;Binding&gt; BindingList;	// 	// This interface defines the operations associated with accessing	// name contexts. A name context associates objects with names	// in a unique mapping. Once an object is bound, it can be	// retrieved by via one of the resolution operations. This interface	// may be used by objects wishing to support uniform name	// resolution but which have their own mechanisms to perform	// the binding operations.	// 	interface NamingContext {		enum NotFoundReason {missing_node, not_context, not_object};		exception NotFound {NotFoundReason why; Name rest_of_name; };		exception CannotProceed {NamingContext cxt; Name rest_of_name; };		exception InvalidName {};		exception AlreadyBound {};		exception NotEmpty {};		#pragma  selector bind contextBind:to:		// This operation binds a name to an object		void bind (in Name n, in Object obj)					raises (NotFound,							CannotProceed,							InvalidName,							AlreadyBound);		#pragma  selector rebind contextReBind:to:		// This operation associates a name with a different bound		// entity		void rebind (in Name n, in Object obj)					raises (NotFound, CannotProceed, InvalidName);		#pragma  selector bind_context contextBindContext:to:		// This operation binds a name to a naming context		void bind_context (in Name n, in NamingContext nc)					raises (NotFound,							CannotProceed,							InvalidName,							AlreadyBound);		#pragma  selector rebind_context contextReBindContext:to:		// This operation associates a name to a different bound		// naming context		void rebind_context (in Name n, in NamingContext nc)					raises (NotFound, CannotProceed, InvalidName);		#pragma  selector resolve contextResolve:		// This operation returns the object which is bound to the		// name in the receiver		Object resolve (in Name n)						raises (NotFound, CannotProceed, InvalidName);		#pragma  selector unbind contextUnBind:		// This operation deletes the name binding from the receiver		void unbind (in Name n)					raises (NotFound, CannotProceed, InvalidName);		// This operation returns a new context		NamingContext new_context ();		#pragma  selector bind_new_context bindNewContext:		// This operation creates a new context and binds it to the		// given name.		NamingContext bind_new_context (in Name n)							raises (NotFound,									AlreadyBound,									CannotProceed,									InvalidName);		#pragma  selector destroy destroyContext		// This operation deletes the receiver		void destroy ()					raises (NotEmpty);		#pragma  selector list listContext:bindingList:bindingIterator:		// This operation returns a name list containing the bindings		// of the receiver		void list (						in unsigned long how_many,						out BindingList bl,						out BindingIterator bi);	};	// 	// A binding iterator is an object which can return portions of a	// long list of bindings	// 	interface BindingIterator {		#pragma  selector next_one nextOne:		// This operation returns the next binding and whether there		// are more or not		boolean next_one (out Binding b);		#pragma  selector next_n nextN:bindingList:		// This operation returns the next n bindings and whether		// there are more or not		boolean next_n (in unsigned long howMany, out BindingList bl);		// This operation deletes the receiver		void destroy ();	};////	Note that DST does not yet provide an implementation of the NamingContextExt//	interface.  It is provided as a convenience for interoperation with ORBs that do.//	interface NamingContextExt : NamingContext {	    typedef string StringName;	    typedef string Address;	    typedef string URLString;	    StringName to_string (in Name n)			raises (InvalidName);	    Name to_name (in StringName sn)			raises (InvalidName);	    exception InvalidAddress {};	    URLString to_url (in Address addr,			      in StringName sn)			raises (InvalidAddress, InvalidName);	    Object resolve_str (in StringName sn)			raises (NotFound, CannotProceed, InvalidName);	};};</body></methods><methods><class-id>Opentalk.BasicRequestBroker</class-id> <category>CORBA</category><body package="Opentalk-COS-Naming">nameServiceAt: anIPSocketAddress	^self		remoteObjectAt: anIPSocketAddress		oid: self nameServiceId asByteArray		interfaceId: 'IDL:omg.org/CosNaming/NamingContext:1.0'</body><body package="Opentalk-COS-Naming">nameServiceId	^#NameService</body></methods><methods><class-id>Core.Array</class-id> <category>Opentalk</category><body package="Opentalk-COS-Naming">asDSTName	"Return a DSTName on the receiver"	^Opentalk.DSTName on: self</body></methods><methods><class-id>Opentalk.RequestBroker</class-id> <category>CORBA</category><body package="Opentalk-COS-Naming">nameService	| nsid |	nsid := self nameServiceId.	^(self serviceById: nsid) ifNil: [		self useNameService: DSTNameContext new ]</body><body package="Opentalk-COS-Naming">useNameService: aNameService"	aNameService &lt;DSTNameContext | RemoteObject&gt; initialize local name service to be aNameService"	| nsid |	nsid := self nameServiceId.	self registerService: aNameService id: nsid.	self objectAdaptor export: aNameService oidBytes: nsid asByteArray.	^aNameService</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>BasicRequestBroker</name><environment>Opentalk</environment><super>Opentalk.RestartProtocol</super><private>false</private><indexed-type>none</indexed-type><inst-vars>remoteObjectRegistry objectAdaptor requestType requestTimeout </inst-vars><class-inst-vars>brokerId defaultPort defaultRequestTimeout </class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><class><name>RequestBroker</name><environment>Opentalk</environment><super>Opentalk.BasicRequestBroker</super><private>false</private><indexed-type>none</indexed-type><inst-vars>serviceDictionary openSelectors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><class><name>Array</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>OrderedCollection</name><environment>Core</environment><super>Core.SequenceableCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>firstIndex lastIndex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Sequenceable</category><attributes><package>Collections-Sequenceable</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>ReadStream</name><environment>Core</environment><super>Core.InternalStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>DSTRepository</name><environment>Opentalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Repository</category><attributes><package>Opentalk-IDL-Repository</package></attributes></class></st-source>