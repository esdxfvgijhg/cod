<?xml version="1.0"?><st-source><!-- Name: Opentalk-IIOPNotice: Copyright 1999-2013 Cincom Systems, Inc.  All rights reserved.Comment: GIOP/IIOP communication infrastructure represented by IIOPTransport and IIOPTransportConfiguration.- supports IIOP 1.0, 1.1, 1.2; this is configured via IIOPTransportConfiguration; defaults to IIOP 1.2- supports Request/Reply, and most Reply statuses- supports LocateRequest/LocateReply and most LocateReply statuses- does not support CancelRequest- does not support Message fragmenting- the general IOR infrastructure is fleshed out, IOPTaggedProfiles, IOPTaggedComponents, IOPServiceContexts, but- supports only CodeSet service context and the codeset negotiation algorithm is not fully implemented (anything else is presented as UnknownContext)- supports CodeSet, ORBType and AlternateAddress components of TaggedProfiles (anything else is presented as UnknownComponent)DbIdentifier: bear73DbTrace: 400729DbUsername: nrossDbVersion: 7.10 - 1DevelopmentPrerequisites: #(#(#any 'Opentalk-Core' '') #(#any 'Opentalk-CDR' '') #(#any 'Opentalk-IDL-MetaObjects' '') #(#any 'Opentalk-IDL-Repository' ''))PackageName: Opentalk-IIOPParcel: #('Opentalk-IIOP')PrerequisiteParcels: #(#('Opentalk-Core' '') #('Opentalk-CDR' '') #('Opentalk-IDL-MetaObjects' '') #('Opentalk-IDL-Repository' ''))PrintStringCache: (7.10 - 1,nross)Version: 7.10 - 1Date: 11:27:08 AM April 12, 2013 --><time-stamp>From VisualWorksÂ®, Pre-Release 7.10 (apr13.2) of April 12, 2013 on April 12, 2013 at 11:27:08 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>IOPTaggedProfile</name><environment>Opentalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>profileData </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Protocols-Core</category><attributes><package>Opentalk-IIOP</package></attributes></class><comment><class-id>Opentalk.IOPTaggedProfile</class-id><body>The abstract profile superclass, defines basic protocol.Instance Variables:	profileData	&lt;ByteArray&gt;	encapsulated data {sequence &lt;octet&gt;}</body></comment><class><name>IOPUnknownProfile</name><environment>Opentalk</environment><super>Opentalk.IOPTaggedProfile</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tag </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Protocols-Core</category><attributes><package>Opentalk-IIOP</package></attributes></class><comment><class-id>Opentalk.IOPUnknownProfile</class-id><body>This is the "catch all" profile for those that we don't recognize yet.Instance Variables:	tag	&lt;Integer&gt;	profile id {typedef unsigned long	ProfileId}	profileData	&lt;ByteArray&gt;	profile bytes {sequence &lt;octet&gt;}</body></comment><class><name>GIOPMessage</name><environment>Opentalk</environment><super>Opentalk.TransportPackage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>transport cdrStream </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Tests</category><attributes><package>Opentalk-IIOP</package></attributes></class><comment><class-id>Opentalk.GIOPMessage</class-id><body>Abstract superclass of GIOP transport messages. A message knows how to unmarshal itself from and marshal itself into a buffer (TransportMessageBytes). It provides access to the unmarshaled elements of its header.15.4.1 GIOP Message HeaderAll GIOP messages begin with the following header, defined in OMG IDL:	module GIOP { // IDL extended for version 1.1, 1.2, and 1.3		struct Version {			octet major;			octet minor;		};		#ifndef GIOP_1_1		// GIOP 1.0		enum MsgType_1_0 { // Renamed from MsgType			Request, Reply, CancelRequest,			LocateRequest, LocateReply,			CloseConnection, MessageError		};	#else		// GIOP 1.1		enum MsgType_1_1 {			Request, Reply, CancelRequest,			LocateRequest, LocateReply,			CloseConnection, MessageError,			Fragment // GIOP 1.1 addition		};	#endif // GIOP_1_1			// GIOP 1.0		struct MessageHeader_1_0 { // Renamed from MessageHeader			char magic [4];			Version GIOP_version;			boolean byte_order;			octet message_type;			unsigned long message_size;		};		// GIOP 1.1		struct MessageHeader_1_1 {			char magic [4];			Version GIOP_version;			octet flags; // GIOP 1.1 change			octet message_type;			unsigned long message_size;		};		// GIOP 1.2, 1.3		typedef MessageHeader_1_1 MessageHeader_1_2;		typedef MessageHeader_1_1 MessageHeader_1_3;	};The message header clearly identifies GIOP messages and their byte-ordering. The header is independent of byte ordering except for the field encoding message size.&gt; magic identifies GIOP messages. The value of this member is always the four (upper case) characters 'GIOP', encoded in ISO Latin-1 (8859.1).&gt; GIOP_version contains the version number of the GIOP protocol being used in the message. The version number applies to the transport-independent elements of this specification (i.e., the CDR and message formats) that constitute the GIOP. This is not equivalent to the IIOP version number (as described in Section 15.3.6, Object References, on page 15-30) though it has the same structure. The major GIOP version number of this specification is one (1); the minor versions are one (1), two (2), and three (3).A server implementation supporting a minor GIOP protocol version 1.n (with n &gt; 0 and n &lt; 3), must also be able to process GIOP messages having minor protocol version 1.m, with m less than n. A GIOP server, which receives a request having a greater minor version number than it supports, should respond with an error message having the highest minor version number that that server supports, and then close the connection.A client should not send a GIOP message having a higher minor version number than that published by the server in the tag Internet IIOP Profile body of an IOR.&gt; byte_order (in GIOP 1.0 only) indicates the byte ordering used in subsequent elements of the message (including message_size). A value of FALSE (0) indicates big-endian byte ordering, and TRUE (1) indicates little-endian byte ordering.&gt; flags (in GIOP 1.1, 1.2, and 1.3) is an 8-bit octet. The least significant bit indicates the byte ordering used in subsequent elements of the message (including message_size). A value of FALSE (0) indicates big-endian byte ordering, and TRUE (1) indicates little-endian byte ordering. The byte order for fragment messages must match the byte order of the initial message that the fragment extends. The second least significant bit indicates whether or not more framents follow. A value of FALSE (0) indicates this message is the last fragment, and TRUE (1) indicates more fragments follow this message. The most significant 6 bits are reserved. These 6 bits must have value 0 for GIOP version 1.1, 1.2, and 1.3.&gt; message_type indicates the type of the message, according to Table 15-3; these correspond to enum values of type MsgType.&gt; message_size contains the number of octets in the message following the message header, encoded using the byte order specified in the byte order bit (the least significant bit) in the flags field (or using the byte_order field in GIOP 1.0). It refers to the size of the message body, not including the 12-byte message header. This count includes any alignment gaps and must match the size of the actual request parameters (plus any final padding bytes that may follow the parameters to have a fragment message terminate on an 8-byte boundary).A MARSHAL exception with minor code 7 indicates that fewer bytes were present in a message than indicated by the count. (This condition can arise if the sender sends a message in fragments, and the receiver detects that the final fragment was received but contained insufficient data for all parameters to be unmarshaled.).A MARSHAL exception with minor code 8 indicates that more bytes were present in a message than indicated by the count. Depending on the ORB implementation, this condition may be reported for the current message or the next message that is processed (when the receiver detects that the previous message is not immediately followed by the GIOP magic number).The use of a message size of 0 with a Request, LocateRequest, Reply, or LocateReply message is reserved for future use.For GIOP version 1.2, and 1.3, if the second least significant bit of Flags is 1, the sum of the message_size value and 12 must be evenly divisible by 8.Messages with different GIOP minor versions may be mixed on the same underlying transport connection.Instance Variables:	transport &lt;IIOPTransport&gt; corresponding connection	cdrStream &lt;CDRStream&gt; marshaling stream</body></comment><class><name>GIOPFragment</name><environment>Opentalk</environment><super>Opentalk.GIOPMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>requestId </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Tests</category><attributes><package>Opentalk-IIOP</package></attributes></class><comment><class-id>Opentalk.GIOPFragment</class-id><body>This message is added in GIOP 1.1. The Fragment message is sent following a previous request or response message that has the more fragments bit set to TRUE in the flags field.All of the GIOP messages begin with a GIOP header. One of the fields of this header is the message_size field, a 32-bit unsigned number giving the number of bytes in the message following the header. Unfortunately, when actually constructing a GIOP Request or Reply message, it is sometimes impractical or undesirable to ascertain the total size of the message at the stage of message construction where the message header has to be written. GIOP 1.1 provides an alternative indication of the size of the message, for use in those cases.In GIOP 1.1, a Request or Reply message can be broken into multiple fragments. In GIOP 1.2 and 1.3, a Request, Reply, LocateRequest, or LocateReply message can be broken into multiple fragment. The first fragment is a regular message (e.g., Request or Reply) with the more fragments bit in the flags field set to TRUE. This initial fragment can be followed by one or more messages using the fragment messages. The last fragment shall have the more fragment bit in the flag field set to FALSE.A CancelRequest message may be sent by the client before the final fragment of the message being sent. In this case, the server should assume no more fragments will follow.Note: A GIOP client that fragments the header of a Request message before sending the request ID may not send a CancelRequest message pertaining to that request ID and may not send another Request message until after the request ID is sent. A primitive data type of 8 bytes or smaller should never be broken across two fragments.In GIOP 1.1, the data in a fragment is marshaled with alignment relative to its position in the fragment, not relative to its position in the whole unfragmented message.For GIOP version 1.2 and 1.3, the total length (including the message header) of a fragment other than the final fragment of a fragmented message are required to be a multiple of 8 bytes in length, allowing bridges to defragment and/or refragment messages without having to remarshal the encoded data to insert or remove padding.For GIOP version 1.2 and 1.3, a fragment header is included in the message, immediately after the GIOP message header and before the fragment data. The request ID, in the fragment header, has the same value as that used in the original message associated with the fragment.The byte order and GIOP protocol version of a fragment shall be the same as that of the message it continues.Instance Variables:	requestId	&lt;Integer&gt; unsigned long  request_id</body></comment><class><name>IOPServiceContext</name><environment>Opentalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>contextData </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Protocols-Core</category><attributes><package>Opentalk-IIOP</package></attributes></class><comment><class-id>Opentalk.IOPServiceContext</class-id><body>The abstract profile superclass, defines basic protocol.Instance Variables:	contextData	&lt;ByteArray&gt;	the data bytes {sequence &lt;octet&gt;}</body></comment><class><name>GIOPReply</name><environment>Opentalk</environment><super>Opentalk.GIOPMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>requestId replyStatus serviceContext reply </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Tests</category><attributes><package>Opentalk-IIOP</package></attributes></class><comment><class-id>Opentalk.GIOPReply</class-id><body>Reply messages are sent in response to Request messages if and only if the response expected flag in the request is set to TRUE. Replies include inout and out parameters, operation results, and may include exception values. In addition, Reply messages may provide object location information. In GIOP versions 1.0 and 1.1, replies flow only from server to client.Instance Variables:	requestId	&lt;Integer&gt; unsigned long  request_id	replyStatus	&lt;SmallInteger&gt; exception? location forward? ...; ReplyStatusType_1_0  reply_status	serviceContext	&lt;Array of: IOPServiceContext&gt; IOP::ServiceContextList  service_context; 13.6.7	reply	&lt;IIOPObjRef | SystemException | Object&gt; a reply body cache</body></comment><class><name>IOPTaggedComponent</name><environment>Opentalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>componentData </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Protocols-Core</category><attributes><package>Opentalk-IIOP</package></attributes></class><comment><class-id>Opentalk.IOPTaggedComponent</class-id><body>The abstract IOP::TaggedComponent used in IOP::TaggedProfiles, defines basic protocol [13.6.5]Instance Variables:	componentData	&lt;ByteArray&gt;	encapsulated data {sequence &lt;octet&gt;}</body></comment><class><name>GIOPCloseConnection</name><environment>Opentalk</environment><super>Opentalk.GIOPMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Tests</category><attributes><package>Opentalk-IIOP</package></attributes></class><comment><class-id>Opentalk.GIOPCloseConnection</class-id><body>CloseConnection messages are sent only by servers in GIOP protocol versions 1.0 and 1.1. They inform clients that the server intends to close the connection and must not be expected to provide further responses. Moreover, clients know that any requests for which they are awaiting replies will never be processed, and may safely be reissued (on another connection). In GIOP version 1.2 and 1.3 both sides of the connection may send the CloseConnection message.</body></comment><class><name>IOPUnknownContext</name><environment>Opentalk</environment><super>Opentalk.IOPServiceContext</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tag </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Protocols-Core</category><attributes><package>Opentalk-IIOP</package></attributes></class><comment><class-id>Opentalk.IOPUnknownContext</class-id><body>This is the "catch all" profile for those that we don't recognize yet.Instance Variables:	tag	&lt;SmallInteger&gt;	service id; 13.6.7 {typedef unsigned long  ServiceId}</body></comment><class><name>IOPCodeSets</name><environment>Opentalk</environment><super>Opentalk.IOPTaggedComponent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>charNativeSet charConversionSets wcharNativeSet wcharConversionSets </inst-vars><class-inst-vars>codeSetMap reverseCodeSetMap compatibilityMap charSetMap default </class-inst-vars><imports></imports><category>CORBA-Protocols-Core</category><attributes><package>Opentalk-IIOP</package></attributes></class><comment><class-id>Opentalk.IOPCodeSets</class-id><body>The TAG_CODE_SETS component [13.7.2.4]. Code sets are identified by a 32-bit integer id from the OSF Character and Code Set Registry (http://www.opengroup.org/tech/rfc/rfc40.2.html).Instance Variables:	charNativeSet	&lt;SmallInteger&gt; native char code set {typedef unsigned long  CodeSetId}	charConversionSets	&lt;Array of: SmallInteger&gt; char conversion code sets {sequence&lt;CodeSetId&gt;}	wcharNativeSet	&lt;SmallInteger&gt; native wchar code set {typedef unsigned long  CodeSetId}	wcharConversionSets	&lt;Array of: SmallInteger&gt; wchar conversion code sets {sequence&lt;CodeSetId&gt;}Class Instance Variables:	codeSetMap	&lt;Dictionary key: SmallInteger value: String&gt; maps code set id to a descriptive name	reverseCodeSetMap	&lt;Dictionary key: String value: SmallInteger&gt; maps code set names to ids	compatibilityMap	&lt;Dictionary key: SmallInteger value: SmallInteger&gt; maps code set to the corresponding char set	charSetMap	&lt;Dictionary key: SmallInteger value: String&gt; maps char set id to a descriptive name	default	&lt;IOPCodeSets&gt; the default VW code sets</body></comment><class><name>IIOPProfile</name><environment>Opentalk</environment><super>Opentalk.IOPTaggedProfile</super><private>false</private><indexed-type>none</indexed-type><inst-vars>majorVersion minorVersion host port objectKey components </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Protocols-Core</category><attributes><package>Opentalk-IIOP</package></attributes></class><comment><class-id>Opentalk.IIOPProfile</class-id><body>This class is private to the implementation of the Distributed Smalltalk.  Users should not use this class directly and should not subclass it.Instance Variables:	majorVersion	&lt;SmallInteger&gt;	major IIOP version	minorVersion	&lt;SmallInteger&gt; minor IIOP version	host	&lt;String&gt; qualified domain name or printed IP address in dotted notation	port	&lt;SmallInteger&gt;	port number	objectKey	&lt;ByteArray&gt;	opaque object identifier {sequence &lt;octet&gt;}	components	&lt;Array of: IOPTaggedComponent&gt; additional components; IIOP 1.1 and higher {sequence &lt;IOP::TaggedComponent&gt;}</body></comment><class><name>IOPORBType</name><environment>Opentalk</environment><super>Opentalk.IOPTaggedComponent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id </inst-vars><class-inst-vars>default </class-inst-vars><imports></imports><category>CORBA-Protocols-Core</category><attributes><package>Opentalk-IIOP</package></attributes></class><comment><class-id>Opentalk.IOPORBType</class-id><body>The TAG_ORB_TYPE component [13.6.3.1]Instance Variables:	id	&lt;SmallInteger&gt; ORB type ID {unsigned long}Class Instance Variables:	default	&lt;IOPORBType&gt; the default TAG_ORB_TYPE component</body></comment><class><name>IIOPObjRef</name><environment>Opentalk</environment><super>Opentalk.ObjRef</super><private>false</private><indexed-type>none</indexed-type><inst-vars>profiles profile interfaceId interface </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-IIOP</category><attributes><package>Opentalk-IIOP</package></attributes></class><comment><class-id>Opentalk.IIOPObjRef</class-id><body>Instance Variables:	profiles	&lt;Array of: IOPTaggedProfile&gt;	tagged protocol profiles	profile	&lt;IOPTaggedProfile&gt; selected protocol profile	interfaceId	&lt;RepositoryId&gt; repository id of the interface	interface	&lt;DSTinterface&gt;	interface definition object</body></comment><class><name>IOPCodeSet</name><environment>Opentalk</environment><super>Opentalk.IOPServiceContext</super><private>false</private><indexed-type>none</indexed-type><inst-vars>charData wcharData </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-IIOP</category><attributes><package>Opentalk-IIOP</package></attributes></class><comment><class-id>Opentalk.IOPCodeSet</class-id><body>GIOP Code Set Service Context [13.7.2.5]. Code sets are identified by a 32-bit integer id from the OSF Character and Code Set Registry (http://www.opengroup.org/tech/rfc/rfc40.2.html).Instance Variables:	charData	&lt;SmallInteger&gt; char transmission code set id {typedef unsigned long  CodeSetId}	wcharData	&lt;SmallInteger&gt; 	wchar transmission code set id {typedef unsigned long  CodeSetId}</body></comment><class><name>IIOPTransport</name><environment>Opentalk</environment><super>Opentalk.StreamTransport</super><private>false</private><indexed-type>none</indexed-type><inst-vars>socket timeout </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Tests</category><attributes><package>Opentalk-IIOP</package></attributes></class><comment><class-id>Opentalk.IIOPTransport</class-id><body>Instance Variables:	socket	&lt;SocketAccessor&gt;	the socket	timeout	&lt;Integer&gt;		the socket readWait and writeWait timeout</body></comment><class><name>GIOPRequest</name><environment>Opentalk</environment><super>Opentalk.GIOPMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>requestId target operation responseFlags serviceContext </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Tests</category><attributes><package>Opentalk-IIOP</package></attributes></class><comment><class-id>Opentalk.GIOPRequest</class-id><body>Request messages encode CORBA object invocations, including attribute accessor operations, and CORBA::Object operations get_interface and get_implementation.Instance Variables:	requestId	&lt;Integer&gt; unsigned long  request_id	target	&lt;ByteArray | IIOPObjRef | IIOPProfile&gt; target object identification; union TargetAddress  target	operation	&lt;String&gt; operation name; string  operation	responseFlags	&lt;SmallInteger&gt; big-endian ? fragment ? response expected ?; octet  response_flags	serviceContext	&lt;Array of: IOPServiceContext&gt; IOP::ServiceContextList  service_context; 13.6.7</body></comment><class><name>GIOPMessageError</name><environment>Opentalk</environment><super>Opentalk.GIOPMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Tests</category><attributes><package>Opentalk-IIOP</package></attributes></class><comment><class-id>Opentalk.GIOPMessageError</class-id><body>The MessageError message is sent in response to any GIOP message whose version number or message type is unknown to the recipient or any message received whose header is not properly formed (e.g., has the wrong magic value). Error handling is context-specific.</body></comment><class><name>IOPUnknownComponent</name><environment>Opentalk</environment><super>Opentalk.IOPTaggedComponent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tag </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Protocols-Core</category><attributes><package>Opentalk-IIOP</package></attributes></class><comment><class-id>Opentalk.IOPUnknownComponent</class-id><body>The "catch-all" component type that is used for those components that we don't recognize yet.Instance Variables:	tag	&lt;SmallInteger&gt;	component tag; 13.6.3 {unsigned long}</body></comment><class><name>IOPMultipleComponentProfile</name><environment>Opentalk</environment><super>Opentalk.IOPTaggedProfile</super><private>false</private><indexed-type>none</indexed-type><inst-vars>components </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Protocols-Core</category><attributes><package>Opentalk-IIOP</package></attributes></class><comment><class-id>Opentalk.IOPMultipleComponentProfile</class-id><body>Instance Variables:	components	&lt;Array of: IOPTaggedComponent&gt;	profile components {sequence &lt;TaggedComponent&gt;}</body></comment><class><name>IIOPTransportConfiguration</name><environment>Opentalk</environment><super>Opentalk.StreamTransportConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars>minorVersion </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Tests</category><attributes><package>Opentalk-IIOP</package></attributes></class><comment><class-id>Opentalk.IIOPTransportConfiguration</class-id><body>Instance Variables:	minorVersion	&lt;SmallInteger&gt; minor IIOP version number &lt;0..2&gt;</body></comment><class><name>IIOPAlternateAddress</name><environment>Opentalk</environment><super>Opentalk.IOPTaggedComponent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>host port </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Protocols-Core</category><attributes><package>Opentalk-IIOP</package></attributes></class><comment><class-id>Opentalk.IIOPAlternateAddress</class-id><body>The TAG_ALTERNATE_IIOP_ADDRESS component [13.6.3.2]Instance Variables:	host	&lt;String&gt; 	host name {string HostID}	port	&lt;SmallInteger&gt; 	port number {short Port}</body></comment><class><name>LocationForward</name><environment>Opentalk</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-IIOP</category><attributes><package>Opentalk-IIOP</package></attributes></class><comment><class-id>Opentalk.LocationForward</class-id><body>Signals a LocationForward exception in the incoming reply.</body></comment><class><name>SystemException</name><environment>Opentalk</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars>repositoryId minorCode completionStatus </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-CORBA</category><attributes><package>Opentalk-IIOP</package></attributes></class><comment><class-id>Opentalk.SystemException</class-id><body>Standard CORBA System Exceptions as defined in 4.12.2 section in ORB Interface chapter.Instance Variables:	repositoryId	&lt;RepositoryId&gt;	id of the exception definition, string  exception_id;	minorCode	&lt;SmallInteger&gt; exception detail; unsigned long  minor_code_value;	completionStatus	&lt;Symbol&gt; request completion status; unsigned long  completion_status;</body></comment><class><name>GIOPLocateReply</name><environment>Opentalk</environment><super>Opentalk.GIOPMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>requestId locateStatus reply </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Tests</category><attributes><package>Opentalk-IIOP</package></attributes></class><comment><class-id>Opentalk.GIOPLocateReply</class-id><body>LocateReply messages are sent from servers to clients in response to LocateRequest messages.In GIOP versions 1.0 and 1.1 the LocateReply message is only sent from the server to the client.Instance Variables:	requestId	&lt;Integer&gt; unsigned long  request_id	locateStatus	&lt;SmallInteger&gt; HERE?, FORWARD?, UNKNOWN?; LocateStatusType_1_0/2  locate_status	reply	&lt;IIOPObjRef | SystemException&gt; the locate resply</body></comment><class><name>GIOPCancelRequest</name><environment>Opentalk</environment><super>Opentalk.GIOPMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>requestId </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Tests</category><attributes><package>Opentalk-IIOP</package></attributes></class><comment><class-id>Opentalk.GIOPCancelRequest</class-id><body>CancelRequest messages notify a server that the client is no longer expecting a reply for a specified pending Request or LocateRequest message. CancelRequest messages may be sent, in GIOP versions 1.0 and 1.1, only from clients to servers.Instance Variables:	requestId	&lt;Integer&gt; unsigned long  request_id</body></comment><class><name>GIOPLocateRequest</name><environment>Opentalk</environment><super>Opentalk.GIOPMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>requestId target promise </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Tests</category><attributes><package>Opentalk-IIOP</package></attributes></class><comment><class-id>Opentalk.GIOPLocateRequest</class-id><body>LocateRequest messages may be sent from a client to a server to determine whether the current server is capable of directly receiving requests for the object reference, and if not, to what address requests for the object reference should be sent.Note that this information is also provided through the Request message, but that some clients might prefer not to support retransmission of potentially large messages that might be implied by a LOCATION_FORWARD status in a Reply message. That is, client use of this represents a potential optimization.Instance Variables:	requestId	&lt;Integer&gt; unsigned long  request_id	target	&lt;ByteArray | IIOPObjRef | IIOPProfile&gt; target object identification; union TargetAddress  target	promise	&lt;Promise&gt; promise for the client thread</body></comment><shared-variable><name>MessageTypeMap</name><environment>Opentalk.GIOPMessage</environment><private>false</private><constant>false</constant><category>types</category><initializer>GIOPMessage buildMessageTypeMap</initializer><attributes><package>Opentalk-IIOP</package></attributes></shared-variable><shared-variable><name>TagMap</name><environment>Opentalk.IOPTaggedComponent</environment><private>false</private><constant>false</constant><category>constants</category><initializer>nil</initializer><attributes><package>Opentalk-IIOP</package></attributes></shared-variable><shared-variable><name>TagMap</name><environment>Opentalk.IOPServiceContext</environment><private>false</private><constant>false</constant><category>constants</category><initializer>nil</initializer><attributes><package>Opentalk-IIOP</package></attributes></shared-variable><shared-variable><name>VMCID</name><environment>Opentalk.SystemException</environment><private>false</private><constant>false</constant><category>constants</category><initializer>		('OS' asByteArray, #[0 0])			inject: 0 into: [ :t :b |				(t bitShift: 8) + b ]</initializer><attributes><package>Opentalk-IIOP</package></attributes></shared-variable><shared-variable><name>TagMap</name><environment>Opentalk.IOPTaggedProfile</environment><private>false</private><constant>false</constant><category>accessing-tag map</category><initializer>nil</initializer><attributes><package>Opentalk-IIOP</package></attributes></shared-variable><methods><class-id>Opentalk.IOPTaggedProfile</class-id> <category>accessing</category><body package="Opentalk-IIOP">profileData	^profileData ifNil: [ | stream |		stream := CDRStream on: (ByteArray new: 10).		self profileDataOn: stream.		profileData := stream contents ]</body><body package="Opentalk-IIOP">profileData: aByteArray	profileData := aByteArray.	self profileDataFrom: (CDRStream with: aByteArray) reset</body><body package="Opentalk-IIOP">profileDataFrom: aCDRStream	aCDRStream nextEncapsulatedInOctets: [ :stream |		 self unmarshalProfileDataFrom: stream ]</body><body package="Opentalk-IIOP">profileDataOn: aCDRStream	profileData		ifNil: [ aCDRStream nextPutEncapsulatedInOctets: [ :stream |				self marshalProfileDataOn: stream ] ]		ifNotNil: [ aCDRStream nextPutAll: profileData ]</body><body package="Opentalk-IIOP">tag	^self class tag</body><body package="Opentalk-IIOP">tag: anInteger	anInteger = self tag ifFalse: [self error: 'Cannot change the tag!']</body></methods><methods><class-id>Opentalk.IOPTaggedProfile</class-id> <category>marshaling</category><body package="Opentalk-IIOP">cdrReadFrom: aCDRStream	self profileDataFrom: aCDRStream</body><body package="Opentalk-IIOP">cdrWriteOn: aCDRStream	aCDRStream nextPutUnsignedLong: self tag.	self profileDataOn: aCDRStream</body></methods><methods><class-id>Opentalk.IOPTaggedProfile</class-id> <category>testing</category><body package="Opentalk-IIOP">isSupported	^false</body></methods><methods><class-id>Opentalk.IOPTaggedProfile</class-id> <category>private</category><body package="Opentalk-IIOP">marshalProfileDataOn: aCDRStream	self subclassResponsibility</body><body package="Opentalk-IIOP">unmarshalProfileDataFrom: aCDRStream	self subclassResponsibility</body></methods><methods><class-id>Opentalk.IOPTaggedProfile</class-id> <category>printing</category><body package="Opentalk-IIOP">printOn: aStream	aStream		nextPut: $(;		print: self tag;		nextPut: $)</body></methods><methods><class-id>Opentalk.IOPTaggedProfile class</class-id> <category>instance creation</category><body package="Opentalk-IIOP">tag: aSmallInteger	^(self componetTypeFor: aSmallInteger) new tag: aSmallInteger</body></methods><methods><class-id>Opentalk.IOPTaggedProfile class</class-id> <category>accessing-tag map</category><body package="Opentalk-IIOP">buildTagMap	| maxTag classes |	classes := IOPTaggedProfile allSubclasses.	maxTag := classes inject: 0 into: [ :max :cl | (cl tag ifNil: [0]) max: max ].	^classes		inject: (Array new: maxTag withAll: IOPUnknownProfile)		into: [ :map :cl |			cl tag ifNotNil: [ :tag | tag isZero ifFalse: [ map at: tag put: cl ] ].			map ]</body><body package="Opentalk-IIOP">componetTypeFor: aSmallInteger	| map |	aSmallInteger isZero ifTrue: [^IIOPProfile].	map := self tagMap.	^aSmallInteger &gt; map size		ifTrue: [IOPUnknownProfile]		ifFalse: [map at: aSmallInteger]</body><body package="Opentalk-IIOP">tagMap	^TagMap ifNil: [ TagMap := self buildTagMap ]</body></methods><methods><class-id>Opentalk.IOPTaggedProfile class</class-id> <category>constants</category><body package="Opentalk-IIOP">tag	^nil</body></methods><methods><class-id>Opentalk.IOPTaggedProfile class</class-id> <category>marshaling</category><body package="Opentalk-IIOP">cdrReadFrom: aCDRStream	^(self tag: aCDRStream nextUnsignedLong)		cdrReadFrom: aCDRStream</body></methods><methods><class-id>Opentalk.IOPUnknownProfile</class-id> <category>accessing</category><body package="Opentalk-IIOP">tag	^tag</body><body package="Opentalk-IIOP">tag: anInteger	tag := anInteger</body></methods><methods><class-id>Opentalk.IOPUnknownProfile</class-id> <category>marshaling</category><body package="Opentalk-IIOP">cdrReadFrom: aCDRStream	profileData := aCDRStream nextOctetSequence</body><body package="Opentalk-IIOP">cdrWriteOn: aCDRStream	aCDRStream		nextPutUnsignedLong: self tag;		nextPutOctetSequence: profileData</body></methods><methods><class-id>Opentalk.IOPUnknownProfile</class-id> <category>printing</category><body package="Opentalk-IIOP">printOn: aStream	aStream nextPutAll: 'Profile'.	super printOn: aStream</body></methods><methods><class-id>Opentalk.GIOPMessage</class-id> <category>accessing</category><body package="Opentalk-IIOP">cdrStream	^cdrStream ifNil: [ cdrStream := self newCDRStream ]</body><body package="Opentalk-IIOP">newCDRStream	| headerIndex |	headerIndex := buffer headerSize + 1.	^(	CDRStream			on: buffer			from: headerIndex			to: buffer size	)	byteOrder: self byteOrder;		marshaler: (self transport ifNotNil: [ self transport marshaler ]);		yourself</body><body package="Opentalk-IIOP">position	^self cdrStream position</body><body package="Opentalk-IIOP">transport	^transport</body><body package="Opentalk-IIOP">transport: aTransport"	aTransport	&lt;IIOPTransport&gt; corresponding connection"	transport := aTransport</body></methods><methods><class-id>Opentalk.GIOPMessage</class-id> <category>initialization</category><body package="Opentalk-IIOP">initializeOn: aBuffer	self initialize: aBuffer.	aBuffer msgType: self class msgType</body><body package="Opentalk-IIOP">readHeader"Unmarshal the request header from the buffer and set the position to the end of the request header.expects position to be set at the end of message header."	^self "do nothing"</body><body package="Opentalk-IIOP">writeHeader"Marshal the request header into the buffer and set the position to the end of the request header.Expects position to be set at the end of message header."	^self "do nothing"</body></methods><methods><class-id>Opentalk.GIOPMessage</class-id> <category>marshaling</category><body package="Opentalk-IIOP">receivingMessageIn: aTransport</body><body package="Opentalk-IIOP">sendingMessageIn: aTransport</body><body package="Opentalk-IIOP">updateSizeFromPosition	self msgSize: self position - self headerSize</body></methods><methods><class-id>Opentalk.GIOPMessage</class-id> <category>printing</category><body package="Opentalk-IIOP">printOn: aStream	aStream nextPutAll: self typeTag</body><body package="Opentalk-IIOP">typeTag	^self class name</body></methods><methods><class-id>Opentalk.GIOPMessage</class-id> <category>services</category><body package="Opentalk-IIOP">addCodeSet: anIOPCodeSet"This applies to GIOPRequests only.	anIOPCodeSet &lt;IOPCodeSet&gt;"</body><body package="Opentalk-IIOP">codeSet"... only applies to GIOPRequests.	^&lt;IOPCodeSet | nil&gt;"	^nil</body></methods><methods><class-id>Opentalk.GIOPMessage class</class-id> <category>accessing</category><body package="Opentalk-IIOP">buildMessageTypeMap	| map |	map := IdentityDictionary new.	self allSubclassesDo: [ :c || t |		(t := c msgType) isNil ifFalse: [			map at: t put: c ] ].	^map</body><body package="Opentalk-IIOP">msgType	^nil</body><body package="Opentalk-IIOP">msgTypeMap"MessageTypeMap := self buildMessageTypeMap"	^MessageTypeMap</body></methods><methods><class-id>Opentalk.GIOPMessage class</class-id> <category>instance creation</category><body package="Opentalk-IIOP">newOn: aBuffer	^self new initializeOn: aBuffer</body><body package="Opentalk-IIOP">newWith: aBuffer	^(self msgTypeMap at: aBuffer msgType) new initialize: aBuffer</body></methods><methods><class-id>Opentalk.GIOPFragment</class-id> <category>initialization</category><body package="Opentalk-IIOP">readHeader"Unmarshal the fragment header from the buffer and set the position to the end of the fragment header.expects position to be set at the end of message header."	| stream |	stream := self cdrStream.	"15.4.9"	self minorVersion &gt; 1 ifTrue: [ "GIOP 1.2, ..."		self requestId: stream nextUnsignedLong ]	"unsigned long  request_id"</body><body package="Opentalk-IIOP">writeHeader"Marshal the fragment header into the buffer and set the position to the end of the fragment header.Expects position to be set at the end of message header."	| stream |	stream := self cdrStream.	self minorVersion &gt; 1 ifTrue: [ "GIOP 1.2, ..."		stream nextPutUnsignedLong: self requestId ].	"unsigned long  request_id"</body></methods><methods><class-id>Opentalk.GIOPFragment</class-id> <category>accessing</category><body package="Opentalk-IIOP">requestId	^requestId</body><body package="Opentalk-IIOP">requestId: anObject	requestId := anObject</body></methods><methods><class-id>Opentalk.GIOPFragment class</class-id> <category>accessing</category><body package="Opentalk-IIOP">msgType	^7</body></methods><methods><class-id>Opentalk.IOPServiceContext</class-id> <category>accessing</category><body package="Opentalk-IIOP">contextData	^contextData ifNil: [ | stream |		stream := CDRStream on: (ByteArray new: 10).		self contextDataOn: stream.		contextData := stream contents ]</body><body package="Opentalk-IIOP">contextData: aByteArray	contextData := aByteArray.	self contextDataFrom: (CDRStream with: aByteArray) reset</body><body package="Opentalk-IIOP">tag	^self class tag</body><body package="Opentalk-IIOP">tag: anInteger	anInteger = self tag ifFalse: [self error: 'Cannot change the tag!']</body></methods><methods><class-id>Opentalk.IOPServiceContext</class-id> <category>private</category><body package="Opentalk-IIOP">contextDataFrom: aCDRStream	aCDRStream nextEncapsulatedInOctets: [ :stream |		 self readContextDataFrom: stream ]</body><body package="Opentalk-IIOP">contextDataOn: aCDRStream	contextData		ifNil: [ aCDRStream nextPutEncapsulatedInOctets: [ :stream |				self writeContextDataOn: stream ] ]		ifNotNil: [ aCDRStream nextPutAll: contextData ]</body><body package="Opentalk-IIOP">readContextDataFrom: aCDRStream 	self subclassResponsibility</body><body package="Opentalk-IIOP">writeContextDataOn: aCDRStream 	self subclassResponsibility</body></methods><methods><class-id>Opentalk.IOPServiceContext</class-id> <category>marshaling</category><body package="Opentalk-IIOP">cdrReadFrom: aCDRStream	self contextDataFrom: aCDRStream</body><body package="Opentalk-IIOP">cdrWriteOn: aCDRStream	aCDRStream nextPutUnsignedLong: self tag.	self contextDataOn: aCDRStream</body></methods><methods><class-id>Opentalk.IOPServiceContext</class-id> <category>printing</category><body package="Opentalk-IIOP">printOn: aStream	aStream		nextPut: $(;		print: self tag;		nextPut: $)</body></methods><methods><class-id>Opentalk.IOPServiceContext class</class-id> <category>accessing-tag map</category><body package="Opentalk-IIOP">buildTagMap	| maxTag classes |	classes := IOPServiceContext allSubclasses.	maxTag := classes inject: 0 into: [ :max :cl | (cl tag ifNil: [0]) max: max ].	^classes		inject: (Array new: maxTag withAll: IOPUnknownContext)		into: [ :map :cl |			cl tag ifNotNil: [ :tag | tag isZero ifFalse: [ map at: tag put: cl ] ].			map ]</body><body package="Opentalk-IIOP">contextTypeFor: aSmallInteger	| map |	aSmallInteger isZero ifTrue: [^IOPUnknownContext]. "This should return TransactionService context when we get there"	map := self tagMap.	^aSmallInteger &gt; map size		ifTrue: [IOPUnknownContext]		ifFalse: [map at: aSmallInteger]</body><body package="Opentalk-IIOP">tagMap	^TagMap ifNil: [ TagMap := self buildTagMap ]</body></methods><methods><class-id>Opentalk.IOPServiceContext class</class-id> <category>accessing</category><body package="Opentalk-IIOP">tag	^nil</body></methods><methods><class-id>Opentalk.IOPServiceContext class</class-id> <category>instance creation</category><body package="Opentalk-IIOP">tag: aSmallInteger	^(self contextTypeFor: aSmallInteger) new tag: aSmallInteger</body></methods><methods><class-id>Opentalk.IOPServiceContext class</class-id> <category>marshaling</category><body package="Opentalk-IIOP">cdrReadFrom: aCDRStream	^(self tag: aCDRStream nextUnsignedLong)		cdrReadFrom: aCDRStream</body></methods><methods><class-id>Opentalk.GIOPReply</class-id> <category>initialization</category><body package="Opentalk-IIOP">readHeader"Unmarshal the reply header from the buffer and set the position to the end of the reply header.Expects position to be set at the end of message header."	| stream |	stream := self cdrStream.	self minorVersion &lt; 2		ifTrue: [ "GIOP 1.0, 1.1"			self	serviceContext: (stream nextSequenceOf: IOPServiceContext);	"IOP::ServiceContextList  service_context; 13.6.7"				requestId: stream nextUnsignedLong;	"unsigned long  request_id"				"enum ReplyStatusType_1_0 {NO_EXCEPTION, USER_EXCEPTION, ...}"				replyStatus: stream nextUnsignedLong ] "ReplyStatusType_1_0  reply_status; 15.4.3.1"		ifFalse: [ "GIOP 1.2, ..."			self	requestId: stream nextUnsignedLong;	"unsigned long  request_id"				"enum ReplyStatusType_1_2 {NO_EXCEPTION, USER_EXCEPTION, ...}"				replyStatus: stream nextUnsignedLong;	"ReplyStatusType_1_2  reply_status; 15.4.3.1"				serviceContext: (stream nextSequenceOf: IOPServiceContext) ].	"IOP::ServiceContextList  service_context; 13.6.7"</body><body package="Opentalk-IIOP">writeHeader"Marshal the reply header into the buffer and set the position to the end of the reply header.Expects position to be set at the end of message header."	| stream |	stream := self cdrStream.	self minorVersion &lt; 2		ifTrue: [ "GIOP 1.0, 1.1"			stream nextPutSequence: self serviceContext;	"IOP::ServiceContextList  service_context; 13.6.7"				nextPutUnsignedLong: self requestId;	"unsigned long  request_id"				"enum ReplyStatusType_1_0 {NO_EXCEPTION, USER_EXCEPTION, ...}"				nextPutUnsignedLong: self replyStatus ] "ReplyStatusType_1_0  reply_status; 15.4.3.1"		ifFalse: [ "GIOP 1.2, ..."			stream nextPutUnsignedLong: self requestId;	"unsigned long  request_id"				"enum ReplyStatusType_1_2 {NO_EXCEPTION, USER_EXCEPTION, ...}"				nextPutUnsignedLong: self replyStatus;	"ReplyStatusType_1_2  reply_status; 15.4.3.1"				nextPutSequence: self serviceContext ].	"IOP::ServiceContextList  service_context; 13.6.7"</body></methods><methods><class-id>Opentalk.GIOPReply</class-id> <category>accessing</category><body package="Opentalk-IIOP">reply	^reply</body><body package="Opentalk-IIOP">reply: anObject	reply := anObject</body><body package="Opentalk-IIOP">requestId	^requestId</body><body package="Opentalk-IIOP">requestId: anObject	requestId := anObject</body><body package="Opentalk-IIOP">serviceContext	^serviceContext ifNil: [ OrderedCollection new ]</body><body package="Opentalk-IIOP">serviceContext: contexts	serviceContext := contexts asOrderedCollection</body></methods><methods><class-id>Opentalk.GIOPReply</class-id> <category>printing</category><body package="Opentalk-IIOP">printOn: aStream	super printOn: aStream.	aStream		nextPut: $[;		print: requestId;		nextPutAll: ']('.	self printReplyOn: aStream.	aStream nextPut: $)</body><body package="Opentalk-IIOP">printReplyOn: aStream	self replyStatusName printOn: aStream</body></methods><methods><class-id>Opentalk.GIOPReply</class-id> <category>accessing - status</category><body package="Opentalk-IIOP">LOCATION_FORWARD: anIIOPObjRef	replyStatus := 3.	reply := anIIOPObjRef</body><body package="Opentalk-IIOP">SYSTEM_EXCEPTION: aSystemException	replyStatus := 2.	reply := aSystemException</body><body package="Opentalk-IIOP">replyStatus	^replyStatus ifNil: [0] "default to no exception"</body><body package="Opentalk-IIOP">replyStatus: anObject	replyStatus := anObject</body><body package="Opentalk-IIOP">replyStatusName	^#(	NO_EXCEPTION		USER_EXCEPTION		SYSTEM_EXCEPTION		LOCATION_FORWARD		LOCATION_FORWARD_PERM		NEEDS_ADDRESSING_MODE	) at: self replyStatus + 1</body></methods><methods><class-id>Opentalk.GIOPReply</class-id> <category>testing</category><body package="Opentalk-IIOP">isLocationForward	^replyStatus = 3</body><body package="Opentalk-IIOP">isLocationForwardPerm	^replyStatus = 4</body><body package="Opentalk-IIOP">isNeedsAddressingMode	^replyStatus = 5</body><body package="Opentalk-IIOP">isNoException	^replyStatus = 0</body><body package="Opentalk-IIOP">isSystemException	^replyStatus = 2</body><body package="Opentalk-IIOP">isUserException	^replyStatus = 1</body></methods><methods><class-id>Opentalk.GIOPReply class</class-id> <category>accessing</category><body package="Opentalk-IIOP">msgType	^1</body></methods><methods><class-id>Opentalk.IOPTaggedComponent</class-id> <category>private</category><body package="Opentalk-IIOP">componentDataFrom: aCDRStream	aCDRStream nextEncapsulatedInOctets: [ :stream |		 self readComponentDataFrom: stream ]</body><body package="Opentalk-IIOP">componentDataOn: aCDRStream	componentData		ifNil: [ aCDRStream nextPutEncapsulatedInOctets: [ :stream |				self writeComponentDataOn: stream ] ]		ifNotNil: [ aCDRStream nextPutAll: componentData ]</body><body package="Opentalk-IIOP">readComponentDataFrom: aCDRStream 	self subclassResponsibility</body><body package="Opentalk-IIOP">writeComponentDataOn: aCDRStream 	self subclassResponsibility</body></methods><methods><class-id>Opentalk.IOPTaggedComponent</class-id> <category>accessing</category><body package="Opentalk-IIOP">componentData	^componentData ifNil: [ | stream |		stream := CDRStream on: (ByteArray new: 10).		self componentDataOn: stream.		componentData := stream contents ]</body><body package="Opentalk-IIOP">componentData: aByteArray	componentData := aByteArray.	self componentDataFrom: (CDRStream with: aByteArray) reset</body><body package="Opentalk-IIOP">tag	^self class tag</body><body package="Opentalk-IIOP">tag: aSmallInteger	self tag = aSmallInteger ifFalse: [ self error: 'Cannot change the tag!' ]</body></methods><methods><class-id>Opentalk.IOPTaggedComponent</class-id> <category>printing</category><body package="Opentalk-IIOP">printOn: aStream	aStream		nextPut: $(;		print: self tag;		nextPut: $)</body></methods><methods><class-id>Opentalk.IOPTaggedComponent</class-id> <category>marshaling</category><body package="Opentalk-IIOP">cdrReadFrom: aCDRStream	self componentDataFrom: aCDRStream</body><body package="Opentalk-IIOP">cdrWriteOn: aCDRStream	aCDRStream nextPutUnsignedLong: self tag.	self componentDataOn: aCDRStream</body></methods><methods><class-id>Opentalk.IOPTaggedComponent class</class-id> <category>instance creation</category><body package="Opentalk-IIOP">tag: aSmallInteger	^(self componetTypeFor: aSmallInteger) new tag: aSmallInteger</body></methods><methods><class-id>Opentalk.IOPTaggedComponent class</class-id> <category>accessing-tag map</category><body package="Opentalk-IIOP">buildTagMap	| maxTag classes |	classes := IOPTaggedComponent allSubclasses.	maxTag := classes inject: 0 into: [ :max :cl | (cl tag ifNil: [0]) max: max ].	^classes		inject: (Array new: maxTag withAll: IOPUnknownComponent)		into: [ :map :cl |			cl tag ifNotNil: [ :tag | tag isZero ifFalse: [ map at: tag put: cl ] ].			map ]</body><body package="Opentalk-IIOP">componetTypeFor: aSmallInteger	| map |	aSmallInteger = 0 ifTrue: [^IOPORBType].	map := self tagMap.	^aSmallInteger &gt; map size		ifTrue: [IOPUnknownComponent]		ifFalse: [map at: aSmallInteger]</body><body package="Opentalk-IIOP">tagMap	^TagMap ifNil: [ TagMap := self buildTagMap ]</body></methods><methods><class-id>Opentalk.IOPTaggedComponent class</class-id> <category>accessing</category><body package="Opentalk-IIOP">tag	^nil</body></methods><methods><class-id>Opentalk.IOPTaggedComponent class</class-id> <category>marshaling</category><body package="Opentalk-IIOP">cdrReadFrom: aCDRStream	^(self tag: aCDRStream nextUnsignedLong)		cdrReadFrom: aCDRStream</body></methods><methods><class-id>Opentalk.GIOPCloseConnection class</class-id> <category>accessing</category><body package="Opentalk-IIOP">msgType	^5</body></methods><methods><class-id>Opentalk.IOPUnknownContext</class-id> <category>accessing</category><body package="Opentalk-IIOP">tag	^tag</body><body package="Opentalk-IIOP">tag: anInteger	tag := anInteger</body></methods><methods><class-id>Opentalk.IOPUnknownContext</class-id> <category>marshaling</category><body package="Opentalk-IIOP">cdrReadFrom: aCDRStream	contextData := aCDRStream nextOctetSequence</body><body package="Opentalk-IIOP">cdrWriteOn: aCDRStream	aCDRStream		nextPutUnsignedLong: self tag;		nextPutOctetSequence: contextData</body></methods><methods><class-id>Opentalk.IOPUnknownContext</class-id> <category>printing</category><body package="Opentalk-IIOP">printOn: aStream	aStream nextPutAll: 'ServiceContext'.	super printOn: aStream</body></methods><methods><class-id>Opentalk.IOPCodeSets</class-id> <category>comparing</category><body package="Opentalk-IIOP">= codeSets	^	self class = codeSets class and: [		self charNativeSet = codeSets charNativeSet and: [		self charConversionSets = codeSets charConversionSets and: [		self wcharNativeSet = codeSets wcharNativeSet and: [		self wcharConversionSets = codeSets wcharConversionSets ] ] ] ]</body><body package="Opentalk-IIOP">hash	^self charNativeSet hash bitXor: self wcharNativeSet hash</body></methods><methods><class-id>Opentalk.IOPCodeSets</class-id> <category>accessing</category><body package="Opentalk-IIOP">charConversionSets	^charConversionSets</body><body package="Opentalk-IIOP">charConversionSets: integers	charConversionSets := integers</body><body package="Opentalk-IIOP">charNativeSet	^charNativeSet</body><body package="Opentalk-IIOP">charNativeSet: aSmallInteger	charNativeSet := aSmallInteger</body><body package="Opentalk-IIOP">wcharConversionSets	^wcharConversionSets</body><body package="Opentalk-IIOP">wcharConversionSets: integers	wcharConversionSets := integers</body><body package="Opentalk-IIOP">wcharNativeSet	^wcharNativeSet</body><body package="Opentalk-IIOP">wcharNativeSet: aSmallInteger	wcharNativeSet := aSmallInteger</body></methods><methods><class-id>Opentalk.IOPCodeSets</class-id> <category>private</category><body package="Opentalk-IIOP">readComponentDataFrom: aCDRStream 	self	charNativeSet: aCDRStream nextUnsignedLong;		charConversionSets: aCDRStream nextUnsignedLongs;		wcharNativeSet: aCDRStream nextUnsignedLong;		wcharConversionSets: aCDRStream nextUnsignedLongs</body><body package="Opentalk-IIOP">writeComponentDataOn: aCDRStream 	aCDRStream		"typedef unsigned long  CodeSetId"		"struct CodeSetComponent"		nextPutUnsignedLong: self charNativeSet; 	"CodeSetId  native_code_set"		nextPutUnsignedLongs: self charConversionSets; 	"sequence&lt;CodeSetId&gt;  conversion_code_sets"		"struct CodeSetComponent"		nextPutUnsignedLong: self wcharNativeSet; 	"CodeSetId  native_code_set"		nextPutUnsignedLongs: self wcharConversionSets 	"sequence&lt;CodeSetId&gt;  conversion_code_sets"</body></methods><methods><class-id>Opentalk.IOPCodeSets</class-id> <category>services</category><body package="Opentalk-IIOP">cncs: cncs cccs: cccs sncs: sncs sccs: sccs fallback: fbcs	cncs = sncs ifTrue: [^cncs].	(cccs includes: sncs) ifTrue: [^sncs].	(sccs includes: cncs) ifTrue: [^cncs].	^sccs		detect: [ :cs | cccs includes: cs ]		ifNone: [ (self isCompatible: cncs with: sncs)				ifTrue: [ fbcs ]				ifFalse: [ nil ] ]</body><body package="Opentalk-IIOP">isCompatible: cs1 with: cs2	"need to fill in the compatiblity check"	^true</body><body package="Opentalk-IIOP">isNull	^charNativeSet isNil and: [ charConversionSets isNil and: [ wcharNativeSet isNil and: [ wcharConversionSets isNil ] ] ]</body><body package="Opentalk-IIOP">negotiateWith: serverCodeSets"Perform the client side code set negotiation algorithm. 13.10.2.6 Code Set Negotiation (CORBA 2.6)	serverCodeSets &lt;IOPCodeSets&gt;	^&lt;IOPCodeSet&gt;"	| tcsc tcsw |	tcsc := self			cncs: self charNativeSet			cccs: self charConversionSets			sncs: serverCodeSets charNativeSet			sccs: serverCodeSets charConversionSets			fallback: "(self codeSetForName: 'UTF-8')" 83951617.	tcsw := self			cncs: self wcharNativeSet			cccs: self wcharConversionSets			sncs: serverCodeSets wcharNativeSet			sccs: serverCodeSets wcharConversionSets			fallback: "(self codeSetForName: 'UTF-16')" 65801.	^IOPCodeSet charData: tcsc wcharData: tcsw</body></methods><methods><class-id>Opentalk.IOPCodeSets</class-id> <category>printing</category><body package="Opentalk-IIOP">printOn: aStream	aStream nextPutAll: 'CODE_SETS'.	super printOn: aStream.	aStream nextPutAll: ': '.	self isNull ifTrue: [^aStream nextPutAll: 'null' ].	self class printCode: self charNativeSet on: aStream.	aStream nextPut: $(.	self charConversionSets		do: [ :set | self class printCode: set on: aStream ]		separatedBy: [ aStream nextPutAll: ', ' ].	aStream nextPutAll: ') &amp; '.	self class printCode: self wcharNativeSet on: aStream.	aStream nextPut: $(.	self wcharConversionSets		do: [ :set | self class printCode: set on: aStream ]		separatedBy: [ aStream nextPutAll: ', ' ].	aStream nextPut: $).</body></methods><methods><class-id>Opentalk.IOPCodeSets class</class-id> <category>accessing</category><body package="Opentalk-IIOP">charSetNameFor: aSmallInteger"	aSmallInteger 	&lt;SmallInteger&gt;	the char set id	^&lt;String | nil&gt; 	descriptive name"	^self charSetMap		at: aSmallInteger		ifAbsent: [nil]</body><body package="Opentalk-IIOP">charSetsFor: aSmallInteger"	aSmallInteger 	&lt;SmallInteger&gt;	the code set id	^&lt;Array of: SmallInteger | nil&gt; 	compatible char sets"	| org |	"X/Open UTF-8; UCS Transformation Format 8 (UTF-8)  0x05010001  0x1000"	aSmallInteger = 83951617 ifTrue: [^#(4096)].	org := aSmallInteger bitShift: -16.	self charSetMap size &lt; org ifTrue: [^nil].	^(self charSetMap at: org) ifNotNil: [ :map |		map at: (aSmallInteger bitAnd: 16rFFFF) ifAbsent: [ nil ] ]</body><body package="Opentalk-IIOP">checkedCodeSetForName: aString "Return a code set id based on the code set name. Signal an error if the code set name is not known.	aString 	&lt;String&gt;	the code set name	^&lt;SmallInteger&gt; 	code set id"	^(self codeSetForName: aString) 		ifNil: [self error: 'Unknown char set ' , aString]</body><body package="Opentalk-IIOP">codeSetForName: aString"	aString 	&lt;String&gt;	the code set name	^&lt;SmallInteger | nil&gt; 	code set id"	"X/Open UTF-8; UCS Transformation Format 8 (UTF-8)  0x05010001  0x1000"	aString = 'UTF-8' ifTrue: [^83951617].	^self reverseCodeSetMap at: aString ifAbsent: [ nil ]</body><body package="Opentalk-IIOP">codeSetNameFor: aSmallInteger"	aSmallInteger 	&lt;SmallInteger&gt;	the code set id	^&lt;String | nil&gt; 	short name"	| org |	aSmallInteger = 0 ifTrue: [^'0'].	"X/Open UTF-8; UCS Transformation Format 8 (UTF-8)  0x05010001  0x1000"	aSmallInteger = 83951617 ifTrue: [^'UTF-8'].	org := aSmallInteger bitShift: -16.	self codeSetMap size &lt; org ifTrue: [^nil].	^(self codeSetMap at: org) ifNotNil: [ :map |		map at: (aSmallInteger bitAnd: 16rFFFF) ifAbsent: [ nil ] ]</body><body package="Opentalk-IIOP">default	^default ifNil: [ default := self defaultValue ]</body><body package="Opentalk-IIOP">default: codeSets	default := codeSets</body><body package="Opentalk-IIOP">defaultValue	^self all</body><body package="Opentalk-IIOP">encoderNameFor: codeSet"Convert an OSF code set id to VW stream encoder symbol	codeSet &lt;Integer&gt; OSF code set id	^&lt;Symbol&gt;"	| nm end |	nm := self codeSetNameFor: codeSet.	end := nm indexOf: $:.	^(end isZero		ifTrue: [ nm ]		ifFalse: [ nm copyFrom: 1 to: end - 1 ]	) asSymbol</body><body package="Opentalk-IIOP">printCode: anInteger on: aStream	(self codeSetNameFor: anInteger)		ifNil: [ anInteger printOn: aStream paddedWith: 0 to: 8 base: 16 ]		ifNotNil: [ :set | aStream nextPutAll: set ]</body><body package="Opentalk-IIOP">tag	^1 "TAG_CODE_SETS"</body></methods><methods><class-id>Opentalk.IOPCodeSets class</class-id> <category>constants</category><body package="Opentalk-IIOP">charSetMap	^charSetMap ifNil: [ charSetMap := self newCharSetMap ]</body><body package="Opentalk-IIOP">codeSetMap	^codeSetMap ifNil: [ codeSetMap := self newCodeSetMap ]</body><body package="Opentalk-IIOP">compatibilityMap	^compatibilityMap ifNil: [ compatibilityMap := self newCompatibilityMap ]</body><body package="Opentalk-IIOP">knownCharSets	^self charSetMap values</body><body package="Opentalk-IIOP">knownCodeSets	^self reverseCodeSetMap keys</body><body package="Opentalk-IIOP">newCharSetMap"as extracted from ftp://ftp.opengroup.org/pub/code_set_registry/cs_registry1.2g"	"Comment format: # Identifier  Descriptive Name  Approx. Repertoire"	^Dictionary new		"PCS = Portable Character Set"		at: 1 put: 'PCS';	"# 0x0001  PCS  A-Za-z0-9 !""#$%&amp;'()*+,-/:;&lt;=&gt;?@[\]^_`{|}~"		at: 17 put: 'Latin1';	"# 0x0011  Latin-1  ISO 8859-1"		at: 18 put: 'Latin2';	"# 0x0012  Latin-2  ISO 8859-2"		at: 19 put: 'Latin3';	"# 0x0013  Latin-3  ISO 8859-3"		at: 20 put: 'Latin4';	"# 0x0014  Latin-4  ISO 8859-4"		at: 21 put: 'Cyrillic';	"# 0x0015  Cyrillic Script  ISO 8859-5"		at: 22 put: 'Arabic';	"# 0x0016  Arabic Script  ISO 8859-6"		at: 23 put: 'Greek';	"# 0x0017  Greek Script  ISO 8859-7"		at: 24 put: 'Hebrew';	"# 0x0018  Hebrew Script  ISO 8859-8"		at: 25 put: 'Latin5';	"# 0x0019  Latin-5  ISO 8859-9"		at: 26 put: 'Latin6';	"# 0x001a  Latin-6  ISO 8859-10"		at: 80 put: 'European';	"# 0x0050  European  ISO 6937"		at: 128 put: 'Japanese1';	"# 0x0080  Japanese1  JIS X0201"		at: 129 put: 'Japanese2';	"# 0x0081  Japanese2  JIS X0208"		at: 130 put: 'Japanese3';	"# 0x0082  Japanese3  JIS X0212"		at: 256 put: 'Korean1';	"# 0x0100  Korean1  KS C5601"		at: 257 put: 'Korean2';	"# 0x0101  Korean2  KS C5657"		at: 384 put: 'Taiwanese1';	"# 0x0180  Taiwanese1  CNS 11643 (1986)"		at: 385 put: 'Taiwanese2';	"# 0x0181  Taiwanese2  CNS 11643 (1992)"		at: 512 put: 'Thai';	"# 0x0200  Thai  TIS 620-2529"		at: 640 put: 'Indian';	"# 0x0280  Indian  LTD 37(1610)"		at: 768 put: 'Chinese';	"# 0x0300  Simplified Chinese  GB 2312-1980"		at: 4096 put: 'Universal';	"# 0x1000  Universal  ISO 10646-1"		yourself</body><body package="Opentalk-IIOP">newCodeSetMap"... as extracted from ftp://ftp.opengroup.org/pub/code_set_registry/cs_registry1.2g.Note that the encoding names chosen here should match (case insensitive) the names from	(((StreamEncoder encoderDirectory keys)))to be able to find corresponding encoder for a given code set.Since the names here must be distinct, but some encodings have several entries, an optional discriminator can be added after a colon $:.The encoder lookup (#encoderNameFor:) will ignore anything after the first colon in the name."	^(Array new: 13)		at: 1 put: ( "0x0001  ISO"			Dictionary new				at: 1 put: 'iso8859-1'; "ISO 8859-1:1987; Latin Alphabet No. 1; 0x00010001 0x0011"				at: 2 put: 'iso8859-2'; "ISO 8859-2:1987; Latin Alphabet No. 2  0x00010002  0x0012"				at: 3 put: 'iso8859-3'; "ISO 8859-3:1988; Latin Alphabet No. 3  0x00010003  0x0013"				at: 4 put: 'iso8859-4'; "ISO 8859-4:1988; Latin Alphabet No. 4  0x00010004  0x0014"				at: 5 put: 'iso8859-5'; "ISO 8859-5:1988; Latin-Cyrillic Alphabet  0x00010005  0x0015"				at: 6 put: 'iso8859-6'; "ISO 8859-6:1987; Latin-Arabic Alphabet  0x00010006  0x0016"				at: 7 put: 'iso8859-7'; "ISO 8859-7:1987; Latin-Greek Alphabet  0x00010007  0x0017"				at: 8 put: 'iso8859-8'; "ISO 8859-8:1988; Latin-Hebrew Alphabet  0x00010008  0x0018"				at: 9 put: 'iso8859-9'; "ISO/IEC 8859-9:1989; Latin Alphabet No. 5  0x00010009  0x0019"				at: 10 put: 'iso8859-10'; "ISO/IEC 8859-10:1992; Latin Alphabet No. 6  0x0001000a  0x001a"				at: 32 put: 'iso646'; "ISO 646:1991 IRV (International Reference Version)  0x00010020  0x0001"				at: 256 put: 'UCS-2:L1'; "ISO/IEC 10646-1:1993; UCS-2, Level 1  0x00010100  0x1000"				at: 257 put: 'UCS-2:L2'; "ISO/IEC 10646-1:1993; UCS-2, Level 2  0x00010101  0x1000"				at: 258 put: 'UCS-2:L3'; "ISO/IEC 10646-1:1993; UCS-2, Level 3  0x00010102  0x1000"				at: 260 put: 'UCS-4:L1'; "ISO/IEC 10646-1:1993; UCS-4, Level 1  0x00010104  0x1000"				at: 261 put: 'UCS-4:L2'; "ISO/IEC 10646-1:1993; UCS-4, Level 2  0x00010105  0x1000"				at: 262 put: 'UCS-4:L3'; "ISO/IEC 10646-1:1993; UCS-4, Level 3  0x00010106  0x1000"				at: 264 put: 'UTF-1';	"ISO/IEC 10646-1:1993; UTF-1, UCS Transformation Format 1  0x00010108  0x1000"				at: 265 put: 'UTF-16'; "ISO/IEC 10646-1:1993; UTF-16, UCS Transformation Format 16-bit form  0x00010109  0x1000"				yourself);		"0x0002  ECMA"		at: 3 put: ( "0x0003  JIS"			Dictionary new				at: 1 put: 'jisX0201'; "JIS X0201:1976; Japanese phonetic characters  0x00030001  0x0080"				at: 4 put: 'jisX0208:78'; "JIS X0208:1978 Japanese Kanji Graphic Characters  0x00030004  0x0081"				at: 5 put: 'jisX0208:83'; "JIS X0208:1983 Japanese Kanji Graphic Characters  0x00030005  0x0081"				at: 6 put: 'jisX0208:90'; "JIS X0208:1990 Japanese Kanji Graphic Characters  0x00030006  0x0081"				at: 10 put: 'jisX0212'; "JIS X0212:1990; Supplementary Japanese Kanji Graphic Chars  0x0003000a  0x0082"				at: 16 put: 'eucJP'; "JIS eucJP:1993; Japanese EUC  0x00030010  0x0011:0x0080:0x0081:0x0082"				yourself);		at: 4 put: ( "0x0004  KS"			Dictionary new				at: 1 put: 'ksC5601'; "KS C5601:1987; Korean Hangul and Hanja Graphic Characters  0x00040001  0x0100"				at: 2 put: 'ksC5657'; "KS C5657:1991; Supplementary Korean Graphic Characters  0x00040002  0x0101"				at: 10 put: 'eucKR'; "KS eucKR:1991; Korean EUC  0x0004000a  0x0011:0x0100:0x0101"				yourself);		at: 5 put: ( "0x0005  CNS"			Dictionary new				at: 1 put: 'cns11643:86'; "CNS 11643:1986; Taiwanese Hanzi Graphic Characters  0x00050001  0x0180"				at: 2 put: 'cns11643:92'; "CNS 11643:1992; Taiwanese Extended Hanzi Graphic Chars  0x00050002  0x0181"				at: 10 put: 'eucTW:91'; "CNS eucTW:1991; Taiwanese EUC  0x0005000a  0x0001:0x0180"				at: 16 put: 'eucTW:93'; "CNS eucTW:1993; Taiwanese EUC  0x00050010  0x0001:0x0180"				yourself);		"0x0006  ASMO"		"0x0007  ANSI"		"0x0008  DS"		"0x0009  DIN"		"0x000a  BSI"		at: 11 put: ( "0x000b  TISI"			Dictionary new				at: 1 put: 'tis620-2529'; "TIS 620-2529, Thai characters  0x000b0001  0x0200"				yourself);		"0x000c  IEC"		at: 13 put: ( "0x000d TTB"			Dictionary new				at: 1 put: 'ttbCCDC'; "TTB CCDC:1984; Chinese Code for Data Communications  0x000d0001  0x0180"				yourself);		yourself</body><body package="Opentalk-IIOP">newCompatibilityMap"Maps code sets to compatible char sets.Extracted from ftp://ftp.opengroup.org/pub/code_set_registry/cs_registry1.2g"	^(Array new: 13)		at: 1 put: ( "0x0001  ISO"			Dictionary new				at: 1 put: #(17); "ISO 8859-1:1987; Latin Alphabet No. 1; 0x00010001 0x0011"				at: 2 put: #(18); "ISO 8859-2:1987; Latin Alphabet No. 2  0x00010002  0x0012"				at: 3 put: #(19); "ISO 8859-3:1988; Latin Alphabet No. 3  0x00010003  0x0013"				at: 4 put: #(20); "ISO 8859-4:1988; Latin Alphabet No. 4  0x00010004  0x0014"				at: 5 put: #(21); "ISO 8859-5:1988; Latin-Cyrillic Alphabet  0x00010005  0x0015"				at: 6 put: #(22); "ISO 8859-6:1987; Latin-Arabic Alphabet  0x00010006  0x0016"				at: 7 put: #(23); "ISO 8859-7:1987; Latin-Greek Alphabet  0x00010007  0x0017"				at: 8 put: #(24); "ISO 8859-8:1988; Latin-Hebrew Alphabet  0x00010008  0x0018"				at: 9 put: #(25); "ISO/IEC 8859-9:1989; Latin Alphabet No. 5  0x00010009  0x0019"				at: 10 put: #(26); "ISO/IEC 8859-10:1992; Latin Alphabet No. 6  0x0001000a  0x001a"				at: 32 put: #(1); "ISO 646:1991 IRV (International Reference Version)  0x00010020  0x0001"				at: 256 put: #(4096); "ISO/IEC 10646-1:1993; UCS-2, Level 1  0x00010100  0x1000"				at: 257 put: #(4096); "ISO/IEC 10646-1:1993; UCS-2, Level 2  0x00010101  0x1000"				at: 258 put: #(4096); "ISO/IEC 10646-1:1993; UCS-2, Level 3  0x00010102  0x1000"				at: 260 put: #(4096); "ISO/IEC 10646-1:1993; UCS-4, Level 1  0x00010104  0x1000"				at: 261 put: #(4096); "ISO/IEC 10646-1:1993; UCS-4, Level 2  0x00010105  0x1000"				at: 262 put: #(4096); "ISO/IEC 10646-1:1993; UCS-4, Level 3  0x00010106  0x1000"				at: 264 put: #(4096); "ISO/IEC 10646-1:1993; UTF-1, UCS Transformation Format 1  0x00010108  0x1000"				at: 265 put: #(4096); "ISO/IEC 10646-1:1993; UTF-16, UCS Transformation Format 16-bit form  0x00010109  0x1000"				yourself);		"0x0002  ECMA"		at: 3 put: ( "0x0003  JIS"			Dictionary new				at: 1 put: #(128); "JIS X0201:1976; Japanese phonetic characters  0x00030001  0x0080"				at: 4 put: #(129); "JIS X0208:1978 Japanese Kanji Graphic Characters  0x00030004  0x0081"				at: 5 put: #(129); "JIS X0208:1983 Japanese Kanji Graphic Characters  0x00030005  0x0081"				at: 6 put: #(129); "JIS X0208:1990 Japanese Kanji Graphic Characters  0x00030006  0x0081"				at: 10 put: #(130); "JIS X0212:1990; Supplementary Japanese Kanji Graphic Chars  0x0003000a  0x0082"				at: 16 put: #(17 128 129 130); "JIS eucJP:1993; Japanese EUC  0x00030010  0x0011:0x0080:0x0081:0x0082"				yourself);		at: 4 put: ( "0x0004  KS"			Dictionary new				at: 1 put: #(256); "KS C5601:1987; Korean Hangul and Hanja Graphic Characters  0x00040001  0x0100"				at: 2 put: #(257); "KS C5657:1991; Supplementary Korean Graphic Characters  0x00040002  0x0101"				at: 10 put: #(17 256 267); "KS eucKR:1991; Korean EUC  0x0004000a  0x0011:0x0100:0x0101"				yourself);		at: 5 put: ( "0x0005  CNS"			Dictionary new				at: 1 put: #(384); "CNS 11643:1986; Taiwanese Hanzi Graphic Characters  0x00050001  0x0180"				at: 2 put: #(385); "CNS 11643:1992; Taiwanese Extended Hanzi Graphic Chars  0x00050002  0x0181"				at: 10 put: #(1 384); "CNS eucTW:1991; Taiwanese EUC  0x0005000a  0x0001:0x0180"				at: 16 put: #(1 384); "CNS eucTW:1993; Taiwanese EUC  0x00050010  0x0001:0x0180"				yourself);		"0x0006  ASMO"		"0x0007  ANSI"		"0x0008  DS"		"0x0009  DIN"		"0x000a  BSI"		at: 11 put: ( "0x000b  TISI"			Dictionary new				at: 1 put: #(512); "TIS 620-2529, Thai characters  0x000b0001  0x0200"				yourself);		"0x000c  IEC"		at: 13 put: ( "0x000d TTB"			Dictionary new				at: 1 put: #(384); "TTB CCDC:1984; Chinese Code for Data Communications  0x000d0001  0x0180"				yourself);		yourself</body><body package="Opentalk-IIOP">newReverseCodeSetMap	| map |	map := Dictionary new.	self codeSetMap		keysAndValuesDo: [ :org :sub |			sub ifNotNil: [				sub keysAndValuesDo: [ :id :nm || code |					code := (org bitShift: 16) bitOr: id.					map at: nm put: code ] ] ].	^map</body><body package="Opentalk-IIOP">reverseCodeSetMap	^reverseCodeSetMap ifNil: [ reverseCodeSetMap := self newReverseCodeSetMap ]</body></methods><methods><class-id>Opentalk.IOPCodeSets class</class-id> <category>sets</category><body package="Opentalk-IIOP">UTF	^self		charSets: #('UTF-8')		wcharSets: #('UTF-16')</body><body package="Opentalk-IIOP">all	^self		charSets: #('UTF-8' 'iso8859-1' 'iso8859-2' 'iso8859-3' 'iso8859-4' 'iso8859-5' 'iso8859-6' 'iso8859-7' 'iso8859-8' 'iso8859-9' 'iso8859-10')		wcharSets: #('UCS-2:L1' 'UTF-16')</body><body package="Opentalk-IIOP">null	^self new</body></methods><methods><class-id>Opentalk.IOPCodeSets class</class-id> <category>instance creation</category><body package="Opentalk-IIOP">charSets: charSets wcharSets: wcharSets"Allows to create an instance expressing code sets with ids or names. The first code set in the collection is the native code set.	charSets 	&lt;Array of: (SmallInteger | String)&gt; char code sets, native first	wcharSets &lt;Array of: (SmallInteger | String)&gt; wchar code sets, native first	^&lt;IOPCodeSets&gt;"	| cids wcids |	cids := charSets collect: [ :cs |			cs isInteger				ifTrue: [cs]				ifFalse: [ self checkedCodeSetForName: cs ] ].	wcids := wcharSets collect: [ :cs |			cs isInteger				ifTrue: [cs]				ifFalse: [ self checkedCodeSetForName: cs ] ].	^self new		charNativeSet: cids first;		charConversionSets: (cids copyFrom: 2 to: cids size);		wcharNativeSet: wcids first;		wcharConversionSets: (wcids copyFrom: 2 to: wcids size);		yourself</body></methods><methods><class-id>Opentalk.IIOPProfile</class-id> <category>accessing</category><body package="Opentalk-IIOP">accessPoint	^IPSocketAddress hostName: self host port: self port</body><body package="Opentalk-IIOP">asObjectKey	^self objectKey asByteArray</body><body package="Opentalk-IIOP">components	^components ifNil: [ #() ]</body><body package="Opentalk-IIOP">components: taggedComponents	components := taggedComponents</body><body package="Opentalk-IIOP">host	^host</body><body package="Opentalk-IIOP">host: aString	host := aString</body><body package="Opentalk-IIOP">majorVersion	^majorVersion</body><body package="Opentalk-IIOP">majorVersion: aSmallInteger	majorVersion := aSmallInteger</body><body package="Opentalk-IIOP">minorVersion	^minorVersion</body><body package="Opentalk-IIOP">minorVersion: aSmallInteger	minorVersion := aSmallInteger</body><body package="Opentalk-IIOP">objectKey	^objectKey</body><body package="Opentalk-IIOP">objectKey: aByteArray	objectKey := aByteArray</body><body package="Opentalk-IIOP">port	^port</body><body package="Opentalk-IIOP">port: aSmallInteger	port := aSmallInteger</body></methods><methods><class-id>Opentalk.IIOPProfile</class-id> <category>comparing</category><body package="Opentalk-IIOP">= anIIOPProfile	^	self class = anIIOPProfile class and: [		self objectKey = anIIOPProfile objectKey and: [		self host = anIIOPProfile host and: [		self port = anIIOPProfile port ] ] ]</body><body package="Opentalk-IIOP">hash	^(self objectKey hash bitXor: self host hash) bitXor: self port</body></methods><methods><class-id>Opentalk.IIOPProfile</class-id> <category>testing</category><body package="Opentalk-IIOP">isSupported	^true</body></methods><methods><class-id>Opentalk.IIOPProfile</class-id> <category>marshaling</category><body package="Opentalk-IIOP">writeTargetAddressOn: aCDRStream"used by GIOPRequest"	"union TargetAddress switch (AddressingDisposition)"	aCDRStream nextPutShort: 1.	"typedef short  AddressingDisposition"	self cdrWriteOn: aCDRStream "case ProfileAddr:  IOP::TaggedProfile  profile"</body></methods><methods><class-id>Opentalk.IIOPProfile</class-id> <category>printing</category><body package="Opentalk-IIOP">printOn: aStream	aStream nextPutAll: 'INTERNET_IOP'.	super printOn: aStream.	aStream nextPutAll: ': '.	self objectKey do: [ :b | b printOn: aStream base: 16 ].	aStream nextPut: $@;		nextPutAll: self host;		nextPut: $:;		print: self port;		nextPutAll: '; IIOP ';		print: self majorVersion;		nextPut: $.;		print: self minorVersion;		nextPutAll: ' ('.	self components		do: [ :c | c printOn: aStream ]		separatedBy: [ aStream nextPutAll: ', ' ].	aStream nextPut: $)</body></methods><methods><class-id>Opentalk.IIOPProfile</class-id> <category>private</category><body package="Opentalk-IIOP">marshalProfileDataOn: aCDRStream	aCDRStream		nextPut: self majorVersion;		nextPut: self minorVersion;		nextPutASCIIString: self host;		nextPutUnsignedShort: self port;		nextPutOctetSequence: self objectKey.	self minorVersion &gt; 0 ifTrue: [		aCDRStream nextPutSequence: self components ]</body><body package="Opentalk-IIOP">unmarshalProfileDataFrom: aCDRStream	majorVersion := aCDRStream next.	minorVersion := aCDRStream next.	host := aCDRStream nextASCIIString.	port := aCDRStream nextUnsignedShort.	objectKey := aCDRStream nextOctetSequence.	self minorVersion &gt; 0 ifTrue: [		self components: (aCDRStream nextSequenceOf: IOPTaggedComponent) ]</body></methods><methods><class-id>Opentalk.IIOPProfile class</class-id> <category>constants</category><body package="Opentalk-IIOP">tag	^0 "TAG_INTERNET_IOP"</body></methods><methods><class-id>Opentalk.IOPORBType</class-id> <category>private</category><body package="Opentalk-IIOP">readComponentDataFrom: aCDRStream 	self id: aCDRStream nextUnsignedLong</body><body package="Opentalk-IIOP">writeComponentDataOn: aCDRStream 	aCDRStream nextPutUnsignedLong: self id</body></methods><methods><class-id>Opentalk.IOPORBType</class-id> <category>accessing</category><body package="Opentalk-IIOP">id	^id</body><body package="Opentalk-IIOP">id: aSmallInteger	id := aSmallInteger</body></methods><methods><class-id>Opentalk.IOPORBType</class-id> <category>comparing</category><body package="Opentalk-IIOP">= anORBType	^self class = anORBType class and: [		self id = anORBType id ]</body><body package="Opentalk-IIOP">hash	^self id hash</body></methods><methods><class-id>Opentalk.IOPORBType</class-id> <category>printing</category><body package="Opentalk-IIOP">printOn: aStream	| bytes |	bytes := ByteArray new: 4.	(4 to: 1 by: -1) inject: id into: [ :nr :i |		bytes at: i put: (nr bitAnd: 255).		nr bitShift: -8 ]. 	aStream nextPutAll: 'ORB_TYPE'.	super printOn: aStream.	aStream nextPutAll: ': ';		nextPutAll: (bytes copyFrom: 1 to: 3) asString;		print: bytes last;		nextPut: $/.	self id printOn: aStream base: 16</body></methods><methods><class-id>Opentalk.IOPORBType class</class-id> <category>accessing</category><body package="Opentalk-IIOP">DST"We've got 128 component tags from OMG: 0x44535400 - 0x4453547F  ('DST\x00' - 'DST\x7f')Let's start from the end of the range for OpentalkCORBA"	| id |	id := 'DST' asByteArray, #[16r7F].	id := id inject: 0 into: [ :t :b | (t bitShift: 8) bitOr: b ].	^self id: id</body><body package="Opentalk-IIOP">default	^default ifNil: [ default := self defaultValue ]</body><body package="Opentalk-IIOP">defaultValue	^self DST</body><body package="Opentalk-IIOP">tag	^0 "TAG_ORB_TYPE"</body></methods><methods><class-id>Opentalk.IOPORBType class</class-id> <category>instance creation</category><body package="Opentalk-IIOP">id: aSmallInteger	^self new id: aSmallInteger</body></methods><methods><class-id>Opentalk.IIOPObjRef</class-id> <category>comparing</category><body package="Opentalk-IIOP">= anIIOPObjRef	^self class = anIIOPObjRef class and: [		self oid = anIIOPObjRef oid and: [			self accessPoint = anIIOPObjRef accessPoint ] ]</body><body package="Opentalk-IIOP">hash	^self oid hash bitXor: self accessPoint hash</body></methods><methods><class-id>Opentalk.IIOPObjRef</class-id> <category>accessing</category><body package="Opentalk-IIOP">accessPoint	^accessPoint ifNil: [		self profile ifNotNil: [ accessPoint := self profile accessPoint ] ]</body><body package="Opentalk-IIOP">interfaceId	^interfaceId</body><body package="Opentalk-IIOP">interfaceId: anIfcId	| id |	id := anIfcId isCharacters			ifTrue: [RepositoryId fromString: anIfcId]			ifFalse: [anIfcId].	interfaceId = id  ifFalse: [		interface := nil.		interfaceId := id ]</body><body package="Opentalk-IIOP">oid"Integral version of the OID	^&lt;Integer&gt;"	^oid ifNil: [		self profile ifNotNil: [			self setOIDFromBytes: self profile objectKey.			oid ] ]</body><body package="Opentalk-IIOP">oidBytes"byte version of the OID.	^&lt;ByteArray&gt;"	^self oid ifNotNil: [ :nr |		nr class = LargePositiveInteger			ifTrue: [ nr copy changeClassTo: ByteArray ]			ifFalse: [ | bytes |				bytes := ByteArray new: nr digitLength.				(1 to: bytes size)					inject: nr					into: [ :t :i | bytes at: i put: (t bitAnd: 255). t bitShift: -8 ].				bytes ] ]</body><body package="Opentalk-IIOP">profile	^profile ifNil: [		profile := profiles				ifNil: [ oid						ifNil: [ self noObjectKey ]						ifNotNil: [							(accessPoint notNil and: [ oid notNil ])								ifTrue: [ IIOPProfile new										majorVersion: 1;										minorVersion: 2;										host: self accessPoint hostAddressString;										port: self accessPoint port;										objectKey: self oidBytes  ]								ifFalse: [nil] ] ]				ifNotNil: [ profiles						detect: [ :p | p isSupported ]						ifNone: [ self noSupportedProtocol ] ] ]</body><body package="Opentalk-IIOP">profile: aTaggedProfile	profile := aTaggedProfile</body><body package="Opentalk-IIOP">profiles	^profiles ifNil: [		profiles := Array with: self profile ]</body><body package="Opentalk-IIOP">profiles: taggedProfiles	profiles := taggedProfiles</body></methods><methods><class-id>Opentalk.IIOPObjRef</class-id> <category>marshaling</category><body package="Opentalk-IIOP">cdrReadFrom: aCDRStream	self interfaceId: aCDRStream nextRepositoryId.	self profiles: (aCDRStream nextSequenceOf: IOPTaggedProfile)</body><body package="Opentalk-IIOP">cdrWriteOn: aCDRStream	aCDRStream		nextPutRepositoryId: self interfaceId;		nextPutSequence: self profiles</body><body package="Opentalk-IIOP">writeTargetAddressOn: aCDRStream"used by GIOPRequest"	| index |	"union TargetAddress switch (AddressingDisposition)"	aCDRStream nextPutShort: 2.	"typedef short  AddressingDisposition"	"case ReferenceAddr:  IORAddressingInfo ior"	index := self profiles indexOf: self profile.	aCDRStream nextPutUnsignedLong: index - 1. "unsigned long  selected_profile_index"	self cdrWriteOn: aCDRStream "IOP::IOR  ior"</body></methods><methods><class-id>Opentalk.IIOPObjRef</class-id> <category>printing</category><body package="Opentalk-IIOP">printOn: aStream 	aStream nextPutAll: (#IIOPObjRef &lt;&lt; #opentalk &gt;&gt; 'IIOPObjRef') asString; nextPut: $&lt;.	self printAccessInfoOn: aStream.	aStream nextPut: $&gt;</body></methods><methods><class-id>Opentalk.IIOPObjRef</class-id> <category>converting</category><body package="Opentalk-IIOP">asIIOPObjRefFor: anIIOPTransport	^self</body></methods><methods><class-id>Opentalk.IIOPObjRef</class-id> <category>accessing - extended</category><body package="Opentalk-IIOP">asObjectKey	^self oidBytes</body><body package="Opentalk-IIOP">codeSets	^self profile components		detect: [ :tc | tc class = IOPCodeSets ]		ifNone: [ nil ]</body><body package="Opentalk-IIOP">getOpInfo: opSelector in: anInterfaceRepository	| opInfo interfaceObject |      	(interfaceObject := self interfaceIn: anInterfaceRepository) isNil		ifTrue: [^Opentalk.DSTORBObject intfReposError: 0].	(opInfo := interfaceObject findOpBySelector: opSelector) isNil 		" DST:		and: [(opInfo := (anInterfaceRepository metaObjectOf: #'SmalltalkSpecific::SmalltalkObject')					findOpBySelector: opSelector) isNil"		ifTrue: [^Opentalk.DSTORBObject badOperationError: 0].	^opInfo</body><body package="Opentalk-IIOP">interfaceIn: anInterfaceRepository	interface isNil ifTrue: [		interface := anInterfaceRepository lookupId: interfaceId ].	^interface</body><body package="Opentalk-IIOP">releaseInterface	interface := nil</body></methods><methods><class-id>Opentalk.IIOPObjRef</class-id> <category>initialize</category><body package="Opentalk-IIOP">initOIDBytes: bytes accessPoint: addr	self setOIDFromBytes: bytes.	accessPoint := addr.</body></methods><methods><class-id>Opentalk.IIOPObjRef</class-id> <category>private</category><body package="Opentalk-IIOP">setOIDFromBytes: bytes"	bytes &lt;ByteArray | ByteString | ByteSymbol&gt;"	oid := bytes size &gt; 4			ifTrue: [ bytes copy changeClassTo: LargePositiveInteger ]			ifFalse: [ bytes asByteArray inject: 0 into: [ :t :b | (t bitShift: 8) bitOr: b ] ]</body></methods><methods><class-id>Opentalk.IIOPObjRef class</class-id> <category>marshaling</category><body package="Opentalk-IIOP">cdrReadFrom: aCDRStream	| ref |	ref := self new cdrReadFrom: aCDRStream.	^(ref interfaceId isNil and: [ ref profiles isEmpty ])		ifTrue: [nil]		ifFalse: [ref]</body><body package="Opentalk-IIOP">readTargetAddressFrom: aCDRStream"used by GIOPMessage"	| disposition |	"union TargetAddress switch (AddressingDisposition)"	disposition := aCDRStream nextShort.	"typedef short  AddressingDisposition"	disposition = 0 ifTrue: [ ^aCDRStream nextOctetSequence ].	"case KeyAddr:  sequence &lt;octet&gt;  object_key"	disposition = 1 ifTrue: [ ^IOPTaggedProfile cdrReadFrom: aCDRStream ].	"case ProfileAddr:  IOP::TaggedProfile profile"	disposition = 2 ifTrue: [ | index ior | "case ReferenceAddr:  IORAddressingInfo ior"		index := aCDRStream nextUnsignedLong.	"unsigned long  selected_profile_index"		ior := self cdrReadFrom: aCDRStream.		ior profile: (ior profiles at: index + 1).		^ior ].  "IOP::IOR  ior"</body></methods><methods><class-id>Opentalk.IIOPObjRef class</class-id> <category>instance creation</category><body package="Opentalk-IIOP">newOn: accessPoint oid: anOID interfaceId: anIfcId"	accessPoint &lt;IPSocketAddress&gt;	anOID &lt;ByteArray | ByteString | ByteSymbol&gt;	anIfcId &lt;ByteString | RepositoryId&gt;	^&lt;IIOPObjRef&gt;"	| ref |	ref := anOID isInteger			ifTrue: [ self newOn: accessPoint oid: anOID ]			ifFalse: [ self newOn: accessPoint oidBytes: anOID ].	^ref	interfaceId: anIfcId;		yourself</body><body package="Opentalk-IIOP">newOn: accessPoint oidBytes: bytes"	accessPoint &lt;IPSocketAddress&gt;	bytes &lt;ByteArray | ByteString | ByteSymbol&gt;	^&lt;IIOPObjRef&gt;"	^self new initOIDBytes: bytes accessPoint: accessPoint</body></methods><methods><class-id>Opentalk.IOPCodeSet</class-id> <category>private</category><body package="Opentalk-IIOP">readContextDataFrom: aCDRStream 	self charData: aCDRStream nextUnsignedLong.	self wcharData: aCDRStream nextUnsignedLong</body><body package="Opentalk-IIOP">writeContextDataOn: aCDRStream 	aCDRStream		nextPutUnsignedLong: self charData;		nextPutUnsignedLong: self wcharData</body></methods><methods><class-id>Opentalk.IOPCodeSet</class-id> <category>accessing</category><body package="Opentalk-IIOP">charData	^charData</body><body package="Opentalk-IIOP">charData: anInteger	charData := anInteger</body><body package="Opentalk-IIOP">wcharData	^wcharData</body><body package="Opentalk-IIOP">wcharData: anInteger	wcharData := anInteger</body></methods><methods><class-id>Opentalk.IOPCodeSet</class-id> <category>comparing</category><body package="Opentalk-IIOP">= aCodeSet	^self class = aCodeSet class and: [		charData = aCodeSet charData and: [			wcharData = aCodeSet wcharData ] ]</body><body package="Opentalk-IIOP">hash	^charData bitXor: wcharData</body></methods><methods><class-id>Opentalk.IOPCodeSet</class-id> <category>printing</category><body package="Opentalk-IIOP">printOn: aStream	aStream nextPutAll: 'CodeSet'.	super printOn: aStream.	aStream nextPutAll: ': '.	IOPCodeSets printCode: self charData on: aStream.	aStream nextPutAll: ' &amp; '.	IOPCodeSets printCode: self wcharData on: aStream</body></methods><methods><class-id>Opentalk.IOPCodeSet</class-id> <category>services</category><body package="Opentalk-IIOP">charEncoder"Create a stream encoder corresponding to charData	^&lt;StreamEncoer&gt;"	^self class encoderFor: charData</body><body package="Opentalk-IIOP">wcharEncoder"Create a stream encoder corresponding to wcharData	^&lt;StreamEncoer&gt;"	^self class encoderFor: wcharData</body></methods><methods><class-id>Opentalk.IOPCodeSet class</class-id> <category>instance creation</category><body package="Opentalk-IIOP">charData: charInteger wcharData: wcharInteger	^self new		charData: charInteger;		wcharData: wcharInteger;		yourself</body><body package="Opentalk-IIOP">charSet: charSet wcharSet: wcharSet"Allows to create an instance expressing code sets with ids or names.	charSet 	&lt;SmallInteger | String&gt; char code set	wcharSet &lt;SmallInteger | String&gt; wchar code set	^&lt;IOPCodeSet&gt;"	^self		charData: (charSet isInteger					ifTrue: [charSet]					ifFalse: [ self checkedCodeSetForName: charSet ])		wcharData: (wcharSet isInteger					ifTrue: [wcharSet]					ifFalse: [ self checkedCodeSetForName: wcharSet ])</body><body package="Opentalk-IIOP">default	^self		charData: 16r00010001 "ISO 8859-1"		wcharData:  16r00010109 "UTF-16"</body><body package="Opentalk-IIOP">fallback	^self		charData: 16r05010001 "UTF-8"		wcharData: 16r00010109 "UTF-16"</body></methods><methods><class-id>Opentalk.IOPCodeSet class</class-id> <category>accessing</category><body package="Opentalk-IIOP">charSetNameFor: aSmallInteger"	aSmallInteger 	&lt;SmallInteger&gt;	the char set id	^&lt;String | nil&gt; 	descriptive name"	^IOPCodeSets charSetNameFor: aSmallInteger</body><body package="Opentalk-IIOP">charSetsFor: aSmallInteger"	aSmallInteger 	&lt;SmallInteger&gt;	the code set id	^&lt;Array of: SmallInteger | nil&gt; 	compatible char sets"	^IOPCodeSets charSetsFor: aSmallInteger</body><body package="Opentalk-IIOP">checkedCodeSetForName: aString"Return a code set id based on the code set name. Signal an error if the code set name is not known.	aString 	&lt;String&gt;	the code set name	^&lt;SmallInteger&gt; 	code set id"	^IOPCodeSets checkedCodeSetForName: aString</body><body package="Opentalk-IIOP">codeSetNameFor: aSmallInteger"	aSmallInteger 	&lt;SmallInteger&gt;	the code set id	^&lt;String | nil&gt; 	short name"	^IOPCodeSets codeSetNameFor: aSmallInteger</body><body package="Opentalk-IIOP">encoderFor: codeSet"Create a stream encoder corresponding to codeSet	codeSet &lt;Integer&gt; OSF code set id	^&lt;StreamEncoer&gt;"	^StreamEncoder new: (self encoderNameFor: codeSet)</body><body package="Opentalk-IIOP">encoderNameFor: codeSet"Convert an OSF code set id to VW stream encoder symbol	codeSet &lt;Integer&gt; OSF code set id	^&lt;Symbol&gt;"	^IOPCodeSets encoderNameFor: codeSet</body><body package="Opentalk-IIOP">tag	^1 "CodeSets"</body></methods><methods><class-id>Opentalk.IIOPTransport</class-id> <category>private</category><body package="Opentalk-IIOP">checkHeader	(self isValidHeader: readBuffer) ifFalse: [		OtEProtocol raiseSignal: (#ProtocolMismatch &lt;&lt; #opentalk &gt;&gt; 'Protocol Mismatch')].</body><body package="Opentalk-IIOP">createApplicationPackageFrom: aTransportPkg	^marshaler unmarshalGIOPPayloadFrom: aTransportPkg</body><body package="Opentalk-IIOP">createTransportPackageFrom: anApplicationPkg	| transportPkg |	transportPkg :=		anApplicationPkg			buildGIOPMessageOn: writeBuffer			for: self.	transportPkg :=		marshaler			marshalGIOPPayloadOf: anApplicationPkg			into: transportPkg.	^transportPkg</body><body package="Opentalk-IIOP">handleIncomingMessageError: anException	super handleIncomingMessageError: anException.	(OtECommunicationFailure handles: anException)		"If this is a connection failure, let's skip the connection closing handshake"		ifTrue: [self doStop]		ifFalse: [self stop]</body><body package="Opentalk-IIOP">handleLocationForward: aLocationForward	| reply request |	reply := aLocationForward parameter.	request := self requestById: reply requestId.	request isNil		ifTrue: [ reply receivedOrphanReplyIn: self ]		ifFalse: [ request target: reply reply.			self sendPackage: request ]</body><body package="Opentalk-IIOP">handlingIncomingMessage"Get the next income package and dispatches it."	[	[	self handleIncomingMessage: self nextPackage		]	on: LocationForward			do: [ :ex | self handleLocationForward: ex ]	]	on: Error		do: [:ex | self handleIncomingMessageError: ex]</body><body package="Opentalk-IIOP">isValidHeader: aBuffer	^aBuffer magic = "'GIOP' asByteArray" #[71 73 79 80] and: [		aBuffer majorVersion = 1 and: [			aBuffer minorVersion = self minorVersion ] ]</body><body package="Opentalk-IIOP">negotiateCodeSetWith: anIOR	marshaler negotiateCodeSetWith: anIOR</body><body package="Opentalk-IIOP">nextBuffer: aBuffer size: aSize startingAt: position	^[	| readSize chunkSize |		readSize := 0.		chunkSize := 100. "Just to let us into the first iteration of the loop, the value is otherwise meaningless"		[ readSize &lt; aSize and: [ chunkSize &gt; 0 and: [ (socket readWaitWithTimeoutMs: timeout) not] ]		] whileTrue: [			chunkSize := socket					readInto: aBuffer					startingAt: position + readSize					for: aSize - readSize.			readSize := readSize + chunkSize ].		readSize = 0 ifTrue: [			OtECommunicationFailure raiseSignal: (				(#x1sSocketPossiblyClosed &lt;&lt; #opentalk &gt;&gt; '&lt;1s&gt; Socket malfunction, possibly closed by the other party')					expandMacrosWith: self printString)].		readSize = aSize ifFalse: [			OtECommunicationFailure raiseSignal: (				(#x1sSocketReadFailed2s3s &lt;&lt; #opentalk &gt;&gt; '&lt;1s&gt; Socket read failed. Expected &lt;2s&gt; and got &lt;3s&gt;')					expandMacrosWith: self printString					with: aSize printString					with: readSize printString) ].		aBuffer	]	on: OsError do: [ :ex |			ex resignalAs: (				OtECommunicationFailure new					messageText: (						(#x1sFailed2s &lt;&lt; #opentalk &gt;&gt; '&lt;1s&gt; failed - &lt;2s&gt;')							expandMacrosWith: self printString							with: ex printString);					yourself) ]</body><body package="Opentalk-IIOP">privateSendTransportPackage: aTransportPkg	super sendTransportPackage: aTransportPkg.	[	| writeSize pkgSize |		pkgSize := aTransportPkg position.		writeSize := 0.		[ writeSize &lt; pkgSize and: [(socket writeWaitWithTimeoutMs: timeout) not ] ] whileTrue: [			writeSize := writeSize +					(socket						writeFrom: aTransportPkg buffer						startingAt: 1 + writeSize						for: pkgSize - writeSize) ].		writeSize = pkgSize ifFalse: [			OtECommunicationFailure raiseSignal: (				(#x1sSocketWriteFailed2s3s &lt;&lt; #opentalk &gt;&gt; '&lt;1s&gt; Socket write failed. Wanted &lt;2s&gt; and got &lt;3s&gt;')					expandMacrosWith: self printString					with: pkgSize printString					with: writeSize printString) ]	] 	on: OsError do: [:ex |		"This is likely a connection failure so let's skip connection closing handshake,		especially because the handshake itself needs this part working smoothly as well		(See AR 42265 for more details)"			self doStop.			ex resignalAs: (				OtECommunicationFailure new					messageText: (						(#x1sFailed2s &lt;&lt; #opentalk &gt;&gt; '&lt;1s&gt; failed - &lt;2s&gt;')							expandMacrosWith: self printString							with: ex printString);					yourself) ]</body><body package="Opentalk-IIOP">readTransportPackage	self	readTransportPackageHeader;		readTransportPackageBody.	^(GIOPMessage newWith: readBuffer)		transport: self;		readHeader;		yourself</body><body package="Opentalk-IIOP">readTransportPackageBody"Read in the body of the incoming message.Here the expectation is that the header was already read in and that it check out."	| size |	"Note that in many cases the readBuffer is reused. Also note that if one huge message comes in,	the readBuffer will stay large even though all the subsequent messages are tiny.	We may want to throw in some configurable policy here."	readBuffer isBigEnoughForMessageBody ifFalse: [ readBuffer growToFitTheMessageBody ].	(size := readBuffer msgSize) = 0 ifFalse: [		readBuffer := self nextBuffer: readBuffer size: size startingAt: readBuffer headerSize + 1]</body><body package="Opentalk-IIOP">readTransportPackageHeader	readBuffer := self nextBuffer: readBuffer size: readBuffer headerSize startingAt: 1.	self checkHeader</body><body package="Opentalk-IIOP">readyToHandleIncomingMessage"Let's quit the server loop if no message arrives within timeout period"	^super readyToHandleIncomingMessage		and: [ (socket readWaitWithTimeoutMs:timeout) not ]</body><body package="Opentalk-IIOP">socket	^socket</body><body package="Opentalk-IIOP">timeout	^timeout</body></methods><methods><class-id>Opentalk.IIOPTransport</class-id> <category>initialize-release</category><body package="Opentalk-IIOP">initializeBuffers: bufferSize	readBuffer := (TransportPackageBytes new: bufferSize)				initializeGIOPMinorVersion: self minorVersion.	writeBuffer := (TransportPackageBytes new: bufferSize)				initializeGIOPMinorVersion: self minorVersion.</body><body package="Opentalk-IIOP">initializeMarshalers"An IIOPTransport uses single marshaler for both marshaling and unmarshaling"	| marshalerConfiguration |	(marshalerConfiguration := self configuration marshaler) notNil ifTrue: [		marshaler := unmarshaler := marshalerConfiguration newFor: self ]</body><body package="Opentalk-IIOP">initializeStreams"Since we're always reading a know number of bytes let's skip the stream overhead for this one.	writeStream := ((ExternalConnection new) input: socket; output: socket) writeStream.	readStream := ((ExternalConnection new) input: socket; output: socket) readStream.	writeStream binary.	readStream binary." "Note that using streams is causing troubles with socket readWait as the driving condition of the server loop. If there are 2 messages incoming when the first one is read, the second one will get sucked into the BufferedExternalStream buffers and readWait will block because the data for the second message are not in the socket anymore."</body><body package="Opentalk-IIOP">setManager: aManager id: aConnectionId socket: aSocket	timeout := aManager connectionTimeout.	socket := aSocket.	"Need to set socket first because streams are created on top of it."	super setManager: aManager id: aConnectionId socket: aSocket.</body></methods><methods><class-id>Opentalk.IIOPTransport</class-id> <category>protocol-API</category><body package="Opentalk-IIOP">closePeer	"Inform my peer that I'm going down"	self peerOK ifTrue: [		self sendPackage: GIOPCloseConnection new ]</body><body package="Opentalk-IIOP">doStop	socket isNil ifFalse: [		socket close.		socket := nil].	super doStop.</body><body package="Opentalk-IIOP">peerClose	state := self pStopping.	self stop.</body><body package="Opentalk-IIOP">peerOK	"Answer true if my peer is ok and false otherwise."	^[	(	socket isNil			or: [ socket getPeer.				socket errorCode notNil ]		) not	]	on: Error		do: [:ex | ex return: false ]</body><body package="Opentalk-IIOP">preStop	super preStop.	"We need to terminate the server rpocess before sending close request,	otherwise the broken pipe will cause the server loop to run once more with no data"	self isRunning ifTrue: [		state := self pStopping.		self stopServerProcess.		self closePeer ]</body></methods><methods><class-id>Opentalk.IIOPTransport</class-id> <category>printing</category><body package="Opentalk-IIOP">printAccessInfoOn: aStream	super printAccessInfoOn: aStream.	id notNil ifTrue: [		aStream nextPut: $/.		id hostAddress			do: [ :e | aStream print: e ]			separatedBy: [ aStream nextPut: $.].		aStream nextPut: $:.		id port printOn: aStream]</body></methods><methods><class-id>Opentalk.IIOPTransport</class-id> <category>protocol-states</category><body package="Opentalk-IIOP">pStopping	^#stopping</body></methods><methods><class-id>Opentalk.IIOPTransport</class-id> <category>accessing</category><body package="Opentalk-IIOP">interfaceRepository		^marshaler interfaceRepository</body><body package="Opentalk-IIOP">minorVersion	^configuration minorVersion</body></methods><methods><class-id>Opentalk.IIOPTransport</class-id> <category>transport-API</category><body package="Opentalk-IIOP">sendPackage: aRemoteMessage	sendLock critical: [		self privateSendTransportPackage: (			self createTransportPackageFrom: aRemoteMessage ) ]</body><body package="Opentalk-IIOP">sendTransportPackage: aTransportPkg	sendLock critical: [		self privateSendTransportPackage: aTransportPkg ]</body></methods><methods><class-id>Opentalk.IIOPTransport class</class-id> <category>private</category><body package="Opentalk-IIOP">new: aConfiguration socketTo: anIPSocketAddress for: aManager"Create a socket connected to the given remote address"	| skt |	skt := SocketAccessor 				family: SocketAccessor AF_INET				type: SocketAccessor SOCK_STREAM.	[ skt connectTo: anIPSocketAddress timeout: aManager connectingTimeout ]		on: OsError		do: [ :ex | ex resignalAs: (			OtECommunicationFailure new				messageText: (					(#FailedToConnectTo1s &lt;&lt; #opentalk &gt;&gt; 'Failed to establish connection to &lt;1s&gt;')						expandMacrosWith: anIPSocketAddress printString);				yourself) ].	^skt</body></methods><methods><class-id>Opentalk.IIOPTransport class</class-id> <category>accessing</category><body package="Opentalk-IIOP">protocolTag	^'iiop'</body></methods><methods><class-id>Opentalk.GIOPRequest</class-id> <category>accessing</category><body package="Opentalk-IIOP">objectKey	^self target asObjectKey</body><body package="Opentalk-IIOP">objectKey: keyBytes	^self target: keyBytes</body><body package="Opentalk-IIOP">operation	^operation</body><body package="Opentalk-IIOP">operation: aString	operation := aString</body><body package="Opentalk-IIOP">requestId	^requestId</body><body package="Opentalk-IIOP">requestId: anInteger	requestId := anInteger</body><body package="Opentalk-IIOP">responseExpected	^(self responseFlags bitAnd: 1) ~~ 0</body><body package="Opentalk-IIOP">responseExpected: aBoolean	| flags |	flags := self responseFlags.	self responseFlags: (		aBoolean			ifTrue: [ flags bitOr: 1]			ifFalse: [ flags bitAnd: 254] )</body><body package="Opentalk-IIOP">responseFlags	^responseFlags ifNil: [1] "default to synchronous request"</body><body package="Opentalk-IIOP">responseFlags: aByte	responseFlags := aByte</body><body package="Opentalk-IIOP">serviceContext	^serviceContext ifNil: [ OrderedCollection new ]</body><body package="Opentalk-IIOP">serviceContext: contexts	serviceContext := contexts asOrderedCollection</body><body package="Opentalk-IIOP">target	^target</body><body package="Opentalk-IIOP">target: anIIOPObjRef	target := anIIOPObjRef</body></methods><methods><class-id>Opentalk.GIOPRequest</class-id> <category>printing</category><body package="Opentalk-IIOP">printOn: aStream	super printOn: aStream.	aStream		nextPut: $[;		print: requestId;		nextPutAll: ']{'.	self printTargetOn: aStream.	aStream nextPut: $}</body><body package="Opentalk-IIOP">printTargetOn: aStream	target printOn: aStream</body></methods><methods><class-id>Opentalk.GIOPRequest</class-id> <category>initialization</category><body package="Opentalk-IIOP">readHeader"Unmarshal the request header from the buffer and set the position to the end of the request header.expects position to be set at the end of message header."	| stream |	stream := self cdrStream.	self minorVersion &lt; 2		ifTrue: [ "GIOP 1.0, 1.1"			self	serviceContext: (stream nextSequenceOf: IOPServiceContext);	"IOP::ServiceContextList  service_context; 13.6.7"				requestId: stream nextUnsignedLong;	"unsigned long  request_id"				responseExpected: stream nextBoolean.	"boolean  response_expected"			self minorVersion = 1 ifTrue: [ stream nextBytes: 3].	"octet  reserved[3]"			self	objectKey: stream nextOctetSequence;	"sequence &lt;octet&gt;  object_key"				operation: stream nextASCIIString.		"string  operation"			stream nextOctetSequence ] "Principal  requesting_principal; 15.3.5.3"		ifFalse: [ "GIOP 1.2, ..."			self	requestId: stream nextUnsignedLong;	"unsigned long  request_id"				responseFlags: stream nextByte.	"octet  response_flags"			stream nextBytes: 3.	"octet  reserved[3]"			self	target: (IIOPObjRef readTargetAddressFrom: stream);	"TargetAddress  target"				operation: stream nextASCIIString;		"string  operation"				serviceContext: (stream nextSequenceOf: IOPServiceContext) ].	"IOP::ServiceContextList  service_context; 13.6.7"</body><body package="Opentalk-IIOP">writeHeader"Marshal the request header into the buffer and set the position to the end of the request header.Expects position to be set at the end of message header."	| stream |	stream := self cdrStream.	self minorVersion &lt; 2		ifTrue: [ "GIOP 1.0, 1.1"			stream nextPutSequence: self serviceContext;	"IOP::ServiceContextList  service_context; 13.6.7"				nextPutUnsignedLong: self requestId;	"unsigned long  request_id"				nextPutBoolean: self responseExpected.	"boolean  response_expected"			self minorVersion = 1 ifTrue: [ stream nextPutBytes: #[0 0 0]].	"octet  reserved[3]"			stream nextPutOctetSequence: self objectKey;	"sequence &lt;octet&gt;  object_key"				nextPutASCIIString: self operation;		"string  operation"				nextPutOctetSequence: #[] ]	"Principal  requesting_principal; 15.3.5.3"		ifFalse: [ "GIOP 1.2, ..."			stream nextPutUnsignedLong: self requestId;	"unsigned long  request_id"				nextPutByte: self responseFlags;	"octet  response_flags"				nextPutBytes: #[0 0 0].	"octet  reserved[3]"			self target writeTargetAddressOn: stream.	"TargetAddress  target"			stream nextPutASCIIString: self operation;		"string  operation"				nextPutSequence: self serviceContext ].	"IOP::ServiceContextList  service_context; 13.6.7"</body></methods><methods><class-id>Opentalk.GIOPRequest</class-id> <category>services</category><body package="Opentalk-IIOP">addCodeSet: anIOPCodeSet"	anIOPCodeSet &lt;IOPCodeSet&gt;"	self serviceContext add: anIOPCodeSet</body><body package="Opentalk-IIOP">codeSet"... only applies to GIOPRequests.	^&lt;IOPCodeSet | nil&gt;"	^self serviceContext		detect: [ :context | context class = IOPCodeSet ]		ifNone: [ nil ]</body></methods><methods><class-id>Opentalk.GIOPRequest class</class-id> <category>accessing</category><body package="Opentalk-IIOP">msgType	^0</body></methods><methods><class-id>Opentalk.GIOPMessageError class</class-id> <category>accessing</category><body package="Opentalk-IIOP">msgType	^6</body></methods><methods><class-id>Opentalk.IOPUnknownComponent</class-id> <category>marshaling</category><body package="Opentalk-IIOP">cdrReadFrom: aCDRStream	componentData := aCDRStream nextOctetSequence</body><body package="Opentalk-IIOP">cdrWriteOn: aCDRStream	aCDRStream		nextPutUnsignedLong: self tag;		nextPutOctetSequence: componentData</body></methods><methods><class-id>Opentalk.IOPUnknownComponent</class-id> <category>accessing</category><body package="Opentalk-IIOP">tag	^tag</body><body package="Opentalk-IIOP">tag: aSmallInteger	tag := aSmallInteger</body></methods><methods><class-id>Opentalk.IOPUnknownComponent</class-id> <category>printing</category><body package="Opentalk-IIOP">printOn: aStream	aStream nextPutAll: 'Component'.	super printOn: aStream</body></methods><methods><class-id>Opentalk.IOPMultipleComponentProfile</class-id> <category>printing</category><body package="Opentalk-IIOP">printOn: aStream	aStream nextPutAll: 'MULTIPLE_COMPONENTS'.	super printOn: aStream.	aStream nextPutAll: ': ('.	self components		do: [ :c | c printOn: aStream ]		separatedBy: [ aStream nextPutAll: ', ' ].	aStream nextPut: $)</body></methods><methods><class-id>Opentalk.IOPMultipleComponentProfile</class-id> <category>private</category><body package="Opentalk-IIOP">marshalProfileDataOn: aCDRStream	aCDRStream nextPutSequence: self components</body><body package="Opentalk-IIOP">unmarshalProfileDataFrom: aCDRStream	self components: (aCDRStream nextSequenceOf: IOPTaggedComponent)</body></methods><methods><class-id>Opentalk.IOPMultipleComponentProfile</class-id> <category>accessing</category><body package="Opentalk-IIOP">components	^components ifNil: [ #() ]</body><body package="Opentalk-IIOP">components: taggedComponents	components := taggedComponents</body></methods><methods><class-id>Opentalk.IOPMultipleComponentProfile class</class-id> <category>constants</category><body package="Opentalk-IIOP">tag	^1 "TAG_MULTIPLE_COMPONENTS"</body></methods><methods><class-id>Opentalk.IIOPTransportConfiguration</class-id> <category>accessing</category><body package="Opentalk-IIOP">componentClass	^IIOPTransport</body><body package="Opentalk-IIOP">minorVersion	minorVersion isNil ifTrue: [minorVersion := 2].	^minorVersion</body><body package="Opentalk-IIOP">minorVersion: anInteger	minorVersion := anInteger</body></methods><methods><class-id>Opentalk.IIOPTransportConfiguration class</class-id> <category>instance creation</category><body package="Opentalk-IIOP">rootConfigurationMetaclass	^TransportConfiguration class</body></methods><methods><class-id>Opentalk.IIOPAlternateAddress</class-id> <category>accessing</category><body package="Opentalk-IIOP">host	^host</body><body package="Opentalk-IIOP">host: aString	host := aString</body><body package="Opentalk-IIOP">port	^port</body><body package="Opentalk-IIOP">port: aSmallInteger	port := aSmallInteger</body></methods><methods><class-id>Opentalk.IIOPAlternateAddress</class-id> <category>comparing</category><body package="Opentalk-IIOP">= anAlternateAddress	^self class = anAlternateAddress class and: [		self host = anAlternateAddress host and: [			self port = anAlternateAddress port ] ]</body><body package="Opentalk-IIOP">hash	^self host hash bitXor: self port hash</body></methods><methods><class-id>Opentalk.IIOPAlternateAddress</class-id> <category>printing</category><body package="Opentalk-IIOP">printOn: aStream	aStream nextPutAll: 'ALTERNATE_IIOP_ADDRESS'.	super printOn: aStream.	aStream nextPutAll: ': ';		nextPutAll: self host;		nextPut: $:;		print: self port</body></methods><methods><class-id>Opentalk.IIOPAlternateAddress</class-id> <category>private</category><body package="Opentalk-IIOP">readComponentDataFrom: aCDRStream 	self host: aCDRStream nextASCIIString.	self port: aCDRStream nextShort</body><body package="Opentalk-IIOP">writeComponentDataOn: aCDRStream 	aCDRStream		nextPutASCIIString: self host;		nextPutShort: self port</body></methods><methods><class-id>Opentalk.IIOPAlternateAddress class</class-id> <category>instance creation</category><body package="Opentalk-IIOP">host: aString port: anInteger	^self new		host: aString;		port: anInteger;		yourself</body></methods><methods><class-id>Opentalk.IIOPAlternateAddress class</class-id> <category>accessing</category><body package="Opentalk-IIOP">tag	^3 "TAG_ALTERNATE_IIOP_ADDRESS"</body></methods><methods><class-id>Opentalk.SystemException</class-id> <category>marshaling</category><body package="Opentalk-IIOP">cdrReadFrom: aCDRStream	"messageText := (repositoryId identifiers tokensBasedOn: $/) last."	minorCode := aCDRStream nextUnsignedLong.	completionStatus := self statusFrom: aCDRStream nextUnsignedLong.</body><body package="Opentalk-IIOP">cdrWriteOn: aCDRStream	aCDRStream		nextPutRepositoryId: self repositoryId;		nextPutUnsignedLong: self minorCode;		nextPutUnsignedLong: self statusCode</body></methods><methods><class-id>Opentalk.SystemException</class-id> <category>accessing</category><body package="Opentalk-IIOP">name	| id |	id := self repositoryId asString.	^id	copyFrom: (id lastIndexOf: $/ ifAbsent: [ id indexOf: $: ]) + 1		to: (id lastIndexOf: $:) - 1</body><body package="Opentalk-IIOP">repositoryId	^repositoryId</body><body package="Opentalk-IIOP">repositoryId: aRepositoryId	repositoryId := aRepositoryId</body></methods><methods><class-id>Opentalk.SystemException</class-id> <category>accessing - status code</category><body package="Opentalk-IIOP">COMPLETED_MAYBE	completionStatus := #MAYBE</body><body package="Opentalk-IIOP">COMPLETED_NO	completionStatus := #NO</body><body package="Opentalk-IIOP">COMPLETED_YES	completionStatus := #YES</body><body package="Opentalk-IIOP">completionStatus	^completionStatus</body><body package="Opentalk-IIOP">completionStatus: aSymbol	completionStatus := aSymbol</body><body package="Opentalk-IIOP">statusCode	^self statusCodeFrom: completionStatus</body><body package="Opentalk-IIOP">statusCodeFrom: aSymbol	^(#(YES MAYBE NO) indexOf: aSymbol) - 1</body><body package="Opentalk-IIOP">statusFrom: aSmalInteger	^#(YES MAYBE NO) at: aSmalInteger + 1</body></methods><methods><class-id>Opentalk.SystemException</class-id> <category>accessing - minor code</category><body package="Opentalk-IIOP">code"Get the minor code number	^&lt;SmallInteger&gt; minor code &lt;0 .. 4095&gt;"	^self minorCode bitAnd: 16rFFF</body><body package="Opentalk-IIOP">code: aCode"Set the minor code number	aCode &lt;SmallInteger&gt; minor code &lt;0 .. 4095&gt;"	self vmcid bitOr: aCode</body><body package="Opentalk-IIOP">minorCode	^minorCode ifNil: [VMCID]</body><body package="Opentalk-IIOP">minorCode: anInteger	minorCode := anInteger</body><body package="Opentalk-IIOP">vmcid	^self minorCode bitAnd: 16rFFFFF000</body><body package="Opentalk-IIOP">vmcidString	| id |	id := self minorCode bitShift: -16.	^String		with: (id bitShift: -8) asCharacter		with: (id bitAnd: 255) asCharacter</body></methods><methods><class-id>Opentalk.SystemException</class-id> <category>printing</category><body package="Opentalk-IIOP">printOn: aStream	aStream		nextPutAll: self name;		nextPut: $(;		nextPutAll: self vmcidString;		space;		print: self code;		nextPut: $).	messageText ifNotNil: [		aStream space; nextPutAll: messageText ]</body></methods><methods><class-id>Opentalk.SystemException class</class-id> <category>marshaling</category><body package="Opentalk-IIOP">cdrReadFrom: aCDRStream	^(self repositoryId: aCDRStream nextRepositoryId)		cdrReadFrom: aCDRStream</body></methods><methods><class-id>Opentalk.SystemException class</class-id> <category>instance creation</category><body package="Opentalk-IIOP">INTERNAL	^self repositoryId: 'IDL:omg.org/CORBA/INTERNAL:1.0'</body><body package="Opentalk-IIOP">repositoryId: aRepositoryId	^self new repositoryId: aRepositoryId</body></methods><methods><class-id>Opentalk.GIOPLocateReply</class-id> <category>initialization</category><body package="Opentalk-IIOP">LOC_SYSTEM_EXCEPTION: aSystemException	locateStatus := 4.	reply := aSystemException</body><body package="Opentalk-IIOP">OBJECT_FORWARD: anIIOPObjRef	locateStatus := 2.	reply := anIIOPObjRef</body><body package="Opentalk-IIOP">OBJECT_FORWARD_PERM: anIIOPObjRef	locateStatus := 3.	reply := anIIOPObjRef</body><body package="Opentalk-IIOP">OBJECT_HERE	locateStatus := 1</body><body package="Opentalk-IIOP">UNKNOWN_OBJECT	locateStatus := 0</body><body package="Opentalk-IIOP">locateStatus: aSmallInteger	locateStatus := aSmallInteger</body><body package="Opentalk-IIOP">readHeader"Unmarshal the reply header from the buffer and set the position to the end of the reply header.Expects position to be set at the end of message header."	| stream |	stream := self cdrStream.	self	requestId: stream nextUnsignedLong;	"unsigned long  request_id"		"enum LocateStatusType_1_0/2 {UNKNOW_OBJECT, OBJECT_HERE, ...}"		locateStatus: stream nextUnsignedLong. "LocateStatusType_1_0/2  locate_status; 15.4.6.1"</body><body package="Opentalk-IIOP">requestId: anObject	requestId := anObject</body><body package="Opentalk-IIOP">writeHeader"Marshal the reply header into the buffer and set the position to the end of the reply header.Expects position to be set at the end of message header."	| stream |	stream := self cdrStream.	stream nextPutUnsignedLong: self requestId;	"unsigned long  request_id"		"enum LocateStatusType_1_0/2 {UNKNOW_OBJECT, OBJECT_HERE, ...}"		nextPutUnsignedLong: self locateStatus. "LocateStatusType_1_0/2  reply_status; 15.4.6.1"</body></methods><methods><class-id>Opentalk.GIOPLocateReply</class-id> <category>accessing</category><body package="Opentalk-IIOP">locateStatus	^locateStatus</body><body package="Opentalk-IIOP">locateStatusName	^#(	UNKNOWN_OBJECT		OBJECT_HERE		OBJECT_FORWARD		OBJECT_FORWARD_PERM 		"new value for GIOP 1.2"		LOC_SYSTEM_EXCEPTION		"new value for GIOP 1.2"		LOC_NEEDS_ADDRESSING_MODE	"new value for GIOP 1.2"	)	at: self locateStatus + 1</body><body package="Opentalk-IIOP">reply	^reply</body><body package="Opentalk-IIOP">requestId	^requestId</body></methods><methods><class-id>Opentalk.GIOPLocateReply</class-id> <category>testing</category><body package="Opentalk-IIOP">failed	^locateStatus = 4</body><body package="Opentalk-IIOP">isHere	^locateStatus = 1</body><body package="Opentalk-IIOP">isObjectForward	^(locateStatus bitAnd: 16rFE) = 2</body><body package="Opentalk-IIOP">isUnknown	^locateStatus = 0</body></methods><methods><class-id>Opentalk.GIOPLocateReply</class-id> <category>printing</category><body package="Opentalk-IIOP">printOn: aStream	super printOn: aStream.	aStream		nextPut: $[;		print: requestId;		nextPutAll: '](';		nextPutAll: self locateStatusName.	self hasBody ifTrue: [		aStream nextPut: $:.		self printReplyOn: aStream ].	aStream nextPut: $)</body><body package="Opentalk-IIOP">printReplyOn: aStream	reply printOn: aStream</body></methods><methods><class-id>Opentalk.GIOPLocateReply class</class-id> <category>accessing</category><body package="Opentalk-IIOP">msgType	^4</body></methods><methods><class-id>Opentalk.GIOPCancelRequest</class-id> <category>accessing</category><body package="Opentalk-IIOP">requestId	^requestId</body><body package="Opentalk-IIOP">requestId: anObject	requestId := anObject</body></methods><methods><class-id>Opentalk.GIOPCancelRequest</class-id> <category>initialization</category><body package="Opentalk-IIOP">readHeader"Unmarshal the request header from the buffer and set the position to the end of the request header.expects position to be set at the end of message header."	| stream |	stream := self cdrStream.	"15.4.4.1"	self requestId: stream nextUnsignedLong	"unsigned long  request_id"</body><body package="Opentalk-IIOP">writeHeader"Marshal the request header into the buffer and set the position to the end of the request header.Expects position to be set at the end of message header."	| stream |	stream := self cdrStream.	"15.4.4.1"	stream nextPutUnsignedLong: self requestId.	"unsigned long  request_id"</body></methods><methods><class-id>Opentalk.GIOPCancelRequest class</class-id> <category>accessing</category><body package="Opentalk-IIOP">msgType	^2</body></methods><methods><class-id>Opentalk.GIOPLocateRequest</class-id> <category>accessing</category><body package="Opentalk-IIOP">destination		^target accessPoint</body><body package="Opentalk-IIOP">objectKey	^self target asObjectKey</body><body package="Opentalk-IIOP">objectKey: keyBytes	^self target: keyBytes</body><body package="Opentalk-IIOP">requestId	^requestId</body><body package="Opentalk-IIOP">requestId: anObject	requestId := anObject</body><body package="Opentalk-IIOP">target	^target</body><body package="Opentalk-IIOP">target: anIIOPObjRef	target := anIIOPObjRef</body></methods><methods><class-id>Opentalk.GIOPLocateRequest</class-id> <category>initialization</category><body package="Opentalk-IIOP">initializeOn: aBuffer	super initializeOn: aBuffer.	promise := Promise new.</body><body package="Opentalk-IIOP">readHeader"Unmarshal the request header from the buffer and set the position to the end of the request header.expects position to be set at the end of message header."	| stream |	stream := self cdrStream.	"15.4.5.1"	self requestId: stream nextUnsignedLong.	"unsigned long  request_id"	self minorVersion &lt; 2		ifTrue: [ "GIOP 1.0, 1.1"			self objectKey: stream nextOctetSequence ]	"sequence &lt;octet&gt;  object_key"		ifFalse: [ "GIOP 1.2, ..."			self target: (IIOPObjRef readTargetAddressFrom: stream) ].	"TargetAddress  target"</body><body package="Opentalk-IIOP">writeHeader"Marshal the request header into the buffer and set the position to the end of the request header.Expects position to be set at the end of message header."	| stream |	stream := self cdrStream.	stream nextPutUnsignedLong: self requestId.	"unsigned long  request_id"	self minorVersion &lt; 2		ifTrue: [ "GIOP 1.0, 1.1"			stream nextPutOctetSequence: self objectKey ]	"sequence &lt;octet&gt;  object_key"		ifFalse: [ "GIOP 1.2, ..."			self target writeTargetAddressOn: stream ].	"TargetAddress  target"</body></methods><methods><class-id>Opentalk.GIOPLocateRequest</class-id> <category>printing</category><body package="Opentalk-IIOP">printOn: aStream	super printOn: aStream.	aStream		nextPut: $[;		print: requestId;		nextPutAll: ']{'.	self printTargetOn: aStream.	aStream nextPut: $}</body><body package="Opentalk-IIOP">printTargetOn: aStream	target printOn: aStream</body></methods><methods><class-id>Opentalk.GIOPLocateRequest class</class-id> <category>accessing</category><body package="Opentalk-IIOP">msgType	^3</body></methods><methods><class-id>Opentalk.DSTRepository</class-id> <category>CORBA</category><body package="Opentalk-IIOP">// Module GIOP// File: GIOP.idl// From CORBA 2.3: Chapter 15, General Inter-ORB Protocolmodule GIOP {                   // IDL extended for version 1.1 and 1.2    struct Version {                                    octet           major;        octet           minor;    };    // Note: Principal is not used in V1.2 and beyond. However, it must    //       be available for V1.0 and V1.1    typedef sequence&lt;octet&gt; Principal;    // GIOP 1.0    enum MsgType_1_0{                       // rename from MsgType        Request,            Reply,          CancelRequest,        LocateRequest,      LocateReply,        CloseConnection,    MessageError        };    // GIOP 1.1    enum MsgType_1_1{        Request,            Reply,          CancelRequest,        LocateRequest,      LocateReply,        CloseConnection,    MessageError,                          Fragment            // GIOP 1.1 addition    };        // GIOP 1.0     struct MessageHeader_1_0 {// Renamed from MessageHeader        char                        magic [4];        Version                     GIOP_version;        boolean                     byte_order;                 octet                       message_type;        unsigned long               message_size;    };    // GIOP 1.1    struct MessageHeader_1_1 {        char                        magic [4];        Version                     GIOP_version;        octet                       flags;      // GIOP 1.1 change        octet                       message_type;        unsigned long               message_size;    };    // GIOP 1.2    typedef MessageHeader_1_1 MessageHeader_1_2;                    // GIOP 1.0    struct RequestHeader_1_0 {        IOP::ServiceContextList     service_context;        unsigned long               request_id;        boolean                     response_expected;        sequence &lt;octet&gt;            object_key;        string                      operation;        Principal                   requesting_principal;    };    // GIOP 1.1    struct RequestHeader_1_1 {        IOP::ServiceContextList     service_context;        unsigned long               request_id;        boolean                     response_expected;        octet                       reserved[3]; // Added in GIOP 1.1        sequence &lt;octet&gt;            object_key;        string                      operation;        Principal                   requesting_principal;    };    // GIOP 1.2    typedef short                   AddressingDisposition;    const short                     KeyAddr         = 0;    const short                     ProfileAddr     = 1;    const short                     ReferenceAddr   = 2;    struct IORAddressingInfo {        unsigned long               selected_profile_index;        IOP::IOR                    ior;    };    union TargetAddress switch (AddressingDisposition) {        case KeyAddr:               sequence &lt;octet&gt;    object_key;        case ProfileAddr:           IOP::TaggedProfile  profile;        case ReferenceAddr:         IORAddressingInfo   ior;    };    struct RequestHeader_1_2 {        unsigned long               request_id;        octet                       response_flags;                     octet                       reserved[3];        TargetAddress               target;        string                      operation;        // Principal not in GIOP 1.2        IOP::ServiceContextList     service_context;    // 1.2 change    };    // GIOP 1.0 and 1.1    enum ReplyStatusType_1_0 {// Renamed from ReplyStatusType        NO_EXCEPTION,        USER_EXCEPTION,        SYSTEM_EXCEPTION,        LOCATION_FORWARD    };    // GIOP 1.0    struct ReplyHeader_1_0 {// Renamed from ReplyHeader        IOP::ServiceContextList     service_context;        unsigned long               request_id;        ReplyStatusType_1_0         reply_status;    };    // GIOP 1.1    typedef ReplyHeader_1_0 ReplyHeader_1_1;    // Same Header contents for 1.0 and 1.1    // GIOP 1.2    enum ReplyStatusType_1_2 {        NO_EXCEPTION,        USER_EXCEPTION,        SYSTEM_EXCEPTION,        LOCATION_FORWARD,        LOCATION_FORWARD_PERM,              // new value for 1.2        NEEDS_ADDRESSING_MODE               // new value for 1.2    };                      struct ReplyHeader_1_2 {        unsigned long               request_id;        ReplyStatusType_1_2         reply_status;        IOP::ServiceContextList      service_context;    // 1.2 change    };    struct SystemExceptionReplyBody {        string                      exception_id;        unsigned long               minor_code_value;        unsigned long               completion_status;    };    struct CancelRequestHeader {        unsigned long               request_id;    };    // GIOP 1.0    struct LocateRequestHeader_1_0 {// Renamed LocationRequestHeader        unsigned long               request_id;        sequence &lt;octet&gt;            object_key;    };    // GIOP 1.1    typedef LocateRequestHeader_1_0 LocateRequestHeader_1_1;    // Same Header contents for 1.0 and 1.1    // GIOP 1.2    struct LocateRequestHeader_1_2 {            unsigned long           request_id;            TargetAddress           target;    };    // GIOP 1.0 and 1.1    enum LocateStatusType_1_0 {// Renamed from LocateStatusType            UNKNOWN_OBJECT,            OBJECT_HERE,            OBJECT_FORWARD    };    // GIOP 1.0        struct LocateReplyHeader_1_0 {// Renamed from LocateReplyHeader            unsigned long           request_id;            LocateStatusType_1_0    locate_status;    };    // GIOP 1.1    typedef LocateReplyHeader_1_0 LocateReplyHeader_1_1;    // same Header contents for 1.0 and 1.1    // GIOP 1.2    enum LocateStatusType_1_2 {            UNKNOWN_OBJECT,            OBJECT_HERE,            OBJECT_FORWARD,            OBJECT_FORWARD_PERM,        // new value for GIOP 1.2            LOC_SYSTEM_EXCEPTION,       // new value for GIOP 1.2            LOC_NEEDS_ADDRESSING_MODE   // new value for GIOP 1.2    };    struct LocateReplyHeader_1_2 {        unsigned long               request_id;        LocateStatusType_1_2        locate_status;        };    // GIOP 1.2    struct FragmentHeader_1_2 {        unsigned long               request_id;    };};</body><body package="Opentalk-IIOP">// Module IIOP// File: IIOP.idl// From CORBA 2.3: Chapter 15, General Inter-ORB Protocolmodule IIOP {       // IDL extended for version 1.1 and 1.2    struct Version {        octet               major;        octet               minor;    };    struct ProfileBody_1_0 {// renamed from ProfileBody        Version             iiop_version;        string              host;        unsigned short      port;        sequence &lt;octet&gt;    object_key;    };    struct ProfileBody_1_1 {// also used for 1.2        Version             iiop_version;        string              host;        unsigned short      port;        sequence &lt;octet&gt;    object_key;        // Added in 1.1 unchanged for 1.2        sequence &lt;IOP::TaggedComponent&gt; components;     };                  struct ListenPoint {        string              host;        unsigned short      port;    };    typedef sequence&lt;ListenPoint&gt; ListenPointList;    struct BiDirIIOPServiceContext {// BI_DIR_IIOP Service Context        ListenPointList listen_points;    };};</body><body package="Opentalk-IIOP">// Module IOP// File: IOP.idl// From CORBA 2.3: Chapter 13, ORB Interoperability Achitecturemodule IOP {    // Standard Protocol Profile tag values     typedef unsigned long           ProfileId;    const ProfileId                 TAG_INTERNET_IOP = 0;    const ProfileId                 TAG_MULTIPLE_COMPONENTS = 1;    struct TaggedProfile {        ProfileId                   tag;        sequence &lt;octet&gt;            profile_data;    };        // an Interoperable Object Reference is a sequence of    // object-specific protocol profiles, plus a type ID.    struct IOR {        string                      type_id;        sequence &lt;TaggedProfile&gt;    profiles;    };        // Standard way of representing multicomponent profiles.    // This would be encapsulated in a TaggedProfile.    typedef unsigned long ComponentId;    struct TaggedComponent {        ComponentId                 tag;        sequence &lt;octet&gt;            component_data;    };    typedef sequence &lt;TaggedComponent&gt; MultipleComponentProfile;    const ComponentId           TAG_ORB_TYPE                = 0;    const ComponentId           TAG_CODE_SETS               = 1;    const ComponentId           TAG_POLICIES                = 2;       const ComponentId           TAG_ALTERNATE_IIOP_ADDRESS  = 3;    const ComponentId           TAG_ASSOCIATION_OPTIONS     = 13;    const ComponentId           TAG_SEC_NAME                = 14;    const ComponentId           TAG_SPKM_1_SEC_MECH         = 15;    const ComponentId           TAG_SPKM_2_SEC_MECH         = 16;    const ComponentId           TAG_KerberosV5_SEC_MECH     = 17;    const ComponentId           TAG_CSI_ECMA_Secret_SEC_MECH= 18;    const ComponentId           TAG_CSI_ECMA_Hybrid_SEC_MECH= 19;    const ComponentId           TAG_SSL_SEC_TRANS           = 20;    const ComponentId           TAG_CSI_ECMA_Public_SEC_MECH= 21;    const ComponentId           TAG_GENERIC_SEC_MECH        = 22;    const ComponentId           TAG_JAVA_CODEBASE           = 25;    const ComponentId           TAG_COMPLETE_OBJECT_KEY     = 5;    const ComponentId           TAG_ENDPOINT_ID_POSITION    = 6;    const ComponentId           TAG_LOCATION_POLICY         = 12;    const ComponentId           TAG_DCE_STRING_BINDING      = 100;    const ComponentId           TAG_DCE_BINDING_NAME        = 101;    const ComponentId           TAG_DCE_NO_PIPES            = 102;    const ComponentId           TAG_DCE_SEC_MECH            = 103; // Security Service    typedef unsigned long       ServiceId;    struct ServiceContext {        ServiceId               context_id;        sequence &lt;octet&gt;        context_data;    };    typedef sequence &lt;ServiceContext&gt; ServiceContextList;    const ServiceId             TransactionService          = 0;    const ServiceId             CodeSets                    = 1;    const ServiceId             ChainBypassCheck            = 2;    const ServiceId             ChainBypassInfo             = 3;    const ServiceId             LogicalThreadId             = 4;    const ServiceId             BI_DIR_IIOP                 = 5;    const ServiceId             SendingContextRunTime       = 6;    const ServiceId             INVOCATION_POLICIES         = 7;    const ServiceId             FORWARDED_IDENTITY          = 8;    const ServiceId             UnknownExceptionInfo        = 9;};</body></methods><methods><class-id>Opentalk.TransportPackageBytes</class-id> <category>iiop</category><body package="Opentalk-IIOP">initializeGIOPMinorVersion: anOctet	"Initialize the receiver"	self majorVersion: 1.	self minorVersion: anOctet.	self magic: 'GIOP'.	self byteOrder: false "BIG-ENDIAN"	"Ideally we should use UninterpretedBytes isBigEndian not,	but CDRStream currently only supports big-endian writing"</body></methods><methods><class-id>Core.ByteArray</class-id> <category>opentalk</category><body package="Opentalk-IIOP">asIIOPObjRefFor: anIIOPTransport	^Opentalk.IIOPObjRef		newOn: anIIOPTransport manager localAccessPoint		oidBytes: self</body><body package="Opentalk-IIOP">asObjectKey	^self</body><body package="Opentalk-IIOP">writeTargetAddressOn: aCDRStream"used by GIOPRequest"	"union TargetAddress switch (AddressingDisposition)"	aCDRStream		nextPutShort: 0;	"typedef short  AddressingDisposition"		nextPutOctetSequence: self "case KeyAddr:  sequence &lt;octet&gt;  object_key"</body></methods><methods><class-id>Opentalk.CDRStream</class-id> <category>marshaling-constructed</category><body package="Opentalk-IIOP">nextPutSequence: aCollection	self nextPutUnsignedLong: aCollection size.	aCollection do: [ :e | e cdrWriteOn: self ]</body><body package="Opentalk-IIOP">nextPutUnsignedLongs: integers	self nextPutUnsignedLong: integers size.	integers do: [ :e | self nextPutUnsignedLong: e ]</body></methods><methods><class-id>Opentalk.CDRStream</class-id> <category>marshaling-support</category><body package="Opentalk-IIOP">nextRepositoryId	| s |	^(s := self nextASCIIString) isEmpty		ifTrue: [nil]		ifFalse: [RepositoryId fromString: s]</body></methods><methods><class-id>Opentalk.CDRStream</class-id> <category>marshaling-constructed</category><body package="Opentalk-IIOP">nextSequenceOf: aClass	| size sequence |	size := self nextUnsignedLong.	sequence := Array new: size.	1 to: size do: [ :i |		sequence at: i put: (aClass cdrReadFrom: self) ].	^sequence</body><body package="Opentalk-IIOP">nextUnsignedLongs	| size sequence |	size := self nextUnsignedLong.	sequence := Array new: size.	1 to: size do: [ :i |		sequence at: i put: self nextUnsignedLong ].	^sequence</body></methods><methods><class-id>Opentalk.TransportConfiguration class</class-id> <category>types</category><body package="Opentalk-IIOP">iiop	^IIOPTransportConfiguration new</body></methods><methods><class-id>OS.IPSocketAddress</class-id> <category>opentalk</category><body package="Opentalk-IIOP">hostAddressString	| ws |	ws := (String new: 10) writeStream.	self hostAddress		do: [ :byte | ws print: byte ]		separatedBy: [ ws nextPut: $. ].	^ws contents</body></methods><methods><class-id>Opentalk.TransportPackage</class-id> <category>accessing</category><body package="Opentalk-IIOP">majorVersion	^buffer majorVersion</body><body package="Opentalk-IIOP">majorVersion: aByte	^buffer majorVersion: aByte</body><body package="Opentalk-IIOP">minorVersion	^buffer minorVersion</body><body package="Opentalk-IIOP">minorVersion: aByte	^buffer minorVersion: aByte</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>IPSocketAddress</name><environment>OS</environment><super>OS.SocketAddress</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Sockets</category><attributes><package>OS-Sockets</package></attributes></class><class><name>ByteArray</name><environment>Core</environment><super>Core.IntegerArray</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>TransportPackageBytes</name><environment>Opentalk</environment><super>Kernel.BinaryStorageBytes</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><class><name>StreamTransportConfiguration</name><environment>Opentalk</environment><super>Opentalk.TransportConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><class><name>DSTRepository</name><environment>Opentalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Repository</category><attributes><package>Opentalk-IDL-Repository</package></attributes></class><class><name>TransportPackage</name><environment>Opentalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>buffer position peer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><class><name>CDRStream</name><environment>Opentalk</environment><super>Core.ReadWriteStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>byteOrder charEncoder wcharEncoder marshaler </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Protocols-Core</category><attributes><package>Opentalk-CDR</package></attributes></class><class><name>ObjRef</name><environment>Opentalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>accessPoint oid </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><class><name>StreamTransport</name><environment>Opentalk</environment><super>Opentalk.RequestTransport</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id peerId writeStream readStream </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><class><name>Exception</name><environment>Core</environment><super>Core.GenericException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class></st-source>