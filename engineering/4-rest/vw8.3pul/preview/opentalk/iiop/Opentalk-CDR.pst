<?xml version="1.0"?><st-source><!-- Name: Opentalk-CDRNotice: Copyright 1999-2013 Cincom Systems, Inc.  All rights reserved.Comment: Basic CDR marshaling machinery represented by the CDRStream.DbIdentifier: bear73DbTrace: 400723DbUsername: nrossDbVersion: 7.10 - 1DevelopmentPrerequisites: #(#(#package 'Opentalk-Prerequisites' ''))PackageName: Opentalk-CDRParcel: #('Opentalk-CDR')PrerequisiteParcels: #(#('Opentalk-Prerequisites' ''))PrintStringCache: (7.10 - 1,nross)Version: 7.10 - 1Date: 11:27:07 AM April 12, 2013 --><time-stamp>From VisualWorksÂ®, Pre-Release 7.10 (apr13.2) of April 12, 2013 on April 12, 2013 at 11:27:07 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>CDRNotification</name><environment>Opentalk</environment><super>Core.Notification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-CDR</category><attributes><package>Opentalk-CDR</package></attributes></class><class><name>ArraySegment</name><environment>Opentalk</environment><super>Core.IntegerArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars>array startOffset stopIndex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-CDR</category><attributes><package>Opentalk-CDR</package></attributes></class><comment><class-id>Opentalk.ArraySegment</class-id><body>A segment of an array. Restricts access to the underlying array to the specified bounds and pretends to be a collection of its own.Instance Variables:	array	&lt;ByteArray&gt;	the undelying byte array	startOffset	&lt;Integer&gt;	segment start; startIndex - 1	stopIndex	&lt;Integer&gt;	segment end</body></comment><class><name>CDRError</name><environment>Opentalk</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-CDR</category><attributes><package>Opentalk-CDR</package></attributes></class><class><name>CDRStream</name><environment>Opentalk</environment><super>Core.ReadWriteStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>byteOrder charEncoder wcharEncoder marshaler </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Protocols-Core</category><attributes><package>Opentalk-CDR</package></attributes></class><comment><class-id>Opentalk.CDRStream</class-id><body>This class is private to the implementation of the Distributed Smalltalk.  Users should not use this class directly and should not subclass it.  This class implements the marshalling primitives as per the CORBA2.0 specificationInstance Variables:	byteOrder	&lt;Boolean&gt; the byte order of the remote system	charEncoder	&lt;StreamEncoder&gt; character encoder for char and string types	wcharEncoder	&lt;StreamEncoder&gt; character encoder for wchar and wstring types	marshaler	&lt;CDRMarshaler&gt; what marshaler do I work for</body></comment><class><name>TCCDRStream</name><environment>Opentalk</environment><super>Opentalk.CDRStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Protocols-Core</category><attributes><package>Opentalk-CDR</package></attributes></class><comment><class-id>Opentalk.TCCDRStream</class-id><body>CDR stream extended for type codes.</body></comment><shared-variable><name>BigEndian</name><environment>Opentalk.CDRStream</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Opentalk-CDR</package></attributes></shared-variable><methods><class-id>Opentalk.ArraySegment</class-id> <category>accessing</category><body package="Opentalk-CDR">adjustedIndex: index	| adjustedIndex |	index &gt; 0 ifFalse: [^self subscriptBoundsErrorFor: #at: index: index].	adjustedIndex := index + startOffset.	adjustedIndex &gt; stopIndex ifTrue: [^self subscriptBoundsErrorFor: #at: index: index].	^adjustedIndex</body><body package="Opentalk-CDR">at: index	"Answer the value of an indexable field in the receiver.  Fail if the	argument index is not an Integer or is out of bounds."	^array at: (self adjustedIndex: index)</body><body package="Opentalk-CDR">at: index put: value	"Store the argument value in the indexable field of the receiver indicated by	 index. Fail if the index is not an Integer or is out of bounds. Fail if the	 value is not of the right type for this kind of collection. Answer the	 value that was stored."	^array at: (self adjustedIndex: index) put: value</body><body package="Opentalk-CDR">byteAt: index 	"Answer the byte at the given index."	^array byteAt: (self adjustedIndex: index)</body><body package="Opentalk-CDR">size	"Answer the number of indexable fields in the receiver. This value is the	same as the largest legal subscript."	^stopIndex - startOffset</body></methods><methods><class-id>Opentalk.ArraySegment</class-id> <category>initialize-release</category><body package="Opentalk-CDR">on: anArray from: start to: end	array := anArray.	startOffset := start - 1.	stopIndex := end</body></methods><methods><class-id>Opentalk.ArraySegment</class-id> <category>private</category><body package="Opentalk-CDR">replaceBytesFrom: start to: stop with: replacement startingAt: repStart 	"This destructively replaces elements from start to stop in the receiver	starting at index, repStart, in the collection, replacement.  Answer the	receiver."	array		replaceBytesFrom: start + startOffset		to: stop + startOffset		with: replacement		startingAt: repStart</body></methods><methods><class-id>Opentalk.ArraySegment</class-id> <category>adding</category><body package="Opentalk-CDR">growToAtLeast: anInteger	"The receiver becomes at least as large as anInteger."	"This is not a copy of the receiver, so all shared references survive."	| adjustedSize |	anInteger &lt;= self size ifTrue: [^self].	adjustedSize := startOffset + anInteger.	array size &lt; adjustedSize ifTrue: [		array growToAtLeast: adjustedSize ].	stopIndex := array size</body></methods><methods><class-id>Opentalk.ArraySegment class</class-id> <category>instance creation</category><body package="Opentalk-CDR">new	^self basicNew</body><body package="Opentalk-CDR">on: anArray from: start to: end	^self new on: anArray from: start to: end</body></methods><methods><class-id>Opentalk.CDRStream</class-id> <category>alignment</category><body package="Opentalk-CDR">alignToDouble	"advance the position to the Double alignment boundary"	[(position bitAnd: 7) isZero | self atEnd]		whileFalse: [self next]</body><body package="Opentalk-CDR">alignToLong	"advance the position to the Long alignment boundary"	[(position bitAnd: 3) == 0  or: [position &gt;= readLimit]]		whileFalse: [position := position + 1]</body><body package="Opentalk-CDR">alignToLongDouble	"advance the position to the Long Double alignment boundary"	[(position bitAnd: 7) isZero | self atEnd]		whileFalse: [self next]</body><body package="Opentalk-CDR">alignToLongLong	"advance the position to the Long Long alignment boundary"	[(position bitAnd: 7) isZero | self atEnd]		whileFalse: [self next]</body><body package="Opentalk-CDR">alignToShort	"advance the position to the Short alignment boundary"	[(position bitAnd: 1) isZero | self atEnd]		whileFalse: [self next]</body><body package="Opentalk-CDR">alignToWideChar	"advance the position to the WideChar alignment boundary"	[(position bitAnd: 1) isZero | self atEnd]		whileFalse: [self next]</body><body package="Opentalk-CDR">padToDouble	"advance the position to the Double alignment boundary"	[(position bitAnd: 7) isZero]		whileFalse: [self nextPut: 0]</body><body package="Opentalk-CDR">padToLong	"advance the position to the Long alignment boundary"	(position bitAnd: 3) == 0 ifTrue: [^self].	self nextPut: 0.	(position bitAnd: 3) == 0 ifTrue: [^self].	self nextPut: 0.	(position bitAnd: 3) == 0 ifTrue: [^self].	self nextPut: 0.	(position bitAnd: 3) == 0 ifTrue: [^self].</body><body package="Opentalk-CDR">padToLongDouble	"advance the position to the Long Double alignment boundary"	[(position bitAnd: 7) isZero]		whileFalse: [self nextPut: 0]</body><body package="Opentalk-CDR">padToLongLong	"advance the position to the LongLong alignment boundary"	[(position bitAnd: 7) isZero]		whileFalse: [self nextPut: 0]</body><body package="Opentalk-CDR">padToShort	"advance the position to the Short alignment boundary"	[(position bitAnd: 1) isZero]		whileFalse: [self nextPut: 0]</body><body package="Opentalk-CDR">padToWideChar	"advance the position to the Wide Char alignment boundary"	[(position bitAnd: 1) isZero]		whileFalse: [self nextPut: 0]</body></methods><methods><class-id>Opentalk.CDRStream</class-id> <category>marshaling-primitive</category><body package="Opentalk-CDR">nextBoolean	"return the next boolean in the receiver"	self nextByte = 0		ifTrue: [^false]		ifFalse: [^true]</body><body package="Opentalk-CDR">nextByte	"return the next byte from the receiver"	^self next</body><body package="Opentalk-CDR">nextCharacter	"return the next character in the receiver"	^self charEncoder nextFrom: self</body><body package="Opentalk-CDR">nextPutBoolean: aBoolean 	"marshall the boolean in the receiver"	"Must raise an exception if non-Boolean"	self nextPut: (aBoolean ifTrue: [1] ifFalse: [0])</body><body package="Opentalk-CDR">nextPutByte: aByte	"marshall the byte in the receiver"	self nextPut: aByte</body><body package="Opentalk-CDR">nextPutCharacter: aCharacter 	"marshall the character in the receiver"	"Must raise exception if non-character (currently	via MNU on toCORBACharCode"	self charEncoder nextPut: aCharacter on: self</body><body package="Opentalk-CDR">nextPutDouble: aDouble 	"marshall the double float in the receiver."	| param |	self padToDouble.	BigEndian		ifTrue: [param := aDouble]		ifFalse: 			[param := aDouble copy.			param reverseByteOrder].	1 to: param basicSize do: [:i | self nextPut: (param basicAt: i)]</body><body package="Opentalk-CDR">nextPutFloat: aFloat 	"marshall the float in the receiver."	| param |	self padToLong.	BigEndian		ifTrue: [param := aFloat]		ifFalse: 			[param := aFloat copy.			param reverseByteOrder].	1 to: param basicSize do: [:i | self nextPut: (param basicAt: i)]</body><body package="Opentalk-CDR">nextPutWideCharacter: aCharacter 	"marshall the character in the receiver"	"Must raise exception if non-character"	"Description from class character:		For character codes between 0 and 65535 (16rFFFF), the Unicode		Character Code Standard is used.  Characters with codes between 		0 and 255 also coincide with the ISO 8859-1 standard. At present, 		mappings for Characters greater than 65535 are undefined.	It is assumed that if ISO 8859-1 characters are most common in	an application, the type char is used instead of wchar. So here	we assume that characters are two byte wide (or user defined	encoding)"	| anInt len |	len := self wideCharLength.	anInt := aCharacter asInteger.	self padToWideChar.	self nextPut: len.	BigEndian 		ifTrue: [			len-1 to: 1 by: -1 do: [:i |  				self nextPut: ((anInt bitShift: -8*i) bitAnd: 255).].			self nextPut: (anInt bitAnd: 255)]		ifFalse:  [			self nextPut: (anInt bitAnd: 255).			1 to: len-1 do: [:i |  				self nextPut: ((anInt bitShift: -8*i) bitAnd: 255).]]</body><body package="Opentalk-CDR">nextWideCharacter	"return the next wide character in the receiver"	"The first byte is the number of bytes that form the character."	| nBytes bytes result |	self alignToWideChar.	nBytes := self next.	bytes := ByteArray new: nBytes.	self mustSwapBytes		ifTrue: [nBytes to: 1 by: -1 do: [:i | bytes at: i put: self next]]		ifFalse: [1 to: nBytes do: [:i | bytes at: i put: self next]].	result := 0.	1 to: nBytes do: [:i | result := (result bitShift: 8) + (bytes at: i)].	^Character value: result</body></methods><methods><class-id>Opentalk.CDRStream</class-id> <category>marshaling-integers</category><body package="Opentalk-CDR">nextLong	"return the next long integer in the receiver"	| ival |	ival := self nextUnsignedLong.	(ival &gt; 536870911 and: [ival &gt; 2147483647])		ifTrue: [^(4294967296 - ival) negated]		ifFalse: [^ival]</body><body package="Opentalk-CDR">nextLongLong	"return the next long long integer in the receiver"	"536870911 is the largest possible SmallInteger (faster &gt; test)"	"9223372036854775807 = 7FFF FFFF FFFF FFFF Hex"	"18446744073709551616 = 1 0000 0000 0000 0000 Hex"	| ival |	ival := self nextUnsignedLongLong.	(ival &gt; 536870911 and: [ival &gt; 9223372036854775807])		ifTrue: [^(18446744073709551616 - ival) negated]		ifFalse: [^ival]</body><body package="Opentalk-CDR">nextPutLong: anInt 	"marshall the long integer in the receiver"	"Must raise exception if not an integer (currently via MNU on 	bitShift:)"	self padToLong.	writeLimit - position &gt;= 4		ifFalse: 			[collection growToAtLeast: (writeLimit + 4).			writeLimit := collection size].	collection at: position + 1 put: ((anInt bitShift: -24)			bitAnd: 255).	collection at: position + 2 put: ((anInt bitShift: -16)			bitAnd: 255).	collection at: position + 3 put: ((anInt bitShift: -8)			bitAnd: 255).	collection at: (position := position + 4) put: (anInt bitAnd: 255)</body><body package="Opentalk-CDR">nextPutLongLong: aLongLong 	"marshall the long integer in the receiver"	"Must raise exception if not an integer (currently via nextPutLong:)"	self padToLongLong.	writeLimit - position &gt;= 8		ifFalse: 			[collection growToAtLeast: collection size + 8.			writeLimit := collection size].	collection at: position + 1 put: ((aLongLong bitShift: -56)			bitAnd: 255).	collection at: position + 2 put: ((aLongLong bitShift: -48)			bitAnd: 255).	collection at: position + 3 put: ((aLongLong bitShift: -40)			bitAnd: 255).	collection at: position + 4 put: ((aLongLong bitShift: -32)			bitAnd: 255).	collection at: position + 5 put: ((aLongLong bitShift: -24)			bitAnd: 255).	collection at: position + 6 put: ((aLongLong bitShift: -16)			bitAnd: 255).	collection at: position + 7 put: ((aLongLong bitShift: -8)			bitAnd: 255).	collection at: (position := position + 8) put: (aLongLong bitAnd: 255)</body><body package="Opentalk-CDR">nextPutShort: anInt	"marshall the short integer in the receiver"	"Must raise exception if not an integer (currently via MNU on bitShift:)"	self padToShort; 		nextPut: ((anInt bitShift: -8) bitAnd: 255); 		nextPut: (anInt bitAnd: 255)</body><body package="Opentalk-CDR">nextPutUnsignedLong: anInt 	"marshall the long integer in the receiver"	"Must raise exception if not an integer (currently via nextPutLong:)"	self nextPutLong: anInt</body><body package="Opentalk-CDR">nextPutUnsignedLongLong: anInt 	"marshall the long integer in the receiver"	"Must raise exception if not an integer (currently via nextPutLong:)"	self nextPutLongLong: anInt</body><body package="Opentalk-CDR">nextPutUnsignedShort: anInt 	"marshall the short integer in the receiver"	"Must raise exception if not an integer (currently via nextPutShort:)"	self nextPutShort: anInt</body><body package="Opentalk-CDR">nextShort	"return the next short integer in the receiver"	| ival |	ival := self nextUnsignedShort.	ival &gt; 32767		ifTrue: [^(65536 - ival) negated]		ifFalse: [^ival]</body><body package="Opentalk-CDR">nextUnsignedLong	"return the next long integer in the receiver"	| ba b0 b1 b2 w |	self alignToLong.	self isBigEndian		ifTrue: [(readLimit - position) &gt;= 4				ifTrue: [b0 := collection at: position + 1.  						b1 := collection at: position + 2.  						b2 := collection at: position + 3.    						w := collection at: (position := position + 4)]				ifFalse: [b0 := self next.  						b1 := self next.  						b2 := self next.  						w := self next].				"Following sequence minimizes LargeInteger arithmetic for small results."				b2=0 ifFalse: [w := (b2 bitShift: 8) + w].				b1=0 ifFalse: [w := (b1 bitShift: 16) + w].				b0=0 ifFalse: [w := (b0 bitShift: 24) + w].				^w]		ifFalse: [ba := ByteArray new: 4.				4 to: 1 by: -1 do: [:i | ba at: i put: self next].				^self decodeLong: ba].</body><body package="Opentalk-CDR">nextUnsignedLongLong	"return the next long integer in the receiver"	| ba b0 b1 b2 b3 b4 b5 b6 w |	self alignToLongLong.	self isBigEndian		ifFalse: [ba := ByteArray new: 8.				8 to: 1 by: -1 do: [:i | ba at: i put: self next].				^self decodeLongLong: ba]		ifTrue: [(readLimit - position) &gt;= 8				ifTrue: [						b0 := collection at: position + 1.  						b1 := collection at: position + 2.  						b2 := collection at: position + 3.    						b3 := collection at: position + 4.  						b4 := collection at: position + 5.  						b5 := collection at: position + 6.						b6 := collection at: position + 7.    						w := collection at: (position := position + 8)]				ifFalse: [						b0 := self next.  						b1 := self next.  						b2 := self next.  						b3 := self next.  						b4 := self next.  						b5 := self next.  						b6 := self next.						w := self next].				"Following sequence minimizes LargeInteger arithmetic for small results."				b6=0 ifFalse: [w := (b6 bitShift: 8) + w].					b5=0 ifFalse: [w := (b5 bitShift: 16) + w].				b4=0 ifFalse: [w := (b4 bitShift: 24) + w].				b3=0 ifFalse: [w := (b3 bitShift: 32) + w].				b2=0 ifFalse: [w := (b2 bitShift: 40) + w].				b1=0 ifFalse: [w := (b1 bitShift: 48) + w].				b0=0 ifFalse: [w := (b0 bitShift: 56) + w].				^w]</body><body package="Opentalk-CDR">nextUnsignedShort	"return the next short integer in the receiver"	| ba |	self alignToShort.	ba := ByteArray new: 2.	self isBigEndian		ifTrue: [1 to: 2 do: [:i | ba at: i put: self next]]		ifFalse: [2 to: 1 by: -1 do: [:i | ba at: i put: self next]].	^self decodeShort: ba</body></methods><methods><class-id>Opentalk.CDRStream</class-id> <category>testing</category><body package="Opentalk-CDR">isBigEndian	"answer the byte ordering of the elements - a value of zero indicates 	big-endian byte ordering"  	^self byteOrder ifTrue: [false] ifFalse: [true]</body><body package="Opentalk-CDR">mustSwapBytes 	^self isBigEndian ~~ BigEndian</body></methods><methods><class-id>Opentalk.CDRStream</class-id> <category>marshaling-extended</category><body package="Opentalk-CDR">nextEncapsulatedInOctets: aBlock	| end length result start stream |	length := self nextUnsignedLong.	start := self position + 1.	end := self position + length.	stream := CDRStream with: (ArraySegment on: collection from: start to: end).	stream reset.	stream byteOrder: stream nextBoolean.	result := aBlock value: stream.	self position: end.	^result</body><body package="Opentalk-CDR">nextLocalType	"We put the local type information for type retention."	^nil</body><body package="Opentalk-CDR">nextPutEncapsulatedInOctets: aBlock	| start end stream |	start := self position.	self nextPutUnsignedLong: 0.	stream := CDRStream on: (ArraySegment on: collection from: start + 5 to: (start + 50 min: collection size)).	stream byteOrder: self byteOrder.	stream nextPutBoolean: stream byteOrder.	aBlock value: stream.	end := stream position.	self position: start.	self nextPutUnsignedLong: end.	self position: end + start + 4</body><body package="Opentalk-CDR">nextPutLocalType: aString 	"Localtype is not used for CDR marshalling of typecode information"</body><body package="Opentalk-CDR">nextPutNullIOR"Section 13.6.3 IOR Profiles: 'Null object references are indicated by an empty set of profiles, and by a 'Null' typeID (a string which contains only a single terminating character).'"	self		nextPutASCIIString: ''; "null type ID"		nextPutUnsignedLong: 0 "empty sequence"</body></methods><methods><class-id>Opentalk.CDRStream</class-id> <category>accessing</category><body package="Opentalk-CDR">adaptor	^marshaler adaptor</body><body package="Opentalk-CDR">byteOrder	"return the byte ordering of the message, in cases for a new stream 	we set the byte order to false for all platforms"	byteOrder == nil ifTrue: [byteOrder := false].	^byteOrder</body><body package="Opentalk-CDR">byteOrder: aBoolean 	"set the byte ordering of the message"	byteOrder := aBoolean</body><body package="Opentalk-CDR">charEncoder	^charEncoder ifNil: [		charEncoder := self marshaler charEncoder ]</body><body package="Opentalk-CDR">charEncoder: aStreamEncoder	charEncoder := aStreamEncoder</body><body package="Opentalk-CDR">collection	^collection</body><body package="Opentalk-CDR">marshaler	^marshaler</body><body package="Opentalk-CDR">marshaler: aCDRMarshaler"	aCDRMarshaler &lt;CDRMarshaler | nil&gt; what marshaler do I work for. "	marshaler := aCDRMarshaler</body><body package="Opentalk-CDR">minorVersion	^self marshaler minorVersion</body><body package="Opentalk-CDR">wcharEncoder	^wcharEncoder ifNil: [		wcharEncoder := self marshaler wcharEncoder ]</body><body package="Opentalk-CDR">wcharEncoder: aStreamEncoder	wcharEncoder := aStreamEncoder</body><body package="Opentalk-CDR">wideCharLength	^self wcharEncoder characterSize: $A</body></methods><methods><class-id>Opentalk.CDRStream</class-id> <category>marshaling-support</category><body package="Opentalk-CDR">decodeLong: ba 	"decode a long integer from the byte array"	| result |	result := 0.	1 to: 4 do: [:i | result := (result bitShift: 8)					+ (ba at: i)].	^result</body><body package="Opentalk-CDR">decodeLongLong: ba 	"decode a long integer from the byte array"	| result |	result := 0.	1 to: 8 do: [:i | result := (result bitShift: 8)					+ (ba at: i)].	^result</body><body package="Opentalk-CDR">decodeShort: ba 	"decode a short integer from the byte array"	^((ba at: 1) asInteger bitShift: 8)		+ (ba at: 2) asInteger</body><body package="Opentalk-CDR">encodeLong: anInt 	"encode the long integer in a byte array"	| ba |	ba := ByteArray new: 4.	ba at: 1 put: ((anInt bitShift: -24)			bitAnd: 255).	ba at: 2 put: ((anInt bitShift: -16)			bitAnd: 255).	ba at: 3 put: ((anInt bitShift: -8)			bitAnd: 255).	ba at: 4 put: (anInt bitAnd: 255).	^ba</body><body package="Opentalk-CDR">nextASCIIString	| s result | 	s := self nextUnsignedLong.	^s &gt; 0		ifTrue: [			result := String new: s-1.			self nextBytesInto: result.			self next = 0 ifFalse: [self error: 'String not null terminated'].			result ]		ifFalse: ['']</body><body package="Opentalk-CDR">nextBytes: n	"return the next n bytes from the receiver"	| ba |	ba := ByteArray new: n.	self nextBytesInto: ba.	^ba</body><body package="Opentalk-CDR">nextBytesInto: aByteObject	| size |	size := aByteObject size.	position + size &lt;= readLimit		ifTrue: [ aByteObject					replaceBytesFrom: 1					to: size					with: collection					startingAt: position+1.				position := position + size]		ifFalse: [1 to: size do: [:i |  aByteObject byteAt: i put: self next]].</body><body package="Opentalk-CDR">nextPutASCIIString: aByteString 	aByteString == nil		ifTrue: [ self nextPutLong: 1 ]		ifFalse: [ self				nextPutLong: aByteString size + 1;				nextPutBytes: aByteString ].	self nextPut: 0</body><body package="Opentalk-CDR">nextPutBytes: aByteObject 	| size |	size := aByteObject basicSize. "Can't use #size because of TwoByteStrings"	position + size &lt;= writeLimit ifFalse: [		collection growToAtLeast: collection size + size.		writeLimit := collection size].	collection		replaceBytesFrom: position + 1		to: position + size		with: aByteObject		startingAt: 1.	position := position + size</body><body package="Opentalk-CDR">nextPutRepositoryId: anId	anId == nil		ifTrue: [ self nextPutLong: 1; nextPut: 0 ]		ifFalse: [			self	nextPutLong: anId size + 1;				nextPutBytes: anId;				nextPut: 0 ]</body></methods><methods><class-id>Opentalk.CDRStream</class-id> <category>positioning</category><body package="Opentalk-CDR">position: anInteger 	"Set position to anInteger as long as anInteger is within the bounds 	of the receiver's contents. If it is not, provide an error notification."	(anInteger &gt;= 0 and: [anInteger &lt;= collection size])		ifTrue: 			[anInteger &gt;= readLimit ifTrue: [readLimit := anInteger].			position := anInteger]		ifFalse: [^self positionOutOfBoundsError: anInteger]</body></methods><methods><class-id>Opentalk.CDRStream</class-id> <category>marshaling-constructed</category><body package="Opentalk-CDR">nextFixed: digits scale: scale	"Read the next fixed point number of the CDRStream"	|  byte sign aNumber |	aNumber := 0.	byte := self next.	(digits // 2) timesRepeat: [		aNumber := aNumber * 10 + (byte bitShift: -4).		aNumber := aNumber * 10 + (byte bitAnd: 15).		byte := self next.].	sign := (byte bitAnd: 15) == 12			ifTrue:[1]			ifFalse:[-1].	aNumber := aNumber * 10 + (byte bitShift: -4).	aNumber := (aNumber * (10 ** scale negated)) asFixedPoint: (scale &gt; 0		ifTrue:[scale]		ifFalse:[0]).	^sign * aNumber</body><body package="Opentalk-CDR">nextOctetSequence	^self nextBytes: self nextUnsignedLong</body><body package="Opentalk-CDR">nextPutFixed: aFixedPoint digits: digits scale: scale	"Put aFixedPoint on to the CDRStream.  Note that the CORBA fixed type of 	limited scale, and a prescribed decimal point position, unlike the FixedPoint	in Smalltalk.  Hence, if the scale is non-negative we round down to obtain	the IDL prescribed precision."	| denom n aStream  low byte numerator denominator base |	denom := 10 ** scale.	(aFixedPoint * denom) abs &lt; (10 ** digits)		ifFalse:[self error: 'Out of the fixed range'].	numerator := aFixedPoint numerator.	denominator := aFixedPoint denominator.	base := 10.	n :=  numerator * denom + (denominator bitShift: -1) // denominator.	numerator &lt; 0		ifTrue: 			[low := 13.			n := n negated]		ifFalse:[low := 12].	aStream := WriteStream on: (ByteArray new: 32).	(digits // 2 + 1)  timesRepeat: [		byte := low bitOr: (( n \\ base) bitShift: 4).		aStream nextPut: byte.		n := n // base.		low := n \\ base.		n := n // base].	self nextPutBytes: aStream contents reverse.</body><body package="Opentalk-CDR">nextPutOctetSequence: aByteArray	self		nextPutUnsignedLong: aByteArray size;		nextPutBytes: aByteArray</body><body package="Opentalk-CDR">nextPutString: aString 	"Marshall the parameter onto the stream"	"Must raise exception is not string or nil"	aString == nil		ifTrue: [self nextPutLong: 1; nextPut: 0]		ifFalse: 			[self nextPutLong: aString size + 1.			aString do: [ :ch |				self charEncoder nextPut: ch on: self ].			"self nextPutBytes: aString toCORBACharCodes."			self nextPut: 0]</body><body package="Opentalk-CDR">nextPutWideString: aString 	| encoder string sizeInChars sizePosition |	string := aString ifNil: [			self minorVersion &gt; 1				ifTrue: [^self nextPutUnsignedLong: 0]				ifFalse: [''] ].	encoder := self wcharEncoder.		sizeInChars := self minorVersion = 1 and: [ #(#'UTF-16' #'UCS-2') includes: encoder encoding ].	sizeInChars		ifTrue: [ self nextPutUnsignedLong: string size + 1 ]		ifFalse: [ sizePosition := self position.			self nextPutUnsignedLong: 0 ].	(string class = TwoByteString and: [ #(#'UTF-16' #'UCS-2') includes: encoder encoding ])		ifTrue: [ "UTF16/UCS-2 is our internal representation for TwoByteStrings"			self mustSwapBytes ifTrue: [				string := string copy.				string reverseByteOrder ].			self nextPutBytes: string ]		ifFalse: [ encoder bigEndian: self isBigEndian.			string do: [ :ch | encoder nextPut: ch on: self ] ].	"IIOP 1.1 is null char terminated"	self minorVersion = 1 ifTrue: [ encoder nextPut: 0 asCharacter on: self ].	sizeInChars ifFalse: [ "need to fixup the encoded size now"		self	withPosition: sizePosition			do: [ :endPosition || size |				size := endPosition - sizePosition - 4. "don't count the long for size"				self nextPutUnsignedLong: size ] ]</body><body package="Opentalk-CDR">nextString	"unMarshall a string"	| s result | 	s := self nextUnsignedLong.	^s &gt; 0		ifTrue: [			result := String new: s-1.			self charEncoder	"Optimize for iso-8859-1 encoding"				ifNil: [ self nextBytesInto: result ]				ifNotNil: [ 1 to: s - 1 do: [ :i | result at: i put: (self charEncoder nextFrom: self) ] ].			self next = 0 ifFalse: [self error: 'String not null terminated'].			result ]		ifFalse: ['']</body><body package="Opentalk-CDR">nextWideString	| string size encoder sizeInChars |	(size := self nextUnsignedLong) = 0 ifTrue: [^''].	encoder := self wcharEncoder.	sizeInChars := self minorVersion = 1 and: [ #(#'UTF-16' #'UCS-2') includes: encoder encoding ].	size := self minorVersion = 1 "convert to byte size excluding null terminator if any"			ifTrue: [ sizeInChars ifTrue: [ (size - 1) * 2 ] ifFalse: [size - 2] ]			ifFalse: [ size ].	encoder bigEndian: self isBigEndian.	(#(#'UTF-16' #'UCS-2') includes: encoder encoding )		ifTrue: [ "UTF16/UCS-2 is our internal representation for TwoByteStrings"			string := ByteArray new: size.			self nextBytesInto: string.			string changeClassTo: TwoByteString.			self mustSwapBytes ifTrue: [string reverseByteOrder]]		ifFalse: [ | stop index |			string := String new: size.			stop := self position + size.			index := 0.			[ self position &lt; stop ] whileTrue: [				index := index + 1.				string at: index put: (encoder nextFrom: self) ].			string := string copyFrom: 1 to: index ].	"IIOP 1.1 is null char terminated"	self minorVersion = 1 ifTrue: [ encoder nextFrom: self ].	^string</body></methods><methods><class-id>Opentalk.CDRStream</class-id> <category>marshalling</category><body package="Opentalk-CDR">nextDouble	"return the next double in the receiver."	| res |	self alignToDouble.	res := 0.0d copy.	res whileMutableDo: [ | size |		size := res basicSize.		self mustSwapBytes			ifTrue: [				size to: 1 by: -1 do: [ :i |					res basicAt: i put: self next ] ]  			ifFalse: [				1 to: size do: [ :i |					res basicAt: i put: self next ] ] ].	^res</body><body package="Opentalk-CDR">nextFloat	"return the next float in the receiver."	| res |	self alignToLong.	res := 0.0 copy.	res whileMutableDo: [ | size |		size := res basicSize.		self mustSwapBytes			ifTrue: [				size to: 1 by: -1 do: [ :i |					res basicAt: i put: self next ] ]  			ifFalse: [				1 to: size do: [ :i |					res basicAt: i put: self next ] ] ].	^res</body></methods><methods><class-id>Opentalk.CDRStream class</class-id> <category>private</category><body package="Opentalk-CDR">reverseWideStringByteOrder: bytes	"self reverseWideStringByteOrder: 		(ByteArray withAll: #(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16))"	| len |	len := self wideCharLength.	1 to: bytes basicSize - 1 by: len do:		[:i |	| tmp |		0 to: len/2 -1 do:[:j |			tmp := bytes basicAt: i+j.			bytes basicAt: i+j put: (bytes basicAt: i+len-j-1).			bytes basicAt: i+len-j-1 put: tmp]].	^bytes</body></methods><methods><class-id>Opentalk.CDRStream class</class-id> <category>initialization</category><body package="Opentalk-CDR">initialize	"initialize the receiver"	BigEndian := UninterpretedBytes isBigEndian</body><body package="Opentalk-CDR">reInitialize	"re-initialize the receiver"	self initialize.	"fieldArray := Array with: (Array with: (Array with: (DSTdeclaratorSimple new initialize: #tag))					with: DSTtypeUnsignedLong new)				with: (Array with: (Array with: (DSTdeclaratorSimple new initialize: #profileData))						with: ((DSTtypeSequence new) subtype: DSTtypeOctet new size: nil; localType: #ByteArray)).	IORDef := DSTtypeSequence new subtype: ((DSTtypeStructure new) id: #TaggedProfile fields: fieldArray; localType: #IOPTaggedProfile) size: nil"</body></methods><methods><class-id>Opentalk.CDRStream class</class-id> <category>accessing</category><body package="Opentalk-CDR">bigEndian	^BigEndian</body></methods><methods><class-id>Opentalk.TCCDRStream</class-id> <category>marshalling</category><body package="Opentalk-CDR">nextLocalType	"We put the local type information for type retention."	^self nextASCIIString</body><body package="Opentalk-CDR">nextPutLocalType: aString 	"We put the local type information for type retention."	self nextPutASCIIString: aString</body></methods><initialize><class-id>Opentalk.CDRStream</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>ReadWriteStream</name><environment>Core</environment><super>Core.WriteStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>Notification</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>IntegerArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class></st-source>