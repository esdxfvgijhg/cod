<?xml version="1.0"?><st-source><!-- Name: Opentalk-IDL-CompilerNotice: Copyright 1999-2013 Cincom Systems, Inc.  All rights reserved.Comment: IDL compilation machinery used to parse IDL document and produce corresponding IDL meta object structure.DbIdentifier: bear73DbTrace: 400726DbUsername: nrossDbVersion: 7.10 - 1DevelopmentPrerequisites: #(#(#any 'AT Parser Compiler' '') #(#any 'Opentalk-IDL-MetaObjects' ''))PackageName: Opentalk-IDL-CompilerParcel: #('Opentalk-IDL-Compiler')PrerequisiteParcels: #(#('AT Parser Compiler' '') #('Opentalk-IDL-MetaObjects' ''))PrintStringCache: (7.10 - 1,nross)Version: 7.10 - 1Date: 11:27:08 AM April 12, 2013 --><time-stamp>From VisualWorksÂ®, Pre-Release 7.10 (apr13.2) of April 12, 2013 on April 12, 2013 at 11:27:08 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>DSTvalueExpr</name><environment>Opentalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>opString opSel left right </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>Opentalk-IDL-Compiler</package></attributes></class><comment><class-id>Opentalk.DSTvalueExpr</class-id><body>Instance Variables:	opString 	&lt;String&gt;	opSel 		&lt;Boolean&gt;	left 			&lt;DSTvalueExpr&gt;	right 		&lt;DSTvalueExpr&gt;</body></comment><class><name>DSTIRPragma</name><environment>Opentalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Compilers</category><attributes><package>Opentalk-IDL-Compiler</package></attributes></class><comment><class-id>Opentalk.DSTIRPragma</class-id><body>This class is the abstract base class for CORBA 2.0 interface repository pragmas. There are three pragmas defined by the OMG:	#pragma ID &lt;name&gt; "&lt;id&gt;"	#pragma version &lt;name&gt; &lt;major&gt;.&lt;minor&gt;	#pragma prefix "&lt;string&gt;"DST defines three more:	#pragma SELECTOR &lt;name&gt; &lt;smalltalk selector&gt;	#pragma CLASS &lt;name&gt; &lt;smalltalk class name&gt;	#pragma ACCESS &lt;name&gt; &lt;access rights&gt;The IDL compiler collects the ID and version pragmas for each scope entered and createsa collection of DSTIRPragmas which is associated with the container for the given scope. The current prefix is also recorded as part of the pragma. Once the IDL is compiled therepository IDs of the objects in the repository are set based on the collected pragmas.Subclasses must implement the following messages:	actions		applyTo:Instance variables:	name	&lt;String&gt;		the name of the idl construct to which the pragma applies.</body></comment><class><name>DSTAccessPragma</name><environment>Opentalk</environment><super>Opentalk.DSTIRPragma</super><private>false</private><indexed-type>none</indexed-type><inst-vars>accessRights </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Compilers</category><attributes><package>Opentalk-IDL-Compiler</package></attributes></class><comment><class-id>Opentalk.DSTAccessPragma</class-id><body>This class represents an access pragma which has the following syntax:	#pragma access &lt;name&gt; &lt;rights&gt;Instance Variables:	accessRights	&lt;Symbol&gt;		the user specified access rights</body></comment><class><name>DSTClassPragma</name><environment>Opentalk</environment><super>Opentalk.DSTIRPragma</super><private>false</private><indexed-type>none</indexed-type><inst-vars>className </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Compilers</category><attributes><package>Opentalk-IDL-Compiler</package></attributes></class><comment><class-id>Opentalk.DSTClassPragma</class-id><body>This class represents a class pragma which has the following syntax:	#pragma class &lt;name&gt; &lt;class name&gt;Instance variables:	className	&lt;String&gt;		the user specified class</body></comment><class><name>DSTVersionPragma</name><environment>Opentalk</environment><super>Opentalk.DSTIRPragma</super><private>false</private><indexed-type>none</indexed-type><inst-vars>version </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Compilers</category><attributes><package>Opentalk-IDL-Compiler</package></attributes></class><comment><class-id>Opentalk.DSTVersionPragma</class-id><body>This class represents a version pragma. A version pragma has the form:	#pragma version &lt;name&gt; major.minorInstance Variables:	version		&lt;String&gt;		The major.minor version as a string</body></comment><class><name>ScopeBlock</name><environment>Opentalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>prefix container pragmas </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Compilers</category><attributes><package>Opentalk-IDL-Compiler</package></attributes></class><comment><class-id>Opentalk.ScopeBlock</class-id><body>ScopeBlocks are used by the IDL compiler to handle prefix pragmas. As a new scope isentered an instance of a ScopeBlock is created and pushed on a scoping stack.Instance Variables:	prefix 			&lt;IDLPrefix&gt;  holds the current prefix and container	container		&lt;DSTMetaContainer&gt; the container for objects in this scope	pragmas			&lt;OrderedCollection&gt; an ordered stack of pragmas to be applied to						objects in this scope</body></comment><class><name>IDLPrefix</name><environment>Opentalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>prefixString definingContainer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>Opentalk-IDL-Compiler</package></attributes></class><comment><class-id>Opentalk.IDLPrefix</class-id><body>IDLPrefix instances are placed in ScopeBlocks. An IDLPrefix holds the current prefix string and defining container. This information is used to implement the prefix pragma.Instance Variables:	prefixString	&lt;String&gt;		prefix string	definingContainer &lt;DSTMetaContainer&gt; container for current scope</body></comment><class><name>DSTSelectorPragma</name><environment>Opentalk</environment><super>Opentalk.DSTIRPragma</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Compilers</category><attributes><package>Opentalk-IDL-Compiler</package></attributes></class><comment><class-id>Opentalk.DSTSelectorPragma</class-id><body>DSTSelectorPragma represents a selector pragma. A selector pragma has the following syntax:	#pragma selector &lt;name&gt; &lt;a selector&gt;Instance variables:	selector		&lt;String&gt;		the Smalltalk selector corresponding to the IDL operation</body></comment><class><name>IDLCompiler</name><environment>Opentalk</environment><super>Kernel.ExternalLanguageParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>scope </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Compilers</category><attributes><package>Opentalk-IDL-Compiler</package></attributes></class><comment><class-id>Opentalk.IDLCompiler</class-id><body>This class implements a compiler which accepts IDL module or interface declarations and produces a method which will return the correct meta object network to represent the IDL declaration.  Note that these methods store the actual object instances which they return upon demand, and that changes to an instance will be reflected in the results of subsequent calls.Instance Variables:	scope			&lt;OrderedCollection&gt; stack for scope nestingShared Variables:	EnforceNaming 	&lt;Boolean&gt;		Controls checking of the syntax of identifiers.	CharacterLiteralTable	&lt;IdentityDictionary&gt; special characters found in string literals.	KeywordTable 	&lt;IdentityDictionary&gt; reserved IDL keywords</body></comment><class><name>DSTIDPragma</name><environment>Opentalk</environment><super>Opentalk.DSTIRPragma</super><private>false</private><indexed-type>none</indexed-type><inst-vars>repositoryId </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Compilers</category><attributes><package>Opentalk-IDL-Compiler</package></attributes></class><comment><class-id>Opentalk.DSTIDPragma</class-id><body>This class represents an ID pragma which has the following syntax:	#pragma ID &lt;name&gt; &lt;repositoryId&gt;The repositoryId can be one of three types: IDL, DCE, or LOCAL.Instance variables:	repositoryId	&lt;RepositoryId&gt;	the user specified repository Id</body></comment><shared-variable><name>EnforceNaming</name><environment>Opentalk.IDLCompiler</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Opentalk-IDL-Compiler</package></attributes></shared-variable><shared-variable><name>KeywordTable</name><environment>Opentalk.IDLCompiler</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Opentalk-IDL-Compiler</package></attributes></shared-variable><shared-variable><name>CharacterLiteralTable</name><environment>Opentalk.IDLCompiler</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Opentalk-IDL-Compiler</package></attributes></shared-variable><methods><class-id>Opentalk.DSTvalueExpr</class-id> <category>operators</category><body package="Opentalk-IDL-Compiler">and	"and the left and right arguments and return the result"	| l r |	l := left value.	r := right value.	^l == true		ifTrue: [r]		ifFalse: [l == false				ifTrue: [l]				ifFalse: [l asInteger bitAnd: r asInteger]]</body><body package="Opentalk-IDL-Compiler">bool	"return the right argument as the result of a boolean literal"	^right value</body><body package="Opentalk-IDL-Compiler">characterLiteral	^right</body><body package="Opentalk-IDL-Compiler">complement	"complement the right argument and return the result"	| v |	v := right value.	v isInteger ifTrue: [^v bitInvert].	(v == true or: [v == false])		ifTrue: [^v not].	self notify: 'Complement operator applied to illegal value'</body><body package="Opentalk-IDL-Compiler">concat	"concat the left and right arguments and return the result"	| l r |	l := left value.	r := right value.	^l , r</body><body package="Opentalk-IDL-Compiler">div	"divide the left and right arguments and return the result"	^left value / right value</body><body package="Opentalk-IDL-Compiler">fixedPointLiteral	^right</body><body package="Opentalk-IDL-Compiler">floatLiteral	^right</body><body package="Opentalk-IDL-Compiler">minus	"subtract the left and right arguments and return the result"	^left value - right value</body><body package="Opentalk-IDL-Compiler">mod	"mod the left and right arguments and return the result"	^left value \\ right value</body><body package="Opentalk-IDL-Compiler">mult	"multiply the left and right arguments and return the result"	^left value * right value</body><body package="Opentalk-IDL-Compiler">neg	"negate the right argument and return the result"	^right value negated</body><body package="Opentalk-IDL-Compiler">nest	"return the right argument as the result"	^right value</body><body package="Opentalk-IDL-Compiler">not	"complement the right argument and return the result"	^right value not</body><body package="Opentalk-IDL-Compiler">or	"or the left and right arguments and return the result"	| l r |	l := left value.	r := right value.	^l == true		ifTrue: [l]		ifFalse: [l == false				ifTrue: [r]				ifFalse: [l asInteger bitOr: r asInteger]]</body><body package="Opentalk-IDL-Compiler">plus	"add the left and right arguments and return the result"	^left value + right value</body><body package="Opentalk-IDL-Compiler">shLeft	"shift the left value left by the right argument and return the result"	^left value bitShift: right value</body><body package="Opentalk-IDL-Compiler">shRight	"shift the left value right by the right argument and return the result"	^left value bitShift: right value negated</body><body package="Opentalk-IDL-Compiler">stringLiteral	^right</body><body package="Opentalk-IDL-Compiler">unaryPlus	^right value</body><body package="Opentalk-IDL-Compiler">xor	"xor the left and right arguments and return the result"	| l r |	l := left value.	r := right value.	^l == true		ifTrue: [l]		ifFalse: [l == false				ifTrue: [r]				ifFalse: [l asInteger bitXor: r asInteger]]</body></methods><methods><class-id>Opentalk.DSTvalueExpr</class-id> <category>accessing</category><body package="Opentalk-IDL-Compiler">definedIn: aMetaObject 	"set the receiver's defining container meta object"	(left respondsTo: #definedIn:) ifTrue: [left definedIn: aMetaObject].	(right respondsTo: #definedIn:) ifTrue: [right definedIn: aMetaObject].</body><body package="Opentalk-IDL-Compiler">value	"return the value of the receiver"	^self perform: opSel</body></methods><methods><class-id>Opentalk.DSTvalueExpr</class-id> <category>repository</category><body package="Opentalk-IDL-Compiler">allMetaObjectsInto: aSet 	"add all of the referenced metaobjects to the set"	(left respondsTo: #allMetaObjectsInto:)		ifTrue: [left allMetaObjectsInto: aSet].	(right respondsTo: #allMetaObjectsInto:)		ifTrue: [right allMetaObjectsInto: aSet]</body></methods><methods><class-id>Opentalk.DSTvalueExpr</class-id> <category>initialization</category><body package="Opentalk-IDL-Compiler">op: aStr sel: aSel right: rExpr left: lExpr 	"initialize a new instance"	opString := aStr.	opSel := aSel.	left := lExpr.	right := rExpr</body></methods><methods><class-id>Opentalk.DSTvalueExpr class</class-id> <category>creation</category><body package="Opentalk-IDL-Compiler">op: aStr sel: aSel right: rExpr left: lExpr	"create a new instance"	^self new op: aStr sel: aSel right: rExpr left: lExpr</body></methods><methods><class-id>Opentalk.DSTIRPragma</class-id> <category>accessing</category><body package="Opentalk-IDL-Compiler">name	^name</body><body package="Opentalk-IDL-Compiler">name: aName 	name := aName</body></methods><methods><class-id>Opentalk.DSTIRPragma</class-id> <category>actions</category><body package="Opentalk-IDL-Compiler">applyTo: aMetaObject 	^self subclassResponsibility</body></methods><methods><class-id>Opentalk.DSTAccessPragma</class-id> <category>accessing</category><body package="Opentalk-IDL-Compiler">accessRights	^accessRights</body><body package="Opentalk-IDL-Compiler">accessRights: someAccess 	accessRights := someAccess</body></methods><methods><class-id>Opentalk.DSTAccessPragma</class-id> <category>printing</category><body package="Opentalk-IDL-Compiler">printOn: aStream 	"print the receiver's printname on the stream"	aStream nextPutAll: '#pragma access ' , name , ' ' , accessRights</body></methods><methods><class-id>Opentalk.DSTAccessPragma</class-id> <category>actions</category><body package="Opentalk-IDL-Compiler">applyTo: aMetaObject 	"Set the access rights for an operation from the specified pragma."	| msg |	(aMetaObject canApplyPragma: #ACCESS)		ifTrue: [aMetaObject accessRight: self accessRights]		ifFalse: 			[msg := 'Access pragma not allowed on ' , aMetaObject displayString.			"ORBDaemon configurationManager log: msg withCRs."			Dialog notify: msg]</body></methods><methods><class-id>Opentalk.DSTClassPragma</class-id> <category>accessing</category><body package="Opentalk-IDL-Compiler">className	^className</body><body package="Opentalk-IDL-Compiler">className: aClass 	className := aClass</body></methods><methods><class-id>Opentalk.DSTClassPragma</class-id> <category>actions</category><body package="Opentalk-IDL-Compiler">applyTo: aMetaObject 	"Set local type for metaobject."	| msg |	(aMetaObject canApplyPragma: #CLASS)		ifTrue: [aMetaObject baseType localType: self className]		ifFalse: 			[msg := 'Class pragma not allowed on ' , aMetaObject displayString.			"ORBDaemon configurationManager log: msg withCRs."			Dialog notify: msg]</body></methods><methods><class-id>Opentalk.DSTClassPragma</class-id> <category>printing</category><body package="Opentalk-IDL-Compiler">printOn: aStream 	"print the receiver's printname on the stream"	aStream nextPutAll: '#pragma class ' , name , ' ' , className</body></methods><methods><class-id>Opentalk.DSTVersionPragma</class-id> <category>actions</category><body package="Opentalk-IDL-Compiler">applyTo: aMetaObject 	"set the version for the meta object from the pragma."	| msg id |	(aMetaObject canApplyPragma: #VERSION)		ifTrue: 			[aMetaObject setVersion: self version.			(id := aMetaObject repositoryId) isNil ifFalse: [id formatName == #IDL					ifTrue: 						[aMetaObject repositoryId: nil.						aMetaObject id]]]		ifFalse: 			[msg := 'Version pragma not allowed on ' , aMetaObject displayString.			"ORBDaemon configurationManager log: msg withCRs."			Dialog notify: msg]</body></methods><methods><class-id>Opentalk.DSTVersionPragma</class-id> <category>accessing</category><body package="Opentalk-IDL-Compiler">version	^version</body><body package="Opentalk-IDL-Compiler">version: aVersion 	version := aVersion</body></methods><methods><class-id>Opentalk.DSTVersionPragma</class-id> <category>printing</category><body package="Opentalk-IDL-Compiler">printOn: aStream 	"print the receiver's printname on the stream"	aStream nextPutAll: '#pragma version ' , name , ' ' , version</body></methods><methods><class-id>Opentalk.ScopeBlock</class-id> <category>accessing</category><body package="Opentalk-IDL-Compiler">container	^container</body><body package="Opentalk-IDL-Compiler">container: aContainer 	container := aContainer</body><body package="Opentalk-IDL-Compiler">pragmas	^pragmas</body><body package="Opentalk-IDL-Compiler">prefix	^prefix</body><body package="Opentalk-IDL-Compiler">prefix: aPrefix 	prefix := aPrefix</body></methods><methods><class-id>Opentalk.ScopeBlock</class-id> <category>actions</category><body package="Opentalk-IDL-Compiler">addPragma: aPragma 	pragmas addLast: aPragma</body></methods><methods><class-id>Opentalk.ScopeBlock</class-id> <category>initialize-release</category><body package="Opentalk-IDL-Compiler">initialize	"initialize the receiver"	prefix := IDLPrefix new.	container := nil.	pragmas := OrderedCollection new</body></methods><methods><class-id>Opentalk.ScopeBlock class</class-id> <category>instance creation</category><body package="Opentalk-IDL-Compiler">new	^super new initialize</body><body package="Opentalk-IDL-Compiler">prefix: aPrefix container: aContainer 	| block |	block := self new.	block prefix: aPrefix.	block container: aContainer.	^block</body></methods><methods><class-id>Opentalk.IDLPrefix</class-id> <category>accessing</category><body package="Opentalk-IDL-Compiler">definingContainer	^definingContainer</body><body package="Opentalk-IDL-Compiler">definingContainer: defContainer 	definingContainer := defContainer</body><body package="Opentalk-IDL-Compiler">prefixString	^prefixString</body><body package="Opentalk-IDL-Compiler">prefixString: aString 	prefixString := aString</body></methods><methods><class-id>Opentalk.IDLPrefix class</class-id> <category>instance creation</category><body package="Opentalk-IDL-Compiler">prefix: aString container: aContainer 	| p |	p := self basicNew.	p prefixString: aString.	aContainer isNil		ifTrue: [p definingContainer: DSTORBObject repository]		ifFalse: [p definingContainer: aContainer].	^p</body></methods><methods><class-id>Opentalk.DSTSelectorPragma</class-id> <category>accessing</category><body package="Opentalk-IDL-Compiler">selector	^selector</body><body package="Opentalk-IDL-Compiler">selector: aSelector 	selector := aSelector</body></methods><methods><class-id>Opentalk.DSTSelectorPragma</class-id> <category>printing</category><body package="Opentalk-IDL-Compiler">printOn: aStream 	"print the receiver's printname on the stream"	aStream nextPutAll: '#pragma selector ' , name , ' ' , selector</body></methods><methods><class-id>Opentalk.DSTSelectorPragma</class-id> <category>actions</category><body package="Opentalk-IDL-Compiler">applyTo: aMetaObject 	"set the selector for the operation from the pragma."	| msg |	(aMetaObject canApplyPragma: #ID)		ifTrue: [aMetaObject localOp: (aMetaObject convertSymbol: self selector)]		ifFalse: 			[msg := 'Selector pragma not allowed on ' , aMetaObject displayString.			"ORBDaemon configurationManager log: msg withCRs."			Dialog notify: msg]</body></methods><methods><class-id>Opentalk.IDLCompiler</class-id> <category>operation syntax</category><body package="Opentalk-IDL-Compiler">contextExpr  =	word=#context  $( identifier\$,  $)</body><body package="Opentalk-IDL-Compiler">opAttribute =	word=#oneway [#ONEWAY]</body><body package="Opentalk-IDL-Compiler">opDecl =	(opAttribute  opTypeSpec  opIdentifier  parameterDecls 	( raisesExpr  |  [#()]  ) 	( contextExpr  | [#()])		[(DSToperation prefix: scope last) 			cxt: stack removeLast 			evts: stack removeLast 			params: stack removeLast 			id: stack removeLast			type: stack removeLast			attr: stack removeLast])  |	(opTypeSpec  opIdentifier  parameterDecls 	( raisesExpr  |  [#()]  ) 	( contextExpr  | [#()])		[(DSToperation prefix: scope last)  			cxt: stack removeLast 			evts: stack removeLast 			params: stack removeLast 			id: stack removeLast			type: stack removeLast			attr: #NORMAL])</body><body package="Opentalk-IDL-Compiler">opTypeSpec =	word=#void  [DSTtypeVoid new]	|	paramTypeSpec</body><body package="Opentalk-IDL-Compiler">paramAttribute =	word=#in  [#IN] |	word=#out  [#OUT] |	word=#inout [#INOUT]</body><body package="Opentalk-IDL-Compiler">paramDecl =		paramAttribute  paramTypeSpec  simpleDeclarator		[DSTparameter new 			name: stack removeLast 			type: stack removeLast			direction: stack removeLast ]</body><body package="Opentalk-IDL-Compiler">parameterDecls =	$( [DSTsignature new] 	(paramDecl\$,  [: addAll: ] | )	$)</body><body package="Opentalk-IDL-Compiler">raisesExpr  =	word=#raises  $( scopedName\$,  $)</body></methods><methods><class-id>Opentalk.IDLCompiler</class-id> <category>interface syntax</category><body package="Opentalk-IDL-Compiler">inheritanceSpec =	$:  scopedName\$,</body><body package="Opentalk-IDL-Compiler">interface =        interfaceHeader        (${ interfaceBody $} [: n: s: d: b:]   | [DSTtypeNamed new d: stack removeLast s: stack removeLast n: stack removeLast i: stack removeLast])        [popScopeBlock: ]</body><body package="Opentalk-IDL-Compiler">interfaceBody =	export*</body><body package="Opentalk-IDL-Compiler">interfaceHeader =	word=#interface 	[DSTinterface prefix: scope last]	[pushScopeBlock: ]	typeIdentifier 	(inheritanceSpec | [#()] )  	[| p | p := currentComment. currentComment := nil. p]</body></methods><methods><class-id>Opentalk.IDLCompiler</class-id> <category>constructed types</category><body package="Opentalk-IDL-Compiler">arrayDeclarator =	typeIdentifier  fixedArraySize+		  [(DSTtypeArray prefix: scope last) sizes: stack removeLast ident: stack removeLast type: stack last]		  [(DSTdeclaratorSimple prefix: scope last) array: stack removeLast]</body><body package="Opentalk-IDL-Compiler">case =	(caseLabel+ elementSpec  $;)		 [stack removeLast: 3]</body><body package="Opentalk-IDL-Compiler">caseLabel =	(word=#case  constExp  $: )  |	(word=#default  [#default]  $: )</body><body package="Opentalk-IDL-Compiler">constructedTypeSpec =	structType  |	unionType  |	enumType</body><body package="Opentalk-IDL-Compiler">elementSpec =	typeSpec  declarator</body><body package="Opentalk-IDL-Compiler">enumType =	word=#enum [DSTtypeEnumeration prefix: scope last] typeIdentifier  ${  enumerator\$,  $}		[: id: values:]</body><body package="Opentalk-IDL-Compiler">enumerator =	enumIdentifier</body><body package="Opentalk-IDL-Compiler">fixedArraySize =	$[  integerConst  $]</body><body package="Opentalk-IDL-Compiler">fixedPointType =	word=#fixed [DSTtypeFixed new] 		($&lt;  integerConst $, constExp  $&gt;  [(stack at: stack size) value  &gt; (stack at: stack size -1) value													ifTrue:[self notify: '&lt;- Digits can''t be smaller then scale']].		|		[nil])	 [: digits: scale:]</body><body package="Opentalk-IDL-Compiler">integerConst =	constExp [stack last value &lt; 0 ifTrue: [ self notify: ' &lt;- ', 'Expected a positive constant'] ifFalse: [ stack removeLast]]</body><body package="Opentalk-IDL-Compiler">member =		typeSpec  declarators  $;		[Array with: stack removeLast with: stack removeLast]</body><body package="Opentalk-IDL-Compiler">memberList =	member+</body><body package="Opentalk-IDL-Compiler">sequenceType =	word=#sequence [DSTtypeSequence new]	$&lt;  simpleTypeSpec  ($,  integerConst  | [nil])  $&gt;	 [: subtype: size:]</body><body package="Opentalk-IDL-Compiler">stringType =		word=#string [DSTtypeString new] 		($&lt;  integerConst  $&gt;  |		[nil])	 [: maxSize:]</body><body package="Opentalk-IDL-Compiler">structType =		word=#struct  [DSTtypeStructure prefix: scope last]		typeIdentifier  ${  memberList  $}			[: id: fields:]</body><body package="Opentalk-IDL-Compiler">switchBody =	case+</body><body package="Opentalk-IDL-Compiler">switchTypeSpec =	integerType  |	charType  |	booleanType  |	enumType  |	scopedName [DSTtypeNamed new initialize: stack removeLast]</body><body package="Opentalk-IDL-Compiler">templateTypeSpec =	sequenceType |	stringType |	wideStringType |	fixedPointType</body><body package="Opentalk-IDL-Compiler">unionType =	word=#union  [DSTtypeUnion prefix: scope last]	identifier  word=#switch  $( switchTypeSpec  $) ${  switchBody  $}		[: name: switch: triples:]</body><body package="Opentalk-IDL-Compiler">wideStringType =	word=#wstring [DSTtypeWideString new] 		($&lt;  integerConst  $&gt;  |		[nil])	 [: maxSize:]</body></methods><methods><class-id>Opentalk.IDLCompiler</class-id> <category>module syntax</category><body package="Opentalk-IDL-Compiler">definition  =	(interface		|		module			|		constDecl		 |		exceptDecl 	 |		typeDecl)	description	$;</body><body package="Opentalk-IDL-Compiler">export =	(constDecl		 |		exceptDecl 	 |		attrDecl 	 |		typeDecl 	 |		opDecl)	description	$;</body><body package="Opentalk-IDL-Compiler">module  =	word=#module [DSTmodule prefix: scope last]	[pushScopeBlock: ]	typeIdentifier [: ident: ]		[| p | p := currentComment. currentComment := nil. p]	${   definition+   $}		[: def: defs: ]	[popScopeBlock: ]</body></methods><methods><class-id>Opentalk.IDLCompiler</class-id> <category>scanning</category><body package="Opentalk-IDL-Compiler">blockComment	| savedEnd prev |	savedEnd := prevEnd.	"preserve end of last token"	buffer reset.	buffer nextPut: $/; nextPut: $*.	prev := nil.	[(hereChar := source next) == nil | (prev == $* and: [hereChar == $/])]		whileFalse: 			[buffer nextPut: hereChar.			prev := hereChar].	buffer nextPut: hereChar.	currentComment == nil		ifTrue: [currentComment := OrderedCollection with: buffer contents trim]		ifFalse: [currentComment add: buffer contents trim].	buffer position &gt; 200 ifTrue: ["Shorten the buffer if it got unreasonably large."		buffer := WriteStream on: (String new: 40)].	hereChar := source next.	self scanToken.	prevEnd := savedEnd</body><body package="Opentalk-IDL-Compiler">collectFloat: start end: end 	buffer reset.	source position: start.	start to: end - 1 do: [:i | buffer nextPut: source next].	^buffer contents</body><body package="Opentalk-IDL-Compiler">collectString: start end: end 	"The end position is at one character past the string terminator."	buffer reset.	source position: start.	start to: end - 2 do: [:i | buffer nextPut: source next].	source skip: 1.	^buffer contents</body><body package="Opentalk-IDL-Compiler">lineComment	| savedEnd char |	savedEnd := prevEnd.	"preserve end of last token"	buffer reset.	[source peek = $ ]		whileTrue: [source next].	[self endOfLineComment: (char := source next)]		whileFalse: [buffer nextPut: char].	currentComment == nil		ifTrue: [currentComment := OrderedCollection with: buffer contents trim]		ifFalse: [currentComment add: buffer contents trim].	buffer position &gt; 200 ifTrue: ["Shorten the buffer if it got unreasonably large."		buffer := WriteStream on: (String new: 40)].	hereChar := source next.	self scanToken.	prevEnd := savedEnd</body><body package="Opentalk-IDL-Compiler">scanCharLiteral	"Called when $\ seen during a character literal or string literal scan."	| c |	hereChar := source next.	hereChar asLowercase == $x		ifTrue: [c := Character value: (self readIDLIntegerFrom: source radix: 16)]		ifFalse: [hereChar &gt;= $0 &amp; (hereChar &lt;= $7)				ifTrue: 					[source skip: -1.					c := Character value: (self readIDLIntegerFrom: source radix: 8)]				ifFalse: [c := CharacterLiteralTable at: hereChar ifAbsent: [^nil]]].	^c</body><body package="Opentalk-IDL-Compiler">skip	"advance the position to skip over delimiters and equal"	[(tokenType := typeTable at: hereChar asInteger) == #xDelimiter or: [tokenType = #ascii75]]		whileTrue: [hereChar := source next]</body><body package="Opentalk-IDL-Compiler">xCharacterLiteral	"An IDL character literal"	| char start |	start := source position.	(char := source next) == nil ifTrue: [^self offEnd: 'Unmatched character quote'].	char == $\		ifTrue: [token := self scanCharLiteral]		ifFalse: [token := char].	(token isNil or: [source next ~= $'])		ifTrue: [^self offEnd: 'Unmatched character quote'].	token := DSTvalueExpr				op: 'characterLiteral'				sel: #characterLiteral				right: token				left: (self collectString: start end: source position).	hereChar := source next.	tokenType := #characterLiteral</body><body package="Opentalk-IDL-Compiler">xCommentOrDivide	"collect line comment, block comment, or return simple slash"	source peek == $/		ifTrue: 			[source next.			^self lineComment].	source peek == $*		ifTrue: 			[source next.			^self blockComment].	token := hereChar.	tokenType := #ascii57.	hereChar := source next.	^token</body><body package="Opentalk-IDL-Compiler">xDigit	"An IDL constant (number)"	| c n start |	start := source position -1.	hereChar == $0		ifTrue: 			[c := source peek.			c == $x | (c == $X)				ifTrue: 					[source next.					n := self readIDLIntegerFrom: source radix: 16]				ifFalse: [n := self readIDLIntegerFrom: source radix: 8]]		ifFalse: 			[source skip: -1.			n := self readIDLIntegerFrom: source radix: 10].	('.ed' includes: source peek asLowercase)		ifTrue: 			[n := self readIDLFloat: n from: source.			token := (source atEnd not and: [source peek asLowercase == $d])				ifTrue:[source next.					DSTvalueExpr						op: 'fixedPointLiteral'						sel: #fixedPointLiteral						right: n						left: (self collectFloat: start end: source position)]				ifFalse:[					DSTvalueExpr						op: 'floatLiteral'						sel: #floatLiteral						right: n						left: (self collectFloat: start end: source position)]]		ifFalse: [token := n].	tokenType := #number.	hereChar := source next</body><body package="Opentalk-IDL-Compiler">xFraction	source skip: -1.	token := self readIDLFloat: 0 from: source.	tokenType := #number.	hereChar := source next</body><body package="Opentalk-IDL-Compiler">xLeftShiftOrPunctuation	"Saw a $&lt;. Could either be a left shift operator or the beginning of a 	'&lt; positive_int_const&gt;' construct."	source peek == $&lt;		ifTrue: 			[source next.			token := #&lt;&lt;.			tokenType := #binary]		ifFalse: 			[token := hereChar.			tokenType := #ascii74].	hereChar := source next</body><body package="Opentalk-IDL-Compiler">xLetter	"A letter begins either an IDL identifier or a keyword. 	All are terminated by whitespace. 	Tokens can be identifiersor keywords. 	Selectors (in pragmas) are handled during the scanning of pragmas."	| type char |	buffer reset.	buffer nextPut: hereChar.		[char := source next.	char notNil		and: 			[type := typeTable at: char asInteger.			type == #xLetter or: [type == #xDigit]]]		whileTrue: [buffer nextPut: char].	hereChar := char.	token := buffer contents.	(KeywordTable includesKey: token asSymbol)		ifTrue: [tokenType := #word]		ifFalse: [tokenType := #word]</body><body package="Opentalk-IDL-Compiler">xRightShiftOrPunctuation	"Saw a $&gt;. Could either be a left shift operator or the end of a 	'&lt; positive_int_const&gt;' construct."	source peek == $&gt;		ifTrue: 			[source next.			token := #&gt;&gt;.			tokenType := #binary]		ifFalse: 			[token := hereChar.			tokenType := #ascii76].	hereChar := source next</body><body package="Opentalk-IDL-Compiler">xStringLiteral	"An IDL string literal"	| char start v |	buffer reset.	start := source position.	char := source next.	buffer on: (String new: 40).		[char == nil ifTrue: [^self offEnd: 'Unmatched string quote'].	char ~= $"]		whileTrue: 			[char == $\ ifTrue: [char := self scanCharLiteral].			buffer nextPut: char.			char := source next].	v := buffer contents.	token := DSTvalueExpr				op: 'stringLiteral'				sel: #stringLiteral				right: v				left: (self collectString: start end: source position).	hereChar := source next.	tokenType := #string</body></methods><methods><class-id>Opentalk.IDLCompiler</class-id> <category>pseudo types</category><body package="Opentalk-IDL-Compiler">typeCode =	word=#TypeCode [DSTpseudoTypeCode prefix: scope last]</body></methods><methods><class-id>Opentalk.IDLCompiler</class-id> <category>simple types</category><body package="Opentalk-IDL-Compiler">anyType =	word=#any  [DSTtypeAny prefix: scope last]</body><body package="Opentalk-IDL-Compiler">booleanType =	word=#boolean  [DSTtypeBoolean prefix: scope last]</body><body package="Opentalk-IDL-Compiler">charType =	word=#char [DSTtypeCharacter prefix: scope last]</body><body package="Opentalk-IDL-Compiler">fixedPointConstType =	word=#fixed  [DSTtypeFixed prefix: scope last]	"May be need to introduce DSTtypeFixedConst"</body><body package="Opentalk-IDL-Compiler">floatingPointType =	word=#float  [DSTtypeFloat prefix: scope last]  |	word=#double  [DSTtypeDouble prefix: scope last] 	" this branch is moved to signedInt for ease of parsing	|  word=#long word=#double [DSTtypeLongDouble prefix: scope last ] "</body><body package="Opentalk-IDL-Compiler">octetType =	word=#octet    [DSTtypeOctet prefix: scope last]</body><body package="Opentalk-IDL-Compiler">signedInt =	"See floatingPointType for an explanaition of why long double is here"	word=#short [DSTtypeShort prefix: scope last ]	 | 	(word=#long (word=#long [DSTtypeLongLong prefix: scope last ] | 				 word=#double [DSTtypeLongDouble prefix: scope last ] | 					[DSTtypeLong prefix: scope last ]  ))</body><body package="Opentalk-IDL-Compiler">unsignedInt =	word=#unsigned 		(word=#short [DSTtypeUnsignedShort prefix: scope last ] | 		 (word=#long (word=#long [DSTtypeUnsignedLongLong prefix: scope last ] | 					[DSTtypeUnsignedLong prefix: scope last ]  )))</body><body package="Opentalk-IDL-Compiler">wideCharType =	word=#wchar [DSTtypeWideCharacter prefix: scope last]</body></methods><methods><class-id>Opentalk.IDLCompiler</class-id> <category>number parsing</category><body package="Opentalk-IDL-Compiler">readIDLFloat: integerPart from: aStream 	"The integer part has already been scanned and is passed in as 'integerpart'.  This method expects to scan in the fractional part, including the exponent.  It handles the cases where there is no fractional part (only the '.') and the case where there is no exponent.  	Versions of this method prior to 5i.4 could not deal with a pragma version as the very last statement, if there was no further character, hence the replacement of 'aStream peek asLowercase == $e' with '(aStream atEnd not and: [aStream peek asLowercase == $e])'."	| value precision digit num den exp neg endOfNumber |	precision := 1.	num := 0.	den := 1.	(aStream peekFor: $.)		ifTrue: ["&lt;integer&gt;.&lt;fraction&gt; -- scan the fraction"			(aStream atEnd not and: [aStream peek isDigit])				ifTrue: 					[| atEnd |					num := 0.					precision := 0.					[(atEnd := aStream atEnd) or: [(digit := aStream next) isDigit not]]						whileFalse: 							[num := num * 10 + digit digitValue.							precision := precision + 1].					den := 10 ** precision.					atEnd ifFalse: [aStream skip: -1]]				ifFalse: ["just &lt;integer&gt;."]].	exp := 0.	(aStream atEnd not and: [aStream peek asLowercase == $e])		ifTrue: 			[aStream next.			endOfNumber := aStream position.			aStream peekFor: $+.			neg := aStream peekFor: $-.			((digit := aStream peek) notNil and: [digit isDigit])				ifTrue: 					[exp := self readIDLIntegerFrom: aStream radix: 10.					neg ifTrue: [exp := exp negated].					precision := precision - exp]				ifFalse: [aStream position: endOfNumber]].	value := integerPart + (num / den) * (10 raisedTo: exp).	^value asDouble</body><body package="Opentalk-IDL-Compiler">readIDLIntegerFrom: aStream radix: radix 	| digit value |	value := 0.	[aStream atEnd]		whileFalse: 			[digit := aStream next digitValue.			(digit &lt; 0 or: [digit &gt;= radix])				ifTrue: 					[aStream skip: -1.					^value]				ifFalse: [value := value * radix + digit]].	^value</body></methods><methods><class-id>Opentalk.IDLCompiler</class-id> <category>pragmas</category><body package="Opentalk-IDL-Compiler">accessPragma	| prag | 	prag := DSTAccessPragma new.	self skip; scanPragmaToken.	prag name: token.	self skip; scanPragmaToken.	prag accessRights: token.	scope last addPragma: prag.	self scanToken</body><body package="Opentalk-IDL-Compiler">classPragma	| prag |	prag := DSTClassPragma new.	self skip; scanPragmaToken.	prag name: token.	self skip; scanPragmaToken.	prag className: token.	scope last addPragma: prag.	self scanToken</body><body package="Opentalk-IDL-Compiler">idPragma	| prag |	prag := DSTIDPragma new.	self skip; scanPragmaToken.	prag name: token.	self skip; scanRepositoryId.	prag repositoryId: (RepositoryId fromString: token).	scope last addPragma: prag.	self scanToken</body><body package="Opentalk-IDL-Compiler">prefixPragma	| block |	self skip; xStringLiteral.	block := scope last.	block prefix: (IDLPrefix prefix: token value container: block container).	self scanToken</body><body package="Opentalk-IDL-Compiler">scanPragmaToken	buffer reset.	[(tokenType := typeTable at: hereChar asInteger) == #xDelimiter]		whileFalse: 			[hereChar == nil ifTrue: [^self offEnd: 'Unterminated pragma'].			buffer nextPut: hereChar.			hereChar := source next].	token := buffer contents trim</body><body package="Opentalk-IDL-Compiler">scanRepositoryId	"Scan a repository id. It can be one of three forms: 	1) IDL:&lt;some path&gt;:version 	2) DCE:uuid:version 	3) LOCAL:&lt;a string&gt;."	buffer reset.	[(hereChar := source next) == $"]		whileFalse: 			[hereChar == nil ifTrue: [^self offEnd: 'Unterminated pragma'].			buffer nextPut: hereChar].	token := buffer contents trim.	hereChar := source next</body><body package="Opentalk-IDL-Compiler">scanVersion	"Scan a version pragma"	self xDigit.	token := token value asFloat asString</body><body package="Opentalk-IDL-Compiler">selectorPragma	| prag |	prag := DSTSelectorPragma new.	self skip; scanPragmaToken.	prag name: token.	self skip; scanPragmaToken.	prag selector: token.	scope last addPragma: prag.	self scanToken</body><body package="Opentalk-IDL-Compiler">versionPragma	| prag |	prag := DSTVersionPragma new.	self skip; scanPragmaToken.	prag name: token.	self skip; scanVersion.	prag version: token.	scope last addPragma: prag.	self scanToken</body><body package="Opentalk-IDL-Compiler">xPragma	"process a pragma declaration, adding the successful result to the 	currentPragma"	| msg |	self xLetter.	token = '#pragma' ifFalse: [^self notify: 'Other preprocessing than #pragma is not supported'].	self skip; xLetter.	token := token asUppercase.	token = 'SELECTOR' ifTrue: [^self selectorPragma].	token = 'CLASS' ifTrue: [^self classPragma].	token = 'PREFIX' ifTrue: [^self prefixPragma].	token = 'VERSION' ifTrue: [^self versionPragma].	token = 'ID' ifTrue: [^self idPragma].	token = 'ACCESS' ifTrue: [^self accessPragma].	buffer reset.	[self endOfLineComment: (hereChar := source next)]		whileFalse: [buffer nextPut: hereChar].	buffer nextPut: source next.	hereChar := source next.	msg := 'Ignoring unknown pragma: #pragma ' , buffer contents.	"ORBDaemon configurationManager log: msg withCRs."	self scanToken</body></methods><methods><class-id>Opentalk.IDLCompiler</class-id> <category>constant syntax</category><body package="Opentalk-IDL-Compiler">addExp  =	multExp 		($+  addExp  [DSTvalueExpr op: '+' sel: #plus right: stack removeLast left: stack removeLast]  |		$-  addExp  [DSTvalueExpr op: '-' sel: #minus right: stack removeLast left: stack removeLast]  |			 )</body><body package="Opentalk-IDL-Compiler">andExp  =	shiftExp 		($&amp;  andExp  [DSTvalueExpr op: '&amp;' sel: #and right: stack removeLast left: stack removeLast]  |			 )</body><body package="Opentalk-IDL-Compiler">charLit	"parse a character literal and leave it on the stack. return a success 	boolean"	tokenType == #characterLiteral ifFalse: [^false].	stack add: token.	token := hereChar.	hereChar := source next.	tokenType := typeTable at: token asInteger.	^true</body><body package="Opentalk-IDL-Compiler">characterLiteral =	[self charLit] ?</body><body package="Opentalk-IDL-Compiler">constDecl =	word=#const  [DSTconstant prefix: scope last] constType  typeIdentifier  $=  constExp			[: t:i:v:]</body><body package="Opentalk-IDL-Compiler">constExp  =		orExp</body><body package="Opentalk-IDL-Compiler">constType  =	integerType |	charType  |	wideCharType  |			booleanType  |	floatingPointType  |	wideStringType  |			stringType  |	fixedPointConstType | 	scopedName [DSTtypeNamed new initialize: stack removeLast]</body><body package="Opentalk-IDL-Compiler">leftShift =	 #&lt;&lt;</body><body package="Opentalk-IDL-Compiler">literal  =	number | 	characterLiteral  | 	string+  [combine:]  |	word=#TRUE [DSTvalueExpr op: 'TRUE' sel: #bool right: true left: nil]  |	word=#FALSE [DSTvalueExpr op: 'FALSE' sel: #bool right: false left: nil]</body><body package="Opentalk-IDL-Compiler">multExp  =	unaryExp 		($*  multExp  [DSTvalueExpr op: '*' sel: #mult right: stack removeLast left: stack removeLast]  |		$/  multExp  [DSTvalueExpr op: '/' sel: #div right: stack removeLast left: stack removeLast]  |		$%  multExp  [DSTvalueExpr op: '%' sel: #mod right: stack removeLast left: stack removeLast]  |			 )</body><body package="Opentalk-IDL-Compiler">orExp  =	xorExp 		($|  orExp  [DSTvalueExpr op: '|' sel: #or right: stack removeLast left: stack removeLast]  |			 )</body><body package="Opentalk-IDL-Compiler">primaryExp =	literal  |	scopedName  [DSTvalueNamed new initialize: stack removeLast]  |	$(  constExp  $) [DSTvalueExpr op: '' sel: #nest right: stack removeLast left: nil]</body><body package="Opentalk-IDL-Compiler">rightShift =	 #&gt;&gt;</body><body package="Opentalk-IDL-Compiler">shiftExp  =        addExp                (rightShift  shiftExp  [DSTvalueExpr op: '&gt;&gt;' sel: #shRight right: stack removeLast left: stack removeLast]  |                 leftShift  shiftExp  [DSTvalueExpr op: '&lt;&lt;' sel: #shLeft right: stack removeLast left: stack removeLast]  |  )</body><body package="Opentalk-IDL-Compiler">unaryExp  =	$-  primaryExp  [DSTvalueExpr op: '-' sel: #neg right: stack removeLast left: nil]  |	$~  primaryExp  [DSTvalueExpr op: '~' sel: #complement right: stack removeLast left: nil]  |	$+  primaryExp  [DSTvalueExpr op: '+' sel: #unaryPlus right: stack removeLast left: nil]  |	primaryExp</body><body package="Opentalk-IDL-Compiler">xorExp  =	andExp 		($^  xorExp  [DSTvalueExpr op: '^' sel: #xor right: stack removeLast left: stack removeLast]  |			 )</body></methods><methods><class-id>Opentalk.IDLCompiler</class-id> <category>public access</category><body package="Opentalk-IDL-Compiler">parse: sourceCode in: aClass notifying: aRequestor 	"Compile the incoming text and answer with the resulting 	parse tree. This is the only public message that saves the 	source map and the comments. If the requestor is nil, 	warning messages (as opposed to outright errors) are silently 	discarded."	self setClass: aClass.	self		init: sourceCode		notifying: aRequestor		failBlock: [^nil].	self method ifFalse: [self unexpectedError].	tokenType == #doIt ifFalse: [self notify: 'End of method expected'].	stack size = 1 ifFalse: [self notify: 'Stack size error, compiler bug!'].	^stack last value</body><body package="Opentalk-IDL-Compiler">parseSelector: methodSourceString	"Treating the argument as an IDL definition, answer the selector	under which the definition would be stored in the repository class,	or nil if the argument cannot be parsed."	| definition |	definition :=		[self			parse: methodSourceString 			in: UndefinedObject 			notifying: (SignallingCompilerErrorHandler handler: SilentCompilerErrorHandler new)]				on: CompilerError do: [:ex | ^nil].	^definition name</body><body package="Opentalk-IDL-Compiler">parseSelectorInterval: methodSourceString	| id start |	id := self parseSelector: methodSourceString.	id isNil ifTrue: [^1 to: 0].	start := methodSourceString indexOfSubCollection: id startingAt: 1.	^start to: start + id size - 1</body></methods><methods><class-id>Opentalk.IDLCompiler</class-id> <category>scope stack</category><body package="Opentalk-IDL-Compiler">popScopeBlock: aContainer 	self processScopeBlock: aContainer.	scope removeLast.	^aContainer</body><body package="Opentalk-IDL-Compiler">processScopeBlock: aContainer 	"Branch on whether the container of the last scope is nil."	| block |	block := scope last.	block container isNil		ifTrue:	[ self processScopeBlockWithNil: aContainer ]		ifFalse:	[ self processScopeBlockWithoutNil: aContainer ]</body><body package="Opentalk-IDL-Compiler">processScopeBlockWithNil: aContainer 	"Versions of the IDLCompiler prior to 5i.4 could not deal with a pragma version for modules, because the container of the scope block was nil.  This method handles that case."	| block |	block := scope last.	block pragmas do: [:e |		e name asSymbol = aContainer name			ifTrue: [e applyTo: aContainer]			ifFalse: [				| msg |				msg := 'Warning: ' , e asString , ' not applied -- ' , e name , ' not found in this scope.'.				"ORBDaemon configurationManager log: msg withCRs."				Dialog notify: msg]]</body><body package="Opentalk-IDL-Compiler">processScopeBlockWithoutNil: aContainer 	"Process all the collected pragmas.  The pragmas are collected into an ordered collection. The first entry is always the prefix and is discarded. The second entry is the metacontainer to which this scope is attached. All pragmas are evaluated relative to this container following IDL's name scoping rules."	| block container mo msg |	block := scope last.	container := block container.	block pragmas do: [:e | (aContainer isKindOf: DSTMetaContainer)			ifTrue: 				[mo := container lookup: e name.				mo isNil ifFalse: [e applyTo: mo]					ifTrue: 						[msg := 'Warning: ' , e asString , ' not applied -- ' , e name , ' not found in this scope.'.						"ORBDaemon configurationManager log: msg withCRs."						Dialog notify: msg]]			ifFalse: [e applyTo: aContainer]]</body><body package="Opentalk-IDL-Compiler">pushScopeBlock: aContainer 	"Push a containing scope. Also set the parent for the new container."	| block |	block := scope last.	aContainer prefix: block prefix.	aContainer definedIn: block container.	scope addLast: (ScopeBlock prefix: block prefix container: aContainer).	^aContainer</body></methods><methods><class-id>Opentalk.IDLCompiler</class-id> <category>type syntax</category><body package="Opentalk-IDL-Compiler">baseTypeSpec =	floatingPointType  |	integerType  |	charType  |	wideCharType  |		booleanType  |	octetType  |	anyType |	typeCode</body><body package="Opentalk-IDL-Compiler">complexDeclarator =	arrayDeclarator</body><body package="Opentalk-IDL-Compiler">declarator =	@complexDeclarator  |	simpleDeclarator</body><body package="Opentalk-IDL-Compiler">declarators =	declarator\$,</body><body package="Opentalk-IDL-Compiler">description =		[| p |	p := currentComment.	currentComment := nil.	p isNil		ifTrue: [stack removeLast]		ifFalse: [stack removeLast definition: p]]</body><body package="Opentalk-IDL-Compiler">integerType =	signedInt |	unsignedInt</body><body package="Opentalk-IDL-Compiler">paramTypeSpec	"	***This is decompiled code.*** 	This may reflect a problem with the configuration of your image 	and its sources and changes files. 	Please refer to the documentation and the settings tool for help in 	setting up the proper source code files."	self baseTypeSpec ifTrue: [^true].	self stringType ifTrue: [^true].	self wideStringType ifTrue: [^true].	self fixedPointType ifTrue: [^true].	self scopedName		ifTrue: 			[stack addLast: (DSTtypeNamed new initialize: stack removeLast).			^true].	^false</body><body package="Opentalk-IDL-Compiler">simpleDeclarator =	identifier [(DSTdeclaratorSimple prefix: scope last) initialize: stack removeLast]</body><body package="Opentalk-IDL-Compiler">simpleDeclarators =	simpleDeclarator\$,</body><body package="Opentalk-IDL-Compiler">simpleTypeSpec =	baseTypeSpec  |	templateTypeSpec  |	scopedName [DSTtypeNamed new initialize: stack removeLast]</body><body package="Opentalk-IDL-Compiler">typeDecl =	(word=#typedef  typeDeclarator  |	structType  |	unionType  |	enumType)</body><body package="Opentalk-IDL-Compiler">typeDeclarator =	typeSpec  declarators		[ generateTypeAliases: declarators: ]	[ stack removeLast do: [:e | stack add: e]].</body><body package="Opentalk-IDL-Compiler">typeSpec =	constructedTypeSpec	|	simpleTypeSpec</body></methods><methods><class-id>Opentalk.IDLCompiler</class-id> <category>type stackops</category><body package="Opentalk-IDL-Compiler">generateTypeAliases: aType declarators: decls 	"Generate a type alias and connect it to the list of declarators."	^decls		collect: 			[:d | 			d resolveTo: aType.			(DSTtypeAlias prefix: scope last)				initialize: d type: aType]</body></methods><methods><class-id>Opentalk.IDLCompiler</class-id> <category>private</category><body package="Opentalk-IDL-Compiler">endOfDefinition: arg  	"The IDL compiler is at the end of an IDL definition. The calling 	method, compile:in:notifying:ifFail:, expects to be at end of file 	which is represented by a tokenType with the value #doIt. But since 	we may be compiling an IDL file containing multiple definitions 	tokenType may not be #doIt at this point. If tokenType is not #doIt 	then this routine will set it to #doIt and backup the source stream to 	the mark."	tokenType == #doIt		ifFalse: 			[tokenType := #doIt.			source position: prevEnd].	^arg</body><body package="Opentalk-IDL-Compiler">endOfLineComment: aCharacter 	"Normally the end of line character is a Character cr (the Smalltalk 	default). 		However when dealing with external streams this can get 	complicated. External streams use the platform's lineEndConvention 	and lineEndCharacter to translate to the Smalltalk default (CR). For 	example, on a PC the lineEndConvention is CRLF and the 	lineEndCharacter is CR. On an input request (next) the CRLF will be 	converted to a CR. On outupt (nextPut:) a CR will be translated to a 	CRLF. The conventions for UNIX are lineEndConvention = LF and 	lineEndCharacter = LF. 		A problem arises when a file created on one platform is moved to 	another. The receiving platform does not know the conventions used 	to create the file. This causes problems for any software which 	is scanning for end of line. This routine attempts to decipher what 	the line convention of the file is regardless of the current platform 	convention. 		If a LF is seen then assume that this is a unix file being read by a PC 	and consider the LF the end of line. 	If a CR is seen then normally this would be end of line. But also 	check for the next character being a LF (which is true if this is a PC 	file being read on a Unix platform)."	aCharacter == nil ifTrue: [^true].	aCharacter == Character lf ifTrue: [^true].	aCharacter == Character cr		ifTrue: 			[source peek == Character lf ifTrue: [source next].			^true].	^false</body></methods><methods><class-id>Opentalk.IDLCompiler</class-id> <category>code generation</category><body package="Opentalk-IDL-Compiler">combine: aString with: anotherStr	"combine strings in a scoped name"	| st | 	st := aString asString , '::' , anotherStr asString.	^st asSymbol</body><body package="Opentalk-IDL-Compiler">makeGlobalName: string	"make a globally scoped name"	 ^('::' , string) asSymbol</body></methods><methods><class-id>Opentalk.IDLCompiler</class-id> <category>primitives</category><body package="Opentalk-IDL-Compiler">enumIdentifier  =	identifier [(stack last select: [:ch | ch isLowercase]) isEmpty  | EnforceNaming not] ?</body><body package="Opentalk-IDL-Compiler">identifier  =	word\$_  [stack last size = 1 | EnforceNaming not] ?		[| st ar | 			ar := stack removeLast.			st := ar at: 1.			2 to: ar size do: [:s| st := st , '_' , (ar at: s)].			st asSymbol]</body><body package="Opentalk-IDL-Compiler">opIdentifier  =	identifier [(stack last at: 1) isLowercase | EnforceNaming not] ?</body><body package="Opentalk-IDL-Compiler">scopedName  =	twoColons scopedNameTail [makeGlobalName: ] | 	scopedNameTail</body><body package="Opentalk-IDL-Compiler">scopedNameTail  =	 identifier (@twoColons  scopedNameTail  [combine:with: ] |  )</body><body package="Opentalk-IDL-Compiler">twoColons  =	$:  $:</body><body package="Opentalk-IDL-Compiler">typeIdentifier  =	identifier [(stack last at: 1) isUppercase | EnforceNaming not] ?</body></methods><methods><class-id>Opentalk.IDLCompiler</class-id> <category>exception syntax</category><body package="Opentalk-IDL-Compiler">exceptDecl  =	word=#exception  [DSTexception prefix: scope last] opIdentifier  		${  member*  $}  [: id: members:]</body></methods><methods><class-id>Opentalk.IDLCompiler</class-id> <category>formatting</category><body package="Opentalk-IDL-Compiler">format: sourceCode in: aClass notifying: aRequestor 	| text mo |	DSTMetaObject initializeCurrentPrefix.	text := self				subFormat: sourceCode				in: aClass				notifying: aRequestor.	text == nil		ifTrue: [^nil]		ifFalse: 			[mo := stack removeLast value.			(mo isKindOf: DSTMetaObject)				ifTrue: [mo removeMetaObject].			^text asText]</body><body package="Opentalk-IDL-Compiler">subFormat: sourceCode in: aClass notifying: aRequestor 	"Format the source code if possible. 	If not, return nil and let the default compiler do it."	| mo |	^Cursor wait		showWhile: 			[mo := self						parse: sourceCode						in: aClass						notifying: aRequestor.			mo isNil ifFalse: [mo getIDLDefinition]				ifTrue: []]</body></methods><methods><class-id>Opentalk.IDLCompiler</class-id> <category>constant stackops</category><body package="Opentalk-IDL-Compiler">combine: stArray 	"return the concatenation of the strings in the array"	stArray size = 1		ifTrue: [^stArray at: 1]		ifFalse: [^DSTvalueExpr				op: ' '				sel: #concat				right: (self combine: (stArray copyFrom: 2 to: stArray size))				left: (stArray at: 1)]</body></methods><methods><class-id>Opentalk.IDLCompiler</class-id> <category>attribute syntax</category><body package="Opentalk-IDL-Compiler">attrDecl  =	((word=#readonly word=#attribute  [DSTattribute prefix: scope last] [true]  		paramTypeSpec  simpleDeclarators 		[: declarators: ])  |	(word=#attribute  [DSTattribute prefix: scope last] [false]  		paramTypeSpec  simpleDeclarators		[: declarators: ]))			[: r: t:]</body></methods><methods><class-id>Opentalk.IDLCompiler</class-id> <category>subclass responsibility</category><body package="Opentalk-IDL-Compiler">method = 	"Parse an IDL definition, leaving the parsed representation, either a parse tree or 	Smalltalk source code, as the sole item on the stack"	definition	[popScopeBlock: ]	[| if |  if := stack removeLast.		if printName -&gt; if]	[endOfDefinition:]</body></methods><methods><class-id>Opentalk.IDLCompiler</class-id> <category>initialize-release</category><body package="Opentalk-IDL-Compiler">initScanner	"initialize my scanner tables"	super initScanner.	typeTable := typeTable copy.	typeTable at: $' asInteger put: #xCharacterLiteral.	typeTable at: $" asInteger put: #xStringLiteral.	typeTable at: $/ asInteger put: #xCommentOrDivide.	typeTable at: $# asInteger put: #xPragma.	typeTable at: $_ asInteger put: #xLetter.	typeTable at: $&lt; asInteger put: #xLeftShiftOrPunctuation.	typeTable at: $&gt; asInteger put: #xRightShiftOrPunctuation.	typeTable at: $. asInteger put: #xFraction.	scope := OrderedCollection with: ScopeBlock new</body></methods><methods><class-id>Opentalk.IDLCompiler class</class-id> <category>public access</category><body package="Opentalk-IDL-Compiler">preprocess: aStream 	"This method is called by the IDL importation methods to preprocess 	the IDL source. It must return a stream representing the 	preprocessed IDL. 		This routine can be modified to suit whatever 	preprocessor that is used. For example, if the DLL/C connect 	preprocessor is used then the body of this method might be: 	^CPreprocessor preprocess: aStream 	By default this method just returns its argument stream. 	"	^aStream</body></methods><methods><class-id>Opentalk.IDLCompiler class</class-id> <category>class initialization</category><body package="Opentalk-IDL-Compiler">initialize	"initialize the receiver"	| charLits keywords |	EnforceNaming := false.	charLits := IdentityDictionary new.	charLits at: $n put: Character lf.	charLits at: $t put: Character tab.	charLits at: $v put: (Character value: 11).	charLits at: $b put: Character backspace.	charLits at: $r put: Character cr.	charLits at: $f put: Character newPage.	charLits at: $a put: (Character value: 7).	charLits at: $\ put: $\.	charLits at: $? put: $?.	charLits at: $' put: $'.	charLits at: $" put: $".	CharacterLiteralTable := charLits.	keywords := IdentityDictionary new.	#('any' 'attribute' 'boolean' 'case' 'char' 'const' 'context' 'default' 'double' 'enum' 'exception' 'FALSE' 'fixed' 'float' 'in' 'inout' 'interface' 'long' 'module' 'octet' 'oneway' 'out' 'raises' 'readonly' 'sequence' 'short' 'string' 'struct' 'switch' 'TRUE' 'TypeCode' 'typedef' 'unsigned' 'union' 'void' 'wchar' 'wstring' 'fixed') do: [:keyword | keywords add: keyword asSymbol -&gt; nil].	KeywordTable := keywords</body><body package="Opentalk-IDL-Compiler">release	"release class variables"	CharacterLiteralTable := EnforceNaming := KeywordTable := nil</body></methods><methods><class-id>Opentalk.IDLCompiler class</class-id> <category>private</category><body package="Opentalk-IDL-Compiler">computeTables	"Compute the character type, reserved word tables, and 	keyword flag from the information associated with each method."	| words types kwds info typeInfo allMethods allSelectors |	self superclass computeTables.	words := Set new.	types := TypeTable copy.	kwds := false.	allMethods := self superclass methodInfo copy.	allMethods addAll: self methodInfo associations.	allSelectors := self superclass selectors.	allSelectors addAll: methodDict keys.	allMethods keys do: [:selector | (allSelectors includes: selector)			ifTrue: 				[info := allMethods at: selector.				words addAll: (info at: 1).				typeInfo := info at: 2.				typeInfo isEmpty ifFalse: [typeInfo associationsDo: [:char | types at: char key asInteger put: char value]].				kwds := kwds | (info at: 3)]			ifFalse: [methodInfo removeKey: selector ifAbsent: []]].	reservedWords := words isEmpty				ifTrue: [false]				ifFalse: [words].	typeTable := types.	hasKeywords := kwds</body></methods><methods><class-id>Opentalk.IDLCompiler class</class-id> <category>accessing</category><body package="Opentalk-IDL-Compiler">enforceNamingConventions: bool 	"Controls the checking of identifier syntax. 		If true: 	- 'identifier' accepts only one legal Smalltalk identifier. 	- 'enumIdentifier' accepts only uppercase letters in 	'identifier'. 	- 'typeIdentifier' accepts only capitalized 'identifier'. 	- 'opIdentifier' accepts only 'identifier' starting with lowercase 	letter. 		If false (default): 	- 'identifier' accepts multiple legal Smalltalk identifiers 	separated by an underscore. 	- 'enumIdentifier' same as 'identifier'. 	- 'typeIdentifier' same as 'identifier'. 	- 'opIdentifier' same as 'identifier'. 	"	EnforceNaming := bool</body><body package="Opentalk-IDL-Compiler">preferredParserClass	^self</body></methods><methods><class-id>Opentalk.DSTIDPragma</class-id> <category>accessing</category><body package="Opentalk-IDL-Compiler">repositoryId	^repositoryId</body><body package="Opentalk-IDL-Compiler">repositoryId: aRepositoryId 	repositoryId := aRepositoryId</body></methods><methods><class-id>Opentalk.DSTIDPragma</class-id> <category>actions</category><body package="Opentalk-IDL-Compiler">applyTo: aMetaObject 	"set the repository id of the meta object from the pragma."	| msg |	(aMetaObject canApplyPragma: #ID)		ifTrue: [aMetaObject repositoryId: self repositoryId]		ifFalse: 			[msg := 'Id pragma not allowed on ' , aMetaObject displayString.			"ORBDaemon configurationManager log: msg withCRs."			Dialog notify: msg]</body></methods><methods><class-id>Opentalk.DSTIDPragma</class-id> <category>printing</category><body package="Opentalk-IDL-Compiler">printOn: aStream 	"print the receiver's printname on the stream"	aStream nextPutAll: '#pragma ID ' , name , ' ' , repositoryId asString</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>DST</category><body package="Opentalk-IDL-Compiler">trim	"Return a copy of the receiver which has 	no trailing spaces or control chars."	| i |	i := self size.	[i &gt; 0 and: [(self at: i) asInteger &lt;= 32]]		whileTrue: [i := i - 1].	^self copyFrom: 1 to: i</body></methods><initialize><class-id>Opentalk.IDLCompiler</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>CharacterArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>ExternalLanguageParser</name><environment>Kernel</environment><super>Kernel.GeneralParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AT-ParserCompiler</category><attributes><package>AT Parser Compiler</package></attributes></class></st-source>