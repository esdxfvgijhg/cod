<?xml version="1.0"?><st-source><!-- Name: Opentalk-IDL-MetaObjectsNotice: Copyright 1999-2013 Cincom Systems, Inc.  All rights reserved.Comment: IDL meta objects representing specific IDL constructs. These directly control the marshaling process.DbIdentifier: bear73DbTrace: 400725DbUsername: nrossDbVersion: 7.10 - 1DevelopmentPrerequisites: #(#(#any 'Opentalk-CDR' '') #(#any 'Opentalk-IDL-Base' ''))PackageName: Opentalk-IDL-MetaObjectsParcel: #('Opentalk-IDL-MetaObjects')PrerequisiteParcels: #(#('Opentalk-CDR' '') #('Opentalk-IDL-Base' ''))PrintStringCache: (7.10 - 1,nross)Version: 7.10 - 1Date: 11:27:07 AM April 12, 2013 --><time-stamp>From VisualWorksÂ®, Pre-Release 7.10 (apr13.2) of April 12, 2013 on April 12, 2013 at 11:27:07 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>DSTORBObject</name><environment>Opentalk</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>accessControlList </inst-vars><class-inst-vars>abstractClassId classAbstractClassId accessControlList </class-inst-vars><imports></imports><category>CORBA-Core</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></class><comment><class-id>Opentalk.DSTORBObject</class-id><body>Instance Variables:	accessControlListShared Variables:	AccessSymbols	BOAid	Factories	InstallDir	InterfaceRepository	LocalRepository	NamingService	ProfilerObj	Profiling		RemoteRepository	RepositoryCache	Services	SharedRepositoryModule</body></comment><class><name>DSTMetaObject</name><environment>Opentalk</environment><super>Opentalk.DSTORBObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name definedIn definition version repositoryId prefix </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></class><comment><class-id>Opentalk.DSTMetaObject</class-id><body>The CORBA architecture is independent of the programming language used to construct clients or implementations.  In order to use the ORB, it is necessary for programmers to know how to access ORB functionality from their particular programming languages.This class, in conjunction with its subclasses and the immediate subclasses of ORBObject, implement the mapping to the Smalltalk programming language.  These classes provide the Smalltalk programmer with mechanisms for expressing the following IDL concepts:1. All IDL basic datatypes (see class DSTtypeBase)2. All IDL constructed datatypes (see class DSTtypeConstr &amp; DSTtypeTemplate)3. References to constants defined in IDL (see class DSTconstant)4. References to objects defined in IDL (see class DSTObjRef)5. Invocations of operations, including passing parameters and receiving results. (see class DSToperation &amp; DSTparameter)6. Exceptions, including what happens when an operation raises an exception and how the exception parameters are accessed. (see class DSTexception)7. Access to attributes (see class DSTattribute)8. Signatures for the operations defined by the ORB, such as the dynamic invocation interface, the object adapters, etc. (see class ORBObject)In addition to defining the language mapping from IDL to Smalltalk, these meta objects are themselves remotely accessible and provide the Interface Repository behavior which is defined for all CORBA implementations.Subclasses must implement the following messages:	TypeCode		marshallTypeCode:on:		typeKind	printing		printDefinitionOn:indent:style:	accessing		descriptionInstance Variables	name 		 &lt;String | Symbol&gt;		printname	repositoryId 	 &lt;RepositoryId&gt;			global unique identifier	version		&lt;String&gt;					the major.minor version number as a string	prefix		&lt;String&gt;					the prefix pragma prefix for this meta object	definedIn 	 &lt;DSTMetaObject&gt;		defining metaobject ("container")	definition	 &lt;String&gt;				optional commentShared Variables	TCTable	&lt;Dictionary key: Integer value: (DSTMetaObject | nil)&gt;  type code table used during unmarshalling to decode typecodes into metaobject	CurrentPrefix	&lt;String&gt;		used by the IDL formatting facility to keep track of the current prefix. Used to decide								when a prefix pragma must be emitted.</body></comment><class><name>DSTtype</name><environment>Opentalk</environment><super>Opentalk.DSTMetaObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>declarators localtype localclass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></class><comment><class-id>Opentalk.DSTtype</class-id><body>Subclasses must implement the following messages:	marshalling		marshall:on:		unMarshall:		typeKind		Instance variables:	declarators 		&lt;Array&gt;	localtype 		&lt;DSTtypeAny&gt;	localclass		&lt;Symbol&gt;</body></comment><class><name>DSTtypeSimple</name><environment>Opentalk</environment><super>Opentalk.DSTtype</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></class><comment><class-id>Opentalk.DSTtypeSimple</class-id><body>This is an abstract class which is used purely for organization of IDL type object classes</body></comment><class><name>DSTtypeNamed</name><environment>Opentalk</environment><super>Opentalk.DSTtypeSimple</super><private>false</private><indexed-type>none</indexed-type><inst-vars>equivalentType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></class><comment><class-id>Opentalk.DSTtypeNamed</class-id><body>Instances of this class are produced by the IDL compiler whenever identifiers are parsed in IDL definitions.  At Repository initialization time, each DSTtypeNamed is matched with a corresponding DSTinterface, DSTdeclaratorSimple, or DSTdeclaratorComplex instances which is registered in the repository.  This is done by searching the outward from the scope in which the name is used until the intended definition is encountered.Instance Variables:	equivalentType	&lt;DSTtypeAny&gt;</body></comment><class><name>DSTtypeBase</name><environment>Opentalk</environment><super>Opentalk.DSTtypeSimple</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></class><comment><class-id>Opentalk.DSTtypeBase</class-id><body>Smalltalk magnitude classes map directly onto the required IDL basic datatypes, and the subclasses of this abstract class are concerned with their representation in all situations.  In addition, instances of these subclasses perform marshalling and unmarshalling operations related to remote procedure call semantics.</body></comment><class><name>DSTtypeFloat</name><environment>Opentalk</environment><super>Opentalk.DSTtypeBase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></class><comment><class-id>Opentalk.DSTtypeFloat</class-id><body>Float and Double values are used by the Smalltalk programmer to represent IDL float and double types in all situations</body></comment><class><name>DSTtypeConstr</name><environment>Opentalk</environment><super>Opentalk.DSTtype</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></class><comment><class-id>Opentalk.DSTtypeConstr</class-id><body>IDL type-enumeration, type-structure, and type-union are the most difficult types to map effectively onto Smalltalk language constructs.  See each class comment for details</body></comment><class><name>DSTtypeTemplate</name><environment>Opentalk</environment><super>Opentalk.DSTtypeSimple</super><private>false</private><indexed-type>none</indexed-type><inst-vars>size subtype </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></class><comment><class-id>Opentalk.DSTtypeTemplate</class-id><body>This class provides shared implementation between IDL sequence and string datatypes.  No actual instances of this class are created.Instance Variables:	size 		&lt;Integer&gt;	subtype		&lt;DSTtypeAny&gt;</body></comment><class><name>DSTtypeString</name><environment>Opentalk</environment><super>Opentalk.DSTtypeTemplate</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></class><comment><class-id>Opentalk.DSTtypeString</class-id><body>Smalltalk strings and their subclasses may be passed and will be returned by IDL operations involving type-string arguments.  The Smalltalk class of returned values can be specified using the CLASS= &lt;Smalltalk class name&gt; pragma in the IDL definition.</body></comment><class><name>RepositoryId</name><environment>Opentalk</environment><super>Core.ByteArray</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></class><comment><class-id>Opentalk.RepositoryId</class-id><body>RepositoryIds are used to uniquely identify modules, interfaces, constants, typedefs, exceptions, attributes, and operations within the interface repository. Each repository id is unique within the system (just like symbols). The repository id is represented as a byte array.Shared Variables:	IDTable			&lt;Array of: (Array of: RepositoryId)&gt;  the hash table for all repository ids</body></comment><class><name>DSTdeclaratorSimple</name><environment>Opentalk</environment><super>Opentalk.DSTMetaObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>baseType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></class><comment><class-id>Opentalk.DSTdeclaratorSimple</class-id><body>Declarators are used to name type meta objects within an IDL scope.  In practice, each declarator is registered in the symbol dictionary of its defining meta container and is referenced by DSTtypeNamed instances in other parts of the Repository.  Instance variables:	baseType 	&lt;DSTtypeAny&gt;</body></comment><class><name>DSTtypeAlias</name><environment>Opentalk</environment><super>Opentalk.DSTtypeConstr</super><private>false</private><indexed-type>none</indexed-type><inst-vars>equivalentType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></class><comment><class-id>Opentalk.DSTtypeAlias</class-id><body>A type alias is a first class meta object. Type aliases are created as the resultof a typedef. Type aliases can have class pragmas and thus override the localtype of the type being aliased.Instance variables:	equivalentType	&lt;DSTMetaObject&gt; the type being aliased.</body></comment><class><name>DSTtypeLong</name><environment>Opentalk</environment><super>Opentalk.DSTtypeBase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></class><class><name>DSTtypeLongLong</name><environment>Opentalk</environment><super>Opentalk.DSTtypeLong</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></class><class><name>DSTattributeDescription</name><environment>Opentalk</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name id definedIn version type mode </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></class><class><name>DSTtypeOctet</name><environment>Opentalk</environment><super>Opentalk.DSTtypeBase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></class><comment><class-id>Opentalk.DSTtypeOctet</class-id><body>Character and SmallInteger values may be used by the Smalltalk programmer to represent IDL octet types</body></comment><class><name>DSTparameter</name><environment>Opentalk</environment><super>Opentalk.DSTMetaObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>direction type </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></class><class><name>DSTcachedParameter</name><environment>Opentalk</environment><super>Opentalk.DSTparameter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>typeCodeInfo </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></class><comment><class-id>Opentalk.DSTcachedParameter</class-id><body>This class implements the protocols needed for the shared repository mechanism to cache remote parameters.  This class acts a cached parameter for a meta object stored on a remote system.Instance Variables:	typeCodeInfo	&lt;ByteArray&gt;</body></comment><class><name>DSTtypeCharacter</name><environment>Opentalk</environment><super>Opentalk.DSTtypeBase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></class><comment><class-id>Opentalk.DSTtypeCharacter</class-id><body>Character values are used by the Smalltalk programmer to represent IDL char types in all situations</body></comment><class><name>DSToperationInfo</name><environment>Opentalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>interface operation selector opIndex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></class><comment><class-id>Opentalk.DSToperationInfo</class-id><body>Instance variables:	interface 	&lt;DSTinterface&gt;	operation 	&lt;DSToperation&gt;	selector 	&lt;Symbol&gt;	opIndex 	&lt;Integer&gt;</body></comment><class><name>DSTconstant</name><environment>Opentalk</environment><super>Opentalk.DSTMetaObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>typeSpec valueExpr value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></class><comment><class-id>Opentalk.DSTconstant</class-id><body>IDL constant values are stored in a pool dictionary CORBAConstants under the fully qualified name of the constant.  Each DSTconstant meta object is also an instance of the ConstantDef interface in the Repository, and may be accessed accordingly.Instance variables:	valueExpr	&lt;DSTvalueExpr&gt;	typeSpec 	&lt;DSTtype&gt;	value 		&lt;String&gt;</body></comment><class><name>DSTtypeEnumeration</name><environment>Opentalk</environment><super>Opentalk.DSTtypeConstr</super><private>false</private><indexed-type>none</indexed-type><inst-vars>values </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></class><comment><class-id>Opentalk.DSTtypeEnumeration</class-id><body>Smalltalk Symbols are used to represent IDL type-enumeration values, where the symbol name is identical to the enumerator in all cases.  To preserve the IDL ordering requirements on enumerations, each enumeration type also defines a constant array which contains its values in declaration order.  This constant array may be accessed from the CORBAConstants poolDictionary using the fully scoped name of the type (i.e. CORBAConstants at: #'::MetaTypes::TypeCode::TCKind')Instance Variables:	values	&lt;Array&gt;</body></comment><class><name>DSTtypeUnsignedLongLong</name><environment>Opentalk</environment><super>Opentalk.DSTtypeLongLong</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></class><class><name>ORBConstantsDictionary</name><environment>Opentalk</environment><super>Core.IdentityDictionary</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>exceptions exceptionIndex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Core</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></class><class><name>DSToperation</name><environment>Opentalk</environment><super>Opentalk.DSTMetaObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>localOp signature sync raises context access </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></class><comment><class-id>Opentalk.DSToperation</class-id><body>An operation invocation requires the specification of the object to be invoked, the operation to be performed, and the parameters to be supplied.  A language mapping must therefore address how these basic mechanisms are accessed by the programmer.  For Distributed Smalltalk, a remote method invocation is indistinguishable from a local invocation, i.e. normal Smalltalk syntax is observed.  The only difference to the programmer should be the amount of time required to complete the request.Smalltalk method invocation syntax allows zero or multiple input parameters to be supplied in a call.  For return values, however, IDL allows multiple out parameters to be return from a single invocation.  This is handled by returning an Array with all of the non-in (result, out, inout) parameters included in order of their declaration in the IDL operation declaration.  All parameters are allocated and reclaimed from the Smalltalk heap.IDL also allows inout parameters to be defined.  These parameters are expected to be supplied in the invocation and will be returned as out parameters in the resultant array.  Note that the in and out values will be distinct Smalltalk objects, rather than sharing some portion of the heap together (as in C, for example).  Finally, IDL operations declared to have type-void results but which have a single out or inout parameter are returned as single values just like operations with a single result value and no output parameters:  a single value without an enclosing array.Each DSToperation meta object is also an instance of the OperationDef interface in the Repository, and may be accessed accordingly.Instance Variables:	localOp 		&lt;Symbol&gt; 	the local selector associated with this operation	signature		&lt;DSTsignature&gt; signature 	sync 			&lt;Symbol&gt;		raises 			&lt;Array&gt; 	list of exceptions raised	context 		&lt;Array&gt;		context information	access			&lt;Symbol&gt;	access rights needed for user securityShared Variables:	ContextIF					&lt;DSTtypeSequence | nil&gt;		ServiceContextListDef		&lt;DSTtypeSequence | nil&gt;	</body></comment><class><name>DSTtypeFixed</name><environment>Opentalk</environment><super>Opentalk.DSTtypeConstr</super><private>false</private><indexed-type>none</indexed-type><inst-vars>digits scale </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></class><comment><class-id>Opentalk.DSTtypeFixed</class-id><body>This class is now a placeholder, created so that the TCTable of DSTMetaObject couldbe properly reinitialized.</body></comment><class><name>DSTtypeArray</name><environment>Opentalk</environment><super>Opentalk.DSTtypeTemplate</super><private>false</private><indexed-type>none</indexed-type><inst-vars>arrayType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></class><class><name>DSTMetaContainer</name><environment>Opentalk</environment><super>Opentalk.DSTMetaObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>contents symbols </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></class><comment><class-id>Opentalk.DSTMetaContainer</class-id><body>This class implements the CORBA 1.1 Container interface.  Its two subclasses, DSTinterface and DSTmodule, provide the implementations of InterfaceDef and ModuleDef respectively.Instance Variables:	contents  &lt;OrderedCollection&gt; of the contents of the receiver	symbols  &lt;IdentityDictionary&gt;  holding the contents keyed by their interfaceIDs and by their printNames.</body></comment><class><name>DSTinterface</name><environment>Opentalk</environment><super>Opentalk.DSTMetaContainer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>superiors subordinates sunames epv allSuperiors allOperations myOperations extent key </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></class><comment><class-id>Opentalk.DSTinterface</class-id><body>Interfaces contain definitions of IDL constructs and define the basic unit of abstract type.  Objects in the system are manipulated via object references which each have an associated interface type.  This interface type defines all of the operations and all of the abstract behavior of the object which is accessible to a client.  Object references to local objects supporting IDL interfaces is via the normal Smalltalk object reference mechanism.  To obtain the interface which is associated with the objRef, the user may invoke the getInterface method to return the actual interface meta object which models its type information.  Other calls, from interface InterfaceDef, Container, Contained, and Object may also be invoked on this metaObjRef to further elucidate its nature.Remote object references are handled via references to local surrogate objects which are subclasses of ORBObjRef.  Since access to remote objects is transparent to the Smalltalk programmer, the above sequence of operations may also be applied.  In addition, and when the programmer knows she is dealing with a surrogate objRef, the call #interface will return the local Repository's meta object for that type.  Access to local meta objects is considerably faster, of course.Instance variables:	superiors 		&lt;OrderedCollection&gt; of interfaces from which I inherit	allSuperiors 	&lt;OrderedCollection&gt; of all interfaces from which I inherit	subordinates 	&lt;OrderedCollection&gt; of all interfaces which inherit from me	sunames		&lt;OrderedCollection&gt; of names of superior interfaces	epv 				&lt;OrderedCollection&gt; entry point vector of Smalltalk selectors for myOperations	myOperations	&lt;OrderedCollection&gt; of the operations which I define	allOperations	&lt;OrderedCollection&gt; of all the operations which I define or inherit	extent			&lt;String&gt; ODL extent name	key				&lt;Array&gt; ODL extent keys	persistence 		&lt;Symbol&gt; either #persistent or #transient or nil.  ODL persistence informationShared variables:	ForceI3IfOn	&lt;Boolean&gt; when 'true' and I3 is on, forces use of I3 marshaling even if a applicable IDL interface is available</body></comment><class><name>DSTtypeDouble</name><environment>Opentalk</environment><super>Opentalk.DSTtypeBase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></class><class><name>DSTattribute</name><environment>Opentalk</environment><super>Opentalk.DSTMetaObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>typeSpec readOnly getOp setOp </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></class><comment><class-id>Opentalk.DSTattribute</class-id><body>IDL attribute declarations are a shorthand mechanism of defining pairs of simple accessor operations, one to set the value of the attribute and one to get it.  Such accessor methods are common in Smalltalk programs as well, thus attribute declarations are mapped to standard methods to get and set the named attribute value, respectively.For example:attribute		string		title;means that Smalltalk programmers can expect to make #title and #title: calls to get and set the title attribute of the object.  Each DSTattribute meta object is also an instance of the AttributeDef interface in the Repository, and may be accessed accordingly.Instance variables:	typeSpec 	&lt;DSTtype&gt;	readOnly  	&lt;Boolean&gt;	getOp  		&lt;DSToperation&gt;	setOp  		&lt;DSToperation&gt;</body></comment><class><name>DSTtypeVoid</name><environment>Opentalk</environment><super>Opentalk.DSTtypeSimple</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></class><comment><class-id>Opentalk.DSTtypeVoid</class-id><body>Void values are never manipulated directly, however void results may be defined on operationsShared Variables:		CachedTypeVoid	&lt;DSTtypeVoid&gt;</body></comment><class><name>DSTsignature</name><environment>Opentalk</environment><super>Core.OrderedCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>ins outs return params </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></class><comment><class-id>Opentalk.DSTsignature</class-id><body>Signatures are a subclass of OrderedCollection with some filters for accessing parameters by their direction attributes.Instance Variables:	ins		&lt;DSTsignature&gt;		collection of all of the #in parameters in this signature	outs	&lt;DSTsignature&gt;		collection of all of the #out parameters in this signature	return	&lt;DSTparameter&gt;	 	return parameter of this signature	</body></comment><class><name>DSTtypeStructure</name><environment>Opentalk</environment><super>Opentalk.DSTtypeConstr</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fields allFields useClassMethod useCombinedmethod selector readSelectors writeSelectors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></class><comment><class-id>Opentalk.DSTtypeStructure</class-id><body>Heterogeneous instances of Collection subclasses may be passed as parameter values to IDL operations, assuming that their run-time values can be marshalled by the appropriate type meta objects in the order of field-type specification.  OrderedCollection values containing these instances will be returned by remote operations.In addition, any Smalltalk class which has method selectors with the same names as the fields in the IDL type definition can be used to produce type-structured values for remote calls.  On return parameters, a method of the form #'f1:f2:f3:...:fn:' , where fi are the field names, will be called on the class or on a new instance to properly initialize the result value.  To utilize this capability, the Smalltalk class name must have been declared in a CLASS pragma associated with the IDL type declaration.Instance Variables:	fields				&lt;OrderedCollection&gt;	allFields				&lt;OrderedCollection&gt;	useClassMethod		&lt;Boolean&gt;	useCombinedmethod	&lt;Boolean&gt;	selector				&lt;Symbol&gt;	readSelectors		&lt;OrderedCollection&gt;	writeSelectors		&lt;OrderedCollection&gt;</body></comment><class><name>DSTtypeShort</name><environment>Opentalk</environment><super>Opentalk.DSTtypeBase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></class><class><name>DSTtypeUnsignedShort</name><environment>Opentalk</environment><super>Opentalk.DSTtypeShort</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></class><class><name>DSTmodule</name><environment>Opentalk</environment><super>Opentalk.DSTMetaContainer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></class><comment><class-id>Opentalk.DSTmodule</class-id><body>Modules contain collections of related IDL declarations and form a new naming scope for their identifiers.  Modules may be searched for their contents by accessing them through the method ORBObject class &gt;&gt; lookupName:levels:limit: excludeInherited, or more directly by accessing the ORBObject class &gt;&gt; repository method to return the overall Repository's enclosing module meta object.Each DSTmodule meta object is also an instance of the ModuleDef interface in the Repository, and may be accessed accordingly.</body></comment><class><name>DSTtypeSequence</name><environment>Opentalk</environment><super>Opentalk.DSTtypeTemplate</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></class><comment><class-id>Opentalk.DSTtypeSequence</class-id><body>Instances of Smalltalk Collection subclasses may be passed as sequence values in IDL operations.  Since IDL sequences are all strongly typed to have elements of the same type, this represents a limitation which the Smalltalk programmer must take into consideration when defining interfaces.  For situations where the Smalltalk value of choice is a heterogeneous Collection subclass, consider the use of IDL type-structure instead.IDL sequence values returned from remote operations are instantiated as Smalltalk OrderedCollections by default.  This may be overridden to accept &amp; return any Smalltalk class which has the appropriate #at: and #at:Put: methods by using the CLASS= &lt;Smalltalk class name&gt; pragma in IDL definitions.</body></comment><class><name>DSTcachedOperation</name><environment>Opentalk</environment><super>Opentalk.DSToperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></class><comment><class-id>Opentalk.DSTcachedOperation</class-id><body>This class extends DSToperation to allow it to act as a cached version of an operation stored on a remote system.</body></comment><class><name>DSTtypeBoolean</name><environment>Opentalk</environment><super>Opentalk.DSTtypeBase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></class><comment><class-id>Opentalk.DSTtypeBoolean</class-id><body>Boolean values true and false are used by the Smalltalk programmer to represent IDL boolean types in all situations</body></comment><class><name>DSTvalueNamed</name><environment>Opentalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>definedIn name value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></class><comment><class-id>Opentalk.DSTvalueNamed</class-id><body>Instances of this class are used for IDL of scoped names in union case labels and constant declaration expressions.Instance Variables:	definedIn	&lt;DSTMetaObject&gt;  the defining meta object of the receiver	name		&lt;Symbol&gt;  the IDL name of the receiver	value		&lt;Object&gt;  the value of the receiver</body></comment><class><name>DSTtypeUnion</name><environment>Opentalk</environment><super>Opentalk.DSTtypeConstr</super><private>false</private><indexed-type>none</indexed-type><inst-vars>switchtype cases defaultValue defaultIndex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></class><comment><class-id>Opentalk.DSTtypeUnion</class-id><body>IDL type-unions are represented in Smalltalk by instances of the Association class, where the key of the association is the discriminator value and where the value of the association is the union member.  For proper operation during remote invocation, both the key and the value of the association must be of a type which is compatible with the respective union declaration roles.Instance Variables:	switchtype 	&lt;DSTtypeEnumeration | DSTtypeCharacter | DSTtypeInteger | DSTtypeBoolean | DSTtypeNamed&gt;		IDL type of the switch	cases 		&lt;Array of: DSTUnionCase&gt;	defaultValue &lt;Boolean | Symbol | Integer | Character&gt; a computed sample value that can be used to marshall the default case</body></comment><class><name>DSTtypeWideString</name><environment>Opentalk</environment><super>Opentalk.DSTtypeString</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></class><comment><class-id>Opentalk.DSTtypeWideString</class-id><body>Smalltalk strings and their subclasses may be passed and will be returned by IDL operations involving type-string arguments.  The Smalltalk class of returned values can be specified using the CLASS= &lt;Smalltalk class name&gt; pragma in the IDL definition.</body></comment><class><name>DSTpseudoTypeCode</name><environment>Opentalk</environment><super>Opentalk.DSTtype</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></class><comment><class-id>Opentalk.DSTpseudoTypeCode</class-id><body>A DSTpseudoTypeCode gets created when the TypeCode IDL keyword is seen by the IDL compiler. It is the type codefor a given IDL type.Shared Variables:	TCStreamDef	&lt;DSTtypeSequence&gt;	a type code stream (a sequence of octet).</body></comment><class><name>DSTtypeLongDouble</name><environment>Opentalk</environment><super>Opentalk.DSTtypeBase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></class><class><name>DSToperationDescription</name><environment>Opentalk</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name id definedIn version result mode contexts parameters exceptions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></class><class><name>DSTexception</name><environment>Opentalk</environment><super>Opentalk.DSTMetaObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>members signal </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></class><comment><class-id>Opentalk.DSTexception</class-id><body>Exception handling is implemented using the normal Smalltalk exception handling mechanisms.  Thus to raise an exception, the programmer can merely invoke #error: .  Since IDL exceptions are allowed to have arbitrary structured values returned with the exception, the programmer needs a way to specify this information as well.  Fortunately, Smalltalk is up to the task.  Consider the example Smalltalk fragment which raises the BAD_INV_ORDER exception (one of the standard exceptions defined in interface Object):	^ErrorSignal 		raiseWith: (Array 						with: #'BAD_INV_ORDER' 						with: (Array 								with: minor 								with: #NO))		errorString: ' routine invocations out of order'In order to allow the ORB to correctly return the error result structure to the sender of the method, an array must be returned as the parameter of the error.  Here, the symbolic name of the event is provided in an array along with the type-structure representation of the required error result values.  These values will be marshalled by the ORB to ensure that the same exception can be raised in the context of the client of the remote operation.As with normal Smalltalk exceptions, a #handle:do: recovery block may be used to catch and recover from these exceptions.  The main difference is that the ORB call context will have already unwound to the site of the remote call before the exception is raised.  This greatly limits the extent to which recovery can be accomplished.Each DSTexception meta object is also an instance of the ExceptionDef interface in the Repository, and may be accessed accordingly.Instance variables:	members	&lt;DSTtypeStructure&gt;	signal  		&lt;Signal&gt;</body></comment><class><name>DSTcachedInterface</name><environment>Opentalk</environment><super>Opentalk.DSTinterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars>idlName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></class><comment><class-id>Opentalk.DSTcachedInterface</class-id><body>This class extends DSTinterface to allow it to act as a cached version of an interface on a remote system.Instance variables:	fullName		&lt;String&gt;</body></comment><class><name>DSTtypeUnsignedLong</name><environment>Opentalk</environment><super>Opentalk.DSTtypeLong</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></class><class><name>DSTUnionCase</name><environment>Opentalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>discriminator type </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></class><comment><class-id>Opentalk.DSTUnionCase</class-id><body>This class is a holds discriminator/type info for a case in a union.Instance Variables:	discriminator	&lt;Object&gt;		type			&lt;DSTtype&gt;</body></comment><class><name>DSTtypeAny</name><environment>Opentalk</environment><super>Opentalk.DSTtypeBase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></class><comment><class-id>Opentalk.DSTtypeAny</class-id><body>Any Smalltalk class which supports the #typeObject method may be used as an instance of an IDL type-any in an operation invocation parameter list.  On return, type-any output parameters and results are returned as Associations of the form  "obj typeObject -&gt; obj".  Associations of this form may also be provided as in parameters to operation calls, for uniformity.  Since all Smalltalk objects are inherently typed by their #class method, and since return parameters also have this characteristic,  Smalltalk programmers may prefer to use normal class typing instead of the IDL version.  To assist with easy conversion of Association valued type-any results to normally typed Smalltalk instances, the method #value has been added to class Object to return the object itself.Thus, possibly-remote operations which yield type-any values can be handled uniformly by appending the #value method to the result.  If the operation is local and is returning a local Smalltalk object directly, then there is no net effect.  However, if the operation is remote and actually returns an Association value, then the value of the Association (the intended result) results.e.g.		property := (aPropertySet getProperty: #company) value  works uniformly when the PropertySet is local and returns a single value and also when it is remote and returns "aDSTtypeString -&gt; 'ParcPlace-Digitalk' "</body></comment><class><name>DSTcachedException</name><environment>Opentalk</environment><super>Opentalk.DSTexception</super><private>false</private><indexed-type>none</indexed-type><inst-vars>typeCodeInfo idlName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></class><comment><class-id>Opentalk.DSTcachedException</class-id><body>This class implements the protocols needed for the shared repository mechanism to cache meta objects.  This classacts a cached exception for a meta object stored in a repository.Instance Variables:	typeCodeInfo	&lt;ByteArray&gt;	fullName		&lt;String&gt;</body></comment><class><name>DSTexceptionDescription</name><environment>Opentalk</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name id definedIn version type </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></class><class><name>DSTmoduleRepository</name><environment>Opentalk</environment><super>Opentalk.DSTmodule</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></class><comment><class-id>Opentalk.DSTmoduleRepository</class-id><body>This class implements the root of the meta object structure constituting the interface repository.Shared Variables:	SearchSubscope	&lt;Boolean&gt;	if true, then name resolution will continue searching the content of the repository, otherwise name resolution will stop at the repository level	PKTable				&lt;Dictionary&gt; the mapping from primitive kind symbols to Smalltalk classes</body></comment><class><name>DSTtypeWideCharacter</name><environment>Opentalk</environment><super>Opentalk.DSTtypeCharacter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></class><class><name>DSTparameterDescription</name><environment>Opentalk</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name type typeDef mode </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></class><shared-variable><name>RemoteRepository</name><environment>Opentalk.DSTORBObject</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></shared-variable><shared-variable><name>InterfaceRepository</name><environment>Opentalk.DSTORBObject</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></shared-variable><shared-variable><name>LocalRepository</name><environment>Opentalk.DSTORBObject</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></shared-variable><shared-variable><name>SharedRepositoryModule</name><environment>Opentalk.DSTORBObject</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></shared-variable><shared-variable><name>RepositoryCache</name><environment>Opentalk.DSTORBObject</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></shared-variable><shared-variable><name>SearchSubscope</name><environment>Opentalk.DSTmoduleRepository</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></shared-variable><shared-variable><name>PKTable</name><environment>Opentalk.DSTmoduleRepository</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></shared-variable><shared-variable><name>TCTable</name><environment>Opentalk.DSTMetaObject</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></shared-variable><shared-variable><name>CurrentPrefix</name><environment>Opentalk.DSTMetaObject</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></shared-variable><shared-variable><name>TCMap</name><environment>Opentalk.DSTMetaObject</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></shared-variable><shared-variable><name>CORBAConstants</name><environment>Opentalk</environment><private>false</private><constant>false</constant><category>CORBA</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></shared-variable><shared-variable><name>ServiceContextListDef</name><environment>Opentalk.DSToperation</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></shared-variable><shared-variable><name>ContextIF</name><environment>Opentalk.DSToperation</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></shared-variable><shared-variable><name>TCStreamDef</name><environment>Opentalk.DSTtypeAny</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></shared-variable><shared-variable><name>CORBATypeMap</name><environment>Opentalk.DSTtypeAny</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></shared-variable><shared-variable><name>TCStreamDef</name><environment>Opentalk.DSTpseudoTypeCode</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></shared-variable><shared-variable><name>IDTable</name><environment>Opentalk.RepositoryId</environment><private>false</private><constant>false</constant><category>Statics</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></shared-variable><shared-variable><name>CachedTypeVoid</name><environment>Opentalk.DSTtypeVoid</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Opentalk-IDL-MetaObjects</package></attributes></shared-variable><methods><class-id>Opentalk.DSTORBObject class</class-id> <category>ORB-error handling</category><body package="Opentalk-IDL-MetaObjects">badContextSignal	"Answer the signal used for error processing context object errors"	^(self standardExceptions at: #'BAD_CONTEXT') errorSignal</body><body package="Opentalk-IDL-MetaObjects">badInvOrderSignal	"Answer the Signal for routine invocations out of order"	^(self standardExceptions at: #'BAD_INV_ORDER') errorSignal</body><body package="Opentalk-IDL-MetaObjects">badOperationSignal	"Answer the Signal for invalid operation errors"	^(self standardExceptions at: #'BAD_OPERATION') errorSignal</body><body package="Opentalk-IDL-MetaObjects">badParamSignal	"Answer the signal used for invalid parameters"	^(self standardExceptions at: #'BAD_PARAM') errorSignal</body><body package="Opentalk-IDL-MetaObjects">badTypecodeSignal	"Answer the signal for bad typecode errors"	^(self standardExceptions at: #'BAD_TYPECODE') errorSignal</body><body package="Opentalk-IDL-MetaObjects">commFailureSignal	"Answer the signal used for communication failures"	^(self standardExceptions at: #'COMM_FAILURE') errorSignal</body><body package="Opentalk-IDL-MetaObjects">dataConversionSignal	"Answer the signal used for Data conversion errors"	^(self standardExceptions at: #'DATA_CONVERSION') errorSignal</body><body package="Opentalk-IDL-MetaObjects">freeMemSignal	"Answer the signal used for cannot free memory errors"	^(self standardExceptions at: #'FREE_MEM') errorSignal</body><body package="Opentalk-IDL-MetaObjects">impLimitSignal	"Answer the signal used for errors for violating implementation limit"	^(self standardExceptions at: #'IMP_LIMIT') errorSignal</body><body package="Opentalk-IDL-MetaObjects">initializeSignal	"Answer the signal usef for an ORB initialization failure"	^(self standardExceptions at: #INITIALIZE) errorSignal</body><body package="Opentalk-IDL-MetaObjects">internalSignal	"Answer the signal used for ORB internal errors"	^(self standardExceptions at: #INTERNAL) errorSignal</body><body package="Opentalk-IDL-MetaObjects">intfReposSignal	"Answer the signal used for accessing interface repository errors"	^(self standardExceptions at: #'INTF_REPOS') errorSignal</body><body package="Opentalk-IDL-MetaObjects">invFlagSignal	"Answer the signal used for handling Invalid flags"	^(self standardExceptions at: #'INV_FLAG') errorSignal</body><body package="Opentalk-IDL-MetaObjects">invIdentSignal	"Answer the signal used for Invalid identifier syntax errors"	^(self standardExceptions at: #'INV_IDENT') errorSignal</body><body package="Opentalk-IDL-MetaObjects">invObjrefSignal	"Answer the signal used for invalid object references"	^(self standardExceptions at: #'INV_OBJREF') errorSignal</body><body package="Opentalk-IDL-MetaObjects">marshallSignal	"Answer the signal used for marshalling param/result errors"	^(self standardExceptions at: #MARSHAL) errorSignal</body><body package="Opentalk-IDL-MetaObjects">noImplementSignal	"Answer the signal used for operation implementation unavailable errors"	^(self standardExceptions at: #'NO_IMPLEMENT') errorSignal</body><body package="Opentalk-IDL-MetaObjects">noMemorySignal	"Answer the signal used for dynamic memory allocation failures"	^(self standardExceptions at: #'NO_MEMORY') errorSignal</body><body package="Opentalk-IDL-MetaObjects">noPermissionSignal	"Answer the signal used for no permission for attempted op errors"	^(self standardExceptions at: #'NO_PERMISSION') errorSignal</body><body package="Opentalk-IDL-MetaObjects">noResourcesSignal	"Answer the signal used for Insufficient resources for request"	^(self standardExceptions at: #'NO_RESOURCES') errorSignal</body><body package="Opentalk-IDL-MetaObjects">noResponseSignal	"Answer the signal used for errors when a response to the request is not 	yet available"	^(self standardExceptions at: #'NO_RESPONSE') errorSignal</body><body package="Opentalk-IDL-MetaObjects">objAdapterSignal	"Answer the signal used for failures detected by object adaptor"	^(self standardExceptions at: #'OBJ_ADAPTER') errorSignal</body><body package="Opentalk-IDL-MetaObjects">persistStoreSignal	"Answer the signal used for persistent storage failures"	^(self standardExceptions at: #'PERSIST_STORE') errorSignal</body><body package="Opentalk-IDL-MetaObjects">transientSignal	"Answer the signal used for transient failures"	^(self standardExceptions at: #TRANSIENT) errorSignal</body><body package="Opentalk-IDL-MetaObjects">unknownSignal	"Answer the signal used for unknown exception errors"	^(self standardExceptions at: #UNKNOWN) errorSignal</body></methods><methods><class-id>Opentalk.DSTORBObject class</class-id> <category>instance creation</category><body package="Opentalk-IDL-MetaObjects">new	"create a new instance and initialize it"	^self basicNew initialize</body></methods><methods><class-id>Opentalk.DSTORBObject class</class-id> <category>Repository</category><body package="Opentalk-IDL-MetaObjects">containingRepository	"Forward to repository object"	^self repository containingRepository</body><body package="Opentalk-IDL-MetaObjects">contents: limitType excludeInherited: bool 	"return the list of objects contained by the receiver. If limitType is set 	to #dk_all, then all contained meta objects are returned. If the 	limitType is the name of an interface type, then only instances of 	that type will be returned."	^self repository contents: limitType excludeInherited: bool</body><body package="Opentalk-IDL-MetaObjects">createAlias: id name: aName version: aVersion originalType: aType 	"Forward to repository object"	^self repository		createAlias: id		name: aName		version: aVersion		originalType: aType</body><body package="Opentalk-IDL-MetaObjects">createArray: length elementType: type 	"Forward to repository object"	^self repository createArray: length elementType: type</body><body package="Opentalk-IDL-MetaObjects">createConstant: id name: aName version: aVersion type: aType value: aValue 	"Forward to repository object"	^self repository		createConstant: id		name: aName		version: aVersion		type: aType		value: aValue</body><body package="Opentalk-IDL-MetaObjects">createEnum: id name: aName version: aVersion members: memList 	"Forward to repository object"	^self repository		createEnum: id		name: aName		version: aVersion		members: memList</body><body package="Opentalk-IDL-MetaObjects">createException: id name: aName version: aVersion members: aMemberCollection 	"Redispatch to the repository object."	^self repository		createException: id		name: aName		version: aVersion		members: aMemberCollection</body><body package="Opentalk-IDL-MetaObjects">createFixed: arg1 scale: arg2	"Forward to repository object"	^self repository		createFixed: arg1		scale: arg2</body><body package="Opentalk-IDL-MetaObjects">createInterface: id name: aName version: aVersion baseInterfaces: interfaces 	"Forward to repository object"	^self repository		createInterface: id		name: aName		version: aVersion		baseInterfaces: interfaces</body><body package="Opentalk-IDL-MetaObjects">createModule: id name: aName version: aVersion	"Forward to repository object"	^self repository createModule: id name: aName version: aVersion</body><body package="Opentalk-IDL-MetaObjects">createSequence: bound elementType: type 	"Forward to repository object"	^self repository createSequence: bound elementType: type</body><body package="Opentalk-IDL-MetaObjects">createString: bound 	"Forward to repository object"	^self repository createString: bound</body><body package="Opentalk-IDL-MetaObjects">createStruct: id name: aName version: aVersion members: memList 	"Forward to repository object"	^self repository		createStruct: id		name: aName		version: aVersion		members: memList</body><body package="Opentalk-IDL-MetaObjects">createUnion: id name: aName version: aVersion discriminatorType: aType members: memList 	"Forward to repository object"	^self repository		createUnion: id		name: aName		version: aVersion		discriminatorType: aType		members: memList</body><body package="Opentalk-IDL-MetaObjects">createWideString: bound 	"Forward to repository object"	^self repository createWideString: bound</body><body package="Opentalk-IDL-MetaObjects">defKind	"Forward to repository object"	^self repository defKind</body><body package="Opentalk-IDL-MetaObjects">definedIn	"return the receivers definedIn"	^self repository definedIn</body><body package="Opentalk-IDL-MetaObjects">describe: aSymbol excludeInherited: bool max: anInt 	"return the description of each of the contents of the receiver"	^self repository describe: aSymbol excludeInherited: bool max: anInt</body><body package="Opentalk-IDL-MetaObjects">getPrimitive: pk 	"Forward to repository object"	^self repository getPrimitive: pk</body><body package="Opentalk-IDL-MetaObjects">id	"return the Repository's repositoryId"	^self repository id</body><body package="Opentalk-IDL-MetaObjects">id: newId 	"Forward to repository object"	^self repository id: newId</body><body package="Opentalk-IDL-MetaObjects">lookup: aName	"Forward to repository object"	^self repository lookup: aName</body><body package="Opentalk-IDL-MetaObjects">lookupId: aRepositoryId 	"return the repository meta object associated with the RepositoryId"	^InterfaceRepository at: aRepositoryId ifAbsent: [nil]</body><body package="Opentalk-IDL-MetaObjects">lookupName: aSymbol levels: anInt limit: limitType excludeInherited: bool 	"search for the contained object with the given symbol in the 	contents of the receiver. Levels gives the number of contained 	containers to search as well. If limitType is set to #all, then all 	contained meta objects are returned. If the limitType is the name of 	an interface type, then only instances of that type will be returned."	^self repository lookupName: aSymbol levels: anInt limit: limitType excludeInherited: bool</body><body package="Opentalk-IDL-MetaObjects">move: newContainer name: newName version: newVersion 	"Forward to repository object"	^self repository		move: newContainer		name: newName		version: newVersion</body><body package="Opentalk-IDL-MetaObjects">name: newName	"Forward to repository object"	^self repository name: newName</body><body package="Opentalk-IDL-MetaObjects">version	"Forward to repository object"	^self repository version</body><body package="Opentalk-IDL-MetaObjects">version: newVersion 	"Forward to repository object"	^self repository version: newVersion</body><body package="Opentalk-IDL-MetaObjects">within	"return the receivers within"	^self repository within</body></methods><methods><class-id>Opentalk.DSTORBObject class</class-id> <category>ORB-repository</category><body package="Opentalk-IDL-MetaObjects">addExceptionToCache: anException exceptionName: anExceptionName 	"add the exception to the cache."	RepositoryCache at: anException repositoryId put: anException.	RepositoryCache at: anExceptionName asSymbol put: anException</body><body package="Opentalk-IDL-MetaObjects">addInterfaceToCache: anInterface 	"add the interface to the cache.  Add the superiors if needed"	RepositoryCache at: anInterface repositoryId put: anInterface.	RepositoryCache at: anInterface idlName asSymbol put: anInterface.	anInterface superiors:  (anInterface superiors collect: [:superior | RepositoryCache at: superior repositoryId ifAbsent: [self addInterfaceToCache: superior]]).	^anInterface</body><body package="Opentalk-IDL-MetaObjects">addMetaObjectToCache: aMetaObject identity: anId 	"add the meta object to the cache"	| mo |	(aMetaObject isDSTMetaObject and: [aMetaObject isDSTinterface])		ifTrue: [^self addInterfaceToCache: aMetaObject].	((aMetaObject isMemberOf: ByteArray)		and: [aMetaObject isEmpty not])		ifTrue: 			[mo := DSTMetaObject unMarshallTypeCode: Dictionary new from: (TCCDRStream with: aMetaObject) reset.			RepositoryCache at: anId put: mo.			^mo].	(aMetaObject isDSTMetaObject and: [aMetaObject isDSTexception])		ifTrue: 			[RepositoryCache at: anId put: aMetaObject.			^aMetaObject].	^nil</body><body package="Opentalk-IDL-MetaObjects">cacheInterface: anId 	"return the interface object associated with the id"	| if |	self remoteRepository isNil		ifTrue: 			[if := self localRepository metaObjectOf: anId.			if notNil ifTrue: [RepositoryCache at: anId put: if]]		ifFalse: 			[if := self sharedRepositoryModule searchScopeFor: anId.			if isNil				ifTrue: [ if := self remoteRepository getCachedInterface: anId.						self addInterfaceToCache: if]				ifFalse: [RepositoryCache at: anId put: if]].	^if</body><body package="Opentalk-IDL-MetaObjects">cacheMetaObject: anId 	"return the meta object associated with the id"	| mo | 	self remoteRepository isNil		ifTrue: 			[mo := self localRepository metaObjectOf: anId.			mo notNil ifTrue: [RepositoryCache at: anId put: mo]]		ifFalse: 			[mo := self searchSharedRepositoryModule: anId.			mo isNil				ifTrue: [mo := RemoteRepository getCachedMetaObject: anId.					^self addMetaObjectToCache: mo identity: anId]				ifFalse: [RepositoryCache at: anId put: mo]].	^mo</body><body package="Opentalk-IDL-MetaObjects">checkInterfaceIdentity: interfaces 	"Check that all interfaces have unique identities"	Transcript crtab; show: 'Checking interface identities...'.	interfaces do: 		[:if | 		| mo |		(mo := RepositoryCache at: if repositoryId					ifAbsent: 						[Dialog notify: 'Identity of interface ' , if idlName , ' is not registered'.						if]) == if ifFalse: [Dialog notify: 'Identity of interface ' , if idlName , ' conflicts with the identity of ' , mo idlName]]</body><body package="Opentalk-IDL-MetaObjects">checkInterfaceMethods	"check that all classes which have interfaces are complete"	| abscl if epv obj root |	Transcript crtab; show: 'Checking interface implementations...'.	root := Object new CORBAName.	abscl :=	( Object allSubclasses select: [:cl |				(cl includesSelector: #CORBAName) and: [cl basicNew CORBAName ~= root]]			) asSortedCollection: [:a :b | a name &lt; b name].	abscl do: [:cl | 		self remoteRepository isNil ifTrue: [			if := cl basicNew corbaInterfaceIn: self.			if isNil				ifTrue: [Transcript crtab; tab; show: '***interface for "' , cl name , '"  is undefined' ]				ifFalse: [ (if isMemberOf: DSTinterface) ifTrue: [						epv := if fullEntryPointVector.						obj := cl basicNew.						epv do: [:sel |							(obj respondsTo: sel) ifFalse: [								Transcript crtab; tab; show: 'WARNING: method for "' , sel , '" for IF "' , if idlName , '" is not implemented in "' , cl name , '"']]]]]].</body><body package="Opentalk-IDL-MetaObjects">checkRepository	"Verify the accuracy of the DST repository"	"self checkRepository"	self remoteRepository isNil ifTrue: [self checkRepository: DSTORBObject repositoryClass]</body><body package="Opentalk-IDL-MetaObjects">checkRepository: repName 	"Verify the accuracy of the named repository"	"self checkRepository"	| ifs ifaces symbols selectors metas nas dif metaConts ops epv |	Transcript cr; cr; show: 'Checking Interface Repository...'.	self checkInterfaceMethods.	ObjectMemory compactingGC.	metas := Set new.	self localRepository allMetaObjectsInto: metas.	metaConts := metas select: [:mo | (mo isKindOf: DSTinterface)					| (mo isKindOf: DSTmodule)].	ifaces := metaConts select: [:if | if isKindOf: DSTinterface].	symbols := metaConts collect: [:if | if printName].	selectors := repName selectors.	self checkInterfaceIdentity: ifaces.	Transcript crtab; show: 'Checking for completeness...'.	ifs := selectors reject: [:sy | symbols includes: sy].	ifs isEmpty ifFalse: [Dialog notify: 'Repository is missing some of the defined modules or interfaces'].	Transcript crtab; show: 'Checking definition consistency...'.	ifs := metas reject: [:mo | metas includes: mo definingMetaObject].	ifs size &lt;= 1 ifFalse: [Dialog notify: 'Repository contains ' , ifs size printString , ' undeclared interfaces'].	Transcript crtab; show: 'Checking inheritance graph consistency...'.	ifs := ifaces reject: [:if | (if superiors reject: [:sup | (ifaces includes: sup)						&amp; (sup subordinates includes: if)]) isEmpty and: [(if subordinates reject: [:sub | (ifaces includes: sub)							&amp; (sub superiors includes: if)]) isEmpty and: [if superiors size = if sunames size]]].	ifs isEmpty ifFalse: [Dialog notify: 'Repository inheritance graph is inconsistent'].	Transcript crtab; show: 'Checking for identifier completeness...'.	nas := metas select: [:mo | mo class == DSTtypeNamed].	nas do: [:mo | mo equivalentType].	Transcript crtab; show: 'Checking for identifier ambiguity...'.	ifs := nas select: [:mo | (dif := mo definingMetaContainer) notNil and: [(mo definingMetaObject isKindOf: DSTMetaContainer)						and: [(dif								lookupName: mo printName								levels: 1								limit: #dk_all								excludeInherited: false) size &gt; 1]]].	ifs isEmpty ifFalse: [Dialog notify: 'Repository contains ambiguous identifiers'].	Transcript crtab; show: 'Checking for unresolved identifiers...'.	ifs := nas select: [:na | na attemptResolution isNil].	ifs isEmpty ifFalse: [Dialog notify: 'Repository contains unresolvable identifiers'].	Transcript crtab; show: 'Checking for inherited interface name ambiguity...'.	ifaces do: [:if | if checkReferencesUniqueness].	Transcript crtab; show: 'Checking for name resolution ambiguity...'.	nas do: [:na | na checkReferencesUniqueness].	Transcript crtab; show: 'Checking for operation ambiguity...'.	ops := metas select: [:mo | mo class == DSToperation].	ifs := ops select: [:mo | (dif := mo definingMetaContainer) notNil and: [(mo definingMetaObject isKindOf: DSTMetaContainer)						and: [(dif								lookupName: mo printName								levels: 1								limit: #dk_all 								excludeInherited: false) size &gt; 1]]].	ifs isEmpty ifFalse: [			"Hacking away here! The main problem is that we treat PIDL as IDL,			and that the CORBA spec for some reason allow overloading of			PIDL operations while not on IDL operation. The is_a operation is			overloaded withing CORBA itself therefore the exception"			| msg ignore |			ignore := false.			msg := 'Repository contains ambiguous operations:\'.			ifs do:[:mo | 				(mo idlName = '::CORBA::InterfaceDef::is_a')					ifTrue: [ignore := true]					ifFalse: [msg := msg, mo idlName, '\']].			(ignore and:[ ifs size = 1])				ifFalse:[Dialog notify: msg  withCRs]].	Transcript crtab; show: 'Checking for operation selector ambiguity...'.	ifs := ifaces select: [:mo | (epv := mo fullEntryPointVector) size ~= epv asBag size].	ifs isEmpty ifFalse: [Dialog notify: 'Repository contains ambiguous operation selectors'].	Transcript crtab; show: 'Checking for exception name ambiguity...'.	ops do: [:op | op checkReferencesUniqueness].	Transcript crtab; show: 'DONE...'; cr</body><body package="Opentalk-IDL-MetaObjects">localRepository	"return the interfaces in the repository"	LocalRepository isNil ifTrue: [self initializeRepository; checkRepository].	^LocalRepository</body><body package="Opentalk-IDL-MetaObjects">lookupConstantOrSignal: anId 	"return the constant or signal associated with the id"	| conOrEx | 	self remoteRepository isNil		ifTrue: 			[conOrEx := self localRepository metaObjectOf: anId.			(conOrEx isMemberOf: DSTconstant)				ifTrue: [^conOrEx value].			(conOrEx isMemberOf: DSTtypeEnumeration)				ifTrue: [^conOrEx values].			(conOrEx isDSTMetaObject and: [conOrEx isDSTexception])				ifTrue: [^conOrEx errorSignal].			(conOrEx isKindOf: Enumerator)				ifTrue: [^conOrEx]]		ifFalse: 			[conOrEx := RepositoryCache at: anId ifAbsent: [nil].			conOrEx isNil				ifTrue: 					[conOrEx := self getConstantOrException: anId.					(conOrEx isDSTMetaObject and: [conOrEx isDSTexception])						ifTrue: 							[RepositoryCache at: conOrEx idlName asSymbol put: conOrEx.							RepositoryCache at: conOrEx repositoryId put: conOrEx.							^conOrEx errorSignal]						ifFalse: [^conOrEx]]				ifFalse: [(conOrEx isDSTMetaObject and: [conOrEx isDSTexception])						ifTrue: [^conOrEx errorSignal]						ifFalse: [^conOrEx]]].	^nil</body><body package="Opentalk-IDL-MetaObjects">lookupInterfaceId: anId	"return the interface object associated with the id"	| if |	anId == NCSuuid nilId ifTrue: [^nil].	if := RepositoryCache at: anId ifAbsent: [self cacheInterface: anId].	(if isDSTMetaObject and: [if isDSTinterface])		ifTrue: [^if]		ifFalse: [self  intfReposError: 0]</body><body package="Opentalk-IDL-MetaObjects">lookupMetaId: anId 	"Return the repository meta object associated with the id"	| mo |	mo := RepositoryCache at: anId ifAbsent: [self cacheMetaObject: anId].	^mo isNil		ifTrue: [nil]		ifFalse: [mo class == DSTtypeAlias				ifTrue: [mo]				ifFalse: [mo equivalentType]]</body><body package="Opentalk-IDL-MetaObjects">publishRepository: syArray onFile: fname 	"Utility - publish selected interfaces in the repository on the file, without 	any pragmas or implementation specifics"	| file mo  rmo map |	file := fname asFilename writeStream.	map := Dictionary new.	syArray		do: 			[:sy | 			mo := self repository metaObjectOf: sy.			mo isNil				ifTrue: [Transcript show: '** ' , sy , ' not found in Repository'; cr]				ifFalse: 					[mo printName asUppercase.					rmo := mo referencedMetaContainers.					rmo := rmo - (Set with: (self repository metaObjectOf: #Object)).					rmo do: [:m | m printName = #CORBA ifFalse: [file nextPutAll: '#include &lt;' , (map at: m printName ifAbsent: [m printName]) , '.idl&gt;'; cr]].					mo						publishDefinitionOn: file						indent: 0						style: #default.					file cr]].	file close</body><body package="Opentalk-IDL-MetaObjects">reInitializeSharedRepositoryModule	"self reInitializeSharedRepositoryModule"	| mo sups subs "bos ws" |	mo := self localRepository metaObjectOf: #'::SharedIR'.	mo isNil		ifTrue: [self intfReposError: 0]		ifFalse: 			[sups := IdentityDictionary new.			subs := IdentityDictionary new.			mo definedIn: nil.			mo interfaces				do: 					[:if | 					sups at: if put: if superiors.					subs at: if put: if subordinates.					if resetInheritance].			"ws := WriteStream on: (ByteArray new: 100).			bos := BinaryObjectStorage onNew: ws.			bos nextPut: mo.			bos close."			mo interfaces				do: 					[:if | 					if setInheritance.					if superiors: (sups at: if).					if subordinates: (subs at: if)].			mo definedIn: self localRepository.			"bos := BinaryObjectStorage onOld: (ReadStream on: ws contents).			SharedRepositoryModule := bos next.			bos close"			SharedRepositoryModule := mo]</body><body package="Opentalk-IDL-MetaObjects">remoteRepository	^RemoteRepository</body><body package="Opentalk-IDL-MetaObjects">remoteRepository: anObjRef 	"create a remote object reference for remote shared repository 	operations"	(anObjRef isNil or: [anObjRef isLocal])		ifTrue: [RemoteRepository := nil]		ifFalse: [RemoteRepository := anObjRef.			RemoteRepository := anObjRef narrowTo: (				self lookupMetaId: #'::SharedIR::SharedInterfaceRepository') repositoryId.			self initializeRepository ]</body><body package="Opentalk-IDL-MetaObjects">repository	"return a reference to the repository"	"If repository is set to local and it has not been initialize,	initialize it first."	^self remoteRepository		ifNil: [ self localRepository ]		ifNotNil: [ :rep | rep ]</body><body package="Opentalk-IDL-MetaObjects">repositoryClass	"return the class to be used for the interface repository definitions"	# {DSTRepository} ifDefinedDo: [:rc | ^rc].	Dialog warn: 'Local repository facility not in placed.\Use remote repository.' withCRs.	^nil</body><body package="Opentalk-IDL-MetaObjects">resetRepository	"clear the Repository cache"	"WARNING: The ORB should be stopped before calling this method"	LocalRepository := nil.	self initializeInterfaceRepository.	self initializeRepositoryCache.	ORBConstantsDictionary rebuild</body><body package="Opentalk-IDL-MetaObjects">resetRepositoryCache	"reset the cache"	self remoteRepository notNil		ifTrue: 			[self initializeRepositoryCache.			ORBConstantsDictionary rebuild]</body><body package="Opentalk-IDL-MetaObjects">searchSharedRepositoryModule: aSymbol 	"search the shared repository module for anId"	| str x head tail |	aSymbol class == RepositoryId		ifTrue: [^self sharedRepositoryModule symbols at: aSymbol ifAbsent: [nil]]		ifFalse: 			[str := aSymbol asString.			x := str findFirst: [:ch | ch = $:].			x isZero ifTrue: [^nil].			x = 1				ifTrue: 					[str := str copyFrom: 3 to: str size.					x := str findFirst: [:ch | ch = $:]].			head := str copyFrom: 1 to: x - 1.			head asSymbol == self sharedRepositoryModule name				ifTrue: 					[tail := str copyFrom: x + 2 to: str size.					^self sharedRepositoryModule searchScopeFor: tail asSymbol]				ifFalse: [^nil]]</body><body package="Opentalk-IDL-MetaObjects">sharedRepositoryModule	"return the interfaces in the repository"	| bos | 	SharedRepositoryModule isNil		ifTrue: 			[bos := BinaryObjectStorage onOld: (Filename named: 'SharedRM.bos') readStream.			SharedRepositoryModule := bos next.			bos close].	^SharedRepositoryModule</body></methods><methods><class-id>Opentalk.DSTORBObject class</class-id> <category>ORB-initialization</category><body package="Opentalk-IDL-MetaObjects">initialize	"initialize all class variables"	self initializeInterfaceRepository.	self initializeRepositoryCache.</body><body package="Opentalk-IDL-MetaObjects">initializeInterfaceRepository	InterfaceRepository := Dictionary new: 1200</body><body package="Opentalk-IDL-MetaObjects">initializeRepository	"initialize the repository to the definitions in the ORBObject 	repositoryClass class"	"WARNING: The ORB should be stopped before calling this method" 	| rep metas |	Transcript cr; show: 'Initializing Interface Repository...'.	self resetRepository.	self remoteRepository isNil		ifTrue: 			[Transcript crtab; show: 'Resetting repository ids...'.			(DSTMetaObject withAllSubclasses collect: [:cl | cl allInstances])				do: [:co | co do: [:mo | mo reInitialize]].			LocalRepository := DSTmoduleRepository new initialize.			LocalRepository				ident: #'Smalltalk Repository'				def: #()				defs: OrderedCollection new.			ORBConstantsDictionary rebuild.			Transcript crtab; show: 'Resetting inheritance graph...'.			DSTinterface withAllSubclasses do: [:cl | cl allInstances do: [:if | if resetInheritance]].			DSTtypeNamed allInstances do: [:tn | tn resolveTo: nil].			rep := DSTORBObject repositoryClass new.			rep class selectors collect: [:ifn | LocalRepository addMetaObject: (rep perform: ifn)].			metas := Set new.			LocalRepository allMetaObjectsInto: metas.			Transcript crtab; show: 'Rebuilding inheritance graph...'.			metas do: [:mo | (mo isDSTMetaObject and: [mo isDSTinterface])					ifTrue: [mo setInheritance]].			Transcript crtab; show: 'Resolving references...'.			metas				do: 					[:mo | 					mo registerIdentity.					mo resolveTypeReference].			self reInitializeSharedRepositoryModule]</body><body package="Opentalk-IDL-MetaObjects">initializeRepositoryCache	RepositoryCache := IdentityDictionary new: 1200</body><body package="Opentalk-IDL-MetaObjects">release	"release all class variables"	InterfaceRepository := LocalRepository := RemoteRepository := RepositoryCache := SharedRepositoryModule := nil</body></methods><methods><class-id>Opentalk.DSTORBObject class</class-id> <category>ORB-exceptions</category><body package="Opentalk-IDL-MetaObjects">badContextError: minor 	"error processing context object"	^(self standardExceptions at: #BAD_CONTEXT) errorSignal 		raiseWith: (Dictionary with: #minor -&gt; minor with: #completed -&gt; #COMPLETED_NO)		errorString: ' error processing context object'</body><body package="Opentalk-IDL-MetaObjects">badInvOrderError: minor 	"routine invocations out of order"	^(self standardExceptions at: #BAD_INV_ORDER) errorSignal		raiseWith: (Dictionary with: #minor -&gt; minor with: #completed -&gt; #COMPLETED_NO)		errorString: ' routine invocations out of order'</body><body package="Opentalk-IDL-MetaObjects">badOperationError: minor 	"Invalid operation"	^(self standardExceptions at: #BAD_OPERATION) errorSignal		raiseWith: (Dictionary with: #minor -&gt; (self minorCodeOf: minor) with: #completed -&gt; #COMPLETED_NO)		errorString: ' invalid operation'</body><body package="Opentalk-IDL-MetaObjects">badParamError: minor 	"an invalid parameter was passed"	^(self standardExceptions at: #BAD_PARAM) errorSignal		raiseWith: (Dictionary with: #minor -&gt; minor with: #completed -&gt; #COMPLETED_MAYBE)		errorString: ' an invalid parameter was passed'</body><body package="Opentalk-IDL-MetaObjects">badTypecodeError: minor 	"bad typecode"	^(self standardExceptions at: #BAD_TYPECODE) errorSignal		raiseWith: (Dictionary with: #minor -&gt; minor with: #completed -&gt; #COMPLETED_NO)		errorString: ' bad typecode'</body><body package="Opentalk-IDL-MetaObjects">codeSetIncompatibleError: minor 	"ORB initialization failure"	^(self standardExceptions at: #CODESET_INCOMPATIBLE) errorSignal		raiseWith: (Dictionary with: #minor -&gt; minor with: #completed -&gt; #COMPLETED_NO)		errorString: ' Code Set negotiation failed'</body><body package="Opentalk-IDL-MetaObjects">commFailureError: minor 	"communication failure"	^(self standardExceptions at: #COMM_FAILURE) errorSignal		raiseWith: (Dictionary with: #minor -&gt; minor with: #completed -&gt; #COMPLETED_NO)		errorString: ' communication failure'</body><body package="Opentalk-IDL-MetaObjects">dataConversionError: minor 	"Data conversion error"	^(self standardExceptions at: #DATA_CONVERSION) errorSignal		raiseWith: (Dictionary with: #minor -&gt; minor with: #completed -&gt; #COMPLETED_NO)		errorString: ' data conversion error'</body><body package="Opentalk-IDL-MetaObjects">freeMemError: minor 	"cannot free memory"	^(self standardExceptions at: #FREE_MEM) errorSignal		raiseWith: (Dictionary with: #minor -&gt; minor with: #completed -&gt; #COMPLETED_NO)		errorString: ' cannot free memory'</body><body package="Opentalk-IDL-MetaObjects">impLimitError: minor 	"violated implementation limit"	^(self standardExceptions at: #IMP_LIMIT) errorSignal		raiseWith: (Dictionary with: #minor -&gt; minor with: #completed -&gt; #COMPLETED_MAYBE)		errorString: ' violated implementation limit'</body><body package="Opentalk-IDL-MetaObjects">initializeError: minor 	"ORB initialization failure"	^(self standardExceptions at: #INITIALIZE) errorSignal		raiseWith: (Dictionary with: #minor -&gt; minor with: #completed -&gt; #COMPLETED_NO)		errorString: ' ORB initialization failure'</body><body package="Opentalk-IDL-MetaObjects">internalError: minor 	"ORB internal error"	^(self standardExceptions at: #INTERNAL) errorSignal		raiseWith: (Dictionary with: #minor -&gt; minor with: #completed -&gt; #COMPLETED_NO)		errorString: ' ORB internal error'</body><body package="Opentalk-IDL-MetaObjects">intfReposError: minor 	"Error accessing interface repository"	^(self standardExceptions at: #INTF_REPOS) errorSignal		raiseWith: (Dictionary with: #minor -&gt; minor with: #completed -&gt; #COMPLETED_NO)		errorString: ' error accessing interface repository'</body><body package="Opentalk-IDL-MetaObjects">invFlagError: minor 	"Invalid flag was specified"	^(self standardExceptions at: #INV_FLAG) errorSignal		raiseWith: (Dictionary with: #minor -&gt; minor with: #completed -&gt; #COMPLETED_NO)		errorString: ' invalid flag was specified'</body><body package="Opentalk-IDL-MetaObjects">invIdentError: minor 	"Invalid identifier syntax"	^(self standardExceptions at: #INV_IDENT) errorSignal		raiseWith: (Dictionary with: #minor -&gt; minor with: #completed -&gt; #COMPLETED_NO)		errorString: ' invalid identifier syntax'</body><body package="Opentalk-IDL-MetaObjects">invObjrefError: minor 	"invalid object reference"	^(self standardExceptions at: #INV_OBJREF) errorSignal		raiseWith: (Dictionary with: #minor -&gt; minor with: #completed -&gt; #COMPLETED_NO)		errorString: ' invalid object reference'</body><body package="Opentalk-IDL-MetaObjects">marshallError: minor 	"error marshalling param/result"	^(self standardExceptions at: #MARSHAL) errorSignal		raiseWith: (Dictionary with: #minor -&gt; minor with: #completed -&gt; #COMPLETED_NO)		errorString: ' error marshalling param/result'</body><body package="Opentalk-IDL-MetaObjects">minorCodeOf: minor 	"Return minor if it is an integer, otherwise search CORBAConstants with minor 	appended to the scope name of the Object interface. In the later case, 	minor must be a symbol or a string"	"ORBObject minorCodeOf: 1"	"ORBObject minorCodeOf: #M_IF_VERSION_MISMATCH"	"ORBObject minorCodeOf: 'M_PING_LIMIT_EXCEEDED'"	^minor isInteger		ifTrue: [minor]		ifFalse: [CORBAConstants at: minor asSymbol]</body><body package="Opentalk-IDL-MetaObjects">noImplementError: minor 	"operation implementation unavailable"	^(self standardExceptions at: #NO_IMPLEMENT) errorSignal		raiseWith: (Dictionary with: #minor -&gt; minor with: #completed -&gt; #COMPLETED_NO)		errorString: ' operation implementation unavailable'</body><body package="Opentalk-IDL-MetaObjects">noMemoryError: minor 	"dynamic memory allocation failure"	^(self standardExceptions at: #NO_MEMORY) errorSignal		raiseWith: (Dictionary with: #minor -&gt; minor with: #completed -&gt; #COMPLETED_MAYBE)		errorString: ' dynamic memory allocation failure'</body><body package="Opentalk-IDL-MetaObjects">noPermissionError: minor 	"no permission for attempted op"	^(self standardExceptions at: #NO_PERMISSION) errorSignal		raiseWith: (Dictionary with: #minor -&gt; minor with: #completed -&gt; #COMPLETED_NO)		errorString: ' no permission for attempted op'</body><body package="Opentalk-IDL-MetaObjects">noResourcesError: minor 	"Insufficient resources for request"	^(self standardExceptions at: #NO_RESOURCES) errorSignal		raiseWith: (Dictionary with: #minor -&gt; minor with: #completed -&gt; #COMPLETED_NO)		errorString: ' insufficient resources for request'</body><body package="Opentalk-IDL-MetaObjects">noResponseError: minor 	"response to request not yet available"	^(self standardExceptions at: #NO_RESPONSE) errorSignal		raiseWith: (Dictionary with: #minor -&gt; minor with: #completed -&gt; #COMPLETED_NO)		errorString: ' response to request not yet available'</body><body package="Opentalk-IDL-MetaObjects">objAdapterError: minor 	"Failure detected by object adaptor"	^(self standardExceptions at: #OBJ_ADAPTER) errorSignal		raiseWith: (Dictionary with: #minor -&gt; minor with: #completed -&gt; #COMPLETED_NO)		errorString: ' failure detected by object adaptor'</body><body package="Opentalk-IDL-MetaObjects">persistStoreError: minor 	"persistent storage failure"	^(self standardExceptions at: #PERSIST_STORE) errorSignal		raiseWith: (Dictionary with: #minor -&gt; minor with: #completed -&gt; #COMPLETED_NO)		errorString: ' persistent storage failure'</body><body package="Opentalk-IDL-MetaObjects">standardExceptions	"return standard exceptions"	^CORBAConstants standardExceptions</body><body package="Opentalk-IDL-MetaObjects">transientError: minor 	"transient failure - reissue request"	^(self standardExceptions at: #TRANSIENT) errorSignal		raiseWith: (Dictionary with: #minor -&gt; minor with: #completed -&gt; #COMPLETED_NO)		errorString: ' transient failure - reissue request'</body><body package="Opentalk-IDL-MetaObjects">unknownError: minor 	"an unknown error occurred"	^(self standardExceptions at: #UNKNOWN) errorSignal 		raiseWith: (Dictionary with: #minor -&gt; minor with: #completed -&gt; #COMPLETED_MAYBE)		errorString: ' unknown error'</body></methods><methods><class-id>Opentalk.DSTORBObject class</class-id> <category>SharedRepository</category><body package="Opentalk-IDL-MetaObjects">getCachedInterface: anId 	| int |	int := self lookupInterfaceId: anId.	^DSTcachedInterface new		name: int name		idlName: int idlName		repositoryId: int repositoryId		superiors: (int superiors collect: [:sup | self getCachedInterface: sup repositoryId])		epv: int entryPointVector</body><body package="Opentalk-IDL-MetaObjects">getCachedMetaObject: anId 	| mo tcs |	mo := self lookupMetaId: anId.	mo isDSTMetaObject ifTrue: [mo isDSTinterface			ifTrue: [^DSTcachedInterface new					name: mo name					idlName: mo idlName					repositoryId: mo repositoryId					superiors: (mo superiors collect: [:sup | self getCachedInterface: sup repositoryId])					epv: mo entryPointVector]			ifFalse: [(mo isDSTtype or: [mo isDSTdeclaratorSimple])					ifTrue: 						[tcs := (TCCDRStream with: ( ByteArray new: 1024 ) ) reset.						mo marshallTypeCode: Dictionary new on: tcs.						^tcs contents]					ifFalse: [mo isDSTexception ifTrue: [^DSTcachedException								name: mo name								idlName: mo idlName								repositoryId: mo repositoryId								errorTypeCodeInfo: 									[tcs := (TCCDRStream with: #[]) reset.									mo errorType marshallTypeCode: Dictionary new on: tcs.									tcs contents] value]]]].	^#[]</body><body package="Opentalk-IDL-MetaObjects">getCachedOperation: selector interface: anId 	| int op tci |	int := self lookupInterfaceId: anId.	op := int findOpBySelector: selector.	op := op operation.	(op isDSTMetaObject and: [op isDSTcachedOperation])		ifTrue: [^op]		ifFalse: [^DSTcachedOperation				name: op name				definedIn: op definedIn				localOp: op localOp				access: op accessRight				signature: (op signature collect: [:par | DSTcachedParameter							name: par name							direction: par direction asUppercase asSymbol							typeCodeInfo: 								[tci := (TCCDRStream with: ( ByteArray new: 1024 ) ) reset.								par type marshallTypeCode: Dictionary new on: tci.								tci contents] value])				mode: op mode				raises: (op exceptions collect: [:ex | ex idlName])				context: op context]</body><body package="Opentalk-IDL-MetaObjects">getConstantOrException: aSymbol 	| mo tci |	self remoteRepository isNil		ifTrue: [mo := self localRepository metaObjectOf: aSymbol]		ifFalse: [^self remoteRepository getConstantOrException: aSymbol				"ifFalse: [^ORBObject intfReposError: 0]"].	(mo isMemberOf: DSTconstant)		ifTrue: [^mo value].	mo class == Enumerator ifTrue: [^mo].	(mo isDSTMetaObject and: [mo isDSTexception])		ifTrue: [^DSTcachedException				name: mo name				idlName: mo idlName				repositoryId: mo repositoryId				errorTypeCodeInfo: 					[tci := (TCCDRStream with: ( ByteArray new: 1024 ) ) reset.					mo errorType marshallTypeCode: Dictionary new on: tci.					tci contents] value].	^DSTORBObject intfReposError: 1</body><body package="Opentalk-IDL-MetaObjects">getSharedRepositoryModule	^SharedRepositoryModule</body><body package="Opentalk-IDL-MetaObjects">sharedRepositoryModule: aDSTModule	SharedRepositoryModule := aDSTModule</body></methods><methods><class-id>Opentalk.DSTMetaObject</class-id> <category>testing</category><body package="Opentalk-IDL-MetaObjects">IIOPIsA: aRepositoryId	aRepositoryId asString = 'IDL:CORBA/Contained:1.0' ifTrue:[^true].	^self isA: aRepositoryId</body><body package="Opentalk-IDL-MetaObjects">isDSTMetaContainer	^false</body><body package="Opentalk-IDL-MetaObjects">isDSTMetaObject	^true</body><body package="Opentalk-IDL-MetaObjects">isDSTattribute	^false</body><body package="Opentalk-IDL-MetaObjects">isDSTcachedOperation	^false</body><body package="Opentalk-IDL-MetaObjects">isDSTdeclaratorSimple	^false</body><body package="Opentalk-IDL-MetaObjects">isDSTexception	^false</body><body package="Opentalk-IDL-MetaObjects">isDSTinterface	^false</body><body package="Opentalk-IDL-MetaObjects">isDSTmodule	^false</body><body package="Opentalk-IDL-MetaObjects">isDSToperation	^false</body><body package="Opentalk-IDL-MetaObjects">isDSTtype	^false</body><body package="Opentalk-IDL-MetaObjects">isDSTtypeArray	^false</body><body package="Opentalk-IDL-MetaObjects">isDSTtypeNamed	^false</body></methods><methods><class-id>Opentalk.DSTMetaObject</class-id> <category>accessing</category><body package="Opentalk-IDL-MetaObjects">absoluteName	"The absoluteName attribute is an absolute scoped name that 	identifies a contained object uniquely within its enclosing 	repository. If the object's definedIn attribute references a repository, 	the absoluteName is formed by concatenating the string '::' and the 	object's name attribute. Otherwise, the absoluteName is formed by 	concatenating the absoluteName attribute of the object referenced 	by the object's definedIn attribute, the string '::', and the object's 	name attribute."	^self idlName</body><body package="Opentalk-IDL-MetaObjects">accessControlList	"return the access control list"	^IdentityDictionary with: #other -&gt; (IdentitySet with: #read)</body><body package="Opentalk-IDL-MetaObjects">convertedName	"return the converted print name symbol of the receiver"	^self convertSymbol: self printName</body><body package="Opentalk-IDL-MetaObjects">declarators	"return the declarators of the receiver. Only types can have 	multiple declarators, so return an array with the receiver"	^Array with: self</body><body package="Opentalk-IDL-MetaObjects">definedIn: aMetaObject 	"set the receiver's defining container meta object"	definedIn := aMetaObject.</body><body package="Opentalk-IDL-MetaObjects">definedInOnly: aMetaObject 	"set only the receiver's defining container meta object"	definedIn := aMetaObject.</body><body package="Opentalk-IDL-MetaObjects">definingMetaContainer	"return the meta container which contains the receiver" 	^self definingMetaObject  definingMetaContainer</body><body package="Opentalk-IDL-MetaObjects">definition: aStringArray 	"set the definition of the receiver"	definition := aStringArray</body><body package="Opentalk-IDL-MetaObjects">description	"return a description of the receiver"	self subclassResponsibility</body><body package="Opentalk-IDL-MetaObjects">equivalentType	"Return the equivalentType. By default return self. Override if need 	something different."	^self</body><body package="Opentalk-IDL-MetaObjects">idlName	"return the receivers full qualified name"	^self definingMetaObject idlName , '::' , self printName</body><body package="Opentalk-IDL-MetaObjects">isDeclarator	^false</body><body package="Opentalk-IDL-MetaObjects">prefix: aPrefix 	"Set the prefix for this meta object."	aPrefix prefixString isNil		ifTrue: [prefix := nil]		ifFalse: [prefix := aPrefix]</body><body package="Opentalk-IDL-MetaObjects">printName	"return the print name symbol of the receiver"	^name isNil		ifTrue: ['?']		ifFalse: [name]</body><body package="Opentalk-IDL-MetaObjects">repositoryId	^repositoryId ifNil: [repositoryId := self generateRepositoryId]</body><body package="Opentalk-IDL-MetaObjects">repositoryId: aRepositoryId 	repositoryId := aRepositoryId</body><body package="Opentalk-IDL-MetaObjects">unitOfCompilation	"return the unit of compilation of the receiver (a real 	module or interface) that is defined in the repository" 	| def |	^(def := self definingMetaObject) class == DSTmoduleRepository		ifTrue: [self]		ifFalse: [def unitOfCompilation]</body></methods><methods><class-id>Opentalk.DSTMetaObject</class-id> <category>repository</category><body package="Opentalk-IDL-MetaObjects">CORBAName	"return the name of my CORBA interface in the repository"	^#'::CORBA::Contained'</body><body package="Opentalk-IDL-MetaObjects">allMetaObjectsInto: aSet	"add all of the contained metaobjects to the set"	aSet add: self.</body><body package="Opentalk-IDL-MetaObjects">canApplyPragma: pragma 	"Check to see if the argument pragma can be applied to the receiver."	^false</body><body package="Opentalk-IDL-MetaObjects">defKind        "Return the definition kind."        ^#dk_none</body><body package="Opentalk-IDL-MetaObjects">extractFullName: aReposId 	"extract the fullName from the repositoryId from the fullname based 	upon the IR Specification"	^self class extractFullName: aReposId</body><body package="Opentalk-IDL-MetaObjects">generateRepositoryId	"generate the repositoryId from the fullname based upon the IR 	Specification"	| cn fn ws c1 |	fn := self idlName.	prefix isNil		ifTrue: 			[ws := WriteStream on: (fn species new: fn size + 6).			ws nextPutAll: 'IDL:']		ifFalse: 			[prefix definingContainer isNil				ifFalse: 					[cn := prefix definingContainer idlName.					fn := fn								copyReplaceFrom: 1								to: cn size								with: String new].			prefix prefixString isNil				ifTrue: 					[ws := WriteStream on: (fn species new: fn size + 6).					ws nextPutAll: 'IDL:']				ifFalse: 					[ws := WriteStream on: (fn species new: fn size + 6 + prefix prefixString size).					ws nextPutAll: 'IDL:'.					ws nextPutAll: prefix prefixString; nextPut: $/]].	3 to: fn size		do: 			[:i | 			c1 := fn at: i.			c1 = $:				ifTrue: [(fn at: i + 1)						= $: ifTrue: [ws nextPut: $/]]				ifFalse: [ws nextPut: c1]].	version isNil		ifTrue: [ws nextPutAll: ':1.0']		ifFalse: [ws nextPut: $:; nextPutAll: version].	^RepositoryId fromString: ws contents</body><body package="Opentalk-IDL-MetaObjects">metaObjectOf: aSymbol 	"return the meta object which is associated with the given identifier"	^self definingMetaObject metaObjectOf: aSymbol</body><body package="Opentalk-IDL-MetaObjects">metaValueOf: aSymbol 	"return the meta value which is associated with the given identifier"	^(self metaObjectOf: aSymbol) value</body><body package="Opentalk-IDL-MetaObjects">registerIdentity	"Register the identity and full name of the receiver in the Interface 	Repository."	| fn |	prefix isNil ifFalse: [self repositoryId].	repositoryId isNil		ifFalse: 			[fn := self idlName.			InterfaceRepository at: repositoryId put: self.			InterfaceRepository at: fn asSymbol put: self.			RepositoryCache at: repositoryId put: self.			RepositoryCache at: fn asSymbol put: self]</body><body package="Opentalk-IDL-MetaObjects">removeContained: aMetaObject	"Remove references to a contained object, aMetaObject.	Only containers have something interesting to do"</body><body package="Opentalk-IDL-MetaObjects">removeMetaObject	"Most meta objects don't need any special processing. 	Only DSTinterfaces, DSTmodules, and DSTMetaContainers do 	something special."</body><body package="Opentalk-IDL-MetaObjects">resolveTypeReference	"implemented by DSTtypeNamed &amp;  DSTconstant only. Others 	should noop"</body><body package="Opentalk-IDL-MetaObjects">searchScopeFor: aSymbol 	"return the meta object which is associated with the given identifier"	^nil</body><body package="Opentalk-IDL-MetaObjects">unlinkFromRepository	"The receiver is being removed from the repository. Unlink as 	required"	[RepositoryCache includes: self]		whileTrue: [RepositoryCache removeKey: (RepositoryCache keyAtValue: self)].	[InterfaceRepository includes: self]		whileTrue: [InterfaceRepository removeKey: (InterfaceRepository keyAtValue: self)].	definedIn notNil ifTrue: [definedIn removeContained: self].	definedIn := nil</body></methods><methods><class-id>Opentalk.DSTMetaObject</class-id> <category>TypeCode</category><body package="Opentalk-IDL-MetaObjects">typeEqual: aTC 	"return if the receiver is equal to the given type code"	^self typeCodeConstant = aTC typeCodeConstant</body></methods><methods><class-id>Opentalk.DSTMetaObject</class-id> <category>printing</category><body package="Opentalk-IDL-MetaObjects">getIDLDefinition	"return the IDL definition of the receiver"	^self getIDLDefinition: #default</body><body package="Opentalk-IDL-MetaObjects">hasComment	"return true if the receiver has a comment string"	^(definition isNil or: [definition isEmpty]) not</body><body package="Opentalk-IDL-MetaObjects">hasPragma	"return true if the receiver has a pragma string"	^false</body><body package="Opentalk-IDL-MetaObjects">printCommentOn: aStream indent: level 	"print the comment of the receiver on the stream, inserting crs 	so that the appropriate print width is obtained. Return true iff 	a comment has been printed."	self hasComment ifFalse: [^false].	1 to: definition size		do: 			[:index | 			self				printSingleComment: (definition at: index)				on: aStream				indent: level.			aStream cr].	^true</body><body package="Opentalk-IDL-MetaObjects">printDefinitionOn: aStream indent: level style: aTextStyleName 	"subclasses must overload"	self subclassResponsibility</body><body package="Opentalk-IDL-MetaObjects">printHeaderOn: aStream indent: level 	"print the comment of the receiver on the stream. Precede the 	comment with an extra line that contains the receiver's 	name. Return true iff a comment has been printed."	level = 0 ifTrue: [(self hasComment and: [definition first = self printName asString])			ifFalse: [aStream tab: level; nextPutAll: '// '; nextPutAll: self printName; cr]].	^self printCommentOn: aStream indent: level</body><body package="Opentalk-IDL-MetaObjects">printSingleComment: aString on: aStream indent: indent 	"Print the comment string, assuming it has been indented 	indent tabs. Break the string at word breaks, given the widths 	in the default font, at 450 points."	| readStream position lineBreak font wordWidth tabWidth spaceWidth outStream char commentBegin commentBeginWidth leaderWidth |	readStream := aString readStream.	outStream := (String new: 16) writeStream.	font := Screen default defaultFontPolicy findFont: FontDescription default.	tabWidth := TextConstants at: #DefaultTab.	spaceWidth := font spaceWidth.	commentBegin := '// '.	commentBeginWidth := commentBegin inject: 0 into: [:w :c | w + (font widthOf: c)].	leaderWidth := indent * tabWidth + commentBeginWidth.	position := leaderWidth.	aStream tab: indent; nextPutAll: commentBegin.	lineBreak := 480 - spaceWidth.	char := readStream next.	["In the loop, char is the last character already 	read from readStream. We detect end-of-stream 	by char == nil, because we always read 1 character 	ahead."	char == nil]		whileFalse: [char = Character space				ifTrue: ["Skip inter-word spaces"					char := readStream next]				ifFalse: [char = Character cr						ifTrue: 							[[(char := readStream next) = Character tab]								whileTrue: [].	"skip tabs after cr"							aStream crtab: indent; nextPutAll: commentBegin.							position := leaderWidth]						ifFalse: 							["Collect a word onto outStream, 							and its width in wordWidth."							outStream reset.							wordWidth := 0.														[outStream nextPut: char.							wordWidth := wordWidth + (font widthOf: char).							char := readStream next.							char = Character cr or: [char = Character space or: [char == nil]]]								whileFalse: [].							position + wordWidth &gt; lineBreak								ifTrue: 									["Check whether the word will fit 									on a line."									aStream crtab: indent; nextPutAll: commentBegin.									position := leaderWidth].							aStream nextPutAll: outStream contents.							position := position + wordWidth.							readStream atEnd								ifFalse: 									[position := position + spaceWidth.									aStream space]]]]</body><body package="Opentalk-IDL-MetaObjects">publishDefinitionOn: aStream indent: level style: aTextStyleName 	"publish my definition"	self		printDefinitionOn: aStream		indent: level		style: aTextStyleName</body><body package="Opentalk-IDL-MetaObjects">stringNeedsFormatting: aString indent: level style: aTextStyleName 	"answer true if aString extends beyond the maximum right 	margin when starting at the specified indentation"	| tabWidth stringWidth |	tabWidth := TextConstants at: #DefaultTab.	stringWidth := ComposedText widthOfString: aString styleName: aTextStyleName.	^level + (stringWidth / tabWidth) &gt; 20</body><body package="Opentalk-IDL-MetaObjects">tabFor: aString style: aTextStyleName 	"Calculate the required number of tabs to cover the width of 	aString"	| tabWidth stringWidth |	tabWidth := TextConstants at: #DefaultTab.	stringWidth := ComposedText widthOfString: aString styleName: aTextStyleName.	^stringWidth // tabWidth + (stringWidth \\ tabWidth) sign</body><body package="Opentalk-IDL-MetaObjects">wantsSpace	"return true if the receiver wants an extra line of space before 	printing itself"	^self hasComment | self hasPragma</body></methods><methods><class-id>Opentalk.DSTMetaObject</class-id> <category>Contained</category><body package="Opentalk-IDL-MetaObjects">containingRepository	"The containingRepository attribute identifies the repository that is 	eventually reached by recursively following the object's definedIn 	attribute."	^DSTORBObject repository widenTo: #'::CORBA::Repository'</body><body package="Opentalk-IDL-MetaObjects">definedIn	"The definedIn attribute identifies the container within which the 	object is defined. Objects can be contained either because they are 	defined within the containing object or because they are inherited 	by the containing object. If an object is contained through 	inheritance, the definedIn attribute identifies the InterfaceDef from 	which the object is inherited."	^definedIn</body><body package="Opentalk-IDL-MetaObjects">definedInString	"Return the repository id of the container object as a byte string."	^self definedIn repositoryId asString</body><body package="Opentalk-IDL-MetaObjects">describe	"The describe operation returns information about the interface."	^Dictionary with: #kind -&gt; self defKind with: #value -&gt; self description</body><body package="Opentalk-IDL-MetaObjects">id	"The id attribute identifies the object globally."	repositoryId isNil		ifTrue: 			[repositoryId := self generateRepositoryId.			InterfaceRepository at: repositoryId put: self.			InterfaceRepository at: self idlName asSymbol put: self].	^repositoryId</body><body package="Opentalk-IDL-MetaObjects">id: aRepositoryId 	"Setting the id attribute changes the global identity of the interface. 	An error is returned if an object with the specified id attribute 	already exists within this object's repository."	self notYetImplemented</body><body package="Opentalk-IDL-MetaObjects">move: newContainer name: newName version: newVersion 	"The move operation atomically removes the receiver from its current 	container, and adds it to the container specified by newContainer, 	which must: 	1) be in the same repository 	2) be capable of containing this object's type 	3) not already contain an object with this object's name (unless 	multiple versions are supported by the IR) 	The name attribute is changed to newName, and the version 	attribute is changed to newVersion. 	The definedIn and absoluteName attributes are updated to reflect 	the new container and name. If this object is also a container, the 	absoluteName attributes of any objects it contains are also updated."	self notYetImplemented</body><body package="Opentalk-IDL-MetaObjects">name	"The name attribute identifies the object uniquely within the 	enclosing container object."	^name</body><body package="Opentalk-IDL-MetaObjects">name: newName 	"Setting the name attribute changes the identity of this definition 	within its container. An error is returned if an object with the 	specified name attribute already exists within this object's 	container."	self notYetImplemented</body><body package="Opentalk-IDL-MetaObjects">version	"The version attribute distinguishes the object from other versioned 	object with the same name."	version isNil ifTrue: [version := '1.0'].	^version</body><body package="Opentalk-IDL-MetaObjects">version: newVersion 	"The version attribute distinguishes the object from other versioned 	object with the same name."	self notYetImplemented</body></methods><methods><class-id>Opentalk.DSTMetaObject</class-id> <category>marshalling</category><body package="Opentalk-IDL-MetaObjects">boldMarshall: aParameter on: aStream 	"Marshall the parameter onto the stream. Subclasses must overload"	self subclassResponsibility</body><body package="Opentalk-IDL-MetaObjects">boldMarshall: aParameter on: aStream withLocalClass: aClass 	"Marshall the parameter onto the stream"	self boldMarshall: aParameter on: aStream</body><body package="Opentalk-IDL-MetaObjects">canMarshall: aParameter 	"return if the receiver can marshall the given parameter"	^(self marshallMatch: aParameter) ~~ false</body><body package="Opentalk-IDL-MetaObjects">marshall: aParameter on: aStream 	"Marshall the parameter onto the stream"	[self boldMarshall: aParameter on: aStream]		on: self errorSignal do: [:ex || sig |			sig := ex getSignal.			(sig class = Signal and: [ sig nameClass = DSTexception ])				ifTrue: [ ex pass ].			self class marshallError: 0]</body><body package="Opentalk-IDL-MetaObjects">marshall: aParameter on: aStream withLocalClass: aClass 	"Marshall the parameter onto the stream"	[self		boldMarshall: aParameter		on: aStream		withLocalClass: aClass]		on: self errorSignal do: [:ex | self class marshallError: 0]</body><body package="Opentalk-IDL-MetaObjects">tryMarshallIndirectTypeCode: aDictionary on: aStream 	"if the dictionary contains me, then marshall an indirect typecode"	^(aDictionary includesKey: self)		ifTrue: 			[aStream nextPutUnsignedLong: (self class typeCodeOf: #tk_indirect).			aStream nextPutLong: (aDictionary at: self)					- aStream position.			true]		ifFalse: 			[aStream padToLong.			aDictionary at: self put: aStream position.			false]</body><body package="Opentalk-IDL-MetaObjects">tryUnmarshallIndirectTypeCode: aDictionary from: aStream 	"if the dictionary contains me, then marshall an indirect typecode"	| ix |	^aStream peek = (self class typeCodeOf: #'tk_indirect')		ifTrue: 			[ix := aStream nextLong.			DSTtypeNamed new resolveTo: (aDictionary at: ix)]		ifFalse: 			[aDictionary add: aStream position -&gt; self.			nil]</body><body package="Opentalk-IDL-MetaObjects">tryUnmarshallIndirectTypeCode: aDictionary from: aStream typeKind: aTK 	"if the dictionary contains me, then marshall an indirect typecode"	| ix  |	^aTK = (self class typeCodeOf: #tk_indirect)		ifTrue: 			[ix := aStream nextLong.			DSTtypeNamed new resolveTo: (aDictionary at: aStream position + ix)]		ifFalse: 			[aDictionary add: aStream position -&gt; self.			nil]</body><body package="Opentalk-IDL-MetaObjects">typeCode	"return the type code of the receiver"	^self class typeCodeOf: self typeKind</body><body package="Opentalk-IDL-MetaObjects">unMarshallTypeCode: aDictionary from: aStream	"unmarshall an indirect type"	| ix  |	ix := aStream nextLong.	^(DSTtypeNamed new) resolveTo: (aDictionary at: aStream position + ix); yourself</body></methods><methods><class-id>Opentalk.DSTMetaObject</class-id> <category>persistence</category><body package="Opentalk-IDL-MetaObjects">persistentState	"return my persistent state. NOTE: will want to change this if we add copy 	semantics to meta objects later"	^#()</body></methods><methods><class-id>Opentalk.DSTMetaObject</class-id> <category>private</category><body package="Opentalk-IDL-MetaObjects">initialSOevents	^self shouldNotImplement</body><body package="Opentalk-IDL-MetaObjects">setVersion: newVersion 	"Set the version field of the meta object. Called from a version 	pragma."	version := newVersion</body></methods><methods><class-id>Opentalk.DSTMetaObject</class-id> <category>rendering</category><body package="Opentalk-IDL-MetaObjects">asMetaInfo	"return an Dictionary with information about the receiver"	^Dictionary		with: #title -&gt; self childName		with: #iconId -&gt; self iconId		with: #hasComponents -&gt; self hasComponents		with: #inheritedDirectly -&gt; false</body><body package="Opentalk-IDL-MetaObjects">childName	"return the name to be used for the receiver in a browser window"	^self printName</body><body package="Opentalk-IDL-MetaObjects">hasComponents	"return true iff I have components worthwhile to show in a browser 	window"	^true</body><body package="Opentalk-IDL-MetaObjects">iconId	"Return the key to find my icon image in the installed icon dictionary"	^self class iconId</body><body package="Opentalk-IDL-MetaObjects">nonTrivialDeclarators	"Get rid of declarators in the browser. Return the declarators of the 	receiver if there is more than one declarator, otherwise return an 	Array containing myself."	^self declarators</body><body package="Opentalk-IDL-MetaObjects">title	^self shouldNotImplement</body></methods><methods><class-id>Opentalk.DSTMetaObject</class-id> <category>initialization</category><body package="Opentalk-IDL-MetaObjects">initialize	"initialize the receiver"</body><body package="Opentalk-IDL-MetaObjects">initialize: aSymbol 	"initialize the type printname of the receiver"	self initialize.	name := aSymbol</body><body package="Opentalk-IDL-MetaObjects">reInitialize	"reinitialize the receiver. Zap my objectId and my locally generated 	identity"	repositoryId := nil.</body></methods><methods><class-id>Opentalk.DSTMetaObject</class-id> <category>fileIn/Out</category><body package="Opentalk-IDL-MetaObjects">representBinaryOn: binWriter 	"This is called by the BOSS when an on object is written to a BOSS 	stream. By default, meta objects do nothing special to represent 	themselves in binary form."	^nil</body></methods><methods><class-id>Opentalk.DSTMetaObject</class-id> <category>parcel support</category><body package="Opentalk-IDL-MetaObjects">postReadGeneralStructureOn: aBinaryStorageReader 	"Use the exsiting copy in the image, if there is one"	| existOne |	^(existOne := DSTORBObject lookupId: repositoryId) == nil		ifTrue: 			[(repositoryId isKindOf: RepositoryId)				ifTrue: [repositoryId := RepositoryId fromString: repositoryId].			self]		ifFalse: [self oneWayBecome: existOne]</body></methods><methods><class-id>Opentalk.DSTMetaObject</class-id> <category>MetaSem</category><body package="Opentalk-IDL-MetaObjects">definingMetaObject	"return the receiver's defining meta object" 	^definedIn ifNil: [DSTmoduleRepository new initialize: #Undefined]</body><body package="Opentalk-IDL-MetaObjects">getIDLDefinition: aTextStyleName 	"return the IDL definition of the receiver formatted with the 	specified text style (a Symbol, e.g. #fixed, #default)"	| str |	str := (String new: 80) writeStream.	self		printDefinitionOn: str		indent: 0		style: aTextStyleName.	^str contents</body><body package="Opentalk-IDL-MetaObjects">metaObject	^self</body><body package="Opentalk-IDL-MetaObjects">references	"Return a list with information about meta objects that are referencing the 	receiver. For each referent an Array with three Elements is returned, 	consisting of the referent, its full name, and the number of references to 	the receiver from the referent"	"(ORBObject repository metaObjectOf: #'ContainerSem') references"	"(ORBObject repository metaObjectOf: #'::Naming::NotFound') references"	| metas result refs |	metas := Set with: 1000.	self repository allMetaObjectsInto: metas.	refs := Bag new: 20.	metas		do: 			[:mo | mo isDSTMetaObject ifTrue: [				((mo isDSTtypeNamed)					and: [mo equivalentType idlName = self idlName])					ifTrue: [refs add: mo definingMetaObject].				(((mo isDSToperation)					and: [mo exceptions includes: self])					or: [(mo isDSTinterface)							and: [mo superiors includes: self]])					ifTrue: [refs add: mo]]].	result := refs asSet collect: [:ref | Dictionary					with: #referent -&gt; ref					with: #name -&gt; ref idlName					with: #count -&gt; (refs occurrencesOf: ref)].	^result</body><body package="Opentalk-IDL-MetaObjects">repository	"return the repository meta object"	^DSTORBObject repository</body></methods><methods><class-id>Opentalk.DSTMetaObject</class-id> <category>converting</category><body package="Opentalk-IDL-MetaObjects">convertSymbol: aSymbol 	"remove underscore characters and capitalize following character"	| str i |	str := aSymbol asString.	[str includes: $_]		whileTrue: 			[i := str indexOf: $_.			str := (str copyFrom: 1 to: i - 1)						, (str copyFrom: i + 1 to: str size) capitalized].	^str asSymbol</body></methods><methods><class-id>Opentalk.DSTMetaObject</class-id> <category>comparing</category><body package="Opentalk-IDL-MetaObjects">&lt;= aMetaObject 	"Answer true if and only if the receiver collates before aMetaObject or is 	the same as aMetaObject. The print names of meta objects are used for 	the comparison"	^self printName &lt;= aMetaObject printName</body></methods><methods><class-id>Opentalk.DSTMetaObject</class-id> <category>exceptions</category><body package="Opentalk-IDL-MetaObjects">notYetImplemented	"Raise an exception indicating that the write interface to the IR is not 	implemented."	self error: 'Interface repository write interface not yet implemented'</body></methods><methods><class-id>Opentalk.DSTMetaObject</class-id> <category>repository-private</category><body package="Opentalk-IDL-MetaObjects">canContain: kind 	"Check to see if the definition kind can be contained in the receiver."	^false</body></methods><methods><class-id>Opentalk.DSTMetaObject class</class-id> <category>very private</category><body package="Opentalk-IDL-MetaObjects">initializeTypeCodes	TCMap := TCTable := nil</body></methods><methods><class-id>Opentalk.DSTMetaObject class</class-id> <category>utilities</category><body package="Opentalk-IDL-MetaObjects">confirmCriticalClassName: aClassName andSelector: aSelectorSymbol	^( aClassName == #DSTRepository and:		[ self criticalModules includes: aSelectorSymbol ] )		ifTrue:	[	Dialog confirm:							(	'The IDL module you are about to edit remotely\',							'is used in support of remote editing itself.  Are\',							'you *sure* that you want to edit it?'						) withCRs				]		ifFalse:	[ true ]</body><body package="Opentalk-IDL-MetaObjects">criticalModules	"Return a collection of repository units that are needed during repository 	editing and therefore cannot be changed using the repository browser."	"ONLY CHANGE WHEN YOU ARE SURE WHAT YOU ARE DOING!"	"Extended in DST 5.8 to include:		#DSTEnvironmentService, and 		#SmartClassAgent."	^#(	#Debugging 		#DistributedSmalltalk 		#DynamicInvocation 		#PSSplitBasic 		#SharedIR 		#IRBrowser		#DSTEnvironmentService		#SmartClassAgent	  )</body><body package="Opentalk-IDL-MetaObjects">extractFullName: aReposId 	"Extract the fullName from the IDL format repositoryId from the fullname based upon the IR Specification"	| ws first last ch rs | 	rs := aReposId asString.	ws := WriteStream on: (ByteString new: aReposId size + 10).	ws nextPutAll: '::'.	first := rs findFirst: [:c | c = $:].	first isZero		ifTrue: [self error: 'invalid repositoryId']		ifFalse: 			[last := rs findLast: [:c | c = $:].			first + 1 to: last - 1				do: 					[:i | 					ch := rs at: i.					ch = $/						ifTrue: [ws nextPutAll: '::']						ifFalse: [ws nextPut: ch]].			^ws contents]</body><body package="Opentalk-IDL-MetaObjects">parseName: aString 	"return the components of the qualified name aString as 	ordered collection"	| x tail |	x := aString findFirst: [:ch | ch = $:].	x isZero		ifFalse: 			[tail := aString copyFrom: x + 2 to: aString size.			x = 1 ifTrue: [^self parseName: tail].			^(self parseName: tail)				addFirst: (aString copyFrom: 1 to: x - 1); yourself]		ifTrue: [^OrderedCollection with: aString]</body><body package="Opentalk-IDL-MetaObjects">scopedNameFrom: anOrderedCollection 	"return a scoped name using the elements of 	anOrderedCollection as the name components"	"self scopedNameFrom: (self parseName: '::a::b::c')"	"self scopedNameFrom: (self parseName: 'a')"	"self scopedNameFrom: #()"	^(anOrderedCollection inject: (WriteStream on: (String new: 20))		into: [:result :el | result nextPutAll: '::'; nextPutAll: el asString; yourself]) contents</body></methods><methods><class-id>Opentalk.DSTMetaObject class</class-id> <category>marshalling</category><body package="Opentalk-IDL-MetaObjects">typeCodeOf: typeKind 	"return the type code of the kind" 	^self typeCodeMap at: typeKind ifAbsent: [nil]</body><body package="Opentalk-IDL-MetaObjects">unMarshallTypeCode: aDictionary from: aStream 	"unmarshall a type code and return an appropriate metaobject"	| tk |	tk := aStream nextUnsignedLong.	^(self typeCodeTable at: tk ifAbsent: [self intfReposError: 0]) new unMarshallTypeCode: aDictionary from: aStream</body><body package="Opentalk-IDL-MetaObjects">unMarshallTypeCode: aDictionary from: aStream typeKind: anInteger 	"unmarshall a type code and return an appropriate metaobject"	^(self typeCodeTable at: anInteger ifAbsent: [self intfReposError: 0]) new unMarshallTypeCode: aDictionary from: aStream</body></methods><methods><class-id>Opentalk.DSTMetaObject class</class-id> <category>rendering</category><body package="Opentalk-IDL-MetaObjects">iconId	"Return the key to find my icon image in the installed icon dictionary"	^self name</body></methods><methods><class-id>Opentalk.DSTMetaObject class</class-id> <category>creation</category><body package="Opentalk-IDL-MetaObjects">new	"create and initialize a metaobject"	^self basicNew initialize</body><body package="Opentalk-IDL-MetaObjects">prefix: aScope 	| mo |	mo := self basicNew initialize.	mo prefix: aScope prefix.	^mo</body></methods><methods><class-id>Opentalk.DSTMetaObject class</class-id> <category>private</category><body package="Opentalk-IDL-MetaObjects">initializeCurrentPrefix	CurrentPrefix := nil</body><body package="Opentalk-IDL-MetaObjects">typeCodeMap	"Answer the type code map."	^TCMap		ifNil: 			[TCMap := IdentityDictionary new.			TCMap add: #tk_null -&gt; 0.			TCMap add: #tk_void -&gt; 1.			TCMap add: #tk_short -&gt; 2.			TCMap add: #tk_long -&gt; 3.			TCMap add: #tk_ushort -&gt; 4.			TCMap add: #tk_ulong -&gt; 5.			TCMap add: #tk_float -&gt; 6.			TCMap add: #tk_double -&gt; 7.			TCMap add: #tk_boolean -&gt; 8.			TCMap add: #tk_char -&gt; 9.			TCMap add: #tk_octet -&gt; 10.			TCMap add: #tk_any -&gt; 11.			TCMap add: #tk_TypeCode -&gt; 12.			TCMap add: #tk_Principal -&gt; 13.			TCMap add: #tk_objref -&gt; 14.			TCMap add: #tk_struct -&gt; 15.			TCMap add: #tk_union -&gt; 16.			TCMap add: #tk_enum -&gt; 17.			TCMap add: #tk_string -&gt; 18.			TCMap add: #tk_sequence -&gt; 19.			TCMap add: #tk_array -&gt; 20.			TCMap add: #tk_alias -&gt; 21.			TCMap add: #tk_except -&gt; 22.			TCMap add: #tk_longlong -&gt; 23.			TCMap add: #tk_ulonglong -&gt; 24.			TCMap add: #tk_longdouble -&gt; 25.			TCMap add: #tk_wchar -&gt; 26.			TCMap add: #tk_wstring -&gt; 27.			TCMap add: #tk_fixed -&gt;28.			TCMap add: #tk_indirect -&gt; 4294967295.			TCMap yourself]</body><body package="Opentalk-IDL-MetaObjects">typeCodeTable	"Answer the type code table."	^TCTable		ifNil: 			[TCTable := Dictionary new.			TCTable add: (self typeCodeOf: #tk_null)					-&gt; DSTtypeVoid.			TCTable add: (self typeCodeOf: #tk_void)					-&gt; DSTtypeVoid.			TCTable add: (self typeCodeOf: #tk_short)					-&gt; DSTtypeShort.			TCTable add: (self typeCodeOf: #tk_long)					-&gt; DSTtypeLong.			TCTable add: (self typeCodeOf: #tk_ushort)					-&gt; DSTtypeUnsignedShort.			TCTable add: (self typeCodeOf: #tk_ulong)					-&gt; DSTtypeUnsignedLong.			TCTable add: (self typeCodeOf: #tk_float)					-&gt; DSTtypeFloat.			TCTable add: (self typeCodeOf: #tk_double)					-&gt; DSTtypeDouble.			TCTable add: (self typeCodeOf: #tk_boolean)					-&gt; DSTtypeBoolean.			TCTable add: (self typeCodeOf: #tk_char)					-&gt; DSTtypeCharacter.			TCTable add: (self typeCodeOf: #tk_octet)					-&gt; DSTtypeOctet.			TCTable add: (self typeCodeOf: #tk_any)					-&gt; DSTtypeAny.			TCTable add: (self typeCodeOf: #tk_TypeCode)					-&gt; DSTpseudoTypeCode.			TCTable add: (self typeCodeOf: #tk_Principal)					-&gt; DSTinterface.			TCTable add: (self typeCodeOf: #tk_objref)					-&gt; DSTinterface.			TCTable add: (self typeCodeOf: #tk_struct)					-&gt; DSTtypeStructure.			TCTable add: (self typeCodeOf: #tk_union)					-&gt; DSTtypeUnion.			TCTable add: (self typeCodeOf: #tk_enum)					-&gt; DSTtypeEnumeration.			TCTable add: (self typeCodeOf: #tk_string)					-&gt; DSTtypeString.			TCTable add: (self typeCodeOf: #tk_sequence)					-&gt; DSTtypeSequence.			TCTable add: (self typeCodeOf: #tk_array)					-&gt; DSTtypeArray.			TCTable add: (self typeCodeOf: #tk_alias)					-&gt; DSTtypeAlias.			TCTable add: (self typeCodeOf: #tk_except)					-&gt; DSTexception.			TCTable add: (self typeCodeOf: #tk_longlong)					-&gt; DSTtypeLongLong.			TCTable add: (self typeCodeOf: #tk_ulonglong)					-&gt; DSTtypeUnsignedLongLong.			TCTable add: (self typeCodeOf: #tk_longdouble)					-&gt; DSTtypeLongDouble.			TCTable add: (self typeCodeOf: #tk_wchar)					-&gt; DSTtypeWideCharacter.			TCTable add: (self typeCodeOf: #tk_wstring)					-&gt; DSTtypeWideString.			TCTable add: (self typeCodeOf: #tk_fixed)					-&gt; DSTtypeFixed.			TCTable add: (self typeCodeOf: #tk_indirect)					-&gt; DSTMetaObject.			TCTable yourself]</body></methods><methods><class-id>Opentalk.DSTtype</class-id> <category>printing</category><body package="Opentalk-IDL-MetaObjects">IDLTypeName	"return the printable name of the receiver's IDL type ie the type to be 	actually marshalled in the NCS packet"	^name</body><body package="Opentalk-IDL-MetaObjects">declaratorPrintName: n 	"return the nth declarator's printName"	declarators isNil ifFalse: [^(declarators at: n) printName]</body><body package="Opentalk-IDL-MetaObjects">declaratorString	"return the declarator definition string of the receiver"	| st |	st := WriteStream on: ( String new: 32 ).	self printDeclaratorsOn: st.	^st contents</body><body package="Opentalk-IDL-MetaObjects">definitionString	"return my unformatted IDL type definition string"	^name</body><body package="Opentalk-IDL-MetaObjects">hasPragma	"return true if the receiver has a pragma string"	^self localType notNil</body><body package="Opentalk-IDL-MetaObjects">printDeclaratorsOn: aStream 	"print the declarators list onto the stream"	| dec |	declarators isNil		ifFalse: 			[dec := declarators at: 1.			aStream nextPutAll: dec declaratorString.			2 to: declarators size				do: 					[:i | 					dec := declarators at: i.					aStream nextPutAll: ', '; nextPutAll: dec declaratorString]]</body><body package="Opentalk-IDL-MetaObjects">printDefinitionOn: aStream indent: level style: aTextStyleName 	"Print my IDL definition on the stream."	"Since the default Parser class is used to parse the selector of IDL 	units, it is important that the first token of an IDL 'method' is parsed 	correctly by Parser. Specifically, it must be avoided that the pound 	sign is the 	first character in the method, since it would cause a parsing 	problem. 	Therefore we show pragmas AFTER the comment lines and we also 	make sure that there is always at least one comment line. Also note, 	that 	senders of Parser&gt;&gt;parseSelector: (such as 	Text&gt;&gt;makeSelectorBoldIn:) 	assume that the selector starts at position 1 of the method source."	self printHeaderOn: aStream indent: level.	prefix isNil ifFalse: [CurrentPrefix ~= prefix prefixString			ifTrue: 				[aStream tab: level; nextPutAll: '#pragma  prefix '; nextPut: $"; nextPutAll: prefix prefixString; nextPut: $"; cr.				CurrentPrefix := prefix prefixString]].	aStream tab: level.	declarators isNil		ifTrue: 			[self				printFormattedOn: aStream				indent: level				style: aTextStyleName.			aStream nextPutAll: ';'; cr]		ifFalse: 			[self hasPragma				ifTrue: 					[aStream nextPutAll: '#pragma class '; nextPutAll: (self declaratorPrintName: 1); nextPutAll: ' '; nextPutAll: self localType; cr.					aStream tab: level; nextPutAll: 'typedef ']				ifFalse: [aStream nextPutAll: 'typedef '].			self				printFormattedOn: aStream				indent: level + (self tabFor: 'typedef ' style: aTextStyleName)				style: aTextStyleName.			aStream nextPut: $ ; nextPutAll: self declaratorString; nextPut: $;; cr]</body><body package="Opentalk-IDL-MetaObjects">printFormattedOn: aStream indent: level style: aTextStyleName 	"print the detailed formatted definition of the receiver on 	aStream. To be overloaded by subclasses if formatting is 	actually required"	aStream nextPutAll: self definitionString</body><body package="Opentalk-IDL-MetaObjects">printHeaderOn: aStream indent: level 	"print the comment of the receiver on the stream. Precede the 	comment with an extra line that contains the receiver's 	name. Return true iff a comment has been printed."	level = 0 ifTrue: [(self hasComment and: [definition first = self childName asString])			ifFalse: [aStream tab: level; nextPutAll: '// '; nextPutAll: self childName; cr]].	^self printCommentOn: aStream indent: level</body><body package="Opentalk-IDL-MetaObjects">printOn: aStream 	"print the receiver's printname on the stream"	[aStream nextPutAll: self definitionString , '  ' , self idlName]		on: Object errorSignal do: [:x | ^super printOn: aStream]</body><body package="Opentalk-IDL-MetaObjects">publishDefinitionOn: aStream indent: level style: aTextStyleName 	"publish my IDL definition on the stream"	self printHeaderOn: aStream indent: level.	aStream tab: level.	declarators isNil		ifTrue: 			[self				printFormattedOn: aStream				indent: level				style: aTextStyleName.			aStream nextPutAll: ';'; cr]		ifFalse: 			[aStream nextPutAll: 'typedef '.			self				printFormattedOn: aStream				indent: level + (self tabFor: 'typedef ' style: aTextStyleName)				style: aTextStyleName.			aStream nextPut: $ ; nextPutAll: self declaratorString; nextPut: $;; cr]</body></methods><methods><class-id>Opentalk.DSTtype</class-id> <category>initialization</category><body package="Opentalk-IDL-MetaObjects">initialize: aSymbol 	"set the type printname of the receiver"	name := aSymbol</body><body package="Opentalk-IDL-MetaObjects">localType: aClassName 	"set the description and local type fields"	aClassName isEmpty		ifTrue: [localtype := nil]		ifFalse: [localtype := aClassName asSymbol]</body><body package="Opentalk-IDL-MetaObjects">with: decls 	"set the type printname of the receiver"	declarators := decls.</body></methods><methods><class-id>Opentalk.DSTtype</class-id> <category>copying</category><body package="Opentalk-IDL-MetaObjects">copy	"perform the copy operation on the receiver"	| obj |	obj := super shallowCopy.	declarators notNil ifTrue: 		[obj declarators: (declarators collect: [:co | co copyDeclaratorOn: self])].	^obj postCopy</body><body package="Opentalk-IDL-MetaObjects">copyDeclaratorOn: aType	"make a copy of a declarator type, remembering that the declarator will point 	back to the type object which contained it as a declarator. We must avoid 	an infinite loop. Named, array, &amp; pointer types must overload"	^self shallowCopy</body></methods><methods><class-id>Opentalk.DSTtype</class-id> <category>repository</category><body package="Opentalk-IDL-MetaObjects">allMetaObjectsInto: aSet	"add all of the contained metaobjects to the set"	super allMetaObjectsInto: aSet.	declarators notNil ifTrue: [declarators  do: [:dec | aSet add: dec]].</body><body package="Opentalk-IDL-MetaObjects">typeKind	"return the TCKind of the receiver"	^self subclassResponsibility</body></methods><methods><class-id>Opentalk.DSTtype</class-id> <category>marshalling</category><body package="Opentalk-IDL-MetaObjects">marshallTypeCode: aDictionary on: aStream 	"marshall the type code of the receiver. Types with more interesting 	codes should overload"	(self tryMarshallIndirectTypeCode: aDictionary on: aStream)		ifTrue: [^self].	aStream nextPutUnsignedLong: self typeCode</body><body package="Opentalk-IDL-MetaObjects">unMarshall: aStream 	"Unmarshall a result from the stream and return an object of the 	appropriate class. Subclasses must overload"	self subclassResponsibility</body><body package="Opentalk-IDL-MetaObjects">unMarshall: aStream withLocalClass: aClass 	"Unmarshall a result from the stream and return an object of the 	appropriate class"	^self unMarshall: aStream</body><body package="Opentalk-IDL-MetaObjects">unMarshallTypeCode: aDictionary from: aStream typeKind: anInt 	"unmarshall the type code of the receiver. Types with more 	interesting codes should overload"	| mo |	(mo := self				tryUnmarshallIndirectTypeCode: aDictionary				from: aStream				typeKind: anInt) notNil ifTrue: [^mo].	anInt = self typeCode ifFalse: [self class badTypecodeError: 0]</body></methods><methods><class-id>Opentalk.DSTtype</class-id> <category>accessing</category><body package="Opentalk-IDL-MetaObjects">baseType	"The baseType of most types is self."	^self</body><body package="Opentalk-IDL-MetaObjects">declarators	"return the declarators of the receiver, or an array of self if nil"	declarators notNil		ifTrue: [^declarators]		ifFalse: [^#()]</body><body package="Opentalk-IDL-MetaObjects">declarators: decls 	"set the declarators of the receiver"	declarators := decls.	declarators do: [:dec| dec resolveTo: self]</body><body package="Opentalk-IDL-MetaObjects">definedIn: aMetaObject 	"set the receiver's defining container meta object"	super definedIn: aMetaObject.	declarators notNil ifTrue: [declarators do: [:ty | ty definedInOnly: aMetaObject]]</body><body package="Opentalk-IDL-MetaObjects">idlName	"return the receivers full qualified name"	^self definingMetaObject idlName , '::' , self childName</body><body package="Opentalk-IDL-MetaObjects">localClass	"return the local class of the receiver"	localclass == nil ifFalse: [^localclass].	localtype == nil ifTrue: [^nil].	^localclass := Opentalk at: localtype ifAbsent: [self class intfReposError: 0]</body><body package="Opentalk-IDL-MetaObjects">localType	"return the local type of the receiver"	^localtype</body><body package="Opentalk-IDL-MetaObjects">nAry	"types used as targets of relationships are not nAry"	^false</body><body package="Opentalk-IDL-MetaObjects">resolveLocalTypesIn: aType 	"Called by typeAny to get any local type symbols which relate to the 	receiver in its scope. Currently, only structures have sufficent 	information to be able to resolve.  Do nothing here"</body><body package="Opentalk-IDL-MetaObjects">resolveTo: aType	"cause the receiver to resolve to the given type object"	self error: 'Must be overridden by subclass'</body></methods><methods><class-id>Opentalk.DSTtype</class-id> <category>TypeDef</category><body package="Opentalk-IDL-MetaObjects">description	"return the appropriate description for the receiver"	^Dictionary		with: #name -&gt; name		with: #id -&gt; self id		with: #definedIn -&gt; self definedInString		with: #type -&gt; self</body><body package="Opentalk-IDL-MetaObjects">type	"return the type code of the receiver"	^self</body></methods><methods><class-id>Opentalk.DSTtype</class-id> <category>testing</category><body package="Opentalk-IDL-MetaObjects">isDSTtype	^true</body></methods><methods><class-id>Opentalk.DSTtype</class-id> <category>TypeCode</category><body package="Opentalk-IDL-MetaObjects">typeParamCount	"return the number of parameters which the receiver supports. 	Subtypes should overload as required"	^0</body><body package="Opentalk-IDL-MetaObjects">typeParameter: anInt	"return the nth parameter which the receiver supports. 	Subtypes should overload as required"	self error: #Bounds</body></methods><methods><class-id>Opentalk.DSTtype</class-id> <category>rendering</category><body package="Opentalk-IDL-MetaObjects">childName	"return the name to be used for the receiver in a browser window"	^declarators isNil		ifTrue: [self printName]		ifFalse: [declarators first name]</body><body package="Opentalk-IDL-MetaObjects">nonTrivialDeclarators	"Get rid of declarators in the browser. Return the declarators of the 	receiver if there is more than one declarator, otherwise return an 	Array containing myself."	^(declarators isNil or: [declarators size == 1])		ifTrue: [Array with: self]		ifFalse: [declarators]</body></methods><methods><class-id>Opentalk.DSTtype class</class-id> <category>accessing</category><body package="Opentalk-IDL-MetaObjects">iconId	"Return the key to find my icon image in the installed icon dictionary"	^#DSTtype</body></methods><methods><class-id>Opentalk.DSTtypeNamed</class-id> <category>accessing</category><body package="Opentalk-IDL-MetaObjects">attemptResolution	"return the equivalentType or attempt to resolve. Return nil if this is 	not possible"	equivalentType notNil ifTrue: [^equivalentType].	equivalentType := self definingMetaObject metaObjectOf: name.	^equivalentType</body><body package="Opentalk-IDL-MetaObjects">equivType	"private - return the equivalentType"	^equivalentType</body><body package="Opentalk-IDL-MetaObjects">equivalentType	"return the equivalentType. Resolve if necessary, and fail if not 	resolvable"	(equivalentType isNil and: [self attemptResolution isNil])		ifTrue: 			[Transcript show: 'Forward declaration of "' , name , '" in "' , self definingMetaObject printName , '" never defined.'; cr.			self class intfReposError: 0].	^equivalentType</body><body package="Opentalk-IDL-MetaObjects">resolveTo: aType 	"cause the receiver to resolve to the given type object"	equivalentType := aType</body><body package="Opentalk-IDL-MetaObjects">value	"return the value of the receiver's equivalent type"	^self equivalentType value</body><body package="Opentalk-IDL-MetaObjects">valueExcept: aCol 	"Answer a valid value not contained in the collection, otherwise 	nil"	^self equivalentType valueExcept: aCol</body></methods><methods><class-id>Opentalk.DSTtypeNamed</class-id> <category>marshalling</category><body package="Opentalk-IDL-MetaObjects">boldMarshall: aParameter on: aStream 	"Marshall the parameter onto the stream"	self equivalentType boldMarshall: aParameter on: aStream</body><body package="Opentalk-IDL-MetaObjects">boldMarshall: aParameter on: aStream withLocalClass: aClass	"Marshall the parameter onto the stream" 	self equivalentType boldMarshall: aParameter on: aStream withLocalClass: aClass</body><body package="Opentalk-IDL-MetaObjects">marshallMatch: aParameter 	"Return:		true			- if I can marshall the parameter		false		- if I can NOT marshall the parameter		#mappable	- if I can marshall the parameter by mapping to something else"		^self equivalentType marshallMatch: aParameter</body><body package="Opentalk-IDL-MetaObjects">unMarshall: aStream 	"Unmarshall a result from the stream and return an object of the 	appropriate class"	^self equivalentType unMarshall: aStream</body><body package="Opentalk-IDL-MetaObjects">unMarshall: aStream withLocalClass: aClass 	"Unmarshall a result from the stream and return an object of the 	appropriate class"	^self equivalentType unMarshall: aStream withLocalClass: aClass</body></methods><methods><class-id>Opentalk.DSTtypeNamed</class-id> <category>repository</category><body package="Opentalk-IDL-MetaObjects">checkReferencesUniqueness	"check if name resolution is ambiguous"	| ref |	 	[DSTmoduleRepository convenientNameResolution: false.	equivalentType := nil.	ref := self attemptResolution.	ref isNil ifTrue: [^nil].	(ref isDSTMetaObject)		ifTrue: [ref := Set with: ref].	ref size &gt; 1 ifTrue: [Dialog notify: 'Resolution of ''' , self printName , ''' for ''' , self idlName , ''' is ambiguous']]		ensure: 			[DSTmoduleRepository convenientNameResolution: true.			equivalentType := nil]</body><body package="Opentalk-IDL-MetaObjects">corbaInterfaceIn: aRepository"return the CORBAInterface of the receiver. This must be the equivalent type's CORBAInterface since typeObject forwards also"	^self equivalentType corbaInterfaceIn: aRepository</body><body package="Opentalk-IDL-MetaObjects">corbaTypeIn: aRepository	"return the CORBAType of the receiver. This must be the equivalent 	type's CORBAType since typeObject forwards also"	^self equivalentType corbaTypeIn: aRepository</body><body package="Opentalk-IDL-MetaObjects">marshallTypeCode: aDictionary on: aStream	"marshall the type code of the receiver"	^self equivalentType marshallTypeCode: aDictionary on: aStream</body><body package="Opentalk-IDL-MetaObjects">metaValueOf: aSymbol 	"return the meta value which is associated with the given identifier"	^self equivalentType metaValueOf: aSymbol</body><body package="Opentalk-IDL-MetaObjects">resolveLocalTypesIn: aType 	"Called by typeAny to get any local type symbols which relate to the 	receiver in its scope."	self equivalentType resolveLocalTypesIn: aType</body><body package="Opentalk-IDL-MetaObjects">resolveTypeReference	"implemented by DSTtypeNamed &amp; DSTconstant. Others 	should noop"	| msg |	self resolveTo: (self definingMetaObject metaObjectOf: name).	equivalentType isNil ifTrue: [		msg := 'Forward declaration of "' , name , '" in "' , self definingMetaObject printName , '" never defined.'.		Transcript show: msg; cr.		"Dialog notify: msg"]</body><body package="Opentalk-IDL-MetaObjects">typeKind	"return the TCKind of the receiver"	^self equivalentType typeKind</body><body package="Opentalk-IDL-MetaObjects">typeParamCount	"return the TCParamCount of the receiver"	^self equivalentType typeParamCount</body><body package="Opentalk-IDL-MetaObjects">typeParameter: anInt	"return the TCParameter of the receiver"	^self equivalentType typeParameter: anInt</body></methods><methods><class-id>Opentalk.DSTtypeNamed</class-id> <category>testing</category><body package="Opentalk-IDL-MetaObjects">isDSTtypeNamed	^true</body></methods><methods><class-id>Opentalk.DSTtypeNamed</class-id> <category>printing</category><body package="Opentalk-IDL-MetaObjects">asString	"return the string representation of the receiver"	^self printName</body><body package="Opentalk-IDL-MetaObjects">printDefinitionOn: aStream indent: level style: aTextStyleName 	"Print the IDL definition of the receiver onto the stream. 	Special case interface forward references."	| eqType |	eqType := self equivalentType.	eqType isNil ifTrue: [self error: 'Forward declaration of ' , self printName , ' never defined'].	(eqType isDSTMetaObject and: [eqType isDSTinterface])		ifTrue: 			[self printHeaderOn: aStream indent: level.			aStream tab: level; nextPutAll: 'interface '; nextPutAll: name asString; nextPut: $;; cr.			^self].	eqType		printDefinitionOn: aStream		indent: level		style: aTextStyleName</body><body package="Opentalk-IDL-MetaObjects">printOn: aStream 	"print the receiver's printname on the stream"	aStream nextPutAll: 'ref ' , self idlName</body></methods><methods><class-id>Opentalk.DSTtypeNamed</class-id> <category>copying</category><body package="Opentalk-IDL-MetaObjects">copyDeclaratorOn: aType	"make a copy of a declarator type, remembering that the declarator will point 	back to the type object which contained it as a declarator. We must avoid 	an infinite loop. Array, &amp; pointer types must overload"	| obj |	obj := super copyDeclaratorOn: aType .	obj resolveTo: nil.	^obj</body></methods><methods><class-id>Opentalk.DSTtypeNamed</class-id> <category>initialization</category><body package="Opentalk-IDL-MetaObjects">d: aDescr s: supers n: aName i: anInterface 	"Called when a forward declaration is seen. 	Supers and anInterface are not used."	(aName isSymbol)		ifFalse: [self error: 'Print name must be a symbol'].	name := aName asSymbol.	definition := aDescr</body></methods><methods><class-id>Opentalk.DSTtypeNamed</class-id> <category>rendering</category><body package="Opentalk-IDL-MetaObjects">iconId	"Return the key to find my icon image in the installed icon dictionary"	^self equivalentType iconId</body><body package="Opentalk-IDL-MetaObjects">nonTrivialDeclarators	"Don't display forward declarations of interfaces in the browser."	^#()</body></methods><methods><class-id>Opentalk.DSTtypeBase</class-id> <category>repository</category><body package="Opentalk-IDL-MetaObjects">CORBAName	"return the name of my CORBA interface in the repository"	^#'::CORBA::PrimitiveDef'</body><body package="Opentalk-IDL-MetaObjects">defKind        "Return the definition kind."        ^#dk_Primitive</body></methods><methods><class-id>Opentalk.DSTtypeBase</class-id> <category>marshalling</category><body package="Opentalk-IDL-MetaObjects">marshallTypeCode: aDictionary on: aStream 	"marshall the type code of the receiver. Types with more interesting 	codes should overload"	aStream nextPutUnsignedLong: self typeCode</body><body package="Opentalk-IDL-MetaObjects">unMarshallTypeCode: aDictionary from: aStream	"unmarshall the type code of the receiver - do nothing since the 	TCKind has already been unmarshalled and base types have no 	TypeCode parameters"	^self</body></methods><methods><class-id>Opentalk.DSTtypeBase</class-id> <category>Primitive Def</category><body package="Opentalk-IDL-MetaObjects">kind	"return the receiver's primitive type"	^self subclassResponsibility</body></methods><methods><class-id>Opentalk.DSTtypeBase</class-id> <category>rendering</category><body package="Opentalk-IDL-MetaObjects">hasComponents	"return true iff I have components worthwhile to show in a browser 	window"	^declarators notNil</body></methods><methods><class-id>Opentalk.DSTtypeFloat</class-id> <category>marshalling</category><body package="Opentalk-IDL-MetaObjects">boldMarshall: aParameter on: aStream 	"Marshall the parameter onto the stream"	"canMarshall = MNU on asFloat"	aStream nextPutFloat: aParameter asFloat</body><body package="Opentalk-IDL-MetaObjects">marshallMatch: aParameter 	"Return:		true			- if I can marshall the parameter		false		- if I can NOT marshall the parameter		#mappable	- if I can marshall the parameter by mapping to something else"		^aParameter isKindOf: Number</body><body package="Opentalk-IDL-MetaObjects">unMarshall: aStream 	"Unmarshall a result from the stream and return an object of the 	appropriate class"	^aStream nextFloat</body></methods><methods><class-id>Opentalk.DSTtypeFloat</class-id> <category>initialization</category><body package="Opentalk-IDL-MetaObjects">initialize	"initialize the receiver"	super initialize.	name := 'float'</body></methods><methods><class-id>Opentalk.DSTtypeFloat</class-id> <category>repository</category><body package="Opentalk-IDL-MetaObjects">typeKind	"return the TCKind of the receiver"	^#tk_float</body></methods><methods><class-id>Opentalk.DSTtypeFloat</class-id> <category>Primitive Def</category><body package="Opentalk-IDL-MetaObjects">kind	"return the receiver's primitive type"	^#pk_float</body></methods><methods><class-id>Opentalk.DSTtypeConstr</class-id> <category>printing</category><body package="Opentalk-IDL-MetaObjects">wantsSpace	"return true if the receiver wants an extra line of space before 	printing itself"	^true</body></methods><methods><class-id>Opentalk.DSTtypeConstr</class-id> <category>accessing</category><body package="Opentalk-IDL-MetaObjects">baseType	^self</body><body package="Opentalk-IDL-MetaObjects">declarators	"return the declarators of the receiver, or an array of self if nil"	declarators notNil		ifTrue: [^declarators]		ifFalse: [^Array with: self]</body></methods><methods><class-id>Opentalk.DSTtypeConstr</class-id> <category>repository</category><body package="Opentalk-IDL-MetaObjects">defKind        "Return the definition kind."        ^#dk_Typedef</body></methods><methods><class-id>Opentalk.DSTtypeTemplate</class-id> <category>rendering</category><body package="Opentalk-IDL-MetaObjects">childName	"return the name to be used for the receiver in a browser window"	^declarators isNil		ifTrue: [self definitionString]		ifFalse: [super childName]</body></methods><methods><class-id>Opentalk.DSTtypeTemplate</class-id> <category>accessing</category><body package="Opentalk-IDL-MetaObjects">definedIn: aMetaObject 	"set the receiver's defining container meta object"	super definedIn: aMetaObject.	subtype notNil ifTrue: [subtype definedIn: aMetaObject]</body><body package="Opentalk-IDL-MetaObjects">nAry	"template types used as targets of relationships are nAry"	^true</body><body package="Opentalk-IDL-MetaObjects">subtype	"return the subtype of the receiver"	^subtype</body><body package="Opentalk-IDL-MetaObjects">subtype: atype	"set the subtype of the receiver"	subtype := atype</body></methods><methods><class-id>Opentalk.DSTtypeTemplate</class-id> <category>repository</category><body package="Opentalk-IDL-MetaObjects">allMetaObjectsInto: aSet	"add all of the contained metaobjects to the set"	super allMetaObjectsInto: aSet.	subtype allMetaObjectsInto: aSet</body><body package="Opentalk-IDL-MetaObjects">canApplyPragma: pragma 	"Check to see if the argument pragma can be applied to the receiver."	^#(#CLASS) includes: pragma</body><body package="Opentalk-IDL-MetaObjects">typeKind	"return the TCKind of the receiver"	^#tk_array</body><body package="Opentalk-IDL-MetaObjects">typeParamCount	"return the number of parameters which the receiver supports. 	Subtypes should overload as required"	^2</body><body package="Opentalk-IDL-MetaObjects">typeParameter: anInt	"return the nth parameter which the receiver supports. 	Subtypes should overload as required"	anInt = 1 ifTrue: [^subtype].	anInt = 2 ifTrue: [^size].	self error: #Bounds</body></methods><methods><class-id>Opentalk.DSTtypeTemplate</class-id> <category>initialization</category><body package="Opentalk-IDL-MetaObjects">sizes: sizes ident: aSymbol 	"Initialize instance variables for a fixed sized array"	name := aSymbol.	size := sizes at: 1.	sizes size = 1		ifTrue: [subtype := nil]		ifFalse: [subtype := self class new sizes: (sizes copyFrom: 2 to: sizes size)						ident: '']</body><body package="Opentalk-IDL-MetaObjects">subtype: aType size: aSize	"initialize the subtype and size of the receiver"	subtype := aType.	size := aSize.</body></methods><methods><class-id>Opentalk.DSTtypeTemplate</class-id> <category>printing</category><body package="Opentalk-IDL-MetaObjects">IDLTypeName	"return the printable name of the receiver's IDL type ie the type to be 	actually marshalled in the NCS packet"	^self definitionString</body><body package="Opentalk-IDL-MetaObjects">printOn: aStream 	"print the receiver's printname on the stream"	[aStream nextPutAll: self definitionString , ' ' , self idlName]		on: Object errorSignal do: [:x | ^super printOn: aStream]</body></methods><methods><class-id>Opentalk.DSTtypeTemplate</class-id> <category>copying</category><body package="Opentalk-IDL-MetaObjects">copyDeclaratorOn: aType 	"make a copy of a declarator type, remembering that the declarator will point 	back to the type object which contained it as a declarator. We must avoid 	an infinite loop. Array, &amp; pointer types must overload"	| obj |	obj := super copyDeclaratorOn: aType .	subtype == aType		ifTrue: [obj subtype: nil]		ifFalse: [obj subtype: (subtype copyDeclaratorOn: aType)].	^obj</body></methods><methods><class-id>Opentalk.DSTtypeString</class-id> <category>repository</category><body package="Opentalk-IDL-MetaObjects">CORBAName	"return the name of my CORBA interface in the repository"	^#'::CompoundDefs::PrimitiveCompoundDef'</body><body package="Opentalk-IDL-MetaObjects">defKind        "Return the definition kind."        ^#dk_String</body><body package="Opentalk-IDL-MetaObjects">typeKind	"return the TCKind of the receiver"	^#tk_string</body><body package="Opentalk-IDL-MetaObjects">typeParamCount	"return the number of parameters which the receiver supports. 	Subtypes should overload as required"	^1</body><body package="Opentalk-IDL-MetaObjects">typeParameter: anInt	"return the nth parameter which the receiver supports. 	Subtypes should overload as required"	anInt = 1 ifTrue: [^size isNil ifTrue: [0] ifFalse: [size]].	self error: #Bounds</body></methods><methods><class-id>Opentalk.DSTtypeString</class-id> <category>marshalling</category><body package="Opentalk-IDL-MetaObjects">boldMarshall: aParameter on: aStream 	"Marshall the parameter onto the stream"		(size == nil or: [size = 0 or: [ aParameter size &lt;= size]])		ifFalse: [^self class marshallError: 0].	aStream nextPutString: aParameter</body><body package="Opentalk-IDL-MetaObjects">boldMarshall: aParameter on: aStream withLocalClass: aClass 	"Marshall the parameter onto the stream"	self boldMarshall: aParameter on: aStream</body><body package="Opentalk-IDL-MetaObjects">marshallMatch: aParameter 	"Return:		true			- if I can marshall the parameter		false		- if I can NOT marshall the parameter		#mappable	- if I can marshall the parameter by mapping to something else"		aParameter == nil ifTrue: [^#mappable].	^(aParameter isCharacterArray)		and: [size == nil or: [size = 0 or: [ aParameter size &lt;= size]]]</body><body package="Opentalk-IDL-MetaObjects">marshallTypeCode: aDictionary on: aStream 	"marshall the type code of the receiver"	aStream nextPutUnsignedLong: self typeCode; nextPutUnsignedLong: (size == nil ifTrue: [0] ifFalse: [size])</body><body package="Opentalk-IDL-MetaObjects">unMarshall: aStream 	"Unmarshall a result from the stream and return an object of the 	appropriate class."	^self unMarshall: aStream withLocalClass: self localClass</body><body package="Opentalk-IDL-MetaObjects">unMarshall: aStream withLocalClass: aClass 	"Unmarshall a result from the stream and return an object of the 	appropriate class."	| result |	result := aStream nextString.	aClass notNil ifTrue: [^aClass fromString: result].	^result</body><body package="Opentalk-IDL-MetaObjects">unMarshallTypeCode: aDictionary from: aStream	"marshall the type code of the receiver"	size := aStream nextUnsignedLong</body></methods><methods><class-id>Opentalk.DSTtypeString</class-id> <category>Primitive Def</category><body package="Opentalk-IDL-MetaObjects">kind	"return the receiver's primitive type"	^#pk_string</body></methods><methods><class-id>Opentalk.DSTtypeString</class-id> <category>StringDef</category><body package="Opentalk-IDL-MetaObjects">bound	"The bound attribute specifies the maximum number of characters in 	the string, and must not be zero."	^size</body><body package="Opentalk-IDL-MetaObjects">bound: newSize 	"The bound attribute specifies the maximum number of characters in 	the string, and must not be zero."	self notYetImplemented</body></methods><methods><class-id>Opentalk.DSTtypeString</class-id> <category>rendering</category><body package="Opentalk-IDL-MetaObjects">hasComponents	"return true iff I have components worthwhile to show in a browser 	window"	^declarators notNil</body></methods><methods><class-id>Opentalk.DSTtypeString</class-id> <category>initialization</category><body package="Opentalk-IDL-MetaObjects">initialize	"initialize the receiver"	super initialize.	name := 'string'</body><body package="Opentalk-IDL-MetaObjects">maxSize: anint	"initialize the receiver with the max size"	size := anint.	name := 'string'.	subtype := DSTtypeCharacter new</body></methods><methods><class-id>Opentalk.DSTtypeString</class-id> <category>printing</category><body package="Opentalk-IDL-MetaObjects">definitionString	"return my CDL type definition string"	^size isNil		ifTrue: ['string']		ifFalse: ['string&lt;' , size printString , '&gt;']</body></methods><methods><class-id>Opentalk.RepositoryId</class-id> <category>accessing</category><body package="Opentalk-IDL-MetaObjects">at: anInteger put: anObject 	"Provide an error notification that RepositoryIds cannot be	modified."	self errorNoModification</body><body package="Opentalk-IDL-MetaObjects">formatName	"Return the format name component of the repository id as a symbol."	^(self asString copyUpTo: $:) asSymbol</body><body package="Opentalk-IDL-MetaObjects">identifiers	"Return the list of identifiers. Identifiers are separated by '/' 	characters as a string."	| s start end |	s := self asString.	(start := s indexOf: $:) isZero ifFalse: [start := start + 1].	(end := s				nextIndexOf: $:				from: start				to: s size) isZero ifFalse: [end := end - 1].	^s copyFrom: start to: end</body><body package="Opentalk-IDL-MetaObjects">replaceFrom: start to: stop with: replacement startingAt: repStart 	"Provide an error notification that RepositoryIds can not be	modified."	self errorNoModification</body><body package="Opentalk-IDL-MetaObjects">value	"Allow this object to act as a ValueHolder on itself."	^self</body><body package="Opentalk-IDL-MetaObjects">version	"Return the version portion of the repository id as a string."	| s start |	s := self asString.	start := s				nextIndexOf: $:				from: 5				to: s size.	^s copyFrom: start + 1 to: s size</body></methods><methods><class-id>Opentalk.RepositoryId</class-id> <category>comparing</category><body package="Opentalk-IDL-MetaObjects">= anObject 	"Answer whether the receiver and the argument are the same object 	(have the same object pointer)."	^self == anObject</body><body package="Opentalk-IDL-MetaObjects">hash	"Answer a uniformly distributed SmallInteger computed from the 	contents of the receiver."	"We consider the low-order bits of a character the most random ones 	and assume that the low order bits of the hash are the most 	interesting, so we take special care to spread the low-order bits of 	several characters over the low-order bits of the result."	| size midLeft midRight nextToLast firstc mlc mrc nlc lastc |	size := self size.	midLeft := size bitShift: -1.	midRight := midLeft + 1.	nextToLast := size - 5.	firstc := self at: 5.	mlc := self at: midLeft.	mrc := self at: midRight.	nlc := self at: nextToLast.	lastc := self at: size - 4.	^mrc + (mrc + size bitShift: 8) + ((firstc + nlc bitAnd: 16383)			bitShift: 12) + (nlc bitShift: 2) + ((lastc bitAnd: 2047)			bitShift: 16) + (firstc + lastc bitShift: 4) + ((mlc bitAnd: 255)			bitShift: 20) + (mlc bitShift: 6)</body></methods><methods><class-id>Opentalk.RepositoryId</class-id> <category>converting</category><body package="Opentalk-IDL-MetaObjects">asByteString	"Forward this to the asString method."	^self asString</body><body package="Opentalk-IDL-MetaObjects">asString	"Answer the receiver converted to a String."	| str |	str := ByteString new: self size.	1 to: self size do: [:i | str at: i put: (self at: i) asCharacter].	^str</body><body package="Opentalk-IDL-MetaObjects">decodeAsLiteralArray	"Return an instance based on the information encoded in the receiver."	^self</body><body package="Opentalk-IDL-MetaObjects">literalArrayEncoding	"Return a literal suitable for reconstituting the receiver."	^self</body><body package="Opentalk-IDL-MetaObjects">toCORBACharCodes	^self</body></methods><methods><class-id>Opentalk.RepositoryId</class-id> <category>private</category><body package="Opentalk-IDL-MetaObjects">errorNoModification	self error:  'symbols can not be modified.'</body></methods><methods><class-id>Opentalk.RepositoryId</class-id> <category>printing</category><body package="Opentalk-IDL-MetaObjects">isLiteral	"Answer whether the receiver is a literal."	^true</body><body package="Opentalk-IDL-MetaObjects">printOn: aStream 	(1 to: self size)		do: [:index | aStream nextPut: (self at: index) asCharacter]</body></methods><methods><class-id>Opentalk.RepositoryId</class-id> <category>testing</category><body package="Opentalk-IDL-MetaObjects">isRepositoryId	^true</body><body package="Opentalk-IDL-MetaObjects">refersToLiteral: anObject	^self == anObject</body></methods><methods><class-id>Opentalk.RepositoryId</class-id> <category>fileIn/Out</category><body package="Opentalk-IDL-MetaObjects">representBinaryOn: binWriter	" RepositoryIds must be re-interned	when they are read in. " 	^MessageSend		receiver: self class		selector: #intern:		argument: self asString</body></methods><methods><class-id>Opentalk.RepositoryId</class-id> <category>copying</category><body package="Opentalk-IDL-MetaObjects">copy	"Answer the receiver, because RepositoryIds are unique."	^self</body><body package="Opentalk-IDL-MetaObjects">shallowCopy	"Answer the receiver because RepositoryIds are unique."	^self</body></methods><methods><class-id>Opentalk.RepositoryId class</class-id> <category>instance creation</category><body package="Opentalk-IDL-MetaObjects">defaultImplementor	"Answer a class that usually represents repository ids."	^RepositoryId</body><body package="Opentalk-IDL-MetaObjects">fromString: aString 	"Alternate form of intern."	^self intern: aString</body><body package="Opentalk-IDL-MetaObjects">intern: aRepositoryId 	"Answer a unique RepositoryId whose characters are those of 	aRepositoryId."	| anId repId index table subTable subIndex |	anId := aRepositoryId class == self				ifTrue: [aRepositoryId]				ifFalse: [(self new: aRepositoryId size)						replaceBytesFrom: 1						to: aRepositoryId size						with: aRepositoryId						startingAt: 1].	repId := self findInterned: anId.	repId notNil ifTrue: [^repId].	table := self table.	index := anId hash \\ table size + 1.	subTable := table at: index.	subIndex := subTable				indexOf: 0				replaceWith: anId				startingAt: 1				stoppingAt: subTable size.	subIndex = 0		ifTrue: 			[| newTable |			newTable := subTable class new: subTable size + 1.			newTable				replaceFrom: 1				to: subTable size				with: subTable.			newTable at: newTable size put: anId.			table at: index put: newTable].	^anId</body><body package="Opentalk-IDL-MetaObjects">readFrom: aStream	"Create an object based on the contents of aStream."	| object |	object := self evaluatorClass evaluate: aStream.	(object isKindOf: self) ifFalse: [self error: self name, ' expected'].	^object</body></methods><methods><class-id>Opentalk.RepositoryId class</class-id> <category>private</category><body package="Opentalk-IDL-MetaObjects">rehash	"Rebuild the hash table that holds all the unique RepositoryIds."	"We want to keep the average number of probes for a lookup	constant; independent of the number of symbols.  Therefore,	when rehashing we adjust the number of buckets such that	we meet a target bucket size (e.g. symbols/buckets).	Choosing a target bucket size is a classic time/space tradeoff;	the value used here is 10, based on empirical tests."	| numBuckets | 	"Set knows good hash moduli."	numBuckets := Set goodSizeFrom: (self tableSize / 10) rounded.	self table: ((1 to: numBuckets) collect: [:id | WeakArray with: 0]).	ObjectMemory garbageCollect.	self allInstancesDo: [:id | self intern: id].	"RepositoryId rehash"</body><body package="Opentalk-IDL-MetaObjects">table	"answer the table that holds repositoryIds"	^IDTable</body><body package="Opentalk-IDL-MetaObjects">table: newArray 	^IDTable := newArray</body></methods><methods><class-id>Opentalk.RepositoryId class</class-id> <category>class initialization</category><body package="Opentalk-IDL-MetaObjects">initialize	"Initialize the class variables."	self rehash</body><body package="Opentalk-IDL-MetaObjects">release	"release the class variables."	IDTable := nil</body></methods><methods><class-id>Opentalk.RepositoryId class</class-id> <category>accessing</category><body package="Opentalk-IDL-MetaObjects">findInterned: aRepositoryId 	"If aRepositoryId has been interned (into a RepositoryId), 	answer the RepositoryId, otherwise answer nil."	| v idSize |	idSize := aRepositoryId size.	v := self table at: aRepositoryId hash \\ self table size + 1.	1 to: v size do: 		[:i | 		| test |		((test := v at: i) class == self and: [idSize = test size				and: 					[| match ii |					match := true.					ii := 0.					[match and: [(ii := ii + 1) &lt;= idSize]]						whileTrue: [(aRepositoryId at: ii)								= (test at: ii) ifFalse: [match := false]].					match]])			ifTrue: [^test]].	^nil</body><body package="Opentalk-IDL-MetaObjects">tableSize	"Answer the number of RepositoryIds in the table."	| total |	self table isNil ifTrue: [^1023].	total := 0.	self table do: [:bucket | total := total + bucket size].	^total</body></methods><methods><class-id>Opentalk.DSTdeclaratorSimple</class-id> <category>rendering</category><body package="Opentalk-IDL-MetaObjects">hasComponents	"return true iff I have components worthwhile to show in a browser 	window"	^self baseType notNil</body><body package="Opentalk-IDL-MetaObjects">iconId	"Return the key to find my icon image in the installed icon dictionary"	^baseType iconId</body><body package="Opentalk-IDL-MetaObjects">nonTrivialDeclarators	"Get rid of declarators in the browser. Return the declarators of the 	receiver if there is more than one declarator, otherwise return an 	Array containing myself."	^Array with: (self baseType isNil			ifTrue: [self]			ifFalse: [self baseType])</body></methods><methods><class-id>Opentalk.DSTdeclaratorSimple</class-id> <category>accessing</category><body package="Opentalk-IDL-MetaObjects">baseType	"return the base type of the receiver"	^baseType</body><body package="Opentalk-IDL-MetaObjects">definedIn: aMetaObject 	"set the receiver's defining container meta object"	super definedIn: aMetaObject.	baseType notNil ifTrue: [baseType definedIn: aMetaObject]</body><body package="Opentalk-IDL-MetaObjects">equivalentType	"The equivalentType for a declarator is the base type."	^baseType</body><body package="Opentalk-IDL-MetaObjects">isDeclarator	"return true"	^true</body><body package="Opentalk-IDL-MetaObjects">resolveTo: aType 	"cause the receiver to resolve to the given type object"	baseType isNil ifTrue: [baseType := aType]</body><body package="Opentalk-IDL-MetaObjects">valueExcept: aCol 	"Answer a valid value not contained in the collection, otherwise 	nil"	^self baseType valueExcept: aCol</body></methods><methods><class-id>Opentalk.DSTdeclaratorSimple</class-id> <category>TypeCode</category><body package="Opentalk-IDL-MetaObjects">marshallTypeCode: aDictionary on: aStream	"marshall the type code of the receiver"	^baseType marshallTypeCode: aDictionary on: aStream</body><body package="Opentalk-IDL-MetaObjects">typeKind	"return the TCKind of the receiver"	^baseType typeKind</body><body package="Opentalk-IDL-MetaObjects">typeParamCount	"return the TCParamCount of the receiver"	^baseType typeParamCount</body><body package="Opentalk-IDL-MetaObjects">typeParameter: anInt 	"return the nth parameter which the receiver supports. 	Subtypes should overload as required"	^baseType typeParameter: anInt</body></methods><methods><class-id>Opentalk.DSTdeclaratorSimple</class-id> <category>testing</category><body package="Opentalk-IDL-MetaObjects">isDSTdeclaratorSimple	^true</body></methods><methods><class-id>Opentalk.DSTdeclaratorSimple</class-id> <category>printing</category><body package="Opentalk-IDL-MetaObjects">IDLTypeName	"return the printable name of the receiver's type ie the type 	to be actually marshalled in the NCS packet"	^name</body><body package="Opentalk-IDL-MetaObjects">declaratorString	"return an IDL declarator string"	self baseType isDSTtypeArray		ifTrue: [^self baseType declaratorString]		ifFalse: [^self printName]</body><body package="Opentalk-IDL-MetaObjects">printDefinitionOn: aStream indent: level style: aTextStyleName 	"print my IDL definition on the stream"	self baseType		printDefinitionOn: aStream		indent: level		style: aTextStyleName</body><body package="Opentalk-IDL-MetaObjects">printOn: aStream 	"print the receiver"	aStream nextPutAll: 'declarator ' , self idlName</body></methods><methods><class-id>Opentalk.DSTdeclaratorSimple</class-id> <category>repository</category><body package="Opentalk-IDL-MetaObjects">CORBAName	"return the name of my base type's CORBA interface in the repository"	^baseType CORBAName</body><body package="Opentalk-IDL-MetaObjects">canApplyPragma: pragma 	"Check to see if the argument pragma can be applied to the 	baseType of the receiver."	^self baseType canApplyPragma: pragma</body><body package="Opentalk-IDL-MetaObjects">corbaInterfaceIn: aRepository"return an instance of the DSTinterface which defines the behavior of the receiver when passed as a CORBA object"	^baseType corbaInterfaceIn: aRepository</body><body package="Opentalk-IDL-MetaObjects">corbaTypeIn: aRepository	"return an instance of the DSTmetaObject subclass which can marshall an 	instance of the receiver. This method must be implemented in every 	class which can be passed as an IDL type 'any' parameter"	^baseType corbaTypeIn: aRepository</body><body package="Opentalk-IDL-MetaObjects">defKind        "Return the definition kind."        ^baseType defKind</body><body package="Opentalk-IDL-MetaObjects">metaValueOf: aSymbol 	"return the meta value which is associated with the given identifier"	^self baseType metaValueOf: aSymbol</body><body package="Opentalk-IDL-MetaObjects">searchScopeFor: aSymbol 	"return the meta object which is associated with the given identifier"	^baseType searchScopeFor: aSymbol</body></methods><methods><class-id>Opentalk.DSTdeclaratorSimple</class-id> <category>marshalling</category><body package="Opentalk-IDL-MetaObjects">boldMarshall: aParameter on: aStream 	"Marshall the parameter onto the stream"	baseType boldMarshall: aParameter on: aStream</body><body package="Opentalk-IDL-MetaObjects">marshallMatch: param 	"Return:		true			- if I can marshall the parameter		false		- if I can NOT marshall the parameter		#mappable	- if I can marshall the parameter by mapping to something else"		^baseType marshallMatch: param</body><body package="Opentalk-IDL-MetaObjects">unMarshall: aStream 	"Unmarshall a result from the stream and return an object of the 	appropriate class."	^baseType unMarshall: aStream</body></methods><methods><class-id>Opentalk.DSTdeclaratorSimple</class-id> <category>initialization</category><body package="Opentalk-IDL-MetaObjects">array: anArray 	"Initialize a simple declarator with a DSTtypeArray."	self initialize.	name := anArray name.	baseType := anArray</body></methods><methods><class-id>Opentalk.DSTdeclaratorSimple</class-id> <category>DeclaratorDef</category><body package="Opentalk-IDL-MetaObjects">description	"return a declarator description"	^Dictionary new		add: #name -&gt; name;		add: #id -&gt; self id; 		add: #definedIn -&gt; self definedInString;		add: #type -&gt; self;		yourself</body><body package="Opentalk-IDL-MetaObjects">type	"return the base type of the receiver"	^self baseType</body></methods><methods><class-id>Opentalk.DSTtypeAlias</class-id> <category>accessing</category><body package="Opentalk-IDL-MetaObjects">definedIn: aMetaObject 	"Set the receiver's defining container meta object."	super definedIn: aMetaObject.	equivalentType notNil ifTrue: [equivalentType definedIn: aMetaObject]</body><body package="Opentalk-IDL-MetaObjects">equivalentType	"Return the type being aliased."	(equivalentType isMemberOf: DSTtypeNamed)		ifTrue: [^equivalentType equivalentType]		ifFalse: [^equivalentType]</body><body package="Opentalk-IDL-MetaObjects">resolveTo: aType 	"cause the receiver to resolve to the given type object"	equivalentType := aType</body><body package="Opentalk-IDL-MetaObjects">valueExcept: aCol 	"Answer a valid value not contained in the collection, otherwise 	nil"	^self equivalentType valueExcept: aCol</body></methods><methods><class-id>Opentalk.DSTtypeAlias</class-id> <category>initialization</category><body package="Opentalk-IDL-MetaObjects">initialize: decl type: aType 	"Set the name and declarator fields."	name := decl name.	declarators := nil.	equivalentType := decl baseType</body></methods><methods><class-id>Opentalk.DSTtypeAlias</class-id> <category>printing</category><body package="Opentalk-IDL-MetaObjects">IDLTypeName	"return the printable name of the receiver's type ie the type 	to be actually marshalled"	^'alias (' , equivalentType baseType name , ')'</body><body package="Opentalk-IDL-MetaObjects">asString	"return the string representation of the receiver"	^equivalentType asString</body><body package="Opentalk-IDL-MetaObjects">printDefinitionOn: aStream indent: level style: aTextStyleName 	"print a typedef onto the outstream in response to a format request."	self printHeaderOn: aStream indent: level.	prefix isNil ifFalse: [CurrentPrefix ~= prefix prefixString			ifTrue: 				[aStream tab: level; nextPutAll: '#pragma  prefix '; nextPut: $"; nextPutAll: prefix prefixString; nextPut: $"; cr.				CurrentPrefix := prefix prefixString]].	(repositoryId isNil not and: [repositoryId ~= self generateRepositoryId])		ifTrue: [aStream tab: level; nextPutAll: '#pragma  ID '; nextPutAll: self printName; space; nextPut: $"; nextPutAll: repositoryId asString; nextPut: $"; cr].	version notNil ifTrue: [aStream tab: level; nextPutAll: '#pragma  version '; nextPutAll: self printName; space; nextPutAll: version; cr].	aStream tab: level.	self localType isNil		ifFalse: 			[aStream nextPutAll: '#pragma class '; nextPutAll: self name; nextPutAll: ' '; nextPutAll: self localType; cr.			aStream tab: level; nextPutAll: 'typedef ']		ifTrue: [aStream nextPutAll: 'typedef '].	(equivalentType isDSTMetaObject and: [equivalentType isDSTtypeArray])		ifTrue: [aStream nextPut: $ ; nextPutAll: equivalentType arrayType equivalentType definitionString; nextPut: $ ; nextPutAll: equivalentType declaratorString]		ifFalse: [aStream nextPut: $ ; nextPutAll: equivalentType definitionString; nextPut: $ ; nextPutAll: name].	aStream nextPut: $;; cr</body><body package="Opentalk-IDL-MetaObjects">printOn: aStream 	"print the receiver's printname on the stream"	aStream nextPutAll: 'typedef '; nextPutAll: (equivalentType isNil			ifTrue: ['?']			ifFalse: [equivalentType definitionString]); space; nextPutAll: (name isNil			ifTrue: ['?']			ifFalse: [self name])</body></methods><methods><class-id>Opentalk.DSTtypeAlias</class-id> <category>copying</category><body package="Opentalk-IDL-MetaObjects">copyDeclaratorOn: aType	"make a copy of a declarator type, remembering that the declarator will point 	back to the type object which contained it as a declarator. We must avoid 	an infinite loop. Array, &amp; pointer types must overload"	| obj |	obj := super copyDeclaratorOn: aType .	obj resolveTo: nil.	^obj</body></methods><methods><class-id>Opentalk.DSTtypeAlias</class-id> <category>marshalling</category><body package="Opentalk-IDL-MetaObjects">boldMarshall: aParameter on: aStream 	"Marshall the parameter onto the stream"	self localType notNil		ifTrue: [(aParameter isKindOf: self localClass)				ifTrue: [self equivalentType						boldMarshall: aParameter						on: aStream						withLocalClass: self localClass]				ifFalse: [self equivalentType boldMarshall: aParameter on: aStream]]		ifFalse: [self equivalentType boldMarshall: aParameter on: aStream]</body><body package="Opentalk-IDL-MetaObjects">boldMarshall: aParameter on: aStream withLocalClass: aClass 	"Marshall the parameter onto the stream"	self equivalentType boldMarshall: aParameter on: aStream withLocalClass: aClass</body><body package="Opentalk-IDL-MetaObjects">marshallMatch: aParameter 	"Return:		true			- if I can marshall the parameter		false		- if I can NOT marshall the parameter		#mappable	- if I can marshall the parameter by mapping to something else"		(self localType notNil and: [aParameter isKindOf: self localClass]) ifTrue: [^true].	^equivalentType marshallMatch: aParameter</body><body package="Opentalk-IDL-MetaObjects">marshallTypeCode: aDictionary on: aStream 	"marshall the type code of the receiver"	(self tryMarshallIndirectTypeCode: aDictionary on: aStream)		ifTrue: [^self].	aStream nextPutUnsignedLong: self typeCode.	aStream nextPutEncapsulatedInOctets: [ :stream |		stream			nextPutASCIIString: self repositoryId asString;			nextPutASCIIString: self printName;			nextPutLocalType: self localType.		equivalentType marshallTypeCode: aDictionary on: stream ]</body><body package="Opentalk-IDL-MetaObjects">unMarshall: aStream 	"Unmarshall a result from the stream and return an object of the 	appropriate class."	^self localType notNil		ifTrue: [self equivalentType unMarshall: aStream withLocalClass: self localClass]		ifFalse: [self equivalentType unMarshall: aStream]</body><body package="Opentalk-IDL-MetaObjects">unMarshall: aStream withLocalClass: aClass 	"Unmarshall a result from the stream and return an object of the 	appropriate class. "	^self equivalentType unMarshall: aStream withLocalClass: aClass</body><body package="Opentalk-IDL-MetaObjects">unMarshallTypeCode: aDictionary from: aStream 	"unMarshall the type code of the receiver"	| mo byteOrder locType |	aDictionary add: aStream position -&gt; self.	aStream nextUnsignedLong.	byteOrder := aStream byteOrder.	aStream byteOrder: aStream nextBoolean.	repositoryId := aStream nextASCIIString.	repositoryId isEmpty ifFalse: [repositoryId := RepositoryId fromString: repositoryId].	name := aStream nextASCIIString.	locType := aStream nextLocalType.	equivalentType := self class unMarshallTypeCode: aDictionary from: aStream.	locType isNil		ifTrue: [repositoryId isEmpty				ifFalse: 					[mo := DSTORBObject lookupMetaId: repositoryId.					mo isNil ifFalse: [mo localType isNil ifFalse: [self localType: mo localType]]]]		ifFalse: [self localType: locType].	aStream byteOrder: byteOrder</body></methods><methods><class-id>Opentalk.DSTtypeAlias</class-id> <category>rendering</category><body package="Opentalk-IDL-MetaObjects">childName	"return the name to be used for the receiver in a browser window"	^declarators isNil		ifTrue: [self printName]		ifFalse: [name]</body><body package="Opentalk-IDL-MetaObjects">iconId	"Return the key to find my icon image in the installed icon dictionary"	^self equivalentType iconId</body></methods><methods><class-id>Opentalk.DSTtypeAlias</class-id> <category>AliasDef</category><body package="Opentalk-IDL-MetaObjects">description	"return an alias description"	| d |	d := (Dictionary new) 			add: #name -&gt; name; 			add: #id -&gt; self id; 			add: #definedIn -&gt; self definedInString; 			add: #version -&gt; self version; 			add: #type -&gt; self; 			yourself.	d overrideCORBAType: (DSTORBObject lookupMetaId: #'::CORBA::TypeDescription').	^d</body><body package="Opentalk-IDL-MetaObjects">originalTypeDef	"The originalTypeDef attribute identifies the type being aliased."	^self equivalentType</body><body package="Opentalk-IDL-MetaObjects">originalTypeDef: aType 	"Setting the originalTypeDef attribute also updates the type 	attribute."	self notYetImplemented</body></methods><methods><class-id>Opentalk.DSTtypeAlias</class-id> <category>repository</category><body package="Opentalk-IDL-MetaObjects">CORBAName	"return the name of my CORBA interface in the repository"	^#'::CORBA::AliasDef'</body><body package="Opentalk-IDL-MetaObjects">canApplyPragma: pragma 	"Check to see if the argument pragma can be applied to the receiver."	^#(#ID #CLASS #VERSION) includes: pragma</body><body package="Opentalk-IDL-MetaObjects">defKind        "Return the definition kind."        ^#dk_Alias</body><body package="Opentalk-IDL-MetaObjects">metaValueOf: aSymbol 	"return the meta value which is associated with the given identifier"	^self equivalentType metaValueOf: aSymbol</body><body package="Opentalk-IDL-MetaObjects">resolveLocalTypesIn: aType 	"Called by typeAny to get any local type symbols which relate to the 	receiver in its scope."	self equivalentType resolveLocalTypesIn: aType</body><body package="Opentalk-IDL-MetaObjects">typeKind	"return the TCKind of the receiver"	^#tk_alias</body></methods><methods><class-id>Opentalk.DSTtypeLong</class-id> <category>marshalling</category><body package="Opentalk-IDL-MetaObjects">boldMarshall: aParameter on: aStream 	"Marshall the parameter onto the stream"	"canMarshall not = raises exception in nextPutLong:"	aStream nextPutLong: aParameter</body><body package="Opentalk-IDL-MetaObjects">marshallMatch: aParameter 	"Return:		true			- if I can marshall the parameter		false		- if I can NOT marshall the parameter		#mappable	- if I can marshall the parameter by mapping to something else"		^aParameter isInteger</body><body package="Opentalk-IDL-MetaObjects">unMarshall: aStream 	"Unmarshall a result from the stream and return an object of the 	appropriate class."	^aStream nextLong</body></methods><methods><class-id>Opentalk.DSTtypeLong</class-id> <category>initialization</category><body package="Opentalk-IDL-MetaObjects">initialize	"initialize the receiver"	super initialize.	name := 'long'</body></methods><methods><class-id>Opentalk.DSTtypeLong</class-id> <category>accessing</category><body package="Opentalk-IDL-MetaObjects">valueExcept: aCol 	"Answer a valid boolean value not contained in the collection, otherwise 	nil"	| max maxSize probe |	name = 'short'		ifTrue: [max := 32767]		ifFalse: [name = 'long'				ifTrue: [max := 2147483647]				ifFalse: [name = 'unsigned short'						ifTrue: [maxSize := 65536]						ifFalse: [maxSize := 4294967296]]].	maxSize isNil		ifTrue: [maxSize := max + 1 * 2]		ifFalse: [max := maxSize - 1].	aCol size &lt; maxSize		ifTrue: 			[probe := max.			[aCol includes: probe]				whileTrue: [probe := probe - 1].			^probe]		ifFalse: [^nil]</body></methods><methods><class-id>Opentalk.DSTtypeLong</class-id> <category>repository</category><body package="Opentalk-IDL-MetaObjects">typeKind	"return the TCKind of the receiver"	^#tk_long</body></methods><methods><class-id>Opentalk.DSTtypeLong</class-id> <category>Primitive Def</category><body package="Opentalk-IDL-MetaObjects">kind	"return the receiver's primitive type"	^#pk_long</body></methods><methods><class-id>Opentalk.DSTtypeLongLong</class-id> <category>marshalling</category><body package="Opentalk-IDL-MetaObjects">boldMarshall: aParameter on: aStream 	"Marshall the parameter onto the stream"	"canMarshall not = raises exception in nextPutLongLong:"	aStream nextPutLongLong: aParameter</body><body package="Opentalk-IDL-MetaObjects">unMarshall: aStream 	"Unmarshall a result from the stream and return an object of the 	appropriate class."	^aStream nextLongLong</body></methods><methods><class-id>Opentalk.DSTtypeLongLong</class-id> <category>Primitive Def</category><body package="Opentalk-IDL-MetaObjects">kind	"return the receiver's primitive type"	^#pk_longlong</body></methods><methods><class-id>Opentalk.DSTtypeLongLong</class-id> <category>repository</category><body package="Opentalk-IDL-MetaObjects">typeKind	"return the TCKind of the receiver"	^#tk_longlong</body></methods><methods><class-id>Opentalk.DSTtypeLongLong</class-id> <category>initialization</category><body package="Opentalk-IDL-MetaObjects">initialize	"initialize the receiver"	super initialize.	name := 'long long'</body></methods><methods><class-id>Opentalk.DSTattributeDescription</class-id> <category>accessing</category><body package="Opentalk-IDL-MetaObjects">definedIn	^definedIn</body><body package="Opentalk-IDL-MetaObjects">definedIn: aValue	definedIn := aValue</body><body package="Opentalk-IDL-MetaObjects">id	^id</body><body package="Opentalk-IDL-MetaObjects">id: aValue	id := aValue</body><body package="Opentalk-IDL-MetaObjects">mode	^mode</body><body package="Opentalk-IDL-MetaObjects">mode: aValue	mode := aValue</body><body package="Opentalk-IDL-MetaObjects">name	^name</body><body package="Opentalk-IDL-MetaObjects">name: aValue	name := aValue</body><body package="Opentalk-IDL-MetaObjects">type	^type</body><body package="Opentalk-IDL-MetaObjects">type: aValue	type := aValue</body><body package="Opentalk-IDL-MetaObjects">version	^version</body><body package="Opentalk-IDL-MetaObjects">version: aValue	version := aValue</body></methods><methods><class-id>Opentalk.DSTattributeDescription</class-id> <category>repository</category><body package="Opentalk-IDL-MetaObjects">corbaTypeIn: aRepository	^aRepository lookupMetaId: #'::CORBA::AttributeDescription'</body></methods><methods><class-id>Opentalk.DSTtypeOctet</class-id> <category>repository</category><body package="Opentalk-IDL-MetaObjects">typeKind	"return the TCKind of the receiver"	^#tk_octet</body></methods><methods><class-id>Opentalk.DSTtypeOctet</class-id> <category>Primitive Def</category><body package="Opentalk-IDL-MetaObjects">kind	"return the receiver's primitive type"	^#pk_octet</body></methods><methods><class-id>Opentalk.DSTtypeOctet</class-id> <category>marshalling</category><body package="Opentalk-IDL-MetaObjects">boldMarshall: aParameter on: aStream 	"Marshall the parameter onto the stream"	"canMarshall = no MNU on between:and: and 0&lt;=aParameter&lt;=255"	(aParameter between: 0 and: 255)		ifFalse: [self class marshallError: 0].	aStream nextPutByte: aParameter</body><body package="Opentalk-IDL-MetaObjects">marshallMatch: aParameter 	"Return:		true			- if I can marshall the parameter		false		- if I can NOT marshall the parameter		#mappable	- if I can marshall the parameter by mapping to something else"		^(aParameter isInteger)		and: [aParameter between: 0 and: 255]</body><body package="Opentalk-IDL-MetaObjects">unMarshall: aStream 	"Unmarshall a result from the stream and return an object of the 	appropriate class."	^aStream nextByte</body></methods><methods><class-id>Opentalk.DSTtypeOctet</class-id> <category>initialization</category><body package="Opentalk-IDL-MetaObjects">initialize	"initialize the receiver"	super initialize.	name := 'octet'</body></methods><methods><class-id>Opentalk.DSTparameter</class-id> <category>printing</category><body package="Opentalk-IDL-MetaObjects">IDLTypeName	"return the type name of the receiver"	^type IDLTypeName</body><body package="Opentalk-IDL-MetaObjects">definitionString	"return the IDL definition of the receiver"	| aStream |	aStream := (String new: 80) writeStream.	self isResult ifFalse: [aStream nextPutAll: self direction; nextPut: $ ].	aStream nextPutAll: self IDLTypeName; nextPut: $ ; nextPutAll: self printName.	^aStream contents</body><body package="Opentalk-IDL-MetaObjects">printDefinitionOn: aStream indent: level style: aTextStyleName 	"Print the parameter on a stream. Note: This is called in text 	view mode during repository browsing"	self printCommentOn: aStream indent: level.	aStream nextPutAll: self definitionString</body><body package="Opentalk-IDL-MetaObjects">printName	"return the name of the receiver"	^name printName</body><body package="Opentalk-IDL-MetaObjects">printOn: aStream	"print the receiver's printname on the stream"	aStream nextPutAll: direction , '  ' , type idlName , '  ' , name printName</body></methods><methods><class-id>Opentalk.DSTparameter</class-id> <category>marshalling</category><body package="Opentalk-IDL-MetaObjects">boldMarshall: aParam on: aStream	"marshall an instance of the receiver's type on the stream"   	type boldMarshall: aParam on: aStream</body><body package="Opentalk-IDL-MetaObjects">unMarshall: aStream	"unmarshall an instance of the receiver's type from the stream"	^type unMarshall: aStream</body></methods><methods><class-id>Opentalk.DSTparameter</class-id> <category>rendering</category><body package="Opentalk-IDL-MetaObjects">iconId	"Return the key to find my icon image in the installed icon dictionary"	^(#DST , (self isResult			ifTrue: ['RESULT']			ifFalse: [direction]) , 'parameter') asSymbol</body><body package="Opentalk-IDL-MetaObjects">isResult	"Return true if this is a operation result"	^self printName == #'OP RESULT'</body></methods><methods><class-id>Opentalk.DSTparameter</class-id> <category>attributes</category><body package="Opentalk-IDL-MetaObjects">direction	"returns the parameter direction, as a lowercase string"	^direction asString asLowercase</body><body package="Opentalk-IDL-MetaObjects">notIN	"return if the receiver is not an IN mode parameter"	^direction ~= #IN</body><body package="Opentalk-IDL-MetaObjects">notOUT	"return if the receiver is not an OUT mode parameter"	^direction ~= #OUT</body></methods><methods><class-id>Opentalk.DSTparameter</class-id> <category>repository</category><body package="Opentalk-IDL-MetaObjects">CORBAName	"return the name of my CORBA interface in the repository"	^#'::CORBA::Contained'</body><body package="Opentalk-IDL-MetaObjects">allMetaObjectsInto: aSet 	"add all of the contained metaobjects to the set"	super allMetaObjectsInto: aSet."	name allMetaObjectsInto: aSet."	type allMetaObjectsInto: aSet</body><body package="Opentalk-IDL-MetaObjects">typeKind        "Return the type code kind of a parameter."        ^type typeKind</body></methods><methods><class-id>Opentalk.DSTparameter</class-id> <category>Parameter Def</category><body package="Opentalk-IDL-MetaObjects">description	"return an operation description"	^(DSTparameterDescription new) 		name: self printName; 		type: type equivalentType; 		typeDef: type equivalentType; 		mode: direction; 		yourself</body><body package="Opentalk-IDL-MetaObjects">mode	"return the direction of the receiver"	^direction</body><body package="Opentalk-IDL-MetaObjects">name	"return the receiver's name"	^name printName</body><body package="Opentalk-IDL-MetaObjects">type	"return the type of the receiver"	^type</body></methods><methods><class-id>Opentalk.DSTparameter</class-id> <category>accessing</category><body package="Opentalk-IDL-MetaObjects">definedIn: aMetaObject 	"set the defining metaObject of the receiver"	super definedIn: aMetaObject.	name definedIn: aMetaObject.	type definedIn: aMetaObject</body><body package="Opentalk-IDL-MetaObjects">isVoid	"return if the type of the parameter is void"	^type isMemberOf: DSTtypeVoid</body></methods><methods><class-id>Opentalk.DSTparameter</class-id> <category>initialization</category><body package="Opentalk-IDL-MetaObjects">name: aName type: aType direction: aDirection 	"called by the IDL compiler: initialize these values of the parameter"	direction := aDirection.	type  := aType.	aName isSymbol		ifTrue: [name := (DSTtypeNamed new) initialize: aName; definedIn: self; yourself]		ifFalse: [name := aName]</body></methods><methods><class-id>Opentalk.DSTcachedParameter</class-id> <category>accessing</category><body package="Opentalk-IDL-MetaObjects">definedIn: aMetaObject 	"set the defining metaObject of the receiver"	definedIn := aMetaObject.	type definedIn: aMetaObject</body><body package="Opentalk-IDL-MetaObjects">direction	^direction</body><body package="Opentalk-IDL-MetaObjects">idlName		^[super idlName] on: Object errorSignal do: [:ex | name]</body><body package="Opentalk-IDL-MetaObjects">name 	^name</body><body package="Opentalk-IDL-MetaObjects">typeCodeInfo	^typeCodeInfo ifNil: [self class intfReposError: 0]</body></methods><methods><class-id>Opentalk.DSTcachedParameter</class-id> <category>printing</category><body package="Opentalk-IDL-MetaObjects">printName	^name</body><body package="Opentalk-IDL-MetaObjects">printOn: aStream	"print the receiver's printname on the stream"	aStream nextPutAll: direction  , '  ' , name</body></methods><methods><class-id>Opentalk.DSTcachedParameter</class-id> <category>private</category><body package="Opentalk-IDL-MetaObjects">name: aName direction: aSymbol typeCodeInfo: aByteArray  	name := aName.	direction := aSymbol.	typeCodeInfo := aByteArray.	type := DSTMetaObject unMarshallTypeCode: Dictionary new from: (TCCDRStream with: aByteArray) reset</body></methods><methods><class-id>Opentalk.DSTcachedParameter</class-id> <category>repository</category><body package="Opentalk-IDL-MetaObjects">corbaTypeIn: aRepository	"return an instance of the DSTmetaObject subclass which can marshall an 	instance of the receiver."	^aRepository lookupMetaId: #'::SharedIR::CachedParameter'</body></methods><methods><class-id>Opentalk.DSTcachedParameter class</class-id> <category>instance creation</category><body package="Opentalk-IDL-MetaObjects">name: aName direction: aSymbol typeCodeInfo: aByteArray	^(self new) name: aName direction: aSymbol typeCodeInfo: aByteArray; yourself</body></methods><methods><class-id>Opentalk.DSTtypeCharacter</class-id> <category>Primitive Def</category><body package="Opentalk-IDL-MetaObjects">kind	"return the receiver's primitive type"	^#pk_char</body></methods><methods><class-id>Opentalk.DSTtypeCharacter</class-id> <category>marshalling</category><body package="Opentalk-IDL-MetaObjects">boldMarshall: aParameter on: aStream 	"Marshall the parameter onto the stream"	"canMarshall not = nextPutCharacter: raises exception"	aStream nextPutCharacter: aParameter</body><body package="Opentalk-IDL-MetaObjects">marshallMatch: aParameter 	"Return:		true			- if I can marshall the parameter		false		- if I can NOT marshall the parameter		#mappable	- if I can marshall the parameter by mapping to something else"		^aParameter isKindOf: Character</body><body package="Opentalk-IDL-MetaObjects">unMarshall: aStream 	"Unmarshall a result from the stream and return an object of the 	appropriate class."	^aStream nextCharacter</body></methods><methods><class-id>Opentalk.DSTtypeCharacter</class-id> <category>initialization</category><body package="Opentalk-IDL-MetaObjects">initialize	"initialize the receiver"	super initialize.	name := 'char'</body></methods><methods><class-id>Opentalk.DSTtypeCharacter</class-id> <category>repository</category><body package="Opentalk-IDL-MetaObjects">typeKind	"return the TCKind of the receiver"	^#tk_char</body></methods><methods><class-id>Opentalk.DSTtypeCharacter</class-id> <category>accessing</category><body package="Opentalk-IDL-MetaObjects">valueExcept: aCol 	"Answer a valid boolean value not contained in the collection, otherwise 	nil"	aCol size &lt; 256		ifTrue: [0 to: 255 do: [:i | (aCol includes: i asCharacter)					ifFalse: [^i asCharacter]]]		ifFalse: [^nil]</body></methods><methods><class-id>Opentalk.DSToperationInfo</class-id> <category>accessing</category><body package="Opentalk-IDL-MetaObjects">interface	"return the interface of the receiver"	^interface</body><body package="Opentalk-IDL-MetaObjects">interfaceId	"return the interfaceId of the defining interface"	^interface repositoryId</body><body package="Opentalk-IDL-MetaObjects">opIndex	"return the opIndex of the receiver"	^opIndex</body><body package="Opentalk-IDL-MetaObjects">operation	"return the operation of the receiver"	^operation</body><body package="Opentalk-IDL-MetaObjects">selector	"return the selector of the receiver"	^selector</body><body package="Opentalk-IDL-MetaObjects">traceString	"return a string for printing the receiver"	^operation printName , ' (' , selector , ')'</body></methods><methods><class-id>Opentalk.DSToperationInfo</class-id> <category>creation</category><body package="Opentalk-IDL-MetaObjects">interface: anIf operation: anOp selector: aSymbol opIndex: anInt 	"set all instance variables in the receiver"	interface := anIf.	operation := anOp.	selector := aSymbol.	opIndex := anInt.	anInt &lt; 0 ifTrue: [self error: 'Invalid operation index']</body></methods><methods><class-id>Opentalk.DSTconstant</class-id> <category>printing</category><body package="Opentalk-IDL-MetaObjects">printDefinitionOn: aStream indent: level style: aTextStyleName 	"print the IDL definition of the receiver on the stream"	self printHeaderOn: aStream indent: level.	prefix isNil ifFalse: [CurrentPrefix ~= prefix prefixString			ifTrue: 				[aStream tab: level; nextPutAll: '#pragma  prefix '; nextPut: $"; nextPutAll: prefix prefixString; nextPut: $"; cr.				CurrentPrefix := prefix prefixString]].	(repositoryId isNil not and: [repositoryId ~= self generateRepositoryId])		ifTrue: [aStream tab: level; nextPutAll: '#pragma  ID '; nextPutAll: self printName; space; nextPut: $"; nextPutAll: repositoryId asString; nextPut: $"; cr].	version notNil ifTrue: [aStream tab: level; nextPutAll: '#pragma  version '; nextPutAll: self printName; space; nextPutAll: version; cr].	aStream tab: level; nextPutAll: 'const '; nextPutAll: typeSpec definitionString; nextPut: $ ; nextPutAll: name; nextPut: $ ; nextPutAll: '= '.	(valueExpr isString)		ifTrue: [aStream nextPut: $"; nextPutAll: valueExpr; nextPut: $"]		ifFalse: [aStream nextPutAll: valueExpr asIDLString].	aStream nextPut: $;; cr</body><body package="Opentalk-IDL-MetaObjects">printOn: aStream	"print the receiver's printname on the stream"	aStream nextPutAll: 'const ' , self idlName</body></methods><methods><class-id>Opentalk.DSTconstant</class-id> <category>ConstantDef</category><body package="Opentalk-IDL-MetaObjects">description	"return a constant description"	^(Dictionary new)		add: #name -&gt; name;		add: #id -&gt; self id;		add: #definedIn -&gt; self definedInString;		add: #version -&gt; self version;		add: #type -&gt; self;		add: #value -&gt; self value;		yourself</body><body package="Opentalk-IDL-MetaObjects">type	"return the typeSpec of the receiver"	^typeSpec</body><body package="Opentalk-IDL-MetaObjects">typeDef	"The typeDef attribute identifies the definition of the type of the 	constant."	^typeSpec</body><body package="Opentalk-IDL-MetaObjects">typeDef: newIDLType 	"The typeDef attribute identifies the definition of the type of the 	constant."	self notYetImplemented</body><body package="Opentalk-IDL-MetaObjects">value	"The value attribute contains the value of the constant, not the computation of the value."	^value ifNil: [value := valueExpr value]</body><body package="Opentalk-IDL-MetaObjects">value: newValue 	"The value attribute contains the value of the constant, not the 	computation of the value."	self notYetImplemented</body></methods><methods><class-id>Opentalk.DSTconstant</class-id> <category>repository</category><body package="Opentalk-IDL-MetaObjects">CORBAName	"return the name of my CORBA interface in the repository"	^#'::CORBA::ConstantDef'</body><body package="Opentalk-IDL-MetaObjects">allMetaObjectsInto: aSet 	"add all of the referenced metaobjects to the set"	super allMetaObjectsInto: aSet.	typeSpec allMetaObjectsInto: aSet.	(valueExpr respondsTo: #allMetaObjectsInto:) ifTrue: [valueExpr allMetaObjectsInto: aSet]</body><body package="Opentalk-IDL-MetaObjects">canApplyPragma: pragma 	"Check to see if the argument pragma can be applied to the receiver."	^#(#ID #VERSION) includes: pragma</body><body package="Opentalk-IDL-MetaObjects">defKind        "Return the definition kind."        ^#dk_Constant</body><body package="Opentalk-IDL-MetaObjects">resolveTypeReference	"implemented by DSTtypeNamed &amp;  DSTconstant. Others 	should noop"	self value</body></methods><methods><class-id>Opentalk.DSTconstant</class-id> <category>initialization</category><body package="Opentalk-IDL-MetaObjects">t: aType  i: ident  v: aValue	"initialize the receiver"	typeSpec := aType.	name := ident.	valueExpr := aValue.</body></methods><methods><class-id>Opentalk.DSTconstant</class-id> <category>accessing</category><body package="Opentalk-IDL-MetaObjects">definedIn: aMetaObject 	"set the receiver's defining container meta object"	super definedIn: aMetaObject.	typeSpec definedIn: aMetaObject.	(valueExpr respondsTo: #definedIn:) ifTrue: [valueExpr definedIn: aMetaObject]</body></methods><methods><class-id>Opentalk.DSTtypeEnumeration</class-id> <category>EnumDef</category><body package="Opentalk-IDL-MetaObjects">description	"return an enumeration description"	|d| 	d := (Dictionary new) 			add: #name -&gt; name; 			add: #id -&gt; self id; 			add: #definedIn -&gt; self definedInString; 			add: #version -&gt; self version; 			add: #type -&gt; self;			yourself.	d overrideCORBAType: (DSTORBObject lookupMetaId: #'::CORBA::TypeDescription').	^d</body><body package="Opentalk-IDL-MetaObjects">members	"The members attribute contains a distinct name for each possible 	value of the enumeration."	^values</body><body package="Opentalk-IDL-MetaObjects">members: newMembers 	"The members attribute contains a distinct name for each possible 	value of the enumeration."	self notYetImplemented</body></methods><methods><class-id>Opentalk.DSTtypeEnumeration</class-id> <category>printing</category><body package="Opentalk-IDL-MetaObjects">definitionString	"return my unformatted definition string"	| aStream |	aStream := (String new: 80) writeStream.	aStream nextPutAll: 'enum '; nextPutAll: name; nextPutAll: ' {'.	(1 to: values size - 1)		do: [:i | aStream nextPutAll: (values at: i); nextPutAll: ', '].	values isEmpty ifFalse: [aStream nextPutAll: values last].	aStream nextPut: $}.	^aStream contents</body><body package="Opentalk-IDL-MetaObjects">printDefinitionOn: aStream indent: level style: aTextStyleName 	"Print my IDL definition on the stream."	"Since the default Parser class is used to parse the selector of IDL 	units, it 	is important that the first token of an IDL 'method' is parsed 	correctly by 	Parser. Specifically, it must be avoided that the pound sign is the 	first 	character in the method, since it would cause a parsing problem. 	Therefore we show pragmas AFTER the comment lines and we also 	make 	sure that there is always at least one comment line. Also note, that 	senders of Parser&gt;&gt;parseSelector: (such as 	Text&gt;&gt;makeSelectorBoldIn:) 	assume that the selector starts at position 1 of the method source."	self printHeaderOn: aStream indent: level.	prefix isNil ifFalse: [CurrentPrefix ~= prefix prefixString			ifTrue: 				[aStream tab: level; nextPutAll: '#pragma  prefix '; nextPut: $"; nextPutAll: prefix prefixString; nextPut: $"; cr.				CurrentPrefix := prefix prefixString]].	self hasPragma ifTrue: [aStream tab: level; nextPutAll: '#pragma class '; nextPutAll: self printName; nextPutAll: ' '; nextPutAll: self localType; cr].	aStream tab: level.	declarators isNil		ifTrue: 			[self				printFormattedOn: aStream				indent: level				style: aTextStyleName.			aStream nextPutAll: ';'; cr]		ifFalse: 			[aStream nextPutAll: 'typedef '.			self				printFormattedOn: aStream				indent: level + (self tabFor: 'typedef ' style: aTextStyleName)				style: aTextStyleName.			aStream nextPut: $ ; nextPutAll: self declaratorString; nextPut: $;; cr]</body><body package="Opentalk-IDL-MetaObjects">printFormattedOn: aStream indent: level style: aTextStyleName 	"print the detailed formatted definition of the receiver on 	aStream. To be overloaded by subclasses if formatting is 	actually required"	| unformatted |	unformatted := self definitionString.	(self		stringNeedsFormatting: unformatted		indent: level		style: aTextStyleName)		ifTrue: 			[aStream nextPutAll: 'enum '; nextPutAll: name; nextPutAll: ' {'; cr.			(1 to: values size - 1)				do: [:i | aStream tab: level + 1; nextPutAll: (values at: i); nextPut: $,; cr].			values isEmpty ifFalse: [aStream tab: level + 1; nextPutAll: values last; cr].			aStream tab: level; nextPut: $}]		ifFalse: [aStream nextPutAll: unformatted]</body><body package="Opentalk-IDL-MetaObjects">printOn: aStream 	"print the receiver's printname on the stream"	aStream nextPutAll: 'enum ' , self idlName</body></methods><methods><class-id>Opentalk.DSTtypeEnumeration</class-id> <category>accessing</category><body package="Opentalk-IDL-MetaObjects">valueExcept: aCol 	"Answer a valid boolean value not contained in the collection, otherwise 	nil"	| candidates |	candidates := self values asSet - aCol asSet.	^candidates isEmpty		ifTrue: [nil]		ifFalse: [candidates anElement]</body><body package="Opentalk-IDL-MetaObjects">values	^values</body></methods><methods><class-id>Opentalk.DSTtypeEnumeration</class-id> <category>repository</category><body package="Opentalk-IDL-MetaObjects">CORBAName	"return the name of my CORBA interface in the repository"	^#'::CORBA::EnumDef'</body><body package="Opentalk-IDL-MetaObjects">allMetaObjectsInto: aSet 	"add all of the contained metaobjects to the set"	super allMetaObjectsInto: aSet.	values notNil ifTrue: [values do: [:val | (val isDSTMetaObject)				ifTrue: [aSet add: val]]]</body><body package="Opentalk-IDL-MetaObjects">canApplyPragma: pragma 	"Check to see if the argument pragma can be applied to the receiver."	^#(#CLASS) includes: pragma</body><body package="Opentalk-IDL-MetaObjects">defKind        "Return the definition kind."        ^#dk_Enum</body><body package="Opentalk-IDL-MetaObjects">metaObjectOf: aSymbol 	"return the meta object which is associated with the given identifier"	^(values includes: aSymbol)		ifTrue: [self]		ifFalse: [self definingMetaObject metaObjectOf: aSymbol]</body><body package="Opentalk-IDL-MetaObjects">metaValueOf: aSymbol 	"return the meta value which is associated with the given identifier"	^(values includes: aSymbol)		ifTrue: [aSymbol]		ifFalse: [self class intfReposError: 0]</body><body package="Opentalk-IDL-MetaObjects">searchScopeFor: aSymbol 	"return the meta object which is associated with the given identifier"	(values includes: aSymbol)		ifTrue: [^Enumerator				name: aSymbol				value: (values indexOf: aSymbol)						- 1				type: self]		ifFalse: [^nil]</body><body package="Opentalk-IDL-MetaObjects">typeKind	"return the TCKind of the receiver"	^#tk_enum</body><body package="Opentalk-IDL-MetaObjects">typeParamCount	"return the number of parameters which the receiver supports. 	Subtypes should overload as required"	^1 + values size</body><body package="Opentalk-IDL-MetaObjects">typeParameter: anInt	"return the nth parameter which the receiver supports. 	Subtypes should overload as required"	anInt = 1 ifTrue: [^self printName].	(anInt between: 2 and: self typeParamCount )ifTrue: [^(values at: anInt - 1) asString].	self error: #Bounds</body></methods><methods><class-id>Opentalk.DSTtypeEnumeration</class-id> <category>initialization</category><body package="Opentalk-IDL-MetaObjects">id: aSymbol values: anArray 	"Initialize instance variables for an enumerated type"	name := aSymbol asSymbol.	values := anArray</body></methods><methods><class-id>Opentalk.DSTtypeEnumeration</class-id> <category>marshalling</category><body package="Opentalk-IDL-MetaObjects">boldMarshall: aParameter on: aStream 	"Marshall the parameter onto the stream"	"canMarshall not = MNU on asSymbol or (idx &lt;= 0)"	aParameter class == Enumerator		ifTrue: [aStream nextPutLong: aParameter value]		ifFalse: 			[| idx |			idx := values indexOf: aParameter asSymbol.			idx &gt; 0 ifFalse: [self class marshallError: 0].			aStream nextPutLong: idx - 1]</body><body package="Opentalk-IDL-MetaObjects">marshallMatch: aParameter 	"Return:		true			- if I can marshall the parameter		false		- if I can NOT marshall the parameter		#mappable	- if I can marshall the parameter by mapping to something else"		^aParameter class == Enumerator or: [(aParameter isKindOf: CharacterArray)			and: [(values indexOf: aParameter asSymbol)					&gt; 0]]</body><body package="Opentalk-IDL-MetaObjects">marshallTypeCode: aDictionary on: aStream 	"marshall the type code of the receiver"	(self tryMarshallIndirectTypeCode: aDictionary on: aStream)		ifTrue: [^self].	aStream nextPutUnsignedLong: self typeCode.	aStream nextPutEncapsulatedInOctets: [ :stream |		stream			nextPutASCIIString: self repositoryId asString;			nextPutASCIIString: self printName;			nextPutLocalType: self localType;			nextPutUnsignedLong: values size.		values do: [:v | stream nextPutASCIIString: v] ]</body><body package="Opentalk-IDL-MetaObjects">unMarshall: aStream 	"Unmarshall a result from the stream and return an object of the 	appropriate class"	| int |	int := aStream nextUnsignedLong.	^Enumerator		name: (values at: int + 1)		value: int		type: self</body><body package="Opentalk-IDL-MetaObjects">unMarshallTypeCode: aDictionary from: aStream 	"unmarshall the type code of the receiver"	| mo sz byteOrder locType str |	aDictionary add: aStream position -&gt; self.	aStream nextUnsignedLong.	byteOrder := aStream byteOrder.	aStream byteOrder: aStream nextBoolean.	repositoryId := aStream nextASCIIString.	repositoryId isEmpty ifFalse: [		repositoryId := RepositoryId fromString: repositoryId.		mo := DSTORBObject lookupMetaId: repositoryId ].	name := aStream nextASCIIString.	(name isEmpty and: [mo notNil]) ifTrue: [name := mo name].	locType := aStream nextLocalType.	sz := aStream nextUnsignedLong.	values :=		(1 to: sz) collect: [:v | 			str := aStream nextASCIIString asSymbol.			(str isEmpty and: [mo notNil]) ifTrue: [str := mo values at: v].			str].	locType isNil		ifTrue: [mo isNil ifFalse: [mo localType isNil ifFalse: [self localType: mo localType]]]		ifFalse: [self localType: locType].	aStream byteOrder: byteOrder</body></methods><methods><class-id>Opentalk.DSTtypeUnsignedLongLong</class-id> <category>marshalling</category><body package="Opentalk-IDL-MetaObjects">boldMarshall: aParameter on: aStream 	"Marshall the parameter onto the stream"	"canMarshall not = raises exception in nextPutUnsignedLongLong:"	aStream nextPutUnsignedLongLong: aParameter</body><body package="Opentalk-IDL-MetaObjects">unMarshall: aStream 	"Unmarshall a result from the stream and return an object of the 	appropriate class."	^aStream nextUnsignedLongLong</body></methods><methods><class-id>Opentalk.DSTtypeUnsignedLongLong</class-id> <category>Primitive Def</category><body package="Opentalk-IDL-MetaObjects">kind	"return the receiver's primitive type"	^#pk_ulonglong</body></methods><methods><class-id>Opentalk.DSTtypeUnsignedLongLong</class-id> <category>repository</category><body package="Opentalk-IDL-MetaObjects">typeKind	"return the TCKind of the receiver"	^#tk_ulonglong</body></methods><methods><class-id>Opentalk.DSTtypeUnsignedLongLong</class-id> <category>initialization</category><body package="Opentalk-IDL-MetaObjects">initialize	"initialize the receiver"	super initialize.	name := 'unsigned long long'</body></methods><methods><class-id>Opentalk.ORBConstantsDictionary</class-id> <category>private</category><body package="Opentalk-IDL-MetaObjects">changeCapacityTo: newSize	"Change the number of elements of the collection.	Preserve the values of exceptions and exceptionIndexs	by saving them across the become."	| exs exidx |	exs := exceptions.	exidx := exceptionIndex.	super changeCapacityTo: newSize.	exceptions := exs.	exceptionIndex := exidx.</body></methods><methods><class-id>Opentalk.ORBConstantsDictionary</class-id> <category>accessing</category><body package="Opentalk-IDL-MetaObjects">at: aStringOrSymbol 	"Answer the value at key. If needed get the value from the 	Repository."	| index obj key |	exceptions == nil ifTrue: [self initializeStandardExceptions].	key := aStringOrSymbol asSymbol.	index := self findKeyOrNil: key.	^(self basicAt: index) == nil		ifTrue: 			[obj := DSTORBObject lookupConstantOrSignal: key.			obj isNil				ifTrue: [DSTORBObject intfReposError: 0]				ifFalse: [super at: key put: obj]]		ifFalse: [valueArray at: index]</body><body package="Opentalk-IDL-MetaObjects">at: key ifAbsent: aBlock 	"Answer the value at key. If needed get the value from the 	Repository. If key is not found, answer the result of evaluating 	aBlock."	| index obj |	exceptions == nil ifTrue: [self initializeStandardExceptions].	index := self findKeyOrNil: key.	^(self basicAt: index)		== nil		ifTrue: 			[obj := [DSTORBObject lookupConstantOrSignal: key]						on: DSTORBObject intfReposSignal do: [:ex | (ex parameter at: #minor ifAbsent: [nil]								= 1)							ifTrue: [nil]							ifFalse: [ex reject]].			obj isNil				ifTrue: [aBlock value]				ifFalse: [super at: key put: obj]]		ifFalse: [valueArray at: index]</body><body package="Opentalk-IDL-MetaObjects">indexForStandardException: anException 	"return a unique index for the standard exception"	exceptionIndex == nil ifTrue: [self initializeStandardExceptions].	^exceptionIndex indexOf: anException</body><body package="Opentalk-IDL-MetaObjects">standardExceptionForIndex: anInteger 	"return the standard exception for the index"	exceptionIndex == nil ifTrue: [self initializeStandardExceptions].	^exceptionIndex at: anInteger</body><body package="Opentalk-IDL-MetaObjects">standardExceptions	"return standard exceptions"	exceptions == nil ifTrue: [self initializeStandardExceptions].	^exceptions</body></methods><methods><class-id>Opentalk.ORBConstantsDictionary</class-id> <category>initialize-release</category><body package="Opentalk-IDL-MetaObjects">initializeStandardExceptions	"initialize standard exceptions, communication failure minor codes, 	and invalid operation minor codes"	| memberArray ex prefix |	exceptions := IdentityDictionary new.	memberArray := Array with: (Array with: (Array with: (DSTdeclaratorSimple new initialize: #minor))					with: DSTtypeUnsignedLong new)				with: (Array with: (Array with: (DSTdeclaratorSimple new initialize: #completed))						with: (DSTtypeEnumeration new id: #completion_status values: #(#COMPLETED_YES #COMPLETED_NO #COMPLETED_MAYBE))).	prefix := 'IDL:omg.org/CORBA/'.	self class standardExceptionNames		do: 			[:exName | 			ex := DSTexception new id: exName members: memberArray.			exceptions at: exName put: ex.			self at: exName put: ex errorSignal.			ex repositoryId: (RepositoryId fromString: prefix , exName , ':1.0').			DSTORBObject addExceptionToCache: ex exceptionName: exName ].	exceptionIndex := exceptions asSortedCollection: [:a :b | a name &lt; b name].	self at: #M_PING_LIMIT_EXCEEDED put: 1.	self at: #M_REQUEST_LIMIT_EXCEEDED put: 2.	self at: #M_FRAGMENT_REQUEST_LIMIT_EXCEEDED put: 3.	self at: #M_IF_VERSION_MISMATCH put: 1</body></methods><methods><class-id>Opentalk.ORBConstantsDictionary class</class-id> <category>instance creation</category><body package="Opentalk-IDL-MetaObjects">new	"Create an instance - guess a good size."	^self new: (self standardExceptionNames size * 2)</body></methods><methods><class-id>Opentalk.ORBConstantsDictionary class</class-id> <category>accessing</category><body package="Opentalk-IDL-MetaObjects">rebuild	"Create a new CORBAConstants and pre-initialize it"	self initialize.	CORBAConstants initializeStandardExceptions.</body></methods><methods><class-id>Opentalk.ORBConstantsDictionary class</class-id> <category>class initialization</category><body package="Opentalk-IDL-MetaObjects">initialize	"ORBConstantsDictionary initialize"	CORBAConstants := self new.</body></methods><methods><class-id>Opentalk.ORBConstantsDictionary class</class-id> <category>private</category><body package="Opentalk-IDL-MetaObjects">standardExceptionNames	"return a an array of names for exceptions"	^#(UNKNOWN BAD_PARAM NO_MEMORY IMP_LIMIT  COMM_FAILURE INV_OBJREF NO_PERMISSION INTERNAL MARSHAL INITIALIZE NO_IMPLEMENT BAD_TYPECODE BAD_OPERATION NO_RESOURCES NO_RESPONSE PERSIST_STORE BAD_INV_ORDER TRANSIENT FREE_MEM INV_IDENT INV_FLAG INTF_REPOS BAD_CONTEXT OBJ_ADAPTER DATA_CONVERSION OBJECT_NOT_EXIST TRANSACTION_REQUIRED TRANSACTION_ROLLEDBACK INVALID_TRANSACTION INV_POLICY CODESET_INCOMPATIBLE)</body></methods><methods><class-id>Opentalk.DSToperation</class-id> <category>printing</category><body package="Opentalk-IDL-MetaObjects">attrAndTypeString	"return a string with the operation attribute and the result 	type of the receiver"	| tempStream |	tempStream := (String new: 80) writeStream.	self isNormal ifFalse: [tempStream nextPutAll: self mode asLowercase; nextPut: $ ].	tempStream nextPutAll: signature returnParameter IDLTypeName; nextPut: $ .	^tempStream contents</body><body package="Opentalk-IDL-MetaObjects">hasPragma	"return true if the receiver has a pragma string"	^localOp ~= self defaultOp</body><body package="Opentalk-IDL-MetaObjects">printContext: attrAndTypeString on: aStream indent: level style: aTextStyleName 	"print the context expression of the receiver"	| tabs tempStream |	(context notNil and: [context isEmpty not])		ifTrue: 			[tabs := level + (self tabFor: attrAndTypeString style: aTextStyleName) + 1.			tempStream := (String new: 80) writeStream.			tempStream nextPutAll: 'context ('; nextPutAll: context first.			2 to: context size do: [:i | tempStream nextPutAll: ', '; nextPutAll: (context at: i)].			tempStream nextPut: $).			aStream crtab: tabs.			(self				stringNeedsFormatting: tempStream contents				indent: tabs				style: aTextStyleName)				ifFalse: [aStream nextPutAll: tempStream contents]				ifTrue: 					[aStream nextPutAll: 'context ('.					aStream nextPutAll: raises first.					2 to: context size do: [:i | aStream nextPut: $,; crtab: tabs + 2; nextPutAll: (context at: i)].					aStream nextPut: $)]]</body><body package="Opentalk-IDL-MetaObjects">printDefinitionOn: aStream indent: level style: aTextStyleName 	"print the operation on a stream"	| attrAndType |	prefix isNil ifFalse: [CurrentPrefix ~= prefix prefixString			ifTrue: 				[aStream tab: level; nextPutAll: '#pragma  prefix '; nextPut: $"; nextPutAll: prefix prefixString; nextPut: $"; cr.				CurrentPrefix := prefix prefixString]].	(repositoryId isNil not and: [repositoryId ~= self generateRepositoryId])		ifTrue: [aStream tab: level; nextPutAll: '#pragma  ID '; nextPutAll: self printName; space; nextPut: $"; nextPutAll: repositoryId asString; nextPut: $"; cr].	localOp ~= self defaultOp ifTrue: [aStream tab: level; nextPutAll: '#pragma  selector '; nextPutAll: self printName; space; nextPutAll: localOp; cr].	access notNil ifTrue: [aStream tab: level; nextPutAll: '#pragma  access '; nextPutAll: self printName; space; nextPutAll: access; cr].	version notNil ifTrue: [aStream tab: level; nextPutAll: '#pragma  version '; nextPutAll: self printName; space; nextPutAll: version; cr].	self printCommentOn: aStream indent: level.	attrAndType := self attrAndTypeString.	self		printOperationHeader: attrAndType		on: aStream		indent: level		style: aTextStyleName.	self		printRaisedExceptions: attrAndType		on: aStream		indent: level		style: aTextStyleName.	self		printContext: attrAndType		on: aStream		indent: level		style: aTextStyleName.	aStream nextPut: $;; cr</body><body package="Opentalk-IDL-MetaObjects">printOn: aStream	"print the receiver's printname on the stream"	aStream nextPutAll: 'operation ' , self idlName</body><body package="Opentalk-IDL-MetaObjects">printOperationHeader: attrAndTypeString on: aStream indent: level style: aTextStyleName 	"print the mode and the signature of the receiver"	| tempStream tabs |	tempStream := (String new: 80) writeStream.	tempStream nextPutAll: attrAndTypeString; nextPutAll: name; nextPutAll: ' ('; nextPutAll: signature definitionString; nextPut: $).	aStream tab: level.	(self		stringNeedsFormatting: tempStream contents		indent: level		style: aTextStyleName)		&amp; (signature size &gt; 1) ifFalse: [aStream nextPutAll: tempStream contents]		ifTrue: 			[aStream nextPutAll: attrAndTypeString; nextPutAll: name; nextPutAll: ' ('.			tabs := level + (self tabFor: attrAndTypeString style: aTextStyleName) + 2.			(1 to: signature size - 2)				do: [:i | aStream crtab: tabs; nextPutAll: (signature at: i) definitionString; nextPut: $,].			aStream crtab: tabs; nextPutAll: (signature at: signature size - 1) definitionString; nextPut: $)]</body><body package="Opentalk-IDL-MetaObjects">printRaisedExceptions: attrAndTypeString on: aStream indent: level style: aTextStyleName 	"print the list of raised exceptions of the receiver"	| tabs tempStream |	(raises notNil and: [raises isEmpty not])		ifTrue: 			[tabs := level + (self tabFor: attrAndTypeString style: aTextStyleName) + 1.			tempStream := (String new: 80) writeStream.			tempStream nextPutAll: 'raises ('; nextPutAll: raises first.			2 to: raises size do: [:i | tempStream nextPutAll: ', '; nextPutAll: (raises at: i)].			tempStream nextPut: $).			aStream crtab: tabs.			(self				stringNeedsFormatting: tempStream contents				indent: tabs				style: aTextStyleName)				ifFalse: [aStream nextPutAll: tempStream contents]				ifTrue: 					[aStream nextPutAll: 'raises ('.					aStream nextPutAll: raises first.					2 to: raises size do: [:i | aStream nextPut: $,; crtab: tabs + 2; nextPutAll: (raises at: i)].					aStream nextPut: $)]]</body><body package="Opentalk-IDL-MetaObjects">publishDefinitionOn: aStream indent: level style: aTextStyleName 	"publish the operation on a stream"	| attrAndType |	self printCommentOn: aStream indent: level.	attrAndType := self attrAndTypeString.	self		printOperationHeader: attrAndType		on: aStream		indent: level		style: aTextStyleName.	self		printRaisedExceptions: attrAndType		on: aStream		indent: level		style: aTextStyleName.	self		printContext: attrAndType		on: aStream		indent: level		style: aTextStyleName.	aStream nextPut: $;; cr</body></methods><methods><class-id>Opentalk.DSToperation</class-id> <category>Operation Def</category><body package="Opentalk-IDL-MetaObjects">context	"return the context of the receiver"	^context</body><body package="Opentalk-IDL-MetaObjects">contextIds	"return the context of the receiver. 	This is contextIds rather than context because of IDL naming 	restrictions"	^context</body><body package="Opentalk-IDL-MetaObjects">contexts	"The contexts attribute specifies the list of context identifiers that 	apply to the operation."	^context</body><body package="Opentalk-IDL-MetaObjects">contexts: newContexts 	"Set the contexts attribute to the list of context identifiers that 	apply to the operation."	self notYetImplemented</body><body package="Opentalk-IDL-MetaObjects">description	"return an operation description"	^(DSToperationDescription new) 		name: name; 		id: self id; 		definedIn: self definedInString; 		version: self version;		result: signature returnParameter type equivalentType; 		mode: #NORMAL; 		contexts: self contexts; 		parameters: ((signature asOrderedCollection select: [:p | p isResult not]) collect: [:p | p description]); 		exceptions: (raises asOrderedCollection collect: [:x | (self exceptionOf: x) description]); 		yourself</body><body package="Opentalk-IDL-MetaObjects">exceptions	"The exceptions attribute specifies the list of exception types that 	can be raised by the operation."	^raises collect: [:x | self exceptionOf: x]</body><body package="Opentalk-IDL-MetaObjects">exceptions: newExceptions 	"Set the exceptions attribute to the list of exception types that 	can be raised by the operation."	self notYetImplemented</body><body package="Opentalk-IDL-MetaObjects">mode	"The operation's mode is either oneway (i.e. no output is returned) or 	normal."	sync == nil ifTrue: [sync := #NORMAL].	^sync</body><body package="Opentalk-IDL-MetaObjects">mode: anOperationMode 	"The mode attribute can only be set to OP_ONEWAY if the result is 	TC_void and all elements of params have a mode of PARAM_IN."	self notYetImplemented</body><body package="Opentalk-IDL-MetaObjects">params	"The params attribute describes the parameters of the operation. It is 	a sequence of ParameterDescriptions. The order of the 	ParameterDescriptions in the sequence is significant. The name 	member of each description provides the parameter name. The type 	member is a typecode describing the type of the parameter. The 	typeDef member identifies the definition of the type of the 	parameter. The mode member indicates whether the parameter is 	an in, out, or inout parameter."	^signature collect: [:p | p description]</body><body package="Opentalk-IDL-MetaObjects">params: paramList 	"The params attribute describes the parameters of the operation. It is 	a sequence of ParameterDescriptions. The order of the 	ParameterDescriptions in the sequence is significant. The name 	member of each description provides the parameter name. The type 	member is a typecode describing the type of the parameter. The 	typeDef member identifies the definition of the type of the 	parameter. The mode member indicates whether the parameter is 	an in, out, or inout parameter."	self notYetImplemented</body><body package="Opentalk-IDL-MetaObjects">result	"The result attribute is a typecode describing the type of the value 	returned by the operation."	^signature returnParameter type equivalentType typeKind</body><body package="Opentalk-IDL-MetaObjects">resultDef	"The resultDef attribute identifies the definition of the returned type."	^signature returnParameter type equivalentType baseType</body><body package="Opentalk-IDL-MetaObjects">resultDef: anIDLType 	"Setting the resultDef attribute updates the result attribute."	self notYetImplemented</body></methods><methods><class-id>Opentalk.DSToperation</class-id> <category>rendering</category><body package="Opentalk-IDL-MetaObjects">hasComponents	"return true iff I have components worthwhile to show in a browser 	window"	^(signature nonTrivialSignature isEmpty &amp; raises isEmpty) not</body></methods><methods><class-id>Opentalk.DSToperation</class-id> <category>marshalling</category><body package="Opentalk-IDL-MetaObjects">handleErrorResultFrom: aPacket 	"unmarshall the appropriate error result from the 	stream"	| ix ex parm |	ix := aPacket nextUnsignedShort.	self unMarshallServiceContextFrom: aPacket.	ix &gt; 32767		ifTrue: 			[ix := 65536 - ix.			ex := CORBAConstants standardExceptionForIndex: ix]		ifFalse: [ex := self exceptionOf: (raises at: ix)].	parm := ex errorType unMarshall: aPacket.	^ex errorSignal raiseWith: parm errorString: ' '</body><body package="Opentalk-IDL-MetaObjects">handleFaultResultFrom: aPacket 	"unmarshall the appropriate fault result from the stream"	self class unknownError: 0</body><body package="Opentalk-IDL-MetaObjects">marshallArguments: argArray on: aStream 	"marshall the arguments onto the stream"	| inArray |	inArray := signature parameters.	argArray size = inArray size		ifTrue: [1 to: inArray size				do: 					[:inx | 					| typ direction |					typ := inArray at: inx.					direction := typ mode.					direction == #IN						ifTrue: [typ marshall: (argArray at: inx)								on: aStream]						ifFalse: [direction == #INOUT ifTrue: [typ marshall: (argArray at: inx) value on: aStream]]]]		ifFalse: [DSTORBObject badParamError: 0]</body><body package="Opentalk-IDL-MetaObjects">marshallErrorResult: exception on: aStream 	"marshall the appropriate error result on the stream"	| ex ix errs opErrs param |	errs := CORBAConstants standardExceptions.	ex := errs values detect: [:exmo | exmo errorSignal == exception getSignal]				ifNone: [].	ex isNil		ifFalse: 			[ix := (CORBAConstants indexForStandardException: ex) negated.			param := exception parameter]		ifTrue: 			[opErrs := Dictionary new.			raises do: [:sy | opErrs add: sy -&gt; (self exceptionOf: sy)].			ex := opErrs detect: [:exmo | exmo errorSignal == exception getSignal]						ifNone: [].			ex isNil				ifFalse: 					[ix := raises indexOf: (opErrs keyAtValue: ex).					param := exception parameter]				ifTrue: 					[ex := errs at: #UNKNOWN.					ix := (CORBAConstants indexForStandardException: ex) negated.					param := Dictionary with: #minor -&gt; 0 with: #completed -&gt; #COMPLETED_MAYBE]].	aStream nextPutShort: ix.	self marshallServiceContextForReply: aStream.	ex errorType marshall: param on: aStream</body><body package="Opentalk-IDL-MetaObjects">marshallResult: result on: aStream withArgs: argArray 	"marshall the results onto the stream"	| restype |	restype := signature returnParameter.	restype isVoid ifFalse: [restype marshall: result on: aStream].	signature parameters keysAndValuesDo: [:i :p | p notIN ifTrue: [p marshall: (argArray at: i) value on: aStream]]</body><body package="Opentalk-IDL-MetaObjects">marshallServiceContextForReply: aStream 	"marshall the context on the reply stream"	"remove the security context and the debugging context since they 	do not propagate backwards"	| orbCxt |		[orbCxt := Processor activeProcess orbContext.	orbCxt debuggerContext: nil.	orbCxt securityContext: nil.	self class serviceContextListDef marshall: orbCxt serviceContextList on: aStream]		on: Object errorSignal do: [:ex | self class badContextError: 0]</body><body package="Opentalk-IDL-MetaObjects">marshallServiceContextForRequest: aStream 	"marshall the context on the request stream"	"WARNING: do not change this method without making sure that 	'callingContext' returns the right value"	| orbCxt cxtList |	orbCxt := Processor activeProcess orbContext.		[Processor activeProcess orbContext: nil.	"(DSTModules security isLoaded and: [orbCxt local and: [orbCxt securityContext isNil]])		ifTrue: 			[newCxt := DSTModules security newSecurityContext.			newCxt notNil ifTrue: [orbCxt securityContext: newCxt]].	newCxt := orbCxt debuggerContext.	ORBDaemon debugging &amp; newCxt isNil		ifTrue: 			[newCxt := DSTModules debugger createContext.			orbCxt debuggerContext: newCxt]."	cxtList := orbCxt serviceContextList.	"newCxt notNil		ifTrue: 			[cxtList := cxtList copyWithout: newCxt.			cxtList addLast: (newCxt copy callingContext: self callingContext)]."	self class serviceContextListDef marshall: cxtList on: aStream]		ensure: [Processor activeProcess orbContext: orbCxt]</body><body package="Opentalk-IDL-MetaObjects">unMarshallArgumentsFrom: aStream 	"unmarshall the arguments from the stream"	^signature parameters collect: [:p | p mode == #IN			ifTrue: [p unMarshall: aStream]			ifFalse: [p mode == #INOUT					ifTrue: [(p unMarshall: aStream) asCORBAParameter]					ifFalse: [nil asCORBAParameter]]]</body><body package="Opentalk-IDL-MetaObjects">unMarshallResultsFrom: aPacket withArgs: argArray 	"un-marshall the results from the stream"	| paramArray result |	result := signature returnParameter unMarshall: aPacket.	signature outParameters isEmpty		ifFalse: 			[paramArray := signature parameters.			paramArray keysAndValuesDo: [:i :p | p notIN ifTrue: [(argArray at: i)						value: (p unMarshall: aPacket)]]].	^result</body><body package="Opentalk-IDL-MetaObjects">unMarshallServiceContextFrom: aStream 	"unmarshall the service context from the stream. This method relies 	on the fact that the active process was newly created and has an 	unset ORB context"	| cxtList orbCxt |	cxtList := self class serviceContextListDef unMarshall: aStream.	cxtList isEmpty		ifFalse: 			[orbCxt := Processor activeProcess orbContext.			cxtList do: [:cxt | orbCxt addServiceContext: cxt]]</body></methods><methods><class-id>Opentalk.DSToperation</class-id> <category>accessing</category><body package="Opentalk-IDL-MetaObjects">accessRight	^access ifNil: [#noSecurity]</body><body package="Opentalk-IDL-MetaObjects">accessRight: aString 	access := aString asSymbol</body><body package="Opentalk-IDL-MetaObjects">definedIn: aMetaObject 	"set the receiver's defining container meta object"	super definedIn: aMetaObject.	signature do: [:p | p definedIn: self]</body><body package="Opentalk-IDL-MetaObjects">exceptionOf: aSymbol 	"Return an exception meta object which has the given print name 	symbol. 	Error if not" 	| ex |	ex := self definingMetaContainer metaObjectOf: aSymbol.	DSTmoduleRepository convenientNameResolution		ifFalse: 			[ex isNil ifTrue: [^nil].			(ex isDSTMetaObject)				ifTrue: [ex := Set with: ex].			^ex inject: Set new				into: 					[:result :mo | 					| m |					m := mo equivalentType.					result add: m; yourself]]		ifTrue: 			[ex := ex equivalentType.			(ex isDSTMetaObject and: [ex isDSTexception])				ifTrue: [^ex]				ifFalse: [self class intfReposError: 0]]</body><body package="Opentalk-IDL-MetaObjects">findCorbaExceptionFor: anException 	"return the appropriate error so that it can be marshalled on a stream"	| ex errs opErrs param exType |	errs := CORBAConstants standardExceptions.	ex := errs values detect: [:exmo | exmo errorSignal == anException getSignal]				ifNone: [].	ex isNil		ifFalse: 			[param := anException parameter.			exType := #systemException]		ifTrue: 			[opErrs := Dictionary new.			raises do: [:sy | opErrs add: sy -&gt; (self exceptionOf: sy)].			ex := opErrs detect: [:exmo | exmo errorSignal == anException getSignal]						ifNone: [].			ex isNil				ifFalse: 					[param := anException parameter.					exType := #userException]				ifTrue: 					[ex := errs at: #UNKNOWN.					param := Dictionary with: #minor -&gt; 0 with: #completed -&gt; #COMPLETED_MAYBE.					exType := #systemException]].	^Array		with: ex		with: param		with: exType</body><body package="Opentalk-IDL-MetaObjects">isNormal	"return if the receiver has default (normal) invocation 	semantics"	^self mode == #NORMAL</body><body package="Opentalk-IDL-MetaObjects">isOneWay	"return if the receiver has been specified to have the one-way (asynchronous) attribute"	^sync == #ONEWAY</body><body package="Opentalk-IDL-MetaObjects">localOp	"return the operation's local opselector"	^localOp</body><body package="Opentalk-IDL-MetaObjects">localOp: aSelector 	"set the operation's local opselector"	localOp := aSelector</body><body package="Opentalk-IDL-MetaObjects">opSelector	"return the operation's selector"	^name isNil 		ifTrue: ['?']		ifFalse: [name]</body><body package="Opentalk-IDL-MetaObjects">signature	"Return the signature for the operation. The last parameter is the 	return value."	^signature</body></methods><methods><class-id>Opentalk.DSToperation</class-id> <category>repository</category><body package="Opentalk-IDL-MetaObjects">CORBAName	"return the name of my CORBA interface in the repository"	^#'::CORBA::OperationDef'</body><body package="Opentalk-IDL-MetaObjects">allMetaObjectsInto: aSet	"add all of the contained metaobjects to the set"	super allMetaObjectsInto: aSet.	signature do: [:s | s allMetaObjectsInto: aSet]</body><body package="Opentalk-IDL-MetaObjects">canApplyPragma: pragma 	"Check to see if the argument pragma can be applied to the receiver."	^#(#ID #SELECTOR #VERSION #ACCESS) includes: pragma</body><body package="Opentalk-IDL-MetaObjects">checkReferencesUniqueness	"check if all referenced exceptions can be resolved uniquely" 		[DSTmoduleRepository convenientNameResolution: false.	raises asSet		do: 			[:na | 			| ref |			ref := self exceptionOf: na.			ref size &gt; 1 ifTrue: [Dialog notify: 'Operation ''' , self idlName , ''' raises ambiguous exception ''' , na asString , '''']]]		ensure: [DSTmoduleRepository convenientNameResolution: true]</body><body package="Opentalk-IDL-MetaObjects">defKind        "Return the definition kind."        ^#dk_Operation</body><body package="Opentalk-IDL-MetaObjects">registerIdentity	"Register the identity and full name of the receiver in the Interface 	Repository."	"Though very odd but four PIDL operations in CORBA::Object has 	special operator mappings defined by GIOP (CORBA 2.0  section 12.4.1). 	This is the best place that I can think of to insert the mapping"	self definedIn name == #Object		ifTrue:[ self name == #get_interface					ifTrue:[ name := #_interface].				self name == #get_implementation					ifTrue:[ name := #_implementation].				 self name == #is_a					ifTrue:[ name := #_is_a].				self name == #non_existent					ifTrue:[ name := #_not_existent]].	super registerIdentity.</body></methods><methods><class-id>Opentalk.DSToperation</class-id> <category>initialization</category><body package="Opentalk-IDL-MetaObjects">cxt: cxt evts: evts params: params id: id type: result attr: attrib 	"initialize the operation named by id with signature consisting of an 	array of typeId symbols"	name := id.	signature := DSTsignature new.	params do: [:p | signature add: p].	signature add: (DSTparameter new			name: #'OP RESULT'			type: result			direction: #OUT).	sync := attrib.	raises := evts.	context := cxt.	localOp := self defaultOp</body><body package="Opentalk-IDL-MetaObjects">defaultOp	"return a computed local operation selector"	| sel n x | 	sel := nil.	signature parameters		do: 			[:p | 			n := p name asString copy.			n replaceAll: $  with: $_.			n := (self convertSymbol: n) asString.			x := n findLast: [:c | c = $:].			x &gt; 0 ifTrue: [n := n copyFrom: x + 1 to: n size].			sel isNil				ifTrue: [sel := self printName asString unCapitalized , ':']				ifFalse: [sel := sel , n unCapitalized , ':']].	sel ifNil: [sel := self printName asString unCapitalized].	^self convertSymbol: sel</body><body package="Opentalk-IDL-MetaObjects">initialize	"initialize the operation"	super initialize.	signature := #().	raises := #().	context := #()</body><body package="Opentalk-IDL-MetaObjects">opSel: localop cxt: cxt evts: evts params: params id: id type: result attr: attrib 	"initialize the operation named by id with signature consisting of an 	array of typeId symbols"	name := id.	signature := DSTsignature new.	params do: [:p | signature add: p].	signature add: (DSTparameter new			name: #'OP RESULT'			type: result			direction: #OUT).	sync := attrib.	raises := evts.	context := cxt.	localOp := self convertSymbol: (localop ifNil: [self defaultOp])</body></methods><methods><class-id>Opentalk.DSToperation</class-id> <category>object tester</category><body package="Opentalk-IDL-MetaObjects">performInteractivelyOn: anObject 	"prompt the user for the arguments to the operation and display an 	inspector on the result"	| args result |	[args := signature inParameters collect: [:parm | parm valueFromUser]]		on: self errorSignal do: [:err | ^Dialog warn: ('Operation aborted:\\' , err errorString) withCRs].	result := anObject perform: localOp withArguments: args asArray.	(#{Inspector} isDefined)		ifTrue: [result inspect]		ifFalse: [Transcript show: 'Result: ' , result printString; cr]</body></methods><methods><class-id>Opentalk.DSToperation</class-id> <category>private</category><body package="Opentalk-IDL-MetaObjects">callingContext	"Answer the calling context of the receiver." 	"NOTA BENE:  The context answered must be the context 	for either 'NCSClientConversation class&gt;&gt;clientCall:...' or 	'IIOPClientConversation class&gt;&gt;clientCall:...'.  If some other	context is answered, the distributed debugger will fail."	"NOTA BENE: Changes to the implementation of either of the	'clientCall:...' methods may affect the validity of this method."	"NOTA BENE:  The implementation of this method is dependent	on details of the OE implemenatation.  OE optimizations after	VW 3.0 added two intervening contexts between the 'clientCall:...'	context and this context."	self objectEngineImplementationDependent.	^thisContext sender sender sender sender sender sender</body></methods><methods><class-id>Opentalk.DSToperation</class-id> <category>testing</category><body package="Opentalk-IDL-MetaObjects">IIOPIsA: aRepositoryId	aRepositoryId asString = 'IDL:CORBA/OperationDef:1.0' ifTrue:[^true].	^super IIOPIsA: aRepositoryId</body><body package="Opentalk-IDL-MetaObjects">isDSToperation	^true</body></methods><methods><class-id>Opentalk.DSToperation</class-id> <category>converting</category><body package="Opentalk-IDL-MetaObjects">asOperationInfo	"return an operationInfo object for the receiver"	| if |	^DSToperationInfo new		interface: (if := self definingMetaContainer)		operation: self		selector: localOp		opIndex: (if entryPointVector indexOf: localOp)				- 1</body></methods><methods><class-id>Opentalk.DSToperation class</class-id> <category>marshalling</category><body package="Opentalk-IDL-MetaObjects">contextInterface	"cache and return the interface for marshalling ORBContext strings"	^ContextIF</body><body package="Opentalk-IDL-MetaObjects">serviceContextListDef	"cache and return the interface for marshalling ORBContext strings"	| fieldArray |	^ServiceContextListDef		ifNil: 			[fieldArray := Array with: (Array with: (Array with: (DSTdeclaratorSimple new initialize: #contextId))							with: DSTtypeUnsignedLong new)						with: (Array with: (Array with: (DSTdeclaratorSimple new initialize: #contextData))								with: ((DSTtypeSequence new) subtype: DSTtypeOctet new size: nil; localType: #ByteArray)).			ServiceContextListDef := DSTtypeSequence new subtype: ((DSTtypeStructure new) id: #ServiceContext fields: fieldArray; localType: #DSTServiceContext) size: nil]</body></methods><methods><class-id>Opentalk.DSTtypeFixed</class-id> <category>marshalling</category><body package="Opentalk-IDL-MetaObjects">boldMarshall: aParameter on: aStream 	"Marshall the parameter onto the stream. "	[aStream		nextPutFixed: aParameter		digits: digits		scale: scale]		on: Error do: [:ex | self class marshallError: 0]</body><body package="Opentalk-IDL-MetaObjects">marshallMatch: aParameter 	"Return:		true			- if I can marshall the parameter		false		- if I can NOT marshall the parameter		#mappable	- if I can marshall the parameter by mapping to something else"		^aParameter isKindOf: FixedPoint</body><body package="Opentalk-IDL-MetaObjects">marshallTypeCode: aDictionary on: aStream 	"marshall the type code of the receiver"	aStream nextPutUnsignedLong: self typeCode; 			nextPutUnsignedShort: (digits == nil ifTrue: [0] ifFalse: [digits]);			nextPutShort: (scale == nil ifTrue: [0] ifFalse: [scale]).</body><body package="Opentalk-IDL-MetaObjects">unMarshall: aStream 	"Unmarshall a result from the stream and return an object of the 	appropriate class."	^aStream nextFixed: digits scale: scale</body><body package="Opentalk-IDL-MetaObjects">unMarshallTypeCode: aDictionary from: aStream	"marshall the type code of the receiver"	digits := aStream nextUnsignedShort.	scale := aStream nextShort.</body></methods><methods><class-id>Opentalk.DSTtypeFixed</class-id> <category>accessing</category><body package="Opentalk-IDL-MetaObjects">digits	^digits</body><body package="Opentalk-IDL-MetaObjects">digits: anUnsignedLong	digits := anUnsignedLong</body><body package="Opentalk-IDL-MetaObjects">scale	^scale</body><body package="Opentalk-IDL-MetaObjects">scale: anSignedShort	scale := anSignedShort</body></methods><methods><class-id>Opentalk.DSTtypeFixed</class-id> <category>repository</category><body package="Opentalk-IDL-MetaObjects">CORBAName	"return the name of my CORBA interface in the repository"	^#'::CORBA::FixedDef'</body><body package="Opentalk-IDL-MetaObjects">defKind        "Return the definition kind."        ^#dk_Fixed</body><body package="Opentalk-IDL-MetaObjects">typeKind	"return the TCKind of the receiver"	^#tk_fixed</body><body package="Opentalk-IDL-MetaObjects">typeParamCount	"return the number of parameters which the receiver supports. "	^2</body><body package="Opentalk-IDL-MetaObjects">typeParameter: anInt	"return the nth parameter which the receiver supports. 	Subtypes should overload as required"	anInt = 1 ifTrue: [^digits].	anInt = 2 ifTrue: [^scale].	self error: #Bounds</body></methods><methods><class-id>Opentalk.DSTtypeFixed</class-id> <category>printing</category><body package="Opentalk-IDL-MetaObjects">definitionString	"return my IDL type definition string"	| aStream |	aStream := (String new: 80) writeStream.	aStream 		nextPutAll: name; 		nextPutAll: '&lt;'; 		nextPutAll: digits printString;		nextPutAll: ', '; 		nextPutAll: scale printString;		nextPut: $&gt;.	^aStream contents</body></methods><methods><class-id>Opentalk.DSTtypeFixed</class-id> <category>initialization</category><body package="Opentalk-IDL-MetaObjects">digits: d scale: s 	name := 'fixed'.	digits := d value.	scale := s value.</body><body package="Opentalk-IDL-MetaObjects">initialize	"initialize the receiver"	super initialize.	name := 'fixed'</body></methods><methods><class-id>Opentalk.DSTtypeFixed</class-id> <category>Primitive Def</category><body package="Opentalk-IDL-MetaObjects">kind	"return the receiver's primitive type"	^#pk_fixed</body></methods><methods><class-id>Opentalk.DSTtypeArray</class-id> <category>testing</category><body package="Opentalk-IDL-MetaObjects">isDSTtypeArray	^true</body></methods><methods><class-id>Opentalk.DSTtypeArray</class-id> <category>accessing</category><body package="Opentalk-IDL-MetaObjects">arrayType	"The arrayType of an array is the type for printing."	^arrayType</body><body package="Opentalk-IDL-MetaObjects">baseType	"The baseType of an array is the subtype."	^subtype</body><body package="Opentalk-IDL-MetaObjects">resolveTo: aType	"cause the receiver to resolve to the given type object"	subtype class == self class		ifTrue: [subtype resolveTo: aType]		ifFalse: [subtype := aType]</body></methods><methods><class-id>Opentalk.DSTtypeArray</class-id> <category>initialization</category><body package="Opentalk-IDL-MetaObjects">sizes: sizes ident: aSymbol type: aType 	"Initialize instance variables for a fixed sized array"	super initialize: aSymbol.	size := sizes at: 1.	arrayType := aType.	sizes size = 1		ifTrue: [subtype := aType]		ifFalse: [subtype := self class new						sizes: (sizes copyFrom: 2 to: sizes size)						ident: ''						type: aType]</body></methods><methods><class-id>Opentalk.DSTtypeArray</class-id> <category>printing</category><body package="Opentalk-IDL-MetaObjects">declaratorString	"return an IDL declarator string"	(subtype isDSTMetaObject and: [subtype isDSTtypeArray])		ifTrue: [^self printName , '[' , size printString , ']' , subtype declaratorString]		ifFalse: [^self printName , '[' , size printString , ']']</body><body package="Opentalk-IDL-MetaObjects">definitionString	"return my unformatted IDL type definition string"	^subtype name</body><body package="Opentalk-IDL-MetaObjects">idlName	"return the receivers full qualified name"	^self definingMetaObject idlName , '::' , self declaratorString</body></methods><methods><class-id>Opentalk.DSTtypeArray</class-id> <category>marshalling</category><body package="Opentalk-IDL-MetaObjects">boldMarshall: aParameter on: aStream 	"Marshall the parameter onto the stream"	"canMarshall = size matches and not exception on marshalling on elements"	(aParameter size = size)		ifFalse: [self class marshallError: 0].	1 to: aParameter size do: [:i | subtype boldMarshall: (aParameter at: i)			on: aStream].</body><body package="Opentalk-IDL-MetaObjects">marshallMatch: aParameter 	"Return:		true			- if I can marshall the parameter		false		- if I can NOT marshall the parameter		#mappable	- if I can marshall the parameter by mapping to something else"		^aParameter size = size and: [subtype marshallMatch: (aParameter at: 1)]</body><body package="Opentalk-IDL-MetaObjects">marshallTypeCode: aDictionary on: aStream 	"marshall the type code of the receiver"	(self tryMarshallIndirectTypeCode: aDictionary on: aStream)		ifTrue: [^self].	aStream nextPutUnsignedLong: self typeCode.	aStream nextPutEncapsulatedInOctets: [ :stream |		subtype marshallTypeCode: aDictionary on: stream.		stream nextPutUnsignedLong: size ]</body><body package="Opentalk-IDL-MetaObjects">unMarshall: aStream 	"Unmarshall a result from the stream and return an object of the 	appropriate class."	^self unMarshall: aStream withLocalClass: self localClass</body><body package="Opentalk-IDL-MetaObjects">unMarshall: aStream withLocalClass: aClass 	"Unmarshall a result from the stream and return an object of the 	appropriate class."	| result |	aClass isNil		ifTrue: [result := Array new: size]		ifFalse: [result := aClass new: size].	1 to: size do: [:i | result at: i put: (subtype unMarshall: aStream)].	aClass == NCSuuid ifTrue: [^NCSuuid intern: result].	^result</body><body package="Opentalk-IDL-MetaObjects">unMarshallTypeCode: aDictionary from: aStream	"unmarshall the type code of the receiver"	| byteOrder |	aDictionary add: aStream position -&gt; self.	aStream nextUnsignedLong.	byteOrder := aStream byteOrder.	aStream byteOrder: aStream nextBoolean.	subtype := self class unMarshallTypeCode: aDictionary from: aStream.	size := aStream nextUnsignedLong.	aStream byteOrder: byteOrder</body></methods><methods><class-id>Opentalk.DSTtypeArray</class-id> <category>ArrayDef</category><body package="Opentalk-IDL-MetaObjects">elementType	"The type of the elements is described by elementType."	^subtype equivalentType baseType</body><body package="Opentalk-IDL-MetaObjects">elementTypeDef	"The type of the elements is identified by elementTypeDef."	^subtype equivalentType baseType</body><body package="Opentalk-IDL-MetaObjects">elementTypeDef: anIDLType 	"Setting the elementTypeDef attribute also updates the elementType 	and the inherited type attributes."	self notYetImplemented</body><body package="Opentalk-IDL-MetaObjects">length	"The length attribute specifies the number of elements in the array."	^size</body><body package="Opentalk-IDL-MetaObjects">length: newLength 	"Setting the length attribute also updates the inherited type 	attribute."	self notYetImplemented</body></methods><methods><class-id>Opentalk.DSTtypeArray</class-id> <category>rendering</category><body package="Opentalk-IDL-MetaObjects">childName	"return the name to be used for the receiver in a browser window"	^self declaratorString</body></methods><methods><class-id>Opentalk.DSTtypeArray</class-id> <category>TypeCode</category><body package="Opentalk-IDL-MetaObjects">typeKind	"return the TCKind of the receiver"	^#tk_array</body><body package="Opentalk-IDL-MetaObjects">typeParamCount	"return the number of parameters which the receiver supports. 	Subtypes should overload as required"	^2</body><body package="Opentalk-IDL-MetaObjects">typeParameter: anInt	"return the nth parameter which the receiver supports. 	Subtypes should overload as required"	anInt = 1 ifTrue: [^subtype].	anInt = 2 ifTrue: [^size].	self error: #Bounds</body></methods><methods><class-id>Opentalk.DSTtypeArray</class-id> <category>repository</category><body package="Opentalk-IDL-MetaObjects">CORBAName	"return the name of my CORBA interface in the repository"	^#'::CompoundDefs::ArrayCompoundDef'</body><body package="Opentalk-IDL-MetaObjects">defKind        "Return the definition kind."        ^#dk_Array</body></methods><methods><class-id>Opentalk.DSTMetaContainer</class-id> <category>Container</category><body package="Opentalk-IDL-MetaObjects">contents: limitType excludeInherited: bool 	"The contents operation returns the list of objects directly contained 	by or inherited into the object. The operation is used to navigate 	through the hierarchy of objects. Starting with the repository object, 	a client uses this operation to list all of the objects contained by the 	repository, all of the objects contained by the modules within the 	repository, and then all of the interfaces within a specific module, 	and so on. 		If limitType is set to dk_all, objects of all interface types are 	returned. 		If limitType is set to a specific interface, only objects of that 	interface type are returned. 		If excludeInherited is TRUE, inherited objects (if any) are not 	returned. If set to FALSE, all contained objects--whether contained 	due to inheritance or because they were defined within the 	object--are returned."	| res |	res := contents asSet select: [:mo | limitType = #dk_all | (limitType = mo defKind)].	bool ifFalse: [self withAllSuperiors do: [:mo | res addAll: (mo contents: limitType excludeInherited: true)]].	^res</body><body package="Opentalk-IDL-MetaObjects">createAlias: aRepositoryId name: aName version: aVersion originalType: anIDLType 	"The createAlias operation returns a new AliasDef with the specified 	originalType. 		The aRepositoryId and aName parameters are used to initialize the 	identity of the created alias. An error is returned if an object 	with the specified aRepositoryId already exists within this object's 	repository, or, assuming multiple versions are not supported, if an 	object with the specified aName already exists within this container."	self notYetImplemented</body><body package="Opentalk-IDL-MetaObjects">createConstant: aRepositoryId name: aName version: aVersion type: anIDLType value: aValue 	"The createConstant operation returns a new ConstantDef with the 	specified type and value. 		The aRepositoryId and aName parameters are used to initialize the 	identity of the created constant. An error is returned if an object 	with the specified aRepositoryId already exists within this object's 	repository, or, assuming multiple versions are not supported, if an 	object with the specified aName already exists within this container."	self notYetImplemented</body><body package="Opentalk-IDL-MetaObjects">createEnum: aRepositoryId name: aName version: aVersion members: memberList 	"The createEnum operation returns a new EnumDef with the 	specified members. 		The aRepositoryId and aName parameters are used to initialize the 	identity of the created enumeration. An error is returned if an object 	with the specified aRepositoryId already exists within this object's 	repository, or, assuming multiple versions are not supported, if an 	object with the specified aName already exists within this container."	self notYetImplemented</body><body package="Opentalk-IDL-MetaObjects">createException: aRepositoryId name: aName version: aVersion members: aMemberCollection 	"The createException operation returns a new ExceptionDef with the specified 	members. 		The aRepositoryId and aName parameters are used to initialize the 	identity of the created exception. An error is returned if an object 	with the specified aRepositoryId already exists within this object's 	repository, or, assuming multiple versions are not supported, if an 	object with the specified aName already exists within this container."	self notYetImplemented</body><body package="Opentalk-IDL-MetaObjects">createInterface: aRepositoryId name: aName version: aVersion baseInterfaces: interfaceList 	"The createInterface operation returns a new empty InterfaceDef 	with the specified base interfaces. Type, exception, and constant 	definitions can be added using create&lt;Type&gt; operations on the new 	interface. OperationDefs can be added by using createOperation and 	AttributeDefs can be added by using createAttribute. Definitions can 	also be added by using the move operation. 		The aRepositoryId and aName parameters are used to initialize the 	identity of the created interface. An error is returned if an object 	with the specified aRepositoryId already exists within this object's 	repository, or, assuming multiple versions are not supported, if an 	object with the specified aName already exists within this container."	self notYetImplemented</body><body package="Opentalk-IDL-MetaObjects">createModule: aRepositoryId name: aName version: aVersion 	"The createModule operation returns a new empty ModuleDef. 	Definitions can be added using create&lt;Type&gt; operations on the new 	module, or by using the move operation. 		The aRepositoryId and aName parameters are used to initialize the 	identity of the created module. An error is returned if an object with 	the specified aRepositoryId already exists within this object's 	repository, or, assuming multiple versions are not supported, if an 	object with the specified aName already exists within this container."	self notYetImplemented</body><body package="Opentalk-IDL-MetaObjects">createStruct: aRepositoryId name: aName version: aVersion members: memberList 	"The createStruct operation returns a new StructDef with the 	specified members. The type member of the StructMembers 	structure is ignored, and should be set to TC_void. 		The aRepositoryId and aName parameters are used to initialize the 	identity of the created structure. An error is returned if an object 	with the specified aRepositoryId already exists within this object's 	repository, or, assuming multiple versions are not supported, if an 	object with the specified aName already exists within this container."	self notYetImplemented</body><body package="Opentalk-IDL-MetaObjects">createUnion: aRepositoryId name: aName version: aVersion discriminatorType: aDiscriminatorType members: memberList 	"The createUnion operation returns a new UnionDef with the 	specified discriminator type and members. The type member of the 	UnionMember structure is ignored, and should be set to TC_void. 		The aRepositoryId and aName parameters are used to initialize the 	identity of the created union. An error is returned if an object 	with the specified aRepositoryId already exists within this object's 	repository, or, assuming multiple versions are not supported, if an 	object with the specified aName already exists within this container."	self notYetImplemented</body><body package="Opentalk-IDL-MetaObjects">describe: aSymbol excludeInherited: bool max: anInt 	"The describeContents operation combines the contents operation 	and the describe operation. For each object returned by the contents 	operation, the description of the object is returned. 		If limitType is set to #dk_all, objects of all interface types are returned. 	If limitType is set to a specific interface, only objects of that 	interface type are returned. 		maxReturnedObjs limits the number of objects that can be returned 	in an invocation of the call to the number provided. Setting the 	parameter to -1 means return all contained objects."	| res |	res := (self contents: aSymbol excludeInherited: bool) asOrderedCollection.	anInt negative not &amp; (anInt &lt; res size) ifTrue: [res := res copyFrom: 1 to: anInt].	^res collect: [:mo | Dictionary			with: #containedObject -&gt; (mo widenTo: #'::CORBA::Contained')			with: #kind -&gt; mo defKind			with: #value -&gt; mo description]</body><body package="Opentalk-IDL-MetaObjects">description	"return the description of the receiver"	^Dictionary		with: #containedObject -&gt; self definedInString		with: #kind -&gt; self defKind		with: #value -&gt; self id</body><body package="Opentalk-IDL-MetaObjects">lookup: searchName 	"The lookup operation locates a definition relative to the receiver 	given a scoped name using IDL's name scoping rules. An absolute 	scoped name (beginning with '::' locates the definition relative to the 	enclosing repository. If no object is found, a nil object reference is 	returned."	| components container mo ns |	components := self components: searchName.	components first = #'::'		ifTrue: 			[container := DSTORBObject repository.			ns := searchName.			components removeFirst]		ifFalse: 			[container := self.			ns := container idlName , '::' , searchName].	mo := self class lookupId: ns.	mo isNil ifFalse: [^mo].	components		do: 			[:c | 			mo := container						lookupName: c						levels: 1						limit: #dk_all						excludeInherited: true.			mo isEmpty				ifTrue: [^nil]				ifFalse: [container := mo asOrderedCollection first]].	container isNil ifFalse: [container registerIdentity].	^container</body><body package="Opentalk-IDL-MetaObjects">lookupName: aSymbol levels: anInt limit: limitType excludeInherited: bool 	"The lookup name operation is used to locate an object by name 	within a particular object or within the objects contained by that 	object. aSymbol specifies which name is to be searched for. 		anInt controls whether the lookup is constrained to the 	object the operation is invoked on or whether it should search 	through objects contained by the object as well. Setting 	levels to -1 searches the current object and all contained 	objects. Setting levels to 1 searches only the current object. 		If limitType is set to dk_all, objects of all interface types are 	returned. 	If limitType is set to a specific interface, only objects of that 	interface type are returned. 		If excludeInherited is TRUE, inherited objects (if any) are not 	returned. If set to FALSE, all contained objects--whether contained 	due to inheritance or because they were defined within the 	object--are returned."	| res r |	res := Set with: (symbols at: aSymbol ifAbsent: [nil]).	anInt = -1 ifTrue: [contents do: [:mo | (mo isDSTMetaObject and: [mo isDSTMetaContainer])				ifTrue: 					[r := mo								lookupName: aSymbol								levels: anInt								limit: limitType								excludeInherited: bool.					res addAll: r]]].	anInt &gt; 1 ifTrue: [contents do: [:mo | (mo isDSTMetaObject and: [mo isDSTMetaContainer])				ifTrue: 					[r := mo								lookupName: aSymbol								levels: anInt - 1								limit: limitType								excludeInherited: bool.					res addAll: r]]].	res := res select: [:mo | limitType = #dk_all | (limitType = mo defKind)].	bool ifFalse: [self withAllSuperiors do: [:mo | res addAll: (mo					lookupName: aSymbol					levels: 1					limit: limitType					excludeInherited: true)]].	^res</body></methods><methods><class-id>Opentalk.DSTMetaContainer</class-id> <category>accessing - private</category><body package="Opentalk-IDL-MetaObjects">allSuperiors	"modules have no superiors"	^#()</body><body package="Opentalk-IDL-MetaObjects">contents	"return the container's contents array."	^contents</body><body package="Opentalk-IDL-MetaObjects">definedIn: aMetaObject 	"set the receiver's defining container meta object"	super definedIn: aMetaObject.	contents do: [:mo | mo definedIn: self]</body><body package="Opentalk-IDL-MetaObjects">definingMetaContainer	"return the meta container which contains the receiver"	^self</body><body package="Opentalk-IDL-MetaObjects">definition: aStringArray 	"set the definition of the receiver.  Do nothing, as it has already been set"</body><body package="Opentalk-IDL-MetaObjects">symbols	"return the container's symbol dictionary."	^symbols</body><body package="Opentalk-IDL-MetaObjects">withAllSuperiors	"modules have no superiors"	^#()</body></methods><methods><class-id>Opentalk.DSTMetaContainer</class-id> <category>repository</category><body package="Opentalk-IDL-MetaObjects">CORBAName	"return the name of my CORBA interface in the repository"	^#'::CORBA::Container'</body><body package="Opentalk-IDL-MetaObjects">addMetaObject: aMetaObject 	"add the meta-object to the container"	contents add: aMetaObject.	self registerMetaObject: aMetaObject.	aMetaObject definedInOnly: self</body><body package="Opentalk-IDL-MetaObjects">allMetaObjectsInto: aSet	"add all of the contained metaobjects to the set"	super allMetaObjectsInto: aSet.	contents do: [:mo | mo allMetaObjectsInto: aSet].</body><body package="Opentalk-IDL-MetaObjects">interfaceOf: aSymbol 	"Return an instance which has the given print name symbol. Error if 	not" 	| if |	aSymbol == NCSuuid nilId ifTrue: [^nil].	if := self metaObjectOf: aSymbol.	if isNil ifTrue: [^nil].			DSTmoduleRepository convenientNameResolution		ifFalse: 			[(if isDSTMetaObject)				ifTrue: [if := Set with: if].			^if inject: Set new				into: 					[:result :mo | 					| m |					m := mo equivalentType.					result add: m; yourself]]		ifTrue: 			[if := if equivalentType.			(if isDSTMetaObject and: [if isDSTinterface])				ifTrue: [^if]				ifFalse: [self class intfReposError: 0]]</body><body package="Opentalk-IDL-MetaObjects">referencedMetaContainers	"return the other modules or interfaces which are referenced by the 	receiver. Used to generate automatic include declarations for printed 	output to be compiled by other IDL compilers"	| rmo metas res |	rmo := Set new.	metas := Set new.	self allMetaObjectsInto: metas.	metas		do: 			[:mo | 			(mo isDSTMetaObject and: [mo isDSTinterface])				ifTrue: [mo allSuperiors do: [:sup | rmo add: sup definingMetaObject]].			mo class == DSTtypeNamed ifTrue: [rmo add: mo equivalentType definingMetaObject]].	res := rmo - (Set with: self) - (Set withAll: contents).	metas do: [:mo | (mo class == DSTtypeNamed 			and: [(res includes: mo equivalentType definingMetaObject)				&amp; (mo printName first ~= $:)])			ifTrue: [Transcript show: '**Warning: ' , mo printName , ' in ' , mo definingMetaObject printName , ' is a non-local reference'; cr]].	^res</body><body package="Opentalk-IDL-MetaObjects">registerMetaObject: aMetaObject 	"register the meta-object in the symbol table of the receiver"	| id na |	id := aMetaObject repositoryId.	aMetaObject declarators		do: 			[:decl | 			na := decl printName.			(self checkForCollision: na)				ifTrue: [^Dialog notify: 'Name redefinition "' , na , '" in ' , self printName].			symbols at: na asSymbol put: decl].	id notNil ifTrue: [symbols at: id put: aMetaObject]</body><body package="Opentalk-IDL-MetaObjects">removeContained: aMetaObject	self contents notNil ifTrue: [self contents remove: aMetaObject ifAbsent: []]</body><body package="Opentalk-IDL-MetaObjects">removeMetaObject	"Enable the receiver to be garbage collected"	super removeMetaObject.	definedIn := contents := symbols := nil</body><body package="Opentalk-IDL-MetaObjects">requiredUnitsOfCompilationInto: aSet 	"add the units of compilation (i.e. meta objects like modules or 	interfaces 	which are linked to a selector of the repository class) which are 	required 	by the receiver to aSet"	| metas unit |	(aSet includes: (unit := self unitOfCompilation))		ifFalse: 			[aSet add: unit.			unit requiredUnitsOfCompilationInto: aSet]		ifTrue: 			[metas := Set new: contents size + 1.			self allMetaObjectsInto: metas.			metas do: [:mo | mo isDSTMetaObject					ifTrue: 						[mo isDSTinterface ifTrue: [mo allSuperiors do: [:sup | (aSet includes: (unit := sup unitOfCompilation))									ifFalse: 										[aSet add: unit.										unit requiredUnitsOfCompilationInto: aSet]]].						mo isDSTtypeNamed ifTrue: [(aSet includes: (unit := mo equivalentType unitOfCompilation))								ifFalse: 									[aSet add: unit.									unit requiredUnitsOfCompilationInto: aSet]].						mo isDSToperation ifTrue: [mo exceptions do: [:ex | (aSet includes: (unit := ex unitOfCompilation))									ifFalse: 										[aSet add: unit.										unit requiredUnitsOfCompilationInto: aSet]]]]]]</body><body package="Opentalk-IDL-MetaObjects">typeOf: aSymbol 	"return the type object which is associated with the given identifier"	| mo |	mo := self metaObjectOf: aSymbol.	mo isNil ifTrue: [Dialog notify: '"' , aSymbol , '" is not defined in the scope of "' , self definingMetaObject printName , '"'].	[mo isDSTMetaObject and: [mo isDSTdeclaratorSimple]]				whileTrue: [mo := mo baseType].	^(mo isDSTMetaObject and: [mo isDSTtype])		ifTrue: [mo]		ifFalse: [self class intfReposError: 0]</body><body package="Opentalk-IDL-MetaObjects">unRegisterMetaObject: aMetaObject 	"unregister the meta-object from the symbol table of the receiver"	| id na |	id := aMetaObject repositoryId.	aMetaObject declarators		do: 			[:decl | 			na := decl printName asSymbol.			(symbols keys includes: na)				ifTrue: [symbols removeKey: na]].	id notNil ifTrue: [symbols removeKey: id]</body><body package="Opentalk-IDL-MetaObjects">unlinkFromRepository	"The receiver is being removed from the repository. Unlink as 	required"	super unlinkFromRepository.	contents := symbols := nil</body></methods><methods><class-id>Opentalk.DSTMetaContainer</class-id> <category>rendering</category><body package="Opentalk-IDL-MetaObjects">hasComponents	"return true iff I have components worthwhile to show in a browser 	window"	^self allComponents isEmpty not</body></methods><methods><class-id>Opentalk.DSTMetaContainer</class-id> <category>private</category><body package="Opentalk-IDL-MetaObjects">checkForCollision: aName 	"Check to see if aName is already in the container. Do a case 	insensitive check."	symbols keysDo: [:n | n isSymbol ifTrue: [n asString asUppercase = aName asUppercase ifTrue: [^true]]].	^false</body><body package="Opentalk-IDL-MetaObjects">components: aString 	"Break a scoped name into its base components."	"Slash as temporary separator is inherited from a previous	implementation that used UnixFilename to divide components."	| components separator compSeparator compString stream |	separator := $/.	compSeparator := '::'.	compString := aString copyReplaceAll: compSeparator with: (String with: separator).	components := OrderedCollection new.	stream := compString readStream.	(stream peekFor: separator)		ifTrue: [components add: compSeparator asSymbol].	[stream atEnd]		whileFalse: [components add: (stream upTo: separator) asSymbol].	^components</body></methods><methods><class-id>Opentalk.DSTMetaContainer</class-id> <category>testing</category><body package="Opentalk-IDL-MetaObjects">IIOPIsA: aRepositoryId	aRepositoryId asString = 'IDL:CORBA/Container:1.0' ifTrue:[^true].	^super IIOPIsA: aRepositoryId</body><body package="Opentalk-IDL-MetaObjects">isDSTMetaContainer	^true</body></methods><methods><class-id>Opentalk.DSTMetaContainer</class-id> <category>accessing</category><body package="Opentalk-IDL-MetaObjects">exceptions	"return the receiver's exceptions"	contents isNil ifTrue: [^#()].	^contents select: [:obj | obj isDSTMetaObject and: [obj isDSTexception]]</body></methods><methods><class-id>Opentalk.DSTinterface</class-id> <category>repository</category><body package="Opentalk-IDL-MetaObjects">CORBAName	"return the name of my CORBA interface in the repository"	^#'::CompoundDefs::InterfaceCompoundDef'</body><body package="Opentalk-IDL-MetaObjects">canApplyPragma: pragma 	"Check to see if the argument pragma can be applied to the receiver."	^#(#ID #VERSION) includes: pragma</body><body package="Opentalk-IDL-MetaObjects">checkReferencesUniqueness	"check if all referenced superiors can be resolved uniquely" 		[DSTmoduleRepository convenientNameResolution: false.	sunames asSet		do: 			[:na | 			| ref |			ref := self definingMetaObject interfaceOf: na.			ref size &gt; 1 ifTrue: [Dialog notify: 'Interface ''' , self printName , ''' inherits from ambiguous ''' , na asString , '''']]]		ensure: [DSTmoduleRepository convenientNameResolution: true]</body><body package="Opentalk-IDL-MetaObjects">defKind        "Return the definition kind."        ^#dk_Interface</body><body package="Opentalk-IDL-MetaObjects">metaObjectOf: aSymbol 	"return the meta object which is associated with the given identifier"	| res |	^symbols at: aSymbol		ifAbsent: 			[self allSuperiors do: [:if | (res := if searchScopeFor: aSymbol) notNil ifTrue: [^res]].			^self definingMetaObject metaObjectOf: aSymbol]</body><body package="Opentalk-IDL-MetaObjects">removeMetaObject	"Enable the receiver to be garbage collected"	super removeMetaObject.	self superiors do: [:sup | sup removeSubordinate: self].	self subordinates do: [:sub | sub removeSuperior: self].	superiors := subordinates := epv := allOperations := myOperations := nil.	sunames := #()</body><body package="Opentalk-IDL-MetaObjects">resetInheritance	"reset instance variables related to inheritance"	subordinates := Set new.	superiors := Set new.	allOperations := myOperations := allSuperiors := nil.</body><body package="Opentalk-IDL-MetaObjects">searchScopeFor: aSymbol 	"return the meta object which is associated with the given identifier"	| str x head tail |	str := aSymbol asString.	x := str findFirst: [:ch | ch = $:].	x isZero		ifTrue: [^symbols at: aSymbol ifAbsent: [nil]]		ifFalse: 			[x = 1 ifTrue: [^nil].			head := str copyFrom: 1 to: x - 1.			tail := str copyFrom: x + 2 to: str size.			^(symbols at: head asSymbol ifAbsent: [^nil])				searchScopeFor: tail asSymbol].	^nil</body><body package="Opentalk-IDL-MetaObjects">setInheritance	"resolve inheritance references to named interfaces in the repository" 	superiors := sunames asSet collect: [:na | self definingMetaObject interfaceOf: na].	superiors do: [:if | if addSubordinate: self].	repositoryId isNil ifTrue: [ self repositoryId].	RepositoryCache at: repositoryId put: self.</body><body package="Opentalk-IDL-MetaObjects">unlinkFromRepository	"The receiver is being removed from the repository. Unlink as 	required"	super unlinkFromRepository.	self superiors do: [:sup | sup removeSubordinate: self].	self subordinates do: [:sub | sub removeSuperior: self].	superiors := subordinates := epv := allOperations := myOperations := nil.	sunames := #().	"IIOPObjRef withAllSubclasses do: [:cl | cl allInstances do: [:inst | inst clearInterfaceReferencesTo: self]]"</body></methods><methods><class-id>Opentalk.DSTinterface</class-id> <category>searching</category><body package="Opentalk-IDL-MetaObjects">allAttributes	"returns an ordered collection of all of the attributes defined by the 	receiver and its direct supertypes"	| allAttributes |	allAttributes := OrderedCollection new.	self withAllSuperiors do: [:if | allAttributes addAll: if attributes].	^allAttributes</body><body package="Opentalk-IDL-MetaObjects">allAttributes: oList avoiding: iSet 	"returns an ordered collection of all of the attributes defined by the 	receiver and its direct supertypes. Add the receiver to the set and do not 	revisit any IFs in that set"	iSet add: self.	self attributes do: [:op | oList add: op].	superiors do: [:su | (iSet includes: su)			ifFalse: [su allAttributes: oList avoiding: iSet]]</body><body package="Opentalk-IDL-MetaObjects">allOperations	"returns an ordered collection of all of the operations defined by the 	receiver and its direct supertypes"	| ifs | 	^allOperations notNil		ifTrue: [allOperations]		ifFalse: 			[allOperations := OrderedCollection new.			ifs := self withAllSuperiors.			ifs do: [:if | allOperations addAll: if operations].			allOperations]</body><body package="Opentalk-IDL-MetaObjects">allOperations: oList avoiding: iSet 	"returns an ordered collection of all of the operations defined by the 	receiver and its direct supertypes. Add the receiver to the set and do not 	revisit any IFs in that set"	iSet add: self.	self operations do: [:op | oList add: op].	superiors do: [:su | (iSet includes: su)			ifFalse: [su allOperations: oList avoiding: iSet]]</body><body package="Opentalk-IDL-MetaObjects">findOpByIndex: index 	"find the DSToperation by its index in the interface. Return an 	array with the operation and its local opSelector"	| op ops | 	ops := self entryPointVector.	(index between: 0 and: ops size - 1) ifFalse: [self class badOperationError: 0].	op := self operations at: (ops at: index + 1).	^Array with: op with: op localOp</body><body package="Opentalk-IDL-MetaObjects">findOpByIndex: index version: requestedVersion 	"Find the operation by its index in the interface. Raise an exception if the 	index is invalid or if requestedVersion is not compatible (greater than) the 	version of the receiver. Return an array with the operation and its local 	opSelector"	| result |	result := self findOpByIndex: index.	self version &lt; requestedVersion ifTrue: [self class badOperationError: #'M_IF_VERSION_MISMATCH'].	^result</body><body package="Opentalk-IDL-MetaObjects">findOpByName: aString 	"find the DSToperation by its name in the interface. Return an 	array with the operation and its local opSelector"	| sym |	sym := aString asSymbol.	^self allOperations detect: [:oper | oper name == sym] ifNone: [nil]		"ifNone: [self findOpByName: sym forInterface: (DSTORBObject lookupMetaId: #'SmalltalkSpecific::SmalltalkObject')]"</body><body package="Opentalk-IDL-MetaObjects">findOpBySelector: opSelector	"... find the DSToperation in the interface by its selector.  Return an OperationInfo object."	| op |	op := self findOpInMyVector: opSelector.	op isNil		ifTrue: [self allSuperiors do: [:sup | (op := sup findOpInMyVector: opSelector) notNil ifTrue: [^op asOperationInfo]]]		ifFalse: [^op asOperationInfo].	^nil "DSTModules i3 newOperationInfoForInterface: self selector: opSelector"</body><body package="Opentalk-IDL-MetaObjects">findOpInMyVector: opSelector 	"find the DSToperation in the this interface by its selector. Return an 	Operation object"	 	^self operations at: opSelector ifAbsent: [nil]</body><body package="Opentalk-IDL-MetaObjects">findOpInSubordinate: opSelector avoiding: iSet 	"find the DSToperation in the interface by its selector. Return an array with: 	#(theInterface theOperation theOpSelector theOpIndex)"	| if ar |	iSet add: self.	self allOperations do: [:op | op localOp == opSelector ifTrue: [^Array				with: (if := op definingMetaContainer)				with: op				with: opSelector				with: (if entryPointVector indexOf: opSelector)						- 1				with: self]].	subordinates do: [:sub | (iSet includes: sub)			ifFalse: 				[ar := sub findOpInSubordinate: opSelector avoiding: iSet.				ar notNil ifTrue: [^ar]]].	^nil</body></methods><methods><class-id>Opentalk.DSTinterface</class-id> <category>accessing</category><body package="Opentalk-IDL-MetaObjects">addSubordinate: anInterface 	"private - add a subordinate DSTinterface to the interface, at the end of the 	list"	anInterface isDSTinterface		ifTrue: [(self subordinates includes: anInterface)				ifFalse: [self subordinates add: anInterface]]		ifFalse: [self error: 'Can only add interfaces as subordinates']</body><body package="Opentalk-IDL-MetaObjects">allSubordinatesAvoiding: iSet "Return the transitive closure of the receiver's superiors. Avoid recursing to the members of the iSet"	iSet add: self.	self subordinates do: [:if |		(iSet includes: if) ifFalse: [			if allSubordinatesAvoiding: iSet]].	^iSet</body><body package="Opentalk-IDL-MetaObjects">allSuperiors	"return the transitive closure of the receiver's superiors"	allSuperiors isNil		ifTrue: 			[(name == #SharedInterfaceRepository and: [self class remoteRepository notNil])				ifTrue: [allSuperiors := Set new]				ifFalse: [allSuperiors := Set with: (DSTORBObject lookupInterfaceId: #'::CORBA::Object')].			superiors do: [:if | if allSuperiorsAvoiding: allSuperiors]].	^allSuperiors</body><body package="Opentalk-IDL-MetaObjects">allSuperiorsAvoiding: iSet 	"return the transitive closure of the receiver's superiors. Avoid 	recursing to the members of the set"	iSet add: self.	superiors do: [:if | (iSet includes: if)			ifFalse: [if allSuperiorsAvoiding: iSet]]</body><body package="Opentalk-IDL-MetaObjects">attributes	"return the receiver's attributes"	contents isNil ifTrue: [^#()].	^contents select: [:obj | obj isDSTMetaObject and: [obj isDSTattribute]]</body><body package="Opentalk-IDL-MetaObjects">entryPointVector	"return the epv of the receiver"	epv isNil		ifTrue: 			[epv := OrderedCollection new.			contents				do: 					[:co | 					(co isDSTMetaObject and: [co isDSTattribute])						ifTrue: 							[epv addAll: (co getOperations collect: [:op | op localOp]).							epv addAll: (co setOperations collect: [:op | op localOp])].					co class == DSToperation ifTrue: [epv add: co localOp]]].	^epv</body><body package="Opentalk-IDL-MetaObjects">fullEntryPointVector	"return the complete epv of the receiver"	| res ifs |	res := OrderedCollection new.	ifs := self withAllSuperiors.	ifs do: [:if | res addAll: if entryPointVector].	^res</body><body package="Opentalk-IDL-MetaObjects">grandSuperiors	"return the receiver's non-immediate superiors"	^self allSuperiors - self superiors</body><body package="Opentalk-IDL-MetaObjects">operations	"return the receiver's operations"	| ops |	^myOperations		ifNil: 			[contents isNil ifTrue: [myOperations := IdentityDictionary new].			ops := IdentityDictionary new.			contents				do: 					[:obj | 					(obj isDSTMetaObject and: [obj isDSToperation])						ifTrue: [ops at: obj localOp put: obj].					(obj isDSTMetaObject and: [obj isDSTattribute])						ifTrue: 							[obj getOperations do: [:getOp | ops at: getOp localOp put: getOp].							obj setOperations do: [:setOp | ops at: setOp localOp put: setOp]]].			myOperations := ops]</body><body package="Opentalk-IDL-MetaObjects">removeSubordinate: anInterface 	"private - remove a subordinate DSTinterface from the interface"	subordinates notNil ifTrue: [subordinates remove: anInterface ifAbsent: []]</body><body package="Opentalk-IDL-MetaObjects">removeSuperior: anInterface 	"private - remove a superior DSTinterface from the interface"	superiors remove: anInterface ifAbsent: [].	allSuperiors := nil.	self subordinates do: [:sub | sub removeSuperior: anInterface].</body><body package="Opentalk-IDL-MetaObjects">resolveLocalTypesIn: aType 	"Called by typeAny to get any local type symbols which relate to the 	receiver in its scope. Currently, only structures have sufficent 	information to be able to resolve.  Do nothing here"</body><body package="Opentalk-IDL-MetaObjects">subordinates	"return the receiver's immediate subordinates"	subordinates isNil ifTrue: [subordinates := OrderedCollection new].	^subordinates</body><body package="Opentalk-IDL-MetaObjects">subordinates: aCollection	"set the receiver's immediate subordinates"	subordinates := aCollection</body><body package="Opentalk-IDL-MetaObjects">sunames	"return the receiver's immediate sunames"	sunames isNil ifTrue: [^#()].	^sunames</body><body package="Opentalk-IDL-MetaObjects">superiors	"return the receiver's immediate superiors"	superiors isNil ifTrue: [superiors := Set new].	^superiors</body><body package="Opentalk-IDL-MetaObjects">superiors: aSet	"set the receiver's immediate superiors"	superiors := aSet</body><body package="Opentalk-IDL-MetaObjects">withAllSubordinates"return the transitive closure of the receiver's subordinates"	^self allSubordinatesAvoiding: Set new</body><body package="Opentalk-IDL-MetaObjects">withAllSuperiors	"return the transitive closure of the receiver's superiors"		| sup |	sup := Set new: (self allSuperiors size + 1).	sup add: self.	sup addAll: self allSuperiors.	^sup</body></methods><methods><class-id>Opentalk.DSTinterface</class-id> <category>printing</category><body package="Opentalk-IDL-MetaObjects">IDLTypeName	"return the printable name of the receiver's IDL type ie the type to be	actually marshalled in the NCS packet"	^name</body><body package="Opentalk-IDL-MetaObjects">hasPragma	"return true if the receiver has a pragma string"	^true</body><body package="Opentalk-IDL-MetaObjects">printDefinitionOn: aStream indent: level style: aTextStyleName 	"Print the IDL definition of the receiver onto the stream."	"Since the default Parser class is used to parse the selector of IDL 	units, it 	is important that the first token of an IDL 'method' is parsed 	correctly by 	Parser. Specifically, it must be avoided that the pound sign is the 	first 	character in the method, since it would cause a parsing problem. 	Therefore we show pragmas AFTER the comment lines and we also 	make 	sure that there is always at least one comment line. Also note, that 	senders of Parser&gt;&gt;parseSelector: (such as 	Text&gt;&gt;makeSelectorBoldIn:) 	assume that the selector starts at position 1 of the method source."	self printHeaderOn: aStream indent: level.	prefix isNil ifFalse: [CurrentPrefix ~= prefix prefixString			ifTrue: 				[aStream tab: level; nextPutAll: '#pragma  prefix '; nextPut: $"; nextPutAll:  prefix prefixString; nextPut: $"; cr.				CurrentPrefix := prefix prefixString]]. 	(repositoryId isNil not and: [repositoryId ~= self generateRepositoryId])		ifTrue: [aStream tab: level; nextPutAll: '#pragma  ID '; nextPutAll: self printName; space; nextPut: $"; nextPutAll: repositoryId asString; nextPut: $"; cr].	version notNil ifTrue: [aStream tab: level; nextPutAll: '#pragma  version '; nextPutAll: self printName; space; nextPutAll: version; cr].	self		printInterfaceHeaderOn: aStream		indent: level		style: aTextStyleName.	self printODLHeaderOn: aStream level: level.	aStream nextPut: ${.	contents isEmpty		ifFalse: 			[aStream cr; cr.			(1 to: contents size)				do: 					[:i | 					(i &gt; 1 and: [(contents at: i - 1) wantsSpace or: [(contents at: i) wantsSpace]])						ifTrue: [aStream cr].					(contents at: i)						printDefinitionOn: aStream						indent: level + 1						style: aTextStyleName].			aStream tab: level].	aStream nextPutAll: '};'; cr</body><body package="Opentalk-IDL-MetaObjects">printInterfaceHeaderOn: aStream indent: level style: aTextStyleName 	"print the name and the superiors of the receiver"	| tempStream su |	tempStream := (String new: 80) writeStream.	tempStream nextPutAll: 'interface '; nextPutAll: name asString.	su := sunames asOrderedCollection.	su remove: #Object ifAbsent: [].	su isEmpty		ifFalse: 			[tempStream nextPutAll: ' : '.			(1 to: su size - 1)				do: [:i | tempStream nextPutAll: (su at: i) asString; nextPutAll: ', '].			tempStream nextPutAll: su last asString].	aStream tab: level.	(self		stringNeedsFormatting: tempStream contents		indent: level		style: aTextStyleName)		&amp; su isEmpty not ifFalse: [aStream nextPutAll: tempStream contents; nextPut: $ ]		ifTrue: 			[aStream nextPutAll: 'interface '; nextPutAll: name asString; nextPutAll: ' :'.			(1 to: su size - 1)				do: [:i | aStream crtab: level + 4; nextPutAll: (su at: i) asString; nextPutAll: ', '].			aStream crtab: level + 4; nextPutAll: su last asString; crtab: level]</body><body package="Opentalk-IDL-MetaObjects">printODLHeaderOn: aStream level: level 	"print ODL extent and key information if it is present"	| last |	extent notNil | key notNil		ifTrue: 			[aStream cr; tab: level; nextPut: $(; tab.			extent notNil ifTrue: [aStream nextPutAll: 'extent'; tab; nextPutAll: extent; cr; tab: level + 1].			key isEmpty				ifFalse: 					[(key isMemberOf: Array)						ifTrue: [aStream nextPutAll: 'keys'; tab]						ifFalse: [aStream nextPutAll: 'key'; tab].					last := key at: key size.					key						do: 							[:k | 							(k isMemberOf: Array)								ifTrue: 									[aStream nextPut: $(; nextPutAll: (k at: 1).									2 to: k size do: [:i | aStream nextPutAll: ', '; nextPutAll: (k at: i)].									aStream nextPut: $)]								ifFalse: [aStream nextPutAll: k].							k == last ifFalse: [aStream nextPutAll: ', ']]].			aStream nextPut: $); cr; tab: level]</body><body package="Opentalk-IDL-MetaObjects">printOn: aStream	"print the receiver's printname on the stream"	aStream nextPutAll: 'interface ' , self idlName</body><body package="Opentalk-IDL-MetaObjects">publishDefinitionOn: aStream indent: level style: aTextStyleName 	"print the IDL definition of the receiver onto the stream, with no pragmas"	self printHeaderOn: aStream indent: level.	self		printInterfaceHeaderOn: aStream		indent: level		style: aTextStyleName.	self printODLHeaderOn: aStream level: level.	aStream nextPut: ${.	contents isEmpty		ifFalse: 			[aStream cr; cr.			(1 to: contents size)				do: 					[:i | 					(i &gt; 1 and: [(contents at: i - 1) wantsSpace or: [(contents at: i) wantsSpace]])						ifTrue: [aStream cr].					(contents at: i)						publishDefinitionOn: aStream						indent: level + 1						style: aTextStyleName].			aStream tab: level].	aStream nextPutAll: '};'; cr</body></methods><methods><class-id>Opentalk.DSTinterface</class-id> <category>initializing</category><body package="Opentalk-IDL-MetaObjects">initialize	"private - initialize the instance variables of the receiver"	super initialize.	contents := OrderedCollection new.	superiors := Set new.	subordinates := Set new.	symbols := Dictionary new</body><body package="Opentalk-IDL-MetaObjects">n: aName s: supers d: aDescr b: aBody 	"private - initialize the instance variables: 	name = a printable name symbol 	definition = a printable description of the interface 	contents = an ordered collection of constants, types, attributes, 	operations, and events 	superiors = a set of DST interfaces"	aName isSymbol		ifFalse: [self error: 'Print name must be a symbol'].	repositoryId := nil.	name := aName.	definition := aDescr.	contents := aBody asOrderedCollection.	superiors := Set new.	subordinates := Set new.	sunames := supers.	aBody		do: 			[:bod | 			bod definedIn: self.			self registerMetaObject: bod]</body></methods><methods><class-id>Opentalk.DSTinterface</class-id> <category>generation</category><body package="Opentalk-IDL-MetaObjects">generateClassAttributes: override 	"generate and compile Smalltalk method definitions for my attributes"	| aStream param aname aClass |	aClass := name asQualifiedReference valueOrDo: [override or: [self generateClassDef]].	aStream := String new writeStream.	self attributes		do: 			[:attr | 			aname := self convertSymbol: attr printName.			attr getOperations do: [:op | (override or: [(aClass includesSelector: op localOp) not])					ifTrue: 						[aStream nextPutAll: '!' , name , ' methodsFor: ''attributes''!'; cr.						aStream nextPutAll: op localOp; cr.						aStream tab; nextPutAll: '"get the value of the attribute"'; cr.						aStream cr; tab; nextPutAll: '^' , aname , ' ! !'; cr; cr]].			attr setOperations do: [:op | (override or: [(aClass includesSelector: op localOp) not])					ifTrue: 						[aStream nextPutAll: '!' , name , ' methodsFor: ''attributes''!'; cr.						param := self convertSymbol: 'a_' , op signature inParameters first type printName.						aStream nextPutAll: op localOp; nextPutAll: ' ' , param; cr.						aStream tab; nextPutAll: '"set the value of the attribute"'; cr.						aStream cr; tab; nextPutAll: aname , ' := ' , param , '.'; cr.						aStream tab; nextPutAll: 'self changed: #' , aname , ' with: self.'; cr.						aStream nextPutAll: ' ! !'; cr; cr]]].	^aStream contents</body><body package="Opentalk-IDL-MetaObjects">generateClassDef	"generate and compile a Smalltalk class definition with my name"	(self generateClassDefinition: true) readStream fileIn.	^name asQualifiedReference value</body><body package="Opentalk-IDL-MetaObjects">generateClassDefinition: override 	"generate and compile a Smalltalk class definition with my name"	| instvars aClass superclass category aStream |	instvars := ''.	self attributes do: [:attr | instvars := instvars , ' ' , (self convertSymbol: attr printName)].	aClass :=name asQualifiedReference valueOrDo: [].	aClass isNil		ifTrue: 			[superclass := Object.			category := 'IDL-Classes']		ifFalse: 			[override ifFalse: [^''].			superclass := aClass superclass.			category := aClass category].	aStream := String new writeStream.	aStream nextPutAll: superclass name , ' subclass: #' , name , '	instanceVariableNames: ''' , instvars , '''	classVariableNames: ''''	poolDictionaries: ''''	category: ''' , category , ''' !'; cr.	^aStream contents</body><body package="Opentalk-IDL-MetaObjects">generateClassOperations: override	"generate and compile Smalltalk method definitions for my operations"	| aStream opstr typ parmBag sym aClass |	aClass := name asQualifiedReference valueOrDo: [override or: [self generateClassDef]].	aStream := String new writeStream.	(contents select: [:obj | obj isDSTMetaObject and: [obj isDSToperation]])		do: [:op | (override or: [(aClass includesSelector: op localOp) not])				ifTrue: 					[parmBag := Bag new.					aStream nextPutAll: '!' , name , ' methodsFor: ''' , self printName , '''!'; cr.					opstr := op localOp asString readStream.					aStream nextPutAll: (opstr upTo: $:).					op signature inParameters						do: 							[:parm | 							aStream nextPut: $:; nextPut: $ .							typ := parm type printName replaceAll: $  with: $_.							sym := self convertSymbol: 'a_' , typ.							parmBag add: sym.							(parmBag occurrencesOf: sym)								= 1 ifFalse: [sym := sym asString , (parmBag occurrencesOf: sym) asString].							aStream nextPutAll: sym.							aStream nextPut: $ ; nextPutAll: (opstr upTo: $:)].					aStream cr; nextPut: $".					op publishDefinitionOn: aStream indent: 1 style: #default.					aStream nextPut: $"; cr; tab; nextPutAll: '^self   ! !'; cr; cr]].	^aStream contents</body><body package="Opentalk-IDL-MetaObjects">generateClassSkeleton: override	"generate and compile a Smalltalk class skeleton with my name"	| aStream |	aStream := String new writeStream.	aStream nextPutAll: (self generateClassDefinition: override); cr; cr.	aStream nextPutAll: (self generateClassAttributes: override); cr; cr.	aStream nextPutAll: (self generateClassOperations: override); cr; cr.	^aStream contents</body><body package="Opentalk-IDL-MetaObjects">generateRelationship: rel addOp: op on: aStream 	"generate the addRelationship operation"	| param |	aStream nextPutAll: '!' , name , ' methodsFor: ''admin-relationships''!'; cr.	param := self convertSymbol: 'a_' , op signature inParameters first type equivalentType printName.	aStream nextPutAll: op localOp; nextPutAll: ' ' , param; cr.	aStream tab; nextPutAll: '"add a value to the relationship"'; cr; cr.	aStream tab; nextPutAll: 'self ' , rel printName , ' add: ' , param , '.'; cr.	aStream tab; nextPutAll: 'self changed: #' , rel printName , ' with: self  ! !'; cr; cr</body><body package="Opentalk-IDL-MetaObjects">generateRelationship: rel assertOp: op on: aStream param: param 	"generate the assert operations on the relationship"	| inverse |	aStream nextPutAll: '!' , name , ' methodsFor: ''relationships''!'; cr.	aStream nextPutAll: op localOp; nextPutAll: ' ' , param; cr.	aStream tab; nextPutAll: '"form the relationship"'; cr; cr.	rel inverse isNil		ifFalse: 			[inverse := self metaObjectOf: rel inverse.			inverse isMultiValued				ifTrue: [aStream tab; nextPutAll: param , ' ' , inverse addOperation localOp , ' self.'; cr]				ifFalse: [aStream tab; nextPutAll: param , ' ' , inverse setOperation localOp , ' self.'; cr]].	rel isMultiValued		ifTrue: [aStream tab; nextPutAll: 'self ' , rel addOperation localOp , ' ' , param; cr]		ifFalse: [aStream tab; nextPutAll: 'self ' , rel setOperation localOp , ' ' , param; cr].	aStream cr</body><body package="Opentalk-IDL-MetaObjects">generateRelationship: rel getOp: op on: aStream 	"generate the getOp method for the class"	| reltype |	aStream nextPutAll: '!' , name , ' methodsFor: ''relationships''!'; cr.	aStream nextPutAll: op localOp; cr.	aStream tab; nextPutAll: '"get the value of the relationship"'; cr.	reltype := rel isMultiValued				ifTrue: [' := ' , (self convertSymbol: '_' , rel target printName) , ' new']				ifFalse: [''].	aStream cr; tab; nextPutAll: '^' , rel printName , ' ifNil: [' , rel printName , reltype , '] ! !'; cr; cr</body><body package="Opentalk-IDL-MetaObjects">generateRelationship: rel removeOp: op on: aStream 	"generate the remove operation on the relationship"	| param |	aStream nextPutAll: '!' , name , ' methodsFor: ''admin-relationships''!'; cr.	param := self convertSymbol: 'a_' , op signature inParameters first type equivalentType printName.	aStream nextPutAll: op localOp; nextPutAll: ' ' , param; cr.	aStream tab; nextPutAll: '"remove a value from the relationship"'; cr.	aStream cr; tab; nextPutAll: 'self ' , rel printName , ' remove: ' , param , '.'; cr.	aStream tab; nextPutAll: 'self changed: #' , rel printName , ' with: self.'; cr.	aStream nextPutAll: ' ! !'; cr; cr</body><body package="Opentalk-IDL-MetaObjects">generateRelationship: rel retractOp: op on: aStream param: param 	"generate the retract operations on the relationship"	| inverse |	aStream nextPutAll: '!' , name , ' methodsFor: ''relationships''!'; cr.	aStream nextPutAll: op localOp; nextPutAll: ' ' , param; cr.	aStream tab; nextPutAll: '"drop the relationship"'; cr; cr.	rel inverse isNil		ifFalse: 			[inverse := self metaObjectOf: rel inverse.			inverse isMultiValued				ifTrue: [aStream tab; nextPutAll: param , ' ' , inverse removeOperation localOp , ' self.'; cr]				ifFalse: [aStream tab; nextPutAll: param , ' ' , inverse setOperation localOp , ' nil.'; cr]].	rel isMultiValued		ifTrue: [aStream tab; nextPutAll: 'self ' , rel removeOperation localOp , ' ' , param; cr]		ifFalse: [aStream tab; nextPutAll: 'self ' , rel setOperation localOp , ' nil'; cr].	aStream cr</body><body package="Opentalk-IDL-MetaObjects">generateRelationship: rel setOp: op on: aStream 	"generate the set, assert, and retract operations on the relationship"	| param |	param := self convertSymbol: 'a_' , op signature inParameters first type printName.	('_form*' match: op printName asString)		ifTrue: [self				generateRelationship: rel				assertOp: op				on: aStream				param: param]		ifFalse: [('_drop*' match: op printName asString)				ifTrue: [self						generateRelationship: rel						retractOp: op						on: aStream						param: param]				ifFalse: 					[aStream nextPutAll: '!' , name , ' methodsFor: ''admin-relationships''!'; cr.					aStream nextPutAll: op localOp; nextPutAll: ' ' , param; cr.					aStream tab; nextPutAll: '"set the value of the relationship"'; cr.					aStream cr; tab; nextPutAll: rel printName , ' := ' , param , '.'; cr.					aStream tab; nextPutAll: 'self changed: #' , rel printName , ' with: self.'; cr]].	aStream nextPutAll: ' ! !'; cr; cr</body></methods><methods><class-id>Opentalk.DSTinterface</class-id> <category>InterfaceDef</category><body package="Opentalk-IDL-MetaObjects">baseInterfaceIds	"return the ids of the base interfaces of the receiver"	^self allSuperiors asOrderedCollection collect: [:if | if id]</body><body package="Opentalk-IDL-MetaObjects">baseInterfaces	"return the base interfaces of the receiver"	^self allSuperiors</body><body package="Opentalk-IDL-MetaObjects">baseInterfaces: interfaces 	"Setting baseInterfaces returns an error if the name attribute of any 	object contained by this interface conflicts with the name attribute 	of any object contained by any of the specified base interfaces."	self notYetImplemented</body><body package="Opentalk-IDL-MetaObjects">createAttribute: anId name: aName version: aVersion type: anIDLType mode: anAttributeMode 	"The createAttribute operation returns a new AttributeDef contained 	in the receiver. The id, name, version, type, and mode attributes are 	set as specified. The type attribute is also set. The definedIn 	attribute is initialized to identify the containing interface. An error is 	returned if an object with the specified id already exists within the 	receiver's repository, or if an object with the specified name already 	exists within this interface."	self notYetImplemented</body><body package="Opentalk-IDL-MetaObjects">createOperation: anId name: aName version: aVersion result: anIDLType mode: anOperationMode params: paramList exceptions: exceptionList contexts: contextList 	"The createOperation operation returns a new OperationDef 	contained in the receiver. The id, name, version, result, mode, 	params, exceptions, and context attributes are 	set as specified. The result attribute is also set. The definedIn 	attribute is initialized to identify the containing interface. An error is 	returned if an object with the specified id already exists within the 	receiver's repository, or if an object with the specified name already 	exists within this interface."	self notYetImplemented</body><body package="Opentalk-IDL-MetaObjects">describeImplementation	"returns a FullImplementationDescription struct"	^Dictionary		with: #name -&gt; name		with: #id -&gt; self id		with: #definedIn -&gt; self definingMetaObject id		with: #methods -&gt; self entryPointVector</body><body package="Opentalk-IDL-MetaObjects">describeInterface	"return a FullInterfaceDescription of the receiver"	^(Dictionary new)	add: #name -&gt; name;	add: #id -&gt; self id;	add: #definedIn -&gt; self definedInString;	add: #version -&gt; self version;	add: #operations -&gt; ((contents select: [:co | co isDSTMetaObject and: [co isDSToperation]])				collect: [:op | op description]);	add: #attributes -&gt; ((contents select: [:co | co isDSTMetaObject and: [co isDSTattribute]])				collect: [:at | at description]);	add: #baseInterfaces -&gt; self baseInterfaceIds;	add: #type -&gt; self;	yourself</body><body package="Opentalk-IDL-MetaObjects">description	"return an interface description"	^(Dictionary new) 		add: #name -&gt; name; 		add: #id -&gt; self id; 		add: #definedIn -&gt; self definedInString; 		add: #version -&gt; self version;		add: #baseInterfaces -&gt; self baseInterfaceIds;		yourself</body><body package="Opentalk-IDL-MetaObjects">isA: interfaceId 	"isA returns TRUE if the receiver is identical to or inherits, directly or 	indirectly, from the interface identified by the parameter. Otherwise 	it returns FALSE."	| targetId |	targetId := RepositoryId fromString: interfaceId.	self repositoryId == targetId ifTrue: [^true].	self allSuperiors do: [:sup | sup repositoryId == targetId ifTrue: [^true]].	^false</body></methods><methods><class-id>Opentalk.DSTinterface</class-id> <category>TypeCode</category><body package="Opentalk-IDL-MetaObjects">type	"return the type code of the receiver"	^self</body><body package="Opentalk-IDL-MetaObjects">typeKind	"return the TCKind of the receiver"	^#tk_objref</body><body package="Opentalk-IDL-MetaObjects">typeParamCount	"return the number of parameters which the receiver supports. 	Subtypes should overload as required"	^1</body><body package="Opentalk-IDL-MetaObjects">typeParameter: anInt	"return the nth parameter which the receiver supports. 	Subtypes should overload as required"	anInt = 1 ifTrue: [^repositoryId printString ].	self error: #Bounds</body></methods><methods><class-id>Opentalk.DSTinterface</class-id> <category>parcel support</category><body package="Opentalk-IDL-MetaObjects">storeGeneralStructureOn: aBinaryStorageWriter	"We need to cut of the subordinates of the dstInterface"	| save |	save :=  subordinates.	subordinates := nil.	super storeGeneralStructureOn: aBinaryStorageWriter.	subordinates := save.</body><body package="Opentalk-IDL-MetaObjects">traceFrom: aTracer 	aTracer doTraceOfDSTInterface: self</body></methods><methods><class-id>Opentalk.DSTinterface</class-id> <category>testing</category><body package="Opentalk-IDL-MetaObjects">IIOPIsA: aString	aString asString = 'IDL:CORBA/InterfaceDef:1.0' ifTrue:[^true].	^super IIOPIsA: aString</body><body package="Opentalk-IDL-MetaObjects">isAko: anInterface 	"succeed if anInterface is in my superiors list"	anInterface name == #Object		ifTrue: [^true]		ifFalse: [self withAllSuperiors do: [:if | if repositoryId == anInterface repositoryId ifTrue: [^true]]].	^false</body><body package="Opentalk-IDL-MetaObjects">isDSTinterface	^true</body></methods><methods><class-id>Opentalk.DSTinterface</class-id> <category>rendering</category><body package="Opentalk-IDL-MetaObjects">hasComponents	"return true iff I have components worthwhile to show in a browser 	window"	^self superiors isEmpty not or: [self allComponents isEmpty not]</body></methods><methods><class-id>Opentalk.DSTinterface</class-id> <category>private</category><body package="Opentalk-IDL-MetaObjects">findOpByName: aSymbol forInterface: anInterface	"... find the DSToperation by its name in the specified interface."	^anInterface class == self class		ifTrue: [anInterface allOperations				detect: [:oper | oper name == aSymbol]				ifNone: [nil "DSTModules i3 newOperationFor: aSymbol"]]		ifFalse: [nil]</body></methods><methods><class-id>Opentalk.DSTinterface</class-id> <category>Primitive Def</category><body package="Opentalk-IDL-MetaObjects">kind	"return the receiver's primitive type"	^#pk_objref</body></methods><methods><class-id>Opentalk.DSTinterface</class-id> <category>repository-private</category><body package="Opentalk-IDL-MetaObjects">canContain: kind 	"Check to see if the definition kind can be contained in the receiver."	^#(#dk_Constant #dk_Typedef #dk_Exception #dk_Attribute #dk_Operation) includes: kind</body></methods><methods><class-id>Opentalk.DSTinterface</class-id> <category>marshalling</category><body package="Opentalk-IDL-MetaObjects">boldMarshall: aParameter on: aStream 	"Marshall the parameter onto the stream"	(self canMarshall: aParameter)		ifTrue: [ aParameter isNil				ifTrue: [ aStream nextPutNullIOR ]				ifFalse: [					(aStream marshaler						export: aParameter						interfaceId: self repositoryId					) cdrWriteOn: aStream ] ]		ifFalse: [ self class marshallError: 0 ]</body><body package="Opentalk-IDL-MetaObjects">canMarshall: aParameter 	"return if the receiver can marshall the given parameter"	^	aParameter == nil or: [		name == #SmalltalkObject or: [		name == #ClassObject or: [		(aParameter corbaInterfaceIn: self repository) isAko: self]]]</body><body package="Opentalk-IDL-MetaObjects">marshallMatch: aParameter 	"Return:		true			- if I can marshall the parameter		false		- if I can NOT marshall the parameter		#mappable	- if I can marshall the parameter by mapping to something else"		aParameter == nil ifTrue: [^#mappable].	^	name == #SmalltalkObject or: [		name == #ClassObject or: [		(aParameter corbaInterfaceIn: self repository) isAko: self]]</body><body package="Opentalk-IDL-MetaObjects">marshallTypeCode: aDictionary on: aStream 	"marshall the type code of the receiver"	(self tryMarshallIndirectTypeCode: aDictionary on: aStream) ifTrue: [^self].	aStream nextPutUnsignedLong: self typeCode.	aStream nextPutEncapsulatedInOctets: [ :stream |		stream			nextPutASCIIString: self repositoryId asString;			nextPutASCIIString: self printName ]</body><body package="Opentalk-IDL-MetaObjects">unMarshall: aStream 	"Unmarshall a result from the stream and return an object of the 	appropriate class. Subclasses must overload"	| ref |	ref := IIOPObjRef cdrReadFrom: aStream.	^ref ifNotNil: [ aStream adaptor objectByRef: ref ]</body><body package="Opentalk-IDL-MetaObjects">unMarshallTypeCode: aDictionary from: aStream 	"unMarshall the type code of the receiver"	|  byteOrder |	aDictionary add: aStream position -&gt; self.	aStream nextUnsignedLong.	byteOrder := aStream byteOrder.	aStream byteOrder: aStream nextBoolean.	repositoryId := aStream nextASCIIString.	name := aStream nextASCIIString.	repositoryId isEmpty		ifTrue: [^self class badTypecodeError: 0]		ifFalse: [repositoryId := RepositoryId fromString: repositoryId].	aStream byteOrder: byteOrder</body></methods><methods><class-id>Opentalk.DSTtypeDouble</class-id> <category>repository</category><body package="Opentalk-IDL-MetaObjects">typeKind	"return the TCKind of the receiver"	^#tk_double</body></methods><methods><class-id>Opentalk.DSTtypeDouble</class-id> <category>Primitive Def</category><body package="Opentalk-IDL-MetaObjects">kind	"return the receiver's primitive type"	^#pk_double</body></methods><methods><class-id>Opentalk.DSTtypeDouble</class-id> <category>marshalling</category><body package="Opentalk-IDL-MetaObjects">boldMarshall: aParameter on: aStream 	"Marshall the parameter onto the stream"	"canMarshall not = MNU on asDouble"	aStream nextPutDouble: aParameter asDouble</body><body package="Opentalk-IDL-MetaObjects">marshallMatch: aParameter 	"Return:		true			- if I can marshall the parameter		false		- if I can NOT marshall the parameter		#mappable	- if I can marshall the parameter by mapping to something else"		^aParameter isKindOf: Number</body><body package="Opentalk-IDL-MetaObjects">unMarshall: aStream 	"Unmarshall a result from the stream and return an object of the 	appropriate class"	^aStream nextDouble</body></methods><methods><class-id>Opentalk.DSTtypeDouble</class-id> <category>initialization</category><body package="Opentalk-IDL-MetaObjects">initialize	"initialize the receiver"	super initialize.	name := 'double'</body></methods><methods><class-id>Opentalk.DSTattribute</class-id> <category>Attribute Def</category><body package="Opentalk-IDL-MetaObjects">description	"return an attribute description"	^(DSTattributeDescription new)		name: name;		id: self id;		definedIn: self definedInString;		version: self version; 		type: self type; 		mode: self mode;		yourself</body><body package="Opentalk-IDL-MetaObjects">mode	"return the mode of the receiver"	^readOnly		ifTrue: [#READONLY]		ifFalse: [#NORMAL]</body><body package="Opentalk-IDL-MetaObjects">mode: newMode 	"return the mode of the receiver"	self notYetImplemented</body><body package="Opentalk-IDL-MetaObjects">type	"The type attribute provides the typecode describing the type of this 	attribute."	^typeSpec equivalentType</body><body package="Opentalk-IDL-MetaObjects">typeDef	"The typeDef attribute identifies the object defining the type of this 	attribute."	^typeSpec equivalentType baseType</body><body package="Opentalk-IDL-MetaObjects">typeDef: anIDLType 	"Setting typeDef also updates the type attribute."	self notYetImplemented</body></methods><methods><class-id>Opentalk.DSTattribute</class-id> <category>accessing</category><body package="Opentalk-IDL-MetaObjects">definedIn: aMetaObject 	"set the receiver's defining container meta object"	super definedIn: aMetaObject.	self getOperations do: [:op | op definedIn: aMetaObject].	self setOperations do: [:op | op definedIn: aMetaObject].	typeSpec definedIn: aMetaObject</body><body package="Opentalk-IDL-MetaObjects">getOperations	"return the operation objects for the _get_attribute() operation"	^getOp ifNil: [getOp := typeSpec declarators collect: [:dec | DSToperation new						opSel: name						cxt: #()						evts: #()						params: DSTsignature new						id: ('_get_' , dec printName asString) asSymbol						type: typeSpec						attr: nil]]</body><body package="Opentalk-IDL-MetaObjects">isReadOnly	"return the read only state of the receiver"	^readOnly</body><body package="Opentalk-IDL-MetaObjects">setOperations	"return an operation object for the _set_attribute() operation"	^setOp ifNil: [setOp := readOnly					ifTrue: [#()]					ifFalse: [typeSpec declarators collect: [:dec | DSToperation new								opSel: (name asString , ':') asSymbol								cxt: #()								evts: #()								params: (DSTsignature with: (DSTparameter new											name: #new_value											type: typeSpec											direction: #IN))								id: ('_set_' , dec printName asString) asSymbol								type: DSTtypeVoid new								attr: nil]]]</body></methods><methods><class-id>Opentalk.DSTattribute</class-id> <category>repository</category><body package="Opentalk-IDL-MetaObjects">CORBAName	"return the name of my CORBA interface in the repository"	^#'::CORBA::AttributeDef'</body><body package="Opentalk-IDL-MetaObjects">allMetaObjectsInto: aSet 	"add all of the referenced metaobjects to the set"	super allMetaObjectsInto: aSet.	typeSpec allMetaObjectsInto: aSet.	self getOperations do: [:op | op allMetaObjectsInto: aSet].	self setOperations do: [:op | op allMetaObjectsInto: aSet]</body><body package="Opentalk-IDL-MetaObjects">canApplyPragma: pragma 	"Check to see if the argument pragma can be applied to the receiver."	^#(#ID #VERSION) includes: pragma</body><body package="Opentalk-IDL-MetaObjects">defKind        "Return the definition kind."        ^#dk_Attribute</body></methods><methods><class-id>Opentalk.DSTattribute</class-id> <category>testing</category><body package="Opentalk-IDL-MetaObjects">IIOPIsA: aRepositoryId	aRepositoryId asString = 'IDL:CORBA/AttributeDef:1.0' ifTrue:[^true].	^super IIOPIsA: aRepositoryId</body><body package="Opentalk-IDL-MetaObjects">isDSTattribute	^true</body></methods><methods><class-id>Opentalk.DSTattribute</class-id> <category>printing</category><body package="Opentalk-IDL-MetaObjects">printDefinitionOn: aStream indent: level style: aTextStyleName 	"print the IDL definition of the receiver on the stream"	self printCommentOn: aStream indent: level.	prefix isNil ifFalse: [CurrentPrefix ~= prefix prefixString			ifTrue: 				[aStream tab: level; nextPutAll: '#pragma  prefix '; nextPut: $"; nextPutAll: prefix prefixString; nextPut: $"; cr.				CurrentPrefix := prefix prefixString]].	(repositoryId isNil not and: [repositoryId ~= self generateRepositoryId])		ifTrue: [aStream tab: level; nextPutAll: '#pragma  ID '; nextPutAll: self printName; space; nextPut: $"; nextPutAll: repositoryId asString; nextPut: $"; cr].	version notNil ifTrue: [aStream tab: level; nextPutAll: '#pragma  version '; nextPutAll: self printName; space; nextPutAll: version; cr].	aStream tab: level.	readOnly ifTrue: [aStream nextPutAll: 'readonly '].	aStream nextPutAll: 'attribute '; nextPutAll: typeSpec definitionString; nextPut: $ ; nextPutAll: typeSpec declaratorString; nextPut: $;; cr</body><body package="Opentalk-IDL-MetaObjects">printOn: aStream	"print the receiver's printname on the stream"	aStream nextPutAll: 'attribute ' , self idlName</body></methods><methods><class-id>Opentalk.DSTattribute</class-id> <category>rendering</category><body package="Opentalk-IDL-MetaObjects">iconId	"Return the key to find my icon image in the installed icon dictionary"	^('DST' , (readOnly			ifTrue: ['R']			ifFalse: ['RW']) , 'attribute') asSymbol</body></methods><methods><class-id>Opentalk.DSTattribute</class-id> <category>initialization</category><body package="Opentalk-IDL-MetaObjects">r: bool t: aType 	"initialize the receiver"	readOnly := bool.	typeSpec := aType.	name := typeSpec declaratorString</body></methods><methods><class-id>Opentalk.DSTtypeVoid</class-id> <category>marshalling</category><body package="Opentalk-IDL-MetaObjects">boldMarshall: aParameter on: aStream 	"Marshall the parameter onto the stream. Do nothing"</body><body package="Opentalk-IDL-MetaObjects">marshallMatch: aParameter 	"Return:		true			- if I can marshall the parameter		false		- if I can NOT marshall the parameter		#mappable	- if I can marshall the parameter by mapping to something else"		^true</body><body package="Opentalk-IDL-MetaObjects">unMarshall: aStream 	"Unmarshall a result from the stream and return an object of the 	appropriate class. 	Do nothing"	^nil</body><body package="Opentalk-IDL-MetaObjects">unMarshallTypeCode: aDictionary from: aStream	"unmarshall the type code of the receiver - do nothing since there 	are no parameters and the TCkind has already been unmarshalled"	^self</body></methods><methods><class-id>Opentalk.DSTtypeVoid</class-id> <category>initialization</category><body package="Opentalk-IDL-MetaObjects">initialize	"initialize the receiver"	super initialize.	name := 'void'</body></methods><methods><class-id>Opentalk.DSTtypeVoid</class-id> <category>rendering</category><body package="Opentalk-IDL-MetaObjects">hasComponents	"return true iff I have components worthwhile to show in a browser 	window"	^false</body></methods><methods><class-id>Opentalk.DSTtypeVoid</class-id> <category>repository</category><body package="Opentalk-IDL-MetaObjects">CORBAName	"return the name of my CORBA interface in the repository"	^#'::CORBA::PrimitiveDef'</body><body package="Opentalk-IDL-MetaObjects">typeKind	"return the TCKind of the receiver"	^#tk_void</body></methods><methods><class-id>Opentalk.DSTtypeVoid</class-id> <category>Primitive Def</category><body package="Opentalk-IDL-MetaObjects">kind	"return the receiver's primitive type"	^#pk_void</body></methods><methods><class-id>Opentalk.DSTtypeVoid</class-id> <category>accessing</category><body package="Opentalk-IDL-MetaObjects">idlName	"return the receivers full qualified name"	^self definingMetaObject  idlName , '::' , self printName</body></methods><methods><class-id>Opentalk.DSTtypeVoid class</class-id> <category>instance creation</category><body package="Opentalk-IDL-MetaObjects">name: aName 	aName = 'void'		ifTrue: [^CachedTypeVoid]		ifFalse: [self class intfReposError: 0]</body></methods><methods><class-id>Opentalk.DSTtypeVoid class</class-id> <category>initialization</category><body package="Opentalk-IDL-MetaObjects">initialize	"DSTtypeVoid initialize"	CachedTypeVoid := DSTtypeVoid new</body></methods><methods><class-id>Opentalk.DSTsignature</class-id> <category>accessing</category><body package="Opentalk-IDL-MetaObjects">inParameters	"returns the parameters which are #in or #inout"	^ins ifNil: [ins := self select: [:p | p notOUT]]</body><body package="Opentalk-IDL-MetaObjects">nonTrivialSignature	"returns a copy of the receiver that does not include a void result. I.e. only 	meaningful results are included"	| c |	c := self copy.	c isEmpty ifTrue: [^c].	^c returnParameter isVoid		ifTrue: [c removeLast; yourself]		ifFalse: [c]</body><body package="Opentalk-IDL-MetaObjects">outParameters	"returns the parameters which are #out or #inout"	^outs		ifNil: 			[outs := self select: [:p | p notIN].			outs removeLast.			outs]</body><body package="Opentalk-IDL-MetaObjects">parameters	"return a signature without the result"	^params		ifNil: 			[params := self copy.			params isEmpty ifFalse: [params removeLast].			params]</body><body package="Opentalk-IDL-MetaObjects">returnParameter	"returns the return parameter of the signature, or nil if none"	^return ifNil: [return := self last]</body></methods><methods><class-id>Opentalk.DSTsignature</class-id> <category>printing</category><body package="Opentalk-IDL-MetaObjects">definitionString	"return a definition string for the parameters of the receiver"	| aStream |	self size = 1 ifTrue: [^''].	aStream := (String new: 80) writeStream.	aStream nextPutAll: self first definitionString.	2 to: self size - 1 do: [:i | aStream nextPutAll: ', '; nextPutAll: (self at: i) definitionString].	^aStream contents</body></methods><methods><class-id>Opentalk.DSTtypeStructure</class-id> <category>accessing</category><body package="Opentalk-IDL-MetaObjects">allFields	"Return an ordered collection of all my fields."	^allFields == nil		ifTrue: [allFields := fields inject: OrderedCollection new into: [:comps :mo | comps , mo declarators]]		ifFalse: [allFields]</body><body package="Opentalk-IDL-MetaObjects">computeSelectors	"re compute my selector caches"	| sel |	selector := ''.	readSelectors := OrderedCollection new.	writeSelectors := OrderedCollection new.	self allFields		do: 			[:fld | 			sel := fld convertedName.			readSelectors add: sel.			sel := sel asString , ':'.			writeSelectors add: sel asSymbol.			selector := selector , sel].	selector := selector asSymbol</body><body package="Opentalk-IDL-MetaObjects">definedIn: aMetaObject 	"set the receiver's defining container meta object"	super definedIn: aMetaObject.	fields do: [:ty | ty definedIn: self].</body><body package="Opentalk-IDL-MetaObjects">fields	"return the list of fields"	^fields</body><body package="Opentalk-IDL-MetaObjects">readSelectors	"Return an ordered collection of read selectors on my fields."	readSelectors == nil ifTrue: [self computeSelectors].	^readSelectors</body><body package="Opentalk-IDL-MetaObjects">resolveLocalTypesIn: aType 	"Called by typeAny to get any local type symbols which relate to the 	receiver in its scope. Find the receiver's typename in the 	context of the given type. If so, copy its localType to the receiver" 	| mo |  	mo := aType typeOf: name asSymbol.	mo notNil ifTrue: [self localType: mo localType].	fields do: [:fld | fld resolveLocalTypesIn: aType]</body><body package="Opentalk-IDL-MetaObjects">selector	"Return an ordered collection of all my fields."	selector == nil ifTrue: [self computeSelectors].	^selector</body><body package="Opentalk-IDL-MetaObjects">useClassMethod	"return if the class method is to be used"	useClassMethod == nil ifTrue: [useClassMethod := self localClass respondsTo: self selector].	^useClassMethod</body><body package="Opentalk-IDL-MetaObjects">useCombinedmethod	"return if the combined instance method is to be used"	useCombinedmethod == nil ifTrue: [useCombinedmethod := self localClass new respondsTo: self selector].	^useCombinedmethod</body><body package="Opentalk-IDL-MetaObjects">writeSelectors	"Return an ordered collection of write selectors on my fields."	writeSelectors == nil ifTrue: [self computeSelectors].	^writeSelectors</body></methods><methods><class-id>Opentalk.DSTtypeStructure</class-id> <category>marshalling</category><body package="Opentalk-IDL-MetaObjects">boldMarshall: aParameter on: aStream 	"Marshall the parameter onto the stream"	self		boldMarshall: aParameter		on: aStream		withLocalClass: self localClass</body><body package="Opentalk-IDL-MetaObjects">boldMarshall: aParameter on: aStream withLocalClass: aClass 	"Marshall the parameter onto the stream. Subclasses must overload. 	(Modified to use Dictionary access)"	"canMarshall = dictionary has those elements 		or class responds to to those messages"	| i |	aClass isNil		ifTrue: 			[i := 0.			self allFields do: [:fld | fld boldMarshall: (aParameter at: (self readSelectors at: (i := i + 1)))					on: aStream]]		ifFalse: 			[i := 0.			self allFields do: [:fld | fld boldMarshall: (aParameter perform: (self readSelectors at: (i := i + 1)))					on: aStream]]</body><body package="Opentalk-IDL-MetaObjects">marshallMatch: aParameter 	"Return:		true			- if I can marshall the parameter		false		- if I can NOT marshall the parameter		#mappable	- if I can marshall the parameter by mapping to something else"		^self localClass == nil		ifTrue: 			[(aParameter isDictionary)				ifFalse: [^false].			1 to: self readSelectors size do: [:idx | aParameter at: (self readSelectors at: idx)					ifAbsent: [^false]].			true]		ifFalse: [aParameter isKindOf: self localClass]</body><body package="Opentalk-IDL-MetaObjects">marshallTypeCode: aDictionary on: aStream 	"marshall the type code of the receiver"	| flds |	(self tryMarshallIndirectTypeCode: aDictionary on: aStream)		ifTrue: [^self].	flds := self allFields.	aStream nextPutUnsignedLong: self typeCode.	aStream nextPutEncapsulatedInOctets: [ :stream |		stream			nextPutASCIIString: self repositoryId asString;			nextPutASCIIString: self printName;			nextPutLocalType: self localType;			nextPutUnsignedLong: flds size.		flds do: [ :f |			stream nextPutASCIIString: f printName.			f marshallTypeCode: aDictionary on: stream ] ]</body><body package="Opentalk-IDL-MetaObjects">unMarshall: aStream 	"Unmarshall a result from the stream and return an object of the 	appropriate class."	^self unMarshall: aStream withLocalClass: self localClass</body><body package="Opentalk-IDL-MetaObjects">unMarshall: aStream withLocalClass: aClass	"Unmarshall a result from the stream and return an object of the 	appropriate class."	| result values |	values := self allFields collect: [:fld | fld unMarshall: aStream].	aClass notNil		ifTrue: [(aClass respondsTo: self selector)				ifTrue: [result := aClass perform: selector withArguments: values asArray]				ifFalse: [result := aClass new.						(result respondsTo: self selector)						ifTrue: [result perform: selector withArguments: values asArray]						ifFalse: 							[self writeSelectors do: [:sel | result perform: sel with: values removeFirst]]]]		ifFalse: 			[result := Dictionary new.			self readSelectors do: [:key | result at: key put: values removeFirst]].	^result</body><body package="Opentalk-IDL-MetaObjects">unMarshallTypeCode: aDictionary from: aStream 	"unmarshall the type code of the receiver"	| mo sz n field byteOrder locType |	aDictionary add: aStream position -&gt; self.	aStream nextUnsignedLong.	byteOrder := aStream byteOrder.	aStream byteOrder: aStream nextBoolean.	repositoryId := aStream nextASCIIString.	repositoryId isEmpty ifFalse: [		repositoryId := RepositoryId fromString: repositoryId.		mo := DSTORBObject lookupMetaId: repositoryId ].	name := aStream nextASCIIString.	locType := aStream nextLocalType.	sz := aStream nextUnsignedLong.	(name isEmpty and: [mo notNil]) ifTrue: [name := mo name].	fields :=		(1 to: sz) collect: [:f | 			n := aStream nextASCIIString.			(n isEmpty and: [mo notNil]) ifTrue: [n := (mo allFields at: f) name].			field := self class unMarshallTypeCode: aDictionary from: aStream.			field definedIn: self.			(field isDSTinterface)				ifTrue: [ field initialize: n ]				ifFalse: [ field declarators: (Array with: (DSTdeclaratorSimple new initialize: n)) ].			field ].	locType isNil		ifTrue: [mo isNil ifFalse: [mo localType isNil ifFalse: [self localType: mo localType]]]		ifFalse: [self localType: locType].	aStream byteOrder: byteOrder</body></methods><methods><class-id>Opentalk.DSTtypeStructure</class-id> <category>StructDef</category><body package="Opentalk-IDL-MetaObjects">description	"return a structure description"	|d|	d:= (Dictionary new) 		add: #name -&gt; name; 		add: #id -&gt; self id; 		add: #definedIn -&gt; self definedInString; 		add: #version -&gt; self version; 		add: #type -&gt; self;		yourself.	d overrideCORBAType: (DSTORBObject lookupMetaId: #'::CORBA::TypeDescription').	^d</body><body package="Opentalk-IDL-MetaObjects">members	"The members attribute contains a description of each structure 	member."	^self allFields collect: [:field | (Dictionary new) add: #name -&gt; field name; add: #type -&gt; field equivalentType; add: #typeDef -&gt; field equivalentType; yourself]</body><body package="Opentalk-IDL-MetaObjects">members: memberList 	"Setting the members attribute also updates the type attribute. When 	setting the members attribute, the type member of the 	StructMember structure is ignored and should be set to TC_void."	self notYetImplemented</body></methods><methods><class-id>Opentalk.DSTtypeStructure</class-id> <category>printing</category><body package="Opentalk-IDL-MetaObjects">definitionString	"return my unformatted IDL definition string"	| aStream |	aStream := (String new: 80) writeStream.	aStream nextPutAll: 'struct  '; nextPutAll: name; nextPutAll: ' {'.	fields do: [:fld | aStream nextPutAll: fld definitionString; nextPut: $ ; nextPutAll: fld declaratorString; nextPutAll: '; '].	aStream nextPut: $}.	^aStream contents</body><body package="Opentalk-IDL-MetaObjects">printDefinitionOn: aStream indent: level style: aTextStyleName 	"Print my IDL definition on the stream."	"Since the default Parser class is used to parse the selector of IDL 	units, it 	is important that the first token of an IDL 'method' is parsed 	correctly by 	Parser. Specifically, it must be avoided that the pound sign is the 	first 	character in the method, since it would cause a parsing problem. 	Therefore we show pragmas AFTER the comment lines and we also 	make 	sure that there is always at least one comment line. Also note, that 	senders of Parser&gt;&gt;parseSelector: (such as 	Text&gt;&gt;makeSelectorBoldIn:) 	assume that the selector starts at position 1 of the method source."	self printHeaderOn: aStream indent: level.	prefix isNil ifFalse: [CurrentPrefix ~= prefix prefixString			ifTrue: 				[aStream tab: level; nextPutAll: '#pragma  prefix '; nextPut: $"; nextPutAll: prefix prefixString; nextPut: $"; cr.				CurrentPrefix := prefix prefixString]].	self hasPragma ifTrue: [aStream tab: level; nextPutAll: '#pragma class '; nextPutAll: self printName; nextPutAll: ' '; nextPutAll: self localType; cr].	aStream tab: level.	declarators isNil		ifTrue: 			[self				printFormattedOn: aStream				indent: level				style: aTextStyleName.			aStream nextPutAll: ';'; cr]		ifFalse: 			[aStream nextPutAll: 'typedef '.			self				printFormattedOn: aStream				indent: level + (self tabFor: 'typedef ' style: aTextStyleName)				style: aTextStyleName.			aStream nextPut: $ ; nextPutAll: self declaratorString; nextPut: $;; cr]</body><body package="Opentalk-IDL-MetaObjects">printFormattedOn: aStream indent: level style: aTextStyleName 	"print the detailed formatted definition of the receiver on 	aStream. To be overloaded by subclasses if formatting is 	actually required"	| unformatted |	unformatted := self definitionString.	(self		stringNeedsFormatting: unformatted		indent: level		style: aTextStyleName)		ifTrue: 			[aStream nextPutAll: 'struct '; nextPutAll: name; nextPutAll: ' {'; cr.			fields				do: 					[:fld | 					aStream tab: level + 1.					fld						printFormattedOn: aStream						indent: level + 1						style: aTextStyleName.					aStream nextPut: $ ; nextPutAll: fld declaratorString; nextPut: $;; cr].			aStream tab: level; nextPut: $}]		ifFalse: [aStream nextPutAll: unformatted]</body><body package="Opentalk-IDL-MetaObjects">printOn: aStream 	"print the receiver's printname on the stream"	aStream nextPutAll: 'struct ' , self idlName</body></methods><methods><class-id>Opentalk.DSTtypeStructure</class-id> <category>repository</category><body package="Opentalk-IDL-MetaObjects">CORBAName	"return the name of my CORBA interface in the repository"	^#'::CORBA::StructDef'</body><body package="Opentalk-IDL-MetaObjects">allMetaObjectsInto: aSet	"add all of the contained metaobjects to the set" 	super allMetaObjectsInto: aSet.	fields do: [:s | s allMetaObjectsInto: aSet]</body><body package="Opentalk-IDL-MetaObjects">canApplyPragma: pragma 	"Check to see if the argument pragma can be applied to the receiver."	^#(#CLASS) includes: pragma</body><body package="Opentalk-IDL-MetaObjects">defKind        "Return the definition kind."        ^#dk_Struct</body><body package="Opentalk-IDL-MetaObjects">lookupName: aSymbol levels: anInt limit: limitType excludeInherited: bool 	"Modified version of DSTMetaContainer's routine. Used to lookup 	definitions within a structure."	self allFields do: [:f | f name == aSymbol ifTrue: [^Set with: f]].	^#()</body><body package="Opentalk-IDL-MetaObjects">typeKind	"return the TCKind of the receiver"	^#tk_struct</body><body package="Opentalk-IDL-MetaObjects">typeParamCount	"return the number of parameters which the receiver supports. 	Subtypes should overload as required"	^self allFields size * 2 + 1</body><body package="Opentalk-IDL-MetaObjects">typeParameter: anInt 	"return the nth parameter which the receiver supports. 	Subtypes should overload as required"	| f |	anInt = 1 ifTrue: [^self printName].	(anInt between: 2 and: self typeParamCount)		ifTrue: 			[f := self allFields at: (anInt - 2 // 2) + 1.			anInt - 2 \\ 2 = 0				ifTrue: [^f printName asString]				ifFalse: [^f]].	self error: #Bounds</body></methods><methods><class-id>Opentalk.DSTtypeStructure</class-id> <category>rendering</category><body package="Opentalk-IDL-MetaObjects">hasComponents	"return true iff I have components worthwhile to show in a browser 	window"	^fields isEmpty not</body></methods><methods><class-id>Opentalk.DSTtypeStructure</class-id> <category>initialization</category><body package="Opentalk-IDL-MetaObjects">id: aSymbol fields: fieldarray 	"initialize a new instance"	| field decls |	name := aSymbol asSymbol.	fields := OrderedCollection new. 	fieldarray do: [:f| 		field := f at: 2.		decls := f at: 1.		field declarators: decls.		fields add: field]</body><body package="Opentalk-IDL-MetaObjects">reInitialize	"reinitialize the receiver. Zap my caches"	super reInitialize.	useClassMethod := useCombinedmethod := selector := readSelectors := writeSelectors := nil.</body></methods><methods><class-id>Opentalk.DSTtypeStructure class</class-id> <category>creation</category><body package="Opentalk-IDL-MetaObjects">on: aFieldArray 	"create a structure metaobject with the given fields"	|  | 	^self new id: 'exception' 		fields: aFieldArray</body></methods><methods><class-id>Opentalk.DSTtypeShort</class-id> <category>repository</category><body package="Opentalk-IDL-MetaObjects">typeKind	"return the TCKind of the receiver"	^#tk_short</body></methods><methods><class-id>Opentalk.DSTtypeShort</class-id> <category>Primitive Def</category><body package="Opentalk-IDL-MetaObjects">kind	"return the receiver's primitive type"	^#pk_short</body></methods><methods><class-id>Opentalk.DSTtypeShort</class-id> <category>marshalling</category><body package="Opentalk-IDL-MetaObjects">boldMarshall: aParameter on: aStream 	"Marshall the parameter onto the stream"	"canMarshall not = exception on nextPutShort:"	aStream nextPutShort: aParameter</body><body package="Opentalk-IDL-MetaObjects">marshallMatch: aParameter 	"Return:		true			- if I can marshall the parameter		false		- if I can NOT marshall the parameter		#mappable	- if I can marshall the parameter by mapping to something else"		^(aParameter isInteger)		and: [aParameter between:  -32768 and:  32767]</body><body package="Opentalk-IDL-MetaObjects">unMarshall: aStream 	"Unmarshall a result from the stream and return an object of the 	appropriate class."	^aStream nextShort</body></methods><methods><class-id>Opentalk.DSTtypeShort</class-id> <category>initialization</category><body package="Opentalk-IDL-MetaObjects">initialize	"initialize the receiver"	super initialize.	name := 'short'</body></methods><methods><class-id>Opentalk.DSTtypeShort</class-id> <category>accessing</category><body package="Opentalk-IDL-MetaObjects">valueExcept: aCol 	"Answer a valid boolean value not contained in the collection, otherwise 	nil"	| max maxSize probe |	name = 'short'		ifTrue: [max := 32767]		ifFalse: [name = 'long'				ifTrue: [max := 2147483647]				ifFalse: [name = 'unsigned short'						ifTrue: [maxSize := 65536]						ifFalse: [maxSize := 4294967296]]].	maxSize isNil		ifTrue: [maxSize := max + 1 * 2]		ifFalse: [max := maxSize - 1].	aCol size &lt; maxSize		ifTrue: 			[probe := max.			[aCol includes: probe]				whileTrue: [probe := probe - 1].			^probe]		ifFalse: [^nil]</body></methods><methods><class-id>Opentalk.DSTtypeUnsignedShort</class-id> <category>Primitive Def</category><body package="Opentalk-IDL-MetaObjects">kind	"return the receiver's primitive type"	^#pk_ushort</body></methods><methods><class-id>Opentalk.DSTtypeUnsignedShort</class-id> <category>marshalling</category><body package="Opentalk-IDL-MetaObjects">boldMarshall: aParameter on: aStream 	"Marshall the parameter onto the stream"	"canMarshall not = exception on nextPutUnsignedShort:"	aStream nextPutUnsignedShort: aParameter</body><body package="Opentalk-IDL-MetaObjects">unMarshall: aStream 	"Unmarshall a result from the stream and return an object of the 	appropriate class."	^aStream nextUnsignedShort</body></methods><methods><class-id>Opentalk.DSTtypeUnsignedShort</class-id> <category>repository</category><body package="Opentalk-IDL-MetaObjects">typeKind	"return the TCKind of the receiver"	^#tk_ushort</body></methods><methods><class-id>Opentalk.DSTtypeUnsignedShort</class-id> <category>initialization</category><body package="Opentalk-IDL-MetaObjects">initialize	"initialize the receiver"	super initialize.	name := 'unsigned short'</body></methods><methods><class-id>Opentalk.DSTmodule</class-id> <category>repository</category><body package="Opentalk-IDL-MetaObjects">CORBAName	"return the name of my CORBA interface in the repository"	^#'::CORBA::ModuleDef'</body><body package="Opentalk-IDL-MetaObjects">canApplyPragma: pragma 	"Check to see if the argument pragma can be applied to the receiver."	^#(#ID #VERSION) includes: pragma</body><body package="Opentalk-IDL-MetaObjects">defKind        "Return the definition kind."        ^#dk_Module</body><body package="Opentalk-IDL-MetaObjects">metaObjectOf: aSymbol 	"return the meta object which is associated with the given identifier"	"(name isMemberOf: ORBDeadObject) ifTrue: [^nil]."	^(self searchScopeFor: aSymbol)		ifNil: [self definingMetaObject metaObjectOf: aSymbol]</body><body package="Opentalk-IDL-MetaObjects">removeMetaObject	"Prepare the metaobject so that it can be garbage collected."	| mos refs |	mos := Set new.	self allMetaObjectsInto: mos.	mos do: [:m | CORBAConstants removeKey: m idlName asSymbol ifAbsent: []].	refs := mos select: [:mo | mo isDSTMetaObject and: [mo isDSTinterface or: [mo isDSTdeclaratorSimple]]].	DSTtypeNamed allInstances do: [:tn | (refs includes: tn equivType)			ifTrue: [tn resolveTo: nil]].	(refs select: [:m | m class == DSTinterface])		do: [:obj | obj allOwners do: [:own | (own isKindOf: IIOPObjRef)					ifTrue: [own interface: nil]]].	mos do: [:m | m destroy].	super removeMetaObject</body><body package="Opentalk-IDL-MetaObjects">removeMetaObject: aMetaContainer 	"Remove the meta-object from the Repository. An association 	between the fully scoped name of the receiver and its 	presenters will be added to aCollection. 	The presenters contained in aCollection must be 	relinked with the replacing meta objects (if possible)"	| mos refs |	contents remove: aMetaContainer ifAbsent: [].	symbols removeKey: aMetaContainer repositoryId ifAbsent: [].	symbols removeKey: aMetaContainer printName ifAbsent: [].	mos := Set new.	aMetaContainer allMetaObjectsInto: mos.	mos		do: 			[:m | CORBAConstants removeKey: m idlName asSymbol ifAbsent: []].	refs := mos select: [:mo | mo isDSTMetaObject and: [mo isDSTinterface or: [mo isDSTdeclaratorSimple]]].	DSTtypeNamed allInstances do: [:tn | (refs includes: tn equivType)			ifTrue: [tn resolveTo: nil]].	(refs select: [:m | m class == DSTinterface])		do: [:obj | obj allOwners do: [:own | (own isKindOf: IIOPObjRef)					ifTrue: [own releaseInterface]]].	mos do: [:m | m unlinkFromRepository].</body><body package="Opentalk-IDL-MetaObjects">searchScopeFor: aSymbol 	"return the meta object which is associated with the given identifier"	| head str tail x | 	aSymbol class == NCSuuid		ifTrue: [x := 0]		ifFalse: 			[str := aSymbol asString.			x := str findFirst: [:ch | ch = $:]].	x isZero		ifTrue: [^symbols at: aSymbol ifAbsent: [nil]]		ifFalse: 			[x = 1 ifTrue: [^nil].			head := str copyFrom: 1 to: x - 1.			tail := str copyFrom: x + 2 to: str size.			^(symbols at: head asSymbol ifAbsent: [^nil])				searchScopeFor: tail asSymbol].	^nil</body></methods><methods><class-id>Opentalk.DSTmodule</class-id> <category>ModuleDef</category><body package="Opentalk-IDL-MetaObjects">description	"return a module description"	^(Dictionary new) 		add: #name -&gt; name; 		add: #id -&gt; self id; 		add: #definedIn -&gt; self definedInString; 		add: #version -&gt; self version; 		yourself</body></methods><methods><class-id>Opentalk.DSTmodule</class-id> <category>initialization</category><body package="Opentalk-IDL-MetaObjects">initialize	"initialize the receiver"	super initialize.	contents := OrderedCollection new.	symbols := Dictionary new.</body></methods><methods><class-id>Opentalk.DSTmodule</class-id> <category>accessing</category><body package="Opentalk-IDL-MetaObjects">addSubordinate: aMO	"only interfaces keep track of sub-interfaces.  Do nothing"</body><body package="Opentalk-IDL-MetaObjects">allOperations: oList avoiding: iSet	"only interfaces can add operations to the set.  Do nothing"</body><body package="Opentalk-IDL-MetaObjects">interfaces	"return the interfaces which are declared within the receiver"	^contents select: [:mo | mo isDSTMetaObject and: [mo isDSTinterface]]</body></methods><methods><class-id>Opentalk.DSTmodule</class-id> <category>printing</category><body package="Opentalk-IDL-MetaObjects">forwardInterfaces	"for the benefit of simple minded compilers, return the interfaces 	which need to be forward declared within the receiver"	| allIfs encountered forward s et |	allIfs := contents  "self interfaces".	encountered := Set new.	forward := Set new.	allIfs		do: 			[:if | 			encountered add: if.			s := Set new.			if allMetaObjectsInto: s.			s do: [:mo | mo class = DSTtypeNamed					ifTrue: 						[et := mo equivalentType definingMetaContainer.						(allIfs includes: et)							&amp; (encountered includes: et) not							ifTrue: 								[forward add: et.								encountered add: et]]]].	^forward</body><body package="Opentalk-IDL-MetaObjects">printDefinitionOn: aStream indent: level style: aTextStyleName 	"print the IDL definition of the receiver onto the stream"	self printHeaderOn: aStream indent: level.	prefix isNil ifFalse: [CurrentPrefix ~= prefix prefixString			ifTrue: 				[aStream tab: level; nextPutAll: '#pragma  prefix '; nextPut: $"; nextPutAll: prefix prefixString; nextPut: $"; cr.				CurrentPrefix := prefix prefixString]].	(repositoryId isNil not and: [repositoryId ~= self generateRepositoryId])		ifTrue: [aStream tab: level; nextPutAll: '#pragma  ID '; nextPutAll: self printName; space; nextPut: $"; nextPutAll: repositoryId asString; nextPut: $"; cr].	version notNil ifTrue: [aStream tab: level; nextPutAll: '#pragma  version '; nextPutAll: self printName; space; nextPutAll: version; cr].	aStream tab: level; nextPutAll: 'module '; nextPutAll: name asString; nextPutAll: '  {'.	contents isEmpty		ifFalse: 			[aStream cr; cr.			(1 to: contents size)				do: 					[:i | 					(i &gt; 1 and: [(contents at: i - 1) wantsSpace or: [(contents at: i) wantsSpace]])						ifTrue: [aStream cr].					(contents at: i)						printDefinitionOn: aStream						indent: level + 1						style: aTextStyleName].			aStream tab: level].	aStream nextPutAll: '};'; cr</body><body package="Opentalk-IDL-MetaObjects">printOn: aStream	"print the receiver's printname on the stream"	aStream nextPutAll: 'module ' , self idlName</body><body package="Opentalk-IDL-MetaObjects">publishDefinitionOn: aStream indent: level style: aTextStyleName 	"publish the IDL definition of the receiver onto the stream"	self printHeaderOn: aStream indent: level.	aStream tab: level; nextPutAll: 'module '; nextPutAll: name asString; nextPutAll: '  {'; cr; cr.	self forwardInterfaces		do: 			[:if |  			aStream tab: level+1.			aStream nextPutAll: 'interface  ' , if printName , ';  // forward declaration'; cr].	contents isEmpty		ifFalse: 			[aStream cr; cr.			(1 to: contents size)				do: 					[:i | 					(i &gt; 1 and: [(contents at: i - 1) wantsSpace or: [(contents at: i) wantsSpace]])						ifTrue: [aStream cr].					(contents at: i)						publishDefinitionOn: aStream						indent: level + 1						style: aTextStyleName].			aStream tab: level].	aStream nextPutAll: '};'; cr</body></methods><methods><class-id>Opentalk.DSTmodule</class-id> <category>creation</category><body package="Opentalk-IDL-MetaObjects">def: stArray defs: anArray 	"Set the module's description and contents"	definition := stArray.	contents := anArray asOrderedCollection.	contents		do: 			[:mo | 			mo definedIn: self.			self registerMetaObject: mo]</body><body package="Opentalk-IDL-MetaObjects">ident: id 	"Set the module's name"	name := id.</body><body package="Opentalk-IDL-MetaObjects">ident: id def: stArray defs: anArray 	"initialize a new instance of the receiver"	name := id.	definition := stArray.	contents := anArray.	contents		do: 			[:mo | 			mo definedIn: self.			self registerMetaObject: mo]</body></methods><methods><class-id>Opentalk.DSTmodule</class-id> <category>repository-private</category><body package="Opentalk-IDL-MetaObjects">canContain: kind 	"Check to see if the definition kind can be contained in the receiver."	^#(#dk_Constant #dk_Typedef #dk_Exception #dk_Interface #dk_Module) includes: kind</body></methods><methods><class-id>Opentalk.DSTmodule</class-id> <category>testing</category><body package="Opentalk-IDL-MetaObjects">IIOPIsA: aRepositoryId	aRepositoryId asString = 'IDL:CORBA/ModuleDef:1.0' ifTrue:[^true].	^super IIOPIsA: aRepositoryId</body><body package="Opentalk-IDL-MetaObjects">isDSTmodule	^true</body></methods><methods><class-id>Opentalk.DSTtypeSequence</class-id> <category>marshalling</category><body package="Opentalk-IDL-MetaObjects">boldMarshall: aParameter on: aStream 		"Marshall the parameter onto the stream. Subclasses must 	overload, for sequences we disregard the localClass"	"canMarshall = Dictionary or doesn't MNU on 'do:'"	| sz |	(size == nil or: [size = 0 or: [ aParameter size &lt;= size]])		ifFalse: [^self class marshallError: 0].	aStream nextPutUnsignedLong: (sz := aParameter size).	sz == 0 ifTrue: [^self].	(aParameter class == ByteArray and: [subtype class == DSTtypeOctet or: [subtype class == DSTtypeCharacter]])		ifTrue: [aStream nextPutAll: aParameter]		ifFalse: [(aParameter isDictionary)				ifTrue: [aParameter associationsDo: [:x | subtype boldMarshall: x on: aStream]]				ifFalse: [aParameter do: [:x | subtype boldMarshall: x on: aStream]]]</body><body package="Opentalk-IDL-MetaObjects">marshallMatch: aParameter 	"Return:		true			- if I can marshall the parameter		false		- if I can NOT marshall the parameter		#mappable	- if I can marshall the parameter by mapping to something else.	Modified in 5i with the final 'and:' clause, to test the subtype, so that unions of 	sequences get marshalled with some degree of discrimination."			^( aParameter isCollection 		and: [ size == nil or: [size == 0 or: [ aParameter size &lt;= size ] ] ] )		and: [ aParameter size &lt; 1 or: [ subtype marshallMatch: ( aParameter at: 1) ] ]</body><body package="Opentalk-IDL-MetaObjects">marshallTypeCode: aDictionary on: aStream 	"marshall the type code of the receiver"	(self tryMarshallIndirectTypeCode: aDictionary on: aStream)		ifTrue: [^self].	aStream nextPutUnsignedLong: self typeCode.	aStream nextPutEncapsulatedInOctets: [ :stream |		subtype marshallTypeCode: aDictionary on: stream.		stream nextPutUnsignedLong: (size == nil ifTrue: [0] ifFalse: [size]) ]</body><body package="Opentalk-IDL-MetaObjects">unMarshall: aStream 	"Unmarshall a result from the stream and return an object of the 	appropriate class."	^self unMarshall: aStream withLocalClass: self localClass</body><body package="Opentalk-IDL-MetaObjects">unMarshall: aStream withLocalClass: aClass 	"Unmarshall a result from the stream and return an object of the 	appropriate class."	| result actual |	actual := aStream nextUnsignedLong.	(size notNil and: [size &gt; 0 and: [actual &gt; size]])		ifTrue: [self error: 'Sequence has too many elements'].	aClass == nil		ifTrue: [result := OrderedCollection new: actual.				1 to: actual do: [:i | result add: (subtype unMarshall: aStream)].				^result]		ifFalse: [(aClass == ByteArray and:				[subtype class == DSTtypeOctet or: [subtype class == DSTtypeCharacter]])					ifTrue: [ | bytes |						bytes := ByteArray new: actual.						aStream next: actual into: bytes startingAt: 1.						^bytes]].	result := aClass new: actual.	(result isKindOf: ArrayedCollection)		ifTrue: [1 to: actual do: [:i | result at: i put: (subtype unMarshall: aStream)]]		ifFalse: [1 to: actual do: [:i | result add: (subtype unMarshall: aStream)]].	^result</body><body package="Opentalk-IDL-MetaObjects">unMarshallTypeCode: aDictionary from: aStream	"unmarshall the type code of the receiver."	| byteOrder |	aDictionary add: aStream position -&gt; self.	aStream nextUnsignedLong.	byteOrder := aStream byteOrder.	aStream byteOrder: aStream nextBoolean.	subtype := self class unMarshallTypeCode: aDictionary from: aStream.	size := aStream nextUnsignedLong.	aStream byteOrder: byteOrder</body></methods><methods><class-id>Opentalk.DSTtypeSequence</class-id> <category>repository</category><body package="Opentalk-IDL-MetaObjects">CORBAName	"return the name of my CORBA interface in the repository"	^#'::CompoundDefs::SequenceCompoundDef'</body><body package="Opentalk-IDL-MetaObjects">defKind        "Return the definition kind."        ^#dk_Sequence</body><body package="Opentalk-IDL-MetaObjects">typeKind	"return the TCKind of the receiver"	^#tk_sequence</body><body package="Opentalk-IDL-MetaObjects">typeParameter: anInt 	"return the nth parameter which the receiver supports. 	Subtypes should overload as required"	anInt = 1 ifTrue: [^subtype].	anInt = 2 ifTrue: [^size isNil			ifTrue: [0]			ifFalse: [size]].	self error: #Bounds</body></methods><methods><class-id>Opentalk.DSTtypeSequence</class-id> <category>SequenceDef</category><body package="Opentalk-IDL-MetaObjects">bound	"The bound attribute specifies the maximum number of elements in 	the sequence. A bound of zero indicates an unbounded sequence."	^size</body><body package="Opentalk-IDL-MetaObjects">bound: newBound 	"Setting the bound attribute updates the type attribute."	self notYetImplemented</body><body package="Opentalk-IDL-MetaObjects">elementType	"The type of the elements of the sequence is described by 	elementType and identified by elementTypeDef."	^subtype equivalentType baseType</body><body package="Opentalk-IDL-MetaObjects">elementTypeDef	"The type of the elements of the sequence is described by 	elementType and identified by elementTypeDef."	^subtype equivalentType baseType</body><body package="Opentalk-IDL-MetaObjects">elementTypeDef: anIDLType 	"Setting the elementTypeDef attribute also updates the elementType 	attribute. The type attribute is also updated."	self notYetImplemented</body></methods><methods><class-id>Opentalk.DSTtypeSequence</class-id> <category>printing</category><body package="Opentalk-IDL-MetaObjects">definitionString	"return my IDL type definition string"	| aStream |	aStream := (String new: 80) writeStream.	aStream nextPutAll: name; nextPutAll: '&lt;'; nextPutAll: subtype definitionString.	size isNil | (size = 0) ifFalse: [aStream nextPutAll: ', '; nextPutAll: size printString].	aStream nextPut: $&gt;.	^aStream contents</body></methods><methods><class-id>Opentalk.DSTtypeSequence</class-id> <category>initialization</category><body package="Opentalk-IDL-MetaObjects">initialize	"initialize the receiver"	super initialize.	name := 'sequence'</body></methods><methods><class-id>Opentalk.DSTcachedOperation</class-id> <category>accessing</category><body package="Opentalk-IDL-MetaObjects">access	^self accessRight</body><body package="Opentalk-IDL-MetaObjects">definedIn	^(definedIn class == RepositoryId)		ifTrue: [definedIn]		ifFalse: [self definingMetaObject id]</body><body package="Opentalk-IDL-MetaObjects">exceptionOf: aSymbol 	"Return an exception meta object which has the given print name symbol. 	Error if not"	| ex |	ex := DSTORBObject lookupMetaId: aSymbol.	(ex isDSTMetaObject and: [ex isDSTexception])		ifTrue: [^ex]		ifFalse: [self class intfReposError: 0]</body><body package="Opentalk-IDL-MetaObjects">exceptions	^raises</body><body package="Opentalk-IDL-MetaObjects">idlName		^[super idlName] on: Object errorSignal do: [:ex | name]</body><body package="Opentalk-IDL-MetaObjects">raises	^raises</body></methods><methods><class-id>Opentalk.DSTcachedOperation</class-id> <category>testing</category><body package="Opentalk-IDL-MetaObjects">isDSTcachedOperation	^true</body></methods><methods><class-id>Opentalk.DSTcachedOperation</class-id> <category>private</category><body package="Opentalk-IDL-MetaObjects">name: aName definedIn: anId localOp: aSelector access: anAccess signature: aSignature mode: aMode raises: aCollection context: aCxt 	name := aName.	definedIn := anId.	localOp := aSelector.	access := anAccess.	signature := aSignature.	sync := aMode.	raises := aCollection.	context := aCxt</body></methods><methods><class-id>Opentalk.DSTcachedOperation</class-id> <category>repository</category><body package="Opentalk-IDL-MetaObjects">corbaTypeIn: aRepository	"return an instance of the DSTmetaObject subclass which can marshall an 	instance of the receiver."	^aRepository lookupMetaId: #'::SharedIR::CachedOperation'</body></methods><methods><class-id>Opentalk.DSTcachedOperation class</class-id> <category>instance creation</category><body package="Opentalk-IDL-MetaObjects">name: aName definedIn: anId localOp: aSelector access: anAccess signature: aSignature mode: aMode raises: aCollection context: aCxt 	^(self new)		name: aName		definedIn: anId		localOp: aSelector		access: anAccess		signature: aSignature		mode: aMode		raises: aCollection		context: aCxt; yourself</body></methods><methods><class-id>Opentalk.DSTtypeBoolean</class-id> <category>repository</category><body package="Opentalk-IDL-MetaObjects">typeKind	"return the TCKind of the receiver"	^#tk_boolean</body></methods><methods><class-id>Opentalk.DSTtypeBoolean</class-id> <category>Primitive Def</category><body package="Opentalk-IDL-MetaObjects">kind	"return the receiver's primitive type"	^#pk_boolean</body></methods><methods><class-id>Opentalk.DSTtypeBoolean</class-id> <category>marshalling</category><body package="Opentalk-IDL-MetaObjects">boldMarshall: aParameter on: aStream 	"Marshall the parameter onto the stream"	"canMarshall not = nextputBoolean: raises exception"	((aParameter == true) or: [aParameter == false]) ifFalse: [self class marshallError: 0].	aStream nextPutBoolean: aParameter</body><body package="Opentalk-IDL-MetaObjects">marshallMatch: aParameter 	"Return:		true			- if I can marshall the parameter		false		- if I can NOT marshall the parameter		#mappable	- if I can marshall the parameter by mapping to something else"		^aParameter == true or: [aParameter == false]</body><body package="Opentalk-IDL-MetaObjects">unMarshall: aStream 	"Unmarshall a result from the stream and return an object of the 	appropriate class."	^aStream nextBoolean</body></methods><methods><class-id>Opentalk.DSTtypeBoolean</class-id> <category>initialization</category><body package="Opentalk-IDL-MetaObjects">initialize	"initialize the receiver"	super initialize.	name := 'boolean'</body></methods><methods><class-id>Opentalk.DSTtypeBoolean</class-id> <category>accessing</category><body package="Opentalk-IDL-MetaObjects">valueExcept: aCol 	"Answer a valid boolean value not contained in the collection, otherwise 	nil"	| candidates |	candidates := #(true false ) asSet - aCol asSet.	^candidates isEmpty		ifTrue: [nil]		ifFalse: [candidates anElement]</body></methods><methods><class-id>Opentalk.DSTvalueNamed</class-id> <category>initialization</category><body package="Opentalk-IDL-MetaObjects">initialize: aName 	"set the type printname of the receiver"	name := aName</body></methods><methods><class-id>Opentalk.DSTvalueNamed</class-id> <category>repository</category><body package="Opentalk-IDL-MetaObjects">allMetaObjectsInto: aSet 	"add me"	aSet add: self</body><body package="Opentalk-IDL-MetaObjects">cleanHouse	"Close all local and remote presentations. Here do nothing."</body><body package="Opentalk-IDL-MetaObjects">definingMetaObject	"return my defining meta object"	^definedIn</body><body package="Opentalk-IDL-MetaObjects">registerIdentity	"do nothing"</body><body package="Opentalk-IDL-MetaObjects">resolveTypeReference	"force evaluation of my value"	self value</body><body package="Opentalk-IDL-MetaObjects">unlinkFromRepository	"The receiver is being removed from the repository. Unlink as 	required.  Here do nothing"</body></methods><methods><class-id>Opentalk.DSTvalueNamed</class-id> <category>accessing</category><body package="Opentalk-IDL-MetaObjects">definedIn: aMetaObject 	"set the receiver's defining container meta object"	definedIn := aMetaObject</body><body package="Opentalk-IDL-MetaObjects">idlName	"return the receivers full qualified name"	^self definingMetaObject idlName , '::' , name</body><body package="Opentalk-IDL-MetaObjects">value	"return the value of the receiver"	value == nil ifTrue: [value := definedIn metaValueOf: name].	^value</body><body package="Opentalk-IDL-MetaObjects">value: anObject	value := anObject</body></methods><methods><class-id>Opentalk.DSTtypeUnion</class-id> <category>printing</category><body package="Opentalk-IDL-MetaObjects">definitionString	"return my unformatted IDL definition string"	| aStream |	aStream := (String new: 80) writeStream.	aStream nextPutAll: 'union '; nextPutAll: name; nextPutAll: ' switch ('; nextPutAll: switchtype definitionString; nextPutAll: ') {'.	cases do: [:ca | ca printOn: aStream].	aStream nextPut: $}.	^aStream contents</body><body package="Opentalk-IDL-MetaObjects">printDefinitionOn: aStream indent: level style: aTextStyleName 	"Print my IDL definition on the stream."	"Since the default Parser class is used to parse the selector of IDL 	units, it 	is important that the first token of an IDL 'method' is parsed 	correctly by 	Parser. Specifically, it must be avoided that the pound sign is the 	first 	character in the method, since it would cause a parsing problem. 	Therefore we show pragmas AFTER the comment lines and we also 	make 	sure that there is always at least one comment line. Also note, that 	senders of Parser&gt;&gt;parseSelector: (such as 	Text&gt;&gt;makeSelectorBoldIn:) 	assume that the selector starts at position 1 of the method source."	self printHeaderOn: aStream indent: level.	prefix isNil ifFalse: [CurrentPrefix ~= prefix prefixString			ifTrue: 				[aStream tab: level; nextPutAll: '#pragma  prefix '; nextPut: $"; nextPutAll: prefix prefixString; nextPut: $"; cr.				CurrentPrefix := prefix prefixString]].	self hasPragma ifTrue: [aStream tab: level; nextPutAll: '#pragma class '; nextPutAll: self printName; nextPutAll: ' '; nextPutAll: self localType; cr].	aStream tab: level.	declarators isNil		ifTrue: 			[self				printFormattedOn: aStream				indent: level				style: aTextStyleName.			aStream nextPutAll: ';'; cr]		ifFalse: 			[aStream nextPutAll: 'typedef '.			self				printFormattedOn: aStream				indent: level + (self tabFor: 'typedef ' style: aTextStyleName)				style: aTextStyleName.			aStream nextPut: $ ; nextPutAll: self declaratorString; nextPut: $;; cr]</body><body package="Opentalk-IDL-MetaObjects">printFormattedOn: aStream indent: level style: aTextStyleName 	"print the detailed formatted definition of the receiver on 	aStream. To be overloaded by subclasses if formatting is 	actually required"	| unformatted intro |	unformatted := self definitionString.	(self		stringNeedsFormatting: unformatted		indent: level		style: aTextStyleName)		ifTrue: 			[intro := 'union ' , name , ' switch ('.			aStream nextPutAll: intro.			switchtype				printFormattedOn: aStream				indent: level + (self tabFor: intro style: aTextStyleName) + 1				style: aTextStyleName.			aStream nextPutAll: ') {'; cr.			1 to: cases size				do: 					[:idx | 					| case |					case := cases at: idx.					(idx &gt;= cases size or: [case type ~~ (cases at: idx + 1)])						ifTrue: [case								printFormattedOn: aStream								indent: level + 1								style: aTextStyleName]						ifFalse: 							[case printDiscriminatorOn: aStream indent: level.							aStream cr]].			aStream tab: level; nextPut: $}]		ifFalse: [aStream nextPutAll: unformatted]</body><body package="Opentalk-IDL-MetaObjects">printOn: aStream 	"print the receiver's printname on the stream"	aStream nextPutAll: 'union ' , self idlName</body></methods><methods><class-id>Opentalk.DSTtypeUnion</class-id> <category>marshalling</category><body package="Opentalk-IDL-MetaObjects">boldMarshall: aParameter on: aStream 	"Marshall the parameter onto the stream"	self localClass == nil		ifTrue:  [self boldMarshallImplict: aParameter on: aStream]		ifFalse:  [self boldMarshallExplict: aParameter on: aStream ]</body><body package="Opentalk-IDL-MetaObjects">boldMarshall: aParameter on: aStream withLocalClass: aClass 	"Marshall the parameter onto the stream."	aClass == nil		ifTrue:  [self boldMarshallImplict: aParameter on: aStream]		ifFalse:  [self boldMarshallExplict: aParameter on: aStream withLocalClass: aClass ]</body><body package="Opentalk-IDL-MetaObjects">boldMarshallExplict: aParameter on: aStream	"Marshall the parameter onto the stream."	"This is an explict union (as marked by having a local class)."	"Determine which case to use and try to marshall it."	| discriminator case |	discriminator := aParameter discriminator.	case := self caseExplictDiscriminator: discriminator.	case == nil ifTrue: [self class marshallError: 0].	switchtype boldMarshall: discriminator on: aStream.	case boldMarshall: aParameter value on: aStream</body><body package="Opentalk-IDL-MetaObjects">boldMarshallExplict: aParameter on: aStream withLocalClass: aClass 	"Marshall the parameter onto the stream."	"This is an explict union (as marked by having a local class)."	"Determine which case to use and try to marshall it."	| discriminator case |	discriminator := aParameter discriminator.	case := self caseExplictDiscriminator: discriminator.	case == nil ifTrue: [self class marshallError: 0].	switchtype boldMarshall: discriminator on: aStream.	case boldMarshall: aParameter value on: aStream</body><body package="Opentalk-IDL-MetaObjects">boldMarshallImplict: aParameter on: aStream 	"Marshall the parameter onto the stream."	"This is an implict union (as marked by lacking a local class)."	"Determine which case to use and try to marshall it."	| case expr |	case := self caseImplictFor: aParameter.	expr := case discriminator value.	case isDefaultDiscriminator ifTrue: [expr := self defaultValue].	switchtype boldMarshall: expr on: aStream.	case boldMarshall: aParameter on: aStream</body><body package="Opentalk-IDL-MetaObjects">caseExplictDiscriminator: aDiscriminator 	"Return the case that has the discriminator 'aDiscriminator', 	or return nil if there is no match."	"In the explict case we can just look for a discriminator 	that matches."	| cadefault |	cadefault := nil.	cases do: [:case | 		case isDefaultDiscriminator			ifTrue: [cadefault := case]			ifFalse: [aDiscriminator = case discriminator value  ifTrue: [^case]]].	^cadefault</body><body package="Opentalk-IDL-MetaObjects">caseImplictFor: aParameter 	"Return the case for the parameter, or return nil"	"In the implict case we try each type to see how well 	it matches aParameter. If there are no perfect matches 	we use one that is mappable, failing that we return nil."	| mappableCase |	mappableCase := nil.	cases		do: 			[:case | 			| match |			match := case marshallMatch: aParameter.			match == true ifTrue: [^case].			match == #mappable ifTrue: [mappableCase := case]].	^mappableCase</body><body package="Opentalk-IDL-MetaObjects">marshallMatch: aParameter 	"Return: 		true			- if I can marshall the parameter 		false		- if I can NOT marshall the parameter 		#mappable	- if I can marshall the parameter by mapping to something else"	^self localClass == nil		ifTrue: 			[| mappable |			mappable := false.			cases				do: 					[:case | 					| match |					match := case marshallMatch: aParameter.					match == true ifTrue: [^true].					match == #mappable ifTrue: [mappable := match]].			mappable]		ifFalse: [aParameter isKindOf: self localClass]</body><body package="Opentalk-IDL-MetaObjects">marshallTypeCode: aDictionary on: aStream 	"marshall the type code of the receiver"	(self tryMarshallIndirectTypeCode: aDictionary on: aStream) ifTrue: [^self].	aStream nextPutUnsignedLong: self typeCode.	aStream nextPutEncapsulatedInOctets: [ :stream |		stream			nextPutASCIIString: self repositoryId asString;			nextPutASCIIString: self printName;			nextPutLocalType: self localType.		switchtype marshallTypeCode: aDictionary on: stream.		stream nextPutLong: self defaultIndex - 1;			nextPutUnsignedLong: cases size.		cases do: [:ca | 			"DSTtypeAny new marshall: ca discriminator value on: stream."			switchtype marshall: ca discriminator value on: stream.			stream nextPutASCIIString: ca type childName.			ca type marshallTypeCode: aDictionary on: stream] ]</body><body package="Opentalk-IDL-MetaObjects">unMarshall: aStream 	"Unmarshall a result from the stream and return an object of the 	appropriate class."	^self unMarshall: aStream withLocalClass: self localClass</body><body package="Opentalk-IDL-MetaObjects">unMarshall: aStream withLocalClass: aClass 	"Unmarshall a result from the stream and return an object of the 	appropriate class."	| switch value defaultCase |	switch := switchtype unMarshall: aStream.	cases do: [:ca | switch = ca discriminator value			ifTrue: 				[value := ca unMarshall: aStream.				^aClass notNil					ifTrue: [aClass discriminator: switch value: value]					ifFalse: [value]]			ifFalse: [ca discriminator == #default ifTrue: [defaultCase := ca]]].	defaultCase isNil		ifTrue: [^self class marshallError: 0]		ifFalse: 			[value := defaultCase unMarshall: aStream.			^aClass notNil				ifTrue: [aClass discriminator: switch value: value]				ifFalse: [value]]</body><body package="Opentalk-IDL-MetaObjects">unMarshallTypeCode: aDictionary from: aStream 	"unmarshall the type code of the receiver"	| mo sz byteOrder locType |	aDictionary add: aStream position -&gt; self.	aStream nextUnsignedLong.	byteOrder := aStream byteOrder.	aStream byteOrder: aStream nextBoolean.	repositoryId := aStream nextASCIIString.	repositoryId isEmpty ifFalse: [		repositoryId := RepositoryId fromString: repositoryId.		mo := DSTORBObject lookupMetaId: repositoryId ].	name := aStream nextASCIIString.	(name isEmpty and: [mo notNil]) ifTrue: [name := mo name].	locType := aStream nextLocalType.	switchtype := self class unMarshallTypeCode: aDictionary from: aStream.	defaultIndex := aStream nextLong + 1.	sz := aStream nextUnsignedLong.	cases :=		(1 to: sz) collect: [:idx || label discrim type |			"typ := DSTtypeAny new unMarshallType: aStream."			label := switchtype unMarshall: aStream.			discrim := DSTvalueNamed new initialize: aStream nextASCIIString.			discrim value: label.			discrim definedIn: self.			type := self class unMarshallTypeCode: aDictionary from: aStream.			"typ initialize: n."			type definedIn: self.			DSTUnionCase discriminator: discrim type: type].	defaultIndex &gt; 0 ifTrue: [(cases at: defaultIndex) discriminator: #default].	locType isNil		ifTrue: [mo isNil ifFalse: [mo localType isNil ifFalse: [self localType: mo localType]]]		ifFalse: [self localType: locType].	aStream byteOrder: byteOrder</body></methods><methods><class-id>Opentalk.DSTtypeUnion</class-id> <category>repository</category><body package="Opentalk-IDL-MetaObjects">CORBAName	"return the name of my CORBA interface in the repository"	^#'::CORBA::UnionDef'</body><body package="Opentalk-IDL-MetaObjects">allMetaObjectsInto: aSet 	"add all of the contained metaobjects to the set"	super allMetaObjectsInto: aSet.	switchtype allMetaObjectsInto: aSet.	cases do: [:case | case allMetaObjectsInto: aSet]</body><body package="Opentalk-IDL-MetaObjects">canApplyPragma: pragma 	"Check to see if the argument pragma can be applied to the receiver."	^#(#CLASS) includes: pragma</body><body package="Opentalk-IDL-MetaObjects">defKind        "Return the definition kind."        ^#dk_Union</body><body package="Opentalk-IDL-MetaObjects">lookupName: aSymbol levels: anInt limit: limitType excludeInherited: bool 	"Modified version of DSTMetaContainer's routine. Used to lookup 	definitions within a structure."	cases do: [:ca | ca declarators do: [:d | d name == aSymbol ifTrue: [^Set with: d]]].	^#()</body><body package="Opentalk-IDL-MetaObjects">typeKind	"return the TCKind of the receiver"	^#tk_union</body><body package="Opentalk-IDL-MetaObjects">typeParamCount	"return the number of parameters which the receiver supports. 	Subtypes should overload as required"	^cases size * 3 + 2</body><body package="Opentalk-IDL-MetaObjects">typeParameter: anInt 	"return the nth parameter which the receiver supports. 	Subtypes should overload as required"	| n m case |	anInt = 1 ifTrue: [^self printName].	anInt = 2 ifTrue: [^switchtype].	(anInt between: 3 and: self typeParamCount)		ifTrue: 			[n := anInt - 3 // 3.			case := cases at: n + 1.			(m := anInt \\ 3) = 0				ifTrue: [^case discriminator value asString]				ifFalse: [^m = 1						ifTrue: [case type printName asString]						ifFalse: [case type]]].	self error: #Bounds</body></methods><methods><class-id>Opentalk.DSTtypeUnion</class-id> <category>accessing</category><body package="Opentalk-IDL-MetaObjects">allCaseValues	"Answer all case labels of the receiver"	| col |	col := OrderedCollection new.	cases do: [:case | col add: case discriminator value].	col remove: #default ifAbsent: [].	^col</body><body package="Opentalk-IDL-MetaObjects">defaultIndex	defaultIndex == nil ifTrue: [defaultIndex := 0].	^defaultIndex</body><body package="Opentalk-IDL-MetaObjects">defaultValue	"answer a computed value for the default case of the switchtype"	defaultValue == nil ifTrue: [		(defaultValue := switchtype valueExcept: self allCaseValues) == nil ifTrue: [self class marshallError: 1]].	^defaultValue</body><body package="Opentalk-IDL-MetaObjects">definedIn: aMetaObject 	"set the receiver's defining container meta object"	super definedIn: aMetaObject.	switchtype definedIn: aMetaObject.	cases		do: 			[:case | 			(case discriminator isMemberOf: DSTvalueNamed)				ifTrue: [case discriminator definedIn: switchtype].			case type definedIn: self]</body></methods><methods><class-id>Opentalk.DSTtypeUnion</class-id> <category>UnionDef</category><body package="Opentalk-IDL-MetaObjects">description	"return a union description"	|d|	d := (Dictionary new) 			add: #name -&gt; name; 			add: #id -&gt; self id; 			add: #definedIn -&gt; self definedInString; 			add: #version -&gt; self version; 			add: #type -&gt; self;			yourself.	d overrideCORBAType: (DSTORBObject lookupMetaId: #'::CORBA::TypeDescription').	^d</body><body package="Opentalk-IDL-MetaObjects">discriminatorType	"The discriminatorType attribute describes the union's discriminator 	type."	^switchtype</body><body package="Opentalk-IDL-MetaObjects">discriminatorTypeDef	"The discriminatorTypeDef attribute identifies the union's 	discriminator type."	^switchtype</body><body package="Opentalk-IDL-MetaObjects">discriminatorTypeDef: aTypeDef 	"Setting the discriminatorTypeDef attribute also updates the 	discriminatorType attribute. The type attribute is also updated."	self notYetImplemented</body><body package="Opentalk-IDL-MetaObjects">members	"The members attribute contains a description of each union 	member. The label of each union member description is a distinct 	value of the discriminator type. Adjacent members can have the 	same name. Members with the same name must also have the same 	type. A label with type octet and value 0 indicates the default union 	member."	^cases collect: [:case | 		(Dictionary new) 			add: #name -&gt; case type equivalentType childName; 			add: #label -&gt; case discriminator value; 			add: #type -&gt; case type; 			add: #typeDef -&gt; case type; 			yourself]</body><body package="Opentalk-IDL-MetaObjects">members: memberList 	"When setting the members attribute, the type member of the union 	member structure is ignored and should be set to TC_void. The type 	attribute is also updated."	self notYetImplemented</body></methods><methods><class-id>Opentalk.DSTtypeUnion</class-id> <category>initialization</category><body package="Opentalk-IDL-MetaObjects">name: aSymbol switch: switchType triples: anArray 	"initialize instance variables for a structure with given subtypes. 	The triples array contains a list of cases, where each triple is		(1:caseLabelValues 2:caseType 3:caseDeclarator)"	| oc |	name := aSymbol asSymbol.	switchtype := switchType.	oc := OrderedCollection new: anArray size.	anArray do: [:caseArray | (caseArray at: 1)			do: 				[:discrim | 				oc add: (DSTUnionCase						discriminator: discrim						type: (caseArray at: 2)						declarators: (Array with: (caseArray at: 3))).				discrim == #default ifTrue: [defaultIndex := oc size]]].	cases := oc asArray</body></methods><methods><class-id>Opentalk.DSTtypeWideString</class-id> <category>marshalling</category><body package="Opentalk-IDL-MetaObjects">boldMarshall: aParameter on: aStream 	"Marshall the parameter onto the stream"	"canMarshall not = nextPutWideString raises exception"	(self marshallMatch: aParameter) == false		ifTrue: [^self class marshallError: 0].	aStream nextPutWideString:  aParameter."  asTwoByteString."</body><body package="Opentalk-IDL-MetaObjects">boldMarshall: aParameter on: aStream withLocalClass: aClass 	"Marshall the parameter onto the stream"	(self marshallMatch: aParameter) == false		ifTrue: [^self class marshallError: 0].	aStream nextPutWideString: aParameter. "asTwoByteString."</body><body package="Opentalk-IDL-MetaObjects">marshallMatch: aParameter 	"Return: 	true			- if I can marshall the parameter 	false		- if I can NOT marshall the parameter 	#mappable	- if I can marshall the parameter by mapping to 	something else"	aParameter == nil ifTrue: [^#mappable].	^(aParameter isTwoByteArray or: [aParameter isCharacterArray])		and: [size == nil or: [size = 0 or: [aParameter size &lt;= size]]]</body><body package="Opentalk-IDL-MetaObjects">unMarshall: aStream withLocalClass: aClass 	"Unmarshall a result from the stream and return an object of the 	appropriate class."	| result |	result := aStream nextWideString.	aClass notNil ifTrue: [^aClass fromString: result].	^result</body></methods><methods><class-id>Opentalk.DSTtypeWideString</class-id> <category>Primitive Def</category><body package="Opentalk-IDL-MetaObjects">kind	"return the receiver's primitive type"	^#pk_wstring</body></methods><methods><class-id>Opentalk.DSTtypeWideString</class-id> <category>repository</category><body package="Opentalk-IDL-MetaObjects">defKind        "Return the definition kind."        ^#dk_Wstring</body><body package="Opentalk-IDL-MetaObjects">typeKind	"return the TCKind of the receiver"	^#tk_wstring</body></methods><methods><class-id>Opentalk.DSTtypeWideString</class-id> <category>initialization</category><body package="Opentalk-IDL-MetaObjects">initialize	"initialize the receiver"	super initialize.	name := 'wstring'</body><body package="Opentalk-IDL-MetaObjects">maxSize: anint	"initialize the receiver with the max size"	size := anint.	name := 'wstring'.	subtype := DSTtypeWideCharacter new</body></methods><methods><class-id>Opentalk.DSTtypeWideString</class-id> <category>printing</category><body package="Opentalk-IDL-MetaObjects">definitionString	"return my CDL type definition string"	^size isNil		ifTrue: ['wstring']		ifFalse: ['wstring&lt;' , size printString , '&gt;']</body></methods><methods><class-id>Opentalk.DSTpseudoTypeCode</class-id> <category>marshalling</category><body package="Opentalk-IDL-MetaObjects">boldMarshall: aParameter on: aStream 	"Marshall the aParameter's typecode onto the stream"	"canMarshall not = MNU on 'aParameter typeCode'"	| strm |	(self isComplexTypeCode: aParameter typeCode)		ifTrue: 			[strm := CDRStream on: (ByteArray new: 100).			aParameter marshallTypeCode: Dictionary new on: strm.			aStream padToLong.			aStream nextPutAll: strm contents]		ifFalse: [aParameter marshallTypeCode: Dictionary new on: aStream]</body><body package="Opentalk-IDL-MetaObjects">marshallMatch: aParameter 	"Return:		true			- if I can marshall the parameter		false		- if I can NOT marshall the parameter		#mappable	- if I can marshall the parameter by mapping to something else"		^aParameter respondsTo: #typeKind</body><body package="Opentalk-IDL-MetaObjects">marshallTypeCode: aDictionary on: aStream 	"marshall the type code of the receive"	aStream nextPutUnsignedLong: self typeCode</body><body package="Opentalk-IDL-MetaObjects">unMarshall: aStream 	"Unmarshall a result from the stream and return an object of the 	appropriate class."	| type tk ba strm byteOrder |	tk := aStream nextUnsignedLong.	(self isComplexTypeCode: tk)		ifTrue: 			[ba := self class typeCodeStreamDef unMarshall: aStream.			strm := (CDRStream on: (ByteArray new: ba size + 4)) reset.			strm nextPutUnsignedLong: ba size.			strm nextPutAll: ba.			strm reset]		ifFalse: 			[strm := aStream.			byteOrder := nil].	type := DSTMetaObject				unMarshallTypeCode: Dictionary new				from: strm				typeKind: tk.	byteOrder notNil ifTrue: [aStream byteOrder: byteOrder].	type definedIn: self definingMetaContainer.	^type</body><body package="Opentalk-IDL-MetaObjects">unMarshallTypeCode: aDictionary from: aStream 	"unmarshall the type code of the receiver - do nothing since the 	TCKind has already been unmarshalled and TypeCodes have no 	TypeCode parameters"	^self</body></methods><methods><class-id>Opentalk.DSTpseudoTypeCode</class-id> <category>testing</category><body package="Opentalk-IDL-MetaObjects">isComplexTypeCode: anInteger        ^anInteger &gt; 13 and: [anInteger ~= 18]</body></methods><methods><class-id>Opentalk.DSTpseudoTypeCode</class-id> <category>TypeCode</category><body package="Opentalk-IDL-MetaObjects">typeKind	"return the TCKind of the receiver"	^#tk_TypeCode</body></methods><methods><class-id>Opentalk.DSTpseudoTypeCode</class-id> <category>printing</category><body package="Opentalk-IDL-MetaObjects">IDLTypeName	"return the printable name of the receiver's IDL type"	^'TypeCode'</body><body package="Opentalk-IDL-MetaObjects">definitionString	"return my unformatted IDL definition string"	^'TypeCode'</body></methods><methods><class-id>Opentalk.DSTpseudoTypeCode</class-id> <category>repository</category><body package="Opentalk-IDL-MetaObjects">CORBAName	"return the name of my CORBA interface in the repository"	^#'::CORBA::PrimitiveDef'</body></methods><methods><class-id>Opentalk.DSTpseudoTypeCode</class-id> <category>Primitive Def</category><body package="Opentalk-IDL-MetaObjects">kind	"return the receiver's primitive type"	^#pk_TypeCode</body></methods><methods><class-id>Opentalk.DSTpseudoTypeCode class</class-id> <category>private</category><body package="Opentalk-IDL-MetaObjects">typeCodeStreamDef        "answer the type code stream definition"        ^TCStreamDef ifNil: [TCStreamDef := (DSTtypeSequence new) subtype: DSTtypeOctet new size: nil; localType: #ByteArray]</body></methods><methods><class-id>Opentalk.DSTtypeLongDouble</class-id> <category>repository</category><body package="Opentalk-IDL-MetaObjects">typeKind	"return the TCKind of the receiver"	^#tk_longdouble</body></methods><methods><class-id>Opentalk.DSTtypeLongDouble</class-id> <category>Primitive Def</category><body package="Opentalk-IDL-MetaObjects">kind	"return the receiver's primitive type"	^#pk_longdouble</body></methods><methods><class-id>Opentalk.DSTtypeLongDouble</class-id> <category>marshalling</category><body package="Opentalk-IDL-MetaObjects">boldMarshall: aParameter on: aStream 	"Marshall the parameter onto the stream"	"canMarshall not = MNU on asDouble"	aStream nextPutLongDouble: aParameter asLongDouble</body><body package="Opentalk-IDL-MetaObjects">marshallMatch: aParameter 	"Return:		true			- if I can marshall the parameter		false		- if I can NOT marshall the parameter		#mappable	- if I can marshall the parameter by mapping to something else"		^aParameter isKindOf: Number</body><body package="Opentalk-IDL-MetaObjects">unMarshall: aStream 	"Unmarshall a result from the stream and return an object of the 	appropriate class"	^aStream nextLongDouble</body></methods><methods><class-id>Opentalk.DSTtypeLongDouble</class-id> <category>initialization</category><body package="Opentalk-IDL-MetaObjects">initialize	"initialize the receiver"	super initialize.	name := 'long double'</body></methods><methods><class-id>Opentalk.DSToperationDescription</class-id> <category>accessing</category><body package="Opentalk-IDL-MetaObjects">contexts	^contexts</body><body package="Opentalk-IDL-MetaObjects">contexts: aValue	contexts := aValue</body><body package="Opentalk-IDL-MetaObjects">definedIn	^definedIn</body><body package="Opentalk-IDL-MetaObjects">definedIn: aValue	definedIn := aValue</body><body package="Opentalk-IDL-MetaObjects">exceptions	^exceptions</body><body package="Opentalk-IDL-MetaObjects">exceptions: aValue	exceptions := aValue</body><body package="Opentalk-IDL-MetaObjects">id	^id</body><body package="Opentalk-IDL-MetaObjects">id: aValue	id := aValue</body><body package="Opentalk-IDL-MetaObjects">mode	^mode</body><body package="Opentalk-IDL-MetaObjects">mode: aValue	mode := aValue</body><body package="Opentalk-IDL-MetaObjects">name	^name</body><body package="Opentalk-IDL-MetaObjects">name: aValue	name := aValue</body><body package="Opentalk-IDL-MetaObjects">parameters	^parameters</body><body package="Opentalk-IDL-MetaObjects">parameters: aValue	parameters := aValue</body><body package="Opentalk-IDL-MetaObjects">result	^result</body><body package="Opentalk-IDL-MetaObjects">result: aValue	result := aValue</body><body package="Opentalk-IDL-MetaObjects">version	^version</body><body package="Opentalk-IDL-MetaObjects">version: aValue	version := aValue</body></methods><methods><class-id>Opentalk.DSToperationDescription</class-id> <category>repository</category><body package="Opentalk-IDL-MetaObjects">corbaTypeIn: aRepository	^aRepository lookupMetaId: #'::CORBA::OperationDescription'</body></methods><methods><class-id>Opentalk.DSTexception</class-id> <category>accessing</category><body package="Opentalk-IDL-MetaObjects">definedIn: aMetaObject 	"set the receiver's defining container meta object"	super definedIn: aMetaObject.	members definedIn: aMetaObject</body><body package="Opentalk-IDL-MetaObjects">errorSignal	"return the receiver's error signal object. The instance variable signal must be laze initialized because in the parcel suppotwe have to nil it out."	^signal isNil		ifTrue: 			[signal := Object errorSignal newSignalMayProceed: false.			signal nameClass: self class message: self name.			signal notifierString: 'ORB Exception (' , name , ') -']		ifFalse: [signal]</body><body package="Opentalk-IDL-MetaObjects">errorType	"return the type of the exception"	^members</body></methods><methods><class-id>Opentalk.DSTexception</class-id> <category>Exception Def</category><body package="Opentalk-IDL-MetaObjects">description	"return an operation description"	^(DSTexceptionDescription new)		name: name;		id: self id; 		definedIn: self definedInString;		version: self version;		type: members;		yourself</body><body package="Opentalk-IDL-MetaObjects">members	"return the members of the receiver"	^members members</body><body package="Opentalk-IDL-MetaObjects">members: newMembers 	"return the members of the receiver"	self notYetImplemented</body><body package="Opentalk-IDL-MetaObjects">type	"return the members of the receiver"	^members</body></methods><methods><class-id>Opentalk.DSTexception</class-id> <category>repository</category><body package="Opentalk-IDL-MetaObjects">CORBAName	"return the name of my CORBA interface in the repository"	^#'::CORBA::ExceptionDef'</body><body package="Opentalk-IDL-MetaObjects">allMetaObjectsInto: aSet 	"add all of the referenced metaobjects to the set"	super allMetaObjectsInto: aSet.	members allMetaObjectsInto: aSet</body><body package="Opentalk-IDL-MetaObjects">canApplyPragma: pragma 	"Check to see if the argument pragma can be applied to the receiver."	^#(#ID #VERSION) includes: pragma</body><body package="Opentalk-IDL-MetaObjects">defKind        "Return the definition kind."        ^#dk_Exception</body></methods><methods><class-id>Opentalk.DSTexception</class-id> <category>testing</category><body package="Opentalk-IDL-MetaObjects">IIOPIsA: aRepositoryId	aRepositoryId asString = 'IDL:CORBA/ExceptionDef:1.0' ifTrue:[^true].	^super IIOPIsA: aRepositoryId</body><body package="Opentalk-IDL-MetaObjects">isDSTexception	^true</body></methods><methods><class-id>Opentalk.DSTexception</class-id> <category>printing</category><body package="Opentalk-IDL-MetaObjects">definitionString	"return my unformatted IDL definition string"	| aStream |	aStream := (String new: 80) writeStream.	aStream nextPutAll: 'exception '; nextPutAll: name; nextPutAll: ' {'.	members fields do: [:fld | aStream nextPutAll: fld definitionString; nextPut: $ ; nextPutAll: fld declaratorString; nextPutAll: '; '].	aStream nextPut: $}.	^aStream contents</body><body package="Opentalk-IDL-MetaObjects">printDefinitionOn: aStream indent: level style: aTextStyleName 	"print the IDL definition of the receiver on the stream"	| unformatted |	self printHeaderOn: aStream indent: level.	prefix isNil ifFalse: [CurrentPrefix ~= prefix prefixString			ifTrue: 				[aStream tab: level; nextPutAll: '#pragma  prefix '; nextPut: $"; nextPutAll: prefix prefixString; nextPut: $"; cr.				CurrentPrefix := prefix prefixString]].	(repositoryId isNil not and: [repositoryId ~= self generateRepositoryId])		ifTrue: [aStream tab: level; nextPutAll: '#pragma  ID '; nextPutAll: self printName; space; nextPut: $"; nextPutAll: repositoryId asString; nextPut: $"; cr].	version notNil ifTrue: [aStream tab: level; nextPutAll: '#pragma  version '; nextPutAll: self printName; space; nextPutAll: version; cr].	aStream tab: level.	unformatted := self definitionString.	(self		stringNeedsFormatting: unformatted		indent: level		style: aTextStyleName)		ifTrue: 			[aStream nextPutAll: 'exception '; nextPutAll: name; nextPutAll: ' {'; cr.			members fields				do: 					[:fld | 					aStream tab: level + 1.					fld						printFormattedOn: aStream						indent: level + 1						style: aTextStyleName.					aStream nextPut: $ ; nextPutAll: fld declaratorString; nextPut: $;; cr].			aStream tab: level; nextPut: $}]		ifFalse: [aStream nextPutAll: unformatted].	aStream nextPut: $;; cr</body><body package="Opentalk-IDL-MetaObjects">printOn: aStream	"print the receiver's printname on the stream"	aStream nextPutAll: 'exception ' , self idlName</body></methods><methods><class-id>Opentalk.DSTexception</class-id> <category>rendering</category><body package="Opentalk-IDL-MetaObjects">hasComponents	"return true iff I have components worthwhile to show in a browser 	window"	^members hasComponents</body></methods><methods><class-id>Opentalk.DSTexception</class-id> <category>parcel support</category><body package="Opentalk-IDL-MetaObjects">traceFrom: aTracer 	"Don't trace my signal"		"We have to remove the signal from cache, CORBAConstants.	DO NOT remove the following	line unless you absolutely know what you are doing."	signal notNil		ifTrue: [CORBAConstants removeKey: self idlName asSymbol ifAbsent: [] ].	signal := nil.	super traceFrom: aTracer.</body></methods><methods><class-id>Opentalk.DSTexception</class-id> <category>creation</category><body package="Opentalk-IDL-MetaObjects">id: anId  members: anArray	"initialize the receiver"	name := anId. 	members := DSTtypeStructure on: anArray.	signal := Object errorSignal newSignalMayProceed: false.	signal nameClass: self class message: anId.	signal notifierString: 'ORB Exception (' , name , ') -'.</body></methods><methods><class-id>Opentalk.DSTcachedInterface</class-id> <category>searching</category><body package="Opentalk-IDL-MetaObjects">allOperations	"returns an ordered collection of all of the operations defined by the 	receiver and its direct supertypes. This method will retrieve cached 	operations if needed"	| ifs | 	^allOperations notNil		ifTrue: [allOperations]		ifFalse: 			[allOperations := OrderedCollection new.			ifs := self withAllSuperiors.			ifs do: [:if | if entryPointVector do: [:opSelector | allOperations add: (self findOpBySelector: opSelector) operation]].			allOperations]</body><body package="Opentalk-IDL-MetaObjects">findOpByIndex: index 	"find the DSToperation by its index in the interface. Return an 	array with the operation and its local opSelector"	| op opSelector |	(index between: 0 and: epv size - 1)		ifFalse: [self class badOperationError: 0].	opSelector := epv at: index + 1.	op := self operations at: opSelector.	op isNil ifTrue: [(DSTORBObject remoteRepository notNil "and: [ORBDaemon running]")			ifTrue: 				[op := DSTORBObject remoteRepository getCachedOperation: opSelector interface: self repositoryId.				op definedIn "asUUID - this can't work" == self repositoryId					ifTrue: [op definedIn: self]					ifFalse: [self class intfReposError: 0].				self operations at: opSelector put: op]			ifFalse: [self class intfReposError: 0]].	^Array with: op with: op localOp</body><body package="Opentalk-IDL-MetaObjects">findOpInMyVector: opSelector 	"find the DSToperation in the this interface by its selector. Return an 	Operation object"	| op |	op := self operations at: opSelector ifAbsent: [^nil].	op isNil ifTrue: [(DSTORBObject remoteRepository notNil "and: [ORBDaemon running]")			ifTrue: 				[op := DSTORBObject remoteRepository getCachedOperation: opSelector interface: self repositoryId.				(RepositoryId fromString: op definedIn) == self repositoryId					ifTrue: [op definedIn: self]					ifFalse: [self class intfReposError: 0].				self operations at: opSelector put: op.				^op]].	^op</body></methods><methods><class-id>Opentalk.DSTcachedInterface</class-id> <category>accessing</category><body package="Opentalk-IDL-MetaObjects">epv	^epv</body><body package="Opentalk-IDL-MetaObjects">identity	^repositoryId</body><body package="Opentalk-IDL-MetaObjects">idlName	^idlName</body><body package="Opentalk-IDL-MetaObjects">operations	"return the receiver's operations"	myOperations isNil		ifTrue: 			[myOperations := IdentityDictionary new.			epv do: [:sel | myOperations at: sel put: nil]].	^myOperations</body><body package="Opentalk-IDL-MetaObjects">updateInheritance	"resolve missing inheritance references, if possible, to named 	interfaces in the repository"	"(name isMemberOf: ORBDeadObject)		ifTrue: [^nil]."	allOperations := myOperations := allSuperiors := nil</body></methods><methods><class-id>Opentalk.DSTcachedInterface</class-id> <category>private</category><body package="Opentalk-IDL-MetaObjects">name: aName idlName: aFullName repositoryId: anId superiors: aSupCollection epv: anEntryPointVector	name := aName.	idlName := aFullName.	repositoryId := RepositoryId fromString: anId.	superiors := aSupCollection.	epv := anEntryPointVector.</body></methods><methods><class-id>Opentalk.DSTcachedInterface</class-id> <category>repository</category><body package="Opentalk-IDL-MetaObjects">corbaTypeIn: aRepository	"return an instance of the DSTmetaObject subclass which can marshall an 	instance of the receiver."	^aRepository lookupMetaId: #'::SharedIR::CachedInterface'</body></methods><methods><class-id>Opentalk.DSTcachedInterface class</class-id> <category>instance creation</category><body package="Opentalk-IDL-MetaObjects">name: aName idlName: aFullName repositoryId: anId superiors: aSupCollection epv: anEntryPointVector 	^(self new)		name: aName		idlName: aFullName		repositoryId: anId		superiors: aSupCollection asSet		epv: anEntryPointVector; yourself</body></methods><methods><class-id>Opentalk.DSTtypeUnsignedLong</class-id> <category>marshalling</category><body package="Opentalk-IDL-MetaObjects">boldMarshall: aParameter on: aStream 	"Marshall the parameter onto the stream"	"canMarshall not = raises exception in nextPutUnsignedLong:"	aStream nextPutUnsignedLong: aParameter</body><body package="Opentalk-IDL-MetaObjects">unMarshall: aStream 	"Unmarshall a result from the stream and return an object of the 	appropriate class."	^aStream nextUnsignedLong</body></methods><methods><class-id>Opentalk.DSTtypeUnsignedLong</class-id> <category>Primitive Def</category><body package="Opentalk-IDL-MetaObjects">kind	"return the receiver's primitive type"	^#pk_ulong</body></methods><methods><class-id>Opentalk.DSTtypeUnsignedLong</class-id> <category>repository</category><body package="Opentalk-IDL-MetaObjects">typeKind	"return the TCKind of the receiver"	^#tk_ulong</body></methods><methods><class-id>Opentalk.DSTtypeUnsignedLong</class-id> <category>initialization</category><body package="Opentalk-IDL-MetaObjects">initialize	"initialize the receiver"	super initialize.	name := 'unsigned long'</body></methods><methods><class-id>Opentalk.DSTUnionCase</class-id> <category>initialize-release</category><body package="Opentalk-IDL-MetaObjects">discriminator: aDiscriminator type: aType 	discriminator := aDiscriminator.	type := aType</body></methods><methods><class-id>Opentalk.DSTUnionCase</class-id> <category>marshalling</category><body package="Opentalk-IDL-MetaObjects">boldMarshall: value on: aStream 	| decl |	decl := type declarators.	^(decl isEmpty			ifTrue: [type]			ifFalse: [decl first]) 		boldMarshall: value on: aStream</body><body package="Opentalk-IDL-MetaObjects">marshallMatch: aParameter 	"Return: 	true			- if I can marshall the parameter 	false		- if I can NOT marshall the parameter 	#mappable	- if I can marshall the parameter by mapping to something else"	| decl |	decl := type declarators.	^(decl isEmpty			ifTrue: [type]			ifFalse: [decl first]) 		marshallMatch: aParameter</body><body package="Opentalk-IDL-MetaObjects">unMarshall: aStream 	| decl |	decl := type declarators.	^(decl isEmpty			ifTrue: [type]			ifFalse: [decl first]) 		unMarshall: aStream</body></methods><methods><class-id>Opentalk.DSTUnionCase</class-id> <category>accessing</category><body package="Opentalk-IDL-MetaObjects">declarators	^type declarators</body><body package="Opentalk-IDL-MetaObjects">discriminator	^discriminator</body><body package="Opentalk-IDL-MetaObjects">discriminator: aDiscriminator	discriminator := aDiscriminator</body><body package="Opentalk-IDL-MetaObjects">type	^type</body></methods><methods><class-id>Opentalk.DSTUnionCase</class-id> <category>printing</category><body package="Opentalk-IDL-MetaObjects">printDeclaratorOn: aStream 	"print one cases declarator in the switch body of a union"	aStream nextPut: $ ; nextPutAll: type declaratorString; nextPutAll: '; '</body><body package="Opentalk-IDL-MetaObjects">printDiscriminatorOn: aStream indent: level 	"print one cases discriminator in the switch body of a union"	aStream tab: level.	discriminator == #default		ifTrue: [aStream nextPutAll: 'default: ']		ifFalse: [aStream nextPutAll: 'case '; nextPutAll: discriminator asIDLString; nextPutAll: ': ']</body><body package="Opentalk-IDL-MetaObjects">printFormattedOn: aStream indent: level style: aTextStyleName 	"print one case in the switch body of a union"	self printDiscriminatorOn: aStream indent: level .	type		printFormattedOn: aStream		indent: level + 1		style: aTextStyleName.	self printDeclaratorOn: aStream.	aStream cr</body><body package="Opentalk-IDL-MetaObjects">printOn: aStream 	"print one case in the switch body of a union"	self printDiscriminatorOn: aStream indent: 0.	aStream nextPutAll: type definitionString.	self printDeclaratorOn: aStream</body></methods><methods><class-id>Opentalk.DSTUnionCase</class-id> <category>testing</category><body package="Opentalk-IDL-MetaObjects">isDefaultDiscriminator	^discriminator value == #default</body></methods><methods><class-id>Opentalk.DSTUnionCase</class-id> <category>repository</category><body package="Opentalk-IDL-MetaObjects">allMetaObjectsInto: aSet 	"add all of the contained metaobjects to the set"	(discriminator respondsTo: #allMetaObjectsInto:)		ifTrue: [discriminator allMetaObjectsInto: aSet].	type allMetaObjectsInto: aSet</body></methods><methods><class-id>Opentalk.DSTUnionCase class</class-id> <category>instance creation</category><body package="Opentalk-IDL-MetaObjects">discriminator: discriminator type: type	| case |	case := self new.	case discriminator: discriminator type: type.	^case</body><body package="Opentalk-IDL-MetaObjects">discriminator: discriminator type: type declarators: declarators	| case |	case := self new.	case discriminator: discriminator type: type.	type declarators: declarators.	^case</body></methods><methods><class-id>Opentalk.DSTtypeAny</class-id> <category>repository</category><body package="Opentalk-IDL-MetaObjects">typeKind	"return the TCKind of the receiver"	^#tk_any</body></methods><methods><class-id>Opentalk.DSTtypeAny</class-id> <category>Primitive Def</category><body package="Opentalk-IDL-MetaObjects">kind	"return the receiver's primitive type"	^#pk_any</body></methods><methods><class-id>Opentalk.DSTtypeAny</class-id> <category>initialize-release</category><body package="Opentalk-IDL-MetaObjects">initialize	"initialize the receiver"	super initialize.	name := 'any'</body></methods><methods><class-id>Opentalk.DSTtypeAny</class-id> <category>marshalling</category><body package="Opentalk-IDL-MetaObjects">boldMarshall: aParameter on: aStream 	"Marshall the parameter onto the stream"	| type value strm |	localtype notNil		ifTrue: 			[type := aParameter type.			value := aParameter value]		ifFalse: 			[type := CORBATypeMap at: aParameter ifAbsent: [aParameter corbaTypeIn: aStream repository].			value := aParameter].	(self isComplexTypeCode: type typeCode)		ifTrue: 			[strm := CDRStream on: (ByteArray new: 100).			type marshallTypeCode: Dictionary new on: strm.			aStream padToLong.			aStream nextPutAll: strm contents]		ifFalse: [type marshallTypeCode: Dictionary new on: aStream].	type boldMarshall: value on: aStream</body><body package="Opentalk-IDL-MetaObjects">marshallMatch: aParameter 	"Return if the receiver can marshall the given parameter. If it is an 	association (the representation of a Smalltalk any), or if such a 	representation can be built, return true"	"Return:		true			- if I can marshall the parameter		false		- if I can NOT marshall the parameter		#mappable	- if I can marshall the parameter by mapping to something else"		^localtype notNil		ifTrue: [aParameter isKindOf: self localClass]		ifFalse: [(aParameter corbaTypeIn: self repository) marshallMatch: aParameter]</body><body package="Opentalk-IDL-MetaObjects">unMarshall: aStream 	"Unmarshall a result from the stream and return an object of the 	appropriate class."	| type obj tk ba strm byteOrder |	tk := aStream nextUnsignedLong.	(self isComplexTypeCode: tk)		ifTrue: 			[ba := self class typeCodeStreamDef unMarshall: aStream.			strm := (CDRStream on: (ByteArray new: ba size + 4)) reset.			strm nextPutUnsignedLong: ba size.			strm nextPutAll: ba.			strm reset]		ifFalse: 			[strm := aStream.			byteOrder := nil].	type := DSTMetaObject				unMarshallTypeCode: Dictionary new				from: strm				typeKind: tk.	byteOrder notNil ifTrue: [aStream byteOrder: byteOrder].	type definedIn: self definingMetaContainer.	obj := type unMarshall: aStream.	^localtype notNil		ifTrue: [(self localClass new) type: type; value: obj; yourself]		ifFalse: 			[((self isComplexTypeCode: tk)			and: [ (obj isKindOf: Union)					or: [ (obj isKindOf: Collection)						and: [(obj isSymbol) not]]])				ifTrue: [CORBATypeMap at: obj put: type].			obj]</body></methods><methods><class-id>Opentalk.DSTtypeAny</class-id> <category>testing</category><body package="Opentalk-IDL-MetaObjects">isComplexTypeCode: anInteger	^anInteger &gt; 13 and: [(#(18 23 24 25 26 27 28) includes: anInteger) not]</body></methods><methods><class-id>Opentalk.DSTtypeAny class</class-id> <category>private</category><body package="Opentalk-IDL-MetaObjects">typeCodeStreamDef	"answer the type code stream definition"	^TCStreamDef ifNil: [TCStreamDef := (DSTtypeSequence new) subtype: DSTtypeOctet new size: nil; localType: #ByteArray]</body></methods><methods><class-id>Opentalk.DSTtypeAny class</class-id> <category>testing</category><body package="Opentalk-IDL-MetaObjects">test	((DSTtype withAllSubclasses) remove: DSTtypeNamed; yourself) do: [:cl | self test: cl]</body><body package="Opentalk-IDL-MetaObjects">test: cl 	Transcript print: cl name; flush.	cl allInstances do: [:mo | self testMO: mo].	Transcript cr; flush</body></methods><methods><class-id>Opentalk.DSTtypeAny class</class-id> <category>override corbatype</category><body package="Opentalk-IDL-MetaObjects">overrideCORBAType: aDSTMetaObject forObject: anObject 	"override the default CORBAType"	(aDSTMetaObject isDSTMetaObject and: [aDSTMetaObject isDSTtype or: [aDSTMetaObject isDSTinterface]])		ifTrue: [CORBATypeMap at: anObject put: aDSTMetaObject]		ifFalse: [self class badParamError: 0]</body></methods><methods><class-id>Opentalk.DSTtypeAny class</class-id> <category>class initialization</category><body package="Opentalk-IDL-MetaObjects">initialize	"DSTtypeAny initialize"	"This doesn't allow nil as a key	CORBATypeMap := OtWeakKeyDictionary new: 2011"	CORBATypeMap := EphemeronDictionary new: 2011</body><body package="Opentalk-IDL-MetaObjects">release	"release class variables"	CORBATypeMap := TCStreamDef := nil</body></methods><methods><class-id>Opentalk.DSTcachedException</class-id> <category>errorType</category><body package="Opentalk-IDL-MetaObjects">errorTypeCodeInfo	"return the type of the exception"	^typeCodeInfo ifNil: [self class intfReposError: 0]</body></methods><methods><class-id>Opentalk.DSTcachedException</class-id> <category>private</category><body package="Opentalk-IDL-MetaObjects">id: anId idlName: aFullName repositoryId: aRepositoryId members: aByteArray 	"initialize the receiver"	name := anId.	idlName := aFullName.	repositoryId := RepositoryId fromString: aRepositoryId.	typeCodeInfo := aByteArray.	members := DSTMetaObject unMarshallTypeCode: Dictionary new from: (TCCDRStream with: aByteArray) reset.	signal := Object errorSignal newSignalMayProceed: false.	signal notifierString: 'ORB Exception (' , name , ') -'.	signal nameClass: self class message: anId.</body></methods><methods><class-id>Opentalk.DSTcachedException</class-id> <category>accessing</category><body package="Opentalk-IDL-MetaObjects">idlName 	^idlName</body></methods><methods><class-id>Opentalk.DSTcachedException</class-id> <category>repository</category><body package="Opentalk-IDL-MetaObjects">corbaTypeIn: aRepository	"return an instance of the DSTmetaObject subclass which can marshall an 	instance of the receiver."	^aRepository lookupMetaId: #'::SharedIR::CachedException'</body></methods><methods><class-id>Opentalk.DSTcachedException class</class-id> <category>instance creation</category><body package="Opentalk-IDL-MetaObjects">name: aSymbol idlName: aString repositoryId: aRepositoryId errorTypeCodeInfo: aByteArray		^(self new) id: aSymbol idlName: aString repositoryId: aRepositoryId members: aByteArray; yourself</body></methods><methods><class-id>Opentalk.DSTexceptionDescription</class-id> <category>accessing</category><body package="Opentalk-IDL-MetaObjects">definedIn	^definedIn</body><body package="Opentalk-IDL-MetaObjects">definedIn: aValue	definedIn := aValue</body><body package="Opentalk-IDL-MetaObjects">id	^id</body><body package="Opentalk-IDL-MetaObjects">id: aValue	id := aValue</body><body package="Opentalk-IDL-MetaObjects">name	^name</body><body package="Opentalk-IDL-MetaObjects">name: aValue	name := aValue</body><body package="Opentalk-IDL-MetaObjects">type	^type</body><body package="Opentalk-IDL-MetaObjects">type: aValue	type := aValue</body><body package="Opentalk-IDL-MetaObjects">version	^version</body><body package="Opentalk-IDL-MetaObjects">version: aValue	version := aValue</body></methods><methods><class-id>Opentalk.DSTexceptionDescription</class-id> <category>repository</category><body package="Opentalk-IDL-MetaObjects">corbaTypeIn: aRepository	^aRepository lookupMetaId: #'::CORBA::ExceptionDescription'</body></methods><methods><class-id>Opentalk.DSTmoduleRepository</class-id> <category>Repository</category><body package="Opentalk-IDL-MetaObjects">createArray: length elementType: aType 	"The createArray operation returns a new ArrayDef with the 	specified length and elementType. 	It is the callers responsibility to invoke destroy on the returned 	object if it is not successfully used in creating a definition that is 	derived from contained (as createSequence is NOT derived from 	Contained)."	self notYetImplemented</body><body package="Opentalk-IDL-MetaObjects">createFixed: arg1 scale: arg2 	self notYetImplemented</body><body package="Opentalk-IDL-MetaObjects">createSequence: bound elementType: aType 	"The createSequence operation returns a new SequenceDef with the 	specified bound and elementType. 	It is the callers responsibility to invoke destroy on the returned 	object if it is not successfully used in creating a definition that is 	derived from contained (as createSequence is NOT derived from 	Contained)."	self notYetImplemented</body><body package="Opentalk-IDL-MetaObjects">createString: bound 	"The createString operation returns a new StringDef with the 	specified bound, which must be non-zero. The getPrimitive 	operation is used for unbounded strings. 	It is the callers responsibility to invoke destroy on the returned 	object if it is not successfully used in creating a definition that is 	derived from contained (as createString is NOT derived from 	Contained)."	self notYetImplemented</body><body package="Opentalk-IDL-MetaObjects">createWideString: bound 	"The createString operation returns a new StringDef with the 	specified bound, which must be non-zero. The getPrimitive 	operation is used for unbounded strings. 	It is the callers responsibility to invoke destroy on the returned 	object if it is not successfully used in creating a definition that is 	derived from contained (as createString is NOT derived from 	Contained)."	self notYetImplemented</body><body package="Opentalk-IDL-MetaObjects">getPrimitive: pk 	"The getPrimitive operation returns a reference to a PrimitiveDef 	with the specified kind attribute. All PrimitiveDefs are immutable 	and are owned by the repository."	| prim type |	pk isSymbol		ifTrue: 			[name := #'CORBA::PrimitiveKind::' , pk.			type := CORBAConstants at: name]		ifFalse: [type := pk].	prim := self class primitiveKindTable at: type name ifAbsent: [self error: 'Invalid primitive kind specified'].	^prim new widenTo: #'::CORBA::PrimitiveDef'</body><body package="Opentalk-IDL-MetaObjects">lookupId: aRepositoryId 	"return the repository meta object associated with the RepositoryId"	| mo |	mo := self class lookupId: aRepositoryId.	mo isNil ifTrue: [aRepositoryId formatName == #IDL ifTrue: [mo := self lookup: (self extractFullName: aRepositoryId)]].	^mo</body></methods><methods><class-id>Opentalk.DSTmoduleRepository</class-id> <category>printing</category><body package="Opentalk-IDL-MetaObjects">printOn: aStream 	"print the receiver's printname on the stream"	aStream nextPutAll: 'repository ' , self printName</body></methods><methods><class-id>Opentalk.DSTmoduleRepository</class-id> <category>MetaSem</category><body package="Opentalk-IDL-MetaObjects">definingMetaObject	"return the receiver's defining meta object"	^self</body></methods><methods><class-id>Opentalk.DSTmoduleRepository</class-id> <category>repository-private</category><body package="Opentalk-IDL-MetaObjects">canContain: kind 	"Check to see if the definition kind can be contained in the receiver."	^#(#dk_Constant #dk_Typedef #dk_Exception #dk_Interface #dk_Module) includes: kind</body></methods><methods><class-id>Opentalk.DSTmoduleRepository</class-id> <category>repository</category><body package="Opentalk-IDL-MetaObjects">CORBAName	"return the name of my CORBA interface in the repository"	^#'::CORBA::Repository'</body><body package="Opentalk-IDL-MetaObjects">addMetaObject: aMetaObject 	"Add the meta-object to the Repository. allow any kind IDL Definition 	to be added in the Repository so foreign forward declarations can be 	supported"	| mos |	contents add: aMetaObject.	self registerMetaObject: aMetaObject.	(aMetaObject isDSTMetaObject and: [aMetaObject isDSTMetaContainer])		ifTrue: ["this is what DST will always generate and normally expects to see"			aMetaObject definedInOnly: self]		ifFalse: ["this implies something foreign and not expected, the aMetaObject 			has to inform all of his children"			[aMetaObject definedIn: self]				on: Object messageNotUnderstoodSignal				do: 					[:ex | 					"be sure to do something legal"					| theMessage |					theMessage := ex parameter.					(theMessage class = Message and: [theMessage selector = #definedIn: and: [theMessage arguments = (Array with: self)]])						ifTrue: 							["aMetaObject did not understand the message 							#definedIn:"							aMetaObject definedInOnly: self.							ex return]						ifFalse: ["this was not our call, so we don't handle it"							ex reject]]].	mos := Set new.	aMetaObject allMetaObjectsInto: mos.	mos do: [:m | m registerIdentity]</body><body package="Opentalk-IDL-MetaObjects">defKind        "Return the definition kind."        ^#dk_Repository</body><body package="Opentalk-IDL-MetaObjects">metaObjectOf: aSymbol 	"return the meta object which is associated with the given identifier"	| obj |	^(self searchScopeFor: aSymbol)		ifNil: 			[obj := self searchScopeFor: #'CORBA::Object'.			obj notNil				ifTrue: [obj searchScopeFor: aSymbol]				ifFalse: [nil]]</body><body package="Opentalk-IDL-MetaObjects">searchOutwards: aString 	"Find and answer the meta object by resolving the scoped name 	aString. 	Iterate outwards towards enclosing name spaces. Otherwise return 	nil"	| mo nameComponents |	mo := self metaObjectOf: aString asSymbol.	nameComponents := self class parseName: aString.		[nameComponents removeLast.	mo == nil and: [nameComponents size &gt; 0]]		whileTrue: [mo := self metaObjectOf: (self class scopedNameFrom: nameComponents) asSymbol].	^(mo isMemberOf: DSTdeclaratorSimple)		ifTrue: [mo baseType]		ifFalse: [mo]</body><body package="Opentalk-IDL-MetaObjects">searchScopeFor: aSymbol 	"return the meta object which is associated with the given identifier"	| head str tail x |	aSymbol class == RepositoryId		ifTrue: [^self lookupId: aSymbol]		ifFalse: 			[str := aSymbol asString.			x := str findFirst: [:ch | ch = $:]].	x isZero		ifTrue: [^symbols at: aSymbol ifAbsent: [self searchSubScopeFor: aSymbol]]		ifFalse: 			[x = 1 ifTrue: [^self searchScopeFor: (str copyFrom: 3 to: str size) asSymbol].			head := str copyFrom: 1 to: x - 1.			tail := str copyFrom: x + 2 to: str size.			^(symbols at: head asSymbol ifAbsent: [^nil])				searchScopeFor: tail asSymbol].	^nil</body><body package="Opentalk-IDL-MetaObjects">searchSubScopeFor: aSymbol 	"If enabled, search contents for the symbol. 	Note that CORBA actually requires full name specification for referenced 	names outside of the scope of a metaobject. DST provides subscope 	searching as a convenience feature. If subscope searching is enabled, 	then this method will return the FIRST metaobject that is found using 	aSymbol. If subscope searching is disabled, then the result will be ALL 	metaobjects that can be found for aSymbol. The result must then be 	checked for uniqueness."	| m found |	found := nil.	contents do: [:mo | (m := mo searchScopeFor: aSymbol) notNil ifTrue: [self class convenientNameResolution				ifTrue: [^m]				ifFalse: [(found ifNil: [found := Set new])						add: m]]].	^found</body></methods><methods><class-id>Opentalk.DSTmoduleRepository</class-id> <category>accessing</category><body package="Opentalk-IDL-MetaObjects">idlName	"return the receivers full qualified name"	^''</body></methods><methods><class-id>Opentalk.DSTmoduleRepository</class-id> <category>parcel support</category><body package="Opentalk-IDL-MetaObjects">traceFrom: aTracer 	"If this module is the root,  stop tracing" 	aTracer doTraceOfDSTmoduleRepository: self</body></methods><methods><class-id>Opentalk.DSTmoduleRepository</class-id> <category>testing</category><body package="Opentalk-IDL-MetaObjects">IIOPIsA: aRepositoryId 	aRepositoryId asString = 'IDL:CORBA/Repository:1.0' ifTrue:[^true].	^super IIOPIsA: aRepositoryId</body></methods><methods><class-id>Opentalk.DSTmoduleRepository class</class-id> <category>rendering</category><body package="Opentalk-IDL-MetaObjects">iconId	"Return the key to find my icon image in the installed icon dictionary" 	^#DSTRepository</body></methods><methods><class-id>Opentalk.DSTmoduleRepository class</class-id> <category>accessing</category><body package="Opentalk-IDL-MetaObjects">convenientNameResolution	"answer whether name resolution will continue in the repository contents" 	^SearchSubscope ifNil: [SearchSubscope := true]</body><body package="Opentalk-IDL-MetaObjects">convenientNameResolution: aBoolean 	"set the flag whether name resolution will continue in the repository 	contents" 	^SearchSubscope := aBoolean == true</body></methods><methods><class-id>Opentalk.DSTmoduleRepository class</class-id> <category>private</category><body package="Opentalk-IDL-MetaObjects">primitiveKindTable	"answer the primitive kind table" 	^PKTable		ifNil: 			[PKTable := Dictionary new.			PKTable add: #pk_void -&gt; DSTtypeVoid.			PKTable add:  #pk_short -&gt; DSTtypeShort.			PKTable add:  #pk_long -&gt; DSTtypeLong.			PKTable add:  #pk_ushort -&gt; DSTtypeUnsignedShort.			PKTable add:  #pk_ulong -&gt; DSTtypeUnsignedLong.			PKTable add:  #pk_float -&gt; DSTtypeFloat.			PKTable add:  #pk_double -&gt; DSTtypeDouble.			PKTable add:  #pk_boolean -&gt; DSTtypeBoolean.			PKTable add:  #pk_char -&gt; DSTtypeCharacter.			PKTable add:  #pk_octet -&gt; DSTtypeOctet.			PKTable add:  #pk_any -&gt; DSTtypeAny.			PKTable add:  #pk_TypeCode -&gt; DSTpseudoTypeCode.			PKTable add:  #pk_Principal -&gt; DSTinterface.			PKTable add:  #pk_string -&gt; DSTtypeString.			PKTable add:  #pk_objref -&gt; DSTinterface.			PKTable add:  #pk_longlong -&gt; DSTtypeLongLong.			PKTable add:  #pk_ulonglong-&gt; DSTtypeUnsignedLongLong.			PKTable add:  #pk_longdouble -&gt; DSTtypeLongDouble.			PKTable add:  #pk_wchar -&gt; DSTtypeWideCharacter.			PKTable add:  #pk_wstring -&gt; DSTtypeWideString.			PKTable yourself]</body></methods><methods><class-id>Opentalk.DSTtypeWideCharacter</class-id> <category>marshalling</category><body package="Opentalk-IDL-MetaObjects">boldMarshall: aParameter on: aStream 	"Marshall the parameter onto the stream"	"canMarshall not = nextPutCharacter: raises exception"	aStream nextPutWideCharacter: aParameter</body><body package="Opentalk-IDL-MetaObjects">unMarshall: aStream 	"Unmarshall a result from the stream and return an object of the 	appropriate class."	^aStream nextWideCharacter</body></methods><methods><class-id>Opentalk.DSTtypeWideCharacter</class-id> <category>Primitive Def</category><body package="Opentalk-IDL-MetaObjects">kind	"return the receiver's primitive type"	^#pk_wchar</body></methods><methods><class-id>Opentalk.DSTtypeWideCharacter</class-id> <category>repository</category><body package="Opentalk-IDL-MetaObjects">typeKind	"return the TCKind of the receiver"	^#tk_wchar</body></methods><methods><class-id>Opentalk.DSTtypeWideCharacter</class-id> <category>initialization</category><body package="Opentalk-IDL-MetaObjects">initialize	"initialize the receiver"	super initialize.	name := 'wchar'</body></methods><methods><class-id>Opentalk.DSTparameterDescription</class-id> <category>accessing</category><body package="Opentalk-IDL-MetaObjects">mode	^mode</body><body package="Opentalk-IDL-MetaObjects">mode: aValue	mode := aValue</body><body package="Opentalk-IDL-MetaObjects">name	^name</body><body package="Opentalk-IDL-MetaObjects">name: aValue	name := aValue</body><body package="Opentalk-IDL-MetaObjects">type	^type</body><body package="Opentalk-IDL-MetaObjects">type: aValue	type := aValue</body><body package="Opentalk-IDL-MetaObjects">typeDef	^typeDef</body><body package="Opentalk-IDL-MetaObjects">typeDef: aValue	typeDef := aValue</body></methods><methods><class-id>Opentalk.DSTparameterDescription</class-id> <category>repository</category><body package="Opentalk-IDL-MetaObjects">corbaTypeIn: aRepository	^aRepository lookupMetaId: #'::CORBA::ParameterDescription'</body></methods><methods><class-id>Core.Object</class-id> <category>opentalk</category><body package="Opentalk-IDL-MetaObjects">asCORBAParameter	"Answer an object that confomrs to the CORBAParameter protocol as 	required by the IDL Smalltalk Language Mapping"	^ValueHolder with: self</body><body package="Opentalk-IDL-MetaObjects">corbaInterfaceIn: aRepository"return an instance of the DSTinterface which defines the behavior of the receiver when passed as a CORBA object. This must be a local repository object"	^aRepository searchScopeFor: self CORBAName asSymbol</body><body package="Opentalk-IDL-MetaObjects">CORBAName"return the CORBA name of the receiver's IDL definition in the local repository"	^#'::CORBA::Object'</body><body package="Opentalk-IDL-MetaObjects">corbaTypeIn: aRepository	"return an instance of the DSTmetaObject subclass which can marshall an 	instance of the receiver. This method must be implemented in every 	class which can be passed as an IDL type 'any' parameter. The returned 	object must be local"	^aRepository lookupMetaId: self CORBAName asSymbol</body><body package="Opentalk-IDL-MetaObjects">isCharacterArray	"Answer true if the receiver is an instance of CharacterArray or a sub-type."	^false</body><body package="Opentalk-IDL-MetaObjects">isCollection	"Answer true if the receiver is a collection."	^false</body><body package="Opentalk-IDL-MetaObjects">isDictionary	"Answer true if the receiver is a Dictionary."	^false</body><body package="Opentalk-IDL-MetaObjects">isDSTMetaObject	^false</body><body package="Opentalk-IDL-MetaObjects">isTwoByteArray	"Answer true if the receiver is a two byte array."	^false</body><body package="Opentalk-IDL-MetaObjects">overrideCORBAType: aMetaObject "Override the default CORBAType used when marshaling Any"	Opentalk.DSTtypeAny overrideCORBAType: aMetaObject forObject: self</body></methods><methods><class-id>Core.Integer</class-id> <category>DST</category><body package="Opentalk-IDL-MetaObjects">corbaTypeIn: aRepository	"return an instance of the DSTmetaObject subclass which can marshall an 	instance of the receiver. This method must be implemented in every 	class which can be passed as an IDL type 'any' parameter"	^Opentalk.DSTtypeLong new</body></methods><methods><class-id>Core.LargePositiveInteger</class-id> <category>DST</category><body package="Opentalk-IDL-MetaObjects">corbaTypeIn: aRepository	"return an instance of the DSTmetaObject subclass which can marshall an 	instance of the receiver. This method must be implemented in every 	class which can be passed as an IDL type 'any' parameter"	^Opentalk.DSTtypeUnsignedLongLong new</body></methods><methods><class-id>Core.Collection</class-id> <category>DST</category><body package="Opentalk-IDL-MetaObjects">isCollection	"Answer true if the receiver is a collection."	^true</body></methods><methods><class-id>Core.Character</class-id> <category>opentalk</category><body package="Opentalk-IDL-MetaObjects">corbaTypeIn: aRepository	"return an instance of the DSTmetaObject subclass which can marshall an 	instance of the receiver. This method must be implemented in every 	class which can be passed as an IDL type 'any' parameter"	^(self codePoint &lt; 256) ifTrue: [Opentalk.DSTtypeCharacter new] ifFalse: [Opentalk.DSTtypeWideCharacter new].</body></methods><methods><class-id>Core.FixedPoint</class-id> <category>opentalk</category><body package="Opentalk-IDL-MetaObjects">corbaTypeIn: aRepository	"return an instance of the DSTmetaObject subclass which can marshall an 	instance of the receiver. This method must be implemented in every 	class which can be passed as an IDL type 'any' parameter"	| abs integral fractional log |	abs := self abs.	abs &lt; 1 ifTrue: [		fractional := scale min: 31.		^Opentalk.DSTtypeFixed new			digits: fractional;			scale: fractional;			yourself ].	log := abs truncated log.	integral := log ceiling.	integral &gt; 31 ifTrue: [ self error: 'Maximum size of fixed is 31 decimal digits!' ].	log &lt; integral ifFalse: [		"1000 log = 3.0, but is 4 digits"		integral := integral + 1 ].	fractional := scale min: 31 - integral.	^Opentalk.DSTtypeFixed new		digits: integral + fractional;		scale: fractional		yourself</body></methods><methods><class-id>Core.ByteEncodedString</class-id> <category>opentalk</category><body package="Opentalk-IDL-MetaObjects">corbaTypeIn: aRepository	"return an instance of the DSTmetaObject subclass which can marshall an 	instance of the receiver. This method must be implemented in every 	class which can be passed as an IDL type 'any' parameter"	^Opentalk.DSTtypeString new localType: self class name; yourself</body></methods><methods><class-id>Core.LargeInteger</class-id> <category>DST</category><body package="Opentalk-IDL-MetaObjects">corbaTypeIn: aRepository	"return an instance of the DSTmetaObject subclass which can marshall an 	instance of the receiver. This method must be implemented in every 	class which can be passed as an IDL type 'any' parameter"	^Opentalk.DSTtypeLongLong new</body></methods><methods><class-id>Graphics.ComposedText class</class-id> <category>DST</category><body package="Opentalk-IDL-MetaObjects">widthOfString: aString styleName: aSymbol 	"Calculate the width of the string if composed with the 	specified style (e.g. #default, #fixed)"	^self widthOfText: aString asText styleName: aSymbol</body><body package="Opentalk-IDL-MetaObjects">widthOfText: aText styleName: aSymbol 	"Calculate the width of the text if composed with the specified 	style (e.g. #default, #fixed)"	^(ComposedText withText: aText style: (aSymbol == #default			ifTrue: [TextConstants at: #DefaultTextStyle]			ifFalse: [TextAttributes styleNamed: aSymbol])) width</body></methods><methods><class-id>Core.Double</class-id> <category>opentalk</category><body package="Opentalk-IDL-MetaObjects">corbaTypeIn: aRepository	"return an instance of the DSTmetaObject subclass which can marshall an 	instance of the receiver. This method must be implemented in every 	class which can be passed as an IDL type 'any' parameter"	^Opentalk.DSTtypeDouble new</body><body package="Opentalk-IDL-MetaObjects">xcorbaTypeIn: aRepository	"return an instance of the DSTmetaObject subclass which can marshall an 	instance of the receiver. This method must be implemented in every 	class which can be passed as an IDL type 'any' parameter"	^Opentalk.DSTtypeDouble new</body></methods><methods><class-id>Core.Dictionary</class-id> <category>DST</category><body package="Opentalk-IDL-MetaObjects">isDictionary	"Answer true if the receiver is a Dictionary."	^true</body></methods><methods><class-id>Core.Boolean</class-id> <category>opentalk</category><body package="Opentalk-IDL-MetaObjects">corbaTypeIn: aRepository	"Return an instance of the DSTmetaObject subclass which can marshall an 	instance of the receiver. This method must be implemented in every class 	that can be passed as an IDL type 'any' parameter."	^Opentalk.DSTtypeBoolean new</body></methods><methods><class-id>Core.TwoByteSymbol</class-id> <category>opentalk</category><body package="Opentalk-IDL-MetaObjects">isCharacterArray	"Answer true if the receiver is an instance of CharacterArray or a 	sub-type. TwoByte strings/symbols should not really be thought of 	as character arrays."	^false</body><body package="Opentalk-IDL-MetaObjects">isTwoByteArray	"Answer true if the receiver is a two byte character array."	^true</body></methods><methods><class-id>Opentalk.LongDouble</class-id> <category>DST</category><body package="Opentalk-IDL-MetaObjects">corbaTypeIn: aRepository	"return an instance of the DSTmetaObject subclass which can marshall an 	instance of the receiver. This method must be implemented in every 	class which can be passed as an IDL type 'any' parameter"	^DSTtypeLongDouble new</body></methods><methods><class-id>Kernel.CodeWriteAnalysisTracer</class-id> <category>tracing</category><body package="Opentalk-IDL-MetaObjects">doTraceOfDSTInterface: anObject	"We need to cut of the subordinates of the dstInterface"	| save |	save := anObject subordinates.	anObject subordinates: nil.	self doTraceOfObject: anObject.	anObject subordinates: save.</body><body package="Opentalk-IDL-MetaObjects">doTraceOfDSTmoduleRepository: anObject	"no op"</body></methods><methods><class-id>Core.FourByteString</class-id> <category>opentalk</category><body package="Opentalk-IDL-MetaObjects">corbaTypeIn: aRepository	"return an instance of the DSTmetaObject subclass which can marshall an 	instance of the receiver. This method must be implemented in every 	class which can be passed as an IDL type 'any' parameter"	^(Opentalk.DSTtypeWideString new) localType: self class name; yourself</body></methods><methods><class-id>Opentalk.Enumerator</class-id> <category>repository</category><body package="Opentalk-IDL-MetaObjects">corbaTypeIn: aRepository	"return an instance of the DSTmetaObject subclass which can marshall an 	instance of the receiver."	^self type</body></methods><methods><class-id>Core.Float</class-id> <category>DST</category><body package="Opentalk-IDL-MetaObjects">corbaTypeIn: aRepository	"return an instance of the DSTmetaObject subclass which can marshall an 	instance of the receiver. This method must be implemented in every 	class which can be passed as an IDL type 'any' parameter"	^Opentalk.DSTtypeFloat new</body></methods><methods><class-id>Opentalk.NCSuuid</class-id> <category>repository</category><body package="Opentalk-IDL-MetaObjects">corbaTypeIn: aRepository	"return an instance of the DSTmetaObject subclass which can 	marshall an instance of the receiver."	^aRepository lookupMetaId: #'::CORBA::ORBId'</body></methods><methods><class-id>Opentalk.CDRStream</class-id> <category>accessing</category><body package="Opentalk-IDL-MetaObjects">repository	^self marshaler repository</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>DST</category><body package="Opentalk-IDL-MetaObjects">capitalized	self isEmpty ifFalse:  [| newString |		newString := self shallowCopy.		newString at: 1 put: (self at: 1) asUppercase.		^newString].	^self</body><body package="Opentalk-IDL-MetaObjects">isCharacterArray	"Answer true if the receiver is an instance of CharacterArray or a 	sub-type (except wide strings - see TwoByteString)."	^true</body><body package="Opentalk-IDL-MetaObjects">unCapitalized	"Answer the receiver whose first character is lower cased."	self isEmpty ifFalse: [| newString |		newString := self shallowCopy.		newString at: 1 put: (self at: 1) asLowercase.		^newString].	^self</body></methods><methods><class-id>Kernel.CodeWriter</class-id> <category>dst tracing</category><body package="Opentalk-IDL-MetaObjects">doTraceOfDSTInterface: anObject	"We need to cut of the subordinates of the dstInterface"	| save |	save := anObject subordinates.	anObject subordinates: nil.	self doTraceOfObject: anObject.	anObject subordinates: save.</body><body package="Opentalk-IDL-MetaObjects">doTraceOfDSTmoduleRepository: anObject		stream storeObjectPointer: 1</body></methods><methods><class-id>Core.TwoByteString</class-id> <category>DST</category><body package="Opentalk-IDL-MetaObjects">corbaTypeIn: aRepository	"return an instance of the DSTmetaObject subclass which can 	marshall an 	instance of the receiver. This method must be implemented in every 	class which can be passed as an IDL type 'any' parameter"	^(Opentalk.DSTtypeWideString new) localType: self class name; yourself</body><body package="Opentalk-IDL-MetaObjects">isCharacterArray	"Answer true if the receiver is an instance of CharacterArray or a 	sub-type. TwoByte strings/symbols should not really be thought of 	as character arrays."	^false</body><body package="Opentalk-IDL-MetaObjects">isTwoByteArray	"Answer true if the receiver is a two byte character array."	^true</body></methods><initialize><class-id>Opentalk.DSTORBObject</class-id></initialize><initialize><class-id>Opentalk.RepositoryId</class-id></initialize><initialize><class-id>Opentalk.ORBConstantsDictionary</class-id></initialize><initialize><class-id>Opentalk.DSTtypeVoid</class-id></initialize><initialize><class-id>Opentalk.DSTtypeAny</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Collection</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>ByteArray</name><environment>Core</environment><super>Core.IntegerArray</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>NCSuuid</name><environment>Opentalk</environment><super>Core.ByteArray</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Protocols-Core</category><attributes><package>Opentalk-IDL-Base</package></attributes></class><class><name>Float</name><environment>Core</environment><super>Core.LimitedPrecisionReal</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Integer</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>LargeInteger</name><environment>Core</environment><super>Core.Integer</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>LargePositiveInteger</name><environment>Core</environment><super>Core.LargeInteger</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Character</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>CharacterArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>Double</name><environment>Core</environment><super>Core.LimitedPrecisionReal</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Model</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dependents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>TwoByteString</name><environment>Core</environment><super>Core.String</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-String Support</category><attributes><package>Collections-String Support</package></attributes></class><class><name>ByteEncodedString</name><environment>Core</environment><super>Core.String</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars>encoder </class-inst-vars><imports></imports><category>Collections-String Support</category><attributes><package>Collections-String Support</package></attributes></class><class><name>TwoByteSymbol</name><environment>Core</environment><super>Core.Symbol</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-String Support</category><attributes><package>Collections-String Support</package></attributes></class><class><name>Enumerator</name><environment>Opentalk</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name value type </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>Opentalk-IDL-Base</package></attributes></class><class><name>Dictionary</name><environment>Core</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>OrderedCollection</name><environment>Core</environment><super>Core.SequenceableCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>firstIndex lastIndex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Sequenceable</category><attributes><package>Collections-Sequenceable</package></attributes></class><class><name>CDRStream</name><environment>Opentalk</environment><super>Core.ReadWriteStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>byteOrder charEncoder wcharEncoder marshaler </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Protocols-Core</category><attributes><package>Opentalk-CDR</package></attributes></class><class><name>Boolean</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>IdentityDictionary</name><environment>Core</environment><super>Core.Dictionary</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>valueArray </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>FixedPoint</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars>numerator denominator scale </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>CodeWriter</name><environment>Kernel</environment><super>Kernel.ObjectTracer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>definedObjects classes extendedClasses extensionMethods exclusionset definedBindings scopeZones currentClass objectSpace analysisTracer symbolNum stringNum byteArrayNum floatNum doubleNum largePositiveNum largeNegativeNum mclassNum mclassclassNum refNamObjNum scopeZonesNum defObjOrganizerNum classOrganizerNum arbObjectNum arbClassNum stream sourceStream sourceName hideOnLoad pointer currentKey properties prerequisites namedObjects newSourceKeys dateString timeString scratchDictionary codeComponent </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Code Storage</category><attributes><package>System-Code Storage</package></attributes></class><class><name>FourByteString</name><environment>Core</environment><super>Core.String</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-String Support</category><attributes><package>Collections-String Support</package></attributes></class><class><name>LongDouble</name><environment>Opentalk</environment><super>Core.LimitedPrecisionReal</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Opentalk-IDL-Base</package></attributes></class><class><name>CodeWriteAnalysisTracer</name><environment>Kernel</environment><super>Kernel.ObjectTracer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classifications mclassList referencedNamedObjects currentClass scopeZones codeMode packageClasses extendedClasses packageNamedObjects compiledMethodCount scratchDictionary codeComponent </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Code Storage</category><attributes><package>System-Code Storage</package></attributes></class></st-source>