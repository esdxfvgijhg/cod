<?xml version="1.0"?><st-source><!-- Name: Opentalk-IDL-BaseNotice: Copyright 1999-2013 Cincom Systems, Inc.  All rights reserved.Comment: Addional classes corresponding to those IDL types that don't have direct smalltalk counterparts.DbIdentifier: bear73DbTrace: 402321DbUsername: tkoganDbVersion: 7.10 - 2DevelopmentPrerequisites: #(#(#any 'Opentalk-Core' '') #(#any 'Opentalk-CDR' ''))PackageName: Opentalk-IDL-BaseParcel: #('Opentalk-IDL-Base')PrerequisiteParcels: #(#('Opentalk-Core' '') #('Opentalk-CDR' ''))PrintStringCache: (7.10 - 2,tkogan)Version: 7.10 - 2Date: 11:27:07 AM April 12, 2013 --><time-stamp>From VisualWorksÂ®, Pre-Release 7.10 (apr13.2) of April 12, 2013 on April 12, 2013 at 11:27:07 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>LongDouble</name><environment>Opentalk</environment><super>Core.LimitedPrecisionReal</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Opentalk-IDL-Base</package></attributes></class><comment><class-id>Opentalk.LongDouble</class-id><body>Instances of the class LongDouble represent represent an IEEE double-extendedfloating-point number, which supports of an exponent of at least 15 bits in lengthand a fraction of at least 63 bits. See IEEE Standard for Binary Floating-Point Arithmetic,ANSI/IEEE STd 754-1985, for a detailed specification."Right now this class is a value holder for long double values passed in from otherenvironment via DST. It has no real implementation except for what is needed forDST to handle the long double bits comming from the wire and not truncate themor transform them. I.e. a long double can survive a roundtrip through DST and comeback to the origionator unchanged.This is a detailed description of the bits for future implementation.The exponent (e1 and e2) is 15 bits long, where the 7 bits in e1 are the most significant.The value of long double is determined by the expression:  sign     (exponent - 16383)-1      * 2                           * (1 + fraction)Big-Endian                  octet-----------------| s |   e1      | 0 -----------------|       e2      | 1 -----------------|       f1      | 2 -----------------|       f2      | 3 -----------------|       f3      | 4 -----------------|       f4      | 5 -----------------|       f5      | 6 -----------------|       f6      | 7 -----------------|       f7      | 8 -----------------|       f8      | 9 -----------------|       f9      | 10 -----------------|       f10     | 11 -----------------|       f11     | 12-----------------|       f12     | 13-----------------|       f13     | 14-----------------|       f14     | 15-----------------Little-Endian                  octet-----------------|       f14     | 0 -----------------|       f13     | 1 -----------------|       f12     | 2 -----------------|       f11     | 3 -----------------|       f10     | 4 -----------------|       f9      | 5 -----------------|       f8      | 6 -----------------|       f7      | 7 -----------------|       f6      | 8 -----------------|       f5      | 9 -----------------|       f4      | 10 -----------------|       f3      | 11 -----------------|       f2      | 12-----------------|       f1      | 13-----------------|       e2      | 14-----------------| s |   e1      | 15-----------------</body></comment><class><name>NCSuuid</name><environment>Opentalk</environment><super>Core.ByteArray</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Protocols-Core</category><attributes><package>Opentalk-IDL-Base</package></attributes></class><comment><class-id>Opentalk.NCSuuid</class-id><body>This class implements the NCS 1.5.1 Universally Unique Identifier definition.  A UUIDconsists of a 16 byte quantity which encodes a network IP address and a timestamp value.  In order to allow UUIDs to be used as keys in various dictionariesmaintained by the ORBObject class, they are interned using similar code to thatin the Symbol class.Shared Variables:	NilId 		&lt;NCSuuid&gt; which contains all zero byte values &amp; denotes nil.	STable	 	&lt;Array&gt; The symbol table used to intern UUID values.	Sema 		&lt;Semaphore&gt; 	Tincr 		&lt;Integer&gt;	Tval		&lt;Integer&gt;</body></comment><class><name>Union</name><environment>Opentalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>discriminator value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>Opentalk-IDL-Base</package></attributes></class><comment><class-id>Opentalk.Union</class-id><body>This class implements a holder for type 'union' values which may be used to provide instances needed for remote method invocations where the CLASS pragma has been used to select the explicit marshalling styleInstance Variables:	discriminator		&lt;Object&gt; a value of the switch type of the union	value				&lt;Object&gt; the value of the union</body></comment><class><name>Any</name><environment>Opentalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>type value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>Opentalk-IDL-Base</package></attributes></class><comment><class-id>Opentalk.Any</class-id><body>This class implements a holder for type 'any' values which may be used to provide instances needed for remote method invocations where the CLASS pragma has been used to select the explicit marshalling styleInstance Variables:	type		&lt;DSTMetaObject&gt;  the type of the any	value		&lt;Object&gt; the value of the any</body></comment><class><name>Enumerator</name><environment>Opentalk</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name value type </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>Opentalk-IDL-Base</package></attributes></class><shared-variable><name>RadiansPerDegree</name><environment>Opentalk.LongDouble</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Opentalk-IDL-Base</package></attributes></shared-variable><shared-variable><name>Pi</name><environment>Opentalk.LongDouble</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Opentalk-IDL-Base</package></attributes></shared-variable><shared-variable><name>Sema</name><environment>Opentalk.NCSuuid</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Opentalk-IDL-Base</package></attributes></shared-variable><shared-variable><name>Tval</name><environment>Opentalk.NCSuuid</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Opentalk-IDL-Base</package></attributes></shared-variable><shared-variable><name>NilId</name><environment>Opentalk.NCSuuid</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Opentalk-IDL-Base</package></attributes></shared-variable><shared-variable><name>STable</name><environment>Opentalk.NCSuuid</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Opentalk-IDL-Base</package></attributes></shared-variable><shared-variable><name>Tincr</name><environment>Opentalk.NCSuuid</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Opentalk-IDL-Base</package></attributes></shared-variable><shared-variable><name>Type</name><environment>Opentalk.Enumerator</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Opentalk-IDL-Base</package></attributes></shared-variable><methods><class-id>Opentalk.LongDouble</class-id> <category>mathematical functions</category><body package="Opentalk-IDL-Base">arcCos	"Answer the angle in radians.	The receiver must be between -1.0 and 1.0	The result will be between 0.0 and Pi"	^self notImplemented</body><body package="Opentalk-IDL-Base">arcSin	"Answer the angle in radians.	The receiver must be between -1.0 and 1.0	The result will be between -Pi/2 and Pi/2"	^self notImplemented</body><body package="Opentalk-IDL-Base">arcTan	"Answer the angle in radians.	The receiver can be any valid LongDouble	The result will be between -Pi/2 and Pi/2"	^self notImplemented</body><body package="Opentalk-IDL-Base">cos	"return the cosine of the receiver (an angle in radians)	The receiver can be any valid LongDouble	The result will be between -1.0 and 1.0"	^self notImplemented</body><body package="Opentalk-IDL-Base">exp	"return the exponential function of the receiver 	The receiver may be between roughly -709.0 and 709.0 	The result will be greater than 0.0"	^self notImplemented</body><body package="Opentalk-IDL-Base">floorLog10	"Answer with a (quick) computation of (self log: 10) floor.	The receiver must be greater than zero	The result will be between -307 and 307"	^self notImplemented</body><body package="Opentalk-IDL-Base">ln	"answer the natural log of the reciever	The receiver must be greater than 0.0	The result will be between -709.0 and 709.0"	^self notImplemented</body><body package="Opentalk-IDL-Base">raisedTo: power 	"return (receiver ** power)"	^self notImplemented</body><body package="Opentalk-IDL-Base">sin	"return the sine of the receiver (an angle in radians)	The receiver can be any valid LongDouble	The result will be between -1.0 and 1.0"	^self notImplemented</body><body package="Opentalk-IDL-Base">sqrt	"Answer the square root of the receiver.	The receiver must be positive	The result will be positive"	^self notImplemented</body><body package="Opentalk-IDL-Base">tan	"Answer the ratio of the sine to cosine of the receiver in radians.	The receiver can be any valid Float--in practice it is unlikely that		a Float would have a value close enough to Pi/2, or -Pi/2, or		3*Pi/2, or . . . to cause the primitive to fail	The result will be between -Infinity and +Infinity--if failure occurs,		the value was arbitrarily large, either positive or negative"	^self notImplemented</body></methods><methods><class-id>Opentalk.LongDouble</class-id> <category>arithmetic</category><body package="Opentalk-IDL-Base">* aNumber 	"Answer a LongDouble that is the result of multiplying the receiver by the 	argument, aNumber.  The primitive fails if it cannot coerce the argument	to a LongDouble"	^self notImplemented</body><body package="Opentalk-IDL-Base">+ aNumber 	"Answer a LongDouble that is the result of adding the receiver to the argument.  	The primitive fails if it cannot coerce the argument to a LongDouble, or if 	overflow occurs."	^self notImplemented</body><body package="Opentalk-IDL-Base">- aNumber 	"Answer a LongDouble that is the difference between the receiver and aNumber.  	The primitive fails if it cannot coerce the argument to a LongDouble."	^self notImplemented</body><body package="Opentalk-IDL-Base">/ aNumber 	"Answer a LongDouble that is the exact result of dividing the receiver by the 	argument, anInteger.  The primitive fails if it cannot coerce the argument 	to a LongDouble."	^self notImplemented</body></methods><methods><class-id>Opentalk.LongDouble</class-id> <category>accessing</category><body package="Opentalk-IDL-Base">at: index        "Override implementation in Object since LongDouble        instances are not element indexable."         ^self shouldNotImplement</body><body package="Opentalk-IDL-Base">at: index put: value        "Override implementation in Object since LongDouble        instances are not element indexable."         ^self shouldNotImplement</body><body package="Opentalk-IDL-Base">size        "Override implementation in Object since LongDouble        instances are not element indexable."         ^self shouldNotImplement</body></methods><methods><class-id>Opentalk.LongDouble</class-id> <category>converting</category><body package="Opentalk-IDL-Base">asDouble	^self notImplemented</body><body package="Opentalk-IDL-Base">asFloat	"Answer the receiver as a float.	If the receiver's magnitude is too great to store in a float		raise an overflow signal	If the receiver's magnitude is too small (the magnitude is too		small for a float), raise an underflow signal"	^self notImplemented</body><body package="Opentalk-IDL-Base">asLongDouble	"Answer the receiver itself."	^self</body><body package="Opentalk-IDL-Base">reverseByteOrder	"Swap byte order when booting up on a different-endian	machine than the image was saved on."	| bytes |	bytes := self basicSize.	1 to: bytes by: 2 do:		[:i |	| t |		t := self basicAt: i.		self basicAt: i put: (self basicAt: bytes-i+1).		self basicAt: bytes-i+1 put: t]</body></methods><methods><class-id>Opentalk.LongDouble</class-id> <category>double dispatching</category><body package="Opentalk-IDL-Base">differenceFromFloat: aFloat	^self notImplemented</body><body package="Opentalk-IDL-Base">differenceFromFraction: aFraction	^self notImplemented</body><body package="Opentalk-IDL-Base">differenceFromInteger: anInteger	^self notImplemented</body><body package="Opentalk-IDL-Base">differenceFromLongDouble: aLongDouble	"Presumably here because LongDouble - failed.	If the receiver's magnitude is very small, then aLongDouble's magnitude		must be very small, and the calculation underflowed.	Otherwise, both are very large and the calculation overflowed"	^self notImplemented</body><body package="Opentalk-IDL-Base">equalFromFloat: aFloat	^self notImplemented</body><body package="Opentalk-IDL-Base">equalFromFraction: aFraction	^self notImplemented</body><body package="Opentalk-IDL-Base">equalFromInteger: anInteger	^self notImplemented</body><body package="Opentalk-IDL-Base">equalFromLongDouble: aLongDouble	^self notImplemented</body><body package="Opentalk-IDL-Base">lessFromFloat: aFloat	^self notImplemented</body><body package="Opentalk-IDL-Base">lessFromFraction: aFraction	^self notImplemented</body><body package="Opentalk-IDL-Base">lessFromInteger: anInteger	^self notImplemented</body><body package="Opentalk-IDL-Base">lessFromLongDouble: aLongDouble	^self notImplemented</body><body package="Opentalk-IDL-Base">productFromFloat: aFloat	^self notImplemented</body><body package="Opentalk-IDL-Base">productFromFraction: aFraction	^self notImplemented</body><body package="Opentalk-IDL-Base">productFromInteger: anInteger	^self notImplemented</body><body package="Opentalk-IDL-Base">productFromLongDouble: aLongDouble	"Presumably here because LongDouble * failed.	If the receiver's magnitude is very small, then aLongDouble's magnitude		must be very small, and the calculation underflowed.	Otherwise, both are very large and the calculation overflowed"	^self notImplemented</body><body package="Opentalk-IDL-Base">quotientFromFloat: aFloat	^self notImplemented</body><body package="Opentalk-IDL-Base">quotientFromFraction: aFraction	^self notImplemented</body><body package="Opentalk-IDL-Base">quotientFromInteger: anInteger	^self notImplemented</body><body package="Opentalk-IDL-Base">quotientFromLongDouble: aLongDouble 	"Presumably here because LongDouble / failed.	First check for division by zero.	If the receiver's magnitude is smaller than aLongDouble's magnitude, the		calculation overflowed, since the quotient's magnitude &gt; 1.0.	Otherwise, the receiver was larger (in magnitude) than the argument,		so the quotient's magnitude &lt; 1.0 and underflow must have occurred"	^self notImplemented</body><body package="Opentalk-IDL-Base">sumFromFloat: aFloat	^self notImplemented</body><body package="Opentalk-IDL-Base">sumFromFraction: aFraction	^self notImplemented</body><body package="Opentalk-IDL-Base">sumFromInteger: anInteger	^self notImplemented</body><body package="Opentalk-IDL-Base">sumFromLongDouble: aLongDouble	"Presumably here because LongDouble + failed.	If the receiver's magnitude is very small, then aLongDouble's magnitude		must be very small, and the calculation underflowed.	Otherwise, both are very large and the calculation overflowed"	^self notImplemented</body></methods><methods><class-id>Opentalk.LongDouble</class-id> <category>comparing</category><body package="Opentalk-IDL-Base">&lt; aNumber 	"Answer whether the receiver is less than the argument.	The primitive fails if it cannot coerce the argument to a LongDouble"	^self notImplemented</body><body package="Opentalk-IDL-Base">&lt;= aNumber 	"Answer whether the receiver is less than or equal to the argument.   	The primitive fails if it cannot coerce the argument to a LongDouble"	^self notImplemented</body><body package="Opentalk-IDL-Base">= aNumber 	"Answer whether the receiver is equal to the argument.	Better implementation needed"	"| a b c status|	a :=  (DSTLongDouble new) basicAt:1 put:222; basicAt: 11 put: 55;yourself.	b := a copy.	c := (DSTLongDouble new) basicAt:2 put:192; basicAt: 8 put: 155;yourself.	status := true.	status := status and: [a = b].	status := status and: [(b = c) not]."	(aNumber class == LongDouble) ifFalse: [^false].	1 to: 16 do: [:i | ((self basicAt: i) = (aNumber basicAt: i)) ifFalse:  [^false]].	^true</body><body package="Opentalk-IDL-Base">&gt; aNumber 	"Answer whether the receiver is greater than the argument. 	The primitive fails if it cannot coerce the argument to a LongDouble"	^self notImplemented</body><body package="Opentalk-IDL-Base">&gt;= aNumber 	"Answer whether the receiver is greater than or equal to the argument. " 	^self notImplemented</body><body package="Opentalk-IDL-Base">hash	^((self basicAt: 16) bitShift: 8) + (self basicAt: 1)</body><body package="Opentalk-IDL-Base">~= aNumber 	"Answer whether the receiver is not equal to the argument.	The primitive fails if it cannot coerce the argument to a LongDouble"	^self notImplemented</body></methods><methods><class-id>Opentalk.LongDouble</class-id> <category>coercing</category><body package="Opentalk-IDL-Base">coerce: aNumber	^aNumber asLongDouble</body><body package="Opentalk-IDL-Base">generality	^95</body></methods><methods><class-id>Opentalk.LongDouble</class-id> <category>testing</category><body package="Opentalk-IDL-Base">isLiteral	"Answer whether the receiver has a literal text form	recognized by the compiler."	^true</body><body package="Opentalk-IDL-Base">isZero	"Answer whether 'self = self class zero'"	^self = 0.0q</body></methods><methods><class-id>Opentalk.LongDouble</class-id> <category>truncation and round off</category><body package="Opentalk-IDL-Base">fractionPart	"Answer a LongDouble whose value is the difference between the  	receiver and the receiver's truncated value"	^self notImplemented</body><body package="Opentalk-IDL-Base">rounded	"Answer the integer nearest the receiver."	^self notImplemented</body><body package="Opentalk-IDL-Base">truncated	"Answer a SmallInteger equal to the value of the receiver     	without its fractional part. Fail if the truncated value cannot be    	represented as a SmallInteger.  In that case, the code below will   	compute a LargeInteger truncated value"	^self notImplemented</body></methods><methods><class-id>Opentalk.LongDouble</class-id> <category>printing</category><body package="Opentalk-IDL-Base">printOn: aStream 	"Append to the argument, aStream, a literal form of the receiver 	using a reasonable number of significant digits."	"-1.234567d asDSTLongDouble printString"	"123.4567d asDSTLongDouble printString"	| sign exp frac |	sign := (((self  basicAt: 1) bitAnd: 128) bitShift: -7).	exp := (((self basicAt: 1) bitAnd: 127) asInteger bitShift: 8) + (self basicAt: 2) asInteger.	frac := 12.	sign + exp + frac.	'Not yet impl' printOn: aStream.</body></methods><methods><class-id>Opentalk.LongDouble</class-id> <category>private</category><body package="Opentalk-IDL-Base">defaultNumberOfDigits	"Answer how many digits of accuracy this class supports"	^20</body><body package="Opentalk-IDL-Base">exponent	"Answer the SmallInteger to whose power two is raised.	Consider the receiver to be represented as a power of 	two multiplied by a mantissa (between one and two)	Optional. See Object documentation whatIsAPrimitive."	^super exponent</body><body package="Opentalk-IDL-Base">timesTwoPower: anInteger 	"Answer the receiver multiplied by 2.0 raised to the power of 	the argument"	^self notImplemented</body></methods><methods><class-id>Opentalk.LongDouble class</class-id> <category>external accessing</category><body package="Opentalk-IDL-Base">baseCType	"Answer the receiver's base type with respect to the external interface C language type machinery."	^CLimitedPrecisionRealType double</body></methods><methods><class-id>Opentalk.LongDouble class</class-id> <category>constants access</category><body package="Opentalk-IDL-Base">exponentCharacter	"Answer the Character that precedes the exponent in the printed form for instances"	^$q</body><body package="Opentalk-IDL-Base">pi	"Answer the constant, Pi."	^Pi</body><body package="Opentalk-IDL-Base">radiansPerDegree	"Answer the constant, RadiansPerDegree."	^RadiansPerDegree</body><body package="Opentalk-IDL-Base">unity	"Answer the value which allows, for any given arithmetic value, the following to be true		aNumber * aNumber class unity = aNumber	This must be true regardless of how a given subclass chooses to define #*"	^1.0q</body><body package="Opentalk-IDL-Base">zero	"Answer the value which allows, for any given arithmetic value, the following to be true		aNumber + aNumber class zero = aNumber	This must be true regardless of how a given subclass chooses to define #+"	^0.0q</body></methods><methods><class-id>Opentalk.LongDouble class</class-id> <category>instance creation</category><body package="Opentalk-IDL-Base">fromDouble: aDouble	^0</body><body package="Opentalk-IDL-Base">new 	^self basicNew:16</body></methods><methods><class-id>Opentalk.LongDouble class</class-id> <category>private</category><body package="Opentalk-IDL-Base">coerce: value to: class precision: precision exponent: exponent exponentChar: expChar	"Coerce the value to be an instance of 'class', or	if the receiver is a concrete subclass of Number, it	should coerce the number to itself.  'precision' is	the number of digits after the decimal point that	were explicitly represented. 'exponent' is the number	that follows the exponent character--this usually	represents multiplying the number by a power of 10,	but may mean something else for FixedPoint. The	'expChar' is the character that identifies what type	of number this is, and separates the basic number	from its exponent."	"This is a support routine for Number class&gt;&gt;readFrom:,	and may change or disappear from release to release."	^exponent == nil		ifTrue: [value asLongDouble]		ifFalse: [value asLongDouble * (10 raisedTo: exponent)]</body></methods><methods><class-id>Opentalk.LongDouble class</class-id> <category>class initialization</category><body package="Opentalk-IDL-Base">initialize	"Constants from Computer Approximations, pp. 182-183 	Pi = 3.14159265358979323846264338327950288 	Pi/2 = 1.57079632679489661923132169163975144 	Pi/4 = 0.78539816339744830961566084581987572 	Pi*2 = 6.28318530717958647692528676655900576 	Pi/180 = 0.01745329251994329576923690768488612 	2.0 ln = 0.69314718055994530941723212145817657 	2.0 sqrt = 1.41421356237309504880168872420969808"	"LongDouble initialize."	Pi := -1.0d arcCos.	RadiansPerDegree := Pi / 180.0d</body></methods><methods><class-id>Opentalk.LongDouble class</class-id> <category>testing</category><body package="Opentalk-IDL-Base">isVariableSize	"Answer whether the receiver has variable-sized members."	^false</body></methods><methods><class-id>Opentalk.NCSuuid</class-id> <category>converting</category><body package="Opentalk-IDL-Base">asByteArray	"Answer an instance of ByteArray whose elements	are the elements of the receiver."	^ByteArray fromString: self</body><body package="Opentalk-IDL-Base">asByteString	"Answer an instance of ByteString whose elements 	are the elements of the receiver."	^self asByteArray asByteString</body><body package="Opentalk-IDL-Base">asFactoryIdOn: hostId	"perform the interface to factory oid mapping for the given host"	| ba x |	ba := self asByteArray.	1 to: 4 do: [:i | ba at: 9 + i put: (hostId at: i)].	ba at: 9 put: 2.	(6 to: 1 by: -1)		do: 			[:j | 			ba at: j put: (x := (ba at: j) + 1 bitAnd: 255).			x isZero ifFalse: [^ba asString asUUID]]</body><body package="Opentalk-IDL-Base">asIdOn: hostId	"return a copy of the receiver on the the given host"	| ba  |	ba := self shallowCopy.	1 to: 4 do: [:i | ba at: 9 + i put: (hostId at: i)].	^self class intern: ba</body><body package="Opentalk-IDL-Base">hostId	"return the hostId of the receiver"	^(self copyFrom: 10 to: 13) asByteArray</body></methods><methods><class-id>Opentalk.NCSuuid</class-id> <category>testing</category><body package="Opentalk-IDL-Base">isLocalId	"return if the uuid is local"	^self hostId = GenericProtocol hostAddress</body><body package="Opentalk-IDL-Base">isNilId	"return if the uuid is nil"	^self == NilId</body></methods><methods><class-id>Opentalk.NCSuuid</class-id> <category>private</category><body package="Opentalk-IDL-Base">copy	"return the receiver"	^self</body><body package="Opentalk-IDL-Base">hash	"Answer a uniformly distributed SmallInteger computed from the contents	of the receiver.  We consider that the 5th &amp; 6th bytes of a UUID are the most	likely to be randomly distributed"	^((self at: 5) asInteger bitShift: 8) bitOr: (self at: 6) asInteger</body><body package="Opentalk-IDL-Base">key	"return the receiver. used by HandleRegistry"	^self</body><body package="Opentalk-IDL-Base">postReadGeneralStructureOn: aBinaryStorageReader	"When we bring in an uuid we have to intern it"	| existOne |	^self == (existOne := self class intern: self)		ifTrue:[self]		ifFalse:[self oneWayBecome: existOne]</body></methods><methods><class-id>Opentalk.NCSuuid</class-id> <category>printing</category><body package="Opentalk-IDL-Base">asString	"return the printString notation"	^self printString</body><body package="Opentalk-IDL-Base">printOn: aStream	"return a human readable string for the uuid, in DCE format"	self isNil ifTrue: [^aStream nextPutAll: 'NIL'].	1 to: 4 do: [:i | aStream nextPutAll: (self at: i) asHex].	aStream nextPutAll: '-'.	5 to: 6 do: [:i | aStream nextPutAll: (self at: i) asHex].	aStream nextPutAll: '-'.	7 to: 8 do: [:i | aStream nextPutAll: (self at: i) asHex].	aStream nextPutAll: '-'.	9 to: 10 do: [:i | aStream nextPutAll: (self at: i) asHex].	aStream nextPutAll: '-'.	11 to: 16 do: [:i | aStream nextPutAll: (self at: i) asHex].</body></methods><methods><class-id>Opentalk.NCSuuid</class-id> <category>persistence</category><body package="Opentalk-IDL-Base">representBinaryOn: binWriter 	"Represent an ORBPersistentObjRef by a constructor which will 	rebuild either an objref or the object itself"	^MessageSend		receiver: self class		selector: #intern:		argument: self asByteArray</body></methods><methods><class-id>Opentalk.NCSuuid class</class-id> <category>private</category><body package="Opentalk-IDL-Base">intern: aUUID 	"Answer a unique UUID whose characters are those of aUUID."	| uuid index table subTable subIndex id |	^Sema		critical: 			[id := aUUID class == self						ifTrue: ["putting old id in new table"							aUUID]						ifFalse: ["create a new one"							(self new: 16)								replaceBytesFrom: 1								to: 16								with: aUUID								startingAt: 1].			uuid := self findInterned: id.			uuid notNil				ifTrue: [uuid]				ifFalse: 					[table := self table.					index := id hash \\ table size + 1.					subTable := table at: index.					subIndex := subTable								indexOf: 0								replaceWith: id								startingAt: 1								stoppingAt: subTable size.					subIndex = 0						ifTrue: 							[| newTable |							newTable := subTable class new: subTable size + 1.							newTable								replaceFrom: 1								to: subTable size								with: subTable.							newTable at: newTable size put: id.							table at: index put: newTable].					id]]</body><body package="Opentalk-IDL-Base">rehash	"Rebuild the hash table that holds all the unique UUIDs."	"We want to keep the average number of probes for a lookup	constant; independent of the number of symbols.  Therefore,	when rehashing we adjust the number of buckets such that	we meet a target bucket size (e.g. symbols/buckets).	Choosing a target bucket size is a classic time/space tradeoff;	the value used here is 10, based on empirical tests."	| numBuckets |	"Set knows good hash moduli."	numBuckets := (Set goodSizeFrom: (self tableSize / 10) rounded) max: 3943.	self table: ((1 to: numBuckets) collect: [:uid | WeakArray with: 0]).	ObjectMemory garbageCollect.	self allInstancesDo: [:uid | self intern: uid].</body><body package="Opentalk-IDL-Base">table	"return the symbol table for UUIDs"	^STable</body><body package="Opentalk-IDL-Base">table: newArray 	"set the symbol table for UUIDs"	^STable := newArray</body></methods><methods><class-id>Opentalk.NCSuuid class</class-id> <category>accessing</category><body package="Opentalk-IDL-Base">findInterned: aUUID 	"If aUUID has been interned (into a UUID), 	answer the UUID, otherwise answer nil."	| v stringSize |	stringSize := aUUID size.	v := self table at: aUUID hash \\ self table size + 1.	1 to: v size do: 		[:i | 		| test |		((test := v at: i) class == self and: [stringSize = test size				and: 					[| match ii |					match := true.					ii := 0.					[match and: [(ii := ii + 1) &lt;= stringSize]]						whileTrue: [(aUUID at: ii)								= (test at: ii) ifFalse: [match := false]].					match]])			ifTrue: [^test]].	^nil</body><body package="Opentalk-IDL-Base">getImageId	"Get a small unique number for this image.	In the case of multiprocessor machine, to make UUID unique, it is necessary	to assign a differenet image id for each image running on the same machine."	^0</body><body package="Opentalk-IDL-Base">tableSize	"Answer the number of UUIDs in the system."	^self allInstances size</body></methods><methods><class-id>Opentalk.NCSuuid class</class-id> <category>instance creation</category><body package="Opentalk-IDL-Base">from: aByteArray at: index 	"extract and intern a uuid from the byte array at the index"	| uuid |	uuid := self new: 16.	uuid		replaceBytesFrom: 1		to: 16		with: aByteArray		startingAt: index.	^self intern: uuid</body><body package="Opentalk-IDL-Base">newId	"Create a new local uuid, using NCS guidelines: The time stamp is 	the number of 4 us intervals since 1/1/80"	| uuid hostId time |	Sema		critical: 			[hostId := GenericProtocol hostAddress.			uuid := self new: 16.			Tincr := Tincr + 1.			Tval isZero | (Tincr &gt; 249)				ifTrue: 					[Tval := Time totalSeconds - (Date newDay: 1 monthNumber: 1 year: 1980) asSeconds * 250000 + (Time millisecondClockValue \\ 1000 * 250).					Tincr := 0].			time := Tval + Tincr.			(6 to: 1 by: -1)				do: 					[:i | 					uuid at: i put: (time bitAnd: 255).					time := time bitShift: -8].			uuid at: 9 put: 2.			1 to: 4 do: [:j | uuid at: j + 9 put: (hostId at: j)].			uuid at: 15 put: self getImageId].	^self intern: uuid</body><body package="Opentalk-IDL-Base">newId: timeVal 	"create a new local uuid, using NCS guidelines and the given time stamp value"	| uuid hostId time |	time := timeVal.	hostId := GenericProtocol hostAddress.	uuid := self new: 16.	(6 to: 1 by: -1)		do: 			[:i | 			uuid at: i put: (time bitAnd: 255).			time := time bitShift: -8].	uuid at: 9 put: 2.	1 to: 4 do: [:j | uuid at: j + 9 put: (hostId at: j)].	^self intern: uuid</body><body package="Opentalk-IDL-Base">nilId	"return a nil local uuid, using NCS guidelines"	^NilId</body><body package="Opentalk-IDL-Base">on: aString 	"return a uuid with value from an encoded print string or packed 	char array"	| uuid k ix dce |	aString size = 16 ifTrue: [aString class == self			ifTrue: [^self intern: aString]			ifFalse: 				[uuid := self new: 16.				1 to: 16 do: [:i | uuid at: i put: (aString at: i) asInteger].				^self intern: uuid]].	aString size = 36 ifFalse: [^self error: 'Cannot convert to UUID'].	uuid := self new: 16.	dce := (aString at: 9)				= $- and: [(aString at: 14)					= $- and: [(aString at: 19)						= $- and: [(aString at: 24)							= $-]]].	dce		ifTrue: ["handle DCE format"			ix := #(8 13 18 23 )]		ifFalse: ["handle NCS format"			ix := #(12 15 18 21 24 27 30 33 )].	k := 0.	1 to: 16 do: [:i | (dce or: [(#(7 8 ) includes: i) not])			ifTrue: 				[uuid at: i put: (aString at: (k := k + 1)) digitValue * 16 + ((aString at: (k := k + 1)) digitValue).				(ix includes: k)					ifTrue: [k := k + 1]]].	^self intern: uuid</body></methods><methods><class-id>Opentalk.NCSuuid class</class-id> <category>class initialization</category><body package="Opentalk-IDL-Base">initialize	"initialize the class"	"self initialize"	"Protect against multiple initialize's."	(ObjectMemory dependents includes: self)		ifFalse:	[ObjectMemory addDependent: self].	Tval := Tincr := 0.	Sema := Semaphore new signal.	self rehash.	NilId := self intern: (String new: 16)</body><body package="Opentalk-IDL-Base">obsolete	ObjectMemory removeDependent: self.	super obsolete.</body><body package="Opentalk-IDL-Base">reInitialize	"initialize the class"	Sema wait.	Tval := Tincr := 0.	Sema signal.	NilId := self intern: (String new: 16).</body><body package="Opentalk-IDL-Base">release	"release the class variables"	NilId := Sema := STable := Tincr := Tval := nil</body></methods><methods><class-id>Opentalk.NCSuuid class</class-id> <category>updating</category><body package="Opentalk-IDL-Base">update: anAspect with: arguments from: anObject	"Check for return from snapshot to reInitialize."	anAspect == #earlySystemInstallation		ifTrue: [self reInitialize]</body></methods><methods><class-id>Opentalk.Union</class-id> <category>accessing</category><body package="Opentalk-IDL-Base">discriminator	^discriminator</body><body package="Opentalk-IDL-Base">discriminator: aValue	discriminator := aValue</body><body package="Opentalk-IDL-Base">value	^value</body><body package="Opentalk-IDL-Base">value: aValue	value := aValue</body></methods><methods><class-id>Opentalk.Union class</class-id> <category>creation</category><body package="Opentalk-IDL-Base">discriminator: aDiscriminator value: aValue	^self new discriminator: aDiscriminator; value: aValue; yourself</body></methods><methods><class-id>Opentalk.Any</class-id> <category>accessing</category><body package="Opentalk-IDL-Base">type	^type</body><body package="Opentalk-IDL-Base">type: aValue	type := aValue</body><body package="Opentalk-IDL-Base">value	^value</body><body package="Opentalk-IDL-Base">value: aValue	value := aValue</body></methods><methods><class-id>Opentalk.Enumerator</class-id> <category>accessing</category><body package="Opentalk-IDL-Base">name	"answer the name"	^name</body><body package="Opentalk-IDL-Base">type	"answer the type"	^DSTORBObject repository lookupId: type</body><body package="Opentalk-IDL-Base">value	"answer the integer value of the enumeration"	^value</body></methods><methods><class-id>Opentalk.Enumerator</class-id> <category>comparing</category><body package="Opentalk-IDL-Base">&lt; anEnumerator 	"Answer true if the receiver is equal to aCORBAEnum, otherwise 	answer false"	^self value &lt; anEnumerator value</body><body package="Opentalk-IDL-Base">= anEnumeratorOrSymbol 	"Answer true if the receiver is equal to aCORBAEnum, otherwise 	answer false. It should be noted that we allow comparison against 	symbols for migration"	^anEnumeratorOrSymbol class == Enumerator		ifTrue: [name == anEnumeratorOrSymbol name and: [value == anEnumeratorOrSymbol value]]		ifFalse: [name == anEnumeratorOrSymbol]</body><body package="Opentalk-IDL-Base">&gt; anEnumerator 	"Answer true if the receiver is equal to aCORBAEnum, otherwise 	answer false"	^self value &gt; anEnumerator value</body><body package="Opentalk-IDL-Base">hash	^self value hash</body></methods><methods><class-id>Opentalk.Enumerator</class-id> <category>persistence</category><body package="Opentalk-IDL-Base">persistentState	"return the persistent state of the receiver"	^Array		with: name		with: value		with: type</body><body package="Opentalk-IDL-Base">representBinaryOn: binWriter 	"Represent a DSTEnumeration by its contents (elements). This is called by 	the BOSS when an on object is written to a BOSS stream. Note that 	this process will automatically register the receiver as a persistent 	object. If that stream is subsequently stored in the object database, 	then a tombstone will remain after I am reclaimed which will allow 	me to be resurrected later"	^MessageSend		receiver: self class		selector: #createLike:		argument: self persistentState</body></methods><methods><class-id>Opentalk.Enumerator</class-id> <category>private</category><body package="Opentalk-IDL-Base">n: aSymbol v: anInteger t: aDSTtypeEnumeration 	"set the enumeration"	name := aSymbol.	value := anInteger.	type := aDSTtypeEnumeration repositoryId</body></methods><methods><class-id>Opentalk.Enumerator</class-id> <category>printing</category><body package="Opentalk-IDL-Base">printOn: aStream 	"print a representation of the receiver"	super printOn: aStream.	aStream nextPutAll: ' (' , self name asString , ')'</body></methods><methods><class-id>Opentalk.Enumerator class</class-id> <category>instance creation</category><body package="Opentalk-IDL-Base">createLike: anArray 	"create a new instance of the receiver's class with the given 	persistent state. This is called by the BOSS when a new object is to 	be created from a BOSS binary stream. Cause the newly created 	object to replace its resident version, if one exists."	| enumName value type | 	enumName := anArray at: 1.	value := anArray at: 2.	type :=  DSTORBObject lookupMetaId: (anArray at: 3).	^self name: enumName value: value type: type</body><body package="Opentalk-IDL-Base">name: aSymbol value: anInteger type: aDSTtypeEnumeration 	"create a new instance"	^(self basicNew) n: aSymbol v: anInteger t: aDSTtypeEnumeration; yourself</body></methods><methods><class-id>Core.Number</class-id> <category>converting</category><body package="Opentalk-IDL-Base">asLongDouble	^(self asDouble) asLongDouble</body></methods><methods><class-id>Opentalk.CDRStream</class-id> <category>marshaling-integers</category><body package="Opentalk-IDL-Base">nextLongDouble	"return the next long double in the receiver."	| res |	self alignToLongDouble.	res := LongDouble new.	1 to: res basicSize do: [:i | res basicAt: i put: self next].	self mustSwapBytes ifTrue: [res reverseByteOrder].	^res</body><body package="Opentalk-IDL-Base">nextPutLongDouble: aLongDouble 	"marshall the long double float in the receiver."	| param |	self padToLongDouble.	BigEndian		ifTrue: [param := aLongDouble]		ifFalse: 			[param := aLongDouble copy.			param reverseByteOrder].	1 to: param basicSize do: [:i | self nextPut: (param basicAt: i)]</body><body package="Opentalk-IDL-Base">nextPutUUID: auuid	"return the next UUID in the receiver"	self padToLong; nextPutAll: auuid.</body><body package="Opentalk-IDL-Base">nextUUID	"return the next uuid in the receiver"	| uuid |	self alignToLong.	uuid := self				next: 16				into: (NCSuuid new: 16)				startingAt: 1.	^NCSuuid intern: uuid</body></methods><methods><class-id>Core.ByteString</class-id> <category>accessing</category><body package="Opentalk-IDL-Base">replaceBytesFrom: start to: stop with: replacement startingAt: repStart 	"This destructively replaces elements from start to stop in the receiver	starting at index, repStart, in the collection, replacement.  Answer the	receiver."	&lt;primitive: 559&gt;	| repOff |	repOff := repStart - start.	(self == replacement and: [repStart &lt; start])		ifTrue:	["Replacement would be overwritten; use reverse order"				stop to: start by: -1 do:					[ :i |	self byteAt: i put: (replacement byteAt: repOff + i)]]		ifFalse:	[start to: stop do:					[ :i |	self byteAt: i put: (replacement byteAt: repOff + i)]]</body></methods><methods><class-id>Core.Double</class-id> <category>converting</category><body package="Opentalk-IDL-Base">asLongDouble	"1.2333d halt; asDSTLongDouble"	self error: 'Not implemented yet'."	| longDouble |		longDouble := Opentalk.LongDouble new.	longDouble basicAt: 1 put: (self basicAt: 1).	longDouble basicAt: 2 put: ((self basicAt: 2) bitAnd: 240).	3 to: 8 do: [:i | 		longDouble			basicAt: i 			put: ((((self basicAt: i-1) bitAnd: 15) bitShift: 4) bitOr: 				(((self basicAt: i) bitAnd: 240) bitShift: -4))].	longDouble basicAt: 9 put: (((self basicAt: 8) bitAnd: 15) bitShift: 4).	^longDouble."	" Used to debug it:	dstream := WriteStream on: (String new: 8).	ldstream := WriteStream on: (String new: 16).	1 to: 8  do: [:i | dstream nextPutAll: (self basicAt: i) asHex; space].	1 to: 16 do: [:j | ldstream nextPutAll: (longDouble basicAt: j) asHex; space].	"</body></methods><methods><class-id>Core.Object</class-id> <category>opentalk</category><body package="Opentalk-IDL-Base">asUnion: aDiscriminator 	"Answer an object that confomrs to the CORBAUnion protocol as 	required by the IDL Smalltalk Language Mapping"	^Opentalk.Union discriminator: aDiscriminator value: self</body></methods><methods><class-id>Core.SmallDouble</class-id> <category>converting</category><body package="Opentalk-IDL-Base">asLongDouble	"1.2333d halt; asDSTLongDouble"	self error: 'Not implemented yet'."	| longDouble |		longDouble := Opentalk.LongDouble new.	longDouble basicAt: 1 put: (self basicAt: 1).	longDouble basicAt: 2 put: ((self basicAt: 2) bitAnd: 240).	3 to: 8 do: [:i | 		longDouble			basicAt: i 			put: ((((self basicAt: i-1) bitAnd: 15) bitShift: 4) bitOr: 				(((self basicAt: i) bitAnd: 240) bitShift: -4))].	longDouble basicAt: 9 put: (((self basicAt: 8) bitAnd: 15) bitShift: 4).	^longDouble."	" Used to debug it:	dstream := WriteStream on: (String new: 8).	ldstream := WriteStream on: (String new: 16).	1 to: 8  do: [:i | dstream nextPutAll: (self basicAt: i) asHex; space].	1 to: 16 do: [:j | ldstream nextPutAll: (longDouble basicAt: j) asHex; space].	"</body></methods><initialize><class-id>Opentalk.LongDouble</class-id></initialize><initialize><class-id>Opentalk.NCSuuid</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>ByteString</name><environment>Core</environment><super>Core.ByteEncodedString</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-String Support</category><attributes><package>Collections-String Support</package></attributes></class><class><name>ByteArray</name><environment>Core</environment><super>Core.IntegerArray</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>Magnitude</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>Number</name><environment>Core</environment><super>Core.ArithmeticValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>CDRStream</name><environment>Opentalk</environment><super>Core.ReadWriteStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>byteOrder charEncoder wcharEncoder marshaler </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Protocols-Core</category><attributes><package>Opentalk-CDR</package></attributes></class><class><name>LimitedPrecisionReal</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>powersOfTwo </class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Double</name><environment>Core</environment><super>Core.LimitedPrecisionReal</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>SmallDouble</name><environment>Core</environment><super>Core.LimitedPrecisionReal</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class></st-source>