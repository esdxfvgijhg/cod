<?xml version="1.0"?><st-source><!-- Name: Opentalk-CORBANotice: Copyright 1999-2013 Cincom Systems, Inc.  All rights reserved.Comment: CORBA ORB extensions.- adds Broker>>remoteObjectAt:oid:interfaceId: for proxy construction- adds Broker>>locate: anIOR and RemoteObject>>_locate for access to LocateRequest capabilities.- adds Broker creation API, #newCdrIIOPAt: and #newCdrIIOPAtPort: (IIOP version defaults to 1.2)EXAMPLES:Remote stream access (exploiting the IDL definitions from the SmalltakTypes module)	| broker stream proxy oid |	broker := Opentalk.BasicRequestBroker newCdrIiopAtPort: 4242.	broker start.	[	oid := 'stream' asByteArray.		stream := 'Hello World' asByteArray readStream.		broker objectAdaptor export: stream oid: oid.		proxy := broker				remoteObjectAt: (IPSocketAddress hostName: 'localhost' port: 4242)				oid: oid				interfaceId: 'IDL:SmalltalkTypes/Stream:1.0'.		proxy next: 5.	] ensure: [ broker stop ]Locating an object	| broker |	broker := Opentalk.BasicRequestBroker newCdrIiopAtPort: 4242.	broker start.	[	| result stream oid proxy found |		found := OrderedCollection new.		"Try to locate a non-existent remote object"		oid := 'stream' asByteArray.		proxy := broker				remoteObjectAt: (IPSocketAddress hostName: 'localhost' port: 4242)				oid: oid				interfaceId: 'IDL:SmalltalkTypes/Stream:1.0'.		result := proxy _locate.		found add: result.		"Now try to locate an existing remote object"		stream := 'Hello World' asByteArray readStream.		broker objectAdaptor export: stream oid: oid.		result := proxy _locate.		found add: result.		found	] ensure: [ broker stop ]To list the contents of a running Java JDK 1.4 naming service (Assuming you have Opentalk-COS-Naming loaded)(To run the naming service just invoke 'orbd -ORBInitialPort 1050')	| broker context list iterator |	broker := Opentalk.BasicRequestBroker newCdrIiopAtPort: 4242.	broker passErrors; start.	[	context := broker				remoteObjectAt: (IPSocketAddress hostName: 'localhost' port: 1050)
				oid: 'NameService' asByteArray
				interfaceId: 'IDL:CosNaming/NamingContextExt:1.0'.		list := nil asCORBAParameter.		iterator := nil asCORBAParameter.
		context listContext: 10 bindingList: list bindingIterator: iterator.		list value	] ensure: [ broker stop ]To list initial services of a running DST ORB	| broker dst |
	broker := 		(Opentalk.BrokerConfiguration basic			adaptor: (Opentalk.AdaptorConfiguration asymmetricConnectionOriented					transport: (Opentalk.TransportConfiguration iiop							minorVersion: 0;							marshaler: (Opentalk.MarshalerConfiguration cdr)))		) newAtPort: 4242.
	broker start.
	[	dst := broker				remoteObjectAt: (IPSocketAddress hostName: 'localhost' port: 3460)
				oid: #[0 0 0 0 0 1 0 0 2 0 0 0 0 0 0 0]
				interfaceId: 'IDL:CORBA/ORB:1.0'.
		dst listInitialServices
	] ensure: [ broker stop ]
DbIdentifier: bear73DbTrace: 400730DbUsername: nrossDbVersion: 7.10 - 1DevelopmentPrerequisites: #(#(#any 'Opentalk-Core' '') #(#any 'Opentalk-IIOP' ''))PackageName: Opentalk-CORBAParcel: #('Opentalk-CORBA')PrerequisiteParcels: #(#('Opentalk-Core' '') #('Opentalk-IIOP' ''))PrintStringCache: (7.10 - 1,nross)Version: 7.10 - 1Date: 11:27:09 AM April 12, 2013 --><time-stamp>From VisualWorksÂ®, Pre-Release 7.10 (apr13.2) of April 12, 2013 on April 12, 2013 at 11:27:09 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>CORBARequest</name><environment>Opentalk</environment><super>Opentalk.RemoteRequest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>operation serviceContext </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Protocol-STST</category><attributes><package>Opentalk-CORBA</package></attributes></class><class><name>CORBAReply</name><environment>Opentalk</environment><super>Opentalk.RemoteReply</super><private>false</private><indexed-type>none</indexed-type><inst-vars>arguments serviceContext operation </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Protocol-STST</category><attributes><package>Opentalk-CORBA</package></attributes></class><class><name>CDRMarshaler</name><environment>Opentalk</environment><super>Opentalk.Marshaler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>interfaceRepository charEncoder wcharEncoder codeSet </inst-vars><class-inst-vars>defaultCodeSets defaultORBType defaultCharEncoder </class-inst-vars><imports></imports><category>Opentalk-Tests</category><attributes><package>Opentalk-CORBA</package></attributes></class><comment><class-id>Opentalk.CDRMarshaler</class-id><body>Instance Variables:	interfaceRepository	&lt;DSTmoduleRepository&gt; IDL meta object repository to be used for this connection	charEncoder	&lt;StreamEncoder&gt; character encoder for char and string types	wcharEncoder	&lt;StreamEncoder&gt; character encoder for wchar and wstring types	codeSet	&lt;IOPCodeSet&gt; negotiated transmission code set (TCS-C, TCS-W)Class Instance Variables:	defaultCodeSets	&lt;IOPCodeSets&gt; standard code sets to advertize in exported IORs	defaultORBType	&lt;IOPORBType&gt; standard ORBType to advertize in exported IORs	defaultCharEncoder	&lt;StreamEncoder&gt; the default narrow character encoder</body></comment><class><name>CDRMarshalerConfiguration</name><environment>Opentalk</environment><super>Opentalk.MarshalerConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars>orbType codeSets </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-CORBA</category><attributes><package>Opentalk-CORBA</package></attributes></class><comment><class-id>Opentalk.CDRMarshalerConfiguration</class-id><body>Instance Variables:	orbType	&lt;IOPORBType&gt; what ORB identifier should the broker advertise in its references	codeSets	&lt;IOPCodeSets&gt; which character encoding support should the broker advertise in its references</body></comment><methods><class-id>Opentalk.CORBARequest</class-id> <category>accessing</category><body package="Opentalk-CORBA">destination	^target accessPoint</body><body package="Opentalk-CORBA">operation	^operation</body><body package="Opentalk-CORBA">operation: anOperationMO	operation := anOperationMO</body><body package="Opentalk-CORBA">serviceContext	"Return the service context"	^serviceContext ifNil: [ OrderedCollection new ]</body><body package="Opentalk-CORBA">serviceContext: aContextObject	"Set the service context"	serviceContext := aContextObject</body></methods><methods><class-id>Opentalk.CORBARequest</class-id> <category>invocation</category><body package="Opentalk-CORBA">getProcessEnvironmentAssociations		"We should build a valid IOP::ServiceContextList here	^ProcessEnvironment current environmentDictionary associations"	^#()</body><body package="Opentalk-CORBA">sendAndWaitForReply: aConnection 	self serviceContext: self getProcessEnvironmentAssociations.	^super sendAndWaitForReply: aConnection</body></methods><methods><class-id>Opentalk.CORBARequest</class-id> <category>marshaling</category><body package="Opentalk-CORBA">buildGIOPMessageOn: aBuffer for: aTransport	message selector = #_locate ifTrue: [		^(GIOPLocateRequest newOn: aBuffer)			requestId: requestId;			target: target;			yourself ].	operation := target getOpInfo: message selector in: aTransport interfaceRepository.	^(GIOPRequest newOn: aBuffer)		transport: aTransport;		requestId: requestId;		responseFlags: 3;		serviceContext: serviceContext;		target: target;		operation: operation operation name;		yourself</body></methods><methods><class-id>Opentalk.CORBARequest</class-id> <category>dispatching</category><body package="Opentalk-CORBA">doTheWorkFor: aConnection	"Perform the user remote call"	^[	target remotePerform: message selector withArguments: message arguments.	] on: Error do: [ :ex | ex return: ex ]</body><body package="Opentalk-CORBA">evaluateFor: aConnection 	target _isRemote ifTrue: [		^self locationForwardTo: target _objRef using: aConnection ].	serviceContext == nil ifFalse:[ | edic |		edic := ProcessEnvironment current environmentDictionary.		serviceContext do: [:each | edic at: each class put: each]].	super evaluateFor: aConnection</body><body package="Opentalk-CORBA">locationForwardTo: anIIOPObjRef using: aConnection	reply := GIOPReply new			requestId: self requestId;			serviceContext: self serviceContext;			LOCATION_FORWARD: anIIOPObjRef;			yourself.	[	aConnection sendPackage: reply	] on: Error do: [ :error |		self handleReplyError: error in: aConnection ]</body><body package="Opentalk-CORBA">replyForResult: anObject 	^(CORBAReply return: anObject)		requestId: requestId;		operation: operation;		arguments: message arguments;		interceptorDispatcher: self interceptorDispatcher;		yourself</body></methods><methods><class-id>Opentalk.CORBAReply</class-id> <category>accessing</category><body package="Opentalk-CORBA">arguments	^arguments</body><body package="Opentalk-CORBA">arguments: anArgCollection	arguments := anArgCollection</body><body package="Opentalk-CORBA">operation	^operation</body><body package="Opentalk-CORBA">operation: anOperationMO	operation := anOperationMO</body><body package="Opentalk-CORBA">serviceContext	^serviceContext ifNil: [ OrderedCollection new ]</body><body package="Opentalk-CORBA">serviceContext: aServiceContext	serviceContext := aServiceContext</body></methods><methods><class-id>Opentalk.CORBAReply</class-id> <category>invocation</category><body package="Opentalk-CORBA">getProcessEnvironmentAssociations		"We should build a valid IOP::ServiceContextList here"	^ProcessEnvironment current environmentDictionary associations</body><body package="Opentalk-CORBA">send: aConnection	self getProcessEnvironmentAssociations.	super send: aConnection</body></methods><methods><class-id>Opentalk.CORBAReply</class-id> <category>marshaling</category><body package="Opentalk-CORBA">buildGIOPMessageOn: aBuffer for: aTransport	| status result |	reply isSignalledException		ifTrue: [ | array mo params |			array := operation findCorbaExceptionFor: reply.			mo := array at: 1.			params := array at: 2.			(array at: 3) = #systemException				ifTrue: [ result :=						(SystemException repositoryId: mo repositoryId)							minorCode: (params at: #minor);							perform: (params at: #completed);							yourself.					status := 2 "SYSTEM_EXCEPTION" ]				ifFalse: [ result := array.					status := 1 "USER_EXCEPTION" ] ]		ifFalse: [ result := reply.			status := 0 "NO_EXCEPTION" ].	^(GIOPReply newOn: aBuffer)		transport: aTransport;		requestId: self requestId;		serviceContext: self serviceContext;		reply: result;		replyStatus: status		yourself</body></methods><methods><class-id>Opentalk.CDRMarshaler</class-id> <category>accessing</category><body package="Opentalk-CORBA">charEncoder"From 01-12-35.prf CORBA2.6; 13.10.2.4 CodeSet Component of IOR Multi-Component Profile; pp 13-43:If the code set component is not present in a multi-component profile structure, thenthe default char code set is ISO 8859-1 for backward compatibility."	^charEncoder ifNil: [		self class defaultCharEncoder ]</body><body package="Opentalk-CORBA">charEncoder: aStreamEncoder	charEncoder := aStreamEncoder</body><body package="Opentalk-CORBA">codeSet"	^&lt;IOPCodeSet&gt; negotiated transmission code set (TCS-C, TCS-W)"	^codeSet</body><body package="Opentalk-CORBA">codeSet: aCodeSet"	aCodeSet &lt;IOPCodeSet&gt; negotiated transmission code set (TCS-C, TCS-W)"	aCodeSet ifNotNil: [		codeSet := aCodeSet.		self charEncoder: aCodeSet charEncoder.		self wcharEncoder: aCodeSet wcharEncoder ].</body><body package="Opentalk-CORBA">codeSets	^configuration codeSets		ifNil: [ self class defaultCodeSets ]		ifNotNil: [ :cs |			cs isNull				ifTrue: [nil]				ifFalse: [cs] ]</body><body package="Opentalk-CORBA">interfaceRepository	^interfaceRepository</body><body package="Opentalk-CORBA">iorComponents	^( Set "eliminate nils"		with: self orbType		with: self codeSets	) asArray</body><body package="Opentalk-CORBA">minorVersion	^self manager minorVersion</body><body package="Opentalk-CORBA">orbType	^configuration orbType ifNil: [		self class defaultORBType ]</body><body package="Opentalk-CORBA">repository	^DSTORBObject</body><body package="Opentalk-CORBA">wcharEncoder"From 01-12-35.prf CORBA2.6; 13.10.2.4 CodeSet Component of IOR Multi-Component Profile; pp 13-43:If a client application invokes an operation which results in an attempt by the clientORB to marshall wchar or wstring data for an in parameter (or to unmarshalwchar or wstring data for an in/out parameter, out parameter or the return value),and the associated Object Reference does not include a codeset component, then theclient ORB shall raise the INV_OBJREF standard system exception with standardminor code 2 as a response to the operation invocation."	^wcharEncoder ifNil: [		DSTORBObject invObjrefError: 2 ]</body><body package="Opentalk-CORBA">wcharEncoder: aStreamEncoder	wcharEncoder := aStreamEncoder</body></methods><methods><class-id>Opentalk.CDRMarshaler</class-id> <category>initialization</category><body package="Opentalk-CORBA">initialize: aConfiguration	super initialize: aConfiguration.	interfaceRepository := aConfiguration iiopInterfaceRepository.</body><body package="Opentalk-CORBA">setManager: aTransport	super setManager: aTransport.	"interfaceRepository definedIn: self adaptor."</body></methods><methods><class-id>Opentalk.CDRMarshaler</class-id> <category>marshaling</category><body package="Opentalk-CORBA">export: anObject interfaceId: aRepositoryId	 | ref |	ref := self manager export: anObject.	ref := IIOPObjRef			newOn: ref accessPoint			oid: ref oid			interfaceId: aRepositoryId.	ref profile components: self iorComponents.	^ref</body><body package="Opentalk-CORBA">marshalGIOPPayloadOf: anApplicationPkg into: transportPkg	anApplicationPkg sendingMessageIn: self transport.	(codeSet isNil and: [ anApplicationPkg class == CORBARequest ]) ifTrue: [		self negotiateCodeSetWith: anApplicationPkg target ].	codeSet ifNotNil: [ transportPkg addCodeSet: codeSet ].	^transportPkg marshalPayloadFrom: anApplicationPkg using: self</body><body package="Opentalk-CORBA">negotiateCodeSetWith: anIOR	| ccss scss cs | 	(scss := anIOR codeSets) ifNil: [^self].	(ccss := self codeSets) ifNil: [^self].	cs := ccss negotiateWith: scss.	cs charData isNil ifTrue: [ DSTORBObject codeSetIncompatibleError: 1 ].	cs wcharData isNil ifTrue: [ DSTORBObject codeSetIncompatibleError: 2 ].	self codeSet: cs</body><body package="Opentalk-CORBA">unmarshalGIOPPayloadFrom: transportPkg	| msg |	codeSet ifNil: [ self codeSet: transportPkg codeSet ].	msg := transportPkg unmarshalPayloadUsing: self.	msg receivingMessageIn: self transport.	^msg</body></methods><methods><class-id>Opentalk.CDRMarshaler class</class-id> <category>accessing</category><body package="Opentalk-CORBA">defaultCharEncoder	^defaultCharEncoder ifNil: [		defaultCharEncoder := self defaultCharEncoderValue ]</body><body package="Opentalk-CORBA">defaultCharEncoder: aStreamEncoder	defaultCharEncoder := aStreamEncoder</body><body package="Opentalk-CORBA">defaultCodeSets	^defaultCodeSets ifNil: [		defaultCodeSets := self defaultCodeSetsValue ]</body><body package="Opentalk-CORBA">defaultCodeSets: anIOPCodeSets	defaultCodeSets := anIOPCodeSets</body><body package="Opentalk-CORBA">defaultORBType	^defaultORBType ifNil: [		defaultORBType := self defaultORBTypeValue ]</body><body package="Opentalk-CORBA">defaultORBType: anIOPORBType	defaultORBType := anIOPORBType</body><body package="Opentalk-CORBA">requestClass	^CORBARequest</body></methods><methods><class-id>Opentalk.CDRMarshaler class</class-id> <category>defaults</category><body package="Opentalk-CORBA">defaultCharEncoderValue	^StreamEncoder new: 'ISO8859-1'</body><body package="Opentalk-CORBA">defaultCodeSetsValue	^IOPCodeSets default</body><body package="Opentalk-CORBA">defaultORBTypeValue	^IOPORBType default</body></methods><methods><class-id>Opentalk.CDRMarshalerConfiguration</class-id> <category>accessing</category><body package="Opentalk-CORBA">codeSets"	^&lt;IOPCodeSets&gt; which character encoding support should the broker advertise in its references"	^codeSets</body><body package="Opentalk-CORBA">codeSets: iopCodeSets"	iopCodeSets &lt;IOPCodeSets&gt; which character encoding support should the broker advertise in its references"	codeSets := iopCodeSets</body><body package="Opentalk-CORBA">componentClass	^CDRMarshaler</body><body package="Opentalk-CORBA">iiopInterfaceRepository	^DSTORBObject localRepository</body><body package="Opentalk-CORBA">orbType"	^&lt;IOPORBType&gt; what ORB identifier should the broker advertise in its references"	^orbType</body><body package="Opentalk-CORBA">orbType: anIOPORBType"	anIOPORBType &lt;IOPORBType&gt; what ORB identifier should the broker advertise in its references"	orbType := anIOPORBType</body></methods><methods><class-id>Core.Object</class-id> <category>opentalk</category><body package="Opentalk-CORBA">asCORBAUnion: aDiscriminator 	"Answer an object that confomrs to the CORBAUnion protocol as 	required by the IDL Smalltalk Language Mapping"	^self asUnion: aDiscriminator</body></methods><methods><class-id>Opentalk.IIOPObjRef</class-id> <category>converting</category><body package="Opentalk-CORBA">narrowTo: anIfcId	| id |	id := anIfcId isCharacters			ifTrue: [RepositoryId fromString: anIfcId]			ifFalse: [anIfcId].	"Check inheritance"	interface ifNotNil: [		(interface withAllSubordinates anySatisfy: [ :i | i repositoryId = id ]) ifFalse: [			DSTORBObject badParamError: 33 "not standardized" ] ].	self interfaceId: id</body><body package="Opentalk-CORBA">widenTo: anIfcId	| id |	id := anIfcId isCharacters			ifTrue: [RepositoryId fromString: anIfcId]			ifFalse: [anIfcId].	"Check inheritance"	interface ifNotNil: [		(interface withAllSuperiors anySatisfy: [ :i | i repositoryId = id ]) ifFalse: [			DSTORBObject badParamError: 34 "not standardized" ] ].	self interfaceId: id</body></methods><methods><class-id>Opentalk.GIOPLocateRequest</class-id> <category>dispatching</category><body package="Opentalk-CORBA">dispatchFor: aTransport	| obj reply ref |	"aTransport manager receivingRequest: self in: aTransport."	ref := self target asIIOPObjRefFor: aTransport.	obj := aTransport objectByRef: ref.	reply := GIOPLocateReply new.	reply requestId: self requestId.	obj _isRemote		ifTrue: [ reply OBJECT_FORWARD: obj _objRef ]		ifFalse: [ obj = UnregisteredObject default				ifTrue: [ reply UNKNOWN_OBJECT ]				ifFalse: [ reply OBJECT_HERE ] ].	"aTransport manager sendingReply: reply in: aTransport."	aTransport sendPackage: reply</body></methods><methods><class-id>Opentalk.GIOPLocateRequest</class-id> <category>marshaling</category><body package="Opentalk-CORBA">marshalPayloadFrom: anApplicationPkg using: marshaler	^self		writeHeader;		updateSizeFromPosition;		yourself</body></methods><methods><class-id>Opentalk.GIOPLocateRequest</class-id> <category>dispatching</category><body package="Opentalk-CORBA">returnWith: aLocateReply	"Returned from remote invocation (called from return package dispatching).  Inject the result into the promise to wakeup the sending thread."	| result |	result := aLocateReply getReturnValueFor: self.	aLocateReply failed		ifTrue: [ promise exception: result ]		ifFalse: [ promise value: result ]</body></methods><methods><class-id>Opentalk.GIOPLocateRequest</class-id> <category>marshaling</category><body package="Opentalk-CORBA">unmarshalPayloadUsing: marshaler 	^self</body></methods><methods><class-id>Opentalk.BasicObjectAdaptor</class-id> <category>CORBA</category><body package="Opentalk-CORBA">export: anObject oidBytes: aByteArray	| oid |	oid := aByteArray size &gt; 4		ifTrue: [ aByteArray copy changeClassTo: LargePositiveInteger; yourself ]		ifFalse: [ aByteArray reverse inject: 0 into: [ :t :b | (t bitShift: 8) bitOr: b ] ].	self export: anObject oid: oid</body></methods><methods><class-id>Opentalk.GIOPRequest</class-id> <category>marshaling</category><body package="Opentalk-CORBA">marshalPayloadFrom: anApplicationPkg using: marshaler	self writeHeader.	self minorVersion &gt; 1 ifTrue: [		self cdrStream padToLongLong ].	anApplicationPkg operation operation		marshallArguments: anApplicationPkg message arguments		on: self cdrStream.	^self		updateSizeFromPosition;		yourself</body><body package="Opentalk-CORBA">unmarshalPayloadUsing: marshaler 	| receiver ref request |	ref := self target asIIOPObjRefFor: marshaler transport.	receiver := marshaler adaptor objectByRef: ref.	request :=	CORBARequest new				target: receiver;				requestId: requestId;				serviceContext: serviceContext;				interceptorDispatcher: marshaler processingPolicy provideInterceptorDispatcher;				yourself.	receiver _isRemote ifFalse: [ | opMO arguments ifc |		ifc := ref interfaceId				ifNil: [ receiver corbaTypeIn: marshaler repository ]				ifNotNil: [ ref interfaceIn: marshaler repository ].		opMO := ifc findOpByName: operation.		self minorVersion &gt; 1 ifTrue: [ self cdrStream alignToLongLong ].		arguments := opMO unMarshallArgumentsFrom: self cdrStream.		request			message: (Message selector: opMO localOp arguments: arguments asArray);			operation: opMO ].	^request</body></methods><methods><class-id>Opentalk.GIOPReply</class-id> <category>marshaling</category><body package="Opentalk-CORBA">buildGIOPMessageOn: aBuffer for: aTransport	^self		initializeOn: aBuffer;		transport: aTransport;		yourself</body><body package="Opentalk-CORBA">locationForwardUsing: marshaler 	reply := IIOPObjRef cdrReadFrom: self cdrStream.	LocationForward signalWith: self.</body><body package="Opentalk-CORBA">marshalPayloadFrom: anApplicationPkg using: marshaler	self writeHeader.	self minorVersion &gt; 1 ifTrue: [		self cdrStream padToLongLong ].	(self isLocationForward or: [ self isSystemException ])		ifTrue: [ reply cdrWriteOn: self cdrStream ]		ifFalse: [ self isUserException				ifTrue: [ | mo params |					mo := (reply at: 1).					params := (reply at: 2).					self cdrStream nextPutRepositoryId: mo repositoryId.					mo errorType marshall: params on: self cdrStream ]				ifFalse: [					anApplicationPkg operation						marshallResult: reply						on: self cdrStream						withArgs: anApplicationPkg arguments ] ].	^self		updateSizeFromPosition;		yourself</body><body package="Opentalk-CORBA">noExceptionUsing: marshaler 	| request |	request := marshaler manager requestById: requestId.	request isNil ifTrue: [		marshaler adaptor receivedOrphanReply: self in: marshaler manager.		^self].	reply := request operation operation 			unMarshallResultsFrom: self cdrStream			withArgs: request message arguments.	^(CORBAReply return: reply)		serviceContext: serviceContext;		requestId: requestId;		arguments: request message arguments;		yourself</body><body package="Opentalk-CORBA">systemExceptionUsing: marshaler	reply := SystemException cdrReadFrom: self cdrStream.	^self useException: reply</body><body package="Opentalk-CORBA">unmarshalPayloadUsing: marshaler 	^(self unmarshalReplyUsing: marshaler)		interceptorDispatcher: (			(marshaler transport requestById: self requestId)				ifNil: [ marshaler processingPolicy provideInterceptorDispatcher ]				ifNotNil: [ :request | request interceptorDispatcher ]);		yourself</body><body package="Opentalk-CORBA">unmarshalReplyUsing: marshaler 	self minorVersion &gt; 1 ifTrue: [ self cdrStream alignToLongLong].	self isNoException ifTrue: [^self noExceptionUsing: marshaler].	(self isLocationForward or: [ self isLocationForwardPerm ])		ifTrue: [^self locationForwardUsing: marshaler].	self isUserException ifTrue: [^self userExceptionUsing: marshaler].	self isSystemException ifTrue: [^self systemExceptionUsing: marshaler].	^self useException: (		SystemException INTERNAL			messageText: 'LOC_NEEDS_ADDRESSING_MODE not supported';			COMPLETED_YES;			yourself)</body><body package="Opentalk-CORBA">useException: ex	^(CORBAReply return: ex)		serviceContext: serviceContext;		requestId: requestId;		yourself</body><body package="Opentalk-CORBA">userExceptionUsing: marshaler	| cds id mo |	cds := self cdrStream.	id := cds nextRepositoryId.	mo := marshaler repository lookupId: id.	reply := mo errorType unMarshall: cds.	reply :=		mo errorSignal exceptionClass new			parameter: reply;			messageText: mo name;			yourself.	^self useException: reply</body></methods><methods><class-id>Opentalk.MarshalerConfiguration class</class-id> <category>types</category><body package="Opentalk-CORBA">cdr	^CDRMarshalerConfiguration new</body></methods><methods><class-id>Core.Exception</class-id> <category>DST</category><body package="Opentalk-CORBA">corbaExceptionValue        "standard wrapper as required by the IDL Smalltalk Language        Mapping for accessing the exception value"        ^self parameter</body></methods><methods><class-id>Opentalk.GIOPCloseConnection</class-id> <category>marshaling</category><body package="Opentalk-CORBA">buildGIOPMessageOn: aBuffer for: aTransport	^self		initializeOn: aBuffer;		transport: aTransport;		yourself</body></methods><methods><class-id>Opentalk.GIOPCloseConnection</class-id> <category>dispatching</category><body package="Opentalk-CORBA">dispatchFor: aTransport 	"Force close aTransport."	"aTransport manager receivingRequest: self in: aTransport."	aTransport peerClose.</body></methods><methods><class-id>Opentalk.GIOPCloseConnection</class-id> <category>marshaling</category><body package="Opentalk-CORBA">marshalPayloadFrom: anApplicationPkg using: marshaler	^self		updateSizeFromPosition;		yourself</body><body package="Opentalk-CORBA">unmarshalPayloadUsing: marshaler 	^self</body></methods><methods><class-id>Opentalk.RemoteObject</class-id> <category>services</category><body package="Opentalk-CORBA">_locate	| ref |	ref := requestBroker locate: objRef.	ref isNil ifTrue: [^nil].	ref = objRef ifTrue: [^self].	^RemoteObject		newOn: ref		requestBroker: requestBroker</body><body package="Opentalk-CORBA">_narrowTo: anIfcId	objRef narrowTo: anIfcId</body><body package="Opentalk-CORBA">_release	requestBroker remoteObjectRegistry removeKey: objRef</body><body package="Opentalk-CORBA">_widenTo: anIfcId	objRef widenTo: anIfcId</body></methods><methods><class-id>Core.Signal</class-id> <category>DST</category><body package="Opentalk-CORBA">corbaHandle: handlerBlock do: doBlock 	"standard wrapper as required by the IDL Smalltalk Language Mapping for 	exception handling"	^self handle: handlerBlock do: doBlock</body><body package="Opentalk-CORBA">corbaRaise	"standard wrapper as required by the IDL Smalltalk Language 	Mapping for raising exceptions"	^self raiseWith: #()</body><body package="Opentalk-CORBA">corbaRaiseWith: aDictionary 	"standard wrapper as required by the IDL Smalltalk Language 	Mapping for raising exceptions with exception values"	^self raiseWith: aDictionary</body><body package="Opentalk-CORBA">corbaRaiseWith: aDictionary errorString: aString 	"standard wrapper as required by the IDL Smalltalk Language 	Mapping for raising exceptions with exception values"	^self raiseWith: aDictionary errorString: aString</body></methods><methods><class-id>Opentalk.CDRStream class</class-id> <category>utilities</category><body package="Opentalk-CORBA">referenceFromFile: aString 	"This method reads an object reference from a file"	| strm col |	strm := aString asFilename readStream.	[col := strm upToEnd]		ensure: [strm close].	^self stringToObject: col trim</body><body package="Opentalk-CORBA">referenceToFile: aString object: anObject 	"This method writes out the an object to an external file denoted by aString"	| strm |	strm := aString asFilename writeStream.		[strm nextPutAll: (self objectToString: anObject).	strm flush]		ensure: [strm close]</body></methods><methods><class-id>Opentalk.GIOPLocateReply</class-id> <category>marshaling</category><body package="Opentalk-CORBA">buildGIOPMessageOn: aBuffer for: aTransport	^self		initializeOn: aBuffer;		transport: aTransport;		yourself</body></methods><methods><class-id>Opentalk.GIOPLocateReply</class-id> <category>dispatching</category><body package="Opentalk-CORBA">dispatchFor: aTransport	| request |	"aTransport manager receivingReply: self in: aTransport."	request := aTransport requestById: self requestId.	request isNil		ifTrue: [ aTransport manager receivedOrphanReply: self in: aTransport ]		ifFalse: [ request returnWith: self ]</body><body package="Opentalk-CORBA">getReturnValueFor: aLocateRequest	^self isUnknown		ifTrue: [nil]		ifFalse: [self isHere				ifTrue: [aLocateRequest target]				ifFalse: [self reply]]</body></methods><methods><class-id>Opentalk.GIOPLocateReply</class-id> <category>marshaling</category><body package="Opentalk-CORBA">hasBody	"Neither UNKNOWN_OBJECT(0) and OBJECT_HERE(1)"	^locateStatus &gt; 1</body><body package="Opentalk-CORBA">marshalPayloadFrom: anApplicationPkg using: marshaler	self writeHeader.	self hasBody ifTrue: [		reply cdrWriteOn: self cdrStream ].	^self		updateSizeFromPosition;		yourself</body><body package="Opentalk-CORBA">unmarshalPayloadUsing: marshaler	reply := 		self isObjectForward			ifTrue: [ IIOPObjRef cdrReadFrom: self cdrStream ]			ifFalse: [ self failed					ifTrue: [ SystemException cdrReadFrom: self cdrStream ]					ifFalse: [ SystemException INTERNAL							messageText: 'LOC_NEEDS_ADDRESSING_MODE not supported';							COMPLETED_YES;							yourself ] ].	^self</body></methods><methods><class-id>Opentalk.BasicRequestBroker class</class-id> <category>instance creation</category><body package="Opentalk-CORBA">newCdrIiopAt: anIPSocketAddress	^(StandardBrokerConfiguration new		adaptor: (ConnectionAdaptorConfiguration new			isBiDirectional: false;			transport: (IIOPTransportConfiguration new				marshaler: (CDRMarshalerConfiguration new))))		newAt: anIPSocketAddress</body><body package="Opentalk-CORBA">newCdrIiopAt: anIPSocketAddress minorVersion: anInteger	^(StandardBrokerConfiguration new		adaptor: (ConnectionAdaptorConfiguration new			isBiDirectional: false;			transport: (IIOPTransportConfiguration new				minorVersion: anInteger;				marshaler: (CDRMarshalerConfiguration new))))		newAt: anIPSocketAddress</body><body package="Opentalk-CORBA">newCdrIiopAtPort: aNumber	^(StandardBrokerConfiguration new		adaptor: (ConnectionAdaptorConfiguration new			isBiDirectional: false;			transport: (IIOPTransportConfiguration new				marshaler: (CDRMarshalerConfiguration new))))		newAtPort: aNumber</body><body package="Opentalk-CORBA">newCdrIiopAtPort: aNumber minorVersion: anInteger	^(StandardBrokerConfiguration new		adaptor: (ConnectionAdaptorConfiguration new			isBiDirectional: false;			transport: (IIOPTransportConfiguration new				minorVersion: anInteger;				marshaler: (CDRMarshalerConfiguration new))))		newAtPort: aNumber</body></methods><methods><class-id>Opentalk.BasicRequestBroker</class-id> <category>RMI-API</category><body package="Opentalk-CORBA">locate: anObjRef	anObjRef isNil ifTrue: [^nil].	^self sendMessage: (Message selector: #_locate) to: anObjRef</body></methods><methods><class-id>Opentalk.BasicRequestBroker</class-id> <category>CORBA</category><body package="Opentalk-CORBA">objectToString: anObj 	"return the string which refers to the object as per the CORBA2.0 	Spec"	| ws ior ba |	ba := ByteArray new: 100.	ws := (CDRStream on: ba) reset.	ws nextPutBoolean: ws byteOrder.	anObj cdrWriteOn: ws.	ior := ws contents.	ws := (WriteStream on: (ByteString new: 200)) reset.	ws nextPutAll: 'IOR:'.	ior do: [:ch | ws nextPutAll: ch asHex].	^ws contents asByteString</body></methods><methods><class-id>Opentalk.BasicRequestBroker</class-id> <category>remoteObj-API</category><body package="Opentalk-CORBA">remoteObjectAt: anIPSocketAddress oid: oid interfaceId: anIfcId	^RemoteObject		newOn: (IIOPObjRef				newOn: anIPSocketAddress				oid: oid				interfaceId: anIfcId)		requestBroker: self</body></methods><methods><class-id>Opentalk.BasicRequestBroker</class-id> <category>CORBA</category><body package="Opentalk-CORBA">stringToObject: aString 	"return the object which is denoted by the string as per the 	CORBA2.0 Spec"	| prefix strm | 	prefix := aString copyUpTo: $:.	^prefix = 'IOR'		ifTrue: [			strm := (CDRStream on: (ByteArray new: aString size)) reset.			prefix size + 2 to: aString size - 1 by: 2 do: [:i |				strm nextPut: (aString at: i) digitValue * 16 + (aString at: i + 1) digitValue].			strm reset.			strm byteOrder: strm nextBoolean.			IIOPObjRef cdrReadFrom: strm]		ifFalse: [DSTORBObject invObjrefError: 0]</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>BasicRequestBroker</name><environment>Opentalk</environment><super>Opentalk.RestartProtocol</super><private>false</private><indexed-type>none</indexed-type><inst-vars>remoteObjectRegistry objectAdaptor requestType requestTimeout </inst-vars><class-inst-vars>brokerId defaultPort defaultRequestTimeout </class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><class><name>RemoteObject</name><environment>Opentalk</environment><super>Opentalk.Proxy</super><private>false</private><indexed-type>none</indexed-type><inst-vars>requestBroker dependents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><class><name>Signal</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parent mayProceed notifierString nameClass nameMessage exceptionClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>RemoteReply</name><environment>Opentalk</environment><super>Opentalk.RemoteMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>reply </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><class><name>GIOPCloseConnection</name><environment>Opentalk</environment><super>Opentalk.GIOPMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Tests</category><attributes><package>Opentalk-IIOP</package></attributes></class><class><name>RemoteRequest</name><environment>Opentalk</environment><super>Opentalk.RemoteMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>target message timeout promise reply </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><class><name>GIOPLocateReply</name><environment>Opentalk</environment><super>Opentalk.GIOPMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>requestId locateStatus reply </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Tests</category><attributes><package>Opentalk-IIOP</package></attributes></class><class><name>IIOPObjRef</name><environment>Opentalk</environment><super>Opentalk.ObjRef</super><private>false</private><indexed-type>none</indexed-type><inst-vars>profiles profile interfaceId interface </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-IIOP</category><attributes><package>Opentalk-IIOP</package></attributes></class><class><name>GIOPReply</name><environment>Opentalk</environment><super>Opentalk.GIOPMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>requestId replyStatus serviceContext reply </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Tests</category><attributes><package>Opentalk-IIOP</package></attributes></class><class><name>Marshaler</name><environment>Opentalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>manager configuration </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><class><name>BasicObjectAdaptor</name><environment>Opentalk</environment><super>Opentalk.RestartProtocol</super><private>false</private><indexed-type>none</indexed-type><inst-vars>accessPoint localAccessPoint accessAddress objectTable orb requestDispatcher processingPolicy localityTest </inst-vars><class-inst-vars>defaultRequestDispatcherConfiguration defaultLocalityTest </class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><class><name>MarshalerConfiguration</name><environment>Opentalk</environment><super>Opentalk.Configuration</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bufferSize </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><class><name>GIOPLocateRequest</name><environment>Opentalk</environment><super>Opentalk.GIOPMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>requestId target promise </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Tests</category><attributes><package>Opentalk-IIOP</package></attributes></class><class><name>Exception</name><environment>Core</environment><super>Core.GenericException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>GIOPRequest</name><environment>Opentalk</environment><super>Opentalk.GIOPMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>requestId target operation responseFlags serviceContext </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Tests</category><attributes><package>Opentalk-IIOP</package></attributes></class></st-source>