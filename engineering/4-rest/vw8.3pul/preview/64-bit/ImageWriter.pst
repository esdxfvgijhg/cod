<?xml version="1.0"?><st-source><!-- Name: ImageWriterNotice: Copyright 2008-2017 Cincom Systems, Inc.  All rights reserved.Comment: This package provides an image conversion framework which can read virtual image files and write them out with modifications.  This is used to convert from 32-bit virtual images to 64-bit virtual images.  It can convert from 64-bit to 32-bit as well, but this is used much less frequently.To produce a 64-bit image, load this package and then evaluate	VirtualImage		cloneFrom: 'visual'					"input 32-bit image"		to: 'visual64'							"output 64-bit image"		target: McCartneyImage				"code name for 64-bit engine"This image can then be loaded and run on a 64-bit VM (i.e. the Linux x86-64 VM, bin/linuxx86_64/vwlinuxx86_64gui).The ImageWriter takes some time and a lot of memory.  You may have to increase the memory upper bound to convert larger images.  Much of the time is taken in a consistency check that checks the output image's heap for leaks.  This can be disabled.  To do so, comment out "self testValidityForWrite" in VirtualImage>>#writeOutOn:.  Also, note the ImageWriter does not currently convert images with multiple fixed space segments.  This limitation can be worked around, however, by loading and resaving the image to convert.As far as the 64-bit system itself, there are few changes except for the larger potential heap.  The most significant change is the addition of an immediate double floating-point type, SmallDouble, which should reduce the memory footprint and increase the performance of double floating-point intensive applications (see SmallDouble's class comment).  Also, in the 64-bit system SmallIntegers are in the range from (2 raisedTo: 60) negated to (2 raisedTo: 60) - 1.DbIdentifier: bear73DbTrace: 501855DbUsername: lkooymanDbVersion: 8.3 - 5HideSource: falsePackageName: ImageWriterParcel: #('ImageWriter')ParcelName: ImageWriterPrintStringCache: (8.3 - 5,lkooyman)SaveSource: trueVersion: 8.3 - 5Date: 5:07:43 PM May 26, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (may17.4) of May 26, 2017 on May 26, 2017 at 5:07:43 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>VirtualImage</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>headerBytes registry objectMap segments bigEndian normalEndian sourceImage metaclasses classesToRehash allObjectsCache objectsForValidityTests </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VirtualImageWriter</category><attributes><package>ImageWriter</package></attributes></class><class><name>SixtyFourBitVirtualImage</name><environment>Smalltalk</environment><super>VirtualImage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tombstone classTable classHashTable nextClassHash fakeImage </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VirtualImageWriter</category><attributes><package>ImageWriter</package></attributes></class><class><name>McCartneyImage</name><environment>Smalltalk</environment><super>SixtyFourBitVirtualImage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VirtualImageWriter</category><attributes><package>ImageWriter</package></attributes></class><class><name>HandleRegistryForImageWriter</name><environment>Smalltalk</environment><super>OS.HandleRegistry</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ImageWriter</category><attributes><package>ImageWriter</package></attributes></class><class><name>HugeArray</name><environment>Smalltalk</environment><super>Core.SegmentedCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>shift mask </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VirtualImageWriter</category><attributes><package>ImageWriter</package></attributes></class><class><name>VirtualImageBytes</name><environment>Smalltalk</environment><super>Core.UninterpretedBytes</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>ImageWriter</package></attributes></class><class><name>VirtualObjectRehashProxy</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>actingAsAnAssociation virtualObject </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VirtualImageWriter</category><attributes><package>ImageWriter</package></attributes></class><class><name>ThirtyTwoBitVirtualmage</name><environment>Smalltalk</environment><super>VirtualImage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VirtualImageWriter</category><attributes><package>ImageWriter</package></attributes></class><class><name>VW7Image</name><environment>Smalltalk</environment><super>ThirtyTwoBitVirtualmage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VirtualImageWriter</category><attributes><package>ImageWriter</package></attributes></class><class><name>VirtualObject</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>address image header body mclass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VirtualImageWriter</category><attributes><package>ImageWriter</package></attributes></class><class><name>LargeVirtualImageBytes</name><environment>Smalltalk</environment><super>Core.SegmentedCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VirtualImageWriter</category><attributes><package>ImageWriter</package></attributes></class><class><name>VirtualImageSegment</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>baseAddress size data type allocs allocIndex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VirtualImageWriter</category><attributes><package>ImageWriter</package></attributes></class><methods><class-id>VirtualImage</class-id> <category>private enumerating</category><body package="ImageWriter">addClassAndAllSubclassesOf: aVirtualObject to: aSet	| subclasses |	aSet add: aVirtualObject.	subclasses := aVirtualObject body at: (Behavior instVarIndexFor: 'subclasses').	subclasses body do:		[:subclass|		self addClassAndAllSubclassesOf: subclass to: aSet]</body></methods><methods><class-id>VirtualImage</class-id> <category>private accessing</category><body package="ImageWriter">allInstVarNamesOfClass: aClassObject	| superclass list localVars shouldBeString |	superclass := aClassObject body at: 1.	list := superclass == superclass image nilOop		ifTrue: [OrderedCollection new]		ifFalse: [superclass image allInstVarNamesOfClass: superclass].	localVars := aClassObject body at: (Class instVarIndexFor: 'instanceVariables').	localVars == localVars image nilOop		ifTrue: [localVars := #()]		ifFalse:			[(self nameOfClass: localVars mclass) == #Array				ifFalse: [self error: 'Class structure not understood'].			localVars indexedFieldsDo: [:bodyArray :index |				shouldBeString := bodyArray at: index.				(self isBitData: shouldBeString body) ifFalse: [self halt].				list add: shouldBeString body asString]].	^list</body><body package="ImageWriter">allObjects	allObjectsCache notNil ifTrue: [^allObjectsCache].	segments last segmentType = #ot ifFalse: [self halt].	^allObjectsCache := segments last allObjects</body><body package="ImageWriter">allocateByteObj: object mclass: mclass bytes: bytes	| obj |	obj := VirtualObject new		image: self;		header: (self newBytes: self sizeOfOtEntry);		mclass: mclass;		body: (self newBytes: bytes sizeInBytes);		yourself."	self allocateData: obj."	self setHeader: obj header immutable: true for: obj.	obj body replaceBytesFrom: 1 to: bytes sizeInBytes with: bytes startingAt: 1."	obj address: (self allocateOop: obj)."	^obj</body><body package="ImageWriter">asBytes: aByteObject	^aByteObject copy changeClassTo: ByteArray</body><body package="ImageWriter">asStructuredBytes: bytes	^bytes copy changeClassTo: self structuredBytesClass</body><body package="ImageWriter">defaultLastHashValue	^self subclassResponsibility</body><body package="ImageWriter">double: offset in: bytes	^normalEndian		ifTrue: [bytes doubleAt: offset]		ifFalse: [bytes doubleAt: offset bigEndian: bigEndian]</body><body package="ImageWriter">double: offset in: bytes put: value	^normalEndian		ifTrue: [bytes doubleAt: offset put: value]		ifFalse: [bytes doubleAt: offset put: value bigEndian: bigEndian]</body><body package="ImageWriter">findSizeMethod	| nilObject mclass superclassIndex objectMethodDictionary |	nilObject := registry body at: self nilOopX.	mclass := nilObject mclass.	superclassIndex := Behavior instVarIndexFor: 'superclass'.	[(mclass body at: superclassIndex) == nilObject] whileFalse:		[mclass := mclass body at: superclassIndex].	objectMethodDictionary := mclass body at: (Behavior instVarIndexFor: 'methodDict').	^objectMethodDictionary body at: (objectMethodDictionary body indexOf: (registry body at: self sizeSelectorX)) + 1</body><body package="ImageWriter">flag: bit at: offset in: header 	self subclassResponsibility</body><body package="ImageWriter">flag: bit at: offset in: header put: value 	self subclassResponsibility</body><body package="ImageWriter">imageVersionsOfRehashClasses	"General instances of MethodDictionary and HandleRegistry must be	 correctly hashed if the system is to start-up.  So if the cloning process	 changes hashes all instances of these classes must be rehashed."	^IdentitySet with: MethodDictionary with: HandleRegistry</body><body package="ImageWriter">long: offset in: bytes 	^normalEndian 		ifTrue: [bytes longAt: offset]		ifFalse: [bytes longAt: offset bigEndian: bigEndian]</body><body package="ImageWriter">nameOfClass: aVirtualObject	| shouldBeASymbol |	shouldBeASymbol := aVirtualObject body at: (Class instVarIndexFor: 'name').	(self isBitData: shouldBeASymbol body) ifFalse: [self halt].	^shouldBeASymbol body asString asSymbol</body><body package="ImageWriter">nameOfClassEnvironment: aVirtualObject	| environment shouldBeASymbol |	environment := aVirtualObject body at: (Class instVarIndexFor: 'environment').	shouldBeASymbol := environment body at: (NameSpace instVarIndexFor: 'name').	(self isBitData: shouldBeASymbol body) ifFalse: [self halt].	^shouldBeASymbol body asString asSymbol</body><body package="ImageWriter">newBytes: size	^self structuredBytesClass new: size</body><body package="ImageWriter">oopSized: offset in: bytes	"Implementation must take into account the size of pointers in the target	image, and whether the target image is the same endianness as the image	doing the conversion."	^self subclassResponsibility</body><body package="ImageWriter">oopSized: offset in: bytes put: value	"Implementation must take into account the size of pointers in the target	image, and whether the target image is the same endianness as the image	doing the conversion."	^self subclassResponsibility</body><body package="ImageWriter">pointerSize	self subclassResponsibility</body><body package="ImageWriter">smallIntegerTag	self subclassResponsibility</body><body package="ImageWriter">structuredBytesClass	^VirtualImageBytes</body><body package="ImageWriter">tombstoneOop	^self registry body at: self weakRefTombstoneOopX</body><body package="ImageWriter">twosComplementImmediateOffset	^(1 bitShift: self pointerSize) + self smallIntegerTag</body><body package="ImageWriter">ulong: offset in: bytes	^normalEndian		ifTrue: [bytes unsignedLongAt: offset]		ifFalse: [bytes unsignedLongAt: offset bigEndian: bigEndian]</body><body package="ImageWriter">ulong: offset in: bytes put: value	^normalEndian		ifTrue: [bytes unsignedLongAt: offset put: value]		ifFalse: [bytes unsignedLongAt: offset put: value bigEndian: bigEndian]</body></methods><methods><class-id>VirtualImage</class-id> <category>writing</category><body package="ImageWriter">allocateData: object	| seg addr sz |	object bodySize &gt; 0		ifTrue:			[segments size = 2 ifFalse: [self halt].			 seg := segments first.			 seg segmentType = #data ifFalse: [self halt].			 addr := seg baseAddress + seg size.			 seg noteObject: object.			 seg growBy: (self computeBodySizeOf: object overflow: [:delta | addr := addr+delta])]		ifFalse: [addr := 0].	self bodyAddress: object header put: addr.	sz := object body class == Array		ifTrue: [object body size *self sizeOfOop]		ifFalse: [object body sizeInBytes].	self size: object header put: sz.	^addr</body><body package="ImageWriter">allocateNewSegments	segments := OrderedCollection new.	segments add: (VirtualImageSegment new		baseAddress: self defaultOldSpaceBase;		size: 0;		data: (LargeVirtualImageBytes new: (1 bitShift: 24));		segmentType: #data;		yourself).	segments add: (VirtualImageSegment new		baseAddress: self defaultOldOtBase;		size: 0;		data: (LargeVirtualImageBytes new: (1 bitShift: 22));		segmentType: #ot;		yourself)</body><body package="ImageWriter">allocateOop: object	| seg addr |	segments size = 2 ifFalse: [self halt].	seg := segments last.	seg segmentType = #ot ifFalse: [self halt].	addr := seg baseAddress + seg size.	seg noteObject: object.	seg growBy: self sizeOfOtEntry.	allObjectsCache := nil.	^addr</body><body package="ImageWriter">allocateRawData: size	| seg addr |	segments size = 2 ifFalse: [self halt].	seg := segments first.	seg segmentType = #data ifFalse: [self halt].	addr := seg baseAddress + seg size.	seg noteObject: #raw-&gt;size.	seg growBy: size.	addr - seg baseAddress + 1 to: addr - seg baseAddress + size do: [:index |		seg data byteAt: index put: 0].	^addr</body><body package="ImageWriter">computeBodySizeOf: object overflow: block 	self subclassResponsibility</body><body package="ImageWriter">defaultOldOtBase	self subclassResponsibility</body><body package="ImageWriter">defaultOldSpaceBase	self subclassResponsibility</body><body package="ImageWriter">finishHeaderForWrite	self subclassResponsibility</body><body package="ImageWriter">primeThreadedFreeLists	self subclassResponsibility</body><body package="ImageWriter">setViSignatureImageSizeFlag	"Either set or clear the most significant bit of the minor release	 number to distinguish between 32- and 64-bit images."	self subclassResponsibility</body><body package="ImageWriter">trimRegistry	| count |	count := self oopSized: self numSysOopSlotsOffset in: headerBytes.		"count should never be greater than the size of the registry, except		for old images resulting from a less than optimal ImageWrite."	count := count min: registry body size.	registry body: (registry body copyFrom: 1 to: count), (Array new: 25 withAll: registry body first).	(registry body at: self rtOopX) zeroData. "RT"	"Why can't we just zero it out? Why do we need to discard it?	 The VM would need to be rewritten, but that's probably worth it..."	(registry body at: self oldRtOopX) ~~ registry body first ifTrue:		[(registry body at: self oldRtOopX) zeroData.		 registry body at: self oldRtOopX put: registry body first]</body><body package="ImageWriter">writeOutOn: fileName	| file |	self finishHeaderForWrite.	self testValidityForWrite.	file := (fileName asFilename withEncoding: #binary) writeStream.	[file nextPutAll: (self asBytes: headerBytes).	segments do: [:s | file next: s size putAll: s data startingAt: 1]]		ensure: [file close].</body></methods><methods><class-id>VirtualImage</class-id> <category>immediates</category><body package="ImageWriter">asOop: object 	self subclassResponsibility</body><body package="ImageWriter">immediateTagsAndClassIndicesGivenOldRegistry: oldRegistry	self subclassResponsibility</body><body package="ImageWriter">isImmediateOop: anAddress	self subclassResponsibility</body><body package="ImageWriter">objectForImmediate: aSmalltalkObject	self subclassResponsibility</body><body package="ImageWriter">resolveImmediate: address 	self subclassResponsibility</body><body package="ImageWriter">tagBitsMask	self subclassResponsibility</body></methods><methods><class-id>VirtualImage</class-id> <category>testing</category><body package="ImageWriter">bigEndian: aBoolean	bigEndian := aBoolean</body><body package="ImageWriter">hasDirectClassPointers	^true</body><body package="ImageWriter">isBigEndian	^((headerBytes byteAt: self platformFlagsOffset) bitAnd: 1) = 0</body><body package="ImageWriter">mustRehash: aVirtualObject	^sourceImage notNil	 and: [sourceImage hashFieldSize ~= self hashFieldSize	 and: [classesToRehash includesKey: aVirtualObject mclass]]</body><body package="ImageWriter">noLeaksInAddressSpace	self subclassResponsibility</body><body package="ImageWriter">normalEndian: aBoolean	normalEndian := aBoolean</body><body package="ImageWriter">shouldIncludeObjectForValidityTest: aVirtualObject	^true</body><body package="ImageWriter">testValidityForWrite	"Answer if the object graph and image segments look valid or not."	objectsForValidityTests := VirtualObject allGeneralInstances select:								[:vo | vo image == self and: [self shouldIncludeObjectForValidityTest: vo]].	objectsForValidityTests := objectsForValidityTests asSortedCollection: [:a :b | a address &lt;= b address].	objectsForValidityTests := objectsForValidityTests asArray.	^self noLeaksInAddressSpace</body></methods><methods><class-id>VirtualImage</class-id> <category>decoding</category><body package="ImageWriter">bodyAddress: header	self subclassResponsibility</body><body package="ImageWriter">bodyAddress: header put: addr 	self subclassResponsibility</body><body package="ImageWriter">classPointer: header 	self subclassResponsibility</body><body package="ImageWriter">hasPointers: header 	self subclassResponsibility</body><body package="ImageWriter">hasPointers: header put: value 	self subclassResponsibility</body><body package="ImageWriter">hash: header 	self subclassResponsibility</body><body package="ImageWriter">hash: header put: value fromBits: oldBits 	self subclassResponsibility</body><body package="ImageWriter">hashBits	self subclassResponsibility</body><body package="ImageWriter">inOldRt: header put: value 	self subclassResponsibility</body><body package="ImageWriter">inRt: header put: value 	self subclassResponsibility</body><body package="ImageWriter">isEphemeron: header 	self subclassResponsibility</body><body package="ImageWriter">isEphemeron: header put: value 	self subclassResponsibility</body><body package="ImageWriter">isGcSpecial: header 	self subclassResponsibility</body><body package="ImageWriter">isGcSpecial: header put: value 	self subclassResponsibility</body><body package="ImageWriter">isImmutableObj: header 	self subclassResponsibility</body><body package="ImageWriter">isImmutableObj: header put: value 	self subclassResponsibility</body><body package="ImageWriter">isMarked: header put: value 	self subclassResponsibility</body><body package="ImageWriter">size: header overflow: checkOverflowSize 	self subclassResponsibility</body><body package="ImageWriter">size: header put: size	self subclassResponsibility</body></methods><methods><class-id>VirtualImage</class-id> <category>image header offsets</category><body package="ImageWriter">bytesInCopyrightOffset	self subclassResponsibility</body><body package="ImageWriter">copyrightOffset	self subclassResponsibility</body><body package="ImageWriter">fileFormatOffset	^44</body><body package="ImageWriter">fileIdNumberOffset	^37</body><body package="ImageWriter">imageSubTypeOffset	^42</body><body package="ImageWriter">imageTypeOffset	^41</body><body package="ImageWriter">largeSpaceThresholdOffset	^65</body><body package="ImageWriter">lastHashOffset	self subclassResponsibility</body><body package="ImageWriter">loadPolicyOffset	^43</body><body package="ImageWriter">numOldSpaceSandbarsOffset	self subclassResponsibility</body><body package="ImageWriter">numSysOopSlotsOffset	self subclassResponsibility</body><body package="ImageWriter">platformFlagsOffset	^45</body><body package="ImageWriter">scavengeThresholdOffset	^57</body><body package="ImageWriter">startupFlagsOffset	^46</body><body package="ImageWriter">sysOopRegistryOffset	self subclassResponsibility</body><body package="ImageWriter">tenureThresholdOffset	^61</body><body package="ImageWriter">viHeraldStringOffset	self subclassResponsibility</body><body package="ImageWriter">viHeraldStringSize	^101</body><body package="ImageWriter">viSignatureOffset	^69</body><body package="ImageWriter">vmIdOffset	^1</body><body package="ImageWriter">vmIdSize	^36</body><body package="ImageWriter">vmThumbprintOffset	^73</body></methods><methods><class-id>VirtualImage</class-id> <category>accessing</category><body package="ImageWriter">hashFieldSize	self subclassResponsibility</body><body package="ImageWriter">header	^headerBytes</body><body package="ImageWriter">imageHeaderSize	self subclassResponsibility</body><body package="ImageWriter">imageSubType	self subclassResponsibility</body><body package="ImageWriter">imageType	self subclassResponsibility</body><body package="ImageWriter">log2BytesInOop	self subclassResponsibility</body><body package="ImageWriter">nilOop	^registry body at: self nilOopX</body><body package="ImageWriter">rehashClassFor: aVirtualClassObject	^classesToRehash at: aVirtualClassObject</body><body package="ImageWriter">segments	^segments</body><body package="ImageWriter">sizeOfOop	self subclassResponsibility</body><body package="ImageWriter">sizeOfOtEntry	self subclassResponsibility</body><body package="ImageWriter">sizeOfRegistry	self subclassResponsibility</body></methods><methods><class-id>VirtualImage</class-id> <category>cloning</category><body package="ImageWriter">cloneFrom: anImage 	"We don't support fancy load control--this can be done by loading	the image into a functioning VM and saving it in a special way."	sourceImage := anImage.	bigEndian := anImage isBigEndian.	normalEndian := bigEndian = UninterpretedBytes isBigEndian.	headerBytes == nil ifTrue:		[headerBytes := self newBytes: self imageHeaderSize].	classesToRehash := IdentityDictionary new.	self initializeHeaderFrom: anImage.	self allocateNewSegments.	self primeThreadedFreeLists.	anImage trimRegistry.	self prepareForMigrationFrom: anImage.	registry := self importRegistry: anImage registry.	"Migrate nil, true and false first so the VM can optimize jump code.	 Strange but true.  See tCondBranch in tran/tcodes.c"	#(nilOopX trueOopX falseOopX) do:		[:indexSel| self migrate: (registry body at: (self perform: indexSel))].	self migrate: registry</body><body package="ImageWriter">convertRegistry: aRegistry	self subclassResponsibility</body><body package="ImageWriter">importRegistry: aRegistryObject	^aRegistryObject image sizeOfOop == self sizeOfOop		ifTrue: [aRegistryObject]		ifFalse: [self convertRegistry: aRegistryObject]</body><body package="ImageWriter">initializeHeaderFrom: anImage 	headerBytes		replaceBytesFrom: self vmIdOffset		to: self vmIdOffset+self vmIdSize-1		with: anImage header		startingAt: anImage vmIdOffset.	headerBytes		replaceBytesFrom: self fileIdNumberOffset		to: self fileIdNumberOffset+3		with: anImage header		startingAt: anImage fileIdNumberOffset.	headerBytes byteAt: self imageTypeOffset put: self imageType.	headerBytes byteAt: self imageSubTypeOffset put: self imageSubType.	"We don't support fancy load control--this can be done by loading	the image into a functioning VM and saving it in a special way."	headerBytes byteAt: self loadPolicyOffset put: 0.	"We don't support compression."	headerBytes byteAt: self fileFormatOffset put: 0.	"We could theoretically allow the output image to have a	different endianness than the input, but we'd have to byte-swap	manually all instances in the image whose layout changes	based on endianness. This includes Float, Double, WordArray,	TwoByteString, TwoByteSymbol, etc. It's not worth the trouble	at this time."	headerBytes		byteAt: self platformFlagsOffset		put: (anImage header byteAt: anImage platformFlagsOffset).	"Copy over the startup flags"	headerBytes		byteAt: self startupFlagsOffset		put: (anImage header byteAt: anImage startupFlagsOffset).	self ulong: self scavengeThresholdOffset		in: headerBytes		put: (anImage ulong: anImage scavengeThresholdOffset in: anImage header).	self ulong: self tenureThresholdOffset		in: headerBytes		put: (anImage ulong: anImage tenureThresholdOffset in: anImage header).	self ulong: self largeSpaceThresholdOffset		in: headerBytes		put: (anImage ulong: anImage largeSpaceThresholdOffset in: anImage header).	headerBytes		replaceBytesFrom: self viSignatureOffset		to: self viSignatureOffset+3		with: anImage header		startingAt: anImage viSignatureOffset.	self setViSignatureImageSizeFlag.	headerBytes		replaceBytesFrom: self vmThumbprintOffset		to: self vmThumbprintOffset+3		with: anImage header		startingAt: anImage vmThumbprintOffset.	self oopSized: self numSysOopSlotsOffset in: headerBytes put: self sizeOfRegistry.	"If the nunber of hash bits has changed lastHash is set	 to zero to tell the VM id hashes are not to be trusted."	self oopSized: self lastHashOffset		in: headerBytes		put: (anImage hashBits = self hashBits				ifTrue: [anImage oopSized: anImage lastHashOffset in: anImage header]				ifFalse: [self defaultLastHashValue]).	#(edenSizeOffset survivorSpaceSizeOffset largeSpaceSizeOffset stackSpaceSizeOffset	   nMethodZoneSizeOffset headroomSizeOffset fixedSpaceSizeOffset) do:		[:sel |		self ulong: (self perform: sel)			in: headerBytes			put: (anImage ulong: (anImage perform: sel) in: anImage header)].	headerBytes		replaceBytesFrom: self viHeraldStringOffset		to: self viHeraldStringOffset+self viHeraldStringSize-1		with: anImage header		startingAt: anImage viHeraldStringOffset.	headerBytes		byteAt: self bytesInCopyrightOffset		put: (anImage header byteAt: anImage bytesInCopyrightOffset).	headerBytes		replaceBytesFrom: self copyrightOffset		to: self copyrightOffset+(anImage header byteAt: anImage bytesInCopyrightOffset)-1		with: anImage header		startingAt: anImage copyrightOffset.	self initializeWidthDependentFieldsInHeaderFrom: anImage</body><body package="ImageWriter">initializeWidthDependentFieldsInHeaderFrom: anImage	self subclassResponsibility</body><body package="ImageWriter">migrate: object 	^object isImmediate		ifTrue: [object]		ifFalse: [object migrateTo: self]</body><body package="ImageWriter">migrateClass: aClassObject for: anInstance	| emigre |	emigre := self migrate: aClassObject.	self checkIfRehashClass: aClassObject.	^emigre</body><body package="ImageWriter">migrateHeader: header from: oldHeader in: oldImage for: anObject 	self hasPointers: header put: (oldImage hasPointers: oldHeader).	self isEphemeron: header put: (oldImage isEphemeron: oldHeader).	self isMarked: header put: false.	self inRt: header put: false.	self isImmutableObj: header put: (oldImage isImmutableObj: oldHeader).	self inOldRt: header put: false.	self isGcSpecial: header put: (oldImage isGcSpecial: oldHeader).	self hash: header put: (oldImage hash: oldHeader) fromBits: oldImage hashBits</body><body package="ImageWriter">numFixedFieldsForClass: aClassObject	^(aClassObject body at: 3) bitAnd: self class fixedFieldsMask</body><body package="ImageWriter">prepareForMigrationFrom: anImage	"Hook for subclasses to compute things immediately prior to migrating the object graph.	 By default, compute the set of metaclasses so classes can be easily identified."	| metaclass |	metaclasses := IdentitySet new: 8.	metaclass := (anImage registry body at: anImage arrayClassX) mclass mclass.	metaclasses		add: metaclass;		add: metaclass mclass</body><body package="ImageWriter">setHeader: header immutable: immutable for: obj	self hasPointers: header put: obj mclass mclassHasPointers.	self isEphemeron: header put: obj mclass mclassIsEphemeron.	self isMarked: header put: false.	self inRt: header put: false.	self isImmutableObj: header put: immutable.	self inOldRt: header put: false.	self isGcSpecial: header put: false.	false		ifTrue: [self hash: header put: (nil hash: nil) fromBits: self hashBits]</body></methods><methods><class-id>VirtualImage</class-id> <category>private testing</category><body package="ImageWriter">checkIfRehashClass: aClassObject	"Hook for subclasses to analyse freshly-migrated classes.	This is used e.g. to collect the classes whose instances	must be rehashed.  Be careful accessing instance variables,	some objects are instances of absent behavior shells"	| nameInstVarIndex maybeName imageClass |	nameInstVarIndex := Class instVarIndexFor: 'name'.	aClassObject body size &lt; nameInstVarIndex ifTrue: [^self].	maybeName := aClassObject body at: nameInstVarIndex.	"If the body is not a symbol this is a metaclass since (Metaclass allInstVarNames at: (Class instVarIndexFor: 'name') = 'thisClass')"	(self isBitData: maybeName body) ifFalse: [^self].	imageClass := self imageVersionOfClass: aClassObject thatIsOrInheritsFromAnyOf: self imageVersionsOfRehashClasses.	imageClass notNil ifTrue:		[classesToRehash at: aClassObject put: imageClass]</body><body package="ImageWriter">imageVersionOfClass: aClassObject thatIsOrInheritsFromAnyOf: imageVersionsOfRehashClasses	(imageVersionsOfRehashClasses do:		[:classInThisImage|		 (classInThisImage name == (self nameOfClass: aClassObject)		 and: [classInThisImage environment name == (self nameOfClassEnvironment: aClassObject)]) ifTrue:			[^(self subclassWithAppropriateHash: classInThisImage)]]).	  ^(self superclassOf: aClassObject) notNil ifTrue:		 [self			imageVersionOfClass: (self superclassOf: aClassObject)			thatIsOrInheritsFromAnyOf: imageVersionsOfRehashClasses]</body><body package="ImageWriter">isBitData: object	^object class == self structuredBytesClass</body><body package="ImageWriter">isPointerClass: aClassObject	^(aClassObject body at: 3) anyMask: self class pointersMask</body><body package="ImageWriter">subclassWithAppropriateHash: aClassObject	| name theClass |	(aClassObject == MethodDictionary	or: [aClassObject inheritsFrom: MethodDictionary]) ifTrue:		[^aClassObject].	name := (aClassObject name, 'ForImageWriter') asSymbol.	(self class environment includesKey: name) ifTrue:		[^self class environment at: name].	theClass := self class environment				defineClass: name				superclass: aClassObject fullyQualifiedReference				indexedType: #objects				private: false				instanceVariableNames: ''				classInstanceVariableNames: ''				imports: ''				category: 'ImageWriter'.	theClass		compile: 'initialIndexFor: aHashValue boundedBy: length	^(length &gt; SmallCollectionLimit	  and: [aHashValue &lt;= ', ((2 raisedTo: self hashBits) - 1) printString, '])		ifTrue: [aHashValue * (length // SmallCollectionLimit + 1) \\ length + 1]		ifFalse: [aHashValue \\ length + 1]'		classified: #'image writer rehash'.	^theClass</body><body package="ImageWriter">superclassOf: aClassObject	"Answer the superclass object for a virtual class object or nil if none."	| maybeSuperclass |	maybeSuperclass := aClassObject body at: (Behavior instVarIndexFor: 'superclass').	^maybeSuperclass body isEmpty ifFalse: [maybeSuperclass]</body></methods><methods><class-id>VirtualImage</class-id> <category>reading</category><body package="ImageWriter">addr: addressPtr size: sizePtr in: file segmentType: type	| addr size buf res |	addr := self oopSized: (self perform: addressPtr) in: headerBytes.	size := self oopSized: (self perform: sizePtr) in: headerBytes.	buf := LargeVirtualImageBytes new: size.	1 to: size by: 256 do: [:i |		res := file next: (256 min: size+1-i).		buf replaceBytesFrom: i to: i-1+res size with: res startingAt: 1].	^VirtualImageSegment new		baseAddress: addr;		size: size;		data: buf;		segmentType: type;		yourself</body><body package="ImageWriter">purgeSegments	segments := OrderedCollection new</body><body package="ImageWriter">readImage: file 	"VW7Image new readImageNamed: 'japan.im'"	"VW7Image new readImageNamed: 'visual.im'"	[headerBytes := self asStructuredBytes: (file next: self imageHeaderSize).	 bigEndian := ((headerBytes byteAt: self platformFlagsOffset) bitAnd: 1) = 0.	 normalEndian := bigEndian = UninterpretedBytes isBigEndian.	 (headerBytes byteAt: self fileFormatOffset) ~= 0 ifTrue:		[self error: (#canOnlyReadNormalFormat &lt;&lt; #dialogs &gt;&gt; 'Can only read normal image formats.  Image is probably compressed.')].	 self readSegments: file.	 self resolveObjectsFromRoot] 		ensure: [file close]</body><body package="ImageWriter">readImageNamed: name	"VW7Image new readImageNamed: 'japan.im'"	self readImage: (name asFilename withEncoding: #binary) readStream</body><body package="ImageWriter">readSegments: file	| oldData numSandbars oldOtData oldMap startD startOt baseD sizeD baseOt sizeOt data oopSize oldMapBlock |	segments := OrderedCollection new.	objectMap := HugeArray new: (1 bitShift: 64) shift: 48.	segments add: (self addr: #permSpaceBaseOffset size: #bytesInPermSpaceOffset in: file segmentType: #data).	segments add: (self addr: #permOtBaseOffset size: #bytesInPermOtOffset in: file segmentType: #ot).	segments add: (self addr: #newSpaceBaseOffset size: #bytesInNewSpaceOffset in: file segmentType: #mixed).	segments add: (self addr: #largeSpaceBaseOffset size: #bytesInLargeSpaceOffset in: file segmentType: #data).		"We don't use the LT, but treating it like any other segment simplifies parsing the file."	segments add: (self addr: #ltBaseOffset size: #bytesInLtOffset in: file segmentType: #garbage).	segments add: (self addr: #fixedSpaceBaseOffset size: #bytesInFixedSpaceOffset in: file segmentType: #data).	segments add: (self addr: #ftBaseOffset size: #bytesInFtOffset in: file segmentType: #ot).	oldData := self addr: #oldSpaceBaseOffset size: #bytesInOldSpaceOffset in: file segmentType: #data.	numSandbars := self oopSized: self numOldSpaceSandbarsOffset in: headerBytes.	oopSize := self pointerSize / 8.	oldMap := numSandbars = 0		ifTrue: [nil]		ifFalse: [self asStructuredBytes: (file next: numSandbars+1*oopSize*4)].	oldMapBlock := oopSize = 4		ifTrue: [[:base :field | oldMap unsignedLongAt: base+(oopSize*field) bigEndian: bigEndian]]		ifFalse: [oopSize = 8		ifTrue: [[:base :field | oldMap unsignedLongLongAt: base+(oopSize*field) bigEndian: bigEndian]]		ifFalse: [self error: 'bad oop size']].	oldOtData := self addr: #otBaseOffset size: #bytesInOtOffset in: file segmentType: #ot.	file atEnd ifFalse: [self error: 'extra data at end of file'].	oldMap == nil		ifTrue:			[segments add: oldData; add: oldOtData]		ifFalse:			[startD := 1.			startOt := 1.			1 to: oldMap sizeInBytes by: oopSize*4 do: [:i |				baseD := oldMapBlock value: i value: 0.				sizeD := oldMapBlock value: i value: 1.				baseOt := oldMapBlock value: i value: 2.				sizeOt := oldMapBlock value: i value: 3.				data := oldData data class new: sizeD.				data replaceBytesFrom: 1 to: sizeD with: oldData data startingAt: startD.				segments add: (VirtualImageSegment new					baseAddress: baseD;					size: sizeD;					data: data;					segmentType: #data;					yourself).				data := oldOtData data class new: sizeOt.				data replaceBytesFrom: 1 to: sizeOt with: oldOtData data startingAt: startOt.				segments add: (VirtualImageSegment new					baseAddress: baseOt;					size: sizeOt;					data: data;					segmentType: #ot;					yourself).				startD := startD + sizeD.				startOt := startOt + sizeOt].			startD - 1 = oldData size ifFalse: [self halt].			startOt - 1 = oldOtData size ifFalse: [self halt]]</body><body package="ImageWriter">registry	^registry</body><body package="ImageWriter">resolveObject: address	| segment header obj body |	(address isInteger and: [(address bitAnd: self tagBitsMask) ~= 0]) ifTrue:		[^self resolveImmediate: address].	obj := objectMap at: address.	obj isNil ifFalse: [^obj].	segment := segments detect: [:s | s contains: address].	segment segmentType = #ot ifTrue:		[| a |		 segment size \\ self sizeOfOtEntry = 0 ifFalse: [self halt].		 a := address - segment baseAddress \\ self sizeOfOtEntry.		 a = 0 ifFalse: [self halt]].	header := segment data				copyFrom: address-segment baseAddress+1				to: address-segment baseAddress+self sizeOfOtEntry.	obj := VirtualObject new.	obj address: address.	obj image: self.	obj header: header.	obj hasBody		ifTrue:			[segment := segments detect: [:s | s contains: obj bodyAddress].			body := segment data copyFrom: obj bodyAddress-segment baseAddress+1 to: obj bodyAddress-segment baseAddress+obj size.			obj body: body]		ifFalse: [obj body: #()].	objectMap at: address put: obj.	^obj</body><body package="ImageWriter">resolveObjectsFromRoot	 registry := self resolveObject: (self oopSized: self sysOopRegistryOffset in: headerBytes).	 registry resolvePointers</body></methods><methods><class-id>VirtualImage</class-id> <category>sys oop indices</category><body package="ImageWriter">nilOopX	self subclassResponsibility</body><body package="ImageWriter">oldRtOopX	self subclassResponsibility</body><body package="ImageWriter">rtOopX	self subclassResponsibility</body><body package="ImageWriter">sizeSelectorX	self subclassResponsibility</body><body package="ImageWriter">weakRefTombstoneOopX	self subclassResponsibility</body></methods><methods><class-id>VirtualImage class</class-id> <category>cloning</category><body package="ImageWriter">cloneFrom: oldName to: newName target: aVirtualImageClass	| oldImageName oldChangesName oldImage newImage |	oldImageName := (oldName, Filename imageExtension) asFilename.	oldChangesName := (oldName, Filename changeExtension) asFilename.	oldImage := self readImageNamed: oldImageName.	oldImage purgeSegments.	newImage := aVirtualImageClass new cloneFrom: oldImage.	newImage writeOutOn: (newName, Filename imageExtension) asFilename.	oldChangesName exists ifTrue:		[oldChangesName copyTo: (newName, Filename changeExtension) asFilename].	^newImage</body><body package="ImageWriter">default32BitImageType	"What is the image type we would use by default for 32-bit platforms?"	^VW7Image</body><body package="ImageWriter">default64BitImageType	"What is the image type we would use by default for 64-bit platforms?"	^McCartneyImage</body><body package="ImageWriter">readImageNamed: imageFilename	| rs majorVersionNumber minorVersionNumber |	rs := imageFilename asFilename readStream.	[rs binary; skip: 68.	 majorVersionNumber := rs next.	 minorVersionNumber := rs next]		ensure: [rs close].	^(minorVersionNumber &gt;= 128		ifTrue: [McCartneyImage]		ifFalse: [VW7Image]) new readImageNamed: imageFilename</body></methods><methods><class-id>VirtualImage class</class-id> <category>examples</category><body package="ImageWriter">example1	"VirtualImage example1"	| oldImage newImage |	oldImage := VW7Image new readImageNamed: (LogicalFilename fromComponents: #('$(VISUALWORKS)' 'image' 'visual.im')).	oldImage purgeSegments.	newImage := VW7Image new cloneFrom: oldImage.	newImage writeOutOn: 'v2.im'.	^newImage</body><body package="ImageWriter">example2	"VirtualImage example2"	| oldImage newImage |	oldImage := VW7Image new readImageNamed: (LogicalFilename fromComponents: #('$(VISUALWORKS)' 'image' 'visual.im')).	oldImage purgeSegments.	newImage := McCartneyImage new cloneFrom: oldImage.	newImage writeOutOn: 'visual64.im'.	^newImage</body></methods><methods><class-id>VirtualImage class</class-id> <category>hack accessing</category><body package="ImageWriter">sysOopIndices	| implementor |	implementor := self whichClassIncludesSelector: #nilOopX.	^implementor organization listAtCategoryNamed: (implementor whichCategoryIncludesSelector: #nilOopX)</body></methods><methods><class-id>SixtyFourBitVirtualImage</class-id> <category>sys oop indices</category><body package="ImageWriter">arrayClassX	^1 + 15</body><body package="ImageWriter">atPutSelectorX	^1 + 40</body><body package="ImageWriter">atSelectorX	^1 + 39</body><body package="ImageWriter">attemptToAssignSelectorX	^1 + 37</body><body package="ImageWriter">badBytecodeSelectorX	^1 + 36</body><body package="ImageWriter">blockClosureClassX	^1 + 13</body><body package="ImageWriter">blockContextClassX	^1 + 12</body><body package="ImageWriter">byteArrayClassX	^1 + 22</body><body package="ImageWriter">byteStringClassX	^1 + 17</body><body package="ImageWriter">byteSymbolClassX	^1 + 21</body><body package="ImageWriter">cannotResumeSelectorX	^1 + 38</body><body package="ImageWriter">cannotReturnSelectorX	^1 + 10</body><body package="ImageWriter">characterClassX	^1 + 6</body><body package="ImageWriter">classTablePageClassX	"Answer the class tag for the class table weak arrays"	^1 + 42</body><body package="ImageWriter">classTableX	^1 + 29</body><body package="ImageWriter">doesNotUnderstandSelectorX	^1 + 8</body><body package="ImageWriter">doubleClassX	^1 + 25</body><body package="ImageWriter">errorCodeTableX	^1 + 31</body><body package="ImageWriter">falseOopX	^1 + 2</body><body package="ImageWriter">finalQueueOopX	^1 + 34</body><body package="ImageWriter">floatClassX	^1 + 28</body><body package="ImageWriter">largeNegativeIntegerClassX	^1 + 19</body><body package="ImageWriter">largePositiveIntegerClassX	^1 + 18</body><body package="ImageWriter">maxHybridClassX	^1 + 10</body><body package="ImageWriter">messageClassX	^1 + 14</body><body package="ImageWriter">methodContextClassX	^1 + 11</body><body package="ImageWriter">mustBeBooleanSelectorX	^1 + 9</body><body package="ImageWriter">nilOopX	^1 + 0</body><body package="ImageWriter">nonlocalReturnSelectorX	^1 + 7</body><body package="ImageWriter">oldRtOopX	^1 + 33</body><body package="ImageWriter">pointClassX	^1 + 27</body><body package="ImageWriter">processSchedulerOopX	^1 + 3</body><body package="ImageWriter">rtOopX	^1 + 32</body><body package="ImageWriter">semaphoreClassX	^1 + 16</body><body package="ImageWriter">sizeSelectorX	^1 + 41</body><body package="ImageWriter">smallDoubleClassX	^1 + 5</body><body package="ImageWriter">smallIntegerClassX	^1 + 4</body><body package="ImageWriter">specialSelectorTableX	^1 + 30</body><body package="ImageWriter">trueOopX	^1 + 1</body><body package="ImageWriter">twoByteStringClassX	^1 + 23</body><body package="ImageWriter">twoByteSymbolClassX	^1 + 24</body><body package="ImageWriter">uninterpretedBytesClassX	^1 + 20</body><body package="ImageWriter">weakArrayClassX	^1 + 26</body><body package="ImageWriter">weakRefTombstoneOopX	^1 + 35</body></methods><methods><class-id>SixtyFourBitVirtualImage</class-id> <category>decoding</category><body package="ImageWriter">bodyAddress: header 	| addr |	addr := self ulonglong: 1 in: header.	(addr bitAnd: 7) = 0 ifFalse: [self halt].	^addr</body><body package="ImageWriter">bodyAddress: header put: addr 	self 		ulonglong: 1		in: header		put: addr</body><body package="ImageWriter">bodySize: header ifOverflow: aBlock 	| slotSize addr seg |	slotSize := self bits: 89 through: 96 in: header.	slotSize &gt;= (256 - 4) ifFalse: [^(slotSize bitShift: self log2BytesInOop)].	aBlock value: 8.	addr := (self bodyAddress: header) - 8.	seg := segments detect: [:s | s contains: addr].	addr := addr - seg baseAddress.	^self ulonglong: addr + 1 in: seg data</body><body package="ImageWriter">hasPointers: header 	^self flag: 64 at: 9 in: header</body><body package="ImageWriter">hasPointers: header put: value 	self flag: 64 at: 9 in: header put: value</body><body package="ImageWriter">hash: header 	^self bits: 107 through: 126 in: header</body><body package="ImageWriter">hash: header put: value fromBits: oldBits 	self bits: 107 through: 126 in: header put: value	"| ba |	 ba := ByteArray new: 16.	 (SixtyFourBitVirtualImage basicNew		normalEndian: UninterpretedBytes isBigEndian not;		bigEndian: false) hash: ba put: 16rFFFFF fromBits: 20.	 ba asArray collect: [:ea| ea storeStringRadix: 16]"</body><body package="ImageWriter">hashBits	^20</body><body package="ImageWriter">inOldRt: header put: value 	self flag: 21 at: 9 in: header put: value	"| ba |	 ba := ByteArray new: 16.	 (SixtyFourBitVirtualImage basicNew		normalEndian: UninterpretedBytes isBigEndian not;		bigEndian: false)inOldRt: ba put: true.	 ba asArray collect: [:ea| ea storeStringRadix: 16]"</body><body package="ImageWriter">inRt: header put: value 	self flag: 22 at: 9 in: header put: value</body><body package="ImageWriter">indexabilityField: header	^self bits: 99 through: 106 in: header</body><body package="ImageWriter">indexabilityField: header setTo: value	self bits: 99 through: 106 in: header put: value	"| ba |	 ba := ByteArray new: 16.	 (SixtyFourBitVirtualImage basicNew		normalEndian: UninterpretedBytes isBigEndian not;		bigEndian: false) indexabilityField: ba setTo: 16rFF.	 ba asArray collect: [:ea| ea storeStringRadix: 16]"</body><body package="ImageWriter">isEphemeron: header 	^self flag: 24 at: 9 in: header</body><body package="ImageWriter">isEphemeron: header put: value 	self flag: 24 at: 9 in: header put: value</body><body package="ImageWriter">isGcSpecial: header 	^self flag: 23 at: 9 in: header</body><body package="ImageWriter">isGcSpecial: header put: value 	self flag: 23 at: 9 in: header put: value</body><body package="ImageWriter">isImmutableObj: header 	^self flag: 33 at: 9 in: header</body><body package="ImageWriter">isImmutableObj: header put: value 	self flag: 33 at: 9 in: header put: value</body><body package="ImageWriter">isMarked: header put: value 	self flag: 34 at: 9 in: header put: value	"| ba |	 ba := ByteArray new: 16.	 (SixtyFourBitVirtualImage basicNew		normalEndian: UninterpretedBytes isBigEndian not;		bigEndian: false) isMarked: ba put: true.	 ba asArray collect: [:ea| ea storeStringRadix: 16]"</body><body package="ImageWriter">size: header overflow: checkOverflowSize 	| slotSize byteSize addr seg oddBytes |	slotSize := self bits: 89 through: 96 in: header .	oddBytes := (self hasPointers: header)					ifTrue: [0]					ifFalse: [(self indexabilityField: header) bitAnd: self sizeOfOop - 1]. 	checkOverflowSize ifFalse: [^(slotSize bitShift: self log2BytesInOop) - oddBytes].	slotSize &gt;= (256 - 4) ifFalse: [^(slotSize bitShift: self log2BytesInOop) - oddBytes].	addr := (self bodyAddress: header) - 8.	seg := segments detect: [:s | s contains: addr].	addr := addr - seg baseAddress.	byteSize := self ulonglong: addr + 1 in: seg data.	^byteSize - oddBytes</body><body package="ImageWriter">size: header put: size 	| roundedSize oddBytes slotSize addr seg |	roundedSize := size + 7 bitAnd: -8.	oddBytes := roundedSize - size.	slotSize := roundedSize bitShift: -3.	slotSize &gt;= (256 - 4) ifTrue:		[slotSize := 252.		addr := self bodyAddress: header.		seg := segments detect: [:s | s contains: addr].		self ulonglong: addr - seg baseAddress - 7 in: seg data put: roundedSize].	self bits: 89 through: 96 in: header put: slotSize.	oddBytes ~= 0 ifTrue:		[self indexabilityField: header setTo: oddBytes]</body></methods><methods><class-id>SixtyFourBitVirtualImage</class-id> <category>image header offsets</category><body package="ImageWriter">bytesInCopyrightOffset	^924</body><body package="ImageWriter">bytesInFixedSpaceOffset	^329</body><body package="ImageWriter">bytesInFtOffset	^345</body><body package="ImageWriter">bytesInLargeSpaceOffset	^113</body><body package="ImageWriter">bytesInLtOffset	^129</body><body package="ImageWriter">bytesInNewSpaceOffset	^97</body><body package="ImageWriter">bytesInOldSpaceOffset	^145</body><body package="ImageWriter">bytesInOtOffset	^161</body><body package="ImageWriter">bytesInPermOtOffset	^289</body><body package="ImageWriter">bytesInPermSpaceOffset	^273</body><body package="ImageWriter">checksumOffset	^1021</body><body package="ImageWriter">copyrightOffset	^925</body><body package="ImageWriter">defaultMappedPsBaseOffset	^297</body><body package="ImageWriter">edenSizeOffset	^241</body><body package="ImageWriter">firstThreadedDataOffset	^209</body><body package="ImageWriter">firstThreadedOtEntryOffset	^193</body><body package="ImageWriter">fixedSpaceBaseOffset	^321</body><body package="ImageWriter">fixedSpaceSizeOffset	^353</body><body package="ImageWriter">ftBaseOffset	^337</body><body package="ImageWriter">headroomSizeOffset	^261</body><body package="ImageWriter">heapBaseOffset	^81</body><body package="ImageWriter">largeSpaceBaseOffset	^105</body><body package="ImageWriter">largeSpaceSizeOffset	^249</body><body package="ImageWriter">lastHashOffset	^233</body><body package="ImageWriter">ltBaseOffset	^121</body><body package="ImageWriter">nMethodZoneSizeOffset	^257</body><body package="ImageWriter">newSpaceBaseOffset	^89</body><body package="ImageWriter">numOldSpaceSandbarsOffset	^169</body><body package="ImageWriter">numSysOopSlotsOffset	^185</body><body package="ImageWriter">numThreadedDataOffset	^217</body><body package="ImageWriter">numThreadedDataSlotsOffset	^225</body><body package="ImageWriter">numThreadedOtEntriesOffset	^201</body><body package="ImageWriter">oldSpaceBaseOffset	^137</body><body package="ImageWriter">otBaseOffset	^153</body><body package="ImageWriter">permOtBaseOffset	^281</body><body package="ImageWriter">permSpaceBaseOffset	^265</body><body package="ImageWriter">prevThreadedDataOffset	^self shouldNotImplement</body><body package="ImageWriter">psFirstThreadedDataOffset	^305</body><body package="ImageWriter">stackSpaceSizeOffset	^253</body><body package="ImageWriter">survivorSpaceSizeOffset	^245</body><body package="ImageWriter">sysOopRegistryOffset	^177</body><body package="ImageWriter">viHeraldStringOffset	^823</body></methods><methods><class-id>SixtyFourBitVirtualImage</class-id> <category>writing</category><body package="ImageWriter">computeBodySizeOf: object overflow: block 	| sz |	sz := object body class == Array 			ifTrue: [object body size * 8]			ifFalse: [object body sizeInBytes].	sz &gt; 2008 ifTrue: 		[sz := sz + 8.		 block value: 8].	sz := sz + 7 bitAnd: -8.	^sz</body><body package="ImageWriter">defaultOldOtBase	| base |	base := self ulonglong: self otBaseOffset in: headerBytes.	^base = 0		ifTrue: [16rC000000]		ifFalse: [base]</body><body package="ImageWriter">defaultOldSpaceBase	| base |	base := self ulonglong: self oldSpaceBaseOffset in: headerBytes.	^base = 0		ifTrue: [16r8000000]		ifFalse: [base]</body><body package="ImageWriter">primeThreadedFreeLists	| chunkSize freeData seg |	chunkSize := 70 * self sizeOfOop.	freeData := self allocateRawData: chunkSize.	seg := segments first.	self ulonglong: freeData - seg baseAddress + 1 in: seg data put: (chunkSize bitOr: self tagBitsMask).	self ulonglong: freeData - seg baseAddress + 41 in: seg data put: freeData.	self ulonglong: self firstThreadedOtEntryOffset in: headerBytes put: 0.	self ulonglong: self numThreadedOtEntriesOffset in: headerBytes put: 0.	self ulonglong: self firstThreadedDataOffset in: headerBytes put: freeData.	self ulonglong: self numThreadedDataOffset in: headerBytes put: 1.	self ulonglong: self numThreadedDataSlotsOffset in: headerBytes put: chunkSize / self sizeOfOop.	self ulonglong: self psFirstThreadedDataOffset in: headerBytes put: 0</body><body package="ImageWriter">setViSignatureImageSizeFlag	"Set the most significant bit of the minor release number	 to distinguish between 32- and 64-bit images."	headerBytes		byteAt: self viSignatureOffset + 1		put: ((headerBytes byteAt: self viSignatureOffset + 1) bitOr: 16r80)</body></methods><methods><class-id>SixtyFourBitVirtualImage</class-id> <category>private accessing</category><body package="ImageWriter">bits: startBit through: endBit in: bytes	| offset bits firstBit lastBit |	(startBit - endBit &gt;= 64 or: [startBit &gt; endBit]) ifTrue: [self halt].	offset := startBit - 1 // 64 * 8 + 1.	firstBit := startBit - 1 \\ 64 + 1.	lastBit := endBit - 1 \\ 64 + 1.	bits := self ulonglong: offset in: bytes.	^(bits bitShift: 1 - firstBit) bitAnd: (1 bitShift: lastBit - firstBit + 1) - 1	"((SixtyFourBitVirtualImage basicNew		normalEndian: UninterpretedBytes isBigEndian not;		bigEndian: false)		bits: 65		through: 84		in: #[16r00  16r11 16r22 16r33 16r44 16r55 16r66 16r77 16r88 16r99 16rAA 16rBB 16rCC 16rDD 16rEE 16rFF])			printStringRadix: 16"</body><body package="ImageWriter">bits: startBit through: endBit in: bytes put: anInteger	| offset bits firstBit lastBit |	(startBit - endBit &gt;= 64 or: [startBit &gt; endBit]) ifTrue: [self halt].	anInteger highBit &gt; 65 ifTrue: [self halt].	offset := startBit - 1 // 64 * 8 + 1.	firstBit := startBit - 1 \\ 64 + 1.	lastBit := endBit - 1 \\ 64 + 1.	bits := self ulonglong: offset in: bytes.	bits := bits bitAnd: ((1 bitShift: lastBit - firstBit + 1) - 1 bitShift: firstBit - 1) bitInvert.	bits := bits bitOr: (anInteger bitShift: firstBit - 1).	self ulonglong: offset in: bytes put: bits.	^bytes	"((SixtyFourBitVirtualImage basicNew		normalEndian: UninterpretedBytes isBigEndian not;		bigEndian: false)		bits: 65		through: 84		in: #[16r00  16r11 16r22 16r33 16r44 16r55 16r66 16r77 16r88 16r99 16rAA 16rBB 16rCC 16rDD 16rEE 16rFF] copy		put: 16r32211) asArray collect: [:ea| ea storeStringRadix: 16]"</body><body package="ImageWriter">defaultLastHashValue	"Answer a suitable default initial hash value.  Since we do rehash MethodDictionaries	 we don't need to tell the VM to avoid hashing into MethodDictionaries initially."	^16r55555</body><body package="ImageWriter">flag: bit at: offset in: header 	| word |	word := self ulonglong: offset in: header.	^(word bitAnd: (1 bitShift: bit - 1)) ~= 0</body><body package="ImageWriter">flag: bit at: offset in: header put: value 	| mask word |	mask := 1 bitShift: bit - 1.	word := self ulonglong: offset in: header.	word := word bitAnd: (-1 bitXor: mask).	value ifTrue: [word := word + mask].	self ulonglong: offset in: header put: word</body><body package="ImageWriter">oopSized: offset in: bytes	^normalEndian		ifTrue: [bytes unsignedLongLongAt: offset]		ifFalse: [bytes unsignedLongLongAt: offset bigEndian: bigEndian]</body><body package="ImageWriter">oopSized: offset in: bytes put: value	^normalEndian		ifTrue: [bytes unsignedLongLongAt: offset put: value]		ifFalse: [bytes unsignedLongLongAt: offset put: value bigEndian: bigEndian]</body><body package="ImageWriter">pointerSize	^64</body><body package="ImageWriter">smallIntegerTag	"Provisional"	^7</body><body package="ImageWriter">ulonglong: offset in: bytes	^normalEndian		ifTrue: [bytes unsignedLongLongAt: offset]		ifFalse: [bytes unsignedLongLongAt: offset bigEndian: bigEndian]</body><body package="ImageWriter">ulonglong: offset in: bytes put: value	^normalEndian		ifTrue: [bytes unsignedLongLongAt: offset put: value]		ifFalse: [bytes unsignedLongLongAt: offset put: value bigEndian: bigEndian]</body></methods><methods><class-id>SixtyFourBitVirtualImage</class-id> <category>accessing</category><body package="ImageWriter">imageHeaderSize	^1024</body><body package="ImageWriter">log2BytesInOop	^3</body><body package="ImageWriter">sizeOfOop	^8</body><body package="ImageWriter">sizeOfOtEntry	^16</body></methods><methods><class-id>SixtyFourBitVirtualImage</class-id> <category>cloning</category><body package="ImageWriter">initializeWidthDependentFieldsInHeaderFrom: anImage	self ulonglong: self heapBaseOffset in: headerBytes put: 16r4000000.	self ulonglong: self newSpaceBaseOffset in: headerBytes put: 16r4000000.	self ulonglong: self bytesInNewSpaceOffset in: headerBytes put: 0.	self ulonglong: self largeSpaceBaseOffset in: headerBytes put: 16r4000010.	self ulonglong: self bytesInLargeSpaceOffset in: headerBytes put: 0.	self ulonglong: self ltBaseOffset in: headerBytes put: 16r4000020.	self ulonglong: self bytesInLtOffset in: headerBytes put: 0.	self ulonglong: self oldSpaceBaseOffset in: headerBytes put: 16r8000000.	self ulonglong: self bytesInOldSpaceOffset in: headerBytes put: 0.	self ulonglong: self otBaseOffset in: headerBytes put: 16rC000000.	self ulonglong: self bytesInOtOffset in: headerBytes put: 0.	self ulonglong: self numOldSpaceSandbarsOffset in: headerBytes put: 0.	#(permSpaceBaseOffset bytesInPermSpaceOffset permOtBaseOffset	  bytesInPermOtOffset defaultMappedPsBaseOffset	  fixedSpaceBaseOffset bytesInFixedSpaceOffset ftBaseOffset bytesInFtOffset) do: [:sel |		self ulonglong: (self perform: sel) in: headerBytes put: 0].</body><body package="ImageWriter">setHeader: header immutable: immutable for: obj	self hasPointers: header put: obj mclass mclassHasPointers.	self isEphemeron: header put: obj mclass mclassIsEphemeron.	self isMarked: header put: false.	self inRt: header put: false.	self isImmutableObj: header put: immutable.	self inOldRt: header put: false.	self isGcSpecial: header put: false.	false		ifTrue: [self hash: header put: (nil hash: nil) fromBits: self hashBits].	self halt: 'set class and indexability'</body><body package="ImageWriter">slot: slotIndex in: body	^self ulonglong: slotIndex - 1 * 8 + 1 in: body</body><body package="ImageWriter">slot: slotIndex in: newBody putAsOop: aVirtualImageObject	self ulonglong: slotIndex - 1 * 8 + 1 in: newBody put: (self asOop: aVirtualImageObject)</body></methods><methods><class-id>SixtyFourBitVirtualImage</class-id> <category>reading</category><body package="ImageWriter">resolveClassFromHeader: header	^self classPointer: header</body></methods><methods><class-id>SixtyFourBitVirtualImage</class-id> <category>immediates</category><body package="ImageWriter">tagBitsMask	^7</body></methods><methods><class-id>McCartneyImage</class-id> <category>accessing</category><body package="ImageWriter">hashFieldSize	^20</body><body package="ImageWriter">imageSubType	^0</body><body package="ImageWriter">imageType	^10</body><body package="ImageWriter">sizeOfRegistry	^64</body></methods><methods><class-id>McCartneyImage</class-id> <category>immediates</category><body package="ImageWriter">findSmallDoubleGivenOldRegistry: oldRegistry	| doubleClass limitedPrecisionReal limitedPrecisionRealSubclasses |	oldRegistry resolvePointers.	doubleClass := oldRegistry body at: oldRegistry image doubleClassX.	doubleClass resolvePointers.	limitedPrecisionReal := doubleClass body at: (Behavior instVarIndexFor: 'superclass').	limitedPrecisionReal resolvePointers.	limitedPrecisionRealSubclasses := limitedPrecisionReal body at: (Behavior instVarIndexFor: 'subclasses').	limitedPrecisionRealSubclasses resolvePointers.	limitedPrecisionRealSubclasses body do:		[:maybeSmallDouble|		maybeSmallDouble resolvePointers.		(maybeSmallDouble image nameOfClass: maybeSmallDouble) == #SmallDouble ifTrue:			[^maybeSmallDouble]].	self error: 'Could not find SmallDouble in old image.  File-in SmallDouble.st to old image; save and try again.'</body><body package="ImageWriter">immediateTagsAndClassIndicesGivenOldRegistry: oldRegistry	^Dictionary new		at: 1 put: (oldRegistry body at: oldRegistry image characterClassX);		at: 3 put: (oldRegistry body at: oldRegistry image smallIntegerClassX);		at: 5 put: ([oldRegistry body at: oldRegistry image smallDoubleClassX]					on: MessageNotUnderstood					do: [:ex| self findSmallDoubleGivenOldRegistry: oldRegistry]);		yourself</body><body package="ImageWriter">isImmediateOop: anAddress	^(anAddress bitAnd: self tagBitsMask) ~= 0</body><body package="ImageWriter">resolveImmediate: address 	| tag a mantissa sign exponent n |	tag := address bitAnd: 7.	tag = 3 ifTrue:		[a := address.		 a highBit = 64 ifTrue: [a := a - 16r10000000000000000].		 a := a bitShift: -3.		 a class == 0 class ifFalse: [self halt].		^a].	tag = 1 ifTrue:		[^Character value: (address bitShift: -3)].	tag = 5 ifTrue:		["Create a Double or SmallDouble depending on what is supported		by the hosting image."		a := address bitShift: -3.		sign := a bitAnd: 1.		a := a bitShift: -1.		mantissa := a bitAnd: (1 bitShift: 52) - 1.		exponent := (a bitShift: -52) bitAnd: 16rFF.		(exponent = 0 and: [mantissa = 0]) ifTrue: [^0.0d * (-1.0d ** sign)].		mantissa := mantissa + (1 bitShift: 52).		n := mantissa asDouble timesTwoPower: exponent - 179.		^n * (-1.0d ** sign)].	self error: 'Unknown bit pattern'		"| im oop result list |	list := OrderedCollection with: 0.0d.	#(1.0d 3.14159d) do: [:v |		list add: v.		[(list last * 2) class == SmallDouble]			whileTrue: [list add: list last * 2].		list add: v/2.		[(list last / 2) class == SmallDouble]			whileTrue: [list add: list last / 2]].	im := McCartneyImmediateDoubles new.	im normalEndian: true.	list do: [:val |		oop := im			ifCanEncodeDouble: (VirtualObject new				body: ((VirtualImageBytes new: 8)					doubleAt: 1 put: val; yourself))			asSmallDouble: [:v|v].		val = (result := im resolveObject: oop)			ifFalse: [self halt]]"</body></methods><methods><class-id>McCartneyImage</class-id> <category>reading</category><body package="ImageWriter">resolveObjectsFromRoot	registry := self resolveObject: (self ulonglong: self sysOopRegistryOffset in: headerBytes).	registry resolveBodyPointers.	classTable := registry body at: self classTableX.	classTable resolveBodyPointers.	classTable body do: [:page |		page body class isBits 			ifTrue: [page resolveBodyPointers]			ifFalse: []].	classTable mclass; resolveIndirectPointers.	registry mclass; resolveIndirectPointers.</body></methods><methods><class-id>McCartneyImage</class-id> <category>testing</category><body package="ImageWriter">fillUnusedBitsInOt: os map: oas data: ds map: das	| valid freeDataAddress freeDataSlots |	valid := true.	freeDataAddress := self ulonglong: self firstThreadedDataOffset				in: headerBytes.	freeDataSlots := self ulonglong: self numThreadedDataSlotsOffset				in: headerBytes.	"Fill-out remaining bits to make error checking simpler (i.e. look for anything except 255)"	(freeDataAddress - ds baseAddress		to: freeDataAddress - ds baseAddress + (freeDataSlots * self sizeOfOop) - 1		by: 8) , (ds size to: ds size + 64 by: 8)		do: 			[:j |			| bit byte prev mask |			bit := j / 8 \\ 8.			byte := j // 64 + 1.			byte &lt;= das size				ifTrue: 					[mask := 1 bitShift: bit.					prev := das at: byte.					(prev bitAnd: mask) ~= 0						ifTrue: 							[valid := false.							self halt].					das at: byte put: (prev bitOr: mask)]].	(os size to: os size + 64 by: 8) do: 			[:j |			| bit byte prev mask |			bit := j / 8 \\ 8.			byte := j // 64 + 1.			byte &lt;= oas size				ifTrue: 					[mask := 1 bitShift: bit.					prev := oas at: byte.					(prev bitAnd: mask) ~= 0						ifTrue: 							[valid := false.							self halt].					oas at: byte put: (prev bitOr: mask)]].	^valid</body><body package="ImageWriter">hasDirectClassPointers	^false</body><body package="ImageWriter">noLeaksInAddressSpace	"Create two leak maps mapping each 8 byte quad-word to a bit."	| das oas os ds valid dataHoles otHoles |	ds := segments first.	os := segments last.	"8 bytes per bit in the leak map.	 Hence 8 * 8 bytes in the address space per byte in the leak map."	das := ByteArray new: (ds size + 63) // 64.	oas := ByteArray new: (os size + 63) // 64.	"Fill-out extra bits to make error checking simpler (i.e. look for anything except 255)"	valid := self				fillUnusedBitsInOt: os				map: oas				data: ds				map: das.	objectsForValidityTests do: 			[:ea |			| s sz bit byte prev mask |			s := ea bodyAddress - ds baseAddress.			sz := self computeBodySizeOf: ea overflow: [:n | s := s - n].			s to: s + sz - 1				by: 8				do: 					[:j |					bit := j / 8 \\ 8.					byte := j // 64 + 1.					mask := 1 bitShift: bit.					prev := das at: byte.					(prev bitAnd: mask) ~= 0						ifTrue: 							[valid := false.							self halt].					das at: byte put: (prev bitOr: mask)].			s := ea address - os baseAddress.			s to: s + 15				by: 8				do: 					[:j |					bit := j / 8 \\ 8.					byte := j // 64 + 1.					mask := 1 bitShift: bit.					prev := oas at: byte.					(prev bitAnd: mask) ~= 0						ifTrue: 							[valid := false.							self halt].					oas at: byte put: (prev bitOr: mask)]].	(dataHoles := (1 to: das size) select: [:i | (das at: i) ~= 255]) size &gt; 0		ifTrue: 			[valid := false.			self halt].	(otHoles := (1 to: oas size) select: [:i | (oas at: i) ~= 255]) size &gt; 0		ifTrue: 			[valid := false.			self halt].	^valid</body><body package="ImageWriter">noLeaksInHeap	"Traverse starting from the registry.  Everything should be reachable.  There should be no leaks."	| das oas os ds valid dataHoles otHoles |	ds := segments first.	os := segments last.	"8 bytes per bit in the leak map.	 Hence 8 * 8 bytes in the address space per byte in the leak map."	das := ByteArray new: (ds size + 63) // 64.	oas := ByteArray new: (os size + 63) // 64.	"Fill-out extra bits to make error checking simpler (i.e. look for anything except 255)"	valid := self				fillUnusedBitsInOt: os				map: oas				data: ds				map: das.	valid := valid &amp; (self						traverseHeapFrom: registry address						updatingOtMap: oas						ot: os						heapMap: das						data: ds).	(dataHoles := (1 to: das size) select: [:i | (das at: i) ~= 255]) size &gt; 0		ifTrue: 			[valid := false.			self halt].	(otHoles := (1 to: oas size) select: [:i | (oas at: i) ~= 255]) size &gt; 0		ifTrue: 			[valid := false.			self halt].	^valid</body><body package="ImageWriter">shouldIncludeObjectForValidityTest: aVirtualObject	"Filter-out Doubles that have been mapped to SmallDouble and LargeIntegers that have been mapped to SmallInteger."	^(aVirtualObject address bitAnd: self tagBitsMask) = 0</body><body package="ImageWriter">testObjectsValidInstances	| bad |	bad := objectsForValidityTests				select: [:obj | (self lookupClass: (self classTag: obj header)) == tombstone].	bad notEmpty ifTrue: [self halt].	^bad isEmpty</body><body package="ImageWriter">testValidClassTables	| valid badHashes badLookups hybridHashes badClasses badPages |	valid := true.	badHashes := Dictionary new.	badLookups := Dictionary new.	classHashTable keysAndValuesDo:		[:obj :hash| | lookup |		(self hash: obj header) ~= hash ifTrue:			[badHashes at: obj put: (self hash: obj header) -&gt; hash].		(lookup := self lookupClass: hash) ~~ obj ifTrue:			[badLookups at: obj put: lookup]].	(badHashes notEmpty or: [badLookups notEmpty]) ifTrue: [self halt].	hybridHashes := (Array						with: self hybridBlockContextClassTag						with: self hybridBlockClosureClassTag						with: self hybridMethodContextClassTag).	badClasses := IdentitySet new.	badPages := IdentitySet new.	classTable ~~ (registry body at: self classTableX) ifTrue: [valid := false. self halt].	1 to: classTable body size do:		[:majorIndex| | page |		page := classTable body at: majorIndex.		page ~~ registry body first ifTrue:			[(page body last ~= (majorIndex - 1)			 or: [page body size ~= ((1 bitShift: self bitsInClassTag / 2) + 1)]) ifTrue: [badPages add: majorIndex -&gt; page].			 badClasses addAll: (((1 to: page body size - 1) select:				[:minorIndex| | maybeClassObj hash |				 hash := (majorIndex - 1 bitShift: self bitsInClassTag / 2) + minorIndex - 1.				 (maybeClassObj := page body at: minorIndex) ~~ tombstone				  and: [((self hash: maybeClassObj header) ~= hash and: [(hybridHashes includes: hash) not])						or: [(classHashTable includesKey: maybeClassObj) not]]]) collect: [:index| page body at: index])]].	^valid	 and: [badHashes isEmpty	 and: [badLookups isEmpty	 and: [badPages isEmpty	 and: [badClasses isEmpty]]]]</body><body package="ImageWriter">testValidityForWrite	"Answer if the object graph and image segments look valid or not."	^super testValidityForWrite	&amp; self testValidClassTables	&amp; self testObjectsValidInstances	&amp; self noLeaksInHeap</body><body package="ImageWriter">traverseHeapFrom: obj updatingOtMap: oas ot: ot heapMap: das data: data	"Traverse starting from the registry.  Everything should be reachable.  There should be no leaks."	| valid s bit byte mask prev header delta sz |	valid := true.	(obj bitAnd: self tagBitsMask) ~= 0 ifTrue: [^true].	"immediate"	(obj bitAnd: self tagBitsMask + 1) ~= 0		ifTrue: 			[self halt.			^false].	"misaligned if in old segment, not if in perm..."	s := obj - ot baseAddress.	bit := s / 8 \\ 8.	byte := s // 64 + 1.	mask := 1 bitShift: bit.	prev := oas at: byte.	(prev bitAnd: mask) ~= 0 ifTrue: [^true].	"Already scanned"	mask = 128		ifTrue: 			[oas				at: byte put: (prev bitOr: 128);				at: byte + 1 put: ((oas at: byte + 1) bitOr: 1)]		ifFalse: [oas at: byte put: (prev bitOr: mask * 3)].	header := ot data copyFrom: obj - ot baseAddress + 1				to: obj - ot baseAddress + 16.	s := (self bodyAddress: header) - data baseAddress.	delta := 0.	sz := self bodySize: header ifOverflow: [:n | delta := 8].	s - delta to: s + sz - 1		by: 8		do: 			[:i |			bit := i / 8 \\ 8.			byte := i // 64 + 1.			mask := 1 bitShift: bit.			prev := das at: byte.			(prev bitAnd: mask) ~= 0				ifTrue: 					[valid := false.					self halt].			das at: byte put: (prev bitOr: mask)].	(self hasPointers: header)		ifTrue: 			[s + 1 to: s + sz				by: 8				do: 					[:j |					valid := valid &amp; (self										traverseHeapFrom: (self ulonglong: j in: data data)										updatingOtMap: oas										ot: ot										heapMap: das										data: data)]].	^valid</body></methods><methods><class-id>McCartneyImage</class-id> <category>decoding</category><body package="ImageWriter">classPointer: header	^self lookupClass: (self classTag: header)</body><body package="ImageWriter">classPointer: header setTo: aClassObject	| classTag |	classTag := self assignedHashFor: aClassObject.	classTag = 0		ifTrue: 			[classTag := classHashTable at: aClassObject.			classTag = 0 ifTrue: [self halt].			self				hash: aClassObject header				put: classTag				fromBits: nil].	self classTag: header setTo: classTag.	(self isPointerClass: aClassObject)		ifTrue: 			[self indexabilityField: header				setTo: (self numFixedFieldsForClass: aClassObject)]</body><body package="ImageWriter">classTag: header	^self bits: 65 through: 84 in: header</body><body package="ImageWriter">classTag: header setTo: anInteger	self		bits: 65		through: 84		in: header		put: anInteger</body></methods><methods><class-id>McCartneyImage</class-id> <category>class table indices</category><body package="ImageWriter">hybridBlockClosureClassTag	"This is only a (0-relative) class table index"	^10</body><body package="ImageWriter">hybridBlockContextClassTag	"This is only a (0-relative) class table index"	^9</body><body package="ImageWriter">hybridMethodContextClassTag	"This is only a (0-relative) class table index"	^8</body></methods><methods><class-id>McCartneyImage</class-id> <category>writing</category><body package="ImageWriter">allocateOop: object	(object isBits and: [object body sizeInBytes &lt;= 8]) ifTrue:		[object isDouble ifTrue:			[self ifCanEncodeDouble: object asSmallDouble: [:encodedOop| ^encodedOop]].		 object isLargePositiveInteger ifTrue:			[self ifCanEncodeLargePositiveInteger: object asSmallInteger: [:encodedOop| ^encodedOop]].		 object isLargeNegativeInteger ifTrue:			[self ifCanEncodeLargeNegativeInteger: object asSmallInteger: [:encodedOop| ^encodedOop]]].	^super allocateOop: object</body><body package="ImageWriter">asOop: object 	| raw signAndTags |	object class == Character ifTrue:		[^(object asInteger bitShift: 3) + 1].	object class == SmallInteger ifTrue: 		[^(object bitShift: 3) + (object &lt; 0 								ifTrue: [16r10000000000000003]								ifFalse: [3])].	(object respondsToArithmetic and: [object _iw_isDouble]) ifTrue:		[raw := (self newBytes: 8) doubleAt: 1 put: object; unsignedLongLongAt: 1.		 signAndTags := ((raw bitShift: -60) bitAnd: 16) bitOr: 5.		 ^object = 0.0d			ifTrue: [signAndTags] "make sure -0.0 remains -0.0"			ifFalse: [signAndTags bitOr: ((raw bitAnd: 16r7FFFFFFFFFFFFFFF) - (896 bitShift: 52) bitShift: 4)]].	^object address</body><body package="ImageWriter">finishHeaderForWrite	self		ulonglong: self sysOopRegistryOffset		in: headerBytes		put: registry address.	self		ulonglong: self bytesInOldSpaceOffset		in: headerBytes		put: segments first size.	self		ulonglong: self bytesInOtOffset		in: headerBytes		put: segments last size.	"Note that this seems to be explicitly a 32-bit quantity"	self		ulong: self classTableAllocationPointerOffset		in: headerBytes		put: nextClassHash</body><body package="ImageWriter">ifCanEncodeDouble: object asSmallDouble: aBlock 	[		| double raw signAndTags |		double := self double: 1 in: object body.		raw := self ulonglong: 1 in: object body.		signAndTags := ((raw bitShift: -60) bitAnd: 8) bitOr: 5. "make sure -0.0d remains -0.0d"		double = 0.0d ifTrue: [^aBlock value: signAndTags].		(double exponent between: -127 and: 128) ifTrue:			[				| remainingBits |				remainingBits := (raw bitAnd: 16r7FFFFFFFFFFFFFFF) - (896 bitShift: 52) bitShift: 4.				remainingBits &gt; 0 ifTrue:					[						"The encoding of +/- 1.0d timesTwoPower: -127 collides with that of 0.0d and -0.0d"						"If (blockValue bitAnd: 16rFFFFFFFFFFFFFFF0) = 0, then there is a representation issue"						| blockValue |						blockValue := remainingBits bitOr: signAndTags.						^aBlock value: blockValue					]			]	]		on: Double domainErrorSignal		do: [:ex | ex return]	"| im oop val result |	val := 3.14159d.	im := McCartneyImmediateDoubles new.	im normalEndian: true.	oop := im		ifCanEncodeDouble: (VirtualObject new			body: ((VirtualImageBytes new: 8)				doubleAt: 1 put: val; yourself))		asSmallDouble: [:v|v].	val = (result := im resolveObject: oop)		ifFalse: [self halt]"</body><body package="ImageWriter">ifCanEncodeLargeNegativeInteger: object asSmallInteger: aBlock 	| int |	object body sizeInBytes &gt; 8 ifTrue: [^self].	int := object body copy changeClassTo: LargePositiveInteger.	int &gt; (2 raisedTo: 60) ifTrue: [^self].	^aBlock value: (((int negated bitShift: 3) bitOr: 3) bitAnd: (1 bitShift: 64) - 1)</body><body package="ImageWriter">ifCanEncodeLargePositiveInteger: object asSmallInteger: aBlock 	| int |	object body sizeInBytes &gt; 8 ifTrue: [^self].	int := object body copy changeClassTo: LargePositiveInteger.	int &gt;= (2 raisedTo: 60) ifTrue: [^self].	^aBlock value: (((int bitShift: 3) bitOr: 3) bitAnd: (1 bitShift: 64) - 1)</body></methods><methods><class-id>McCartneyImage</class-id> <category>cloning</category><body package="ImageWriter">assignedHashFor: aClassObject	| hashOrNil |	hashOrNil := classHashTable at: aClassObject ifAbsent: [].	hashOrNil == nil		ifTrue: 			[hashOrNil := nextClassHash.			nextClassHash := nextClassHash + 1.			aClassObject image hasDirectClassPointers				ifFalse: 					[self						hash: aClassObject header						put: hashOrNil						fromBits: nil].			classHashTable at: aClassObject put: hashOrNil.			self classTableAt: hashOrNil put: aClassObject].	^hashOrNil</body><body package="ImageWriter">classTablePageSize	| pageSize |	pageSize := 1 bitShift: self bitsInClassTag / 2.	^pageSize</body><body package="ImageWriter">cloneFrom: anImage	super cloneFrom: anImage.	self writeClassTableData</body><body package="ImageWriter">convertRegistry: oldRegistry	(registry := VirtualObject new)		image: self;		body: (Array new: self sizeOfRegistry + 25);		header: (self newBytes: self sizeOfOtEntry).	false		ifTrue: 			["Allocation happens in migrateTo:"			registry address: (self allocateOop: registry).			self allocateData: registry.			registry mclass: (oldRegistry body at: oldRegistry image arrayClassX)].	self classTag: registry header setTo: self arrayClassX - 1.	"one rel to zero rel"	self hasPointers: registry header put: true.	registry body atAllPut: (oldRegistry body at: oldRegistry image nilOopX).	(self class sysOopIndices copyWithout: #oldRtOopX) do: 			[:sel |						[registry body at: (self perform: sel)				put: (oldRegistry body at: (oldRegistry image perform: sel))]					on: MessageNotUnderstood					do: 						[:ex |						ex message selector == #smallDoubleClassX							ifTrue: 								[registry body at: self smallDoubleClassX									put: (self findSmallDoubleGivenOldRegistry: oldRegistry)].						ex return]].	registry body at: self oldRtOopX put: registry body first.	self initializeClassTableGivenOldRegistry: oldRegistry.	registry body at: self classTableX put: classTable.	registry image: fakeImage.	"hack to get the thing to migrate in migrateTo:."	^registry</body><body package="ImageWriter">initializeClassTableGivenOldRegistry: oldRegistry	| pageSize |	classHashTable := IdentityDictionary new: 1024.	pageSize := 1 bitShift: self bitsInClassTag / 2.	(classTable := VirtualObject new)		image: self;		body: (Array new: pageSize);		header: registry header copy.	"both Arrays"	self classTag: classTable header setTo: self arrayClassX - 1.	"one rel to zero rel"	classTable body atAllPut: (registry body at: self nilOopX).	"Fill-in the immediate classes. 0 unused (0 is an illegal identity hash anyway)"	(self immediateTagsAndClassIndicesGivenOldRegistry: oldRegistry)		keysAndValuesDo: 			[:tagBits :classObject |			self classTableAt: tagBits put: classObject.			classHashTable at: classObject put: tagBits.			classObject image				hash: classObject header				put: tagBits				fromBits: classObject image hashBits].	"Fill-in the hybrid class puns"	self classTableAt: self hybridMethodContextClassTag		put: (oldRegistry body at: oldRegistry image methodContextClassX).	self classTableAt: self hybridBlockContextClassTag		put: (oldRegistry body at: oldRegistry image blockContextClassX).	self classTableAt: self hybridBlockClosureClassTag		put: (oldRegistry body at: oldRegistry image blockClosureClassX).	"Fill-in the known classes"	#(#arrayClassX #blockClosureClassX #blockContextClassX #byteArrayClassX #byteStringClassX #byteSymbolClassX #doubleClassX #floatClassX #largeNegativeIntegerClassX #largePositiveIntegerClassX #messageClassX #methodContextClassX #pointClassX #semaphoreClassX #twoByteStringClassX #twoByteSymbolClassX #uninterpretedBytesClassX #weakArrayClassX #classTablePageClassX)		do: 			[:sel |			| hash getIndex classObj |			hash := (self perform: sel) - 1.			getIndex := oldRegistry image perform: sel.			classObj := oldRegistry body at: getIndex.			self classTableAt: hash put: classObj.			classHashTable at: classObj put: hash.			classObj image				hash: classObj header				put: hash				fromBits: classObj image hashBits].	classTable image: fakeImage.	"hack to get the thing to migrate in migrateTo:."	^classTable</body><body package="ImageWriter">migrate: object	^object isImmediate		ifTrue: [object]		ifFalse: 			[(metaclasses includes: object mclass mclass)				ifTrue: [self migrateClass: object for: nil]				ifFalse: [object migrateTo: self]]</body><body package="ImageWriter">migrateClass: aClassObject for: anInstance	| hashOrNil emigre |	hashOrNil := self assignedHashFor: aClassObject.	anInstance ~~ nil		ifTrue: [self classTag: anInstance header setTo: hashOrNil].	emigre := aClassObject migrateTo: self.	self checkIfRehashClass: emigre.	^emigre</body><body package="ImageWriter">migrateHeader: header from: oldHeader in: oldImage for: anObject	| aClassObject hash |	self hasPointers: header put: (oldImage hasPointers: oldHeader).	self isEphemeron: header put: (oldImage isEphemeron: oldHeader).	self isMarked: header put: false.	self inRt: header put: false.	self isImmutableObj: header put: (oldImage isImmutableObj: oldHeader).	self inOldRt: header put: false.	self isGcSpecial: header put: (oldImage isGcSpecial: oldHeader).	self		hash: header		put: ((hash := classHashTable at: anObject ifAbsent: []) ~~ nil				ifTrue: [hash]				ifFalse: [oldImage hash: oldHeader])		fromBits: oldImage hashBits.	oldImage hasDirectClassPointers		ifTrue: 			[aClassObject := oldImage resolveClassFromHeader: oldHeader.			aClassObject isImmediate				ifTrue: [aClassObject := oldImage resolveHybridContextClass: aClassObject].			self classTag: header setTo: (self assignedHashFor: aClassObject).			(self hasPointers: header)				ifTrue: 					[self indexabilityField: header						setTo: (self numFixedFieldsForClass: aClassObject)]]		ifFalse: 			[self classTag: header setTo: (oldImage classTag: oldHeader).			self indexabilityField: header				setTo: (oldImage indexabilityField: oldHeader)]</body><body package="ImageWriter">newClassTablePageAt: hiIndex	| page |	fakeImage isNil		ifTrue: 			[classTable isNil ifTrue: [self halt].			fakeImage := self shallowCopy].	(page := VirtualObject new)		image: self;		body: (Array new: self classTablePageSize);		header: (self newBytes: self sizeOfOtEntry).	self classTag: page header setTo: self classTablePageClassX - 1.	self isImmutableObj: page header put: true.	self hasPointers: page header put: true.	self isGcSpecial: page header put: true.	self isEphemeron: page header put: false.	page body atAllPut: tombstone.	page image: fakeImage.	"hack to get the thing to migrate in migrateTo:."	^page</body><body package="ImageWriter">prepareForMigrationFrom: anImage	"Remember the tombstone for classTable iniialization."	super prepareForMigrationFrom: anImage.	tombstone := anImage registry body at: anImage weakRefTombstoneOopX</body><body package="ImageWriter">writeClassTableData	"Since the class table gets updated every time a class gets a hash assigned	 we must flush its data to the heap after all objects have migrated and before	 writing the heap."	classTable writeData.	classTable body do: [:pageOrNil | pageOrNil writeData]</body></methods><methods><class-id>McCartneyImage</class-id> <category>private accessing</category><body package="ImageWriter">bitsInClassTag	^20</body><body package="ImageWriter">classTableAt: hashIndex	| page hiIndex loIndex result |	hiIndex := (hashIndex bitShift: 0 - (self bitsInClassTag / 2)) + 1.	loIndex := (hashIndex bitAnd: (1 bitShift: self bitsInClassTag / 2) - 1)				+ 1.	page := (classTable body at: hiIndex) body.	page isEmpty		ifTrue: [^self subscriptBoundsErrorFor: #classTableAt: index: hashIndex].	(result := page at: loIndex) == tombstone		ifTrue: [^self subscriptBoundsErrorFor: #classTableAt: index: hashIndex].	^result</body><body package="ImageWriter">classTableAt: hashIndex put: aClassObject	| page hiIndex loIndex |	((aClassObject image hasPointers: aClassObject header)		and: [metaclasses includes: aClassObject mclass mclass])			ifFalse: 				[Transcript					cr;					show: 'Warning: unrecognized metaclasses (absent behavior shells?)'].	hiIndex := (hashIndex bitShift: 0 - (self bitsInClassTag / 2)) + 1.	loIndex := (hashIndex bitAnd: (1 bitShift: self bitsInClassTag / 2) - 1)				+ 1.	page := (classTable body at: hiIndex) body.	page isEmpty		ifTrue: 			[page := (classTable body at: hiIndex						put: (self newClassTablePageAt: hiIndex)) body].	(page at: loIndex) ~~ tombstone ifTrue: [self halt].	(nextClassHash isNil or: [nextClassHash &lt;= hashIndex])		ifTrue: [nextClassHash := hashIndex + 1].	^page at: loIndex put: aClassObject</body><body package="ImageWriter">lookupClass: aClassTag	aClassTag = 0 ifTrue: [self halt].	^(classTable body		at: (aClassTag bitShift: 0 - (self bitsInClassTag / 2)) + 1) body		at: (aClassTag bitAnd: (1 bitShift: self bitsInClassTag / 2) - 1) + 1</body></methods><methods><class-id>McCartneyImage</class-id> <category>image header offsets</category><body package="ImageWriter">classTableAllocationPointerOffset	^237</body></methods><methods><class-id>HandleRegistryForImageWriter</class-id> <category>image writer rehash</category><body package="ImageWriter">initialIndexFor: aHashValue boundedBy: length	^(length &gt; SmallCollectionLimit	  and: [aHashValue &lt;= 1048575])		ifTrue: [aHashValue * (length // SmallCollectionLimit + 1) \\ length + 1]		ifFalse: [aHashValue \\ length + 1]</body></methods><methods><class-id>HugeArray</class-id> <category>accessing</category><body package="ImageWriter">at: anIndex	"If the page is missing, answer what an uninitialized page would	have answered."	| c |	c := self basicAt: (anIndex - 1 bitShift: shift) + 1.	c == nil ifTrue: [^self defaultElement].	^c at: (anIndex - 1 bitAnd: mask) + 1</body><body package="ImageWriter">at: anIndex put: anObject 	"We copy the segment each time in case someone has asked for 	sharing. This makes for low space, but works only if stores are quite 	infrequent."	| c i1 |	i1 := (anIndex - 1 bitShift: shift) + 1.	c := self basicAt: i1.	c == nil		ifTrue:			[shift abs &gt; 20				ifTrue: [c := self class new: mask+1 shift: shift abs - 16]				ifFalse: [c := LargeArray new: mask+1]]		ifFalse: [compressed ifTrue: [c := c copy]].	c at: (anIndex - 1 bitAnd: mask) + 1 put: anObject.	self basicAt: i1 put: c.	^anObject</body><body package="ImageWriter">pageSize	"Answer the size of a page of the collection."	^mask+1</body><body package="ImageWriter">size	^self basicSize bitShift: shift negated</body><body package="ImageWriter">species	^Array</body></methods><methods><class-id>HugeArray</class-id> <category>initialize</category><body package="ImageWriter">setShift: newShift	shift := newShift negated.	mask := (1 bitShift: newShift) - 1.</body></methods><methods><class-id>HugeArray</class-id> <category>user interface</category><body package="ImageWriter">inspectorClasses	"For some arrayed collections there is no real difference between the	array and basic views, but for some there is so let's provide both. If this 	proves to be confusing, we can do a finer-grained tuning in individual	subclasses."	^Array		with: Tools.Trippy.BasicInspector</body></methods><methods><class-id>HugeArray class</class-id> <category>instance creation</category><body package="ImageWriter">new: n shift: shift	"Create an instance with at LEAST n slots, but it may be more."	^(self basicNew: (n - 1 bitShift: shift negated) + 1) initialize; setShift: shift</body></methods><methods><class-id>VirtualImageBytes</class-id> <category>private</category><body package="ImageWriter">asByteString	^self copy changeClassTo: ByteString</body><body package="ImageWriter">asString	^self copy changeClassTo: ByteString</body><body package="ImageWriter">doubleAt: byteIndex bigEndian: isBigEndian	"Answer a double-precision (64 bit) floating point quantity 	starting at the given byteIndex."	| bytes |	bytes := UninterpretedBytes new: 8.	bytes replaceBytesFrom: 1 to: 8 with: self startingAt: byteIndex.	isBigEndian = self platformIsBigEndian ifFalse: [bytes swapDoubleAt: 1].	bytes changeClassTo: Double.	^bytes + 0.0d		"Add 0 in case the double should be a SmallDouble"</body><body package="ImageWriter">doubleAt: byteIndex put: aDouble bigEndian: isBigEndian	"Store a double-precision (64 bit) floating point quantity	starting at the given byteIndex."	| bytes |	bytes := aDouble asDouble.	bytes class == SmallDouble ifTrue: [bytes := bytes asDegenerateDouble].	bytes := bytes shallowCopy.	bytes changeClassTo: UninterpretedBytes.	isBigEndian = self platformIsBigEndian ifFalse: [bytes swapDoubleAt: 1].	self replaceBytesFrom: byteIndex to: byteIndex+7 with: bytes startingAt: 1.	^aDouble</body><body package="ImageWriter">startingAt: repStart replaceBytesIn: collection from: start to: stop	"This destructively replaces elements from start to stop in the 	collection starting at index, repStart, in the receiver. 	Answer the collection."	^collection		replaceBytesFrom: start		to: stop		with: self		startingAt: repStart</body></methods><methods><class-id>VirtualImageBytes</class-id> <category>testing</category><body package="ImageWriter">platformIsBigEndian	^UninterpretedBytes isBigEndian</body></methods><methods><class-id>VirtualObjectRehashProxy</class-id> <category>instance initialization</category><body package="ImageWriter">for: aVirtualObject	virtualObject := aVirtualObject.	actingAsAnAssociation := false</body></methods><methods><class-id>VirtualObjectRehashProxy</class-id> <category>association impersonation</category><body package="ImageWriter">key	actingAsAnAssociation := true.	^self</body></methods><methods><class-id>VirtualObjectRehashProxy</class-id> <category>accessing</category><body package="ImageWriter">identityHash	"Here's a horrible hack.  If the hashed collection sends key to this	 proxy then we can assume we're being used an association.  So if	 we're acting as an association we answer the key's identityHash not	 the association's.  The horrible hack is that we assume the key is the	 first field in the virtual association.  The correct thing to do would be	 to derive the key inst var index from the methods of the key's class,	 i.e. do a virtual method lookup of the key message and extract the inst	 var index from the method.  But that's a lot of work and not guaranteed	 to work unless the method is very simple.  So for now we punt and	 assume the key is the first field of an association."	| virtualObjectsKey |	^actingAsAnAssociation		ifTrue:			[virtualObjectsKey := virtualObject body at: 1.			 virtualObjectsKey image hash: virtualObjectsKey header]		ifFalse:			[virtualObject isImmediate				ifTrue: [virtualObject identityHash]				ifFalse: [virtualObject image hash: virtualObject header]]</body><body package="ImageWriter">object	^virtualObject</body></methods><methods><class-id>VirtualObjectRehashProxy class</class-id> <category>instance creation</category><body package="ImageWriter">for: aVirtualObject	^self new for: aVirtualObject</body></methods><methods><class-id>ThirtyTwoBitVirtualmage</class-id> <category>sys oop indices</category><body package="ImageWriter">arrayClassX	^1 + 12</body><body package="ImageWriter">atPutSelectorX	^1 + 26</body><body package="ImageWriter">atSelectorX	^1 + 25</body><body package="ImageWriter">attemptToAssignSelectorX	^1 + 39</body><body package="ImageWriter">badBytecodeSelectorX	^1 + 38</body><body package="ImageWriter">blockClosureClassX	^1 + 6</body><body package="ImageWriter">blockContextClassX	^1 + 5</body><body package="ImageWriter">byteArrayClassX	^1 + 24</body><body package="ImageWriter">byteStringClassX	^1 + 19</body><body package="ImageWriter">byteSymbolClassX	^1 + 22</body><body package="ImageWriter">cannotResumeSelectorX	^1 + 23</body><body package="ImageWriter">cannotReturnSelectorX	^1 + 15</body><body package="ImageWriter">characterClassX	^1 + 8</body><body package="ImageWriter">classTablePageClassX	^1 + 40</body><body package="ImageWriter">doesNotUnderstandSelectorX	^1 + 14</body><body package="ImageWriter">doubleClassX	^1 + 32</body><body package="ImageWriter">errorCodeTableX	^1 + 18</body><body package="ImageWriter">falseOopX	^1 + 2</body><body package="ImageWriter">finalQueueOopX	^1 + 36</body><body package="ImageWriter">floatClassX	^1 + 9</body><body package="ImageWriter">largeNegativeIntegerClassX	^1 + 28</body><body package="ImageWriter">largePositiveIntegerClassX	^1 + 20</body><body package="ImageWriter">messageClassX	^1 + 11</body><body package="ImageWriter">methodContextClassX	^1 + 4</body><body package="ImageWriter">mustBeBooleanSelectorX	^1 + 16</body><body package="ImageWriter">nilOopX	^1 + 0</body><body package="ImageWriter">nonlocalReturnSelectorX	^1 + 33</body><body package="ImageWriter">oldRtOopX	^1 + 35</body><body package="ImageWriter">pointClassX	^1 + 10</body><body package="ImageWriter">processSchedulerOopX	^1 + 3</body><body package="ImageWriter">rtOopX	^1 + 31</body><body package="ImageWriter">semaphoreClassX	^1 + 13</body><body package="ImageWriter">sizeSelectorX	^1 + 27</body><body package="ImageWriter">smallIntegerClassX	^1 + 7</body><body package="ImageWriter">specialSelectorTableX	^1 + 17</body><body package="ImageWriter">trueOopX	^1 + 1</body><body package="ImageWriter">twoByteStringClassX	^1 + 29</body><body package="ImageWriter">twoByteSymbolClassX	^1 + 30</body><body package="ImageWriter">uninterpretedBytesClassX	^1 + 21</body><body package="ImageWriter">weakArrayClassX	^1 + 34</body><body package="ImageWriter">weakRefTombstoneOopX	^1 + 37</body></methods><methods><class-id>ThirtyTwoBitVirtualmage</class-id> <category>decoding</category><body package="ImageWriter">bodyAddress: header 	| addr |	addr := self ulong: 1 in: header.	(addr bitAnd: 3) = 0 ifFalse: [self halt].	^addr</body><body package="ImageWriter">bodyAddress: header put: addr 	self 		ulong: 1		in: header		put: addr</body><body package="ImageWriter">classPointer: header 	^self ulong: 5 in: header</body><body package="ImageWriter">classPointer: header put: addr 	^self 		ulong: 5		in: header		put: addr</body><body package="ImageWriter">classPointer: header setTo: aClassObject	^self classPointer: header put: aClassObject address</body><body package="ImageWriter">hasPointers: header 	^self flag: 32 at: 9 in: header</body><body package="ImageWriter">hasPointers: header put: value 	self flag: 32 at: 9 in: header put: value</body><body package="ImageWriter">hash: header 	^(self ulong: 9 in: header) bitAnd: 16r3FFF</body><body package="ImageWriter">hash: header put: value fromBits: oldBits 	| flags hash |	flags := (self ulong: 9 in: header) bitAnd: 16r3FFF bitInvert.	hash := value bitShift: self hashBits - oldBits.	(hash = 0 and: [value ~= 0]) ifTrue: [hash := value].	hash &lt; (1 bitShift: self hashBits) ifFalse: [self error: 'invalid hash'].	flags := flags + hash.	self 		ulong: 9		in: header		put: flags</body><body package="ImageWriter">hashBits	^14</body><body package="ImageWriter">inOldRt: header put: value 	self flag: 16 at: 9 in: header put: value</body><body package="ImageWriter">inRt: header put: value 	self flag: 29 at: 9 in: header put: value</body><body package="ImageWriter">isEphemeron: header 	^self flag: 31 at: 9 in: header</body><body package="ImageWriter">isEphemeron: header put: value 	self flag: 31 at: 9 in: header put: value</body><body package="ImageWriter">isGcSpecial: header 	^self flag: 15 at: 9 in: header</body><body package="ImageWriter">isGcSpecial: header put: value 	self flag: 15 at: 9 in: header put: value</body><body package="ImageWriter">isImmutableObj: header 	^self flag: 28 at: 9 in: header</body><body package="ImageWriter">isImmutableObj: header put: value 	self flag: 28 at: 9 in: header put: value</body><body package="ImageWriter">isMarked: header put: value 	self flag: 30 at: 9 in: header put: value</body><body package="ImageWriter">size: header overflow: checkOverflowSize 	| size addr seg |	size := self ulong: 9 in: header.	size := (size bitShift: -16) bitAnd: 16r7FF.	checkOverflowSize ifFalse: [^size].	size &gt;= (2048 - 32) ifFalse: [^size].	addr := (self bodyAddress: header) - 4.	seg := segments detect: [:s | s contains: addr].	addr := addr - seg baseAddress.	size := self ulong: addr + 1 in: seg data.	^size</body><body package="ImageWriter">size: header put: size 	| inlineSize flagWord addr seg |	size &lt; (2048 - 32) 		ifTrue: [inlineSize := size]		ifFalse: 			[inlineSize := 2016.			addr := self bodyAddress: header.			seg := segments detect: [:s | s contains: addr].			self ulong: addr - seg baseAddress - 3 in: seg data put: size].	flagWord := self ulong: 9 in: header.	flagWord := (flagWord bitAnd: 16rF800FFFF) + (inlineSize bitShift: 16).	self ulong: 9 in: header put: flagWord</body></methods><methods><class-id>ThirtyTwoBitVirtualmage</class-id> <category>image header offsets</category><body package="ImageWriter">bytesInCopyrightOffset	^412</body><body package="ImageWriter">bytesInFixedSpaceOffset	^213</body><body package="ImageWriter">bytesInFtOffset	^221</body><body package="ImageWriter">bytesInLargeSpaceOffset	^93</body><body package="ImageWriter">bytesInLtOffset	^101</body><body package="ImageWriter">bytesInNewSpaceOffset	^85</body><body package="ImageWriter">bytesInOldSpaceOffset	^109</body><body package="ImageWriter">bytesInOtOffset	^117</body><body package="ImageWriter">bytesInPermOtOffset	^197</body><body package="ImageWriter">bytesInPermSpaceOffset	^189</body><body package="ImageWriter">checksumOffset	^509</body><body package="ImageWriter">copyrightOffset	^413</body><body package="ImageWriter">defaultMappedPsBaseOffset	^201</body><body package="ImageWriter">edenSizeOffset	^161</body><body package="ImageWriter">firstThreadedDataOffset	^141</body><body package="ImageWriter">firstThreadedOtEntryOffset	^133</body><body package="ImageWriter">fixedSpaceBaseOffset	^209</body><body package="ImageWriter">fixedSpaceSizeOffset	^225</body><body package="ImageWriter">ftBaseOffset	^217</body><body package="ImageWriter">headroomSizeOffset	^181</body><body package="ImageWriter">heapBaseOffset	^77</body><body package="ImageWriter">largeSpaceBaseOffset	^89</body><body package="ImageWriter">largeSpaceSizeOffset	^169</body><body package="ImageWriter">lastHashOffset	^157</body><body package="ImageWriter">ltBaseOffset	^97</body><body package="ImageWriter">nMethodZoneSizeOffset	^177</body><body package="ImageWriter">newSpaceBaseOffset	^81</body><body package="ImageWriter">numOldSpaceSandbarsOffset	^121</body><body package="ImageWriter">numSysOopSlotsOffset	^129</body><body package="ImageWriter">numThreadedDataOffset	^149</body><body package="ImageWriter">numThreadedDataSlotsOffset	^153</body><body package="ImageWriter">numThreadedOtEntriesOffset	^137</body><body package="ImageWriter">oldSpaceBaseOffset	^105</body><body package="ImageWriter">otBaseOffset	^113</body><body package="ImageWriter">permOtBaseOffset	^193</body><body package="ImageWriter">permSpaceBaseOffset	^185</body><body package="ImageWriter">prevThreadedDataOffset	^145</body><body package="ImageWriter">psFirstThreadedDataOffset	^205</body><body package="ImageWriter">stackSpaceSizeOffset	^173</body><body package="ImageWriter">survivorSpaceSizeOffset	^165</body><body package="ImageWriter">sysOopRegistryOffset	^125</body><body package="ImageWriter">viHeraldStringOffset	^311</body></methods><methods><class-id>ThirtyTwoBitVirtualmage</class-id> <category>writing</category><body package="ImageWriter">computeBodySizeOf: object overflow: block 	| sz |	sz := object body class == Array 			ifTrue: [object body size * 4]			ifFalse: [object body sizeInBytes].	sz &gt; 2046 ifTrue: 		[sz := sz + 4.		 block value: 4].	sz := sz + 3 bitAnd: -4.	^sz</body><body package="ImageWriter">defaultOldOtBase	| base |	base := self ulong: self otBaseOffset in: headerBytes.	^base = 0		ifTrue: [16rC000000]		ifFalse: [base]</body><body package="ImageWriter">defaultOldSpaceBase	| base |	base := self ulong: self oldSpaceBaseOffset in: headerBytes.	^base = 0		ifTrue: [16r8000000]		ifFalse: [base]</body><body package="ImageWriter">finishHeaderForWrite	self ulong: self sysOopRegistryOffset in: headerBytes put: registry address.	self ulong: self bytesInOldSpaceOffset in: headerBytes put: (segments first size).	self ulong: self bytesInOtOffset in: headerBytes put: (segments last size)</body><body package="ImageWriter">primeThreadedFreeLists	| chunkSize freeData seg |	chunkSize := 70 * self sizeOfOop.	freeData := self allocateRawData: chunkSize.	seg := segments first.	self ulong: freeData - seg baseAddress + 1 in: seg data put: (chunkSize bitOr: self tagBitsMask).	self ulong: freeData - seg baseAddress + 21 in: seg data put: freeData.	self ulong: self firstThreadedOtEntryOffset in: headerBytes put: 0.	self ulong: self numThreadedOtEntriesOffset in: headerBytes put: 0.	self ulong: self firstThreadedDataOffset in: headerBytes put: freeData.	self ulong: self prevThreadedDataOffset in: headerBytes put: 0.	self ulong: self numThreadedDataOffset in: headerBytes put: 1.	self ulong: self numThreadedDataSlotsOffset in: headerBytes put: chunkSize / 4.	self ulong: self psFirstThreadedDataOffset in: headerBytes put: 0</body><body package="ImageWriter">resolveHybridContextClass: hybridContextClassTag	"Resolve the class of a hybrid context tag to the real context class."	^registry body at: hybridContextClassTag + 1</body><body package="ImageWriter">setViSignatureImageSizeFlag	"Clear the most significant bit of the minor release	 number to distinguish between 32- and 64-bit images."	headerBytes		byteAt: self viSignatureOffset + 1		put: ((headerBytes byteAt: self viSignatureOffset + 1) bitAnd: 16r7f)</body></methods><methods><class-id>ThirtyTwoBitVirtualmage</class-id> <category>private accessing</category><body package="ImageWriter">defaultLastHashValue	^0</body><body package="ImageWriter">flag: bit at: offset in: header 	| word |	word := self ulong: offset in: header.	^(word bitAnd: (1 bitShift: bit - 1)) ~= 0</body><body package="ImageWriter">flag: bit at: offset in: header put: value 	| mask word |	mask := 1 bitShift: bit - 1.	word := self ulong: offset in: header.	word := word bitAnd: (-1 bitXor: mask).	value ifTrue: [word := word + mask].	self ulong: offset in: header put: word</body><body package="ImageWriter">oopSized: offset in: bytes	^normalEndian		ifTrue: [bytes unsignedLongAt: offset]		ifFalse: [bytes unsignedLongAt: offset bigEndian: bigEndian]</body><body package="ImageWriter">oopSized: offset in: bytes put: value	^normalEndian		ifTrue: [bytes unsignedLongAt: offset put: value]		ifFalse: [bytes unsignedLongAt: offset put: value bigEndian: bigEndian]</body><body package="ImageWriter">pointerSize	^32</body><body package="ImageWriter">smallIntegerTag	^3</body></methods><methods><class-id>ThirtyTwoBitVirtualmage</class-id> <category>accessing</category><body package="ImageWriter">hashFieldSize	^14</body><body package="ImageWriter">imageHeaderSize	^512</body><body package="ImageWriter">log2BytesInOop	^2</body><body package="ImageWriter">sizeOfOop	^4</body><body package="ImageWriter">sizeOfOtEntry	^12</body></methods><methods><class-id>ThirtyTwoBitVirtualmage</class-id> <category>immediates</category><body package="ImageWriter">asOop: object 	object class == Character ifTrue:		[^(object asInteger bitShift: 2) + 1].	object class == SmallInteger ifTrue: 		[(object between: -536870912 and: 536870911)			ifTrue: [^((object bitAnd: 16r3FFFFFFF) bitShift: 2) + 3]			ifFalse: [self halt: 'This object should have been converted']].	(object respondsToArithmetic and: [object _iw_isDouble]) ifTrue: 		[self halt: 'This object should have been converted'].	^object address</body><body package="ImageWriter">immediateTagsAndClassIndicesGivenOldRegistry: oldRegistry	^Dictionary new		at: 1 put: (oldRegistry body at: oldRegistry image characterClassX);		at: 3 put: (oldRegistry body at: oldRegistry image smallIntegerClassX);		yourself</body><body package="ImageWriter">objectForImmediate: aSmalltalkObject	aSmalltalkObject class == Character ifTrue: [^(aSmalltalkObject asInteger bitShift: 2) + 1].	aSmalltalkObject class == SmallInteger ifTrue: 		[^aSmalltalkObject &lt; 0 			ifTrue: [(aSmalltalkObject bitShift: 2) + 16r100000003]			ifFalse: [(aSmalltalkObject bitShift: 2) + 3]].	"We'll hit this when mapping back from 64-bit images with immediate floats"	self halt</body><body package="ImageWriter">resolveImmediate: address 	| a |	(address bitAnd: 3) = 3 ifTrue: 		[a := address.		 a highBit = 32 ifTrue: [a := a - 16r100000000].		 a := a bitShift: -2.		 a class == 0 class ifFalse: [self halt].		 ^a].	(address bitAnd: 3) = 1 ifTrue:		[^Character value: (address bitShift: -2)].	self error: 'Unknown tag bit pattern'</body><body package="ImageWriter">tagBitsMask	^3</body></methods><methods><class-id>ThirtyTwoBitVirtualmage</class-id> <category>cloning</category><body package="ImageWriter">initializeWidthDependentFieldsInHeaderFrom: anImage	self ulong: self heapBaseOffset in: headerBytes put: 16r4000000.	self ulong: self newSpaceBaseOffset in: headerBytes put: 16r4000000.	self ulong: self bytesInNewSpaceOffset in: headerBytes put: 0.	self ulong: self largeSpaceBaseOffset in: headerBytes put: 16r4000010.	self ulong: self bytesInLargeSpaceOffset in: headerBytes put: 0.	self ulong: self ltBaseOffset in: headerBytes put: 16r4000020.	self ulong: self bytesInLtOffset in: headerBytes put: 0.	self ulong: self oldSpaceBaseOffset in: headerBytes put: 16r8000000.	self ulong: self bytesInOldSpaceOffset in: headerBytes put: 0.	self ulong: self otBaseOffset in: headerBytes put: 16rC000000.	self ulong: self bytesInOtOffset in: headerBytes put: 0.	self ulong: self numOldSpaceSandbarsOffset in: headerBytes put: 0.	#(permSpaceBaseOffset bytesInPermSpaceOffset permOtBaseOffset	  bytesInPermOtOffset defaultMappedPsBaseOffset	  fixedSpaceBaseOffset bytesInFixedSpaceOffset ftBaseOffset bytesInFtOffset) do: [:sel |		self ulong: (self perform: sel) in: headerBytes put: 0].</body><body package="ImageWriter">migrate: object 	^object isImmediate		ifTrue: [| obj classIndex bytes |			object class == SmallInteger ifTrue: 				[(object between: -536870912 and: 536870911)					ifFalse:						[classIndex := object &gt;= 0							ifTrue: [self largePositiveIntegerClassX]							ifFalse: [self largeNegativeIntegerClassX].						bytes := ByteArray new: object digitLength.						1 to: bytes size do: [:i | bytes at: i put: (object digitAt: i)].						obj := self							allocateByteObj: object							mclass: (registry body at: classIndex)							bytes: bytes.						^obj migrateTo: self]].			(object respondsToArithmetic and: [object _iw_isDouble]) ifTrue: 				[^(self					allocateByteObj: object					mclass: (registry body at: self doubleClassX)					bytes: (object asDegenerateDouble shallowCopy							changeClassToThatOf: #[]))					migrateTo: self].			object]		ifFalse: [object migrateTo: self]</body><body package="ImageWriter">slot: slotIndex in: body	^self ulong: slotIndex - 1 * 4 + 1 in: body</body><body package="ImageWriter">slot: slotIndex in: newBody putAsOop: aVirtualImageObject	self ulong: slotIndex - 1 * 4 + 1 in: newBody put: (self asOop: aVirtualImageObject)</body></methods><methods><class-id>ThirtyTwoBitVirtualmage</class-id> <category>reading</category><body package="ImageWriter">nilSlot: slotIndex in: body	body class == Array ifTrue: [self halt].	self		ulong: slotIndex - 1 * 4 + 1		in: body		put: (registry body class == Array				ifTrue: [(registry body at: 1) address]				ifFalse: [self ulong: 1 in: registry body])</body><body package="ImageWriter">resolveClassFromHeader: header	^self resolveObject: (self classPointer: header)</body></methods><methods><class-id>ThirtyTwoBitVirtualmage</class-id> <category>testing</category><body package="ImageWriter">noLeaksInAddressSpace	"Create two leak maps mapping each 4 byte word to a bit."	 | das oas os ds valid dataHoles otHoles |	valid := true.	ds := segments first.	os := segments last.	"8 * 4 bytes in the address space per byte in the leak map."	das := ByteArray new: ds size + 31 // 32.	oas := ByteArray new: os size + 31 // 32.	objectsForValidityTests do:		[:ea| | s sz bit byte prev mask |		s := ea bodyAddress - ds baseAddress.		sz := self computeBodySizeOf: ea overflow: [:n| s := s - n].		s to: s + sz - 1 by: 4 do:			[:j|			bit := j / 4 \\ 8.			byte := j // 32 + 1.			mask := 1 bitShift: bit.			prev := das at: byte.			(prev bitAnd: mask) ~= 0 ifTrue: [valid := false. self halt].			das at: byte put: (prev bitOr: mask)].		s := ea address - os baseAddress.		s to: s + 11 by: 4 do:			[:j|			bit := j / 4 \\ 8.			byte := j // 32 + 1.			mask := 1 bitShift: bit.			prev := oas at: byte.			(prev bitAnd: mask) ~= 0 ifTrue: [valid := false. self halt].			oas at: byte put: (prev bitOr: mask)]].	"Fill-out remaining bits to make error checking simpler (i.e. look for anything except 255)"	(ds size to: ds size + 32 by: 4) do:		[:j| | bit byte prev mask |		bit := j / 4 \\ 8.		byte := j // 32 + 1.		byte &lt;= das size ifTrue:			[mask := 1 bitShift: bit.			 prev := das at: byte.			 (prev bitAnd: mask) ~= 0 ifTrue: [valid := false. self halt].			 das at: byte put: (prev bitOr: mask)]].	(os size to: os size + 32 by: 4) do:		[:j| | bit byte prev mask |		bit := j / 4 \\ 8.		byte := j // 32 + 1.		byte &lt;= oas size ifTrue:			[mask := 1 bitShift: bit.			 prev := oas at: byte.			 (prev bitAnd: mask) ~= 0 ifTrue: [valid := false. self halt].			 oas at: byte put: (prev bitOr: mask)]].	(dataHoles := (1 to: das size) select: [:i| (das at: i) ~= 255]) size &gt; 0 ifTrue: [valid := false. self halt].	(otHoles := (1 to: oas size) select: [:i| (oas at: i) ~= 255]) size &gt; 0 ifTrue: [valid := false. self halt].	^valid</body></methods><methods><class-id>VW7Image</class-id> <category>accessing</category><body package="ImageWriter">imageSubType	^3</body><body package="ImageWriter">imageType	^9</body><body package="ImageWriter">sizeOfRegistry	^64</body></methods><methods><class-id>VW7Image</class-id> <category>immediates</category><body package="ImageWriter">isImmediateOop: anAddress	^(anAddress bitAnd: self tagBitsMask) ~= 0</body></methods><methods><class-id>VW7Image</class-id> <category>cloning</category><body package="ImageWriter">convertRegistry: oldRegistry	(registry := VirtualObject new)		image: self;		body: (Array new: self sizeOfRegistry+25);		mclass: (oldRegistry body at: oldRegistry image arrayClassX);		header: (self newBytes: self sizeOfOtEntry).	false ifTrue: "Allocation happens in migrateTo:"		[registry address: (self allocateOop: registry).		 self allocateData: registry.		 registry mclass: (oldRegistry body at: oldRegistry image arrayClassX)].	self hasPointers: registry header put: true.	registry body atAllPut: (oldRegistry body at: oldRegistry image nilOopX).	(self class sysOopIndices copyWithout: #oldRtOopX) do:		[:sel|		[registry body at: (self perform: sel) put: (oldRegistry body at: (oldRegistry image perform: sel))]			on: MessageNotUnderstood			do: [:ex|				ex pass]].	registry body at: self oldRtOopX put: registry body first.	false		ifTrue: [registry image: self fakeImage]. "hack to get the thing to migrate in migrateTo:."	^registry</body></methods><methods><class-id>VirtualObject</class-id> <category>accessing</category><body package="ImageWriter">address	^address</body><body package="ImageWriter">address: a	address := a.</body><body package="ImageWriter">body	^body</body><body package="ImageWriter">body: bytes	body := bytes</body><body package="ImageWriter">bodyAddress	^image bodyAddress: header</body><body package="ImageWriter">bodySize	^body class isBits		ifTrue: [body sizeInBytes]		ifFalse: [body size]</body><body package="ImageWriter">header	^header</body><body package="ImageWriter">header: bytes	header := bytes</body><body package="ImageWriter">image	^image</body><body package="ImageWriter">image: im	image := im</body><body package="ImageWriter">mclass	mclass == nil		ifTrue:			[mclass := image resolveClassFromHeader: header.			 mclass isImmediate				ifTrue: [self stabilizeHybridContext]				ifFalse: [mclass resolvePointers]]		ifFalse:			[mclass isImmediate ifTrue: "Do the last part of dehybridizing later, when the registry has been converted"				[mclass := image resolveHybridContextClass: mclass]].	^mclass</body><body package="ImageWriter">mclass: newMClass	mclass := newMClass.	address == nil		ifFalse: [image migrateClass: newMClass for: self]</body><body package="ImageWriter">resolveBodyPointers	| newBody |	((image hasPointers: header) and: [body class isBits]) ifTrue:		[newBody := Array new: (body sizeInBytes bitShift: image log2BytesInOop negated).		1 to: newBody size do: [:i | | obj addr |			addr := image slot: i in: body.			obj := image resolveObject: addr.			newBody at: i put: obj].		body := newBody]</body><body package="ImageWriter">resolveIndirectPointers	self mclass.	body class == Array ifTrue:		[body do: [:obj2 | obj2 isImmediate ifFalse: [obj2 resolvePointers]]]</body><body package="ImageWriter">resolvePointers	| newBody |	(mclass == nil or: [(image hasPointers: header) and: [body class isBits]]) ifFalse: [^self].	self mclass.	((image hasPointers: header) and: [body class isBits]) ifTrue:		[newBody := Array new: (body sizeInBytes bitShift: image log2BytesInOop negated).		1 to: newBody size do: [:i | | obj addr |			addr := image slot: i in: body.			obj := image resolveObject: addr.			newBody at: i put: obj].		body := newBody.		body do: [:obj2 | obj2 isImmediate ifFalse: [obj2 resolvePointers]]]</body></methods><methods><class-id>VirtualObject</class-id> <category>printing</category><body package="ImageWriter">className	| className |	self resolvePointers.	className := (body at: (Class instVarIndexFor: 'name')) body asString.	self mclass mclass ~~ image registry mclass mclass mclass ifTrue:		[^className asSymbol].	^className, ' class'</body><body package="ImageWriter">printOn: aStream	| b |	mclass == nil ifTrue: [^super printOn: aStream].	self mclass mclass == image registry mclass mclass mclass		ifTrue:			[self resolvePointers.			b := body at: 7.			b class == self class ifFalse: [self halt].			b := b body asByteString.			aStream nextPutAll: 'vo.'; nextPutAll: b]		ifFalse: [aStream nextPutAll: 'vo.instance of '; print: self mclass].</body></methods><methods><class-id>VirtualObject</class-id> <category>testing</category><body package="ImageWriter">hasBody	^(image size: header overflow: false) &gt; 0</body><body package="ImageWriter">isBits	^body class ~~ Array</body><body package="ImageWriter">isDouble	^(image registry body at: image doubleClassX) == self mclass</body><body package="ImageWriter">isLargeNegativeInteger	^(image registry body at: image largeNegativeIntegerClassX) == self mclass</body><body package="ImageWriter">isLargePositiveInteger	^(image registry body at: image largePositiveIntegerClassX) == self mclass</body><body package="ImageWriter">size	^image size: header overflow: true</body></methods><methods><class-id>VirtualObject</class-id> <category>private-rehashing</category><body package="ImageWriter">indexedFieldsDo: aBlock	(image numFixedFieldsForClass: self mclass)+1 to: body size do: [:i |		aBlock value: body value: i]</body><body package="ImageWriter">methodDictionaryRehash	| newmd |	newmd := MethodDictionary new: body size // 2.	1 to: body size by: 2 do:		[:i|		newmd at: (VirtualObjectRehashProxy for: (body at: i)) put: (body at: i + 1)].	1 to: body size by: 2 do:		[:i|		body			at: i put: (newmd basicAt: i) object;			at: i + 1 put: (newmd basicAt: i + 1)]</body><body package="ImageWriter">nilHandle	"Handle registries may contain objects that have something other	than handle or theDatum instance variables.  An example of this	are instances of OracleConnection.  Assume the ImageWriter will	never be able to deal with every single thing that can be put in a	handle registry, and therefore let go of the objects that cannot be	recognized.  Let the image deal with those objects upon startup.	Do not fail if the detect: does not recognize any of the known	instance variable names."	| allInstVarNames name nameIndex |	allInstVarNames := self mclass image allInstVarNamesOfClass: self mclass.	name := #('handle' 'theDatum')		detect: [:nm | allInstVarNames includes: nm]		ifNone: [nil].	name isNil ifTrue:		[			Transcript show: 'Warning: unrecognized object in handle registry, ', self mclass className; cr.			^self		].	nameIndex := allInstVarNames indexOf: name.	body at: nameIndex put: image nilOop</body></methods><methods><class-id>VirtualObject</class-id> <category>writing</category><body package="ImageWriter">migrateTo: anImage 	| oldImage oldHeader |	(image == anImage and: [address notNil]) ifTrue: [^self].	oldImage := image.	image := anImage.	(anImage isImmediateOop: (address := anImage allocateOop: self)) ifFalse:		[oldHeader := header.		 header := image newBytes: image sizeOfOtEntry.		 anImage allocateData: self.		 image migrateHeader: header from: oldHeader in: oldImage for: self.		 anImage migrateClass: self mclass for: self.		 image classPointer: header setTo: mclass.		 self writeHeader.		 self writeData].	^self</body><body package="ImageWriter">stabilizeHybridContext	"Dehybridize a hybrid context.  i.e. replace its integer class marker with the actual	 context class, set the sender to nil and set the pc to some invalid value.  We leave	 the class until later but do the other two things now.  Its typically too early to convert	 the class as the registry has yet to be mapped."	image nilSlot: (Context instVarIndexFor: 'sender') in: body.		"Put a SmallInteger value (SmallInteger maxVal on 32-bit images)		that is large enough to be virtually impossible as a PC value but small		enough to be immediate on all image types."	image		slot: (Context instVarIndexFor: 'pc')		in: body		putAsOop: 16r1FFFFFFF</body><body package="ImageWriter">writeData	| bodyData seg |	body class == Array 		ifTrue: 			[bodyData := image newBytes: body size * image sizeOfOop.			1 to: body size do:				[:i |				body at: i put: (image migrate: (body at: i))].			(image mustRehash: self) ifTrue:				[self rehash].			1 to: body size do:				[:i |				image slot: i in: bodyData putAsOop: (body at: i)]			"Note the above is now breadth-first.  As Steve originally wrote it it was depth first:			 1 to: body size do:				[:i |				body at: i put: (image migrate: (body at: i)).				image slot: i in: bodyData putAsOop: (body at: i)]."]		ifFalse: [bodyData := body].	seg := image segments first.	seg data 		replaceBytesFrom: self bodyAddress - seg baseAddress + 1		to: self bodyAddress - seg baseAddress + bodyData sizeInBytes		with: bodyData		startingAt: 1.</body><body package="ImageWriter">writeHeader	| seg |	seg := image segments last.	seg data 		replaceBytesFrom: address - seg baseAddress + 1		to: address - seg baseAddress + header sizeInBytes		with: header		startingAt: 1.</body><body package="ImageWriter">zeroData	1 to: body sizeInBytes do: [:i | body byteAt: i put: 0].</body></methods><methods><class-id>VirtualObject</class-id> <category>cloning</category><body package="ImageWriter">rehash	"Rehash instances of MethodDictionary"	(image nameOfClass: self mclass) == #MethodDictionary		ifTrue: [self methodDictionaryRehash]</body></methods><methods><class-id>VirtualObject</class-id> <category>class accessing</category><body package="ImageWriter">mclassHasPointers	| format |	body class isBits ifTrue: [self halt].	format := body at: 3.	format class == 0 class ifFalse: [self halt].	^format anyMask: Behavior.PointersMask</body><body package="ImageWriter">mclassIsEphemeron	| format |	body class isBits ifTrue: [self halt].	format := body at: 3.	format class == 0 class ifFalse: [self halt].	^format anyMask: Behavior.EphemeronMask</body></methods><methods><class-id>LargeVirtualImageBytes</class-id> <category>accessing</category><body package="ImageWriter">at: anIndex	^self byteAt: anIndex</body><body package="ImageWriter">byteAt: anIndex 	"Answer the byte at the given index.  If the page is missing,	 answer what an uninitialized page would have answered."	| c |	c := self basicAt: (anIndex - 1 bitShift: -8) + 1.	c == nil ifTrue: [^self defaultElement].	^c byteAt: (anIndex - 1 bitAnd: 255) + 1</body><body package="ImageWriter">byteAt: anIndex put: aByte 	"Store a byte at the given index.  We copy the segment each time in	 case someone has asked for sharing. This makes for low space, but	 works only if stores are quite infrequent."	| c i1 |	i1 := (anIndex - 1 bitShift: -8) + 1.	c := self basicAt: i1.	c == nil		ifTrue: [c := self basicAt: i1 put: (self species new: 256)]		ifFalse: [compressed ifTrue: [c := self basicAt: i1 put: c copy]].	c byteAt: (anIndex - 1 bitAnd: 255) + 1 put: aByte.	^aByte</body><body package="ImageWriter">defaultElement	^0</body><body package="ImageWriter">doubleAt: byteIndex	"Answer a double-precision (64 bit) floating point quantity 	starting at the given byteIndex."		| startPage endPage page |	startPage := (byteIndex - 1 bitShift: -8) + 1.	endPage := (byteIndex + 7 bitShift: -8) + 1.	startPage ~= endPage		ifTrue:			[^self				doubleAt: byteIndex				bigEndian: self platformIsBigEndian].	page := self basicAt: startPage.	page == nil ifTrue: [^0.0d].	^page doubleAt: (byteIndex - 1 bitAnd: 255) + 1</body><body package="ImageWriter">doubleAt: byteIndex put: aDouble	"Store a double-precision (64 bit) floating point quantity	starting at the given byteIndex."		| startPage endPage page |	startPage := (byteIndex - 1 bitShift: -8) + 1.	endPage := (byteIndex + 7 bitShift: -8) + 1.	startPage ~= endPage		ifTrue:			[^self				doubleAt: byteIndex				put: aDouble				bigEndian: self platformIsBigEndian].	page := self basicAt: startPage.	page == nil		ifTrue:			[page := self				basicAt: startPage				put: (self species new: 256)]		ifFalse:			[compressed				ifTrue:					[page := self						basicAt: startPage						put: page copy]].	^page		doubleAt: (byteIndex - 1 bitAnd: 255) + 1		put: aDouble</body><body package="ImageWriter">floatAt: byteIndex	"Answer a single-precision (32 bit) floating point quantity	starting at the given byteIndex."		| startPage endPage page |	startPage := (byteIndex - 1 bitShift: -8) + 1.	endPage := (byteIndex + 3 bitShift: -8) + 1.	startPage ~= endPage		ifTrue:			[^self				floatAt: byteIndex				bigEndian: self platformIsBigEndian].	page := self basicAt: startPage.	page == nil ifTrue: [^0.0].	^page floatAt: (byteIndex - 1 bitAnd: 255) + 1</body><body package="ImageWriter">floatAt: byteIndex put: aFloat	"Store a single-precision (32 bit) 	floating point quantity 	starting at the given byteIndex."		| startPage endPage page |	startPage := (byteIndex - 1 bitShift: -8) + 1.	endPage := (byteIndex + 3 bitShift: -8) + 1.	startPage ~= endPage		ifTrue:			[^self				floatAt: byteIndex				put: aFloat				bigEndian: self platformIsBigEndian].	page := self basicAt: startPage.	page == nil		ifTrue:			[page := self				basicAt: startPage				put: (self species new: 256)]		ifFalse:			[compressed				ifTrue:					[page := self						basicAt: startPage						put: page copy]].	^page		floatAt: (byteIndex - 1 bitAnd: 255) + 1		put: aFloat</body><body package="ImageWriter">longAt: byteIndex	"Answer a signed long (32 bit) quantity	starting at the given byteIndex."		| startPage endPage page |	startPage := (byteIndex - 1 bitShift: -8) + 1.	endPage := (byteIndex + 3 bitShift: -8) + 1.	startPage ~= endPage		ifTrue:			[^self				longAt: byteIndex				bigEndian: self platformIsBigEndian].	page := self basicAt: startPage.	page == nil ifTrue: [^0].	^page longAt: (byteIndex - 1 bitAnd: 255) + 1</body><body package="ImageWriter">longAt: byteIndex put: aLong	"Store a signed long (32 bit) quantity	starting at the given byteIndex."		| startPage endPage page |	startPage := (byteIndex - 1 bitShift: -8) + 1.	endPage := (byteIndex + 3 bitShift: -8) + 1.	startPage ~= endPage		ifTrue:			[^self				longAt: byteIndex				put: aLong				bigEndian: self platformIsBigEndian].	page := self basicAt: startPage.	page == nil		ifTrue:			[page := self				basicAt: startPage				put: (self species new: 256)]		ifFalse:			[compressed				ifTrue:					[page := self						basicAt: startPage						put: page copy]].	^page		longAt: (byteIndex - 1 bitAnd: 255) + 1		put: aLong</body><body package="ImageWriter">longLongAt: byteIndex	"Answer a signed long long (64 bit) quantity starting at the given byteIndex."		| startPage endPage page |	startPage := (byteIndex - 1 bitShift: -8) + 1.	endPage := (byteIndex + 7 bitShift: -8) + 1.	startPage ~= endPage		ifTrue:			[^self				longLongAt: byteIndex				bigEndian: self platformIsBigEndian].	page := self basicAt: startPage.	page == nil ifTrue: [^0].	^page longLongAt: (byteIndex - 1 bitAnd: 255) + 1</body><body package="ImageWriter">longLongAt: byteIndex put: aLongLong	"Store a signed long long (64 bit) quantity starting at the given byteIndex."		| startPage endPage page |	startPage := (byteIndex - 1 bitShift: -8) + 1.	endPage := (byteIndex + 7 bitShift: -8) + 1.	startPage ~= endPage		ifTrue:			[^self				longLongAt: byteIndex				put: aLongLong				bigEndian: self platformIsBigEndian].	page := self basicAt: startPage.	page == nil		ifTrue:			[page := self				basicAt: startPage				put: (self species new: 256)]		ifFalse:			[compressed				ifTrue:					[page := self						basicAt: startPage						put: page copy]].	^page		longLongAt: (byteIndex - 1 bitAnd: 255) + 1		put: aLongLong</body><body package="ImageWriter">pageAt: index put: collection	"This is protocol supported for knowledgeable clients	who want to populate the collection one page at a	time, as they attempt to refer to a missing page."	collection class = self species		ifFalse: [self error: (#errPageType &lt;&lt; #dialogs &gt;&gt; 'Incorrect page type')].	collection sizeInBytes = 256		ifFalse: [self error: (#errPageSize &lt;&lt; #dialogs &gt;&gt; 'Incorrect page size')].	self basicAt: index put: collection.</body><body package="ImageWriter">replaceFrom: start to: stop with: replacement startingAt: repStart	"This destructively replaces elements from start to stop in the	receiver starting at index, repStart, in the collection, replacement.	Answer the receiver. No range checks are performed, but	overlapping replacements are handled correctly."	^replacement		startingAt: repStart		replaceElementsIn: self		from: start		to: stop</body><body package="ImageWriter">shortAt: byteIndex	"Answer a signed short (16 bit) quantity	starting at the given byteIndex."		| startPage endPage page |	startPage := (byteIndex - 1 bitShift: -8) + 1.	endPage := (byteIndex + 1 bitShift: -8) + 1.	startPage ~= endPage		ifTrue:			[^self				shortAt: byteIndex				bigEndian: self platformIsBigEndian].	page := self basicAt: startPage.	page == nil ifTrue: [^0].	^page shortAt: (byteIndex - 1 bitAnd: 255) + 1</body><body package="ImageWriter">shortAt: byteIndex put: aShort	"Store a signed short (16 bit) quantity	starting at the given byteIndex."		| startPage endPage page |	startPage := (byteIndex - 1 bitShift: -8) + 1.	endPage := (byteIndex + 1 bitShift: -8) + 1.	startPage ~= endPage		ifTrue:			[^self				shortAt: byteIndex				put: aShort				bigEndian: self platformIsBigEndian].	page := self basicAt: startPage.	page == nil		ifTrue:			[page := self				basicAt: startPage				put: (self species new: 256)]		ifFalse:			[compressed				ifTrue:					[page := self						basicAt: startPage						put: page copy]].	^page		shortAt: (byteIndex - 1 bitAnd: 255) + 1		put: aShort</body><body package="ImageWriter">signedByteAt: index 	"Answer a signed byte at the given index."	^((self byteAt: index) bitXor: 128) - 128</body><body package="ImageWriter">signedByteAt: index put: signedByte	"Store a signed byte at the given index."	self byteAt: index put: (signedByte + 128 bitXor: 128).	^signedByte</body><body package="ImageWriter">sizeInBytes	"Answer how many bytes the receiver contains."	^self size</body><body package="ImageWriter">species	^VirtualImageBytes</body><body package="ImageWriter">unsignedLongAt: byteIndex	"Answer an unsigned long (32 bit) quantity	starting at the given byteIndex."		| startPage endPage page |	startPage := (byteIndex - 1 bitShift: -8) + 1.	endPage := (byteIndex + 3 bitShift: -8) + 1.	startPage ~= endPage		ifTrue:			[^self				unsignedLongAt: byteIndex				bigEndian: self platformIsBigEndian].	page := self basicAt: startPage.	page == nil ifTrue: [^0].	^page unsignedLongAt: (byteIndex - 1 bitAnd: 255) + 1</body><body package="ImageWriter">unsignedLongAt: byteIndex put: anUnsignedLong	"Store an unsigned long (32 bit) quantity	starting at the given byteIndex."		| startPage endPage page |	startPage := (byteIndex - 1 bitShift: -8) + 1.	endPage := (byteIndex + 3 bitShift: -8) + 1.	startPage ~= endPage		ifTrue:			[^self				unsignedLongAt: byteIndex				put: anUnsignedLong				bigEndian: self platformIsBigEndian].	page := self basicAt: startPage.	page == nil		ifTrue:			[page := self				basicAt: startPage				put: (self species new: 256)]		ifFalse:			[compressed				ifTrue:					[page := self						basicAt: startPage						put: page copy]].	^page		unsignedLongAt: (byteIndex - 1 bitAnd: 255) + 1		put: anUnsignedLong</body><body package="ImageWriter">unsignedLongLongAt: byteIndex	"Answer an unsigned long long (64 bit) quantity starting at the given byteIndex."		| startPage endPage page |	startPage := (byteIndex - 1 bitShift: -8) + 1.	endPage := (byteIndex + 7 bitShift: -8) + 1.	startPage ~= endPage		ifTrue:			[^self				unsignedLongLongAt: byteIndex				bigEndian: self platformIsBigEndian].	page := self basicAt: startPage.	page == nil ifTrue: [^0].	^page unsignedLongLongAt: (byteIndex - 1 bitAnd: 255) + 1</body><body package="ImageWriter">unsignedLongLongAt: byteIndex put: anUnsignedLongLong	"Store an unsigned long long (64 bit) quantity starting at the given byteIndex."		| startPage endPage page |	startPage := (byteIndex - 1 bitShift: -8) + 1.	endPage := (byteIndex + 7 bitShift: -8) + 1.	startPage ~= endPage		ifTrue:			[^self				unsignedLongLongAt: byteIndex				put: anUnsignedLongLong				bigEndian: self platformIsBigEndian].	page := self basicAt: startPage.	page == nil		ifTrue:			[page := self				basicAt: startPage				put: (self species new: 256)]		ifFalse:			[compressed				ifTrue:					[page := self						basicAt: startPage						put: page copy]].	^page		unsignedLongLongAt: (byteIndex - 1 bitAnd: 255) + 1		put: anUnsignedLongLong</body><body package="ImageWriter">unsignedShortAt: byteIndex	"Answer an unsigned short (16 bit) quantity	starting at the given byteIndex."		| startPage endPage page |	startPage := (byteIndex - 1 bitShift: -8) + 1.	endPage := (byteIndex + 1 bitShift: -8) + 1.	startPage ~= endPage		ifTrue:			[^self				unsignedShortAt: byteIndex				bigEndian: self platformIsBigEndian].	page := self basicAt: startPage.	page == nil ifTrue: [^0].	^page unsignedShortAt: (byteIndex - 1 bitAnd: 255) + 1</body><body package="ImageWriter">unsignedShortAt: byteIndex put: anUnsignedShort	"Store an unsigned short (16 bit) quantity	starting at the given byteIndex."		| startPage endPage page |	startPage := (byteIndex - 1 bitShift: -8) + 1.	endPage := (byteIndex + 1 bitShift: -8) + 1.	startPage ~= endPage		ifTrue:			[^self				unsignedShortAt: byteIndex				put: anUnsignedShort				bigEndian: self platformIsBigEndian].	page := self basicAt: startPage.	page == nil		ifTrue:			[page := self				basicAt: startPage				put: (self species new: 256)]		ifFalse:			[compressed				ifTrue:					[page := self						basicAt: startPage						put: page copy]].	^page		unsignedShortAt: (byteIndex - 1 bitAnd: 255) + 1		put: anUnsignedShort</body></methods><methods><class-id>LargeVirtualImageBytes</class-id> <category>accessing-platform independent</category><body package="ImageWriter">doubleAt: byteIndex bigEndian: isBigEndian	"Answer a double-precision (64 bit) floating point quantity 	starting at the given byteIndex."		| bytes |	bytes := UninterpretedBytes new: 8.	bytes replaceBytesFrom: 1 to: 8 with: self startingAt: byteIndex.	isBigEndian = self platformIsBigEndian ifFalse: [bytes swapDoubleAt: 1].	bytes changeClassTo: Double.	^bytes + 0.0d	"Add 0 in case the double should be a SmallDouble"</body><body package="ImageWriter">doubleAt: byteIndex put: aDouble bigEndian: isBigEndian	"Store a double-precision (64 bit) floating point quantity	starting at the given byteIndex."		| bytes |	bytes := aDouble asDouble.	bytes class == SmallDouble ifTrue: [bytes := bytes asDegenerateDouble].	bytes := bytes shallowCopy.	bytes changeClassTo: UninterpretedBytes.	isBigEndian = self platformIsBigEndian ifFalse: [bytes swapDoubleAt: 1].	self		replaceBytesFrom: byteIndex		to: byteIndex + 7		with: bytes		startingAt: 1.	^aDouble</body><body package="ImageWriter">floatAt: byteIndex bigEndian: isBigEndian	"Answer a single-precision (32 bit) floating point quantity 	starting at the given byteIndex."		| bytes |	bytes := UninterpretedBytes new: 4.	bytes replaceBytesFrom: 1 to: 4 with: self startingAt: byteIndex.	isBigEndian = self platformIsBigEndian ifFalse: [bytes swapFloatAt: 1].	bytes changeClassTo: Float.	^bytes</body><body package="ImageWriter">floatAt: byteIndex put: aFloat bigEndian: isBigEndian	"Store a single-precision (32 bit) floating point quantity	starting at the given byteIndex."		| bytes |	bytes := aFloat asFloat shallowCopy.	bytes changeClassTo: UninterpretedBytes.	isBigEndian = self platformIsBigEndian ifFalse: [bytes swapFloatAt: 1].	self		replaceBytesFrom: byteIndex		to: byteIndex + 3		with: bytes		startingAt: 1.	^aFloat</body><body package="ImageWriter">longAt: byteIndex bigEndian: isBE	"Answer a signed long (32 bit) quantity starting at the given byteIndex."	| b0 b1 b2 w h |	isBE		ifTrue:			[b0 := self byteAt: byteIndex.  			b1 := self byteAt: byteIndex+1.  			b2 := self byteAt: byteIndex+2.  			w := self byteAt: byteIndex+3]		ifFalse:			[b0 := self byteAt: byteIndex+3.  			b1 := self byteAt: byteIndex+2.  			b2 := self byteAt: byteIndex+1.  			w := self byteAt: byteIndex].	"Following sequence minimizes LargeInteger arithmetic for small results."	h := ((b0 bitAnd: 16r7F) - (b0 bitAnd: 16r80) bitShift: 8) + b1.	b2=0 ifFalse: [w := (b2 bitShift: 8) + w].	h=0 ifFalse: [w := (h bitShift: 16) + w].	^w</body><body package="ImageWriter">longAt: byteIndex put: aLong bigEndian: isBE	"Store a signed long (32 bit) quantity starting at the given byteIndex."	| b0 b1 b2 b3 |	b0 := aLong bitShift: -24.	  b0 := (b0 bitAnd: 16r7F) - (b0 bitAnd: -16r80).	b1 := (aLong bitShift: -16) bitAnd: 16rFF.	b2 := (aLong bitShift: -8) bitAnd: 16rFF.	b3 := aLong bitAnd: 16rFF.	isBE		ifTrue:			["Only the first store can fail."			self byteAt: byteIndex put: b0.  			self byteAt: byteIndex+1 put: b1.			self byteAt: byteIndex+2 put: b2.  			self byteAt: byteIndex+3 put: b3]		ifFalse:			["Only the first store can fail."			self byteAt: byteIndex+3 put: b0.  			self byteAt: byteIndex+2 put: b1.			self byteAt: byteIndex+1 put: b2.  			self byteAt: byteIndex put: b3].	^aLong</body><body package="ImageWriter">longLongAt: byteIndex bigEndian: isBE	"Answer a signed long long (64 bit) quantity starting at the given byteIndex."	| b0 b1 b2 b3 b4 b5 b6 w h |	isBE		ifTrue:			[b0 := self byteAt: byteIndex.			b1 := self byteAt: byteIndex+1.			b2 := self byteAt: byteIndex+2.			b3 := self byteAt: byteIndex+3.			b4 := self byteAt: byteIndex+4.			b5 := self byteAt: byteIndex+5.			b6 := self byteAt: byteIndex+6.			w := self byteAt: byteIndex+7]		ifFalse:			[b0 := self byteAt: byteIndex+7.			b1 := self byteAt: byteIndex+6.			b2 := self byteAt: byteIndex+5.			b3 := self byteAt: byteIndex+4.			b4 := self byteAt: byteIndex+3.			b5 := self byteAt: byteIndex+2.			b6 := self byteAt: byteIndex+1.			w := self byteAt: byteIndex].	"Following sequence minimizes LargeInteger arithmetic for small results."	h := ((b0 bitAnd: 16r7F) - (b0 bitAnd: 16r80) bitShift: 8) + b1.	b6=0 ifFalse: [w := (b6 bitShift:   8) + w].	b5=0 ifFalse: [w := (b5 bitShift: 16) + w].	b4=0 ifFalse: [w := (b4 bitShift: 24) + w].	b3=0 ifFalse: [w := (b3 bitShift: 32) + w].	b2=0 ifFalse: [w := (b2 bitShift: 40) + w].	h=0 ifFalse: [w := (h bitShift: 48) + w].	^w</body><body package="ImageWriter">longLongAt: byteIndex put: aLongLong bigEndian: isBE	"Store an unsigned long long (64 bit) quantity starting at the given byteIndex."	| b0 b1 b2 b3 b4 b5 b6 b7 |	b0 := (aLongLong bitShift: -56).	  b0 := (b0 bitAnd: 16r7F) - (b0 bitAnd: -16r80).	b1 := (aLongLong bitShift: -48) bitAnd: 16rFF.	b2 := (aLongLong bitShift: -40) bitAnd: 16rFF.	b3 := (aLongLong bitShift: -32) bitAnd: 16rFF.	b4 := (aLongLong bitShift: -24) bitAnd: 16rFF.	b5 := (aLongLong bitShift: -16) bitAnd: 16rFF.	b6 := (aLongLong bitShift:   -8) bitAnd: 16rFF.	b7 := (aLongLong bitAnd: 16rFF).	isBE		ifTrue:			["Only the first store can fail."			self byteAt: byteIndex put: b0.			self byteAt: byteIndex+1 put: b1.			self byteAt: byteIndex+2 put: b2.			self byteAt: byteIndex+3 put: b3.			self byteAt: byteIndex+4 put: b4.			self byteAt: byteIndex+5 put: b5.			self byteAt: byteIndex+6 put: b6.			self byteAt: byteIndex+7 put: b7]		ifFalse:			["Only the first store can fail."			self byteAt: byteIndex+7 put: b0.			self byteAt: byteIndex+6 put: b1.			self byteAt: byteIndex+5 put: b2.			self byteAt: byteIndex+4 put: b3.			self byteAt: byteIndex+3 put: b4.			self byteAt: byteIndex+2 put: b5.			self byteAt: byteIndex+1 put: b6.			self byteAt: byteIndex     put: b7].	^aLongLong</body><body package="ImageWriter">replaceBytesFrom: start to: stop with: replacement startingAt: repStart 	"This destructively replaces bytes from start to stop in the 	receiver starting at index, repStart, from the byte-object, 	replacement. Answer the receiver."	| repOff |	(replacement sizeInBytes = 256 and: [repStart = 1 and: [(start bitAnd: 255) = 1 and: [stop-start = 255]]])		ifTrue: [^self pageAt: start//256+1 put: (replacement copy changeClassTo: self species)].	repOff := repStart - start.	(self == replacement and: [repStart &lt; start])		ifTrue:	["Replacement would be overwritten; use reverse order"				stop to: start by: -1 do:					[ :i |	self byteAt: i put: (replacement byteAt: repOff + i)]]		ifFalse:	[start to: stop do:					[ :i |	self byteAt: i put: (replacement byteAt: repOff + i)]]</body><body package="ImageWriter">shortAt: byteIndex bigEndian: isBE	| word |	word := self unsignedShortAt: byteIndex bigEndian: isBE.	^(word bitAnd: 16r7FFF) - (word bitAnd: 16r8000)</body><body package="ImageWriter">shortAt: byteIndex put: aShort bigEndian: isBE	"Store a signed short (16 bit) quantity starting at the given byteIndex."	self unsignedShortAt: byteIndex put:		(aShort bitAnd: 16r7FFF) - (aShort bitAnd: -16r8000) bigEndian: isBE.	^aShort</body><body package="ImageWriter">unsignedLongAt: byteIndex bigEndian: isBE	"Answer an unsigned long (32 bit) quantity starting at the given byteIndex."	| b0 b1 b2 w |	isBE		ifTrue:			[b0 := self byteAt: byteIndex.  			b1 := self byteAt: byteIndex+1.  			b2 := self byteAt: byteIndex+2.  			w := self byteAt: byteIndex+3]		ifFalse:			[b0 := self byteAt: byteIndex+3.  			b1 := self byteAt: byteIndex+2.  			b2 := self byteAt: byteIndex+1.  			w := self byteAt: byteIndex].	"Following sequence minimizes LargeInteger arithmetic for small results."	b2=0 ifFalse: [w := (b2 bitShift: 8) + w].	b1=0 ifFalse: [w := (b1 bitShift: 16) + w].	b0=0 ifFalse: [w := (b0 bitShift: 24) + w].	^w</body><body package="ImageWriter">unsignedLongAt: byteIndex put: anUnsignedLong bigEndian: isBE	"Store an unsigned long (32 bit) quantity starting at the given byteIndex."	| b0 b1 b2 b3 |	b0 := anUnsignedLong bitShift: -24.	b1 := (anUnsignedLong bitShift: -16) bitAnd: 16rFF.	b2 := (anUnsignedLong bitShift: -8) bitAnd: 16rFF.	b3 := anUnsignedLong bitAnd: 16rFF.	isBE		ifTrue:			["Only the first store can fail."			self byteAt: byteIndex put: b0.  			self byteAt: byteIndex+1 put: b1.			self byteAt: byteIndex+2 put: b2.  			self byteAt: byteIndex+3 put: b3]		ifFalse:			["Only the first store can fail."			self byteAt: byteIndex+3 put: b0.  			self byteAt: byteIndex+2 put: b1.			self byteAt: byteIndex+1 put: b2.  			self byteAt: byteIndex put: b3].	^anUnsignedLong</body><body package="ImageWriter">unsignedLongLongAt: byteIndex bigEndian: isBE	"Answer an unsigned long long (64 bit) quantity starting at the given byteIndex."	| b0 b1 b2 b3 b4 b5 b6 w |	isBE		ifTrue:			[b0 := self byteAt: byteIndex.			b1 := self byteAt: byteIndex+1.			b2 := self byteAt: byteIndex+2.			b3 := self byteAt: byteIndex+3.			b4 := self byteAt: byteIndex+4.			b5 := self byteAt: byteIndex+5.			b6 := self byteAt: byteIndex+6.			w := self byteAt: byteIndex+7]		ifFalse:			[b0 := self byteAt: byteIndex+7.			b1 := self byteAt: byteIndex+6.			b2 := self byteAt: byteIndex+5.			b3 := self byteAt: byteIndex+4.			b4 := self byteAt: byteIndex+3.			b5 := self byteAt: byteIndex+2.			b6 := self byteAt: byteIndex+1.			w := self byteAt: byteIndex].	"Following sequence minimizes LargeInteger arithmetic for small results."	b6=0 ifFalse: [w := (b6 bitShift: 8) + w].	b5=0 ifFalse: [w := (b5 bitShift: 16) + w].	b4=0 ifFalse: [w := (b4 bitShift: 24) + w].	b3=0 ifFalse: [w := (b3 bitShift: 32) + w].	b2=0 ifFalse: [w := (b2 bitShift: 40) + w].	b1=0 ifFalse: [w := (b1 bitShift: 48) + w].	b0=0 ifFalse: [w := (b0 bitShift: 56) + w].	^w</body><body package="ImageWriter">unsignedLongLongAt: byteIndex put: anUnsignedLongLong bigEndian: isBE	"Store an unsigned long long (64 bit) quantity starting at the given byteIndex."	| b0 b1 b2 b3 b4 b5 b6 b7 |	b0 := (anUnsignedLongLong bitShift: -56).	b1 := (anUnsignedLongLong bitShift: -48) bitAnd: 16rFF.	b2 := (anUnsignedLongLong bitShift: -40) bitAnd: 16rFF.	b3 := (anUnsignedLongLong bitShift: -32) bitAnd: 16rFF.	b4 := (anUnsignedLongLong bitShift: -24) bitAnd: 16rFF.	b5 := (anUnsignedLongLong bitShift: -16) bitAnd: 16rFF.	b6 := (anUnsignedLongLong bitShift:   -8) bitAnd: 16rFF.	b7 := (anUnsignedLongLong bitAnd: 16rFF).	isBE		ifTrue:			["Only the first store can fail."			self byteAt: byteIndex put: b0.			self byteAt: byteIndex+1 put: b1.			self byteAt: byteIndex+2 put: b2.			self byteAt: byteIndex+3 put: b3.			self byteAt: byteIndex+4 put: b4.			self byteAt: byteIndex+5 put: b5.			self byteAt: byteIndex+6 put: b6.			self byteAt: byteIndex+7 put: b7]		ifFalse:			["Only the first store can fail."			self byteAt: byteIndex+7 put: b0.			self byteAt: byteIndex+6 put: b1.			self byteAt: byteIndex+5 put: b2.			self byteAt: byteIndex+4 put: b3.			self byteAt: byteIndex+3 put: b4.			self byteAt: byteIndex+2 put: b5.			self byteAt: byteIndex+1 put: b6.			self byteAt: byteIndex     put: b7].	^anUnsignedLongLong</body><body package="ImageWriter">unsignedShortAt: byteIndex bigEndian: isBE	"Answer an unsigned short (16 bit) quantity starting at the given byteIndex."	^isBE		ifTrue: [((self byteAt: byteIndex) bitShift: 8) + (self byteAt: byteIndex + 1)]		ifFalse: [((self byteAt: byteIndex + 1) bitShift: 8) + (self byteAt: byteIndex)]</body><body package="ImageWriter">unsignedShortAt: byteIndex put: anUnsignedShort bigEndian: isBE	"Store an unsigned short (16 bit) quantity starting at the given byteIndex."	isBE		ifTrue:			["Just shifting, without masking, will cause byteAt:put:			to fail if anUnsignedShort doesn't fit in 16 bits."			self byteAt: byteIndex put: (anUnsignedShort bitShift: -8).			self byteAt: byteIndex + 1 put: (anUnsignedShort bitAnd: 16rFF)]		ifFalse:			[self byteAt: byteIndex + 1 put: (anUnsignedShort bitShift: -8).			self byteAt: byteIndex put: (anUnsignedShort bitAnd: 16rFF)].	^anUnsignedShort</body></methods><methods><class-id>LargeVirtualImageBytes</class-id> <category>private</category><body package="ImageWriter">replaceElementsFrom: start to: stop withByteArray: replacement startingAt: repStart 	(replacement size = 256 and: [repStart = 1 and: [(start bitAnd: 255) = 1 and: [stop-start = 255]]])		ifTrue: [^self pageAt: start//256+1 put: (replacement copy changeClassTo: self species)].	^self replaceElementsFrom: start		to: stop		withSequenceableCollection: replacement		startingAt: repStart</body><body package="ImageWriter">replaceElementsFrom: start to: stop withLargeByteArray: replacement startingAt: repStart 	^self replaceElementsFrom: start		to: stop		withSequenceableCollection: replacement		startingAt: repStart</body><body package="ImageWriter">startingAt: repStart replaceElementsIn: collection from: start to: stop	"This destructively replaces elements from start to stop in the 	collection starting at index, repStart, in the receiver. 	Answer the collection."	| p1 p2 s1 page |	start &gt; stop ifTrue: [^collection].	(repStart-1 bitAnd: -256) = (repStart-1+stop-start bitAnd: -256)		ifTrue:			[(self basicAt: (repStart-1 bitShift: -8)+1)				startingAt: (repStart-1 bitAnd: 255)+1				replaceBytesIn: collection				from: start				to: stop]		ifFalse:			[p1 :=  (repStart-1 bitShift: -8)+1.			p2 := (repStart+stop-start-1 bitShift: -8)+1.			s1 := start.			(self basicAt: p1)				startingAt: (repStart-1 bitAnd: 255)+1				replaceBytesIn: collection				from: start				to: start+255-(repStart-1 bitAnd: 255).			s1 := s1+256-(repStart-1 bitAnd: 255).			p1+1 to: p2-1 do: [:p |				(page := self basicAt: p) == nil ifTrue:					[page := self basicAt: p put: (self species new: 256)].				page					startingAt: 1					replaceBytesIn: collection					from: s1					to: s1+255.				s1 := s1 + 256].			(page := self basicAt: p2) == nil ifTrue:				[page := self basicAt: p2 put: (self species new: 256)].			page				startingAt: (repStart+s1-start-1 bitAnd: 255)+1				replaceBytesIn: collection				from: s1				to: stop].	^collection</body></methods><methods><class-id>LargeVirtualImageBytes</class-id> <category>copying</category><body package="ImageWriter">copyFrom: start to: stop 	"Answer a copy of a subset of the receiver, starting from element at index start 	until element at index stop."	| newSize |	newSize := stop - start + 1.	^(self species new: newSize)		replaceBytesFrom: 1		to: newSize		with: self		startingAt: start</body></methods><methods><class-id>LargeVirtualImageBytes</class-id> <category>testing</category><body package="ImageWriter">platformIsBigEndian	^UninterpretedBytes isBigEndian</body></methods><methods><class-id>VirtualImageSegment</class-id> <category>accessing</category><body package="ImageWriter">allObjects	^(1 to: allocIndex - 1 by: 2) collect: [:i| allocs at: i]</body><body package="ImageWriter">baseAddress	^baseAddress</body><body package="ImageWriter">baseAddress: addr	baseAddress := addr</body><body package="ImageWriter">data	^data</body><body package="ImageWriter">data: bytes	data := bytes</body><body package="ImageWriter">segmentType	^type</body><body package="ImageWriter">segmentType: t	type := t</body><body package="ImageWriter">size	^size</body><body package="ImageWriter">size: n	size := n</body></methods><methods><class-id>VirtualImageSegment</class-id> <category>testing</category><body package="ImageWriter">contains: addr	^baseAddress &lt;= addr and: [baseAddress + size &gt; addr]</body></methods><methods><class-id>VirtualImageSegment</class-id> <category>allocating</category><body package="ImageWriter">growBy: sizeDelta	size := size+sizeDelta.	size &gt; data size ifTrue: [data grow].</body></methods><methods><class-id>VirtualImageSegment</class-id> <category>printing</category><body package="ImageWriter">printOn: aStream	super printOn: aStream.	aStream nextPutAll: '(', type, ', ', (size storeStringRadix: 16), ')'</body></methods><methods><class-id>VirtualImageSegment</class-id> <category>debugging</category><body package="ImageWriter">noteObject: aThing	allocs == nil		ifTrue:			[allocs := LargeArray new: 1000000.			 allocIndex := 1]		ifFalse:			[allocIndex + 1 &gt;= allocs size ifTrue:				[allocs := allocs copyWithSize: allocs size * 2]].	allocs at: allocIndex put: aThing.	allocs at: allocIndex + 1 put: size.	allocIndex := allocIndex + 2</body></methods><methods><class-id>Core.ArithmeticValue</class-id> <category>testing</category><body package="ImageWriter">_iw_isDouble	^false</body></methods><methods><class-id>Core.SmallDouble</class-id> <category>testing</category><body package="ImageWriter">_iw_isDouble	^true</body></methods><methods><class-id>Core.Double</class-id> <category>testing</category><body package="ImageWriter">_iw_isDouble	^true</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>actions</category><body package="ImageWriter">basicSave64BitImage	| thirtyTwoBitImageFilename sixtyFourBitImageFilename fullSixtyFourBitImageFilename |	thirtyTwoBitImageFilename := ObjectMemory imageFilename head asFilename construct:		(ObjectMemory imageFilename tail			copyFrom: 1			to: ObjectMemory imageFilename tail size - ObjectMemory imageFilename extension size).	sixtyFourBitImageFilename := ObjectMemory imageFilename head asFilename construct:		(ObjectMemory imageFilename tail			copyFrom: 1			to: ObjectMemory imageFilename tail size - ObjectMemory imageFilename extension size), '-64'.	fullSixtyFourBitImageFilename := sixtyFourBitImageFilename head asFilename construct:		sixtyFourBitImageFilename tail, '.im'.	(fullSixtyFourBitImageFilename exists and: [(Dialog confirm: 'Overwrite existing 64 bit image?') not]) ifTrue: [^self].	VirtualImage		cloneFrom: thirtyTwoBitImageFilename asString		to: sixtyFourBitImageFilename asString		target: VirtualImage default64BitImageType</body><body package="ImageWriter">save64BitImage	&lt;menuItem: 'Save Image then Convert to 64 Bits'		nameKey: nil		menu: #(#menuBar #file)		position: 10.6&gt;	SmallInteger maxVal &gt; 536870911 ifTrue:		[			Dialog warn: 'This is a 64 bit image already'.			^self		].	ObjectMemory globalGarbageCollect.	self imageSave.	SmallInteger maxVal &gt; 536870911 ifTrue: [^self].	Cursor wait showWhile: [self basicSave64BitImage]</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>ArithmeticValue</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Double</name><environment>Core</environment><super>Core.LimitedPrecisionReal</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>SegmentedCollection</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>compressed </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>HandleRegistry</name><environment>OS</environment><super>Core.WeakDictionary</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Support</category><attributes><package>OS-Support</package></attributes></class><class><name>UninterpretedBytes</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>VisualLauncher</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuBar toolBar textCollector transcriptView statusBar </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>Tools-Misc</package></attributes></class><class><name>SmallDouble</name><environment>Core</environment><super>Core.LimitedPrecisionReal</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class></st-source>