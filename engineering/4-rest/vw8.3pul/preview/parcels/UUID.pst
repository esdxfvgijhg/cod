<?xml version="1.0"?><st-source><!-- Name: UUIDNotice: Copyright 1999-2014 Cincom Systems, Inc.  All rights reserved.Comment: This package provides the ability to generate UUIDs in various formats, including dce, version1, version4. It does not currently support microsoft, NCS, version2, version3 or version5 UUIDs. There are hooks to be able to call out to operating system level UUID generators, but these are not yet implemented. This implementation is based on the Leach, Mealing, and Salz draft (LMS), which expires on 01 June 2005.  (The UUID drafts have never reached approval, and the specification, such as it is, has lived on as a succession of drafts.)  It is also based on the OpenGroup 1.1 RPC specification for the backward-compatible DCE UUID.There is a single distinguished UUID generator per image, which can be accessed as UUIDGenerator default. However, the typical API is to send the UUID class a generation message, e.g. "UUID version1", or "UUID dce".You can also ask either a UUID or the UUIDGenerator for the #next UUID, treating it as a stream. This will give a value in the default implementation. The default default is #version4.DbIdentifier: bear73DbTrace: 432258DbUsername: tkoganDbVersion: 8.0 - 2DevelopmentPrerequisites: #(#(#package 'SecurityBase' ''))PackageName: UUIDParcel: #('UUID')ParcelName: UUIDPrerequisiteParcels: #(#('SecurityBase' ''))PrintStringCache: (8.0 - 2,tkogan)Version: 8.0 - 2Date: 12:44:05 PM May 16, 2014 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.0 (may14.3) of May 16, 2014 on May 16, 2014 at 12:44:05 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>UUID</name><environment>Smalltalk</environment><super>Core.ByteArray</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UUID</category><attributes><package>UUID</package></attributes></class><comment><class-id>UUID</class-id><body>A UUID represents any one of several UUID types.  This implementation is based on the Leach, Mealing, and Salz draft (LMS), which expires on 01 June 2005.  (The UUID drafts have never reached approval, and the specification, such as it is, has lived on as a succession of drafts.)  It is also based on the OpenGroup 1.1 RPC specification for the backward-compatible DCE UUID.</body></comment><class><name>UUIDGenerator</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>random clockSeq cycleTestValue lastTick lastClockSeq </inst-vars><class-inst-vars>default defaultType defaultLMSType defaultMACAddress defaultUseHostAddress lastImageFilename lastHostAddress lastPlatformId lastMACAddress </class-inst-vars><imports></imports><category>UUID</category><attributes><package>UUID</package></attributes></class><comment><class-id>UUIDGenerator</class-id><body>A UUIDGenerator generates instances of UUID.  This implementation is based on the Leach, Mealing, and Salz draft (LMS), which expires on 01 June 2005.  (The UUID drafts have never reached approval, and the specification, such as it is, has lived on as a succession of drafts.)  It is also based on the OpenGroup 1.1 RPC specification for the backward-compatible DCE UUID.Instance Variables:	random	&lt;Random&gt; random generator	clockSeq	&lt;SmallInteger&gt; 	cycleTestValue	&lt;Number&gt; used to detect potential cycles in the random generator	lastTick	&lt;Integer&gt;	lastClockSeq	&lt;SmallInteger&gt;Class Instance Variables:	default	&lt;UUIDGenerator&gt; default generator	defaultType	&lt;Symbol&gt; generation selector to use for the default UUID type #(dce, version4, ...)	defaultLMSType	&lt;Symbol&gt; default LMS generation selector #(version1, version2, ...)	defaultMACAddress	&lt;ByteArray&gt; 	defaultUseHostAddress	&lt;Boolean&gt; 	lastImageFilename	&lt;String&gt; 	lastHostAddress	&lt;ByteArray&gt; 	lastPlatformId	&lt;String&gt; 	lastMACAddress	&lt;ByteArray&gt; </body></comment><class><name>UUIDSystem</name><environment>Smalltalk</environment><super>Core.Subsystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UUID</category><attributes><package>UUID</package></attributes></class><comment><class-id>UUIDSystem</class-id><body>The UUIDSystem governs the resetting of locale parameters critical to the generation of some UUID types.  This implementation is based on the Leach, Mealing, and Salz draft, which expires on 01 June 2005.  (The UUID drafts have never reached approval, and the specification, such as it is, has lived on as a succession of drafts.)  It is also based on the OpenGroup 1.1 RPC specification for the backward-compatible DCE UUID.</body></comment><methods><class-id>UUID</class-id> <category>comparing</category><body package="UUID">&lt; aMagnitude	"Answer whether the receiver is less than the argument.  Add an initial size check, in anticipation of greater than 128-bit Smalltalk-specific UUID type."	| ss ms |	ss := self size.	ms := aMagnitude size.	ss &lt; ms ifTrue: [ ^true ].	ss &gt; ms ifTrue: [ ^false ].	1 to: self size do: [ :i |		(self at: i) == (aMagnitude at: i) ifFalse: [			^(self at: i) &lt; (aMagnitude at: i) ] ].	^false</body><body package="UUID">&lt;= aMagnitude	"Answer whether the receiver is less than or equal to the argument."	^( self &gt; aMagnitude ) not</body><body package="UUID">&gt; aMagnitude	"Answer whether the receiver is greater than the argument."	^aMagnitude &lt; self</body><body package="UUID">&gt;= aMagnitude	"Answer whether the receiver is greater than or equal to the argument."	^( self &lt; aMagnitude ) not</body></methods><methods><class-id>UUID</class-id> <category>converting</category><body package="UUID">asByteArray	"Answer an instance of ByteArray whose elements are the elements of the receiver."	^ByteArray fromString: self</body><body package="UUID">asByteString	"Answer an instance of ByteString whose elements are the elements of the receiver."	^self asByteArray asByteString</body><body package="UUID">asString	"Answer the 'printString' representation"	^self printString</body></methods><methods><class-id>UUID</class-id> <category>accessing - parts</category><body package="UUID">clockSeqHiAndReserved	^( self copyFrom: 9 to: 9 ) asByteArray</body><body package="UUID">clockSeqHiAndReserved: oneByte	self at: 9 put: oneByte</body><body package="UUID">clockSeqLow	^( self copyFrom: 10 to: 10 ) asByteArray</body><body package="UUID">clockSeqLow: oneByte	self at: 10 put: oneByte</body><body package="UUID">node	^( self copyFrom: 11 to: 16 ) asByteArray</body><body package="UUID">node: sixBytes	1 to: 6 do:		[ :n | self at: ( 10 + n ) put: ( sixBytes at: n ) ]</body><body package="UUID">timeHiAndVersion	^( self copyFrom: 7 to: 8 ) asByteArray</body><body package="UUID">timeHiAndVersion: twoBytes 	1 to: 2 do: [:n | self at: 6 + n put: (twoBytes at: n)]</body><body package="UUID">timeLow	^( self copyFrom: 1 to: 4 ) asByteArray</body><body package="UUID">timeLow: fourBytes	1 to: 4 do:		[ :n | self at: ( n ) put: ( fourBytes at: n ) ]</body><body package="UUID">timeMid	^( self copyFrom: 5 to: 6 ) asByteArray</body><body package="UUID">timeMid: twoBytes	1 to: 2 do:		[ :n | self at: ( 4 + n ) put: ( twoBytes at: n ) ]</body></methods><methods><class-id>UUID</class-id> <category>accessing - attributes</category><body package="UUID">hostId	"A 'nil' is answered for those UUID types that do not record locale information overtly.  If the receiver's type does record locale, the ByteArray answered will correspond to a valid host address only if UUIDGenerator's 'defaultUseHostAddress' was appropriately set when the UUID was generated.  And that is the responsibility of the application."	^( self type ~= #'version1/dce' )		ifTrue: 	[ nil ]		ifFalse:	[ self copyFrom: 13 to: 16 ]</body><body package="UUID">type	"Answers a symbol that identifies type of the UUID, given its variant and version, under the strictures of the LMS draft and the OpenGroup 1.1 RPC spec."	| var ver |	var := self variant.	ver := self version.	( var allMask: 2r00000111 )		ifTrue:	[ ^#reserved ].	( var allMask: 2r00000110 )		ifTrue:	[ ^#microsoft ].	( var allMask: 2r00000100 )		ifTrue:	[ ( ver == 1 )					ifTrue:	[ ^#'version1/dce' ]					ifFalse:	[ ^( 'version', ver printString ) asSymbol ]				]		ifFalse:	[ ^#ncs ].	^#unknown</body><body package="UUID">variant	"Answers, in the low order 3 bits, those bits that comprise the UUID variant designation, not all of which are significant.  See the LMS draft for details."	^( self at: 9 ) bitShift: -5</body><body package="UUID">version	"Answers, in the low order 4 bits, those bits that comprise the UUID version designation."	^( self at: 7 ) bitShift: -4</body></methods><methods><class-id>UUID</class-id> <category>testing</category><body package="UUID">isNilUUID	"Answer whether the receiver is equal to the standard nil UUID."	^self = UUID nil</body></methods><methods><class-id>UUID</class-id> <category>printing</category><body package="UUID">printHexOf: aSmallInteger on: aStream	"Print the 2-byte hex representation of aSmallInteger, in lowercase."	"| s |	s := String new writeStream.	self new printHexOf: 11 on: s.	s contents"	| newStream |	newStream := (String new: 2) writeStream.	aSmallInteger printOn: newStream base: 16 digitsToPad: 2 highDigit: 2.	aStream nextPutAll: newStream contents asLowercase.</body><body package="UUID">printOn: aStream 	"Answer a human readable string for the UUID, in standard DCE format, if the UUID is 128 bits."	1 to: 4 do: [:i | self printHexOf: (self at: i) on: aStream].	aStream nextPutAll: '-'.	5 to: 6 do: [:i | self printHexOf: (self at: i) on: aStream].	aStream nextPutAll: '-'.	7 to: 8 do: [:i | self printHexOf: (self at: i) on: aStream].	aStream nextPutAll: '-'.	9 to: 10 do: [:i | self printHexOf: (self at: i) on: aStream].	aStream nextPutAll: '-'.	11 to: 16 do: [:i | self printHexOf: (self at: i) on: aStream].</body></methods><methods><class-id>UUID class</class-id> <category>instance creation</category><body package="UUID">dce	"... answers an OpenGroup 1.1 RPC DCE UUID."	"... one of two recommended replacements for the deprecated 'NCSuuid' in DST."	"... the other is 'version1'."	"... 'dce' is slightly more restrictive than 'version1' for it allows less leeway in the formation of the 'node' field."	^UUIDGenerator default dce</body><body package="UUID">fromString: aString	| uuid readStream decode |	readStream := ReadStream on: aString.	decode := [| c1 c2 |			c1 := readStream next digitValue.			(c1 between: 0 and: 15) ifFalse: [self error: (#invalidUUID &lt;&lt; #net &gt;&gt; 'Invalid UUID')].			c2 := readStream next digitValue.			(c2 between: 0 and: 15) ifFalse: [self error: (#invalidUUID &lt;&lt; #net &gt;&gt; 'Invalid UUID')].			c1 * 16 + c2].	uuid := self nil.	1 to: 4 do: [:i| uuid at: i put: decode value].	readStream next.	5 to: 6 do: [:i| uuid at: i put: decode value].	readStream next.	7 to: 8 do: [:i| uuid at: i put: decode value].	readStream next.	9 to: 10 do:  [:i| uuid at: i put: decode value].	readStream next.	11 to: 16 do:  [:i| uuid at: i put: decode value].	^uuid</body><body package="UUID">microsoft	"... answers a backward-compatible MicroSoft UUID."	"... not supported."	^UUIDGenerator default microsoft</body><body package="UUID">ncs	"... answers a backward-compatible NCS UUID."	"... not supported."	"... the DST 'NCSuuid' is being deprecated."	^UUIDGenerator default ncs</body><body package="UUID">newId	"... dispatches to 'newId:'."	^self newId: nil</body><body package="UUID">newId: anObject	"... attempts to invoke an OS callout -- for example, to 'uuidgen' -- and if that fails, generates a UUID of the default type set in class UUIDGenerator.  The argument is present to accomodate those UUID versions that expect one.  In later stages of processing, the argument is ignored if unneeded, and auto-generated if a non-nil value is both required and not provided."	^UUIDGenerator default primitiveUUIDGen: anObject</body><body package="UUID">newLMSId	"... dispatches to 'newLMSId:'."	^self newLMSId: nil</body><body package="UUID">newLMSId: anObject	"... does not invoke an OS callout -- such as 'uuidgen' -- and directly invokes 'UUISGenerator&gt;&gt;lms:'.  The intent is to provide for the generation of more than one UUID type in the same image without reconfiguration of the UUIDGenerator class, so that one of those types is platform-independent.  The argument is present to accomodate those LMS UUID versions that expect one.  In later stages of processing, the argument is ignored if unneeded, and auto-generated if a non-nil value is both required and not provided."	^UUIDGenerator default lms: anObject</body><body package="UUID">next	"Answer the next UUID using the default generator"	^UUIDGenerator default next.</body><body package="UUID">nil	"... answers an instance of the standard nil UUID."	^self new: 16</body><body package="UUID">version1	"... answers a time-based UUID."	"... one of two recommended replacements for the deprecated 'NCSuuid' in DST."	"... the other is 'dce'."	"... 'version1' is slightly less restrictive than 'dce' for it allows more leeway in the formation of the 'node' field."	^UUIDGenerator default version1</body><body package="UUID">version2	"... answers a DCE UUID with embeded POSIX UIDs."	"... not supported."	^UUIDGenerator default version2</body><body package="UUID">version3From: aStringOrSymbol	"... answers a name-based, MD5 hashed UUID."	"... not supported."	^UUIDGenerator default version3From: aStringOrSymbol</body><body package="UUID">version4	"... answers a pseudo-randomly generated UUID."	^UUIDGenerator default version4</body><body package="UUID">version5From: aStringOrSymbol	"... answers a name-based, SHA-1 hashed UUID."	"... not supported."	^UUIDGenerator default version5From: aStringOrSymbol</body></methods><methods><class-id>UUIDGenerator</class-id> <category>utility - random</category><body package="UUID">generateRandomByte	"Note that we randomly select from the 256 possible bytes, and do not generate a byte bit by bit.  It is about 8 times faster, and, from the standpoint of probability theory, the two methods are equivalent.  We do not keep track of the number of calls to the random generator, in order to trigger a seed refresh on that basis.  Instead, we use MinimumStandardRandom, a generator with a tested, long period (of 2,147,483,647 distinct values), but do test for a recycyling of the pseudo-random number generator's values."	| rnd |	rnd := random next.	( rnd = cycleTestValue  )		ifTrue: [ self resetSeed ].	^( rnd * 256 ) truncated</body><body package="UUID">generateRandomByteArray: anInteger	| bytes |	bytes := ByteArray new: anInteger.	1 to: anInteger do:		[ :ndx | bytes at: ndx put: self generateRandomByte ].	^bytes</body><body package="UUID">generateRandomBytes: anInteger	| n |	n := self generateRandomByte.	( anInteger - 1 ) timesRepeat:		[ n := ( n bitShift: 8 ) bitOr: self generateRandomByte ].	^n</body></methods><methods><class-id>UUIDGenerator</class-id> <category>generation api</category><body package="UUID">dce	"... answers an OpenGroup 1.1 RPC DCE UUID."	"... one of two recommended replacements for the deprecated 'NCSuuid' in DST."	"... 'dce' is slightly more restrictive than 'version1' for it allows less leeway in the formation of the 'node' field.  In particular, it does not allow a pseudo-randomly generated replacement if no address is supplied."	| uuid tick seq |	uuid := UUID nil.	tick := self tick.	tick := self adjustedTick: tick.	seq := self validatedClockSeqWithTick: tick.	1 to: 4 do: [ :ndx | uuid at: ndx put: ( tick digitAt: ndx ) ].	5 to: 6 do: [ :ndx | uuid at: ndx put: ( tick digitAt: ndx ) ].	"time_high_and_version -- VERSION = 1"	uuid at: 7 put: ( ( tick digitAt: 8 ) bitOr: 2r00010000 ).	uuid at: 8 put: ( tick digitAt: 7 ).	"clock_seq_hi_and_reserved -- VARIANT = DCE/LMS"	uuid at: 9 put: ( ( seq bitShift: -8 ) bitOr: 2r10000000 ).	uuid at: 10 put: ( seq \\ 256 ).	11 to: 16 do: [ :ndx | uuid at: ndx put: ( self dceLocaleId at: ndx - 10 ) ].	^uuid</body><body package="UUID">default: anObject	"... in conjunction with 'lms: anObject', allows the UUID generator to produce both backwardly compatible and LMS UUIDs without reset."	"... drops the argument if it is inappropriate for the default type selector.  This is to accomodate the fact that some UUID types require an argument and others do not."	| sel |	sel := self class defaultType.	^( sel last == $: )		ifTrue:	[ self perform: sel with: anObject ]		ifFalse:	[ self perform: sel ]</body><body package="UUID">lms: anObject	"... in conjunction with 'default: anObject', allows the UUID generator to produce both backward-compatible and LMS UUIDs without reset."	"... drops the argument if it is inappropriate for the default type selector.  This is to accomodate the fact that some UUID types require an argument and others do not."	| sel |	sel := self class defaultLMSType.	( sel isNil )		ifTrue:	[ ^self default: anObject ].	^( sel last == $: )		ifTrue:	[ self perform: sel with: anObject ]		ifFalse:	[ self perform: sel ]</body><body package="UUID">microsoft	"... answers a backward-compatible MicroSoft UUID."	self unsupported</body><body package="UUID">ncs	"... answers a backward-compatible NCS UUID."	"... not supported."	"... the DST 'NCSuuid' is being deprecated."	self unsupported</body><body package="UUID">next	"self default next"	^self default: nil.</body><body package="UUID">version1	"... answers a time-based UUID."	"... one of two recommended replacements for the deprecated 'NCSuuid' in DST."	"... 'version1' is slightly less restrictive than 'dce' for it allows more leeway in the formation of the 'node' field."	"The construction algorithm is as follows:		Set the time_low field equal to the least significant 32 bits (bits zero through 31) of the time stamp in the same order of significance.		Set the time_mid field equal to bits 32 through 47 from the time stamp in the same order of significance.		Set the 12 least significant bits (bits zero through 11) of the time_hi_and_version field equal to bits 48 through 59 from the time stamp in the same order of significance.		Set the four most significant bits (bits 12 through 15) of the time_hi_and_version field to the four-bit version number corresponding to the UUID version being created ....		Set the clock_seq_low field to the eight least significant bits (bits zero through seven) of the clock sequence in the same order of significance.		Set the six least significant bits (bits zero through five) of the clock_seq_hi_and_reserved field to the six most significant bits (bits eight through 13) of the clock sequence in the same order of significance.		Set the two most significant bits (bits six and seven) of the clock_seq_hi_and_reserved to zero and one, respectively.		Set the node field to the 48-bit IEEE address in the same order of significance as the address."	| uuid tick seq |	uuid := UUID nil.	tick := self tick.	tick := self adjustedTick: tick.	seq := self validatedClockSeqWithTick: tick.	"time_low"	1 to: 4 do: [ :ndx | uuid at: ndx put: ( tick digitAt: ndx ) ].	"time_mid"	5 to: 6 do: [ :ndx | uuid at: ndx put: ( tick digitAt: ndx ) ].	"time_high_and_version -- VERSION = 1"	uuid at: 7 put: ( ( tick digitAt: 8 ) bitOr: 2r00010000 ).	uuid at: 8 put: ( tick digitAt: 7 ).	"clock_seq_hi_and_reserved -- VARIANT = DCE/LMS"	uuid at: 9 put: ( ( seq bitShift: -8 ) bitOr: 2r10000000 ).	"clock_seq_lo"	uuid at: 10 put: ( seq \\ 256 ).	"node"	11 to: 16 do: [ :ndx | uuid at: ndx put: ( self version1LocaleId at: ndx - 10 ) ].	^uuid</body><body package="UUID">version2	"... answers a DCE UUID with embeded POSIX UIDs."	self unsupported</body><body package="UUID">version3From: aStringOrSymbolOrObject	"... answers a name-based, MD5 hashed UUID."	"... must generate an appropriate value if the parameter is nil."	self unsupported</body><body package="UUID">version4	"... answers a pseudo-randomly generated UUID.  In reading the following excerpt from the LMS draft, recall that the most significant bit is the leftmost."	"The algorithm is as follows:   		Set the two most significant bits (bits six and seven) of the clock_seq_hi_and_reserved to zero and one, respectively.		Set the four most significant bits (bits 12 through 15) of the time_hi_and_version field to the four-bit version number ....		Set all the other bits to randomly (or pseudo-randomly) chosen values.	"	| uuid |	uuid := UUID nil.	"time_low through time_mid"	1 to: 6 do:		[ :ndx | uuid at: ndx put: ( self generateRandomByte ) ].	"time_hi_and_version -- VERSION = 4"	uuid at: 7 put: ( ( self generateRandomByte bitShift: -4 ) bitOr: 2r01000000 ).	uuid at: 8 put: ( self generateRandomByte ).	"clock_seq_hi_and_reserved -- VARIANT = LMS"	uuid at: 9 put: ( ( self generateRandomByte bitShift: -2 ) bitOr: 2r10000000 ).	"clock_seq_low through node"	10 to: 16 do:		[ :ndx | uuid at: ndx put: ( self generateRandomByte ) ].	^uuid</body><body package="UUID">version5From: aStringOrSymbolOrObject	"... answers a name-based, SHA-1 hashed UUID."	"... must generate an appropriate value if the parameter is nil."	self unsupported</body></methods><methods><class-id>UUIDGenerator</class-id> <category>initialize-release</category><body package="UUID">initialize	random := MinimumStandardRandom new.	lastTick := self tick.</body></methods><methods><class-id>UUIDGenerator</class-id> <category>callouts</category><body package="UUID">primitiveUUIDGen: anObject	"... now a placeholder for a primitive or OS callout."	" &lt;primitive: .... "	^self default: anObject</body></methods><methods><class-id>UUIDGenerator</class-id> <category>utility - error</category><body package="UUID">unsupported	^self error: (#UUIDTypeNotSupported &lt;&lt; #dialogs &gt;&gt; 'This UUD type is not supported.')</body></methods><methods><class-id>UUIDGenerator</class-id> <category>utility - seeding</category><body package="UUID">resetSeed	"We do not strive for complication or true randomness in the seeding, because for UUID generation we only need to acheive acceptable pseudo-randomness, and not the additional attribute of 'unpredictability' required in security applications."	random seed: Time microsecondClock.	cycleTestValue := random next.</body></methods><methods><class-id>UUIDGenerator</class-id> <category>utility - locale</category><body package="UUID">dceLocaleId	"... answer a 48-bit (6-byte) locale identifer."	"... should be invoked only in the course of generating a DCE UUID type."	"... preference is given to a MAC address if available.  If not, a locale derived from the host address is returned."	^self macLocaleId		ifNil: [ self hostLocaleId ]</body><body package="UUID">hostLocaleId	"... answer a 48-bit (6-byte) locale identifer based on host address rather than MAC address."	"... should be invoked only in the generation of those UUIDs that overtly represent locale and that allow use of a host address in doing so."	"Perhaps with less than perfect fidelity to the specifications and drafts -- largely because of their unclarity regarding the procedure for encoding a 4-byte host address in the 6-byte 'node' field or locale identifier -- we set the first byte of the locale identifier to the multicast byte, the second to a randomly generated byte, and the last four to the host address.  Please object to Technical Support if you find this implementation unsatisfactory."	| bytes ha |	bytes := ByteArray new: 6.	bytes at: 1 put: 1.	bytes at: 2 put: self generateRandomByte.	ha := self class hostAddress.	1 to: 4 do:		[ :ndx | bytes at: ( ndx + 2 ) put: ( ha at: ndx ) ].	^bytes</body><body package="UUID">macLocaleId	"... answer a 48-bit (6-byte) locale identifer or 'nil'."	"... should be invoked only in the course of generating a UUID type that overtly represent locale."	"... intentionally allows for future redefinition of 'primitiveMACAddress'."	^self class primitiveMACAddress ifNil: [ self class defaultMACAddress ]</body><body package="UUID">randomLocaleId	"... answer a 48-bit (6-byte) locale identifer based on the pseudo-random number generator rather than on host address or MAC address."	"... should be invoked only in the generation of those UUIDs that overtly represent locale and that allow use of a pseudo-randomy generated locale component."	"Do not omit setting the multicast flag in this case."	| bytes |	bytes := self generateRandomByteArray: 6.	bytes basicAt: 1 put: 1.	^bytes.</body><body package="UUID">version1LocaleId	"... answer a 48-bit (6-byte) locale identifer."	"... should be invoked only in the course of generating a version 1 UUID type."	"... preference is given to a MAC address if available.  If not, and 'defaultUseHostAddress' is false, a pseudorandomly-generated location identifier is returned, as permitetd by the LMS draft."	^self macLocaleId		ifNil: [ ^( self class defaultUseHostAddress )					ifTrue:	[ self hostLocaleId ]					ifFalse:	[ self randomLocaleId ]			]</body></methods><methods><class-id>UUIDGenerator</class-id> <category>utility - time</category><body package="UUID">adjustedTick: anInteger 	"It may happen that the system is called upon to generate a new, time-based UUID, more than once within the time resolution of the system clock.  The LMS draft specifies the following."	"If a system overruns the generator by requesting too many UUIDs within a single system time interval, the UUID service MUST either: return an error, or stall the UUID generator until the system clock catches up.	A high resolution time stamp can be simulated by keeping a count of how many UUIDs have been generated with the same value of the system time, and using it to construct the low-order bits of the time stamp. The count will range between zero and the number of 100-nanosecond intervals per system time interval."	"We elect not to simulate but to stall, while providing the class method 'maxTickIncrements' for those who might elect to simulate.  Users pursuing the simulation path will need to add, initialize, and manage a 'tickIncrement' instVar."	| tick adjTick |	tick := self tick.	adjTick := ( tick &gt; lastTick )				ifTrue:	[	tick						]				ifFalse:	[	( Delay forMicroseconds: 1 ) wait.							self adjustedTick: anInteger						].	^lastTick := adjTick</body><body package="UUID">incrementClockSeq	"Increments the clock sequence, which is the required action when the current tick is less than the last tick used.  This may occur when an image is copied to a platform in another time zone, or a system clock is reset."	clockSeq := ( clockSeq + 1 ) \\ 16r4000</body><body package="UUID">resetClockSeq	"The version 1 clock sequence is a 14-bit value used to avoid some forms of UUID replication.  It should be reset when the node identifer changes.  (In this implementation, to account for Smalltalk's special characteristics, we somewhat extend the notion of what counts as a change in locale.)  The value of the clock sequence should not be associated with the node ID and, at least once in the lifetime of the system, it should be set to a high-quality random number.  (We accept good pseudo-randomness in its stead.)  We represent 'clockSeq' as a 2-byte quantity."	clockSeq := ( self generateRandomBytes: 3 ) \\ 16r4000</body><body package="UUID">tick	"A version 1 UUID 'timestamp' is a 60-bit value representing, in UTC, the number of 100-nanosecond intervals since 00:00:00.00 15 Oct 1582, the nominal date of the Gregorian calendar reform.  Thus, we get the current microsecond (10 ** -6) since 00:00:00 01 Jan 1901(the start date of the system clock) ), add in the microseconds since 00:00:00 15 Oct 1582 (the start date of the UUID clock) , add the GMT offset in microseconds, and convert the sum to a 100 nanosecond (10 ** -7) count.  The result is an 8-byte value.  NOTA BENE: Should any of the involved parameters involved here change in future specifications of implementations, this method must be changed."	^( Time microsecondClock		+ 10041840000000000			+ ( TimeZone reference secondsFromGMT * 1000000 ) ) * 10</body><body package="UUID">validatedClockSeqWithTick: aTimeTick 	"Regenerate the clock sequence if necessary.  Use the 'tick' and not the current 'microsecondClock' value, because the former includes the GMT correction.  A side-effect of this method is to update locale information, if necessary.  As a consequence, it must be called before generation of the 'node' component of those UUID types that overtly encode locale."	( aTimeTick &lt; lastTick )		ifTrue:	[	self incrementClockSeq 				]		ifFalse:	[	( self class changedLocale or: [clockSeq isNil])						ifTrue: [ self class refreshAll ]				].	^lastClockSeq := clockSeq</body></methods><methods><class-id>UUIDGenerator class</class-id> <category>accessing</category><body package="UUID">defaultLMSType	"Answers the selector to be used for generating the default LMS UUID type.  The intent is to allow the software generation of a known, platform-independent LMS UUID type, if no OS-specific callout is supplied."	^defaultLMSType ifNil: [ defaultLMSType := self defaultLMSTypeValue ]</body><body package="UUID">defaultLMSType: aSelector	"The argument is expected to be a selector, from the instance-side 'generation' protocol, excluding the selectors that do not begin with 'version'."	defaultLMSType := aSelector</body><body package="UUID">defaultLMSTypeValue	"... expected to answer a selector, from the instance-side 'generation' protocol, excluding the selectors that do not begin with 'version'."	^#version1</body><body package="UUID">defaultMACAddress	"Answers nil or a 6-byte value to be used for generating the UUID types that require a part that specifies a physical location."	^defaultMACAddress ifNil: [ defaultMACAddress := self defaultMACAddressValue ]</body><body package="UUID">defaultMACAddress: aByteArrayOrNil	"The argument should be 'nil' or a 6-byte quantity.  The OpenGroup CDE 1.1 RPC specification allows a 48-bit address obtained through the IEEE registration authority, but this is only appropiate for DCE UUIDs.  If no IEEE 802 address is available, the LMS draft specification allows a pseudo-randomly-generated 6-byte quantity with the multicast bit set, so that the randomly generated address will never conflict with one obtained from a network card."	"	UUIDGenerator defaultMACAddress: nil	"	defaultMACAddress := aByteArrayOrNil</body><body package="UUID">defaultMACAddressValue	"Answers nil or a 6-byte value for use in generating UUID types that require explicitly encode a physical locale.  The default value is 'nil', so that if the MAC address cannot be acquired through a callout, and is left as 'nil', one of the other, draft or specification compliant ways of supplying this part of a UUID may be employed."	^nil</body><body package="UUID">defaultType	"Answers the selector to be used for generating the default UUID type."	^defaultType ifNil: [ defaultType := self defaultTypeValue ]</body><body package="UUID">defaultType: aSelector	"The argument is expected to be a selector, from the instance-side 'generation' protocol, excluding the selector 'default:'."	defaultType := aSelector</body><body package="UUID">defaultTypeValue	"... expected to answer a selector, from the instance-side 'generation' protocol, excluding the selector 'default:'."	^#version4</body><body package="UUID">defaultUseHostAddress	"Answers a boolean controlling the generation of the locale segment of those UUID types thet contain one."	^defaultUseHostAddress ifNil: [ defaultUseHostAddress := self defaultUseHostAddressValue ]</body><body package="UUID">defaultUseHostAddress: aBoolean"	UUIDGenerator defaultUseHostAddress: true.	UUIDGenerator defaultUseHostAddress: false.	"	defaultUseHostAddress := aBoolean</body><body package="UUID">defaultUseHostAddressValue	"In some applications, it may be useful, even if not recommended practice, to take advantage of the locale information present in those UUID types that contain it.  (The practice is not very useful in the presence of dynamically generated IP addresses.)  This setting, for those UUID types that contain locale information, overrides the more usual encoding of locale in information, so that a meaningful host address may be derived from the UUID.  By default, the value returned is 'false'."	^false</body></methods><methods><class-id>UUIDGenerator class</class-id> <category>utility - locale defintion</category><body package="UUID">hostAddress	^IPSocketAddress hostAddressByName: SocketAccessor getHostname.</body><body package="UUID">imageFilename	^ObjectMemory imageFilename asString</body><body package="UUID">macAddress	^self primitiveMACAddress ifNil: [ self defaultMACAddress ]</body><body package="UUID">platformId	^OS.OSHandle.CurrentPlatformID copy</body></methods><methods><class-id>UUIDGenerator class</class-id> <category>constants</category><body package="UUID">maxTickIncrements	"... the time resolution (microseconds) divided by the UUID resolution (100 nanoseconds)."	"	UUIDGenerator maxTimeSteps	self systemTickResolution / self uuidTickResolution	"	^10</body><body package="UUID">systemClockStartDate	"The Smalltalk clock ticks from 00:00:00.00 01 Jan 1901."	^Date newDay: 1 monthNumber: 1 year: 1901</body><body package="UUID">systemTickResolution	"... microseconds"	^10 raisedTo: -6</body><body package="UUID">uuidClockStartDate	"The UUID clock ticks from 00:00:00.00 15 Oct 1582."	^Date newDay: 15 monthNumber: 10 year: 1582</body><body package="UUID">uuidDateOffsetInSeconds	"The difference is 116225 days."	"	( self systemClockStartDate ) subtractDate: ( self uuidClockStartDate )	116225 * 24 * 60 * 60	"	^10041840000</body><body package="UUID">uuidTickResolution	"... 100 nanoseconds, or ( 10 raisedTo: -9 ) * 100."	^10 raisedTo: -7</body></methods><methods><class-id>UUIDGenerator class</class-id> <category>instance creation</category><body package="UUID">default	"... ensure there is only one privileged instance of UUIDGenerator per image."	"	UUIDGenerator default	"	^default := default ifNil: [ super new initialize ]</body><body package="UUID">new	"... ensure there is only one privileged instance of UUIDGenerator per image."	^self default</body><body package="UUID">setDefault: aUUIDGeneratorOrNil	"... ensure there is only one privileged instance of UUIDGenerator per image."	"	UUIDGenerator default: nil	"	^default := aUUIDGeneratorOrNil</body></methods><methods><class-id>UUIDGenerator class</class-id> <category>utility - locale refresh</category><body package="UUID">changedLocale	"This is a reasonable definition of a locale change that a Smalltalk image may undergo.  It ought to cover all cases where a clone has been made of an existing image or a change has occurred in one of the parameters that is both used in UUID generation and can be extracted from a UUID for informational use.  This definition somewhat exceeds the requirements set out in the LMS UUID working draft, which is probably necessary in the case of Smaltalk.  It should also obviate the use of a parameter like the 'imageId' in DST's deprecated 'NCSuuid' implementation.	If the system is marked as runtime, we also consider that as a locale change, because we do not want a packged runtime application, when run repeatedly on the same machine, to always generate the same sequence of UUIDs. That would make them very non-unique."	^( self imageFilename ~= lastImageFilename )		or: [ ( self hostAddress ~= lastHostAddress )			or: [ ( self platformId ~= lastPlatformId )				or: [ self macAddress ~= lastMACAddress ] ] ]</body><body package="UUID">refreshAll	self refreshSeed.	self refreshClockSeq.	self refreshLocale</body><body package="UUID">refreshClockSeq	self default resetClockSeq</body><body package="UUID">refreshLocale	lastImageFilename := self imageFilename.	lastHostAddress := self hostAddress.	lastPlatformId := self platformId.	lastMACAddress := self macAddress</body><body package="UUID">refreshSeed	self default resetSeed</body></methods><methods><class-id>UUIDGenerator class</class-id> <category>callouts</category><body package="UUID">primitiveMACAddress	"... now a placeholder for a primitive or OS callout."	" &lt;primitive: .... "	^self defaultMACAddress</body></methods><methods><class-id>UUIDSystem</class-id> <category>prerequisites</category><body package="UUID">prerequisiteSystems	^Array with: InterestNotificationSystem</body></methods><methods><class-id>UUIDSystem</class-id> <category>actions</category><body package="UUID">setUp	"Refreshes the UUIDGenerator pseudo-random number generator seed and clock sequence at system startup if the host address, the image filename, the platform identifier, or the MAC address or its logical equivalent have changed, and thus embodies a somewhat extended notion, compared to the LMS draft, of change in locale.  Independent of the UUID type used, image files copied to another locale should reset their pseudo-random number generator seed to minimize the possibility of UUID replication."	super setUp.	UUIDGenerator refreshAll</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>ByteArray</name><environment>Core</environment><super>Core.IntegerArray</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>Subsystem</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>state canActivate prerequisites </inst-vars><class-inst-vars>current </class-inst-vars><imports></imports><category>System-Subsystems</category><attributes><package>System-Subsystems</package></attributes></class></st-source>