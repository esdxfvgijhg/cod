<?xml version="1.0"?><st-source><!-- Name: OS-Sockets-IPv6Notice: Copyright 1999-2016 Cincom Systems, Inc.  All rights reserved.Comment: This package adds support for IPv6.In porting, some patterns should be watched out for:You should never create a SocketAccessor until you have the SocketAddress to which it will either bind or connect already in hand. Then, you should use for the socket's family the domainCode of the SocketAddress. For example, change this:	socket := SocketAccessor			family: SocketAccessor AF_INET			type: SocketAccessor SOCK_STREAM.	socket connectoTo: (IPSocketAddress hostName: 'www.example.com' port: 80)....to:	address := IPSocketAddress hostName: 'www.example.com' port: 80.	socket := SocketAccessor			family: address domainCode			type: SocketAccessor SOCK_STREAM.	socket connectTo: address.The address in this case is still IPv4, but if we then move to an IPv6 compatible address lookup, the socket will be created correctly.For code that is looking up a host name in order to create a socket and connect to it, the next step to become IPv6 capable is to use a new host lookup protocol, #tcpAddressesForHost:port:, which answers both IPv4 and IPv6 addresses. But this protocol answers a collection of addresses rather than just one, and it answers more information than just the SocketAddress. The expectation is that you'll iterate over the collection until you succeed in connecting, which we use to rewrite the preceding example :	| socket |	(IPSocketAddress tcpAddressesForHost: 'www.example.com' port: 80)		detect: [ :info |			[	socket := info asSocketAccessor.				[ socket connectTo: info address ] ifCurtailed: [ socket close ].				true			] on: OsError do: [ :ex | false ] ]		ifNone: [ OsInaccessibleError raiseSignal ].	^socketA common pattern for servers is:	address := IPSocketAddress hostAddress: IPSocketAddress thisHost port: somePort.If you want this to be IPv6-compatible, change it to:	address := IPSocketAddress defaultServerAddressType thisHostPort: somePortWhen IPv6 is loaded, this will by default switch to serving on an IPv6 socket. If you want to load IPv6 but continue to have your server code serving on IPv4 by default, evaluate this:	IPSocketAddress.UseIPv6ForDefaultServer := falseDbIdentifier: bear73DbTrace: 483018DbUsername: lkooymanDbVersion: 8.2 - 1PackageName: OS-Sockets-IPv6Parcel: #('OS-Sockets-IPv6')ParcelName: OS-Sockets-IPv6PrintStringCache: (8.2 - 1,lkooyman)Version: 8.2 - 1Date: 12:12:33 PM January 22, 2016 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.2 (jan16.3) of January 22, 2016 on January 22, 2016 at 12:12:33 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>IPv6SocketAddress</name><environment>OS</environment><super>OS.IPSocketAddress</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Sockets</category><attributes><package>OS-Sockets-IPv6</package></attributes></class><comment><class-id>OS.IPv6SocketAddress</class-id><body>Instances of this class represent socket addresses interpreted in the ''Internet (e.g. ARPA) Domain'' address family.From /usr/include/netinet/in.h:	struct in_addr {		union {			struct { u_char s_b1,s_b2,s_b3,s_b4; } S_un_b;			struct { u_short s_w1,s_w2; } S_un_w;			u_long S_addr;		} S_un;	struct sockaddr_in {		short sin_family;		u_short sin_port;		struct in_addr sin_addr;			char sin_zero[8];	};That is, an Internet address has a 2-byte port number and a 4-byte host address.Look for more information about structure of and symbolic names for host addressesand ports in this class's "documentation" protocol.</body></comment><shared-variable><name>UseIPv6ForDefaultServer</name><environment>OS.IPSocketAddress</environment><private>false</private><constant>false</constant><category>settings</category><initializer>true</initializer><attributes><package>OS-Sockets-IPv6</package></attributes></shared-variable><shared-variable><name>PrintHostName</name><environment>OS.IPv6SocketAddress</environment><private>false</private><constant>false</constant><category>settings</category><initializer>false</initializer><attributes><package>OS-Sockets-IPv6</package></attributes></shared-variable><methods><class-id>OS.IPv6SocketAddress</class-id> <category>accessing</category><body package="OS-Sockets-IPv6">flowControl	"Answer the flow control."	"Network byte order is fixed."	^self unsignedLongAt: 5 bigEndian: true</body><body package="OS-Sockets-IPv6">flowControl: p	"Assign the flow control flags."	"Network byte order is fixed."	self unsignedLongAt: 5 put: p bigEndian: true</body><body package="OS-Sockets-IPv6">hostAddress	"Answer the host address."	^(ByteArray new: 16) replaceBytesFrom: 1 to: 16 with: self startingAt: 9</body><body package="OS-Sockets-IPv6">hostAddress: hba 	"Assign the host address."	hba class == ByteArray 		ifTrue: 			[self 				replaceBytesFrom: 9				to: 24				with: hba				startingAt: 1.			^self].	OSErrorHolder badArgumentsSignal raise</body><body package="OS-Sockets-IPv6">hostName	"Answer the host name."	^self class hostNameByAddress: self hostAddress</body><body package="OS-Sockets-IPv6">port	"Answer the port number."	"Network byte order is fixed."	^self unsignedShortAt: 3 bigEndian: true</body><body package="OS-Sockets-IPv6">port: p	"Assign the port number."	"Network byte order is fixed."	(p isKindOf: ByteArray)		ifTrue:			[self byteAt: 3 put: (p at: p size - 1).			self byteAt: 4 put: (p at: p size)]		ifFalse:			[self unsignedShortAt: 3 put: p bigEndian: true]</body><body package="OS-Sockets-IPv6">scopeID	"Answer the scope ID."	"This is in host byte order."	^self unsignedLongAt: 25</body><body package="OS-Sockets-IPv6">scopeID: p	"Assign the scope ID."	"This is in host byte order."	self unsignedLongAt: 25 put: p</body></methods><methods><class-id>OS.IPv6SocketAddress</class-id> <category>printing</category><body package="OS-Sockets-IPv6">printAddressOn: aStream	aStream nextPutAll: (self class bytesToName: self hostAddress)</body><body package="OS-Sockets-IPv6">printBytesOn: aStream	"Output the printable representation of the address to the stream."	PrintHostName		ifTrue: [aStream nextPutAll: self hostName]		ifFalse:			[aStream nextPut: $[.			self printAddressOn: aStream.			aStream nextPut: $].].	aStream		nextPut: $:;		print: self port</body></methods><methods><class-id>OS.IPv6SocketAddress</class-id> <category>comparing</category><body package="OS-Sockets-IPv6">addressBytesMatchThoseOf: anIPv6SocketAddress	"Consider only the first 28 bytes (family, port, flowinfo, addr, scope id)."	1 to: 28 do:		[:each |			(self byteAt: each) = (anIPv6SocketAddress byteAt: each) ifFalse: [^false]		].	^true</body><body package="OS-Sockets-IPv6">hash	"Consider only the first 28 bytes (family, port, flowinfo, addr, scope id)."	| answer |	answer := 1.	1 to: 28 do: [:each | answer := (answer + (self byteAt: each)) hashMultiply].	^answer</body></methods><methods><class-id>OS.IPv6SocketAddress class</class-id> <category>private</category><body package="OS-Sockets-IPv6">bytesToName: aByteArray	"Convert the bytes to the canonical printed representation."	"IPv6SocketAddress bytesToName: #[254 128 0 0 0 0 0 0 70 135 252 255 254 233 212 250]"	| bytes words interval stop start interval2 out |	bytes := aByteArray readStream.	words := (Array new: 8) writeStream.	[bytes atEnd] whileFalse:		[words nextPut: bytes next * 256 + bytes next].	words := words contents.	interval := 1 to: 0.	stop := 0.	[start := (stop+1 to: words size)		detect: [:i | (words at: i) = 0]		ifNone: [nil].	start = nil] whileFalse:		[stop := (start+1 to: words size)			detect: [:i | (words at: i) ~= 0]			ifNone: [nil].		stop = nil ifTrue: [stop := words size+1].		interval2 := start to: stop-1.		interval2 size &gt; interval size ifTrue: [interval := interval2]].	out := (String new: 40) writeStream.	interval size &lt; 2		ifTrue:			[(1 to: words size)				do: [:i | (words at: i) printOn: out base: 16]				separatedBy: [out nextPut: $:]]		ifFalse:			[(1 to: interval first - 1)				do: [:i | (words at: i) printOn: out base: 16]				separatedBy: [out nextPut: $:].			out next: 2 put: $:.			(interval last + 1 to: words size)				do: [:i | (words at: i) printOn: out base: 16]				separatedBy: [out nextPut: $:]].	^out contents asLowercase</body><body package="OS-Sockets-IPv6">decodePartial: list	| output token tok val char cval |	output := (ByteArray new: 16) writeStream.	1 to: list size do: [:i |		token := list at: i.		(token includes: $.)			ifTrue:				[tok := IPSocketAddress stringToBytes: token.				tok == nil ifTrue: [^nil].				output nextPutAll: tok]			ifFalse:				[val := 0.				1 to: token size do: [:ci |					char := token at: ci.					cval := char digitValue.					(cval &lt; 0 or: [cval &gt; 15]) ifTrue: [^nil].					val := val*16 + cval].				val &gt; 65535 ifTrue: [^nil].				output nextPut: val // 256; nextPut: val \\ 256]].	^output contents</body><body package="OS-Sockets-IPv6">new: cnt	"Create an new instance."	^(super new: cnt) domainCode: self networkFamilyCode</body><body package="OS-Sockets-IPv6">primHostAddressByName: bytes 	"return a ByteArray which is the IP address of the named host or nil if no match."	&lt;primitive: 640 errorCode: err&gt;	err == nil		ifTrue: [^OSErrorHolder unsupportedOperationSignal raise].	err name = #'bad argument'		ifTrue: [^OSErrorHolder badArgumentsSignal raise].	err name = #'allocation failed'		ifTrue:			[err handleErrorFor: self.			^self primHostAddressByName: bytes].	err name = #'no match'		ifTrue: [^nil].	self error: (#UnexpectedError &lt;&lt; #dialogs &gt;&gt; 'Unexpected error')</body><body package="OS-Sockets-IPv6">primHostNameByAddress: aByteArray	"return a String which is the host name for the given IP address or nil if no match."	&lt;primitive: 645 errorCode: err&gt;	err == nil		ifTrue: [^OSErrorHolder unsupportedOperationSignal raise].	err name = #'bad argument'		ifTrue: [^OSErrorHolder badArgumentsSignal raise].	err name = #'allocation failed'		ifTrue:			[err handleErrorFor: self.			^self primHostNameByAddress: aByteArray].	err name = #'no match'		ifTrue: [^nil].	self error: (#UnexpectedError &lt;&lt; #dialogs &gt;&gt; 'Unexpected error')</body><body package="OS-Sockets-IPv6">primNetAddressByName: bytes	"return a ByteArray which is the IP address of the named network."	&lt;primitive: 641 errorCode: err&gt;	err == nil		ifTrue: [^OSErrorHolder unsupportedOperationSignal raise].	err name = #'bad argument'		ifTrue: [^OSErrorHolder badArgumentsSignal raise].	err name = #'allocation failed'		ifTrue:			[err handleErrorFor: self.			^self primNetAddressByName: bytes].	err name = #'no match'		ifTrue: [^OSErrorHolder inaccessibleSignal raiseWith:					(IOAccessor convertSimpleStringFromPlatform: bytes)].	self error: (#UnexpectedError &lt;&lt; #dialogs &gt;&gt; 'Unexpected error')</body><body package="OS-Sockets-IPv6">primNetNameByAddress: aByteArray	"return a String which is the network name for the given IP address."	&lt;primitive: 646 errorCode: err&gt;	err == nil		ifTrue: [^OSErrorHolder unsupportedOperationSignal raise].	err name = #'bad argument'		ifTrue: [^OSErrorHolder badArgumentsSignal raise].	err name = #'allocation failed'		ifTrue:			[err handleErrorFor: self.			^self primNetNameByAddress: aByteArray].	err name = #'no match'		ifTrue: [^nil].	self error: (#UnexpectedError &lt;&lt; #dialogs &gt;&gt; 'Unexpected error')</body><body package="OS-Sockets-IPv6">primProtocolNameByNumber: aSmallInteger	"return a String which is the protocol name for the given IP protocol number."	&lt;primitive: 647 errorCode: err&gt;	err == nil		ifTrue: [^OSErrorHolder unsupportedOperationSignal raise].	err name = #'bad argument'		ifTrue: [^OSErrorHolder badArgumentsSignal raise].	err name = #'allocation failed'		ifTrue:			[err handleErrorFor: self.			^self primProtocolNameByNumber: aSmallInteger].	err name = #'no match'		ifTrue: [^OSErrorHolder inaccessibleSignal raiseWith: aSmallInteger].	self error: (#UnexpectedError &lt;&lt; #dialogs &gt;&gt; 'Unexpected error')</body><body package="OS-Sockets-IPv6">primProtocolNumberByName: bytes	"return a SmallInteger which is the IP protocol number of the named protocol."	&lt;primitive: 642 errorCode: err&gt;	err == nil		ifTrue: [^OSErrorHolder unsupportedOperationSignal raise].	err name = #'bad argument'		ifTrue: [^OSErrorHolder badArgumentsSignal raise].	err name = #'no match'		ifTrue: [^OSErrorHolder inaccessibleSignal raiseWith:					(IOAccessor convertSimpleStringFromPlatform: bytes)].	self error: (#UnexpectedError &lt;&lt; #dialogs &gt;&gt; 'Unexpected error')</body><body package="OS-Sockets-IPv6">primServiceNameByPort: aByteArray	"return a String which is the service name for the given IP port number."	&lt;primitive: 648 errorCode: err&gt;	err == nil		ifTrue: [^OSErrorHolder unsupportedOperationSignal raise].	err name = #'bad argument'		ifTrue: [^OSErrorHolder badArgumentsSignal raise].	err name = #'allocation failed'		ifTrue:			[err handleErrorFor: self.			^self primServiceNameByPort: aByteArray].	err name = #'no match'		ifTrue: [^OSErrorHolder inaccessibleSignal raiseWith: aByteArray].	self error: (#UnexpectedError &lt;&lt; #dialogs &gt;&gt; 'Unexpected error')</body><body package="OS-Sockets-IPv6">primServicePortByName: bytes	"return a ByteArray which is the IP port number of the named service."	&lt;primitive: 643 errorCode: err&gt;	err == nil		ifTrue: [^OSErrorHolder unsupportedOperationSignal raise].	err name = #'bad argument'		ifTrue: [^OSErrorHolder badArgumentsSignal raise].	err name = #'allocation failed'		ifTrue:			[err handleErrorFor: self.			^self primServicePortByName: bytes].	err name = #'no match'		ifTrue: [^OSErrorHolder inaccessibleSignal raiseWith:					(IOAccessor convertSimpleStringFromPlatform: bytes)].	self error: (#UnexpectedError &lt;&lt; #dialogs &gt;&gt; 'Unexpected error')</body><body package="OS-Sockets-IPv6">stringToBytes: aString	"Convert the string in any recognized address format to a byte array.	If the string is badly formatted, or if an individual component has a	numerical value that exceeds its maximum permitted value, answer nil."	"Valid addresses...	#('::' '::ffff' 'ffff::' '::ffff:50.100.150.200'			'fe80::3880:9344:9a25:a1a8' 			'fe80:0:0:0:3880:9344:9a25:a1a8')		collect: [:s | IPv6SocketAddress stringToBytes: s].	Invalid addresses, answer nil...	#(':::' '::ffffff' 'ffffff::' '::z' '::ffff:50.100.150'			'fe80::3880::9344:9a25:a1a8' 			'fe80:0:3880:9344:9a25:a1a8'			'fe80:0:0:0:0:3880:9344:9a25:a1a8')		collect: [:s | IPv6SocketAddress stringToBytes: s].	"	| ba tokens blanks partial blankIndex partial1 partial2 | 	ba := ByteArray new: 16.	aString asString = '::' ifTrue: [^ba].	tokens := (aString tokensBasedOn: $:) asArray.	tokens size &lt; 3 ifTrue: [^nil].	blanks := tokens occurrencesOf: ''.	blanks = 2		ifTrue:			[(tokens first: 2) = #('' '')				ifTrue:					[partial := self decodePartial: (tokens copyFrom: 3 to: tokens size).					(partial == nil or: [partial size &gt; ba size]) ifTrue: [^nil].					ba replaceFrom: ba size-partial size+1 to: ba size with: partial startingAt: 1]				ifFalse: [(tokens last: 2) = #('' '')				ifTrue:					[partial := self decodePartial: (tokens copyFrom: 1 to: tokens size-2).					(partial == nil or: [partial size &gt; ba size]) ifTrue: [^nil].					ba replaceFrom: 1 to: partial size with: partial startingAt: 1]				ifFalse: [^nil]]]		ifFalse: [blanks = 1		ifTrue:			[blankIndex := tokens indexOf: ''.			(blankIndex = 1 or: [blankIndex = tokens size]) ifTrue: [^nil].			partial1 := self decodePartial: (tokens copyFrom: 1 to: blankIndex-1).			partial1 == nil ifTrue: [^nil].			partial2 := self decodePartial: (tokens copyFrom: blankIndex+1 to: tokens size).			partial2 == nil ifTrue: [^nil].			partial1 size + partial2 size &gt; ba size ifTrue: [^nil].			ba replaceFrom: 1 to: partial1 size with: partial1 startingAt: 1.			ba replaceFrom: ba size-partial2 size+1 to: ba size with: partial2 startingAt: 1]		ifFalse:			[blanks = 0 ifFalse: [^nil].			ba := self decodePartial: tokens.			ba size = 16 ifFalse: [^nil]]].	^ba</body></methods><methods><class-id>OS.IPv6SocketAddress class</class-id> <category>instance creation</category><body package="OS-Sockets-IPv6">hostAddress: ha	"Answer a new instance with the given host address."	^self new hostAddress: ha</body><body package="OS-Sockets-IPv6">hostAddress: hn port: p	"Answer a new instance with the given host address and port."	^self new		hostAddress: hn;		port: p;		yourself</body><body package="OS-Sockets-IPv6">hostName: hn	"Answer a new instance with the given host name."	^self new hostAddress: (self hostAddressByName: hn)</body><body package="OS-Sockets-IPv6">hostName: hn port: p	"Answer a new instance with the given host name and port."	^self new		hostAddress: (self hostAddressByName: hn);		port: p;		yourself</body><body package="OS-Sockets-IPv6">new	"Return a new instance of the default size and of unspecified type."	^self new: 32</body></methods><methods><class-id>OS.IPv6SocketAddress class</class-id> <category>documentation</category><body package="OS-Sockets-IPv6">allAboutHostAddresses	"IPv6 host addresses are 16 bytes long and are made up of a network	number and a host-on-network number.  (Normally, though, we treat	a host address as if it doesn't have any substructure.)  An IP host	address doesn't really just identify a particular host, it identifies a	particular network interface on a particular host.  Therefore, one host	may have several host addresses.	Host addresses by convention are printed as 8 16-bit hexadecimal values	with colons in between, viz: 0:0:0:0:0:ffff:c009:c802	If more than one 0 appears consecutively in the address, the group of consecutive	zeroes can be abbreviated to a doubled colon, so that the preceding example	could be written: ::ffff:c009:c802	However, collapsing zeroes using doubled colons can only happen at one	place in the representation, so it is normal to apply it to the longest grouping	of zeroes, or the leftmost in case of a tie.	When we need to deal with host or network addresses as such (rather than	embedded in a socket address) we just use (16-byte) ByteArrays.	When a client wants to reach a server on the current host, the address	::1 ('localhost') is used."	^self commentOnly</body><body package="OS-Sockets-IPv6">allAboutPortNumbersAndNames	"Port numbers are necessarily part of socket addresses because more	than just a host-address is needed to identify a communicating entity	on a given host.  That is, since each socket on a host needs a unique	socket address and there will be many sockets with the same	&lt;address-family, host-address, protocol-number&gt;, we need another field to	provide uniqueness.	IP port numbers are 2 bytes long and are normally treated as a 16-bit	positive number.  Some port numbers are assigned in advance (Well Known Ports)	and correspond to some standard service's connection-port.  Sockets which are	not created for these standard purposes are dynamically assigned port numbers.	As with hosts names, programmers prefer to refer to standard services using a name	rather than a string of digits.  So IP implementations usually have some sort of	serviceName-to-portNumber directory. The class protocol ''naming utilities'' has	methods to convert to/from service-names and port-numbers.	Assigning a new standard port number is an issue too complicated to be covered here.	If you want to install a name-to-number correspondence that will have effect	only on your local network, there will be platform-specific means to configure your	local name-service.  (On Suns, this is done with the Yellow Pages).	If your service is transient, or otherwise not appropriate for assigning a Well-Known	Port-Number, you have 2 alternatives:		1) Pick a random number between				IPv6SocketAddress firstUnreservedPort		and				IPv6SocketAddress maxPort		inclusive and hard-code this number into your client and server implementation.  Hope		that no-one on the hosts you will be using has made the same choice.		2) Let the system assign one for you (each time you start a server) by fire-ing up a		server which creates a socket using port:			IPv6SocketAddress anyPort		then do a getName on that socket, print the port number and supply it to the client		when you start it up."	^self commentOnly</body></methods><methods><class-id>OS.IPv6SocketAddress class</class-id> <category>addressing</category><body package="OS-Sockets-IPv6">thisHost	"The wildcard 'thisHost' address."	^ByteArray new: 16</body></methods><methods><class-id>OS.IPv6SocketAddress class</class-id> <category>naming utilities</category><body package="OS-Sockets-IPv6">hostAddressByName: aString	"Answer the host address for the named host."	| address |	(address := self stringToBytes: aString) notNil ifTrue:		[^address].	address := self primHostAddressByName: (IOAccessor convertSimpleStringForPlatform: aString).	^address isNil		ifTrue: [OSErrorHolder inaccessibleSignal raiseWith:aString]		ifFalse: [address]</body><body package="OS-Sockets-IPv6">netAddressByName: aString	"returns a ByteArray which is the IP address of the named network."	^self primNetAddressByName: (IOAccessor convertSimpleStringForPlatform: aString)</body><body package="OS-Sockets-IPv6">netNameByAddress: aByteArray	"returns a String which is the network name for the given IP address."	| nn |	nn := self primNetNameByAddress: aByteArray.	^nn isNil		ifTrue: [self bytesToName: aByteArray]		ifFalse: [IOAccessor convertSimpleStringFromPlatform: nn]</body><body package="OS-Sockets-IPv6">protocolNameByNumber: aSmallInteger	"returns a String which is the protocol name for the given IP protocol	number."	^IOAccessor convertSimpleStringFromPlatform:			(self primProtocolNameByNumber: aSmallInteger)</body><body package="OS-Sockets-IPv6">protocolNumberByName: aString	"returns a SmallInteger which is the IP protocol number of the named	protocol."	^self primProtocolNumberByName: (IOAccessor convertSimpleStringForPlatform: aString)</body><body package="OS-Sockets-IPv6">serviceNameByPort: aByteArrayOrInt	"returns a String which is the service name for the given IP port number."	| ba |	ba := aByteArrayOrInt.	(ba isKindOf: ByteArray)		ifFalse: 			[| ub |			ub := UninterpretedBytes new: 2.			ub unsignedShortAt: 1 put: ba bigEndian: true.			ba := ub asByteArray].	^IOAccessor		convertSimpleStringFromPlatform: (self primServiceNameByPort: ba)</body><body package="OS-Sockets-IPv6">servicePortByName: aString	"returns a ByteArray which is the IP port number of the named service."	^self primServicePortByName: (IOAccessor convertSimpleStringForPlatform: aString)</body></methods><methods><class-id>OS.IPv6SocketAddress class</class-id> <category>class accessing</category><body package="OS-Sockets-IPv6">networkFamilyName	^#AF_INET6</body></methods><methods><class-id>OS.MacOSXSocketAccessor class</class-id> <category>private-ipv6 options</category><body package="OS-Sockets-IPv6">_ipv6JoinGroup	^12</body><body package="OS-Sockets-IPv6">_ipv6LeaveGroup	^13</body><body package="OS-Sockets-IPv6">_ipv6V6Only	^27</body></methods><methods><class-id>OS.MacOSXSocketAccessor class</class-id> <category>private-protocol families</category><body package="OS-Sockets-IPv6">_pfInet6	^30</body></methods><methods><class-id>OS.LinuxSocketAccessor class</class-id> <category>private-ipv6 options</category><body package="OS-Sockets-IPv6">_ipv6JoinGroup	^20</body><body package="OS-Sockets-IPv6">_ipv6LeaveGroup	^21</body><body package="OS-Sockets-IPv6">_ipv6V6Only	^26</body></methods><methods><class-id>OS.LinuxSocketAccessor class</class-id> <category>private-protocol families</category><body package="OS-Sockets-IPv6">_pfInet6	"	***This is decompiled code.*** 	The source was unavailable because the source pointer appears to point to an 	incorrect position in the file. The file may have been modified after this method 	was updated."	^10</body></methods><methods><class-id>OS.SolarisSocketAccessor class</class-id> <category>private-ipv6 options</category><body package="OS-Sockets-IPv6">_ipv6JoinGroup	^9</body><body package="OS-Sockets-IPv6">_ipv6LeaveGroup	^10</body><body package="OS-Sockets-IPv6">_ipv6V6Only	^39</body></methods><methods><class-id>OS.SolarisSocketAccessor class</class-id> <category>private-protocol families</category><body package="OS-Sockets-IPv6">_pfInet6	^26</body></methods><methods><class-id>OS.SocketAccessor class</class-id> <category>private-protocol</category><body package="OS-Sockets-IPv6">_ipprotoIpv6	^41</body></methods><methods><class-id>OS.SocketAccessor class</class-id> <category>private-ipv6 options</category><body package="OS-Sockets-IPv6">_ipv6JoinGroup	^12</body><body package="OS-Sockets-IPv6">_ipv6LeaveGroup	^13</body><body package="OS-Sockets-IPv6">_ipv6V6Only	^26</body></methods><methods><class-id>OS.SocketAccessor class</class-id> <category>constants-address families</category><body package="OS-Sockets-IPv6">AF_INET6	^self PF_INET6</body></methods><methods><class-id>OS.SocketAccessor class</class-id> <category>class initialize/release</category><body package="OS-Sockets-IPv6">hookupFor: ps withID: id 	"hook-up default subclasses."	concreteClass := nil.	self allSubclasses do: [:sub |		(sub matchFor: ps withID: id)			ifTrue: [concreteClass := sub]].	concreteClass == nil ifTrue: [concreteClass := SocketAccessor].	"update address families"	SocketAddress initialize.</body></methods><methods><class-id>OS.SocketAccessor class</class-id> <category>constants-protocol</category><body package="OS-Sockets-IPv6">IPPROTO_IPV6	^self defaultClass _ipprotoIpv6</body></methods><methods><class-id>OS.SocketAccessor class</class-id> <category>constants-ipv6 options</category><body package="OS-Sockets-IPv6">IPV6_JOIN_GROUP	"ipv6_mreq argument; add an IPv6 multicast group membership."	^self defaultClass _ipv6JoinGroup</body><body package="OS-Sockets-IPv6">IPV6_LEAVE_GROUP	"ipv6_mreq argument; leave an IPv6 multicast group membership."	^self defaultClass _ipv6LeaveGroup</body><body package="OS-Sockets-IPv6">IPV6_V6ONLY	"Argument is a pointer to boolean int.	If true (non-zero), then socket can only send/receive IPv6 packets, allowing	two sockets to bind to a single port (one IPv4, one IPv6).	If false (zero), the socket can send/receive from IPv6 addresses as well as	IPv4-mapped IPv6 addresses (::ffff:192.168.0.1)."	^self defaultClass _ipv6V6Only</body></methods><methods><class-id>OS.SocketAccessor class</class-id> <category>constants-protocol families</category><body package="OS-Sockets-IPv6">PF_INET6	"Answer protocol family code for Internet protocols v6."	^self defaultClass _pfInet6</body></methods><methods><class-id>OS.AIXSocketAccessor class</class-id> <category>private-ipv6 options</category><body package="OS-Sockets-IPv6">_ipv6JoinGroup	^12</body><body package="OS-Sockets-IPv6">_ipv6LeaveGroup	^13</body><body package="OS-Sockets-IPv6">_ipv6V6Only	^37</body></methods><methods><class-id>OS.AIXSocketAccessor class</class-id> <category>private-protocol families</category><body package="OS-Sockets-IPv6">_pfInet6	^24</body></methods><methods><class-id>OS.WinSocketAccessor class</class-id> <category>private-ipv6 options</category><body package="OS-Sockets-IPv6">_ipv6JoinGroup	^12</body><body package="OS-Sockets-IPv6">_ipv6LeaveGroup	^13</body><body package="OS-Sockets-IPv6">_ipv6V6Only	^27</body></methods><methods><class-id>OS.WinSocketAccessor class</class-id> <category>private-protocol families</category><body package="OS-Sockets-IPv6">_pfInet6	^23</body></methods><methods><class-id>OS.IPSocketAddress class</class-id> <category>class accessing</category><body package="OS-Sockets-IPv6">defaultServerAddressType	^UseIPv6ForDefaultServer		ifTrue: [IPv6SocketAddress]		ifFalse: [IPv4SocketAddress]</body></methods><methods><class-id>OS.IPSocketAddress class</class-id> <category>naming utilities</category><body package="OS-Sockets-IPv6">getaddrinfo: nodenameOrNil service: serviceNameOrNumberOrNil hints: hintsOrNil	"nodenameOrNil is expected to be a string or nil.	serviceNameOrNumberOrNil is expected to be a string or integer or nil.	hintsOrNil is expected to be an IPAddressInfo or nil"	| node service results |	node := nodenameOrNil = nil				ifTrue: [nil]				ifFalse: [IOAccessor convertSimpleStringForPlatform: nodenameOrNil].	service := serviceNameOrNumberOrNil = nil				ifTrue: [nil]				ifFalse: [serviceNameOrNumberOrNil isString					ifTrue: [IOAccessor convertSimpleStringForPlatform: serviceNameOrNumberOrNil]					ifFalse: [IOAccessor convertSimpleStringForPlatform: serviceNameOrNumberOrNil printString]].	results := self				primGetaddrinfo: node				service: service				hints: (hintsOrNil ifNotNil: [:h | h asInfoArray]).	^results collect: 			[:each | | addr |			(each at: 6) ~= nil				ifTrue: 					[each at: 6 put: (IOAccessor convertSimpleStringFromPlatform: (each at: 6))].			addr := each at: 7.			addr rationalizeDomainCode.			each at: 7 put: (SocketAddress canonicalize: addr).			IPAddressInfo fromInfoArray: each]</body></methods><methods><class-id>OS.IPSocketAddress class</class-id> <category>private</category><body package="OS-Sockets-IPv6">primGetaddrinfo: node service: service hints: hints	&lt;primitive: 1644 errorCode: err&gt;	err == nil		ifTrue: [^OSErrorHolder unsupportedOperationSignal raise].	err name = #'bad argument'		ifTrue: [^OSErrorHolder badArgumentsSignal raise].	err name = #'allocation failed'		ifTrue:			[err handleErrorFor: self.			^self primGetaddrinfo: node service: service hints: hints].	"Platform error signifies one of a group of errors specific to getaddrinfo().	Until we have code to distinguish the various specific error codes, assume	all such errors amount to 'no match'."	err name = #'platform error'		ifTrue: [^OSErrorHolder inaccessibleSignal raise].	self error: (#UnexpectedError &lt;&lt; #dialogs &gt;&gt; 'Unexpected error')</body></methods><methods><class-id>OS.IPSocketAddress class</class-id> <category>instance creation</category><body package="OS-Sockets-IPv6">tcpAddressesForHost: hn port: p	"Answer a list of instances valid for the given host name."	| info |	info := IPAddressInfo new socketType: SocketAccessor SOCK_STREAM.	^self getaddrinfo: hn service: p hints: info</body><body package="OS-Sockets-IPv6">udpAddressesForHost: hn port: p	"Answer a list of instances valid for the given host name."	| info |	info := IPAddressInfo new socketType: SocketAccessor SOCK_DGRAM.	^self getaddrinfo: hn service: p hints: info</body></methods><methods><class-id>OS.IPSocketAddress</class-id> <category>private</category><body package="OS-Sockets-IPv6">primGetnameinfo: nodeOrNil service: serviceOrNil flags: intFlagsOrNil	&lt;primitive: 1645 errorCode: err&gt;	err == nil		ifTrue: [^OSErrorHolder unsupportedOperationSignal raise].	err name = #'bad argument'		ifTrue: [^OSErrorHolder badArgumentsSignal raise].	err name = #'allocation failed'		ifTrue:			[err handleErrorFor: self.			^self primGetnameinfo: nodeOrNil service: serviceOrNil flags: intFlagsOrNil].	"err name = #'no match'		ifTrue: [^nil]."	self error: (#UnexpectedError &lt;&lt; #dialogs &gt;&gt; 'Unexpected error')</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>IPSocketAddress</name><environment>OS</environment><super>OS.SocketAddress</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Sockets</category><attributes><package>OS-Sockets</package></attributes></class></st-source>