<?xml version="1.0"?><st-source><!-- Name: Visibility-BindingsNotice: Copyright 2009-2014 Cincom Systems, Inc.  All rights reserved.Comment: Basic visibility protocol for discovering what can be seen from a given NameSpace.	- #isVisibleIn: implemented for classes, namespaces, variables and pundle models.	- Visibility iterators implemented for NameSpace.Uses:	- When resolving names in code imported from a non-namespaced dialect, the domain of visibility of a given NameSpace and its imports acts as the single global Smalltalk namespace of the other dialect.	- When generating code, determining visibility can be used to guide creation of import strings or qualified names.DbIdentifier: bear73DbTrace: 431657DbUsername: nrossDbVersion: 8.0 - 1PackageName: Visibility-BindingsParcel: #('Visibility-Bindings')ParcelName: Visibility-BindingsPrintStringCache: (8.0 - 1,nross)Version: 8.0 - 1Date: 7:51:35 AM May 13, 2014 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.0 (may14.2) of May 13, 2014 on May 13, 2014 at 7:51:35 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><methods><class-id>Core.VariableBinding</class-id> <category>testing</category><body package="Visibility-Bindings">isVisibleIn: aNameSpace	^self == (aNameSpace bindingFor: self key)</body></methods><methods><class-id>Core.Class</class-id> <category>testing</category><body package="Visibility-Bindings">isVisibleIn: aNameSpace	"Does the namespace' binding for my name have me as its value?"	^(aNameSpace at: self name ifAbsent: [^false]) == self</body></methods><methods><class-id>Store.BundleModel</class-id> <category>testing</category><body package="Visibility-Bindings">isVisibleIn: aNameSpace	^self isEmpty or:		[self leafItems anySatisfy:			[ :pkg | pkg isVisibleIn: aNameSpace]]</body></methods><methods><class-id>Kernel.NameSpace</class-id> <category>enumerating</category><body package="Visibility-Bindings">allNameSpacesOfVisibleClasses	"Return every namespace that holds classes we can see."	| all |	all := Set new.	self allVisibleClassesDo: [:each | all add: each environment].	^all</body><body package="Visibility-Bindings">allVisibleClasses	"Return every class which can be obtained by 'self at: simpleName'.  If there are duplicate bindings, return the one that DuplicateBindingError&gt;&gt;defaultAction would return (i.e. the first found).  Note that, like NameSpace&gt;&gt;classes and &gt;&gt;allClasses but unlike BrowserEnvironment&gt;&gt;classes, this does NOT return meta-classes."	| all |	all := Dictionary new.	self namesAndBindingsDo:		[:key :binding | binding isForClass ifTrue:			[all at: binding key ifAbsentPut: [binding value]]].	^all values</body><body package="Visibility-Bindings">allVisibleClassesDo: aBlock	"Evaluate for every class which can be obtained by 'self at: simpleName'.  If there are duplicate bindings, evaluate only for the one that DuplicateBindingError&gt;&gt;defaultAction would return (i.e. the first found).  Note that, like 'SystemUtils allClassesDo:' (and 'Smalltalk allClassesDo:' in VW3) but unlike BrowserEnvironment&gt;&gt;classesDo: and RBNamespace&gt;&gt;allClassesDo:, this only evaluates the block for classes, NOT also for meta-classes."	| all |	all := Set new.	self namesAndBindingsDo:		[:key :binding | binding isForClass ifTrue:			[(all includes: binding key) ifFalse:				[all add: binding key.				aBlock value: binding value]]].</body><body package="Visibility-Bindings">allVisibleClassNames	"Return every symbol which for which 'self at: symbol' returns a class.  Collect in a Set as there may be duplicate bindings."	| all |	all := Set new.	self namesAndBindingsDo:		[:key :binding | binding isForClass ifTrue: [all add: key]].	^all</body></methods><methods><class-id>Kernel.NameSpace</class-id> <category>testing</category><body package="Visibility-Bindings">isVisibleIn: aNameSpace	"Does the namespace' binding for my name have me as its value?"	^(aNameSpace at: self name ifAbsent: [^false]) == self</body></methods><methods><class-id>Kernel.NameSpace</class-id> <category>store utils</category><body package="Visibility-Bindings">makeClasses: someClasses visibleDuring: aBlock	"I support bossing-in objects from VW3 or VA-Boss, which require that every class in the bos file be visible in Smalltalk."	someClasses do:			[:each | Smalltalk addImport:					(SpecificNameSpaceImport pathString: each fullName)].	aBlock ensure:		[someClasses do:			[:each | Smalltalk removeImport:					(SpecificNameSpaceImport pathString: each fullName)]].</body></methods><methods><class-id>Store.PackageModel</class-id> <category>testing</category><body package="Visibility-Bindings">isVisibleIn: aNameSpace	"For speed, we assumes that all packages we care about in the image are consistently visible or not, so we just check the first model.  If the package is empty, treat it as visible."	^self isEmpty or:		[self modelsDo:			[:each |			^(aNameSpace bindingFor: each name) == each fullName asStrictReference binding]]</body></methods><methods><class-id>Core.Metaclass</class-id> <category>testing</category><body package="Visibility-Bindings">isVisibleIn: aNameSpace	"Does the namespace' binding for my name have me as its value?"	^(aNameSpace at: thisClass name ifAbsent: [^false]) == thisClass</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Metaclass</name><environment>Core</environment><super>Core.ClassDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>thisClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>VariableBinding</name><environment>Core</environment><super>Core.LookupKey</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value usage category environment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Support</category><attributes><package>Collections-Support</package></attributes></class><class><name>Class</name><environment>Core</environment><super>Core.ClassDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name classPool environment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>BundleModel</name><environment>Store</environment><super>Store.PundleModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>PackageModel</name><environment>Store</environment><super>Store.PundleModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>models </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>NameSpace</name><environment>Kernel</environment><super>Kernel.GeneralNameSpace</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parent name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Name Spaces</category><attributes><package>System-Name Spaces</package></attributes></class></st-source>