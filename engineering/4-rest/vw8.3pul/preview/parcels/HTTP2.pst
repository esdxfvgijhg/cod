<?xml version="1.0"?><st-source><!-- Name: HTTP2Notice: Copyright 1999-2017 Cincom Systems, Inc.  All rights reserved.Comment: Implements HTTP2 client that supports both HTTP 1.1 and 2 version. The client can be upgrade to HTTP/2 over clear or secure connections.Currently the code is used for testing SiouX server.Send a request over clear HTTP/2 connection:	client := Net.HTTP2Client new.	"client useH2.  Instructs the client to upgrade to HTTP/2 protocol. It is the default option. "	"client useH1.  Instructs the client to use HTTP/1.1 protocol only."	response := client executeRequest: (Net.HttpRequest get:  'http://localhost:5656/test' ).	"Send another message using HTTP/2 protocol"	response := client executeRequest: (Net.HttpRequest get:  'http://localhost:5656/test1' ).Send a request over secure connection:	certificates := Xtreams.TLSCertificateResource current serverCertificates.	clientContext := TLSContext newClientWithDefaults certificates: certificates; yourself.		clientContext suites: TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256.	"The default protocols TLS layer is going to negotiate are: #('h2' 'http/1.1')	If a server supports h2(HTTP/2 version over secure connection) a connection will be using HTTP/2 protocol.	if a server supports only http/1.1 the connection will established with HTTP/1.1 protocol"	alpn := Xtreams.TLSAppLayerProtocolNegotiation defaults.	clientContext extensions: (Array with: alpn).	client := Net.HTTP2Client new.	"Set some settings for HTTP/2 protocol"	client protocolVersion: (Protocols.HTTPv20 new 						settings:  Protocols.HTTP2Settings new;						yourself).	client tlsContext: clientContext.	client tlsSubjectVerifier: [ :cert | true ]. "so that client doesn't signal TLSBadCertificate"	response := client executeRequest: (Net.HttpRequest get:  'https://localhost:5656/test' ).DbIdentifier: bear73DbTrace: 503120DbUsername: tkoganDbVersion: 8.3 - 17DevelopmentPrerequisites: #(#(#any 'Protocols-Http2' '') #(#any 'Xtreams-Core' '') #(#any 'HTTP' '') #(#any 'SiouX-Tools' '') #(#any 'SiouX-Server-Secure' '') #(#any 'Xtreams-Terminals' '') #(#any 'Xtreams-Transforms' ''))PackageName: HTTP2Parcel: #('HTTP2')PrerequisiteDescriptions: #(#(#name 'Protocols-Http2' #componentType #package) #(#name 'Xtreams-Core' #componentType #package) #(#name 'HTTP' #componentType #package) #(#name 'SiouX-Tools' #componentType #package) #(#name 'SiouX-Server-Secure' #componentType #package) #(#name 'Xtreams-Terminals' #componentType #package) #(#name 'Xtreams-Transforms' #componentType #package))PrerequisiteParcels: #(#('Protocols-Http2' '') #('Xtreams-Core' '') #('HTTP' '') #('SiouX-Tools' '') #('SiouX-Server-Secure' '') #('Xtreams-Terminals' '') #('Xtreams-Transforms' ''))PrintStringCache: (8.3 - 17,tkogan)Version: 8.3 - 17Date: 1:18:20 PM July 14, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (jul17.2) of July 14, 2017 on July 14, 2017 at 1:18:20 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>HTTP2PrintHandler</name><environment>Net</environment><super>Net.HttpPrintHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>HTTP2</package></attributes></class><class><name>HTTP2Client</name><environment>Net</environment><super>Net.HttpClient</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Net.*			</imports><category></category><attributes><package>HTTP2</package></attributes></class><comment><class-id>Net.HTTP2Client</class-id><body>HTTP2Client supports both Http/1.1 and Http/2 connections.See the package comments how to use the client</body></comment><class><name>ServerShuttingDown</name><environment>Net</environment><super>Core.Notification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>HTTP2</package></attributes></class><comment><class-id>Net.ServerShuttingDown</class-id><body>The exception is raised when there is an attempt to send a request while the server is shutting down</body></comment><class><name>HTTP2Parser</name><environment>Net</environment><super>Net.HttpParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Xtreams.*			</imports><category></category><attributes><package>HTTP2</package></attributes></class><class><name>HTTP2BuildHandler</name><environment>Net</environment><super>Net.HttpBuildHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>HTTP2</package></attributes></class><class><name>HTTP2ProtocolInterpreter</name><environment>Net</environment><super>Net.HttpProtocolInterpreter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>protocolVersion connectionErrorBlock </inst-vars><class-inst-vars></class-inst-vars><imports>			Protocols.*			</imports><category></category><attributes><package>HTTP2</package></attributes></class><comment><class-id>Net.HTTP2ProtocolInterpreter</class-id><body>HTTP2ProtocolInterpreter supports both Http/1.1 and Http/2 connectionsInstance Variables:	connectionErrorBlock	&lt;BlockClosure&gt;	connection error block	protocolVersion	&lt;HTTPv11 | HTTPv20&gt; protocol version</body></comment><class><name>HTTP2ClientMultiplexer</name><environment>Net</environment><super>Protocols.HTTP2Multiplexer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>readingProcess connectionErrorBlock connectionError reservedStreams sendSynch sendActions sendingProcess </inst-vars><class-inst-vars></class-inst-vars><imports>			private Protocols.*			private SiouX.*			private Xtreams.*			</imports><category></category><attributes><package>HTTP2</package></attributes></class><comment><class-id>Net.HTTP2ClientMultiplexer</class-id><body>HTTP2ClientMultiplexer implements the client HTTP/2 multiplexerInstance Variables:	connectionError	&lt;GenericException&gt;	a connection error	connectionErrorBlock	&lt;BlockClosure&gt;	the block returns connections errors 	process	&lt;Process&gt;	the multiplxer read frames process	reservedStreams	&lt;Integer&gt;	the amount of pushed streams in #reserved state 	sendSynch &lt;Semaphore&gt;	sendActions &lt;SharedQueue&gt;</body></comment><class><name>HTTP2WriteHandler</name><environment>Net</environment><super>Net.HttpWriteHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>boundary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>HTTP2</package></attributes></class><class><name>HTTP2ClientStream</name><environment>Net</environment><super>Protocols.HTTP2Stream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>status responseBlock isReceivingHeaders windowUpdateSemaphore parentStream </inst-vars><class-inst-vars>responseBlock </class-inst-vars><imports>			private Protocols.*			private SiouX.*			</imports><category></category><attributes><package>HTTP2</package></attributes></class><comment><class-id>Net.HTTP2ClientStream</class-id><body>HTTP2ClientStream implements a client flow of frames within the HTTP/2 connectionInstance Variables:	isReceivingHeaders	&lt;Boolean&gt; the flag is on when the client stream receives HEADERS frame	responseBlock	&lt;BlockClosure&gt;	the block returns an HttpResponse	sendDataProcess	&lt;Process&gt;	a process to send a request 	status	&lt;String&gt;	:status pseudo-header field	windowUpdateSemaphore	&lt;Semaphore&gt; signals arrival of WINDOW_UPDATE frame	parentStream &lt;HTTP2Stream&gt; the parent streamClass Instance Variables:	responseBlock &lt;BlockClosure&gt;	the default block returns an HttpResponse</body></comment><methods><class-id>Net.HTTP2PrintHandler</class-id> <category>action callbacks</category><body package="HTTP2">processMessageBody:  aMessage do: aBlock	self stream 		nextPutAll: aMessage body printString;		cr</body><body package="HTTP2">shouldStartBody: aMessageBody	^self headerOnly not and: [aMessageBody notNil ]</body><body package="HTTP2">startMessageBody: aMessage</body></methods><methods><class-id>Net.HTTP2Client</class-id> <category>commands</category><body package="HTTP2">delete: urlString	^self executeRequest: (self requestClass delete: urlString )</body><body package="HTTP2">get: urlString"The GET method means retrieve whatever information (in the form of an entity ) is identified by the urlString""Returns an instance of HttpResponse if succeed or exception"	^self executeRequest: (self requestClass get: urlString )</body><body package="HTTP2">get: anURL formData: aCollectionOfAssociations"Compose and send a GET query"	| data |	data := (aCollectionOfAssociations isKindOf: Dictionary)			ifTrue: [aCollectionOfAssociations associations]			ifFalse: [aCollectionOfAssociations].	^self executeRequest: ((self requestClass get: anURL) formData: data).</body><body package="HTTP2">headers: urlString"The HEAD method is identical to GET except that the server must not return a message body in the response""Returns an instance of HttpResponse if succeed or exception"	^self executeRequest: (self requestClass headers: urlString )</body><body package="HTTP2">post: urlString contents: aString " The POST method is used to request that the destination server accept the specified aString as a new subordinate of the resource identified by the urlStringReturns an instance of HttpResponse if succeed or exception"	^self executeRequest: ((self requestClass post: urlString ) 									contents: aString;									yourself)</body><body package="HTTP2">post: anURL formData: aCollectionOfAssociations	"Send form data sets as prescribed by http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4"	| data |	data := (aCollectionOfAssociations isKindOf: Dictionary)			ifTrue: [aCollectionOfAssociations associations]			ifFalse: [aCollectionOfAssociations].	^self executeRequest: (( self requestClass method: 'POST' url: anURL) 										formData: data;									yourself).</body><body package="HTTP2">put: urlString contents: aString"The PUT method requests that the specified aString be stored under the supplied urlString.Returns an instance of HttpResponse if succeed or exception"	^self executeRequest: ((self requestClass put: urlString )									contents: aString;									yourself)</body></methods><methods><class-id>Net.HTTP2Client</class-id> <category>accessing</category><body package="HTTP2">connectionErrorBlock	^clientPI connectionErrorBlock</body><body package="HTTP2">connectionErrorBlock: aBlock	clientPI connectionErrorBlock: aBlock</body><body package="HTTP2">http2Settings	^self clientPI http2Settings</body><body package="HTTP2">multiplexer	^self clientPI multiplexer</body><body package="HTTP2">protocolVersion	^self clientPI protocolVersion</body><body package="HTTP2">protocolVersion: aProtocolVersion	^self clientPI protocolVersion: aProtocolVersion</body><body package="HTTP2">useH2	self clientPI useH2</body></methods><methods><class-id>Net.HTTP2Client</class-id> <category>services</category><body package="HTTP2">executeRequest: anHttpRequest responseBlock: successBlock	^self clientPI 		executeRequest: anHttpRequest 		responseBlock: successBlock</body><body package="HTTP2">upgradeAndExecute: aRequest" Connect, upgrade to HTTP2, send request, parse response and answer instance of HttpResponse class "		^self clientPI upgradeAndExecute: aRequest</body></methods><methods><class-id>Net.HTTP2Client</class-id> <category>low-level command interface</category><body package="HTTP2">executeRequest: aRequest" Connect, send request and answer HttpResponse "	^self clientPI executeAndGetResponse: aRequest</body></methods><methods><class-id>Net.HTTP2Client class</class-id> <category>default values</category><body package="HTTP2">defaultProtocolInterpreterClassValue	^HTTP2ProtocolInterpreter</body></methods><methods><class-id>Net.HTTP2Parser</class-id> <category>parsing</category><body package="HTTP2">endMessageBody:  aBody from:  aStream	"Apparently when chunking it is allowed to append additional header fields after the chunked body, referred to as a 'trailer'.	Go figure, I wonder how many HTTP stacks can handle that. In any case we will handle it too."	aBody parent isChunked ifTrue: [ self halt.		"Read an optional trailer containing additional entity-header for chunked messages.				There must be at least the terminating CRLF of the chunked body still left on aStream.			       Chunked-Body   = *chunk                  		      last-chunk		                        trailer            		            CRLF		"		[self privateParseHeader: aBody parent header from: aStream] on: Incomplete do: [:ex |] ].	self handler endMessageBody:  aBody</body><body package="HTTP2">parseHeaderFrom: aStream 	| headerx |	headerx := self handler startHeader: nil.	self 		privateParseHeader:   headerx 		from: (self readHeaderSource: aStream).	^self handler endHeader: headerx.</body><body package="HTTP2">parseMultipartBody: aMultipartBody from: aStream	| parent header part boundary |	parent := aMultipartBody parent. 	boundary := parent boundary.		(((aStream closing: []) encoding: #'ISO8859_1') ending:  boundary) -= 0; close.	"Now we'll process boundaries in binary so that the parts can be processed in binary form as well"	boundary := (ByteArray new writing encoding: #'ISO8859_1')					setLineEndCRLF;					put: CR; write: '--'; write:  boundary;					close; terminal.	[			[(aStream read: 2) = #[13 10] ifFalse: [ Incomplete raise ].		part := self handler startPartFor: parent.		header := self parseHeaderFrom: aStream.		self handler addHeader: header toEntity: part. 		self parseBody: part body from: ( aStream ending: boundary ).		self handler endPart: part. 	 	] repeat		] on: Incomplete do: [ :ex | ]</body><body package="HTTP2">readHeaderSource: aStream 	| buffer bufferWriting headerSource stream |	buffer := ByteString newRecycledDefaultSize.	bufferWriting := buffer writing.	stream := (aStream ending: #[13 10 13 10]) encoding: #'ISO8859_1'.	[	bufferWriting 			write: stream; 			put: CR;			put: CR. "Field parser expects CR;CR at the end"		headerSource := buffer copyFrom: 1 to: bufferWriting position.	] ensure: [ 	stream close.				buffer recycle].	^headerSource reading</body><body package="HTTP2">startMessageFrom: aStream	| fLine aString |	aString := ((aStream ending: #[13 10 ]) encoding: #'ISO8859_1') rest.	aString isEmpty 		ifTrue: [^HttpStatusLineError new				messageText: (#EmptyHttpResponseStatusLine &lt;&lt; #net &gt;&gt; 'Can not read external stream, returns empty the Http response status line') asString;				raiseSignal].	fLine := ('http' = (aString copyFrom: 1 to: 4) asLowercase)		ifTrue: [HttpResponseStatusLine readFrom: aString readStream]		ifFalse: [HttpRequestLine readFrom: aString readStream ].	(fLine isNil or: [ fLine isValid not ])		ifTrue: [ ^HttpEntityError new 				messageText: ((#WrongResponseStatusLine &lt;&lt; #net &gt;&gt; 'Wrong response status line: &lt;1s&gt;') expandMacrosWith: fLine printString); 				raiseSignal ].	^self handler startMessage: fLine.</body></methods><methods><class-id>Net.HTTP2BuildHandler</class-id> <category>action callbacks</category><body package="HTTP2">endMessage: aMessage	^aMessage</body><body package="HTTP2">shouldStartMessageBody: aMessageBody 	" Client only"	| message |	message := aMessageBody parent.	message isMimeEntity  ifTrue: [^true].	(self headerOnly or: [message headerOnly]) ifTrue: [ ^false ].	^true</body></methods><methods><class-id>Net.HTTP2BuildHandler</class-id> <category>private prepare streams</category><body package="HTTP2">prepareStream: aStream forMessageBody: anEntity	stream := aStream.	^stream</body><body package="HTTP2">prepareStream: aStream forSimpleBody: aBody	"TO DO zipped contents		^(self shouldBeDecompressed: aBody parent)		ifTrue: [ OS.ZLib.GZipReadStream on:  aStream ]		ifFalse: [aStream]"			^aStream</body></methods><methods><class-id>Net.HTTP2BuildHandler</class-id> <category>private</category><body package="HTTP2">parse: aStream 	stream := aStream.  "encoding: #ISO8859_1."	^self parser parse: stream</body><body package="HTTP2">safelyRead: aBody from: sourceStream into: resultStream	[  		[[resultStream nextPut: sourceStream next] repeat.]			on: Xtreams.Incomplete			do: [ :ex | ]	 ]		on: Error 		do: [ :ex | self handleStartBody: aBody exception: ex ].</body></methods><methods><class-id>Net.HTTP2BuildHandler</class-id> <category>defaults</category><body package="HTTP2">parserClass	^HTTP2Parser</body></methods><methods><class-id>Net.HTTP2ProtocolInterpreter</class-id> <category>printing options</category><body package="HTTP2">newWriter	^HTTP2WriteHandler</body></methods><methods><class-id>Net.HTTP2ProtocolInterpreter</class-id> <category>low-level command interface</category><body package="HTTP2">executeAndGetResponse: aRequest" Connect, send request, parse response and answer instance of HttpResponse class "		request := aRequest.	(request isHttp11 and: [self settings connectionPersists not])		ifTrue: [request connection: 'close'].			self isConnected ifFalse: [ self connect ].	self prepareRequestToSend.	^self protocolVersion executeRequest: aRequest with: self</body><body package="HTTP2">processResponse: anHttpResponse for: anHttpRequest	request := anHttpRequest.	anHttpResponse log.	"Keep the connection always alive  for 1.0 proxy and CONNECT method"	(anHttpResponse isHttp10 and: [anHttpRequest method = 'CONNECT' ])		ifFalse: [ (anHttpResponse isConnectionTransient or: [anHttpRequest isConnectionTransient]) 					ifTrue: [ self close ]]. 	^[			HttpException handleResponse: anHttpResponse.		"response is success "		self registerCookiesFromResponse: anHttpResponse.		self acceptAuthInfoFrom: anHttpResponse.		anHttpResponse	] on: HttpException	 do:  [ :ex | 		(self handleResponseException: ex )			ifNil: [ ex pass ]			ifNotNil: [ :msg | msg ]].</body><body package="HTTP2">writeStream		^self connection writeStream</body></methods><methods><class-id>Net.HTTP2ProtocolInterpreter</class-id> <category>parsing options</category><body package="HTTP2">newBuilder	^HTTP2BuildHandler</body></methods><methods><class-id>Net.HTTP2ProtocolInterpreter</class-id> <category>accessing</category><body package="HTTP2">connection	^self protocolVersion connection</body><body package="HTTP2">http2Settings	^self protocolVersion settings</body><body package="HTTP2">protocolVersion	^protocolVersion ifNil: [self useH2]</body><body package="HTTP2">protocolVersion: aProtocolVersion	protocolVersion := aProtocolVersion</body><body package="HTTP2">responseStream	^self stream</body><body package="HTTP2">settingsFrame	^self protocolVersion settingsFrame</body><body package="HTTP2">stream	^self connection readStream</body><body package="HTTP2">useH1	protocolVersion := HTTPv11 new</body><body package="HTTP2">useH2	^protocolVersion := HTTPv20 new</body></methods><methods><class-id>Net.HTTP2ProtocolInterpreter</class-id> <category>http2 services</category><body package="HTTP2">addHTTP2UpgradeFieldsTo: aRequest" Connect, send request, parse response and answer instance of HttpResponse class "	| stream  |		aRequest addField: ((HeaderField name: 'Connection') 						value: 'Upgrade, HTTP2-Settings';						yourself).						aRequest addField: ((HeaderField name: 'Upgrade')						value: 'h2c';						yourself).		"HTTP2-Settings: &lt;base64url encoding of HTTP/2 SETTINGS payload&gt;"		stream := ByteArray new writing.	self settingsFrame writePayloadOn: stream.	aRequest addField: ((HeaderField name: 'HTTP2-Settings') 						value: stream contents asBase64String;						yourself ).</body><body package="HTTP2">connectionErrorBlock"TO DO: Review if we need this."	^connectionErrorBlock ifNil: [ connectionErrorBlock := [ :error | 		error class new			messageText: error description;			parameter: error parameter;			raise ]]</body><body package="HTTP2">connectionErrorBlock: aBlock	connectionErrorBlock := aBlock.	self multiplexer ifNotNil: [ self multiplexer connectionErrorBlock: aBlock ]</body><body package="HTTP2">executeH1Request: aRequest	| response |	self execute: aRequest withConnection: self connection writeStream.		[response := self readEntityFrom: self responseStream] 		on: Error do: [ :ex | self close. ex pass ].				^self processResponse: response for: aRequest</body><body package="HTTP2">executeH2Request: aRequest	self multiplexer ifNil: [ ^self upgradeAndExecute: aRequest ].	^self promiseResponse: aRequest</body><body package="HTTP2">executeRequest: anHttpRequest responseBlock: successBlock 		request := anHttpRequest.	self isConnected ifFalse: [ self connect ].	self prepareRequestToSend.	^self multiplexer 		executeRequest: anHttpRequest 		responseBlock: successBlock</body><body package="HTTP2">initializeMultiplexer	self protocolVersion initializeClientMultiplexer.	self multiplexer connectionErrorBlock:  self connectionErrorBlock</body><body package="HTTP2">multiplexer	^self protocolVersion multiplexer</body><body package="HTTP2">multiplexer: anHTTP2ClientMultiplexer	self protocolVersion multiplexer: anHTTP2ClientMultiplexer</body><body package="HTTP2">newPromise	^TimedPromise forMilliseconds: self settings timeout.</body><body package="HTTP2">promiseResponse: aRequest	| promise  |	promise := self newPromise.		self multiplexer 		executeRequest: aRequest		responseBlock: [ :response | 			response isSignalledException				ifTrue: [promise value: response]				ifFalse: [						[promise value: (self processResponse: response for: aRequest)] 										on: HttpException										do: [ :ex | promise value: ex. ex return ]]		].	promise value isSignalledException ifTrue: [ 		"Do not close the connection for HTTP2StreamError only"		(HTTP2StreamError handles: promise value) ifFalse: [self close].		promise value class new			messageText: promise value description;			parameter: promise value parameter;			raise].	^promise value</body><body package="HTTP2">upgradeAndExecute: aRequest" Connect, send request, parse response and answer instance of HttpResponse class "	| response |	self addHTTP2UpgradeFieldsTo: aRequest.	[self executeH1Request: aRequest.	self error: 'Failed to upgrade to HTTP2']		on: HttpInformationalError 		do: [ :ex | 			response := ex parameter.			(response code = '101'				and: [(response fieldAt: 'connection' ifAbsent: [nil]) value first = 'Upgrade'					and: [(response fieldAt: 'upgrade' ifAbsent: [nil]) value first = 'h2c']])				ifTrue: [ | promise |					self initializeMultiplexer.					promise := self newPromise.					self multiplexer onFirstStreamResponseBlock: [ :http2Response | promise value: http2Response. ].					self multiplexer startProcess.					^ promise value					] 				ifFalse: [self error: 'Failed to upgrade to HTTP2']].</body></methods><methods><class-id>Net.HTTP2ProtocolInterpreter</class-id> <category>initialize-release</category><body package="HTTP2">connection: aHttpConnection	self protocolVersion connection: aHttpConnection.</body></methods><methods><class-id>Net.HTTP2ProtocolInterpreter</class-id> <category>secure connection</category><body package="HTTP2">useSecureConnection	self connection: SiouX.HttpsConnection new.	self connection settings: self settings</body></methods><methods><class-id>Net.HTTP2ProtocolInterpreter</class-id> <category>connection management</category><body package="HTTP2">connect	self setHostPort.	self setConnection.	(self useProxyForCurrentHost and: [ self connection isSecure])		ifTrue: [self establishSSLConnectionViaProxy ]		ifFalse: [self connectToHost: self hostName port: self portNumber timeout: self timeout ].		(self connection isSecure 		and: [ self connection tlsConnection tlsAppLayerProtocol = 'h2']) 		ifTrue: [self initializeMultiplexer.			self protocolVersion multiplexer startProcess. ]</body><body package="HTTP2">connectToHost: aHostName port: aNumber timeout: tmNumber	 self connection 			openStreamFor: aHostName			port: aNumber			timeout: tmNumber.		self connection initializeClientStreams: self settings</body><body package="HTTP2">disconnect	self connection ifNil: [ ^nil ].	self protocolVersion ifNotNil: [		self protocolVersion resetMultiplexer.		self connection isOpen ifTrue: [ self connection disconnect ].		self connection: nil ].</body><body package="HTTP2">streamHandlerClassFor: aString	self connection ifNotNil: [^self connection].		('http' match: aString)		ifTrue: [ ^self connection: SiouX.HttpConnection new ].	('https' match: aString)		ifFalse: 			[^HttpException  raiseSignal:  ((#UnsupportedProtocol1s &lt;&lt; #net &gt;&gt; 'Unsupported protocol: &lt;1s&gt;')			expandMacrosWith: aString)].	#{SiouX.HttpsConnection} valueOrDo: [OS.URI tryToLoad: 'SiouX-Server-Secure'].	self connection: #{SiouX.HttpsConnection} value new.	self connection settings: self settings.</body></methods><methods><class-id>Net.HTTP2ProtocolInterpreter</class-id> <category>execute request</category><body package="HTTP2">executeRequest: aRequest	request := aRequest.	self isConnected ifFalse: [ self connect ].	^self executeWithConnection: self writeStream</body></methods><methods><class-id>Net.HTTP2ProtocolInterpreter class</class-id> <category>default values</category><body package="HTTP2">defaultNetConnectionValue	^SiouX.HttpConnection</body></methods><methods><class-id>Net.HTTP2ClientMultiplexer</class-id> <category>accessing</category><body package="HTTP2">connectionErrorBlock	^connectionErrorBlock</body><body package="HTTP2">connectionErrorBlock: aBlock	connectionErrorBlock := aBlock</body><body package="HTTP2">decreaseReservedStreams	reservedStreams := reservedStreams - 1.</body><body package="HTTP2">increaseReservedStreams	reservedStreams := reservedStreams + 1.</body><body package="HTTP2">maxReservedStreams	^self protocolVersion settings reservedStreams</body></methods><methods><class-id>Net.HTTP2ClientMultiplexer</class-id> <category>streams handling</category><body package="HTTP2">http2StreamClass	^HTTP2ClientStream</body><body package="HTTP2">minimumStreamId	^1</body><body package="HTTP2">onFirstStreamResponseBlock: aBlock	^(self newStreamFor: 1)		setEndOfHeaders;		setHalfClosedLocal;		responseBlock: aBlock;		yourself</body></methods><methods><class-id>Net.HTTP2ClientMultiplexer</class-id> <category>logging</category><body package="HTTP2">type	^'C'</body></methods><methods><class-id>Net.HTTP2ClientMultiplexer</class-id> <category>private</category><body package="HTTP2">ackTimeoutError		connectionError := super ackTimeoutError.	^connectionError</body><body package="HTTP2">queueFrame: aFrame	self sendFrame: aFrame</body><body package="HTTP2">raiseConnectionError: typeNumber errorString: aStringOrUserMessage	connectionError := HTTP2ConnectionError new					parameter:  (GoawayFrame new								errorCode: typeNumber;								lastStreamID: self lastStreamID;								debugData: aStringOrUserMessage asString;								yourself);					yourself.	connectionErrorBlock value: connectionError.	connectionError raise</body></methods><methods><class-id>Net.HTTP2ClientMultiplexer</class-id> <category>processing frames</category><body package="HTTP2">processGOAWAY: aFrame	"The GOAWAY frame (type=0x7) is used to initiate shutdown of a connection or to signal serious error conditions.  Receivers of a GOAWAY frame MUST NOT open additional streams on the connection, although a new connection can be established for new streams "	aFrame isGracefulShutdown ifTrue: [^state := #gracefulShutdown].	state := #stopping.	connectionError := (aFrame isConnectionError 			ifTrue: [HTTP2ConnectionError new					messageText: ( #ServerConnectionError &lt;&lt; #net &gt;&gt; 'Server connection error');					parameter: aFrame;					yourself]				ifFalse: [ServerShuttingDown new					messageText: (#ServerIsShuttingDown &lt;&lt; #net &gt;&gt;  'Server is shutting down');					parameter: aFrame;					yourself ]).				self connectionErrorBlock value: connectionError.</body><body package="HTTP2">processHEADERS: aHeaderFrame"The HEADERS frame (type=0x1) is used to open a stream"	| stream |	super processHEADERS: aHeaderFrame.	stream := self findStream: aHeaderFrame streamId.	(stream isReserved or: [stream isHalfClosedLocal])		ifFalse: [^HTTP2StreamError 				protocolError: stream id 				errorString: (#ReceivedHeadersInWrongState &lt;&lt; #net &gt;&gt; 'Received HEADERS in a wrong state')].	stream		ifNotNil: [ stream processHEADERS: aHeaderFrame]		ifNil: [^HTTP2StreamError 				protocolError: aHeaderFrame streamId 				errorString: (#ReceivedHEADERSIDNotRegisterd &lt;&lt; #net &gt;&gt; 'Received HEADERS frame with not registered stream id' ) ] .</body><body package="HTTP2">processPRIORITY: aPriorityFrame	HTTP2ConnectionError protocolError: (#ClientHasNoStreamRepriorSupport &lt;&lt; #net &gt;&gt; 'Client doesn''t support Stream Reprioritization')</body><body package="HTTP2">processPUSH_PROMISE: aPushPromise" The PUSH_PROMISE frame includes the unsigned 31-bit identifier of the stream the endpoint plans to create along with a set of headers that provide additional context for the stream. Section 8.2 contains a thorough description of the use of PUSH_PROMISE frames."	| parentStream pushStream |	self localSettings isPushEnabled		ifFalse: ["PUSH_PROMISE MUST NOT be sent if the SETTINGS_ENABLE_PUSH setting of the peer endpoint is set to 0. An endpoint that has set this setting and has received acknowledgement MUST treat the receipt of a PUSH_PROMISE frame as a connection error (Section 5.4.1) of type PROTOCOL_ERROR."		^self 			raiseConnectionError: HTTP2Multiplexer PROTOCOL_ERROR 			errorString: ( #PushPromiseMustNotBeSend &lt;&lt; #net &gt;&gt; 'PUSH_PROMISE MUST NOT be sent. The client SETTINGS_ENABLE_PUSH  is set to 0' )].	aPushPromise promisedStreamId even		ifFalse: [" the server MUST use even-numbered stream identifiers."		^self 			raiseConnectionError: HTTP2Multiplexer PROTOCOL_ERROR 			errorString: ( #PromisedStreamIdNotEven &lt;&lt; #net &gt;&gt; 'PUSH_PROMISE promisedStreamId is not even' )].		parentStream := self findStream: aPushPromise streamId.	(parentStream isNil 		or: [ parentStream notNil 			and: [parentStream isOpen not and: [parentStream isHalfClosedLocal not ]]])		ifTrue: ["A receiver MUST treat the receipt of a PUSH_PROMISE on a stream that is neither #open 			nor #half-closed (local) as a connection error (Section 5.4.1) of type PROTOCOL_ERROR. "			^self 				raiseConnectionError: HTTP2Multiplexer PROTOCOL_ERROR 				errorString: (#ReceivedPushForStreamInWrongState &lt;&lt; #net &gt;&gt; 'Received a PUSH_PROMISE on a stream that is neither #open nor #half-closed (local)') ].			(self findStream: aPushPromise promisedStreamId) ifNotNil: [		"The promised stream MUST be in the #idle state: not registered in our case "		^self 			raiseConnectionError: HTTP2Multiplexer PROTOCOL_ERROR 			errorString: (#ReceivedPushForRegisteredStream &lt;&lt; #net &gt;&gt; 'Received a PUSH_PROMISE on a promised stream that is already registered')		].		"The new stream doesn't change the active streams count"	pushStream := self newReservedStreamFor: aPushPromise promisedStreamId.	self increaseReservedStreams.	reservedStreams &gt; self maxReservedStreams ifTrue: [		pushStream close.		"A client that accepts server push SHOULD limit the number of streams it allows to be in 		the reserved (remote) state. An excessive number of server push streams can be treated 		as a stream error (Section 5.4.2) of type ENHANCE_YOUR_CALM."		^HTTP2StreamError 			enhanceYourCalmError: pushStream id 			errorString: (#NumberReservedStreamExceedsLimit &lt;&lt; #net &gt;&gt; 'Number of reserved streams exceeds the limit')].			self validateHeaderStreamId: aPushPromise promisedStreamId.	pushStream setReservedRemote.	pushStream processPUSH_PROMISE: aPushPromise parent: parentStream.</body><body package="HTTP2">processWINDOW_UPDATE: aFrame	super processWINDOW_UPDATE: aFrame.	(self flowControlWindow remoteAvailable &gt; 0		and: [ sendActions notEmpty ])			ifTrue: [ sendSynch signal ]</body></methods><methods><class-id>Net.HTTP2ClientMultiplexer</class-id> <category>services</category><body package="HTTP2">executeRequest: anHttpRequest responseBlock: aBlock	self isGracefulShutdown ifTrue: ["No more requests. The server is shutting down" 		^aBlock value: (ServerShuttingDown new							messageText: (#ServerShuttingdown &lt;&lt; #net &gt;&gt; 'The server is shutting down');							yourself)].	"There is possible the multiplexer has not completely started "	(self isRunning or: [state = #initializing ]) ifTrue: [		sendActions nextPut: [self newMessageStream							responseBlock: aBlock;							writeFramesFrom: anHttpRequest;							yourself ].					self flowControlWindow remoteAvailable &gt; 0 ifTrue: [ sendSynch signal].		^self].	"The multiplexer is not running, probably because of a connection error"	^aBlock value: (connectionError 					ifNotNil:[ :er | er]					ifNil: [Error new 							messageText:  (#MultiplexerNotRunning &lt;&lt; #net &gt;&gt; 'The multiplexer is not running. Reconnect the client');							yourself]).</body><body package="HTTP2">senderProcessBody	[		sendSynch wait.		sendActions next value = #terminate.	] whileFalse.</body><body package="HTTP2">startProcess	readingProcess := 	[ 				[self start] on: Incomplete do: [:ex |].		] fork.	readingProcess name: 'Client Multiplexer Process'</body><body package="HTTP2">startSendingProcess	(sendingProcess := [self senderProcessBody]		forkAt: Processor systemBackgroundPriority)		name: 'Client Multiplexer Sender'.</body><body package="HTTP2">stop	"There are some streams could wait for responses. If there is an error return it"	state = #closed ifTrue: [^nil].	(connectionError notNil		and: [streams notNil]) ifTrue: [			streams do: [ :str | str isClosed not ifTrue: [ str responseBlock value: connectionError]]].	super stop.	readingProcess ifNotNil: [ 		readingProcess terminate.		readingProcess := nil ].		sendActions nextPut: #terminate.	sendSynch signal.	sendActions notEmpty ifTrue: [ 0.1 seconds wait].		sendingProcess ifNotNil: [ 		sendingProcess terminate.		sendingProcess := nil].	sendActions := nil</body></methods><methods><class-id>Net.HTTP2ClientMultiplexer</class-id> <category>initialize-release</category><body package="HTTP2">handshake	"The client MUST send a connection preface, which includes a SETTINGS frame"	"The client connection preface starts with a sequence of 24 octets"	self writeStream write: ClientPreface.	self writeStream flush.</body><body package="HTTP2">initialize	super initialize.	" Limit the number of streams it allows to be in the reserved (remote) state"	reservedStreams := 0.	sendSynch := Semaphore new.	sendActions := SharedQueue new.	self startSendingProcess</body></methods><methods><class-id>Net.HTTP2WriteHandler</class-id> <category>private prepare streams</category><body package="HTTP2">newChunkedWriteStreamOn: aStream for: aMessage	"The method is used to send first POST 1.1 message "	^(SiouX.ChunkedWriteStream on: aStream) buffering: (self chunkSize ifNil: [4096])</body><body package="HTTP2">prepareStream: aStream	self pushStream: (aStream closing: []).</body><body package="HTTP2">prepareStream: aStream forMessageBody: aMessage	| streamx |	streamx :=  self newChunkedWriteStreamOn: aStream for: aMessage.	self useGZipTransfer ifTrue: [streamx := streamx gzipBestCompressing].	^streamx</body></methods><methods><class-id>Net.HTTP2WriteHandler</class-id> <category>action callbacks</category><body package="HTTP2">endHeader: aMessageHeader	"aMessageHeader   parent isHttpEntity ifFalse: [ self stream cr ]."	self stream cr.	self stream close.	self popStream.	^aMessageHeader parent</body><body package="HTTP2">endMessage: aMessage	self stream close.	self popStream.</body><body package="HTTP2">endMultipartBody: aMessageBody" Prints end of boundary for a multipart message "	self stream 		write: boundary;		write: #[45 45];		write: #[13 10]</body><body package="HTTP2">endPart: aMimeEntity	self stream write: #[13 10]</body><body package="HTTP2">startHeader: aMessageHeader 	"Print part header fields"	self pushStream: (self stream encoding: #ISO8859_1) setLineEndCRLF.	super startHeader: aMessageHeader</body><body package="HTTP2">startMessageBody: aMessage	| streamx |	streamx := self prepareStream: self stream forMessageBody: aMessage.	self pushStream: streamx.	"print preambule if any "	self printPreambule: aMessage body.</body><body package="HTTP2">startMultipartBody: aMultipartBody	boundary := ('--', aMultipartBody parent boundary) asByteArrayEncoding: #'ISO8859_1'.</body><body package="HTTP2">startPart: aMimeEntity	self stream		write: boundary;		write: #[13 10].</body><body package="HTTP2">startRequestLine: aRequestLine with: aHttpEntity 	self pushStream: (self stream encoding: #ISO8859_1) setLineEndCRLF.	self printLine: aRequestLine printString.	self popStream.</body></methods><methods><class-id>Net.HTTP2WriteHandler</class-id> <category>private</category><body package="HTTP2">addContentLength: aNumber entity: anEntity	"Sending chunks only. If we come here it's a bug"	aNumber = 0 ifTrue: [^self].	self halt.</body><body package="HTTP2">setTransferContext: aMimeEntity 	"The Internet Assigned Numbers Authority (IANA) acts as a registry for transfer-coding value tokens. Initially, the registry contains the following tokens: 'chunked',  'identity', 'gzip', 'compress', and 'deflate'Transfer-Encoding: gzipTransfer-Encoding: chunkedIf the printer is set to send a message in gzip format, we will send the message as gzipped and chunked.Multipart messages and big messages are sent as chunked ones "	| coll |	coll := OrderedCollection new.	aMimeEntity isHttpEntity ifFalse: [^coll].	self useGZipTransfer ifTrue: [coll add: TransferEncoding gzipTransfer].	"Sending only in chunked format"	coll add: TransferEncoding  chunkedTransfer.	^coll</body><body package="HTTP2">startSimpleBody: aSimpleBody	|  encoding writeStream readStream |	writeStream := self stream.	aSimpleBody byteSource notNil 		ifTrue: [ readStream := aSimpleBody byteSource reset]		ifFalse: [ readStream := aSimpleBody source reset.			readStream isInternal 				ifTrue: [encoding := aSimpleBody parent charsetIfNone: [#utf8 ].					writeStream := writeStream encoding: encoding asSymbol]].		[readStream atEnd ]		whileFalse: [ writeStream write: readStream next ].</body></methods><methods><class-id>Net.HTTP2WriteHandler</class-id> <category>printing utilities</category><body package="HTTP2">printHeader: aMessageHeader	aMessageHeader removeKey: 'content-length'.	(self  selectFieldsFrom: aMessageHeader )		do: [ :field | self printHeaderField: field ].</body><body package="HTTP2">printLine: aString	self stream write: aString.	self stream cr</body></methods><methods><class-id>Net.HTTP2WriteHandler</class-id> <category>tasks</category><body package="HTTP2">writeFramesFromBody: aMessageBody on: aStream	self pushStream: (aStream closing: []).	aMessageBody acceptVisit: self dispatcher with: nil.</body></methods><methods><class-id>Net.HTTP2ClientStream</class-id> <category>accessing</category><body package="HTTP2">parentStream	^parentStream</body><body package="HTTP2">pseudoHeaderFields	^self isReserved		ifTrue: [ self class requestPseudoHeaders ]		ifFalse: [ self class responsePseudoHeaders ]</body><body package="HTTP2">requestScheme	^httpMessage url protocol</body><body package="HTTP2">requestServerName	^httpMessage url host</body><body package="HTTP2">responseBlock	^responseBlock ifNil: [ self class responseBlock ]</body><body package="HTTP2">status	^status</body></methods><methods><class-id>Net.HTTP2ClientStream</class-id> <category>initialize-release</category><body package="HTTP2">closeRstStreamFrame: aRstStreamFrame	self responseBlock value: (HTTP2StreamError new 								parameter: aRstStreamFrame;								errorString: 'Processing RSTStream frame';								yourself ).	self close</body><body package="HTTP2">initialize	super initialize.	windowUpdateSemaphore := Semaphore new.</body><body package="HTTP2">responseBlock: aBlock	responseBlock := aBlock</body></methods><methods><class-id>Net.HTTP2ClientStream</class-id> <category>read input</category><body package="HTTP2">receivedEOS	self setClosed</body></methods><methods><class-id>Net.HTTP2ClientStream</class-id> <category>testing</category><body package="HTTP2">canAcceptData	^self isHalfClosedLocal</body><body package="HTTP2">isReceivingHeaders	^isReceivingHeaders ifNil: [false]</body><body package="HTTP2">isReserved	^self state = #reserved_remote</body></methods><methods><class-id>Net.HTTP2ClientStream</class-id> <category>private read</category><body package="HTTP2">headersDone	self ensureInputDataStream.</body></methods><methods><class-id>Net.HTTP2ClientStream</class-id> <category>write output</category><body package="HTTP2">createOutputDataStream	outputDataStream ifNotNil: [^self].	(#('GET' 'HEAD' 'DELETE') includes: httpMessage method) ifTrue: [^self].	outputDataStream := HTTP2DATAWriteStream on: self.	HTTP2WriteHandler new			writeFramesFromBody: httpMessage body 			on: outputDataStream.	outputDataStream close.</body><body package="HTTP2">headerFramesDo: aBlock	| tempHeaders |	tempHeaders := OrderedCollection 				with: ((HeaderField name: ':scheme') value: httpMessage protocol )				with: ((HeaderField name: ':method') value: httpMessage method )				with: ((HeaderField name: ':path') value:  httpMessage url pathString ).	"Clients that generate HTTP/2 requests directly SHOULD use the :authority pseudo-header field instead of the Host header field." 	httpMessage host ifNotNil: [ :val |  tempHeaders add: ((HeaderField name: ':authority') value: val ) ].					httpMessage needsBoundary		ifTrue: [httpMessage boundary: '=_vw', Random new next printString, '_=' ].	httpMessage header fields do: [ :field |		field name = 'host' ifFalse: [tempHeaders add: field]].		self setOpen.	self 		writeHeaders: tempHeaders 		do: [ :header :stream | header writeValueOn: stream encoding: httpMessage charset]		onFrame: aBlock.</body><body package="HTTP2">readyToSendData" Calculate the allowed amount of bytes the client can send. If the server the stream control window size is negative/0 wait, otherwise send data frame"	| allowed |	[		allowed := self remoteMaxFrameSize min: self remoteAvailable.		allowed &lt; 1	] 		whileTrue: [windowUpdateSemaphore wait].			outputDataStream		getDataFrameLimited: allowed 		do: [ :frame | 			self flowControlWindow reduceRemoteAvailableBy: frame dataSize.			multiplexer queueFrame: frame.			 frame endOfStream ifTrue: [ self setHalfClosedLocal ] ].</body><body package="HTTP2">writeFrames	self headerFramesDo: [:frame | multiplexer queueFrame: frame].	self sendHeadersOnly ifFalse: [ self createOutputDataStream. ].</body></methods><methods><class-id>Net.HTTP2ClientStream</class-id> <category>processing frames</category><body package="HTTP2">processHEADERS: aHeaderFrame	isReceivingHeaders := true.	self isReserved ifTrue: [		"Receiving a HEADERS frame causes the stream to transition to half-closed (local)"		self setHalfClosedLocal.		self multiplexer decreaseReservedStreams].	super processHEADERS: aHeaderFrame</body><body package="HTTP2">processPUSH_PROMISE: aPushPromise parent: aParentStream	aPushPromise endOfHeaders ifFalse: [		"CONTINUATION for PUSH_PROMISE currently not supported "		^HTTP2StreamError 			refusedStreamError: self id			errorString: (#ContinuationForPushPromiseNoSupport &lt;&lt; #net &gt;&gt; 'Continuation for Push_Promise frame currently is not supported')		].	parentStream := aParentStream.	responseBlock := aParentStream responseBlock.	inputHeadersStream := HTTP2FrameReadStream on: self multiplexer newRecycledFrameBuffer.	[			self readHeaderBlockFragment: aPushPromise.		self hpackDecoder on: inputHeadersStream.		self decodeHeader.	]		ensure: [ inputHeadersStream recycleWith: self multiplexer ].</body><body package="HTTP2">processWINDOW_UPDATE: aNumber	flowControlWindow processWINDOW_UPDATE: aNumber.	windowUpdateSemaphore signal</body></methods><methods><class-id>Net.HTTP2ClientStream</class-id> <category>state</category><body package="HTTP2">setReservedRemote	state := #reserved_remote</body></methods><methods><class-id>Net.HTTP2ClientStream</class-id> <category>dispatching process</category><body package="HTTP2">dispatchMessage"	On client, the inputDataStream itself will become the source for a response once finished."	| builder response|	self decodeHeader.	builder := HTTP2BuildHandler new.	response := Net.HttpResponse code: self status.	self isPushed ifTrue: [ response fieldValueAt: 'Push' put: 'true'].	response writingOptions printerClass: HTTP2PrintHandler.	builder setEntity: response.		[		self headers do: [ :h | 			response addField: ( HeaderField fromLine: (h first, ': ', h last asString) )].		builder parser 			parseMessageBody: response 			from: inputDataStream.		self responseBlock value: response	] on: Error 	do: [ :ex | 		ex parameter: self.		self multiplexer logAnnounceError: ex.		self responseBlock value: ex.		self close		].</body></methods><methods><class-id>Net.HTTP2ClientStream</class-id> <category>parsing headers</category><body package="HTTP2">anyPseudoHeaderNil	^self isReserved		ifTrue: [ self anyRequestPseudoHeaderNil]		ifFalse: [ self anyResponsePseudoHeaderNil ]</body><body package="HTTP2">anyResponsePseudoHeaderNil	^status == nil</body><body package="HTTP2">setEndOfHeaders	super setEndOfHeaders.	isReceivingHeaders := false</body><body package="HTTP2">status: aString	status == nil ifFalse: [		^self streamProtocolError: (#ReceivedDuplicateStatus &lt;&lt; #net &gt;&gt;  'Received duplicate :status' )].	status := aString</body><body package="HTTP2">validateAuthority	"The server MUST include a value in the :authority pseudo-header field for which 	the server is authoritative (see Section 10.1). A client MUST treat a PUSH_PROMISE 	for which the server is not authoritative as a stream error (Section 5.4.2) of type PROTOCOL_ERROR"	self authority ifNil: [		^self streamProtocolError: (#PushPromiseMissingAuthority &lt;&lt; #net &gt;&gt; 'Push_Promise frame is missing required :authority pseudo-header')].			"The authority identified within the target URI  to be the most appropriate response 	for that request given the state of the target resource at the time of response message origination"	(self serverName = self parentStream requestServerName 			and: [self scheme = self parentStream requestScheme]) ifFalse: [		^self streamProtocolError: (#PushPromiseWrongAuthority &lt;&lt; #net &gt;&gt; 'Push_Promise authority is  a non-authoritative source')].</body><body package="HTTP2">validateHeaders		^self isReserved		ifTrue: [ self validateRequestHeaders ]		ifFalse: [self validateResponseHeaders]</body><body package="HTTP2">validateRequestHeaders	super validateRequestHeaders.		self validateAuthority.			self method ~= self pushMethod ifTrue: [		" If a client receives a PUSH_PROMISE that does not include the :method pseudo-header field or 		identifies a method that is not safe, it MUST respond with a stream error (Section 5.4.2) 		of type PROTOCOL_ERROR"		^self streamProtocolError: (#PushPromiseNotSafeMethod &lt;&lt; #net &gt;&gt; 'Promised requests MUST be cacheable and safe')		]</body><body package="HTTP2">validateResponseHeaders"For HTTP/2 responses, a single :status pseudo-header field is defined that carries the HTTP status code field. This pseudo-header field MUST be included in all responses; otherwise, the response is malformed.Malformed requests or responses that are detected MUST be treated as a stream error (Section 5.4.2) of type PROTOCOL_ERROR"			status == nil ifTrue: [ 		self streamProtocolError: (#ResponseHeaderMissingStatus &lt;&lt; #net &gt;&gt; 'The response is missing required :status pseudo-header' )].</body></methods><methods><class-id>Net.HTTP2ClientStream class</class-id> <category>defaults</category><body package="HTTP2">responseBlock	^responseBlock ifNil: [ [ :r | "nothing by default"]]</body><body package="HTTP2">responseBlock: aBlock	responseBlock := aBlock</body></methods><methods><class-id>Net.HttpResponse</class-id> <category>testing</category><body package="HTTP2">isPushed	^(self fieldAt: 'Push' ifAbsent: [nil]) 		ifNil: [ false]		ifNotNil: [ :f | f value = 'true' ]</body></methods><methods><class-id>SiouX.HttpsConnection</class-id> <category>initialize-release</category><body package="HTTP2">initializeClientStreams: aSettings" TODO Net.TLSConnection  defaults "	| tlsContext tlsSubjectVerifier |	super initializeClientStreams: aSettings.	tlsContext := 	aSettings tlsContext 			ifNotNil: [ :cxt | cxt ]			ifNil: [" self class defaultTLSContext" self error: 'Expected  tlsContext in Settings'].	tlsSubjectVerifier := aSettings tlsSubjectVerifier						ifNotNil: [ :block | block ]						ifNil: [self error: 'Expected tlsSubjectVerifier in Settings'].				tlsConnection := tlsContext newConnectionReading: readStream writing: writeStream.		tlsConnection connect: [ :cert | tlsSubjectVerifier cull: cert cull: self ].		readStream := tlsConnection reading.		writeStream := tlsConnection writing</body></methods><methods><class-id>Protocols.HTTP2Settings class</class-id> <category>accessing</category><body package="HTTP2">reservedStreams	" A client option "	^reservedStreams ifNil: [ reservedStreams := self reservedStreamsDefaultValue]</body><body package="HTTP2">reservedStreams: anInteger	" A client option "	reservedStreams := anInteger</body><body package="HTTP2">reservedStreamsDefaultValue	^100</body></methods><methods><class-id>Protocols.HTTP2Settings</class-id> <category>accessing</category><body package="HTTP2">reservedStreams	^reservedStreams ifNil: [reservedStreams := self class reservedStreams]</body><body package="HTTP2">reservedStreams: anInteger	reservedStreams := anInteger</body></methods><methods><class-id>Xtreams.TLSClientContext</class-id> <category>services</category><body package="HTTP2">sniHostNames	^(self extensions detect: [ :each | each code = TLSServerName code ] ifNone: [ nil ])		ifNotNil: [ :ext | ext hostNames ]		ifNil: [ #() ]</body></methods><methods><class-id>Xtreams.EncodeReadStream</class-id> <category>accessing</category><body package="HTTP2">nextLine	^(self ending: CR) rest</body></methods><methods><class-id>Protocols.HTTPv11</class-id> <category>services</category><body package="HTTP2">executeRequest: aRequest with: aProtocolInterpreter	aProtocolInterpreter executeH1Request: aRequest</body></methods><methods><class-id>SiouX.HttpConnection</class-id> <category>initialize-release</category><body package="HTTP2">accepts: url	^url protocol = 'http'</body><body package="HTTP2">disconnect	self releaseStreams.	socket close.</body><body package="HTTP2">initializeClientStreams: aSettings	writeStream := socket writing buffering: DefaultBufferSize.	readStream := socket reading: aSettings timeout milliseconds.</body></methods><methods><class-id>SiouX.HttpConnection</class-id> <category>accessing</category><body package="HTTP2">isConnected	^socket notNil</body></methods><methods><class-id>SiouX.HttpConnection</class-id> <category>initialize-release</category><body package="HTTP2">openStreamFor: aHost port: aPortNumber timeout: tmNumber   |  exhaustedAllChoices |     exhaustedAllChoices := false.     [    (IPSocketAddress tcpAddressesForHost: aHost port: (aPortNumber ifNil: [80]))             detect: [ :info |                 [    socket := SocketAccessor family: info family type: info socketType protocol: info protocol.                     [ socket connectTo: info address ] ifCurtailed: [ socket close ].                     true                 ] on: OsError do: [ :ex | false ] ]             ifNone: [ exhaustedAllChoices := true ]     ]    onTimeout: tmNumber milliseconds         do: [ OSErrorHolder operationStartedSignal raiseSignal ].	exhaustedAllChoices ifTrue: [OsInaccessibleError raiseSignal].		self initializeId.</body></methods><methods><class-id>SiouX.HttpConnection</class-id> <category>accessing</category><body package="HTTP2">settings: anObject"Is used by NetProtocolIntepreter"</body></methods><methods><class-id>Protocols.HTTPv20</class-id> <category>services</category><body package="HTTP2">executeRequest: aRequest with: aProtocolInterpreter	^aProtocolInterpreter executeH2Request: aRequest</body></methods><methods><class-id>Protocols.HTTPv20</class-id> <category>initialize-release</category><body package="HTTP2">initializeClientMultiplexer 	multiplexer := Net.HTTP2ClientMultiplexer connectionPreface: self.	^multiplexer</body><body package="HTTP2">resetMultiplexer	multiplexer ifNotNil: [ multiplexer stop].	multiplexer := nil</body></methods><methods><class-id>SiouX.WebBasicSettingsDomain class</class-id> <category>pages</category><body package="HTTP2">h2ClientAnnouncementsPage	&lt;settingsPage: #(www debug clientAnnouncements)  position: 110&gt;	^(H2MultiplexerAnnouncementTool multiplexer: Net.HTTP2ClientMultiplexer )		label: #H2ClientAnnouncements &lt;&lt; #labels &gt;&gt; 'H2 Client Announcements';		icon: ((SiouX.ServerIcons visualFor: #Browser_16x16));		yourself</body></methods><methods><class-id>SiouX.WebBasicSettingsDomain class</class-id> <category>settings-http2 debug</category><body package="HTTP2">logH2ClientAnnouncement	&lt;setting: #(www debug logClient)  position: 20 &gt;	^(BooleanSetting on: Net.HTTP2ClientMultiplexer aspect: #isLogging)		default: false;		label: #LogH2ClientToTranscript &lt;&lt; #www &gt;&gt; 'Log client multiplexer announcements to Transcript';		helpText: #LogH2ClientToTranscriptHelp &lt;&lt; #store &gt;&gt; 'Start logging HTTP2 client multiplexer announcements to Transcript'</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>HttpConnection</name><environment>SiouX</environment><super>SiouX.Connection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>persist protocolVersion </inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.*			private Kernel.*			</imports><category></category><attributes><package>SiouX-Server</package></attributes></class><class><name>HttpsConnection</name><environment>SiouX</environment><super>SiouX.HttpConnection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tlsConnection </inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.OsTransferFaultError			</imports><category></category><attributes><package>SiouX-Server-Secure</package></attributes></class><class><name>HttpResponse</name><environment>Net</environment><super>Net.HttpEntity</super><private>false</private><indexed-type>none</indexed-type><inst-vars>statusLine </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><class><name>HttpBuildHandler</name><environment>Net</environment><super>Net.MimeParserHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>decompressContents decodeContents </class-inst-vars><imports>			OS.ZLib.*			</imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><class><name>HttpParser</name><environment>Net</environment><super>Net.MimeParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.IOConstants.*			</imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><class><name>EncodeReadStream</name><environment>Xtreams</environment><super>Xtreams.ReadStream</super><private>true</private><indexed-type>none</indexed-type><inst-vars>transparent crPreceeding encoder buffer bufferWriting bufferReading </inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.IOConstants.*			</imports><category></category><attributes><package>Xtreams-Transforms</package></attributes></class><class><name>HTTP2Stream</name><environment>Protocols</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>multiplexer headers id inputDataStream state endOfHeaders dispatchProcess flowControlWindow inputHeadersStream trailerHeader trailerHeaders contentLength inputDataSize outputDataStream httpMessage dataBytesSent method scheme authority path </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Protocols-Http2</package></attributes></class><class><name>HTTPv20</name><environment>Protocols</environment><super>Protocols.ProtocolVersion</super><private>false</private><indexed-type>none</indexed-type><inst-vars>multiplexer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Protocols-Http2</package></attributes></class><class><name>HTTP2Multiplexer</name><environment>Protocols</environment><super>Core.Announcer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>streams streamId state hpackEncoder hpackDecoder remoteSettings protocolVersion flowControlWindow updatedSettings accessMutex lastStream activeStreams ackTimeout recyclingCenter </inst-vars><class-inst-vars>announcementPrinter </class-inst-vars><imports>			private Protocols.*			private Xtreams.*			</imports><category></category><attributes><package>Protocols-Http2</package></attributes></class><class><name>HTTPv11</name><environment>Protocols</environment><super>Protocols.ProtocolVersion</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Protocols-Http</package></attributes></class><class><name>HttpProtocolInterpreter</name><environment>Net</environment><super>Net.NetProtocolInterpreter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>authPolicy proxyAuthPolicy cookieAgent request hostName portNumber readingOptions writingOptions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HTTP</category><attributes><package>HTTP</package></attributes></class><class><name>HttpClient</name><environment>Net</environment><super>Net.NetClient</super><private>false</private><indexed-type>none</indexed-type><inst-vars>request protocol </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><class><name>HttpWriteHandler</name><environment>Net</environment><super>Net.MimeWriteHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bodySize </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><class><name>Notification</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>HttpPrintHandler</name><environment>Net</environment><super>Net.MimePrintHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Net-MIME-Support</category><attributes><package>HTTP</package></attributes></class><class><name>TLSClientContext</name><environment>Xtreams</environment><super>Xtreams.TLSContext</super><private>false</private><indexed-type>none</indexed-type><inst-vars>clientCertificateSelector </inst-vars><class-inst-vars>clientCertificateSelector </class-inst-vars><imports>			private OS.OSHandle			</imports><category>Xtreams-TLS</category><attributes><package>TLS</package></attributes></class><class><name>HTTP2Settings</name><environment>Protocols</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>settingsFrame outputWindowSize ackTimeout reservedStreams </inst-vars><class-inst-vars>settingsFrame outputWindowSize reservedStreams </class-inst-vars><imports></imports><category></category><attributes><package>Protocols-Http2</package></attributes></class></st-source>