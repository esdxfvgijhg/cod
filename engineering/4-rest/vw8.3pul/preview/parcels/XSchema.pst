<?xml version="1.0"?><st-source><!-- Name: XSchemaNotice: Copyright 1999-2013 Cincom Systems, Inc.  All rights reserved.DbIdentifier: bear73DbTrace: 400510DbUsername: nrossDbVersion: 7.10 - 1DevelopmentPrerequisites: #(#(#any 'XPath' ''))PackageName: XSchemaParcel: #('XSchema')ParcelName: XSchemaPrerequisiteParcels: #(#('XPath' ''))PrintStringCache: (7.10 - 1,nross)Version: 7.10 - 1Date: 6:44:15 AM April 3, 2013 --><time-stamp>From VisualWorksÂ®, Pre-Release 7.10 (mar13.5) of April 3, 2013 on April 3, 2013 at 6:44:15 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>SchemaElement</name><environment>XML</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name refName id schema schemaHolder parts namespaces extraAttributes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XSchema</category><attributes><package>XSchema</package></attributes></class><class><name>IdentityConstraint</name><environment>XML</environment><super>XML.SchemaElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XSchema</category><attributes><package>XSchema</package></attributes></class><class><name>RestrictionRefinement</name><environment>XML</environment><super>XML.SchemaElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value valueString restriction </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XSchema</category><attributes><package>XSchema</package></attributes></class><class><name>RegExpNode</name><environment>XML</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>successor quantifier </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XSchema</category><attributes><package>XSchema</package></attributes></class><class><name>RegExpEmpty</name><environment>XML</environment><super>XML.RegExpNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XSchema</category><attributes><package>XSchema</package></attributes></class><class><name>Selector</name><environment>XML</environment><super>XML.SchemaElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>xpath </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XSchema</category><attributes><package>XSchema</package></attributes></class><class><name>Extension</name><environment>XML</environment><super>XML.SchemaElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>base </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XSchema</category><attributes><package>XSchema</package></attributes></class><class><name>SchemaState</name><environment>XML</environment><super>Core.Link</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name isAttribute keys refs matchedNodes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XSchema</category><attributes><package>XSchema</package></attributes></class><class><name>ElementContentSpecification</name><environment>XML</environment><super>XML.SchemaElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>min max </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XSchema</category><attributes><package>XSchema</package></attributes></class><class><name>Empty</name><environment>XML</environment><super>XML.ElementContentSpecification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XSchema</category><attributes><package>XSchema</package></attributes></class><class><name>RegExpParser</name><environment>XML</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>source </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XSchema</category><attributes><package>XSchema</package></attributes></class><class><name>Choice</name><environment>XML</environment><super>XML.ElementContentSpecification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XSchema</category><attributes><package>XSchema</package></attributes></class><class><name>Any</name><environment>XML</environment><super>XML.ElementContentSpecification</super><private>false</private><indexed-type>none</indexed-type><inst-vars>processContents namespace </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XSchema</category><attributes><package>XSchema</package></attributes></class><class><name>ComplexContent</name><environment>XML</environment><super>XML.ElementContentSpecification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XSchema</category><attributes><package>XSchema</package></attributes></class><class><name>TimeDescription</name><environment>XML</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>year month day hour minute second timeZone </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XSchema</category><attributes><package>XSchema</package></attributes></class><class><name>Duration</name><environment>XML</environment><super>XML.TimeDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XSchema</category><attributes><package>XSchema</package></attributes></class><class><name>List</name><environment>XML</environment><super>XML.SchemaElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>itemTypeName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XSchema</category><attributes><package>XSchema</package></attributes></class><class><name>AttributeSpecification</name><environment>XML</environment><super>XML.SchemaElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>typeName use value fixedValue form </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XSchema</category><attributes><package>XSchema</package></attributes></class><class><name>KeyRef</name><environment>XML</environment><super>XML.SchemaElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>refer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XSchema</category><attributes><package>XSchema</package></attributes></class><class><name>AnyAttribute</name><environment>XML</environment><super>XML.SchemaElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>processContents namespace </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XSchema</category><attributes><package>XSchema</package></attributes></class><class><name>Include</name><environment>XML</environment><super>XML.SchemaElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>uri </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XSchema</category><attributes><package>XSchema</package></attributes></class><class><name>SimpleContent</name><environment>XML</environment><super>XML.ElementContentSpecification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XSchema</category><attributes><package>XSchema</package></attributes></class><class><name>Schema</name><environment>XML</environment><super>XML.SchemaElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>objects baseUri attributeFormDefault elementFormDefault blockDefault </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XSchema</category><attributes><package>XSchema</package></attributes></class><class><name>Group</name><environment>XML</environment><super>XML.ElementContentSpecification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XSchema</category><attributes><package>XSchema</package></attributes></class><class><name>Type</name><environment>XML</environment><super>XML.SchemaElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parentType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XSchema</category><attributes><package>XSchema</package></attributes></class><class><name>NotationSpecification</name><environment>XML</environment><super>XML.SchemaElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XSchema</category><attributes><package>XSchema</package></attributes></class><class><name>ComplexType</name><environment>XML</environment><super>XML.Type</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mixed cachedPartical cachedAttributes block </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XSchema</category><attributes><package>XSchema</package></attributes></class><class><name>DateTime</name><environment>XML</environment><super>XML.TimeDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XSchema</category><attributes><package>XSchema</package></attributes></class><class><name>Documentation</name><environment>XML</environment><super>XML.SchemaElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XSchema</category><attributes><package>XSchema</package></attributes></class><class><name>Sequence</name><environment>XML</environment><super>XML.ElementContentSpecification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XSchema</category><attributes><package>XSchema</package></attributes></class><class><name>Union</name><environment>XML</environment><super>XML.SchemaElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>memberTypes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XSchema</category><attributes><package>XSchema</package></attributes></class><class><name>RegExpTest</name><environment>XML</environment><super>XML.RegExpNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>test negated </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XSchema</category><attributes><package>XSchema</package></attributes></class><class><name>UniqueOrKey</name><environment>XML</environment><super>XML.SchemaElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>isKey </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XSchema</category><attributes><package>XSchema</package></attributes></class><class><name>RegExpLiteral</name><environment>XML</environment><super>XML.RegExpNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XSchema</category><attributes><package>XSchema</package></attributes></class><class><name>SimpleType</name><environment>XML</environment><super>XML.Type</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XSchema</category><attributes><package>XSchema</package></attributes></class><class><name>BaseSimpleType</name><environment>XML</environment><super>XML.SimpleType</super><private>false</private><indexed-type>none</indexed-type><inst-vars>evaluateBlock validateBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XSchema</category><attributes><package>XSchema</package></attributes></class><class><name>SchemaAnnotation</name><environment>XML</environment><super>XML.SchemaElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XSchema</category><attributes><package>XSchema</package></attributes></class><class><name>ElementSpecification</name><environment>XML</environment><super>XML.ElementContentSpecification</super><private>false</private><indexed-type>none</indexed-type><inst-vars>typeName abstract nillable form fixed final substitutionGroup block </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XSchema</category><attributes><package>XSchema</package></attributes></class><class><name>SchemaHandler</name><environment>XML</environment><super>XML.SAXDriver</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stack classMap schemaHolder newNamespaces nsStack uri </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XSchema</category><attributes><package>XSchema</package></attributes></class><class><name>Field</name><environment>XML</environment><super>XML.SchemaElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>xpath </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XSchema</category><attributes><package>XSchema</package></attributes></class><class><name>All</name><environment>XML</environment><super>XML.ElementContentSpecification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XSchema</category><attributes><package>XSchema</package></attributes></class><class><name>AttributeGroupSpecification</name><environment>XML</environment><super>XML.SchemaElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XSchema</category><attributes><package>XSchema</package></attributes></class><class><name>RegExpOr</name><environment>XML</environment><super>XML.RegExpTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XSchema</category><attributes><package>XSchema</package></attributes></class><class><name>Redefine</name><environment>XML</environment><super>XML.SchemaElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>uri includedSchema </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XSchema</category><attributes><package>XSchema</package></attributes></class><class><name>Import</name><environment>XML</environment><super>XML.SchemaElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>targetNamespace uri </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XSchema</category><attributes><package>XSchema</package></attributes></class><class><name>Restriction</name><environment>XML</environment><super>XML.SchemaElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>baseTypeName baseType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XSchema</category><attributes><package>XSchema</package></attributes></class><shared-variable><name>BaseTypes</name><environment>XML.Schema</environment><private>false</private><constant>false</constant><category>Base Types</category><attributes><package>XSchema</package></attributes></shared-variable><methods><class-id>XML.SchemaElement</class-id> <category>construction</category><body package="XSchema">addAttributesTo: type stack: stack	^self</body><body package="XSchema">addElement: aSchemaElement	parts add: aSchemaElement</body><body package="XSchema">internalValidation	"For use by subclasses. Once the element has been constructed, check to see	that it conforms to a valid syntax. This cannot include testing references to other	schema elements if the definitions do not occur within the element. That comes	when the entire Schema is sent the message #internalValidation"</body><body package="XSchema">noteElementTag: aString	"Ignored by many SchemaElements"	^self</body><body package="XSchema">processAttributes: attributes	attributes do: [:attr |		self processSingleAttribute: attr].</body><body package="XSchema">processSingleAttribute: attr	^self subclassResponsibility</body><body package="XSchema">registerName	self parts do: [:i | i registerNameFrom: self].</body><body package="XSchema">registerNameFrom: aSchemaElement	self parts do: [:i | i registerNameFrom: aSchemaElement].</body><body package="XSchema">resolveReferences	^self</body><body package="XSchema">validateParent: aSchemaElement	(name == nil or: [(aSchemaElement isKindOf: Schema)			or: [aSchemaElement isKindOf: Redefine]])		ifFalse: [self error: self class name, ': Named components can only occur at the top level of a schema'].	(refName notNil and: [(aSchemaElement isKindOf: Schema)			or: [aSchemaElement isKindOf: Redefine]])		ifTrue: [self error: self class name, ': Referenced components cannot occur at the top level of a schema'].</body></methods><methods><class-id>XML.SchemaElement</class-id> <category>initialize</category><body package="XSchema">initialize	parts := OrderedCollection new.	extraAttributes := #()</body><body package="XSchema">namespaces: nsStack	namespaces := nsStack</body><body package="XSchema">schema	^self schemaHolder value</body><body package="XSchema">schemaHolder	^schemaHolder</body><body package="XSchema">schemaHolder: aSchemaHolder	schemaHolder := aSchemaHolder</body></methods><methods><class-id>XML.SchemaElement</class-id> <category>accessing</category><body package="XSchema">extraAttributes	^extraAttributes</body><body package="XSchema">name	name == nil		ifTrue: [^refName]		ifFalse: [^name]</body><body package="XSchema">parts	^parts</body></methods><methods><class-id>XML.SchemaElement</class-id> <category>private</category><body package="XSchema">attributeNotRecognized: attr	attr tag namespace = ''		ifFalse: [^extraAttributes := extraAttributes copyWith: attr].	self halt: self class name, (': Attribute &lt;1s&gt; not recognized' expandMacrosWith: attr tag asString)</body><body package="XSchema">collapseSpaces: string	| str str2 |	str := string copy.	[str2 := str copyReplaceAll: '  ' with: ' '.	str = str2] whileFalse: [str := str2].	(str isEmpty not and: [str first = Character space])		ifTrue: [str := str copyFrom: 2 to: str size].	(str isEmpty not and: [str last = Character space])		ifTrue: [str := str copyFrom: 1 to: str size-1].	^str</body><body package="XSchema">isDocument	^false</body><body package="XSchema">nameOfElement: elm	^elm tag copy</body><body package="XSchema">parseSimpleXPath: value	^XPathParser new		xmlNode: self;		parse: value as: #unionExpr</body><body package="XSchema">readBoolean: aValue	(aValue = 'true' or: [aValue = '1']) ifTrue: [^true].	(aValue = 'false' or: [aValue = '0']) ifTrue: [^false].	self error: 'Value of a boolean attribute is not boolean'.</body><body package="XSchema">readQName: str in: aNode	| index qualifier local ns nd |	index := str indexOf: $:.	index = 0		ifTrue:			[qualifier := ''.			local := str]		ifFalse:			[qualifier := str copyFrom: 1 to: index-1.			local := str copyFrom: index+1 to: str size].	(aNode isKindOf: SchemaElement)		ifTrue: [ns := aNode namespaceAt: qualifier]		ifFalse:			[nd := aNode.			[nd isDocument] whileFalse:				[ns == nil ifTrue: [ns := nd namespaceAt: qualifier].				nd := nd parent].			ns == nil				ifTrue: [qualifier = ''					ifTrue: [ns := '']					ifFalse: [self error: 'The qualifier for this name has not been mapped to a namespace'. ^nil]]].	^NodeTag new qualifier: qualifier ns: ns type: local</body><body package="XSchema">replaceSpaces: string	| str |	str := string copy.	str replaceAll: Character cr with: Character space.	str replaceAll: Character lf with: Character space.	str replaceAll: Character tab with: Character space.	^str</body><body package="XSchema">schemaNS	^'http://www.w3.org/2001/XMLSchema'</body><body package="XSchema">skipWhitespace: anXmlNodeStream	| node |	[anXmlNodeStream atEnd ifTrue: [^self].	anXmlNodeStream peek isElement]		whileFalse:			[node := anXmlNodeStream next.			(node isText and: [node isBlankText not])				ifTrue: [self error: 'Elements which are defined to take element content must not contain non-blank text']]</body><body package="XSchema">xsd: string	^NodeTag new qualifier: 'xsi' ns: self schemaNS type: string</body><body package="XSchema">xsi: string	^NodeTag new qualifier: 'xsi' ns: self xsiNS type: string</body><body package="XSchema">xsiNS	^'http://www.w3.org/2001/XMLSchema-instance'</body></methods><methods><class-id>XML.SchemaElement</class-id> <category>processing names</category><body package="XSchema">namespaceAt: qualifier	| asc ns |	asc := namespaces.	[asc == nil] whileFalse:		[asc key == nil			ifFalse:				[ns := asc key at: qualifier ifAbsent: [].				ns == nil ifFalse: [^ns]].		asc := asc value].	^(qualifier = '$' or: [qualifier = ''])		ifTrue: ['']		ifFalse: [self halt: 'The qualifier for this name has not been mapped to a namespace']</body><body package="XSchema">processNCName: aName	| ns |	self validateNCName: aName.	ns := self namespaceAt: '$'.	^NodeTag new qualifier: '' ns: ns type: aName</body><body package="XSchema">processQName: aName	| idx qualifier local ns |	(aName includes: $:)		ifFalse:			[ns := self namespaceAt: ''.			self validateNCName: aName.			^NodeTag new qualifier: '' ns: ns type: aName].	idx := aName indexOf: $:.	qualifier := aName copyFrom: 1 to: idx-1.	self validateNCName: qualifier.	local := aName copyFrom: idx+1 to: aName size.	self validateNCName: local.	ns := self namespaceAt: qualifier.	^NodeTag new qualifier: qualifier ns: ns type: local</body><body package="XSchema">validateNCName: aName	| c |	aName isEmpty ifTrue: [self error: 'An NCName cannot be empty'].	((CharacterClasses at: aName first asInteger+1) bitAnd: 4) = 4		ifFalse: [self error: 'The first letter of an NCName must start with a valid starting character'].	2 to: aName size do: [:i |		c := aName at: i.		((CharacterClasses at: c asInteger+1) bitAnd: 2) = 2			ifFalse: [self error: 'Letters in an NCName must be valid NCName characters']].</body></methods><methods><class-id>XML.SchemaElement</class-id> <category>validation</category><body package="XSchema">isType	^false</body><body package="XSchema">pushIdConstraint: schemaState</body></methods><methods><class-id>XML.SchemaElement class</class-id> <category>private</category><body package="XSchema">matchesTag: aTag	^self tagName = aTag</body><body package="XSchema">tagName	"Must be overridden by subclasses that represent specifically	named elements in an XML Schema."	^nil</body></methods><methods><class-id>XML.SchemaElement class</class-id> <category>instance creation</category><body package="XSchema">new	^super new initialize</body></methods><methods><class-id>XML.RestrictionRefinement</class-id> <category>accessing</category><body package="XSchema">baseType	^restriction baseType</body></methods><methods><class-id>XML.RestrictionRefinement</class-id> <category>initialize</category><body package="XSchema">restriction: aRestriction	restriction := aRestriction</body></methods><methods><class-id>XML.RestrictionRefinement</class-id> <category>private</category><body package="XSchema">fractionDigitsOf: aValue	aValue isInteger ifTrue: [^0].	aValue class = FixedPoint ifTrue: [^aValue scale].	self halt: 'Fraction digits not yet implemented for this data type'</body><body package="XSchema">integerValue	| s |	value == nil ifFalse: [^value].	value := self schema readPositiveIntegerFrom: (s := valueString readStream).	s atEnd ifFalse: [self error: 'Expected valid integer as value of a facet'].	^value</body><body package="XSchema">matchPattern: characterData	value == nil		ifTrue: [value := RegExpParser new parse: valueString readStream].	^value match: characterData</body><body package="XSchema">sizeOf: anObject	(anObject isKindOf: Collection) ifTrue: [^anObject size].	anObject class = NodeTag ifTrue: [^anObject asString size].	self halt: 'Not yet implemented'</body><body package="XSchema">totalDigitsOf: aValue	aValue isInteger ifTrue: [^aValue abs printString size].	aValue class = FixedPoint ifTrue:		[^aValue printString inject: 0 into: [:i :j | i + (j isDigit ifTrue: [1] ifFalse: [0])]].	self halt: 'Total digits not yet implemented for this data type'</body><body package="XSchema">valueInType	value == nil ifFalse: [^value].	^value := restriction evaluate: valueString in: self</body></methods><methods><class-id>XML.RestrictionRefinement</class-id> <category>validation</category><body package="XSchema">preprocess: string priority: priority	| key str |	key := self name type.	(priority = 1 and: [key = 'whiteSpace'])		ifTrue: [valueString = 'preserve'			ifTrue: [^string]			ifFalse:				[str := self replaceSpaces: string.				valueString = 'replace' ifTrue: [^str].				valueString = 'collapse' ifFalse: [self error: 'Invalid value for whiteSpace facet'].				str := self collapseSpaces: str.				^str]].	^string</body><body package="XSchema">validate: aNode attributes: attributes elements: elementStream state: schemaState	^self validate: aNode value: aNode characterData state: schemaState</body><body package="XSchema">validate: anElement value: aString state: schemaState	(self validateBlock value: anElement value: aString)		ifFalse: [self error: 'A type restriction ', self name asString, '(', valueString, ') was not satisfied'].</body><body package="XSchema">validateBlock	| key |	key := self name type.	key = 'maxInclusive'		ifTrue: [^[:elm :str | (self valueOf: str in: elm) &lt;= self valueInType]].	key = 'maxExclusive'		ifTrue: [^[:elm :str | (self valueOf: str in: elm) &lt; self valueInType]].	key = 'minInclusive'		ifTrue: [^[:elm :str | (self valueOf: str in: elm) &gt;= self valueInType]].	key = 'minExclusive'		ifTrue: [^[:elm :str | (self valueOf: str in: elm) &gt; self valueInType]].	key = 'pattern'		ifTrue: [^[:elm :str | self matchPattern: str]].	key = 'fractionDigits'		ifTrue: [^[:elm :str | (self fractionDigitsOf: (self valueOf: str in: elm)) &lt;= self integerValue]].	key = 'totalDigits'		ifTrue: [^[:elm :str | (self totalDigitsOf: (self valueOf: str in: elm)) &lt;= self integerValue]].	key = 'enumeration'		ifTrue: [^[:elm :str | self notYetImplemented. true]].	key = 'whiteSpace'		ifTrue: [^[:elm :str | true]].	key = 'maxLength'		ifTrue: [^[:elm :str | (self sizeOf: (self valueOf: str in: elm)) &lt;= self integerValue]].	key = 'minLength'		ifTrue: [^[:elm :str | (self sizeOf: (self valueOf: str in: elm)) &gt;= self integerValue]].	key = 'length'		ifTrue: [^[:elm :str | (self sizeOf: (self valueOf: str in: elm)) = self integerValue]].	^[:elm :str | self halt: 'Restriction not yet implemented']</body><body package="XSchema">valueOf: aString in: aNode	^self baseType evaluate: aString in: aNode</body></methods><methods><class-id>XML.RestrictionRefinement</class-id> <category>construction</category><body package="XSchema">noteElementTag: aString	name := NodeTag new qualifier: '' ns: '' type: aString</body><body package="XSchema">processSingleAttribute: attr	attr tag type = 'value'		ifTrue:			[valueString := attr value.			^self].	self attributeNotRecognized: attr</body><body package="XSchema">validateParent: aSchemaElement	(aSchemaElement isKindOf: Restriction)		ifFalse: [self error: 'Facet elements can only occur inside restriction elements'].</body><body package="XSchema">value: aString	value := aString</body></methods><methods><class-id>XML.RestrictionRefinement class</class-id> <category>private</category><body package="XSchema">matchesTag: aTag	^#('enumeration' 'length' 'fractionDigits'	'minExclusive' 'minInclusive' 'minLength'	'maxExclusive' 'maxInclusive' 'maxLength'	'pattern' 'totalDigits' 'whiteSpace') includes: aTag</body></methods><methods><class-id>XML.RegExpNode</class-id> <category>testing</category><body package="XSchema">baseMatchFrom: stream	^self foo subclassResponsibility</body><body package="XSchema">isEmpty	^false</body><body package="XSchema">match: aString	| stream |	stream := aString readStream.	(self matchFrom: stream) ifFalse: [^false].	^stream atEnd</body><body package="XSchema">matchFrom: stream	| p |	quantifier first timesRepeat:		[(self baseMatchFrom: stream)			ifFalse: [^false]].	quantifier size-1 timesRepeat:		[p := stream position.		(self baseMatchFrom: stream)			ifFalse:				[stream position: p.				(successor == nil or: [successor matchFrom: stream])					ifFalse: [^false].				^true]].	^successor == nil or: [successor matchFrom: stream]</body></methods><methods><class-id>XML.RegExpNode</class-id> <category>accessing</category><body package="XSchema">quantifier: quantity	quantifier := quantity</body><body package="XSchema">successor	^successor</body><body package="XSchema">successor: node	successor == nil		ifTrue: [successor := node]		ifFalse: [successor successor: node]</body></methods><methods><class-id>XML.RegExpNode</class-id> <category>construction</category><body package="XSchema">initialize	quantifier := #(1)</body><body package="XSchema">| aNode	^RegExpOr new		add: self;		add: aNode</body></methods><methods><class-id>XML.RegExpNode class</class-id> <category>instance creation</category><body package="XSchema">new	^super new initialize</body></methods><methods><class-id>XML.RegExpEmpty</class-id> <category>testing</category><body package="XSchema">baseMatchFrom: stream	^self halt</body><body package="XSchema">isEmpty	^true</body></methods><methods><class-id>XML.Selector</class-id> <category>accessing</category><body package="XSchema">xpath	^xpath</body></methods><methods><class-id>XML.Selector</class-id> <category>construction</category><body package="XSchema">processSingleAttribute: attr	attr tag type = 'xpath'		ifTrue:			[xpath := self parseSimpleXPath: attr value.			^self].	self attributeNotRecognized: attr</body></methods><methods><class-id>XML.Selector class</class-id> <category>private</category><body package="XSchema">tagName	^'selector'</body></methods><methods><class-id>XML.Extension</class-id> <category>construction</category><body package="XSchema">processSingleAttribute: attr	attr tag type = 'base'		ifTrue:			[base := self processQName: attr value.			^self].	self attributeNotRecognized: attr</body></methods><methods><class-id>XML.Extension class</class-id> <category>private</category><body package="XSchema">tagName	^'extension'</body></methods><methods><class-id>XML.SchemaState</class-id> <category>accessing</category><body package="XSchema">keyrefs	^refs</body><body package="XSchema">keys	^keys</body><body package="XSchema">matchedNodes	^matchedNodes</body></methods><methods><class-id>XML.SchemaState</class-id> <category>initialize</category><body package="XSchema">beAttribute	isAttribute := true</body><body package="XSchema">initialize	keys := #().	refs := #().	matchedNodes := #().	isAttribute := false</body><body package="XSchema">name: nm	name := nm</body></methods><methods><class-id>XML.SchemaState</class-id> <category>stack operations</category><body package="XSchema">addKey: aKey	keys := keys copyWith: aKey -&gt; Dictionary new</body><body package="XSchema">addKeyRef: aKeyRef	refs := refs copyWith: aKeyRef -&gt; Dictionary new</body><body package="XSchema">addMatch: keyInstance in: keyScopeState	matchedNodes := matchedNodes copyWith: (Array			with: keyInstance			with: keyScopeState			with: (Array new: keyInstance key fields size))</body><body package="XSchema">checkIdConstraintsAfter	| idConstraint idScope tuple |	matchedNodes do: [:ndList |		idConstraint := ndList at: 1.		idScope := ndList at: 2.		tuple := ndList at: 3.		(tuple includes: nil)			ifTrue: [idConstraint key constraintType = #key				ifTrue: [self error: 'An element which is constrained by a key does not supply all of the fields required by the key']]			ifFalse:				[idConstraint key registerKey: tuple in: idConstraint value.				idConstraint key propogateKeyrefs: tuple for: idScope]].	refs do: [:k |		k key checkConsistency: k value].</body><body package="XSchema">checkIdConstraintsBefore: elm	| state idConstraint idScope tuple |	state := self.	[state == nil] whileFalse:		[state keys do: [:k |			(self match: k key selector stopAt: state)				ifTrue: [self addMatch: k in: state]].		state keyrefs do: [:k |			(self match: k key selector stopAt: state)				ifTrue: [self addMatch: k in: state]].		state := state nextLink].	state := self.	[state == nil] whileFalse:		[state matchedNodes do: [:ndList |			idConstraint := ndList at: 1.			idScope := ndList at: 2.			tuple := ndList at: 3.			idConstraint key fields with: (1 to: tuple size) do: [:field :idx |				(self match: field stopAt: state)					ifTrue: [(tuple at: idx) == nil						ifTrue: [tuple at: idx put: elm characterData notYetImplemented]						ifFalse: [self error: 'A field in a tuple maps to more than one value']]]].		state := state nextLink].</body><body package="XSchema">match: selector stopAt: state	| match |	match := selector		schemaMatch: self		terminateAt: state.	^match</body><body package="XSchema">pushContext: nm	^self class new		nextLink: self;		name: nm</body></methods><methods><class-id>XML.SchemaState</class-id> <category>testing</category><body package="XSchema">isAttribute	^isAttribute</body><body package="XSchema">isElement	^isAttribute not</body><body package="XSchema">parent	^nextLink</body><body package="XSchema">tag	^name</body></methods><methods><class-id>XML.SchemaState class</class-id> <category>instance creation</category><body package="XSchema">new	^super new initialize</body></methods><methods><class-id>XML.ElementContentSpecification</class-id> <category>accessing</category><body package="XSchema">max	^max = nil ifTrue: [1] ifFalse: [max]</body><body package="XSchema">min	^min = nil ifTrue: [1] ifFalse: [min]</body></methods><methods><class-id>XML.ElementContentSpecification</class-id> <category>validation</category><body package="XSchema">checkText: elm	elm characterData do: [:c |		c isSeparator ifFalse: [self error: 'Elements must be separated by blank text']]</body><body package="XSchema">findMatchesFor: elm stack: stack incomplete: incomplete complete: complete	self halt</body><body package="XSchema">findTerminatorInStack: stack incomplete: incomplete complete: complete	self halt</body><body package="XSchema">pop: stack into: incomplete	stack removeLast.	stack isEmpty ifFalse: [incomplete add: stack].</body><body package="XSchema">validate: aNode attributes: attributes elements: elementStream state: schemaState	| incomplete complete match test stack top elm |	incomplete := OrderedCollection with: (OrderedCollection with: (Array with: self with: 0 with: 0)).	[elementStream atEnd] whileFalse:		[elm := elementStream next.		elm isElement			ifTrue:				[complete := OrderedCollection new.				[incomplete isEmpty] whileFalse:					[match := incomplete removeFirst.					match last first						findMatchesFor: elm						stack: match						incomplete: incomplete						complete: complete.					incomplete size &gt; 100 ifTrue: [self halt]].				complete isEmpty					ifTrue: [self error: 'No match for element named ', elm tag asString].				complete size = 1					ifFalse:						[test := complete collect: [:i | i last first].						test := IdentitySet withAll: test.						test size &gt; 1 ifTrue: [self halt: 'Ambiguous definition found for element']].				stack := complete first.				top := stack last.				top first instanceValidation: elm state: schemaState.				incomplete := complete]			ifFalse: [elm isText				ifTrue: [self checkText: elm]				ifFalse: [elm isComment					ifFalse: [self halt]]]].	incomplete isEmpty ifTrue: [self halt].	complete := OrderedCollection new.	[incomplete isEmpty] whileFalse:		[match := incomplete removeFirst.		match last first			findTerminatorInStack: match			incomplete: incomplete			complete: complete].	complete isEmpty		ifTrue: [self error: 'This element''s content ended prematurely'].</body></methods><methods><class-id>XML.Empty</class-id> <category>validation</category><body package="XSchema">validate: aNode attributes: attributes elements: elementStream state: schemaState	elementStream atEnd		ifFalse: [self error: 'This element is declared to be empty']</body></methods><methods><class-id>XML.RegExpParser</class-id> <category>parsing</category><body package="XSchema">atom	| ch p |	ch := source next.	ch == nil ifTrue: [^RegExpEmpty new].	('^.\?*+(){}|[]' includes: ch)		ifTrue:			[ch == nil ifFalse: [source skip: -1].			p := self charClassEsc.			p == nil ifFalse: [^p].			p := self charClassExpr.			p == nil ifFalse: [^p].			(source peekFor: $()				ifTrue:					[p := self regExp.					(source peekFor: $))						ifFalse: [self error: 'Expected )'].					^p].			(source peek = $| or: [source peek = $)])				ifTrue: [^RegExpEmpty new]				ifFalse: [^self halt notYetImplemented]]		ifFalse: [^RegExpLiteral new value: (String with: ch)]</body><body package="XSchema">branch	| p next |	p := self piece.	p isEmpty ifTrue: [^p].	[(next := self piece) isEmpty not]		whileTrue: [p successor: next].	^p</body><body package="XSchema">charClassEsc	| c |	(source peekFor: $\)		ifTrue:			[c := self singleCharEsc.			c == nil				ifFalse: [^RegExpLiteral new value: (String with: c)].			(source peekFor: $s) ifTrue: [^RegExpTest new test: [:ch | ch isSeparator]].			(source peekFor: $i)				ifTrue: [^RegExpTest new					test: [:ch | ch = $: or: [((CharacterClasses at: ch asInteger+1) bitAnd: 4) &gt; 0]]].			(source peekFor: $c)				ifTrue: [^RegExpTest new					test: [:ch | ch = $: or: [((CharacterClasses at: ch asInteger+1) bitAnd: 2) &gt; 0]]].			(source peekFor: $d) ifTrue: [^RegExpTest new test: [:ch | ch isDigit]].			Transcript cr; show: source peek printString.			self halt notYetImplemented].	(source peekFor: $.)		ifTrue:			[^RegExpTest new test: [:ch | ch ~= Character cr and: [ch ~= Character lf]]].	^nil</body><body package="XSchema">charClassExpr	| neg p |	(source peekFor: $[)		ifTrue:			[neg := source peekFor: $^.			p := self posCharGroup.			neg ifTrue: [p negated].			(source peekFor: $-)				ifTrue: [self halt].			(source peekFor: $])				ifFalse: [self halt: 'No matching ] found for a [ in a pattern'].			^p].	^nil</body><body package="XSchema">charRange	| ch start end |	ch := source peek.	(ch = $- or: [ch = $]])		ifTrue: [^nil].	ch := source next.	ch = $[		ifTrue: [self error: 'Invalid character in a posCharGroup'].	ch = $\		ifTrue:			[start := self singleCharEsc.			start == nil ifTrue: [self error: 'Expected a singleCharEsc in a posCharGroup']]		ifFalse: [start := ch].	(source peekFor: $-)		ifTrue:			[ch := source next.			(ch = $[ or: [ch = $]])				ifTrue: [self error: 'Invalid character in a posCharGroup'].			ch = $\				ifTrue:					[end := self singleCharEsc.					end == nil						ifTrue: [self error: 'Expected a singleCharEsc in a posCharGroup']]				ifFalse: [end := ch].			^RegExpTest new test: [:c | c between: start and: end]]		ifFalse: [^RegExpLiteral new value: (String with: start)]</body><body package="XSchema">integer	| n |	(source atEnd not and: [source peek isDigit])		ifFalse: [^nil].	n := 0.	[source atEnd not and: [source peek isDigit]]		whileTrue:			[n := n*10 + source next digitValue].	^n</body><body package="XSchema">parse: stream	source := stream.	^self regExp</body><body package="XSchema">piece	| p |	p := self atom.	p isEmpty ifTrue: [^p].	p quantifier: self quantifier.	^p</body><body package="XSchema">posCharGroup	| p p2 |	p := self charClassEsc.	p == nil ifTrue: [p := self charRange].	p == nil ifTrue: [self error: 'posCharGroup not found'].	[p2 := self charClassEsc.	p2 == nil ifTrue: [p2 := self charRange].	p2 == nil]		whileFalse: [p := p | p2].	^p</body><body package="XSchema">quantifier	| infinity start end |	infinity := 1.0d20.	(source peekFor: $?) ifTrue: [^#(0 1)].	(source peekFor: $*) ifTrue: [^(0 to: infinity)].	(source peekFor: $+) ifTrue: [^(1 to: infinity)].	(source peekFor: ${)		ifTrue:			[start := self integer.			start == nil ifTrue: [self error: 'No integer found in a pattern quantifier'].			(source peekFor: $,)				ifTrue: [end := self integer]				ifFalse: [end := start].			end = nil ifTrue: [end := infinity].			(source peekFor: $})				ifFalse: [self error: 'Expected }'].			^start to: end].	^#(1)</body><body package="XSchema">regExp	| p |	p := RegExpOr new add: self branch.	[source peekFor: $|]		whileTrue: [p := p | self branch].	^p</body><body package="XSchema">singleCharEsc	| c |	c := source next.	c == nil ifTrue: [self error: 'In a pattern, \ must be followed by a character'].	c = $n ifTrue: [^Character lf].	c = $r ifTrue: [^Character cr].	c = $t ifTrue: [^Character tab].	('\|.-^?*+{}()[]' includes: c)		ifTrue: [^c].	source skip: -1.	^nil</body></methods><methods><class-id>XML.Choice</class-id> <category>validation</category><body package="XSchema">findMatchesFor: elm stack: stack incomplete: incomplete complete: complete	| count |	count := stack last at: 2.	count &gt; self max		ifTrue: [^self pop: stack into: incomplete].	stack last at: 2 put: count+1.	parts do: [:p |		stack add: (Array with: p with: 0 with: 0).		p findMatchesFor: elm			stack: (stack collect: [:f | f copy])			incomplete: incomplete			complete: complete.		stack removeLast].	stack last at: 2 put: count.	count &gt;= self min		ifTrue: [self pop: stack into: incomplete].</body><body package="XSchema">findTerminatorInStack: stack incomplete: incomplete complete: complete	| count |	count := stack last at: 2.	count &lt; self min		ifFalse:			[stack removeLast.			^stack isEmpty				ifTrue: [complete add: stack]				ifFalse: [incomplete add: stack]].	stack last at: 2 put: count+1.	parts do: [:p |		stack add: (Array with: p with: 0 with: 0).		p findTerminatorInStack: (stack collect: [:f | f copy])			incomplete: incomplete			complete: complete.		stack removeLast].	stack last at: 2 put: count.</body></methods><methods><class-id>XML.Choice</class-id> <category>construction</category><body package="XSchema">processSingleAttribute: attr	attr tag type = 'minOccurs'		ifTrue:			[min := attr value asNumber.			^self].	attr tag type = 'maxOccurs'		ifTrue:			[max := attr value = 'unbounded' ifTrue: [1.0e20] ifFalse: [attr value asNumber].			^self].	self attributeNotRecognized: attr</body></methods><methods><class-id>XML.Choice class</class-id> <category>private</category><body package="XSchema">tagName	^'choice'</body></methods><methods><class-id>XML.Any</class-id> <category>validation</category><body package="XSchema">findMatchesFor: elm stack: stack incomplete: incomplete complete: complete	| count |	count := stack last at: 2.	(self match: elm tag namespace)		ifFalse: [count &lt; self min			ifTrue: [^self]			ifFalse: [^self pop: stack into: incomplete]].	count &gt;= self max		ifTrue: [^self pop: stack into: incomplete].	stack last at: 2 put: count+1.	complete add: (stack collect: [:f | f copy]).</body><body package="XSchema">findTerminatorInStack: stack incomplete: incomplete complete: complete	| count |	count := stack last at: 2.	count &lt; self min		ifFalse:			[stack removeLast.			stack isEmpty				ifTrue: [complete add: stack]				ifFalse: [incomplete add: stack]].</body><body package="XSchema">instanceValidation: elm state: schemaState	| elmSchema |	processContents = 'skip'		ifTrue: [self skipValidation: elm state: schemaState]		ifFalse:			[elmSchema := processContents = 'lax'				ifTrue: [self schema object: #element at: elm tag ifAbsent: []]				ifFalse: [self schema object: #element at: elm tag].			elmSchema == nil				ifTrue: [self skipValidation: elm state: schemaState]				ifFalse: [elmSchema instanceValidation: elm state: schemaState]].</body><body package="XSchema">match: instanceNS	(namespace = nil or: [namespace = '##any'])		ifTrue: [^true].	namespace = '##other'		ifTrue: [^instanceNS ~= self schema targetNamespace].	namespace = '##targetNamespace'		ifTrue: [^instanceNS = self schema targetNamespace].	namespace = '##local'		ifTrue: [^instanceNS = ''].	(namespace includes: Character space)		ifFalse: [^instanceNS = namespace].	self halt: 'namespace wildcard not yet implemented'</body><body package="XSchema">skipValidation: elm state: schemaState	| stateElm stateAttr |	stateElm := schemaState pushContext: elm tag.	stateElm checkIdConstraintsBefore: elm.	elm attributes do: [:attr |		stateAttr := stateElm pushContext: attr tag.		stateAttr beAttribute.		stateAttr checkIdConstraintsBefore: attr.		stateAttr checkIdConstraintsAfter].	elm children do: [:e |		e isElement			ifTrue: [self skipValidation: e state: stateElm]].	stateElm checkIdConstraintsAfter.</body></methods><methods><class-id>XML.Any</class-id> <category>construction</category><body package="XSchema">processSingleAttribute: attr	attr tag type = 'minOccurs'		ifTrue:			[min := attr value asNumber.			^self].	attr tag type = 'maxOccurs'		ifTrue:			[max := attr value = 'unbounded' ifTrue: [1.0e20] ifFalse: [attr value asNumber].			^self].	attr tag type = 'processContents'		ifTrue:			[processContents := attr value.			(#('skip' 'lax' 'strict') includes: processContents) ifFalse:				[self halt: 'processContents attribute has an invalid value'].			^self].	attr tag type = 'namespace'		ifTrue:			[namespace := attr value.			^self].	self attributeNotRecognized: attr</body></methods><methods><class-id>XML.Any class</class-id> <category>private</category><body package="XSchema">tagName	^'any'</body></methods><methods><class-id>XML.ComplexContent</class-id> <category>validation</category><body package="XSchema">validate: aNode attributes: attributes elements: elementStream state: schemaState	Transcript show: '[] '</body></methods><methods><class-id>XML.ComplexContent class</class-id> <category>private</category><body package="XSchema">tagName	^'complexContent'</body></methods><methods><class-id>XML.TimeDescription</class-id> <category>accessing</category><body package="XSchema">day	^day</body><body package="XSchema">day: aNumber	day := aNumber</body><body package="XSchema">hour	^hour</body><body package="XSchema">hour: aNumber	hour := aNumber</body><body package="XSchema">minute	^minute</body><body package="XSchema">minute: aNumber	minute := aNumber</body><body package="XSchema">month	^month</body><body package="XSchema">month: aNumber	month := aNumber</body><body package="XSchema">second	^second</body><body package="XSchema">second: aNumber	second := aNumber</body><body package="XSchema">timeZone	^timeZone</body><body package="XSchema">timeZone: aNumber	timeZone := aNumber</body><body package="XSchema">year	^year</body><body package="XSchema">year: aNumber	year := aNumber</body></methods><methods><class-id>XML.TimeDescription</class-id> <category>comparing</category><body package="XSchema">&lt; aTimeDescription	| a b |	self class = aTimeDescription class		ifFalse: [self shouldNotImplement].	self timeZone isNil = aTimeDescription timeZone isNil		ifFalse:			[self halt: 'Not yet implemented'.			^false].	self timeZone = aTimeDescription timeZone		ifTrue: [a := self. b := aTimeDescription]		ifFalse:			[a := self normalized.			b := aTimeDescription normalized].	a year isNil = b year isNil		ifTrue: [a year ~= b year ifTrue: [^a year &lt; b year]]		ifFalse: ["These two are not well ordered" ^true].	a month isNil = b month isNil		ifTrue: [a month ~= b month ifTrue: [^a month &lt; b month]]		ifFalse: ["These two are not well ordered" ^true].	a day isNil = b day isNil		ifTrue: [a day ~= b day ifTrue: [^a day &lt; b day]]		ifFalse: ["These two are not well ordered" ^true].	a hour isNil = b hour isNil		ifTrue: [a hour ~= b hour ifTrue: [^a hour &lt; b hour]]		ifFalse: ["These two are not well ordered" ^true].	a minute isNil = b minute isNil		ifTrue: [a minute ~= b minute ifTrue: [^a minute &lt; b minute]]		ifFalse: ["These two are not well ordered" ^true].	a second isNil = b second isNil		ifTrue: [a second ~= b second ifTrue: [^a second &lt; b second]]		ifFalse: ["These two are not well ordered" ^true].	^false</body><body package="XSchema">= aTimeDescription	| a b |	self class = aTimeDescription class		ifFalse: [^false].	self timeZone isNil = aTimeDescription timeZone isNil		ifFalse:			[self halt: 'Not yet implemented'.			^false].	self timeZone = aTimeDescription timeZone		ifTrue: [a := self. b := aTimeDescription]		ifFalse:			[a := self normalized.			b := aTimeDescription normalized].	a year ~= b year ifTrue: [^false].	a month ~= b month ifTrue: [^false].	a day ~= b day ifTrue: [^false].	a hour ~= b hour ifTrue: [^false].	a minute ~= b minute ifTrue: [^false].	a second ~= b second ifTrue: [^false].	^true</body><body package="XSchema">hash	^self year hash</body></methods><methods><class-id>XML.List</class-id> <category>validation</category><body package="XSchema">evaluate: aString in: aNode	| str strings |	str := self collapseSpaces: (self replaceSpaces: aString).	^str isEmpty		ifTrue: [#()]		ifFalse:			[strings := str tokensBasedOn: Character space.			strings collect: [:strPart |				self itemType halt; evaluate: strPart in: aNode]].</body><body package="XSchema">preprocess: string priority: priority	| val |	val := string.	val := self itemType preprocess: val priority: priority.	^val</body><body package="XSchema">validate: aNode value: aString state: schemaState	| str strings |	str := self collapseSpaces: (self replaceSpaces: aString).	str isEmpty		ifFalse:			[strings := str tokensBasedOn: Character space.			strings do: [:strPart |				self itemType validate: aNode value: strPart state: schemaState]].</body></methods><methods><class-id>XML.List</class-id> <category>construction</category><body package="XSchema">processSingleAttribute: attr	attr tag type = 'itemType'		ifTrue:			[itemTypeName := self processQName: attr value.			^self].	self attributeNotRecognized: attr</body></methods><methods><class-id>XML.List</class-id> <category>accessing</category><body package="XSchema">itemType	itemTypeName == nil ifFalse: [^self schema typeAt: itemTypeName].	^self parts detect: [:p | p isType]		ifNone: [self schema typeAt: (NodeTag new qualifier: 'xsd' ns: self schemaNS type: 'anyType')]</body></methods><methods><class-id>XML.List class</class-id> <category>private</category><body package="XSchema">tagName	^'list'</body></methods><methods><class-id>XML.AttributeSpecification</class-id> <category>accessing</category><body package="XSchema">isWild	^false</body><body package="XSchema">type	typeName == nil ifFalse: [^self schema typeAt: typeName].	refName == nil ifFalse: [^(self schema object: #attribute at: refName) type].	^self parts detect: [:p | p isType]		ifNone: [self schema typeAt: (NodeTag new				qualifier: 'xsd'				ns: self schemaNS				type: 'anySimpleType')]</body></methods><methods><class-id>XML.AttributeSpecification</class-id> <category>construction</category><body package="XSchema">addAttributesTo: type stack: stack	type addAttribute: self.</body><body package="XSchema">processSingleAttribute: attr	attr tag type = 'name'		ifTrue:			[name := self processNCName: attr value.			name type = 'xmlns' ifTrue: [self error: 'Attribute tag cannot be "xmlns"'].			^self].	attr tag type = 'id'		ifTrue:			[id := attr value.			^self].	attr tag type = 'ref'		ifTrue:			[refName := self processQName: attr value.			^self].	attr tag type = 'type'		ifTrue:			[typeName := self processQName: attr value.			^self].	attr tag type = 'use'		ifTrue:			[use := attr value.			^self].	attr tag type = 'default'		ifTrue:			[value := attr value.			fixedValue := false.			^self].	attr tag type = 'fixed'		ifTrue:			[value := attr value.			fixedValue := true.			^self].	attr tag type = 'value'		ifTrue:			[value := attr value.			^self].	attr tag type = 'form'		ifTrue:			[form := attr value.			(#('qualified' 'unqualified') includes: form) ifFalse:				[self halt: 'form attribute has an invalid value'].			^self].	self attributeNotRecognized: attr</body><body package="XSchema">registerName	self schema object: #attribute at: self name put: self.	super registerName</body><body package="XSchema">validateParent: aSchemaElement	name = nil ifTrue: [^self].	(aSchemaElement isKindOf: Schema)		ifTrue: [^self].	(aSchemaElement isKindOf: Redefine)		ifTrue: [^self].	(form = nil			ifTrue: [self schema attributeFormDefault = 'qualified']			ifFalse: [form = 'qualified'])		ifFalse: [name := name class new qualifier: '' ns: '' type: name type]</body></methods><methods><class-id>XML.AttributeSpecification</class-id> <category>validation</category><body package="XSchema">instanceValidation: elm state: schemaState	| state2 |	state2 := schemaState pushContext: elm tag.	state2 beAttribute.	self parts do: [:i | i pushIdConstraint: state2].	state2 checkIdConstraintsBefore: elm.	self type validate: elm state: state2.	state2 checkIdConstraintsAfter.</body><body package="XSchema">validate: aNode attributes: attributes elements: elementStream state: schemaState	| att |	att := attributes		detect: [:a | (self nameOfElement: a) = self name]		ifNone: [].	att == nil		ifTrue:			[use = 'required' ifTrue: [self error: 'A required attribute was not found'].			value == nil				ifFalse:					[att := Attribute new tag: name.					self instanceValidation: att state: schemaState].			^att].	use = 'prohibited' ifTrue: [self error: 'A prohibited attribute was found'].	(fixedValue == true and: [value ~= att value])		ifTrue: [self error: 'A fixed attribute has a value different from the schema'].	self instanceValidation: att state: schemaState.	attributes remove: att.</body></methods><methods><class-id>XML.AttributeSpecification class</class-id> <category>private</category><body package="XSchema">tagName	^'attribute'</body></methods><methods><class-id>XML.KeyRef</class-id> <category>construction</category><body package="XSchema">processSingleAttribute: attr	attr tag type = 'name'		ifTrue:			[name := self processNCName: attr value.			^self].	attr tag type = 'refer'		ifTrue:			[refer := self processQName: attr value.			^self].	self attributeNotRecognized: attr</body><body package="XSchema">validateParent: aSchemaElement	self schema		object: #keyref		at: self name		put: self</body></methods><methods><class-id>XML.KeyRef</class-id> <category>validation</category><body package="XSchema">checkConsistency: dictionary	| referent refs |	dictionary do: [:value |		referent := value at: 1.		refs := value at: 2.		(referent == nil and: [refs size &gt; 0])			ifTrue: [self error: 'No matching key value was found for a member of a keyref'].		(referent == #duplicated and: [refs size &gt; 0])			ifTrue: [self error: 'Duplicate key values were found for a member of a keyref']].</body><body package="XSchema">propogateKeyrefs: tuple for: idScope	^self</body><body package="XSchema">pushIdConstraint: schemaState	schemaState addKeyRef: self</body><body package="XSchema">registerKey: tuple in: dictionary	| record |	record := dictionary at: tuple			ifAbsentPut: [Array				with: nil				with: OrderedCollection new].	record last add: tuple</body><body package="XSchema">registerKeyRef: tuple in: dictionary	| record |	record := dictionary at: tuple			ifAbsentPut: [Array				with: nil				with: OrderedCollection new].	(record first == nil or: [record first == tuple])		ifTrue: [record at: 1 put: tuple]		ifFalse: [record at: 1 put: #duplicated]</body></methods><methods><class-id>XML.KeyRef</class-id> <category>accessing</category><body package="XSchema">constraintType	^#keyref</body><body package="XSchema">fields	^(self parts select: [:i | i isKindOf: Field])		collect: [:i | i xpath]</body><body package="XSchema">referentName	^refer</body><body package="XSchema">selector	^(self parts detect: [:i | i isKindOf: Selector]) xpath</body></methods><methods><class-id>XML.KeyRef class</class-id> <category>private</category><body package="XSchema">tagName	^'keyref'</body></methods><methods><class-id>XML.AnyAttribute</class-id> <category>validation</category><body package="XSchema">match: instanceNS	(namespace = nil or: [namespace = '##any'])		ifTrue: [^true].	namespace = '##other'		ifTrue: [^instanceNS ~= self schema targetNamespace].	namespace = '##targetNamespace'		ifTrue: [^instanceNS = self schema targetNamespace].	namespace = '##local'		ifTrue: [^instanceNS = ''].	(namespace includes: Character space)		ifFalse: [^instanceNS = namespace].	self halt: 'namespace wildcard not yet implemented'</body><body package="XSchema">skipValidation: attr state: schemaState	| state2 |	state2 := schemaState pushContext: attr tag.	state2 beAttribute.	state2 checkIdConstraintsBefore: attr.	state2 checkIdConstraintsAfter.</body><body package="XSchema">validate: aNode attributes: attributes elements: elementStream state: schemaState	| attrSchema |	attributes copy do: [:att |		(self match: att tag namespace)			ifTrue:				[processContents = 'skip'					ifTrue: [self skipValidation: att state: schemaState]					ifFalse:						[attrSchema := processContents = 'lax'							ifTrue: [self schema object: #attribute at: att tag ifAbsent: []]							ifFalse: [self schema object: #attribute at: att tag].						attrSchema == nil							ifTrue: [self skipValidation: att state: schemaState]							ifFalse: [attrSchema								validate: aNode								attributes: attributes								elements: elementStream								state: schemaState]].				attributes remove: att ifAbsent: []]].</body></methods><methods><class-id>XML.AnyAttribute</class-id> <category>construction</category><body package="XSchema">addAttributesTo: type stack: stack	type addAttribute: self.</body><body package="XSchema">processSingleAttribute: attr	attr tag type = 'processContents'		ifTrue:			[processContents := attr value.			(#('skip' 'lax' 'strict') includes: processContents) ifFalse:				[self halt: 'processContents attribute has an invalid value'].			^self].	attr tag type = 'namespace'		ifTrue:			[namespace := attr value.			^self].	self attributeNotRecognized: attr</body></methods><methods><class-id>XML.AnyAttribute</class-id> <category>accessing</category><body package="XSchema">isWild	^true</body></methods><methods><class-id>XML.AnyAttribute class</class-id> <category>private</category><body package="XSchema">tagName	^'anyAttribute'</body></methods><methods><class-id>XML.Include</class-id> <category>construction</category><body package="XSchema">processSingleAttribute: attr	attr tag type = 'schemaLocation'		ifTrue:			[uri := attr value.			^self].	self attributeNotRecognized: attr</body><body package="XSchema">resolveReferences	| subschema |	uri notNil		ifTrue:			[subschema := SchemaHandler new				startPrefixMapping: '$' uri: self schema targetNamespace;				parse: (self schema baseURI resolvePath: uri);				documentHolder.			subschema value mergeInto: self schema.			subschema value: self schema].</body></methods><methods><class-id>XML.Include class</class-id> <category>private</category><body package="XSchema">tagName	^'include'</body></methods><methods><class-id>XML.SimpleContent</class-id> <category>validation</category><body package="XSchema">validate: aNode attributes: attributes elements: elementStream state: schemaState	elementStream size &lt;= 1 ifFalse: [self halt].	1 to: self parts size do: [:i || v |		v := self parts at: i.		v validate: aNode			attributes: attributes			elements: elementStream			state: schemaState].</body></methods><methods><class-id>XML.SimpleContent class</class-id> <category>private</category><body package="XSchema">tagName	^'simpleContent'</body></methods><methods><class-id>XML.Schema</class-id> <category>accessing</category><body package="XSchema">attributeFormDefault	^attributeFormDefault</body><body package="XSchema">baseURI	^baseUri</body><body package="XSchema">baseURI: uri	baseUri := uri</body><body package="XSchema">elementFormDefault	^elementFormDefault</body><body package="XSchema">object: baseType at: objectName	^(objects at: baseType ifAbsentPut: [Dictionary new])		at: objectName</body><body package="XSchema">object: baseType at: objectName ifAbsent: aBlock	^(objects at: baseType ifAbsentPut: [Dictionary new])		at: objectName ifAbsent: aBlock</body><body package="XSchema">object: baseType at: objectName put: object	| dict |	dict := (objects at: baseType ifAbsentPut: [Dictionary new]).	(dict includesKey: objectName)		ifTrue: [self error: ('Attempt to define the &lt;1s&gt; named "&lt;2s&gt;" more than once'					expandMacrosWith: baseType					with: objectName asString)]		ifFalse: [dict at: objectName put: object]</body><body package="XSchema">targetNamespace	^self namespaceAt: '$'</body><body package="XSchema">typeAt: typeName	| type newKey |	type := self object: #type at: typeName ifAbsent: [].	^type == nil		ifFalse: [type]		ifTrue: [typeName namespace = self schemaNS			ifTrue:				[newKey := typeName type copy.				newKey at: 1 put: newKey first asUppercase.				type := self perform: ('xsd', newKey) asSymbol.				self object: #type at: typeName put: type.				type]			ifFalse: [self error: 'Type not found']]</body></methods><methods><class-id>XML.Schema</class-id> <category>private - date parsing</category><body package="XSchema">readDateFrom: stream into: date	self readYearFrom: stream into: date.	(stream peekFor: $-) ifFalse: [^self halt: 'Expected - in a date'].	self readMonthFrom: stream into: date.	(stream peekFor: $-) ifFalse: [^self halt: 'Expected - in a date'].	self readDayFrom: stream into: date.	self readTimeZoneFrom: stream into: date.	^date</body><body package="XSchema">readDateTimeFrom: stream into: date	self readYearFrom: stream into: date.	(stream peekFor: $-) ifFalse: [^self halt: 'Expected - in a dateTime'].	self readMonthFrom: stream into: date.	(stream peekFor: $-) ifFalse: [^self halt: 'Expected - in a dateTime'].	self readDayFrom: stream into: date.	(stream peekFor: $T) ifFalse: [^self halt: 'Expected "T" in a dateTime'].	self readHourFrom: stream into: date.	(stream peekFor: $:) ifFalse: [^self halt: 'Expected : in a dateTime'].	self readMinuteFrom: stream into: date.	(stream peekFor: $:) ifFalse: [^self halt: 'Expected : in a dateTime'].	self readSecondFrom: stream into: date.	self readTimeZoneFrom: stream into: date.	^date</body><body package="XSchema">readDayFrom: stream into: date	| v |	v := self readStrictInteger: 2 from: stream.	(v &lt; 1 or: [v &gt; 31])		ifTrue: [self error: 'overflow on day field of a time'].	date day: v.	^date</body><body package="XSchema">readDurationFrom: stream into: date	| mapChars mapSelectors lastIndex n ch fieldIndex count |	mapChars := 'YMD'.	mapSelectors := #(#year: #month: #day:).	lastIndex := 0.	count := 0.	(stream peekFor: $P) ifFalse: [self halt: 'Durations must start with P'].	[ch := stream peek.	ch notNil and: [ch isDigit]] whileTrue:		[count := count+1.		n := Integer readFrom: stream.		ch := stream next.		fieldIndex := mapChars indexOf: ch.		fieldIndex &gt; lastIndex			ifFalse: [self halt: ('Durations do not allow "&lt;1s&gt;" at this point in the string' expandMacrosWith: (String with: ch))].		lastIndex := fieldIndex.		date perform: (mapSelectors at: fieldIndex) with: n.		(mapChars = 'YMD' and: [stream peekFor: $T])			ifTrue:				[lastIndex := count := 0.				mapChars := 'HMS'.				mapSelectors := #(#hour: #minute: #second:)]].	count = 0 ifTrue: [self halt: 'A duration does not have enough fields'].	stream atEnd ifFalse: [self halt].	^date</body><body package="XSchema">readGDayFrom: stream into: date	3 timesRepeat:		[(stream peekFor: $-)			ifFalse: [^self halt: 'Expected - in a gDay']].	self readDayFrom: stream into: date.	self readTimeZoneFrom: stream into: date.	^date</body><body package="XSchema">readGMonthDayFrom: stream into: date	2 timesRepeat:		[(stream peekFor: $-)			ifFalse: [^self halt: 'Expected - in a gMonthDay']].	self readMonthFrom: stream into: date.	(stream peekFor: $-) ifFalse: [^self halt: 'Expected - in a gMonthDay'].	self readDayFrom: stream into: date.	self readTimeZoneFrom: stream into: date.	^date</body><body package="XSchema">readGMonthFrom: stream into: date	2 timesRepeat:		[(stream peekFor: $-)			ifFalse: [^self halt: 'Expected - in a gMonth']].	self readMonthFrom: stream into: date.	2 timesRepeat:		[(stream peekFor: $-)			ifFalse: [^self halt: 'Expected - in a gMonth']].	self readTimeZoneFrom: stream into: date.	^date</body><body package="XSchema">readGYearFrom: stream into: date	self readYearFrom: stream into: date.	self readTimeZoneFrom: stream into: date.	^date</body><body package="XSchema">readGYearMonthFrom: stream into: date	self readYearFrom: stream into: date.	(stream peekFor: $-)		ifFalse: [^self halt: 'Expected - in a gYearMonth'].	self readMonthFrom: stream into: date.	self readTimeZoneFrom: stream into: date.	^date</body><body package="XSchema">readHourFrom: stream into: date	| v |	v := self readStrictInteger: 2 from: stream.	v &gt;= 24		ifTrue: [self error: 'overflow on hours field of a time'].	date hour: v.	^date</body><body package="XSchema">readMinuteFrom: stream into: date	| v |	v := self readStrictInteger: 2 from: stream.	v &gt;= 60		ifTrue: [self error: 'overflow on minutes field of a time'].	date minute: v.	^date</body><body package="XSchema">readMonthFrom: stream into: date	| v |	v := self readStrictInteger: 2 from: stream.	(v &lt; 1 or: [v &gt; 13])		ifTrue: [self error: 'overflow on minutes field of a time'].	date month: v.	^date</body><body package="XSchema">readSecondFrom: stream into: date	| v |	v := self readStrictInteger: 2 from: stream.	(stream peekFor: $.)		ifTrue: [self error: 'Fractional seconds are not yet implemented'].	v &gt;= 60		ifTrue: [self error: 'overflow on seconds field of a time'].	date second: v.	^date</body><body package="XSchema">readStrictInteger: count from: stream	| v ch |	v := 0.	count timesRepeat: [		ch := stream next.		(ch notNil and: [ch isDigit])			ifFalse: [self error: 'The date-time field has too few digits'].		v := v * 10 + ch digitValue].	ch := stream peek.	(ch notNil and: [ch isDigit])		ifTrue: [self error: 'The date-time field has too many digits'].	^v</body><body package="XSchema">readTimeFrom: stream into: date	self readHourFrom: stream into: date.	(stream peekFor: $:) ifFalse: [^self halt: 'Expected : in a dateTime'].	self readMinuteFrom: stream into: date.	(stream peekFor: $:) ifFalse: [^self halt: 'Expected : in a dateTime'].	self readSecondFrom: stream into: date.	self readTimeZoneFrom: stream into: date.	^date</body><body package="XSchema">readTimeZoneFrom: stream into: date	| neg hour minute |	(stream peekFor: $Z)		ifTrue: [date timeZone: 0]		ifFalse: [((neg := stream peekFor: $-) or: [stream peekFor: $+])			ifTrue:				[hour := self readStrictInteger: 2 from: stream.				hour &gt; 12 ifTrue: [self error: 'overflow on hours field of a time zone'].				(stream peekFor: $:) ifFalse: [^self halt: 'Expected : in a time zone'].				minute := self readStrictInteger: 2 from: stream.				minute &gt; 59 ifTrue: [self error: 'overflow on minutess field of a time zone'].				minute := hour * 60 + minute.				neg ifTrue: [minute := 0-minute].				date timeZone: minute]].	^date</body><body package="XSchema">readYearFrom: stream into: date	| v neg first ch |	neg := stream peekFor: $-.	v := 0.	first := stream peek.	4 timesRepeat: [		ch := stream next.		(ch notNil and: [ch isDigit])			ifFalse: [self error: 'The year has too few digits'].		v := v * 10 + ch digitValue].	((ch := stream next) notNil and: [ch isDigit])		ifTrue:			[first = $0 ifTrue: [self error: 'Leading zeros are not permitted on a year that has more than 4 digits'].			[ch notNil and: [ch isDigit]]				whileTrue:					[v := v*10 + ch digitValue.					ch := stream next]].	ch == nil ifFalse: [stream skip: -1].	v = 0		ifTrue: [self error: 'Year 0 is not allowed'].	neg ifTrue: [v := 0-v].	date year: v.	^date</body><body package="XSchema">validate: stream do: aBlock	^[aBlock value: stream.	stream atEnd]		on: Error		do: [:x |			x return: false]</body></methods><methods><class-id>XML.Schema</class-id> <category>private - type definitions</category><body package="XSchema">baseType: type	^self typeAt: (NodeTag new			qualifier: 'xsd'			ns: self schemaNS			type: type)</body><body package="XSchema">xsdAnySimpleType	^(self baseType: 'anyType') newSimpleType		name: 'anySimpleType' in: self schemaNS;		yourself</body><body package="XSchema">xsdAnyType	^Type new		schemaHolder: self asValue;		name: 'anyType' in: self schemaNS;		yourself</body><body package="XSchema">xsdAnyURI	^(self baseType: 'anySimpleType') newBaseType		name: 'anyURI' in: self schemaNS;		evaluateBlock: [:v :e | v];		validateBlock: [:v :e | v size &gt; 0];		allow: #pattern;		allow: #whiteSpace;		yourself</body><body package="XSchema">xsdBase64Binary	^(self baseType: 'anySimpleType') newBaseType		name: 'base64Binary' in: self schemaNS;		evaluateBlock: [:v :e | self readBase64BinaryFrom: v readStream];		validateBlock: [:v :e | (self readBase64BinaryFrom: v readStream) notNil];		allow: #totalDigits;		allow: #fractionDigits;		allow: #pattern;		allow: #enumeration;		allow: #whiteSpace;		allow: #maxInclusive;		allow: #maxExclusive;		allow: #minInclusive;		allow: #minExclusive;		yourself</body><body package="XSchema">xsdBoolean	^(self baseType: 'anySimpleType') newBaseType		name: 'boolean' in: self schemaNS;		evaluateBlock: [:v :e | self readBoolean: v];		validateBlock: [:v :e | (self readBoolean: v) notNil];		allow: #pattern;		allow: #whiteSpace;		yourself</body><body package="XSchema">xsdByte	^(self baseType: 'short') newType		name: 'byte' in: self schemaNS;		restrict: 'maxInclusive' value: (1 bitShift: 7) - 1;		restrict: 'minInclusive' value: (-1 bitShift: 7);		yourself</body><body package="XSchema">xsdDate	^(self baseType: 'anySimpleType') newBaseType		name: 'date' in: self schemaNS;		evaluateBlock: [:v :e | self readDateFrom: v readStream into: DateTime new];		validateBlock: [:v :e | self				validate: v readStream				do: [:s | self readDateFrom: s into: DateTime new]];		allow: #pattern;		allow: #enumeration;		allow: #whiteSpace;		allow: #maxInclusive;		allow: #maxExclusive;		allow: #minInclusive;		allow: #minExclusive;		yourself</body><body package="XSchema">xsdDateTime	^(self baseType: 'anySimpleType') newBaseType		name: 'dateTime' in: self schemaNS;		evaluateBlock: [:v :e | self readDateTimeFrom: v readStream into: DateTime new];		validateBlock: [:v :e | self				validate: v readStream				do: [:s | self readDateTimeFrom: s into: DateTime new]];		allow: #pattern;		allow: #enumeration;		allow: #whiteSpace;		allow: #maxInclusive;		allow: #maxExclusive;		allow: #minInclusive;		allow: #minExclusive;		yourself</body><body package="XSchema">xsdDecimal	^(self baseType: 'anySimpleType') newBaseType		name: 'decimal' in: self schemaNS;		evaluateBlock: [:v :e | self readDecimalFrom: v readStream];		validateBlock: [:v :e | (self readDecimalFrom: v readStream) notNil];		allow: #totalDigits;		allow: #fractionDigits;		allow: #pattern;		allow: #enumeration;		allow: #whiteSpace;		allow: #maxInclusive;		allow: #maxExclusive;		allow: #minInclusive;		allow: #minExclusive;		yourself</body><body package="XSchema">xsdDouble	^(self baseType: 'anySimpleType') newBaseType		name: 'double' in: self schemaNS;		evaluateBlock: [:v :e | self readDoubleFrom: v readStream];		validateBlock: [:v :e | (self readDoubleFrom: v readStream) notNil];		allow: #totalDigits;		allow: #fractionDigits;		allow: #pattern;		allow: #enumeration;		allow: #whiteSpace;		allow: #maxInclusive;		allow: #maxExclusive;		allow: #minInclusive;		allow: #minExclusive;		yourself</body><body package="XSchema">xsdDuration	^(self baseType: 'anySimpleType') newBaseType		name: 'duration' in: self schemaNS;		evaluateBlock: [:v :e | self readDurationFrom: v readStream into: Duration new];		validateBlock: [:v :e | self				validate: v readStream				do: [:s | self readDurationFrom: s into: Duration new]];		allow: #pattern;		allow: #enumeration;		allow: #whiteSpace;		allow: #maxInclusive;		allow: #maxExclusive;		allow: #minInclusive;		allow: #minExclusive;		yourself</body><body package="XSchema">xsdFloat	^(self baseType: 'anySimpleType') newBaseType		name: 'float' in: self schemaNS;		evaluateBlock: [:v :e | self readFloatFrom: v readStream];		validateBlock: [:v :e | (self readFloatFrom: v readStream) notNil];		allow: #totalDigits;		allow: #fractionDigits;		allow: #pattern;		allow: #enumeration;		allow: #whiteSpace;		allow: #maxInclusive;		allow: #maxExclusive;		allow: #minInclusive;		allow: #minExclusive;		yourself</body><body package="XSchema">xsdGDay	^(self baseType: 'anySimpleType') newBaseType		name: 'gDay' in: self schemaNS;		evaluateBlock: [:v :e | self readGDayFrom: v readStream into: DateTime new];		validateBlock: [:v :e | self				validate: v readStream				do: [:s | self readGDayFrom: s into: DateTime new]];		allow: #pattern;		allow: #enumeration;		allow: #whiteSpace;		allow: #maxInclusive;		allow: #maxExclusive;		allow: #minInclusive;		allow: #minExclusive;		yourself</body><body package="XSchema">xsdGMonth	^(self baseType: 'anySimpleType') newBaseType		name: 'gMonth' in: self schemaNS;		evaluateBlock: [:v :e | self readGMonthFrom: v readStream into: DateTime new];		validateBlock: [:v :e | self				validate: v readStream				do: [:s | self readGMonthFrom: s into: DateTime new]];		allow: #pattern;		allow: #enumeration;		allow: #whiteSpace;		allow: #maxInclusive;		allow: #maxExclusive;		allow: #minInclusive;		allow: #minExclusive;		yourself</body><body package="XSchema">xsdGMonthDay	^(self baseType: 'anySimpleType') newBaseType		name: 'gMonthDay' in: self schemaNS;		evaluateBlock: [:v :e | self readGMonthDayFrom: v readStream into: DateTime new];		validateBlock: [:v :e | self				validate: v readStream				do: [:s | self readGMonthDayFrom: s into: DateTime new]];		allow: #pattern;		allow: #enumeration;		allow: #whiteSpace;		allow: #maxInclusive;		allow: #maxExclusive;		allow: #minInclusive;		allow: #minExclusive;		yourself</body><body package="XSchema">xsdGYear	^(self baseType: 'anySimpleType') newBaseType		name: 'gYear' in: self schemaNS;		evaluateBlock: [:v :e | self readGYearFrom: v readStream into: DateTime new];		validateBlock: [:v :e | self				validate: v readStream				do: [:s | self readGYearFrom: s into: DateTime new]];		allow: #pattern;		allow: #enumeration;		allow: #whiteSpace;		allow: #maxInclusive;		allow: #maxExclusive;		allow: #minInclusive;		allow: #minExclusive;		yourself</body><body package="XSchema">xsdGYearMonth	^(self baseType: 'anySimpleType') newBaseType		name: 'gYearMonth' in: self schemaNS;		evaluateBlock: [:v :e | self readGYearMonthFrom: v readStream into: DateTime new];		validateBlock: [:v :e | self				validate: v readStream				do: [:s | self readGYearMonthFrom: s into: DateTime new]];		allow: #pattern;		allow: #enumeration;		allow: #whiteSpace;		allow: #maxInclusive;		allow: #maxExclusive;		allow: #minInclusive;		allow: #minExclusive;		yourself</body><body package="XSchema">xsdHexBinary	^(self baseType: 'anySimpleType') newBaseType		name: 'hexBinary' in: self schemaNS;		evaluateBlock: [:v :e | self readHexBinaryFrom: v readStream];		validateBlock: [:v :e | (self readHexBinaryFrom: v readStream) notNil];		allow: #totalDigits;		allow: #fractionDigits;		allow: #pattern;		allow: #enumeration;		allow: #whiteSpace;		allow: #maxInclusive;		allow: #maxExclusive;		allow: #minInclusive;		allow: #minExclusive;		yourself</body><body package="XSchema">xsdID	^(self baseType: 'NCName') newType		name: 'ID' in: self schemaNS;		yourself</body><body package="XSchema">xsdInt	^(self baseType: 'long') newType		name: 'int' in: self schemaNS;		restrict: 'maxInclusive' value: (1 bitShift: 31) - 1;		restrict: 'minInclusive' value: (-1 bitShift: 31);		yourself</body><body package="XSchema">xsdInteger	^(self baseType: 'decimal') newType		name: 'integer' in: self schemaNS;		restrict: 'fractionDigits' value: 0;		yourself</body><body package="XSchema">xsdLanguage	^(self baseType: 'token') newType		name: 'language' in: self schemaNS;		yourself</body><body package="XSchema">xsdLong	^(self baseType: 'integer') newType		name: 'long' in: self schemaNS;		restrict: 'maxInclusive' value: (1 bitShift: 63) - 1;		restrict: 'minInclusive' value: (-1 bitShift: 63);		yourself</body><body package="XSchema">xsdNCName	^(self baseType: 'Name') newType		name: 'NCName' in: self schemaNS;		yourself</body><body package="XSchema">xsdNMTOKEN	^(self baseType: 'token') newType		name: 'NMTOKEN' in: self schemaNS;		yourself</body><body package="XSchema">xsdName	^(self baseType: 'token') newType		name: 'Name' in: self schemaNS;		yourself</body><body package="XSchema">xsdNegativeInteger	^(self baseType: 'nonPositiveInteger') newType		name: 'negativeInteger' in: self schemaNS;		restrict: 'maxInclusive' value: -1;		yourself</body><body package="XSchema">xsdNonNegativeInteger	^(self baseType: 'integer') newType		name: 'nonNegativeInteger' in: self schemaNS;		restrict: 'minInclusive' value: 0;		yourself</body><body package="XSchema">xsdNonPositiveInteger	^(self baseType: 'integer') newType		name: 'nonPositiveInteger' in: self schemaNS;		restrict: 'maxInclusive' value: 0;		yourself</body><body package="XSchema">xsdNormalizedString	^(self baseType: 'string') newType		name: 'normalizedString' in: self schemaNS;		yourself</body><body package="XSchema">xsdPositiveInteger	^(self baseType: 'nonNegativeInteger') newType		name: 'positiveInteger' in: self schemaNS;		restrict: 'minInclusive' value: 1;		yourself</body><body package="XSchema">xsdQName	^(self baseType: 'anySimpleType') newBaseType		name: 'QName' in: self schemaNS;		evaluateBlock: [:v :e | self readQName: v in: e];		validateBlock: [:v :e | (self readQName: v in: e) notNil];		allow: #pattern;		allow: #enumeration;		allow: #whiteSpace;		allow: #maxInclusive;		allow: #maxExclusive;		allow: #minInclusive;		allow: #minExclusive;		yourself</body><body package="XSchema">xsdShort	^(self baseType: 'int') newType		name: 'short' in: self schemaNS;		restrict: 'maxInclusive' value: (1 bitShift: 15) - 1;		restrict: 'minInclusive' value: (-1 bitShift: 15);		yourself</body><body package="XSchema">xsdString	^(self baseType: 'anySimpleType') newBaseType		name: 'string' in: self schemaNS;		evaluateBlock: [:v :e | v];		validateBlock: [:v :e | true];		allow: #length;		allow: #minLength;		allow: #maxLangth;		allow: #pattern;		allow: #enumeration;		allow: #whiteSpace;		yourself</body><body package="XSchema">xsdTime	^(self baseType: 'anySimpleType') newBaseType		name: 'time' in: self schemaNS;		evaluateBlock: [:v :e | self readTimeFrom: v readStream into: DateTime new];		validateBlock: [:v :e | self				validate: v readStream				do: [:s | self readTimeFrom: s into: DateTime new]];		allow: #pattern;		allow: #enumeration;		allow: #whiteSpace;		allow: #maxInclusive;		allow: #maxExclusive;		allow: #minInclusive;		allow: #minExclusive;		yourself</body><body package="XSchema">xsdToken	^(self baseType: 'normalizedString') newType		name: 'token' in: self schemaNS;		yourself</body><body package="XSchema">xsdUnsignedByte	^(self baseType: 'unsignedShort') newType		name: 'unsignedByte' in: self schemaNS;		restrict: 'maxInclusive' value: (1 bitShift: 8) - 1;		yourself</body><body package="XSchema">xsdUnsignedInt	^(self baseType: 'unsignedLong') newType		name: 'unsignedInt' in: self schemaNS;		restrict: 'maxInclusive' value: (1 bitShift: 32) - 1;		yourself</body><body package="XSchema">xsdUnsignedLong	^(self baseType: 'nonNegativeInteger') newType		name: 'unsignedLong' in: self schemaNS;		restrict: 'maxInclusive' value: (1 bitShift: 64) - 1;		yourself</body><body package="XSchema">xsdUnsignedShort	^(self baseType: 'unsignedInt') newType		name: 'unsignedShort' in: self schemaNS;		restrict: 'maxInclusive' value: (1 bitShift: 16) - 1;		yourself</body></methods><methods><class-id>XML.Schema</class-id> <category>private - value parsing</category><body package="XSchema">base64Map	^#[ 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255	255 255 255 255 255 255 255 255 255 255 255 255 255 255 255 255	255 255 255 255 255 255 255 255 255 255 255 062 255 255 255 063	052 053 054 055 056 057 058 059 060 061 255 255 255 255 255 255	255 000 001 002 003 004 005 006 007 008 009 010 011 012 013 014	015 016 017 018 019 020 021 022 023 024 025 255 255 255 255 255	255 026 027 028 029 030 031 032 033 034 035 036 037 038 039 040	041 042 043 044 045 046 047 048 049 050 051 255 255 255 255 255 ]</body><body package="XSchema">readBase64BinaryFrom: stream	| out map count b n c pad |	out := (ByteArray new: 40) writeStream.	map := self base64Map.	count := 0.	b := 0.	[(stream skipSeparators; atEnd) not and:			[(c := stream next) ~= $=]]		whileTrue:			[c := c asInteger.			n := c &lt; 128 ifTrue: [map at: c] ifFalse: [-1].			n ~= 255				ifTrue: [b := (b bitShift: 6)+n]				ifFalse: [self halt: 'invalid base64 digit'].			count := count + 1 bitAnd: 3.			count = 0 ifTrue:				[out nextPut: (b bitShift: -16).				out nextPut: ((b bitShift: -8) bitAnd: 255).				out nextPut: (b bitAnd: 255).				b := 0]].	c = $= ifTrue:		[count := count+1 bitAnd: 3.		b := b bitShift: 6.		pad := 1.		(stream skipSeparators; peekFor: $=)			ifTrue:				[count := count+1 bitAnd: 3.				b := b bitShift: 6.				pad := 2].		out nextPut: (b bitShift: -16).		pad = 1 ifTrue: [out nextPut: ((b bitShift: -8) bitAnd: 255)].		(stream skipSeparators; atEnd) ifFalse: [self halt: 'Too much data on the base64 stream']].	count = 0 ifFalse: [self halt: 'base64 data stream ended prematurely'].	^out contents</body><body package="XSchema">readDecimalFrom: stream	| negative n f |	(negative := stream peekFor: $-)		ifFalse: [stream peekFor: $-].	(stream atEnd or: [stream peek isDigit not and: [stream peek ~= $.]])		ifTrue: [^nil].	n := self readPositiveIntegerFrom: stream.	(stream peekFor: $.)		ifTrue: [f := self readFractionDigitsFrom: stream]		ifFalse: [f := 0].	stream atEnd ifFalse: [^nil].	n := n + f.	negative ifTrue: [n := 0-n].	^n</body><body package="XSchema">readDoubleFrom: stream	| negative n f negative2 ch exp |	(negative := stream peekFor: $-)		ifFalse: [stream peekFor: $-].	(stream atEnd or: [stream peek isDigit not and: [stream peek ~= $.]])		ifTrue: [self halt. ^nil].	n := self readPositiveIntegerFrom: stream.	(stream peekFor: $.)		ifTrue: [f := self readFractionDigitsFrom: stream]		ifFalse: [f := 0].	((stream peekFor: $e) or: [stream peekFor: $E])		ifTrue:			[negative2 := stream peekFor: $-.			ch := stream peek.			(ch isNil or: [ch isDigit not]) ifTrue: [^nil].			exp := self readPositiveIntegerFrom: stream.			negative2 ifTrue: [exp := 0-exp]]		ifFalse:			[exp := 0].	stream atEnd ifFalse: [^nil].	n := n + f.	negative ifTrue: [n := 0-n].	^(n * (10 ** exp))</body><body package="XSchema">readFloatFrom: stream	| negative n f negative2 ch exp |	(negative := stream peekFor: $-)		ifFalse: [stream peekFor: $-].	(stream atEnd or: [stream peek isDigit not and: [stream peek ~= $.]])		ifTrue: [self halt. ^nil].	n := self readPositiveIntegerFrom: stream.	(stream peekFor: $.)		ifTrue: [f := self readFractionDigitsFrom: stream]		ifFalse: [f := 0].	((stream peekFor: $e) or: [stream peekFor: $E])		ifTrue:			[negative2 := stream peekFor: $-.			ch := stream peek.			(ch isNil or: [ch isDigit not]) ifTrue: [^nil].			exp := self readPositiveIntegerFrom: stream.			negative2 ifTrue: [exp := 0-exp]]		ifFalse:			[exp := 0].	stream atEnd ifFalse: [^nil].	n := n + f.	negative ifTrue: [n := 0-n].	^(n * (10 ** exp))</body><body package="XSchema">readFractionDigitsFrom: stream	| n d |	n := 0.	d := 0.	[stream atEnd not and: [stream peek isDigit]] whileTrue:		[n := n * 10 + stream next digitValue.		d := d + 1].	^FixedPoint numerator: n denominator: 10**d scale: d</body><body package="XSchema">readHexBinaryFrom: stream	| out b n count |	out := (ByteArray new: 40) writeStream.	count := 0.	b := 0.	[stream skipSeparators; atEnd]		whileFalse:			[n := stream next.			(n digitValue between: 0 and: 15)				ifTrue: [b := b*16+n digitValue]				ifFalse: [self error: 'invalid hex digit'].			count := count + 1 bitAnd: 1.			count = 0 ifTrue:				[out nextPut: b.				b := 0]].	count = 0 ifFalse: [self error: 'hexBinary data stream ended prematurely'].	^out contents</body><body package="XSchema">readPositiveIntegerFrom: stream	| n |	n := 0.	[stream atEnd not and: [stream peek isDigit]] whileTrue:		[n := n * 10 + stream next digitValue].	^n</body></methods><methods><class-id>XML.Schema</class-id> <category>initialize</category><body package="XSchema">initialize	super initialize.	objects := IdentityDictionary new.</body></methods><methods><class-id>XML.Schema</class-id> <category>construction</category><body package="XSchema">internalValidation	| key |	self parts do: [:p | p registerName].	self parts do: [:p | p resolveReferences].	(objects at: #keyref ifAbsent: [#()]) do: [:ref |		key := self object: #key at: ref referentName.		ref fields size = key fields size			ifFalse: [self error: 'A keyref has a different number of fields than its key or unique']].</body><body package="XSchema">mergeInto: aSchema	objects keysAndValuesDo: [:type :typedObjects |		typedObjects keysAndValuesDo: [:oName :object |			(oName namespace = self schemaNS)				ifFalse: [aSchema object: type at: oName put: object]]]</body><body package="XSchema">processSingleAttribute: attr	attr tag type = 'targetNamespace'		ifTrue:			[(namespaces key at: '$' ifAbsentPut: [attr value]) = attr value				ifFalse: [self error: 'The targetNamespace of the schema does not match that of the including schema'].			^self].	attr tag type = 'elementFormDefault'		ifTrue:			[elementFormDefault := attr value.			^self].	attr tag type = 'attributeFormDefault'		ifTrue:			[attributeFormDefault := attr value.			^self].	attr tag type = 'blockDefault'		ifTrue:			[blockDefault := attr value.			^self].	self attributeNotRecognized: attr</body><body package="XSchema">transformNamespace: newNamespace	self halt notYetImplemented.	self targetNamespace = '' ifFalse: [self halt: 'We only know how to do this if the targetNamespace is empty'].</body></methods><methods><class-id>XML.Schema</class-id> <category>validation</category><body package="XSchema">validate: aDocument	| root elementDecl |	root := aDocument root.	elementDecl := self object: #element at: (self nameOfElement: root).	elementDecl instanceValidation: root state: SchemaState new</body></methods><methods><class-id>XML.Schema class</class-id> <category>examples</category><body package="XSchema">conformance	"This method runs the XSchema tests collected by the W3C. To run these	tests, download the test files from the W3C at		http://www.w3.org/2001/05/xmlschema-test-collection/XSTC-20020116.tar.gz	Unpack this archive into an empty directory, and run this method. The test script	will ask which directory contains the XSchema tests--the assumption is that they	are in a directory named 'xschema' which is a sibling of the $(VISUALWORKS)	directory. Whenever the script fails to get the predicted results on a test, a message	will be written to the Transcript. If the prediction is that a test should fail and our	implementation fails the test, this should not be taken as confirmation that we	failed for the right reason.	Our implementation currently fails 122 tests, although this will change as the	W3C test suite is modified and as we fix bugs. Of the 122 we are failing, more	than 50 appear to be bugs, not in our processor, but in the test cases themselves."	"Schema conformance"	| base list p testTag findFile files f2 key nm2 schema valid str xschema errors instance fUri doc folder1 folder2 baseU |	Transcript clear; show: '.'; show: '.'.	errors := Bag new.	base := '$(VISUALWORKS)' asLogicalFileSpecification asFilename		directory construct: 'xschema'.	base := Dialog requestDirectoryName: 'Where are the XSchema tests?' default: base asString.	base isEmpty ifTrue: [^errors].	base := base asFilename.	baseU := (base construct: 'foo.xml') asURI.	list := base filesMatching: '*/*LTGfmt.xml'.	list := list copyWith: (self conformanceGenerateLTGForSun: base).	testTag := NodeTag new qualifier: '' ns: '' type: 'test'.	findFile := XPathParser new parse: './/file' as: #locationPath.	list do: [:fn |		p := XMLParser new			validate: false;			parse: fn asFilename.		p nodesDo: [:n |			(n isElement and: [n tag = testTag])				ifTrue:					[files := findFile xpathValueFor: n variables: Dictionary new.					f2 := Dictionary new.					files unsortedNodes do: [:n2 |						key := n2 valueOfAttribute: 'role' ifAbsent: [self halt].						nm2 := n2 valueOfAttribute: 'fileName' ifAbsent: [self halt].						folder1 := n2 valueOfAttribute: 'tsDir' ifAbsent: [self halt].						folder2 := n2 valueOfAttribute: 'folder' ifAbsent: [self halt].						key = 'other' ifFalse:							[valid := n2 valueOfAttribute: 'validity' ifAbsent: [self halt].							f2 at: key put: (Array								with: folder1, '/', folder2, '/', nm2								with: valid)]].					schema := f2 at: 'schema'.					str := 'no schema error found'.					xschema := nil.					valid := [xschema := SchemaHandler new parse: (baseU resolvePath: (schema at: 1)).						'1']							on: Error							do: [:x |								(x class == MessageNotUnderstood or: ['Uni*' match: x messageText]) ifTrue:									[Transcript cr; show:										(baseU resolvePath: (schema at: 1)) asFilename asString.									x pass].								str := x messageText.								x return: '0'].					valid = (schema at: 2) ifFalse:						[errors add: str.						Transcript cr; show:							(baseU resolvePath: (schema at: 1)) asFilename asString.						Transcript cr; tab; show: str].					((schema at: 2) = '1' and: [xschema notNil]) ifTrue:						[instance := f2 at: 'instance' ifAbsent: [nil].						fUri := instance == nil ifFalse: [baseU resolvePath: (instance at: 1)].						(fUri notNil and: [fUri asFilename exists])							ifFalse: [fUri := nil].						fUri == nil ifFalse: [							doc := XMLParser new								lineEndLF;								validate: false;								parse: fUri.							str := 'no instance error found'.							valid := [xschema validate: doc.									'1']									on: Error do: [:x |										str := x errorString.										(' Key*' match: str)											ifTrue: [x pass].										(x class = MessageNotUnderstood and:												[x parameter selector ~= #nil])											ifTrue: [x pass].										'0'].							valid = (instance at: 2) ifFalse: [								errors add: str."								str = 'no instance error found' ifTrue: [files halt]."								Transcript cr; show:									'&gt;&gt;&gt;  ', fUri asFilename asString.								Transcript cr; tab; show:									(baseU resolvePath: (schema at: 1)) asFilename asString.								Transcript cr; tab; show: str].							]].					]]].	Transcript cr; show: errors size printString, ' errors'.	^errors</body><body package="XSchema">conformanceGenerateLTGForSun: base	"Schema conformanceGenerateLTGForSun:		'$(VISUALWORKS)/../../xschema2' asLogicalFileSpecification asFilename"	| schemas pattern output |	output := 'xsd-sun-LTGfmt.xml' asFilename writeStream.	[output cr; nextPutAll: '&lt;tests&gt;'; cr.	schemas := base asFilename filesMatching: 'suntest/*/*.xsd'.	schemas do: [:sch |		('*.e.xsd' match: sch)			ifTrue:				[output nextPutAll:'&lt;test&gt;'; cr;					nextPutAll: '&lt;file tsDir="suntest" folder="SunTestsAll" fileName="',							sch, '" role="schema" validity="0"/&gt;'; cr;					nextPutAll: '&lt;/test&gt;'; cr; cr]			ifFalse:				[pattern := sch copyReplaceAll: '.xsd' with: '.n*.xml'.				(Filename filesMatching: pattern) do: [:s |					output nextPutAll:'&lt;test&gt;'; cr;						nextPutAll: '&lt;file tsDir="suntest" folder="SunTestsAll" fileName="',								sch asFilename tail, '" role="schema" validity="1"/&gt;'; cr;						nextPutAll: '&lt;file tsDir="suntest" folder="SunTestsAll" fileName="',								s asFilename tail, '" role="instance" validity="0"/&gt;'; cr;						nextPutAll: '&lt;/test&gt;'; cr; cr].				pattern := sch copyReplaceAll: '.xsd' with: '.v*.xml'.				(Filename filesMatching: pattern) do: [:s |					output nextPutAll:'&lt;test&gt;'; cr;						nextPutAll: '&lt;file tsDir="suntest" folder="SunTestsAll" fileName="',								sch asFilename tail, '" role="schema" validity="1"/&gt;'; cr;						nextPutAll: '&lt;file tsDir="suntest" folder="SunTestsAll" fileName="',								s asFilename tail, '" role="instance" validity="1"/&gt;'; cr;						nextPutAll: '&lt;/test&gt;'; cr; cr]]].	output nextPutAll: '&lt;/tests&gt;'; cr]		ensure: [output close].	^output name asFilename</body><body package="XSchema">example1	"Schema example1"	| schema doc |	schema := SchemaHandler new parse: self exampleSchema1 readStream.	doc := XMLParser new			handlers: DOM_SAXDriver new;			validate: false;			parse: self exampleBody1 readStream.	^schema validate: doc</body><body package="XSchema">exampleBody1	^'&lt;?xml version="1.0"?&gt;	&lt;purchaseOrder orderDate="1999-10-20"&gt;		&lt;shipTo country="US"&gt;			&lt;name&gt;Alice Smith&lt;/name&gt;			&lt;street&gt;123 Maple Street&lt;/street&gt;			&lt;city&gt;Mill Valley&lt;/city&gt;			&lt;state&gt;CA&lt;/state&gt;			&lt;zip&gt;90952&lt;/zip&gt;		&lt;/shipTo&gt;		&lt;billTo country="US"&gt;			&lt;name&gt;Robert Smith&lt;/name&gt;			&lt;street&gt;8 Oak Avenue&lt;/street&gt;			&lt;city&gt;Old Town&lt;/city&gt;			&lt;state&gt;PA&lt;/state&gt;			&lt;zip&gt;95819&lt;/zip&gt;		&lt;/billTo&gt;		&lt;comment&gt;Hurry, my lawn is going wild!&lt;/comment&gt;		&lt;items&gt;			&lt;item partNum="872-AA"&gt;				&lt;productName&gt;Lawnmower&lt;/productName&gt;				&lt;quantity&gt;1&lt;/quantity&gt;				&lt;USPrice&gt;148.95&lt;/USPrice&gt;				&lt;comment&gt;Confirm this is electric&lt;/comment&gt;			&lt;/item&gt;			&lt;item partNum="926-AA"&gt;				&lt;productName&gt;Baby Monitor&lt;/productName&gt;				&lt;quantity&gt;1&lt;/quantity&gt;				&lt;USPrice&gt;39.98&lt;/USPrice&gt;				&lt;shipDate&gt;1999-05-21&lt;/shipDate&gt;			&lt;/item&gt;		&lt;/items&gt;	&lt;/purchaseOrder&gt;'</body><body package="XSchema">exampleSchema1	^'&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"&gt;		&lt;xsd:annotation&gt;			&lt;xsd:documentation xml:lang="en"&gt;			Purchase order schema for Example.com.			   Copyright 2000 Example.com. All rights reserved.			&lt;/xsd:documentation&gt;		&lt;/xsd:annotation&gt;		&lt;xsd:element name="purchaseOrder" type="PurchaseOrderType"/&gt;		&lt;xsd:element name="comment" type="xsd:string"/&gt;		&lt;xsd:complexType name="PurchaseOrderType"&gt;			&lt;xsd:sequence&gt;				&lt;xsd:element name="shipTo" type="USAddress"/&gt;				&lt;xsd:element name="billTo" type="USAddress"/&gt;				&lt;xsd:element ref="comment" minOccurs="0"/&gt;				&lt;xsd:element name="items"  type="Items"/&gt;			&lt;/xsd:sequence&gt;			&lt;xsd:attribute name="orderDate" type="xsd:date"/&gt;		&lt;/xsd:complexType&gt;		&lt;xsd:complexType name="USAddress"&gt;			&lt;xsd:sequence&gt;				&lt;xsd:element name="name"   type="xsd:string"/&gt;				&lt;xsd:element name="street" type="xsd:string"/&gt;				&lt;xsd:element name="city"   type="xsd:string"/&gt;				&lt;xsd:element name="state"  type="xsd:string"/&gt;				&lt;xsd:element name="zip"    type="xsd:decimal"/&gt;			&lt;/xsd:sequence&gt;			&lt;xsd:attribute name="country" type="xsd:NMTOKEN"			     fixed="US"/&gt;		&lt;/xsd:complexType&gt;		&lt;xsd:complexType name="Items"&gt;			&lt;xsd:sequence&gt;				&lt;xsd:element name="item" minOccurs="0" maxOccurs="unbounded"&gt;					&lt;xsd:complexType&gt;						&lt;xsd:sequence&gt;							&lt;xsd:element name="productName" type="xsd:string"/&gt;							&lt;xsd:element name="quantity"&gt;								&lt;xsd:simpleType&gt;									&lt;xsd:restriction base="xsd:positiveInteger"&gt;										&lt;xsd:maxExclusive value="100"/&gt;									&lt;/xsd:restriction&gt;								&lt;/xsd:simpleType&gt;							&lt;/xsd:element&gt;							&lt;xsd:element name="USPrice"  type="xsd:decimal"/&gt;							&lt;xsd:element ref="comment"   minOccurs="0"/&gt;							&lt;xsd:element name="shipDate" type="xsd:date" minOccurs="0"/&gt;						&lt;/xsd:sequence&gt;						&lt;xsd:attribute name="partNum" type="SKU" use="required"/&gt;					&lt;/xsd:complexType&gt;				&lt;/xsd:element&gt;			&lt;/xsd:sequence&gt;		&lt;/xsd:complexType&gt;		&lt;!-- Stock Keeping Unit, a code for identifying products --&gt;		&lt;xsd:simpleType name="SKU"&gt;			&lt;xsd:restriction base="xsd:string"&gt;				&lt;xsd:pattern value="\d{3}-[A-Z]{2}"/&gt;			&lt;/xsd:restriction&gt;		&lt;/xsd:simpleType&gt;	&lt;/xsd:schema&gt;'</body></methods><methods><class-id>XML.Schema class</class-id> <category>private</category><body package="XSchema">tagName	^'schema'</body></methods><methods><class-id>XML.Schema class</class-id> <category>initialize</category><body package="XSchema">initialize	"Schema initialize"	BaseTypes := Dictionary new.</body></methods><methods><class-id>XML.Group</class-id> <category>construction</category><body package="XSchema">processSingleAttribute: attr	attr tag type = 'name'		ifTrue:			[name := self processNCName: attr value.			^self].	attr tag type = 'ref'		ifTrue:			[refName := self processQName: attr value.			^self].	self attributeNotRecognized: attr</body><body package="XSchema">registerName	self schema object: #group at: self name put: self.	super registerName</body></methods><methods><class-id>XML.Group</class-id> <category>validation</category><body package="XSchema">findMatchesFor: elm stack: stack incomplete: incomplete complete: complete	| count myParts |	myParts := (self schema object: #group at: refName) parts.	count := stack last at: 2.	count &gt; self max		ifTrue: [^self pop: stack into: incomplete].	stack last at: 2 put: count+1.	stack add: (Array with: myParts last with: 0 with: 0).	myParts last findMatchesFor: elm		stack: (stack collect: [:f | f copy])		incomplete: incomplete		complete: complete.	stack removeLast.	stack last at: 2 put: count.	count &gt;= self min		ifTrue: [self pop: stack into: incomplete].</body><body package="XSchema">findTerminatorInStack: stack incomplete: incomplete complete: complete	| count myParts |	myParts := (self schema object: #group at: refName) parts.	count := stack last at: 2.	count &lt; self min		ifFalse:			[stack removeLast.			^stack isEmpty				ifTrue: [complete add: stack]				ifFalse: [incomplete add: stack]].	stack last at: 2 put: count+1.	stack add: (Array with: myParts last with: 0 with: 0).	myParts last findTerminatorInStack: (stack collect: [:f | f copy])		incomplete: incomplete		complete: complete.	stack removeLast.	stack last at: 2 put: count.</body></methods><methods><class-id>XML.Group class</class-id> <category>private</category><body package="XSchema">tagName	^'group'</body></methods><methods><class-id>XML.Type</class-id> <category>deriving</category><body package="XSchema">newBaseType	^BaseSimpleType new		parent: self;		schemaHolder: self schemaHolder</body><body package="XSchema">newComplexType	^ComplexType new		parent: self;		schemaHolder: self schemaHolder</body><body package="XSchema">newSimpleType	^SimpleType new		parent: self;		schemaHolder: self schemaHolder</body><body package="XSchema">newType	^self newComplexType</body></methods><methods><class-id>XML.Type</class-id> <category>construction</category><body package="XSchema">name: type in: ns	name := NodeTag new qualifier: ns ns: ns type: type</body><body package="XSchema">parent: type	parentType := type</body><body package="XSchema">registerName	self schema object: #type at: name put: self.	super registerName</body></methods><methods><class-id>XML.Type</class-id> <category>validation</category><body package="XSchema">isSimple	^false</body><body package="XSchema">isType	^true</body><body package="XSchema">preprocess: string priority: priority	^string</body><body package="XSchema">validate: aNode state: schemaState	^self</body><body package="XSchema">validate: aNode value: aString state: schemaState	^self</body></methods><methods><class-id>XML.ComplexType</class-id> <category>construction</category><body package="XSchema">addAttribute: attr	attr isWild		ifTrue: [cachedAttributes := cachedAttributes copyWith: attr]		ifFalse: [cachedAttributes := (Array with: attr), cachedAttributes]</body><body package="XSchema">processSingleAttribute: attr	attr tag type = 'name'		ifTrue:			[name := self processNCName: attr value.			^self].	attr tag type = 'mixed'		ifTrue:			[mixed := self readBoolean: attr value.			^self].	attr tag type = 'block'		ifTrue:			[block := attr value.			^self].	self attributeNotRecognized: attr</body></methods><methods><class-id>XML.ComplexType</class-id> <category>validation</category><body package="XSchema">isSimple	^false</body><body package="XSchema">validate: aNode attributes: attributes elements: elementStream state: schemaState	self partical validate: aNode			attributes: attributes			elements: elementStream			state: schemaState.	self attributes do: [:att |		att validate: aNode			attributes: attributes			elements: elementStream			state: schemaState].	(attributes reject: [:att | att tag namespace = 'http://www.w3.org/2001/XMLSchema-instance']) isEmpty		ifFalse: [self error: 'One or more attributes are not specified in the schema'].</body><body package="XSchema">validate: element state: schemaState	self validate: element		attributes: element attributes copy asOrderedCollection		elements: element children readStream		state: schemaState</body></methods><methods><class-id>XML.ComplexType</class-id> <category>accessing</category><body package="XSchema">attributes	cachedAttributes == nil ifFalse: [^cachedAttributes].	cachedAttributes := #().	self parts do: [:i |		i addAttributesTo: self stack: OrderedCollection new].	^cachedAttributes</body><body package="XSchema">partical	cachedPartical == nil ifFalse: [^cachedPartical].	^cachedPartical := self parts		detect: [:elm | elm isKindOf: ElementContentSpecification]		ifNone: [Empty new]</body></methods><methods><class-id>XML.ComplexType</class-id> <category>deriving</category><body package="XSchema">newSimpleType	^self shouldNotImplement</body></methods><methods><class-id>XML.ComplexType class</class-id> <category>private</category><body package="XSchema">tagName	^'complexType'</body></methods><methods><class-id>XML.Documentation</class-id> <category>construction</category><body package="XSchema">processSingleAttribute: attr	(attr tag type = 'lang' and: [attr tag namespace = XML_URI])		ifTrue:			[Transcript cr; show: 'xml:lang=', attr value.			^self].	self attributeNotRecognized: attr</body></methods><methods><class-id>XML.Documentation class</class-id> <category>private</category><body package="XSchema">tagName	^'documentation'</body></methods><methods><class-id>XML.Sequence</class-id> <category>validation</category><body package="XSchema">findMatchesFor: elm stack: stack incomplete: incomplete complete: complete	| index count |	index := stack last at: 3.	index = parts size		ifTrue:			[stack last at: 3 put: (index := 0).			count := stack last at: 2.			stack last at: 2 put: (count := count+1).			count &gt;= self max ifTrue: [^self].			count &gt;= self min ifTrue: [self pop: (stack collect: [:f | f copy]) into: incomplete]].	stack last at: 3 put: (index := index+1).	stack add: (Array with: (parts at: index) with: 0 with: 0).	(parts at: index)		findMatchesFor: elm		stack: (stack collect: [:f | f copy])		incomplete: incomplete		complete: complete.	stack removeLast.	stack last at: 3 put: index-1.</body><body package="XSchema">findTerminatorInStack: stack incomplete: incomplete complete: complete	| index count |	index := stack last at: 3.	index = parts size		ifTrue:			[stack last at: 3 put: (index := 0).			count := stack last at: 2.			stack last at: 2 put: (count := count+1).			count &gt;= self min				ifTrue:					[stack removeLast.					^stack isEmpty						ifTrue: [complete add: stack]						ifFalse: [incomplete add: stack]]].	stack last at: 3 put: (index := index+1).	stack add: (Array with: (parts at: index) with: 0 with: 0).	(parts at: index)		findTerminatorInStack: (stack collect: [:f | f copy])		incomplete: incomplete		complete: complete.	stack removeLast.	stack last at: 3 put: index-1.</body></methods><methods><class-id>XML.Sequence</class-id> <category>construction</category><body package="XSchema">processSingleAttribute: attr	attr tag type = 'minOccurs'		ifTrue:			[min := attr value asNumber.			^self].	attr tag type = 'maxOccurs'		ifTrue:			[max := attr value = 'unbounded' ifTrue: [1.0e20] ifFalse: [attr value asNumber].			^self].	self attributeNotRecognized: attr</body></methods><methods><class-id>XML.Sequence class</class-id> <category>private</category><body package="XSchema">tagName	^'sequence'</body></methods><methods><class-id>XML.Union</class-id> <category>validation</category><body package="XSchema">evaluate: aString in: aNode	self memberTypes do: [:v |		[^v evaluate: aString in: aNode]			on: Error			do: [:x | x return]].	self error: 'No types in a union type matched the data'.</body><body package="XSchema">validate: aNode value: aString state: schemaState	self memberTypes do: [:v |		[v validate: aNode value: aString state: schemaState.		^self]			on: Error			do: [:x | x return: false]].	self error: 'No types in a union type matched the data'.</body></methods><methods><class-id>XML.Union</class-id> <category>construction</category><body package="XSchema">initialize	super initialize.	memberTypes := #()</body><body package="XSchema">processSingleAttribute: attr	attr tag type = 'memberTypes'		ifTrue:			[memberTypes := self collapseSpaces: (self replaceSpaces: attr value).			memberTypes isEmpty				ifTrue: [memberTypes := #()]				ifFalse:					[memberTypes := memberTypes tokensBasedOn: Character space.					memberTypes := memberTypes collect: [:s | self processQName: s]].			^self].	self attributeNotRecognized: attr</body></methods><methods><class-id>XML.Union</class-id> <category>accessing</category><body package="XSchema">memberTypes	^(memberTypes collect: [:nm | self schema typeAt: nm]),		(self parts select: [:nd | nd isType])</body></methods><methods><class-id>XML.Union class</class-id> <category>private</category><body package="XSchema">tagName	^'union'</body></methods><methods><class-id>XML.RegExpTest</class-id> <category>construction</category><body package="XSchema">initialize	super initialize.	negated := false</body><body package="XSchema">negated	negated := negated not</body></methods><methods><class-id>XML.RegExpTest</class-id> <category>accessing</category><body package="XSchema">test: aBlock	test := aBlock</body></methods><methods><class-id>XML.RegExpTest</class-id> <category>testing</category><body package="XSchema">baseMatchFrom: stream	stream atEnd ifTrue: [^false].	^(test value: stream next) ~= negated</body></methods><methods><class-id>XML.UniqueOrKey</class-id> <category>accessing</category><body package="XSchema">constraintType	^isKey		ifTrue: [#key]		ifFalse: [#unique]</body><body package="XSchema">fields	^(self parts select: [:i | i isKindOf: Field])		collect: [:i | i xpath]</body><body package="XSchema">selector	^(self parts detect: [:i | i isKindOf: Selector]) xpath</body></methods><methods><class-id>XML.UniqueOrKey</class-id> <category>validation</category><body package="XSchema">propogateKeyrefs: tuple for: idScope	| scope |	scope := idScope.	[scope == nil] whileFalse:		[scope keyrefs do: [:ref |			ref key referentName = name				ifTrue: [ref key registerKeyRef: tuple in: ref value]].		scope := scope nextLink].</body><body package="XSchema">pushIdConstraint: schemaState	schemaState addKey: self.</body><body package="XSchema">registerKey: tuple in: dictionary	(dictionary at: tuple ifAbsent: [tuple]) == tuple		ifTrue: [dictionary at: tuple put: tuple]		ifFalse: [self error: 'Two elements in the same scope have duplicate keys'].</body></methods><methods><class-id>XML.UniqueOrKey</class-id> <category>construction</category><body package="XSchema">noteElementTag: aString	isKey := aString = 'key'</body><body package="XSchema">processSingleAttribute: attr	attr tag type = 'name'		ifTrue:			[name := self processNCName: attr value.			^self].	self attributeNotRecognized: attr</body><body package="XSchema">validateParent: aSchemaElement	self schema		object: #key    "This can be either a &lt;unique&gt; or a &lt;key&gt;,					but to guarantee there are no name collisions,					we use the same naming space."		at: self name		put: self</body></methods><methods><class-id>XML.UniqueOrKey class</class-id> <category>private</category><body package="XSchema">matchesTag: aTag	^#('key' 'unique') includes: aTag</body></methods><methods><class-id>XML.RegExpLiteral</class-id> <category>printing</category><body package="XSchema">printOn: aStream depth: depth	value == nil ifFalse: [aStream nextPutAll: value].	self printQuantifierOn: aStream.	successor == nil ifFalse: [successor printOn: aStream depth: depth].</body></methods><methods><class-id>XML.RegExpLiteral</class-id> <category>accessing</category><body package="XSchema">successor: node	successor == nil		ifTrue: [(node class == self class				and: [self hasOneOccurrence				and: [node hasOneOccurrence]])			ifTrue:				[value := value, node value.				self successor: node successor]			ifFalse: [successor := node]]		ifFalse: [successor successor: node]</body><body package="XSchema">value	^value</body><body package="XSchema">value: aString	value := aString</body></methods><methods><class-id>XML.RegExpLiteral</class-id> <category>testing</category><body package="XSchema">baseMatchFrom: stream	value do: [:c |		(stream peekFor: c) ifFalse: [^false]].	^true</body><body package="XSchema">hasOneOccurrence	^quantifier first = 1 and: [quantifier size = 1]</body></methods><methods><class-id>XML.SimpleType</class-id> <category>construction</category><body package="XSchema">allow: refinementName</body><body package="XSchema">parent: type	self addElement: (Restriction new baseType: type)</body><body package="XSchema">processSingleAttribute: attr	attr tag type = 'name'		ifTrue:			[name := self processNCName: attr value.			^self].	attr tag type = 'id'		ifTrue:			[id := attr value.			^self].	self attributeNotRecognized: attr</body><body package="XSchema">restrict: type value: value	self parts first addElement: (RestrictionRefinement new			noteElementTag: type;			value: value;			restriction: self parts first)</body></methods><methods><class-id>XML.SimpleType</class-id> <category>validation</category><body package="XSchema">evaluate: aString in: aNode	^self parts last evaluate: aString in: aNode</body><body package="XSchema">isSimple	^true</body><body package="XSchema">preprocess: string priority: priority	| val |	val := string.	self parts do: [:p | val := p preprocess: val priority: priority].	^val</body><body package="XSchema">validate: aNode attributes: attributes elements: elementStream state: schemaState	self validate: aNode value: aNode characterData state: schemaState</body><body package="XSchema">validate: aNode state: schemaState	self validate: aNode value: aNode characterData state: schemaState</body><body package="XSchema">validate: aNode value: aString state: schemaState	self parts do: [:v | v validate: aNode value: aString state: schemaState].</body></methods><methods><class-id>XML.SimpleType</class-id> <category>deriving</category><body package="XSchema">newComplexType	^self shouldNotImplement</body><body package="XSchema">newType	^self newSimpleType</body></methods><methods><class-id>XML.SimpleType class</class-id> <category>private</category><body package="XSchema">tagName	^'simpleType'</body></methods><methods><class-id>XML.BaseSimpleType</class-id> <category>initialize</category><body package="XSchema">evaluateBlock: aBlock	evaluateBlock := aBlock</body><body package="XSchema">validateBlock: aBlock	validateBlock := aBlock</body></methods><methods><class-id>XML.BaseSimpleType</class-id> <category>validation</category><body package="XSchema">evaluate: aString in: aNode	^evaluateBlock value: aString value: aNode</body><body package="XSchema">validate: aNode state: schemaState	(validateBlock value: aNode characterData value: aNode)		ifFalse: [self error: 'The node''s character data does not match the basic type for ', self name asString].</body><body package="XSchema">validate: aNode value: aString state: schemaState	(aNode isElement and: [aNode children contains: [:e | e isElement]])		ifTrue: [self halt error: 'Elements with simple types can''t have child elements'].	(validateBlock value: aNode characterData value: aNode)		ifFalse: [self error: 'The node''s character data does not match the basic type for ', self name asString].</body></methods><methods><class-id>XML.SchemaAnnotation class</class-id> <category>private</category><body package="XSchema">tagName	^'annotation'</body></methods><methods><class-id>XML.ElementSpecification</class-id> <category>accessing</category><body package="XSchema">isOptional	^self min = 0</body><body package="XSchema">isTerminator	^false</body><body package="XSchema">max	max == nil ifFalse: [^max].	^1</body><body package="XSchema">min	min == nil ifFalse: [^min].	^1</body><body package="XSchema">type	self halt.	typeName == nil ifFalse: [^self schema typeAt: typeName].	refName == nil ifFalse: [^(self schema object: #element at: refName) type].	^self parts detect: [:p | p isType]		ifNone: [self schema typeAt: (NodeTag new qualifier: 'xsd' ns: self schemaNS type: 'anyType')]</body><body package="XSchema">typeFor: anElement	| qname |	(qname := anElement valueOfAttribute: (self xsi: 'type') ifAbsent: []) = nil		ifFalse:			[qname := self readQName: qname in: anElement.			^self schema typeAt: qname].	typeName == nil ifFalse: [^self schema typeAt: typeName].	refName == nil ifFalse: [^(self schema object: #element at: refName) typeFor: anElement].	self parts isEmpty ifFalse: [^self parts first].	^self schema typeAt: (self xsd: 'anyType')</body></methods><methods><class-id>XML.ElementSpecification</class-id> <category>construction</category><body package="XSchema">processSingleAttribute: attr	attr tag type = 'name'		ifTrue:			[name := self processNCName: attr value.			^self].	attr tag type = 'type'		ifTrue:			[typeName := self processQName: attr value.			^self].	attr tag type = 'ref'		ifTrue:			[refName := self processQName: attr value.			^self].	attr tag type = 'minOccurs'		ifTrue:			[min := attr value asNumber.			^self].	attr tag type = 'maxOccurs'		ifTrue:			[max := attr value = 'unbounded' ifTrue: [1.0e20] ifFalse: [attr value asNumber].			^self].	attr tag type = 'nillable'		ifTrue:			[nillable := self readBoolean: attr value.			^self].	attr tag type = 'abstract'		ifTrue:			[abstract := self readBoolean: attr value.			^self].	attr tag type = 'form'		ifTrue:			[form := attr value.			(#('qualified' 'unqualified') includes: form) ifFalse:				[self halt: 'form attribute has an invalid value'].			^self].	attr tag type = 'fixed'		ifTrue:			[fixed := attr value.			^self].	attr tag type = 'final'		ifTrue:			[final := attr value.			^self].	attr tag type = 'substitutionGroup'		ifTrue:			[substitutionGroup := self processQName: attr value.			^self].	attr tag type = 'block'		ifTrue:			[block := attr value.			^self].	self attributeNotRecognized: attr</body><body package="XSchema">registerName	self schema object: #element at: self name put: self.	super registerName</body><body package="XSchema">validateParent: aSchemaElement	name = nil ifTrue: [^self].	(aSchemaElement isKindOf: Schema)		ifTrue: [^self].	(aSchemaElement isKindOf: Redefine)		ifTrue: [^self].	(form = nil			ifTrue: [self schema elementFormDefault = 'qualified']			ifFalse: [form = 'qualified'])		ifFalse: [name := name class new qualifier: '' ns: '' type: name type]</body></methods><methods><class-id>XML.ElementSpecification</class-id> <category>validation</category><body package="XSchema">findMatchesFor: elm stack: stack incomplete: incomplete complete: complete	| count |	count := stack last at: 2.	elm tag = self name		ifFalse: [count &lt; self min			ifTrue: [^self]			ifFalse: [^self pop: stack into: incomplete]].	count &gt;= self max		ifTrue: [^self pop: stack into: incomplete].	stack last at: 2 put: count+1.	complete add: (stack collect: [:f | f copy]).</body><body package="XSchema">findTerminatorInStack: stack incomplete: incomplete complete: complete	| count |	count := stack last at: 2.	count &lt; self min		ifFalse:			[stack removeLast.			stack isEmpty				ifTrue: [complete add: stack]				ifFalse: [incomplete add: stack]].</body><body package="XSchema">instanceValidation: elm state: schemaState	| state2 type |	state2 := schemaState pushContext: elm tag.	self parts do: [:i | i pushIdConstraint: state2].	state2 checkIdConstraintsBefore: elm.	type := self typeFor: elm.	type isSimple		ifTrue:			[(elm attributes contains: [:a | a tag namespace ~= self xsiNS])				ifTrue: [self error: 'Elements with simple types can''t have attributes'].			(elm children contains: [:nd | nd isElement])				ifTrue: [self error: 'Elements with simple types can''t have child elements']].	type validate: elm state: state2.	state2 checkIdConstraintsAfter.</body></methods><methods><class-id>XML.ElementSpecification class</class-id> <category>private</category><body package="XSchema">tagName	^'element'</body></methods><methods><class-id>XML.SchemaHandler</class-id> <category>content handler</category><body package="XSchema">endElement: namespaceURI localName: localName qName: name	"indicates the end of an element. See startElement"	| type |	nsStack := nsStack value.	type := self stack removeLast.	type internalValidation.</body><body package="XSchema">startElement: namespaceURI localName: localName qName: name attributes: attributes	"Receive notification of the beginning of an element."	| type |	namespaceURI = 'http://www.w3.org/2001/XMLSchema'		ifFalse: [self error: 'Incorrect value for the XML Schema namespace'].	newNamespaces == nil		ifTrue: [nsStack := nil -&gt; nsStack]		ifFalse: [nsStack := newNamespaces].	newNamespaces := nil.	type := self schemaElementFor: localName.	type schemaHolder: schemaHolder.	type noteElementTag: localName.	type namespaces: nsStack.	type processAttributes: attributes.	self stack isEmpty ifFalse: [type validateParent: self stack last].	(type isKindOf: Schema)		ifTrue:			[schemaHolder := type asValue.			schemaHolder value baseURI: uri].	self stack isEmpty ifFalse: [self stack last addElement: type].	self stack add: type.</body><body package="XSchema">startPrefixMapping: prefix uri: uri 	newNamespaces == nil		ifTrue: [newNamespaces := Dictionary new -&gt; nsStack].	newNamespaces key at: prefix put: uri.</body></methods><methods><class-id>XML.SchemaHandler</class-id> <category>initialize</category><body package="XSchema">initialize	stack := OrderedCollection new.	classMap := Dictionary new</body></methods><methods><class-id>XML.SchemaHandler</class-id> <category>private</category><body package="XSchema">schemaElementFor: name	| class |	class := classMap at: name			ifAbsentPut: [SchemaElement allSubclasses					detect: [:c | c matchesTag: name]					ifNone: [self error: 'No implementation for ', name]].	^class new</body></methods><methods><class-id>XML.SchemaHandler</class-id> <category>accessing</category><body package="XSchema">document	^schemaHolder value</body><body package="XSchema">documentHolder	^schemaHolder</body><body package="XSchema">parse: aDataSource	(aDataSource isKindOf: URI)		ifTrue: [uri := aDataSource]		ifFalse: [(aDataSource isString or: [aDataSource isKindOf: Filename])			ifTrue: [uri := aDataSource asFilename asURI]			ifFalse: [uri := 'xxx' asFilename asURI]].	^XMLParser new		handlers: self;		validate: false;		parse: aDataSource</body><body package="XSchema">stack	^stack</body></methods><methods><class-id>XML.SchemaHandler class</class-id> <category>instance creation</category><body package="XSchema">new	^super new initialize</body></methods><methods><class-id>XML.Field</class-id> <category>accessing</category><body package="XSchema">xpath	^xpath</body></methods><methods><class-id>XML.Field</class-id> <category>construction</category><body package="XSchema">processSingleAttribute: attr	attr tag type = 'xpath'		ifTrue:			[xpath := self parseSimpleXPath: attr value.			^self].	self attributeNotRecognized: attr</body></methods><methods><class-id>XML.Field class</class-id> <category>private</category><body package="XSchema">tagName	^'field'</body></methods><methods><class-id>XML.All</class-id> <category>validation</category><body package="XSchema">findMatchesFor: elm stack: stack incomplete: incomplete complete: complete	| baseMask count mask |	baseMask := stack last at: 3.	baseMask = ((1 bitShift: parts size) - 1)		ifTrue:			[stack last at: 3 put: (baseMask := 0).			count := stack last at: 2.			stack last at: 2 put: (count := count+1).			count &gt;= self max ifTrue: [^self].			count &gt;= self min ifTrue: [self pop: (stack collect: [:f | f copy]) into: incomplete]].	1 to: parts size do: [:i |		mask := 1 bitShift: i-1.		(baseMask bitAnd: mask) = 0			ifTrue:				[stack last at: 3 put: baseMask+mask.				stack add: (Array with: (parts at: i) with: 0 with: 0).				(parts at: i)					findMatchesFor: elm					stack: (stack collect: [:f | f copy])					incomplete: incomplete					complete: complete.				stack removeLast.				stack last at: 3 put: baseMask]].</body><body package="XSchema">findTerminatorInStack: stack incomplete: incomplete complete: complete	| baseMask count mask |	baseMask := stack last at: 3.	baseMask = ((1 bitShift: parts size) - 1)		ifTrue:			[stack last at: 3 put: (baseMask := 0).			count := stack last at: 2.			stack last at: 2 put: (count := count+1).			count &gt;= self min				ifTrue:					[stack removeLast.					^stack isEmpty						ifTrue: [complete add: stack]						ifFalse: [incomplete add: stack]]].	1 to: parts size do: [:i |		mask := 1 bitShift: i-1.		(baseMask bitAnd: mask) = 0			ifTrue:				[stack last at: 3 put: baseMask+mask.				stack add: (Array with: (parts at: i) with: 0 with: 0).				(parts at: i)					findTerminatorInStack: (stack collect: [:f | f copy])					incomplete: incomplete					complete: complete.				stack removeLast.				stack last at: 3 put: baseMask]].</body></methods><methods><class-id>XML.All class</class-id> <category>private</category><body package="XSchema">tagName	^'all'</body></methods><methods><class-id>XML.AttributeGroupSpecification</class-id> <category>validation</category><body package="XSchema">validate: aNode attributes: attributes elements: elementStream state: schemaState	Transcript show: '='</body></methods><methods><class-id>XML.AttributeGroupSpecification</class-id> <category>construction</category><body package="XSchema">addAttributesTo: type stack: stack	| myParts |	myParts := (self schema object: #attributeGroup at: refName) parts.	(stack includes: self)		ifTrue: [self error: 'An attribute group includes a direct or indirect reference to itself'].	stack add: self.	myParts do: [:p | p addAttributesTo: type stack: stack].	stack remove: self.</body><body package="XSchema">processSingleAttribute: attr	attr tag type = 'name'		ifTrue:			[name := self processNCName: attr value.			^self].	attr tag type = 'ref'		ifTrue:			[refName := self processQName: attr value.			^self].	attr tag type = 'id'		ifTrue:			[id := attr value.			^self].	self attributeNotRecognized: attr</body><body package="XSchema">registerName	self schema object: #attributeGroup at: self name put: self.	super registerName</body></methods><methods><class-id>XML.AttributeGroupSpecification class</class-id> <category>private</category><body package="XSchema">tagName	^'attributeGroup'</body></methods><methods><class-id>XML.RegExpOr</class-id> <category>construction</category><body package="XSchema">add: aNode	test == nil ifTrue: [test := #()].	test := test copyWith: aNode.</body><body package="XSchema">| aNode	self add: aNode</body></methods><methods><class-id>XML.RegExpOr</class-id> <category>testing</category><body package="XSchema">baseMatchFrom: stream	| p |	p := stream position.	1 to: test size do: [:i |		((test at: i) matchFrom: stream)			ifTrue: [^negated not]			ifFalse: [stream position: p]].	^negated</body></methods><methods><class-id>XML.Redefine</class-id> <category>construction</category><body package="XSchema">processSingleAttribute: attr	attr tag type = 'schemaLocation'		ifTrue:			[uri := attr value.			^self].	self attributeNotRecognized: attr</body><body package="XSchema">resolveReferences	| subschema realSchema |	uri notNil		ifTrue:			[subschema := SchemaHandler new				startPrefixMapping: '$' uri: self schema targetNamespace;				parse: (self schema baseURI resolvePath: uri);				documentHolder.			realSchema := self schema.			self schemaHolder value: subschema value.			self parts do: [:p | p registerName].			self schemaHolder value: realSchema.			subschema value mergeInto: self schema.			subschema value: self schema].</body></methods><methods><class-id>XML.Redefine class</class-id> <category>private</category><body package="XSchema">tagName	^'redefine'</body></methods><methods><class-id>XML.Import</class-id> <category>construction</category><body package="XSchema">processSingleAttribute: attr	attr tag type = 'namespace'		ifTrue:			[targetNamespace := attr value.			^self].	attr tag type = 'schemaLocation'		ifTrue:			[uri := attr value.			^self].	self attributeNotRecognized: attr</body><body package="XSchema">resolveReferences	| subschema |	targetNamespace == nil ifTrue: [targetNamespace := ''].	targetNamespace = self schema targetNamespace		ifTrue: [self error: 'Import may not have the same namespace as its enclosing schema'].	uri notNil		ifTrue:			[subschema := SchemaHandler new					parse: (self schema baseURI resolvePath: uri);					documentHolder.			subschema value targetNamespace = targetNamespace				ifFalse: [self halt: 'The namespace attribute does not match targetNamespace of imported schema'].			subschema value mergeInto: self schema.			subschema value: self schema].</body></methods><methods><class-id>XML.Import class</class-id> <category>private</category><body package="XSchema">tagName	^'import'</body></methods><methods><class-id>XML.Restriction</class-id> <category>construction</category><body package="XSchema">internalValidation	self parts do: [:i |		i class == RestrictionRefinement			ifTrue: [i restriction: self]].</body><body package="XSchema">processSingleAttribute: attr	attr tag type = 'base'		ifTrue:			[baseTypeName := self processQName: attr value.			^self].	self attributeNotRecognized: attr</body></methods><methods><class-id>XML.Restriction</class-id> <category>validation</category><body package="XSchema">evaluate: aString in: aNode	^self baseType evaluate: aString in: aNode</body><body package="XSchema">preprocess: string priority: priority	| val |	val := string.	self parts do: [:p | val := p preprocess: val priority: priority].	val := self baseType preprocess: string priority: priority.	^val</body><body package="XSchema">validate: aNode attributes: attributes elements: elementStream state: schemaState	self baseType validate: aNode state: schemaState.	1 to: self parts size do: [:i || v |		v := self parts at: i.		v validate: aNode			attributes: attributes			elements: elementStream			state: schemaState].</body><body package="XSchema">validate: aNode value: aString state: schemaState	| val |	val := aString.	1 to: 2 do: [:n |		self parts do: [:p |			val := p preprocess: val priority: n.			val := self baseType preprocess: val priority: n]].	self baseType validate: aNode value: val state: schemaState.	self parts do: [:v | v validate: aNode value: val state: schemaState].</body></methods><methods><class-id>XML.Restriction</class-id> <category>accessing</category><body package="XSchema">baseType	baseType == nil ifFalse: [^baseType].	baseTypeName == nil		ifFalse: [^baseType := self schema typeAt: baseTypeName].	^self parts detect: [:p | p isType]		ifNone: [self error: 'No type is known for this restriction']</body><body package="XSchema">baseType: aType	baseType := aType</body></methods><methods><class-id>XML.Restriction class</class-id> <category>private</category><body package="XSchema">tagName	^'restriction'</body></methods><methods><class-id>XML.XPathExpression</class-id> <category>matching</category><body package="XSchema">schemaMatch: aNode terminateAt: parentNode	| base |	base := self.	[base child == nil]		whileFalse: [base := base child].	^base simpleMatchFor: aNode isComplex: false do:		[:root :complex |		complex ifTrue: [self error: 'This XPath expression is too complex for XSchema''s restrictions'].		root == parentNode]</body></methods><methods><class-id>XML.XPathUnion</class-id> <category>matching</category><body package="XSchema">schemaMatch: aNode terminateAt: parentNode	1 to: arguments size do: [:a |		((arguments at: a) schemaMatch: aNode terminateAt: parentNode) ifTrue: [^true]].	^false</body></methods><methods><class-id>XML.XPathCurrentNode</class-id> <category>matching</category><body package="XSchema">simpleMatchFor: anXmlNode isComplex: complex do: aBlock	| hasCP set |	(baseTest match: anXmlNode) ifFalse: [^false].	(hasCP := self hasComplexPredicate)		ifFalse:			[set := XPathNodeContext new add: anXmlNode.			1 to: predicates size do: [:i |				set := set select: (predicates at: i)].			set size = 0 ifTrue: [^false halt]].	parent == nil ifTrue: [^aBlock value: anXmlNode value: complex | hasCP].	^parent simpleMatchFor: anXmlNode		isComplex: complex | hasCP		do: aBlock</body></methods><initialize><class-id>XML.Schema</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>SAXDriver</name><environment>XML</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>locator </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-SAX</category><attributes><package>XML</package></attributes></class><class><name>Link</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>nextLink </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Support</category><attributes><package>Collections-Support</package></attributes></class><class><name>XPathExpression</name><environment>XML</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>predicates child </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XPath</category><attributes><package>XPath</package></attributes></class><class><name>XPathCurrentNode</name><environment>XML</environment><super>XML.XPathStep</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XPath</category><attributes><package>XPath</package></attributes></class><class><name>Magnitude</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>XPathUnion</name><environment>XML</environment><super>XML.XPathExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars>arguments </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XPath</category><attributes><package>XPath</package></attributes></class></st-source>