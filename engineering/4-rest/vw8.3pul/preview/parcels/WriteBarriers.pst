<?xml version="1.0"?><st-source><!-- Name: WriteBarriersNotice: Copyright 1999-2013 Cincom Systems, Inc.  All rights reserved.Comment: WriteBarriers allows multiple frameworks to monitor immutability exceptions in different ways. Normally only one immutability policy can exist in an image at once. This framework makes object change tracking pluggable using subclasses of Tracker. See the Tracker class's comment for details on how to use them.DbIdentifier: bear73DbTrace: 400806DbUsername: nrossDbVersion: 9Namespace: Smalltalk.WriteBarriersPackageName: WriteBarriersParcel: #('WriteBarriers')PrintStringCache: (9,nross)Version: 9Date: 7:26:03 AM April 3, 2013 --><time-stamp>From VisualWorksÂ®, Pre-Release 7.10 (mar13.5) of April 3, 2013 on April 3, 2013 at 7:26:03 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>WriteBarriers</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			</imports><category>ModificationManagementToo</category><attributes><package>WriteBarriers</package></attributes></name-space><class><name>CannotTrackError</name><environment>WriteBarriers</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>WriteBarriers</package></attributes></class><comment><class-id>WriteBarriers.CannotTrackError</class-id><body>CannotTrackError is raised if you are attempting to track an object that is already immutable. This is considered an error because if we weren't responsible for making it immutable with a tracker, then when you untrack the object from a tracker it will become mutable - this could be particularly bad if you did it on a Symbol, etc.</body></comment><class><name>Tracker</name><environment>WriteBarriers</environment><super>Core.Announcer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ModificationManagementToo</category><attributes><package>WriteBarriers</package></attributes></class><comment><class-id>WriteBarriers.Tracker</class-id><body>A Tracker represents a way of dealing with an immutability exception.If an object is marked as immutable and a process attempts to change the object, each registered Tracker is asked if it is tracking the object. If it is tracking the object, it is given the opportunity to do something about the requested change.The default behavior of a Tracker that is tracking an object is to apply the change to the object. This behaviour can be customized to do anything you want by subclassing Tracker and implementing #applyModificationTo:selector:index:value:A Tracker must implement a way of tracking and untracking objects, answering whether it is tracking anObject and what to do when a modification occurs for the Tracker.Must implement:	#privateTrack:	#privateUntrack:	#isTracking:You can also override the following:	#modified:selector:index:value:		This is called when an object that is being tracked is modified. In this method you must decide whether you are interested in the object (by sending #isTracking:) and then what to do with the modification (by default, #applyModificationTo:selector:index:value: is called).		You can override this method to make a global tracker that responds to any change to any object, however this means you would never be able to have an untracked immutable object. This is considered bad style.	#applyModificationTo:selcetor:index:value:		This is called when an object that is being tracked by your Tracker subclass is modified. By default, this method will apply the change to the object, however this may not be what you want your Tracker to do. Override this method to make a custom implementation of what you want to happen.** An important note about Immutability:If an object is immutable before a tracker is applied to it, then no tracker can be applied to the object. The reason for this is because once an object becomes untracked, it will become mutable again. If more than one tracker is tracking an object at once, it will only become mutable again once all the trackers are no longer tracking the object.Consider the example of a Symbol, #test. If we track it and then untrack it, it will become mutable - which could be a very bad thing if the symbol is also the selector of a method. Because of this connundrum, you can only start tracking objects that begin mutable or are already being tracked by another tracker.** An important note about using multiple trackers on the same object:It is okay to use more than one tracker on an object at once, however you must be aware that blending trackers in this way may be problematic. If you have a tracker that wants to mutate the modification before applying it to the object, eg: substituting the argument for another object, you may have a problem if the other tracker is applied after the first tracker and also applies the modification in an untransformed fashion.Because there is no "fair" system for deciding which tracker has more importance and there is no easy way to guarantee tracker order, the ability to have more than one tracker applying changes in a transforming fashion is left up to the developer to deal with. If you want to do this, you may wish to detect when another applying tracker is already tracking an object you are about to track.Alternatively you may want to make Tracker subclass used by your framework pluggable, so that a developer using two tracking systems that do this kind of trick can override your Tracker subclass with their own to make the behavior coherent between the two tracking systems.As a final note, it should be understood that if two applying trackers do no transformation of the arguments, the above issues are not actually a problem, however you are taking a small speed penalty for applying the change to the object twice. If you notice this in your profiling as a cause for speed issues, consider applying the above techniques to avoid doing a double apply.** Registering and Deregistering trackers:When an instance of a subclass of Tracker is instantiated it is registered in the global Trackers collection after its #initialize method. To stop it tracking objects, send #release to your instance. It is important to note that even after releasing the tracker it *may* still receive messages due to race conditions between processes. Your tracker should keep some state to know if it has been deregistered and to ignore requests to perform actions.** Design assumptions:There is an assumption that a Tracker will answer #isTracking: and #modified:selector:index:value: much more often than a tracker is created and released. The create/release actions perform a copy of Trackers which could be costly if there are more trackers than there are NoModificationError exceptions.Shared Class Variables:	Trackers	&lt;OrderedCollection of: Tracker&gt;</body></comment><shared-variable><name>Trackers</name><environment>WriteBarriers.Tracker</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>OrderedCollection new</initializer><attributes><package>WriteBarriers</package></attributes></shared-variable><methods><class-id>WriteBarriers.Tracker</class-id> <category>private</category><body package="WriteBarriers">applyModificationTo: anObject selector: selector index: index value: value	anObject whileMutableDo: [		index isNil			ifTrue: [anObject perform: selector with: value]			ifFalse: [anObject perform: selector with: index with: value]]</body><body package="WriteBarriers">cannotTrackError	^CannotTrackError raiseSignal</body><body package="WriteBarriers">modified: anObject selector: selector index: index value: value	"Someone is trying to modify anObject using selector and at the slot indicated by index. Do whatever we need to do for such a modification; returning either true or false, where true means we were interested in the modification to this object."	(self isTracking: anObject) ifFalse: [^false].	self applyModificationTo: anObject selector: selector index: index value: value.	^true</body><body package="WriteBarriers">privateTrack: anObject	"We are interested in keeping track of @anObject in whatever manner interests us - storing it in a collection, a cache, bossing it out, whatever."	^self subclassResponsibility</body><body package="WriteBarriers">privateUntrack: anObject	"We are no longer interested in keeping track of @anObject so remove it from whatever cache, collection, whatever that it was added to in #privateTrack:"	^self subclassResponsibility</body></methods><methods><class-id>WriteBarriers.Tracker</class-id> <category>API</category><body package="WriteBarriers">isTracking: anObject		"Is anObject something that we are tracking?"	"^false"	^self subclassResponsibility</body><body package="WriteBarriers">track: anObject	(anObject isImmutable and: [anObject hasTrackers not]) ifTrue: [^self cannotTrackError].	anObject beImmutable.	self privateTrack: anObject</body><body package="WriteBarriers">untrack: anObject	(self isTracking: anObject) ifFalse: [^self].	anObject trackers size = 1 ifTrue: [anObject beMutable].	self privateUntrack: anObject</body></methods><methods><class-id>WriteBarriers.Tracker</class-id> <category>initialize-release</category><body package="WriteBarriers">initialize</body><body package="WriteBarriers">release	"	Remove the receiver from Trackers using copyWithout: to protect against possible modification	while another process is in the middle of raising/handling NoModificationError exception.	(AR 61547)	"	Trackers := Trackers copyWithout: self.	super release</body></methods><methods><class-id>WriteBarriers.Tracker class</class-id> <category>API</category><body package="WriteBarriers">hasTrackersTracking: anObject	^Trackers anySatisfy: [:each | each isTracking: anObject]</body><body package="WriteBarriers">trackersTracking: anObject	^Trackers select: [:each | each isTracking: anObject]</body><body package="WriteBarriers">untrack: anObject	(self trackersTracking: anObject) do: [:each | each untrack: anObject]</body></methods><methods><class-id>WriteBarriers.Tracker class</class-id> <category>private</category><body package="WriteBarriers">modified: object selector: selector index: index value: value	| anybodyCared |	anybodyCared := Trackers inject: false into: [ :cared :each | (each modified: object selector: selector index: index value: value) or: [cared]].	anybodyCared ifFalse: [		(NoModificationError receiver: object selector: selector index: index value: value) raiseSignal].	^value.</body></methods><methods><class-id>WriteBarriers.Tracker class</class-id> <category>creation</category><body package="WriteBarriers">new	"	Create a new instance and add it to the Trackers using copyWith: to protect against possible modification	while another process is in the middle of raising/handling NoModificationError exception.	(AR 61547)	"	| instance |	self == WriteBarriers.Tracker ifTrue: [^self error: 'Don''t instantiate me and register me as a tracker, because I''m abstract, I will start throwing #subclassResponsibility exceptions if tracked objects get changed'].	instance := super new initialize.	Trackers := Trackers copyWith: instance.	^instance</body></methods><methods><class-id>Core.NoModificationError class</class-id> <category>testing</category><body package="WriteBarriers">mayResume	^true.</body></methods><methods><class-id>Core.Object</class-id> <category>write barrier tracking</category><body package="WriteBarriers">hasTrackers	^WriteBarriers.Tracker hasTrackersTracking: self</body></methods><methods><class-id>Core.Object</class-id> <category>error handling</category><body package="WriteBarriers">noModificationErrorFor: selector index: index value: value	^WriteBarriers.Tracker modified: self selector: selector index: index value: value</body></methods><methods><class-id>Core.Object</class-id> <category>write barrier tracking</category><body package="WriteBarriers">trackers	^WriteBarriers.Tracker trackersTracking: self</body><body package="WriteBarriers">trackWith: tracker	tracker track: self</body><body package="WriteBarriers">untrackFrom: tracker	tracker untrack: self</body><body package="WriteBarriers">untrackFromAll	WriteBarriers.Tracker untrack: self</body></methods><methods><class-id>Core.Class</class-id> <category>initialize-release</category><body package="WriteBarriers">localObsolete	"Change the receiver to an obsolete class by changing its name to have the prefix -AnObsolete-, and nilling the fields of any instances."	self isPointers ifTrue:		[self allInstancesDo: [:instance | instance beMutable; nilFields]]. 	"nil fields of instances"	('AnObsolete*' match: name) ifFalse:		[name := 'AnObsolete' , name].	classPool := nil.	super localObsolete</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Announcer</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>subscriptionRegistry </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Model-Observables</category><attributes><package>System-Announcements</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>Class</name><environment>Core</environment><super>Core.ClassDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name classPool environment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class></st-source>