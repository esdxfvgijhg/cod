<?xml version="1.0"?><st-source><!-- Name: BOSS64Notice: Copyright © 2010-1999 Cincom Systems, Inc.  All Rights Reserved.Comment: Contains the Binary Object Streaming Service, which supports efficient storage and retrieval of objects, including code, to and from files.  This contains a preview implementation of a new 64 bit format for BOSS.DbIdentifier: bear73DbTrace: 288829DevelopmentPrerequisites: #(#(#any 'BOSS' ''))PackageName: BOSS64Parcel: #('BOSS64')PrerequisiteParcels: #(#('BOSS' ''))PrintStringCache: (7.7 - 2,trobinson)Version: 7.7 - 2Date: 5:44:18 PM June 8, 2010 --><time-stamp>From VisualWorks®, Pre-Release 7.7.1 (jun10.3) of June 8, 2010 on June 8, 2010 at 5:44:18 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>BinaryObjectStorage64</name><environment>Kernel</environment><super>Kernel.AbstractBinaryObjectStorage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Binary Storage</category><attributes><package>BOSS64</package></attributes></class><comment><class-id>Kernel.BinaryObjectStorage64</class-id><body>BinaryObjectStorage provides for writing object structures on a stream in a compact, rapidly loadable binary format, and reading them back in again.  Instances of this class only hold the state that persists between successive reading or writing operations: each such operation creates a transient instance of BOSSReader or BOSSWriter to hold the temporary state of the reading or writing process.  This class implements the 64 bit implementation of BOSS.Instance Variables	stream	&lt;PositionableStream&gt;  stream for reading or writing object structures	platformDescription	&lt;ByteArray&gt;  description of platform where objects were written	initialPosition	&lt;Integer&gt;  position of first object structure	readerClass	&lt;BOSSReader class&gt;  class to instantiate to read a structure	writerClass	&lt;BOSSWriter class&gt;  class to instantiate to write a structure	sourceMode	&lt;Symbol&gt;  #keep, #discard, or #reference	readerMap	&lt;IdentityDictionary key: SmallInteger value: Object&gt;  map from object indices to objects	writerMap	&lt;IdentityDictionary key: Object value: SmallInteger&gt;  map from objects to indices	nextIndex	&lt;Integer&gt;  next object index to be assigned (a multiple of 8)	registry	&lt;OrderedCollection of: BOSSRegisteredObject&gt;	versionReaders	&lt;IdentityDictionary of: (Behavior -&gt; BlockClosure)&gt;  how to handle obsolete versions	classVarLists	&lt;IdentityDictionary of: (Behavior -&gt; (Array | nil))&gt;  lists of the names of all named instance variables for each class in the image that created the file.	expectCycles	&lt;Boolean&gt; controls policy concerning how cautious certain classes should be in storing themselves in a way that does not break due to pointer cycles	mapXeroxToUnicode		&lt;Boolean | nil&gt; nil is treated as false. If true, then a BOSSReader will attempt to transform Strings and Characters from XCCS encoding to Unicode. This may fail for strings that contain unusual characters.Class Variables	BinaryErrorSignal	&lt;Signal&gt;  comment	FormatErrorSignal	&lt;Signal&gt;  comment	HeaderErrorSignal	&lt;Signal&gt;  comment</body></comment><class><name>BinaryObjectStorageFactory</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream storageClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Binary Storage</category><attributes><package>BOSS64</package></attributes></class><comment><class-id>Kernel.BinaryObjectStorageFactory</class-id><body>This class decides whether to use a BinaryObjectStorage for 32 or 64 bits by reading enough from the stream to make the decision.Instance Variables	stream	&lt;Object&gt;	The BOSS stream	storageClass &lt;AbstractBinaryObjectStorage | nil&gt; The chosen concrete binary object storage</body></comment><class><name>BOSSWriter64</name><environment>Kernel</environment><super>Kernel.BOSSAbstractWriter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Binary Storage</category><attributes><package>BOSS64</package></attributes></class><comment><class-id>Kernel.BOSSWriter64</class-id><body>I write out a single object structure in a rapidly-loadable binary format.  This is the 64 bit implementation.Instance Variables	headers	&lt;BOSSBytes&gt;  contains headers for objects being written	bodies	&lt;Array&gt;  bodies and classes of objects being written	objects	&lt;IdentityDictionary of: (Object -&gt; Integer)&gt;  map from objects to indices	baseIndex	&lt;Integer&gt;  index of first object being written	currentClass	&lt;ClassDescription&gt;  class for reverse-resolving Associations	recentClasses	&lt;Array size: 15&gt;  ring buffer of recently used classes	nextRecentClass	&lt;Integer between: 1 and: 15&gt;  next index for storing in ring buffer	bodySize	&lt;Integer&gt;  total space for object bodies	nilIndex	&lt;nil | Integer&gt;  object index for nil	traceClasses	&lt;IdentityDictionary of: (Behavior -&gt; Symbol)&gt;  selectors for tracing specific classes	registry	&lt;OrderedCollection of: BOSSRegisteredObject&gt;The swapBytes instance variable is only needed for the case where we are appending to a file that was written on a platform with a different byte order.See the documentation category in the class methods for more information about the file format.Non-negative values in the objects dictionary are encoded oops (header indices * 4) for objects that have been fully written.  -1 is reserved.  -2 means that this object is currently in the process of being written: if we encounter a -2, we assign an object index on the spot.  This ensures that any object not involved in a circular reference will be written after all objects it references.  Other negative indices indicate registered objects, the first being -3.  Positive entries are strictly a cache for the writerMap in the BinaryObjectStorage.Individual tracing/writing methods return one of three values:	- nil, meaning use the standard representation;	- an Association (integer -&gt; object), indicating that the object (in the form of either a ByteString or an Array) will be passed to a special import method with the given index;	- an array of (receiver selector arg1 ... argn), indicating that the object will be constructed at read time by sending the given message.Internal methods of BOSSWriter can also return an integer, giving the object index.</body></comment><class><name>BOSSReaderMap64</name><environment>Kernel</environment><super>Kernel.AbstractBOSSReaderMap</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Binary Storage</category><attributes><package>BOSS64</package></attributes></class><comment><class-id>Kernel.BOSSReaderMap64</class-id><body>This class implements the index-to-object map when reading from a BinaryObjectStorage stream.  Objects with indices in [baseIndex..baseIndex+(self size-1*8)] are stored directly; objects with other indices are looked up in the BinaryObjectStorage.  Note that indices are 0-origin multiples of 8.Instance Variables	baseIndex	&lt;Integer&gt;  holds objects for this structure	storage	&lt;BinaryObjectStorage&gt;  holds other objects</body></comment><class><name>BOSSReader64</name><environment>Kernel</environment><super>Kernel.BOSSAbstractReader</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Binary Storage</category><attributes><package>BOSS64</package></attributes></class><comment><class-id>Kernel.BOSSReader64</class-id><body>I read a single object structure that was stored in a rapidly-loadable binary format.  This is the 64 bit implementation.Instance Variables	readingClasses	&lt;Boolean&gt;  true if reading classes, false if reading ordinary objects	headers	&lt;BOSSBytes&gt;  contains headers for objects being written	objects	&lt;BOSSReaderMap&gt;  map indices to objects	baseIndex	&lt;Integer&gt;  index of first object in structure	recentClasses	&lt;OrderedCollection size: 15&gt;  recently used classes	compiledCode	&lt;OrderedCollection of: Array&gt;  compiled code needing sources to be fixed up	deferredSends	&lt;OrderedCollection of: MessageSend&gt; evaluations that should not be performed until the compiledCode has been fixed up, along with any other cleanupClass Variables	XeroxMap		&lt;LargeArray&gt; mapping from XCCS code points to Unicode code points. Because of 1-based indexing, add 1 to the XCCS value to find the right Unicode value. If a value maps to nil, the mapping is unknown--this does not mean that there is no mapping, only that the patch does not supply it.Odd-numbered imports have bit-type data, even-numbered have pointer-type.</body></comment><methods><class-id>Kernel.BinaryObjectStorage64</class-id> <category>private - accessing</category><body package="BOSS64" selector="addTagBitsTo:">addTagBitsTo: anInteger	^anInteger bitShift: 3</body><body package="BOSS64" selector="bytesPerLongOop">bytesPerLongOop	^8</body><body package="BOSS64" selector="defaultReaderClass">defaultReaderClass	^BOSSReader64</body><body package="BOSS64" selector="defaultWriterClass">defaultWriterClass	^BOSSWriter64</body><body package="BOSS64" selector="removeTagBitsFrom:">removeTagBitsFrom: anInteger	^anInteger bitShift: -3</body><body package="BOSS64" selector="tagBitsFrom:">tagBitsFrom: anInteger	^anInteger bitAnd: 7</body></methods><methods><class-id>Kernel.BinaryObjectStorage64 class</class-id> <category>documentation</category><body package="BOSS64" selector="fileFormat">fileFormat	"The file format for 64 bit BOSS is marked with version 8.  Currently,	the differences between version 7 and version 8 are as follows.	Long oops are 8 bytes long instead of 4.  Object counts and long	body sizes are also 8 bytes.  Short oops are still 2 bytes.	Immediate objects are encoded with 3 tag bits instead of 2.  This	allows the expression of small doubles as an encoded oop using	the 3 tag bits set to 5."	self commentOnly</body><body package="BOSS64" selector="structureFormat">structureFormat	"The differences between version 7 and version 8 are detailed below.	Long oops are 8 bytes instead of 4.  This means short prefix are 8	bytes instead of 4.  The +2 convention to select either short prefix	or long prefix format still applies, however the long prefix is now 24	bytes as opposed to 12 because the three counts are 8 bytes long.	Headers are 5 bytes per object instead of 4, to accomodate 20 bits'	worth of identityHash in 64 bit images instead of the 14 bits present	in 32 bit images.  The order of fields in the header does not change.	Short oops are still 2 bytes.  Long oops are 8 bytes.  These are	written with 3 tag bits as opposed to 2 tag bits.  This is so that small	doubles can be encoded in an oop using the 3 tag bits set to 5.	Note that some small doubles such as 0.0d and -0.0d can get	encoded in a short oop.  Therefore, even short oops have 3 tag bits.	The +2 convention is still used."	self commentOnly</body></methods><methods><class-id>Kernel.BinaryObjectStorage64 class</class-id> <category>private - instance creation</category><body package="BOSS64" selector="newInstance">newInstance	^self basicNew</body></methods><methods><class-id>Kernel.BinaryObjectStorage64 class</class-id> <category>private - accessing</category><body package="BOSS64" selector="streamFormatNumber">streamFormatNumber	" Answer the format number supported by this	version of this class. "	^8</body></methods><methods><class-id>Kernel.BinaryObjectStorageFactory</class-id> <category>accessing</category><body package="BOSS64" selector="binaryObjectStorage">binaryObjectStorage	^(self storageClass basicNew on: stream)		initializeAfterCheckHeader;		yourself</body></methods><methods><class-id>Kernel.BinaryObjectStorageFactory</class-id> <category>private - factory</category><body package="BOSS64" selector="checkHeader">checkHeader	| format newStorageClass |	self checkHeaderMagicBytes.	format := self readHeaderFormat.	newStorageClass := self classForFormat: format.	newStorageClass isNil ifTrue: [self formatErrorSignal raiseWith: format].	self storageClass: newStorageClass</body><body package="BOSS64" selector="checkHeaderMagicBytes">checkHeaderMagicBytes	1 to: self headerMagicBytes size do:		[:i |			stream next = (self headerMagicBytes at: i) asInteger				ifFalse: [self headerErrorSignal raise]		]</body><body package="BOSS64" selector="classForFormat:">classForFormat: aFormat	AbstractBinaryObjectStorage allSubclassesDo:		[:each | each streamFormatNumber = aFormat ifTrue: [^each]].	^nil</body><body package="BOSS64" selector="headerMagicBytes">headerMagicBytes	^'BOSS '</body><body package="BOSS64" selector="on:">on: aStream 	"Create a new instance of the receiver on aStream, making sure 	that this stream can handle binary reading and writing."	(aStream class canUnderstand: #binary)		ifTrue: [aStream binary].	stream := aStream.	self initialize</body><body package="BOSS64" selector="readHeaderFormat">readHeaderFormat	| answer char |	answer := 0.	[		char := Character value: stream next.		char isDigit	] whileTrue: [answer := answer * 10 + char digitValue].	char = Character space ifFalse: [self headerErrorSignal raise].	^answer</body></methods><methods><class-id>Kernel.BinaryObjectStorageFactory</class-id> <category>private - accessing</category><body package="BOSS64" selector="formatErrorSignal">formatErrorSignal	^AbstractBinaryObjectStorage formatErrorSignal</body><body package="BOSS64" selector="headerErrorSignal">headerErrorSignal	^AbstractBinaryObjectStorage headerErrorSignal</body><body package="BOSS64" selector="storageClass">storageClass	^storageClass</body><body package="BOSS64" selector="storageClass:">storageClass: anObject	storageClass := anObject</body></methods><methods><class-id>Kernel.BOSSWriter64</class-id> <category>private-constants</category><body package="BOSS64" selector="bytesPerHeader">bytesPerHeader	^5</body><body package="BOSS64" selector="bytesPerLongOop">bytesPerLongOop	^8</body></methods><methods><class-id>Kernel.BOSSWriter64</class-id> <category>private</category><body package="BOSS64" selector="encode:">encode: anObject	| class |	class := anObject class.	class == SmallInteger ifTrue: [^(anObject bitShift: 3) + 3].	class == SmallDouble ifTrue: [^self encodeSmallDouble: anObject].	class == Character ifTrue: [^(anObject asInteger bitShift: 3) + 1].	^self encodeNonImmediateObject: anObject</body><body package="BOSS64" selector="encodeSmallDouble:">encodeSmallDouble: aSmallDouble	| bytes answer signBit |	bytes := aSmallDouble asDegenerateDouble.	answer := 0.	swapBytes ~= aSmallDouble isBigEndian		ifTrue: [1 to: 8 do: [:each | answer := answer * 256 + (bytes basicAt: each)]]		ifFalse: [8 to: 1 by: -1 do: [:each | answer := answer * 256 + (bytes basicAt: each)]].	answer := answer bitShift: 1.	signBit := answer digitAt: 9.	answer := 16rFFFFFFFFFFFFFFFF bitAnd: answer.	aSmallDouble = 0.0d ifFalse: [answer := answer - (1023 - 128 + 1 bitShift: 52 + 1)].	answer := answer + signBit.	answer := (answer bitShift: 3) + 5.	answer &gt;= 16r8000000000000000 ifTrue: [answer := answer - 16r10000000000000000].	^answer</body><body package="BOSS64" selector="writeBodyLength:">writeBodyLength: bodyLength	self writeLongLong: bodyLength</body><body package="BOSS64" selector="writeIndexOnly:">writeIndexOnly: topObject	" Write out the representation of a top object	that already has an index assigned. "	| value |	baseIndex := SmallInteger maxVal.	value := self encode: topObject.	self writeLongLong: value</body><body package="BOSS64" selector="writeLongBody:class:flags:">writeLongBody: body class: cx flags: flags	(self flagsRecentClass: flags) ifFalse: [self writeLongLong: cx].	self writeLongBody: body flags: flags</body></methods><methods><class-id>Kernel.BOSSWriter64</class-id> <category>private-headers</category><body package="BOSS64" selector="headersAt:put:object:size:">headersAt: localxput: flagsobject: anObjectsize: objectSize	| headerx identityHash |	headerx := localx // self bytesPerLongOop * self bytesPerHeader.	headers byteAt: headerx + 1 put: flags.	headers byteAt: headerx + 2 put: (objectSize min: 16rff).	identityHash := anObject identityHash bitAnd: 16rFFFFF.	headers byteAt: headerx + 3 put: (identityHash bitShift: -16).	headers byteAt: headerx + 4 put: ((identityHash bitShift: -8) bitAnd: 16rFF).	headers byteAt: headerx + 5 put: (identityHash bitAnd: 16rFF)</body><body package="BOSS64" selector="swapIndentityHashHeaderBytes">swapIndentityHashHeaderBytes	swapBytes ifTrue: [headers swapColumn64: 2 with: 4]</body></methods><methods><class-id>Kernel.BOSSWriter64</class-id> <category>private-initialize-release</category><body package="BOSS64" selector="initializeTraceClasses">initializeTraceClasses	"This must include every immediate class,	and any other class whose stored representation	shouldn't be affected by policy or individual	implementation of representBinaryOn:. "	super initializeTraceClasses.	traceClasses at: SmallDouble put: #traceSkip:</body></methods><methods><class-id>Kernel.BOSSWriter64</class-id> <category>private-oops</category><body package="BOSS64" selector="longOops:at:put:">longOops: anObjectat: anIndexput: aValue	anObject longLongAt: anIndex put: aValue</body><body package="BOSS64" selector="swapLongOopsIn:">swapLongOopsIn: anObject	swapBytes ifTrue: [anObject eightByteEndiannessSwap]</body><body package="BOSS64" selector="writeLongOop:">writeLongOop: anOop	self writeLongLong: anOop</body><body package="BOSS64" selector="writeSingleLongOop:">writeSingleLongOop: anOop	self writeLongOop: -16r8000000000000000 + anOop</body></methods><methods><class-id>Kernel.BOSSReaderMap64</class-id> <category>accessing</category><body package="BOSS64" selector="at:">at: index	"This handles out-of-range indices by trying an access to the array0"	^self primitiveAt: (index bitShift: -3) - baseIndex</body></methods><methods><class-id>Kernel.BOSSReaderMap64</class-id> <category>private - accessing</category><body package="BOSS64" selector="at:put:">at: index put: value	"This only works for in-range indices"	storage atIndex: index put: value.	^self basicAt: (index bitShift: -3) - baseIndex put: value</body><body package="BOSS64" selector="bitsPerIndex">bitsPerIndex	^3</body><body package="BOSS64" selector="bytesPerLongOop">bytesPerLongOop	^8</body></methods><methods><class-id>Kernel.BOSSReaderMap64</class-id> <category>private</category><body package="BOSS64" selector="primitiveAt:">primitiveAt: index	&lt;primitive: 60&gt;	^storage objectAtIndex: (index + baseIndex bitShift: 3)</body></methods><methods><class-id>Kernel.BOSSReader64</class-id> <category>private-constants</category><body package="BOSS64" selector="baseIndexFromPrefix:">baseIndexFromPrefix: prefix	^prefix bitAnd: 16rFFFFFFFFFFFFFF8</body><body package="BOSS64" selector="bytesPerHeader">bytesPerHeader	^5</body><body package="BOSS64" selector="bytesPerLongOop">bytesPerLongOop	^8</body><body package="BOSS64" selector="tagBitsFrom:">tagBitsFrom: anInteger	^anInteger bitAnd: 7</body></methods><methods><class-id>Kernel.BOSSReader64</class-id> <category>private-oops</category><body package="BOSS64" selector="bodyLengthAt:from:">bodyLengthAt: anIndexfrom: anObject	^anObject longLongAt: anIndex</body><body package="BOSS64" selector="longOops:at:put:">longOops: anObjectat: anIndexput: aValue	anObject longLongAt: anIndex put: aValue</body><body package="BOSS64" selector="longOops:signedAt:">longOops: anObjectsignedAt: anIndex	^anObject longLongAt: anIndex</body><body package="BOSS64" selector="longOops:unsignedAt:">longOops: anObjectunsignedAt: anIndex	^anObject unsignedLongLongAt: anIndex</body><body package="BOSS64" selector="swapLongOopsIn:">swapLongOopsIn: anObject	swapBytes ifTrue: [anObject eightByteEndiannessSwap]</body></methods><methods><class-id>Kernel.BOSSReader64</class-id> <category>private-reading</category><body package="BOSS64" selector="objectAt:from:baseIndex:">objectAt: anIndexfrom: aBufferbaseIndex: aBaseIndex	^aBuffer		object64At: anIndex		objectMap: objects		baseIndex: aBaseIndex		swapBytes: swapBytes</body><body package="BOSS64" selector="shortObjectAt:from:baseIndex:">shortObjectAt: anIndexfrom: aBufferbaseIndex: aBaseIndex	^aBuffer		shortObject64At: anIndex		objectMap: objects		baseIndex: aBaseIndex		swapBytes: swapBytes</body><body package="BOSS64" selector="singleObjectFrom:">singleObjectFrom: first	"Answer a single object whose oop is the first self bytesPerIndex bytes of first"	^first object64At: 1 objectMap: objects baseIndex: 0 swapBytes: swapBytes</body></methods><methods><class-id>Kernel.BOSSReader64</class-id> <category>private</category><body package="BOSS64" selector="readerMapClass">readerMapClass	^BOSSReaderMap64</body></methods><methods><class-id>Kernel.BOSSReader64</class-id> <category>private-headers</category><body package="BOSS64" selector="swapIndentityHashHeaderBytes">swapIndentityHashHeaderBytes	swapBytes ifTrue: [headers swapColumn64: 2 with: 4]</body></methods><methods><class-id>Kernel.BinaryStorageBytes</class-id> <category>accessing</category><body package="BOSS64" selector="object64At:objectMap:baseIndex:swapBytes:">object64At: datax objectMap: objMap baseIndex: baseIndex swapBytes: swapBytes	" Decode the encoded oop at byte index	datax in the receiver.  objMap is the table of	decoded objects.  baseIndex is the object	index of the first element of the table. "	| value |	value := self unsignedLongLongAt: datax.	^self object64From: value from: objMap baseIndex: baseIndex swapBytes: swapBytes</body><body package="BOSS64" selector="object64From:from:baseIndex:swapBytes:">object64From: value from: objMap baseIndex: baseIndex swapBytes: swapBytes	" Decode the encoded oop given in value.	objMap is the table of decoded objects.	baseIndex is the object index of the first	element of the table. "	| characterBits |	(value bitAnd: 1) = 0 ifTrue:		["not immediate"			^(value bitAnd: 2) = 0				ifTrue: [objMap at: value]				ifFalse: [objMap at: value - 2 + baseIndex]		].	(value bitAnd: 2) &gt; 0 ifTrue:		["small integer"			| smallIntegerBits |			smallIntegerBits := value bitShift: -3.			^(smallIntegerBits bitAnd: 16r1000000000000000) &gt; 0				ifTrue: [smallIntegerBits - 16r2000000000000000]				ifFalse: [smallIntegerBits]		].	(value bitAnd: 4) &gt; 0 ifTrue:		["small double"			| smallDoubleBits signBit double |			smallDoubleBits := value bitShift: -3.			signBit := smallDoubleBits bitAnd: 1.			smallDoubleBits := smallDoubleBits bitShift: -1.			smallDoubleBits = 0 ifFalse: [smallDoubleBits := smallDoubleBits + (1023 - 128 + 1 bitShift: 52)].			smallDoubleBits := (signBit bitShift: 63) + smallDoubleBits.			double := self class new: 8.			1 to: 8 do: [:each | double basicAt: each put: (smallDoubleBits digitAt: each)].			swapBytes ~= UninterpretedBytes isBigEndian ifTrue: [double eightByteEndiannessSwap].			double changeClassToThatOf: 1.0d40.			^double + 0.0d		].	"immediate, character"	characterBits := value bitShift: -3.	^Character value: characterBits</body><body package="BOSS64" selector="shortObject64At:objectMap:baseIndex:swapBytes:">shortObject64At: datax objectMap: objMap baseIndex: baseIndex swapBytes: swapBytes	" Decode the encoded oop at byte index	datax in the receiver.  objMap is the table of	decoded objects.  baseIndex is the object	index of the first element of the table.  Some	small doubles such as 0.0d may get here,	reuse the code for large oops"	| value |	value := self unsignedShortAt: datax.	^self object64From: value from: objMap baseIndex: baseIndex swapBytes: swapBytes</body></methods><methods><class-id>Kernel.BinaryStorageBytes</class-id> <category>byte endianness</category><body package="BOSS64" selector="swapColumn64:with:">swapColumn64: c0 with: c1	" Swap bytes at indices 5N+c0+1 with	those at indices 5N+c1+1. "	1 to: self size by: 5 do:		[:i |			| t |			t := self at: i + c0.			self at: i + c0 put: (self at: i + c1).			self at: i + c1 put: t		]</body></methods><methods><class-id>Kernel.BOSSBytes</class-id> <category>accessing</category><body package="BOSS64" selector="object64At:objectMap:baseIndex:swapBytes:">object64At: datax objectMap: objMap baseIndex: baseIndex swapBytes: swapBytes	" Decode the encoded oop at byte index	datax in the receiver.  objMap is the table of	decoded objects.  baseIndex is the object	index of the first element of the table. "	| value |	value := self unsignedLongLongAt: datax.	^self object64From: value from: objMap baseIndex: baseIndex swapBytes: swapBytes</body><body package="BOSS64" selector="object64From:from:baseIndex:swapBytes:">object64From: value from: objMap baseIndex: baseIndex swapBytes: swapBytes	" Decode the encoded oop given in value.	objMap is the table of decoded objects.	baseIndex is the object index of the first	element of the table. "	| characterBits |	(value bitAnd: 1) = 0 ifTrue:		["not immediate"			^(value bitAnd: 2) = 0				ifTrue: [objMap at: value]				ifFalse: [objMap at: value - 2 + baseIndex]		].	(value bitAnd: 2) &gt; 0 ifTrue:		["small integer"			| smallIntegerBits |			smallIntegerBits := value bitShift: -3.			^(smallIntegerBits bitAnd: 16r1000000000000000) &gt; 0				ifTrue: [smallIntegerBits - 16r2000000000000000]				ifFalse: [smallIntegerBits]		].	(value bitAnd: 4) &gt; 0 ifTrue:		["small double"			| smallDoubleBits signBit double |			smallDoubleBits := value bitShift: -3.			signBit := smallDoubleBits bitAnd: 1.			smallDoubleBits := smallDoubleBits bitShift: -1.			smallDoubleBits = 0 ifFalse: [smallDoubleBits := smallDoubleBits + (1023 - 128 + 1 bitShift: 52)].			smallDoubleBits := (signBit bitShift: 63) + smallDoubleBits.			double := self class new: 8.			1 to: 8 do: [:each | double basicAt: each put: (smallDoubleBits digitAt: each)].			swapBytes ~= UninterpretedBytes isBigEndian ifTrue: [double eightByteEndiannessSwap].			double changeClassToThatOf: 1.0d40.			^double + 0.0d		].	"immediate, character"	characterBits := value bitShift: -3.	^Character value: characterBits</body><body package="BOSS64" selector="shortObject64At:objectMap:baseIndex:swapBytes:">shortObject64At: datax objectMap: objMap baseIndex: baseIndex swapBytes: swapBytes	" Decode the encoded oop at byte index	datax in the receiver.  objMap is the table of	decoded objects.  baseIndex is the object	index of the first element of the table.  Some	small doubles such as 0.0d may get here"	| value |	value := self unsignedShortAt: datax.	^self object64From: value from: objMap baseIndex: baseIndex swapBytes: swapBytes</body></methods><methods><class-id>Kernel.BOSSBytes</class-id> <category>byte endianness</category><body package="BOSS64" selector="swapColumn64:with:">swapColumn64: c0 with: c1	" Swap bytes at indices 5N+c0+1 with	those at indices 5N+c1+1. "	1 to: self size by: 5 do:		[:i |			| t |			t := self at: i + c0.			self at: i + c0 put: (self at: i + c1).			self at: i + c1 put: t		]</body></methods><methods><class-id>Kernel.AbstractBinaryObjectStorage class</class-id> <category>private - instance creation</category><body package="BOSS64" selector="newInstance">newInstance	^self imageIsThirtyTwoBit		ifTrue: [self newInstance32]		ifFalse: [self newInstance64]</body><body package="BOSS64" selector="newInstance32">newInstance32	^BinaryObjectStorage basicNew</body><body package="BOSS64" selector="newInstance64">newInstance64	^BinaryObjectStorage64 basicNew</body><body package="BOSS64" selector="newOldInstanceFactory">newOldInstanceFactory	^BinaryObjectStorageFactory new</body></methods><methods><class-id>Kernel.AbstractBinaryObjectStorage class</class-id> <category>instance creation</category><body package="BOSS64" selector="onOldNoScan:">onOldNoScan: aStream	"Answer an instance of the receiver	for reading object structures from aStream.	Do not scan to the end of the stream	to find the next assignable object index.	The contents of aStream must	have been written by a BinaryObjectStorage."	| factory |	factory := self newOldInstanceFactory.	factory on: aStream.	factory checkHeader.	^factory binaryObjectStorage</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>BinaryStorageBytes</name><environment>Kernel</environment><super>Core.ByteArray</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Code Storage</category><attributes><package>System-Code Storage</package></attributes></class><class><name>BOSSAbstractWriter</name><environment>Kernel</environment><super>Kernel.BOSSTransporter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bodies currentClass nextRecentClass bodySize nilIndex traceClasses registry </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Binary Storage</category><attributes><package>BOSS</package></attributes></class><class><name>BOSSBytes</name><environment>Kernel</environment><super>Core.ByteArray</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Binary Storage</category><attributes><package>BOSS</package></attributes></class><class><name>BOSSAbstractReader</name><environment>Kernel</environment><super>Kernel.BOSSTransporter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>readingClasses compiledCode deferredSends </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Binary Storage</category><attributes><package>BOSS</package></attributes></class><class><name>AbstractBOSSReaderMap</name><environment>Kernel</environment><super>Core.Array</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>baseIndex storage </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Binary Storage</category><attributes><package>BOSS</package></attributes></class><class><name>AbstractBinaryObjectStorage</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream platformDescription initialPosition readerClass writerClass sourceMode readerMap writerMap nextIndex registry versionReaders classVarLists expectCycles mapXeroxToUnicode </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Binary Storage</category><attributes><package>BOSS</package></attributes></class></st-source>