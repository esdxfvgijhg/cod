<?xml version="1.0"?><st-source><!-- Name: Experimental-ComputedArrayComment: This package represents incremental progress towards supporting Squeak's { 1. 2. 3. } Array syntax, and as much as they are compatible, ObjectStudio's { 1 2 3 } Array syntax.The Squeak-like syntax permits full statements of arbitrary complexity, separated by periods. Each statement is a separate element of the array.The ObjectStudio-like syntax allows only simple literals, nested computed arrays, or block, but does not require a period between them.The compiler supports both ObjectStudio syntax and Squeak syntax, as does the RBParser. Formatting an array that contains simple literals as well as multi-line blocks is imperfect and may benefit from further thought. The formatter will always put periods between elements, in deference to the more general Squeak-like syntax.Over time, the expectation is that the ObjectStudio form can be deprecated as people migrate to the Squeak-like syntax.DbIdentifier: bear73DbTrace: 499963DbUsername: dahlDbVersion: 8.3 - 8PackageName: Experimental-ComputedArrayParcel: #('Experimental-ComputedArray')PrintStringCache: (8.3 - 8,dahl)Version: 8.3 - 8Date: 10:14:14 AM April 7, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (apr17.1) of April 7, 2017 on April 7, 2017 at 10:14:14 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>ComputedArrayNode</name><environment>Kernel</environment><super>Kernel.ValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>statements </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Experimental-ComputedArray</package></attributes></class><comment><class-id>Kernel.ComputedArrayNode</class-id><body>ComputedArrayNode represents an Array semi-literal of the form	{ 1. 2. [nil]. { 1+2. self class name. } }If an Array happens to be composed of true literals, such that it could have been expressed as a #() literal, it will be represented as a LiteralNode rather than ComputedArrayNodeInstance Variables:	statements	&lt;Array of: ProgramNode&gt;	elemnts in the target array</body></comment><class><name>RBComputedArrayNode</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBLiteralArrayNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Experimental-ComputedArray</package></attributes></class><methods><class-id>Kernel.ComputedArrayNode</class-id> <category>code generation</category><body package="Experimental-ComputedArray">emitValue: codeStream	| receiver args body baseArray |	receiver := LiteralNode new value: (baseArray := Array new: statements size).	receiver := MessageNode new				receiver: receiver				selector: #shallowCopy				arguments: #().	statements size &gt; 0		ifTrue: 			[args := OrderedCollection new: statements size + 1.			1 to: statements size do: [:index |				(statements at: index) isLiteralValue					ifTrue: [baseArray at: index put: (statements at: index) value]					ifFalse: [args add: (MessageNode new							receiver: receiver							selector: #at:put:							arguments: (Array								with: (LiteralNode new value: index)								with: (statements at: index)))]].			args add: (MessageNode new					receiver: receiver					selector: #yourself					arguments: #()).			body := CascadeNode new receiver: receiver messages: args]		ifFalse: [body := receiver].	body emitValue: codeStream</body></methods><methods><class-id>Kernel.ComputedArrayNode</class-id> <category>initialize-release</category><body package="Experimental-ComputedArray">elements: elementList	statements := elementList</body></methods><methods><class-id>Kernel.ComputedArrayNode</class-id> <category>enumerating</category><body package="Experimental-ComputedArray">nodeDo: anEnumerator	^anEnumerator doComputedArray: self elements: statements</body></methods><methods><class-id>Kernel.ComputedArrayNode</class-id> <category>printing</category><body package="Experimental-ComputedArray">printOn: aStream indent: level 	"If control gets here, avoid recursion loop"	| thisStatement indent |	sourcePosition isString ifTrue:		[^aStream nextPutAll: sourcePosition].        indent := false.  "we are already indented"	aStream nextPut: ${.        1 to: statements size do:                 [:i |                 thisStatement := statements at: i.                thisStatement comment size &gt; 0                        ifTrue:                                 [i = 1 ifTrue: [aStream crtab: level].                                aStream tab.                                thisStatement printCommentOn: aStream indent: level].                indent ifTrue: [aStream crtab: level].                thisStatement printOn: aStream indent: level.                aStream nextPut: $..                indent := true].	aStream nextPut: $}.</body></methods><methods><class-id>Refactory.Browser.RBComputedArrayNode</class-id> <category>testing</category><body package="Experimental-ComputedArray">isForComputedArray	^true</body></methods><methods><class-id>Refactory.Browser.RBComputedArrayNode</class-id> <category>accessing</category><body package="Experimental-ComputedArray">periods: aList	^self</body><body package="Experimental-ComputedArray">statements: aList	self contents: aList</body><body package="Experimental-ComputedArray">value	"This is complete nonsense."	| array |	array := Array new: contents size.	1 to: contents size		do: [:each |			(contents at: each) isLiteralNode				ifTrue: [array at: each put: (contents at: each) value]				ifFalse: [array at: each put: [].]].	^array</body></methods><methods><class-id>Refactory.Browser.RBComputedArrayNode class</class-id> <category>instance creation</category><body package="Experimental-ComputedArray">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Kernel.ProgramNodeBuilder</class-id> <category>node creation-composite-data</category><body package="Experimental-ComputedArray">computedArrayWithElements: elements	^ComputedArrayNode new elements: elements</body></methods><methods><class-id>Kernel.LiteralNode</class-id> <category>testing</category><body package="Experimental-ComputedArray">isLiteralValue	^true</body></methods><methods><class-id>Refactory.Browser.RBFormatter</class-id> <category>visitor-double dispatching</category><body package="Experimental-ComputedArray">acceptLiteralArrayNode: aLiteralArrayNode	aLiteralArrayNode isForComputedArray ifFalse: [codeStream nextPut: $#].	aLiteralArrayNode looksLikeStructuredArrayEncoding		ifTrue: [self formatStructuredLiteralArray: aLiteralArrayNode]		ifFalse: [self formatGeneralLiteralArray: aLiteralArrayNode]</body></methods><methods><class-id>Refactory.Browser.RBFormatter</class-id> <category>private-formatting</category><body package="Experimental-ComputedArray">formatGeneralLiteralArray: aLiteralArrayNode	codeStream nextPut: (aLiteralArrayNode isForComputedArray				ifTrue: [${]				ifFalse: [aLiteralArrayNode isForByteArray ifTrue: [$[] ifFalse: [$(]]).	self addEveryExtraSpace.	aLiteralArrayNode contents do:			[:each |			self visitNode: each.			aLiteralArrayNode isForComputedArray ifTrue: [codeStream nextPut: $.]]		separatedBy: [codeStream space].	self addEveryExtraSpace.	codeStream nextPut: (aLiteralArrayNode isForComputedArray				ifTrue: [$}]				ifFalse: [aLiteralArrayNode isForByteArray ifTrue: [$]] ifFalse: [$)]])</body><body package="Experimental-ComputedArray">formatStructuredLiteralArray: aLiteralArrayNode	| ratchet first |	codeStream nextPut: (aLiteralArrayNode isForComputedArray				ifTrue: [${]				ifFalse: [$(]).	self addEveryExtraSpace.	ratchet := false.	first := true.	aLiteralArrayNode contents do: [:each |			self				indentWhile: [ratchet ifTrue: [self indent] ifFalse: [first ifFalse: [codeStream space]].					first := false.					ratchet := ratchet not.					self visitNode: each.					aLiteralArrayNode isForComputedArray ifTrue: [codeStream nextPut: $.]]].	self addEveryExtraSpace.	codeStream nextPut: (aLiteralArrayNode isForComputedArray				ifTrue: [$}]				ifFalse: [$)])</body></methods><methods><class-id>Refactory.Browser.RBScanner</class-id> <category>private</category><body package="Experimental-ComputedArray">restoreState: aState	stream position: aState removeFirst.	tokenStart := aState removeFirst.	currentCharacter := aState removeFirst.	characterType := aState removeFirst.	comments := aState removeFirst.	errorActions := aState removeFirst.	aState isEmpty ifFalse: [self halt]</body><body package="Experimental-ComputedArray">saveState	^OrderedCollection new		add: stream position;		add: tokenStart;		add: currentCharacter;		add: characterType;		add: comments copy;		add: errorActions;		yourself</body></methods><methods><class-id>Refactory.Browser.RBLiteralArrayNode</class-id> <category>testing</category><body package="Experimental-ComputedArray">isForComputedArray	^false</body></methods><methods><class-id>Kernel.ProgramNodeEnumerator</class-id> <category>enumerating</category><body package="Experimental-ComputedArray">doComputedArray: aComputedArrayNode elements: elements 	self doNodes: elements</body></methods><methods><class-id>Kernel.Parser</class-id> <category>expression types-success/error</category><body package="Experimental-ComputedArray">computedArray	| state |	state := self saveState.	^self computedArrayOld or: [		self restoreState: state.		self computedArrayNew]</body><body package="Experimental-ComputedArray">computedArrayNew	| stmts start blockComment |	stmts := OrderedCollection new.	"give initial comment to block, since others trail statements"	blockComment := currentComment.	currentComment := nil.	start := endTemps.	[self expression		ifTrue: 			[self addComment.			stmts addLast: parseNode.			self match: #period]		ifFalse: 			[false]]		whileTrue.	tokenType == #rightBrace		ifTrue: [self scanToken]		ifFalse: [self expected: #RightBrace &lt;&lt; #dialogs &gt;&gt; 'right brace'].	self addComment.	parseNode := (stmts allSatisfy: [:n | n isLiteralValue])		ifTrue: [builder newLiteralValue: (stmts asArray collect: [:n | n value])]		ifFalse: [builder computedArrayWithElements: stmts asArray].	parseNode addComment: blockComment.	parseNode sourcePosition: (start to: self endOfLastToken ).	^true</body><body package="Experimental-ComputedArray">computedArrayOld	| s totalStart start |	totalStart := prevEnd.	s := WriteStream on: (Array new: 16).	[tokenType = #rightBrace]		whileFalse: 			[tokenType == #doIt ifTrue:				[^self expected: (#ArrayElementOrRightParenthesis &lt;&lt; #dialogs &gt;&gt; 'array element or right parenthesis')].			tokenType == #leftBracket				ifTrue: [self blockExpression]				ifFalse: [tokenType == #leftBrace				ifTrue: [(self scanToken; computedArray) ifFalse: [^false]]				ifFalse: [start := mark.					self constant						ifTrue:							[parseNode := builder newLiteralValue: parseNode.							parseNode sourcePosition: (start to: self endOfLastToken).]						ifFalse: [^false]]].			s nextPut: parseNode].	s := s contents.	parseNode := (s allSatisfy: [:n | n isLiteralValue])		ifTrue: [builder newLiteralValue: (s collect: [:n | n value])]		ifFalse: [builder computedArrayWithElements: s].	self scanToken.	parseNode sourcePosition: (totalStart to: self endOfLastToken).	^true</body></methods><methods><class-id>Kernel.Parser</class-id> <category>expression types-true/false</category><body package="Experimental-ComputedArray">primaryExpression	| start |	tokenType == #word		ifTrue: 			[start := mark.			self constant  "check for nil / true / false"				ifTrue:					[parseNode := builder newLiteralValue: parseNode.					parseNode sourcePosition: (start to: self endOfLastToken)]				ifFalse:					[parseNode := builder newVariableName: token.					parseNode sourcePosition: mark.					self scanToken].			^true].	tokenType == #compoundWord		ifTrue:			[parseNode := self bindingRefAt: token.			parseNode := builder newVariableName: parseNode.			parseNode sourcePosition: mark.			self scanToken.			^true].	tokenType == #leftBracket		ifTrue: 			[self blockExpression.			^true].	tokenType == #leftParenthesis		ifTrue: 			[self scanToken.			self expression ifFalse: [^self expected: (#Expression &lt;&lt; #dialogs &gt;&gt; 'expression')].			tokenType == #rightParenthesis				ifFalse: [^self expected: (#RightParenthesis &lt;&lt; #dialogs &gt;&gt; 'right parenthesis')].			self scanToken.			^true].	tokenType == #leftBrace		ifTrue: 			[self scanToken.			self computedArray ifFalse: [^self expected: (#Expression &lt;&lt; #dialogs &gt;&gt; 'expression')].			^true].	start := mark.	self constant		ifTrue:			[parseNode := builder newLiteralValue: parseNode.			parseNode sourcePosition: (start to: self endOfLastToken).			^true].	^false</body></methods><methods><class-id>Kernel.Parser</class-id> <category>private</category><body package="Experimental-ComputedArray">restoreState: dict	source position: (dict at: #source).	mark := dict at: #mark.	prevEnd := dict at: #prevEnd.	hereChar := dict at: #hereChar.	token := dict at: #token.	tokenType := dict at: #tokenType.	currentComment := dict at: #currentComment.	parseNode := dict at: #parseNode.</body><body package="Experimental-ComputedArray">saveState	^Dictionary new		at: #source put: source position;		at: #mark put: mark;		at: #prevEnd put: prevEnd;		at: #hereChar put: hereChar;		at: #token put: token;		at: #tokenType put: tokenType;		at: #currentComment put: currentComment;		at: #parseNode put: parseNode;		yourself</body></methods><methods><class-id>Refactory.Browser.RBParser</class-id> <category>private-parsing</category><body package="Experimental-ComputedArray">parseComputedArray	| saveState |	saveState := self saveState.	^[self parseComputedArrayOld]		on: Error		do: [:ex |			self restoreState: saveState.			ex return: (self parseComputedArrayNew)]</body><body package="Experimental-ComputedArray">parseComputedArrayElementOld	(currentToken isLiteralToken and: [currentToken isMultiKeyword not])		ifTrue: [^self parsePrimitiveLiteral].	currentToken isLiteralArrayToken		ifTrue: 			[^currentToken isForByteArray				ifTrue: [self parseLiteralByteArray]				ifFalse: [self parseLiteralArray]].	currentToken isSpecial		ifTrue: 			[currentToken value == $[ ifTrue: [^self parseBlock].			currentToken value == ${ ifTrue: [^self parseComputedArray]].	self error: 'OS-compatible computed array failed'.	self parserError: #VariableExpected &lt;&lt; #browser &gt;&gt; 'Variable expected'.	self step.	^self createObjectErrorNode</body><body package="Experimental-ComputedArray">parseComputedArrayNew	| stream start stop node |	start := currentToken start.	stream := WriteStream on: (Array new: 5).	self step.	node := RBComputedArrayNode				startPosition: start				contents: stream contents				stopPosition: stop				isByteArray: false.	self parseStatementListInto: node endWith: $}.	(currentToken isSpecial and: [currentToken value == $}])		ifTrue: 			[stop := currentToken stop.			self step]		ifFalse: 			[self parserError: #CloseParenExpected &lt;&lt; #browser &gt;&gt; ''')'' expected'.			self insert: ')'].	self addPropertiesTo: node.	^node</body><body package="Experimental-ComputedArray">parseComputedArrayOld	| stream start stop node |	start := currentToken start.	stream := WriteStream on: (Array new: 5).	self step.	[self atEnd or: [currentToken isSpecial and: [currentToken value = $}]]]		whileFalse: 			[self parseComputedArrayElementOld				ifNotNil: [:literal | stream nextPut: literal]].	(currentToken isSpecial and: [currentToken value == $}])		ifTrue: 			[stop := currentToken stop.			self step]		ifFalse: 			[self parserError: #CloseParenExpected &lt;&lt; #browser &gt;&gt; ''')'' expected'.			self insert: ')'].	node := RBComputedArrayNode				startPosition: start				contents: stream contents				stopPosition: stop				isByteArray: false.	self addPropertiesTo: node.	^node</body><body package="Experimental-ComputedArray">parsePrimitiveObject	currentToken isIdentifier ifTrue: [^self parsePrimitiveIdentifier].	(currentToken isLiteralToken and: [currentToken isMultiKeyword not])		ifTrue: [^self parsePrimitiveLiteral].	currentToken isLiteralArrayToken		ifTrue: 			[^currentToken isForByteArray				ifTrue: [self parseLiteralByteArray]				ifFalse: [self parseLiteralArray]].	currentToken isSpecial		ifTrue: 			[currentToken value == $[ ifTrue: [^self parseBlock].			currentToken value == $( ifTrue: [^self parseParenthesizedExpression].			currentToken value == ${ ifTrue: [^self parseComputedArray]].	self parserError: #VariableExpected &lt;&lt; #browser &gt;&gt; 'Variable expected'.	^self createObjectErrorNode</body></methods><methods><class-id>Refactory.Browser.RBParser</class-id> <category>private</category><body package="Experimental-ComputedArray">restoreState: aState	scanner restoreState: aState removeFirst.	currentToken := aState removeFirst.	nextToken := aState removeFirst.	comments := aState removeFirst.	errorActions := aState removeFirst.	aState isEmpty ifFalse: [self halt]</body><body package="Experimental-ComputedArray">saveState	^OrderedCollection new		add: scanner saveState;		add: currentToken;		add: nextToken;		add: comments copy;		add: errorActions copy;		yourself</body></methods><methods><class-id>Kernel.ProgramNode</class-id> <category>testing</category><body package="Experimental-ComputedArray">isLiteralValue	^false</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>RBScanner</name><environment>Refactory.Browser</environment><super>Core.Stream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream buffer tokenStart currentCharacter characterType classificationTable comments errorBlock errorActions </inst-vars><class-inst-vars>classificationTable </class-inst-vars><imports></imports><category>Browser-Scanner</category><attributes><package>Browser-Parser</package></attributes></class><class><name>Parser</name><environment>Kernel</environment><super>Kernel.Scanner</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder requestor oldLanguage newLanguage extendedLanguage parseNode failBlock endTemps targetClass environment topEnvironment bindingRefs </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Public Access</category><attributes><package>System-Compiler-Public Access</package></attributes></class><class><name>ProgramNode</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sourcePosition comment compilerHints blockIndex mapEntry returnMapEntry </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Program Objects</category><attributes><package>System-Compiler-Program Objects</package></attributes></class><class><name>ValueNode</name><environment>Kernel</environment><super>Kernel.StatementNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Program Objects</category><attributes><package>System-Compiler-Program Objects</package></attributes></class><class><name>LiteralNode</name><environment>Kernel</environment><super>Kernel.LeafNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Program Objects</category><attributes><package>System-Compiler-Program Objects</package></attributes></class><class><name>RBParser</name><environment>Refactory.Browser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>scanner currentToken nextToken errorBlock source comments errorActions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parser</category><attributes><package>Browser-Parser</package></attributes></class><class><name>RBFormatter</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBProgramNodeVisitor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>codeStream lineStart firstLineLength tabs lineLengthLimit horizontalSpacing verticalSpacing terminatorFrequency isInBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parser</category><attributes><package>Browser-Parser</package></attributes></class><class><name>RBLiteralArrayNode</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBLiteralNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>isByteArray stop contents start </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parser</category><attributes><package>Browser-Parser</package></attributes></class><class><name>ProgramNodeEnumerator</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Support</category><attributes><package>System-Compiler-Support</package></attributes></class><class><name>ProgramNodeBuilder</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Program Objects</category><attributes><package>System-Compiler-Program Objects</package></attributes></class></st-source>