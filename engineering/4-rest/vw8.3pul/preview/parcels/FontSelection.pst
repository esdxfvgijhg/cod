<?xml version="1.0"?><st-source><!-- Name: FontSelectionNotice: Copyright 2010-2013 Cincom Systems, Inc.  All rights reserved.BundleName: FontSelectionBundleStructure: a Store.BundleForParcelComment: The bundle FontSelection extends the base image functionality for font selection for Windows operating systems. It selects the fonts based on their supported characters in prior to the normal font attributes. The goal of this selection policy is to have a visible output for every printed character. This new selection policy is represented by class WindowsCompositeFontPolicy and can be used in own graphics contexts as default policy. It is automatically installed and activated for the windowing system by loading this bundle (see postload action). It could be possible that you need to reopen existing windows so that the policy is used.The WindowCompositeFontPolicy uses the class WindowsCompositeFont as default font class. This composite font grows dynamically depending on the printed characters. It uses internally instances of WinUnicodeFont as platform font representation. For performance reasons the class FontMatch is introduced, which is used as a cache for a best-match font description and the corresponding encoder. The encoder is a UnicodeRangesCharacterEncoder that encodes/decodes characters based on the character ranges in the given font.Parcel: nilParcelName: FontSelectionPrerequisiteParcels: #()Version: 7.10 - 1Post-Load Block: 	[:package | Screen installWindowsCompositeFontPolicy]Date: 7:26:12 AM April 3, 2013 --><time-stamp>From VisualWorksÂ®, Pre-Release 7.10 (mar13.5) of April 3, 2013 on April 3, 2013 at 7:26:12 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>WindowsCompositeFont</name><environment>Graphics</environment><super>Graphics.CompositeFont</super><private>false</private><indexed-type>none</indexed-type><inst-vars>query policy matches lastMatch </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Internationalization</category><attributes><package>WindowsUnicodeFonts</package></attributes></class><comment><class-id>Graphics.WindowsCompositeFont</class-id><body>WindowsCompositeFont is a specific case of a composite font, implemented for Unicode support, which implements font linking.It starts with only one font of the specified family and adds fonts as they are required for displaying specific characters not supported by the original font. Instance Variables:		query 	&lt;FontDescription&gt; 	The query for which this font has been created		policy	&lt;FontPolicy&gt;		The fontpolicy the font belongs to - needed for finding encoders		matches					a collection of matches that have been generated for the query (best matches first)		lastMatch&lt;Integer&gt;			The index of the fontDescription in the matches collection, which represents the last font which is currently used by the Composite font.</body></comment><class><name>FontMatch</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fontDescription encoder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AllEncodings</category><attributes><package>WindowsUnicodeFonts</package></attributes></class><comment><class-id>FontMatch</class-id><body>This class is an entry in the table of matches generated for a specific FontDescription query. I cashes the Encoder and this way improves runtime performance of WindowsCompositeFonts.Instance Variables:	encoder		&lt;UnicodeRangesCharacterEncoder&gt;		The encoder which describes the character table supported by the font	fontDescription	&lt;FontDescription&gt;					The actual fontdescription</body></comment><class><name>UnicodeRangesCharacterEncoder</name><environment>Core</environment><super>Core.CharacterEncoder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>ranges </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Fonts</category><attributes><package>WindowsUnicodeFonts</package></attributes></class><comment><class-id>Core.UnicodeRangesCharacterEncoder</class-id><body>UnicodeRangesCharacterEncoder provides support for mapping specific ranges of Unicode characters to their respective codepoint numbers. This is required by Unicode fonts which only support specific character ranges, not the entire Uncide range.</body></comment><class><name>WinUnicodeFont</name><environment>Graphics</environment><super>Graphics.MSWindowsFont</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AllEncodingsUnicodeExtension</category><attributes><package>WindowsUnicodeFonts</package></attributes></class><comment><class-id>Graphics.WinUnicodeFont</class-id><body>WinUnicodeFont is Subclass fo MSWindowsFont is special to makes the Textout with Unicodecharacters natively.</body></comment><class><name>WindowsCompositeFontPolicy</name><environment>Core</environment><super>Graphics.FontPolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bestFontsCache </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>WindowsUnicodeFonts</package></attributes></class><class><name>Range</name><environment>Core</environment><super>Core.SequenceableCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>first last </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AT Profiling Core</category><attributes><package>WindowsUnicodeFonts</package></attributes></class><comment><class-id>Core.Range</class-id><body>The class defines a interval, whereby only low and high bound are supplied.The major difference to interval lies the functionality, which has been reduced tothe needs of RangeEncoder, to achieve a high performance boost. </body></comment><shared-variable><name>FontPolicyCache</name><environment>Core.WindowsCompositeFontPolicy</environment><private>false</private><constant>false</constant><category>cacheing</category><initializer>IdentityDictionary new</initializer><attributes><package>WindowsUnicodeFonts</package></attributes></shared-variable><methods><class-id>OS.Win32SystemSupport</class-id> <category>procedures wingdi</category><body package="WindowsUnicodeFonts">CreateFontIndirect: arg1		&lt;C: HFONT CreateFontIndirectW(LOGFONT* arg1)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="WindowsUnicodeFonts">DeleteObject: hObject		&lt;C: BOOL DeleteObject(HGDIOBJ hObject)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="WindowsUnicodeFonts">EnumFontFamiliesEx: arg1 lpLogfont: arg2 lpEnumFontFamExProc: arg3 lParam: arg4 dwFlags: arg5		&lt;C: int EnumFontFamiliesExW(HDC arg1, LPLOGFONT arg2, FONTENUMPROC arg3, LPARAM arg4, DWORD arg5)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="WindowsUnicodeFonts">GetCurrentObject: hdc typeValue: uObjectType		&lt;C: HGDIOBJ GetCurrentObject(HDC hdc, UINT uObjectType)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="WindowsUnicodeFonts">GetFontUnicodeRanges: hdc lpGlyphset: lpgs		&lt;C: DWORD GetFontUnicodeRanges(HDC hdc, LPGLYPHSET lpgs)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="WindowsUnicodeFonts">SelectObject: hdc with: object		&lt;C: HGDIOBJ SelectObject(HDC hdc, HGDIOBJ object)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>Graphics.WindowsCompositeFont</class-id> <category>accessing</category><body package="WindowsUnicodeFonts">currentFont	^currentFont</body><body package="WindowsUnicodeFonts">encode: aCharacter	^aCharacter asInteger</body><body package="WindowsUnicodeFonts">lastMatch	^lastMatch</body><body package="WindowsUnicodeFonts">lastMatch: aLastMatch	lastMatch := aLastMatch</body><body package="WindowsUnicodeFonts">mainFont	"return my main font, the one I was create for"	^fonts first</body><body package="WindowsUnicodeFonts">matches	^matches</body><body package="WindowsUnicodeFonts">matches: aCollection	matches := aCollection</body><body package="WindowsUnicodeFonts">policy	^policy</body><body package="WindowsUnicodeFonts">policy: anObject	policy := anObject</body><body package="WindowsUnicodeFonts">query	^query</body><body package="WindowsUnicodeFonts">query: anObject	query := anObject</body></methods><methods><class-id>Graphics.WindowsCompositeFont</class-id> <category>private</category><body package="WindowsUnicodeFonts">addFontFor: aCharacter	| match |	match := matches				detect: [:each | ((each encoderUsing: policy) encode: aCharacter) ~= Character illegalCode]				ifNone: [nil].	^match		ifNil: 			[self priorityTableAt: aCharacter put: 1.			self mainFont]		ifNotNil: 			[| font |			font := self allocateFont: match fontDescription.			fonts addLast: font.			self priorityTableAt: aCharacter put: fonts size.			font]</body><body package="WindowsUnicodeFonts">allocateFont: aFontDescription		^self class deviceFontClass		createFont: aFontDescription		toResemble: self query		for: policy</body><body package="WindowsUnicodeFonts">getFontFor: aCharacter	"Set my currentFont to be appropriate for aCharacter"	| fontCollectionIndex index |	index := aCharacter asInteger + 1.	fontCollectionIndex := index &gt; priorityTable size		ifTrue: [0]		ifFalse: [priorityTable at: index].	^fontCollectionIndex == 0		ifTrue: [self addFontFor: aCharacter]		ifFalse: [fonts at: fontCollectionIndex]</body><body package="WindowsUnicodeFonts">scaleFontAtPixelsize: aPixelSize 	"Avoid ascent and descent getting to high caused by windows fonts."	| result |	result := (fonts asSortedCollection: 					[:a :b | 					(a ascent + a descent - aPixelSize) abs 						&lt; (b ascent + b descent - aPixelSize) abs]) 				first.	ascent := result ascent.	descent := result descent</body></methods><methods><class-id>Graphics.WindowsCompositeFont</class-id> <category>printing</category><body package="WindowsUnicodeFonts">printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	self mainFont name printOn: aStream.	aStream nextPut: $).</body></methods><methods><class-id>Graphics.WindowsCompositeFont</class-id> <category>initialize-release</category><body package="WindowsUnicodeFonts">initialize	super initialize.	lastMatch := 1</body><body package="WindowsUnicodeFonts">invalidate	policy := nil.</body></methods><methods><class-id>Graphics.WindowsCompositeFont</class-id> <category>converting</category><body package="WindowsUnicodeFonts">withColor: aColor	^(super withColor: aColor)		query: (self query copy color: aColor);		matches: self matches;		lastMatch: self lastMatch;		policy: self policy;		yourself</body><body package="WindowsUnicodeFonts">withStrikeout	^(super withStrikeout)		query: (self query copy strikeout: true);		matches: self matches;		lastMatch: self lastMatch;		policy: self policy;		yourself</body><body package="WindowsUnicodeFonts">withUnderline	^(super withUnderline)		query: (self query copy underline: true);		matches: self matches;		lastMatch: self lastMatch;		policy: self policy;		yourself</body></methods><methods><class-id>Graphics.WindowsCompositeFont</class-id> <category>utility</category><body package="WindowsUnicodeFonts">priorityTableAt: aChar	^priorityTable at: aChar asInteger + 1</body><body package="WindowsUnicodeFonts">priorityTableAt: aChar put: anObject	^priorityTable at: aChar asInteger + 1 put: anObject</body></methods><methods><class-id>Graphics.WindowsCompositeFont class</class-id> <category>instance creation</category><body package="WindowsUnicodeFonts">new	^super new initialize</body></methods><methods><class-id>Graphics.WindowsCompositeFont class</class-id> <category>utility</category><body package="WindowsUnicodeFonts">createFont: aBestFontDescription toResemble: aFontDescription for: aFontPolicy	"Return an instance of the appropriate CompostitFont (sub)class which matches the &lt;bestMatch&gt; fontdescription"	| font newCompositeFont priorityTable |	font := self deviceFontClass				createFont: aBestFontDescription				toResemble: aFontDescription				for: aFontPolicy.	priorityTable := (self				getPriorityTableFor: (Array with: aBestFontDescription encoding)				from: (Array with: font encoder)) copy.	newCompositeFont := self new.	newCompositeFont		with: (OrderedCollection with: font) priorityTable: priorityTable;		query: aFontDescription;		matches: (self findBestMatches: aFontDescription on: aFontPolicy);		policy: aFontPolicy;		scaleFontAtPixelsize: aFontDescription pixelSize.	self nonPrintedCharacters		do: [:char | newCompositeFont priorityTableAt: char put: 1].	^newCompositeFont</body><body package="WindowsUnicodeFonts">defaultFontDescriptionIn: aFontPolicy	^self deviceFontClass defaultFontDescriptionIn: aFontPolicy</body><body package="WindowsUnicodeFonts">findBestMatches: aFontDescription on: aFontPolicy	| bestFonts |	bestFonts := aFontPolicy findBestFonts: aFontDescription.	^bestFonts collect: [:fontDescription | FontMatch forFontDescription: fontDescription]</body><body package="WindowsUnicodeFonts">preferredFontSizeReferringTo: aFontPolicy	^self deviceFontClass preferredFontSizeReferringTo: aFontPolicy</body><body package="WindowsUnicodeFonts">usablePlatformFonts	^self deviceFontClass usablePlatformFonts</body></methods><methods><class-id>Graphics.WindowsCompositeFont class</class-id> <category>private</category><body package="WindowsUnicodeFonts">createPriorityTableForEncoders: encoders	| priorityTable |	priorityTable := RunArray new: 16r1000000 withAll: 0.	^priorityTable</body><body package="WindowsUnicodeFonts">encoderNamed: aString	^self deviceFontClass encoderNamed: aString</body><body package="WindowsUnicodeFonts">nonPrintedCharacters	^(0 to: 31) collect: [:each | each asCharacter]</body><body package="WindowsUnicodeFonts">parse: aName 	^self deviceFontClass parse: aName</body></methods><methods><class-id>Graphics.WindowsCompositeFont class</class-id> <category>accessing</category><body package="WindowsUnicodeFonts">deviceFontClass	^WinUnicodeFont</body></methods><methods><class-id>FontMatch</class-id> <category>accessing</category><body package="WindowsUnicodeFonts">encoder	^encoder</body><body package="WindowsUnicodeFonts">encoder: aCharacterEncoder	encoder := aCharacterEncoder</body><body package="WindowsUnicodeFonts">encoderUsing: aPolicy	^encoder ifNil: [encoder := aPolicy fontClass encoderNamed: fontDescription encoding]</body><body package="WindowsUnicodeFonts">fontDescription	^fontDescription</body><body package="WindowsUnicodeFonts">fontDescription: aFontDescription	fontDescription := aFontDescription</body></methods><methods><class-id>FontMatch</class-id> <category>printing</category><body package="WindowsUnicodeFonts">printOn: aStream	self fontDescription encoding printOn: aStream</body></methods><methods><class-id>FontMatch class</class-id> <category>instance creation</category><body package="WindowsUnicodeFonts">forFontDescription: aFontDescription	^(self new)		fontDescription: aFontDescription;		yourself</body></methods><methods><class-id>Core.UnicodeRangesCharacterEncoder</class-id> <category>accessing</category><body package="WindowsUnicodeFonts">decode: anInteger	"Answer the Character that the argument represents"	(self isValidEncoding: anInteger) ifTrue: [^IllegalCharacterValue asCharacter].	^Character value: anInteger</body><body package="WindowsUnicodeFonts">encode: aCharacter	"Answer an integer representation for the Character"	| anInteger |	anInteger := aCharacter asInteger.	(self isValidEncoding: anInteger) ifFalse: [^IllegalCharacterValue].	^anInteger</body><body package="WindowsUnicodeFonts">find: anInteger between: aStartRangeIndex and: anEndRangeIndex	| startRange endRange numRanges expectedRangeIndex expRange |	^aStartRangeIndex = anEndRangeIndex		ifTrue: [(ranges at: aStartRangeIndex) includes: anInteger]		ifFalse: 			[startRange := (ranges at: aStartRangeIndex) first.			endRange := (ranges at: anEndRangeIndex) last.			(anInteger &gt;= startRange and: [anInteger &lt;= endRange]) ifFalse: [^false].			numRanges := anEndRangeIndex - aStartRangeIndex + 1.			expectedRangeIndex := (anInteger - startRange) * numRanges // (endRange - startRange + 1) + aStartRangeIndex.			expRange := ranges at: expectedRangeIndex.			(anInteger &gt;= expRange first and: [anInteger &lt;= expRange last]) ifTrue: [^true].			anInteger &lt; expRange first				ifTrue: 					[^self						find: anInteger						between: aStartRangeIndex						and: expectedRangeIndex - 1].			anInteger &gt; expRange last				ifTrue: 					[^self						find: anInteger						between: expectedRangeIndex + 1						and: anEndRangeIndex].			false]</body><body package="WindowsUnicodeFonts">isValidEncoding: anInteger	"self new validFrom: 1 to: 10; isValidEncoding: 2"	ranges ifNil: [^false].	^self		find: anInteger		between: 1		and: ranges size</body><body package="WindowsUnicodeFonts">numRanges	^ranges size</body><body package="WindowsUnicodeFonts">numRanges: aSize	ranges := Array new: aSize</body><body package="WindowsUnicodeFonts">ranges	^ranges</body><body package="WindowsUnicodeFonts">ranges: aCollection	ranges := aCollection</body><body package="WindowsUnicodeFonts">setNameFromFontName: aName	| nameString |	nameString := self class encoderNameForFontName: aName.	self name: nameString.	self class		installEncoder: self		named: nameString		platform: self class platformName</body><body package="WindowsUnicodeFonts">setRange: anIndex from: aStartIndex count: aCount	self		setRange: anIndex		from: aStartIndex		to: aStartIndex + aCount - 1</body><body package="WindowsUnicodeFonts">setRange: anIndex from: aStartIndex to: anEndIndex	ranges at: anIndex put: (Range from: aStartIndex to: anEndIndex).</body><body package="WindowsUnicodeFonts">supportedCharacters		^ranges		inject: OrderedCollection new		into:			[:coll :range | 			(range first to: range last)				inject: coll				into:					[:coll1 :each | 					coll1 addLast: each asCharacter.					coll]]</body></methods><methods><class-id>Core.UnicodeRangesCharacterEncoder</class-id> <category>initialize-release</category><body package="WindowsUnicodeFonts">initialize		super initialize.	ranges := SortedCollection sortBlock: [:a :b | a first &lt; b first]</body></methods><methods><class-id>Core.UnicodeRangesCharacterEncoder</class-id> <category>printing</category><body package="WindowsUnicodeFonts">printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	aStream nextPutAll: (self name ifNil: ['unnamed']).	aStream nextPut: $)</body></methods><methods><class-id>Core.UnicodeRangesCharacterEncoder class</class-id> <category>instance creation</category><body package="WindowsUnicodeFonts">fromGlyphset: aGlyphSet	| encoder rangesPtr size |	size := aGlyphSet memberAt: #cRanges.	encoder := self newSize: size.	rangesPtr := aGlyphSet refMemberAt: #ranges.	1 to: size		do: 			[:index |			encoder				setRange: index				from: (rangesPtr memberAt: #wcLow)				count: (rangesPtr memberAt: #cGlyphs).			rangesPtr increment].	^encoder</body><body package="WindowsUnicodeFonts">newSize: aNumber	^(self new)		numRanges: aNumber;		yourself</body></methods><methods><class-id>Core.UnicodeRangesCharacterEncoder class</class-id> <category>utility</category><body package="WindowsUnicodeFonts">encoderNameForFontName: aName	^'Ranges_' , (aName copy replaceAll: Character space with: $_)</body></methods><methods><class-id>Graphics.WinUnicodeFont</class-id> <category>converting</category><body package="WindowsUnicodeFonts">withColor: aColor	^(SyntheticFont on: self) color: aColor</body><body package="WindowsUnicodeFonts">withStrikeout	^(SyntheticFont on: self) strikeout: true</body><body package="WindowsUnicodeFonts">withUnderline	^(SyntheticFont on: self) underline: true</body></methods><methods><class-id>Graphics.WinUnicodeFont</class-id> <category>private</category><body package="WindowsUnicodeFonts">getWidthFor: charIndex	"We collect only the width for the given charIndex, not for a complete page. This is faster, because in most cases we	 do not need the full range of characters"	| a |	a := Array new: 1.	self getWidths: charIndex into: a.	widths at: charIndex + 1 put: a first.	widths compress</body></methods><methods><class-id>Graphics.WinUnicodeFont class</class-id> <category>private</category><body package="WindowsUnicodeFonts">encoderNamed: aString	"Answer a character encoder appropriate to the encoding name"	^  CharacterEncoder encoderNamed: aString asSymbol ifAbsent: [ super encoderNamed: aString]</body><body package="WindowsUnicodeFonts">encodingFor: aCharset 	"Return the Encoding decided by Charset given by the Windows-API EnumFontFamiliesEx"	| lib encoding oemcp |	lib := OSSystemSupport concreteClass new.	oemcp := lib GetOEMCP.	encoding := aCharset = 0 				ifTrue: ['ansi']				ifFalse: 					[aCharset = 255 						ifTrue: ['ms_cp_' , oemcp printString]						ifFalse: 							[aCharset = 2 ifTrue: ['symbol'] ifFalse: ['special' , aCharset printString]]].	^encoding</body><body package="WindowsUnicodeFonts">encodingMatchFor: aFontDescription concrete: concreteFont in: aFontPolicy weight: aWeight	^0</body><body package="WindowsUnicodeFonts">enumFontFamProc: lpelfe newTextMetric: lpntme fontTyp: fontType lParam: lParam into: aCollection	"Callback function for the Windows-API EnumFontFamiliesExA to add all fonts of a given typeface."	| lib fontName tempStream |	lib := OSSystemSupport concreteClass new.	tempStream := String new writeStream.	fontName := ((lpelfe memberAt: #elfLogFont) memberAt: #lfFaceName)				copyUnicodeStringFromHeap.	tempStream		nextPutAll: fontName;		nextPut: $~.	fontType == 4		ifTrue: 			[tempStream				print: 0;				nextPut: $~]		ifFalse: 			[tempStream				print: ((lpelfe memberAt: #elfLogFont) memberAt: #lfHeight);				nextPut: $~].	tempStream		print: ((lpelfe memberAt: #elfLogFont) memberAt: #lfWeight);		nextPut: $~;		print: ((lpelfe memberAt: #elfLogFont) memberAt: #lfItalic);		nextPut: $~;		print: ((lpelfe memberAt: #elfLogFont) memberAt: #lfUnderline);		nextPut: $~;		print: ((lpelfe memberAt: #elfLogFont) memberAt: #lfStrikeOut);		nextPut: $~;		nextPutAll: (UnicodeRangesCharacterEncoder encoderNameForFontName: fontName);		nextPut: $~;		print: fontType.	aCollection add: tempStream contents.	lib TRUE</body><body package="WindowsUnicodeFonts">enumTypeFacesProc: lpelfe newTextMetric: lpntme fontTyp: fontType lParam: lParam into: aCollection	"Callback function for the Windows-API EnumFontFamiliesExA to return the typeface names."		| lib fontName |	lib := OSSystemSupport concreteClass new.	fontName := ((lpelfe memberAt: #elfLogFont) memberAt: #lfFaceName) copyUnicodeStringFromHeap.	(aCollection includes: fontName) ifFalse: 		[aCollection add: fontName].	^lib TRUE</body><body package="WindowsUnicodeFonts">mapEncoding: encodingName withFamily: family	^encodingName</body></methods><methods><class-id>Graphics.WinUnicodeFont class</class-id> <category>system calls</category><body package="WindowsUnicodeFonts">getOSFontNames: dc lib: lib param: fontMatch		| callBackBlock callBack faceNames |	faceNames := OrderedCollection new.	callBackBlock := [:lpelfe :lpntme :fontType :lParam | 	self enumTypeFacesProc: lpelfe newTextMetric: lpntme fontTyp: fontType		lParam: lParam into: faceNames].	callBack := CCallback		do: callBackBlock		ofType: lib FONTENUMPROC.	lib EnumFontFamiliesEx: dc lpLogfont: fontMatch lpEnumFontFamExProc:			callBack lParam: 0 dwFlags: 0.	^faceNames</body><body package="WindowsUnicodeFonts">getOSFonts: dc lib: lib param: fontMatch forTypefaces: faceNames 	| result callBackBlock callBack |	result := Set new.	callBackBlock := 			[:lpelfe :lpntme :fontType :lParam | 			self 				enumFontFamProc: lpelfe				newTextMetric: lpntme				fontTyp: fontType				lParam: lParam				into: result].	callBack := CCallback do: callBackBlock ofType: lib FONTENUMPROC.	faceNames do: 			[:faceName | 			| bytes |			bytes := ((faceName, (String with: 0 asCharacter)) first: 32) asByteArrayEncoding: #UTF16.			(fontMatch refMemberAt: #lfFaceName) 				copyAt: 0				from: bytes				size: bytes size				startingAt: 1.			lib 				EnumFontFamiliesEx: dc				lpLogfont: fontMatch				lpEnumFontFamExProc: callBack				lParam: 0				dwFlags: 0].	^result asOrderedCollection</body><body package="WindowsUnicodeFonts">getUnicodeRanges	"Returns an ordered Collection of font face names installed on the system by using Windows-APIs.	First we have to get all the typefaces and iterate over them to get all fonts."	"WinUnicodeFont getUnicodeRanges"	| fontMatch dc sysSupport hFont oldFont res mem |	sysSupport := OSSystemSupport concreteClass new.	fontMatch := sysSupport LOGFONT gcCalloc.	fontMatch memberAt: #lfCharSet put: sysSupport DEFAULT_CHARSET.	fontMatch memberAt: #lfPitchAndFamily put: 0.	dc := sysSupport GetDC: 0.	oldFont := sysSupport currentFontFor: dc.	self listFontFaceNames do: 			[:fontFaceName | 			| charPtr glyphsize glyphset encoder |			charPtr := fontMatch refMemberAt: #lfFaceName.			fontFaceName asByteArray do: 					[:c | 					charPtr contents: c.					charPtr increment].			charPtr contents: 0.			hFont := sysSupport CreateFontIndirect: fontMatch.			res := sysSupport SelectObject: dc with: hFont.			glyphsize := sysSupport GetFontUnicodeRanges: dc lpGlyphset: 0.			glyphsize = 0 ifFalse: [				mem := CIntegerType unsignedChar gcCalloc: glyphsize.				glyphset := sysSupport GLYPHSET pointerType 							cast: mem.				glyphset memberAt: #cbThis put: glyphsize.				res := sysSupport GetFontUnicodeRanges: dc lpGlyphset: glyphset.				res := sysSupport SelectObject: dc with: oldFont.				res := sysSupport DeleteObject: hFont.				encoder := UnicodeRangesCharacterEncoder fromGlyphset: glyphset.				encoder setNameFromFontName: fontFaceName]].	sysSupport SelectObject: dc with: oldFont.	sysSupport ReleaseDC: 0 with: dc</body><body package="WindowsUnicodeFonts">listFontFaceNames	"Returns an ordered Collection of font face names installed on the system by using Windows-APIs.	First we have to get all the typefaces and iterate over them to get all fonts."	"WinUnicodeFont listFontFaceNames"	| fontMatch dc lib names |	lib := OSSystemSupport concreteClass new.	fontMatch := lib LOGFONT gcMalloc.	fontMatch memberAt: #lfCharSet put: lib DEFAULT_CHARSET.	(fontMatch memberAt: #lfFaceName) zeroFill.	fontMatch memberAt: #lfPitchAndFamily put: 0.	dc := lib GetDC: 0.	names := self 		getOSFontNames: dc		lib: lib		param: fontMatch.	lib ReleaseDC: 0 with: dc.	^names</body><body package="WindowsUnicodeFonts">listFontNames	"Returns an ordered Collection of fonts installed on the system by using Windows-APIs.	First we have to get all the typefaces and iterate over them to get all fonts."	"WinUnicodeFont listFontNames"	| fontMatch dc lib faceNames fonts |	self getUnicodeRanges.	faceNames := self listFontFaceNames.	lib := OSSystemSupport concreteClass new.	fontMatch := lib LOGFONT gcMalloc.	fontMatch memberAt: #lfCharSet put: lib DEFAULT_CHARSET.	(fontMatch memberAt: #lfFaceName) zeroFill.	fontMatch memberAt: #lfPitchAndFamily put: 0.	dc := lib GetDC: 0.	fonts := self 		getOSFonts: dc		lib: lib		param: fontMatch		forTypefaces: faceNames.	lib ReleaseDC: 0 with: dc.	^fonts</body></methods><methods><class-id>Graphics.WinUnicodeFont class</class-id> <category>utilities</category><body package="WindowsUnicodeFonts">createFont: concreteFontDescription toResemble: requestedFontDescription for: aFontPolicy	^self		createFont: concreteFontDescription		toResemble: requestedFontDescription		on: aFontPolicy graphicsDevice</body><body package="WindowsUnicodeFonts">createFont: concreteFontDescription toResemble: requestedFontDescription on: aScreen	| specialFontDescription specialRequestedFontDescription |	specialFontDescription := concreteFontDescription copy.	specialFontDescription name: (self replaceEncodingIn: specialFontDescription name with: 'special0').	specialRequestedFontDescription := requestedFontDescription copy.	specialRequestedFontDescription pixelSize: specialRequestedFontDescription pixelSize rounded.	^(super createFont: specialFontDescription toResemble: specialRequestedFontDescription on: aScreen)		setEncoder: (self encoderNamed: concreteFontDescription encoding)</body><body package="WindowsUnicodeFonts">createFontDesc: concreteFontDescription toResemble: requestedFontDescription 	| synthetic fName divider oneString zeroString |	divider := (#[16r7E] asStringEncoding: #default) first.	oneString := String with: $1 with: divider.	zeroString := String with: $0 with: divider.	synthetic := concreteFontDescription pixelSize = 0.	synthetic := synthetic or: 					[requestedFontDescription boldness &gt; 0.6 						and: [concreteFontDescription boldness &lt; 0.6]].	synthetic := synthetic or: [requestedFontDescription italic].	synthetic := synthetic or: [requestedFontDescription underline].	synthetic := synthetic or: [requestedFontDescription strikeout].	^ synthetic 		ifTrue: 			[| stream size boldValue isItalic fd |			fd := concreteFontDescription copy.			size := concreteFontDescription pixelSize = 0 						ifTrue: [requestedFontDescription pixelSize]						ifFalse: [concreteFontDescription pixelSize].			boldValue := requestedFontDescription specifiesBoldness 						ifTrue: [requestedFontDescription boldness]						ifFalse: 							[requestedFontDescription name isString 								ifTrue: 									[((requestedFontDescription name tokensBasedOn: $~) at: 3) asNumber 										/ 1000.0]								ifFalse: [concreteFontDescription boldness]].			isItalic := requestedFontDescription specifiesItalic 						ifTrue: [requestedFontDescription italic]						ifFalse: 							[requestedFontDescription name isString 								ifTrue: 									[((requestedFontDescription name tokensBasedOn: $~) at: 4) asNumber &gt; 0]								ifFalse: [concreteFontDescription italic]].			stream := String new writeStream.			stream				nextPutAll: concreteFontDescription family;				nextPut: divider.			stream				print: size;				nextPut: divider.			stream				print: (boldValue &gt; 0.6 ifTrue: [700] ifFalse: [400]);				nextPut: divider.			stream nextPutAll: (isItalic ifTrue: [oneString] ifFalse: [zeroString]).			stream nextPutAll: (requestedFontDescription underline 						ifTrue: [oneString]						ifFalse: [zeroString]).			stream nextPutAll: (requestedFontDescription strikeout 						ifTrue: [oneString]						ifFalse: [zeroString]).			stream				nextPutAll: (self extractEncoding: concreteFontDescription name);				nextPut: divider.			stream nextPutAll: '0'.			fName := stream contents.			fd				boldness: (requestedFontDescription boldness &gt; 0.6 							ifTrue: [0.7]							ifFalse: [0.5]);				italic: requestedFontDescription italic;				underline: requestedFontDescription underline;				strikeout: requestedFontDescription strikeout;				pixelSize: size;				name: fName.			fd ]	ifFalse: [ concreteFontDescription ]</body><body package="WindowsUnicodeFonts">replaceEncodingIn: aString with: anEncoding 	"self replaceEncodingIn: 'arial~16~400~1~0~0~special0~0' with: 'test1234'"	| collection newString |	collection := aString tokensBasedOn: $~.	collection at: 7 put: anEncoding.	newString := String new.	collection 		do: [:el | newString := newString , el]		separatedBy: [newString := newString copyWith: $~].	^newString</body></methods><methods><class-id>Graphics.WinUnicodeFont class</class-id> <category>accessing</category><body package="WindowsUnicodeFonts">compositeFontClass	"Only use the newly implemented WindowsCompositeFontClass if we run on a Unicode VM and therefore are able	 of displaying Unicode characters "	^WindowsCompositeFont</body></methods><methods><class-id>Graphics.WinUnicodeFont class</class-id> <category>testing</category><body package="WindowsUnicodeFonts">isComposite: aFontDescription 	^ true</body></methods><methods><class-id>Core.WindowsCompositeFontPolicy</class-id> <category>utilities</category><body package="WindowsUnicodeFonts">findBestFont: requestedFont	"Find a font that approximately or exactly match the requested font"		| matches |	^(matches := self findBestFonts: requestedFont) isEmpty		ifTrue: [^nil]		ifFalse: [matches first]</body><body package="WindowsUnicodeFonts">findBestFonts: requestedFont	"Find a font that approximately or exactly match the requested font"		^self bestFontsCache		at: requestedFont		ifAbsentPut: [requestedFont findBestFontsOn: self allowance: tolerance]</body><body package="WindowsUnicodeFonts">findFont: aFontDescription	"Answer the nearest font from those available on this device	to the requested FontDescription"		| font bestMatch |	fdCache = aFontDescription ifTrue: [^dfCache].	font := fontCache		at: aFontDescription		ifAbsent: [nil].	font		ifNotNil:			[fdCache := aFontDescription copy.			dfCache := font.			^font].	bestMatch := self findBestFont: aFontDescription.	font := self fontClass createFont: bestMatch toResemble: aFontDescription for: self.	aFontDescription underline == true ifTrue: [font := font withUnderline].	aFontDescription strikeout == true ifTrue: [font := font withStrikeout].	aFontDescription color		ifNotNil: [font := font withColor: aFontDescription color].	fontCache		at: aFontDescription copy		put: font.	fdCache := aFontDescription.	dfCache := font.	^font</body></methods><methods><class-id>Core.WindowsCompositeFontPolicy</class-id> <category>initialize-release</category><body package="WindowsUnicodeFonts">initializeAvailableFontsFor: aDevice		availableFonts := self fontClass deviceFontClass listFontNames		collect: [:each | self fontClass parse: each].	bestFontsCache := Dictionary new</body><body package="WindowsUnicodeFonts">initializeFor: aDevice	nameWeight := 10.	familyWeight := 5.	manufacturerWeight := 1.	encodingWeight := 10.	pixelSizeWeight := 3.	boldnessWeight := 2.	italicWeight := 2.	serifWeight := 1.	fixedWidthWeight := 3.	setWidthWeight := 1.	verticalWeight := 10.	tolerance := 9.	self flushFonts.	device := aDevice.	fontClass := self defaultFontClass.	self initializeAvailableFontsFor: aDevice</body><body package="WindowsUnicodeFonts">invalidate	"The font policy has been replaced by a new one - invalidate it"	"Added this since there seemingly appeared circular references"		fontCache do: [:font | font invalidate].	fontCache := nil</body></methods><methods><class-id>Core.WindowsCompositeFontPolicy</class-id> <category>private</category><body package="WindowsUnicodeFonts">bestFonts: requestedFont allowance: allowance	"Find a font that approximately or exactly matches the requested font"	"allowance is ignored"	| req fonts |	req := requestedFont copy.	req optimizeMatching.	fonts := SortedCollection sortBlock: [:a :b | a key &lt; b key].	availableFonts do: 			[:concreteFont |			| distance |			distance := self measureDistancesFrom: req to: concreteFont stopAt: allowance.			fonts add: distance -&gt; concreteFont].	fonts notEmpty ifTrue: [^fonts collect: [:each | each value]].	^noFontBlock		ifNil: [self class noMatchingFontSignal raiseRequestWith: requestedFont]		ifNotNil: [noFontBlock value: requestedFont]</body><body package="WindowsUnicodeFonts">compareSizeOf: requestedFont to: concreteFont	"Measure the difference in sizes between the requested font and a given 	concrete font"	| match |	match := concreteFont specifiesPixelSize		ifTrue: [(self allowsScalableFonts and: [concreteFont pixelSize = 0])				ifTrue: ["Scalable fonts always match the size perfectly."						0]				ifFalse: 					[(0.0 + requestedFont pixelSize - concreteFont pixelSize) abs						/ requestedFont pixelSize * pixelSizeWeight]]		ifFalse: [requestedFont specifiesPixelSize				ifTrue:	[pixelSizeWeight]				ifFalse:	[0]].	requestedFont specifiesPixelSize		ifFalse:	[match := match * 0.01].	^match</body></methods><methods><class-id>Core.WindowsCompositeFontPolicy</class-id> <category>accessing</category><body package="WindowsUnicodeFonts">bestFontsCache		^bestFontsCache</body><body package="WindowsUnicodeFonts">defaultFontClass	^WindowsCompositeFont</body><body package="WindowsUnicodeFonts">flushFonts	super flushFonts.	bestFontsCache := Dictionary new</body></methods><methods><class-id>Core.WindowsCompositeFontPolicy</class-id> <category>private - matching</category><body package="WindowsUnicodeFonts">commonEncodingMatchFrom: requestedFont to: concreteFont weight: weight	"Measure the difference of a non-numeric attribute between the requested font	and a given concrete font"		| match item testValue list |	testValue := concreteFont encoding.	testValue ifNotNil: [testValue := testValue asString].	item := requestedFont encoding.	item ifNil: [^0].	item := item asString.	item = testValue ifTrue: [^0].	(self isUniversalEncoding: testValue) ifTrue: [^weight * 0.04].	list := EncodingTable		at: item		ifAbsent: [^weight].	match := list		at: testValue		ifAbsent: [1.0].	^match * weight</body><body package="WindowsUnicodeFonts">encodingMatchFrom: requestedFont to: concreteFont weight: weight	"Measure the difference of a non-numeric attribute between the requested font	and a given concrete font"	^self fontClass deviceFontClass encodingMatchFor: requestedFont concrete: concreteFont in: self  weight: weight</body></methods><methods><class-id>Core.WindowsCompositeFontPolicy class</class-id> <category>cacheing</category><body package="WindowsUnicodeFonts">flushCaches	FontPolicyCache := IdentityDictionary new</body></methods><methods><class-id>Core.WindowsCompositeFontPolicy class</class-id> <category>instance creation</category><body package="WindowsUnicodeFonts">on: aGraphicsDevice	| fontPolicy |	fontPolicy := FontPolicyCache at: aGraphicsDevice				ifAbsentPut: 					[(super on: aGraphicsDevice)						initializeDefault;						yourself].	^fontPolicy</body></methods><methods><class-id>Core.Range</class-id> <category>adding</category><body package="WindowsUnicodeFonts">add: newObject	self shouldNotImplement</body></methods><methods><class-id>Core.Range</class-id> <category>accessing</category><body package="WindowsUnicodeFonts">at: anIndex	anIndex &gt; self size ifTrue: [self subscriptBoundsErrorFor: #at: index: anIndex].	^anIndex + first - 1</body><body package="WindowsUnicodeFonts">first	^first</body><body package="WindowsUnicodeFonts">first: aNumber	first := aNumber</body><body package="WindowsUnicodeFonts">last	^last</body><body package="WindowsUnicodeFonts">last: aNumber	last := aNumber</body><body package="WindowsUnicodeFonts">size	^last - first + 1</body></methods><methods><class-id>Core.Range</class-id> <category>printing</category><body package="WindowsUnicodeFonts">printOn: aStream	aStream nextPutAll: self class name.	aStream nextPut: $(.	first printOn: aStream.	aStream nextPutAll: ' - '.	last printOn: aStream.	aStream nextPut: $)</body></methods><methods><class-id>Core.Range</class-id> <category>testing</category><body package="WindowsUnicodeFonts">includes: anInteger	^anInteger &gt;= first and: [anInteger &lt;= last]</body></methods><methods><class-id>Core.Range class</class-id> <category>instance creation</category><body package="WindowsUnicodeFonts">from: aStartIndex to: aStopIndex	^(self new)		first: aStartIndex;		last: aStopIndex;		yourself</body></methods><methods><class-id>Core.RunArray</class-id> <category>accessing</category><body package="RunArray extensions">at: anInteger put: aValue	"| ra | ra :=RunArray new: 10 withAll: nil. ra at: 1 put: 16rff.	ra"	self		replaceFrom: anInteger		to: anInteger		with: (RunArray new: 1 withAll: aValue).	^aValue</body></methods><methods><class-id>Core.RunArray</class-id> <category>copying</category><body package="RunArray extensions">replaceFrom: start to: stop with: replacement	| newRunArray |	newRunArray := self copyReplaceFrom: start to: stop with: replacement.	self setRuns: newRunArray runs setValues: newRunArray values</body></methods><methods><class-id>Core.Array</class-id> <category>accessing</category><body package="RunArray extensions">range: aRange ifNilPut: anObject	aRange do: [:i | (self at: i + 1) ifNil: [self at: i + 1 put: anObject]]</body></methods><methods><class-id>Graphics.ByteCharacterEncoder</class-id> <category>accessing</category><body package="WindowsUnicodeFonts">ranges	| ranges supportedCharacters |	ranges := OrderedCollection new.	supportedCharacters := self supportedCharacters.	supportedCharacters piecesCutWhere: [:each :next | each asInteger + 1 ~= next asInteger]		do: [:coll | ranges add: (Range from: coll first asInteger to: coll last asInteger)].	^ranges</body><body package="WindowsUnicodeFonts">supportedCharacters	| illegalChar |	illegalChar := Character value: Character illegalCode.	^decoder select: [:char | char ~= illegalChar]</body></methods><methods><class-id>Graphics.SyntheticFont</class-id> <category>accessing</category><body package="WindowsUnicodeFonts">encoder	^baseFont encoder</body></methods><methods><class-id>Graphics.Screen class</class-id> <category>private</category><body package="WindowsUnicodeFonts">installWindowsCompositeFontPolicy	"self installWindowsCompositeFontPolicy"	self default platformName = 'MS-Windows'		ifTrue: 			[| policy |			policy := WindowsCompositeFontPolicy on: self default.			self default defaultFontPolicy: policy.			self install]</body></methods><methods><class-id>Graphics.Screen</class-id> <category>accessing</category><body package="WindowsUnicodeFonts">defaultFontPolicy: aFontPolicy	defaultFontPolicy := aFontPolicy</body></methods><methods><class-id>Graphics.Screen</class-id> <category>private - allocating resources</category><body package="WindowsUnicodeFonts">fontNamed: aName primName: aPrimName fromClass: aFontClass encoding: anEncoding	| font nameKey |	nameKey := aName asSymbol.	font := openFonts at: nameKey ifAbsent: [nil].	font ifNotNil: [^font].	font := aFontClass new.	font name: aName.	font initializeFrom: (self allocateFontNamed: aPrimName).	font setEncoder: anEncoding.	openFonts at: nameKey put: font.	^font</body></methods><methods><class-id>OS.Win32SystemSupport</class-id> <category>api</category><body package="WindowsUnicodeFonts">currentFontFor: hdc		^self		GetCurrentObject: hdc		typeValue: self OBJ_FONT</body></methods><methods><class-id>OS.Win32SystemSupport</class-id> <category>defines</category><body package="WindowsUnicodeFonts">DEFAULT_CHARSET	&lt;C: #define DEFAULT_CHARSET 1	&gt;</body></methods><methods><class-id>OS.Win32SystemSupport</class-id> <category>typedefs wingdi</category><body package="WindowsUnicodeFonts">ENUMLOGFONTEX		&lt;C: typedef struct tagENUMLOGFONTEX ENUMLOGFONTEX&gt;</body><body package="WindowsUnicodeFonts">FONTENUMPROC		&lt;C: typedef int (__stdcall * FONTENUMPROC)(ENUMLOGFONTEX * , NEWTEXTMETRICEX * , int, LPARAM)&gt;</body><body package="WindowsUnicodeFonts">FONTSIGNATURE		&lt;C: typedef struct tagFONTSIGNATURE FONTSIGNATURE&gt;</body><body package="WindowsUnicodeFonts">GLYPHSET	&lt;C: typedef struct tagGLYPHSET GLYPHSET&gt;</body></methods><methods><class-id>OS.Win32SystemSupport</class-id> <category>typedefs wtypes</category><body package="WindowsUnicodeFonts">HFONT	&lt;C: typedef HANDLE HFONT&gt;</body></methods><methods><class-id>OS.Win32SystemSupport</class-id> <category>typedefs wingdi</category><body package="WindowsUnicodeFonts">HGDIOBJ		&lt;C: typedef HANDLE HGDIOBJ&gt;</body><body package="WindowsUnicodeFonts">LOGFONT	&lt;C: typedef struct tagLOGFONT LOGFONT&gt;</body></methods><methods><class-id>OS.Win32SystemSupport</class-id> <category>typedefs wtypes</category><body package="WindowsUnicodeFonts">LPARAM		&lt;C: typedef DWORD LPARAM&gt;</body></methods><methods><class-id>OS.Win32SystemSupport</class-id> <category>typedefs wingdi</category><body package="WindowsUnicodeFonts">LPGLYPHSET		&lt;C: typedef GLYPHSET* LPGLYPHSET&gt;</body><body package="WindowsUnicodeFonts">LPLOGFONT		&lt;C: typedef LOGFONT* LPLOGFONT&gt;</body><body package="WindowsUnicodeFonts">NEWTEXTMETRIC		&lt;C: typedef struct tagNEWTEXTMETRIC NEWTEXTMETRIC&gt;</body><body package="WindowsUnicodeFonts">NEWTEXTMETRICEX		&lt;C: typedef struct tagNEWTEXTMETRICEX NEWTEXTMETRICEX&gt;</body></methods><methods><class-id>OS.Win32SystemSupport</class-id> <category>defines</category><body package="WindowsUnicodeFonts">OBJ_FONT		^6</body></methods><methods><class-id>OS.Win32SystemSupport</class-id> <category>structures wingdi</category><body package="WindowsUnicodeFonts">tagENUMLOGFONTEX		&lt;C: struct tagENUMLOGFONTEX			{			LOGFONT	elfLogFont;	    		TCHAR		elfFullName[64];    			TCHAR		elfStyle[32];    			TCHAR		elfScript[32];			}&gt;</body><body package="WindowsUnicodeFonts">tagFONTSIGNATURE	&lt;C: struct tagFONTSIGNATURE			{			DWORD	fsUsb[4];    			DWORD	fsCsb[2];			}&gt;</body><body package="WindowsUnicodeFonts">tagGLYPHSET		&lt;C: struct tagGLYPHSET			{			DWORD		cbThis;			DWORD		flAccel;  			DWORD		cGlyphsSupported;  			DWORD		cRanges;  			WCRANGE		ranges[256];			}&gt;</body><body package="WindowsUnicodeFonts">tagLOGFONT		&lt;C: struct tagLOGFONT			{			LONG		lfHeight;    			LONG		lfWidth;    			LONG		lfEscapement;    			LONG		lfOrientation;   		 	LONG		lfWeight;    			BYTE		lfItalic;    			BYTE		lfUnderline;    			BYTE		lfStrikeOut;    			BYTE		lfCharSet;    			BYTE		lfOutPrecision;    			BYTE		lfClipPrecision;    			BYTE		lfQuality;    			BYTE		lfPitchAndFamily;    			TCHAR		lfFaceName[32]; 			}&gt;</body><body package="WindowsUnicodeFonts">tagNEWTEXTMETRIC		&lt;C: struct tagNEWTEXTMETRIC			{			LONG		tmHeight;     			LONG		tmAscent;     			LONG		tmDescent;     			LONG		tmInternalLeading;     			LONG		tmExternalLeading;     			LONG		tmAveCharWidth;     			LONG		tmMaxCharWidth;     			LONG		tmWeight;     			LONG		tmOverhang;     			LONG		tmDigitizedAspectX;     			LONG		tmDigitizedAspectY;     			TCHAR		tmFirstChar;     			TCHAR		tmLastChar;     			TCHAR		tmDefaultChar;     			TCHAR		tmBreakChar;     			BYTE		tmItalic;     			BYTE		tmUnderlined;     			BYTE		tmStruckOut;     			BYTE		tmPitchAndFamily;     			BYTE		tmCharSet;     			DWORD	ntmFlags;     			UINT		ntmSizeEM;     			UINT		ntmCellHeight;     			UINT		ntmAvgWidth; 			}&gt;</body><body package="WindowsUnicodeFonts">tagNEWTEXTMETRICEX		&lt;C: struct tagNEWTEXTMETRICEX			{			NEWTEXTMETRIC	ntmentm;    			FONTSIGNATURE	ntmeFontSignature;			}&gt;</body><body package="WindowsUnicodeFonts">tagWCRANGE		&lt;C: struct tagWCRANGE			{ 			WCHAR	wcLow; 			USHORT	cGlyphs;			}&gt;</body></methods><methods><class-id>OS.Win32SystemSupport</class-id> <category>typedefs wtypes</category><body package="WindowsUnicodeFonts">USHORT		&lt;C: typedef unsigned short USHORT&gt;</body></methods><methods><class-id>OS.Win32SystemSupport</class-id> <category>typedefs wingdi</category><body package="WindowsUnicodeFonts">WCRANGE		&lt;C: typedef struct tagWCRANGE WCRANGE&gt;</body></methods><methods><class-id>Graphics.FontDescription</class-id> <category>private</category><body package="WindowsUnicodeFonts">findBestFontsOn: aFontPolicy allowance: anAllowance	^aFontPolicy bestFonts: self allowance: anAllowance</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Win32SystemSupport</name><environment>OS</environment><super>OS.OSSystemSupport</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.Win32SystemSupportDictionary.*			</imports><category>OS-Support</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>kernel32.dll</item> <item>gdi32.dll</item> <item>advapi32.dll</item> <item>user32.dll</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>OS-PC</package></attributes></class><class><name>SyntheticFont</name><environment>Graphics</environment><super>Graphics.ImplementationFont</super><private>false</private><indexed-type>none</indexed-type><inst-vars>baseFont color underline strikeout widths fontDescription </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Fonts</category><attributes><package>Graphics-Fonts</package></attributes></class><class><name>SequenceableCollection</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>Array</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>CompositeFont</name><environment>Graphics</environment><super>Graphics.ImplementationFont</super><private>false</private><indexed-type>none</indexed-type><inst-vars>ascent descent currentFont fonts priorityTable defaultScanner </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Internationalization</category><attributes><package>Internationalization</package></attributes></class><class><name>Screen</name><environment>Graphics</environment><super>Graphics.HostGraphicsDevice</super><private>false</private><indexed-type>none</indexed-type><inst-vars>boundingBox subRegions resolution rendererName nativeGUIPolicy </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Window System</category><attributes><package>OS-Window System</package></attributes></class><class><name>CharacterEncoder</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name alternateNames </inst-vars><class-inst-vars></class-inst-vars><imports>			Core.CharacterEncoderPool.*			</imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>FontDescription</name><environment>Graphics</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name family manufacturer pixelSize flags masks color encoding encodings </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Fonts</category><attributes><package>Graphics-Fonts</package></attributes></class><class><name>RunArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>runs values cacheRun cacheRunStart </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>ByteCharacterEncoder</name><environment>Graphics</environment><super>Core.CharacterEncoder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>encoder decoder streamEncodingType definitionClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Fonts</category><attributes><package>Graphics-Fonts</package></attributes></class><class><name>FontPolicy</name><environment>Graphics</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>availableFonts device fontClass defaultFont fontCache tolerance nameWeight familyWeight manufacturerWeight encodingWeight pixelSizeWeight boldnessWeight italicWeight serifWeight fixedWidthWeight setWidthWeight verticalWeight fdCache dfCache noFontBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Fonts</category><attributes><package>Graphics-Fonts</package></attributes></class><class><name>MSWindowsFont</name><environment>Graphics</environment><super>Graphics.ScreenFont</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Fonts</category><attributes><package>Graphics-Fonts</package></attributes></class></st-source>