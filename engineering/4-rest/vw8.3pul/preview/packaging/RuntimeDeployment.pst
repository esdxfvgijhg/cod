<?xml version="1.0"?><st-source><!-- Name: RuntimeDeploymentNotice: Copyright 1999-2014 Cincom Systems, Inc.  All rights reserved.Comment: Provides runtime image construction facilities including a generic Subsystem with image deployment behavior, and ErrorNotifier / ErrorDumper functionality for deploying a runtime image for simple applications.  DbIdentifier: bear73DbTrace: 432239DbUsername: jkottDbVersion: 8.0 - 2DisregardedPrerequisites: #()PackageName: RuntimeDeploymentParcel: #('RuntimeDeployment')ParcelName: RuntimeDeploymentPrintStringCache: (8.0 - 2,jkott)Version: 8.0 - 2Date: 7:51:38 AM May 13, 2014 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.0 (may14.2) of May 13, 2014 on May 13, 2014 at 7:51:38 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>RuntimeDeploying</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			</imports><category></category><attributes><package>RuntimeDeployment</package></attributes></name-space><class><name>RuntimeDeployment</name><environment>RuntimeDeploying</environment><super>Core.UserApplication</super><private>false</private><indexed-type>none</indexed-type><inst-vars>properties </inst-vars><class-inst-vars>debug errorFile </class-inst-vars><imports></imports><category></category><attributes><package>RuntimeDeployment</package></attributes></class><comment><class-id>RuntimeDeploying.RuntimeDeployment</class-id><body>RuntimeDeployment is a small subsystem responsible for processing command line options which deploy the application as a runtime image.  Each option is also exposed with scripting support for automatic runtime image construction.  Although you name your application's startup class here, this subsystem uses this class to provide information when setting up the runtime configuration, but does not actually start your application.  You need to provide your own application subsystem with which to do that.UsageName your application's startup class using the class method #startupClassName:.  Your startup class should implement a class method (#imageIdentification) to provide an identification string for debugging purposes.  You may set image configuration properties in this subsystem's singleton instance.  The properties will be used to configure the ImageConfigurationSystem for your deployed application and then cleared from the image before the runtime is created.  See the helper methods in the 'image configuration' protocol.  These configration properties default to false unless explicitly set in your subsystem before building your application runtime.You may also wish to take advantage of the ability to build a debug runtime version of your application which will open on a halt in the Debugger to allow you to track down problems when an exception occurs.  To enable this feature,	1) Implement class methods #debugging / #debugging: on your application startup class to set and return a persistent boolean value	2) Teach your application's #noticeOfWindowClose: how to handle closing your main application window, in the case where you want to open the VisualLauncher instead of just terminating the application.  For instance, you may want to add the following before or after whatever cleanup your application requires :		self class debugging 			ifTrue: 				[ScheduledWindow scheduledControllers size = 1 					ifTrue: [VisualLauncher open]]			ifFalse: [ObjectMemory quit]	3) Build your runtime image to contain the Debugger, as is the case when you use visual.im as your base image.Instance Variables	properties	&lt;Dictionary&gt;	name-value pairs used to setup the ImageConfigurationSystem for the application runtimeShared Variables	StartupClass &lt;Class&gt;	the class which exposes the imageIdentification string for error files, and optionally enables conversion to a debug version when an error is encountered	ImageIdentification &lt;String&gt;	an identification string for your application which will be used in the error dump</body></comment><class><name>RuntimeErrorDumper</name><environment>RuntimeDeploying</environment><super>Core.ErrorDumper</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>RuntimeDeployment</package></attributes></class><comment><class-id>RuntimeDeploying.RuntimeErrorDumper</class-id><body>RuntimeErrorDumper creates a more complete dump suitable for a packaged runtime image.In addition to the information written by ErrorDumper, this class provides a more detailed stack dump, the command line information, and an image identifier provided by a subsystem.</body></comment><class><name>RuntimeErrorNotifier</name><environment>RuntimeDeploying</environment><super>Core.ErrorNotifier</super><private>false</private><indexed-type>none</indexed-type><inst-vars>exceptionType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>RuntimeDeployment</package></attributes></class><comment><class-id>RuntimeDeploying.RuntimeErrorNotifier</class-id><body>RuntimeErrorNotifier traps UserInterrupt (ctrl-y) exceptions and allows quit/continue processing.  In addition to creating a local dump file describing any exceptions encountered with its partner RuntimeErrorDumper (named in #imageDumperClass), it will also ignore any HaltInterrupt exceptions in standard deployment mode.In conjunction with the subsystem settings established when building the runtime image, RuntimeErrorNotifier has the ability to allow a specially built debug enabled image to automatically convert to development mode when an exception is encountered.  To use this facility you must build a debug runtime image based on visual.im (which contains the Debugger), and your subsystem must respond to #debug and #debug:.</body></comment><shared-variable><name>DumpSucceededMsg</name><environment>RuntimeDeploying.RuntimeErrorNotifier</environment><private>false</private><constant>false</constant><category>messages</category><initializer>nil</initializer><attributes><package>RuntimeDeployment</package></attributes></shared-variable><shared-variable><name>UserInterruptMsg</name><environment>RuntimeDeploying.RuntimeErrorNotifier</environment><private>false</private><constant>false</constant><category>messages</category><initializer>nil</initializer><attributes><package>RuntimeDeployment</package></attributes></shared-variable><shared-variable><name>DumpFailedMsg</name><environment>RuntimeDeploying.RuntimeErrorNotifier</environment><private>false</private><constant>false</constant><category>messages</category><initializer>nil</initializer><attributes><package>RuntimeDeployment</package></attributes></shared-variable><shared-variable><name>ErrorOccurredMsg</name><environment>RuntimeDeploying.RuntimeErrorNotifier</environment><private>false</private><constant>false</constant><category>messages</category><initializer>nil</initializer><attributes><package>RuntimeDeployment</package></attributes></shared-variable><shared-variable><name>ImageIdentification</name><environment>RuntimeDeploying.RuntimeDeployment</environment><private>false</private><constant>false</constant><category>resources</category><attributes><package>RuntimeDeployment</package></attributes></shared-variable><shared-variable><name>StartupClassName</name><environment>RuntimeDeploying.RuntimeDeployment</environment><private>false</private><constant>false</constant><category>resources</category><attributes><package>RuntimeDeployment</package></attributes></shared-variable><methods><class-id>RuntimeDeploying.RuntimeDeployment</class-id> <category>scripting support</category><body package="RuntimeDeployment">debug: aBoolean	self class debug: aBoolean</body><body package="RuntimeDeployment">deployAs: imageName	[self class deployAs: imageName] uiEvent</body><body package="RuntimeDeployment">errorFile: aString	self class errorFile: aString</body><body package="RuntimeDeployment">startupClassName: aClassName	self class startupClassName: aClassName</body></methods><methods><class-id>RuntimeDeploying.RuntimeDeployment</class-id> <category>image configuration</category><body package="RuntimeDeployment">allowDevelopment	self propertyAt: #allowDevelopment put: true</body><body package="RuntimeDeployment">allowExpressions	self propertyAt: #allowExpressions put: true</body><body package="RuntimeDeployment">allowFilein	self propertyAt: #allowFilein put: true</body><body package="RuntimeDeployment">allowParcelLoading	self propertyAt: #allowParcelLoading put: true</body><body package="RuntimeDeployment">allowSettings	self propertyAt: #allowSettings put: true</body><body package="RuntimeDeployment">useDefaultConfigFile	self propertyAt: #useDefaultConfigFile put: true</body></methods><methods><class-id>RuntimeDeploying.RuntimeDeployment</class-id> <category>properties</category><body package="RuntimeDeployment">clearProperties	properties := nil</body><body package="RuntimeDeployment">propertyAt: aSymbol	"Answer the property at the symbol"	^properties ifNotNil: [properties at: aSymbol ifAbsent: nil]</body><body package="RuntimeDeployment">propertyAt: aSymbol put: aValue	"Set the property value"	properties ifNil: [properties := Dictionary new].	^properties at: aSymbol put: aValue</body></methods><methods><class-id>RuntimeDeploying.RuntimeDeployment class</class-id> <category>private</category><body package="RuntimeDeployment">defaultErrorFile	^'runtime-error.log'</body><body package="RuntimeDeployment">defaultLocationTail		^'runtime.im'</body><body package="RuntimeDeployment">imagePrefixFrom: aStringOrNil		| imageTail |	imageTail := aStringOrNil ifNil: [self defaultLocationTail].	^('*.im' match: imageTail)		ifTrue:			[imageTail				copyFrom: 1				to: imageTail size - 3]		ifFalse: [imageTail]</body><body package="RuntimeDeployment">suppressDeploymentOptions	"Turn off deployment option support in the resulting deployed image."	RuntimeDeployment		compile: 'debug: ignore ^self'		classified: 'private'		attributes: nil.	RuntimeDeployment		compile: 'deployAs: ignore ^self'		classified: 'private'		attributes: nil.	RuntimeDeployment		compile: 'startupClassName: ignore ^self'		classified: 'private'		attributes: nil</body><body package="RuntimeDeployment">suppressLauncherChangeRequests	VisualLauncher 		compile: 'changeRequest ^true'		classified: 'private'		attributes: nil</body><body package="RuntimeDeployment">suppressLauncherStatusBarUpdates	VisualLauncher 		compile: 'updateStatusBar ^self'		classified: 'private'		attributes: nil</body></methods><methods><class-id>RuntimeDeploying.RuntimeDeployment class</class-id> <category>actions - deployment</category><body package="RuntimeDeployment">cleanUpImage		Transcript cr; show: 'Cleaning up image'.	#{Workbook} ifDefinedDo: [:wkbk |		[wkbk allInstances do: [:i | i closeAndUnschedule]] uiEventNow].	self suppressLauncherStatusBarUpdates.	self suppressLauncherChangeRequests.	DeploymentOptionsSystem suppressSplashScreenAndHerald.	IndexedFileMessageCatalog directoriesModel value removeFirst.	IndexedFileMessageCatalog updateDirectories.	(Parcel parcelNamed: 'DLLCC') ifNotNil: [:pcl | pcl unload].	Parcel searchPathModel value: List new.	NamedChangeSet.ChangeSetList := List new.	ChangeSet current: (NamedChangeSet withName: #Default).	NamedChangeSet addChangeSet: NamedChangeSet current.	Undeclared purgeUnusedBindings.	CompiledMethod purgeSourceInfoCache.	WindowManager purgeDeadWindows.	ProcessEnvironment current localRemoveKey: #WindowManager.	WindowManager		noWindowBlock: [:ignore | RuntimeSystem isRuntime ifTrue: [ObjectMemory quit]].	[VisualLauncher allInstances do: [:each | each closeAndUnschedule]] uiEventNow.	ObjectMemory globalGarbageCollect</body><body package="RuntimeDeployment">clearProperties	self current clearProperties.	ObjectMemory globalGarbageCollect</body><body package="RuntimeDeployment">configureApplication	"If the Application implements debugging switch-over, configure it."	self startupClass		ifNotNil: [:class | (class respondsTo: #debugging:) ifTrue: [class debugging: self debug]]</body><body package="RuntimeDeployment">configureErrorNotification	self startupClass		ifNotNil: 			[:class |			(class respondsTo: #imageIdentification)				ifTrue: [self imageIdentification: class imageIdentification]].	Notifier		current: RuntimeErrorNotifier;		uheFilename: self defaultErrorFile;		logToFile: true</body><body package="RuntimeDeployment">configureImageForRuntime	DeploymentOptionsSystem current startInRuntime: true.	ImageConfigurationSystem		allowParcelLoading: ((self current propertyAt: #allowParcelLoading) ifNil: [false]);		allowFilein: ((self current propertyAt: #allowFilein) ifNil: [false]);		allowSettings: ((self current propertyAt: #allowSettings) ifNil: [false]);		allowExpressions: ((self current propertyAt: #allowExpressions) ifNil: [false]);		useDefaultConfigFile: ((self current propertyAt: #useDefaultConfigFile) ifNil: [false]);		allowDevelopment: ((self current propertyAt: #allowDevelopment) ifNil: [false]).	self isHeadless ifFalse: [		ScheduledWindow scheduledControllers do: [:each | each view lookPreferences: each view lookPreferences]]</body><body package="RuntimeDeployment">deployAs: imageName	| imagePrefix promise |	self cleanUpImage.	self configureImageForRuntime.	self configureErrorNotification.	self configureApplication.	self suppressDeploymentOptions.	"We have finished using the properties, so clear them out of the deployed image."	self clearProperties.	imagePrefix := self imagePrefixFrom: imageName.	promise := 			[(Delay forSeconds: 5) wait.			"The 64-bit VM currently cannot open images that are perm saved."			ObjectMemory is64Bit				ifTrue: [ObjectMemory saveAs: imagePrefix thenQuit: false]				ifFalse: [ObjectMemory permSaveAs: imagePrefix thenQuit: false]]					promise.	promise value.	RuntimeSystem isRuntime ifFalse: [ObjectMemory quit]</body></methods><methods><class-id>RuntimeDeploying.RuntimeDeployment class</class-id> <category>accessing</category><body package="RuntimeDeployment">debug	^debug ifNil: [false]</body><body package="RuntimeDeployment">debug: aBoolean	debug := aBoolean</body><body package="RuntimeDeployment">errorFile	^errorFile ifNil: [self defaultErrorFile]</body><body package="RuntimeDeployment">errorFile: aString	errorFile := aString</body><body package="RuntimeDeployment">imageIdentification	^ImageIdentification ifNil: ['Unspecified VisualWorks Application']</body><body package="RuntimeDeployment">imageIdentification: aString	ImageIdentification := aString</body><body package="RuntimeDeployment">isHeadless	^#{HeadlessImage} ifDefinedDo: [:image | image isHeadless] elseDo: [false]</body><body package="RuntimeDeployment">startupClass	self startupClassName asQualifiedReference ifDefinedDo: [:binding | ^binding].	^nil</body><body package="RuntimeDeployment">startupClassName	^StartupClassName</body><body package="RuntimeDeployment">startupClassName: aClassName	StartupClassName := aClassName</body></methods><methods><class-id>RuntimeDeploying.RuntimeDeployment class</class-id> <category>actions - runtime</category><body package="RuntimeDeployment">quitApplication	^self startupClass		ifNotNil: [:class | class allInstances do: [:app | app closeRequest]]</body><body package="RuntimeDeployment">shouldRaiseDebugger	"In a non-headless image, use the startupClass debugging mode (if any) to determine whether or not to convert	 to a development image and halt in the Debugger."	^self isHeadless not and: 			[(self startupClass respondsTo: #debugging)				ifTrue: [self startupClass debugging]				ifFalse: [false]]</body></methods><methods><class-id>RuntimeDeploying.RuntimeErrorDumper</class-id> <category>dumping</category><body package="RuntimeDeployment">dumpArgs: aContext 	"Dump the receiver and stack for the context"	| local |	aContext isBlockContext 		ifFalse: 			["Must be a method context"			dumpStream				crtab;				nextPutAll: 'Receiver: '.			self dumpValue: aContext homeReceiver.			1 to: aContext method numArgs				do: 					[:n | 					[local := aContext localAt: n] on: Object subscriptOutOfBoundsSignal						do: [:ex | local := 'Out of bounds -- not on context stack'].					dumpStream						crtab;						nextPutAll: 'Arg';						nextPutAll: n printString;						nextPutAll: ': '.					self dumpValue: local]]</body><body package="RuntimeDeployment">dumpCommandLine	"Write a representation of the current command line, if possible"	| opts |	dumpStream cr; nextPutAll: 'Command Line:'.	opts := CEnvironment commandLine.	opts do: [ :opt | dumpStream space; nextPutAll: opt asString. ].</body><body package="RuntimeDeployment">dumpExceptionReport: anException context: aContext	"Append a dump onto the dump stream.  anException represents the	condition causing the dump to be written in the first place.  aContext is the	context in which the exception was raised. The invoker should handle exceptions	that may arise in this process "	self dumpHeader.	self dumpSummary: anException.	self dumpCommandLine.	self dumpSeparator.	dumpStream cr; nextPutAll: 'Active Process'.	self dumpDetailsOfProcess: Processor activeProcess.	self dumpStack: aContext.	self dumpException: anException.	self dumpStackArgs: aContext.	self dumpTrailer.</body><body package="RuntimeDeployment">dumpImageIdentification	dumpStream		cr;		nextPutAll: 'Image Identification: ';		print: RuntimeDeployment imageIdentification</body><body package="RuntimeDeployment">dumpStackArgs: aContext	"Dump  a description of the args used for the initial stack entries.	This is done separately just in case there is a fatal error in evaluating the	printString of one of the argument values.."	| maxNbr ctx stackSize |	self dumpSeparator.	dumpStream cr; nextPutAll: 'Initial Context Stack Arguments:'.	maxNbr := self maximumArgFramesDumped.	ctx := aContext.	stackSize := 0.	[ ctx notNil and: [ stackSize &lt; maxNbr ] ] whileTrue: [		stackSize := stackSize + 1.		"Only dump args for MethodContexts, which are those that are not block contexts"		ctx isBlockContext ifFalse: [			[ dumpStream cr;				nextPut: $[; print: stackSize; nextPut: $]; space;				print: ctx.			self dumpArgs: ctx. ]			on: Error			do: [ :ex | dumpStream cr; nextPutAll: '--Error: ', ex description ] ].		ctx := ctx sender ].	" end of this section "	dumpStream cr.</body></methods><methods><class-id>RuntimeDeploying.RuntimeErrorDumper</class-id> <category>debugging</category><body package="RuntimeDeployment">debugOut: aString	Stdout		nextPutAll: ('&lt;n&gt;EmergencyDumper: &lt;1s&gt;' expandMacrosWith: aString)</body></methods><methods><class-id>RuntimeDeploying.RuntimeErrorNotifier</class-id> <category>testing</category><body package="RuntimeDeployment">canProceedAfterUserInterrupt	"Answer true if a user interrupt can proceed.  Answer false when event driven windows are	interrupted, and therefore event queue synchronization errors can result."	| queueClass nextClassAndMethod semaphoreClass waitClassAndMethod ctx foundNext foundWait counter |	self isProceedable ifFalse: [^false].	"Look through the stack for Semaphore&gt;&gt;wait and EventQueue&gt;&gt;next "	queueClass := #{EventQueue} valueOrDo: [^true].	(nextClassAndMethod := queueClass findSelector: #next) isNil ifTrue: [^true].	semaphoreClass := #{Semaphore} valueOrDo: [^false].	(waitClassAndMethod := semaphoreClass findSelector: #wait) isNil		ifTrue: [^true].	ctx := self context.	foundNext := false.	foundWait := false.	counter := 0.	[foundNext not and: [ctx notNil and: [counter &lt; 10]]] whileTrue: 			[(ctx receiver class == semaphoreClass				and: [ctx method == waitClassAndMethod last]) ifTrue: [foundWait := true].			(ctx receiver class == queueClass				and: [ctx method == nextClassAndMethod last]) ifTrue: [foundNext := true].			ctx := ctx sender.			counter := counter + 1].	" If problem children methods are found, there is no way to proceed without causing an error"	foundNext &amp; foundWait ifTrue: [^false].	^true</body><body package="RuntimeDeployment">canProceedableExceptionProceed	"Here is where we just ignore a halt.  Any other exceptions do not proceed automatically."		self exceptionType == #halt ifTrue: [^true].	^false</body><body package="RuntimeDeployment">isInterruptFromUser	"Answer true if the exception really is from the user versus other	 unrelated ways of raising the userInterruptSignal such as low memory."	^( self exceptionType == #userInterrupt and: [		self exception isResumable ] )</body><body package="RuntimeDeployment">shouldRaiseDebugger	"Debug mode is controlled by the runtime application, if debugging is available in a non-headless image.	 Access this through the Subsystem."	#{DebuggerService} ifDefinedDo: 			[:ignore |			^RuntimeDeployment shouldRaiseDebugger].	^false</body></methods><methods><class-id>RuntimeDeploying.RuntimeErrorNotifier</class-id> <category>actions</category><body package="RuntimeDeployment">createDump	"Create a dump that is appropriate for the runtime image.  If the interrupt was from the user, then	 check with the user first, to see if they want to quit the image.  If they do, then write the dump and 	 quit the image.  If the request to create a runtime image dump was not caused by an user interrupt,	 then write the dump file and quit the image."	| userNotified dumpWorked |	RuntimeDeployment isHeadless ifTrue: [^self createEmergencyDump].	userNotified := false.	self isInterruptFromUser		ifTrue: 			[userNotified := true.			self confirmUserInterruptRequest				ifFalse: 					[self class resetErrorState.					^self proceedAfterUserInterrupt]].	dumpWorked := self createEmergencyDump.	userNotified ifFalse: [self notifyUserOfUnhandledException: dumpWorked].	"Finally, terminate the image. "	self class errorState: #quitting.	self quitImage</body><body package="RuntimeDeployment">createEmergencyDump	"Answer true if no dump is requested, as in the case where imageDumperClass isNil.  If imageDumperClass is defined, create a dump log unless #dumpLogTo: fails with an OsError.  Answer true if the dump succeeded or false otherwise."	self imageDumperClass ifNil: [^true].	self inferMissingData.		[self dumpLogTo: self dumpFilename.	^true] 		on: OsError		do: [:ex | ex return].	^false</body><body package="RuntimeDeployment">dumpFilename	"Create the stack dump in the current directory, if possible.  Otherwise create it in the HOME directory, where the user definitely has write permissions."	| filename |	([(filename := self errorFilename asFilename asAbsoluteFilename) canBeWritten] on: OsError do: [false])		ifFalse: [filename := self platformTempDirectory / self errorFilename asString].	^filename</body><body package="RuntimeDeployment">notify	"We don't normally have a Debugger in the image and therefore can't handle #halt, 	 but in case you built a test image from visual.im instead of base.im, this will bring you 	 into the Debugger if the Application is configured to allow that."	self shouldRaiseDebugger		ifTrue: 			[Notifier beDevelopment.			self				halt: (#HaltInRuntimeErrorNotifier &lt;&lt; #dialogs						&gt;&gt; 'Halted in RuntimeErrorNotifier under debug') asString].	self checkForErrorRecursion.	self class errorState: #processingError.	self class errorProcess: Processor activeProcess.	self proceedExceptionOr: [self createDump]</body><body package="RuntimeDeployment">proceedExceptionOr: aBlock	"Fill out missing information depending on which instantiation technique was used.	 This is done after the recursive error test to catch problems finding the missing ingredients.	 Then check for proceedable signal that can proceed."	self inferMissingData.	self isProceedable		ifTrue: 			[self canProceedableExceptionProceed				ifTrue: 					[self class resetErrorState.					^self exception proceed]].	^aBlock value</body></methods><methods><class-id>RuntimeDeploying.RuntimeErrorNotifier</class-id> <category>internal</category><body package="RuntimeDeployment">classifyException	"Classify an exception as to its type, so we can intercept Halt or a true UserInterrupt."	self exceptionType: #other.	self exception creator == Object haltSignal		ifTrue: 			[self exceptionType: #halt.			^self].	self exception creator == UserInterrupt		ifTrue: 			[self exceptionType: #userInterrupt.			^self]</body><body package="RuntimeDeployment">inferMissingData	"If no exception was passed initially, find one.  	 In the case where no context was provided explicitly, it should be the parameter for the exception."	self exception isNil ifTrue: [self exception: self findException].	self context isNil ifTrue: [self context: self exception parameter].	self classifyException</body><body package="RuntimeDeployment">proceedAfterUserInterrupt	"Proceed carefully after a user interrupt.  When event driven windows are	interrupted, event queue synchronization errors can result.  This case is	recognized and the exception is dismissed.  Since there is nothing going	on at the time anyway, the effect is the same.  This is all just a work-around	for what is probably a bug in the event queue mechanism"	self canProceedAfterUserInterrupt ifFalse: [		self dismissException ].	" otherwise we can just proceed as normal "	^self exception proceed</body><body package="RuntimeDeployment">quitImage	"Defer to the Subsystem."	RuntimeDeployment quitApplication</body></methods><methods><class-id>RuntimeDeploying.RuntimeErrorNotifier</class-id> <category>accessing</category><body package="RuntimeDeployment">exceptionType	^exceptionType</body><body package="RuntimeDeployment">exceptionType: anObject	exceptionType := anObject</body></methods><methods><class-id>RuntimeDeploying.RuntimeErrorNotifier</class-id> <category>debugging</category><body package="RuntimeDeployment">debugOut: aString	Stdout		nextPutAll: ('&lt;n&gt;EmergencyHandler: &lt;1s&gt;' expandMacrosWith: aString)</body></methods><methods><class-id>RuntimeDeploying.RuntimeErrorNotifier</class-id> <category>user interface</category><body package="RuntimeDeployment">confirmUserInterruptRequest	"Ask the user if the image should quit now"	^Dialog confirm: self class userInterruptMsg</body><body package="RuntimeDeployment">notifyUserOfUnhandledException: dumpWorked	"Actually notify the user of the unhandled exception.	dumpWorked is a boolean indicating if a dump was written"	| msg errorString |	msg := WriteStream on: (String new: 512).	errorString := self exception errorString.	errorString size &gt; 60		ifTrue: 			[errorString := errorString copyFrom: 1 to: 55.			errorString := errorString , ' ...'].	msg		nextPutAll: errorString;		nextPutAll: self class errorOccurredMsg.	dumpWorked		ifTrue: 			[msg nextPutAll: (self class dumpSucceededMsg						expandMacrosWith: self dumpFilename asString)]		ifFalse: [msg nextPutAll: self class dumpFailedMsg].	Dialog warn: msg contents</body></methods><methods><class-id>RuntimeDeploying.RuntimeErrorNotifier</class-id> <category>environment settings</category><body package="RuntimeDeployment">platformTempDirectory	^OSHandle currentOS == #win32		ifTrue: [self windowsTempDirectory]		ifFalse: [self unixTempDirectory]</body><body package="RuntimeDeployment">unixTempDirectory	"This should be a writable directory, unless there is no $HOME defined."	^(SystemUtils getEnvironmentVariable: 'HOME' ifAbsent: ['.']) asFilename		asAbsoluteFilename ensureDirectory</body><body package="RuntimeDeployment">windowsTempDirectory	"This should be a writable directory, unless there is no %USERPROFILE% defined."	| tempDir |	(tempDir := ExternalProcess shOne: 'echo %USERPROFILE%') isEmpty		ifTrue: [tempDir := '.'].	^tempDir asFilename asAbsoluteFilename ensureDirectory</body></methods><methods><class-id>RuntimeDeploying.RuntimeErrorNotifier class</class-id> <category>accessing</category><body package="RuntimeDeployment">dumpFailedMsg	^DumpFailedMsg asString</body><body package="RuntimeDeployment">dumpSucceededMsg	^DumpSucceededMsg asString</body><body package="RuntimeDeployment">errorFilename		errorFilename isNil		ifTrue: [errorFilename := Notifier uheFilename asLogicalFileSpecification].	^errorFilename</body><body package="RuntimeDeployment">errorOccurredMsg	^ErrorOccurredMsg asString</body><body package="RuntimeDeployment">imageDumperClass	^imageDumperClass ifNil: [imageDumperClass := RuntimeErrorDumper].</body><body package="RuntimeDeployment">userInterruptMsg	^UserInterruptMsg asString</body></methods><methods><class-id>RuntimeDeploying.RuntimeErrorNotifier class</class-id> <category>class initialization</category><body package="RuntimeDeployment">initialize	"self initialize"	UserInterruptMsg := #RuntimeUserInterruptMsg &lt;&lt; #dialogs				&gt;&gt; 'Processing was interrupted by user request.&lt;n&gt;Do you want to terminate this application now?'						expandMacros.	ErrorOccurredMsg := #RuntimeErrorMsg &lt;&lt; #dialogs				&gt;&gt; '&lt;n&gt;&lt;n&gt;An error occurred in this application.&lt;n&gt;The application will now terminate.'						expandMacros.	DumpFailedMsg := #RuntimeDumpFailedMsg &lt;&lt; #dialogs				&gt;&gt; '&lt;n&gt;A diagnostic dump of the error could not&lt;n&gt;be made, or the dump was incomplete.'						expandMacros.	"Don't expand the macros now.  They will be expanded when the message is used."	DumpSucceededMsg := #RuntimeEmergencyAbortText &lt;&lt; #dialogs				&gt;&gt; '&lt;n&gt;A diagnostic dump is being written to&lt;n&gt;&lt;t&gt;&lt;1p&gt;&lt;n&gt;after which this application will terminate'</body></methods><methods><class-id>RuntimeDeploying.RuntimeDeployment</class-id> <category>command line handling</category><body package="RuntimeDeployment">debugRuntimeImage: tokenReadStream	&lt;option: '--debug' sequence: 1&gt;	self debug: true</body><body package="RuntimeDeployment">deployErrorFile: tokenReadStream	&lt;option: '-errorFile' sequence: 5&gt;	self errorFile: ((CommandLineInterest argumentsFrom: tokenReadStream)				ifNotNil: #first)</body><body package="RuntimeDeployment">deployRuntimeImage: tokenReadStream	&lt;option: '-deployRuntime' sequence: 4&gt;	self deployAs: ((CommandLineInterest argumentsFrom: tokenReadStream)				ifNotNil: #first)</body><body package="RuntimeDeployment">deployStartupClass: tokenReadStream	&lt;option: '-startupClass' sequence: 3&gt;	self startupClassName: ((CommandLineInterest argumentsFrom: tokenReadStream)				ifNotNil: #first)</body></methods><initialize><class-id>RuntimeDeploying.RuntimeErrorNotifier</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>ErrorDumper</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dumpStream dumpDate dumpTime fileName </inst-vars><class-inst-vars>maximumStackEntriesDumped </class-inst-vars><imports></imports><category>RuntimePackager</category><attributes><package>ErrorNotifier</package></attributes></class><class><name>UserApplication</name><environment>Core</environment><super>Core.Subsystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Subsystems</category><attributes><package>System-Subsystems</package></attributes></class><class><name>ErrorNotifier</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>exception context errorFilename </inst-vars><class-inst-vars>errorState errorProcess imageDumperClass errorFilename </class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>ErrorNotifier</package></attributes></class></st-source>