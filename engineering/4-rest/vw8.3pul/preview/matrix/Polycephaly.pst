<?xml version="1.0"?><st-source><!-- Name: PolycephalyNotice: Copyright © 2011-1999 Cincom Systems, Inc.  All Rights Reserved.Comment: This package provides simple mechanisms for spawning multiple running copies of the image and using those to perform various tasks in parallel. This is primarily useful when attempting to utilize hosts with multi-core CPUs. The images are spawned headless and are connected with the main controlling image through their standard I/O streams which are wrapped with BOSS so that arbitrary objects can be sent through.The spawned images (drones) are represented by instances of VirtualMachine. The primary API are the variations of the #do: message which take an action expressed either as a String containing valid Smalltalk code	[ :vm | [ vm do: '3 + 4' ] ensure: [ vm release ] ] value: VirtualMachine newor an instance of "clean" BlockClosure (one that does not reference any variables, including globals, outside of its scope)	| vm |	vm := VirtualMachine new.	[	vm do: [3 + 4]	] ensure: [ vm release ].Optional arguments can be attached as well.	| vm |	vm := VirtualMachine new.	[	vm do: [ :a :b | a + b ] with: 3 with: 4	] ensure: [ vm release ]. Note that the arguments will be "BOSS-ed out" for transport, so anything in the scope of objects they reference (transitively) will be included as well. Avoid including things like classes or external resources. For more complex cases where the clean block with arguments is hard to achieve, or when the action needs to hook into the objects in the drone image, the String based action is more suitable. Its advantage is that the code will be compiled in the Drone and can therefore reference classes and globals available in that image. In this case any arguments are referenced in the code as named variables and has to be passed in as a dictionary mapping the variable names to values. They will be included in the compilation scope as other shared variable bindings.	| vm |	vm := VirtualMachine new.	[	vm do: 'a + b' environment: (Dictionary new at: #a put: 3; at: #b put: 4; yourself)	] ensure: [ vm release ]. Note that a VM instance can be reused multiple times.	| vm |	vm := VirtualMachine new.	[	(1 to: 5) collect: [ :i | vm do: '3 + 4' ]	] ensure: [ vm release ].Consequently it needs to be explicitly shut down with the #release message when no longer needed.For cases when multiple VMs are needed to execute the same action in parallel, VirtualMachines class allows to maintain the whole set of machines as one.	| vm |	vm := VirtualMachines new: 2.	[	vm do: '3 + 4'	] ensure: [ vm release ].TODOCommentsBe Headful -  become headful, but don't open any windows, let the developer do thatHide MacOSX dock icon (LSUIElement mode switching, start in kiosk mode and swap to full ui mode on gui startup?)DbIdentifier: bear73DbTrace: 336118DbUsername: mlucas-smithDbVersion: 7.9 - 1DevelopmentPrerequisites: #(#(#any 'BOSS' '') #(#any 'DLLCC' ''))DialectVersion: VisualWorks®, Pre-Release 7.9 (jun11.1) of June 3, 2011ExplicitPrerequisites: #()IgnoredPrerequisites: #()PackageName: PolycephalyParcel: #('Polycephaly')PrerequisiteParcels: #(#('BOSS' ''))PrintStringCache: (7.9 - 1,mlucas-smith)Version: 7.9 - 1Date: 1:16:01 PM May 3, 2013 --><time-stamp>From VisualWorks®, Pre-Release 7.10 (may13.1) of May 3, 2013 on May 3, 2013 at 1:16:01 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>Polycephaly</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			</imports><category></category><attributes><package>Polycephaly</package></attributes></name-space><class><name>VirtualMachine</name><environment>Polycephaly</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>listener processes input output transcript error </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Polycephaly</package></attributes></class><comment><class-id>Polycephaly.VirtualMachine</class-id><body>I represent and control a spawned copy of the image (a drone) executing in its own OS process. I can send actions to the drone and wait for the result (or error) to be reported back (see the #do:... methods). The drone is connected to me through its standard I/O streams wrapped in BOSS so that arbitrary objects can be passed through easily.Instance Variables	listener	&lt;Process&gt; waits for responses from the drone	processes	&lt;Dictionary key: SmallInteger value: Semaphore&gt; maps idenity of processes waiting for completion of a drone task to their semaphores.	input	&lt;Pipe&gt; standard out of the drone	output	&lt;Pipe&gt; standard in of the drone	transcript	&lt;TextCollector | WriteStream&gt; target for logging	error	&lt;Pipe&gt; standard error of the dronShared Variables	Logging	&lt;Boolean&gt; should we log execution events</body></comment><class><name>DebugMachine</name><environment>Polycephaly</environment><super>Polycephaly.VirtualMachine</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Polycephaly</package></attributes></class><class><name>Drone</name><environment>Polycephaly</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>listener output input processes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Polycephaly</package></attributes></class><class><name>DroneTranscript</name><environment>Polycephaly</environment><super>OS.AbstractStreamTranscript</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>current </class-inst-vars><imports></imports><category>Headless-Support</category><attributes><package>Polycephaly</package></attributes></class><class><name>VirtualMachines</name><environment>Polycephaly</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>machines </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Polycephaly</package></attributes></class><comment><class-id>Polycephaly.VirtualMachines</class-id><body>I'm useful when multiple VMs are needed to execute the same action in parallel. I maintain a set of machines to be controlled as one.Instance Variables	machines	&lt;Array of: VirtualMachines&gt; </body></comment><class><name>Pipe</name><environment>Polycephaly</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>objects bytes connection semaphore </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Polycephaly</package></attributes></class><shared-variable><name>EndOfTransmission</name><environment>Polycephaly</environment><private>true</private><constant>true</constant><category>accessing</category><initializer>4 asCharacter</initializer><attributes><package>Polycephaly</package></attributes></shared-variable><shared-variable><name>Logging</name><environment>Polycephaly.Drone</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>false</initializer><attributes><package>Polycephaly</package></attributes></shared-variable><shared-variable><name>Logging</name><environment>Polycephaly.VirtualMachine</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>false</initializer><attributes><package>Polycephaly</package></attributes></shared-variable><methods><class-id>Polycephaly.VirtualMachine</class-id> <category>private - external process</category><body package="Polycephaly">arguments	^#( 1 '-headless' '-doit' 2 ) copy		replaceAll: 1 with: self image;		replaceAll: 2 with: 'Polycephaly.Drone new';		yourself</body><body package="Polycephaly">executable	^CEnvironment commandLine first asFilename asAbsoluteFilename asString</body><body package="Polycephaly">execute: doBlock errorStreamDo: errorBlock	^ExternalProcess new		encoding: #binary;		execute: self executable		arguments: self arguments		do: doBlock		errorStreamDo: errorBlock;		yourself</body><body package="Polycephaly">image	^ObjectMemory imageFilename asAbsoluteFilename asString</body></methods><methods><class-id>Polycephaly.VirtualMachine</class-id> <category>testing</category><body package="Polycephaly">isBusy	" Is the virtual machine currently doing something. This does not mean you cannot queue up more commands for it to perform. "	^processes notEmpty</body></methods><methods><class-id>Polycephaly.VirtualMachine</class-id> <category>private</category><body package="Polycephaly">listen	[[ | id result semaphore |	self log: '#listen read'.	input readWhile: [:stream |		id := stream next.		result := stream next].	self log: '#listen callback'.	semaphore := processes at: id ifAbsent: [nil].	semaphore ifNotNil:		[processes at: id put: result.		semaphore signal]] repeat]		on: UnhandledException do: [:exception | ]</body><body package="Polycephaly">report	[[ | message |	self log: '#report read'.	message := error readWhile: [:stream | stream next].	transcript nextPutAll: message] repeat]		on: UnhandledException do: [:exception | ]</body><body package="Polycephaly">terminate: id	self log: '#terminate id: ', id printString.	output writeWhile: [:stream |		stream nextPut: id.		stream nextPut: Kernel.ProcessorScheduler.HighIOPriority.		stream nextPut: #terminate.		stream nextPut: nil]</body></methods><methods><class-id>Polycephaly.VirtualMachine</class-id> <category>initialize-release</category><body package="Polycephaly">initialize	self initializeTranscript.	self startLog.	self log: '#initialize'.	processes := Dictionary new.	self initializeListener</body><body package="Polycephaly">initializeListener	| readySemaphore |	readySemaphore := Semaphore new.	listener :=		[self			execute: [:in :out |				[output := Pipe newOutputStream: out.				input := Pipe newInputStream: in] ensure: [readySemaphore signal].				self listen]			errorStreamDo: [:err |				[error := Pipe newInputStream: err] ensure: [readySemaphore signal].				self report].		self release] newProcess.	listener name: (Processor activeProcess name ifNil: [Processor activeProcess identityHash printString]), ':drone'.	listener priority: ProcessorScheduler.LowIOPriority.	listener resume.	readySemaphore wait; wait</body><body package="Polycephaly">initializeTranscript	transcript := Transcript</body><body package="Polycephaly">release	self log: '#release'.	listener ifNotNil:		[listener terminate.		listener := nil].	super release</body></methods><methods><class-id>Polycephaly.VirtualMachine</class-id> <category>api</category><body package="Polycephaly">do: aBlock	^self do: aBlock withArguments: #()</body><body package="Polycephaly">do: action environment: environment	"Execute @action on a virtual machine. The @action may be a string of Smalltalk code, or a Clean block."	| id priority semaphore response |	((action isKindOf: BlockClosure) not or: [action isClean]) ifFalse: [self error: 'A block must be clean'].	id := Processor activeProcess identityHash.	priority := Processor activeProcess priority.	semaphore := Semaphore new.	processes at: id put: semaphore.	output writeWhile: [:stream |		self log: '#doit stream id: ', id printString.		stream nextPut: id.		self log: '#doit priority: ', priority printString.		stream nextPut: priority.		self log: '#doit stream executable'.		stream nextPut: action.		self log: '#doit stream environment'.		stream nextPut: environment].	self log: '#doit wait'.	[semaphore wait] ifCurtailed: [processes removeKey: id. self terminate: id].	response := processes removeKey: id.	response isException ifTrue: [^response raiseSignal].	^response</body><body package="Polycephaly">do: aBlock with: aObject	^self do: aBlock environment: (Array with: aObject)</body><body package="Polycephaly">do: aBlock with: aObject with: bObject	^self do: aBlock environment: (Array with: aObject with: bObject)</body><body package="Polycephaly">do: aBlock with: aObject with: bObject with: cObject	^self do: aBlock environment: (Array with: aObject with: bObject with: cObject)</body><body package="Polycephaly">do: aBlock withArguments: arguments	^self do: aBlock environment: arguments</body><body package="Polycephaly">timeout: milliseconds do: aBlock	| execution timeout finished result timedout |	finished := Semaphore new.	timedout := false.	execution :=		[result := aBlock value.		timeout terminate.		finished signal] newProcess.	timeout :=		[(Delay forMilliseconds: milliseconds) wait.		execution terminate.		timedout := true.		finished signal] newProcess.	execution resume.	timeout resume.	finished wait.	timedout ifTrue: [TimeoutExceeded new raiseSignal].	^result</body></methods><methods><class-id>Polycephaly.VirtualMachine</class-id> <category>accessing</category><body package="Polycephaly">transcript	^transcript</body><body package="Polycephaly">transcript: anObject	transcript := anObject</body></methods><methods><class-id>Polycephaly.VirtualMachine</class-id> <category>private - logging</category><body package="Polycephaly">identity	^self identityHash</body><body package="Polycephaly">log: message	| stream |	stream := String new writeStream.	self identity printOn: stream paddedWith: $0 to: 8 base: 16.	stream nextPutAll: ' @ '.	Time millisecondClockValue printOn: stream paddedWith: $0 to: 12 base: 16.	stream tab.	stream nextPutAll: message.	stream cr.	self writeLog: stream contents</body><body package="Polycephaly">startLog	self writeLog: ''</body><body package="Polycephaly">writeLog: message	Logging ifFalse: [^self].	transcript nextPutAll: message</body></methods><methods><class-id>Polycephaly.VirtualMachine class</class-id> <category>instance creation</category><body package="Polycephaly">new	^super new initialize</body></methods><methods><class-id>Polycephaly.DebugMachine</class-id> <category>initialize-release</category><body package="Polycephaly">arguments	^#( 1 '-doit' 2 ) copy		replaceAll: 1 with: self image;		replaceAll: 2 with: 'Polycephaly.Drone new';		yourself</body></methods><methods><class-id>Polycephaly.Drone</class-id> <category>initialize-release</category><body package="Polycephaly">initialize	self initializeTranscript.	self startLog.	self log: '#initialize'.	processes := Dictionary new.	self initializeStreams.	self initializeListener</body><body package="Polycephaly">initializeListener	listener := [self listen] newProcess.	listener priority: ProcessorScheduler.UserInterruptPriority.	listener resume</body><body package="Polycephaly">initializeStreams	output := Pipe stdout.	input := Pipe stdin</body><body package="Polycephaly">initializeTranscript	Transcript dependents do: [:each | Transcript removeDependent: each. each release].	Transcript addDependent: DroneTranscript current</body><body package="Polycephaly">release	self log: '#release'.	super release.	ObjectMemory quit</body></methods><methods><class-id>Polycephaly.Drone</class-id> <category>private</category><body package="Polycephaly">actionBlockFromScript: script variables: variables	| environment |	environment := NameSpace new environment: Smalltalk.	environment imports: 'private Smalltalk.*'.	variables keysAndValuesDo: [:key :value |		environment simpleAddBinding: (VariableBinding key: key asSymbol value: value) forGeneral].	^[[Compiler new evaluate: script in: nil allowReceiver: false receiver: nil environment: environment notifying: nil ifFail: [:failure | self error: failure]]		on: SyntaxErrorException do: [:exception | exception originator: nil. exception]]</body><body package="Polycephaly">command: command id: id priority: priority arguments: arguments	command = #terminate ifTrue: [^self terminate: id].	^command isString		ifTrue:	[self do: (self actionBlockFromScript: command variables: arguments) id: id priority: priority arguments: #()]		ifFalse:	[self do: command id: id priority: priority arguments: arguments]</body><body package="Polycephaly">do: aBlock id: id priority: priority arguments: arguments	| process |	self log: 'do'.	process :=		[ | response |		response := [aBlock cullWithArguments: arguments] on: UnhandledException do: [:exception | exception parameter].		response isException ifTrue: [response clearForReraise].		processes removeKey: id.		output writeWhile: [:stream |			stream nextPut: id.			stream nextPut: response]]				newProcess.	process priority: priority.	processes at: id put: process.	process resume</body><body package="Polycephaly">listen	[	| id priority command arguments |		[input atEnd] whileFalse:			[input readWhile: [:stream | id := stream next. priority := stream next. command := stream next. arguments := stream next].			self command: command id: id priority: priority arguments: arguments]	] ensure: [self release]</body><body package="Polycephaly">terminate: id	self log: '#terminate: ', id printString.	(processes at: id ifAbsent: [^self]) terminate.	processes removeKey: id.	self log: '#terminated'</body></methods><methods><class-id>Polycephaly.Drone</class-id> <category>private - logging</category><body package="Polycephaly">identity	^OSHandle currentProcessID</body><body package="Polycephaly">log: message	| stream |	stream := String new writeStream.	self identity printOn: stream paddedWith: $0 to: 8 base: 16.	stream nextPutAll: ' @ '.	Time millisecondClockValue printOn: stream paddedWith: $0 to: 12 base: 16.	stream tab.	stream nextPutAll: message.	stream cr.	self writeLog: stream contents</body><body package="Polycephaly">startLog	self writeLog: ''</body><body package="Polycephaly">writeLog: message	Logging ifFalse: [^self].	Transcript nextPutAll: message</body></methods><methods><class-id>Polycephaly.Drone class</class-id> <category>instance creation</category><body package="Polycephaly">new	^super new initialize</body></methods><methods><class-id>Polycephaly.DroneTranscript</class-id> <category>private</category><body package="Polycephaly">appendEntry	[stream writeWhile: [:out | out nextPut: transcript nextEntry]] on: Error do: [:ex | ex return].</body></methods><methods><class-id>Polycephaly.DroneTranscript</class-id> <category>initialize-release</category><body package="Polycephaly">initialize	super initialize.	stream := Pipe stderr</body></methods><methods><class-id>Polycephaly.DroneTranscript class</class-id> <category>instance creation</category><body package="Polycephaly">current	current isNil ifTrue: [current := self new].	^current.</body></methods><methods><class-id>Polycephaly.VirtualMachines</class-id> <category>accessing</category><body package="Polycephaly">machines	^machines</body></methods><methods><class-id>Polycephaly.VirtualMachines</class-id> <category>initialize-release</category><body package="Polycephaly">initialize: someMachines	machines := someMachines</body><body package="Polycephaly">release	machines do: [:machine | machine release].	super release</body></methods><methods><class-id>Polycephaly.VirtualMachines</class-id> <category>api</category><body package="Polycephaly">do: action	^self do: action environments: ((1 to: machines size) collect: [:each |		action isString			ifTrue: [Dictionary new]			ifFalse: [#()]])</body><body package="Polycephaly">do: action environments: environments	| semaphore results |	environments size ~= machines size ifTrue: [machines noMatchError].	semaphore := Semaphore new.	results := Array new: machines size.	machines keysAndValuesDo: [:id :machine |		[ | environment |		environment := (environments at: id) copy.		environment isSequenceable			ifTrue:	[environment := environment, (Array with: id)]			ifFalse:	[environment at: #id put: id].		results at: id put: (machine do: action environment: environment).		semaphore signal] fork].	machines size timesRepeat: [semaphore wait].	^results</body><body package="Polycephaly">timeout: milliseconds do: aBlock	^machines first timeout: milliseconds do: aBlock</body></methods><methods><class-id>Polycephaly.VirtualMachines</class-id> <category>enumerating</category><body package="Polycephaly">first: count do: action	^self first: count do:action environments: ((1 to: machines size) collect: [:each |		action isString			ifTrue: [Dictionary new]			ifFalse: [#()]])</body><body package="Polycephaly">first: count do: action environments: environments	| semaphore results processes |	environments size ~= machines size ifTrue: [machines noMatchError].	semaphore := Semaphore new.	results := SharedQueue new.	processes := Array new: machines size.	machines keysAndValuesDo: [:id :machine |		processes at: id put:			[ | environment |			environment := (environments at: id) copy.			environment isSequenceable				ifTrue:	[environment := environment, (Array with: id)]				ifFalse:	[environment at: #id put: id].			results nextPut: machine -&gt; (machine do: action environment: environment).			semaphore signal] newProcess].	processes do: [:process | process resume].	count timesRepeat: [semaphore wait].	processes do: [:process | process terminate].	processes do: [:process | [process isTerminated] whileFalse: [Processor activeProcess yield]].	^(1 to: count) collect: [:each | results next]</body></methods><methods><class-id>Polycephaly.VirtualMachines class</class-id> <category>instance creation</category><body package="Polycephaly">new: anInteger	^self new initialize: ((1 to: anInteger) collect: [:each | VirtualMachine new])</body><body package="Polycephaly">newDebug: anInteger	^self new initialize: ((1 to: anInteger) collect: [:each | DebugMachine new])</body></methods><methods><class-id>Polycephaly.Pipe</class-id> <category>api</category><body package="Polycephaly">atEnd	bytes basicAtEnd ifTrue: [connection readWait].	^bytes atEnd</body><body package="Polycephaly">readWhile: aBlock	| result |	^semaphore critical:		[bytes basicAtEnd ifTrue: [connection readWait].		result := aBlock cull: objects.		objects initialize.		result]</body><body package="Polycephaly">writeWhile: aBlock	| result |	^semaphore critical:		[connection writeWait.		result := aBlock cull: objects.		objects initialize.		bytes commit.		result]</body></methods><methods><class-id>Polycephaly.Pipe</class-id> <category>accessing</category><body package="Polycephaly">bytes	^bytes</body><body package="Polycephaly">bytes: anObject	bytes := anObject</body><body package="Polycephaly">connection	^connection</body><body package="Polycephaly">connection: anObject	connection := anObject</body><body package="Polycephaly">objects	^objects</body><body package="Polycephaly">objects: anObject	objects := anObject</body></methods><methods><class-id>Polycephaly.Pipe</class-id> <category>initialize-release</category><body package="Polycephaly">initialize	semaphore := Semaphore forMutualExclusion</body></methods><methods><class-id>Polycephaly.Pipe class</class-id> <category>instance creation</category><body package="Polycephaly">new	^super new initialize</body><body package="Polycephaly">newInputStream: stream	^self new		connection: stream connection input;		bytes: stream;		objects: (BinaryObjectStorage onOldNoScan: stream binary);		yourself</body><body package="Polycephaly">newOutputStream: stream	^self new		connection: stream connection output;		bytes: stream;		objects: (BinaryObjectStorage onNew: stream binary);		writeWhile: [];		yourself</body><body package="Polycephaly">stderr	^self new		connection: (StandardIOSubsystem current standardHandles at: 3) ioConnection output;		bytes: Stderr;		objects: (BinaryObjectStorage onNew: Stderr);		writeWhile: [];		yourself</body><body package="Polycephaly">stdin	^self new		connection: (StandardIOSubsystem current standardHandles at: 2) ioConnection input;		bytes: Stdin;		objects: (BinaryObjectStorage onOldNoScan: Stdin);		yourself</body><body package="Polycephaly">stdout	^self new		connection: (StandardIOSubsystem current standardHandles at: 1) ioConnection output;		bytes: Stdout;		objects: (BinaryObjectStorage onNew: Stdout);		writeWhile: [];		yourself</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="Polycephaly">isException	^false</body></methods><methods><class-id>Core.GenericException</class-id> <category>private</category><body package="Polycephaly">clearForReraise"This is to get the exception instance ready for transport to the client side and reraise it in the calling thread.  The method 'copyForReraise' doesn't seem to be good enough to support user defined exception parameters.  Moreover, it seems to make sense to make the exception nonresumable, when raised in the client thread."	messageText := self description.	initialContext := nil.	firstUnwindContext := nil.	handlerContext := nil.	proceedBlock := nil.	isResumable := false.	signal := nil.	searchContext := nil</body></methods><methods><class-id>Core.GenericException</class-id> <category>testing</category><body package="Polycephaly">isException	^true</body></methods><methods><class-id>OS.StandardIOStream</class-id> <category>accessing</category><body package="Polycephaly">basicAtEnd	^self lockWhile: [stream basicAtEnd]</body><body package="Polycephaly">connection	^self lockWhile: [stream ioConnection]</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>GenericException</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>messageText originator initialContext firstUnwindContext handlerContext parameter proceedBlock isResumable signal searchContext </inst-vars><class-inst-vars>notifierString </class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>StandardIOStream</name><environment>OS</environment><super>Core.Stream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream mutex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Standard I/O Streams</category><attributes><package>Standard IO Streams</package></attributes></class><class><name>AbstractStreamTranscript</name><environment>OS</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream transcript </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Headless-Support</category><attributes><package>Headless</package></attributes></class></st-source>