<?xml version="1.0"?><st-source><!-- Name: MatriXNotice: Copyright 1999-2017 Cincom Systems, Inc.  All rights reserved.Comment: This package provides a mechanism for distributing work over a grid of virtual machines, networked or locally running. This is primarily useful when attempting to utilize hosts of multi-core CPUs or to distribute work over a network of computers with unused resources. Images can be pre-configured on a host to listen for connections from a "Master" and therefore act as "Drone", processing actions sent to them from the master. Images can also be pre-configured to connect automatically to a master image. For utilizing multi-core CPUs, drone images can be spawned in a new virtual machine OS process.Communication between master and drone is multiplexed; each smalltalk process on the master is a smalltalk process on the drone. Terminating the process on the master will terminate it on the drone, so long as the drone has enough CPU time to evaluate the terminate request. Objects are marshaled between the master and drone as copies, not as references. For large batch processing jobs, it is often useful to have the drone fetch data on its own to process, rather than having the master provide it; then having the drone respond to the master with a status report on how things went.The simplest approach is to spawn a local copy of the current image. Make sure you save your image before proceeding so that MatriX is pre-installed:{{{	[:machine | [ machine do: '3 + 4' ] ensure: [ machine release ] ] value: VirtualMachine new}}}Strings are useful for quick scripting, but you can also pass alone "clean" block closures. A block closure cannot be attached to an outerScope in a running Process. This happens if the block includes a return, eg: [^5] or if you are stepping through it in the debugger, which attach the outerScope for debugging purposes.{{{	| machine |	machine := VirtualMachine new.	[	machine do: [3 + 4]	] ensure: [ machine release ].}}}Objects can be passed to the drone as arguments for processing, which can make the block more 'generic' for a given data set:{{{	| machine |	machine := VirtualMachine new.	[	machine do: [ :a :b | a + b ] with: 3 with: 4.	] ensure: [ machine release ].}}}Objects can also be streamed to the drone as arguments for processing and the result from the drone may also be a stream. In this example, we stream in odd numbers and the drone streams back even numbers:{{{	| machine evens |	machine := VirtualMachine new.	[ evens := machine do: [ :odds | odds collecting: [ :each | each + 1 ] ] with: (1 to: 9 by: 2) reading.	  evens rest ] ensure: [ machine release ].}}}Large binary or character streams can also be returned from the drone and sent in an optimal manner:{{{	| machine objectComment |	machine := VirtualMachine new.	[ objectComment := (machine do: [ Object comment reading ]) rest.	  'copyOfImage.im' asFilename writing		write: (machine do: [ ObjectMemory imageFilename reading ]);		close.	] ensure: [ machine release ].}}}VirtualMachine is used for one-to-one communication between a master and a drone, but drones can also be part of a grid. A grid of VirtualMachine is called VirtualMachines. An action can be performed over a set of inputs across the grid of machines. There are a few configurations for this; the first is to create a collection of locally spawned images:{{{	| machines |	machines := VirtualMachines new: 3.	[ machines do: [ :a :b | a + b ] with: #(1 2 3 4 5) with: #(5 4 3 2 1)	] ensure: [ machines release ].}}}An array of actions can also be used, instead of or with an array of arguments:{{{	| machines |	machines := VirtualMachines new: 3.	[ machines do: (Array with: [1] with: [2] with: [3])	] ensure: [ machines release ].}}}{{{	| machines |	machines := VirtualMachines new: 3.	[ machines do: (Array with: [:x | x + 1] with: [:x | x + 2] with: [:x | x + 3]) with: #(3 2 1)	] ensure: [ machines release ].}}}Another variation is for a drone image to be pre-configured to listen for connections from master images. In this case, multiple masters can share a drone, which may have some specific domain code on it that only it can answer. This is commonly seen when communicating through a specific drone which has a particular kind of database access that it performs extra security on.Topologically this looks like:{{{	Master \	Master - -  Drone	Master /	...}}}{{{	"I am the drone image"	Drone listenOnPort: 10101.	"I am the master image"	VirtualMachine connectTo: 'localhost' port: 10101.	"I am a master connection to a horde of nodes"	VirtualMachines addresses: ( (10101 to: 10111) collect: [ :port | SocketAddress hostName: 'localhost' port: port ] ).}}}Some grid configurations are done in the opposite direction, where a controlling master image is expected to be up as drones come and go for added/removed extra processing power.The topology of this configuration is:{{{	Drone \	Drone - -  Master	Drone /	...}}}{{{	"I am the master image"	VirtualMachines listenOnPort: 10101.	"I am the drone image"	Drone connectTo: 'localhost' port: 10101.}}}A grid can also be used to race all the drones to find a result the quickest. A scenario like this might be to search for a result from multiple databases simultaneously; where you only care about the first, or perhaps first three results and the rest don't matter after that. VirtualMachines can be used in this manner, cancelling all processes once the first 'n' results are found:{{{	VirtualMachines first: 1 do: [ :searchEngine | searchEngine whereIs: 'Wally' ] with: (Array with: googleEngine with: yahooEngine with: msnEngine)}}}Exceptions are handled in headless images by transmitting the exception back to the master and re-raising it. This can be awkward to deal with when using a grid of drones. Also, you cannot debug it because the stack doesn't exist on the master. Running the drone in headful mode allows you to debug/edit/continue in each drone as desired. If the drone is remote and has its own GUI it may run in headful mode too. However, sometimes you want a gentler fail-over to allow you to re-try data sets that were errornous or perhaps failed due to a volatile resource not being available at the time of execution. The most common way to do this is to capture exceptions and return them with your data set:{{{	| machines results failures |	machines := VirtualMachines new: 3.	[ results := machines do: [ [ :x | x + 1 ] on: UnhandledException do: [ :exception | exception parameter ] ] with: #(1 2 '3').	  failures := results select: [ :each | each isKindOf: Exception ]	] ensure: [ machines release ]}}}Machines within a VirtualMachines grid are round-robin'd to perform their operations. If two different smalltalk processes are re-using the same VirtualMachines grid, they will block on each other, attempting to acquire individual virtual machines as soon as they can, creating a load balancing effect. This can make a grid convenient for dolling out random off-hand work with a Promise as the return value.You can acquire an individual machine temporarily from the grid as follows:{{{	| machines |	machines := VirtualMachines new: 3.	[ result := machines any: [ :machine | machine do: '3 + 4' ].	] ensure: [ machines release ]}}}Once you have the machine instance inside #any: you can send it any of the regular VirtualMachine API, eg: #do:with:with:. You can use this technique with promise too, eg:{{{	| machines promiseA promiseB promise C promiseD |	machines := VirtualMachines new: 3.	[ promiseA := [ machines any: [ :machine | machine do: '3 + 4' ] ] promise.	  promiseB := [ machines any: [ :machine | machine do: '3 + 4' ] ] promise.	  promiseC := [ machines any: [ :machine | machine do: '3 + 4' ] ] promise.	  promiseD := [ machines any: [ :machine | machine do: '3 + 4' ] ] promise.	] ensure: [ machines release ].	promiseA value.	promiseB value.	promiseC value.	promiseD value}}}If you don't need to pass any arguments to the individual machine, the #promise: method can be a quick convenient sugar:{{{	| machines |	machines := VirtualMachines new: 3.	[ promise := machines promise: '3 + 4'.	] ensure: [ machines release ]}}}You should not #release an individual virtual machine from within an #any: block; it must be firsted removed from the grid, which can be done using #removeMachine:.{{{	| machines machine |	machines := VirtualMachines withAll: (machine := VirtualMachine new).	[ machines promise: '3 + 4'	  machines removeMachine: machine.	] ensure: [ machines release ]}}}	=== Compatibility with Polycephaly ===MatriX is a direct descendant of Polycephaly, however there are some key differences between the two frameworks. Under the hood, Polycephaly used BOSS to marshal objects, while MatriX uses the Xtreams ObjectMarshaler. These two marshalers may handle object edge cases differently.Polycephaly used pipes to communicate with local images, while MatriX uses sockets. On unix, these are domain sockets, which should be secure - but on Windows they may be TCP sockets, which may NOT be secure.VirtualMachines is a complete behavioral rewrite. It is now used primarily as a way of grouping and load balancing operations between machines. If you wish to perform the same operation on a set of machines, consider actually using a Set or Array instead of a VirtualMachines instance.The following APIs were removed:	#timeout:do:	#do:environment:DbIdentifier: bear73DbTrace: 498703DbUsername: willowDbVersion: 8.3 - 1DevelopmentPrerequisites: #(#(#any 'Xtreams-Support' '') #(#any 'Xtreams-Core' '') #(#any 'Xtreams-Terminals' '') #(#any 'Xtreams-Transforms' '') #(#any 'Xtreams-Multiplexing' ''))PackageName: MatriXParcel: #('MatriX')PrerequisiteDescriptions: #(#(#name 'Xtreams-Support' #componentType #package) #(#name 'Xtreams-Core' #componentType #package) #(#name 'Xtreams-Terminals' #componentType #package) #(#name 'Xtreams-Transforms' #componentType #package) #(#name 'Xtreams-Multiplexing' #componentType #package))PrerequisiteParcels: #(#('Xtreams-Support' '') #('Xtreams-Core' '') #('Xtreams-Terminals' '') #('Xtreams-Transforms' '') #('Xtreams-Multiplexing' ''))PrintStringCache: (8.3 - 1,willow)Version: 8.3 - 1Date: 1:29:34 PM March 3, 2017 --><time-stamp>From VisualWorks®, Pre-Release 8.3 (mar17.1) of March 3, 2017 on March 3, 2017 at 1:29:34 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>MatriX</name><environment>Smalltalk</environment><private>false</private><imports>			private Core.*			private Xtreams.*			</imports><category></category><attributes><package>MatriX</package></attributes></name-space><class><name>VirtualMachines</name><environment>MatriX</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>machines closeBlock machinesLock work workLock workReady </inst-vars><class-inst-vars></class-inst-vars><imports>			OS.*			</imports><category></category><attributes><package>MatriX</package></attributes></class><comment><class-id>MatriX.VirtualMachines</class-id><body>I represent and control a grid of VirtualMachine, which can be sourced from the local machine, or on the network or can even be built up as drones connect in to the an instance of self. I can run a single command with a queue of parameters across the available machines, utilizing them as they become available, or I can run a queue of commands with a queue of parameters across the available machines. I can also race machines to find an answer, using the #first:... API.Instance Variables	closeBlock	&lt;BlockClosure&gt;				runs when the drone is sent #release. Used for cleaning up socket listeners	machines	&lt;Array of: VirtualMachines&gt; 	a collection of streams to distribute work to	machinesMutex	&lt;Semaphore&gt;			locks changing the available machines to distribute work on</body></comment><class><name>Drone</name><environment>MatriX</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>marshaler multiplexer processes processesMutex allowShutdown logger </inst-vars><class-inst-vars></class-inst-vars><imports>			Xtreams.VirtualMachine.*			</imports><category></category><attributes><package>MatriX</package></attributes></class><comment><class-id>MatriX.Drone</class-id><body>Drone acts as a 'mindless' node in a grid of virtual machines, controlled by a master or master images. It receives block closures from the master which it runs in a separate forked process. Each process has an identity from the master, allowing the master to terminate a running process on the drone image.Instance Variables	allowShutdown	&lt;Boolean&gt;	if the drone is running solely for one master, the master my shut this image down	logger	&lt;Xtreams.WriteStream&gt;	a write stream to record protocol communications on	marshaler	&lt;Xtreams.ObjectMarshaler&gt;	an object marshaler in sync with the master's copy	multiplexer	&lt;Xtreams.Multiplexer&gt;	the multiplexer all communications are coordinated through with the master	processes	&lt;Dictionary&gt;		all active forked processes currently running	processesMutex	&lt;Semaphore&gt;	a mutex to avoid process contention when starting/terminating processes</body></comment><class><name>VirtualMachine</name><environment>MatriX</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>marshaler multiplexer closeBlock commandMutex transcriptProcess transcript logger socket </inst-vars><class-inst-vars></class-inst-vars><imports>			Kernel.*			OS.*			</imports><category></category><attributes><package>MatriX</package></attributes></class><comment><class-id>MatriX.VirtualMachine</class-id><body>I represent and control another virtual machine running another smalltalk image (a drone) executing in its own OS process. I can send actions to the drone and wait for the result (or error) to be reported back (see the #do:... methods). The drone is connected to me through a domain or tcp socket. Drones can be pre-existing, listening for connections, or can be created on the local machine either as a clone of the running image or of another pre-built image.Instance Variables	marshaler	&lt;Process&gt; an object marshaler in sync with the drone's copy	multiplexer	&lt;Xtreams.Multiplexer&gt; the multiplexer all communications are coordinated through with the drone	closeBlock	&lt;BlockClosure&gt; runs when the drone is sent #release. Used for cleaning up socket listeners or external processes	commandMutex	&lt;Semaphore&gt; ensures only one command is changing the number of multiplexers at any one time	transcriptProcess	&lt;Process&gt; a process listening for transcript communications from the drone	transcript	&lt;Xtreams.WriteStream&gt; a stream to write out all transcript communications from the drone	logger	&lt;Xtreams.WriteStream&gt; a stream to record all protocol communications on	socket	&lt;SocketAccessor&gt; underlying communication socketShared Variables	BinaryStreamContent	&lt;Integer&gt; the protocol response of a stream of bytes	CharacterStreamContent	&lt;Integer&gt; the protocol response of a stream of characters, encoded in UTF8	DefaultMarshaler	&lt;Object&gt; undocumented	ExceptionContent	&lt;Integer&gt; the protocol response indicating an exception was raised executing a command on the drone	ForkCommand	&lt;Integer&gt; the protocol command to initiate a new process on the drone	ObjectContent	&lt;Integer&gt; the protocol response of a single object	ObjectStreamContent	&lt;Integer&gt; the protocol response of a stream of objects	ProtocolVersion	&lt;Integer&gt; the protocol version to communicate with, must match the drones version	ShutdownCommand	&lt;Integer&gt; the protocol command to shutdown/quit a drone	TerminateCommand	&lt;Integer&gt; the protocol command to terminate a running process on the drone</body></comment><class><name>DroneTranscript</name><environment>MatriX</environment><super>OS.AbstractStreamTranscript</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>MatriX</package></attributes></class><comment><class-id>MatriX.DroneTranscript</class-id><body>Emits entries to the Transcript back to a drone's master.</body></comment><shared-variable><name>ObjectContent</name><environment>MatriX.VirtualMachine</environment><private>false</private><constant>false</constant><category>protocol - contents</category><attributes><package>MatriX</package></attributes></shared-variable><shared-variable><name>ExceptionContent</name><environment>MatriX.VirtualMachine</environment><private>false</private><constant>false</constant><category>protocol - contents</category><attributes><package>MatriX</package></attributes></shared-variable><shared-variable><name>ProtocolVersion</name><environment>MatriX.VirtualMachine</environment><private>false</private><constant>false</constant><category>protocol - version</category><attributes><package>MatriX</package></attributes></shared-variable><shared-variable><name>ForkCommand</name><environment>MatriX.VirtualMachine</environment><private>false</private><constant>false</constant><category>protocol - commands</category><attributes><package>MatriX</package></attributes></shared-variable><shared-variable><name>BinaryStreamContent</name><environment>MatriX.VirtualMachine</environment><private>false</private><constant>false</constant><category>protocol - contents</category><attributes><package>MatriX</package></attributes></shared-variable><shared-variable><name>ObjectStreamContent</name><environment>MatriX.VirtualMachine</environment><private>false</private><constant>false</constant><category>protocol - contents</category><attributes><package>MatriX</package></attributes></shared-variable><shared-variable><name>TerminateCommand</name><environment>MatriX.VirtualMachine</environment><private>false</private><constant>false</constant><category>protocol - commands</category><attributes><package>MatriX</package></attributes></shared-variable><shared-variable><name>CharacterStreamContent</name><environment>MatriX.VirtualMachine</environment><private>false</private><constant>false</constant><category>protocol - contents</category><attributes><package>MatriX</package></attributes></shared-variable><shared-variable><name>ShutdownCommand</name><environment>MatriX.VirtualMachine</environment><private>false</private><constant>false</constant><category>protocol - commands</category><attributes><package>MatriX</package></attributes></shared-variable><shared-variable><name>DefaultMarshaler</name><environment>MatriX.VirtualMachine</environment><private>false</private><constant>false</constant><category>configuration</category><attributes><package>MatriX</package></attributes></shared-variable><methods><class-id>MatriX.VirtualMachines</class-id> <category>api</category><body package="MatriX">do: actions	"Perform a collection of actions across the receiver's grid collective. One command is given to a machine at a time, keeping as many machines busy as possible."	(actions isSequenceable and: [actions isCharacters not]) ifFalse: [		^(self do: 1 actions: (self actionsBlock: actions) arguments: [:i | #()]) first].	^self do: actions size actions: [:i | actions at: i] arguments: [:i | #()].</body><body package="MatriX">do: actions with: aObjects	"Perform a collection of actions across the receiver's grid collective. Actions can be either a collection of blocks or a single block, however aObjects must be a collection. If actions is a collection, it must be the same size as aObjects. One command is given to a machine at a time, keeping as many machines busy as possible."	^self do: aObjects size actions: (self actionsBlock: actions) arguments: [:i | Array with: (aObjects at: i)].</body><body package="MatriX">do: actions with: aObjects with: bObjects	"Perform a collection of actions across the receiver's grid collective. Actions can be either a collection of blocks or a single block, however aObjects and bObjects must be a collections of the same size. If actions is a collection, it must be the same size as aObjects and bObjects. One command is given to a machine at a time, keeping as many machines busy as possible."	^self do: aObjects size actions: (self actionsBlock: actions) arguments: [:i | Array with: (aObjects at: i) with: (bObjects at: i)].</body><body package="MatriX">do: actions with: aObjects with: bObjects with: cObjects	"Perform a collection of actions across the receiver's grid collective. Actions can be either a collection of blocks or a single block, however aObjects, bObjects and cObjects must be a collections of the same size. If actions is a collection, it must be the same size as aObjects, bObjects and cObjects. One command is given to a machine at a time, keeping as many machines busy as possible."	^self do: aObjects size actions: (self actionsBlock: actions) arguments: [:i | Array with: (aObjects at: i) with: (bObjects at: i) with: (cObjects at: i)].</body><body package="MatriX">do: actions withArguments: arguments	"Perform a collection of actions across the receiver's grid collective. Actions can be either a collection of blocks or a single block, however arguments must be a collections of the same size. If actions is a collection, it must be the same size as arguments. One command is given to a machine at a time, keeping as many machines busy as possible."	^self do: arguments size actions: (self actionsBlock: actions) arguments: [:i | arguments at: i]</body><body package="MatriX">promise: aBlock	"Execute aBlock (or String) on any virtual machine as a promise. If it's a string, compile it into a block."	^[self do: aBlock] promise</body></methods><methods><class-id>MatriX.VirtualMachines</class-id> <category>private</category><body package="MatriX">actionsBlock: actionOrActions	(actionOrActions isSequenceable and: [actionOrActions isCharacters not]) ifTrue: [^[:i | actionOrActions at: i]].	^[:i | actionOrActions]</body><body package="MatriX">do: numberOfJobs actions: actionsBlock arguments: argumentsBlock	| results exceptions workComplete |	numberOfJobs = 0 ifTrue: [^#()].	workComplete := Semaphore new.	exceptions := Dictionary new.	results := Array new: numberOfJobs.	workLock critical: [		1 to: numberOfJobs do: [:i |			work add:				(Array					with: (actionsBlock value: i)					with: (argumentsBlock value: i)					with: [:result |						results at: i put: result.						workComplete signal]					with: [:job :exception |						exceptions at: job put: exception.						workComplete signal])]].	numberOfJobs timesRepeat: [workReady signal].	numberOfJobs timesRepeat: [workComplete wait].	exceptions keysAndValuesDo: [:job :exception |		(job at: 3) value: exception copyForReraise raiseSignal].	^results</body><body package="MatriX">doJob: machine	"Do a job off the work queue on a machine"	| job |	"Fetch a job off the work queue"	job := nil.	workLock critical: [		work isEmpty ifFalse: [			job := work removeFirst]].	job == nil ifTrue: [^self].	"Perform the work on the machine."	[:action :arguments :output :exception |		[			| result |			result := machine do: action withArguments: arguments.			output value: result		] on: UnhandledException do: [:ex | exception value: job value: ex parameter]	] valueWithArguments: job</body><body package="MatriX">doWork: machine	"For a machine, in its own process, pull work from a work queue and idle if there is no work.	  If work is indicated by there is no work, that indicates that the machine is to be shutdown.	  Other processes may be waiting to know that this machine has finished its work, so signal	  machineLock."	| machineLock machineProcess machineInformation |	machineLock := Semaphore new.	machineInformation := Array		with: machine		with: machineLock		with: nil		with: true.	machineProcess := [		[	"Wait until there is work on the queue, then make sure the machine is still meant to be running."			[workReady wait.			machineInformation last] whileTrue: [self doJob: machine]		] ensure: [			"The machine has been asked to shut down"			machinesLock critical: [machines remove: machineInformation].			machine release.			machineLock signal].	] newProcess.	machineInformation at: 3 put: machineProcess.	machinesLock critical: [machines add: machineInformation].	machineProcess resume</body><body package="MatriX">first: numberOfResults do: numberOfJobs actions: actionsBlock arguments: argumentsBlock	| results resultsLock exceptions workComplete |	numberOfJobs = 0 ifTrue: [^#()].	numberOfResults = 0 ifTrue: [^#()].	workComplete := Semaphore new.	exceptions := Dictionary new.	results := OrderedCollection new: numberOfResults.	resultsLock := Semaphore forMutualExclusion.	workLock critical: [		1 to: numberOfJobs do: [:i |			work add:				(Array					with: (actionsBlock value: i)					with: (argumentsBlock value: i)					with: [:result |						resultsLock critical: [results add: result].						workComplete signal]					with: [:job :exception |						exceptions at: job put: exception.						workComplete signal])]].	numberOfJobs timesRepeat: [workReady signal].	numberOfResults timesRepeat: [workComplete wait].	"Cancel the remaining work we added."	workLock critical: [work := OrderedCollection new].	workReady initSignals.	exceptions keysAndValuesDo: [:job :exception |		(job at: 3) value: exception copyForReraise raiseSignal].	"In case we had a race condition where another machine gave us a result before we could cut off new results."	^results first: numberOfResults</body></methods><methods><class-id>MatriX.VirtualMachines</class-id> <category>accessing</category><body package="MatriX">addMachine: aVirtualMachine	"Add a machine to the receiver's grid collective."	self doWork: aVirtualMachine.	^aVirtualMachine</body><body package="MatriX">removeMachine: aVirtualMachine	"Remove a machine to the receiver's grid collective. If the machine is running a job, wait for it to finish so that the machine can safely be shut down if desired."	| locks |	locks := OrderedCollection.	machinesLock critical: [		machines do: [:machineInformation |			[:machine :machineLock :machineProcess :machineRunning |				machine == aVirtualMachine ifTrue: [					machineInformation at: 4 put: false.					locks add: machineLock]			] valueWithArguments: machineInformation].		machines size timesRepeat: [workReady signal]].	locks do: #wait.	^aVirtualMachine</body><body package="MatriX">removeMachineNoWait: aVirtualMachine	"Remove a machine to the receiver's grid collective. Do not wait for the machine to finish any job its running, but respond that it may still be running a job."	machinesLock critical: [		machines do: [:machineInformation |			[:machine :machineLock :machineProcess :machineRunning |				machine == aVirtualMachine ifTrue: [					machineInformation at: 4 put: false]			] valueWithArguments: machineInformation].		machines size timesRepeat: [workReady signal]].	^aVirtualMachine</body></methods><methods><class-id>MatriX.VirtualMachines</class-id> <category>initialize-release</category><body package="MatriX">initialize: someMachines onClose: aBlock	closeBlock := aBlock.	machinesLock := Semaphore forMutualExclusion.	machines := OrderedCollection new.	someMachines do: [:each | self doWork: each].	work := OrderedCollection new.	workLock := Semaphore forMutualExclusion.	workReady := Semaphore new</body><body package="MatriX">release	"To shut down, we must wait for all the work to be completed, otherwise other processes waiting on results will wait forever."	| locks |	"Ensure all running machines get a chance to notice the work queue is now empty and realise it should shut down."	machinesLock critical: [		machines do: [:each | each at: 4 put: false].		locks := machines collect: [:each | each at: 2]].	locks size timesRepeat: [workReady signal].	"Wait for all the machines to finish the work they're doing."	locks do: #wait.	closeBlock value.	super release</body><body package="MatriX">releaseNoWait	"Start the shut down but don't wait for it to finish. The machines will turn themselves off once all work is processed."	| numberOfMachines |	"Ensure all running machines get a chance to notice the work queue is now empty and realise it should shut down."	machinesLock critical: [		machines do: [:each | each at: 4 put: false].		numberOfMachines := machines size].	numberOfMachines timesRepeat: [workReady signal].	closeBlock value.	super release</body></methods><methods><class-id>MatriX.VirtualMachines</class-id> <category>enumerating</category><body package="MatriX">first: numberOfResults do: actions	"Perform a collection of actions across the receiver's grid collective. Stop all actions on all machines of the grid once the first numberOfResults has been found. You can use this to have a collection of machines 'race' to find a one or more results.	The first:* API cannot be used by multiple Smalltalk processes at a time, as once results are found the remaining work queue is cancelled for all processes. You cannot mix and match first:* with do:* API."	(actions isSequenceable and: [actions isCharacters not]) ifFalse: [		self error: 'If you want to run a single command with a single set of arguments, use #any to fetch a single virtual machine from the set.'].	^self first: numberOfResults do: actions size actions: [:i | actions at: i] arguments: [:i | #()].</body><body package="MatriX">first: numberOfResults do: actions with: aObjects	"Perform a collection of actions across the receiver's grid collective. Actions can be either a collection of blocks or a single block, however aObjects must be a collection. If actions is a collection, it must be the same size as aObjects. Stop all actions on all machines of the grid once the first numberOfResults has been found. You can use this to have a collection of machines 'race' to find a one or more results.	The first:* API cannot be used by multiple Smalltalk processes at a time, as once results are found the remaining work queue is cancelled for all processes. You cannot mix and match first:* with do:* API."	^self first: numberOfResults do: aObjects size actions: (self actionsBlock: actions) arguments: [:i | Array with: (aObjects at: i)].</body><body package="MatriX">first: numberOfResults do: actions with: aObjects with: bObjects	"Perform a collection of actions across the receiver's grid collective. Actions can be either a collection of blocks or a single block, however aObjects and bObjects must be a collection. If actions is a collection, it must be the same size as aObjects and bObjects. Stop all actions on all machines of the grid once the first numberOfResults has been found. You can use this to have a collection of machines 'race' to find a one or more results.	The first:* API cannot be used by multiple Smalltalk processes at a time, as once results are found the remaining work queue is cancelled for all processes. You cannot mix and match first:* with do:* API."	^self first: numberOfResults do: aObjects size actions: (self actionsBlock: actions) arguments: [:i | Array with: (aObjects at: i) with: (bObjects at: i)].</body><body package="MatriX">first: numberOfResults do: actions with: aObjects with: bObjects with: cObjects	"Perform a collection of actions across the receiver's grid collective. Actions can be either a collection of blocks or a single block, however aObjects, bObjects and cObjects must be a collection. If actions is a collection, it must be the same size as aObjects, bObjects and cObjects. Stop all actions on all machines of the grid once the first numberOfResults has been found. You can use this to have a collection of machines 'race' to find a one or more results.	The first:* API cannot be used by multiple Smalltalk processes at a time, as once results are found the remaining work queue is cancelled for all processes. You cannot mix and match first:* with do:* API."	^self first: numberOfResults do: aObjects size actions: (self actionsBlock: actions) arguments: [:i | Array with: (aObjects at: i) with: (bObjects at: i)].</body><body package="MatriX">first: numberOfResults do: actions withArguments: arguments	"Perform a collection of actions across the receiver's grid collective. Actions can be either a collection of blocks or a single block, however arguments must be a collections of the same size. If actions is a collection, it must be the same size as arguments. Stop all actions on all machines of the grid once the first numberOfResults has been found. You can use this to have a collection of machines 'race' to find a one or more results.	The first:* API cannot be used by multiple Smalltalk processes at a time, as once results are found the remaining work queue is cancelled for all processes. You cannot mix and match first:* with do:* API."	| actionsBlock |	actionsBlock := self actionsBlock: actions.	^self first: numberOfResults do: arguments size actions: actionsBlock arguments: [:i | arguments at: i]</body></methods><methods><class-id>MatriX.VirtualMachines class</class-id> <category>instance creation</category><body package="MatriX">addresses: anArray	"Create a VirtualMachines grid from anArray of SocketAddress's. Each destination expects to have a Drone already listening for a connection from the receiver."	^self withAll: (anArray collect: [:eachAddress | VirtualMachine address: eachAddress])</body><body package="MatriX">listenOnPort: portNumber	"Start listening for a connection from a Drone on a port given by portNumber. Any drones connecting in to this master will be added to this receiver instance's grid collective."	| socket address instance |	socket := SocketAccessor family: SocketAccessor AF_INET type: SocketAccessor SOCK_STREAM.	socket soReuseaddr: true.	address := IPSocketAddress hostAddress: IPSocketAddress thisHost port: portNumber.	[	socket bindTo: address; listenFor: 1	] ifCurtailed: [socket close].	instance := self basicNew initialize: #() onClose: [ socket close ].	[		[socket accepting do: [:connection | instance addMachine: (VirtualMachine socket: connection) ]]			on: OsError, Incomplete do: [:exception | ]	] fork.	^ instance</body><body package="MatriX">new	"Answer a VirtualMachines grid that contains no pre-configured drones. Add VirtualMachine instances with #addMachine: to make it usable."	^super new initialize: #() onClose: []</body><body package="MatriX">new: anInteger	"Create a VirtualMachines grid with anInteger's number of locally spawned VirtualMachine instances."	^self withAll: ((1 to: anInteger) collect: [:each | VirtualMachine new])</body><body package="MatriX">new: anInteger executable: aVM arguments: anArguments image: aFilename	"Create a VirtualMachines grid with anInteger's worth of new virtual machines (anExecutable) running a new image (anImage)."	^self withAll: ((1 to: anInteger) collect: [:each | VirtualMachine executable: aVM arguments: anArguments image: aFilename])</body><body package="MatriX">new: anInteger image: anImage	"Create a VirtualMachines grid with anInteger's worth of new virtual machines (the same virtual machine as this running image's virtual machine is used) running a new image (anImage)."	^self withAll: ((1 to: anInteger) collect: [:each | VirtualMachine image: anImage])</body><body package="MatriX">newDebug: anInteger	"Create a VirtualMachines grid with anInteger's number of locally spawned VirtualMachine instances running in headful mode for debugging."	^self withAll: ((1 to: anInteger) collect: [:each | VirtualMachine newDebug])</body><body package="MatriX">withAll: anArrayOfMachine	"Create a VirtualMachines grid from anArray of VirtualMachine's. Each VirtualMachine can have been created or configured uniquely, with different virtual machines, images, remotely or locally."	^self basicNew initialize: anArrayOfMachine onClose: []</body></methods><methods><class-id>MatriX.Drone</class-id> <category>initialize-release</category><body package="MatriX">allowShutdown	allowShutdown := true</body><body package="MatriX">initialize: aSocketAccessor	| transcript |	multiplexer := Multiplexer on: aSocketAccessor.	processes := Dictionary new.	processesMutex := Semaphore forMutualExclusion.		self negotiate.	self log: ['opening transcript channel'].	transcript := DroneTranscript new.	transcript stream: self getOutputChannel.	Transcript addDependent: transcript.	[		[[self process] repeat] on: OS.OsError, Incomplete do: [:exception | ]	] ensure: [Transcript removeDependent: transcript].	"If we've lost our stream, simulate being sent a shutdown command."	self processShutdown</body><body package="MatriX">logger: anObject	logger := anObject</body><body package="MatriX">negotiate	| input marshalerClass |	self log: ['receive protocol version'].	input := multiplexer getInputChannel.	self log: ['transmit protocol version: ', _.VirtualMachine.ProtocolVersion printString].	multiplexer getOutputChannel put: _.VirtualMachine.ProtocolVersion; close.	input get = _.VirtualMachine.ProtocolVersion ifFalse: [self error: 'Incompatible protocols'].	self log: ['receive marshaler class'].	marshalerClass := (multiplexer getInputChannel encoding: #utf8) rest.	self log: ['received marshaler class: ', marshalerClass].	marshaler := (marshalerClass asStrictReference valueOrDo: [self error: 'Unknown marshaler class ', marshalerClass]) new</body></methods><methods><class-id>MatriX.Drone</class-id> <category>private - receiving</category><body package="MatriX">process	| input command |	self log: ['opening command input channel'].	input := self getInputChannel.	command := input get.	command = _.VirtualMachine.ForkCommand ifTrue: [self processFork: input].	command = _.VirtualMachine.TerminateCommand ifTrue: [self processTerminate: input].	command = _.VirtualMachine.ShutdownCommand ifTrue: [self processShutdown]</body><body package="MatriX">processArgument	| input mode |	input := self getInputChannel.	mode := input get.	mode = _.VirtualMachine.ObjectContent ifTrue: [^input get].	mode = _.VirtualMachine.BinaryStreamContent ifTrue: [^input source].	mode = _.VirtualMachine.CharacterStreamContent ifTrue: [^input source encoding: #utf8].	^input</body><body package="MatriX">processFork: input	| id priority block arguments process output |	self log: ['receiving fork command'].	id := input get.	priority := input get.	block := input get.	self log: ['receiving fork aguments: ', block numArgs printString].	arguments := (1 to: block numArgs) collect: [:i | self processArgument].	self log: ['opening fork output channel'].	output := self getOutputChannel.	process := 			[			[| response isException |			isException := false.			"If the image is running headful, the usual intention is to debug on the drone, not the master, so don't capture exceptions, let them raise and be dealt with normally."			response := HeadlessImage isHeadless				ifTrue: [					[block cullWithArguments: arguments] on: UnhandledException						do: [:exception | isException := true. exception parameter] ]				ifFalse: [					block cullWithArguments: arguments].			isException				ifTrue: [self transmitException: response output: output]				ifFalse: [self transmitResponse: response output: output]]					ensure: [processesMutex critical: [processes removeKey: id]]]					newProcess.	process priority: priority.	processesMutex critical: [processes at: id put: process].	process resume</body><body package="MatriX">processShutdown	self log: ['received shutdown command'].	logger == nil ifFalse: [logger close].	allowShutdown = true ifTrue: [Kernel.ObjectMemory quit]</body><body package="MatriX">processTerminate: input	| id |	self log: ['receive terminate command'].	id := input get.	(processesMutex critical: [processes at: id ifAbsent: [nil]]) ifNotNil: #terminate</body></methods><methods><class-id>MatriX.Drone</class-id> <category>private</category><body package="MatriX">getInputChannel	^multiplexer getInputChannel marshaling: marshaler</body><body package="MatriX">getOutputChannel	^(multiplexer getOutputChannel buffering: Xtreams.Multiplexer.ChannelWindow) marshaling: marshaler</body><body package="MatriX">log: aMessage	| hash |	logger == nil ifTrue: [^self].	hash := String new writeStream.	self identityHash printOn: hash paddedWith: $0 to: 8 base: 16.	logger		cr; print: Time millisecondClockValue;		space; write: hash contents;		space; write: aMessage value</body></methods><methods><class-id>MatriX.Drone</class-id> <category>private - transmit</category><body package="MatriX">transmitException: anException output: output	self log: ['transmit exception: ', anException description].	anException clearForTransmission.	output		put: _.VirtualMachine.ExceptionContent;		put: anException;		close</body><body package="MatriX">transmitResponse: anObject output: output	| binary |	self log: ['transmit response: ', anObject printString].	(anObject isKindOf: Xtreams.ReadStream)		ifFalse: 			[^output				put: _.VirtualMachine.ObjectContent;				put: anObject;				close].	anObject contentsSpecies = ByteArray		ifTrue: 			[output put: _.VirtualMachine.BinaryStreamContent.			binary := output destination.			^[binary write: anObject] ensure: [binary close]].	(anObject contentsSpecies inheritsFrom: CharacterArray)		ifTrue: 			[output put: _.VirtualMachine.CharacterStreamContent.			binary := output destination encoding: #utf8.			^[binary write: anObject] ensure: [binary close]].	output put: _.VirtualMachine.ObjectStreamContent.	^[output write: anObject] ensure: [output close]</body></methods><methods><class-id>MatriX.Drone class</class-id> <category>instance creation</category><body package="MatriX">address: aSocketAddress	"Connect to a Master that is listening at aSocketAddress."	| connection |	connection := OS.SocketAccessor family: OS.SocketAccessor AF_INET type: OS.SocketAccessor SOCK_STREAM.	connection connectTo: aSocketAddress.	^self socket: connection</body><body package="MatriX">connectTo: aHost port: aPort	"Connect to a Master at aHost:aPort"	^self socket: (OS.SocketAccessor newTCPclientToHost: aHost port: aPort)</body><body package="MatriX">listenOnPort: portNumber	"Start listening for a connection from a master(s) on portNumber. Process commands transmitted on the connection,"	| socket address |	socket := OS.SocketAccessor family: OS.SocketAccessor AF_INET type: OS.SocketAccessor SOCK_STREAM.	socket soReuseaddr: true.	address := OS.IPSocketAddress hostAddress: OS.IPSocketAddress thisHost port: portNumber.	[	socket bindTo: address; listenFor: 1	] ifCurtailed: [socket close].	[socket accepting do: [:connection | [self socket: connection] fork]]		ensure: [socket close]</body><body package="MatriX">socket: aSocketAccessor	"Connect to a Master that is on the receiving end of aSocketAccessor."	^self basicNew initialize: aSocketAccessor</body></methods><methods><class-id>MatriX.VirtualMachine</class-id> <category>initialize-release</category><body package="MatriX">initialize: aSocketAccessor marshaler: aMarshalerClass onClose: aBlock	transcript := Transcript writing.	marshaler := aMarshalerClass new.	socket := aSocketAccessor.	self log: ['open multiplexer'].	multiplexer := Multiplexer on: socket.	closeBlock := aBlock.	commandMutex := Semaphore forMutualExclusion.	self negotiate.	self initializeTranscript</body><body package="MatriX">initializeTranscript	| input hash |	self log: ['receive transcript input channel'].	input := self getInputChannel.	hash := String new writeStream.	self identityHash printOn: hash paddedWith: $0 to: 8 base: 16.	hash := hash contents, ' '.	transcriptProcess := [		[			[transcript write: hash, input get] repeat.		] on: Incomplete, OsError do: [:exception | ].	] fork</body><body package="MatriX">logger: anObject	logger := anObject</body><body package="MatriX">negotiate	| input |	self log: ['transmit protocol version: ', ProtocolVersion printString].	multiplexer getOutputChannel put: ProtocolVersion; close.	self log: ['receive protocol version'].	input := multiplexer getInputChannel.	input get = ProtocolVersion ifFalse: [self error: 'Incompatible protocols'].	self log: ['transmit marshaler class: ', marshaler class absoluteName].	(multiplexer getOutputChannel encoding: #utf8)		write: marshaler class absoluteName;		close.</body><body package="MatriX">release	self log: ['terminate transcript channel'].	transcriptProcess == nil ifFalse: [transcriptProcess terminate].	self log: ['transmit shutdown'].	self transmitShutdown.	self log: ['close multiplexer'].	multiplexer close.	closeBlock value.	socket close.	super release</body><body package="MatriX">transcript: anObject	transcript := anObject</body></methods><methods><class-id>MatriX.VirtualMachine</class-id> <category>private</category><body package="MatriX">getInputChannel	^multiplexer getInputChannel marshaling: marshaler</body><body package="MatriX">getOutputChannel	^(multiplexer getOutputChannel buffering: Xtreams.Multiplexer.ChannelWindow) marshaling: marshaler</body><body package="MatriX">log2: aMessage	| hash |	logger == nil ifTrue: [^self].	hash := String new writeStream.	Processor activeProcess identityHash printOn: hash paddedWith: $0 to: 8 base: 16.	self log: [hash contents, ' ', aMessage value]</body><body package="MatriX">log: aMessage	| hash |	logger == nil ifTrue: [^self].	hash := String new writeStream.	self identityHash printOn: hash paddedWith: $0 to: 8 base: 16.	logger		cr; print: Time millisecondClockValue;		space; write: hash contents;		space; write: aMessage value</body></methods><methods><class-id>MatriX.VirtualMachine</class-id> <category>api</category><body package="MatriX">do: aBlockOrString	"Execute aBlock (or String) on a virtual machine. If it's a string, compile it into a block."	^self do: aBlockOrString withArguments: #()</body><body package="MatriX">do: aBlockOrString with: aObject	"Execute aBlock (or String) on a virtual machine with aObject argument to the block. If it's a string, compile it into a block."	^self do: aBlockOrString withArguments: (Array with: aObject)</body><body package="MatriX">do: aBlockOrString with: aObject with: bObject	"Execute aBlock (or String) on a virtual machine with aObject and bObject arguments to the block. If it's a string, compile it into a block."	^self do: aBlockOrString withArguments:(Array with: aObject with: bObject)</body><body package="MatriX">do: aBlockOrString with: aObject with: bObject with: cObject	"Execute aBlock (or String) on a virtual machine with aObject, bObject and cObject arguments to the block. If it's a string, compile it into a block."	^self do: aBlockOrString withArguments: (Array with: aObject with: bObject with: cObject)</body><body package="MatriX">do: aBlock withArguments: arguments	"Execute aBlock (or String) on a virtual machine with arguments to the block. If it's a string, compile it into a block."	| argumentProcesses input |	aBlock isString ifTrue: [		^aBlock first = $[			ifTrue: [self do: (Compiler evaluate: aBlock) withArguments: arguments]			ifFalse: [self do: (Compiler evaluate: '[', aBlock, ']') withArguments: arguments]].	aBlock outerContext isNil ifFalse: [self error: 'This block has a reference to the stack. This can sometimes happen when debugging or if the block has an inner return.'].	aBlock numArgs = arguments size ifFalse: [self error: ((#errBlockExprects &lt;&lt; #dialogs &gt;&gt; 'This block expects &lt;1p&gt; argument(s) but is invoked with &lt;2p&gt; argument(s)') expandMacrosWith: aBlock numArgs with: arguments size)].	commandMutex critical: [		self log2: ['transmit fork: ', aBlock printString].		self transmitFork: aBlock.		argumentProcesses := (arguments collect: [:each |			self log2: ['	transmit argument: ', each printString].			self transmitArgument: each]) select: #notNil.		self log2: ['receive fork input channel'].		input := self getInputChannel].	self log2: ['receive fork response'].	^[[self processResponse: input] ifCurtailed:		[self log2: ['transmit terminate'].		self transmitTerminate]]		ensure: [	argumentProcesses do: #terminate]</body></methods><methods><class-id>MatriX.VirtualMachine</class-id> <category>private - transmit</category><body package="MatriX">transmitArgument: anObject	| output binary |	output := self getOutputChannel.	(anObject isKindOf: Xtreams.ReadStream) ifFalse:		[output			put: ObjectContent;			put: anObject;			close.		^nil].	anObject contentsSpecies = ByteArray ifTrue:		[output put: BinaryStreamContent.		binary := output destination.		^[[binary write: anObject] ensure: [binary close]] fork].	(anObject contentsSpecies inheritsFrom: CharacterArray) ifTrue:		[output put: CharacterStreamContent.		binary := output destination encoding: #utf8.		^[[binary write: anObject] ensure: [binary close]] fork].	output put: ObjectStreamContent.	^[[output write: anObject] ensure: [output close]] fork</body><body package="MatriX">transmitFork: aBlock	self getOutputChannel		put: ForkCommand;		put: Processor activeProcess identityHash;		put: Processor activeProcess priority;		put: aBlock;		close</body><body package="MatriX">transmitShutdown	commandMutex critical:		[[self getOutputChannel			put: ShutdownCommand;			close] on: OsError, Incomplete do: [:exception | ]]</body><body package="MatriX">transmitTerminate	commandMutex critical:		[[self getOutputChannel			put: TerminateCommand;			put: Processor activeProcess identityHash;			close] on: OsError, Incomplete do: [:exception | ]]</body></methods><methods><class-id>MatriX.VirtualMachine</class-id> <category>private - receive</category><body package="MatriX">processResponse: input	| mode |	mode := input get.	mode = ObjectContent ifTrue: [self log: ['response is an object']. ^input get].	mode = BinaryStreamContent ifTrue: [self log: ['response is a binary stream']. ^input source].	mode = CharacterStreamContent ifTrue: [self log: ['response is a string stream']. ^input source encoding: #utf8].	mode = ExceptionContent ifTrue: [self log: ['response is an object stream']. ^input get raiseSignal].	^input</body></methods><methods><class-id>MatriX.VirtualMachine class</class-id> <category>instance creation</category><body package="MatriX">address: aSocketAddress	"Connect to a Drone that is listening at aSocketAddress."	| connection |	connection := SocketAccessor family: SocketAccessor AF_INET type: SocketAccessor SOCK_STREAM.	connection connectTo: aSocketAddress.	^self socket: connection</body><body package="MatriX">connectTo: aHost port: aPort	"Connect to a Drone at aHost:aPort"	^self socket: (SocketAccessor newTCPclientToHost: aHost port: aPort)</body><body package="MatriX">executable: anExecutable arguments: anArguments image: anImage	"Start a new virtual machine (anExecutable) running a new image (anImage) and establish a socket (domain socket if on unix) to it."	^self executable: anExecutable arguments: anArguments image: anImage marshaler: self defaultMarshaler</body><body package="MatriX">executable: anExecutable arguments: anArguments image: anImage doIt: aScript serverPort: portNum	"Start a new virtual machine (anExecutable) running a new image (anImage) and establish a socket (domain socket if on unix) to it."	| socket |	socket := SocketAccessor newTCPserverAtPort: portNum.	socket listenFor: 1.	^self		executable: anExecutable		arguments: anArguments		image: anImage		marshaler: self defaultMarshaler		doIt: aScript		socket: socket</body><body package="MatriX">executable: anExecutable arguments: anArguments image: anImage marshaler: aMarshalerClass	"Start a new virtual machine (anExecutable) running a new image (anImage) and establish a socket (domain socket if on unix) to it."	| socket |	socket := SocketAccessor newTCP.	socket listenFor: 1.	^self		executable: anExecutable		arguments: anArguments		image: anImage		marshaler: aMarshalerClass		doIt: (self droneScript: socket getName port)		socket: socket</body><body package="MatriX">executable: anExecutable arguments: anArguments image: anImage marshaler: aMarshalerClass doIt: doItScriptString socket: socket	"Start a new virtual machine (anExecutable) running a new image (anImage) and establish a socket (domain socket if on unix) to it."	| externalProcess arguments  connection instance started |	arguments := (Array with: anImage asString),		((anArguments includes: '-headful') ifTrue: [#()] ifFalse: [#('-headless')]),		anArguments,		(Array with: '-doit' with: doItScriptString).	instance := self basicNew.	started := Semaphore new.	externalProcess := [ | externalProgram |		externalProgram := ExternalProcess new.		[externalProgram fork: anExecutable arguments: arguments.		started wait.		instance release]			ifCurtailed: [ [externalProgram kill: 9] on: Error do: [:exception | ] ]] fork.	[connection := socket accept] ensure: [socket close].	started signal.	^instance initialize: connection marshaler: aMarshalerClass onClose: [externalProcess terminate]</body><body package="MatriX">image: anImage	"Start a new virtual machine (the same virtual machine as this running image's virtual machine is used) running a new image (anImage) and establish a socket (domain socket if on unix) to it."	^self		executable: self defaultExecutable		arguments: #()		image: anImage</body><body package="MatriX">new	"Start a new virtual machine (the same virtual machine as this running image's virtual machine is used) running a new image (the same image that was used to start this virtual machine is used) and establish a socket (domain socket if on unix) to it. Keep in mind that if you make changes to your code in your current image, you will need to first save your image to have a drone started this way pick those changes up."	^self		executable: self defaultExecutable		arguments: #()		image: self defaultImage</body><body package="MatriX">newDebug	"Start a new virtual machine (the same virtual machine as this running image's virtual machine is used) running a new image (the same image that was used to start this virtual machine is used) in headful mode, which is useful for debugging; establish a socket (domain socket if on unix) to it. Keep in mind that if you make changes to your code in your current image, you will need to first save your image to have a drone started this way pick those changes up."	^self		executable: self defaultExecutable		arguments: #('-headful')		image: self defaultImage</body><body package="MatriX">socket: aSocketAccessor	"Connect to a Drone that is on the receiving end of aSocketAccessor."	^self socket: aSocketAccessor marshaler: ObjectMarshaler</body><body package="MatriX">socket: aSocketAccessor marshaler: aMarshalerClass	"Connect to a Drone that is on the receiving end of aSocketAccessor."	^self basicNew initialize: aSocketAccessor marshaler: self defaultMarshaler onClose: []</body></methods><methods><class-id>MatriX.VirtualMachine class</class-id> <category>private</category><body package="MatriX">defaultArguments	"Drones by default run headless when started locally."	^#('-headless')</body><body package="MatriX">defaultExecutable	"Return the virtual machine used by the currently running virtual machine."	^CEnvironment commandLine first asFilename asAbsoluteFilename</body><body package="MatriX">defaultImage	"Return the Smalltalk image used to start the current virtual machine."	^ObjectMemory imageFilename asAbsoluteFilename</body><body package="MatriX">defaultMarshaler	^DefaultMarshaler</body><body package="MatriX">droneScript: aPort	"This script is run on a locally initiated drone. It will automatically load MatriX if MatriX is not already in the image. This assumes MatriX is available as a parcel if this execution path is taken. A drone is configured to shut down when the receiver instance is sent #release. Because we listen on and connect through localhost, security must be a consideration for any machine/site engineer."	^'[ | drone | [RuntimeSystem isActive] whileFalse: [5 milliseconds wait]. (Store.Registry packageNamed: ''MatriX'') ifNil: [Parcel loadParcelByName: ''MatriX'']. drone := MatriX.Drone basicNew. drone allowShutdown. drone initialize: (OS.SocketAccessor newTCPclientToHost: ''localhost'' port: ', aPort printString, ') ] fork.'</body></methods><methods><class-id>MatriX.VirtualMachine class</class-id> <category>class initialization</category><body package="MatriX">initialize	"self initialize"	DefaultMarshaler := ObjectMarshaler.	ProtocolVersion := 1.	ForkCommand := 0.	TerminateCommand := 1.	ShutdownCommand := 2.	ObjectContent := 0.	BinaryStreamContent := 1.	CharacterStreamContent := 2.	ObjectStreamContent := 3.	ExceptionContent := 4</body></methods><methods><class-id>MatriX.DroneTranscript</class-id> <category>private</category><body package="MatriX">appendEntry	[stream put: transcript nextEntry.	stream flush] on: Error do: [:ex | ex return].</body></methods><methods><class-id>Core.GenericException</class-id> <category>private</category><body package="MatriX">clearForTransmission"This is to get the exception instance ready for transport to the client side and reraise it in the calling thread.  The method 'copyForReraise' doesn't seem to be good enough to support user defined exception parameters.  Moreover, it seems to make sense to make the exception non-resumable, when raised in the client thread."	messageText := self description.	initialContext := nil.	firstUnwindContext := nil.	handlerContext := nil.	proceedBlock := nil.	isResumable := false.	signal := nil.	searchContext := nil.	originator := nil</body></methods><initialize><class-id>MatriX.VirtualMachine</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>GenericException</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>messageText originator initialContext firstUnwindContext handlerContext parameter proceedBlock isResumable signal searchContext </inst-vars><class-inst-vars>notifierString </class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>AbstractStreamTranscript</name><environment>OS</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream transcript </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Headless-Support</category><attributes><package>Headless</package></attributes></class></st-source>