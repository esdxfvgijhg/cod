<?xml version="1.0"?><st-source><!-- Name: SupraEXDINotice: Copyright © 2002 Cincom Systems, Inc.  All Rights Reserved.Comment: This parcel implements the EXDI database connection to Supra V2.DbIdentifier: bear73DbTrace: 56839DevelopmentPrerequisites: #(#(#any 'Database' '') #(#any 'DLLCC' ''))PackageName: SupraEXDIParcel: #('SupraEXDI')ParcelName: SupraEXDIPrerequisiteParcels: #(#('Database' ''))PrintStringCache: (7.4 - 13,smichael)Version: 7.4 - 13Date: 9:33:52 AM September 25, 2009 --><time-stamp>From VisualWorks®, Pre-Release 7.7 (sep09.4) of September 25, 2009 on September 25, 2009 at 9:33:52 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>SupraDatabaseException</name><environment>Database</environment><super>Database.ExternalDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SupraEXDI</category><attributes><package>SupraEXDI</package></attributes></class><comment><class-id>Database.SupraDatabaseException</class-id><body>SupraDatabaseException is raised in case of Supra database errors.</body></comment><class><name>CommandInactivityTimeout</name><environment>Database</environment><super>Database.SupraDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SupraEXDI</category><attributes><package>SupraEXDI</package></attributes></class><comment><class-id>Database.CommandInactivityTimeout</class-id><body>Exceptions from this class are raised when Supra error -700 or +700 occurs.CSWP0700 COMMAND INACTIVITY TIMEOUT (WORK ROLLED BACK)</body></comment><class><name>SupraDatabaseExceptionWithHack</name><environment>Database</environment><super>Database.SupraDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sqlString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SupraEXDI</category><attributes><package>SupraEXDI</package></attributes></class><comment><class-id>Database.SupraDatabaseExceptionWithHack</class-id><body>Exceptions from this class are raised when a Supra error occurs that needs a special handling.Instances of subclasses must be implement workarounds for Supra SQL restrictions.Instance Variables:	sqlString				&lt;String&gt;			original SQL statementSubclasses must implement the following messages:	hack-restricted sql		executeSQL:usingSession:	initialize-release		initializeOn:</body></comment><class><name>SupraDatabaseResumableException</name><environment>Database</environment><super>Database.SupraDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SupraEXDI</category><attributes><package>SupraEXDI</package></attributes></class><comment><class-id>Database.SupraDatabaseResumableException</class-id><body></body></comment><class><name>SupraConnection</name><environment>Database</environment><super>Database.ExternalDatabaseConnection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sqlcaHolder autocommit </inst-vars><class-inst-vars>signalMap </class-inst-vars><imports></imports><category>Database-Supra</category><attributes><package>SupraEXDI</package></attributes></class><comment><class-id>Database.SupraConnection</class-id><body>Class SupraConnectionis the concrete implementation of the Supra database connection through the Supra CallInterface.Instance Variables:	sqlcaHolder			&lt;SupraSqlcaHolder&gt;			holder for SupraSqlca SQLCA manager	autocommit			&lt;Boolean&gt;		indicates whether or not each request is automatically commited	Class Variables:	RegisteredSupraConnections		&lt;HandleRegistry&gt;			registry of active database connectionsClass Instance Variables:	signalMap			&lt;IdentityDictionary&gt;		maps database error codes to signals specific to Supra connections</body></comment><class><name>SupraTransaction</name><environment>Database</environment><super>Database.ExternalDatabaseTransaction</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Supra</category><attributes><package>SupraEXDI</package></attributes></class><comment><class-id>Database.SupraTransaction</class-id><body>Class SupraTransaction is the concrete implementation of the transaction concept for the EXDI Database Connect for Supra V2.The implementation is trivial.Instance Variables:	none</body></comment><class><name>ConnectionDown</name><environment>Database</environment><super>Database.SupraDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SupraEXDI</category><attributes><package>SupraEXDI</package></attributes></class><comment><class-id>Database.ConnectionDown</class-id><body>Exceptions from this class are raised when Supra error -807 occurs.CSWP0807 ERROR: CONNECTION DOWN</body></comment><class><name>SupraStatus</name><environment>Database</environment><super>Database.ExternalDatabaseError</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dbmsWarningCode affectedRows </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Supra</category><attributes><package>SupraEXDI</package></attributes></class><comment><class-id>Database.SupraStatus</class-id><body>Class SupraStatusextends ExternalDatabaseError to implement the complete result of an SQL request to the Supra CallInterface.This can be one of: &lt; #Success #Warning #Error &gt;Instances of this class capture the snapshot of relevant SQLCA details immediately following completion of the SQL command execution.  This information is held in the common area of the SQLCA.  Since the SQLCA might be immediately reused by another request (relying on its own connection-specific section of the context area), these details must be preserved so they are available to subsequent processing related to this request.Instance Variables:	dbmsWarningCode		&lt;Integer&gt;			the number of the SQLWARN(n) variable set in the SQLDA, if any	affectedRows			&lt;Integer&gt;			the number of rows which the Supra CallInterface reports affected by the SQL request		This is the number of rows inserted/deleted, or the size of the result set selected.		A value of (-1) indicates the count is unknown.		NOTE: The Supra CallInterface can only determine the number of rows in a result set if the SELECT instructs Supra to create an internal snapshot of the result set using the 'FOR REUSE' syntax.  See details in SupraSession for performance implications and enabling/disabling this syntax.</body></comment><class><name>SupraSqlcaHolder</name><environment>Database</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sqlcaHolder sqlcaSlotNumber dbNumber </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Supra</category><attributes><package>SupraEXDI</package></attributes></class><comment><class-id>Database.SupraSqlcaHolder</class-id><body>Class SupraSqlcaHolderimplements connection specific context for the Supra SQLCA.Each connection must know its relevant database connection number.Because we do not limit ourselves to a single SQLCA with its hard coded limit of 8 connections, each connection must also know its virtual slot number (relative to all currently allocated SQLCA's).Instance Variables:	sqlcaHolder			&lt;SupraSqlca&gt;			Supra SQLCA value holder	sqlcaSlotNumber	&lt;Integer&gt;			"virtual" database slot number		not limited to maximum of 8 hard-coded into the SQLCA, because we can		allocate multiple SQLCAs	dbNumber			&lt;Integer&gt;		physical database number, relative to the SQLCA in use for this connection	</body></comment><class><name>ServerNotRestarted</name><environment>Database</environment><super>Database.SupraDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SupraEXDI</category><attributes><package>SupraEXDI</package></attributes></class><comment><class-id>Database.ServerNotRestarted</class-id><body>Exceptions from this class are raised when Supra error -8000 occurs.CSWK8000 DATABASE SYSTEM MUST BE RESTARTED orCSWK8000 MESSAGE NOT AVAILABLE</body></comment><class><name>SupraBuffer</name><environment>Database</environment><super>Database.ExternalDatabaseBuffer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>getSelector setSelector null nullsPossible scale hostvarType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Supra</category><attributes><package>SupraEXDI</package></attributes></class><comment><class-id>Database.SupraBuffer</class-id><body>Class SupraBufferis the concrete implementation of a Supra host variable buffer.NOTE:DoubleByte support has not been implemented yet.This is primarily a Smalltalk issue -- Given the Supra implementation of DBYTE support, what Smalltalk class is appropriate for the application to use to manipulate data in the DBYTE format?Instance Variables:	getSelector		&lt;Symbol&gt;			the local selector for retrieving data from external memory	setSelector		&lt;Symbol&gt;			the local selector for storing data in external memory	null				&lt;Integer&gt;		null value indicator ( -1 indicates value is null )	nullsPossible	&lt;Boolean&gt;			indicates whether or not data in the buffer may be Null	scale			&lt;Integer&gt;			the number of fractional decimal digits (used for zoned decimal numbers)	hostvarType		&lt;Integer&gt;			the type of the host variable in the buffer  		(See Supra CallInterface documentation for additional information on application data types and usage considerations)Class Variables:	ClassToHostvarMap					&lt;IdentityDictionary&gt;			map the supported Smalltalk types to Supra host variable type codes	DefaultDoublePointerType			&lt;CPointerType&gt;			pointer type for double values	DefaultFixedSizeMap				&lt;IdentityDictionary&gt;			map the default sizes for fixed-size data types	DefaultUnsignedCharPointerType		&lt;CPointerType&gt;			pointer type for unsigned character values	HostvarToInternalDatatypeMap		&lt;IdentityDictionary&gt;			map the Supra host variable type codes to default Supra internal datatypes	InternalDatatypeToHostvarMap		&lt;IdentityDictionary&gt;			map the Supra internal datatypes to Supra host variable type codes</body></comment><class><name>TruncatedParameter</name><environment>Database</environment><super>Database.SupraDatabaseResumableException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SupraEXDI</category><attributes><package>SupraEXDI</package></attributes></class><comment><class-id>Database.TruncatedParameter</class-id><body></body></comment><class><name>SupraSession</name><environment>Database</environment><super>Database.ExternalDatabaseSession</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cursorName sqlType rowCount resultsCache paramDescriptions paramBuffersHolder preparedQuery sqlPointerHolder sqldaHolder parsidHolder preparedFetch fetchPointerHolder fetchSqldaHolder fetchParsidHolder maxLongBytes minSqlvarSize reUse </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Supra</category><attributes><package>SupraEXDI</package></attributes></class><comment><class-id>Database.SupraSession</class-id><body>Class SupraSessionis the concrete implementation of Supra Database Session behavior.This is roughly equivalent to an active Statement or an open Cursor.Instance Variables:	cursorName					&lt;String&gt;		internal name created for the cursor, used to transform a simple		SELECT into a DECLARE CURSOR statement	sqlType						&lt;Symbol&gt;		SQL statement (verb)		rowCount					&lt;Integer&gt;			number of rows affected by SQL request		[See SupraStatus for information on Supra implementation restrictions]	resultsCache				&lt;Array&gt;			the result from the most recent sqcExecute on a SQL query	paramDescriptions			&lt;IdentityDictionary&gt;		dictionary of SupraColumnDescription instances		describing the input host variables		paramBuffersHolder			&lt;ValueHolder&gt;			contains IdentityDictionary of SupraBuffer instances		describing external memory allocated for input host variables	preparedQuery				&lt;String&gt;		the expanded SQL request which is actually sent to Supra	sqlPointerHolder				&lt;CPointer&gt;			pointer to external memory which holds SQL String	sqldaHolder					&lt;CCompositePointer&gt;			pointer to external memory for the [command] SQLDA	parsidHolder				&lt;CPointer&gt;		pointer to external memory for the [command] PARSID	preparedFetch				&lt;String&gt;		constructed FETCH statement used to retrieve result set from SELECT	fetchPointerHolder			&lt;CPointer&gt;			pointer to external memory which holds FETCH String	fetchSqldaHolder			&lt;CCompositePointer&gt;			pointer to external memory for the [fetch] SQLDA	fetchParsidHolder			&lt;CPointer&gt;			pointer to external memory for the [fetch] PARSID	maxLongBytes				&lt;Integer&gt;			can be used for memory performance when the database contains		large CHAR fields, but the actual values are shorter	minSqlvarSize				&lt;Integer&gt;			can be used for memory performance to control the number of		SQLVAR structures in the SQLDA	reUse						&lt;Boolean&gt;		controls the use of 'FOR REUSE' syntax	Class Variables:	RegisteredSupraSessions		&lt;HandleRegistry&gt;		registry of active database sessions</body></comment><class><name>SupraInterface</name><environment>Database</environment><super>External.ExternalInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Database.SupraInterfaceDictionary.*			</imports><category>Database-External-Libraries-Supra</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>libsupra258rst.dll</item></libraryFiles><libraryDirectories><item>$(windir)\system32</item></libraryDirectories><beVirtual>true</beVirtual><optimizationLevel>full</optimizationLevel><package>SupraEXDI</package></attributes></class><comment><class-id>Database.SupraInterface</class-id><body>Class SupraInterfaceis the ExternalInterface to the Supra CallInterface API.This API is only available for Windows platforms.This was generated with DLLCC against pclibw32.dll (same library serves WIN95, WIN98 and NT)Instance Variables:	none</body></comment><class><name>SupraSqlca</name><environment>Database</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>index sqlcaPointer sqlcaSessions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Supra</category><attributes><package>SupraEXDI</package></attributes></class><comment><class-id>Database.SupraSqlca</class-id><body>Class SupraSqlcaimplements value holder behavior specifically for the Supra SQLCA.This class uses intimate knowledge of the _catype C structure defined in SupraInterface to provide accessors to fields of the SQLCA.  Supra internal tracing can be enabled on the class side (see class protocol tracing).  Instance Variables:	index				&lt;Integer&gt;			sequential number indicating order of allocation of the SQLCA		This value serves as the key in the HandleRegistry of instances.	sqlcaPointer		&lt;CCompositePointer&gt;			pointer to external memory allocated for the SQLCA structure	sqlcaSessions	&lt;ByteArray&gt;			in-use indicators for the multiple SQLCA Sessions (max = 8 per SQLCA)		0 = available, 1 = in-useClass Variables:	RegisteredSupraSqlcaList		&lt;HandleRegistry&gt;			registry of allocated SupraSqlca instances	SupraTraceLevel				&lt;Integer&gt;			trace level for Supra internal tracing		2 = TRACE (standard), 3 = TRACE_LONG (extended)</body></comment><class><name>SupraColumnDescription</name><environment>Database</environment><super>Database.ExternalDatabaseColumnDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>databaseType hostvarType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Supra</category><attributes><package>SupraEXDI</package></attributes></class><comment><class-id>Database.SupraColumnDescription</class-id><body>Class SupraColumnDescriptionis the concrete implementation of a Supra column descriptorInstance Variables:	databaseType	&lt;Integer&gt;			Supra internal database type code	hostvarType		&lt;Integer&gt;			Supra external host variable type codeClass Variables:	InternalDatatypeToClassMap		&lt;IdentityDictionary&gt;			map Supra internal database type code to Smalltalk class</body></comment><class><name>InvalidSelectTable</name><environment>Database</environment><super>Database.SupraDatabaseExceptionWithHack</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tableName resultName insertColumnNames selectColumnNames where </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SupraEXDI</category><attributes><package>SupraEXDI</package></attributes></class><comment><class-id>Database.InvalidSelectTable</class-id><body>Exceptions from this class are raised when Supra error -7025 occurs.CSWK7025 INSERT TABLE NAME NOT ALLOWED IN THE FROM LISTThis errors happens when StORE uses an unsupported form of the INSERT statement like	INSERT INTO tablename (colname, ...) SELECT colname, ... FROM tablename WHERE clausewhere the INSERT and the SELECT are for the same table.The exceptions from this class are caught by SupraBroker class&gt;&gt;process:bindInput:bindOutput:usingSession:The handling of such an exception is delegated to the exception itself and consists in inserting three SQL statements:	1. Execute the SELECT portion of the original statement making sure the result table is named and reusable.	2. Execute the INSERT portion of the original statement together with a SELECT on the named result table.	3. Execute a CLOSE for the named result table.Instance Variables:	insertColumnNames		&lt;Collection&gt;		column names from the INSERT portion of the original statement	resultName				&lt;String&gt;			generated name for the named result table	selectColumnNames	&lt;Collection&gt;		column names from the SELECT portion of the original statement	tableName				&lt;String&gt;			table name from the original statement	where					&lt;String&gt;			where clause from the original statement</body></comment><class><name>StatementTooComplicated</name><environment>Database</environment><super>Database.SupraDatabaseExceptionWithHack</super><private>false</private><indexed-type>none</indexed-type><inst-vars>baseSQLFragment columnName keys </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SupraEXDI</category><attributes><package>SupraEXDI</package></attributes></class><comment><class-id>Database.StatementTooComplicated</class-id><body>Exceptions from this class are raised when Supra error -1101 or -1103 occurs.CSWK1101 BUFFER AND/OR STACK OVERFLOW; COMMAND IS TOO COMPLICATEDCSWK1103 TOO COMPLICATED COMMAND (TOO MANY ARITHMETICS)This errors happens when StORE uses an unsupported form of the DELETE statement like	DELETE tablename WHERE keycolumn IN ( ... )where the IN specification contains too many values.The exceptions from this class are caught by SupraBroker class&gt;&gt;process:bindInput:bindOutput:usingSession:The handling of such an exception is delegated to the exception itself and consists in inserting one or more SQL statements:	1. DELETE statement with one or more BETWEEN specifications connected with OR	2. DELETE statement with one or more = specifications connected with ORInstance Variables:	baseSQLFragment	&lt;String&gt;		the beginning of the SQL statement including the WHERE keyword	columnName		&lt;String&gt;		the column name used in the WHERE clause	keys				&lt;Collection&gt;	key values</body></comment><class><name>FetchBufferIncompatible</name><environment>Database</environment><super>Database.SupraDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SupraEXDI</category><attributes><package>SupraEXDI</package></attributes></class><comment><class-id>Database.FetchBufferIncompatible</class-id><body></body></comment><class><name>SupraWin95Interface</name><environment>Database</environment><super>Database.SupraInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Database.SupraWin95InterfaceDictionary.*			</imports><category>Database-External-Libraries-Supra</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>libsupra258rst.dll</item></libraryFiles><libraryDirectories><item>$(windir)\system32</item></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>SupraEXDI</package></attributes></class><comment><class-id>Database.SupraWin95Interface</class-id><body>Class SupraWin95Interfaceis the Windows 95 version of the Supra ExternalInterface.It is currently a placeholder.Instance Variables:	none</body></comment><class><name>KeyUpdateNotAllowed</name><environment>Database</environment><super>Database.SupraDatabaseExceptionWithHack</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tableName updateColumnNames insertColumnNames where </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SupraEXDI</category><attributes><package>SupraEXDI</package></attributes></class><comment><class-id>Database.KeyUpdateNotAllowed</class-id><body>Exceptions from this class are raised when Supra error -7042 occurs.CSWK7042 KEY UPDATE NOT ALLOWEDThis errors happens when StORE uses an unsupported form of the UPDATE statement like	UPDATE tablename SET colname = value WHERE clausewhere the column identified by colname is part of the table primary key.The exceptions from this class are caught by SupraBroker class&gt;&gt;process:bindInput:bindOutput:usingSession:The handling of such an exception is delegated to the exception itself and consists in inserting two SQL statements:	1. Execute an INSERT using the values found in the where clause plus the value found in the SET clause	2. Execute a DELETE using the where clause unchangedInstance Variables:	insertColumnNames		&lt;Dictionary&gt;		column names and values used in the INSERT	tableName				&lt;String&gt;			table name from the original statement	updateColumnNames	&lt;Collection&gt;		column names and values from the original statement	where					&lt;String&gt;			where clause from the original statement</body></comment><class><name>SupraNTInterface</name><environment>Database</environment><super>Database.SupraInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Database.SupraNTInterfaceDictionary.*			</imports><category>Database-External-Libraries-Supra</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>libsupra258rst.dll</item></libraryFiles><libraryDirectories><item>$(windir)\system32</item></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>SupraEXDI</package></attributes></class><comment><class-id>Database.SupraNTInterface</class-id><body>Class SupraNTInterfaceis the Windows NT version of the Supra ExternalInterface.It is currently a placeholder.Instance Variables:	none</body></comment><shared-variable><name>InternalDatatypeToHostvarMap</name><environment>Database.SupraBuffer</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>SupraEXDI</package></attributes></shared-variable><shared-variable><name>DefaultDoublePointerType</name><environment>Database.SupraBuffer</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>SupraEXDI</package></attributes></shared-variable><shared-variable><name>ClassToHostvarMap</name><environment>Database.SupraBuffer</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>SupraEXDI</package></attributes></shared-variable><shared-variable><name>DefaultFixedSizeMap</name><environment>Database.SupraBuffer</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>SupraEXDI</package></attributes></shared-variable><shared-variable><name>DefaultUnsignedCharPointerType</name><environment>Database.SupraBuffer</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>SupraEXDI</package></attributes></shared-variable><shared-variable><name>RegisteredSupraConnections</name><environment>Database.SupraConnection</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>SupraEXDI</package></attributes></shared-variable><shared-variable><name>SupraTraceLevel</name><environment>Database.SupraSqlca</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>SupraEXDI</package></attributes></shared-variable><shared-variable><name>RegisteredSupraSqlcaList</name><environment>Database.SupraSqlca</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>SupraEXDI</package></attributes></shared-variable><shared-variable><name>SupraInterfaceDictionary</name><environment>Database</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>SupraEXDI</package></attributes></shared-variable><shared-variable><name>SupraNTInterfaceDictionary</name><environment>Database</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>SupraEXDI</package></attributes></shared-variable><shared-variable><name>SupraWin95InterfaceDictionary</name><environment>Database</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>SupraEXDI</package></attributes></shared-variable><shared-variable><name>WarningMessages</name><environment>Database.SupraStatus</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>SupraEXDI</package></attributes></shared-variable><shared-variable><name>WarningNotification</name><environment>Database.SupraStatus</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>SupraEXDI</package></attributes></shared-variable><shared-variable><name>RegisteredSupraSessions</name><environment>Database.SupraSession</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>SupraEXDI</package></attributes></shared-variable><shared-variable><name>InternalDatatypeToClassMap</name><environment>Database.SupraColumnDescription</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>SupraEXDI</package></attributes></shared-variable><methods><class-id>Database.SupraDatabaseException</class-id> <category>printing</category><body package="SupraEXDI" selector="defaultMessageText">defaultMessageText	^#errSupraDatabase &lt;&lt; #supraDB &gt;&gt; 'Supra Database Error'.</body></methods><methods><class-id>Database.CommandInactivityTimeout</class-id> <category>printing</category><body package="SupraEXDI" selector="defaultMessageText">defaultMessageText	^#commandInactivityTimeout &lt;&lt; #supraDB &gt;&gt; 'Command inactivity timeout.'.</body></methods><methods><class-id>Database.SupraDatabaseExceptionWithHack</class-id> <category>printing</category><body package="SupraEXDI" selector="defaultMessageText">defaultMessageText	^self subclassResponsibility.</body></methods><methods><class-id>Database.SupraDatabaseExceptionWithHack</class-id> <category>hack-restricted sql</category><body package="SupraEXDI" selector="retrySQL">retrySQL	"Answer an OrderedCollection containing the SQL statements necessary		to retry the initial request using syntax/semantics acceptable to SupraSQL.	 These will be executed in sequence, followed by a commit."	^ self subclassResponsibility.</body></methods><methods><class-id>Database.SupraDatabaseExceptionWithHack</class-id> <category>accessing</category><body package="SupraEXDI" selector="sqlString">sqlString	^sqlString</body><body package="SupraEXDI" selector="sqlString:">sqlString: aString	sqlString := aString.</body></methods><methods><class-id>Database.SupraDatabaseExceptionWithHack class</class-id> <category>signalling</category><body package="SupraEXDI" selector="signalWithSQLString:">signalWithSQLString: aString	"Raise an an exception with sqlString set to aString."	^self new 		searchFrom: thisContext sender;		originator: thisContext sender homeReceiver;		sqlString: aString;		raiseSignal.</body></methods><methods><class-id>Database.SupraDatabaseResumableException</class-id> <category>printing</category><body package="SupraEXDI" selector="defaultMessageText">defaultMessageText	^#errSupraInformation &lt;&lt; #supraDB &gt;&gt; 'Supra Database Information'.</body></methods><methods><class-id>Database.SupraDatabaseResumableException class</class-id> <category>testing</category><body package="SupraEXDI" selector="mayResume">mayResume	^true</body></methods><methods><class-id>Database.SupraConnection</class-id> <category>private-library calls</category><body package="SupraEXDI" selector="acquireExternal:">acquireExternal: aPassword 	"Acquire the external resources involved with a connection to the 	SQL-environment."	| name pw env xif cannotFindSupraLibrary uidPointer pwPointer envPointer connectString dbnoPointer stmlenPointer stmbufPointer status |	name := self username.	[name isString] 		whileFalse: [name := self class requiredUsernameSignal raiseRequest].	pw := aPassword.	[pw isString] 		whileFalse: [pw := self class requiredPasswordSignal raiseRequest].	(env := self environment) isNil 		ifTrue: [env := self class defaultEnvironment].	[env isString] 		whileFalse: [env := self class requiredEnvironmentSignal raiseRequest].	env := self class mapLogical: env.		["Begin unwind protection (level 1 -- allocation of sqlca)"	xif := self class xif.	self acquireSqlca.	cannotFindSupraLibrary := false.		["Begin unwind protection (level 2  -- allocation of connect parameters)"	connectString := self constructedConnectString.	dbnoPointer := self dbNumber asSmallInteger 				perform: xif copyToHeapSelector.	envPointer := env copyToHeap: xif mallocSelector encoding: self encoding.	stmlenPointer := connectString size asSmallInteger 				perform: xif copyToHeapSelector.	stmbufPointer := connectString copyToHeap: xif mallocSelector				encoding: self encoding.	uidPointer := name copyToHeap: xif mallocSelector encoding: self encoding.	pwPointer := pw copyToHeap: xif mallocSelector encoding: self encoding.		[status := self sqlcaDo: 					[xif 						sqcconnect: self sqlcaPointer						with: dbnoPointer						with: envPointer						with: stmlenPointer						with: stmbufPointer						with: uidPointer						with: pwPointer.					self sqlca setTraceParams]] 			on: self errorSignal			do: 				[:ex | 				cannotFindSupraLibrary := true.				ex return]	" any exception assumed to indicate library not available "	"End unwind protection (level 2  -- allocation of parameters)"] 			ensure: 				[dbnoPointer == nil ifFalse: [dbnoPointer freePointer].				envPointer == nil ifFalse: [envPointer freePointer].				stmlenPointer == nil ifFalse: [stmlenPointer freePointer].				stmbufPointer == nil ifFalse: [stmbufPointer freePointer].				uidPointer == nil ifFalse: [uidPointer freePointer].				pwPointer == nil ifFalse: [pwPointer freePointer]].	cannotFindSupraLibrary 		ifTrue: 			[" This error occurs when the Supra CallInterface DLL					cannot be found in the search path.					We catch it here, but once CONNECT succeeds,					we assume the library is loaded. "			^self class externalDatabaseLibraryInaccessibleSignal raise].	traceLevel &gt;= 2 		ifTrue: 			[(self traceStream)				nextPutAll: 'sqcconnect( sqlca=';				nextPutAll: (self sqlcaPointer referentAddress printStringRadix: 16);				nextPutAll: ', ';				print: env;				nextPutAll: ', dbno=[';				print: self dbNumber;				nextPutAll: ']';				nextPutAll: ', ';				print: name;				nextPutAll: ', ';				print: pw;				nextPutAll: ')';				crtab;				nextPutAll: 'status=';				print: status.			self class trace: self emitTrace].	status isError 		ifTrue: 			[| sig |			sig := self class signalMap at: status sqlCode abs						ifAbsent: [#unableToConnectToSQLserverSignal].			(self class perform: sig) raiseWith: (Array with: status)]	"End unwind protection (level 1 -- allocation of sqlca)"] 			ifCurtailed: [self releaseSqlca].	self singleStatementTransactions</body><body package="SupraEXDI" selector="autoCommit">autoCommit	self isAutocommit ifTrue: [		self commitExternal	]</body><body package="SupraEXDI" selector="beginExternal">beginExternal	"Mark the beginning of receiver's portion of a transaction."	super beginExternal.	self multiStatementTransactions</body><body package="SupraEXDI" selector="commitExternal">commitExternal	"Commit all changes made by receiver's connection."	|  status |	super commitExternal ifFalse: [ ^self ].	status := self sqcStatement: self commitString.	status isError ifTrue: [		^self class externalDatabaseTransactionErrorSignal raiseWith: (Array with: status) errorString: status dbmsErrorString ].	self singleStatementTransactions</body><body package="SupraEXDI" selector="dismissExternal">dismissExternal	"Release the external resources."	"All activity within this method must function with only the instance	variables defined in the executor object."	| dbnoPointer status |	(self sqlca isNil or: [self sqlcaPointer isNull]) ifTrue: [ ^self ].	[		dbnoPointer := self dbNumber asSmallInteger copyToHeap.		status := self sqlcaDo: [			self class xif sqcrelease: self sqlcaPointer						with: dbnoPointer			].		( traceLevel &gt;= 2 ) ifTrue: [			(self traceStream)					nextPutAll: 'sqcrelease( sqlca=';						nextPutAll: (self sqlcaPointer referentAddress printStringRadix: 16);					nextPutAll: ', dbno=['; print: self dbNumber; nextPutAll: '] )';					crtab;					nextPutAll: 'status='; print: status.			self class trace: self emitTrace			].	] 	ensure: [		dbnoPointer == nil ifFalse: [ dbnoPointer freePointer ].		self releaseSqlca		].	status isError ifTrue: [		"If sqcrelease failed for reasons other than database down, signal an exception."		status isDatabaseDown			ifFalse: 				[self class unableToDisconnectSignal raiseRequestWith: (Array with: status) ]].</body><body package="SupraEXDI" selector="installExternal">installExternal	"Perform return from snapshot processing for this connection."	super installExternal.	self sqlcaHolder initialize.	self autocommitOn.</body><body package="SupraEXDI" selector="multiStatementTransactions">multiStatementTransactions	"Disable the SupraConnection autocommit mode."	self autocommitOff</body><body package="SupraEXDI" selector="rollbackExternal">rollbackExternal	"Rollback all changes made by receiver's connection."	|  status |	super rollbackExternal ifFalse: [ ^self ].	status := self sqcStatement: self rollbackString.	status isError ifTrue: [		^self class externalDatabaseTransactionErrorSignal raiseWith: (Array with: status) errorString: status dbmsErrorString ].	self singleStatementTransactions.</body><body package="SupraEXDI" selector="singleStatementTransactions">singleStatementTransactions	"Put SupraConnection into autocommit mode to give the effect of single-statement transactions."	self autocommitOn</body><body package="SupraEXDI" selector="sqcStatement:">sqcStatement: sqlString	" Execute a single SQL Statement on the Connection.		Used for any statement that does not require PREPARE.		Used locally for COMMIT/ROLLBACK "	| xif dbnoPointer stmlenPointer stmbufPointer status |	xif := self class xif.	[ 		dbnoPointer := self dbNumber asSmallInteger copyToHeap.		stmlenPointer := sqlString size asSmallInteger copyToHeap.		stmbufPointer :=  sqlString copyToHeap: xif mallocSelector encoding: self encoding.		status := self sqlcaDo:	[				xif sqcstatement: self sqlcaPointer						with: dbnoPointer 						with: stmlenPointer 						with: stmbufPointer			]	] 	ensure: [		dbnoPointer == nil ifFalse: [ dbnoPointer freePointer ].		stmlenPointer == nil ifFalse: [ stmlenPointer freePointer ].		stmbufPointer == nil ifFalse: [ stmbufPointer freePointer ]		].	( traceLevel &gt;= 2 ) ifTrue: [		(self traceStream)			nextPutAll: 'sqcstatement( sqlca=';				nextPutAll: (self sqlcaPointer referentAddress printStringRadix: 16); 			nextPutAll: ', dbno=['; print: self dbNumber; nextPutAll: ']';			nextPutAll: ', stmlen='; print: sqlString size;			nextPutAll: ', stmbuf='; print: sqlString; nextPutAll: ')';			crtab;			nextPutAll: 'status='; print: status.		self class trace: self emitTrace		].	^status.</body></methods><methods><class-id>Database.SupraConnection</class-id> <category>private-accessing</category><body package="SupraEXDI" selector="autocommitOff">autocommitOff	autocommit := false</body><body package="SupraEXDI" selector="autocommitOn">autocommitOn	autocommit := true</body><body package="SupraEXDI" selector="dbNumber">dbNumber	^self sqlcaHolder dbNumber</body><body package="SupraEXDI" selector="encoding">encoding	^self class xif encoding</body><body package="SupraEXDI" selector="isolationLevel:">isolationLevel: newIsolationLevel	"Set the current isolation level."	newIsolationLevel == #RR ifFalse: [ExternalDatabaseConnection unsupportedIsolationLevelSignal raise].	isolationLevel := newIsolationLevel.</body><body package="SupraEXDI" selector="sqlca">sqlca	^ self sqlcaHolder sqlca.</body><body package="SupraEXDI" selector="sqlca:">sqlca: aValue	self sqlcaHolder sqlca: aValue.</body><body package="SupraEXDI" selector="sqlcaHolder">sqlcaHolder	^sqlcaHolder</body><body package="SupraEXDI" selector="sqlcaHolder:">sqlcaHolder: aValueHolder	sqlcaHolder := aValueHolder</body><body package="SupraEXDI" selector="sqlcaPointer">sqlcaPointer	" Answer the external address for the SQLCA memory,		or nil. "	| ca |	^ (ca := self sqlca) isNil		ifTrue: [ nil ]		ifFalse: [ ca sqlca ].</body></methods><methods><class-id>Database.SupraConnection</class-id> <category>private-defaults</category><body package="SupraEXDI" selector="caTag">caTag	^String defaultPlatformClass fromString: 'SQCCA   '.</body></methods><methods><class-id>Database.SupraConnection</class-id> <category>private-command strings</category><body package="SupraEXDI" selector="commitString">commitString	^'COMMIT WORK '</body><body package="SupraEXDI" selector="constructedConnectString">constructedConnectString	"#toDo: Add access to Supra connect parameters"	^ self defaultConnectString</body><body package="SupraEXDI" selector="defaultConnectString">defaultConnectString	^'CONNECT :userid IDENTIFIED BY :password '</body><body package="SupraEXDI" selector="rollbackString">rollbackString	^'ROLLBACK WORK '</body></methods><methods><class-id>Database.SupraConnection</class-id> <category>private-finalization</category><body package="SupraEXDI" selector="executor">executor	| ex |	ex := super executor.	ex sqlcaHolder: self sqlcaHolder.	^ex</body><body package="SupraEXDI" selector="finalizeExternal">finalizeExternal	(self sqlca isNil or: [self sqlcaPointer isNull]) ifTrue: [ ^self ].	( traceLevel &gt;= 1 ) ifTrue: [ self class trace: nil ].	self releaseSqlca.	super finalizeExternal</body><body package="SupraEXDI" selector="key">key	"The sqlcaHolder is unique to the connection and is constant	across pause/resume."	^self sqlcaHolder</body></methods><methods><class-id>Database.SupraConnection</class-id> <category>private-testing</category><body package="SupraEXDI" selector="isAutocommit">isAutocommit	^autocommit</body></methods><methods><class-id>Database.SupraConnection</class-id> <category>printing</category><body package="SupraEXDI" selector="printOn:">printOn: aStream	super printOn: aStream.	(self sqlca isNil or: [self sqlcaPointer isNull]) ifFalse:		[ aStream			nextPutAll: '( sqlca=';			nextPutAll: (self sqlcaPointer referentAddress printStringRadix: 16);			nextPutAll: ' )' ]</body></methods><methods><class-id>Database.SupraConnection</class-id> <category>private-resources</category><body package="SupraEXDI" selector="acquireSqlca">acquireSqlca	self sqlcaHolder acquireSqlca.	self sqlca isNil 		ifTrue: [ 	self class unableToAllocateHandleSignal raise ].</body><body package="SupraEXDI" selector="releaseSqlca">releaseSqlca	self sqlcaHolder releaseSqlca.</body><body package="SupraEXDI" selector="sqlcaDo:">sqlcaDo: aBlock 	" Control execution access for this connection "	^ self sqlca sqlcaDo: aBlock.</body></methods><methods><class-id>Database.SupraConnection</class-id> <category>initialize-release</category><body package="SupraEXDI" selector="initialize">initialize	super initialize.	sqlcaHolder := SupraSqlcaHolder new.	self autocommitOn.</body></methods><methods><class-id>Database.SupraConnection class</class-id> <category>private-accessing</category><body package="SupraEXDI" selector="columnDescriptionClass">columnDescriptionClass	"Answer the class to use for column description objects associated with receiver."	^SupraColumnDescription</body><body package="SupraEXDI" selector="interfaceClass">interfaceClass	"Answer the class to use as the SupraInterface for the current platform."	| interfaceClassName |	interfaceClassName := xifMap at: self platformType ifAbsent: [nil].	^self environment at: interfaceClassName ifAbsent: [nil].</body><body package="SupraEXDI" selector="privateXif">privateXif	"Answer the xif class instVar without attempting to initialize"	^xif</body><body package="SupraEXDI" selector="sessionClass">sessionClass	"Answer the class to use for session objects associated with receiver."	^SupraSession</body><body package="SupraEXDI" selector="signalMap">signalMap	"Answer the signal map dictionary"	^signalMap</body><body package="SupraEXDI" selector="sqlcaClass">sqlcaClass	"Answer the class to use for SQLCA associated with receiver."	^SupraSqlca</body><body package="SupraEXDI" selector="transactionClass">transactionClass	"Answer the class to use for transaction objects associated with receiver."	^SupraTransaction</body><body package="SupraEXDI" selector="xif">xif	"Answer the ExternalInterface subclass instance to use." 	xif isNil ifTrue:		[ self initializeExternalInterface ].	^xif</body></methods><methods><class-id>Database.SupraConnection class</class-id> <category>private-activation</category><body package="SupraEXDI" selector="determinePlatformType">determinePlatformType	"Answer a symbol representing the current platform type."	"ExternalInterface must complete its #returnFromSnapshot processing before	this method can be safely invoked."	| platformArray platformSymbol osNameString |	platformArray := ExternalInterface currentPlatform.	platformSymbol := platformArray at: 1.	osNameString := platformArray at: 2.	#win32 == platformSymbol		ifTrue: [^self determineWinTelPlatformFrom: osNameString].	^#unknown.</body><body package="SupraEXDI" selector="determineWinTelPlatformFrom:">determineWinTelPlatformFrom: osNameString	"Answer a symbol representing the current platform type."	"ExternalInterface must complete its #returnFromSnapshot processing before	this method can be safely invoked."	"WinNT  ^#nt		Win95 ^#win95	Win3.1 ^#win32s"	| tokens |	tokens := osNameString tokensBasedOn: Character space.	(tokens includes: 'nt') ifTrue: [^#nt].	(tokens includes: '95') ifTrue: [^#win95].	^#win32s</body><body package="SupraEXDI" selector="install">install	self == SupraConnection		ifTrue:	[ self subclasses do: [ :each | each install ] ]		ifFalse:	[ self subclassResponsibility ].	TraceLevel &gt;= 1 ifTrue: [self trace: nil].	self xif: nil.	"These classes only need to set/reset themselves and their shared variables."	SupraBuffer install.	SupraSqlca install.	"Send install to all entities in the registry"	self returnFromSnapshot.</body></methods><methods><class-id>Database.SupraConnection class</class-id> <category>activation</category><body package="SupraEXDI" selector="pause">pause	"Direct the suspension of all activity."	^self quiesce</body><body package="SupraEXDI" selector="resume">resume	"Direct the resumption of all suspended activity."	^self activate</body></methods><methods><class-id>Database.SupraConnection class</class-id> <category>private-registry</category><body package="SupraEXDI" selector="registry">registry	^RegisteredSupraConnections</body><body package="SupraEXDI" selector="registry:">registry: aCollection	RegisteredSupraConnections := aCollection</body></methods><methods><class-id>Database.SupraConnection class</class-id> <category>accessing</category><body package="SupraEXDI" selector="kind">kind	"Answer a symbol representing the type of DBMS the receiver provides services for."	^#'Supra SQL'</body><body package="SupraEXDI" selector="version">version	^(#supraVersion &lt;&lt; #supraDB &gt;&gt; 'Database Connect for Supra SQL - Release 2900') asString.</body></methods><methods><class-id>Database.SupraConnection class</class-id> <category>class initialization</category><body package="SupraEXDI" selector="initialize">initialize	"SupraConnection initialize"	self xif: nil.	self initRegistry.	self initializeInterfaceMapping.	self initializeSignalMap.</body><body package="SupraEXDI" selector="initializeExternalInterface">initializeExternalInterface	"Reset xif with the right interface class based on our platform."	" self initializeExternalInterface "	|  xifClass |	xifClass := self interfaceClass.	self xif: (xifClass notNil			ifTrue: [xifClass new]			ifFalse: [nil]).	self privateXif isNil ifTrue: 		[ ^Dialog warn: ((#errDatabaseNotCorrectlyInstalled &lt;&lt; #supraDB &gt;&gt; 'The &lt;1s&gt; is not correctly installed.')  expandMacrosWith: self version) ]</body><body package="SupraEXDI" selector="initializeInterfaceMapping">initializeInterfaceMapping	"self initializeInterfaceMapping"	xifMap := IdentityDictionary new.	xifMap at: #win95 put: #SupraWin95Interface.	xifMap at: #nt put: #SupraNTInterface.	xifMap at: #unknown put: #SupraInterface.</body><body package="SupraEXDI" selector="initializeSignalMap">initializeSignalMap	"self initializeSignalMap"	signalMap := IdentityDictionary new.	signalMap at: 700 put: #commandInactivityTimeoutSignal.	signalMap at: 709 put: #couldNotResolveServiceNameSignal.	signalMap at: 807 put: #connectionDownSignal.	signalMap at: 4004 put: #invalidTableNameSignal.	signalMap at: 4008 put: #authenticationFailureSignal.	signalMap at: 8000 put: #serverNotRestartedSignal.	"The following exceptions have special Retry syntax used by Store."	signalMap at: 7025 put: #invalidSelectTableSignal.	signalMap at: 7042 put: #keyUpdateNotAllowedSignal.	signalMap at: 1103 put: #statementTooComplicatedSignal.	signalMap at: 1101 put: #statementTooComplicatedSignal.</body><body package="SupraEXDI" selector="releaseExternalInterface">releaseExternalInterface	" self releaseExternalInterface "	|  xifClass |	xifClass := self interfaceClass.	xifClass unloadLibraries.</body></methods><methods><class-id>Database.SupraConnection class</class-id> <category>signal constants</category><body package="SupraEXDI" selector="commandInactivityTimeoutSignal">commandInactivityTimeoutSignal	"Answer the signal used to indicate that the Supra connection was terminated."	^CommandInactivityTimeout</body><body package="SupraEXDI" selector="connectionDownSignal">connectionDownSignal	"Answer the signal used to indicate that the Supra connection was terminated."	^ConnectionDown</body><body package="SupraEXDI" selector="fetchBufferIncompatibleSignal">fetchBufferIncompatibleSignal	"Answer the signal used to indicate that buffer is incompatible with fetch column data."	^FetchBufferIncompatible</body><body package="SupraEXDI" selector="invalidSelectTableSignal">invalidSelectTableSignal	"For SupraSession&gt;&gt;executeExternal :	 Answer the signal used to indicate that the INSERT has a SELECT against the same table.	 This exception can provide a series of SQL statements with which to retry the request."	^InvalidSelectTable</body><body package="SupraEXDI" selector="keyUpdateNotAllowedSignal">keyUpdateNotAllowedSignal	"For SupraSession&gt;&gt;executeExternal :	 Answer the signal used to indicate that an update of the row key was attempted.	 This exception can provide a series of SQL statements with which to retry the request."	^KeyUpdateNotAllowed</body><body package="SupraEXDI" selector="serverNotRestartedSignal">serverNotRestartedSignal	"Answer the signal used to indicate that the server is running but was not restarted."	^ServerNotRestarted</body><body package="SupraEXDI" selector="statementTooComplicatedSignal">statementTooComplicatedSignal	"For SupraSession&gt;&gt;executeExternal :	 Answer the signal used to indicate that a statement is too complicated.	 This exception can provide a series of SQL statements with which to retry the request."	^StatementTooComplicated</body><body package="SupraEXDI" selector="truncatedParameterSignal">truncatedParameterSignal	"Answer the signal used to indicate that a parameter was truncated."	^TruncatedParameter</body></methods><methods><class-id>Database.SupraTransaction</class-id> <category>private-library calls</category><body package="SupraEXDI" selector="acquireExternal">acquireExternal	^self</body><body package="SupraEXDI" selector="beginExternal">beginExternal	^self</body><body package="SupraEXDI" selector="commitExternal">commitExternal	^self</body><body package="SupraEXDI" selector="dismissExternal">dismissExternal	^self</body><body package="SupraEXDI" selector="rollbackExternal">rollbackExternal	^self</body></methods><methods><class-id>Database.SupraTransaction</class-id> <category>private-finalization</category><body package="SupraEXDI" selector="executor">executor	^self shouldNotImplement</body><body package="SupraEXDI" selector="finalizeExternal">finalizeExternal	^self shouldNotImplement</body><body package="SupraEXDI" selector="key">key	^self shouldNotImplement</body></methods><methods><class-id>Database.SupraTransaction class</class-id> <category>accessing</category><body package="SupraEXDI" selector="connectionClass">connectionClass	^SupraConnection</body></methods><methods><class-id>Database.SupraTransaction class</class-id> <category>private-registry</category><body package="SupraEXDI" selector="registry:">registry: aCollection 	^self shouldNotImplement</body></methods><methods><class-id>Database.ConnectionDown</class-id> <category>printing</category><body package="SupraEXDI" selector="defaultMessageText">defaultMessageText	^#connectionDown &lt;&lt; #supraDB &gt;&gt; 'Connection down.'.</body></methods><methods><class-id>Database.SupraStatus</class-id> <category>initialize-release</category><body package="SupraEXDI" selector="asErrorFrom:">asErrorFrom: anSqlca 	"Initialize this SupraStatus as an error using current contents of SQLCA"	dbmsErrorString := anSqlca sqlerrmc.	dbmsWarningCode := 0.	affectedRows := 0</body><body package="SupraEXDI" selector="asSuccess">asSuccess	"Convert this status to Success.		Keep current value for affectedRows, but reinitialize everything else"	osErrorCode := 0.	osErrorString := nil.	dbmsErrorCode := 0.	dbmsErrorString := nil.	dbmsWarningCode := 0.</body><body package="SupraEXDI" selector="asSuccessFrom:">asSuccessFrom: anSqlca 	" Initialize this SupraStatus as success using current contents of SQLCA "		dbmsWarningCode := 0.	affectedRows := anSqlca sqlerrd3.</body><body package="SupraEXDI" selector="asWarningFrom:">asWarningFrom: anSqlca 	" Initialize this SupraStatus as a warning using current contents of SQLCA "		dbmsWarningCode := anSqlca warningCode.	affectedRows := anSqlca sqlerrd3.</body><body package="SupraEXDI" selector="initialize">initialize	osErrorCode := 0.	dbmsErrorCode := 0.	dbmsWarningCode := 0.	affectedRows := 0.</body><body package="SupraEXDI" selector="initializeFrom:">initializeFrom: anSqlca	osErrorCode := 0.	(dbmsErrorCode := anSqlca sqlcode) ~~ 0		ifTrue: [ ^ self asErrorFrom: anSqlca ].	(anSqlca sqlwarn0) == $w		ifTrue: [ ^ self asWarningFrom: anSqlca ].	^ self asSuccessFrom: anSqlca.</body></methods><methods><class-id>Database.SupraStatus</class-id> <category>accessing</category><body package="SupraEXDI" selector="affectedRows">affectedRows	"Answer the number of rows inserted/updated/deleted or fetched."	^affectedRows</body><body package="SupraEXDI" selector="dbmsWarningCode">dbmsWarningCode	"Answer the warning code used by the dbms api which lead to this error report."	^dbmsWarningCode</body><body package="SupraEXDI" selector="dbmsWarningString">dbmsWarningString	"Answer the text associated with the warning value in the SQLCA."	^ (#Warning: &lt;&lt; #supraDB &gt;&gt; 'Warning: ') asString,		(self class warningMessages 			at: dbmsWarningCode			ifAbsent: [(#warnNotImplemented &lt;&lt; #supraDB &gt;&gt; 'Warning value not implemented.')] ) asString.</body><body package="SupraEXDI" selector="notifyOnWarning">notifyOnWarning	"Answer whether or not to display Warning messages."	^self class notifyOnWarning</body><body package="SupraEXDI" selector="raiseWarning">raiseWarning	(self isWarning and: [ self notifyOnWarning ])		ifTrue: [ Dialog warn: self dbmsWarningString ].</body><body package="SupraEXDI" selector="sqlCode">sqlCode	"Answer the primary SQL return code."	^dbmsErrorCode</body></methods><methods><class-id>Database.SupraStatus</class-id> <category>testing</category><body package="SupraEXDI" selector="hasRetrySQL">hasRetrySQL	^ (Set withAll: #( 1101 1103 7025 7042 )) includes: dbmsErrorCode abs.</body><body package="SupraEXDI" selector="isDatabaseDown">isDatabaseDown	^ (dbmsErrorCode == -807) or: [dbmsErrorCode == -813]</body><body package="SupraEXDI" selector="isError">isError	^ dbmsErrorCode ~~ 0</body><body package="SupraEXDI" selector="isResultSetNotFound">isResultSetNotFound	^ dbmsErrorCode == -4000</body><body package="SupraEXDI" selector="isRowNotFound">isRowNotFound	^ dbmsErrorCode == 100</body><body package="SupraEXDI" selector="isSqldaTooSmall">isSqldaTooSmall	^ dbmsErrorCode == -712</body><body package="SupraEXDI" selector="isSuccess">isSuccess	^ (dbmsErrorCode == 0) and: [dbmsWarningCode == 0]</body><body package="SupraEXDI" selector="isSuccessOrWarning">isSuccessOrWarning	^ self isError not</body><body package="SupraEXDI" selector="isWarning">isWarning	^ dbmsWarningCode ~~ 0</body></methods><methods><class-id>Database.SupraStatus</class-id> <category>printing</category><body package="SupraEXDI" selector="printOn:">printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	self isError 		ifTrue: [			aStream				nextPutAll: (#Error: &lt;&lt; #labels &gt;&gt; 'Error:') asString;				nextPut: $(; print: self dbmsErrorCode;				nextPutAll: ', '; print: self dbmsErrorString;				nextPut: $) ]		ifFalse: [			self isWarning 				ifTrue: [					aStream						nextPutAll: (#Warning: &lt;&lt; #supraDB &gt;&gt; 'Warning:') asString;						nextPut: $(; print: self dbmsWarningCode;						nextPutAll: ', '; print: self dbmsWarningString;						nextPut: $) ]				ifFalse: [					aStream						nextPutAll: (#Success: &lt;&lt; #supraDB &gt;&gt; 'Success:') asString ]		].	aStream nextPut: $).</body></methods><methods><class-id>Database.SupraStatus class</class-id> <category>instance creation</category><body package="SupraEXDI" selector="new">new	^ super new initialize</body><body package="SupraEXDI" selector="newFrom:">newFrom: sqlca	^ super new 		initializeFrom: sqlca</body></methods><methods><class-id>Database.SupraStatus class</class-id> <category>private-accessing</category><body package="SupraEXDI" selector="notifyOnWarning">notifyOnWarning	"Answer whether or not to display Warning messages."	WarningNotification isNil		ifTrue: [ WarningNotification := true ].	^ WarningNotification</body><body package="SupraEXDI" selector="notifyOnWarning:">notifyOnWarning: aBoolean	WarningNotification := aBoolean</body><body package="SupraEXDI" selector="warningMessageDictionary">warningMessageDictionary	| dict |	dict := IdentityDictionary new.	dict at: 1 put: (#warnTruncatedData &lt;&lt; #supraDB &gt;&gt; 		'Data value truncated in host variable.').	dict at: 2 put: (#warnNullValuesIgnored &lt;&lt; #supraDB &gt;&gt; 		'One or more null values were ignored during function processing.').	dict at: 3 put: (#warnUnequalNumColumns &lt;&lt; #supraDB &gt;&gt; 		'Number of result columns does not equal number of parameters.').	dict at: 4 put: (#warnAffectedAllRows &lt;&lt; #supraDB &gt;&gt; 		'Update/Delect affected all rows.').	^dict.</body><body package="SupraEXDI" selector="warningMessages">warningMessages	"Answer whether or not to display Warning messages."	WarningMessages isNil		ifTrue: [ WarningMessages := self warningMessageDictionary ].	^ WarningMessages</body></methods><methods><class-id>Database.SupraSqlcaHolder</class-id> <category>private-accessing</category><body package="SupraEXDI" selector="dbNumber">dbNumber		^ dbNumber</body><body package="SupraEXDI" selector="dbNumber:">dbNumber: aValue		dbNumber := aValue</body><body package="SupraEXDI" selector="sqlca">sqlca	^ self sqlcaHolder value.</body><body package="SupraEXDI" selector="sqlca:">sqlca: aValue	self sqlcaHolder value: aValue.</body><body package="SupraEXDI" selector="sqlcaHolder">sqlcaHolder	^sqlcaHolder</body><body package="SupraEXDI" selector="sqlcaHolder:">sqlcaHolder: aValue	sqlcaHolder := aValue</body><body package="SupraEXDI" selector="sqlcaSlotNumber">sqlcaSlotNumber	^sqlcaSlotNumber</body><body package="SupraEXDI" selector="sqlcaSlotNumber:">sqlcaSlotNumber: aValue	sqlcaSlotNumber := aValue</body></methods><methods><class-id>Database.SupraSqlcaHolder</class-id> <category>initialize-release</category><body package="SupraEXDI" selector="initialize">initialize	sqlcaHolder := nil asValue.	sqlcaSlotNumber := 0.	dbNumber := 0.</body></methods><methods><class-id>Database.SupraSqlcaHolder</class-id> <category>accessing</category><body package="SupraEXDI" selector="acquireSqlca">acquireSqlca	| slot |	slot := SupraSqlca acquireSqlcaSlot.	self sqlca: (SupraSqlca sqlcaForSlotNumber: slot).	self sqlca notNil 		ifTrue: 			[ self sqlcaSlotNumber: slot.			self dbNumber: (SupraSqlca dbNumberFor: slot) ].</body><body package="SupraEXDI" selector="releaseSqlca">releaseSqlca	SupraSqlca releaseSqlcaSlot: self sqlcaSlotNumber.	self sqlcaHolder value: nil.	self sqlcaSlotNumber: 0.	self dbNumber: 0.</body></methods><methods><class-id>Database.SupraSqlcaHolder class</class-id> <category>instance creation</category><body package="SupraEXDI" selector="new">new	^super new initialize</body></methods><methods><class-id>Database.ServerNotRestarted</class-id> <category>printing</category><body package="SupraEXDI" selector="defaultMessageText">defaultMessageText	^#serverNotRestartedMsg &lt;&lt; #supraDB &gt;&gt; 'Supra Server needs to be restarted'.</body></methods><methods><class-id>Database.SupraBuffer</class-id> <category>private-testing</category><body package="SupraEXDI" selector="canBind:">canBind: aValue 	"Answer whether or not the current hostvarType can accept aValue"	^self hostvarType == (self class hostvarTypeFor: aValue supraConversion)</body><body package="SupraEXDI" selector="isNull">isNull	^null</body><body package="SupraEXDI" selector="isNullable">isNullable	^nullsPossible</body></methods><methods><class-id>Database.SupraBuffer</class-id> <category>initialize-release</category><body package="SupraEXDI" selector="elementSize:count:databaseType:">elementSize: anElementSize count: aCount databaseType: aDatabaseType	^self shouldNotImplement</body><body package="SupraEXDI" selector="elementSize:databaseType:">elementSize: anElementSize databaseType: aDatabaseType	^ super 		elementSize: anElementSize		count: 0		" no bulk parameters "		databaseType: aDatabaseType</body></methods><methods><class-id>Database.SupraBuffer</class-id> <category>allocation</category><body package="SupraEXDI" selector="free">free	"Free the external resources held by this buffer."	bufferPointer == nil ifFalse: [ bufferPointer freePointer ].	bufferPointer := nil.</body><body package="SupraEXDI" selector="mallocBuffer">mallocBuffer	self hostvarType == 15 ifTrue: [ "sqcvstring"		^ self allocStructuredBuffer ].	self hostvarType == 5 ifTrue: [ "sqcvzoned"		^ self allocScalarBufferType: DefaultUnsignedCharPointerType ].	self hostvarType == 6 ifTrue: [ "sqcvfchar"		^ self allocScalarBufferType: DefaultUnsignedCharPointerType ].	self hostvarType == 3 ifTrue: [ "sqcreal8"		^ self allocScalarBufferType: DefaultDoublePointerType ].	" Return nil for unsupported hostvarType "	^ nil.</body><body package="SupraEXDI" selector="mallocForParameter">mallocForParameter	[ "Begin unwind protection"		"Allocate a properly typed buffer --			indicator(s) are part of the SQLVAR."		bufferPointer := self mallocBuffer.	] "End unwind protection"		ifCurtailed:			[ self free ].	getSelector := self mapGetSelectorOn: hostvarType for: databaseType.	setSelector := self mapSetSelectorOn: hostvarType for: databaseType.</body><body package="SupraEXDI" selector="mallocForRowBuffer">mallocForRowBuffer	[ "Begin unwind protection"		"Allocate a properly typed buffer --			indicator(s) are part of the SQLVAR."		bufferPointer := self mallocBuffer.	] "End unwind protection"		ifCurtailed:			[ self free ].	getSelector := self mapGetSelectorOn: hostvarType for: databaseType.</body><body package="SupraEXDI" selector="mallocUsingSelector:">mallocUsingSelector: mallocSelector	^self shouldNotImplement</body></methods><methods><class-id>Database.SupraBuffer</class-id> <category>private-accessing</category><body package="SupraEXDI" selector="bufferSize">bufferSize	"Adjust available buffer size for hostvar structure size element."	^ hostvarType == 15 ifFalse: [ elementSize ] ifTrue: [ elementSize - 2 ].</body><body package="SupraEXDI" selector="getSelector">getSelector	^getSelector</body><body package="SupraEXDI" selector="hostvarType">hostvarType	^hostvarType</body><body package="SupraEXDI" selector="hostvarType:">hostvarType: aValue	hostvarType := aValue</body><body package="SupraEXDI" selector="nullsPossible:">nullsPossible: aValue	nullsPossible := aValue</body><body package="SupraEXDI" selector="scale">scale	^ scale</body><body package="SupraEXDI" selector="scale:">scale: aValue	scale := aValue</body><body package="SupraEXDI" selector="setNotNull">setNotNull		null := false</body><body package="SupraEXDI" selector="setNull">setNull		null := true</body><body package="SupraEXDI" selector="setSelector">setSelector	^setSelector</body></methods><methods><class-id>Database.SupraBuffer</class-id> <category>private-data accessing</category><body package="SupraEXDI" selector="byteArrayFromData:">byteArrayFromData: bufferData 	"The String we get may come pre-encoded."	^ (bufferData isKindOf: ByteArray) 		ifTrue: [bufferData]		ifFalse: [| str |			str := (bufferData isKindOf: Text) 						ifTrue: [bufferData string]						ifFalse: 							[(bufferData isKindOf: GapString) 								ifTrue: [bufferData compress string]								ifFalse: [bufferData]].			ByteArray fromString: str encoding: self encoding].</body><body package="SupraEXDI" selector="convertToFixedPoint:">convertToFixedPoint: number		| newScale |	number isInteger		ifTrue: [ newScale := 0 ]		ifFalse: [ newScale := (((number printString) readStream skipThrough: $.) upToAll: 's') size ].	^ number asFixedPoint: newScale.</body><body package="SupraEXDI" selector="getBinary">getBinary	"Answer a ByteArray (with no encoding)		as described in the structure pointed to by bufferPointer."	| byteArray size | 	size := self getLength.	" Ensure size/type compatibility "	((size &gt; self bufferSize) or: [ self hostvarType ~~ 15 "sqcvstring" ])		ifTrue: [ self class connectionClass fetchBufferIncompatibleSignal raise ].	byteArray := ByteArray new: size.	bufferPointer		copyAt: 2		to: byteArray		size: size		startingAt: 1.	^ byteArray.</body><body package="SupraEXDI" selector="getDate">getDate	"Answer a Date as described in the 8 bytes (YYYYMMDD) pointed to by bufferPointer."	| byteArray |	byteArray := ByteArray new: elementSize.	bufferPointer		copyAt: 0		to: byteArray		size: elementSize		startingAt: 1.	^Date readFromSupraString: byteArray asString.</body><body package="SupraEXDI" selector="getFloat">getFloat	"Answer a Float (or Double) as described in the 4 (or 8) bytes 	pointed to by bufferPointer."	"Assume that bufferPointer is coerced to array of float or double."	^bufferPointer at: 0</body><body package="SupraEXDI" selector="getLength">getLength	"Answer length as reported in Supra hostvar structure."	^ bufferPointer memberAt: #length.</body><body package="SupraEXDI" selector="getString">getString	"Answer a String (with appropriate encoding) 		as described in the structure pointed to by bufferPointer."	^ self getBinary asStringEncoding: self encoding.</body><body package="SupraEXDI" selector="getTime">getTime	"Answer a Time as described in the 8 bytes (00HHMMSS) pointed to by bufferPointer."	| byteArray |	byteArray := ByteArray new: elementSize.	bufferPointer		copyAt: 0		to: byteArray		size: elementSize		startingAt: 1.	^Time readFromSupraString: byteArray asString.</body><body package="SupraEXDI" selector="getTimestamp">getTimestamp	"Answer a Timestamp as described in the 19 bytes (YYYYMMDD:00HHMMSSFF) pointed to by bufferPointer."	| byteArray |	byteArray := ByteArray new: elementSize.	bufferPointer		copyAt: 0		to: byteArray		size: elementSize		startingAt: 1.	^Timestamp readFromSupraString: byteArray asString.</body><body package="SupraEXDI" selector="getZoned">getZoned	"Answer a FixedPoint with appropriate scale as described in the n zoned decimal bytes pointed to by bufferPointer."	| signExponentByte isNegative number fixedPoint byteArray power10 temp |	byteArray := ByteArray new: elementSize.	bufferPointer		copyAt: 0		to: byteArray		size: elementSize		startingAt: 1.	"Sign is overlayed in last digit - 		[IS_NEGNUM 	(ptr) &amp; 0x40]"	signExponentByte := byteArray at: elementSize.	(isNegative := signExponentByte allMask: 64) ifTrue:		[ byteArray at: elementSize put: (signExponentByte maskClear: 64) ].	"Convert the numeric bytes into a FixedPoint number."	number := (byteArray asStringEncoding:self encoding) asNumber.	power10 := 10 raisedTo: self scale.	fixedPoint := FixedPoint numerator: number denominator: power10 scale: self scale.	"Apply the sign if necessary and answer."	temp := isNegative ifTrue: [ fixedPoint negated ] ifFalse: [ fixedPoint ].	"Return Integer or Float as appropriate.		Supra cannot parse FixedPoint #printString values yet."	^ temp scale = 0		ifTrue: [ temp asInteger ]		ifFalse: [ temp asFloat ]</body><body package="SupraEXDI" selector="putBinary:">putBinary: string 	"Store a binary string (with no encoding) or a string (with encoding as specified) 		in the structure referenced by bufferPointer."	| byteArray size |	byteArray := self byteArrayFromData: string.	size := byteArray size.	" Ensure size/type compatibility "	(size &gt; self bufferSize or: [self hostvarType ~~ 15	"sqcvstring"]) 		ifTrue: [self class connectionClass unableToBindSignal raise].	self putLength: size.	bufferPointer 		copyAt: 2		from: byteArray		size: size		startingAt: 1</body><body package="SupraEXDI" selector="putDate:">putDate: aValue	"Store a Date (YYYYMMDD) at the location in bufferPointer."	| byteArray |	byteArray := aValue asDate asSupraString asByteArray.	" Ensure size/type compatibility "	(( elementSize ~~ 8 "yyyymmdd" ) or: [ self hostvarType ~~ 6 "sqcvfchar" ])		ifTrue: [ self class connectionClass unableToBindSignal raise ].	bufferPointer		copyAt: 0		from: byteArray		size: elementSize		startingAt: 1</body><body package="SupraEXDI" selector="putFloat:">putFloat: aValue	"Store a float or double at the location in bufferPointer."	"Assume that bufferPointer is coerced to float or double."	bufferPointer at: 0 put: aValue</body><body package="SupraEXDI" selector="putLength:">putLength: aSize	"Set length in Supra hostvar structure."	bufferPointer memberAt: #length put: aSize.</body><body package="SupraEXDI" selector="putString:">putString: string	"Store a string (with encoding as specified) or binary string (with no encoding) 		in the structure referenced by bufferPointer.		Same processing as BYTE data."	self putBinary: string.</body><body package="SupraEXDI" selector="putTime:">putTime: aValue	"Store a Time (00HHMMSS) at the location in bufferPointer."	| byteArray |	byteArray := aValue asTime asSupraString asByteArray.	" Ensure size/type compatibility "	(( elementSize ~~ 8 "00hhmmss" ) or: [ self hostvarType ~~ 6 "sqcvfchar" ])		ifTrue: [ self class connectionClass unableToBindSignal raise ].	bufferPointer		copyAt: 0		from: byteArray		size: elementSize		startingAt: 1</body><body package="SupraEXDI" selector="putTimestamp:">putTimestamp: aValue	"Store a Timestamp (YYYYMMDD:HHHHMMSSFF) at the location in bufferPointer."	| byteArray |	byteArray := aValue asTimestamp asSupraString asByteArray.	" Ensure size/type compatibility "	(( elementSize ~~ 19 "yyyymmdd:00hhmmssff" ) or: [ self hostvarType ~~ 6 "sqcvfchar" ])		ifTrue: [ self class connectionClass unableToBindSignal raise ].	bufferPointer		copyAt: 0		from: byteArray		size: elementSize		startingAt: 1</body><body package="SupraEXDI" selector="putZoned:">putZoned: number	"Store a zoned decimal number at the location in bufferPointer."	| tokens byteArray isNegative zonedText  |	isNegative := (self convertToFixedPoint: number) negative.	" Build String representation of numeric digits (ByteArray) "	tokens :=  (String new: elementSize withAll: $0) asSymbol.	zonedText := NumberPrintPolicy print: ((number asFixedPoint: self scale) abs) using: tokens.	byteArray := zonedText string asByteArray.	" Mask on sign bit (in last byte) as required "	isNegative		ifTrue: [ | signByte |			signByte := byteArray at: elementSize.			byteArray at: elementSize put: (signByte maskSet: 64) ].	bufferPointer		copyAt: 0		from: byteArray		size: elementSize		startingAt: 1</body></methods><methods><class-id>Database.SupraBuffer</class-id> <category>accessing</category><body package="SupraEXDI" selector="at:">at: anIndex	"Answer the element in the buffer at anIndex."	"No bulk parameters - ignore anIndex"	^self perform: self getSelector.</body><body package="SupraEXDI" selector="at:put:">at: anIndex put: aValue	"Set NULL, or store aValue at appropriate index in the receiver."	"No bulk parameters - ignore anIndex"	aValue isNil ifTrue: [ ^ self setNull ].	self setNotNull.	(self canBind: aValue)		ifFalse: [ ^ self class connectionClass unableToBindSignal raise ].	self perform: self setSelector with: aValue.</body></methods><methods><class-id>Database.SupraBuffer</class-id> <category>private-binding</category><body package="SupraEXDI" selector="mapGetSelectorOn:for:">mapGetSelectorOn: hvType for: dbType	hvType == 3		"sqcvfloat8"		ifTrue: [ ^ #getFloat ].	hvType == 5		"sqcvzoned"		ifTrue: [ ^ #getZoned ].	hvType == 15	"sqcvstring"		ifTrue: [ 			dbType == 2 ifTrue: [ ^ #getString ].			dbType == 3 ifTrue: [ ^ #getBinary ] ].	hvType == 6		"sqcvfchar"		ifTrue: [			dbType == 4 ifTrue: [ ^ #getDate ].			dbType == 5 ifTrue: [ ^ #getTime ].			dbType == 8 ifTrue: [ ^ #getTimestamp ] ].	" Return nil for unknown type "	^ nil</body><body package="SupraEXDI" selector="mapSetSelectorOn:for:">mapSetSelectorOn: hvType for: dbType	hvType == 3		"sqcvfloat8"		ifTrue: [ ^ #putFloat: ].	hvType == 5		"sqcvzoned"		ifTrue: [ ^ #putZoned: ].	hvType == 15	"sqcvstring"		ifTrue: [ 			dbType == 2 ifTrue: [ ^ #putString: ].			dbType == 3 ifTrue: [ ^ #putBinary: ] ].	hvType == 6		"scqvfchar"		ifTrue: [			dbType == 4 ifTrue: [ ^ #put:Date: ].			dbType == 5 ifTrue: [ ^ #putTime: ].			dbType == 8 ifTrue: [ ^ #putTimestamp: ] ].	" Return nil for unknown type "	^ nil</body></methods><methods><class-id>Database.SupraBuffer</class-id> <category>private-allocation</category><body package="SupraEXDI" selector="allocScalarBufferType:">allocScalarBufferType: thePointerType	| address |	address := thePointerType 			primMalloc: elementSize			pointerKind: thePointerType kind.	^address == nil		ifTrue:	[ nil ]		ifFalse:	[ CPointer new newDatum: address ofType: thePointerType ]</body><body package="SupraEXDI" selector="allocStructuredBuffer">allocStructuredBuffer	| newStruct thePointerType address ptr |	"Create structure on the fly"	newStruct := self structVCharBuffer: self bufferSize.	thePointerType := newStruct pointerType.	SupraConnection platformType == #win32s ifTrue:		[ thePointerType beFar ].	address := thePointerType 					primMalloc: newStruct sizeof					pointerKind: thePointerType kind.	^ address == nil		ifTrue:	[ nil ]		ifFalse:	[ 			ptr := CCompositePointer new newDatum: address ofType: thePointerType.			ptr memberAt: #length put: self bufferSize.			ptr ].</body><body package="SupraEXDI" selector="structVCharBuffer:">structVCharBuffer: varSize	| newStruct |	"Create a structure on the fly"	newStruct := CCompositeType new beStructure.	newStruct at: #length put: 0 -&gt; CIntegerType unsignedShort.	newStruct at: #array put: 1 -&gt; (CArrayType defaultPointer			referentType: CIntegerType unsignedChar;			numElements: varSize).	^ newStruct align.</body></methods><methods><class-id>Database.SupraBuffer class</class-id> <category>private-accessing</category><body package="SupraEXDI" selector="defaultSizeFor:type:">defaultSizeFor: value type: type	" Answer the default size for the type. "	^ DefaultFixedSizeMap at: type ifAbsent: [ value size ].</body><body package="SupraEXDI" selector="hostvarSizeFor:type:precision:max:">hostvarSizeFor: hvType type: dbType precision: precis max: maxBytes 		hvType == 15 ifTrue: [ "sqcvstring"		dbType isNil ifTrue: [ 	"Assume CHAR" ^ (2 + (precis min: maxBytes)) ].		dbType == 0 ifTrue: [	"FIXED"	^ (2 + 2 + precis) ].		dbType == 1 ifTrue: [	"FLOAT"	^ (2 + 6 + precis) ].		"CHAR, BYTE, TIME, DATE, TIMESTAMP"	^ (2 + (precis min: maxBytes)) ].	hvType == 5 ifTrue: [ "sqcvzoned"		^ precis ].	hvType == 6 ifTrue: [ "sqcvfchar"		^ precis ].	hvType == 3 ifTrue: [ "sqcvreal8"		^DefaultDoublePointerType referentType sizeof ].	"Return 0 for unsupported hostvarType"	^0</body><body package="SupraEXDI" selector="hostvarTypeFor:">hostvarTypeFor: aValue	"Answer the hostvar type to be used.  The parameter aValue is either		the database type (an Integer)			or		a Smalltalk class name (a Symbol).	 Return nil for unsupported type or class."	aValue isNil ifTrue: [ ^nil ].	aValue isInteger 		ifTrue:		[ ^ InternalDatatypeToHostvarMap at: aValue ifAbsent: [ nil ] ]		ifFalse:		[ ^ ClassToHostvarMap at: aValue ifAbsent: [ nil ] ].</body></methods><methods><class-id>Database.SupraBuffer class</class-id> <category>private-activation</category><body package="SupraEXDI" selector="install">install	DefaultDoublePointerType := CLimitedPrecisionRealType double pointerType.	DefaultUnsignedCharPointerType := CIntegerType unsignedChar pointerType.	SupraConnection platformType == #win32s ifTrue:		[ DefaultDoublePointerType beFar.		DefaultUnsignedCharPointerType beFar ]</body></methods><methods><class-id>Database.SupraBuffer class</class-id> <category>class initialization</category><body package="SupraEXDI" selector="initialize">initialize	"SupraBuffer initialize"	self install.	"Map the Supra internal datatypes to Supra host variable type codes."	(InternalDatatypeToHostvarMap := IdentityDictionary new)		add: (  0 "FIXED" -&gt; 5 "#sqcvzoned" );		add: (  1 "FLOAT" -&gt; 3 "#sqcvreal8" );		add: (  2 "CHAR" -&gt; 15 "#sqcvstring" );		add: (  3 "BYTE" -&gt; 15 "#sqcvstring" );		add: (  4 "DATE" -&gt; 6 "#sqcvfchar" );		add: (  5 "TIME" -&gt; 6 "#sqcvfchar" );		add: (  8 "TIMESTAMP" -&gt;6 "#sqcvfchar" ).	"Map the supported Smalltalk types to Supra host variable type codes."	(ClassToHostvarMap := IdentityDictionary new)		add: ( #String  -&gt; 15 "#sqcvstring" );		add: ( #ByteArray  -&gt; 15 "#sqcvstring" );		add: ( #Date -&gt; 6 "#sqcvfchar" );		add: ( #Time -&gt; 6 "#sqcvfchar" );		add: ( #Timestamp -&gt; 6 "#sqcvfchar" );		add: ( #Float -&gt; 3 "#sqcvreal8 -- use this to avoid unnecessary rebinding");		add: ( #Double -&gt; 3 "#sqcvreal8" );		add: ( #Integer -&gt; 5 "#sqcvzoned" );		add: ( #FixedPoint -&gt; 5 "#sqcvzoned" ).	"Map the default sizes for fixed-size data types."	(DefaultFixedSizeMap := IdentityDictionary new)		add: ( #Date -&gt; 8 );		add: ( #Time -&gt; 8 );		add: ( #Timestamp -&gt; 19 );		add: ( #Float -&gt; 8 	"-- to avoid unnecessary rebinding");		add: ( #Double -&gt; 8 );		add: ( #Integer -&gt; 18 	"max precision");		add: ( #FixedPoint -&gt; 18 	"max precision").</body></methods><methods><class-id>Database.SupraBuffer class</class-id> <category>instance creation</category><body package="SupraEXDI" selector="newFor:type:size:">newFor: value type: type size: size	" For input parameters, allocate buffer based on value attributes,		but we don't have a Description 		so don't set the databaseType until we have it "	| hvSize aType hvType aSize |	aType := type isNil 		ifTrue: [ value supraConversion ]		ifFalse: [ type ] .	aSize := size isNil		ifTrue: [ self defaultSizeFor: value type: aType ]		ifFalse: [ size ].	(hvType := self hostvarTypeFor: aType) isNil		ifTrue: [ ^ self connectionClass unableToBindSignal raise ].	hvSize := self		hostvarSizeFor: hvType		type: nil		precision: aSize		max: aSize.	^super new		elementSize: hvSize databaseType: nil;		hostvarType: hvType;		scale: 0;		nullsPossible: true;		yourself.</body><body package="SupraEXDI" selector="newOn:">newOn: descr 	" For output columns, allocate buffer based on Description "	| hvType hvSize |	(hvType := self hostvarTypeFor: descr databaseType) isNil		ifTrue: [ ^ self connectionClass unableToBindSignal raise ].	hvSize := self		hostvarSizeFor: hvType		type: descr databaseType		precision: descr precision		max: descr maxColumnConstraint.	^super new		elementSize: hvSize databaseType: descr databaseType;		hostvarType: hvType;		scale: descr scale;		nullsPossible: descr nullable;		yourself.</body><body package="SupraEXDI" selector="newOn:for:">newOn: descr for: value	" For input parameters, allocate buffer based on value's class,		but use Description for true database attributes "	| hvSize hvType |	(hvType := self hostvarTypeFor: value supraConversion) isNil		ifTrue: [ hvType := self hostvarTypeFor: descr databaseType ].	hvType isNil		ifTrue: [ ^ self connectionClass unableToBindSignal raise ].	hvSize := self		hostvarSizeFor: hvType		type: descr databaseType		precision: descr precision		max: descr precision.	^super new		elementSize: hvSize databaseType: descr databaseType;		hostvarType: hvType;		scale: descr scale;		nullsPossible: descr nullable;		yourself.</body></methods><methods><class-id>Database.SupraBuffer class</class-id> <category>accessing</category><body package="SupraEXDI" selector="connectionClass">connectionClass	^SupraConnection</body></methods><methods><class-id>Database.TruncatedParameter</class-id> <category>printing</category><body package="SupraEXDI" selector="defaultMessageText">defaultMessageText	#wrnTruncatedParameter &lt;&lt; #supraDB &gt;&gt; 'Truncated parameter.'</body></methods><methods><class-id>Database.SupraSession</class-id> <category>private-execution</category><body package="SupraEXDI" selector="acquireExternal">acquireExternal	"We only need a cursor name for printing.		All additional external resources can be deferred."	self cursorName: self defaultCursorName.</body><body package="SupraEXDI" selector="autoCommit">autoCommit	self connection autoCommit.</body><body package="SupraEXDI" selector="cancelExternal">cancelExternal	"There's nothing to do here.  		Once execution begins, a request cannot be cancelled."	^self</body><body package="SupraEXDI" selector="closeCursor">closeCursor	^ self state == #fetchingData 		ifTrue: [ self sqcStatement: self constructedCloseString ]		ifFalse: [ SupraStatus new asSuccess ].</body><body package="SupraEXDI" selector="dismissExternal">dismissExternal	"Release the external resources."	"All activity within this method must function with only the instance	variables defined in the executor object."	| status |	(self parsid isNil and: [self fetchParsid isNil]) ifTrue: [ ^self ].	[		self dropParsid: self parsid.			" ignore errors "		self dropParsid: self fetchParsid.		" ignore errors "		status := self closeCursor.		status isError 			ifTrue: [				"If close failed for reasons other than database down, or result set not found					raise a resumable exception."				(status isDatabaseDown or: [status isResultSetNotFound]) ifFalse: [					self class connectionClass unableToCloseCursorSignal 						raiseRequestWith: (Array with: status) errorString: (' \' withCRs, status dbmsErrorString) ]]	]	ensure:		[ self freePointerHolder: self sqldaHolder.		self freePointerHolder: self fetchSqldaHolder.		self cursorName: self defaultCursorName ]</body><body package="SupraEXDI" selector="executeDirect:">executeDirect: sqlStatement	"Execute the SQL text without preparing/fetching.		There is no commit.		Use with caution."	| status oldState |	"Enforce: we're in a legal state to execute the query."	oldState := self state.	(#( executing connected prepared new ) includes: oldState)		ifFalse: [			self class connectionClass invalidSessionStateSignal raise ].	[ self state: #executing.	status := self sqcStatement: sqlStatement.	status isSuccessOrWarning		ifTrue: [			status raiseWarning ]		ifFalse: 	[ | signal connClass |			signal := (connClass := self connection class)						perform: (connClass signalMap								at: status sqlCode abs								ifAbsent: [ #unableToExecuteSQLSignal ]).			signal				raiseWith: (Array with: status)				errorString: (' \' withCRs, status dbmsErrorString) ]]	ensure: 		[ self state: oldState ].</body><body package="SupraEXDI" selector="executeExternal">executeExternal	"Execute the [prepared] SQL text."	| status |	self rowCount: -1.	" initial value: unknown "	self isDML 		ifTrue: [			self bindParameters.			status := self sqcExecute.			status hasRetrySQL ifTrue: [self raiseRetryExceptionFor: status].			status isSuccessOrWarning 				ifTrue: 					[self updateRowCount: status affectedRows.					self connection autoCommit.					status raiseWarning].			" Save the status for the client when requesting an answer. "			self resultsCache: status]		ifFalse: [			self executeDirect: self query.			self connection commit]</body><body package="SupraEXDI" selector="installExternal">installExternal	super installExternal.	preparedQuery := ''.	sqlPointerHolder := nil asValue.	sqldaHolder := nil asValue.	parsidHolder := nil asValue.	preparedFetch := ''.	resultsCache := nil.	fetchPointerHolder := nil asValue.	fetchSqldaHolder := nil asValue.	fetchParsidHolder := nil asValue.	paramBuffersHolder := nil asValue.</body><body package="SupraEXDI" selector="moreResultsExternal">moreResultsExternal	"The Supra CallInterface doesn't support multiple answers."	^false</body><body package="SupraEXDI" selector="raiseRetryExceptionFor:">raiseRetryExceptionFor: status 	| signal connClass |	signal := (connClass := self class connectionClass) 				perform: (connClass signalMap at: status sqlCode abs						ifAbsent: [#unableToPrepareSignal]).	signal signalWithSQLString: self query.</body><body package="SupraEXDI" selector="readyExternal">readyExternal	"The Supra CallInterface does not have a concept of asynchronous query execution.		In fact, by the time that the application can even ask isReady, the processing		has occurred."	^true</body><body package="SupraEXDI" selector="resultsExternal">resultsExternal	"Examine the outcome of executing an SQL statement.		Raise exceptions for any errors.  If no errors occurred, answer true."	| status |	(status := self resultsCache) notNil ifTrue: [		"Make sure we get an empty result set on RowNotFound."		(status isError and: [ status isRowNotFound not ])			ifTrue: [ | signal connClass |				signal := (connClass := self class connectionClass) 							perform: (connClass signalMap at: status sqlCode abs									ifAbsent: [#unableToExecuteSQLSignal]).		 		signal mayResume 					ifTrue: [						signal							raiseRequestWith: (Array with: status)								errorString: (' \' withCRs, status dbmsErrorString) ]					ifFalse: [ 						signal							raiseWith: (Array with: status)							errorString: (' \' withCRs, status dbmsErrorString) ].				^ false ] ].	^ true.</body><body package="SupraEXDI" selector="sqcExecute">sqcExecute	"Execute the prepared SQL statement."	| xif dbnoPointer stmlenPointer status |	xif := self class xif.	[ 		dbnoPointer := self dbNumber asSmallInteger copyToHeap.		stmlenPointer := self preparedQuery size asSmallInteger copyToHeap.		status := self sqlcaDo:			[ xif sqcexecute: self sqlcaPointer					with: dbnoPointer 					with: stmlenPointer 					with: self sqlPointer					with: self sqlda					with: self parsid 	]	] 	ensure:		[ dbnoPointer == nil ifFalse: [ dbnoPointer freePointer ].		stmlenPointer == nil ifFalse: [ stmlenPointer freePointer ]].	( traceLevel &gt;= 2 ) ifTrue:		[ (self traceStream)			nextPutAll: 'sqcexecute( sqlca=';				nextPutAll: (self sqlcaPointer referentAddress printStringRadix: 16); 			nextPutAll: ', dbno=['; print: self dbNumber; nextPutAll: ']';			nextPutAll: ', stmlen='; print: self preparedQuery size;			nextPutAll: ', stmbuf='; print: self preparedQuery; 			nextPutAll: ', sqlda='; 				nextPutAll: (self sqlda referentAddress printStringRadix: 16); 			nextPutAll: ', parsid=';				print: (self parsid contents);			nextPutAll: ')';			crtab;			nextPutAll: 'status='; print: status.			self class trace: self emitTrace ].	^ status.</body><body package="SupraEXDI" selector="sqcStatement:">sqcStatement: sqlString	" Execute a single SQL Statement on the Connection.		Used for any statement that does not require PREPARE / FETCH."	^ self connection sqcStatement: sqlString.</body></methods><methods><class-id>Database.SupraSession</class-id> <category>private-resources</category><body package="SupraEXDI" selector="allocCommandSqlda">allocCommandSqlda		"Allocate at least a minimum size sqlda,		but try to reuse one we have already allocated."	| numVars ptr |	"We know the true minimum size required for the query."	numVars := queryFragments size quo: 2.	(ptr := self sqlda) isNil		ifTrue: [ self sqlda: (self allocSqlda: (numVars max: self minSqlvarSize)) ]		ifFalse: [			numVars := queryFragments size quo: 2.			numVars &gt; (ptr memberAt: #sqlmax)				ifTrue: [					self sqlda: (self allocSqlda: numVars)			] ]</body><body package="SupraEXDI" selector="allocFetchSqlda">allocFetchSqlda		"Allocate a minimum size sqlda (parsing will resize if required),		but reuse one we have already allocated."	self fetchSqlda isNil		ifTrue: [ self fetchSqlda: (self allocSqlda: self minSqlvarSize) ]</body><body package="SupraEXDI" selector="allocGenericType:">allocGenericType: memSize	" Allocate memory for a generic type of the desired size "	| ptrType |	ptrType := CArrayType new			referentType: CIntegerType char;			numElements: memSize.	^ ptrType perform: self class xif mallocSelector with: 1.</body><body package="SupraEXDI" selector="allocParsid">allocParsid	| xif |	xif := self class xif.	^((xif sqc_tparsid) perform: xif mallocSelector with: 1).</body><body package="SupraEXDI" selector="allocSqlPointerOn:">allocSqlPointerOn: aString	^ (aString copyToHeap: self class xif mallocSelector encoding: self connection encoding)</body><body package="SupraEXDI" selector="allocSqlda:">allocSqlda: sqlvarMax	| xif ptr memSize ptrType |	xif := self class xif.	" Only allocate memory for the desired amount of SQLVARs "	memSize := (xif sqc_daheadertype sizeof) + ((xif sqc_vartype sizeof) * sqlvarMax).	ptrType := self genericType: memSize.	ptr := (ptrType perform: xif mallocSelector with: 1).	" Now cast it as the full structure.		The sqlmax element will keep Supra and us from walking off the end. "	ptr notNil ifTrue: [		ptr :=  xif sqc_dapointertype cast: ptr.		(ptr memberAt: #sqldaid)				copyAt: 0				from: self daTag				size: self daTag size					startingAt: 1.		ptr memberAt: #sqlmax put: sqlvarMax.		].	^ptr.</body><body package="SupraEXDI" selector="freePointerHolder:">freePointerHolder: aValueHolder	aValueHolder value notNil ifTrue: [		aValueHolder value freePointer.		aValueHolder value: nil		]</body><body package="SupraEXDI" selector="genericType:">genericType: memSize	" Allocate memory for a generic type of the desired size "	^ CArrayType new			referentType: CIntegerType char;			numElements: memSize.</body></methods><methods><class-id>Database.SupraSession</class-id> <category>private-accessing</category><body package="SupraEXDI" selector="bindMarkerAt:">bindMarkerAt: aParamIndex	^ queryFragments at: (aParamIndex * 2)</body><body package="SupraEXDI" selector="columnBufferAt:">columnBufferAt: aColumn		| buffer |	buffer := self rowBuffers at: aColumn.	^ buffer at: 1.</body><body package="SupraEXDI" selector="cursorName">cursorName	^cursorName</body><body package="SupraEXDI" selector="cursorName:">cursorName: aValue	cursorName := aValue</body><body package="SupraEXDI" selector="dbNumber">dbNumber	"Answer the active dbNumber -- from the connection."	^self connection dbNumber</body><body package="SupraEXDI" selector="fetchParsid">fetchParsid	^self fetchParsidHolder value</body><body package="SupraEXDI" selector="fetchParsid:">fetchParsid: aCPointerOrNil	| parsid |	"We may need to free the existing space (and drop Supra resources)."	((parsid := self fetchParsidHolder value) notNil and: [parsid referentAddress notNil])		ifTrue: [ self dropParsid: self fetchParsid ].	self fetchParsidHolder value: aCPointerOrNil.</body><body package="SupraEXDI" selector="fetchParsidHolder">fetchParsidHolder	^fetchParsidHolder</body><body package="SupraEXDI" selector="fetchParsidHolder:">fetchParsidHolder: anExternalDatabaseValueHolder	fetchParsidHolder := anExternalDatabaseValueHolder</body><body package="SupraEXDI" selector="fetchPointer">fetchPointer	^self fetchPointerHolder value</body><body package="SupraEXDI" selector="fetchPointer:">fetchPointer: aCPointerOrNil	| ptr |	"We may need to free the existing space."	((ptr := self fetchPointerHolder value) notNil and: [ptr referentAddress notNil])		ifTrue:	 [ ptr free ].	self fetchPointerHolder value: aCPointerOrNil.</body><body package="SupraEXDI" selector="fetchPointerHolder">fetchPointerHolder	^fetchPointerHolder</body><body package="SupraEXDI" selector="fetchPointerHolder:">fetchPointerHolder: aValueHolder	fetchPointerHolder := aValueHolder</body><body package="SupraEXDI" selector="fetchSqlda">fetchSqlda	^self fetchSqldaHolder value</body><body package="SupraEXDI" selector="fetchSqlda:">fetchSqlda: aCPointerOrNil	| sqlda |	"We may need to free the existing space."	((sqlda := self fetchSqldaHolder value) notNil and: [sqlda referentAddress notNil])		ifTrue:	[ sqlda free ].	self fetchSqldaHolder value: aCPointerOrNil.</body><body package="SupraEXDI" selector="fetchSqldaHolder">fetchSqldaHolder	^fetchSqldaHolder</body><body package="SupraEXDI" selector="fetchSqldaHolder:">fetchSqldaHolder: anExternalDatabaseValueHolder	fetchSqldaHolder := anExternalDatabaseValueHolder</body><body package="SupraEXDI" selector="paramBuffers">paramBuffers	"Answer with the receiver's parameter buffers array."	| holder |	(holder := self paramBuffersHolder) value isNil		ifTrue: [ holder value: IdentityDictionary new ].	^holder value</body><body package="SupraEXDI" selector="paramBuffersHolder">paramBuffersHolder	^paramBuffersHolder</body><body package="SupraEXDI" selector="paramBuffersHolder:">paramBuffersHolder: aValueHolder	paramBuffersHolder := aValueHolder</body><body package="SupraEXDI" selector="paramDescriptions">paramDescriptions	^ paramDescriptions</body><body package="SupraEXDI" selector="paramDescriptions:">paramDescriptions: aValue	paramDescriptions := aValue</body><body package="SupraEXDI" selector="parsid">parsid	^self parsidHolder value</body><body package="SupraEXDI" selector="parsid:">parsid: aCPointerOrNil	| parsid |	"We may need to free the existing space (and free Supra resources)."	((parsid := self parsidHolder value) notNil and: [parsid referentAddress notNil])		ifTrue: [ self dropParsid: self parsid ].	self parsidHolder value: aCPointerOrNil.</body><body package="SupraEXDI" selector="parsidHolder">parsidHolder	^parsidHolder</body><body package="SupraEXDI" selector="parsidHolder:">parsidHolder: anExternalDatabaseValueHolder	parsidHolder := anExternalDatabaseValueHolder</body><body package="SupraEXDI" selector="preparedFetch">preparedFetch	^ preparedFetch</body><body package="SupraEXDI" selector="preparedFetch:">preparedFetch: aValue	preparedFetch := aValue</body><body package="SupraEXDI" selector="preparedQuery">preparedQuery	^ preparedQuery</body><body package="SupraEXDI" selector="preparedQuery:">preparedQuery: aValue	preparedQuery := aValue</body><body package="SupraEXDI" selector="resultsCache">resultsCache	"Answer the result from the most recent sqlExecute.	Clear the cache."	| results |	results := resultsCache.	resultsCache := nil.	^results</body><body package="SupraEXDI" selector="resultsCache:">resultsCache: anErrList	"Record the result from the most recent sqcExecute."	resultsCache := anErrList</body><body package="SupraEXDI" selector="rowCount:">rowCount: aValue	"Set the number of rows affected by this query."	rowCount := aValue</body><body package="SupraEXDI" selector="setSqlType">setSqlType	| tokens |	tokens := (self query tokensBasedOn: Character space)				reject: [:aToken | aToken isEmpty].	sqlType := tokens first asLowercase asSymbol.	self isSelect		ifTrue: 			[ | temp |			temp := (tokens at: 2) asLowercase asSymbol.			" The following single row commands return values on EXECUTE				so FETCH is not permitted "			(#( first last next prev direct ) includes: temp)				ifTrue: [sqlType := temp] ].	^sqlType</body><body package="SupraEXDI" selector="sqlPointer">sqlPointer	^self sqlPointerHolder value</body><body package="SupraEXDI" selector="sqlPointer:">sqlPointer: aCPointerOrNil	| ptr |	"We may need to free the existing space."	((ptr := self sqlPointerHolder value) notNil and: [ptr referentAddress notNil])		ifTrue:	[ ptr free ].	self sqlPointerHolder value: aCPointerOrNil.</body><body package="SupraEXDI" selector="sqlPointerHolder">sqlPointerHolder	^sqlPointerHolder</body><body package="SupraEXDI" selector="sqlPointerHolder:">sqlPointerHolder: aValueHolder	sqlPointerHolder := aValueHolder</body><body package="SupraEXDI" selector="sqlca">sqlca	"Answer the active SupraSqlca -- from the connection."	^self connection sqlca</body><body package="SupraEXDI" selector="sqlcaPointer">sqlcaPointer	"Answer the active sqlcaPointer -- from the connection."	^self connection sqlcaPointer</body><body package="SupraEXDI" selector="sqlda">sqlda	^self sqldaHolder value</body><body package="SupraEXDI" selector="sqlda:">sqlda: aCPointerOrNil	| sqlda |	"We may need to free the existing space."	((sqlda := self sqldaHolder value) notNil and: [sqlda referentAddress notNil])		ifTrue:	[ sqlda free ].	self sqldaHolder value: aCPointerOrNil.</body><body package="SupraEXDI" selector="sqldaHolder">sqldaHolder	^sqldaHolder</body><body package="SupraEXDI" selector="sqldaHolder:">sqldaHolder: anExternalDatabaseValueHolder	sqldaHolder := anExternalDatabaseValueHolder</body><body package="SupraEXDI" selector="updateRowCount:">updateRowCount: aValue	"Update the number of rows that the Supra CallInterface reports		were affected by this query.		Once we have stored a real value, reject further changes."	rowCount &lt;= 0		ifTrue: [ rowCount := aValue ]</body></methods><methods><class-id>Database.SupraSession</class-id> <category>private-binding</category><body package="SupraEXDI" selector="bindNameFor:">bindNameFor: position	"Answer the textual name to use as a bind name for the given position."	| strm |	strm := WriteStream on: (String new: 16).	self bindNameFor: position on: strm.	^strm contents</body><body package="SupraEXDI" selector="bindNameFor:on:">bindNameFor: position on: aStream	"Put the textual name to use as a bind name for the given position on aStream."	aStream nextPut: $:.	position isSymbol		ifTrue:			[ aStream nextPutAll: position ]		ifFalse:			[ aStream nextPut: $p.			aStream print: position ]</body><body package="SupraEXDI" selector="bindParameters">bindParameters	self hasInput ifTrue: [		self paramDescriptions keysAndValuesDo: [ :marker :descr | 			| buffer |			buffer := self paramBuffers at: marker.			buffer databaseType ~~ descr databaseType ifTrue: [				self halt: 'incompatible database types'.				].			self paramBufferAt: descr index put: buffer		] ].</body><body package="SupraEXDI" selector="bindValue:at:">bindValue: value at: marker 	"Store aValue at the given marker, and allocate buffer if it does not already exist.		All this does is bind the value to the SupraBuffer.  		Hooking the SupraBuffer to the SQLVAR is deferred until		immediately before execution, in case we needed to re-bind something"	" Blocked buffers are not permitted "	| buffer descr |	value class == Array 		ifTrue: [^self class connectionClass unableToBindSignal raise].	" If bound parameter is there already just set value. "	(buffer := self paramBuffers at: marker ifAbsent: [nil]) notNil 		ifTrue: 			[[buffer value: value] on: self class connectionClass unableToBindSignal				do: 					[:ex | 					self paramBuffers removeKey: marker.					buffer free.					buffer := nil.					ex return]].	" If it does not exist, or we removed it, bind it now "	buffer isNil 		ifTrue: 			[descr := self paramDescriptions at: marker.			buffer := self class bufferClass newOn: descr for: value.			buffer				encoding: self connection encoding;				mallocForParameter;				value: value.			self paramBuffers at: marker put: buffer]</body><body package="SupraEXDI" selector="convertWhitespaceToBlanks:">convertWhitespaceToBlanks: anArray	"substitute blanks for all white space characters"	| whitespace |	whitespace := Set with: Character cr  with: Character lf with: Character tab with: Character newPage.	^ anArray collect: [:char | (whitespace includes: char) ifTrue: [Character space] ifFalse: [char]]</body><body package="SupraEXDI" selector="describeParameters">describeParameters	"Fill in the paramDescriptions array."	| xif lastParam paramIndex sqlvarArray descrs continue curVar varIndex |	self isParameterized 		ifFalse: [  ^ self paramDescriptions: nil ].	xif := self class xif.	lastParam := self sqlda memberAt: #sqln.	paramIndex := 0.	sqlvarArray := self sqlda refMemberAt: #sqlvar.	descrs := IdentityDictionary new.	continue := true.	"Loop until this is set to false."	[ "Begin whileTrue: calculation and test block"		| isOutput |		isOutput := true.		"Loop again if this is true"		[	varIndex := paramIndex.			paramIndex := paramIndex + 1.			(continue := (paramIndex &lt;= lastParam))				ifTrue: [					curVar := sqlvarArray at: varIndex.					" Input&amp;Ouput host variables are combined into one SQLDA						for non-fetchable (ie. single-row) SELECTs "					isOutput := ((curVar memberAt: #colio) == xif sqcoutpar)					].			(isOutput and: [ continue ])			] whileTrue.		continue	] whileTrue:		[ | param |			( param := self class connectionClass columnDescriptionClass new )				sqlvarDef: curVar				index: varIndex				encoding: self connection encoding				maxBytes: self maxLongBytes.			descrs at: (self bindMarkerAt: paramIndex) put: param			].	self paramDescriptions: (paramIndex &gt; 1 ifTrue: [ descrs ] ifFalse: [ nil ]).</body><body package="SupraEXDI" selector="dropParsid:">dropParsid: aParsid	"Release the database resources."	| dbnoPointer parsidString xif status |	aParsid isNil ifTrue: [ ^self ].	xif := self class xif.	[ 		parsidString := aParsid contents.		dbnoPointer := self dbNumber asSmallInteger perform: xif copyToHeapSelector.		status := self sqlcaDo: 			[ xif sqcdropparsid: self sqlcaPointer					with: dbnoPointer 					with: aParsid ]	] 	ensure:	 	[ dbnoPointer == nil 			ifFalse: [ dbnoPointer freePointer ].		aParsid			copyAt: 0			from: (ByteArray new: 6 withAll: 0)			size: 6			startingAt: 1 ].	( traceLevel &gt;= 2 ) ifTrue:		[ (self traceStream)			nextPutAll: 'sqcdropparsid( sqlca=';				nextPutAll: (self sqlcaPointer referentAddress printStringRadix: 16);			nextPutAll: ', dbno=['; print: self dbNumber; nextPutAll: ']'; 			nextPutAll: ', parsid='; print: parsidString;			nextPutAll: ')'; 			crtab;			nextPutAll: 'status='; print: status.		self class trace: self emitTrace ].	^status.</body><body package="SupraEXDI" selector="parseFetch">parseFetch	| xif dbnoPointer sqllenPointer status |	xif := self class xif.	[ " Unwind protection - level 1 (allocating external resources) "		self fetchPointer: (self allocSqlPointerOn: self preparedFetch).		self fetchParsid: self allocParsid.		[ " Unwind protection - level 2 (allocating local resources) "			dbnoPointer := (self dbNumber asSmallInteger) perform: xif copyToHeapSelector.			sqllenPointer := (self preparedFetch size asSmallInteger) perform: xif copyToHeapSelector.			"Parse the query."			status := self sqlcaDo: 				[ xif sqcparse: self sqlcaPointer							with: dbnoPointer							with: sqllenPointer							with: self fetchPointer							with: self fetchSqlda							with: self fetchParsid ]		] " End level 2 Unwind protection "		ensure:		 	[ dbnoPointer == nil ifFalse: [ dbnoPointer freePointer ].			sqllenPointer == nil ifFalse: [ sqllenPointer freePointer ]].		( traceLevel &gt;= 1 ) ifTrue: 			[ (self traceStream)				nextPutAll: 'sqcparse( sqlca=';					nextPutAll: (self sqlcaPointer referentAddress printStringRadix: 16);				nextPutAll: ', dbno=['; print: self dbNumber; nextPutAll: ']';				nextPutAll: ', stmlen='; print: self preparedFetch size;				nextPutAll: ', stmbuf='; print: self preparedFetch;				nextPutAll: ', sqlda=';					nextPutAll: (self fetchSqlda referentAddress printStringRadix: 16);				nextPutAll: ', parsid=';					print: (self fetchParsid contents);				crtab;				nextPutAll: 'status='; print: status.			self class trace: self emitTrace ].	] " End level 1 Unwind protection "	ifCurtailed:		[ self freePointerHolder: self fetchPointerHolder.		self freePointerHolder: self fetchParsidHolder ].	^ status.</body><body package="SupraEXDI" selector="parseFetchResizable">parseFetchResizable	| newSize status |	status := self parseFetch.	status isSqldaTooSmall		ifTrue:			[ " SQLDA is too small - force a resize and try again "			newSize := self fetchSqlda memberAt: #sqln.			self fetchSqlda: (self allocSqlda: newSize).			status := self parseFetch ].	^ status.</body><body package="SupraEXDI" selector="parseQuery">parseQuery	| xif dbnoPointer sqllenPointer status |	xif := self class xif.	[ " Unwind protection - level 1 (allocating external resources) "			self sqlPointer: (self allocSqlPointerOn: self preparedQuery).		self parsid: self allocParsid.		[ " Unwind protection - level 2 (allocating local resources) "			dbnoPointer := (self dbNumber asSmallInteger) perform: xif copyToHeapSelector.			sqllenPointer := (self preparedQuery size asSmallInteger) perform: xif copyToHeapSelector.			"Parse the query."			status := self sqlcaDo: 				[ xif sqcparse: self sqlcaPointer							with: dbnoPointer							with: sqllenPointer							with: self sqlPointer							with: self sqlda							with: self parsid 	]		] " End level 2 Unwind protection "		ensure:			[ dbnoPointer == nil ifFalse: [ dbnoPointer freePointer ].			sqllenPointer == nil ifFalse: [ sqllenPointer freePointer ]].		( traceLevel &gt;= 1 )			ifTrue:				[ (self traceStream)					nextPutAll: 'sqcparse( sqlca=';						nextPutAll: (self sqlcaPointer referentAddress printStringRadix: 16);					nextPutAll: ', dbno=['; print: self dbNumber; nextPutAll: ']';					nextPutAll: ', stmlen='; print: self preparedQuery size;					nextPutAll: ', stmbuf='; print: self preparedQuery;					nextPutAll: ', sqlda=';						nextPutAll: (self sqlda referentAddress printStringRadix: 16);					nextPutAll: ', parsid=';						print: (self parsid contents);					crtab;					nextPutAll: 'status='; print: status.				self class trace: self emitTrace ].	] " End level 1 Unwind protection "	ifCurtailed:		[ self freePointerHolder: self sqlPointerHolder.		self freePointerHolder: self parsidHolder ].	^ status.</body><body package="SupraEXDI" selector="prepareExternal">prepareExternal	"Prepare the query for execution via SQCPARSE.  		Execution is delayed until SQCEXECUTE."	| status |	" Can only physically PARSE Supra DML Statements			(just EXECUTE anything else) "	self isDML ifFalse: [ ^ self ].	status := self prepareQuery.	status hasRetrySQL ifTrue: [self raiseRetryExceptionFor: status]. 	status isError 		ifTrue:	 		[ | signal connClass |				signal := (connClass := self class connectionClass)								perform: (connClass signalMap										at: status sqlCode abs										ifAbsent: [ #unableToPrepareSignal ]).				signal					raiseWith: (Array with: status)					errorString: (' \' withCRs, status dbmsErrorString)]</body><body package="SupraEXDI" selector="prepareQuery">prepareQuery	| cmdStatus fetStatus |	" We need the SQLDA for any further processing of this query.		Allocate sufficient SQLVARs to handle all host variables. "	self allocCommandSqlda.	self cursorName: self defaultCursorTag, (self sqlda referentAddress printStringRadix: 16).	self storeQuery.	self isFetchable 		ifTrue:			[ " Start with an estimated number of SQLVARs.				Parsing will resize the SQLDA as necessary. "			self allocFetchSqlda.			self storeFetch ].	(cmdStatus := self parseQuery) isSuccess 		ifTrue:			[ self describeParameters.			self isFetchable				ifTrue: [ fetStatus := self parseFetchResizable ]].	" If we did the fetch, that is the relevant status to return "	^ fetStatus isNil ifTrue: [ cmdStatus ] ifFalse: [ fetStatus ].</body><body package="SupraEXDI" selector="releaseBindings">releaseBindings	| holder |	(holder := self paramBuffersHolder value) notNil ifTrue:		[ holder do:			[ :each |			each notNil ifTrue: [ each free ] ].		self paramBuffersHolder value: nil ].	self paramDescriptions: nil.	self freePointerHolder: self sqlPointerHolder.	self preparedQuery: nil.	self freePointerHolder: self fetchPointerHolder.	self preparedFetch: nil.	super releaseBindings</body><body package="SupraEXDI" selector="setupQuery:">setupQuery: aString	"Set up query to be parsed, and determine its command type"	super setupQuery: aString.	self setSqlType.</body><body package="SupraEXDI" selector="startPrepare">startPrepare	super startPrepare.	sqlType := self defaultSqlType.</body><body package="SupraEXDI" selector="storeFetch">storeFetch		" Store the SQL command in external memory.		The command must be available throughout execution because the DRDM		could require the CallInterface to parse it again under certain conditions.		If so, a new PARSID is also returned. "	self preparedFetch: 'FFETCH ', self cursorName, ' USING DESCRIPTOR '.</body><body package="SupraEXDI" selector="storeQuery">storeQuery		" Store the SQL command in external memory.		The command must be available throughout execution because the DRDM		could require the CallInterface to parse it again under certain conditions.		If so, a new PARSID is also returned. "	| sqlStream |	sqlStream := WriteStream on: (String new: self query size * 2).	self isFetchable ifTrue: [		" Prefix to treat SELECT as a fetchable cursor -			we use this form so that the SELECT is allowed duplicate column names "		sqlStream nextPutAll: 'DECLARE ' , self cursorName, ' CURSOR FOR '.		].	sqlStream nextPutAll: (queryFragments at: 1).	queryFragments size == 1 ifFalse: 		[  2 to: queryFragments size by: 2 do: [ :index | 				sqlStream nextPutAll: (self bindNameFor: (queryFragments at: index));				nextPutAll: (queryFragments at: index + 1)			]].	" We need the following to make the result set size available,			but there will be a penalty since the entire thing			must be allocated in TMPSPACE "	self isForReuse 		ifTrue: [ 	sqlStream nextPutAll: ' FOR REUSE' ].	self preparedQuery: sqlStream contents.</body></methods><methods><class-id>Database.SupraSession</class-id> <category>data processing</category><body package="SupraEXDI" selector="bindVariable:">bindVariable: marker	"Answer the value of a SQL variable bound to marker."	| buffer |	buffer := self paramBuffers at: marker ifAbsent: [ nil ].	buffer isNil ifTrue:		[  ^self connection class missingBindVariableSignal raise ].	^buffer value</body><body package="SupraEXDI" selector="bindVariable:value:">bindVariable: marker value: value	"Set the value of a SQL variable.		value is restricted to objects of the classes 			{String, Text, ByteArray, Integer, Double, Float, FixedPoint, Date, Time, Timestamp} 	"	| type |	" Blocked buffers are not permitted "	value class == Array		ifTrue: [ ^ self class connectionClass unableToBindSignal raise ].	type := value supraConversion.	self bindVariable: marker value: value type: type size: nil</body><body package="SupraEXDI" selector="bindVariable:value:type:size:">bindVariable: marker value: value type: type size: size 	"Set the value of a SQL variable.		value is restricted to objects of the classes 			{String, Text, ByteArray, Integer, Double, Float, FixedPoint, Date, Time, Timestamp} 		type is restricted to the Symbols 			{String, ByteArray, Integer, Double, Float, FixedPoint, Date, Time, Timestamp} 		If size is nil, use a default."	" Blocked buffers are not permitted "	| buffer descr |	value class == Array 		ifTrue: [^self class connectionClass unableToBindSignal raise].	" If bound parameter is there already just set value. "	(buffer := self paramBuffers at: marker ifAbsent: [nil]) notNil 		ifTrue: 			[[buffer value: value] on: self class connectionClass unableToBindSignal				do: 					[:ex | 					self paramBuffers removeKey: marker.					buffer free.					buffer := nil.					ex return]].	" If it does not exist, or we removed it, bind or pre-bind it now "	buffer isNil 		ifTrue: 			[self paramDescriptions notNil 				ifTrue: 					["bind it using Description"					descr := self paramDescriptions at: marker.					buffer := self class bufferClass newOn: descr for: value]				ifFalse: 					["pre-bind it using value only"					buffer := self class bufferClass 								newFor: value								type: type								size: size].			buffer				encoding: self connection encoding;				mallocForParameter;				value: value.			self paramBuffers at: marker put: buffer].	self bindInput at: marker put: value</body></methods><methods><class-id>Database.SupraSession</class-id> <category>accessing</category><body package="SupraEXDI" selector="blockFactor:">blockFactor: aSmallInteger	"For Supra V2, the blockFactor can only be 1.  		The CallInterface performs its own internal blocking with FFETCH.		One call to the database will yield a buffer containing multiple rows		which can only be fetched (locally) one at a time."	blockFactor := aSmallInteger min: 1</body><body package="SupraEXDI" selector="forReuse">forReuse	"Sets session enforcement of select processing using the 'FOR REUSE' clause.		In this mode, the entire result set is copied in tempspace, and		the number of rows can be determined.  In addition the result set 		remains unchanged while the underlying table(s) are available for		modification by this or another task."	"This is the default.  It allows correct reporting of result set size, but there is	a memory/performance penalty.  For large tables, or to avoid a complete table scan,	set #notForReuse."	reUse := true</body><body package="SupraEXDI" selector="maxLongBytes">maxLongBytes	"Answer the maximum number of bytes which will be	fetched for a LONG VARCHAR field."	^maxLongBytes</body><body package="SupraEXDI" selector="maxLongBytes:">maxLongBytes: aSmallInteger	"Set the maximum number of bytes which should be	fetched for a LONG VARCHAR field.  If the application	expects more than the default number of bytes, this value	should be increased.  If the application expects fewer bytes,	some savings in memory use may be achieved by reducing this	number."	"2 is the smallest number of bytes which can be bound for a column"	maxLongBytes := 2 max: aSmallInteger</body><body package="SupraEXDI" selector="minSqlvarSize">minSqlvarSize	"Answer the minimum number of SQLVARs which will be		allocated in an SQLDA."	minSqlvarSize isNil 		ifTrue: [ minSqlvarSize := self class defaultSqlvarSize ].	^minSqlvarSize</body><body package="SupraEXDI" selector="minSqlvarSize:">minSqlvarSize: aSmallInteger	"Set the minimum number of SQLVARs which will be		allocated in an SQLDA.		If the application expects more than the default number of 		parameters or columns, this value should be increased.  If the		application expects fewer columns, some savings in memory 		use may be achieved by reducing this number."	minSqlvarSize := aSmallInteger</body><body package="SupraEXDI" selector="notForReuse">notForReuse	"Turns off session enforcement of select processing using the 'FOR REUSE' clause.		In this mode, the result set is not copied into tempspace, and		therefore the number of rows can not be determined."	"Use this mode for large tables, or to avoid a complete table scan.  See also,	#forReuse."	reUse := false</body><body package="SupraEXDI" selector="numParameters">numParameters	^ self paramDescriptions isNil ifTrue: [ 0 ] ifFalse: [ self paramDescriptions size ].</body><body package="SupraEXDI" selector="query">query	"Supra will accept BLANK white space only, not CR, CRLF, TAB, etc.		Override to handle white space conversions"		^ self convertWhitespaceToBlanks: super query.</body><body package="SupraEXDI" selector="rowCount">rowCount	"Answer the number of rows that the Supra CallInterface reports were affected by this query.		This will be the number or rows inserted, updated, or deleted,		or the 	number of rows in the result set.		A value of -1 indicates the true count is unknown."	^rowCount</body></methods><methods><class-id>Database.SupraSession</class-id> <category>private-answer set</category><body package="SupraEXDI" selector="advanceExternal">advanceExternal	"Fetch a row. The Supra CallInterface manages its own row blocking		with FFETCH, but only one row can be locally retrieved at a time.		If the buffer is exhausted, the CallInterface will refill it and continue."	| status |	status := self sqcFetch.	status isRowNotFound 		ifTrue: [ ^ nil ].	status isError 		ifTrue: [ | signal connClass |			signal := (connClass := self class connectionClass)						perform: (connClass signalMap								at: status sqlCode abs								ifAbsent: [ #unableToFetchDataSignal ]).			signal				raiseWith: (Array with: status)				errorString: (' \' withCRs, status dbmsErrorString) ].</body><body package="SupraEXDI" selector="allocateRowBufferExternal:">allocateRowBufferExternal: aColumn	"Allocate a SupraBuffer to receive data for aColumn.  Answer the buffer."	| colDescr buffer |	colDescr := self columnDescriptions at: aColumn.	buffer := (self class bufferClass newOn: colDescr)				encoding: self connection encoding;				mallocForRowBuffer.	self columnBufferAt: aColumn put: buffer.	^buffer</body><body package="SupraEXDI" selector="answerOfClass:">answerOfClass: anAnswerStreamClass	"Answer an instance of the given subclass of ExternalDatabaseAnswerStream"	"Assert: anAnswerStreamClass isKindOf: ExternalDatabaseAnswerStream"	| initialAnswer |	initialAnswer := ( self state == #ready ).	self state: #validResults.	initialAnswer		ifTrue:	[ "Verify that the query executed without error."				self resultsExternal ifFalse: [ ^#noAnswerStream ] ]		ifFalse:	[ "If we're still holding on to a prior answer stream, dismiss it."				answerStream notNil					ifTrue:	[ answerStream close ].				"Assert: self state == #validResults"				self moreResultsExternal					ifFalse:	[ self state: #prepared.							^#noMoreAnswers ] ].	self hasAnswerSetExternal		ifTrue:	[ | answer |				initialAnswer ifFalse:					[ "Previous descriptions/buffers are no longer valid"					self releaseBuffers.					self releaseAdaptors.					self columnDescriptions: nil ].				self getColumnDescriptions.				self acquireBuffers.				self setupAdaptors.				self aboutToAnswer.				answer := anAnswerStreamClass newForSession: self.				self answerStream: answer.				self state: #fetchingData.				^answer ].	^#noAnswerStream.</body><body package="SupraEXDI" selector="answerStreamDismissed">answerStreamDismissed	"The answer stream is being dismissed, normally because it is exhausted.	We should close the named cursor"	self closeCursor.	super answerStreamDismissed.</body><body package="SupraEXDI" selector="cancelAnswerSetExternal">cancelAnswerSetExternal	"Release any resources that must be explicitly released."	( self state == #fetchingData ) ifFalse:		[ ^self ].	" close cursor, maybe ?? "</body><body package="SupraEXDI" selector="describeAnswerColumns">describeAnswerColumns	"Fill in the columnDescriptions array."	|  xif outSqlda lastColumn colIndex sqlvarArray descrs continue curVar varIndex |	xif := self class xif.	outSqlda := self isFetchable ifTrue: [self fetchSqlda] ifFalse: [self sqlda].	lastColumn := outSqlda memberAt: #sqln.	colIndex := 0.	sqlvarArray := outSqlda refMemberAt: #sqlvar.	descrs := Array new writeStream.	continue := true.	"Loop until this is set to false."	[ "Begin whileTrue: calculation and test block"		| isInput |		isInput := true.		"Loop again if this is false"		[	varIndex := colIndex.			colIndex := colIndex + 1.			(continue := (colIndex &lt;= lastColumn))				ifTrue: [					curVar := sqlvarArray at: varIndex.					" Input&amp;Ouput host variables are combined into one SQLDA						for non-fetchable (ie. single-row) SELECTs "					isInput := ((curVar memberAt: #colio) == xif sqcinppar)					].			(isInput and: [ continue ])			] whileTrue.		continue	] whileTrue:		[ | col |			( col := self class connectionClass columnDescriptionClass new )				sqlvarDef: curVar				index: varIndex				encoding: self connection encoding				maxBytes: self maxLongBytes.			descrs nextPut: col			].	self columnDescriptions: (colIndex &gt; 1 ifTrue: [ descrs contents ] ifFalse: [ nil ]).	self numColumns: (colIndex - 1).</body><body package="SupraEXDI" selector="getColumnDescriptionExternal:">getColumnDescriptionExternal: aColumn	"Folded into describeAnswerColumns for efficiency."	^self shouldNotImplement</body><body package="SupraEXDI" selector="getFieldExternal:">getFieldExternal: aColumn	"Answer the data for the aColumn-th column in the current row."	| indicator |	indicator := self columnIndicatorAt: aColumn.	"Check for null"	indicator &lt; 0 ifTrue: [ ^ nil ].	"Check for truncation"	indicator &gt; 0 ifTrue: [		self class connectionClass truncatedParameterSignal				parameter: aColumn;				raiseRequest		].	^self columnBufferAt: aColumn.</body><body package="SupraEXDI" selector="hasAnswerSetExternal">hasAnswerSetExternal	^#( select first last next prev direct ) includes: sqlType</body><body package="SupraEXDI" selector="sqcFetch">sqcFetch	"Execute the prepared FETCH statement."	| xif dbnoPointer stmlenPointer status |	xif := self class xif.	[ 		dbnoPointer := self dbNumber asSmallInteger copyToHeap.		stmlenPointer := self preparedFetch size asSmallInteger copyToHeap.		status := self sqlcaDo:			[ xif sqcexecute: self sqlcaPointer					with: dbnoPointer 					with: stmlenPointer 					with: self fetchPointer					with: self fetchSqlda					with: self fetchParsid ]	] 	ensure:		[ dbnoPointer == nil ifFalse: [ dbnoPointer freePointer ].		stmlenPointer == nil ifFalse: [ stmlenPointer freePointer ]].	( traceLevel &gt;= 2 ) ifTrue:		[ (self traceStream)			nextPutAll: 'sqcexecute[FETCH]( sqlca=';				nextPutAll: (self sqlcaPointer referentAddress printStringRadix: 16); 			nextPutAll: ', dbno=['; print: self dbNumber; nextPutAll: ']';			nextPutAll: ', stmlen='; print: self preparedFetch size;			nextPutAll: ', stmbuf='; print: self preparedFetch; 			nextPutAll: ', sqlda='; 				nextPutAll: (self fetchSqlda referentAddress printStringRadix: 16); 			nextPutAll: ', parsid=';				print: (self fetchParsid contents);			nextPutAll: ')';			crtab;			nextPutAll: 'status='; print: status.			self class trace: self emitTrace ].	^ status.</body></methods><methods><class-id>Database.SupraSession</class-id> <category>private-pointer access</category><body package="SupraEXDI" selector="columnBufferAt:put:">columnBufferAt: aColumn put: buffer 		| curSqlvar |	curSqlvar := self outVarRefAt: aColumn.	curSqlvar memberAt: #hostvaraddr put: buffer pointer referentAddress.	curSqlvar memberAt: #hostvartype put: buffer hostvarType.</body><body package="SupraEXDI" selector="columnIndicatorAt:">columnIndicatorAt: aColumn 		| curSqlvar |	curSqlvar := self outVarRefAt: aColumn.	^curSqlvar memberAt: #hostindicator.</body><body package="SupraEXDI" selector="columnScaleAt:">columnScaleAt: aColumn 		| curSqlvar |	curSqlvar := self outVarRefAt: aColumn.	^curSqlvar memberAt: #colfrac.</body><body package="SupraEXDI" selector="columnTypeAt:">columnTypeAt: aColumn 		| curSqlvar |	curSqlvar := self outVarRefAt: aColumn.	^curSqlvar memberAt: #coltype.</body><body package="SupraEXDI" selector="inVarRefAt:">inVarRefAt: varIndex 	" Answer pointer to input SQLVAR for this column		both IN &amp; OUT host variables are combined on a single SQLVAR		for single row FETCH commands "		^ (self sqlda refMemberAt: #sqlvar) refAt: varIndex.</body><body package="SupraEXDI" selector="outVarRefAt:">outVarRefAt: aColumn 	" Answer pointer to correct output SQLVAR for this column		both IN &amp; OUT host variables are combined on a single SQLVAR		for single row FETCH commands "		| outSqlda varIndex |	outSqlda := self isFetchable				ifTrue:		[ self fetchSqlda ]				ifFalse:	[ self sqlda ].	varIndex := (self columnDescriptions at: aColumn) index.	^ (outSqlda refMemberAt: #sqlvar) refAt: varIndex.</body><body package="SupraEXDI" selector="paramBufferAt:put:">paramBufferAt: varIndex put: buffer 		| curSqlvar |	((buffer isNull) and: [ buffer isNullable not ])		ifTrue: [ ^ self class connectionClass missingBindVariableSignal raise ].	curSqlvar := self inVarRefAt: varIndex.	buffer isNull 		ifTrue:		[ 			curSqlvar memberAt: #hostindicator put: -1.		"null" ]		ifFalse:	[ 			curSqlvar memberAt: #collength put: buffer elementSize.			curSqlvar memberAt: #colfrac put: buffer scale.			curSqlvar memberAt: #hostvaraddr put: buffer pointer referentAddress.			curSqlvar memberAt: #hostvartype put: buffer hostvarType.			curSqlvar memberAt: #hostindicator put: 0.		"not null" ].</body></methods><methods><class-id>Database.SupraSession</class-id> <category>private-command strings</category><body package="SupraEXDI" selector="constructedCloseString">constructedCloseString	^ 'CLOSE ', self cursorName.</body></methods><methods><class-id>Database.SupraSession</class-id> <category>private-defaults</category><body package="SupraEXDI" selector="daTag">daTag	^String defaultPlatformClass fromString: 'SQCDA   '.</body><body package="SupraEXDI" selector="defaultCursorName">defaultCursorName	^self defaultCursorTag, 'default'</body><body package="SupraEXDI" selector="defaultCursorTag">defaultCursorTag	^'VW_CRSR@'</body><body package="SupraEXDI" selector="defaultSqlType">defaultSqlType	^#none</body></methods><methods><class-id>Database.SupraSession</class-id> <category>private-finalization</category><body package="SupraEXDI" selector="executor">executor	"Answer with the executor."	| ex |	ex := super executor.	ex connection: self connection.	ex parsidHolder: self parsidHolder.	ex fetchParsidHolder: self fetchParsidHolder.	ex cursorName: self cursorName.	^ex</body><body package="SupraEXDI" selector="finalizeExternal">finalizeExternal	"Release all external resources."	self releaseBuffersAndAdaptors.	self releaseBindings.	( traceLevel &gt;= 1 ) ifTrue: [ self class trace: nil ].	super finalizeExternal</body><body package="SupraEXDI" selector="key">key	"The sqldaHolder is unique to the session and is constant	across pause/resume."	^self sqldaHolder</body></methods><methods><class-id>Database.SupraSession</class-id> <category>private-testing</category><body package="SupraEXDI" selector="hasInput">hasInput	^ self paramDescriptions notNil</body><body package="SupraEXDI" selector="isDML">isDML	^#( select insert update delete )  includes: sqlType</body><body package="SupraEXDI" selector="isFetchable">isFetchable	"Only a true row set SELECT is Fetchable"	^self isSelect</body><body package="SupraEXDI" selector="isForReuse">isForReuse	^ (reUse) and: [ self isSelect ]</body><body package="SupraEXDI" selector="isParameterized">isParameterized	^ queryFragments size &gt; 1</body><body package="SupraEXDI" selector="isSelect">isSelect	^ #( select )  includes: sqlType</body></methods><methods><class-id>Database.SupraSession</class-id> <category>printing</category><body package="SupraEXDI" selector="printOn:">printOn: aStream	super printOn: aStream.	self cursorName isEmpty ifFalse:		[ aStream			nextPutAll: '( cursorName=', self cursorName, ' )' ]</body></methods><methods><class-id>Database.SupraSession</class-id> <category>private-thread safe</category><body package="SupraEXDI" selector="sqlcaDo:">sqlcaDo: aBlock 	" All execution performed through connection "	^ self connection sqlcaDo: aBlock</body><body package="SupraEXDI" selector="sqldaDo:">sqldaDo: aBlock 	"control access to single sqlda for this Session"	^aBlock value</body></methods><methods><class-id>Database.SupraSession</class-id> <category>initialize-release</category><body package="SupraEXDI" selector="initialize">initialize	super initialize.	blockFactor := 1.	maxLongBytes := 2048.	reUse := true.	cursorName := self defaultCursorName.	sqlType := self defaultSqlType.	preparedQuery := ''.	sqlPointerHolder := nil asValue.	sqldaHolder := nil asValue.	parsidHolder := nil asValue.	preparedFetch := ''.	resultsCache := nil.	fetchPointerHolder := nil asValue.	fetchSqldaHolder := nil asValue.	fetchParsidHolder := nil asValue.	paramBuffersHolder := nil asValue.</body></methods><methods><class-id>Database.SupraSession class</class-id> <category>private-accessing</category><body package="SupraEXDI" selector="bufferClass">bufferClass	^SupraBuffer</body><body package="SupraEXDI" selector="connectionClass">connectionClass	^SupraConnection</body><body package="SupraEXDI" selector="defaultSqlvarSize">defaultSqlvarSize	"Answer a default number of columns for the result set."	^20</body></methods><methods><class-id>Database.SupraSession class</class-id> <category>class initialization</category><body package="SupraEXDI" selector="initialize">initialize	"SupraSession initialize"	self initRegistry.</body></methods><methods><class-id>Database.SupraSession class</class-id> <category>private-registry</category><body package="SupraEXDI" selector="registry">registry	^RegisteredSupraSessions</body><body package="SupraEXDI" selector="registry:">registry: aCollection	RegisteredSupraSessions := aCollection</body></methods><methods><class-id>Database.SupraSession class</class-id> <category>private-activation</category><body package="SupraEXDI" selector="install">install	self bufferClass install.</body></methods><methods><class-id>Database.SupraInterface</class-id> <category>accessing</category><body package="SupraEXDI" selector="copyToHeapSelector">copyToHeapSelector	^#copyToHeap</body><body package="SupraEXDI" selector="encoding">encoding	^ #default</body><body package="SupraEXDI" selector="gcMallocSelector">gcMallocSelector	^#gcMalloc:</body><body package="SupraEXDI" selector="mallocSelector">mallocSelector	^#malloc:</body><body package="SupraEXDI" selector="unsupported">unsupported	^ nil</body></methods><methods><class-id>Database.SupraInterface</class-id> <category>initialize-release</category><body package="SupraEXDI" selector="initialize">initialize	" override to exclude initialize in Object "</body></methods><methods><class-id>Database.SupraInterface</class-id> <category>defines</category><body package="SupraEXDI" selector="__DATE__">__DATE__	&lt;C: #define __DATE__ "June 12, 2000"	&gt;</body><body package="SupraEXDI" selector="__FILE__">__FILE__	&lt;C: #define __FILE__ 	&gt;</body><body package="SupraEXDI" selector="__LINE__">__LINE__	&lt;C: #define __LINE__ 0	&gt;</body><body package="SupraEXDI" selector="__STDC__">__STDC__	&lt;C: #define __STDC__ 1	&gt;</body><body package="SupraEXDI" selector="__TIME__">__TIME__	&lt;C: #define __TIME__ "4:07:29 pm"	&gt;</body><body package="SupraEXDI" selector="sqcarglinelengthmax">sqcarglinelengthmax	&lt;C: #define sqcarglinelengthmax 132	&gt;</body><body package="SupraEXDI" selector="sqcbyte">sqcbyte	&lt;C: #define sqcbyte 3	&gt;</body><body package="SupraEXDI" selector="sqcchar">sqcchar	&lt;C: #define sqcchar 2	&gt;</body><body package="SupraEXDI" selector="sqccxatypelengthmax">sqccxatypelengthmax	&lt;C: #define sqccxatypelengthmax 100	&gt;</body><body package="SupraEXDI" selector="sqcdate">sqcdate	&lt;C: #define sqcdate 4	&gt;</body><body package="SupraEXDI" selector="sqcdbascii">sqcdbascii	&lt;C: #define sqcdbascii 9	&gt;</body><body package="SupraEXDI" selector="sqcdbebcdic">sqcdbebcdic	&lt;C: #define sqcdbebcdic 10	&gt;</body><body package="SupraEXDI" selector="sqcdbnamelengthmax">sqcdbnamelengthmax	&lt;C: #define sqcdbnamelengthmax 64	&gt;</body><body package="SupraEXDI" selector="sqcdbyte">sqcdbyte	&lt;C: #define sqcdbyte 9	&gt;</body><body package="SupraEXDI" selector="sqcfixed">sqcfixed	&lt;C: #define sqcfixed 0	&gt;</body><body package="SupraEXDI" selector="sqcfloat">sqcfloat	&lt;C: #define sqcfloat 1	&gt;</body><body package="SupraEXDI" selector="sqcgatypelengthmax">sqcgatypelengthmax	&lt;C: #define sqcgatypelengthmax 1052	&gt;</body><body package="SupraEXDI" selector="sqcinppar">sqcinppar	&lt;C: #define sqcinppar 0	&gt;</body><body package="SupraEXDI" selector="sqcmatypelengthmax">sqcmatypelengthmax	&lt;C: #define sqcmatypelengthmax 4100	&gt;</body><body package="SupraEXDI" selector="sqcmftypelengthmax">sqcmftypelengthmax	&lt;C: #define sqcmftypelengthmax 7228	&gt;</body><body package="SupraEXDI" selector="sqcnamelengthmax">sqcnamelengthmax	&lt;C: #define sqcnamelengthmax 18	&gt;</body><body package="SupraEXDI" selector="sqcoutpar">sqcoutpar	&lt;C: #define sqcoutpar 1	&gt;</body><body package="SupraEXDI" selector="sqcparsidlength">sqcparsidlength	&lt;C: #define sqcparsidlength 6	&gt;</body><body package="SupraEXDI" selector="sqcpasswordlengthmax">sqcpasswordlengthmax	&lt;C: #define sqcpasswordlengthmax 18	&gt;</body><body package="SupraEXDI" selector="sqcratypelengthmax">sqcratypelengthmax	&lt;C: #define sqcratypelengthmax 8308	&gt;</body><body package="SupraEXDI" selector="sqcstmbufferlengthmax">sqcstmbufferlengthmax	&lt;C: #define sqcstmbufferlengthmax 8240	&gt;</body><body package="SupraEXDI" selector="sqcstring">sqcstring	&lt;C: #define sqcstring 6	&gt;</body><body package="SupraEXDI" selector="sqctime">sqctime	&lt;C: #define sqctime 5	&gt;</body><body package="SupraEXDI" selector="sqctimestamp">sqctimestamp	&lt;C: #define sqctimestamp 8	&gt;</body><body package="SupraEXDI" selector="sqcundef">sqcundef	&lt;C: #define sqcundef 1	&gt;</body><body package="SupraEXDI" selector="sqcuserlengthmax">sqcuserlengthmax	&lt;C: #define sqcuserlengthmax 8	&gt;</body><body package="SupraEXDI" selector="sqcvalue">sqcvalue	&lt;C: #define sqcvalue 0	&gt;</body><body package="SupraEXDI" selector="sqcvartypelengthmax">sqcvartypelengthmax	&lt;C: #define sqcvartypelengthmax 300	&gt;</body><body package="SupraEXDI" selector="sqcvchar">sqcvchar	&lt;C: #define sqcvchar 7	&gt;</body><body package="SupraEXDI" selector="sqcvfchar">sqcvfchar	&lt;C: #define sqcvfchar 6	&gt;</body><body package="SupraEXDI" selector="sqcvint2">sqcvint2	&lt;C: #define sqcvint2 0	&gt;</body><body package="SupraEXDI" selector="sqcvint4">sqcvint4	&lt;C: #define sqcvint4 1	&gt;</body><body package="SupraEXDI" selector="sqcvreal4">sqcvreal4	&lt;C: #define sqcvreal4 2	&gt;</body><body package="SupraEXDI" selector="sqcvreal8">sqcvreal8	&lt;C: #define sqcvreal8 3	&gt;</body><body package="SupraEXDI" selector="sqcvstring">sqcvstring	&lt;C: #define sqcvstring 15	&gt;</body><body package="SupraEXDI" selector="sqcvuns2">sqcvuns2	&lt;C: #define sqcvuns2 16	&gt;</body><body package="SupraEXDI" selector="sqcvuns4">sqcvuns4	&lt;C: #define sqcvuns4 17	&gt;</body><body package="SupraEXDI" selector="sqcvzoned">sqcvzoned	&lt;C: #define sqcvzoned 5	&gt;</body></methods><methods><class-id>Database.SupraInterface</class-id> <category>types</category><body package="SupraEXDI" selector="sqc_argline">sqc_argline	&lt;C: typedef char sqc_argline[132]&gt;</body><body package="SupraEXDI" selector="sqc_c12">sqc_c12	&lt;C: typedef char sqc_c12[12]&gt;</body><body package="SupraEXDI" selector="sqc_c70">sqc_c70	&lt;C: typedef char sqc_c70[70]&gt;</body><body package="SupraEXDI" selector="sqc_c8">sqc_c8	&lt;C: typedef char sqc_c8[8]&gt;</body><body package="SupraEXDI" selector="sqc_catype">sqc_catype	&lt;C: typedef struct _catype sqc_catype&gt;</body><body package="SupraEXDI" selector="sqc_cxatype">sqc_cxatype	&lt;C: typedef char sqc_cxatype[100]&gt;</body><body package="SupraEXDI" selector="sqc_daheadertype">sqc_daheadertype	&lt;C: typedef struct _daheadertype sqc_daheadertype&gt;</body><body package="SupraEXDI" selector="sqc_dapointertype">sqc_dapointertype	&lt;C: typedef struct _datype * sqc_dapointertype&gt;</body><body package="SupraEXDI" selector="sqc_datype">sqc_datype	&lt;C: typedef struct _datype sqc_datype&gt;</body><body package="SupraEXDI" selector="sqc_dbname">sqc_dbname	&lt;C: typedef char sqc_dbname[64]&gt;</body><body package="SupraEXDI" selector="sqc_gatype">sqc_gatype	&lt;C: typedef char sqc_gatype[1052]&gt;</body><body package="SupraEXDI" selector="sqc_int2">sqc_int2	&lt;C: typedef short sqc_int2&gt;</body><body package="SupraEXDI" selector="sqc_int4">sqc_int4	&lt;C: typedef long sqc_int4&gt;</body><body package="SupraEXDI" selector="sqc_matype">sqc_matype	&lt;C: typedef char sqc_matype[4100]&gt;</body><body package="SupraEXDI" selector="sqc_mftype">sqc_mftype	&lt;C: typedef char sqc_mftype[7228]&gt;</body><body package="SupraEXDI" selector="sqc_name">sqc_name	&lt;C: typedef char sqc_name[18]&gt;</body><body package="SupraEXDI" selector="sqc_password">sqc_password	&lt;C: typedef char sqc_password[18]&gt;</body><body package="SupraEXDI" selector="sqc_r4">sqc_r4	&lt;C: typedef float sqc_r4&gt;</body><body package="SupraEXDI" selector="sqc_r8">sqc_r8	&lt;C: typedef double sqc_r8&gt;</body><body package="SupraEXDI" selector="sqc_ratype">sqc_ratype	&lt;C: typedef char sqc_ratype[8308]&gt;</body><body package="SupraEXDI" selector="sqc_statement_buffer">sqc_statement_buffer	&lt;C: typedef char sqc_statement_buffer[8240]&gt;</body><body package="SupraEXDI" selector="sqc_tparsid">sqc_tparsid	&lt;C: typedef char sqc_tparsid[6]&gt;</body><body package="SupraEXDI" selector="sqc_user">sqc_user	&lt;C: typedef char sqc_user[8]&gt;</body><body package="SupraEXDI" selector="sqc_vartype">sqc_vartype	&lt;C: typedef struct _vartype sqc_vartype&gt;</body><body package="SupraEXDI" selector="text">text	&lt;C: typedef void * text&gt;</body></methods><methods><class-id>Database.SupraInterface</class-id> <category>structs</category><body package="SupraEXDI" selector="_catype">_catype	&lt;C: struct _catype {			sqc_int4 sqlenv;			char sqlcaid[8];			sqc_int4 sqlcabc, sqlcode;			sqc_int2 sqlfiller1, sqlerrml;			char sqlerrmc[70];			sqc_int2 sqlmfetch;			char sqlerrp[8];			sqc_int4 sqlerrd1, sqlerrd2, sqlerrd3, sqlerrd4, sqlerrd5, sqlerrd6;			char sqlwarn0, sqlwarn1, sqlwarn2, sqlwarn3, sqlwarn4, sqlwarn5, sqlwarn6, sqlwarn7, sqlwarn8, sqlwarn9, sqlwarna, sqlwarnb, sqlwarnc, sqlwarnd, sqlwarne, sqlwarnf;			sqc_int2 sqlcursor, sqlpfkey, sqlrowno, sqlcolno;			char sqlext[12];			sqc_int4 sqltraceno;			char sqltracefn[64];			sqc_int2 sqltracety, sqlconntyp;			sqc_argline sqlargl;			sqc_gatype sqlga;			sqc_matype sqlma;			sqc_ratype sqlra;			sqc_mftype sqlmf;			sqc_cxatype sqlcxa;		}&gt;</body><body package="SupraEXDI" selector="_daheadertype">_daheadertype	&lt;C: struct _daheadertype {			char sqldaid[8];			sqc_int4 sqlmax;			sqc_int2 sqln, sqld, sqlfill1, sqlfill2;		}&gt;</body><body package="SupraEXDI" selector="_datype">_datype	&lt;C: struct _datype {			char sqldaid[8];			sqc_int4 sqlmax;			sqc_int2 sqln, sqld, sqlfill1, sqlfill2;			struct _vartype sqlvar[300];		}&gt;</body><body package="SupraEXDI" selector="_vartype">_vartype	&lt;C: struct _vartype {			sqc_name colname;			sqc_int2 colio, colmode, coltype, collength, colfrac, hostindicator, hostvartype;			void * hostvaraddr;			sqc_c8 colinfo;		}&gt;</body></methods><methods><class-id>Database.SupraInterface class</class-id> <category>instance creation</category><body package="SupraEXDI" selector="new">new	^super new initialize</body></methods><methods><class-id>Database.SupraSqlca</class-id> <category>private-resources</category><body package="SupraEXDI" selector="acquireSession">acquireSession	" Find and reserve an open slot in sqlcaSessions.		Return slot number on SQLCA. "	1 to: self class maxConnects do: [ :idx | 		(sqlcaSessions at: idx) == 0			ifTrue: [				sqlcaSessions at: idx put: 1.				^idx ] ].	"Return nil if none available"	^nil</body><body package="SupraEXDI" selector="caTag">caTag	^String defaultPlatformClass fromString: 'SQCCA   '.</body><body package="SupraEXDI" selector="releaseSession:">releaseSession: anIndex	" Release slot number on SQLCA. "	sqlcaSessions at: anIndex put: 0.</body><body package="SupraEXDI" selector="sqlcaDo:">sqlcaDo: aBlock 	" Control execution access to single sqlca structure "	self sqlcode: 0.	aBlock value.	^self getStatus</body></methods><methods><class-id>Database.SupraSqlca</class-id> <category>private-tracing</category><body package="SupraEXDI" selector="defaultTraceFileName">defaultTraceFileName	^Filename expandEnvironmentIn: '$(VISUALWORKS)\exdi_t2.log'</body><body package="SupraEXDI" selector="setTraceParams">setTraceParams	self supraTraceLevel ~~ 0		ifTrue: [ 			(self sqlca refMemberAt: #sqlcxa)				copyAt: 50 				from: (ByteArray new: 2 withAll: 0) 				size: 2 				startingAt: 1.			self sqltraceno: 0.			self sqltracety: self supraTraceLevel.			self sqltracefn: self defaultTraceFileName.			].</body><body package="SupraEXDI" selector="supraTraceLevel">supraTraceLevel	^ self class supraTraceLevel.</body></methods><methods><class-id>Database.SupraSqlca</class-id> <category>initialize-release</category><body package="SupraEXDI" selector="allocSqlca">allocSqlca	| xif |	xif := self class xif.	sqlcaPointer := ((xif sqc_catype) perform: xif mallocSelector with: 1).	self sqlca notNil ifTrue: [		(self sqlca memberAt: #sqlcaid)				copyAt: 0				from: self caTag				size: self caTag size					startingAt: 1.		].</body><body package="SupraEXDI" selector="freeSqlca">freeSqlca	sqlcaPointer freePointer.	sqlcaPointer := nil.</body><body package="SupraEXDI" selector="initialize">initialize		index := self class registry size + 1.	self allocSqlca.	sqlcaSessions := ByteArray new: self class maxConnects withAll: 0.	self class register: self.</body></methods><methods><class-id>Database.SupraSqlca</class-id> <category>data processing</category><body package="SupraEXDI" selector="getStatus">getStatus	" Answer a SupraStatus instance to describe (and save)		the status of the just completed CallInterface request.		Data in the sqlca is valid only until it is used for next request. "	^ SupraStatus newFrom: self.</body></methods><methods><class-id>Database.SupraSqlca</class-id> <category>accessing</category><body package="SupraEXDI" selector="key">key		^ index</body><body package="SupraEXDI" selector="sqlca">sqlca	^sqlcaPointer</body><body package="SupraEXDI" selector="sqlcode">sqlcode	^ self sqlca memberAt: #sqlcode</body><body package="SupraEXDI" selector="sqlcode:">sqlcode: aSmallInteger	self sqlca memberAt: #sqlcode put: aSmallInteger</body><body package="SupraEXDI" selector="sqlerrd3">sqlerrd3 	"^ (self sqlca memberAt: #sqlerrd) at: 3." 	^ self sqlca memberAt: #sqlerrd3.</body><body package="SupraEXDI" selector="sqlerrmc">sqlerrmc	| buf len aString |	buf := self sqlca refMemberAt: #sqlerrmc.	len := self sqlca memberAt: #sqlerrml.	aString := String new: len.	buf 		copyAt: 0 		to: aString 		size: len 		startingAt: 1.	^ aString trimBlanks.</body><body package="SupraEXDI" selector="sqlwarn0">sqlwarn0	^ (self sqlca memberAt: #sqlwarn0) asCharacter asLowercase</body><body package="SupraEXDI" selector="warningCode">warningCode	"Extract warning code from current contents of SQLCA"	(self sqlca memberAt: #sqlwarn1) asCharacter asLowercase == #w 		ifTrue: [ ^1 ].	(self sqlca memberAt: #sqlwarn2) asCharacter asLowercase == #w 		ifTrue: [ ^2 ].	(self sqlca memberAt: #sqlwarn3) asCharacter asLowercase == #w 		ifTrue: [ ^3 ].	(self sqlca memberAt: #sqlwarn4) asCharacter asLowercase == #w 		ifTrue: [ ^4 ].	(self sqlca memberAt: #sqlwarne) asCharacter asLowercase == #w 		ifTrue: [ ^15 ].	(self sqlca memberAt: #sqlwarnf) asCharacter asLowercase == #w 		ifTrue: [ ^16 ].</body></methods><methods><class-id>Database.SupraSqlca</class-id> <category>private-accessing</category><body package="SupraEXDI" selector="sqltracefn:">sqltracefn: aString	| fName |	fName := self sqlca refMemberAt: #sqltracefn.	fName 		copyAt: 0 		from: (aString asByteArray copyWith: 0) 		size: (aString size + 1) 		startingAt: 1.</body><body package="SupraEXDI" selector="sqltraceno:">sqltraceno: aSmallInteger	self sqlca memberAt: #sqltraceno put: aSmallInteger</body><body package="SupraEXDI" selector="sqltracety:">sqltracety: aSmallInteger	self sqlca memberAt: #sqltracety put: aSmallInteger</body></methods><methods><class-id>Database.SupraSqlca</class-id> <category>private-execution</category><body package="SupraEXDI" selector="installExternal">installExternal		self allocSqlca.	sqlcaSessions := ByteArray new: self class maxConnects withAll: 0.</body></methods><methods><class-id>Database.SupraSqlca class</class-id> <category>external API</category><body package="SupraEXDI" selector="acquireSqlcaSlot">acquireSqlcaSlot	" Answer the first open SQLCA slot.		Allocate an additional SQLCA if there are no 		currently open slots. "		| slot anSqlca |	self registry do: [ :each |		(slot := each acquireSession) notNil ifTrue: [ ^ slot ].		].		" Nothing found yet, we need an additional SQLCA "	anSqlca := self new.	self register: anSqlca.	" Return the virtual slot number (of the total possible) "	slot := anSqlca acquireSession.	^ slot + ((anSqlca key - 1) * (self maxConnects)).</body><body package="SupraEXDI" selector="dbNumberFor:">dbNumberFor: virtualSlot 	"Answer the adjusted sqlca session index for the virtual index slot."	^ virtualSlot \\ self maxConnects</body><body package="SupraEXDI" selector="registryKeyFor:">registryKeyFor: virtualSlot 	"Answer registry key for the virtual index slot."	^ (virtualSlot quo: self maxConnects) + 1</body><body package="SupraEXDI" selector="releaseSqlcaSlot:">releaseSqlcaSlot: virtualSlot	" Release the SQLCA slot for the virtual index. "	| ca |	(ca := self sqlcaForSlotNumber: virtualSlot) notNil 		ifTrue: [ ca releaseSession: (self dbNumberFor: virtualSlot) ].</body><body package="SupraEXDI" selector="sqlcaForSlotNumber:">sqlcaForSlotNumber: virtualSlot 	"Answer the SupraSqlca from the registry 		which contains the virtual index slot."	^self registry at: (self registryKeyFor: virtualSlot) ifAbsent: [ nil ]</body></methods><methods><class-id>Database.SupraSqlca class</class-id> <category>private-accessing</category><body package="SupraEXDI" selector="connectionClass">connectionClass	^SupraConnection</body><body package="SupraEXDI" selector="maxConnects">maxConnects	^ 8</body><body package="SupraEXDI" selector="supraTraceLevel">supraTraceLevel	SupraTraceLevel isNil ifTrue: [		SupraTraceLevel := 0 ].	^ SupraTraceLevel.</body><body package="SupraEXDI" selector="xif">xif	^ self connectionClass xif.</body></methods><methods><class-id>Database.SupraSqlca class</class-id> <category>private-registry</category><body package="SupraEXDI" selector="initRegistry">initRegistry	"Initialize the registry to the proper form of collection."	self registry: HandleRegistry new.</body><body package="SupraEXDI" selector="register:">register: sender	"Register the sender."	| registry |	^(registry := self registry) notNil		ifTrue: [ registry register: sender ]</body><body package="SupraEXDI" selector="registry">registry	^ RegisteredSupraSqlcaList</body><body package="SupraEXDI" selector="registry:">registry: aCollection	RegisteredSupraSqlcaList := aCollection</body><body package="SupraEXDI" selector="unregister:">unregister: obj 	"Remove the argument from the active registry."	| registry |	(registry := self registry) isNil		ifFalse: [registry unregister: obj]</body></methods><methods><class-id>Database.SupraSqlca class</class-id> <category>instance creation</category><body package="SupraEXDI" selector="new">new	^ super new initialize.</body></methods><methods><class-id>Database.SupraSqlca class</class-id> <category>tracing API</category><body package="SupraEXDI" selector="disableSupraTracing">disableSupraTracing	"Disable tracing in the Supra Call/Interface"	"SupraSqlca disableSupraTracing"		Transcript cr.	Transcript show: (#supraTracing &lt;&lt; #database &gt;&gt; 'Supra tracing ').	SupraTraceLevel := 0.	Transcript show: (#disabled &lt;&lt; #database &gt;&gt; 'disabled').	Transcript cr; flush.</body><body package="SupraEXDI" selector="enableSupraExtendedTracing">enableSupraExtendedTracing	"Enable precompiler TRACE LONG in the Supra Call/Interface"	"SupraSqlca enableSupraExtendedTracing"	Transcript cr.	Transcript show: (#supraExtendedTracing &lt;&lt; #database &gt;&gt; 'Supra extended tracing ').	SupraTraceLevel := 3.	Transcript show: (#enabled &lt;&lt; #database &gt;&gt; 'enabled').	Transcript cr; flush.</body><body package="SupraEXDI" selector="enableSupraTracing">enableSupraTracing	"Enable precompiler TRACE in the Supra Call/Interface"	"SupraSqlca enableSupraTracing"	Transcript cr.	Transcript show: (#supraStandardTracing &lt;&lt; #database &gt;&gt; 'Supra standard tracing ').	SupraTraceLevel := 2.	Transcript show: (#enabled &lt;&lt; #database &gt;&gt; 'enabled').	Transcript cr; flush.</body></methods><methods><class-id>Database.SupraSqlca class</class-id> <category>private-activation</category><body package="SupraEXDI" selector="install">install	self registry registerAllValuesOf: [ self registry collect: [ :ea | ea installExternal ] ].</body></methods><methods><class-id>Database.SupraSqlca class</class-id> <category>class initialization</category><body package="SupraEXDI" selector="initialize">initialize	"self initialize"	self initRegistry.</body></methods><methods><class-id>Database.SupraColumnDescription</class-id> <category>private-accessing</category><body package="SupraEXDI" selector="databaseType">databaseType	^databaseType</body><body package="SupraEXDI" selector="databaseType:">databaseType: anInteger	databaseType := anInteger</body></methods><methods><class-id>Database.SupraColumnDescription</class-id> <category>initialize-release</category><body package="SupraEXDI" selector="displaySizeFor:precision:max:">displaySizeFor: dbType precision: precis max: maxBytes		dbType == 0 ifTrue: ["FIXED"		^precis + 3 ].	dbType == 1 ifTrue: ["FLOAT"		^precis + 6 ].	((dbType == 2) or: [dbType == 3]) ifTrue: ["CHAR or CHAR BYTE"		^(precis max: maxBytes) ].	(((dbType == 4) or: [dbType == 5]) or: [dbType == 8]) ifTrue: ["DATE or TIME or TIMESTAMP"		^precis ].		"Return 0 for unsupported hostvarType"	^0</body><body package="SupraEXDI" selector="sqlvarDef:index:encoding:maxBytes:">sqlvarDef: curVar index: varIndex encoding: encoding maxBytes: maxBytes	 | extName internalType internalSize colNameLen colName |	colNameLen := 18 "sqcnamelengthmax".	colName := String primitiveArgumentClass new: colNameLen.	extName := curVar memberAt: #colname.	1 to: colNameLen do: [ :idx |		colName at: idx put: (extName at: (idx -1)).		].	colName := (colName asStringEncoding: encoding) trimBlanks.	self		index: varIndex;		name: colName;		databaseType: (internalType := curVar memberAt: #coltype);		type: (self class typeFor: internalType);		precision: (internalSize := curVar memberAt: #collength);		scale: (curVar memberAt: #colfrac);		nullable: ((curVar memberAt: #colmode) == 1 "sqcundef");		maxColumnConstraint: (self displaySizeFor: internalType precision: internalSize max: maxBytes).</body></methods><methods><class-id>Database.SupraColumnDescription class</class-id> <category>class initialization</category><body package="SupraEXDI" selector="initialize">initialize	"SupraColumnDescription initialize"	(InternalDatatypeToClassMap := IdentityDictionary new)		add: (  0 "FIXED" -&gt; #FixedPoint );		add: (  1 "FLOAT" -&gt; #Double );		add: (  2 "CHAR" -&gt; #String );		add: (  3 "BYTE" -&gt; #ByteArray );		add: (  4 "DATE" -&gt; #Date );		add: (  5 "TIME" -&gt; #Time );		add: (  8 "TIMESTAMP" -&gt; #Timestamp ).</body></methods><methods><class-id>Database.SupraColumnDescription class</class-id> <category>private-accessing</category><body package="SupraEXDI" selector="typeFor:">typeFor: aDatabaseType	"Answer the class which is equivalent to the database type: aDatabaseType."	| typeSymbol |	(typeSymbol := InternalDatatypeToClassMap at: aDatabaseType ifAbsent: [ nil ] ) notNil		ifTrue:	[ ^self environment at: typeSymbol ifAbsent: [ nil ] ].	^nil</body></methods><methods><class-id>Database.InvalidSelectTable</class-id> <category>initialize-release</category><body package="SupraEXDI" selector="initializeInsertColumnNames">initializeInsertColumnNames		| aStream |	aStream := self sqlString readStream.	aStream 		skipToAll: '(';		skip: 1.	insertColumnNames := ((aStream upToAll: ')') reject: [ :ea | ea = $  ]) tokensBasedOn: $,</body><body package="SupraEXDI" selector="initializeResultName">initializeResultName	resultName := 'CSI#', (self originator class name copyFrom: 1 to: 10), '_', (self originator hash printString).</body><body package="SupraEXDI" selector="initializeSelectColumnNames">initializeSelectColumnNames		| aStream |	aStream := self sqlString readStream.	aStream 		skipToAll: 'SELECT';		skip: 6.	selectColumnNames := ((aStream upToAll: 'FROM') reject: [ :ea | ea = $  ]) tokensBasedOn: $,</body><body package="SupraEXDI" selector="initializeTableName">initializeTableName		| aStream |	aStream := self sqlString readStream.	aStream 		skipToAll: 'INTO';		skip: 4.	tableName := (aStream upToAll: '(') trimBlanks.</body><body package="SupraEXDI" selector="initializeWhere">initializeWhere		| aStream |	aStream := self sqlString readStream.	aStream 		skipToAll: 'WHERE';		skip: 5.	where := (aStream upToEnd) trimBlanks.</body></methods><methods><class-id>Database.InvalidSelectTable</class-id> <category>hack-restricted sql</category><body package="SupraEXDI" selector="closeResultSql">closeResultSql	| closeStream |	closeStream := (String new: 50) writeStream.	closeStream		nextPutAll: 'CLOSE ';		nextPutAll: self resultName.	^ closeStream contents.</body><body package="SupraEXDI" selector="insertSql">insertSql	| insertStream |	insertStream := (String new: 150) writeStream.	insertStream		nextPutAll: 'INSERT INTO ';		nextPutAll: self tableName;		nextPut: $(.	self insertColumnNames do: [ :col |		insertStream			nextPutAll: col; 			nextPutAll: ', ' ].	insertStream 		skip: -2;		nextPutAll: ') SELECT '.	1 to: self selectColumnNames size do: [ :idx |		insertStream			nextPutAll: 'column';			nextPutAll: idx printString;			nextPutAll: ', ' ].	insertStream		skip: -2;		nextPutAll: ' FROM ';		nextPutAll: self resultName.	^ insertStream contents.</body><body package="SupraEXDI" selector="retrySQL">retrySQL	self initializeTableName.	self initializeInsertColumnNames.	self initializeSelectColumnNames.	self initializeWhere.	self initializeResultName.	^ OrderedCollection with: self selectSql with: self insertSql with: self closeResultSql.</body><body package="SupraEXDI" selector="selectSql">selectSql	| selectStream |	selectStream := (String new: 150) writeStream.	selectStream		nextPutAll: 'SELECT ';		nextPutAll: self resultName;		nextPut: $(.	1 to: self selectColumnNames size do: [ :idx |		selectStream 			nextPutAll: 'column';			nextPutAll: idx printString;			nextPut: $=;			nextPutAll: (self selectColumnNames at: idx);			nextPutAll: ', ' ].	selectStream 		skip: -2;		nextPutAll: ') FROM ';		nextPutAll: self tableName;		nextPutAll: ' WHERE ';		nextPutAll: self where;		nextPutAll: ' FOR REUSE'.	^ selectStream contents.</body></methods><methods><class-id>Database.InvalidSelectTable</class-id> <category>printing</category><body package="SupraEXDI" selector="defaultMessageText">defaultMessageText	^#invalidSelectTable &lt;&lt; #supraDB &gt;&gt; 'Insert table not allowed in Select.\Replace query with SQL statements from #retrySQL' withCRs.</body></methods><methods><class-id>Database.InvalidSelectTable</class-id> <category>accessing</category><body package="SupraEXDI" selector="insertColumnNames">insertColumnNames	^insertColumnNames</body><body package="SupraEXDI" selector="resultName">resultName	^resultName</body><body package="SupraEXDI" selector="selectColumnNames">selectColumnNames	^selectColumnNames</body><body package="SupraEXDI" selector="tableName">tableName	^tableName</body><body package="SupraEXDI" selector="where">where	^where</body></methods><methods><class-id>Database.StatementTooComplicated</class-id> <category>hack-restricted sql</category><body package="SupraEXDI" selector="generatedStatements">generatedStatements		| statement |	^ self keys collect:		[:each |		statement := (String new: 50) writeStream.		statement			nextPutAll: self baseSQLFragment;			nextPut: $ ;			nextPutAll: self columnName.		(each first) = (each at: 2) ifTrue:			[statement nextPutAll: ' = ']		ifFalse:			[statement				nextPutAll: ' BETWEEN ';				nextPutAll: each first;				nextPutAll: ' AND '].		statement nextPutAll: (each at: 2).		statement contents].</body><body package="SupraEXDI" selector="retrySQL">retrySQL	" This hack only works for complex IN clauses, and only for		SQL statements that can be reconstructed as a series of		independently executable statements 		- as in DELETE, INSERT or UPDATE and not SELECT. "	self initializeColumnName.	self initializeBaseSQLFragment.	self initializeKeys.	self groupKeys.	^ self generatedStatements.</body></methods><methods><class-id>Database.StatementTooComplicated</class-id> <category>initialize-release</category><body package="SupraEXDI" selector="groupKeys">groupKeys		| groups group |	groups := OrderedCollection new.	group := nil.	keys do:		[ :each |		group isNil ifFalse:			[each asNumber = ((group at: 2) asNumber + 1) ifTrue:				["Contiguous to current group, update current group"				group at: 2 put: each]			ifFalse:				["Not contiguous, close current group"				groups add: group.				group := nil]].		group isNil ifTrue:			["New group"			group := Array new: 2.			group at: 1 put: each.			group at: 2 put: each]].	group isNil ifFalse: [groups add: group].	keys := groups.</body><body package="SupraEXDI" selector="initializeBaseSQLFragment">initializeBaseSQLFragment	| aStream |	aStream := self sqlString readStream.	baseSQLFragment := (aStream upToAll: self columnName) trimBlanks.</body><body package="SupraEXDI" selector="initializeColumnName">initializeColumnName		| aStream |	aStream := self sqlString readStream.	aStream 		skipToAll: 'WHERE';		skip: 5.	columnName := (aStream upToAll: 'IN') trimBlanks.</body><body package="SupraEXDI" selector="initializeKeys">initializeKeys		| aStream |	aStream := self sqlString readStream.	aStream 		skipToAll: 'WHERE';		skip: 5;		skipToAll: self columnName;		skip: self columnName size;		skipToAll: 'IN';		skip: 2;		skipToAll: '(';		skip: 1.	keys := ((aStream upToAll: ')') reject: [ :ea | ea = $  ]) tokensBasedOn: $,.	keys := keys collect: [ :ea | ea asNumber].	SequenceableCollectionSorter sort: keys.	keys := keys collect: [ :ea | ea printString].</body><body package="SupraEXDI" selector="testMe">testMe		self sqlString: 'DELETE FROM TW_METHODS WHERE primaryKey IN ( 1, 10, 2, 7, 14, 13, 5, 3, 4, 12 , 8, 11, 34)'.	^ self generatedStatements.</body></methods><methods><class-id>Database.StatementTooComplicated</class-id> <category>accessing</category><body package="SupraEXDI" selector="baseSQLFragment">baseSQLFragment	^baseSQLFragment</body><body package="SupraEXDI" selector="columnName">columnName	^columnName</body><body package="SupraEXDI" selector="keys">keys	^keys</body></methods><methods><class-id>Database.StatementTooComplicated</class-id> <category>printing</category><body package="SupraEXDI" selector="defaultMessageText">defaultMessageText	^#statementTooComplicated &lt;&lt; #supraDB &gt;&gt; 'Statement is too complicated.'.</body></methods><methods><class-id>Database.FetchBufferIncompatible</class-id> <category>printing</category><body package="SupraEXDI" selector="defaultMessageText">defaultMessageText	^#fetchBufferIncompatible &lt;&lt; #supraDB &gt;&gt; 'Buffer size or type incompatible with fetch column value.'.</body></methods><methods><class-id>Database.KeyUpdateNotAllowed</class-id> <category>initialize-release</category><body package="SupraEXDI" selector="initializeInsertColumnNames">initializeInsertColumnNames	"Needs updateColumns and where to be initialized."	| whereStream column columnStream name value |	insertColumnNames := Dictionary new.	whereStream := where readStream.	[whereStream atEnd]		whileFalse:			[column := (whereStream upToAll: 'AND') trimBlanks.			whereStream atEnd 	ifFalse: [whereStream skip: 3].			columnStream := column readStream.			name := (columnStream upTo: $=) trimBlanks.					value := columnStream upToEnd trimBlanks.					insertColumnNames at: name put: value].	self updateColumnNames do:		[:each |		columnStream := each readStream.		name := (columnStream upTo: $=) trimBlanks.				value := columnStream upToEnd trimBlanks.				insertColumnNames at: name put: value].</body><body package="SupraEXDI" selector="initializeTableName">initializeTableName		| aStream |	aStream := self sqlString readStream.	aStream 		skipToAll: 'UPDATE';		skip: 6.	tableName := (aStream upToAll: 'SET') trimBlanks.</body><body package="SupraEXDI" selector="initializeUpdateColumnNames">initializeUpdateColumnNames		| aStream |	aStream := self sqlString readStream.	aStream 		skipToAll: 'SET';		skip: 3.	updateColumnNames := ((aStream upToAll: 'WHERE') reject: [ :ea | ea = $  ]) tokensBasedOn: $,</body><body package="SupraEXDI" selector="initializeWhere">initializeWhere		| aStream |	aStream := self sqlString readStream.	aStream 		skipToAll: 'WHERE';		skip: 5.	where := (aStream upToEnd) trimBlanks.</body></methods><methods><class-id>Database.KeyUpdateNotAllowed</class-id> <category>hack-restricted sql</category><body package="SupraEXDI" selector="deleteSql">deleteSql	| deleteStream |	deleteStream := (String new: 50) writeStream.	deleteStream		nextPutAll: 'DELETE FROM ';		nextPutAll: self tableName;		nextPutAll: ' WHERE ';		nextPutAll: self where.	^ deleteStream contents.</body><body package="SupraEXDI" selector="insertSql">insertSql	| insertStream |	insertStream := (String new: 150) writeStream.	insertStream		nextPutAll: 'INSERT INTO ';		nextPutAll: self tableName;		nextPutAll: ' SET '.	self insertColumnNames associationsDo: [ :col |		insertStream			nextPutAll: col key; 			nextPut: $=; 			nextPutAll: col value; 			nextPutAll: ', ' ].	insertStream 		skip: -2.	^ insertStream contents.</body><body package="SupraEXDI" selector="retrySQL">retrySQL	self initializeTableName.	self initializeUpdateColumnNames.	self initializeWhere.	self initializeInsertColumnNames.	^ OrderedCollection with: self insertSql with: self deleteSql.</body></methods><methods><class-id>Database.KeyUpdateNotAllowed</class-id> <category>printing</category><body package="SupraEXDI" selector="defaultMessageText">defaultMessageText	^#keyUpdateNotAllowed &lt;&lt; #supraDB &gt;&gt; 'Key update is not allowed.'.</body></methods><methods><class-id>Database.KeyUpdateNotAllowed</class-id> <category>accessing</category><body package="SupraEXDI" selector="insertColumnNames">insertColumnNames	^insertColumnNames</body><body package="SupraEXDI" selector="tableName">tableName	^tableName</body><body package="SupraEXDI" selector="updateColumnNames">updateColumnNames	^updateColumnNames</body><body package="SupraEXDI" selector="where">where	^where</body></methods><methods><class-id>Core.Integer</class-id> <category>private-supra</category><body package="SupraEXDI" selector="supraConversion">supraConversion	^#Integer</body></methods><methods><class-id>Core.String</class-id> <category>private-supra</category><body package="SupraEXDI" selector="supraConversion">supraConversion	^#String</body></methods><methods><class-id>Core.String</class-id> <category>converting</category><body package="SupraEXDI" selector="trimBlanks">trimBlanks	"Return a copy of the receiver that has leading and trailing blanks removed."	| size index space |	(size := self size) == 0 ifTrue: [^self].	index := 1.	space := Character space.	[(self at: index)		= space]		whileTrue: 			[index = size ifTrue: [^''].			index := index + 1].	[(self at: size)		= space]		whileTrue: 			[index = size ifTrue: [^''].			size := size - 1].	^self copyFrom: index to: size</body></methods><methods><class-id>Core.Object</class-id> <category>private-supra</category><body package="SupraEXDI" selector="supraConversion">supraConversion	^nil</body></methods><methods><class-id>Core.FixedPoint</class-id> <category>private-supra</category><body package="SupraEXDI" selector="supraConversion">supraConversion	" ^#FixedPoint "	" Not allowed at this time. "	" StORE uses #printString to build the SQL String,		but Supra cannot parse 23.55s as a numeric value. "	self notYetImplemented.	self halt: 'Not valid for Supra.'</body></methods><methods><class-id>Core.ByteArray</class-id> <category>private-supra</category><body package="SupraEXDI" selector="supraConversion">supraConversion	^#ByteArray</body></methods><methods><class-id>Core.Double</class-id> <category>private-supra</category><body package="SupraEXDI" selector="supraConversion">supraConversion	^#Double</body></methods><methods><class-id>Core.Timestamp class</class-id> <category>private-supra</category><body package="SupraEXDI" selector="readFromSupraString:">readFromSupraString: aString	"Answer a Timestamp as read from Supra format string (YYYYDDMM:HHHHMMSS[FF]). "	^(TimestampReader newFor: #supra) readTimestampFrom: aString readStream.</body></methods><methods><class-id>Core.Timestamp</class-id> <category>private-supra</category><body package="SupraEXDI" selector="asSupraString">asSupraString	^ (TimestampPrintPolicy print: self using: #'yyyymmdd:00hhmmss') string</body><body package="SupraEXDI" selector="supraConversion">supraConversion	^#Timestamp</body></methods><methods><class-id>Core.Time class</class-id> <category>private-supra</category><body package="SupraEXDI" selector="readFromSupraString:">readFromSupraString: aString	"Answer a Time as read from Supra format string ([HHH]HMMSS). "	^(TimestampReader newFor: #supra) readTimeFrom: aString readStream.</body></methods><methods><class-id>Core.Time</class-id> <category>private-supra</category><body package="SupraEXDI" selector="asSupraString">asSupraString	^ (TimestampPrintPolicy print: self using: #'00hhmmss') string</body><body package="SupraEXDI" selector="supraConversion">supraConversion	^#Time</body></methods><methods><class-id>Core.Text</class-id> <category>private-supra</category><body package="SupraEXDI" selector="supraConversion">supraConversion	^#String</body></methods><methods><class-id>Core.Float</class-id> <category>private-supra</category><body package="SupraEXDI" selector="supraConversion">supraConversion	^#Float</body></methods><methods><class-id>Core.Date class</class-id> <category>private-supra</category><body package="SupraEXDI" selector="readFromSupraString:">readFromSupraString: aString	"Answer a Date as read from Supra format string (YYYYMMDD). "	^(TimestampReader newFor: #supra) readDateFrom: aString readStream.</body></methods><methods><class-id>Core.Date</class-id> <category>private-supra</category><body package="SupraEXDI" selector="asSupraString">asSupraString	^(TimestampPrintPolicy print: self using: #yyyymmdd) string</body><body package="SupraEXDI" selector="supraConversion">supraConversion	^#Date</body></methods><methods><class-id>Core.TimestampReader</class-id> <category>private-supra</category><body package="SupraEXDI" selector="getSupraToken:size:">getSupraToken: aStream size: size	| peek str |	aStream atEnd		ifTrue: [self error: (#errEndOfTimestampData &lt;&lt; #dialogs &gt;&gt; 'End of data encountered without finding an expected part of the date')].	str := ReadWriteStream on: (String new: size).	1 to: size do: [	:idx |		peek := aStream peek.		peek notNil			ifTrue: [str nextPut: aStream next].		].	^Integer readFrom: str reset.</body><body package="SupraEXDI" selector="readSupraDateFrom:">readSupraDateFrom: stream	"Answer a Date read from the argument aStream in the form:		YYYYMMDD (all digits are required)"	| day month year |	stream atEnd ifTrue: [ ^nil ].	year := self getSupraToken: stream size: 4.	month := self getSupraToken: stream size: 2.	day :=  self getSupraToken: stream size: 2.	^Date newDay: day monthNumber: month year: year</body><body package="SupraEXDI" selector="readSupraTimeFrom:">readSupraTimeFrom: stream	"Answer a Time read from the argument aStream in the form:		[HHH]HMMSS 		(1,2, 3 or 4 digits for hours)"	| hour minute second hSize |	stream atEnd ifTrue: [ ^nil ].	" Calculate number of digits for hours.		Limit to 4, since we might get the stream from a Timestamp "	hSize := 4 min: (4 - (8 - (stream size))).	hour := self getSupraToken: stream size: hSize.	minute := self getSupraToken: stream size: 2.	second :=  self getSupraToken: stream size: 2.	^Time fromSeconds: 60*(60*hour+minute)+second</body><body package="SupraEXDI" selector="readSupraTimestampFrom:">readSupraTimestampFrom: stream	"Answer a Timestamp read from stream, 	which we expect to contain a Date in Supra format		YYYYMMDD,	and an optional Time in Supra format 		00HHMMSS  ( all 4 digits are required for hours).	The Time may be followed by two optional additional digits,	which we interpret as milliseconds."	| date time milliseconds timestamp |	stream atEnd ifTrue: [ ^nil ].	date := self readDateFrom: stream.	date isNil ifTrue: [ ^nil ].	stream skipSeparators.	milliseconds := 0.	stream atEnd		ifTrue: [time := Time fromSeconds: 0]		ifFalse:			[time := self readTimeFrom: stream.			stream atEnd				ifFalse:					[milliseconds := Integer readFrom: stream]].	timestamp := Timestamp new fromDate: date andTime: time.	timestamp millisecond: milliseconds rounded.	^timestamp</body><body package="SupraEXDI" selector="supra">supra	timeSelector := #readSupraTimeFrom:.	dateSelector := #readSupraDateFrom:.	timestampSelector := #readSupraTimestampFrom:.</body></methods><methods><class-id>Database.SupraInterface</class-id> <category>procedures</category><body package="SupraEXDI" selector="sqcccharbind:with:with:with:with:with:">sqcccharbind: sqcca with: sqlvarno with: varlen with: varcchar with: sqcda with: sqcerr	&lt;C: pascal void sqcccharbind(sqc_catype * sqcca, short * sqlvarno, short * varlen, unsigned char * varcchar, sqc_datype * sqcda, short * sqcerr)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="SupraEXDI" selector="sqccharbind:with:with:with:with:with:">sqccharbind: sqcca with: sqlvarno with: varlen with: varchar with: sqcda with: sqcerr	&lt;C: pascal void sqccharbind(sqc_catype * sqcca, short * sqlvarno, short * varlen, unsigned char * varchar, sqc_datype * sqcda, short * sqcerr)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="SupraEXDI" selector="sqccommand:with:with:with:with:">sqccommand: sqcca with: sqcmode with: sqcstmtlen with: sqcstmtbuf with: sqcresult	&lt;C: pascal void sqccommand(sqc_catype * sqcca, short * sqcmode, short * sqcstmtlen, unsigned char * sqcstmtbuf, short * sqcresult)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="SupraEXDI" selector="sqcconnect:with:with:with:with:with:with:">sqcconnect: sqcca with: sqcdbno with: sqcdbname with: sqcstmtlen with: sqcstmtbuf with: sqcuser with: sqcpassw	&lt;C: pascal void sqcconnect(sqc_catype * sqcca, short * sqcdbno, unsigned char * sqcdbname, short * sqcstmtlen, unsigned char * sqcstmtbuf, unsigned char * sqcuser, unsigned char * sqcpassw)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="SupraEXDI" selector="sqcdecbind:with:with:with:with:with:with:">sqcdecbind: sqcca with: sqlvarno with: varlen with: decfrac with: vardec with: sqcda with: sqcerr	&lt;C: pascal void sqcdecbind(sqc_catype * sqcca, short * sqlvarno, short * varlen, short * decfrac, unsigned char * vardec, sqc_datype * sqcda, short * sqcerr)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="SupraEXDI" selector="sqcdropparsid:with:with:">sqcdropparsid: sqcca with: sqcdbno with: sqcparsid	&lt;C: pascal void sqcdropparsid(sqc_catype * sqcca, short * sqcdbno, unsigned char * sqcparsid)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="SupraEXDI" selector="sqcexecute:with:with:with:with:with:">sqcexecute: sqcca with: sqcdbno with: sqcstmtlen with: sqcstmtbuf with: sqcda with: sqcparsid	&lt;C: pascal void sqcexecute(sqc_catype * sqcca, short * sqcdbno, short * sqcstmtlen, unsigned char * sqcstmtbuf, sqc_datype * sqcda, unsigned char * sqcparsid)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="SupraEXDI" selector="sqcfinish:">sqcfinish: sqcca	&lt;C: pascal void sqcfinish(sqc_catype * sqcca)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="SupraEXDI" selector="sqcgetinfo:with:with:with:with:">sqcgetinfo: sqcca with: sqlvarno with: sqlvarinfo with: sqcda with: sqcerr	&lt;C: pascal void sqcgetinfo(sqc_catype * sqcca, short * sqlvarno, sqc_vartype * sqlvarinfo, sqc_datype * sqcda, short * sqcerr)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="SupraEXDI" selector="sqcint2bind:with:with:with:with:">sqcint2bind: sqcca with: sqlvarno with: varint2 with: sqcda with: sqcerr	&lt;C: pascal void sqcint2bind(sqc_catype * sqcca, short * sqlvarno, short * varint2, sqc_datype * sqcda, short * sqcerr)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="SupraEXDI" selector="sqcint4bind:with:with:with:with:">sqcint4bind: sqcca with: sqlvarno with: varint4 with: sqcda with: sqcerr	&lt;C: pascal void sqcint4bind(sqc_catype * sqcca, short * sqlvarno, long * varint4, sqc_datype * sqcda, short * sqcerr)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="SupraEXDI" selector="sqcparse:with:with:with:with:with:">sqcparse: sqcca with: sqcdbno with: sqcstmtlen with: sqcstmtbuf with: sqcda with: sqcparsid	&lt;C: pascal void sqcparse(sqc_catype * sqcca, short * sqcdbno, short * sqcstmtlen, unsigned char * sqcstmtbuf, sqc_datype * sqcda, unsigned char * sqcparsid)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="SupraEXDI" selector="sqcputinfo:with:with:with:with:">sqcputinfo: sqcca with: sqlvarno with: sqlvarinfo with: sqcda with: sqcerr	&lt;C: pascal void sqcputinfo(sqc_catype * sqcca, short * sqlvarno, sqc_vartype * sqlvarinfo, sqc_datype * sqcda, short * sqcerr)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="SupraEXDI" selector="sqcr4bind:with:with:with:with:">sqcr4bind: sqcca with: sqlvarno with: varreal4 with: sqcda with: sqcerr	&lt;C: pascal void sqcr4bind(sqc_catype * sqcca, short * sqlvarno, float * varreal4, sqc_datype * sqcda, short * sqcerr)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="SupraEXDI" selector="sqcr8bind:with:with:with:with:">sqcr8bind: sqcca with: sqlvarno with: varreal8 with: sqcda with: sqcerr	&lt;C: pascal void sqcr8bind(sqc_catype * sqcca, short * sqlvarno, double * varreal8, sqc_datype * sqcda, short * sqcerr)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="SupraEXDI" selector="sqcrelease:with:">sqcrelease: sqcca with: sqcdbno	&lt;C: pascal void sqcrelease(sqc_catype * sqcca, short * sqcdbno)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="SupraEXDI" selector="sqcstatement:with:with:with:">sqcstatement: sqcca with: sqcdbno with: sqcstmtlen with: sqcstmtbuf	&lt;C: pascal void sqcstatement(sqc_catype * sqcca, short * sqcdbno, short * sqcstmtlen, unsigned char * sqcstmtbuf)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="SupraEXDI" selector="sqcuns2bind:with:with:with:with:">sqcuns2bind: sqcca with: sqlvarno with: varuns2 with: sqcda with: sqcerr	&lt;C: pascal void sqcuns2bind(sqc_catype * sqcca, short * sqlvarno, short * varuns2, sqc_datype * sqcda, short * sqcerr)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="SupraEXDI" selector="sqcuns4bind:with:with:with:with:">sqcuns4bind: sqcca with: sqlvarno with: varuns4 with: sqcda with: sqcerr	&lt;C: pascal void sqcuns4bind(sqc_catype * sqcca, short * sqlvarno, long * varuns4, sqc_datype * sqcda, short * sqcerr)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="SupraEXDI" selector="sqcv1stringbind:with:with:with:with:with:">sqcv1stringbind: sqcca with: sqlvarno with: varlen with: varv1string with: sqcda with: sqcerr	&lt;C: pascal void sqcv1stringbind(sqc_catype * sqcca, short * sqlvarno, short * varlen, unsigned char * varv1string, sqc_datype * sqcda, short * sqcerr)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="SupraEXDI" selector="sqcv2stringbind:with:with:with:with:with:">sqcv2stringbind: sqcca with: sqlvarno with: varlen with: varv2string with: sqcda with: sqcerr	&lt;C: pascal void sqcv2stringbind(sqc_catype * sqcca, short * sqlvarno, short * varlen, unsigned char * varv2string, sqc_datype * sqcda, short * sqcerr)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="SupraEXDI" selector="sqczonedbind:with:with:with:with:with:with:">sqczonedbind: sqcca with: sqlvarno with: varlen with: varfrac with: varzoned with: sqcda with: sqcerr	&lt;C: pascal void sqczonedbind(sqc_catype * sqcca, short * sqlvarno, short * varlen, short * varfrac, unsigned char * varzoned, sqc_datype * sqcda, short * sqcerr)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><initialize><class-id>Database.SupraConnection</class-id></initialize><initialize><class-id>Database.SupraBuffer</class-id></initialize><initialize><class-id>Database.SupraSession</class-id></initialize><initialize><class-id>Database.SupraSqlca</class-id></initialize><initialize><class-id>Database.SupraColumnDescription</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>ByteArray</name><environment>Core</environment><super>Core.IntegerArray</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>ExternalDatabaseException</name><environment>Database</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><class><name>Float</name><environment>Core</environment><super>Core.LimitedPrecisionReal</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Text</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars>string runs </inst-vars><class-inst-vars></class-inst-vars><imports>			private Graphics.TextConstants.*			</imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>ExternalDatabaseTransaction</name><environment>Database</environment><super>Database.ExternalDatabaseFramework</super><private>false</private><indexed-type>none</indexed-type><inst-vars>memberCountHolder remainingCountHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><class><name>ExternalDatabaseColumnDescription</name><environment>Database</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name index type length precision scale nullable </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><class><name>Integer</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>FixedPoint</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars>numerator denominator scale </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Timestamp</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>year month day hour minute second millisecond </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Support</category><attributes><package>Magnitude-General</package></attributes></class><class><name>Date</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>day year </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>ExternalDatabaseConnection</name><environment>Database</environment><super>Database.ExternalDatabaseFramework</super><private>false</private><indexed-type>none</indexed-type><inst-vars>transaction username password environment transactionCoordinator cachedSession isolationLevel encoding </inst-vars><class-inst-vars>environmentMap xif xifMap dependents </class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><class><name>ExternalDatabaseBuffer</name><environment>Database</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>databaseType encoding elementSize count bufferPointer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><class><name>Double</name><environment>Core</environment><super>Core.LimitedPrecisionReal</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>ExternalInterface</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>includeFiles includeDirectories libraryFiles libraryDirectories virtual optimizationLevel </class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>External-Interface</category><attributes><package>External-Interface</package></attributes></class><class><name>Time</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hours minutes seconds </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>ExternalDatabaseError</name><environment>Database</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dbmsErrorCode dbmsErrorString osErrorCode osErrorString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><class><name>ExternalDatabaseSession</name><environment>Database</environment><super>Database.ExternalDatabaseFramework</super><private>false</private><indexed-type>none</indexed-type><inst-vars>connection query queryFragments bindInput bindTemplate bindOutput useNamedOutputBinding bindValues resultTemplate allocateForEachRow blockFactor numColumns columnDescriptions rowAdaptors rowBuffersHolder bufferIndex answerStream currentRow scrollable needBinding </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><class><name>TimestampReader</name><environment>Core</environment><super>Core.LocaleSensitiveDataReader</super><private>false</private><indexed-type>none</indexed-type><inst-vars>timeSelector dateSelector timestampSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Internationalization</category><attributes><package>Internationalization</package></attributes></class></st-source>