<?xml version="1.0"?><st-source><!-- Name: DST_IDLCompilerNotice: Copyright 1999-2013 Cincom Systems, Inc.  All rights reserved.Comment: DST_IDLCompiler contains the IDL compiler class.  It should be loaded before the DSTRepository and before any parcels or packages containing IDL code.Copyright: Copyright © 1999-2001 Cincom Systems, Inc.All Rights ReservedThis product contains copyrighted third-party software.Copyright © 1993-1995 Hewlett-Packard Company.All Rights ReservedDbIdentifier: bear73DbTrace: 464615DbUsername: tkoganDbVersion: 8.1 - 1DevelopmentPrerequisites: #(#(#any 'AT Parser Compiler' '') #(#any 'DST_Core' ''))PackageName: DST_IDLCompilerParcel: #('DST_IDLCompiler')ParcelName: DST_IDLCompilerPrerequisiteParcels: #(#('AT Parser Compiler' '') #('DST_Core' ''))PrintStringCache: (8.1 - 1,tkogan)Version: 8.1 - 1Date: 1:09:21 PM January 29, 2016 --><time-stamp>From VisualWorks®, Pre-Release 8.2 (jan16.4) of January 29, 2016 on January 29, 2016 at 1:09:21 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>IDLCompiler</name><environment>DST</environment><super>Kernel.ExternalLanguageParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>scope </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Compilers</category><attributes><package>DST_IDLCompiler</package></attributes></class><comment><class-id>DST.IDLCompiler</class-id><body>This class implements a compiler which accepts IDL module or interface declarations and produces a method which will return the correct meta object network to represent the IDL declaration.  Note that these methods store the actual object instances which they return upon demand, and that changes to an instance will be reflected in the results of subsequent calls.Instance Variables:	scope			&lt;OrderedCollection&gt; stack for scope nestingShared Variables:	EnforceNaming 	&lt;Boolean&gt;		Controls checking of the syntax of identifiers.	CharacterLiteralTable	&lt;IdentityDictionary&gt; special characters found in string literals.	KeywordTable 	&lt;IdentityDictionary&gt; reserved IDL keywords</body></comment><shared-variable><name>CharacterLiteralTable</name><environment>DST.IDLCompiler</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_IDLCompiler</package></attributes></shared-variable><shared-variable><name>KeywordTable</name><environment>DST.IDLCompiler</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_IDLCompiler</package></attributes></shared-variable><shared-variable><name>EnforceNaming</name><environment>DST.IDLCompiler</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_IDLCompiler</package></attributes></shared-variable><methods><class-id>DST.IDLCompiler</class-id> <category>constructed types</category><body package="DST_IDLCompiler">arrayDeclarator =	typeIdentifier  fixedArraySize+		  [(DSTtypeArray prefix: scope last) sizes: stack removeLast ident: stack removeLast type: stack last]		  [(DSTdeclaratorSimple prefix: scope last) array: stack removeLast]</body><body package="DST_IDLCompiler">case =	(caseLabel+ elementSpec  $;)		 [stack removeLast: 3]</body><body package="DST_IDLCompiler">caseLabel =	(word=#case  constExp  $: )  |	(word=#default  [#default]  $: )</body><body package="DST_IDLCompiler">constructedTypeSpec =	structType  |	unionType  |	enumType</body><body package="DST_IDLCompiler">elementSpec =	typeSpec  declarator</body><body package="DST_IDLCompiler">enumType =	word=#enum [DSTtypeEnumeration prefix: scope last] typeIdentifier  ${  enumerator\$,  $}		[: id: values:]</body><body package="DST_IDLCompiler">enumerator =	enumIdentifier</body><body package="DST_IDLCompiler">fixedArraySize =	$[  integerConst  $]</body><body package="DST_IDLCompiler">fixedPointType =	word=#fixed [DSTtypeFixed new] 		($&lt;  integerConst $, constExp  $&gt;  [(stack at: stack size) value  &gt; (stack at: stack size -1) value													ifTrue:[self notify: '&lt;- Digits can''t be smaller then scale']].		|		[nil])	 [: digits: scale:]</body><body package="DST_IDLCompiler">integerConst =	constExp [stack last value &lt; 0 ifTrue: [ self notify: ' &lt;- ', 'Expected a positive constant'] ifFalse: [ stack removeLast]]</body><body package="DST_IDLCompiler">member =		typeSpec  declarators  $;		[Array with: stack removeLast with: stack removeLast]</body><body package="DST_IDLCompiler">memberList =	member+</body><body package="DST_IDLCompiler">sequenceType =	word=#sequence [DSTtypeSequence new]	$&lt;  simpleTypeSpec  ($,  integerConst  | [nil])  $&gt;	 [: subtype: size:]</body><body package="DST_IDLCompiler">stringType =		word=#string [DSTtypeString new] 		($&lt;  integerConst  $&gt;  |		[nil])	 [: maxSize:]</body><body package="DST_IDLCompiler">structType =		word=#struct  [DSTtypeStructure prefix: scope last]		typeIdentifier  ${  memberList  $}			[: id: fields:]</body><body package="DST_IDLCompiler">switchBody =	case+</body><body package="DST_IDLCompiler">switchTypeSpec =	integerType  |	charType  |	booleanType  |	enumType  |	scopedName [DSTtypeNamed new initialize: stack removeLast]</body><body package="DST_IDLCompiler">templateTypeSpec =	sequenceType |	stringType |	wideStringType |	fixedPointType</body><body package="DST_IDLCompiler">unionType =	word=#union  [DSTtypeUnion prefix: scope last]	identifier  word=#switch  $( switchTypeSpec  $) ${  switchBody  $}		[: name: switch: triples:]</body><body package="DST_IDLCompiler">wideStringType =	word=#wstring [DSTtypeWideString new] 		($&lt;  integerConst  $&gt;  |		[nil])	 [: maxSize:]</body></methods><methods><class-id>DST.IDLCompiler</class-id> <category>scope stack</category><body package="DST_IDLCompiler">popScopeBlock: aContainer 	self processScopeBlock: aContainer.	scope removeLast.	^aContainer</body><body package="DST_IDLCompiler">processScopeBlock: aContainer 	"Branch on whether the container of the last scope is nil."	| block |	block := scope last.	block container isNil		ifTrue:	[ self processScopeBlockWithNil: aContainer ]		ifFalse:	[ self processScopeBlockWithoutNil: aContainer ]</body><body package="DST_IDLCompiler">processScopeBlockWithNil: aContainer 	"Versions of the IDLCompiler prior to 5i.4 could not deal with a pragma version for modules, because the container of the scope block was nil.  This method handles that case."	| block |	block := scope last.	block pragmas do: [:e |		e name asSymbol = aContainer name			ifTrue: [e applyTo: aContainer]			ifFalse: [				| msg |				msg := 'Warning: ' , e asString , ' not applied -- ' , e name , ' not found in this scope.'.				ORBDaemon configurationManager log: msg withCRs.				Dialog notify: msg]]</body><body package="DST_IDLCompiler">processScopeBlockWithoutNil: aContainer 	"Process all the collected pragmas.  The pragmas are collected into an ordered collection. The first entry is always the prefix and is discarded. The second entry is the metacontainer to which this scope is attached. All pragmas are evaluated relative to this container following IDL's name scoping rules."	| block container mo msg |	block := scope last.	container := block container.	block pragmas do: [:e | (aContainer isKindOf: DSTMetaContainer)			ifTrue: 				[mo := container lookup: e name.				mo isNil ifFalse: [e applyTo: mo]					ifTrue: 						[msg := 'Warning: ' , e asString , ' not applied -- ' , e name , ' not found in this scope.'.						ORBDaemon configurationManager log: msg withCRs.						Dialog notify: msg]]			ifFalse: [e applyTo: aContainer]]</body><body package="DST_IDLCompiler">pushScopeBlock: aContainer 	"Push a containing scope. Also set the parent for the new container."	| block |	block := scope last.	aContainer prefix: block prefix.	aContainer definedIn: block container.	scope addLast: (ScopeBlock prefix: block prefix container: aContainer).	^aContainer</body></methods><methods><class-id>DST.IDLCompiler</class-id> <category>pragmas</category><body package="DST_IDLCompiler">accessPragma	| prag | 	prag := DSTAccessPragma new.	self skip; scanPragmaToken.	prag name: token.	self skip; scanPragmaToken.	prag accessRights: token.	scope last addPragma: prag.	self scanToken</body><body package="DST_IDLCompiler">classPragma	| prag |	prag := DSTClassPragma new.	self skip; scanPragmaToken.	prag name: token.	self skip; scanPragmaToken.	prag className: token.	scope last addPragma: prag.	self scanToken</body><body package="DST_IDLCompiler">idPragma	| prag |	prag := DSTIDPragma new.	self skip; scanPragmaToken.	prag name: token.	self skip; scanRepositoryId.	prag repositoryId: (RepositoryId fromString: token).	scope last addPragma: prag.	self scanToken</body><body package="DST_IDLCompiler">prefixPragma	| block |	self skip; xStringLiteral.	block := scope last.	block prefix: (IDLPrefix prefix: token value container: block container).	self scanToken</body><body package="DST_IDLCompiler">scanPragmaToken	buffer reset.	[(tokenType := typeTable at: hereChar asInteger) == #xDelimiter]		whileFalse: 			[hereChar == nil ifTrue: [^self offEnd: 'Unterminated pragma'].			buffer nextPut: hereChar.			hereChar := source next].	token := buffer contents trim</body><body package="DST_IDLCompiler">scanRepositoryId	"Scan a repository id. It can be one of three forms: 	1) IDL:&lt;some path&gt;:version 	2) DCE:uuid:version 	3) LOCAL:&lt;a string&gt;."	buffer reset.	[(hereChar := source next) == $"]		whileFalse: 			[hereChar == nil ifTrue: [^self offEnd: 'Unterminated pragma'].			buffer nextPut: hereChar].	token := buffer contents trim.	hereChar := source next</body><body package="DST_IDLCompiler">scanVersion	"Scan a version pragma"	self xDigit.	token := token value asFloat asString</body><body package="DST_IDLCompiler">selectorPragma	| prag |	prag := DSTSelectorPragma new.	self skip; scanPragmaToken.	prag name: token.	self skip; scanPragmaToken.	prag selector: token.	scope last addPragma: prag.	self scanToken</body><body package="DST_IDLCompiler">versionPragma	| prag |	prag := DSTVersionPragma new.	self skip; scanPragmaToken.	prag name: token.	self skip; scanVersion.	prag version: token.	scope last addPragma: prag.	self scanToken</body><body package="DST_IDLCompiler">xPragma	"process a pragma declaration, adding the successful result to the 	currentPragma"	| msg |	self xLetter.	token = '#pragma' ifFalse: [^self notify: 'Other preprocessing than #pragma is not supported'].	self skip; xLetter.	token := token asUppercase.	token = 'SELECTOR' ifTrue: [^self selectorPragma].	token = 'CLASS' ifTrue: [^self classPragma].	token = 'PREFIX' ifTrue: [^self prefixPragma].	token = 'VERSION' ifTrue: [^self versionPragma].	token = 'ID' ifTrue: [^self idPragma].	token = 'ACCESS' ifTrue: [^self accessPragma].	buffer reset.	[self endOfLineComment: (hereChar := source next)]		whileFalse: [buffer nextPut: hereChar].	buffer nextPut: source next.	hereChar := source next.	msg := 'Ignoring unknown pragma: #pragma ' , buffer contents.	ORBDaemon configurationManager log: msg withCRs.	self scanToken</body></methods><methods><class-id>DST.IDLCompiler</class-id> <category>scanning</category><body package="DST_IDLCompiler">blockComment	| savedEnd prev |	savedEnd := prevEnd.	"preserve end of last token"	buffer reset.	buffer nextPut: $/; nextPut: $*.	prev := nil.	[(hereChar := source next) == nil | (prev == $* and: [hereChar == $/])]		whileFalse: 			[buffer nextPut: hereChar.			prev := hereChar].	buffer nextPut: hereChar.	currentComment == nil		ifTrue: [currentComment := OrderedCollection with: buffer contents trim]		ifFalse: [currentComment add: buffer contents trim].	buffer position &gt; 200 ifTrue: ["Shorten the buffer if it got unreasonably large."		buffer := WriteStream on: (String new: 40)].	hereChar := source next.	self scanToken.	prevEnd := savedEnd</body><body package="DST_IDLCompiler">collectFloat: start end: end 	buffer reset.	source position: start.	start to: end - 1 do: [:i | buffer nextPut: source next].	^buffer contents</body><body package="DST_IDLCompiler">collectString: start end: end 	"The end position is at one character past the string terminator."	buffer reset.	source position: start.	start to: end - 2 do: [:i | buffer nextPut: source next].	source skip: 1.	^buffer contents</body><body package="DST_IDLCompiler">endOfLastToken	"Answer the position of end of last expression parsed."	^prevEnd</body><body package="DST_IDLCompiler">lineComment	| savedEnd char |	savedEnd := prevEnd.	"preserve end of last token"	buffer reset.	[source peek = $ ]		whileTrue: [source next].	[self endOfLineComment: (char := source next)]		whileFalse: [buffer nextPut: char].	currentComment == nil		ifTrue: [currentComment := OrderedCollection with: buffer contents trim]		ifFalse: [currentComment add: buffer contents trim].	buffer position &gt; 200 ifTrue: ["Shorten the buffer if it got unreasonably large."		buffer := WriteStream on: (String new: 40)].	hereChar := source next.	self scanToken.	prevEnd := savedEnd</body><body package="DST_IDLCompiler">scanCharLiteral	"Called when $\ seen during a character literal or string literal scan."	| c |	hereChar := source next.	hereChar asLowercase == $x		ifTrue: [c := Character value: (self readIDLIntegerFrom: source radix: 16)]		ifFalse: [hereChar &gt;= $0 &amp; (hereChar &lt;= $7)				ifTrue: 					[source skip: -1.					c := Character value: (self readIDLIntegerFrom: source radix: 8)]				ifFalse: [c := CharacterLiteralTable at: hereChar ifAbsent: [^nil]]].	^c</body><body package="DST_IDLCompiler">skip	"advance the position to skip over delimiters and equal"	[(tokenType := typeTable at: hereChar asInteger) == #xDelimiter or: [tokenType = #ascii75]]		whileTrue: [hereChar := source next]</body><body package="DST_IDLCompiler">xCharacterLiteral	"An IDL character literal"	| char start |	start := source position.	(char := source next) == nil ifTrue: [^self offEnd: 'Unmatched character quote'].	char == $\		ifTrue: [token := self scanCharLiteral]		ifFalse: [token := char].	(token isNil or: [source next ~= $'])		ifTrue: [^self offEnd: 'Unmatched character quote'].	token := DSTvalueExpr				op: 'characterLiteral'				sel: #characterLiteral				right: token				left: (self collectString: start end: source position).	hereChar := source next.	tokenType := #characterLiteral</body><body package="DST_IDLCompiler">xCommentOrDivide	"collect line comment, block comment, or return simple slash"	source peek == $/		ifTrue: 			[source next.			^self lineComment].	source peek == $*		ifTrue: 			[source next.			^self blockComment].	token := hereChar.	tokenType := #ascii57.	hereChar := source next.	^token</body><body package="DST_IDLCompiler">xDigit	"An IDL constant (number)"	| c n start |	start := source position -1.	hereChar == $0		ifTrue: 			[c := source peek.			c == $x | (c == $X)				ifTrue: 					[source next.					n := self readIDLIntegerFrom: source radix: 16]				ifFalse: [n := self readIDLIntegerFrom: source radix: 8]]		ifFalse: 			[source skip: -1.			n := self readIDLIntegerFrom: source radix: 10].	('.ed' includes: source peek asLowercase)		ifTrue: 			[n := self readIDLFloat: n from: source.			token := (source atEnd not and: [source peek asLowercase == $d])				ifTrue:[source next.					DSTvalueExpr						op: 'fixedPointLiteral'						sel: #fixedPointLiteral						right: n						left: (self collectFloat: start end: source position)]				ifFalse:[					DSTvalueExpr						op: 'floatLiteral'						sel: #floatLiteral						right: n						left: (self collectFloat: start end: source position)]]		ifFalse: [token := n].	tokenType := #number.	hereChar := source next</body><body package="DST_IDLCompiler">xFraction	source skip: -1.	token := self readIDLFloat: 0 from: source.	tokenType := #number.	hereChar := source next</body><body package="DST_IDLCompiler">xLeftShiftOrPunctuation	"Saw a $&lt;. Could either be a left shift operator or the beginning of a 	'&lt; positive_int_const&gt;' construct."	source peek == $&lt;		ifTrue: 			[source next.			token := #&lt;&lt;.			tokenType := #binary]		ifFalse: 			[token := hereChar.			tokenType := #ascii74].	hereChar := source next</body><body package="DST_IDLCompiler">xLetter	"A letter begins either an IDL identifier or a keyword. 	All are terminated by whitespace. 	Tokens can be identifiersor keywords. 	Selectors (in pragmas) are handled during the scanning of pragmas."	| type char |	buffer reset.	buffer nextPut: hereChar.		[char := source next.	char notNil		and: 			[type := typeTable at: char asInteger.			type == #xLetter or: [type == #xDigit]]]		whileTrue: [buffer nextPut: char].	hereChar := char.	token := buffer contents.	(KeywordTable includesKey: token asSymbol)		ifTrue: [tokenType := #word]		ifFalse: [tokenType := #word]</body><body package="DST_IDLCompiler">xRightShiftOrPunctuation	"Saw a $&gt;. Could either be a left shift operator or the end of a 	'&lt; positive_int_const&gt;' construct."	source peek == $&gt;		ifTrue: 			[source next.			token := #&gt;&gt;.			tokenType := #binary]		ifFalse: 			[token := hereChar.			tokenType := #ascii76].	hereChar := source next</body><body package="DST_IDLCompiler">xStringLiteral	"An IDL string literal"	| char start v |	buffer reset.	start := source position.	char := source next.	buffer on: (String new: 40).		[char == nil ifTrue: [^self offEnd: 'Unmatched string quote'].	char ~= $"]		whileTrue: 			[char == $\ ifTrue: [char := self scanCharLiteral].			buffer nextPut: char.			char := source next].	v := buffer contents.	token := DSTvalueExpr				op: 'stringLiteral'				sel: #stringLiteral				right: v				left: (self collectString: start end: source position).	hereChar := source next.	tokenType := #string</body></methods><methods><class-id>DST.IDLCompiler</class-id> <category>type syntax</category><body package="DST_IDLCompiler">baseTypeSpec =	floatingPointType  |	integerType  |	charType  |	wideCharType  |		booleanType  |	octetType  |	anyType |	typeCode</body><body package="DST_IDLCompiler">complexDeclarator =	arrayDeclarator</body><body package="DST_IDLCompiler">declarator =	@complexDeclarator  |	simpleDeclarator</body><body package="DST_IDLCompiler">declarators =	declarator\$,</body><body package="DST_IDLCompiler">description =		[| p |	p := currentComment.	currentComment := nil.	p isNil		ifTrue: [stack removeLast]		ifFalse: [stack removeLast definition: p]]</body><body package="DST_IDLCompiler">integerType =	signedInt |	unsignedInt</body><body package="DST_IDLCompiler">paramTypeSpec	"	***This is decompiled code.*** 	This may reflect a problem with the configuration of your image 	and its sources and changes files. 	Please refer to the documentation and the settings tool for help in 	setting up the proper source code files."	self baseTypeSpec ifTrue: [^true].	self stringType ifTrue: [^true].	self wideStringType ifTrue: [^true].	self fixedPointType ifTrue: [^true].	self scopedName		ifTrue: 			[stack addLast: (DSTtypeNamed new initialize: stack removeLast).			^true].	^false</body><body package="DST_IDLCompiler">simpleDeclarator =	identifier [(DSTdeclaratorSimple prefix: scope last) initialize: stack removeLast]</body><body package="DST_IDLCompiler">simpleDeclarators =	simpleDeclarator\$,</body><body package="DST_IDLCompiler">simpleTypeSpec =	baseTypeSpec  |	templateTypeSpec  |	scopedName [DSTtypeNamed new initialize: stack removeLast]</body><body package="DST_IDLCompiler">typeDecl =	(word=#typedef  typeDeclarator  |	structType  |	unionType  |	enumType)</body><body package="DST_IDLCompiler">typeDeclarator =	typeSpec  declarators		[ generateTypeAliases: declarators: ]	[ stack removeLast do: [:e | stack add: e]].</body><body package="DST_IDLCompiler">typeSpec =	constructedTypeSpec	|	simpleTypeSpec</body></methods><methods><class-id>DST.IDLCompiler</class-id> <category>constant syntax</category><body package="DST_IDLCompiler">addExp  =	multExp 		($+  addExp  [DSTvalueExpr op: '+' sel: #plus right: stack removeLast left: stack removeLast]  |		$-  addExp  [DSTvalueExpr op: '-' sel: #minus right: stack removeLast left: stack removeLast]  |			 )</body><body package="DST_IDLCompiler">andExp  =	shiftExp 		($&amp;  andExp  [DSTvalueExpr op: '&amp;' sel: #and right: stack removeLast left: stack removeLast]  |			 )</body><body package="DST_IDLCompiler">charLit	"parse a character literal and leave it on the stack. return a success 	boolean"	tokenType == #characterLiteral ifFalse: [^false].	stack add: token.	token := hereChar.	hereChar := source next.	tokenType := typeTable at: token asInteger.	^true</body><body package="DST_IDLCompiler">characterLiteral =	[self charLit] ?</body><body package="DST_IDLCompiler">constDecl =	word=#const  [DSTconstant prefix: scope last] constType  typeIdentifier  $=  constExp			[: t:i:v:]</body><body package="DST_IDLCompiler">constExp  =		orExp</body><body package="DST_IDLCompiler">constType  =	integerType |	charType  |	wideCharType  |			booleanType  |	floatingPointType  |	wideStringType  |			stringType  |	fixedPointConstType | 	scopedName [DSTtypeNamed new initialize: stack removeLast]</body><body package="DST_IDLCompiler">leftShift =	 #&lt;&lt;</body><body package="DST_IDLCompiler">literal  =	number | 	characterLiteral  | 	string+  [combine:]  |	word=#TRUE [DSTvalueExpr op: 'TRUE' sel: #bool right: true left: nil]  |	word=#FALSE [DSTvalueExpr op: 'FALSE' sel: #bool right: false left: nil]</body><body package="DST_IDLCompiler">multExp  =	unaryExp 		($*  multExp  [DSTvalueExpr op: '*' sel: #mult right: stack removeLast left: stack removeLast]  |		$/  multExp  [DSTvalueExpr op: '/' sel: #div right: stack removeLast left: stack removeLast]  |		$%  multExp  [DSTvalueExpr op: '%' sel: #mod right: stack removeLast left: stack removeLast]  |			 )</body><body package="DST_IDLCompiler">orExp  =	xorExp 		($|  orExp  [DSTvalueExpr op: '|' sel: #or right: stack removeLast left: stack removeLast]  |			 )</body><body package="DST_IDLCompiler">primaryExp =	literal  |	scopedName  [DSTvalueNamed new initialize: stack removeLast]  |	$(  constExp  $) [DSTvalueExpr op: '' sel: #nest right: stack removeLast left: nil]</body><body package="DST_IDLCompiler">rightShift =	 #&gt;&gt;</body><body package="DST_IDLCompiler">shiftExp  =        addExp                (rightShift  shiftExp  [DSTvalueExpr op: '&gt;&gt;' sel: #shRight right: stack removeLast left: stack removeLast]  |                 leftShift  shiftExp  [DSTvalueExpr op: '&lt;&lt;' sel: #shLeft right: stack removeLast left: stack removeLast]  |  )</body><body package="DST_IDLCompiler">unaryExp  =	$-  primaryExp  [DSTvalueExpr op: '-' sel: #neg right: stack removeLast left: nil]  |	$~  primaryExp  [DSTvalueExpr op: '~' sel: #complement right: stack removeLast left: nil]  |	$+  primaryExp  [DSTvalueExpr op: '+' sel: #unaryPlus right: stack removeLast left: nil]  |	primaryExp</body><body package="DST_IDLCompiler">xorExp  =	andExp 		($^  xorExp  [DSTvalueExpr op: '^' sel: #xor right: stack removeLast left: stack removeLast]  |			 )</body></methods><methods><class-id>DST.IDLCompiler</class-id> <category>primitives</category><body package="DST_IDLCompiler">enumIdentifier  =	identifier [(stack last select: [:ch | ch isLowercase]) isEmpty  | EnforceNaming not] ?</body><body package="DST_IDLCompiler">identifier  =	word\$_  [stack last size = 1 | EnforceNaming not] ?		[| st ar | 			ar := stack removeLast.			st := ar at: 1.			2 to: ar size do: [:s| st := st , '_' , (ar at: s)].			st asSymbol]</body><body package="DST_IDLCompiler">opIdentifier  =	identifier [(stack last at: 1) isLowercase | EnforceNaming not] ?</body><body package="DST_IDLCompiler">scopedName  =	twoColons scopedNameTail [makeGlobalName: ] | 	scopedNameTail</body><body package="DST_IDLCompiler">scopedNameTail  =	 identifier (@twoColons  scopedNameTail  [combine:with: ] |  )</body><body package="DST_IDLCompiler">twoColons  =	$:  $:</body><body package="DST_IDLCompiler">typeIdentifier  =	identifier [(stack last at: 1) isUppercase | EnforceNaming not] ?</body></methods><methods><class-id>DST.IDLCompiler</class-id> <category>code generation</category><body package="DST_IDLCompiler">combine: aString with: anotherStr	"combine strings in a scoped name"	| st | 	st := aString asString , '::' , anotherStr asString.	^st asSymbol</body><body package="DST_IDLCompiler">makeGlobalName: string	"make a globally scoped name"	 ^('::' , string) asSymbol</body></methods><methods><class-id>DST.IDLCompiler</class-id> <category>formatting</category><body package="DST_IDLCompiler">format: sourceCode in: aClass notifying: aRequestor 	| text mo |	DSTMetaObject initializeCurrentPrefix.	text := self				subFormat: sourceCode				in: aClass				notifying: aRequestor.	text == nil		ifTrue: [^nil]		ifFalse: 			[mo := stack removeLast value.			(mo isKindOf: DSTMetaObject)				ifTrue: [mo removeMetaObject].			^text asText]</body><body package="DST_IDLCompiler">subFormat: sourceCode in: aClass notifying: aRequestor 	"Format the source code if possible. 	If not, return nil and let the default compiler do it."	| mo |	^Cursor wait		showWhile: 			[mo := self						parse: sourceCode						in: aClass						notifying: aRequestor.			mo isNil ifFalse: [mo getIDLDefinition]				ifTrue: []]</body></methods><methods><class-id>DST.IDLCompiler</class-id> <category>interface syntax</category><body package="DST_IDLCompiler">inheritanceSpec =	$:  scopedName\$,</body><body package="DST_IDLCompiler">interface =        interfaceHeader        (${ interfaceBody $} [: n: s: d: b:]   | [DSTtypeNamed new d: stack removeLast s: stack removeLast n: stack removeLast i: stack removeLast])        [popScopeBlock: ]</body><body package="DST_IDLCompiler">interfaceBody =	export*</body><body package="DST_IDLCompiler">interfaceHeader =	word=#interface 	[DSTinterface prefix: scope last]	[pushScopeBlock: ]	typeIdentifier 	(inheritanceSpec | [#()] )  	[| p | p := currentComment. currentComment := nil. p]</body></methods><methods><class-id>DST.IDLCompiler</class-id> <category>number parsing</category><body package="DST_IDLCompiler">readIDLFloat: integerPart from: aStream 	"The integer part has already been scanned and is passed in as 'integerpart'.  This method expects to scan in the fractional part, including the exponent.  It handles the cases where there is no fractional part (only the '.') and the case where there is no exponent.  	Versions of this method prior to 5i.4 could not deal with a pragma version as the very last statement, if there was no further character, hence the replacement of 'aStream peek asLowercase == $e' with '(aStream atEnd not and: [aStream peek asLowercase == $e])'."	| value precision digit num den exp neg endOfNumber |	precision := 1.	num := 0.	den := 1.	(aStream peekFor: $.)		ifTrue: ["&lt;integer&gt;.&lt;fraction&gt; -- scan the fraction"			(aStream atEnd not and: [aStream peek isDigit])				ifTrue: 					[| atEnd |					num := 0.					precision := 0.					[(atEnd := aStream atEnd) or: [(digit := aStream next) isDigit not]]						whileFalse: 							[num := num * 10 + digit digitValue.							precision := precision + 1].					den := 10 ** precision.					atEnd ifFalse: [aStream skip: -1]]				ifFalse: ["just &lt;integer&gt;."]].	exp := 0.	(aStream atEnd not and: [aStream peek asLowercase == $e])		ifTrue: 			[aStream next.			endOfNumber := aStream position.			aStream peekFor: $+.			neg := aStream peekFor: $-.			((digit := aStream peek) notNil and: [digit isDigit])				ifTrue: 					[exp := self readIDLIntegerFrom: aStream radix: 10.					neg ifTrue: [exp := exp negated].					precision := precision - exp]				ifFalse: [aStream position: endOfNumber]].	value := integerPart + (num / den) * (10 raisedTo: exp).	^value asDouble</body><body package="DST_IDLCompiler">readIDLIntegerFrom: aStream radix: radix 	| digit value |	value := 0.	[aStream atEnd]		whileFalse: 			[digit := aStream next digitValue.			(digit &lt; 0 or: [digit &gt;= radix])				ifTrue: 					[aStream skip: -1.					^value]				ifFalse: [value := value * radix + digit]].	^value</body></methods><methods><class-id>DST.IDLCompiler</class-id> <category>operation syntax</category><body package="DST_IDLCompiler">contextExpr  =	word=#context  $( identifier\$,  $)</body><body package="DST_IDLCompiler">opAttribute =	word=#oneway [#ONEWAY]</body><body package="DST_IDLCompiler">opDecl =	(opAttribute  opTypeSpec  opIdentifier  parameterDecls 	( raisesExpr  |  [#()]  ) 	( contextExpr  | [#()])		[(DSToperation prefix: scope last) 			cxt: stack removeLast 			evts: stack removeLast 			params: stack removeLast 			id: stack removeLast			type: stack removeLast			attr: stack removeLast])  |	(opTypeSpec  opIdentifier  parameterDecls 	( raisesExpr  |  [#()]  ) 	( contextExpr  | [#()])		[(DSToperation prefix: scope last)  			cxt: stack removeLast 			evts: stack removeLast 			params: stack removeLast 			id: stack removeLast			type: stack removeLast			attr: #NORMAL])</body><body package="DST_IDLCompiler">opTypeSpec =	word=#void  [DSTtypeVoid new]	|	paramTypeSpec</body><body package="DST_IDLCompiler">paramAttribute =	word=#in  [#IN] |	word=#out  [#OUT] |	word=#inout [#INOUT]</body><body package="DST_IDLCompiler">paramDecl =		paramAttribute  paramTypeSpec  simpleDeclarator		[DSTparameter new 			name: stack removeLast 			type: stack removeLast			direction: stack removeLast ]</body><body package="DST_IDLCompiler">parameterDecls =	$( [DSTsignature new] 	(paramDecl\$,  [: addAll: ] | )	$)</body><body package="DST_IDLCompiler">raisesExpr  =	word=#raises  $( scopedName\$,  $)</body></methods><methods><class-id>DST.IDLCompiler</class-id> <category>module syntax</category><body package="DST_IDLCompiler">definition  =	(interface		|		module			|		constDecl		 |		exceptDecl 	 |		typeDecl)	description	$;</body><body package="DST_IDLCompiler">export =	(constDecl		 |		exceptDecl 	 |		attrDecl 	 |		typeDecl 	 |		opDecl)	description	$;</body><body package="DST_IDLCompiler">module  =	word=#module [DSTmodule prefix: scope last]	[pushScopeBlock: ]	typeIdentifier [: ident: ]		[| p | p := currentComment. currentComment := nil. p]	${   definition+   $}		[: def: defs: ]	[popScopeBlock: ]</body></methods><methods><class-id>DST.IDLCompiler</class-id> <category>attribute syntax</category><body package="DST_IDLCompiler">attrDecl  =	((word=#readonly word=#attribute  [DSTattribute prefix: scope last] [true]  		paramTypeSpec  simpleDeclarators 		[: declarators: ])  |	(word=#attribute  [DSTattribute prefix: scope last] [false]  		paramTypeSpec  simpleDeclarators		[: declarators: ]))			[: r: t:]</body></methods><methods><class-id>DST.IDLCompiler</class-id> <category>simple types</category><body package="DST_IDLCompiler">anyType =	word=#any  [DSTtypeAny prefix: scope last]</body><body package="DST_IDLCompiler">booleanType =	word=#boolean  [DSTtypeBoolean prefix: scope last]</body><body package="DST_IDLCompiler">charType =	word=#char [DSTtypeCharacter prefix: scope last]</body><body package="DST_IDLCompiler">fixedPointConstType =	word=#fixed  [DSTtypeFixed prefix: scope last]	"May be need to introduce DSTtypeFixedConst"</body><body package="DST_IDLCompiler">floatingPointType =	word=#float  [DSTtypeFloat prefix: scope last]  |	word=#double  [DSTtypeDouble prefix: scope last] 	" this branch is moved to signedInt for ease of parsing	|  word=#long word=#double [DSTtypeLongDouble prefix: scope last ] "</body><body package="DST_IDLCompiler">octetType =	word=#octet    [DSTtypeOctet prefix: scope last]</body><body package="DST_IDLCompiler">signedInt =	"See floatingPointType for an explanaition of why long double is here"	word=#short [DSTtypeShort prefix: scope last ]	 | 	(word=#long (word=#long [DSTtypeLongLong prefix: scope last ] | 				 word=#double [DSTtypeLongDouble prefix: scope last ] | 					[DSTtypeLong prefix: scope last ]  ))</body><body package="DST_IDLCompiler">unsignedInt =	word=#unsigned 		(word=#short [DSTtypeUnsignedShort prefix: scope last ] | 		 (word=#long (word=#long [DSTtypeUnsignedLongLong prefix: scope last ] | 					[DSTtypeUnsignedLong prefix: scope last ]  )))</body><body package="DST_IDLCompiler">wideCharType =	word=#wchar [DSTtypeWideCharacter prefix: scope last]</body></methods><methods><class-id>DST.IDLCompiler</class-id> <category>type stackops</category><body package="DST_IDLCompiler">generateTypeAliases: aType declarators: decls 	"Generate a type alias and connect it to the list of declarators."	^decls		collect: 			[:d | 			d resolveTo: aType.			(DSTtypeAlias prefix: scope last)				initialize: d type: aType]</body></methods><methods><class-id>DST.IDLCompiler</class-id> <category>private</category><body package="DST_IDLCompiler">endOfDefinition: arg  	"The IDL compiler is at the end of an IDL definition. The calling 	method, compile:in:notifying:ifFail:, expects to be at end of file 	which is represented by a tokenType with the value #doIt. But since 	we may be compiling an IDL file containing multiple definitions 	tokenType may not be #doIt at this point. If tokenType is not #doIt 	then this routine will set it to #doIt and backup the source stream to 	the mark."	tokenType == #doIt		ifFalse: 			[tokenType := #doIt.			source position: prevEnd].	^arg</body><body package="DST_IDLCompiler">endOfLineComment: aCharacter 	"Normally the end of line character is a Character cr (the Smalltalk 	default). 		However when dealing with external streams this can get 	complicated. External streams use the platform's lineEndConvention 	and lineEndCharacter to translate to the Smalltalk default (CR). For 	example, on a PC the lineEndConvention is CRLF and the 	lineEndCharacter is CR. On an input request (next) the CRLF will be 	converted to a CR. On outupt (nextPut:) a CR will be translated to a 	CRLF. The conventions for UNIX are lineEndConvention = LF and 	lineEndCharacter = LF. 		A problem arises when a file created on one platform is moved to 	another. The receiving platform does not know the conventions used 	to create the file. This causes problems for any software which 	is scanning for end of line. This routine attempts to decipher what 	the line convention of the file is regardless of the current platform 	convention. 		If a LF is seen then assume that this is a unix file being read by a PC 	and consider the LF the end of line. 	If a CR is seen then normally this would be end of line. But also 	check for the next character being a LF (which is true if this is a PC 	file being read on a Unix platform)."	aCharacter == nil ifTrue: [^true].	aCharacter == Character lf ifTrue: [^true].	aCharacter == Character cr		ifTrue: 			[source peek == Character lf ifTrue: [source next].			^true].	^false</body></methods><methods><class-id>DST.IDLCompiler</class-id> <category>exception syntax</category><body package="DST_IDLCompiler">exceptDecl  =	word=#exception  [DSTexception prefix: scope last] opIdentifier  		${  member*  $}  [: id: members:]</body></methods><methods><class-id>DST.IDLCompiler</class-id> <category>pseudo types</category><body package="DST_IDLCompiler">typeCode =	word=#TypeCode [DSTpseudoTypeCode prefix: scope last]</body></methods><methods><class-id>DST.IDLCompiler</class-id> <category>public access</category><body package="DST_IDLCompiler">parse: sourceCode in: aClass notifying: aRequestor 	"Compile the incoming text and answer with the resulting 	parse tree. This is the only public message that saves the 	source map and the comments. If the requestor is nil, 	warning messages (as opposed to outright errors) are silently 	discarded."	self setClass: aClass.	self		init: sourceCode		notifying: aRequestor		failBlock: [^nil].	self method ifFalse: [self unexpectedError].	tokenType == #doIt ifFalse: [self notify: 'End of method expected'].	stack size = 1 ifFalse: [self notify: 'Stack size error, compiler bug!'].	^stack last value</body><body package="DST_IDLCompiler">parseSelector: methodSourceString	"Treating the argument as an IDL definition, answer the selector	under which the definition would be stored in the repository class,	or nil if the argument cannot be parsed."	| definition |	definition :=		[self			parse: methodSourceString 			in: UndefinedObject 			notifying: (SignallingCompilerErrorHandler handler: SilentCompilerErrorHandler new)]				on: CompilerError do: [:ex | ^nil].	^definition name</body><body package="DST_IDLCompiler">parseSelectorInterval: methodSourceString	| id start |	id := self parseSelector: methodSourceString.	id isNil ifTrue: [^1 to: 0].	start := methodSourceString indexOfSubCollection: id startingAt: 1.	^start to: start + id size - 1</body></methods><methods><class-id>DST.IDLCompiler</class-id> <category>constant stackops</category><body package="DST_IDLCompiler">combine: stArray 	"return the concatenation of the strings in the array"	stArray size = 1		ifTrue: [^stArray at: 1]		ifFalse: [^DSTvalueExpr				op: ' '				sel: #concat				right: (self combine: (stArray copyFrom: 2 to: stArray size))				left: (stArray at: 1)]</body></methods><methods><class-id>DST.IDLCompiler</class-id> <category>subclass responsibility</category><body package="DST_IDLCompiler">method = 	"Parse an IDL definition, leaving the parsed representation, either a parse tree or 	Smalltalk source code, as the sole item on the stack"	definition	[popScopeBlock: ]	[| if |  if := stack removeLast.		if printName -&gt; if]	[endOfDefinition:]</body></methods><methods><class-id>DST.IDLCompiler</class-id> <category>initialize-release</category><body package="DST_IDLCompiler">initScanner	"initialize my scanner tables"	super initScanner.	typeTable := typeTable copy.	typeTable at: $' asInteger put: #xCharacterLiteral.	typeTable at: $" asInteger put: #xStringLiteral.	typeTable at: $/ asInteger put: #xCommentOrDivide.	typeTable at: $# asInteger put: #xPragma.	typeTable at: $_ asInteger put: #xLetter.	typeTable at: $&lt; asInteger put: #xLeftShiftOrPunctuation.	typeTable at: $&gt; asInteger put: #xRightShiftOrPunctuation.	typeTable at: $. asInteger put: #xFraction.	scope := OrderedCollection with: ScopeBlock new</body></methods><methods><class-id>DST.IDLCompiler class</class-id> <category>private</category><body package="DST_IDLCompiler">computeTables	"Compute the character type, reserved word tables, and 	keyword flag from the information associated with each method."	| words types kwds info typeInfo allMethods allSelectors |	self superclass computeTables.	words := Set new.	types := TypeTable copy.	kwds := false.	allMethods := self superclass methodInfo copy.	allMethods addAll: self methodInfo associations.	allSelectors := self superclass selectors.	allSelectors addAll: methodDict keys.	allMethods keys do: [:selector | (allSelectors includes: selector)			ifTrue: 				[info := allMethods at: selector.				words addAll: (info at: 1).				typeInfo := info at: 2.				typeInfo isEmpty ifFalse: [typeInfo associationsDo: [:char | types at: char key asInteger put: char value]].				kwds := kwds | (info at: 3)]			ifFalse: [methodInfo removeKey: selector ifAbsent: []]].	reservedWords := words isEmpty				ifTrue: [false]				ifFalse: [words].	typeTable := types.	hasKeywords := kwds</body></methods><methods><class-id>DST.IDLCompiler class</class-id> <category>accessing</category><body package="DST_IDLCompiler">enforceNamingConventions: bool 	"Controls the checking of identifier syntax. 		If true: 	- 'identifier' accepts only one legal Smalltalk identifier. 	- 'enumIdentifier' accepts only uppercase letters in 	'identifier'. 	- 'typeIdentifier' accepts only capitalized 'identifier'. 	- 'opIdentifier' accepts only 'identifier' starting with lowercase 	letter. 		If false (default): 	- 'identifier' accepts multiple legal Smalltalk identifiers 	separated by an underscore. 	- 'enumIdentifier' same as 'identifier'. 	- 'typeIdentifier' same as 'identifier'. 	- 'opIdentifier' same as 'identifier'. 	"	EnforceNaming := bool</body><body package="DST_IDLCompiler">preferredParserClass	^self</body></methods><methods><class-id>DST.IDLCompiler class</class-id> <category>class initialization</category><body package="DST_IDLCompiler">initialize	"initialize the receiver"	| charLits keywords |	EnforceNaming := false.	charLits := IdentityDictionary new.	charLits at: $n put: Character lf.	charLits at: $t put: Character tab.	charLits at: $v put: (Character value: 11).	charLits at: $b put: Character backspace.	charLits at: $r put: Character cr.	charLits at: $f put: Character newPage.	charLits at: $a put: (Character value: 7).	charLits at: $\ put: $\.	charLits at: $? put: $?.	charLits at: $' put: $'.	charLits at: $" put: $".	CharacterLiteralTable := charLits.	keywords := IdentityDictionary new.	#('any' 'attribute' 'boolean' 'case' 'char' 'const' 'context' 'default' 'double' 'enum' 'exception' 'FALSE' 'fixed' 'float' 'in' 'inout' 'interface' 'long' 'module' 'octet' 'oneway' 'out' 'raises' 'readonly' 'sequence' 'short' 'string' 'struct' 'switch' 'TRUE' 'TypeCode' 'typedef' 'unsigned' 'union' 'void' 'wchar' 'wstring' 'fixed') do: [:keyword | keywords add: keyword asSymbol -&gt; nil].	KeywordTable := keywords</body><body package="DST_IDLCompiler">release	"release class variables"	CharacterLiteralTable := EnforceNaming := KeywordTable := nil</body></methods><methods><class-id>DST.IDLCompiler class</class-id> <category>public access</category><body package="DST_IDLCompiler">preprocess: aStream 	"This method is called by the IDL importation methods to preprocess 	the IDL source. It must return a stream representing the 	preprocessed IDL. 		This routine can be modified to suit whatever 	preprocessor that is used. For example, if the DLL/C connect 	preprocessor is used then the body of this method might be: 	^CPreprocessor preprocess: aStream 	By default this method just returns its argument stream. 	"	^aStream</body></methods><initialize><class-id>DST.IDLCompiler</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>ExternalLanguageParser</name><environment>Kernel</environment><super>Kernel.GeneralParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AT-ParserCompiler</category><attributes><package>AT Parser Compiler</package></attributes></class></st-source>