<?xml version="1.0"?><st-source><!-- Name: DST_COS_ServicesNotice: Copyright 1999-2013 Cincom Systems, Inc.  All rights reserved.Comment: DST_COS_Services contains the implementation of the following CORBA COS services:	Concurrency,	Transcation, and	Events.Copyright: Copyright © 1999-2001 Cincom Systems, Inc.All Rights ReservedThis product contains copyrighted third-party software.Copyright © 1993-1995 Hewlett-Packard Company.All Rights ReservedDbIdentifier: bear73DbTrace: 464621DbUsername: tkoganDbVersion: 8.1 - 1DevelopmentPrerequisites: #(#(#any 'DST_Core' '') #(#any 'DST_Core_Services' '') #(#any 'DST_COS_Services_IDL' ''))PackageName: DST_COS_ServicesParcel: #('DST_COS_Services')ParcelName: DST_COS_ServicesPrerequisiteDescriptions: #(#(#name 'DST_Core' #componentType #package) #(#name 'DST_Core_Services') #(#name 'DST_COS_Services_IDL' #componentType #package))PrerequisiteParcels: #(#('DST_Core' '') #('DST_Core_Services' '') #('DST_COS_Services_IDL' ''))PrintStringCache: (8.1 - 1,tkogan)Version: 8.1 - 1Date: 1:09:21 PM January 29, 2016 --><time-stamp>From VisualWorks®, Pre-Release 8.2 (jan16.4) of January 29, 2016 on January 29, 2016 at 1:09:21 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>DSTLockCoordinator</name><environment>DST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>lockset transaction </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COS-Concurrency</category><attributes><package>DST_COS_Services</package></attributes></class><class><name>DSTEventConnection</name><environment>DST</environment><super>DST.DSTPersistentObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>host connected </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COS-Events</category><attributes><package>DST_COS_Services</package></attributes></class><comment><class-id>DST.DSTEventConnection</class-id><body>Part of the Standard Event Services defined by OMG.  See DSTEventChannel for a description of the service.  See subclasses DSTPullConsumer, DSTPullSupplier, DSTPushConsumer and DSTPushSupplier for implementation details.Instance variables 	host 		&lt;DSTEventConnection&gt; --  a reference to the object owning the connection	connected    &lt;Boolean&gt; </body></comment><class><name>DSTPushSupplier</name><environment>DST</environment><super>DST.DSTEventConnection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>consumer events </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COS-Events</category><attributes><package>DST_COS_Services</package></attributes></class><comment><class-id>DST.DSTPushSupplier</class-id><body>A DSTPushSupplier is the producer of event data provided to push consumers (DSTPushConsumer). This is part of the Common Object Services Specification 1.0 for Events.  See DSTEventChannel for a description of the service. Instance Variables 	consumer 	&lt;DSTPushConsumer&gt; that will receive events	events	  	&lt;SharedQueue&gt; the pending event notificationsEXAMPLE:  PUSH-SUPPLIERWhen a supplier is set up to push event data, the data is pushed to the Event Channel as soon as an event occurs. A push-supplier need not know who its consumers are.  For example, if you have a system administration tool (consumer) designed to monitor space availability on systems disks, the tool needs to know immediately when a disk runs out of space. The disk (the supplier) is Unaware of the existence of the system administration tool, the disk (the event supplier) simply reports when it is full. </body></comment><class><name>DSTTransactionIdentity</name><environment>DST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>coordinator terminator transactionId </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COS-Transactions</category><attributes><package>DST_COS_Services</package></attributes></class><class><name>DSTLockSet</name><environment>DST</environment><super>DST.DSTPersistentObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>granted lockset accessMutex semaphore validation </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COS-Concurrency</category><attributes><package>DST_COS_Services</package></attributes></class><class><name>DSTTransactionalLockSet</name><environment>DST</environment><super>DST.DSTLockSet</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COS-Transactions</category><attributes><package>DST_COS_Services</package></attributes></class><class><name>DSTPullSupplier</name><environment>DST</environment><super>DST.DSTEventConnection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>consumer events </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COS-Events</category><attributes><package>DST_COS_Services</package></attributes></class><comment><class-id>DST.DSTPullSupplier</class-id><body>A DSTPullSupplier is the producer of event data provided to pull consumers (DSTPullConsumer). This is part of the Common Object Services Specification 1.0 for Events.  See DSTEventChannel for a description of the service. Instance variables 	consumer 	&lt;DSTPullConsumer&gt; that will receive events	events	  	&lt;SharedQueue&gt; the pending event notificationsEXAMPLE:  PULL-SUPPLIERSetting up a supplier for pulls can be used to optimize performance.  For example, an application object (consumer) may be interested in the changes a user makes to its properties object (supplier). However, when the application is closed or busy, it doesn't want to be opened or locked temporarily to handle the notification of changes to its properties.  If the application is set up as a push-consumer, the properties can be changed without getting the application object involved. However, when the application object is activated, it needs to know of the changes to its properties, so it pushes for the event data at that time.</body></comment><class><name>DSTEventChannel</name><environment>DST</environment><super>DST.DSTPersistentObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pushSuppliers pullSuppliers pushConsumers pullConsumers exportedProxies </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COS-Events</category><attributes><package>DST_COS_Services</package></attributes></class><comment><class-id>DST.DSTEventChannel</class-id><body>Along with the other classes in this category, this class implements the Common Object Services (COS) 1.0 Event Service, that provides a decoupled, asynchronous communication service between objects. (This extends the CORBA specification, which limits event notification to synchronous execution between a single client and a single server,  both of which must be available when the service request is made.)Event data are communicated between "suppliers" (producers of event data) and "consumers" (processors of event data) by issuing standard CORBA requests. Support for asynchrony is achieved via "event channels" that allow consumers and suppliers to communicate, by storing event information until the consumer requests (pulls) it or is available to receive it (responds to a push). Instance variables 	pushSuppliers	&lt;IdentitySet&gt;  	pullSuppliers	&lt;IdentitySet&gt;	pushConsumers	&lt;IdentitySet&gt;  	pullConsumers	&lt;IdentitySet&gt;	exportedProxies	&lt;IdentitySet&gt;EVENT CHANNEL ADMINISTRATIONThe event channel is built up incrementally. When an event channel is created, there are no suppliers and no consumers associated with it.  Upon creation of the channel, the factory returns an object reference supporting the EventChannel interface.  The ConsumerAdmin  &amp; SupplierAdmin interfaces allow consumers and suppliers to be added to the event channel. The Event Service allows 1-to-1, many-to-1, 1-to-many and many-to-many relations between suppliers and consumers.  For example, a many-to-1 relation exists between a bank of computer disks (suppliers) and a system administration tool (consumer) that monitors when the disks are full.  A 1-to-many relation exists between a table of current sales figures and the various documents in which the table appears.Usually there is a separate event channel for each group of related objects. Thus, for example, the disks that report when they are full and the system administration tool that monitors disks would use a single event channel. There would be a separate event channel to support the sales figures table and the documents that notice when the table data has changed.The event service does not make a policy for finding event channels. Finding a service is orthogonal to using the service. Higher levels of software (such as the desktop) can make policies for the usage of the event channel. That is, higher layers will dictate when an event channel is created and how references to the event channel are obtained. By representing the event channel as an object, it has all of the properties that apply to objects, including support by finding mechanisms. For example, when a user performs a "drag and drop" or "cut and paste" operation an event channel could be created and identified to suppliers and consumers.  Alternatively, the event channel could be named in a naming context, or it can be exported through an operation on an object.COMMUNICATION  MODELSWhen a consumer or supplier is added to the event channel, a style of communication is indicated. The method chosen to add a consumer defines the style of its communication with the event channel: addPushConsumer or addPullConsumer. Likewise, a supplier can be added with either addPushSupplier or addPullSupplier.Push model  -  Push allows a supplier of events to initiate the transfer of the event data to consumers (via an event channel), by invoking push operations on an object reference supporting the Consumer Interface. Consumers stop the delivery of events by invoking a disconnect operation on an object reference supporting the Disconnect interface. To set up a push-style communication, consumers and suppliers must exchange Consumer and Disconnect object references.Pull Model  -  Pull allows a consumer of events to request the event data from a supplier (via the Event Channel), by invoking pull operations on an object reference supporting the Supplier interface; suppliers stop the requests for events by invoking a disconnect operation on an object reference supporting the Disconnect interface. EVENT  DATAThe default push and pull operations of the Consumer and Supplier interfaces communicate event data as type Any. This allows generic services, such as an event channel, to consume, store and supply event data without understanding the type of the event data. Use of type any for event data does not mean that the data is untyped. Suppliers and consumers of event data need to agree on the type of the event data. Consumers of the event data need to interpret the data according to the agreed upon type.TYPED EVENT DATA -- see comment for class DSTTypedEventChannel.EXAMPLEThe following example illustrates the creation, finding and use of event channels. In this example, a document creates event channels and defines operations in its interface to allow consumers to be added. The document generates events when its title is changed and when a new section is added. 1	The document interface defines two operations to return event channels. Both operations return ConsumerAdmin object references.2	The document implementation contains instance variables for using and administering the event channels.3	At some point, the document implementation creates the event channel, gets supplier and consumer administrative references and adds itself as a supplier.4	The implementations of titleChanged simply returns the ConsumerAdmin object reference. Clients of this operation can add consumers. 5	When the title changes, the document implementation pushes the event to the channel.The document implementation similarly initializes, exports and uses the event channel for reporting new sections.</body></comment><class><name>DSTTransactionContext</name><environment>DST</environment><super>DST.DSTServiceContext</super><private>false</private><indexed-type>none</indexed-type><inst-vars>timeout current parents implementationSpecificData </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COS-Transactions</category><attributes><package>DST_COS_Services</package></attributes></class><class><name>DSTPushConsumer</name><environment>DST</environment><super>DST.DSTEventConnection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>supplier aspect hint </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COS-Events</category><attributes><package>DST_COS_Services</package></attributes></class><comment><class-id>DST.DSTPushConsumer</class-id><body>A DSTPushConsumer is the receiver and processor of event data produced by a push supplier (DSTPushSupplier).  This is part of the Common Object Services Specification 1.0 for Events.  See DSTEventChannel for a description of the service. Instance Variables 	supplier 	&lt;DSTPushSupplier&gt; --  the  push supplier that is processing events	aspect  		&lt;Symbol&gt; --  the push event selector to be sent to the host	hint  		&lt;String&gt; --  a parameter to be provided with the push event selector (optional)EXAMPLE:  PULL-CONSUMERWhen a consumer is set up to pull, it is notified of events as they happen.  For example, a system administration tool (consumer) wants to know immediately if a disk runs out of space. The software managing a disk (the supplier) is unaware of the existence of the system administration tool. The software simply reports that the disk is full. When a disk runs out of space, the system administration tool opens a window to inform the user which disk has run out of space.</body></comment><class><name>DSTLock</name><environment>DST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>count ownerId </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COS-Concurrency</category><attributes><package>DST_COS_Services</package></attributes></class><class><name>DSTRecoveryCoordinator</name><environment>DST</environment><super>DST.DSTPersistentObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>resource </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COS-Transactions</category><attributes><package>DST_COS_Services</package></attributes></class><class><name>DSTPullConsumer</name><environment>DST</environment><super>DST.DSTEventConnection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>supplier </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COS-Events</category><attributes><package>DST_COS_Services</package></attributes></class><comment><class-id>DST.DSTPullConsumer</class-id><body>A DSTPullConsumer is the receiver and processor of event data produced by a pull supplier (DSTPullSupplier).  This is part of the Common Object Services Specification 1.0 for Events.  See DSTEventChannel for a description of the service. Instance variables 	supplier 	&lt;DSTPullSupplier&gt; --  the  pull supplier that is processing eventsEXAMPLE:  PULL-CONSUMERWhen a consumer is set up to pull, it is notified of events as they happen.  For example, a system administration tool (consumer) wants to know immediately if a disk runs out of space. The software managing a disk (the supplier) is unaware of the existence of the system administration tool. The software simply reports that the disk is full. When a disk runs out of space, the system administration tool opens a window to inform the user which disk has run out of space.</body></comment><class><name>DSTTransaction</name><environment>DST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>timeOut status parent subtransactions resources subTransAwareResources </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COS-Transactions</category><attributes><package>DST_COS_Services</package></attributes></class><class><name>DSTTransactionalObject</name><environment>DST</environment><super>DST.DSTPersistentObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>status transaction </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COS-Transactions</category><attributes><package>DST_COS_Services</package></attributes></class><class><name>DSTRecoverableObject</name><environment>DST</environment><super>DST.DSTTransactionalObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>vote lockset </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COS-Transactions</category><attributes><package>DST_COS_Services</package></attributes></class><class><name>DSTSampleRecoverableObject</name><environment>DST</environment><super>DST.DSTRecoverableObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COS-Transactions</category><attributes><package>DST_COS_Services</package></attributes></class><class><name>DSTTransactionIdentifier</name><environment>DST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>formatId length transactionId </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COS-Transactions</category><attributes><package>DST_COS_Services</package></attributes></class><class><name>DSTTypedEventChannel</name><environment>DST</environment><super>DST.DSTEventChannel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COS-Events</category><attributes><package>DST_COS_Services</package></attributes></class><comment><class-id>DST.DSTTypedEventChannel</class-id><body>By default, event channels pass data of type "any."  However, it is more efficient to use a typed event channel, if you know during development what type of data will be passed (such as strings, integers, or specific structures that you have defined).  Also, you can use a typed event service to specify quality of service.  The default quality of service is to try to send event notification when the event occurs to all push-style consumers; if the consumer is not immediately available, the service waits until there is another event, then tries to send all pending event notifications. However, using the typed event service, you can specify different policies for retrying (for example, do not retry, retry every X minutes for X time period, retry X times then stop, etc.).NOTE: A typed event channel can support a combination of typed and untyped consumer-supplier pairs.  Of the typed consumer-supplier pairs, each can support a different type.  Thus for example, one event channel might support:  1 consumer-supplier pair that passes event data of type string, and that passes event data of type someStruct, and another that passes untyped (type any) data.</body></comment><class><name>DSTTypedPullSupplier</name><environment>DST</environment><super>DST.DSTPullSupplier</super><private>false</private><indexed-type>none</indexed-type><inst-vars>semaphore eventSignaller </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COS-Events</category><attributes><package>DST_COS_Services</package></attributes></class><comment><class-id>DST.DSTTypedPullSupplier</class-id><body>Works with DSTTypedEventChannel and DSTTypedPushConsumer to provide typed event services.  You should subclass from here to create specialized typed pull suppliers.(See also comments for DSTPullSupplier, DSTEventChannel and DSTTypedEventChannel.)Instance Variables:	semaphore 		&lt;Semaphore&gt;	eventSignaller 	&lt;Semaphore&gt;</body></comment><class><name>DSTProxySupplier</name><environment>DST</environment><super>DST.ORBObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>supplier </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COS-Events</category><attributes><package>DST_COS_Services</package></attributes></class><comment><class-id>DST.DSTProxySupplier</class-id><body>A DSTProxySupplier is an object that implements the behavior of proxy supplier as defined by OMGin the Common Object Services Specification for Events.Instance variables:	supplier	&lt;DSTPullSupplier | DSTPushSupplier | DSTTypedPullSupplier&gt; </body></comment><class><name>DSTProxyConsumer</name><environment>DST</environment><super>DST.ORBObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>consumer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COS-Events</category><attributes><package>DST_COS_Services</package></attributes></class><comment><class-id>DST.DSTProxyConsumer</class-id><body>A DSTProxyConsumer is an object that implements the behavior of proxy consumer as defined by OMGin the Common Object Services Specification for Events.Instance variables:	consumer	&lt;DSTPullConsumer | DSTPushConsumer | DSTTypedPushConsumer&gt; </body></comment><class><name>DSTTransactionalLock</name><environment>DST</environment><super>DST.DSTLock</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COS-Transactions</category><attributes><package>DST_COS_Services</package></attributes></class><class><name>DSTTypedPushConsumer</name><environment>DST</environment><super>DST.DSTPushConsumer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COS-Events</category><attributes><package>DST_COS_Services</package></attributes></class><comment><class-id>DST.DSTTypedPushConsumer</class-id><body>Works with DSTTypedEventChannel and DSTTypedPullSupplier to provide typed event services.  You should subclass from here to create specialized typed push consumers.(See also comments for DSTPushConsumer, DSTEventChannel and DSTTypedEventChannel.)</body></comment><class><name>DSTConcurrencyContext</name><environment>DST</environment><super>DST.DSTServiceContext</super><private>false</private><indexed-type>none</indexed-type><inst-vars>concurrencyId referenceCount </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COS-Concurrency</category><attributes><package>DST_COS_Services</package></attributes></class><shared-variable><name>ParentsDef</name><environment>DST.DSTTransactionContext</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_COS_Services</package></attributes></shared-variable><methods><class-id>DST.DSTLockCoordinator</class-id> <category>repository</category><body package="DST_COS_Services">CORBAName	"return the name of my CORBA interface in the repository"	^#'::CosConcurrencyControl::LockCoordinator'</body><body package="DST_COS_Services">abstractClassId	"return the abstract class Id of the receiver"	^'6f617e07-64da-0000-020f-1c683d000000' asUUID</body></methods><methods><class-id>DST.DSTLockCoordinator</class-id> <category>private</category><body package="DST_COS_Services">lockset: aLockset	"set the lockset of the receiver"	lockset := aLockset</body><body package="DST_COS_Services">transaction: aTransCoordinator	"set the transaction coordinator of the receiver"	transaction := aTransCoordinator</body></methods><methods><class-id>DST.DSTLockCoordinator</class-id> <category>LockCoordinator</category><body package="DST_COS_Services">dropLocks	"drop all of the locks in the LockSet, the concurrencyContext is the 	key which identifies the owner of the lock, by altering the current 	context, the coordinator can temporarily become the appropriate 	context"	lockset unlockAllForCoordinator</body></methods><methods><class-id>DST.DSTLockCoordinator class</class-id> <category>instance creation</category><body package="DST_COS_Services">new: aTransactionCoordinator lockset: aLockset 	"create and initialize an instance of the receiver"	| inst |	inst := ORBObject factoryFinder createObject: self getInstanceACL.	inst lockset: aLockset.	inst transaction: aTransactionCoordinator.	^inst</body></methods><methods><class-id>DST.DSTEventConnection</class-id> <category>private</category><body package="DST_COS_Services">connected: aBool 	"set the boolean that indicates whether or not there is a connection"	(aBool isKindOf: Boolean)		ifTrue: [connected := aBool == true]</body><body package="DST_COS_Services">disconnect	"disconnect the receiver from his host. As this is the public operation, 	we assume that this method was called by the supplier or consumer 	associated with this object, and that that object has already 	disconnected itself from its host."	connected ifFalse: [^self disconnectedError].	connected := false.	self destroy</body></methods><methods><class-id>DST.DSTEventConnection</class-id> <category>accessing</category><body package="DST_COS_Services">connected	"get the boolean that indicates whether or not there is a connection"	^connected</body><body package="DST_COS_Services">host	"get the host of the receiver"	^host</body><body package="DST_COS_Services">host: anObject 	"set the host of the receiver"	host := anObject</body></methods><methods><class-id>DST.DSTEventConnection</class-id> <category>exceptions</category><body package="DST_COS_Services">disconnectedError	"raise the Disconnected error"	^(CORBAConstants at: #'::CosEventComm::Disconnected')		raiseWith: Dictionary new errorString: ' the channel is already disconnected'</body></methods><methods><class-id>DST.DSTEventConnection</class-id> <category>printing</category><body package="DST_COS_Services">printOn: aStream 	"print a representation of the receiver"	super printOn: aStream.	aStream nextPutAll: ' for '.	host printOn: aStream</body></methods><methods><class-id>DST.DSTEventConnection</class-id> <category>intialize-release</category><body package="DST_COS_Services">initialize	"initialize the receiver"	super initialize.	connected := false</body></methods><methods><class-id>DST.DSTEventConnection class</class-id> <category>errror handling</category><body package="DST_COS_Services">disconnectedSignal	"Answer the signal used for Disconnected errors"	^CORBAConstants at: #'::CosEventComm::Disconnected'</body></methods><methods><class-id>DST.DSTPushSupplier</class-id> <category>accessing</category><body package="DST_COS_Services">consumer	"Answer the consumer"	^consumer</body><body package="DST_COS_Services">host: anEventHost consumer: aConsumer 	"set up the connection"	host := anEventHost.	consumer := aConsumer.	connected := true</body></methods><methods><class-id>DST.DSTPushSupplier</class-id> <category>repository</category><body package="DST_COS_Services">CORBAName	"return the name of my CORBA interface in the repository"	^#'::CosEventComm::PushSupplier'</body></methods><methods><class-id>DST.DSTPushSupplier</class-id> <category>private</category><body package="DST_COS_Services">checkEvent: anAny 	"check the event before processing"	^true</body><body package="DST_COS_Services">pushToConsumer: anEvent 	"pass this event to the consumer calling the appropriate operation defined 	in IDL. TypedPushSuppliers will override this message"	consumer pushEventData: anEvent</body></methods><methods><class-id>DST.DSTPushSupplier</class-id> <category>persistence</category><body package="DST_COS_Services">persistentState	"return a persistent state record for the receiver"	^Array		with: host 		with: consumer asInactiveObjRef		with: connected</body><body package="DST_COS_Services">restorePersistentState: anArray 	"restore my state from the persistent state array"	host := anArray at: 1.	consumer := anArray at: 2.	connected := anArray at: 3.	events := SharedQueue new</body></methods><methods><class-id>DST.DSTPushSupplier</class-id> <category>host messages</category><body package="DST_COS_Services">processEvent: anAny 	"add an event to the receiver."	| errors evt |	(self checkEvent: anAny)		ifFalse: [^nil].	events nextPut: anAny.	connected		ifTrue: 			[errors := false.			[(errors or: [events isDeadObject])				or: [events isEmpty]]				whileFalse: 					[evt := events next.					[self pushToConsumer: evt]						on: self errorSignal do: [:err | err getSignal == ORBObject invObjrefSignal							ifTrue: 								[(host asLocal isKindOf: DSTEventChannel)									ifTrue: [host removeSupplier: self].								self connected: false]							ifFalse: 								[errors := true.								Dialog onDebugNotify: 'EventSupplier&gt;&gt;pushEvent error: ' , err errorString , '. Event queued'.								events nextPut: evt.								1 to: events size - 1 do: [:i | events nextPut: events next]]]]]</body></methods><methods><class-id>DST.DSTPushSupplier</class-id> <category>initialize-release</category><body package="DST_COS_Services">initialize	"initialize the receiver"	super initialize.	events := SharedQueue new</body></methods><methods><class-id>DST.DSTPushSupplier</class-id> <category>PushSupplier</category><body package="DST_COS_Services">disconnectPushSupplier	"disconnect the receiver from his host. As this is the public operation, 	we assume that this method was called by the supplier or consumer 	associated with this object, and that that object has already 	disconnected itself from its host."	( host notNil )		ifTrue:	[	host removeSupplier: self.					^super disconnect				]</body></methods><methods><class-id>DST.DSTTransactionIdentity</class-id> <category>accessing</category><body package="DST_COS_Services">coordinator	^coordinator</body><body package="DST_COS_Services">coordinator: aTransactionCoordinator 	coordinator := aTransactionCoordinator</body><body package="DST_COS_Services">getControl	^coordinator getControl</body><body package="DST_COS_Services">otid	^transactionId</body><body package="DST_COS_Services">otid: aDSTTransactionId 	transactionId := aDSTTransactionId</body><body package="DST_COS_Services">terminator	^terminator</body><body package="DST_COS_Services">terminator: aTransactionTerminator 	terminator := aTransactionTerminator</body></methods><methods><class-id>DST.DSTTransactionIdentity</class-id> <category>repository</category><body package="DST_COS_Services">CORBAType	"return an instance of the DSTmetaObject subclass which can marshall an 	instance of the receiver."	^ORBObject lookupMetaId: #'::TSInteroperation::TransIdentity'</body></methods><methods><class-id>DST.DSTTransactionIdentity class</class-id> <category>instance creation</category><body package="DST_COS_Services">coordinator: aTransactionCoordinator terminator: aTransactionTerminator otid: aDSTTransactionId 	^(self new) 		coordinator: aTransactionCoordinator; 		terminator: aTransactionTerminator; 		otid: aDSTTransactionId; 		yourself</body></methods><methods><class-id>DST.DSTLockSet</class-id> <category>validation-private</category><body package="DST_COS_Services">validateIntentionRead: anOwnerId	"see if a intention read lock can be granted"	| locks |	granted == #write		ifTrue: 			[locks := self writeLocks.			locks size ~= 1 ifTrue: [^false].			^(locks at: 1) sameContext: anOwnerId]		ifFalse: 			[granted == nil ifTrue: [validation := #intentionRead].			^true]</body><body package="DST_COS_Services">validateIntentionWrite: anOwnerId	"see if a intention write lock can be granted"	|  locks |	(self validateUpgrade: anOwnerId)		ifTrue: [granted == #read				ifTrue: 					[locks := self readLocks.					locks size ~= 1 ifTrue: [^false].					^(locks at: 1) sameContext: anOwnerId]				ifFalse: 					[granted == #upgrade ifTrue: [validation := #intentionWrite].					^true]]		ifFalse: [^false]</body><body package="DST_COS_Services">validateRead: anOwnerId	"see if a read lock can be granted"	|  locks |	(self validateIntentionRead: anOwnerId)		ifTrue: [granted == #intentionWrite				ifTrue: 					[locks := self intentionWriteLocks.					locks size &gt; 1 ifTrue: [^false].					locks size ~= 1 ifTrue: [^false].					^(locks at: 1) sameContext: anOwnerId]				ifFalse: 					[granted == #intentionRead ifTrue: [validation := #read].					^true]]		ifFalse: [^false]</body><body package="DST_COS_Services">validateRequest: aLockEnum 	"based on the symbol see if the lock can be granted"	| ownerId context aLockSymbol |	aLockSymbol := aLockEnum name.	context := Processor activeProcess orbContext concurrencyContext.	context notNil		ifTrue: 			[ownerId := context concurrencyId.			aLockSymbol == #read ifTrue: [^self validateRead: ownerId].			aLockSymbol == #write ifTrue: [^self validateWrite: ownerId].			aLockSymbol == #upgrade ifTrue: [^self validateUpgrade: ownerId].			aLockSymbol == #intentionRead ifTrue: [^self validateIntentionRead: ownerId].			aLockSymbol == #intentionWrite ifTrue: [^self validateIntentionWrite: ownerId].			ORBObject badParamError: 0].	^false</body><body package="DST_COS_Services">validateUpgrade: anOwnerId	"see if a upgrade lock can be granted"	|  locks |	(self validateRead: anOwnerId)		ifTrue: [granted == #upgrade				ifTrue: 					[locks := self upgradeLocks.					locks size ~= 1 ifTrue: [^false].					^(locks at: 1) sameContext: anOwnerId]				ifFalse: 					[granted == #read ifTrue: [validation := #upgrade].					^true]]		ifFalse: [^false]</body><body package="DST_COS_Services">validateWrite: anOwnerId	"see if a write lock can be granted"	|  locks |	(self validateIntentionWrite: anOwnerId)		ifTrue: [granted == #intentionRead				ifTrue: 					[locks := self intentionReadLocks.					locks size ~= 1 ifTrue: [^false].					^(locks at: 1) sameContext: anOwnerId]				ifFalse: 					[granted == #intentionWrite ifTrue: [validation := #write].					^true]]		ifFalse: [^false]</body></methods><methods><class-id>DST.DSTLockSet</class-id> <category>LockSet</category><body package="DST_COS_Services">changeMode: heldModeEnum newMode: newModeEnum 	"Change the lock using the specified mode; block until lock acquired. 	Note that the code here is much the same as lock/unlock; the use 	of the mutex is slightly different."	| procede |	accessMutex		critical: 			[self dropLock: heldModeEnum.			(procede := self validateRequest: newModeEnum) ifTrue: [self addLock: newModeEnum]].	procede		ifFalse: 			[self blockForLock: newModeEnum]</body><body package="DST_COS_Services">getCoordinator: aTransactionCoordinator 	"return a lock coordinator for the specified transaction coordinator"	^DSTLockCoordinator new: aTransactionCoordinator lockset: self</body><body package="DST_COS_Services">lock: aLockEnum 	"Acquire the lock using the specified mode; block until lock acquired"	| procede |	accessMutex critical: [		(procede := self validateRequest: aLockEnum) 			ifTrue: [self addLock: aLockEnum]].	procede ifFalse: [self blockForLock: aLockEnum]</body><body package="DST_COS_Services">tryLock: aLockEnum 	"Attempt to acquire the lock using the specified mode; don't block"	accessMutex critical: [(self validateRequest: aLockEnum)			ifTrue: 				[self addLock: aLockEnum.				^true]			ifFalse: [^false]]</body><body package="DST_COS_Services">unlock: aLockEnum 	"Drop the lock using the specified mode; block until lock released"	accessMutex critical: [self dropLock: aLockEnum]</body></methods><methods><class-id>DST.DSTLockSet</class-id> <category>initialize-release</category><body package="DST_COS_Services">initialize	"Initialize the receiver"	self initializeLocks.	accessMutex := Semaphore forMutualExclusion.	semaphore := Semaphore new</body><body package="DST_COS_Services">initializeLocks	"Initialize the Dictionary of locks using symbols corresponding to the 	enumeration names as keys"	lockset := Dictionary new.	lockset at: #read put: nil.	lockset at: #write put: nil.	lockset at: #upgrade put: nil.	lockset at: #intentionRead put: nil.	lockset at: #intentionWrite put: nil.	^lockset</body><body package="DST_COS_Services">initializeRelated: aDSTLockset	"Initialize the receiver with the existing lockset."	aDSTLockset locks addDependent: self</body></methods><methods><class-id>DST.DSTLockSet</class-id> <category>persistence</category><body package="DST_COS_Services">copyPersistentState: anArray 	"copy my persistent state"	granted := anArray at: 1.	lockset := anArray at: 2.	accessMutex := anArray at: 3.	semaphore := anArray at: 4</body><body package="DST_COS_Services">persistentState	"return the persistent state of the receiver"	^Array		with: granted		with: lockset		with: accessMutex		with: semaphore</body><body package="DST_COS_Services">restorePersistentState: anArray 	"restore my persistent state"	granted := anArray at: 1.	lockset := anArray at: 2.	accessMutex := anArray at: 3.	semaphore := anArray at: 4</body></methods><methods><class-id>DST.DSTLockSet</class-id> <category>repository</category><body package="DST_COS_Services">CORBAName	"return the name of my CORBA interface in the repository"	^#'::CosConcurrencyControl::DSTLockSet'</body><body package="DST_COS_Services">abstractClassId	"return the abstract class Id of the receiver"	^'6d88e2ef-227a-0000-020f-1c683d000000' asUUID</body></methods><methods><class-id>DST.DSTLockSet</class-id> <category>accessing</category><body package="DST_COS_Services">allLocks	| locks |	locks := self writeLocks.	locks addAll: self intentionWriteLocks.	locks addAll: self upgradeLocks.	locks addAll: self readLocks.	locks addAll: self intentionReadLocks.	^locks</body><body package="DST_COS_Services">granted	^granted</body><body package="DST_COS_Services">intentionReadLocks	"return the set of intention read locks"	^self locksByMode: #intentionRead</body><body package="DST_COS_Services">intentionWriteLocks	"return the set of intention write locks"	^self locksByMode: #intentionWrite</body><body package="DST_COS_Services">locks	^lockset ifNil: [lockset := self initializeLocks]</body><body package="DST_COS_Services">locksByMode: aLockSymbol 	"return the set of write locks, initialize if nil"	| locks |	locks := self locks at: aLockSymbol.	locks isNil ifTrue: [locks := OrderedCollection new].	^locks</body><body package="DST_COS_Services">readLocks	"return the set of read locks"	^self locksByMode: #read</body><body package="DST_COS_Services">updateLocks	"return the set of update locks"	^self locksByMode: #update</body><body package="DST_COS_Services">upgradeLocks	"return the set of upgrade locks"	^self locksByMode: #upgrade</body><body package="DST_COS_Services">writeLocks	"return the set of write locks"	^self locksByMode: #write</body></methods><methods><class-id>DST.DSTLockSet</class-id> <category>private</category><body package="DST_COS_Services">addLock: aLockEnum 	"add a lock to the set"	| lock locks aLockSymbol |	aLockSymbol := aLockEnum name.	locks := self locks at: aLockSymbol.	locks isNil		ifTrue: 			[lock := DSTLock new initialize.			locks := OrderedCollection with: lock.			self locks at: aLockSymbol put: locks]		ifFalse: [lock := locks detect: [:lck | lck sameContext]						ifNone: 							[lock := DSTLock new initialize.							(self locks at: aLockSymbol)								add: lock.							lock]].	lock increment.	self resetGranted</body><body package="DST_COS_Services">blockForLock: aLockEnum 	"wait to acquire the specified lock"	semaphore wait.	self lock: aLockEnum</body><body package="DST_COS_Services">dropLock: aLockEnum 	"remove a lock from the set"	| locks lock aLockSymbol |		aLockSymbol := aLockEnum name.	locks := self locks at: aLockSymbol ifAbsent: [^self notHeldError].	locks isNil ifTrue: [^self notHeldError].	lock := locks detect: [:lck | lck sameContext]				ifNone: [nil].	lock isNil		ifTrue: [^self notHeldError]		ifFalse: 			[lock decrement.			lock count == 0				ifTrue: 					[locks remove: lock ifAbsent: [].					self resetGranted].			semaphore signal]</body><body package="DST_COS_Services">notHeldError	"raise the AlreadyConnected error"	^self class lockNotHeldSignal 		raiseWith: Dictionary new errorString: ' Operation requested on a lock not held.'</body><body package="DST_COS_Services">resetGranted	"reset the state of the highest granted lock"	self writeLocks isEmpty ifFalse: [^granted := #write].	self intentionWriteLocks isEmpty ifFalse: [^granted := #intentionWrite].	self upgradeLocks isEmpty ifFalse: [^granted := #upgrade].	self readLocks isEmpty ifFalse: [^granted := #read].	self intentionReadLocks isEmpty ifFalse: [^granted := #intentionRead].	^granted := nil</body></methods><methods><class-id>DST.DSTLockSet</class-id> <category>coordinator</category><body package="DST_COS_Services">unlockAllForCoordinator	"Drop all of the locks in the current lockset 	The coordinator does not use the concurrency context for validation, 	it can drop all locks associated with it's transaction"	accessMutex		critical: 			[self unlockForCoordinator: #write.			self unlockForCoordinator: #intentionWrite.			self unlockForCoordinator: #upgrade.			self unlockForCoordinator: #read.			self unlockForCoordinator: #intentionRead]</body><body package="DST_COS_Services">unlockForCoordinator: aLockSymbol 	"Drop the lock using the specified mode; block until lock released. 	The coordinator does not use the concurrency context for validation, 	it can drop all locks associated with it's transaction"	| locks removed |	locks := self locks at: aLockSymbol ifAbsent: [nil].	locks isNil		ifFalse: 			[removed := OrderedCollection new.			locks do: [:lock | lock isNil					ifFalse: 						[lock decrement.						lock count == 0 ifTrue: [removed add: lock].						semaphore signal]].			locks removeAll: removed.			self resetGranted]</body></methods><methods><class-id>DST.DSTLockSet</class-id> <category>validation</category><body package="DST_COS_Services">isHeld	"see if the receiver holds any lock in the set"	| locks held |	locks := self allLocks.	locks isNil ifTrue: [^false].	held := locks detect: [:lock | lock sameContext]				ifNone: [nil].	held isNil		ifTrue: [^false]		ifFalse: [^true]</body><body package="DST_COS_Services">isHeld: aLockEnum	"see if the receiver holds any lock in the set"	| locks held aLockSymbol |	aLockSymbol := aLockEnum name.	locks := self locksByMode: aLockSymbol.	locks isNil ifTrue: [^false].	held := locks detect: [:lock | lock sameContext]				ifNone: [nil].	held isNil		ifTrue: [^false]		ifFalse: [^true]</body></methods><methods><class-id>DST.DSTLockSet class</class-id> <category>repository</category><body package="DST_COS_Services">CORBAName	"return the name of my CORBA interface in the repository"	^#'::CosConcurrencyControl::LockSetFactory'</body></methods><methods><class-id>DST.DSTLockSet class</class-id> <category>LockSetFactory</category><body package="DST_COS_Services">create	"Create a new LockSet and LockCoordinator"	^ORBObject factoryFinder createObject: DSTLockSet getInstanceACL</body><body package="DST_COS_Services">createRelated: lockset	"Create a new LockSet that is related to an existing LockSet. Related lock sets drop their locks together."	^self create initializeRelated: lockset</body><body package="DST_COS_Services">createTransactional	"Create a new LockSet and LockCoordinator"	^ORBObject factoryFinder createObject: DSTTransactionalLockSet getInstanceACL</body><body package="DST_COS_Services">createTransactionalRelated: lockset	"Create a new LockSet that is related to an existing LockSet. Related lock sets drop their locks together."	^self createTransactional initializeRelated: lockset</body></methods><methods><class-id>DST.DSTLockSet class</class-id> <category>LockMode constants</category><body package="DST_COS_Services">intentionRead	"return the DSTEnumeration associated with the intentionRead lock mode"	^CORBAConstants at: #'::CosConcurrencyControl::lock_mode::intentionRead'</body><body package="DST_COS_Services">intentionWrite	"return the DSTEnumeration associated with the intentionWrite lock mode"	^CORBAConstants at: #'::CosConcurrencyControl::lock_mode::intentionWrite'</body><body package="DST_COS_Services">read	"return the DSTEnumeration associated with the read lock mode"	^CORBAConstants at: #'::CosConcurrencyControl::lock_mode::read'</body><body package="DST_COS_Services">upgrade	"return the DSTEnumeration associated with the upgrade lock mode"	^CORBAConstants at: #'::CosConcurrencyControl::lock_mode::upgrade'</body><body package="DST_COS_Services">write	"return the DSTEnumeration associated with the write lock mode"	^CORBAConstants at: #'::CosConcurrencyControl::lock_mode::write'</body></methods><methods><class-id>DST.DSTLockSet class</class-id> <category>Signal constants</category><body package="DST_COS_Services">lockNotHeldSignal	"Answer the signal used for reporting an operation on a lock not held"	^CORBAConstants at: #'::CosConcurrencyControl::LockNotHeld'</body></methods><methods><class-id>DST.DSTLockSet class</class-id> <category>utilities</category><body package="DST_COS_Services">resetAllContexts	"reset all concurrency context information in the image"	| procs |	procs := Process allInstances select: [:proc | proc orbContext concurrencyContext notNil].	procs do: [:proc | proc orbContext concurrencyContext: nil]</body><body package="DST_COS_Services">resetContext	Processor activeProcess orbContext concurrencyContext: nil.</body><body package="DST_COS_Services">setContext	| context |	context := Processor activeProcess orbContext concurrencyContext.	context isNil ifTrue: [context := self setContext: ORBObject newId].	^context</body><body package="DST_COS_Services">setContext: anId 	| context |	context := DSTConcurrencyContext concurrencyId: anId referenceCount: 0.	Processor activeProcess orbContext concurrencyContext: context.	^context</body></methods><methods><class-id>DST.DSTTransactionalLockSet</class-id> <category>private</category><body package="DST_COS_Services">addLock: aLockEnum owner: aCoordinator 	"add a lock to the set"	| lock locks aLockSymbol |	aLockSymbol := aLockEnum name.	locks := self locks at: aLockSymbol.	locks isNil		ifTrue: 			[lock := DSTTransactionalLock new initialize: aCoordinator hashTransaction.			locks := OrderedCollection with: lock.			self locks at: aLockSymbol put: locks]		ifFalse: [lock := locks detect: [:lck | lck sameContext: aCoordinator hashTransaction]						ifNone: 							[lock := DSTTransactionalLock new 										initialize: aCoordinator hashTransaction.							(self locks at: aLockSymbol)								add: lock.							lock]].	lock increment.	self resetGranted</body><body package="DST_COS_Services">blockForLock: aLockEnum owner: aCoordinator	"wait to acquire the specified lock"	semaphore wait.	self lock: aCoordinator mode: aLockEnum</body><body package="DST_COS_Services">dropLock: aLockEnum owner: aCoordinator	"remove a lock from the set in the specified transaction"	| locks lock aLockSymbol |		aLockSymbol := aLockEnum name.	locks := self locks at: aLockSymbol ifAbsent: [^self notHeldError].	locks isNil ifTrue: [^self notHeldError].	lock := locks detect: [:lck | lck sameContext: aCoordinator hashTransaction]				ifNone: [nil].	lock isNil		ifTrue: [^self notHeldError]		ifFalse: 			[lock decrement.			lock count == 0				ifTrue: 					[locks remove: lock ifAbsent: [].					self resetGranted].			semaphore signal]</body></methods><methods><class-id>DST.DSTTransactionalLockSet</class-id> <category>repository</category><body package="DST_COS_Services">CORBAName	"return the name of my CORBA interface in the repository"	^#'::CosConcurrencyControl::DSTTransactionalLockSet'</body><body package="DST_COS_Services">abstractClassId	"return the abstract class Id of the receiver"	^'6f7555da-b1d8-0000-020f-1c683d000000' asUUID</body></methods><methods><class-id>DST.DSTTransactionalLockSet</class-id> <category>TransactionalLockSet</category><body package="DST_COS_Services">changeMode: aCoordinator heldMode: heldModeEnum newMode: newModeEnum 	"Change the lock using the specified mode; block until lock acquired. 	Note that the code here is much the same as lock/unlock; the use 	of the mutex is slightly different."	| procede   |	accessMutex		critical: 			[self dropLock: heldModeEnum owner: aCoordinator.			(procede := self validateRequest: newModeEnum owner: aCoordinator) ifTrue: [self addLock: newModeEnum owner: aCoordinator]].	procede ifFalse: [self blockForLock: newModeEnum owner: aCoordinator]</body><body package="DST_COS_Services">lock: aCoordinator mode:  aLockEnum 	"Acquire the lock using the specified mode; block until lock acquired"	| procede |	accessMutex critical: [ (procede := self validateRequest: aLockEnum owner: aCoordinator) 			ifTrue: [self addLock: aLockEnum owner: aCoordinator]].	procede ifFalse: [self blockForLock: aLockEnum owner: aCoordinator]</body><body package="DST_COS_Services">tryLock: aCoordinator mode: aLockEnum 	"Attempt to acquire the lock using the specified mode; don't block"	accessMutex critical: [(self validateRequest: aLockEnum owner: aCoordinator)			ifTrue: 				[self addLock: aLockEnum owner: aCoordinator.				^true]			ifFalse: [^false]]</body><body package="DST_COS_Services">unlock: aCoordinator mode: aLockEnum 	"Drop the lock using the specified mode; block until lock released"	accessMutex critical: [self dropLock: aLockEnum owner: aCoordinator]</body></methods><methods><class-id>DST.DSTTransactionalLockSet</class-id> <category>validation</category><body package="DST_COS_Services">isHeld: aCoordinator	"see if the receiver holds any lock in the set"	| locks held |	locks := self allLocks.	locks isNil ifTrue: [^false].	held := locks detect: [:lock | lock sameContext: aCoordinator hashTransaction]				ifNone: [nil].	held isNil		ifTrue: [^false]		ifFalse: [^true]</body></methods><methods><class-id>DST.DSTTransactionalLockSet</class-id> <category>validation-private</category><body package="DST_COS_Services">validateRequest: aLockEnum owner: aCoordinator 	"based on the symbol see if the lock can be granted"	| ownerId aLockSymbol |	aLockSymbol := aLockEnum name.	aCoordinator notNil		ifTrue: 			[ownerId := aCoordinator hashTransaction.			aLockSymbol == #read ifTrue: [^self validateRead: ownerId].			aLockSymbol == #write ifTrue: [^self validateWrite: ownerId].			aLockSymbol == #upgrade ifTrue: [^self validateUpgrade: ownerId].			aLockSymbol == #intentionRead ifTrue: [^self validateIntentionRead: ownerId].			aLockSymbol == #intentionWrite ifTrue: [^self validateIntentionWrite: ownerId].			self error: 'Invalid Lock mode in request'].	^false</body></methods><methods><class-id>DST.DSTPullSupplier</class-id> <category>accessing</category><body package="DST_COS_Services">consumer	"Answer the consumer"	^consumer</body><body package="DST_COS_Services">host: anEventHost consumer: aConsumer 	"initialize the receiver"	host := anEventHost.	consumer := aConsumer.	connected := true</body></methods><methods><class-id>DST.DSTPullSupplier</class-id> <category>PullSupplier</category><body package="DST_COS_Services">disconnectPullSupplier	"disconnect the receiver from his host. As this is the public operation, 	we assume that this method was called by the supplier or consumer 	associated with this object, and that that object has already 	disconnected itself from its host."	host removeSupplier: self.	super disconnect</body><body package="DST_COS_Services">pull	"return the next event, blocking if necessary" 	connected ifFalse: [^self disconnectedError].	events isEmpty ifTrue: [host supplierNeedsEvent].	^events next"	connected 		ifFalse:	[ ^self disconnectedError ].	( events isEmpty ) 		ifTrue:	[ host supplierNeedsEvent ]		ifFalse:	[ ^events next ]"</body><body package="DST_COS_Services">tryPull	"return the next event, returning no data if necessary"	connected 		ifFalse:	[ ^self disconnectedError ].	( events isEmpty )		ifTrue:	[ host supplierNeedsEvent	].	^( events isEmpty )		ifTrue:	[ Dictionary with: #Result -&gt; 0 with: #hasEvent -&gt; false ]		ifFalse:	[ Dictionary with: #Result -&gt; events next with: #hasEvent -&gt; true ]</body><body package="DST_COS_Services">tryPull: aBoolean 	"return the next event, returning no data if necessary"	connected 		ifFalse:	[ ^self disconnectedError ].	( events isEmpty )		ifTrue:	[ host supplierNeedsEvent ].	^( events isEmpty )		ifTrue:	[	aBoolean value: false.					0				]		ifFalse:	[	aBoolean value: true.					events next				]</body></methods><methods><class-id>DST.DSTPullSupplier</class-id> <category>repository</category><body package="DST_COS_Services">CORBAName	"return the name of my CORBA interface in the repository"	^#'::CosEventComm::PullSupplier'</body></methods><methods><class-id>DST.DSTPullSupplier</class-id> <category>persistence</category><body package="DST_COS_Services">persistentState	"return a persistent state record for the receiver"	^Array		with: host 		with: consumer asInactiveObjRef		with: connected</body><body package="DST_COS_Services">restorePersistentState: anArray 	"restore my state from the persistent state array"	host := anArray at: 1.	consumer := anArray at: 2.	connected := anArray at: 3.	events := SharedQueue new</body></methods><methods><class-id>DST.DSTPullSupplier</class-id> <category>host messages</category><body package="DST_COS_Services">processEvent: anAny 	"add an event to the receiver"	events nextPut: anAny</body></methods><methods><class-id>DST.DSTPullSupplier</class-id> <category>initialize-release</category><body package="DST_COS_Services">initialize	"initialize the receiver"	super initialize.	events := SharedQueue new</body></methods><methods><class-id>DST.DSTEventChannel</class-id> <category>Event Channel</category><body package="DST_COS_Services">destroy	"destroy the receiver, cleaning up all internal Suppliers and 	Consumers"	pushSuppliers do: [:sup | sup disconnectPushSupplier].	pullSuppliers do: [:sup | sup disconnectPullSupplier].	pushConsumers do: [:con | con disconnectPushConsumer].	pullConsumers do: [:con | con disconnectPullConsumer].	exportedProxies do: [:prox | prox destroy].	super destroy</body><body package="DST_COS_Services">forConsumers	"return an objref of the ConsumerAdmin interface"	^self widenTo: #'::CosEventChannelAdmin::ConsumerAdmin'</body><body package="DST_COS_Services">forSuppliers	"return an objref of the SupplierAdmin interface"	^self widenTo: #'::CosEventChannelAdmin::SupplierAdmin'</body></methods><methods><class-id>DST.DSTEventChannel</class-id> <category>consumer messages</category><body package="DST_COS_Services">connectProxyPullConsumer: aPullConsumer 	"connect a proxy pull consumer to the event channel"	(pullConsumers includes: aPullConsumer)		ifTrue: [^self alreadyConnectedError]		ifFalse: 			[exportedProxies remove: aPullConsumer ifAbsent: [].			pullConsumers add: aPullConsumer]</body><body package="DST_COS_Services">connectProxyPushConsumer: aPushConsumer 	"connect a proxy psuh consumer to the event channel"	(pushConsumers includes: aPushConsumer)		ifTrue: [^self alreadyConnectedError]		ifFalse: 			[exportedProxies remove: aPushConsumer ifAbsent: [].			pushConsumers add: aPushConsumer]</body><body package="DST_COS_Services">processEvent: anAny 	"a proxy consumer has pushed an event. Pass this on to all 	outside consumers via my proxy suppliers"	pushSuppliers do: [:sup | sup processEvent: anAny].	pullSuppliers do: [:sup | sup processEvent: anAny]</body><body package="DST_COS_Services">removeConsumer: aConsumer 	"remove the supplier from the receiver"	| proxyConsumer |	proxyConsumer := pullConsumers detect: [:proxy | proxy consumer == aConsumer asLocal]				ifNone: [nil].	proxyConsumer notNil		ifTrue: 			[pullConsumers remove: proxyConsumer.			proxyConsumer destroy.			^self].	proxyConsumer := pushConsumers detect: [:proxy | proxy consumer == aConsumer asLocal]				ifNone: [nil].	proxyConsumer notNil		ifTrue: 			[pushConsumers remove: proxyConsumer.			proxyConsumer destroy.			^self]</body></methods><methods><class-id>DST.DSTEventChannel</class-id> <category>exceptions</category><body package="DST_COS_Services">alreadyConnectedError	"raise the AlreadyConnected error"	^(CORBAConstants at: #'::CosEventChannelAdmin::AlreadyConnected')		raiseWith: Dictionary new errorString: ' Already Connected to Event Channel'</body><body package="DST_COS_Services">typeErrorError	"raise the TypeError error"	^(CORBAConstants at: #'::CosEventChannelAdmin::TypeError')		raiseWith: Dictionary new errorString: ' Incorrect TypedSupplier'</body></methods><methods><class-id>DST.DSTEventChannel</class-id> <category>persistence</category><body package="DST_COS_Services">persistentState	"return a persistent state record for the receiver"	^Array		with: pullSuppliers		with: pullConsumers		with: pushSuppliers		with: pushConsumers		with: exportedProxies</body><body package="DST_COS_Services">restorePersistentState: anArray 	"restore my state from the persistent state array"	pullSuppliers := anArray at: 1.	pullConsumers := anArray at: 2.	pushSuppliers := anArray at: 3.	pushConsumers := anArray at: 4.	exportedProxies := anArray at: 5</body></methods><methods><class-id>DST.DSTEventChannel</class-id> <category>Supplier Admin</category><body package="DST_COS_Services">obtainPullConsumer	"return an objref of the ProxyPullConsumer interface"	^(exportedProxies add: (DSTProxyConsumer new consumer: (DSTPullConsumer new host: self)))		widenTo: #'CosEventChannelAdmin::ProxyPullConsumer'</body><body package="DST_COS_Services">obtainPushConsumer	"return an objref of the ProxyPushConsumer interface"	^(exportedProxies add: (DSTProxyConsumer new consumer: (DSTPushConsumer new host: self)))		widenTo: #'CosEventChannelAdmin::ProxyPushConsumer'</body></methods><methods><class-id>DST.DSTEventChannel</class-id> <category>Consumer Admin</category><body package="DST_COS_Services">obtainPullSupplier	"return an objref of the ProxyPullSupplier interface"	^(exportedProxies add: (DSTProxySupplier new supplier: (DSTPullSupplier new host: self)))		widenTo: #'CosEventChannelAdmin::ProxyPullSupplier'</body><body package="DST_COS_Services">obtainPushSupplier	"return an objref of the ProxyPushSupplier interface"	^(exportedProxies add: (DSTProxySupplier new supplier: (DSTPushSupplier new host: self)))		widenTo: #'CosEventChannelAdmin::ProxyPushSupplier'</body></methods><methods><class-id>DST.DSTEventChannel</class-id> <category>repository</category><body package="DST_COS_Services">CORBAName	"return the name of my CORBA interface in the repository"	^#'::CosEventChannelAdmin::DSTEventChannel'</body><body package="DST_COS_Services">abstractClassId	"return the abstract class Id of the receiver"	^'6492f1cb-6eb9-0000-020f-1c680a000000' asUUID</body></methods><methods><class-id>DST.DSTEventChannel</class-id> <category>initialization</category><body package="DST_COS_Services">initialize	"initialize the receiver"	super initialize.	pullConsumers := IdentitySet new.	pullSuppliers := IdentitySet new.	pushConsumers := IdentitySet new.	pushSuppliers := IdentitySet new.	exportedProxies := IdentitySet new</body></methods><methods><class-id>DST.DSTEventChannel</class-id> <category>supplier messages</category><body package="DST_COS_Services">connectProxyPullSupplier: aPullSupplier 	"connect a pull consumer to the event channel"	(pullSuppliers includes: aPullSupplier)		ifTrue: [^self alreadyConnectedError]		ifFalse: 			[exportedProxies remove: aPullSupplier ifAbsent: [].			pullSuppliers add: aPullSupplier]</body><body package="DST_COS_Services">connectProxyPushSupplier: aPushSupplier 	"connect a push supplier to the event channel"	(pushSuppliers includes: aPushSupplier)		ifTrue: [^self alreadyConnectedError]		ifFalse: 			[exportedProxies remove: aPushSupplier ifAbsent: [].			pushSuppliers add: aPushSupplier]</body><body package="DST_COS_Services">removeSupplier: aSupplier 	"remove the supplier from the receiver"	| proxySupplier |	proxySupplier := pullSuppliers detect: [:proxy | proxy supplier == aSupplier asLocal]				ifNone: [nil].	proxySupplier notNil		ifTrue: 			[pullSuppliers remove: proxySupplier.			proxySupplier destroy.			^self].	proxySupplier := pushSuppliers detect: [:proxy | proxy supplier == aSupplier asLocal]				ifNone: [nil].	proxySupplier notNil		ifTrue: 			[pushSuppliers remove: proxySupplier.			proxySupplier destroy.			^self]</body><body package="DST_COS_Services">supplierNeedsEvent	"a pull-supplier has received a pull request. Make sure any 	outstanding pull consumers have been polled"	| anEvent hasEvent |	pullConsumers 		do:	[:co | 				[	anEvent := co tryPullEventData: ( hasEvent := nil asCORBAParameter ).					( hasEvent value ) 						ifTrue: [ self processEvent: anEvent ]				]	on: Object errorSignal 					do: [:ex | ]			]</body></methods><methods><class-id>DST.DSTEventChannel class</class-id> <category>error handling</category><body package="DST_COS_Services">alreadyConnectedSignal	"Answer the signal used for AlreadyConnected errors"	^CORBAConstants at: #'::CosEventChannelAdmin::AlreadyConnected'</body><body package="DST_COS_Services">typeErrorSignal	"Answer the signal used for TypeError errors"	^CORBAConstants at: #'::CosEventChannelAdmin::TypeError'</body></methods><methods><class-id>DST.DSTTransactionContext</class-id> <category>accessing</category><body package="DST_COS_Services">current	"answer current transIdentity of the receiver, if necessary extract it 	from the contextData"	extracted ifFalse: [self extractContext].	^current</body><body package="DST_COS_Services">implementationSpecificData	"answer implementationSpecificData of the receiver, if necessary 	extract it from the contextData"	extracted ifFalse: [self extractContext].	^implementationSpecificData</body><body package="DST_COS_Services">parents	"answer collection of transIdentities of the receiver, if necessary 	extract it from the contextData"	extracted ifFalse: [self extractContext].	^parents</body><body package="DST_COS_Services">timeout	"answer timeout, if necessary extract timeout from the 	contextData"	extracted ifFalse: [self extractContext].	^timeout</body><body package="DST_COS_Services">timeout: anInteger 	"set the timeout and mark the context as modified"	extracted ifFalse: [self extractContext].	timeout := anInteger.	modified := true</body></methods><methods><class-id>DST.DSTTransactionContext</class-id> <category>private</category><body package="DST_COS_Services">encapsulateContextData	"answer an encapsulated data stream that contains the debugger 	context information"	| strm transIdentityDef |	^	[strm := CDRStream on: (ByteArray new: 100).	strm nextPutBoolean: strm byteOrder.	strm nextPutUnsignedLong: timeout.	transIdentityDef := ORBObject lookupMetaId: #'::TSInteroperation::TransIdentity'.	transIdentityDef marshall: current on: strm.	(DSTtypeSequence new subtype: transIdentityDef size: nil)		marshall: parents on: strm.	DSTtypeAny new marshall: implementationSpecificData on: strm.	modified := false.	strm contents]		on: self errorSignal do: [:ex | ORBObject badContextError: 0]</body><body package="DST_COS_Services">extractContext	"extract the context from contextData"	| strm transIdentityDef |		[strm := (CDRStream with: contextData) reset.	strm byteOrder: strm nextBoolean.	transIdentityDef := ORBObject lookupMetaId: #'::TSInteroperation::TransIdentity'.	timeout := strm nextUnsignedLong.	current := transIdentityDef unMarshall: strm.	parents := (DSTtypeSequence new subtype: transIdentityDef size: nil)				unMarshall: strm.	implementationSpecificData := DSTtypeAny new unMarshall: strm.	extracted := true]		on: self errorSignal do: [:ex | ORBObject badContextError: 0]</body><body package="DST_COS_Services">timeout: anInteger current: aDSTTransIdentity parents: aCollection 	"initialize the receiver"	timeout := anInteger.	current := aDSTTransIdentity.	parents := aCollection.	modified := extracted := true.	contextId := self class transactionServiceId</body></methods><methods><class-id>DST.DSTTransactionContext class</class-id> <category>private</category><body package="DST_COS_Services">installContext	"add the receiver to the dictionary of installed contexts"	InstalledContexts at: self transactionServiceId put: self</body></methods><methods><class-id>DST.DSTTransactionContext class</class-id> <category>instance creation</category><body package="DST_COS_Services">timeout: anInteger current: aDSTTransIdentity parents: aCollection 	^self basicNew		timeout: anInteger		current: aDSTTransIdentity		parents: aCollection</body></methods><methods><class-id>DST.DSTPushConsumer</class-id> <category>accessing</category><body package="DST_COS_Services">host: anObject supplier: anEventSupplier aspect: anAspectMessage 	"initialize the receiver"	host := anObject.	supplier := anEventSupplier.	aspect := (anAspectMessage asString , ':') asSymbol.	connected := true</body><body package="DST_COS_Services">host: anObject supplier: anEventSupplier aspect: aMsg hint: aAny	"initialize the receiver"	host := anObject.	supplier := anEventSupplier.	aspect := (aMsg asString , ':with:') asSymbol.	hint := aAny.	connected := true</body><body package="DST_COS_Services">supplier	"Answer the supplier"	^supplier</body></methods><methods><class-id>DST.DSTPushConsumer</class-id> <category>persistence</category><body package="DST_COS_Services">persistentState	"return a persistent state record for the receiver"	^Array		with: host 		with: supplier asInactiveObjRef		with: connected		with: aspect		with: hint</body><body package="DST_COS_Services">restorePersistentState: anArray 	"restore my state from the persistent state array"	host := anArray at: 1.	supplier := anArray at: 2.	connected := anArray at: 3.	aspect := anArray at: 4.	hint := anArray at: 5</body></methods><methods><class-id>DST.DSTPushConsumer</class-id> <category>PushConsumer</category><body package="DST_COS_Services">disconnectPushConsumer	"disconnect the receiver from his host. As this is the public operation, 	we assume that this method was called by the supplier or consumer 	associated with this object, and that that object has already 	disconnected itself from its host."	supplier disconnectPushSupplier.	host removeConsumer: self.	super disconnect</body><body package="DST_COS_Services">pushEventData: anAny 	"forward the event posting to the aspect of the client. Called by the 	supplier to post an event"	connected ifFalse: [^self disconnectedError].	hint isNil		ifTrue: [host perform: aspect with: anAny]		ifFalse: [host				perform: aspect				with: anAny				with: hint]</body></methods><methods><class-id>DST.DSTPushConsumer</class-id> <category>repository</category><body package="DST_COS_Services">CORBAName	"return the name of my CORBA interface in the repository"	^#'::CosEventComm::PushConsumer'</body></methods><methods><class-id>DST.DSTLock</class-id> <category>accessing</category><body package="DST_COS_Services">count	"return the current reference count set to 0 if nil"	^count ifNil: [count := 0]</body><body package="DST_COS_Services">count: aNumber	"set the current count "	^count := aNumber</body><body package="DST_COS_Services">decrement	| context |	self count: (self count - 1 max: 0).	context := Processor activeProcess orbContext concurrencyContext.	context notNil ifTrue: [context referenceCount: (context referenceCount - 1 max: 0)]</body><body package="DST_COS_Services">increment	| context |	self count: self count + 1.	context := Processor activeProcess orbContext concurrencyContext.	context notNil ifTrue: [context referenceCount: context referenceCount + 1]</body><body package="DST_COS_Services">ownerId	"return the lock's ownerId initialize to the current 	concurrencyContext concurrencyId if nil. If there is no 	concurrencyContext create one."	| context |	ownerId		ifNil: 			[context := Processor activeProcess orbContext concurrencyContext.			context isNil				ifTrue: 					[ownerId := ORBObject newId.					context := DSTConcurrencyContext concurrencyId: ownerId referenceCount: 0.					Processor activeProcess orbContext concurrencyContext: context]				ifFalse: [ownerId := context concurrencyId]].	^ownerId</body></methods><methods><class-id>DST.DSTLock</class-id> <category>testing</category><body package="DST_COS_Services">sameContext	"return true if the lock is heald by the same context"	| context |	context := Processor activeProcess orbContext concurrencyContext.	context isNil ifTrue: [^false]		ifFalse: [^self sameContext: context concurrencyId]</body><body package="DST_COS_Services">sameContext: anOwnerId 	"return true if the lock is held by the same transaction"	anOwnerId isNil		ifTrue: [^false]		ifFalse: [^self ownerId == anOwnerId]</body></methods><methods><class-id>DST.DSTLock</class-id> <category>initialization</category><body package="DST_COS_Services">initializeself ownerId</body></methods><methods><class-id>DST.DSTRecoveryCoordinator</class-id> <category>persistence</category><body package="DST_COS_Services">copyPersistentState: anArray 	"copy my persistent state"	self resource: (anArray at: 1)</body><body package="DST_COS_Services">persistentState	"return the persistent state of the receiver"	^Array		with: self resource</body><body package="DST_COS_Services">restorePersistentState: anArray 	"restore my persistent state"	self resource: (anArray at: 1)</body></methods><methods><class-id>DST.DSTRecoveryCoordinator</class-id> <category>repository</category><body package="DST_COS_Services">CORBAName	"return the name of my CORBA interface in the repository"	^#'::CosTransactions::DSTRecoveryCoordinator'</body><body package="DST_COS_Services">abstractClassId	"return the abstract class Id of the receiver"	^'6f66047d-851c-0000-020f-1c683d000000' asUUID</body></methods><methods><class-id>DST.DSTRecoveryCoordinator</class-id> <category>accessing</category><body package="DST_COS_Services">resource^resource</body><body package="DST_COS_Services">resource: aResourceresource := aResource</body></methods><methods><class-id>DST.DSTRecoveryCoordinator</class-id> <category>RecoveryCoordinator</category><body package="DST_COS_Services">replayCompletion: aResource	self notify: 'Under Construction'</body></methods><methods><class-id>DST.DSTRecoveryCoordinator class</class-id> <category>instance creation</category><body package="DST_COS_Services">new: aResource	| obj |	obj := super new initialize.	obj resource: aResource.	^obj</body></methods><methods><class-id>DST.DSTPullConsumer</class-id> <category>PullConsumer</category><body package="DST_COS_Services">disconnectPullConsumer	"disconnect the receiver from his host. As this is the public operation, 	we assume that this method was called by the supplier or consumer 	associated with this object, and that that object has already 	disconnected itself from its host."	supplier disconnectPullSupplier.	host removeConsumer: self.	super disconnect</body></methods><methods><class-id>DST.DSTPullConsumer</class-id> <category>host messages</category><body package="DST_COS_Services">pullEventData	"pull event data from the supplier"	^connected		ifTrue:	[ self privatePull ]		ifFalse:	[ self disconnectedError ]</body><body package="DST_COS_Services">tryPullEventData	"try to pull event data from the supplier"	connected		ifTrue: [^supplier tryPull]		ifFalse: [^self disconnectedError]</body><body package="DST_COS_Services">tryPullEventData: aBoolean 	"try to pull event data from the supplier"	connected		ifTrue: [^supplier tryPull: aBoolean]		ifFalse: [^self disconnectedError]</body></methods><methods><class-id>DST.DSTPullConsumer</class-id> <category>persistence</category><body package="DST_COS_Services">persistentState	"return a persistent state record for the receiver"	^Array		with: host 		with: supplier asInactiveObjRef		with: connected</body><body package="DST_COS_Services">restorePersistentState: anArray 	"restore my state from the persistent state array"	host := anArray at: 1.	supplier := anArray at: 2.	connected := anArray at: 3</body></methods><methods><class-id>DST.DSTPullConsumer</class-id> <category>accessing</category><body package="DST_COS_Services">host: anObject supplier: anEventSupplier 	"initialize the receiver"	host := anObject.	supplier := anEventSupplier.	connected := true</body><body package="DST_COS_Services">supplier	"Answer the supplier"	^supplier</body></methods><methods><class-id>DST.DSTPullConsumer</class-id> <category>repository</category><body package="DST_COS_Services">CORBAName	"return the name of my CORBA interface in the repository"	^#'::CosEventComm::PullConsumer'</body></methods><methods><class-id>DST.DSTPullConsumer</class-id> <category>private</category><body package="DST_COS_Services">privatePull	"... replaces the deprecated 'privatePullLoop'."	^supplier pull</body></methods><methods><class-id>DST.DSTTransaction</class-id> <category>Coordinator</category><body package="DST_COS_Services">createSubtransaction	"creat a new sub-transaction whose parent is the transaction 	associated with the target object"	| subtrans |	self getStatus = self class statusPrepared		ifTrue: [self class inactiveSignal raiseWith: Dictionary new errorString: 'transaction has been prepared']		ifFalse: 			[subtrans := (ORBObject factoryFinder createObject: self abstractClassId)						initialize: self timeOut parent: self getControl.			self subtransactions add: subtrans getControl.			^subtrans getControl]</body><body package="DST_COS_Services">getParentStatus	"return the status of the parent transaction if I am a 	topLevelTransaction I have no parent and there is no parent 	transaction"	self isTopLevelTransaction		ifTrue: [^self class statusNoTransaction]		ifFalse: [^parent getCoordinator getStatus]</body><body package="DST_COS_Services">getStatus	^status ifNil: [status := self class statusUnknown]</body><body package="DST_COS_Services">getTopLevelStatus	"Answer the status of the top-level transaction"	self isTopLevelTransaction		ifTrue: [^self getStatus]		ifFalse: [^parent getCoordinator getTopLevelStatus]</body><body package="DST_COS_Services">getTransactionName	^self printString</body><body package="DST_COS_Services">hashTopLevelTran	"Answer the status of the top-level transaction"	self isTopLevelTransaction		ifTrue: [^self hashTransaction]		ifFalse: [^parent getCoordinator hashTopLevelTran]</body><body package="DST_COS_Services">hashTransaction	"return the hash value of the receiver"	^self hash</body><body package="DST_COS_Services">isAncestorTransaction: aCoordinator 	"Answer true if and only if the transaction associated with the target 	object is a ancestor of the transaction associated with the parameter 	object"	(self isSameTransaction: aCoordinator)		ifTrue: [^true]		ifFalse: [^aCoordinator isDescendantTransaction: self getCoordinator]</body><body package="DST_COS_Services">isDescendantTransaction: aCoordinator 	"Answer true if and only if the transaction associated with the target 	object is a descendant of the transaction associated with the 	parameter object"	(self isSameTransaction: aCoordinator)		ifTrue: [^true]		ifFalse: [self isTopLevelTransaction				ifTrue: [^false]				ifFalse: [^parent getCoordinator isDescendantTransaction: aCoordinator]]</body><body package="DST_COS_Services">isRelatedTransaction: aCoordinator 	"Answer true if and only if the transactin associated with the target 	object is an ancestor of the parent transaction of the transaction 	associated with the parameter object"	(self isSameTransaction: aCoordinator)		ifTrue: [^true].	self isTopLevelTransaction		ifTrue: [^aCoordinator isDescendantTransaction: self]		ifFalse: [^parent getCoordinator isRelatedTransaction: aCoordinator]</body><body package="DST_COS_Services">isSameTransaction: aCoordinator 	"Answer true if and only if the target object and the parameter object 	both refer to the same transaction"	^(self getCoordinator == aCoordinator mustBeLocal)</body><body package="DST_COS_Services">isTopLevelTransaction	"Answer the status of the top-level transaction"	^parent isNil</body><body package="DST_COS_Services">registerResource: aResource 	"register a resource within the transaction"	self getStatus = self class statusPrepared		ifTrue: [self class inactiveSignal 			raiseWith: Dictionary new errorString: 'transaction has been prepared']		ifFalse: 			[self resources add: aResource.			^DSTRecoveryCoordinator new resource: aResource]</body><body package="DST_COS_Services">registerSubtranAware: aSubtransactionAwareResource 	"register the subtransaction aware resource"	| recoveryCoordinator |	self isTopLevelTransaction		ifTrue: [self class notSubtransactionSignal raiseWith: Dictionary new errorString: 'not in a subtransaction']		ifFalse: 			[recoveryCoordinator := self registerResource: aSubtransactionAwareResource.			self subTransAwareResources add: aSubtransactionAwareResource.			^recoveryCoordinator]</body><body package="DST_COS_Services">rollbackOnly	self getStatus = self class statusPrepared		ifTrue: [self class inactiveSignal raiseWith: Dictionary new errorString: 'transaction has been prepared']		ifFalse: 			[self status: self class statusMarkedRollback]</body><body package="DST_COS_Services">xregisterResource: aResource 	"register a resource within the transaction"	self getStatus = self class statusPrepared		ifTrue: [self class inactiveSignal raiseWith: Dictionary new errorString: 'transaction has been prepared']		ifFalse: 			[self resources add: aResource.			^(ORBObject factoryFinder createObject: DSTRecoveryCoordinator getInstanceACL)				resource: aResource]</body></methods><methods><class-id>DST.DSTTransaction</class-id> <category>accessing</category><body package="DST_COS_Services">resources	^resources ifNil: [resources := OrderedCollection new]</body><body package="DST_COS_Services">status: newStatus 	status := newStatus</body><body package="DST_COS_Services">subTransAwareResources	^subTransAwareResources ifNil: [subTransAwareResources := OrderedCollection new]</body><body package="DST_COS_Services">subtransactions	^subtransactions ifNil: [subtransactions := OrderedCollection new]</body></methods><methods><class-id>DST.DSTTransaction</class-id> <category>private</category><body package="DST_COS_Services">commitSubtransactions: aBoolean"ask my subtransactions to commit. If an exception is raised, allow it to be propogated back up"subtransactions notNil 	ifTrue: 		[subtransactions do: 			[:subtrans| subtrans getTerminator commit: aBoolean]]</body><body package="DST_COS_Services">commitTransaction: votes 	"Ask each of my resources to commit. Votes is a dictionary	of resource-vote pairs. Set my status accordingly.	Optimize for the case where all resources vote read only"	(votes reject: [:vote | vote = self class voteReadOnly]) isEmpty		ifTrue: 			[self status: self class statusCommitted.			^self].	(votes reject: [:vote | vote = self class voteRollback]) isEmpty		ifTrue: 			[self status: self class statusRolledBack.			self class transactionRolledBackSignal raiseWith: 				Dictionary new errorString: 'transaction has been rolled back'.			^self].	(votes select: [:vote | vote = self class voteCommit]) keys		do: [:resource | resource commit].	self status: self class statusCommitted.	^self</body><body package="DST_COS_Services">notifySubTransAwareResourcesOfCommit	self subTransAwareResources do: [:resource | resource commitSubtransaction: parent getCoordinator]</body><body package="DST_COS_Services">notifySubTransAwareResourcesOfRollback	self subTransAwareResources do: [:resource | resource rollbackSubtransaction]</body><body package="DST_COS_Services">prepareTransaction: votes 	"inform my resources that the transaction is to be prepared. 	If we get a rollback vote, roll back the transaction and return 	false. Otherwise return true. Set my status accordingly. Votes 	is a dictionary of resource-vote pairs."	| someoneVotedRollback copiedResources |	someoneVotedRollback := false.	copiedResources := self resources copy.	copiedResources		do: 			[:resource | 			| vote |			vote := resource prepare.			vote = self class voteRollback ifTrue: [someoneVotedRollback := true].			votes at: resource put: vote].	someoneVotedRollback		ifTrue: 			[self rollbackTransaction: (votes select: [:v | v = self class voteCommit]) keys.			self class transactionRolledBackSignal raiseWith: Dictionary new errorString: 'transaction has been rolled back'.			^false].	self status: self class statusPrepared.	^true</body><body package="DST_COS_Services">rollbackTransaction: resourceList	"inform my resources that the transaction is to be rolled back.	Set my status accordingly."	resourceList do: [:resource | resource rollback].	self status: self class statusRolledBack</body><body package="DST_COS_Services">xprepareTransaction: votes 	"inform my resources that the transaction is to be prepared. 	If we get a rollback vote, roll back the transaction and return 	false. Otherwise return true. Set my status accordingly. Votes 	is a dictionary of resource-vote pairs."	self resources		do: 			[:resource | 			| vote |			vote := resource prepare.			vote = self class voteRollback				ifTrue: 					[self rollbackTransaction: (votes select: [:v | v = self class voteCommit]) keys.					self class transactionRolledBackSignal raiseWith: Dictionary new errorString: 'transaction has been rolled back'.					^false].			votes at: resource put: vote].	self status: self class statusPrepared.	^true</body></methods><methods><class-id>DST.DSTTransaction</class-id> <category>DSTControl</category><body package="DST_COS_Services">destroy	"destroy the receiver. Unmap it from the ORB, then convert it to a 	dead object"	super destroy.	1 to: self class instSize do: [:i | self instVarAt: i put: ORBDeadObject deadObject]</body><body package="DST_COS_Services">getControl	"Answer an objref of the Control interface"	^self</body><body package="DST_COS_Services">getCoordinator	"Answer an objref of the Coordinator interface"	^self "widenTo: #'::CosTransactions::Coordinator'"</body><body package="DST_COS_Services">getTerminator	"Answer an objref of the Terminator interface"	^self "widenTo: #'::CosTransactions::Terminator'"</body><body package="DST_COS_Services">reset	"reset the state of the transaction context by removing this 	transaction's informationfrom the context"	self isTopLevelTransaction		ifTrue: [	self class resetContext.]		ifFalse: [parent remove: self getControl].	self destroy.</body><body package="DST_COS_Services">timeOut	^timeOut ifNil: [timeOut := 0]</body><body package="DST_COS_Services">timeOut: aValue	timeOut := aValue</body><body package="DST_COS_Services">xreset	"reset the state of the transaction context by removing this 	transaction's informationfrom the context"	self isTopLevelTransaction		ifTrue: [	self class resetContext.]		ifFalse: [parent remove: self getControl]</body></methods><methods><class-id>DST.DSTTransaction</class-id> <category>printing</category><body package="DST_COS_Services">printOn: aStream 	"print a representation of the receiver"	super printOn: aStream.	aStream nextPutAll: ' with ', self getStatus asString</body></methods><methods><class-id>DST.DSTTransaction</class-id> <category>Terminator</category><body package="DST_COS_Services">commit: aBoolean 	"commit the transaction using the object associated with the recovery 	coordinator and a two phase commit protocol. In general prepare the 	transaction and if everyone votes to commit, commit each. This 	operation returns void, however exceptions may be raised. For 	subtransactions we ask them to commit and on failure allow the 	exception to be propagated back. 		Optimize for: 	- the case where there is a single resource 	- where the transaction is marked to roll back"	| votes |	self getStatus = self class statusMarkedRollback ifTrue: [self rollbackTransaction: resources].	self getStatus = self class statusRolledBack ifTrue: [aBoolean			ifTrue: 				[self class heuristicHazardSignal raiseWith: Dictionary new errorString: 'transaction has been rolled back'.				^self]].	self commitSubtransactions: aBoolean.	votes := Dictionary new.	[self resources size == 1		ifTrue: 			[(resources at: 1) commitOnePhase.			self status: self class statusCommitted.			self notifySubTransAwareResourcesOfCommit]		ifFalse: [(self prepareTransaction: votes)				ifTrue: 					[self commitTransaction: votes.					self notifySubTransAwareResourcesOfCommit]				ifFalse: [self notifySubTransAwareResourcesOfRollback]]]		on: Object errorSignal		do: 			[:x | 			"Should we check for other transaction service exceptions and reject them"			self status: self class statusRolledBack.			self notifySubTransAwareResourcesOfRollback.			aBoolean				ifTrue: 					[self class heuristicHazardSignal raiseWith: Dictionary new errorString: 'transaction has been rolled back'.					^self]]</body><body package="DST_COS_Services">rollback	"roll back the current transaction"	^self rollbackTransaction: resources</body></methods><methods><class-id>DST.DSTTransaction</class-id> <category>repository</category><body package="DST_COS_Services">CORBAName	"return the name of my CORBA interface in the repository"	^#'::CosTransactions::DSTTransaction'</body><body package="DST_COS_Services">abstractClassId	"return the abstract class Id of the receiver"	^'6e6b3d6a-ddad-0000-020f-1c683d000000' asUUID</body></methods><methods><class-id>DST.DSTTransaction</class-id> <category>initialize-release</category><body package="DST_COS_Services">initialize	"initialize an instance of a Transaction"	^(self initialize: 0) getControl</body><body package="DST_COS_Services">initialize: timeout 	"initialize an instance of a Transaction and set up the current 	transaction context and return its coordinator.	Set a sensible initial status value."	| transactionCxt transIdentity |	self timeOut: timeout.	transIdentity := DSTTransactionIdentity				coordinator: self getCoordinator				terminator: self getTerminator				otid: DSTTransactionIdentifier nullId.	transactionCxt := DSTTransactionContext				timeout: timeOut				current: transIdentity				parents: OrderedCollection new.		self status: (DSTTransaction statusActive).	Processor activeProcess orbContext transactionContext: transactionCxt.	^self</body><body package="DST_COS_Services">initialize: timeout parent: aParentTransactionController 	"initialize an instance of a Transaction as a sub-transaction with the 	given transaction as its parent and return its coordinator"	| transactionCxt |	self timeOut: timeout.	aParentTransactionController isNil		ifFalse: 			[parent := aParentTransactionController.			transactionCxt := Processor activeProcess orbContext transactionContext.			transactionCxt parents add: (DSTTransactionIdentity					coordinator: aParentTransactionController getCoordinator					terminator: aParentTransactionController getTerminator					otid: DSTTransactionIdentifier nullId)]</body></methods><methods><class-id>DST.DSTTransaction class</class-id> <category>repository</category><body package="DST_COS_Services">CORBAName	"return the name of my CORBA interface in the repository"	^#'::CosTransactions::DSTTransactionFactory'</body></methods><methods><class-id>DST.DSTTransaction class</class-id> <category>Factory</category><body package="DST_COS_Services">create: timeOut 	"create an instance of a Transaction and return its coordinator Modify 	the transaction context of the current thread to associate the thread 	with the new transaction"	^((ORBObject factoryFinder createObject: self getInstanceACL)		initialize: 0)</body></methods><methods><class-id>DST.DSTTransaction class</class-id> <category>Signal constants</category><body package="DST_COS_Services">heuristicCommitSignal	"Answer the signal used for "	^CORBAConstants at: #'::CosTransactions::HeuristicCommit'</body><body package="DST_COS_Services">heuristicHazardSignal	"Answer the signal used for"	^CORBAConstants at: #'::CosTransactions::HeuristicHazard'</body><body package="DST_COS_Services">heuristicMixedSignal	"Answer the signal used for"	^CORBAConstants at: #'::CosTransactions::HeuristicMixed'</body><body package="DST_COS_Services">heuristicRollbackSignal	"Answer the signal used for "	^CORBAConstants at: #'::CosTransactions::HeuristicRollback'</body><body package="DST_COS_Services">inactiveSignal	"Answer the signal used for"	^CORBAConstants at: #'::CosTransactions::Inactive'</body><body package="DST_COS_Services">invalidControlSignal	"Answer the signal used for"	^CORBAConstants at: #'::CosTransactions::InvalidControl'</body><body package="DST_COS_Services">invalidTransactionSignal	"Answer the signal used for"	^CORBAConstants at: #'::CosTransactions::InvalidTransaction'</body><body package="DST_COS_Services">noTransactionSignal	"Answer the signal used for"	^CORBAConstants at: #'::CosTransactions::NoTransaction'</body><body package="DST_COS_Services">notPreparedSignal	"Answer the signal used for"	^CORBAConstants at: #'::CosTransactions::NotPrepared'</body><body package="DST_COS_Services">notSubtransactionSignal	"Answer the signal used for "	^CORBAConstants at: #'::CosTransactions::NotSubtransaction'</body><body package="DST_COS_Services">subtransactionsUnavailableSignal	"Answer the signal used for "	^CORBAConstants at: #'::CosTransactions::SubtransactionsUnavailable'</body><body package="DST_COS_Services">transactionRequiredSignal	"Answer the signal used for"	^CORBAConstants at: #'::CosTransactions::TransactionRequired'</body><body package="DST_COS_Services">transactionRolledBackSignal	"Answer the signal used for"	^CORBAConstants at: #'::CosTransactions::TransactionRolledBack'</body><body package="DST_COS_Services">unavailableSignal	"Answer the signal used for "	^CORBAConstants at: #'::CosTransactions::Unavailable'</body><body package="DST_COS_Services">wrongTransactionSignal	"Answer the signal used for "	^CORBAConstants at: #'::CosTransactions::WrongTransaction'</body></methods><methods><class-id>DST.DSTTransaction class</class-id> <category>utilities</category><body package="DST_COS_Services">resetContext	"reset the transaction context in the current thread of control"	Processor activeProcess orbContext transactionContext: nil</body></methods><methods><class-id>DST.DSTTransaction class</class-id> <category>Status constants</category><body package="DST_COS_Services">statusActive	^CORBAConstants at: #'::CosTransactions::Status::StatusActive'</body><body package="DST_COS_Services">statusCommitted	^CORBAConstants at: #'::CosTransactions::Status::StatusCommitted'</body><body package="DST_COS_Services">statusMarkedRollback	^CORBAConstants at: #'::CosTransactions::Status::StatusMarkedRollback'</body><body package="DST_COS_Services">statusNoTransaction	^CORBAConstants at: #'::CosTransactions::Status::StatusNoTransaction'</body><body package="DST_COS_Services">statusPrepared	^CORBAConstants at: #'::CosTransactions::Status::StatusPrepared'</body><body package="DST_COS_Services">statusRolledBack	^CORBAConstants at: #'::CosTransactions::Status::StatusRolledBack'</body><body package="DST_COS_Services">statusUnknown	^CORBAConstants at: #'::CosTransactions::Status::StatusUnknown'</body></methods><methods><class-id>DST.DSTTransaction class</class-id> <category>Vote constants</category><body package="DST_COS_Services">voteCommit	^CORBAConstants at: #'::CosTransactions::Vote::VoteCommit'</body><body package="DST_COS_Services">voteReadOnly	^CORBAConstants at: #'::CosTransactions::Vote::VoteReadOnly'</body><body package="DST_COS_Services">voteRollback	^CORBAConstants at: #'::CosTransactions::Vote::VoteRollback'</body></methods><methods><class-id>DST.DSTTransactionalObject</class-id> <category>persistence</category><body package="DST_COS_Services">copyPersistentState: anArray 	"copy my persistent state"	self transaction: (anArray at: 1)</body><body package="DST_COS_Services">persistentState	"return the persistent state of the receiver"	^Array		with: self transaction</body><body package="DST_COS_Services">restorePersistentState: anArray 	"copy my persistent state"	self transaction: (anArray at: 1)</body></methods><methods><class-id>DST.DSTTransactionalObject</class-id> <category>Current</category><body package="DST_COS_Services">beginTransaction	"Create a new transaction within the current thread."	self transaction isNil		ifTrue: 			[DSTTransaction create: 0.			self transaction: Processor activeProcess orbContext transactionContext current]		ifFalse: [self transaction coordinator createSubtransaction].	status := DSTTransaction statusActive</body><body package="DST_COS_Services">commitTransaction: aBoolean 	"If there is no transaction associated with the current thread raise 	the NoTransaction exception. If the client does not have permission, 	raise the NoPermission exception. Otherwise invoke the commit 	operation on my associated transaction"	(self transaction isNil or: [status = DSTTransaction statusNoTransaction])		ifTrue: [DSTTransaction noTransactionSignal 					raiseWith: Dictionary new 					errorString: 'no transaction in effect']		ifFalse: 			[self terminator commit: aBoolean.			self transaction getControl reset]</body><body package="DST_COS_Services">getTransactionControl	"return an object that supports the control interface associated with 	my transaction if there is no transaction return nil"	self transaction isNil		ifTrue: [^nil]		ifFalse: [^self transaction getControl]</body><body package="DST_COS_Services">getTransactionName	"If there is no transaction associated with the current thread 	return an empty string. Otherwise return the name of my associated 	transaction."	transaction isNil		ifTrue: [^'']		ifFalse: [^transaction coordinator getTransactionName]</body><body package="DST_COS_Services">getTransactionStatus	"If there is no transaction associated with the current thread	return StatusNoTransaction. Otherwise return the status of 	my associated transaction."	transaction isNil		ifTrue: [^DSTTransaction statusNoTransaction]		ifFalse: [^status]</body><body package="DST_COS_Services">resumeTransaction: aTransaction 	| transIdentity transactionCxt |	transIdentity := DSTTransactionIdentity				coordinator: aTransaction getCoordinator				terminator: aTransaction getTerminator				otid: DSTTransactionIdentifier nullId.	transactionCxt := DSTTransactionContext				timeout: aTransaction timeOut				current: transIdentity				parents: OrderedCollection new.	Processor activeProcess orbContext transactionContext: transactionCxt.	self transaction: transIdentity.	status := DSTTransaction statusActive</body><body package="DST_COS_Services">rollbackOnlyTransaction	"If there is no transaction associated with the current thread the 	getter for the coordinator will raise the NoTransaction exception. 	Otherwise invoke the rollbackOnly operation on my 	associated transaction"	(self transaction isNil or: [status = DSTTransaction statusNoTransaction])		ifTrue: [DSTTransaction noTransactionSignal 					raiseWith: Dictionary new errorString: 'no transaction in effect']		ifFalse: [self coordinator rollbackOnly]</body><body package="DST_COS_Services">rollbackTransaction	"If there is no transaction associated with the current thread the 	getter for the terminator will raise the NoTransaction exception. 	If the client does not have permission, raise the NoPermission 	exception. Otherwise invoke the rollback operation on my 	associated transaction"	(self transaction isNil or: [status = DSTTransaction statusNoTransaction])		ifTrue: [DSTTransaction noTransactionSignal 					raiseWith: Dictionary new 					errorString: 'no transaction in effect']		ifFalse: 			[self terminator rollback.			self transaction getControl reset]</body><body package="DST_COS_Services">setTransactionTimeOut: anInteger	(self transaction isNil or: [status = DSTTransaction statusNoTransaction])		ifTrue: [DSTTransaction noTransactionSignal 					raiseWith: Dictionary new errorString: 'no transaction in effect']		ifFalse: [self terminator timeOut: anInteger]</body><body package="DST_COS_Services">suspendTransaction	| control |	control := self getTransactionControl.	status := DSTTransaction statusNoTransaction.	^control</body></methods><methods><class-id>DST.DSTTransactionalObject</class-id> <category>repository</category><body package="DST_COS_Services">CORBAName	"return the name of my CORBA interface in the repository"	^#'::CosTransactions::DSTTransactionalObject'</body><body package="DST_COS_Services">abstractClassId	"return the abstract class Id of the receiver"	^'733f2bd4-9a20-0000-020f-005b2e000000' asUUID</body></methods><methods><class-id>DST.DSTTransactionalObject</class-id> <category>private</category><body package="DST_COS_Services">coordinator	"return the coordinator of my associated transaction if there is no 	transaction return nil"	self transaction isNil		ifTrue: [^nil]		ifFalse: [^self transaction coordinator]</body><body package="DST_COS_Services">resetTransaction	"reset my transaction instance variable and reset the current 	transactionContext"	self transaction notNil ifTrue: [ self transaction getControl reset].	self transaction: nil.</body><body package="DST_COS_Services">terminator	"return the terminator of my associated transaction if there is no 	transaction return nil"	self transaction isNil		ifTrue: [^nil]		ifFalse: [^self transaction terminator]</body><body package="DST_COS_Services">transaction	Processor activeProcess orbContext transactionContext isNil		ifTrue: [^nil]		ifFalse: [^Processor activeProcess orbContext transactionContext current]</body><body package="DST_COS_Services">transaction: aTransactionControlObject 	"transaction objects are objects which respond to the 	CosTransactions::Control interface"	transaction := aTransactionControlObject</body></methods><methods><class-id>DST.DSTTransactionalObject</class-id> <category>initialize-release</category><body package="DST_COS_Services">initialize	super initialize.	status := DSTTransaction statusUnknown</body></methods><methods><class-id>DST.DSTRecoverableObject</class-id> <category>persistence</category><body package="DST_COS_Services">copyPersistentState: anArray	"copy my state from the persistent state array"	super copyPersistentState: (anArray at: 1).	status := (anArray at: 2).	vote := (anArray at: 3).	lockset := (anArray at: 4).</body><body package="DST_COS_Services">persistentState	"return an information array about the receiver"	^Array		with: super persistentState		with: status		with: vote		with: lockset</body><body package="DST_COS_Services">restorePersistentState: anArray	"restore my state from the persistent state array"	super restorePersistentState: (anArray at: 1).	status := (anArray at: 2).	vote := (anArray at: 3).	lockset := (anArray at: 4).</body></methods><methods><class-id>DST.DSTRecoverableObject</class-id> <category>Resource</category><body package="DST_COS_Services">commit	"If necessary, commit all changes made as part of the transaction. 	If the transaction has been forgotten we do nothing. Same thing 	if we VoteReadOnly. If we have not been prepared, raise an 	exception"	((self transaction isNil or: [self vote = DSTTransaction voteReadOnly])		or: [status = DSTTransaction statusCommitted])		ifTrue: []		ifFalse: [status = DSTTransaction statusPrepared				ifTrue: [self commitState						ifTrue: [status := DSTTransaction statusCommitted]						ifFalse: [DSTTransaction heuristicRollbackSignal raiseWith: Dictionary new errorString: 'transaction has been rolled back']]				ifFalse: [DSTTransaction notPreparedSignal raiseWith: Dictionary new errorString: 'resource has not been prepared']].	"Resource objects can (?) forget their transactions on commit or rollback if no exceptions are raised"	self forget</body><body package="DST_COS_Services">commitOnePhase	"A one phase commit is invoked as an optimization when a 	transaction only holds onto a single resource. This means that the 	resource does not need to prepare for a rollback request. A commit 	only makes sense within a transaction or when I'm not marked 	ReadOnly."	self vote = DSTTransaction voteRollback		ifTrue: 			[self rollback.			DSTTransaction transactionRolledBackSignal raiseWith: Dictionary new errorString: 'commit failed']		ifFalse: [(self transaction isNil or: [self vote = DSTTransaction voteReadOnly])				ifTrue: ["no need to do anything"]				ifFalse: [self prepareState						ifTrue: [self commitState								ifTrue: [status := DSTTransaction statusCommitted]								ifFalse: [DSTTransaction heuristicRollbackSignal raiseWith: Dictionary new errorString: 'transaction has been rolled back']]						ifFalse: [DSTTransaction heuristicRollbackSignal raiseWith: Dictionary new errorString: 'transaction has been rolled back']]].	"Resource objects can (?) forget their transactions on commit or rollback if no exceptions are raised"	self forget</body><body package="DST_COS_Services">forget	"This operation is performed if a resource raised an heuristic 	exception to a rollback or a commit. Forget all knowledge of 	the transaction"	self transaction: nil.	status := DSTTransaction statusNoTransaction.	vote := DSTTransaction voteReadOnly</body><body package="DST_COS_Services">prepare	"This operation is invoked to begin the two-phase commit protocol.  If the we VoteReadOnly, the transaction can be forgotten.  If we VoteRollback rollback then forget the transaction and set status accordingly.  If we VoteCommit, prepare ourselves to either commit or roll back."	self vote = DSTTransaction voteRollback		ifTrue:	[	self rollback.					^DSTTransaction voteRollback				].	"Here only to note the implicit branch.	( self vote = DSTTransaction voteReadOnly ) 		ifTrue: 	[				]."	( self vote = DSTTransaction voteCommit )		ifTrue:	[	( self prepareState )						ifTrue: [ status := DSTTransaction statusPrepared ]				].	^self vote</body><body package="DST_COS_Services">rollback	"If necessary, roll back changes made as part of the transaction. 	If there is no transaction, do nothing"	self transaction isNil		ifTrue: ["do nothing"]		ifFalse: 			[self rollbackState				ifTrue: [status := DSTTransaction statusRolledBack]				ifFalse: [status := DSTTransaction statusUnknown]].	"Resource objects can (?) forget their transactions on commit or rollback if no exceptions are raised"	self forget</body></methods><methods><class-id>DST.DSTRecoverableObject</class-id> <category>persistence-framework</category><body package="DST_COS_Services">commitData	"this message is sent by the recoverable object framework when an 	objects data should be committed. Subclasses should implement a 	mechanism to commit data at this time. If the data has been 	commited this method should return true, otherwise false."	self subclassResponsibility.	^false</body><body package="DST_COS_Services">commitState	"commit yourself to persistent storage, if that fails roll back 	and raise the standard exception transactionRolledBackSignal. 	Subclasses should not need to touch this method."	self commitData		ifTrue: [^true]		ifFalse: 			[self rollback.			DSTTransaction transactionRolledBackSignal raiseWith: Dictionary new errorString: 'commit failed'.			^false]</body><body package="DST_COS_Services">prepareState	"Prepare yourself to commit to persistent storage or to be rolled back. 	This message is sent by the recoverable object framework when an 	objects data should prepare to be committed. Subclasses should 	implement a mechanism to save their state at this time. If the state 	has been saved, this method should return true, otherwise false."	self subclassResponsibility.	^false</body><body package="DST_COS_Services">rollbackState	"Roll back to the known good persistent state saved in prepareState. 	This message is sent by the recoverable object framework when an 	object's data should roll back within a transaction. Subclasses should 	implement a mechanism to recover their state at this time. If the 	state has been recovered, this method should return true, otherwise 	false."	self subclassResponsibility.	^false</body></methods><methods><class-id>DST.DSTRecoverableObject</class-id> <category>SubtransactionAware</category><body package="DST_COS_Services">commitSubtransaction: theParentCoordinator 	"This message is sent when a resource has been registered with a 	subtransaction and the subtransaction has been committed. The 	resource is provided with a coordinator that represents the parent 	transaction. This message can be used by an object to implement 	any particular operations on a transaction that depend upon the 	transaction's completion."</body><body package="DST_COS_Services">rollbackSubtransaction	"This message is sent when a resource has been registered with a 	subtransaction and the subtransaction has been rolled back. This 	message can be used by an object to implement any particular 	operations on a transaction that depend upon the transaction's 	completion."</body></methods><methods><class-id>DST.DSTRecoverableObject</class-id> <category>Current</category><body package="DST_COS_Services">beginTransaction	"Create a new transactionwithin the current thread."	super beginTransaction.	self transaction coordinator registerResource: self.</body></methods><methods><class-id>DST.DSTRecoverableObject</class-id> <category>private</category><body package="DST_COS_Services">report:  errorString "ORBDaemon configurationManager log: (errorString, '\') withCRs"</body><body package="DST_COS_Services">vote	^vote</body><body package="DST_COS_Services">vote: anEnumerator 	vote := anEnumerator</body></methods><methods><class-id>DST.DSTRecoverableObject</class-id> <category>repository</category><body package="DST_COS_Services">CORBAName	"return the name of my CORBA interface in the repository"	^#'::CosTransactions::DSTRecoverableObject'</body><body package="DST_COS_Services">abstractClassId	"return the abstract class Id of the receiver"	^'6f4c9ce5-9b00-0000-020f-1c683d000000' asUUID</body></methods><methods><class-id>DST.DSTRecoverableObject</class-id> <category>printing</category><body package="DST_COS_Services">printOn: aStream 	"print a representation of the receiver"	super printOn: aStream.	aStream nextPutAll: ' (', status name asString, ')'</body></methods><methods><class-id>DST.DSTRecoverableObject</class-id> <category>initialize-release</category><body package="DST_COS_Services">initialize	"initialize the receiver"	super initialize.	vote := DSTTransaction voteReadOnly.	lockset := DSTTransactionalLockSet new initialize</body></methods><methods><class-id>DST.DSTRecoverableObject class</class-id> <category>instance creation</category><body package="DST_COS_Services">create	"transaction objects are objects which respond to the 	CosTransactions::Control interface"	^self new initialize</body><body package="DST_COS_Services">forTransaction: aTransaction 	"transaction objects are objects which respond to the 	CosTransactions::Control interface"	^self create transaction: aTransaction</body></methods><methods><class-id>DST.DSTSampleRecoverableObject</class-id> <category>persistence-framework</category><body package="DST_COS_Services">commitData	"this message is sent by the recoverable object framework when an 	objects data should be committed. Subclasses of 	DSTRecoverableObject should implement a mechanism to commit 	data at this time. If the data has been commited this method should 	return true, otherwise false."		[lockset unlock: self coordinator mode: lockset class write.	^true]		on: Object errorSignal do: [:x | ^false]</body><body package="DST_COS_Services">prepareState	"Prepare yourself to commit to persistent storage or to be rolled back. 	This message is sent by the recoverable object framework when an 	objects data should prepare to be committed. Subclasses of 	DSTRecoverableObject should implement a mechanism to save their 	state at this time. If the state has been saved, this method should 	return true, otherwise false."	^lockset tryLock: self coordinator mode: lockset class write</body><body package="DST_COS_Services">rollbackState	"Roll back to the known good persistent state saved in prepareState. 	This message is sent by the recoverable object framework when an 	object's data should roll back within a transaction. Subclasses of 	DSTRecoverableObject should implement a mechanism to recover 	their state at this time. If the state has been recovered, this method 	should return true, otherwise false."		[status = DSTTransaction statusPrepared ifFalse: [lockset tryLock: self coordinator mode: lockset class write].	lockset unlock: self coordinator mode: lockset class write.	^true]		on: Object errorSignal do: [:x | ^false]</body></methods><methods><class-id>DST.DSTSampleRecoverableObject</class-id> <category>repository</category><body package="DST_COS_Services">CORBAName	"return the name of my CORBA interface in the repository"	^#'::CosTransactions::DSTSampleRecoverableObject'</body><body package="DST_COS_Services">abstractClassId	"return the abstract class Id of the receiver"	^'732bfde4-aa9f-0000-020f-005b2e000000' asUUID</body></methods><methods><class-id>DST.DSTSampleRecoverableObject</class-id> <category>SubtransactionAware</category><body package="DST_COS_Services">commitSubtransaction: theParentCoordinator 	"This message is sent when a resource has been registered with a 	subtransaction and the subtransaction has been committed. The 	resource is provided with a coordinator that represents the parent 	transaction. This message can be used by an object to implement 	any particular operations on a transaction that depend upon the 	transaction's completion."	ORBDaemon configurationManager log: 'DSTSampleRecoverableObject: My subtransaction has been committed.\' withCRs</body><body package="DST_COS_Services">rollbackSubtransaction	"This message is sent when a resource has been registered with a 	subtransaction and the subtransaction has been rolled back. This 	message can be used by an object to implement any particular 	operations on a transaction that depend upon the transaction's 	completion."	ORBDaemon configurationManager log: 'DSTSampleRecoverableObject: My subtransaction has been rolled back.\' withCRs</body></methods><methods><class-id>DST.DSTSampleRecoverableObject class</class-id> <category>examples</category><body package="DST_COS_Services">example1: aFactory 	"This example demonstrates the use a recoverable object with indirect context 	management (the Current psuedoObject)"	"Processor activeProcess orbContext transactionContext: nil."	"self example1: ORBObject factoryFinder"	| suspended resource |	resource := self create.	resource beginTransaction.	suspended := resource suspendTransaction.		[resource commitTransaction: false.	self error: 'testCurrentInterfaceNear: suspend failed'; cr]		on: DSTTransaction noTransactionSignal do: [:x | "This should raise an exception"].	resource resumeTransaction: suspended.	[resource commitTransaction: false]		on: Object errorSignal do: [:x | self error: 'example1: resume failed'; cr].	resource beginTransaction.	resource vote: DSTTransaction voteCommit.	resource commitTransaction: false.	resource getTransactionStatus = DSTTransaction statusCommitted ifFalse: [self error: 'example1: Failure, transaction status ' , resource getTransactionStatus printString; cr].	resource beginTransaction.	resource vote: DSTTransaction voteRollback.	resource rollbackTransaction.	^resource</body><body package="DST_COS_Services">example2: aFactory 	"This example demonstrates the use of a recoverable object with indirect context 	management (the Current psuedoObject). DSTRecoverableObject is a subclass of 	DSTTransactionalObject which implements the Current interface."	"Processor activeProcess orbContext transactionContext: nil."	"self example2: ORBObject factoryFinder"	| suspended resource |	resource := self create.	resource beginTransaction.	suspended := resource suspendTransaction.		[resource commitTransaction: false.	self error: 'testCurrentInterfaceNear: suspend failed'; cr]		on: DSTTransaction noTransactionSignal do: [:x | "This should raise an exception"].	resource resumeTransaction: suspended.	[resource commitTransaction: false]		on: Object errorSignal do: [:x | self error: 'example1: resume failed'; cr].	resource beginTransaction.	resource vote: DSTTransaction voteCommit.	resource commitTransaction: false.	resource getTransactionStatus = DSTTransaction statusCommitted ifFalse: [self error: 'example1: Failure, transaction status ' , resource getTransactionStatus printString; cr].	resource beginTransaction.	resource vote: DSTTransaction voteRollback.	resource rollbackTransaction.	^resource</body><body package="DST_COS_Services">example3: aFactory 	"This example demonstrates the use a recoverable object with indirect context 	management (the Current psuedoObject)"	"Processor activeProcess orbContext transactionContext: nil."	"self example3: ORBObject factoryFinder"	| suspended resource remoteResource |	resource := self create.	remoteResource := ORBObject namingService contextResolve: (DSTName onString: 'TestResource').	resource beginTransaction.	resource coordinator registerResource: remoteResource.	resource vote: DSTTransaction voteCommit.	remoteResource vote: DSTTransaction voteCommit.	suspended := resource suspendTransaction.		[resource commitTransaction: false.	self error: 'testCurrentInterfaceNear: suspend failed'; cr] 		on: DSTTransaction noTransactionSignal 		do: [:x | "This should raise an exception"].	resource resumeTransaction: suspended.	[resource commitTransaction: false]		on: Object errorSignal do: [:x | self error: 'example3: resume failed'; cr].	resource beginTransaction.	resource vote: DSTTransaction voteCommit.	resource commitTransaction: false.	( resource getTransactionStatus = DSTTransaction statusCommitted )		ifFalse: [self error: 'example3: Failure, transaction status ' , resource getTransactionStatus printString; cr].	resource beginTransaction.	resource vote: DSTTransaction voteRollback.		[resource commitTransaction: false.	self error: 'testCurrentInterfaceNear: suspend failed'; cr]		on: DSTTransaction transactionRolledBackSignal do: [:x | "This should raise an exception"].	( resource getTransactionStatus = DSTTransaction statusCommitted )		ifTrue: [self error: 'example3: Failure, transaction status ' , resource getTransactionStatus printString; cr].	^resource</body></methods><methods><class-id>DST.DSTTransactionIdentifier</class-id> <category>accessing</category><body package="DST_COS_Services">bequalLength	^length</body><body package="DST_COS_Services">bequalLength: aValue	length := aValue</body><body package="DST_COS_Services">formatId	^formatId</body><body package="DST_COS_Services">formatId: aValue	formatId := aValue</body><body package="DST_COS_Services">tid	^transactionId</body><body package="DST_COS_Services">tid: aValue	transactionId := aValue</body></methods><methods><class-id>DST.DSTTransactionIdentifier</class-id> <category>repository</category><body package="DST_COS_Services">CORBAType	"return an instance of the DSTmetaObject subclass which can marshall an 	instance of the receiver."	^ORBObject lookupMetaId: #'::TSInteroperation::otid_t'</body></methods><methods><class-id>DST.DSTTransactionIdentifier class</class-id> <category>instance creation</category><body package="DST_COS_Services">formatId: anIdentifier bequalLength: aValue tid: aTransactionId 	^(self new) 		formatId: anIdentifier; 		bequalLength: aValue; 		tid: aTransactionId; 		yourself</body><body package="DST_COS_Services">nullId	^self		formatId: -1		bequalLength: 0		tid: ByteArray new</body></methods><methods><class-id>DST.DSTTypedEventChannel</class-id> <category>exceptions</category><body package="DST_COS_Services">interfaceNotSupportedError	"raise the InterfaceNotSupported error"	^(CORBAConstants at: #'::CosTypedEventChannelAdmin::InterfaceNotSupported')		raiseWith: Dictionary new errorString: ' invalid key'</body><body package="DST_COS_Services">noSuchImplementationError	"raise the NoSuchImplementation error"	^(CORBAConstants at: #'::CosTypedEventChannelAdmin::NoSuchImplementation')		raiseWith: Dictionary new errorString: ' invalid key'</body></methods><methods><class-id>DST.DSTTypedEventChannel</class-id> <category>supplier messages</category><body package="DST_COS_Services">supplierNeedsTypedEvent: aClass 	"a typed pull-supplier has received a pull request. Make sure any 	outstanding pull consumers have been polled"	| anEvent hasEvent |	pullConsumers do: [:co | 		[anEvent := (co isKindOf: DSTTypedPullSupplier)					ifTrue: [co tryPullTypedEvent: (hasEvent := nil asCORBAParameter) class: aClass]					ifFalse: [co tryPullEventData].		hasEvent value ifTrue: [self processEvent: anEvent]]			on: Object errorSignal do: [:ex | ]]</body></methods><methods><class-id>DST.DSTTypedEventChannel</class-id> <category>TypedEventChannel</category><body package="DST_COS_Services">forConsumers	"return an objref of the ConsumerAdmin interface"	^self widenTo: #'CosTypedEventChannelAdmin::TypedConsumerAdmin'</body><body package="DST_COS_Services">forSuppliers	"return an objref of the SupplierAdmin interface"	^self widenTo: #'CosTypedEventChannelAdmin::TypedSupplierAdmin'</body></methods><methods><class-id>DST.DSTTypedEventChannel</class-id> <category>private</category><body package="DST_COS_Services">implementsInterface: anInterfaceName subclass: aClassName 	"return the class or subclass that implements the interface, 	anInterfaceName"	| col |	col := OrderedCollection new.	aClassName withAllSubclasses do: [:class | (class includesSelector: #CORBAName)			ifTrue: [col add: class]].	col do: [:class | class new CORBAName = anInterfaceName asSymbol ifTrue: [^class]].	^nil</body></methods><methods><class-id>DST.DSTTypedEventChannel</class-id> <category>repository</category><body package="DST_COS_Services">CORBAName	"return the name of my CORBA interface in the repository"	^#'::CosTypedEventChannelAdmin::DSTTypedEventChannel'</body><body package="DST_COS_Services">abstractClassId	"return the abstract class Id of the receiver"	^'676bf872-87a8-0000-020f-1c680a000000' asUUID</body></methods><methods><class-id>DST.DSTTypedEventChannel</class-id> <category>TypedSupplierAdmin</category><body package="DST_COS_Services">obtainTypedPullConsumer: anInterfaceName 	"return a reference to a an object that supports the 	TypedProxyPullConsumer interface"	| className |	className := self implementsInterface: anInterfaceName subclass: DSTPullConsumer.	className isNil		ifTrue: [^self noSuchImplementationError]		ifFalse: [^(exportedProxies add: (DSTProxyConsumer new consumer: (className new host: self)))				widenTo: #'CosEventChannelAdmin::ProxyPullConsumer']</body><body package="DST_COS_Services">obtainTypedPushConsumer: anInterfaceName 	"return a reference to a an object that supports the 	TypedProxyPushConsumer interface"	| className |	className := self implementsInterface: anInterfaceName subclass: DSTTypedPushConsumer.	className isNil		ifTrue: [^self interfaceNotSupportedError]		ifFalse: [^(exportedProxies add: (DSTProxyConsumer new consumer: (className new host: self)))				widenTo: #'CosTypedEventChannelAdmin::TypedProxyPushConsumer']</body></methods><methods><class-id>DST.DSTTypedEventChannel</class-id> <category>TypedConsumerAdmin</category><body package="DST_COS_Services">obtainTypedPullSupplier: anInterfaceName 	"return a reference to a an object that supports the 	TypedProxyPullSupplier interface"	| className |	className := self implementsInterface: anInterfaceName subclass: DSTTypedPullSupplier.	className isNil		ifTrue: [^self interfaceNotSupportedError]		ifFalse: [^(exportedProxies add: (DSTProxySupplier new supplier: (className new host: self)))				widenTo: #'CosTypedEventChannelAdmin::TypedProxyPullSupplier']</body><body package="DST_COS_Services">obtainTypedPushSupplier: anInterfaceName 	"return a reference to a an object that supports the 	ProxyPushSupplier interface"	| className | 	className := self implementsInterface: anInterfaceName subclass: DSTPushSupplier.	className isNil		ifTrue: [^self noSuchImplementationError]		ifFalse: [^(exportedProxies add: (DSTProxySupplier new supplier: (className new host: self)))				widenTo: #'CosEventChannelAdmin::ProxyPushSupplier']</body></methods><methods><class-id>DST.DSTTypedEventChannel class</class-id> <category>error handling</category><body package="DST_COS_Services">interfaceNotSupportedSignal	"Answer the signal used for InterfaceNotSupported errors"	^CORBAConstants at: #'::CosTypedEventChannelAdmin::InterfaceNotSupported'</body><body package="DST_COS_Services">noSuchImplementationSignal	"Answer the signal used for NoSuchImplementation errors"	^CORBAConstants at: #'::CosTypedEventChannelAdmin::NoSuchImplementation'</body></methods><methods><class-id>DST.DSTTypedPullSupplier</class-id> <category>repository</category><body package="DST_COS_Services">CORBAName	"return the name of my CORBA interface in the repository"	^#'::CosTypedEventComm::TypedPullSupplier'</body></methods><methods><class-id>DST.DSTTypedPullSupplier</class-id> <category>private</category><body package="DST_COS_Services">pullTypedEvent: aClass 	"return the the next event that is a type of class"	| obj |	connected ifFalse: [^self disconnectedError].	events isEmpty		ifTrue: [host supplierNeedsTypedEvent: aClass]		ifFalse: 			[obj := self searchForTypedEvent: aClass.			obj isNil				ifTrue: 					[host supplierNeedsTypedEvent: aClass.					obj := self searchForTypedEvent: aClass]].	obj isNil		ifTrue: 			[eventSignaller wait.			^self pullTypedEvent: aClass]		ifFalse: [^obj]</body><body package="DST_COS_Services">searchForTypedEvent: aClass 	"This method searches through the shared queue to get an event 	matching some criteria"	| numEvents queue event |	semaphore		critical: 			[(numEvents := events size) &lt; 1				ifTrue: [^nil]				ifFalse: 					[queue := SharedQueue new: numEvents.					1 to: numEvents						do: 							[:i | 							event := events next.							(event isKindOf: aClass)								ifTrue: 									[i + i to: numEvents do: [:n | queue nextPut: events next].									events := queue.									^event]								ifFalse: [queue nextPut: event]]].			events := queue.			^nil]</body><body package="DST_COS_Services">tryPullTypedEvent: aBoolean class: aClass 	"return the the next event that is a type of class"	| obj |	connected ifFalse: [^self disconnectedError].	events isEmpty ifTrue: [host supplierNeedsTypedEvent: aClass].	obj := self searchForTypedEvent: aClass.	obj isNil		ifTrue: 			[aBoolean value: false.			^0]		ifFalse: 			[aBoolean value: true.			^obj]</body></methods><methods><class-id>DST.DSTTypedPullSupplier</class-id> <category>initialization</category><body package="DST_COS_Services">initialize	"initialize the receiver"	super initialize.	semaphore := Semaphore new signal.	eventSignaller := Semaphore new</body></methods><methods><class-id>DST.DSTTypedPullSupplier</class-id> <category>host messages</category><body package="DST_COS_Services">processEvent: anAny 	"add an event to the receiver"	semaphore		critical: 			[events nextPut: anAny.			1 to: eventSignaller size do: [:i | eventSignaller signal]]</body></methods><methods><class-id>DST.DSTTypedPullSupplier</class-id> <category>TypedPullSupplier</category><body package="DST_COS_Services">getTypedSupplier	"return a reference to the typed pull supplier"	^self</body></methods><methods><class-id>DST.DSTProxySupplier</class-id> <category>TypedPullSupplier</category><body package="DST_COS_Services">getTypedSupplier	"return a reference to the supplier (typed pull supplier)"	^self supplier</body></methods><methods><class-id>DST.DSTProxySupplier</class-id> <category>PullSupplier</category><body package="DST_COS_Services">disconnectPullSupplier	"forward the request to the supplier"	supplier disconnectPullSupplier</body><body package="DST_COS_Services">pull	"forward the request to the supplier"	^supplier pull</body><body package="DST_COS_Services">tryPull	"forward the request to the supplier"	^supplier tryPull</body><body package="DST_COS_Services">tryPull: aBoolean 	"forward the request to the supplier"	^supplier tryPull: aBoolean</body></methods><methods><class-id>DST.DSTProxySupplier</class-id> <category>ProxyPushSupplier</category><body package="DST_COS_Services">connectPushConsumer: aPushConsumer 	"connect a push consumer to the event channel"	| channel |	aPushConsumer isNil		ifTrue: [^ORBObject badParamError: 0]		ifFalse: [supplier connected				ifTrue: [^self alreadyConnectedError]				ifFalse: 					[channel := supplier host.					supplier host: channel consumer: aPushConsumer.					channel connectProxyPushSupplier: self]]</body></methods><methods><class-id>DST.DSTProxySupplier</class-id> <category>exceptions</category><body package="DST_COS_Services">alreadyConnectedError	"raise the AlreadyConnected error"	^(CORBAConstants at: #'::CosEventChannelAdmin::AlreadyConnected')		raiseWith: Dictionary new errorString: ' Already Connected to Event Channel'</body></methods><methods><class-id>DST.DSTProxySupplier</class-id> <category>accessing</category><body package="DST_COS_Services">supplier	"Answer the supplier of the receiver"	^supplier</body><body package="DST_COS_Services">supplier: aSupplier	"set the instance variable of the receiver"	supplier := aSupplier</body></methods><methods><class-id>DST.DSTProxySupplier</class-id> <category>PushSupplier</category><body package="DST_COS_Services">disconnectPushSupplier	"forward the request to the supplier"	supplier disconnectPushSupplier</body></methods><methods><class-id>DST.DSTProxySupplier</class-id> <category>ProxyPullSupplier</category><body package="DST_COS_Services">connectPullConsumer: aPullConsumer 	"connect a pull consumer to the event channel"	| channel |	supplier connected		ifTrue: [^self alreadyConnectedError]		ifFalse: 			[channel := supplier host.			supplier host: channel consumer: aPullConsumer.			channel connectProxyPullSupplier: self]</body></methods><methods><class-id>DST.DSTProxySupplier</class-id> <category>repository</category><body package="DST_COS_Services">CORBAName	"return the name of my CORBA interface in the repository"	^#'::CosTypedEventChannelAdmin::DSTProxySupplier'</body></methods><methods><class-id>DST.DSTProxySupplier</class-id> <category>host messages</category><body package="DST_COS_Services">processEvent: anAny 	"forward the request to the supplier"	supplier processEvent: anAny</body></methods><methods><class-id>DST.DSTProxySupplier class</class-id> <category>error handling</category><body package="DST_COS_Services">alreadyConnectedSignal	"Answer the signal used for AlreadyConnected errors"	^CORBAConstants at: #'::CosEventChannelAdmin::AlreadyConnected'</body></methods><methods><class-id>DST.DSTProxyConsumer</class-id> <category>PullConsumer</category><body package="DST_COS_Services">disconnectPullConsumer	"forward the request to the consumer"	consumer disconnectPullConsumer</body></methods><methods><class-id>DST.DSTProxyConsumer</class-id> <category>accessing</category><body package="DST_COS_Services">consumer	"Answer the consumer of the receiver"	^consumer</body><body package="DST_COS_Services">consumer: aConsumer 	"set the consumer of the receiver"	consumer := aConsumer</body></methods><methods><class-id>DST.DSTProxyConsumer</class-id> <category>host messages</category><body package="DST_COS_Services">tryPullEventData	"forward the request to the consumer"	^consumer tryPullEventData</body><body package="DST_COS_Services">tryPullEventData: aBoolean 	"forward the request to the consumer"	^consumer tryPullEventData: aBoolean</body></methods><methods><class-id>DST.DSTProxyConsumer</class-id> <category>exceptions</category><body package="DST_COS_Services">alreadyConnectedError	"raise the AlreadyConnected error"	^(CORBAConstants at: #'::CosEventChannelAdmin::AlreadyConnected')		raiseWith: Dictionary new errorString: ' Already Connected to Event Channel'</body></methods><methods><class-id>DST.DSTProxyConsumer</class-id> <category>TypedPushConsumer</category><body package="DST_COS_Services">getTypedConsumer	"retrun a reference to the consumer (typed push consumer)"	^self consumer</body></methods><methods><class-id>DST.DSTProxyConsumer</class-id> <category>ProxyPushConsumer</category><body package="DST_COS_Services">connectPushSupplier: aPushSupplier 	"connect a push supplier to the event channel"	| channel |	consumer connected		ifTrue: [^self alreadyConnectedError]		ifFalse: 			[channel := consumer host.			consumer				host: channel				supplier: aPushSupplier				aspect: #processEvent.			channel connectProxyPushConsumer: self]</body></methods><methods><class-id>DST.DSTProxyConsumer</class-id> <category>PushConsumer</category><body package="DST_COS_Services">disconnectPushConsumer	"forward the request to the consumer"	consumer disconnectPushConsumer</body><body package="DST_COS_Services">pushEventData: anAny 	"forward the event to the consumer"	consumer pushEventData: anAny</body></methods><methods><class-id>DST.DSTProxyConsumer</class-id> <category>ProxyPullConsumer</category><body package="DST_COS_Services">connectPullSupplier: aPullSupplier 	"connect a pull supplier to the event channel"	| channel |	aPullSupplier isNil		ifTrue: [ORBObject badParamError: 0]		ifFalse: [consumer connected				ifTrue: [self alreadyConnectedError]				ifFalse: 					[channel := consumer host.					consumer host: channel supplier: aPullSupplier.					channel connectProxyPullConsumer: self]]</body></methods><methods><class-id>DST.DSTProxyConsumer</class-id> <category>repository</category><body package="DST_COS_Services">CORBAName	"return the name of my CORBA interface in the repository"	^#'::CosTypedEventChannelAdmin::DSTProxyConsumer'</body></methods><methods><class-id>DST.DSTProxyConsumer class</class-id> <category>error handling</category><body package="DST_COS_Services">alreadyConnectedSignal	"Answer the signal used for AlreadyConnected errors"	^CORBAConstants at: #'::CosEventChannelAdmin::AlreadyConnected'</body></methods><methods><class-id>DST.DSTTransactionalLock</class-id> <category>accessing</category><body package="DST_COS_Services">ownerId	"return the lock's ownerId"	^ownerId</body><body package="DST_COS_Services">ownerId: anId	"set the lock's ownerId"	ownerId := anId</body></methods><methods><class-id>DST.DSTTransactionalLock</class-id> <category>initialization</category><body package="DST_COS_Services">initialize: anIdself ownerId: anId</body></methods><methods><class-id>DST.DSTTypedPushConsumer</class-id> <category>repository</category><body package="DST_COS_Services">CORBAName	"return the name of my CORBA interface in the repository"	^#'::CosTypedEventComm::TypedPushConsumer'</body></methods><methods><class-id>DST.DSTTypedPushConsumer</class-id> <category>TypedPushConsumer</category><body package="DST_COS_Services">getTypedConsumer	"return a reference to the typed push consumer"	^self</body></methods><methods><class-id>DST.DSTConcurrencyContext</class-id> <category>accessing</category><body package="DST_COS_Services">concurrencyId	"answer the concurrencyId of the receiver"	extracted ifFalse: [self extractContext].	^concurrencyId</body><body package="DST_COS_Services">concurrencyId: anNCSuuid 	"set the concurrencyId of the receiver"	extracted ifFalse: [self extractContext].	concurrencyId := anNCSuuid.	modified := true</body><body package="DST_COS_Services">referenceCount	"answer the referenceCount of the receiver"	extracted ifFalse: [self extractContext].	^referenceCount</body><body package="DST_COS_Services">referenceCount: anInteger 	"set the referenceCount of the receiver"	extracted ifFalse: [self extractContext].	referenceCount := anInteger.	modified := true</body></methods><methods><class-id>DST.DSTConcurrencyContext</class-id> <category>private</category><body package="DST_COS_Services">concurrencyId: anNCSuuid referenceCount: anInteger 	concurrencyId := anNCSuuid.	referenceCount := anInteger.	modified := extracted := true.	contextId := self class concurrencyServiceId</body><body package="DST_COS_Services">encapsulateContextData	"answer an encapsulated data stream that contains the debugger 	context information"	| strm |	strm := CDRStream on: (ByteArray new: 100).	strm nextPutBoolean: strm byteOrder.	concurrencyId isNil		ifTrue: [^ORBObject badContextError: 0]		ifFalse: [strm nextPutString: concurrencyId printString].	referenceCount isNil		ifTrue: [^ORBObject badContextError: 0]		ifFalse: [strm nextPutUnsignedLong: referenceCount].	modified := false.	^strm contents</body><body package="DST_COS_Services">extractContext	"extract the context from contextData"	| strm |	[strm := (CDRStream with: contextData) reset.			strm byteOrder: strm nextBoolean.			concurrencyId := NCSuuid on: strm nextString.			referenceCount := strm nextUnsignedLong.			extracted := true] on: self errorSignal do: [:ex | ORBObject badContextError: 0]</body></methods><methods><class-id>DST.DSTConcurrencyContext class</class-id> <category>instance creation</category><body package="DST_COS_Services">concurrencyId: anNCSuuid referenceCount: anInteger  	^(self basicNew) concurrencyId: anNCSuuid referenceCount: anInteger</body></methods><methods><class-id>DST.DSTConcurrencyContext class</class-id> <category>private</category><body package="DST_COS_Services">installContext	"add the receiver to the dictionary of installed contexts"	InstalledContexts at: self concurrencyServiceId put: self</body></methods><methods><class-id>DST.ORBContext class</class-id> <category>constants</category><body package="DST_COS_Services">concurrencyServiceId	"answer the value of the Id for the dst concurrency context"	^16r08108003</body><body package="DST_COS_Services">transactionServiceId	"answer the value of the Id for service contexts"	^0</body></methods><methods><class-id>DST.ORBContext</class-id> <category>accessing</category><body package="DST_COS_Services">concurrencyContext	"answer the concurrency service context"	^serviceContexts at: self class concurrencyServiceId ifAbsent: [nil]</body><body package="DST_COS_Services">concurrencyContext: aConcurrencyContext 	"set the concurrency service context"	aConcurrencyContext notNil		ifTrue: [self addServiceContext: aConcurrencyContext]		ifFalse: [serviceContexts removeKey: self class concurrencyServiceId ifAbsent: []]</body><body package="DST_COS_Services">transactionContext	"answer the transaction service context"	^serviceContexts at: self class transactionServiceId ifAbsent: [nil]</body><body package="DST_COS_Services">transactionContext: aTransactionContext 	"set the transaction service context"	aTransactionContext notNil		ifTrue: [self addServiceContext: aTransactionContext]		ifFalse: [serviceContexts removeKey: self class transactionServiceId ifAbsent: []]</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>ORBContext</name><environment>DST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>corbaContext serviceContexts local </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Contexts</category><attributes><package>DST_Core</package></attributes></class><class><name>DSTServiceContext</name><environment>DST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>contextId contextData modified extracted </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Contexts</category><attributes><package>DST_Core</package></attributes></class><class><name>ORBObject</name><environment>DST</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>accessControlList </inst-vars><class-inst-vars>abstractClassId classAbstractClassId accessControlList </class-inst-vars><imports></imports><category>CORBA-Core</category><attributes><package>DST_Core</package></attributes></class><class><name>DSTPersistentObject</name><environment>DST</environment><super>DST.ORBObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>objectId </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Core</category><attributes><package>DST_Core</package></attributes></class></st-source>