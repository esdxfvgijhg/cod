<?xml version="1.0"?><st-source><!-- Name: DST_Core_IDLNotice: Copyright 1999-2013 Cincom Systems, Inc.  All rights reserved.Comment: DST_Core_IDL contains the IDL required by the DST core.Copyright: Copyright © 1999-2001 Cincom Systems, Inc.All Rights ReservedThis product contains copyrighted third-party software.Copyright © 1993-1995 Hewlett-Packard Company.All Rights ReservedDbIdentifier: bear73DbTrace: 464617DbUsername: tkoganDbVersion: 8.1 - 1DevelopmentPrerequisites: #(#(#any 'DST_Repository' '') #(#any 'DST_IDLCompiler' ''))PackageName: DST_Core_IDLParcel: #('DST_Core_IDL')ParcelName: DST_Core_IDLPrerequisiteDescriptions: #(#(#name 'DST_Repository') #(#name 'DST_IDLCompiler' #componentType #package))PrerequisiteParcels: #(#('DST_Repository' '') #('DST_IDLCompiler' ''))PrintStringCache: (8.1 - 1,tkogan)Version: 8.1 - 1Date: 1:09:21 PM January 29, 2016 --><time-stamp>From VisualWorks®, Pre-Release 8.2 (jan16.4) of January 29, 2016 on January 29, 2016 at 1:09:21 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><methods><class-id>DST.DSTRepository</class-id> <category>CORBA</category><body package="DST_Core_IDL">// CompoundDefs// This module defines the interfaces of DST metaobject object classes// which are used by the IR browser and editor during remote operation.//  module CompoundDefs  { 	// 	// InterfaceCompoundDefs also support the PrmitiveDef interface in the Smalltalk	// Repository	// 	interface InterfaceCompoundDef : InterfaceDef, PrimitiveDef {};	//	//Narrow the interfaces of String, Sequence, Array, and Primitive	//defs to support the PrimitiveDef and Contained interfaces	//		interface PrimitiveCompoundDef : PrimitiveDef, Contained {};	interface StringCompoundDef : StringDef, PrimitiveCompoundDef {};	interface SequenceCompoundDef : SequenceDef, Contained {};	interface ArrayCompoundDef : ArrayDef, Contained {};};</body><body package="DST_Core_IDL">// CORBA// This module contains the root object and ORB interfaces, plus// ImplementationDef.//module CORBA  {	#pragma prefix "omg.org/CORBA"	#pragma  class ORBId NCSuuid	typedef octet ORBId[16];	#pragma  class Identifier Symbol	typedef string Identifier;	typedef string ScopedName;	typedef sequence&lt;Identifier&gt; Identifiers;	#pragma class RepositoryId RepositoryId	typedef string RepositoryId;	typedef sequence&lt;RepositoryId&gt; RepositoryIds;	// Many routines return an ORBstatus result, which is intended as	// a status code. Conforming implementations may choose to	// define this as void	typedef unsigned long ORBStatus;	// 	// This is the root interface which defines common types and	// operations on all objects. This should include the factory	// operations create(), destroy(), and copy()	// 	interface Object {		// This operation is used to get the implementation definition		// of the receiver		ImplementationDef get_implementation ();		// This operation is used to get the interface definition of the		// receiver		InterfaceDef get_interface ();			boolean is_nil();		Object duplicate();		void release ();		// the following creates an ambiguity with ImplementationDef. In general this		// should not be a problem but DST treats the CORBA::Object PIDL as real IDL		boolean is_a ( in string logical_type_id);		boolean non_existent();		boolean is_equivalent (in Object other_object);		unsigned long hash (in unsigned long maximum);		#pragma  selector create_request 						createRequestIn:selector:withArguments:result:flags:		// This operation is used to create a dynamic request on the		// receiver		ORBStatus create_request (							in DynamicInvocation::Context ctx,							in Identifier operation,							in NVList arg_list,							inout DynamicInvocation::NamedValue result,							out Request request,							in Flags req_flags);	};	// 	// The ORB interface is the interface to those ORB functions that	// do not depend on which object adapter is used. These	// operations are the same for all ORBs and all object	// implementaions, and can be performed either by clients of the	// objects or by their implementations. The ORB interface also	// defines operations for creating lists and determining the	// default context used in the dynamic invocation interface.	// 	interface ORB {		typedef string ObjectId;	 		typedef sequence &lt;ObjectId&gt; ObjectIdList;		exception	InvalidName {};		ObjectIdList	list_initial_services ();			#pragma  selector resolve_initial_references resolveInitialReferences:		Object resolve_initial_references (in ObjectId identifier) raises (InvalidName) ;	};	// 	// An ImplementationDef object represents the implementation of	// an abstract class	// 	interface ImplementationDef {		// The describe() operation for an ImplementationDef returns:		struct ImplementationDescription {			Identifier name;			RepositoryId id;			RepositoryId defined_in;		};		// The describe_implementation() operation for an		// ImplementationDef returns:		struct FullImplementationDescription {			Identifier name;			RepositoryId id;			RepositoryId defined_in;			sequence&lt;Identifier&gt; methods;		};		// This operation returns more information than describe()		FullImplementationDescription describe_implementation ();	};		enum DefinitionKind {		dk_none,		dk_all,		dk_Attribute,		dk_Constant,		dk_Exception,		dk_Interface,		dk_Module,		dk_Operation,		dk_Typedef,		dk_Alias,		dk_Struct,		dk_Union,		dk_Enum,		dk_Primitive,		dk_String,		dk_Sequence,		dk_Array,		dk_Repository,		dk_Wstring,		dk_Fixed	};	interface IRObject {		// read interface		readonly attribute DefinitionKind def_kind;		// write interface		void destroy ();	};	typedef  string VersionSpec;	interface Contained;	interface Repository;	interface Container;	interface Contained : IRObject {		// read/write interface		attribute RepositoryId id;		attribute Identifier name;		attribute VersionSpec version;		// read interface		readonly attribute Container defined_in;		readonly attribute ScopedName absolute_name;		readonly attribute Repository containing_repository;		struct  Description {DefinitionKind kind; any value; };		Description describe ();		// write interface		#pragma selector move move:name:version:		void move (						in Container new_container,						in Identifier new_name,						in VersionSpec new_version);	};	interface ModuleDef;	interface ConstantDef;	interface IDLType;	interface StructDef;	interface UnionDef;	interface EnumDef;	interface AliasDef;	interface InterfaceDef;	typedef  sequence&lt;InterfaceDef&gt; InterfaceDefSeq;	typedef  sequence&lt;Contained&gt; ContainedSeq;	struct  StructMember {		Identifier name; 		TypeCode type; 		IDLType type_def; };	typedef  sequence&lt;StructMember&gt; StructMemberSeq;	struct UnionMember {		Identifier name;		any label;		TypeCode type;		IDLType type_def;	};	typedef  sequence&lt;UnionMember&gt; UnionMemberSeq;	typedef  sequence&lt;Identifier&gt; EnumMemberSeq;	interface Container : IRObject {		// read interface		#pragma selector lookup lookup:		Contained lookup (in ScopedName search_name);		#pragma  selector contents contents:excludeInherited:		ContainedSeq contents (								in DefinitionKind limit_type,								in boolean exclude_inherited);		#pragma  selector lookup_name lookupName:levels:limit:excludeInherited:		ContainedSeq lookup_name (								in Identifier search_name,								in long levels_to_search,								in DefinitionKind limit_type,								in boolean exclude_inherited);		struct Description {			Contained contained_object;			DefinitionKind kind;			any value;		};		typedef  sequence&lt;Description&gt; DescriptionSeq;				#pragma  selector describe_contents describe:excludeInherited:max:		DescriptionSeq describe_contents (								in DefinitionKind limit_type,								in boolean exclude_inherited,								in long max_returned_objs);		// write interface		#pragma selector create_module createModule:name:version:		ModuleDef create_module (							in RepositoryId id,							in Identifier name,							in VersionSpec version);		#pragma selector create_constant createConstant:name:version:type:value:		ConstantDef create_constant (								in RepositoryId id,								in Identifier name,								in VersionSpec version,								in IDLType type,								in any value);		#pragma selector create_struct createStruct:name:version:members:		StructDef create_struct (							in RepositoryId id,							in Identifier name,							in VersionSpec version,							in StructMemberSeq members);		#pragma selector create_union createUnion:name:version:discriminatorType:members:		UnionDef create_union (							in RepositoryId id,							in Identifier name,							in VersionSpec version,							in IDLType discriminator_type,							in UnionMemberSeq members);		#pragma selector create_enum createEnum:name:version:members:		EnumDef create_enum (							in RepositoryId id,							in Identifier name,							in VersionSpec version,							in EnumMemberSeq members);		#pragma selector create_alias createAlias:name:version:originalType:		AliasDef create_alias (							in RepositoryId id,							in Identifier name,							in VersionSpec version,							in IDLType original_type);		#pragma selector create_interface createInterface:name:version:baseInterfaces:		InterfaceDef create_interface (							in RepositoryId id,							in Identifier name,							in VersionSpec version,							in InterfaceDefSeq base_interfaces );		#pragma selector create_exception createException:name:version:members:		ExceptionDef create_exception (							in RepositoryId id,							in Identifier name,							in VersionSpec version,							in StructMemberSeq members );	};	interface IDLType : IRObject {		readonly attribute TypeCode type;	};	interface PrimitiveDef;	interface StringDef;	interface SequenceDef;	interface ArrayDef;	enum PrimitiveKind {		pk_null,		pk_void,		pk_short,		pk_long,		pk_ushort,		pk_ulong,		pk_float,		pk_double,		pk_boolean,		pk_char,		pk_octet,		pk_any,		pk_TypeCode,		pk_Principal,		pk_string,		pk_objref,		pk_longlong,		pk_ulonglong,		pk_longdouble,		pk_wchar,		pk_wstring	};	//	// We have a difference here from both the 2.0 and the 2.1 specifications,	// neither of which has 'Contained' as an inherited interface for 'Repository'.	//	interface Repository : Container {		// read interface		#pragma selector lookup_id lookupId:		Contained lookup_id (in RepositoryId search_id);		#pragma selector get_primitive getPrimitive:		PrimitiveDef get_primitive (in PrimitiveKind kind);		// write interface		#pragma selector create_string createString:		StringDef create_string (in unsigned long bound);		#pragma selector create_wstring createWideString:		WstringDef create_wstring (			in unsigned long bound		);		#pragma selector create_sequence createSequence:elementType:		SequenceDef create_sequence (			in unsigned long bound,			in IDLType element_type		);		#pragma selector create_array createArray:elementType:		ArrayDef create_array (			in unsigned long length, 			in IDLType element_type 		);		#pragma selector create_fixed createFixed:scale:		FixedDef create_fixed (			in unsigned short digits,			in short scale		);	};	interface ModuleDef : Container, Contained {};	struct ModuleDescription {		Identifier name;		RepositoryId id;		RepositoryId defined_in;		VersionSpec version;	};	interface ConstantDef : Contained {		readonly attribute TypeCode type;		attribute IDLType type_def;		attribute any value;	};	struct ConstantDescription {		Identifier name;		RepositoryId id;		RepositoryId defined_in;		VersionSpec version;		TypeCode type;		any value;	};	interface TypedefDef : Contained, IDLType {	};	struct TypeDescription {		Identifier name;		RepositoryId id;		RepositoryId defined_in;		VersionSpec version;		TypeCode type;	};	//	// in CORBA 2.1, Container was added as an inherited interface	//	interface StructDef : TypedefDef {		attribute StructMemberSeq members;	};	interface UnionDef : TypedefDef {		readonly attribute TypeCode discriminator_type;		attribute IDLType discriminator_type_def;		attribute UnionMemberSeq members;	};	interface EnumDef : TypedefDef {		attribute EnumMemberSeq members;	};	interface AliasDef : TypedefDef {		attribute IDLType original_type_def;	};	interface PrimitiveDef : IDLType {		readonly attribute PrimitiveKind kind;	};	interface StringDef : IDLType {		attribute unsigned long bound;	};	interface WstringDef : IDLType {		attribute unsigned long bound;	};	interface FixedDef : IDLType {		attribute unsigned short digits;		attribute short scale;	};	interface SequenceDef : IDLType {		attribute unsigned long bound;		readonly attribute TypeCode element_type;		attribute IDLType element_type_def;	};	interface ArrayDef : IDLType {		attribute unsigned long length;		readonly attribute TypeCode element_type;		attribute IDLType element_type_def;	};	//	// In CORBA 2.1, Container was added as an inherited interface.	// We do not comply.	//	interface ExceptionDef : Contained {		readonly attribute TypeCode type;		attribute StructMemberSeq members;	};	struct ExceptionDescription {		Identifier name;		RepositoryId id;		RepositoryId defined_in;		VersionSpec version;		TypeCode type;	};	#pragma class ExceptionDescription DSTexceptionDescription	// We don't follow the CORBA spec here! Why?	// enum AttributeMode {ATTR_NORMAL, ATTR_READONLY};	enum AttributeMode {NORMAL, READONLY};	interface AttributeDef : Contained {		readonly attribute TypeCode type;		attribute IDLType type_def;		attribute AttributeMode mode;	};	struct AttributeDescription {		Identifier name;		RepositoryId id;		RepositoryId defined_in;		VersionSpec version;		TypeCode type;		AttributeMode mode;	};	#pragma class AttributeDescription DSTattributeDescription	// Again!		// enum OperationMode {OP_NORMAL, OP_ONEWAY};	enum OperationMode {NORMAL, ONEWAY};	// Again!	// enum ParameterMode {PARAM_IN, PARAM_OUT, PARAM_INOUT};	enum ParameterMode {IN, OUT, INOUT};	struct ParameterDescription {		Identifier name;		TypeCode type;		IDLType type_def;		ParameterMode mode;	};	#pragma class ParameterDescription DSTparameterDescription	typedef  sequence&lt;ParameterDescription&gt; ParDescriptionSeq;	typedef  Identifier ContextIdentifier;	typedef  sequence&lt;ContextIdentifier&gt; ContextIdSeq;	typedef  sequence&lt;ExceptionDef&gt; ExceptionDefSeq;	typedef  sequence&lt;ExceptionDescription&gt; ExcDescriptionSeq;	interface OperationDef : Contained {		readonly attribute TypeCode result;		attribute IDLType result_def;		attribute ParDescriptionSeq params;		attribute OperationMode mode;		attribute ContextIdSeq contexts;		attribute ExceptionDefSeq exceptions;	};	struct OperationDescription {		Identifier name;		RepositoryId id;		RepositoryId defined_in;		VersionSpec version;		TypeCode result;		OperationMode mode;		ContextIdSeq contexts;		ParDescriptionSeq parameters;		ExcDescriptionSeq exceptions;	};	#pragma class OperationDescription DSToperationDescription	typedef  sequence&lt;RepositoryId&gt; RepositoryIdSeq;	typedef  sequence&lt;OperationDescription&gt; OpDescriptionSeq;	typedef  sequence&lt;AttributeDescription&gt; AttrDescriptionSeq;	interface InterfaceDef : Container, Contained, IDLType {		// read/write interface		attribute InterfaceDefSeq base_interfaces;		// read interface		// conflict with Object is_a		#pragma selector is_a isA:		boolean is_a (in RepositoryId interface_id);		struct FullInterfaceDescription {			Identifier name;			RepositoryId id;			RepositoryId defined_in;			VersionSpec version;			OpDescriptionSeq operations;			AttrDescriptionSeq attributes;			RepositoryIdSeq base_interfaces;			TypeCode type;		};		FullInterfaceDescription describe_interface ();		// write interface		#pragma selector create_attribute createAttribute:name:version:type:mode:		AttributeDef create_attribute (							in RepositoryId id,							in Identifier name,							in VersionSpec version,							in IDLType type,							in AttributeMode mode);			#pragma selector create_operation createOperation:name:version:result:mode:params:exceptions:contexts:		OperationDef create_operation (								in RepositoryId id,								in Identifier name,								in VersionSpec version,								in IDLType result,								in OperationMode mode,								in ParDescriptionSeq params,								in ExceptionDefSeq exceptions,								in ContextIdSeq contexts);	};	struct InterfaceDescription {		Identifier name;		RepositoryId id;		RepositoryId defined_in;		VersionSpec version;		RepositoryIdSeq base_interfaces;	};};</body></methods><methods><class-id>DST.DSTRepository</class-id> <category>DST</category><body package="DST_Core_IDL">// DistributedSmalltalk//// This module defines the interfaces of DST core object classes.//  module DistributedSmalltalk  { 	// 	// The ORBobject interface is the MDI of the Smalltalk ORBObject	// class. It is also inherited by every Smalltalk class object, thus	// each class object can represent its ORB, its Repository, and its	// Factories	// 	interface ORBObject_class :					ORB, 					Repository, 					CosLifeCycle::GenericFactory, 					ClassObject	{		// This operation returns the Root NamingContext of the		// NamingService		NamingContext namingService ();		// Thie operation returns a reference to the Daemon		SharedIR::VirtualProcess daemon ();	};	// 	// The SmalltalkObjectAdapter interface is the MDI of the Smalltalk ORBDaemon	// class. 	// 	interface SmalltalkObjectAdapter :					CORBA::ORB, 					SharedIR::SharedInterfaceRepository, 					SharedIR::VirtualProcess	{		// Thie operation returns a reference to the ORBObject_class		ORBObject_class orbObject ();	};};</body></methods><methods><class-id>DST.DSTRepository</class-id> <category>CORBA</category><body package="DST_Core_IDL">// DynamicInvocation//// 	The ORB dynamic invocation interface allows dynamic creation and//	invocation of requests to objects. A client using this interface to// 	send a request to an object obtains the same semantics as a client// 	using the operation stub generated from the type specification////	According to the CORBA specification the PIDL interfaces for DII,//	the associated exception declarations and the like, all belong in//	the 'CORBA' module.////	Furthermore, according to the IDL in the specification, many DII//	operations return a 'Status'.  For this, we have substituted the type//	'CORBA::ORBStatus'.//module DynamicInvocation  {	// According to the 2.1 spec the following line should be in the 'CORBA' module.	exception WrongTransaction {};		// These are global types for the dynamic invocation interface	typedef  unsigned long Flags;	#pragma class ContextEntry Association	struct  ContextEntry {SmalltalkTypes::Symbol key; any value; };	#pragma class Context Dictionary	typedef  sequence&lt;ContextEntry&gt; Context;	typedef  string Environment;	struct NamedValue {		CORBA::Identifier name;		any argument;		long len;		Flags argModes;	};	// 	// The list operations that NVList objects are defined in the ORB	// interface	// 	interface NVList {		#pragma  selector add_item addItemIdentifier:typeCode:any:long:flags:		// This operation adds a new item to the indicated list. The		// item is added after the previously added item.		CORBA::ORBStatus add_item (									in CORBA::Identifier item_name,									in TypeCode item_type,									in any item_value,									in long item_length,									in Flags item_flags);		// This operation frees the list structure and any associated		// memory		CORBA::ORBStatus free ();		// This operation frees any dynamically allocated out-arg		// memory associated with the list. The list itself is not freed.		CORBA::ORBStatus free_memory ();		// This operation returns the total number of items allocated		// for this list		CORBA::ORBStatus get_count ();	};	// 	// The request routines are defined in terms of the Request	// pseudo-object	// 	interface Request {		#pragma  selector add_arg addArg:type:value:length:flags:		// This operation incrementally adds arguments to the		// request		CORBA::ORBStatus add_arg (			in CORBA::Identifier name,			in TypeCode arg_type,			// For the following, the spec reads 'in void * value,'.			in any value,			in long len,			in Flags arg_flags		);		// This operation calls the ORB, which performs method		// resolution and invokes an appropriate method. If the		// method returns successfully, its result is placed in the result		// argument specified on create_request()		CORBA::ORBStatus invoke (in Flags invoke_flags);		// This operation deletes the request. Any memory associated		// with the request is also freed.		CORBA::ORBStatus delete ();		// Send initiates an operation according to the information in		// the Request. Unlike invoke(), send() returns control to the		// caller without waiting for the operation to finish. To		// determine when the operation is done, the caller must use		// the get_response() or get_next_response() operations		// described below. The out parameters and return value must		// not be used until the operation is done.		CORBA::ORBStatus send (in Flags invoke_flags);		// This operation determines whether a request has		// completed. If so, then the out and return parameters		// defined in the Request are valid. If the RESP_NO_WAIT flag		// is set, then get_response() returns immediately even if the		// request is still in progress.		// The IDL for this operation was changed in 2.1.		CORBA::ORBStatus get_response (			in Flags response_flags		) raises (WrongTransaction);	};};</body><body package="DST_Core_IDL">// IOR//// ... contains standard Protocol Profile tag values// module IOR  {	typedef unsigned long ProfileId;	const ProfileId TAG_INTERNET_IOP = 0;	const ProfileId TAG_MULTIPLE_COMPONENTS = 1;	#pragma  class TaggedProfile IORTaggedProfile	struct  TaggedProfile {ProfileId tag; sequence&lt;octet&gt; profile_data; };	// 	// an Interoperable Object Reference is a sequence of	// object-specific protocol profiles, plus a type ID	// 	struct  IOR {string type_id; sequence&lt;TaggedProfile&gt; profiles; };	// 	// Standard way of representing multicomponent profiles.	// This would be encapsulated in a Tagged Component.	// 	typedef unsigned long ComponentId;	#pragma  class TaggedComponent TaggedComponent	struct TaggedComponent {		ComponentId tag;		sequence&lt;octet&gt; profiles;	};	typedef sequence&lt;TaggedComponent&gt; MultiComponentProfile;};</body></methods><methods><class-id>DST.DSTRepository</class-id> <category>DEMO</category><body package="DST_Core_IDL">// Security//// This module defines the types and interfaces which form the // minimum interface to the Security service for access control.//module Security  {	typedef sequence&lt;SmalltalkTypes::Symbol&gt; AccessList;	union SymbolOrORBId switch (boolean) {		case TRUE: SmalltalkTypes::Symbol symbol;		case FALSE: CORBA::ORBId id;	};	typedef sequence&lt;SmalltalkTypes::ByteArray&gt; Hosts;	exception UserNotFound {};	exception NotSupported {};	// This interface defines the abstract behavior of AccesControl objects	// 	interface AccessControl {		#pragma  access acl admin		IdentityDictionary acl ()								raises (NotSupported, UserNotFound);		#pragma  access add admin		#pragma  selector add addAccess:user:		void add (in AccessList access, in SymbolOrORBId user)					raises (NotSupported);		#pragma  access set admin		#pragma  selector set setAccess:user:		void set (in AccessList access, in SymbolOrORBId user)					raises (NotSupported);		#pragma  access remove admin		#pragma  selector remove removeAccess:user:		void remove (in AccessList access, in SymbolOrORBId user)					raises (NotSupported, UserNotFound);		#pragma  access removeUserFromACL admin		#pragma  selector removeUserFromACL removeUserFromACL:		void removeUserFromACL (in SymbolOrORBId user)					raises (NotSupported, UserNotFound);	};};</body></methods><methods><class-id>DST.DSTRepository</class-id> <category>CORE</category><body package="DST_Core_IDL">// SharedIR//// This module defines the interfaces used for shared repository as well as // those interfaces needed for bootstrapping the system.// module SharedIR  {	#pragma class RepositoryId RepositoryId	typedef  string RepositoryId;	#pragma class Symbol Symbol	typedef  string Symbol;	#pragma class ByteArray ByteArray	typedef  sequence&lt;octet&gt; ByteArray;	#pragma class CachedInterface DSTcachedInterface	struct CachedInterface {		Symbol name;		string idlName;		RepositoryId repositoryId;		sequence&lt;CachedInterface&gt; superiors;		sequence&lt;Symbol&gt; epv;	};	#pragma class CachedType ByteArray	typedef  sequence&lt;octet&gt; CachedType;	#pragma class CachedParameter DSTcachedParameter	struct CachedParameter {		Symbol name;		Symbol direction;		CachedType typeCodeInfo;	};	#pragma class Signature DSTsignature	typedef  sequence&lt;CachedParameter&gt; Signature;	#pragma class CachedException DSTcachedException	struct CachedException {		Symbol name;		string idlName;		RepositoryId repositoryId;		CachedType errorTypeCodeInfo;	};	#pragma class CachedOperation DSTcachedOperation	struct CachedOperation {		Symbol name;		RepositoryId definedIn;		Symbol localOp;		Symbol access;		Signature signature;		Symbol mode;		sequence&lt;Symbol&gt; raises;		sequence&lt;Symbol&gt; context;	};	#pragma class Enumerator DSTEnumerator	struct Enumerator {		Symbol name;		unsigned long value;		TypeCode type;	};	union SymbolOrRepositoryId switch (boolean) {		case TRUE: Symbol symbol;		case FALSE: RepositoryId id;	};	union CachedMetaObject switch (short) {		case 1: CachedInterface metaObjectInterface;		case 2: CachedException metaObjectException;		case 3: CachedType typeCodeInfo;	};	union ConstantOrException switch (short) {		case 1: long integerConstant;		case 2: string stringConstant;		case 3: char characterConstant;		case 4: double floatingPointConstant;		case 5: Enumerator enumConstant;		case 6: CachedException exceptionConstant;	};	// 	// This interface defines the abstract behavior of anInterface objects	// 	interface SharedInterfaceRepository {		#pragma  selector getCachedInterface getCachedInterface:		CachedInterface getCachedInterface (									in SymbolOrRepositoryId identity);		#pragma  selector getCachedOperation getCachedOperation:interface:		CachedOperation getCachedOperation (									in Symbol selector,									in RepositoryId Interface);		#pragma  selector getCachedMetaObject getCachedMetaObject:		CachedMetaObject getCachedMetaObject (										in SymbolOrRepositoryId id);		#pragma  selector getConstantOrException getConstantOrException:		ConstantOrException getConstantOrException (in Symbol id);	};	// This interface defines the behavior of ORBDaemon class objects	// 	interface VirtualProcess : SharedInterfaceRepository {		boolean ping ();		#pragma  selector verify verify:vpId:		boolean verify (in string domain, in string vp_id);		#pragma  selector update update:vpId:		VirtualProcess update (in string domain, in string vp_id);	};};</body></methods><methods><class-id>DST.DSTRepository</class-id> <category>DST</category><body package="DST_Core_IDL">// SmalltalkSpecific//// This module defines interfaces common to Smalltalk objects.// module SmalltalkSpecific  {	typedef  sequence&lt;ClassObject&gt; class_objects;	typedef  sequence&lt;Identifier&gt; identifiers;	// 	// This interface defines the Smalltalk dependency mechanism	// 	interface DependentObject {		DependentObject addDependent (in DependentObject object);		DependentObject removeDependent (in DependentObject object);		#pragma  selector expressInterestIn expressInterestIn:for:sendBack:		void expressInterestIn (						in SmalltalkTypes::Symbol aspect,						in DependentObject object,						in SmalltalkTypes::Symbol selector);		#pragma  selector retractInterestIn retractInterestIn:for:		DependentObject retractInterestIn (									in SmalltalkTypes::Symbol aspect,									in DependentObject object);		#pragma  selector updateAspect update:		void updateAspect (in SmalltalkTypes::Symbol aspect);		#pragma  selector updateAspectParameter update:with:		void updateAspectParameter (						in SmalltalkTypes::Symbol aspect,						in any parameter);		#pragma  selector updateAspectParameterFrom update:with:from:		void updateAspectParameterFrom (						in SmalltalkTypes::Symbol aspect,						in any parameter,						in DependentObject from);		// Answer true if the receiver allows a change		boolean update_request ();		#pragma  selector update_aspect_request updateRequest:		// Answer true if the receiver allows the aspect to change		boolean update_aspect_request (in SmalltalkTypes::Symbol aspect);		// The receiver wants to change. Check with all dependents		// that it is OK		boolean change_request ();		// The receiver wants to change. Check with all dependents		// (except the requestor) that it is OK		boolean change_request_from (in DependentObject requestor);		#pragma  selector change_aspect_request changeRequest:		// The receiver wants to change this aspect. Check with all		// dependents that it is OK		boolean change_aspect_request (in SmalltalkTypes::Symbol aspect);	};	// 	// This interface defines operations common to all Smalltalk	// objects	// 	interface SmalltalkObject : DependentObject, Security::AccessControl {		readonly attribute ClassObject classObject;	};	// 	// This interface defines operations common to all Smalltalk class	// objects	// 	interface ClassObject : SmalltalkObject, CORBA::ImplementationDef {		readonly attribute boolean isMeta;		readonly attribute Identifier name;		readonly attribute class_objects allSuperclasses;		readonly attribute class_objects subclasses;	};};</body><body package="DST_Core_IDL">// SmalltalkTypes//// This module defines basic Smalltalktypes which are useful in many// situations.// module SmalltalkTypes  {	#pragma  class Symbol Symbol	typedef string Symbol;	#pragma  class ByteArray ByteArray	typedef sequence&lt;octet&gt; ByteArray;	#pragma  class ByteString ByteString	typedef sequence&lt;char&gt; ByteString;	#pragma  class OrderedCollection OrderedCollection	typedef sequence&lt;any&gt; OrderedCollection;	#pragma  class Set Set	typedef sequence&lt;any&gt; Set;	#pragma  class Bag Bag	typedef sequence&lt;any&gt; Bag;	#pragma  class Association Association	struct  Association {any key; any value; };	#pragma  class Dictionary Dictionary	typedef sequence&lt;Association&gt; Dictionary;	#pragma  class IdentityDictionary IdentityDictionary	typedef sequence&lt;Association&gt; IdentityDictionary;	#pragma  class Point Point	struct  Point {short x; short y; };	#pragma  class Rectangle Rectangle	struct  Rectangle {Point origin; Point corner; };	#pragma  class Date Date	struct  Date {short day; short year; };	#pragma  class Time Time	struct  Time {short hours; short minutes; short seconds; };	#pragma  class ArrayOfShort Array	typedef sequence&lt;short&gt; ArrayOfShort;	#pragma  class ColorValue ColorValue	struct  ColorValue {float red; float green; float blue; };	#pragma  class Runs Array	typedef sequence&lt;Run&gt; Runs;	union Run switch (short) {		case 1: Symbol sym;		case 2: Runs runs;		case 3: Association emphasis;		case 4: Object nil;	};	#pragma  class RunArray RunArray	struct  RunArray {ArrayOfShort runs; Runs values; };	#pragma  class Text Text	struct  Text {string textString; RunArray runs; };	// Here are some useful definitions to deal with nil as it is	// common in Smalltalk implementations	union SymbolOrNil switch (boolean) {		case TRUE: Symbol aSymbol;		case FALSE: Object nil;	};	union SymbolsOrNil switch (boolean) {		case TRUE: sequence&lt;Symbol&gt; symbols;		case FALSE: Object nil;	};	union StringOrNil switch (boolean) {		case TRUE: string aString;		case FALSE: Object nil;	};	union StringsOrNil switch (boolean) {		case TRUE: sequence&lt;string&gt; strings;		case FALSE: Object nil;	};	union WideStringOrNil switch (boolean) {		case TRUE: wstring aWideString;		case FALSE: Object nil;	};	union WideStringsOrNil switch (boolean) {		case TRUE: sequence&lt;wstring&gt; wstrings;		case FALSE: Object nil;	};	union BooleanOrNil switch (boolean) {		case TRUE: boolean aBoolean;		case FALSE: Object nil;	};	union ShortOrNil switch (boolean) {		case TRUE: short aShort;		case FALSE: Object nil;	};	union UnsignedShortOrNil switch (boolean) {		case TRUE: unsigned short anUnsignedShort;		case FALSE: Object nil;	};	union LongOrNil switch (boolean) {		case TRUE: long aLong;		case FALSE: Object nil;	};	union UnsignedLongOrNil switch (boolean) {		case TRUE: unsigned long anUnsignedLong;		case FALSE: Object nil;	};	union LongLongOrNil switch (boolean) {		case TRUE: long long aLongLong;		case FALSE: Object nil;	};	union UnsignedLongLongOrNil switch (boolean) {		case TRUE: unsigned long long anUnsignedLongLong;		case FALSE: Object nil;	};	union FloatOrNil switch (boolean) {		case TRUE: float aFloat;		case FALSE: Object nil;	};	union DoubleOrNil switch (boolean) {		case TRUE: double aDouble;		case FALSE: Object nil;	};	union LongDoubleOrNil switch (boolean) {		case TRUE: long double aLongDouble;		case FALSE: Object nil;	};	union CharacterOrNil switch (boolean) {		case TRUE: char aCharacter;		case FALSE: Object nil;	};	union WideCharacterOrNil switch (boolean) {		case TRUE: wchar aWideCharacter;		case FALSE: Object nil;	};	union DateOrNil switch (boolean) {		case TRUE: SmalltalkTypes::Date aDate;		case FALSE: Object nil;	};	union TimeOrNil switch (boolean) {		case TRUE: SmalltalkTypes::Time aTime;		case FALSE: Object nil;	};	#pragma  class Timestamp Timestamp	struct  Timestamp { 		long year;		long month;		long day;		long hour;		long minute;		long second;		long millisecond;	};	union TimestampOrNil switch (boolean) {		case TRUE: Timestamp aTimestamp;		case FALSE: Object nil;	};	exception StreamError {string reason; };	exception AtEndOfStream {};	// 	// This interface defines operations on Stream objects	// 	interface StreamRead {		#pragma  class Octets ByteArray		typedef sequence&lt;octet&gt; Octets;		readonly attribute Octets contents;		#pragma  selector next_one next		// This operation returns the next element of the receiver		octet next_one ()					raises (AtEndOfStream, StreamError);		#pragma  selector next_n next:		// This operation returns the next "n" elements of the receiver		Octets next_n (in short n)					raises (AtEndOfStream, StreamError);		#pragma  selector next_available nextAvailable:		// This operation returns up to the next "n" elements of the		// receiver		Octets next_available (in short n)					raises (StreamError);		// This operation returns true if the receiver contains no more		// elements		boolean at_end ();	};	// 	// This interface defines operations on Stream objects	// 	interface Stream : StreamRead {		#pragma  selector next_put nextPut:		// This operation appends an element as the next element of		// the receiver		void next_put (in octet value)					raises (StreamError);		#pragma  selector next_put_all nextPutAll:		// This operation appends elements at the end of the receiver		void next_put_all (in ByteArray value)					raises (StreamError);		#pragma  selector destroy_stream destroy		// This operation is used to destroy the receiver		void destroy_stream ();	};};</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>DSTRepository</name><environment>DST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Repository</category><attributes><package>DST_Repository</package></attributes></class></st-source>