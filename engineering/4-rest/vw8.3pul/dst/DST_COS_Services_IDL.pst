<?xml version="1.0"?><st-source><!-- Name: DST_COS_Services_IDLNotice: Copyright 1999-2013 Cincom Systems, Inc.  All rights reserved.Comment: DST_COS_Services_IDL contains the IDL source for the Concurrency Control, Transaction, and Event Services.Copyright: Copyright © 1999-2001 Cincom Systems, Inc.All Rights ReservedThis product contains copyrighted third-party software.Copyright © 1993-1995 Hewlett-Packard Company.All Rights ReservedDbIdentifier: bear73DbTrace: 464620DbUsername: tkoganDbVersion: 8.1 - 1DevelopmentPrerequisites: #(#(#any 'DST_IDLCompiler' '') #(#any 'DST_Repository' ''))PackageName: DST_COS_Services_IDLParcel: #('DST_COS_Services_IDL')ParcelName: DST_COS_Services_IDLPrerequisiteDescriptions: #(#(#name 'DST_IDLCompiler' #componentType #package) #(#name 'DST_Repository' #componentType #package))PrerequisiteParcels: #(#('DST_IDLCompiler' '') #('DST_Repository' ''))PrintStringCache: (8.1 - 1,tkogan)Version: 8.1 - 1Date: 1:09:21 PM January 29, 2016 --><time-stamp>From VisualWorks®, Pre-Release 8.2 (jan16.4) of January 29, 2016 on January 29, 2016 at 1:09:21 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><methods><class-id>DST.DSTRepository</class-id> <category>COS</category><body package="DST_COS_Services_IDL">// CosConcurrencyControl//// This module defines the Concurrency Control Service as defined in the// OMG Common Object Services Specification version 1.2.// module CosConcurrencyControl  {	#pragma prefix "omg.org/CosConcurrencyControl"	// lock_mode defines the types of locks that can be acquired on a	// resource	enum lock_mode {read, write, upgrade, intentionRead, intentionWrite};	// The LockNotHeld exception is raised when an operation to unlock or	// change the mode of a lock is called and the specified lock is not held	exception LockNotHeld {};	// The LockSet interface only provides operations to acquire and release	// locks on behalf of the calling thread or transaction. This interface does	// not provide support for transactional clients that use the explicit OMG	// Transaction Service interfaces.	// 	interface LockSet {		#pragma selector lock lock:		// Acquire the lock using the specified mode; block until lock acquired		void lock (in lock_mode mode);		#pragma selector try_lock tryLock:		// Try to acquire the lock using the specified mode; don't block		boolean try_lock (in lock_mode mode);		#pragma selector unlock unlock:		// drop a single lock on the lock set		void unlock (in lock_mode mode)					raises (LockNotHeld);		#pragma selector change_mode changeMode:newMode:		// change the mode of a single lock from the currently held mode to		// the new mode		void change_mode (						in lock_mode held_mode,						in lock_mode new_mode)					raises (LockNotHeld);		// return the lock coordinator for a specified transaction		LockCoordinator get_coordinator (									in CosTransactions::Coordinator which);	};	// The TransactionalLockSet interface provides operations to acquire and	// release locks on a lock set on behalf of a specific transaction	// 	interface TransactionalLockSet {		#pragma selector lock lock:mode:		// Acquire the lock using the specified mode; block until lock acquired		void lock (						in CosTransactions::Coordinator which,						in lock_mode mode);		#pragma selector try_lock tryLock:mode:		// Try to acquire the lock using the specified mode; don't block		boolean try_lock (							in CosTransactions::Coordinator which,							in lock_mode mode);		#pragma selector unlock unlock:mode:		// drop a single lock on the lock set		void unlock (						in CosTransactions::Coordinator which,						in lock_mode mode)					raises (LockNotHeld);		#pragma selector change_mode changeMode:heldMode:newMode:		// change the mode of a single lock from the currently held mode to		// the new mode		void change_mode (						in CosTransactions::Coordinator which,						in lock_mode held_mode,						in lock_mode new_mode)					raises (LockNotHeld);		// return the lock coordinator for a specified transaction		LockCoordinator get_coordinator (									in CosTransactions::Coordinator which);	};	// The LockSetFactory interface provides two sets of operations which	// return new LockSet and TransactionalLockSet instances	// 	interface LockSetFactory {		// Create a new LockSet and LockCoordinator		LockSet create ();		// Create a new LockSet that is related to an existing LockSet.		// Related lock sets drop their locks together.		LockSet create_related (in LockSet which);		// Create a new Transactional LockSet and LockCoordinator		// for explicit mode transactional clients		TransactionalLockSet create_transactional ();		// Create a new transactional LockSet that is related to an existing 		// LockSet.		// Related lock sets drop their locks together.		TransactionalLockSet create_transactional_related (										in TransactionalLockSet which);	};	// The LockCoordinator interface enables a transaction service to drop all 	// locks held by a transaction	// 	interface LockCoordinator {		void drop_locks ();	};	// The DSTCoordinatingLockSet: interface is a DST extension which allows the	// implementation of locksets to act as their own coordinators	// 	interface DSTCoordinatingLockSet: LockSet, LockCoordinator {};	// This interface defines the abstract behavior of DSTTransactionalObject	// 	interface DSTLockSet :					LockSet, 					CosLifeCycle::LifeCycleObject, 					CosLifeCycle::FactoryRepresentative	{};	// This interface defines the abstract behavior of DSTTransactionalObject	// 	interface DSTTransactionalLockSet :					TransactionalLockSet, 					CosLifeCycle::LifeCycleObject, 					CosLifeCycle::FactoryRepresentative	{};};</body><body package="DST_COS_Services_IDL">// CosEventChannelAdmin//// This defines the administrative interfaces to support the// EventComm policy.// module CosEventChannelAdmin  {	#pragma prefix "omg.org/CosEventChannelAdmin"	exception AlreadyConnected {};	exception TypeError {};	// 	// This interface defines the second step for connecting push	// suppliers to the event channel	// 	interface ProxyPushConsumer : CosEventComm::PushConsumer {		void connect_push_supplier (						in CosEventComm::PushSupplier push_supplier)					raises (AlreadyConnected);	};	// 	// This interface defines the second step for connecting pull	// consumers to the event channel	// 	interface ProxyPullSupplier : CosEventComm::PullSupplier {		void connect_pull_consumer (						in CosEventComm::PullConsumer pull_consumer)					raises (AlreadyConnected);	};	// 	// This interface defines the second step for connecting pull	// suppliers to the event channel	// 	interface ProxyPullConsumer : CosEventComm::PullConsumer {		void connect_pull_supplier (in CosEventComm::PullSupplier pull_supplier)					raises (AlreadyConnected);	};	// 	// This interface defines the second step for connecting push	// consumers to the event channel	// 	interface ProxyPushSupplier : CosEventComm::PushSupplier {		void connect_push_consumer (						in CosEventComm::PushConsumer push_consumer)					raises (AlreadyConnected);	};	// 	// This interface allows consumers to be added to the event	// channel. When a consumer is added to the event channel, a	// style of communication is indicated	// 	interface ConsumerAdmin {		// This operation adds a push-type consumer to the event		// channel		ProxyPushSupplier obtain_push_supplier ();		// This operation adds a pull-type consumer to the event		// channel		ProxyPullSupplier obtain_pull_supplier ();	};	// 	// This defines the supplier administrative operations for event	// channels	// 	interface SupplierAdmin {		// This operation adds a push-type supplier to the event		// channel		ProxyPushConsumer obtain_push_consumer ();		// This operation adds a pull-type supplier to the event		// channel		ProxyPullConsumer obtain_pull_consumer ();	};	// 	// This interface defines three administrative operations. Any	// object that possesses an object reference that supports the	// EventChannel interface can add consumers, add suppliers, and	// can destroy the channel	// 	interface EventChannel {		// This operation returns an object reference supporting the		// ConsumerAdmin interface. The ConsumerAdmin interface		// allows consumers to be added to the event channel		ConsumerAdmin for_consumers ();		// This operation returns an object reference supporting the		// SupplierAdmin interface. The SupplierAdmin interface		// allows suppliers to be added to the event channel		SupplierAdmin for_suppliers ();		// This operation destroys the event channel		void destroy ();	};	// 	// This interface defines three administrative operations. Any	// object that possesses an object reference that supports the	// EventChannel interface can add consumers, add suppliers, and	// can destroy the channel	// 	interface DSTEventChannel : EventChannel, SupplierAdmin, ConsumerAdmin {};};</body><body package="DST_COS_Services_IDL">// CosEventComm//// This defines the interfaces and types to support the OMG// Standardized Event Service.// module CosEventComm  {	#pragma prefix "omg.org/CosEventComm"	exception Disconnected {};	// 	// A push-style consumer supports the PushConsumer interface	// to receive event data.	// 	interface PushConsumer {		#pragma  selector push pushEventData:		// A supplier communicates event data to the consumer by		// invoking the push operation and passing the event data as		// a parameter. If the event communication has already been		// disconnected, the Disconnected exception is raised.		void push (in any event_data)					raises (Disconnected);		// This operation indicates that the event communication		// should be terminated.		void disconnect_push_consumer ();	};	// 	// A push-style supplier supports the PushSupplier interface.	// 	interface PushSupplier {		// This operation indicates that the event communication		// should be terminated.		void disconnect_push_supplier ();	};	// 	// A pull-style consumer supports the PullConsumer interface.	// 	interface PullConsumer {		// This operation indicates that the event communication		// should be terminated.		void disconnect_pull_consumer ();	};	// 	// A pull-style supplier supports the Supplier interface to	// transmit event data.	// 	interface PullSupplier {		// This operation blocks until the event data is available,		// whereupon it returns the event data to the consumer.		any pull ()					raises (Disconnected);		#pragma  selector try_pull tryPull:		// This operation does not block, but sets the has_event		// parameter to true if the event data is available. If the event		// is not available, it returns has_event equal to false and the		// event data is a long with an undefined value.		any try_pull (out boolean has_event)					raises (Disconnected);		// This operation indicates that the event communication		// should be terminated.		void disconnect_pull_supplier ();	};};</body><body package="DST_COS_Services_IDL">// CosTransactions//// This module defines the types and interfaces which form the Transaction// service.// module CosTransactions  {	#pragma prefix "omg.org/CosTransactions"	// Datatypes	enum Status {		StatusActive,		StatusMarkedRollback,		StatusPrepared,		StatusCommitted,		StatusRolledBack,		StatusUnknown,		StatusNoTransaction	};	enum Vote {VoteCommit, VoteRollback, VoteReadOnly};	// Standard exceptions	exception TransactionRequired {};	exception TransactionRolledBack {};	exception InvalidTransaction {};	// Hueristic exceptions	exception HeuristicRollback {};	exception HeuristicCommit {};	exception HeuristicMixed {};	exception HeuristicHazard {};	// Exception from ORB operations	exception WrongTransaction {};	// Other transaction-specific exceptions	exception SubtransactionsUnavailable {};	exception NotSubtransaction {};	exception Inactive {};	exception NotPrepared {};	exception NoTransaction {};	exception InvalidControl {};	exception Unavailable {};	// This interface defines the abstract behavior of Current objects	// 	The Current object is a psuedo-object and therefor not formally	// 	defined as an interface in this module. See the Transactions	// 	specification for the definition of this psuedo-object.	// This interface defines the abstract behavior of Factory objects	// 	interface Factory {		Control create (in unsigned long time_out);	};	// This interface defines the abstract behavior of Control objects	// 	interface Control {		Terminator get_terminator ()							raises (Unavailable);		Coordinator get_coordinator ()							raises (Unavailable);	};	// This interface defines the abstract behavior of Terminator objects	// 	interface Terminator {		void commit (in boolean report_heuristics)					raises (HeuristicMixed, HeuristicHazard);		void rollback ();	};	// This interface defines the abstract behavior of anotherInterface objects	// 	interface Coordinator {		Status get_status ();		Status get_parent_status ();		Status get_top_level_status ();		boolean is_same_transaction (in Coordinator tc);		boolean is_related_transaction (in Coordinator tc);		boolean is_ancestor_transaction (in Coordinator tc);		boolean is_descendant_transaction (in Coordinator tc);		boolean is_top_level_transaction ();		unsigned long hash_transaction ();		unsigned long hash_top_level_tran ();		RecoveryCoordinator register_resource (in Resource r)									raises (Inactive);		void register_subtran_aware (in SubtransactionAwareResource r)					raises (Inactive, NotSubtransaction);		void rollback_only ()					raises (Inactive);		string get_transaction_name ();		Control create_subtransaction ()						raises (SubtransactionsUnavailable, Inactive);	};	// This interface defines the abstract behavior of RecoveryCoordinator	// objects	// 	interface RecoveryCoordinator {		Status replay_completion (in Resource r)					raises (NotPrepared);	};	// This interface defines the abstract behavior of Resource objects	// 	interface Resource {		Vote prepare ();		void rollback ()					raises (HeuristicCommit, HeuristicMixed, HeuristicHazard);		void commit ()					raises (NotPrepared,							HeuristicRollback,							HeuristicMixed,							HeuristicHazard);		void commit_one_phase ()					raises (HeuristicRollback, HeuristicMixed, HeuristicHazard);		void forget ();	};	// This interface defines the abstract behavior of	// SubtransactionAwareResource	// objects	// 	interface SubtransactionAwareResource : Resource {		void commit_subtransaction (in Coordinator parent);		void rollback_subtransaction ();	};	// This interface defines the abstract behavior of TransactionalObject	// objects	// 	interface TransactionalObject {};	// This interface defines the abstract behavior of DSTControl objects	// 	interface DSTControl : Control {		void destroy ();		void reset ();	};	// This interface defines the abstract behavior of DSTTransaction objects	// 	interface DSTTransaction : DSTControl, Terminator, Coordinator {		DSTControl getControl ();		long timeOut ();		#pragma  selector set_timeout timeOut:		void set_timeout (in long timeOut);	};	// This interface defines the abstract behavior of DSTTransactionalObject	// 	interface DSTTransactionalObject :					TransactionalObject, 					CosLifeCycle::LifeCycleObject, 					CosLifeCycle::FactoryRepresentative	{};	// This interface defines the abstract behavior of DSTRecoverableObjects	// 	interface DSTRecoverableObject :					SubtransactionAwareResource, 					DSTTransactionalObject	{};	// This interface defines the abstract behavior of 	// DSTSampleRecoverableObjects	// 	interface DSTSampleRecoverableObject : DSTRecoverableObject {		#pragma  selector vote vote:		void vote (in Vote vote);	};	// This interface defines the abstract behavior of Factory objects	// 	interface DSTTransactionFactory : Factory, ClassObject {};	// This interface defines the abstract behavior of 	// DSTRecoveryCoordinators	// 	interface DSTRecoveryCoordinator :					RecoveryCoordinator, 					CosLifeCycle::LifeCycleObject, 					CosLifeCycle::FactoryRepresentative	{};};</body><body package="DST_COS_Services_IDL">// CosTypedEventChannelAdmin//// This defines the administrative interfaces to support the// EventComm policy.// module CosTypedEventChannelAdmin  {	#pragma prefix "omg.org/CosTypedEventChannelAdmin"	exception InterfaceNotSupported {};	exception NoSuchImplementation {};	typedef string Key;	// 	// This interface defines the second step for connecting push	// suppliers to the event channel	// 	interface TypedProxyPushConsumer :					CosEventChannelAdmin::ProxyPushConsumer, 					CosTypedEventComm::TypedPushConsumer	{};	// 	// This interface defines the second step for connecting pull	// consumers to the event channel	// 	interface TypedProxyPullSupplier :					CosEventChannelAdmin::ProxyPullSupplier, 					CosTypedEventComm::TypedPullSupplier	{};	// 	// This interface allows consumers to be added to the event	// channel. When a consumer is added to the event channel, a	// style of communication is indicated	// 	interface TypedConsumerAdmin : CosEventChannelAdmin::ConsumerAdmin {		#pragma  selector obtain_typed_pull_supplier obtainTypedPullSupplier:		// This operation adds a push-type consumer to the event		// channel		TypedProxyPullSupplier obtain_typed_pull_supplier (										in Key supported_interface)									raises (InterfaceNotSupported);		#pragma  selector obtain_typed_push_supplier obtainTypedPushSupplier:		// This operation adds a pull-type consumer to the event		// channel		ProxyPushSupplier obtain_typed_push_supplier (in Key uses_interface)								raises (NoSuchImplementation);	};	// 	// This interface allows consumers to be added to the event	// channel. When a consumer is added to the event channel, a	// style of communication is indicated	// 	interface TypedSupplierAdmin : CosEventChannelAdmin::SupplierAdmin {		#pragma  selector obtain_typed_push_consumer obtainTypedPushConsumer:		// This operation adds a push-type consumer to the event		// channel		TypedProxyPushConsumer obtain_typed_push_consumer (											in Key supported_interface)										raises (InterfaceNotSupported);		#pragma  selector  obtain_typed_pull_consumer obtainTypedPullConsumer:		// This operation adds a pull-type consumer to the event		// channel		ProxyPullConsumer obtain_typed_pull_consumer (in Key uses_interface)								raises (NoSuchImplementation);	};	// 	// This interface defines three administrative operations. Any	// object that possesses an object reference that supports the	// EventChannel interface can add consumers, add suppliers, and	// can destroy the channel	// 	interface TypedEventChannel {		// This operation returns an object reference supporting the		// ConsumerAdmin interface. The ConsumerAdmin interface		// allows consumers to be added to the event channel		TypedConsumerAdmin for_consumers ();		// This operation returns an object reference supporting the		// SupplierAdmin interface. The SupplierAdmin interface		// allows suppliers to be added to the event channel		TypedSupplierAdmin for_suppliers ();		// This operation destroys the event channel		void destroy ();	};	interface DSTProxyConsumer :					TypedProxyPushConsumer, 					CosEventChannelAdmin::ProxyPullConsumer	{};	interface DSTProxySupplier :					CosEventChannelAdmin::ProxyPushSupplier, 					TypedProxyPullSupplier	{};	// 	// This interface defines three administrative operations. Any	// object that possesses an object reference that supports the	// EventChannel interface can add consumers, add suppliers, and	// can destroy the channel	// 	interface DSTTypedEventChannel :					TypedEventChannel, 					TypedSupplierAdmin, 					TypedConsumerAdmin	{};};</body><body package="DST_COS_Services_IDL">// CosTypedEventComm//// This defines the interfaces and types to support the OMG// Standardized Event Service.// module CosTypedEventComm  {	#pragma prefix "omg.org/CosTypedEventComm"	// 	// A typed push-style consumer supports the	// TypedPushConsumer interface both to receive event data in the	// generic manner, and to supply a specific typed interface	// through which to receive it in typed form.	// 	interface TypedPushConsumer : CosEventComm::PushConsumer {		Object get_typed_consumer ();	};	// 	// A typed pull-style supplier supports the TypedPullSupplier	// interface to transmit event data.	// 	interface TypedPullSupplier : CosEventComm::PullSupplier {		Object get_typed_supplier ();	};};</body><body package="DST_COS_Services_IDL">// TSInteroperation//// This module defines the types and interfaces of the pseudo-object which// is used for propagating context information along a transaction.//module TSInteroperation {	#pragma  class otid_t DSTTransactionIdentifier	struct otid_t {		long	formatId;		long	bequal_length;		sequence &lt;octet&gt; tid;	};	#pragma  class TransIdentity DSTTransactionIdentity	struct TransIdentity {		CosTransactions::Coordinator	coordinator;		CosTransactions::Terminator	terminator;		otid_t	otid;	};	struct PropagationContext {		unsigned long	timeout;		TransIdentity	current;		sequence &lt;TransIdentity&gt; parents;		any		implementation_specific_data;	};};</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>DSTRepository</name><environment>DST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Repository</category><attributes><package>DST_Repository</package></attributes></class></st-source>