<?xml version="1.0"?><st-source><!-- Name: DST_SampleNotice: Copyright 1999-2013 Cincom Systems, Inc.  All rights reserved.Comment: DST_Sample contains the implementation of a few DST sample applications.Copyright: Copyright © 1999-2002 Cincom Systems, Inc.All Rights ReservedThis product contains copyrighted third-party software.Copyright © 1993-1995 Hewlett-Packard Company.All Rights ReservedDbIdentifier: bear73DbTrace: 464625DbUsername: tkoganDbVersion: 8.1 - 1DevelopmentPrerequisites: #(#(#any 'DST_Core' '') #(#any 'DST_Core_Services' '') #(#any 'DST_COS_Services' '') #(#any 'DST_I3' '') #(#any 'DST_Sample_IDL' ''))PackageName: DST_SampleParcel: #('DST_Sample')ParcelName: DST_SamplePrerequisiteDescriptions: #(#(#name 'DST_Core' #componentType #package) #(#name 'DST_Core_Services' #componentType #package) #(#name 'DST_COS_Services') #(#name 'DST_I3') #(#name 'DST_Sample_IDL'))PrerequisiteParcels: #(#('DST_Core' '') #('DST_Core_Services' '') #('DST_COS_Services' '') #('DST_I3' '') #('DST_Sample_IDL' ''))PrintStringCache: (8.1 - 1,tkogan)Version: 8.1 - 1Date: 1:09:21 PM January 29, 2016 --><time-stamp>From VisualWorks®, Pre-Release 8.2 (jan16.4) of January 29, 2016 on January 29, 2016 at 1:09:21 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>DSTSampleRequestInterceptor</name><environment>DST</environment><super>DST.DSTRequestInterceptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>operation </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>DST-Demo-Interceptors</category><attributes><package>DST_Sample</package></attributes></class><class><name>DSTSampleMessageInterceptor</name><environment>DST</environment><super>DST.DSTMessageInterceptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>conversation </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>DST-Demo-Interceptors</category><attributes><package>DST_Sample</package></attributes></class><class><name>DemoEventChannel</name><environment>DST</environment><super>DST.DSTEventChannel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hostname port </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>DST-Demo-EventChannel</category><attributes><package>DST_Sample</package></attributes></class><comment><class-id>DST.DemoEventChannel</class-id><body>DemoEventChannel is a subclass of DSTEventChannel, with additional instance variablesand protocol, to facilitate support of the DemoEventChannelInterface.Instance Variables:	hostname	&lt;String&gt;	the name of the host where the channel resides	port			&lt;Integer&gt;  	the port through which the channel is accessedClass Instance Variables:	None.Shared Variables:	None.</body></comment><class><name>DemoEventChannelInterface</name><environment>DST</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>channelNumber channelHostName channelPortNumber channelHolder pushSupplier pushConsumer pullSupplier pullConsumer interfaceId eventList loopOn semaphore lock random maxPeriod </inst-vars><class-inst-vars>eventId interfaceId tryId </class-inst-vars><imports></imports><category>DST-Demo-EventChannel</category><attributes><package>DST_Sample</package></attributes></class><comment><class-id>DST.DemoEventChannelInterface</class-id><body>DemoEventChannelInterface is an interface for [a] demonstrating the operation ofDSTEventChannels and [b] providing most of the code patterns commonly used with them.  The patterns illustrated characterize the 'well-known channel' pattern, where event suppliers and consumers do not know of one another, but do have access to a common event channel.  (In the alternative 'consumer knows supplier'pattern, the supplier will maintain an event channel in an instVar and supply its own interfaces for client channel registration.)    DemoEventChannelInterfaces work in concert with an instance of DemoEventChannel.  DemoEventChannelInterfaces can create and destroy aDemoEventChannel, register with it as consumers or suppliers in push or pull mode, and generate, receive, pull, or tryPull events.  Instances of DemeEventChannelInterface need not reside in the same image so long as all instances reside in images sharing the same naming service.Instance Variables:	channelNumber	&lt;ValueHolder&gt;	channelHostName	&lt;ValueHolder&gt;	channelPortNumber 	channelHolder 	&lt;ValueHolder&gt;	pushSupplier	pushConsumer	pullSupplier	pullConsumer	interfaceId	eventList 	loopOnClass Instance Variables:	eventId	interfaceId	tryIdShared Variables:	ChannelClassName	ChannelNamePrefix</body></comment><class><name>DSTSampleComputeService</name><environment>DST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>random computeServers </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>DST-Demo-Interceptors</category><attributes><package>DST_Sample</package></attributes></class><comment><class-id>DST.DSTSampleComputeService</class-id><body>This is a simple DST example.  MyComputeService has one useful method, slowComputationWith:And:, which performs a computation and returns the result.  The accessor method defaultService creates the instance if none already exists.  MyComputeService as written requires the Implicit Invocation Interface (I3) for remote use. Instance Variables:	None.Shared Variables: 	DefaultService	&lt;MyComputeService&gt;	holds the single instance of the compute service</body></comment><shared-variable><name>DefaultService</name><environment>DST.DSTSampleComputeService</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Sample</package></attributes></shared-variable><shared-variable><name>ChannelNamePrefix</name><environment>DST.DemoEventChannelInterface</environment><private>false</private><constant>false</constant><category>statics</category><attributes><package>DST_Sample</package></attributes></shared-variable><shared-variable><name>ChannelClassName</name><environment>DST.DemoEventChannelInterface</environment><private>false</private><constant>false</constant><category>statics</category><attributes><package>DST_Sample</package></attributes></shared-variable><methods><class-id>DST.DSTSampleRequestInterceptor</class-id> <category>intercepting</category><body package="DST_Sample">clientInvokePostSend	Transcript cr; show: 'Intercept - reply post unmarshall - ', operation printString</body><body package="DST_Sample">clientInvokePreSend: aRequest context: anORBContext target: anObjRef operation: anOperation parameters: someParams	operation := anOperation.	Transcript cr; show: 'Intercept - request pre marshall - ',anOperation printString</body><body package="DST_Sample">targetInvokePreReceive: aRequest context: anORBContext target: aReceiver parameters: someParams	self halt.</body></methods><methods><class-id>DST.DSTSampleRequestInterceptor</class-id> <category>sorting</category><body package="DST_Sample">orderOfExecution	^5</body></methods><methods><class-id>DST.DSTSampleRequestInterceptor class</class-id> <category>install</category><body package="DST_Sample">install	IIOPConversation installRequestInterceptor: DSTSampleRequestInterceptor</body></methods><methods><class-id>DST.DSTSampleRequestInterceptor class</class-id> <category>sorting</category><body package="DST_Sample">orderOfExecution	^5</body></methods><methods><class-id>DST.DSTSampleRequestInterceptor class</class-id> <category>testing</category><body package="DST_Sample">test1	"self test1"	^(ORBObject namingService contextResolve: 'DSTSampleComputeService' asDSTName) 		slowComputationWith: 2 and: 3</body></methods><methods><class-id>DST.DSTSampleMessageInterceptor</class-id> <category>intercepting</category><body package="DST_Sample">postSendMessage		Transcript cr; show: 'Intercept - reply pre unmarshall - ', conversation opSelector.</body><body package="DST_Sample">preSendMessage: aClientConversation context: anORBContext target: aReceiver		conversation := aClientConversation.	Transcript cr; show: 'Intercept - request post marshall - ', aClientConversation opSelector.</body></methods><methods><class-id>DST.DSTSampleMessageInterceptor class</class-id> <category>install</category><body package="DST_Sample">install	IIOPConversation installMessageInterceptor: DSTSampleMessageInterceptor</body></methods><methods><class-id>DST.DSTSampleMessageInterceptor class</class-id> <category>sorting</category><body package="DST_Sample">orderOfExecution	^5</body></methods><methods><class-id>DST.DSTSampleMessageInterceptor class</class-id> <category>testing</category><body package="DST_Sample">test1	"self test1"	^(ORBObject namingService contextResolve: 'DSTSampleComputeService' asDSTName) 		slowComputationWith: 2 and: 3</body></methods><methods><class-id>DST.DemoEventChannel</class-id> <category>inquiry</category><body package="DST_Sample">hasPullConsumers	^self pullConsumers isEmpty not</body><body package="DST_Sample">hasPullSuppliers	^self pullSuppliers isEmpty not</body><body package="DST_Sample">hasPushConsumers	^self pushConsumers isEmpty not</body><body package="DST_Sample">hasPushSuppliers	^self pushSuppliers isEmpty not</body><body package="DST_Sample">ping	^true</body></methods><methods><class-id>DST.DemoEventChannel</class-id> <category>repository</category><body package="DST_Sample">CORBAName	^#'::DemoEventChannel::DemoEventChannel'</body><body package="DST_Sample">abstractClassId	^'7b34a187-ee60-0000-02c0-a095f2000000' asUUID</body></methods><methods><class-id>DST.DemoEventChannel</class-id> <category>accessing</category><body package="DST_Sample">hostname	^hostname</body><body package="DST_Sample">hostname: aString	hostname := aString</body><body package="DST_Sample">port	^port</body><body package="DST_Sample">port: anInteger	port := anInteger</body><body package="DST_Sample">pullConsumers	^pullConsumers</body><body package="DST_Sample">pullSuppliers	^pullSuppliers</body><body package="DST_Sample">pushConsumers	^pushConsumers</body><body package="DST_Sample">pushSuppliers	^pushSuppliers</body></methods><methods><class-id>DST.DemoEventChannel</class-id> <category>destruction</category><body package="DST_Sample">destroyAndUnregister: aDSTName	"Unregister the single instance of the registry in the 	Naming Service."	self class destroyAndUnregister: aDSTName</body></methods><methods><class-id>DST.DemoEventChannel</class-id> <category>initialize-release</category><body package="DST_Sample">initialize	super initialize.	self hostname: ORBObject hostIdString.	self port: ( ORBDaemon installedDaemonFor: #IIOPDaemon ) configuredPortNo</body></methods><methods><class-id>DST.DemoEventChannel class</class-id> <category>loading</category><body package="DST_Sample">registerAsFactory	ORBObject registerAsFactory: self</body><body package="DST_Sample">unregisterAsFactory	ORBObject unregisterAsFactory: self</body></methods><methods><class-id>DST.DemoEventChannel class</class-id> <category>instance management</category><body package="DST_Sample">createAndRegister: aDSTName	"Create an instance of the event channel and register it 	in the Naming Service. If the name is already bound, warn 	the user and do not register the instance."	" DemoEventChannel createAndRegister. "	| singleton |	singleton := super new initialize.	DSTObjRef registerFactoryObject: singleton.	^DSTNameContext alreadyBoundSignal		handle:	[:x |	Dialog warn: 						(	'The DemoEventChannel named ',							aDSTName asString,							' is already registered in the Naming Service.' 						). 					nil				]		do:		[ 	ORBObject namingService contextBind: aDSTName to: singleton.					singleton				]</body><body package="DST_Sample">destroyAndUnregister: aDSTName	"Unregister the single instance of the broadcast	channel in the Naming Service."	" DemoEventChannel destroyAndUnregister. "	| inst |	[ inst := ORBObject namingService contextResolve: aDSTName ]		on: DSTNameContext notFoundSignal		do: [ :x | ].	DSTNameContext notFoundSignal		handle: [ :x | ]		do: [ ORBObject namingService contextUnBind: aDSTName ].	(self standardExceptions at: #INV_OBJREF) errorSignal		handle: [ :x | ]		do:	[ inst destroy ].</body><body package="DST_Sample">new	"Instances of this class should be 	created using 'createAndRegister'."	^self shouldNotImplement</body><body package="DST_Sample">new: aValue	"Instances of this class should be 	created using 'createAndRegister'."	^self shouldNotImplement</body></methods><methods><class-id>DST.DemoEventChannel class</class-id> <category>repository</category><body package="DST_Sample">CORBAName	^#'::DemoEventChannel::DemoEventChannelClass'</body></methods><methods><class-id>DST.DemoEventChannelInterface</class-id> <category>actions</category><body package="DST_Sample">clearEventList	self eventList list: List new</body><body package="DST_Sample">createChannel	| orbProxy |	 ( self checkChannelHostName and: [self checkChannelPortNumber ] )		ifTrue:	[	orbProxy := OrbResolver 									generateOrbProxy: self channelHostName value									transport: ORBDaemon configurationManager primaryTransport									port: self channelPortNumber value.					( ( orbProxy resolveInitialReferences: #FactoryFinder ) 						contextResolve: self class channelClassName ) 							createAndRegister: self channelName.					self obtainChannelReference				]</body><body package="DST_Sample">destroyChannel	self channelHolder value destroyAndUnregister: self channelName.	self channelHolder value: nil.</body><body package="DST_Sample">killLoop	self loopOn: false</body><body package="DST_Sample">pull	| c |	( ( c := self pullConsumer ) notNil )		ifTrue:	[	| pe |					pe := c pullEventData.					self incomingEvent: pe.				]</body><body package="DST_Sample">pullEvent	"Generates a 'pull' event and sends it off for processing by 	the pull supplier, if there is one."	| sup | 	( sup := self pullSupplier ) notNil		ifTrue:	[	sup processEvent: self fabricateEvent.					semaphore signal 				]</body><body package="DST_Sample">pullLoop	| c |	self loopOn: true.	[	[ loopOn and: [ ( c := self pullConsumer ) notNil ] ]			whileTrue:	[	| pe |							pe := c pullEventData.							self incomingEvent: pe.						]	] forkAt: Processor userSchedulingPriority -1</body><body package="DST_Sample">pushEvent	"Generates a 'push' event and sends it off for processing by the push 	supplier, if there is one."	| sup |	( sup := self pushSupplier ) notNil		ifTrue:	[	sup processEvent: self fabricateEvent.				].</body><body package="DST_Sample">pushLoop	| s t |	self loopOn: true.	[	[ loopOn and: [ ( s := self pushSupplier ) notNil ] ]			whileTrue:	[	t := self randomInteger: self maxPeriod.							Transcript cr; show: t printString.							s processEvent: self fabricateEvent.							( Delay forMilliseconds: t ) wait.						]	] forkAt: Processor userSchedulingPriority -1</body><body package="DST_Sample">registerAsPullConsumer	| channel consumer proxy |	[	channel := self channelHolder value.		self pullConsumer: ( consumer := DSTPullConsumer new ).		proxy :=channel forConsumers obtainPullSupplier.		proxy connectPullConsumer: consumer.		consumer			host: self			supplier: proxy.		self refreshChannelState	]	on: ORBObject invObjrefSignal		do:	[ :ex | ]</body><body package="DST_Sample">registerAsPullSupplier	| channel supplier proxy |	[	channel := self channelHolder value.		self pullSupplier: ( supplier := DSTPullSupplier new ).		proxy :=channel forSuppliers obtainPullConsumer.		proxy connectPullSupplier: supplier.		supplier 			host: self			consumer: proxy.		self refreshChannelState	]	on: ORBObject invObjrefSignal		do:	[ :ex | ]</body><body package="DST_Sample">registerAsPushConsumer	| channel consumer proxy |	[	channel := self channelHolder value.		self pushConsumer: ( consumer := DSTPushConsumer new ).		proxy :=channel forConsumers obtainPushSupplier.		proxy connectPushConsumer: consumer.		consumer			host: self			supplier: proxy			aspect: #incomingEvent.		self refreshChannelState	]	on: ORBObject invObjrefSignal		do:	[ :ex | ]</body><body package="DST_Sample">registerAsPushSupplier	| channel supplier proxy |	[	channel := self channelHolder value.		self pushSupplier: ( supplier := DSTPushSupplier new ).		proxy :=channel forSuppliers obtainPushConsumer.		proxy connectPushSupplier: supplier.		supplier 			host: self			consumer: proxy.		self refreshChannelState	]	on: ORBObject invObjrefSignal		do:	[ :ex | ]</body><body package="DST_Sample">tryPull	| c vh ed |	( ( c := self pullConsumer ) notNil )		ifTrue:	[	vh := nil asCORBAParameter.					ed := c tryPullEventData: vh.					( ed == 0 )						ifTrue: [ ed := self fabricateNonEvent ].					self incomingEvent: ed ]</body><body package="DST_Sample">tryPullLoop	| c vh ed |	self loopOn: true.	[	[ loopOn and: [ ( c := self pullConsumer ) notNil ] ]			whileTrue:	[	vh := nil asCORBAParameter.							ed := c tryPullEventData: vh.							( ed == 0 )								ifTrue: [ ed := self fabricateNonEvent ].							self incomingEvent: ed 						]	] forkAt: Processor userSchedulingPriority -1</body><body package="DST_Sample">unregisterAsPullConsumer	[	self pullConsumer disconnectPullConsumer.		self refreshChannelState	]	on: ORBObject invObjrefSignal		do:	[ :ex | ]</body><body package="DST_Sample">unregisterAsPullSupplier	[	self pullSupplier consumer disconnectPullConsumer.		self refreshChannelState	]	on: ORBObject invObjrefSignal		do:	[ :ex | ]</body><body package="DST_Sample">unregisterAsPushConsumer	[	self pushConsumer disconnectPushConsumer.		self refreshChannelState	]	on: ORBObject invObjrefSignal		do:	[ :ex | ]</body><body package="DST_Sample">unregisterAsPushSupplier	[	self pushSupplier consumer disconnectPushConsumer.		self refreshChannelState	]	on: ORBObject invObjrefSignal		do:	[ :ex | ]</body></methods><methods><class-id>DST.DemoEventChannelInterface</class-id> <category>private</category><body package="DST_Sample">channelIsAlive	^[ channelHolder value ping ]		on: ORBObject invObjrefSignal		do:	[ :ex | ex return: false ].</body><body package="DST_Sample">pingChannel	^[ channelHolder value ping ]		on: ORBObject invObjrefSignal		do:	[ :ex | ex return: false ].</body><body package="DST_Sample">randomInteger: anInteger	^( ( self random next * anInteger ) + 1 ) truncated</body><body package="DST_Sample">setIndicator: aSymbol toBooleanState: aBoolean	"Changes the color of an indicator light on the basis	if a predicate value."	self 		setIndicator: aSymbol		toColor: ( aBoolean 					ifTrue:	[ ColorValue green ] 					ifFalse:	[ ColorValue red ] )</body><body package="DST_Sample">setIndicator: aSymbol toColor: aColorValue	"Sets an indicator light to the specified color value."	| light look |		light := self builder componentAt: aSymbol.	look := light lookPreferences copy.	look setBackgroundColor: aColorValue.	light lookPreferences: look.</body><body package="DST_Sample">supplierNeedsEvent	"In order to have the correct behavior, this method must block until	an event becomes available and return the event data. The event	generator will signal semaphore after it pushes an event to the 	supplier."	lock		critical:	[	semaphore initSignals.					semaphore wait				]</body></methods><methods><class-id>DST.DemoEventChannelInterface</class-id> <category>initialize-release</category><body package="DST_Sample">initialize	super initialize.	self interfaceId value: self class nextInterfaceId.	eventList := SelectionInList new.	loopOn := false.	semaphore := Semaphore new.	lock := Semaphore new.	random := Random new.	maxPeriod := 9000</body><body package="DST_Sample">release	super release.	[	( self pushSupplier notNil )			ifTrue:	[ self pushSupplier disconnectPushSupplier ].		( self pushConsumer notNil ) 			ifTrue:	[ self pushConsumer disconnectPushConsumer ].		( self pullSupplier notNil )			ifTrue:	[ self pullSupplier disconnectPullSupplier ].		( self pullConsumer notNil )			ifTrue: [ self pullConsumer disconnectPullConsumer ]		]	on: ORBObject invObjrefSignal			do:	[ :ex | ]</body></methods><methods><class-id>DST.DemoEventChannelInterface</class-id> <category>interests</category><body package="DST_Sample">changedChannel	( self channelHolder value == nil )		ifTrue: [ self clearRegistrations ].	self refreshChannelState.</body><body package="DST_Sample">changedChannelDescription	self channelHolder value: nil</body><body package="DST_Sample">clearRegistrations	"Forces the cleanup of suppliers and consumers on a dead channel."	pullSupplier := pullConsumer := pushSupplier := pushConsumer := nil</body><body package="DST_Sample">expressInterests	self channelHolder		onChangeSend: #changedChannel		to: self.</body><body package="DST_Sample">retractInterests	self channelHolder retractInterestsFor: self</body></methods><methods><class-id>DST.DemoEventChannelInterface</class-id> <category>display states</category><body package="DST_Sample">refreshChannelState	[	( self channelHolder value == nil )			ifTrue: 	[ self setNoChannelState ]			ifFalse:	[ self setChannelState ].		self setRegistrationState.		self setRegistrationIndicators.		self setCommandState	]	on: ORBObject invObjrefSignal		do:	[ :ex | ]</body><body package="DST_Sample">setChannelIndicators	| cha ex |	ex := ( ( cha := self channelHolder value ) ~= nil ).	self setIndicator: #channelExists toBooleanState: ex.	self 		setIndicator: #isPushSupplier 		toBooleanState: ( ex and: [ cha hasPushSuppliers ] ).	self 		setIndicator: #isPushConsumer 		toBooleanState: ( ex and: [ cha hasPushConsumers ] ).	self 		setIndicator: #isPullSupplier 		toBooleanState: ( ex and: [ cha hasPullSuppliers ] ).	self 		setIndicator: #isPullConsumer 		toBooleanState: ( ex and: [ cha hasPullConsumers ] ).</body><body package="DST_Sample">setChannelState	self setChannelIndicators.	self channelHostName value: ( channelHolder value hostname ).	self channelPortNumber value: ( channelHolder value port ).	( self builder componentAt: #channelNumber ) widget controller readOnly: true.	( self builder componentAt: #channelHostName ) widget controller readOnly: true.	( self builder componentAt: #channelPortNumber ) widget controller readOnly: true.	( self builder componentAt: #createChannel ) disable.	( self builder componentAt: #destroyChannel ) enable.</body><body package="DST_Sample">setCommandState	| pshS pllS pllC lo |	pshS := self pushSupplier isNil not.	pllS := self pullSupplier isNil not.	pllC := self pullConsumer isNil not.	lo := self loopOn not.	( self builder componentAt: #pushEvent ) isEnabled: ( pshS &amp; lo ).	( self builder componentAt: #pushLoop ) isEnabled: ( pshS &amp; lo ).	( self builder componentAt: #pullEvent ) isEnabled: ( pllS &amp; lo ).	( self builder componentAt: #pull ) isEnabled: ( pllC &amp; lo ).	( self builder componentAt: #tryPull ) isEnabled: ( pllC &amp; lo ).	( self builder componentAt: #pullLoop ) isEnabled: ( pllC &amp; lo ).	( self builder componentAt: #tryPullLoop ) isEnabled: ( pllC &amp; lo ).	( self builder componentAt: #killLoop ) isEnabled: ( ( pllC | pshS ) &amp; ( lo not ) ).</body><body package="DST_Sample">setNoChannelState	self setChannelIndicators.	self channelHostName value: ORBObject hostIdString.	self channelPortNumber value: ( ORBDaemon installedDaemonFor: #IIOPDaemon ) configuredPortNo.	( self builder componentAt: #channelNumber ) widget controller readOnly: false.	( self builder componentAt: #channelHostName ) widget controller readOnly: false.	( self builder componentAt: #channelPortNumber ) widget controller readOnly: false.	( self builder componentAt: #createChannel ) enable.	( self builder componentAt: #destroyChannel ) disable.</body><body package="DST_Sample">setRegistrationIndicators	| ex |	ex := ( self channelHolder value ~= nil ).	self 		setIndicator: #hasPushSupplier 		toBooleanState: ( ex and: [ self pushSupplier notNil ] ).	self 		setIndicator: #hasPushConsumer 		toBooleanState: ( ex and: [ self pushConsumer notNil ] ).	self 		setIndicator: #hasPullSupplier 		toBooleanState: ( ex and: [ self pullSupplier notNil ] ).	self 		setIndicator: #hasPullConsumer 		toBooleanState: ( ex and: [ self pullConsumer notNil ] ).</body><body package="DST_Sample">setRegistrationState	| ex pshS pshC pllS pllC |	ex := ( self channelHolder value ~= nil ).	pshS := self pushSupplier isNil.	pshC := self pushConsumer isNil.	pllS := self pullSupplier isNil.	pllC := self pullConsumer isNil.	( self builder componentAt: #unregisterAsPushSupplier ) isEnabled: ex &amp; pshS not; isVisible: pshS not.	( self builder componentAt: #registerAsPushSupplier ) isEnabled: ex &amp; pshS; isVisible: pshS.	( self builder componentAt: #unregisterAsPushConsumer ) isEnabled: ex &amp; pshC not; isVisible: pshC not.	( self builder componentAt: #registerAsPushConsumer ) isEnabled: ex &amp; pshC; isVisible: pshC.	( self builder componentAt: #unregisterAsPullSupplier ) isEnabled: ex &amp; pllS not; isVisible: pllS not.	( self builder componentAt: #registerAsPullSupplier ) isEnabled: ex &amp; pllS; isVisible: pllS.	( self builder componentAt: #unregisterAsPullConsumer ) isEnabled: ex &amp; pllC not; isVisible: pllC not.	( self builder componentAt: #registerAsPullConsumer ) isEnabled: ex &amp; pllC; isVisible: pllC.</body></methods><methods><class-id>DST.DemoEventChannelInterface</class-id> <category>accessing</category><body package="DST_Sample">channelName	^( self class channelNamePrefix, self channelNumber value printString ) asDSTName</body><body package="DST_Sample">loopOn	^loopOn</body><body package="DST_Sample">loopOn: aBoolean	loopOn := aBoolean.	self setCommandState</body><body package="DST_Sample">maxPeriod	^maxPeriod</body><body package="DST_Sample">maxPeriod: anInteger	maxPeriod := anInteger</body><body package="DST_Sample">pullConsumer	^pullConsumer</body><body package="DST_Sample">pullConsumer: aValue	pullConsumer := aValue</body><body package="DST_Sample">pullSupplier	^pullSupplier</body><body package="DST_Sample">pullSupplier: aValue	pullSupplier := aValue</body><body package="DST_Sample">pushConsumer	^pushConsumer</body><body package="DST_Sample">pushConsumer: aValue	pushConsumer := aValue</body><body package="DST_Sample">pushSupplier	^pushSupplier</body><body package="DST_Sample">pushSupplier: aValue	pushSupplier := aValue</body><body package="DST_Sample">random	^random</body><body package="DST_Sample">random: aRandom	random := aRandom</body></methods><methods><class-id>DST.DemoEventChannelInterface</class-id> <category>events</category><body package="DST_Sample">fabricateEvent	| en note |	en := self class nextEventId printString.	note := 'Created Event #', en, '.'.	self eventList list add: note.	self eventList selection: note.	( self builder componentAt: #eventList ) repairDamage.	^	'Event #',		en,		' from interface ',		self interfaceId value,		'.'</body><body package="DST_Sample">fabricateNonEvent	^	'Null pull #',		self class nextTryId printString,		'.'</body><body package="DST_Sample">incomingEvent: anEvent	self eventList list add: anEvent.	self eventList selection: anEvent.	( self builder componentAt: #eventList ) repairDamage</body></methods><methods><class-id>DST.DemoEventChannelInterface</class-id> <category>aspects</category><body package="DST_Sample">channelHolder	^( channelHolder isNil )		ifTrue:	[ channelHolder := nil asValue ]		ifFalse:	[ channelHolder ]</body><body package="DST_Sample">channelHostName	^( channelHostName isNil )		ifTrue:	[ channelHostName := String new asValue ]		ifFalse:	[ channelHostName ]</body><body package="DST_Sample">channelNumber	^( channelNumber isNil )		ifTrue:	[ channelNumber := Integer zero asValue ]		ifFalse:	[ channelNumber ]</body><body package="DST_Sample">channelPortNumber	^( channelPortNumber isNil )		ifTrue:	[ channelPortNumber := Integer zero asValue ]		ifFalse:	[ channelPortNumber ]</body><body package="DST_Sample">eventList	^eventList</body><body package="DST_Sample">interfaceId	^( interfaceId isNil )		ifTrue:	[ interfaceId := String new asValue ]		ifFalse:	[ interfaceId ]</body></methods><methods><class-id>DST.DemoEventChannelInterface</class-id> <category>interface</category><body package="DST_Sample">initializeDisplayState	self changedChannel</body><body package="DST_Sample">noticeOfWindowClose: aWindow	self release</body><body package="DST_Sample">openInterface: aSymbol	"Ensure that the ORB is on, and other requisite 	startup conditions are fulfilled before opening."	^( self class startupConditionsFulfilled )		ifTrue: [	self obtainChannelReference. 				super openInterface: aSymbol ]</body><body package="DST_Sample">postBuildWith: aBuilder	"Before opening, initialize the display state"	super postBuildWith: aBuilder.	self expressInterests.	self initializeDisplayState</body></methods><methods><class-id>DST.DemoEventChannelInterface</class-id> <category>references</category><body package="DST_Sample">obtainChannelReference	self channelHolder value:		( ( SignalCollection			with: DSTNameContext cannotProceedSignal			with: DSTNameContext notFoundSignal			with: DSTNameContext invalidNameSignal )				handle: [ :ex | nil ]				do: [ ORBObject namingService contextResolve: self channelName ] ).</body></methods><methods><class-id>DST.DemoEventChannelInterface</class-id> <category>validation</category><body package="DST_Sample">checkChannelHostName	| boo |	( boo := ( self channelHostName value ~= String new ) )		ifFalse:	[ Dialog warn: self class missingHostNameWarning ].	^boo</body><body package="DST_Sample">checkChannelPortNumber	| boo |	( boo := ( self channelPortNumber value ~= Integer zero ) )		ifFalse:	[ Dialog warn: self class missingPortNumberWarning ].	^boo</body></methods><methods><class-id>DST.DemoEventChannelInterface</class-id> <category>channel</category><body package="DST_Sample">removeConsumer: aConsumer	( self pushConsumer == aConsumer ) 		ifTrue:	[ self pushConsumer: nil ].	( self pullConsumer == aConsumer ) 		ifTrue:	[ self pullConsumer: nil ].</body><body package="DST_Sample">removeSupplier: aSupplier	( self pushSupplier == aSupplier ) 		ifTrue:	[ self pushSupplier: nil ].	( self pullSupplier == aSupplier ) 		ifTrue:	[ self pullSupplier: nil ].</body></methods><methods><class-id>DST.DemoEventChannelInterface class</class-id> <category>accessing</category><body package="DST_Sample">channelClassName	^ChannelClassName</body><body package="DST_Sample">channelNamePrefix	^ChannelNamePrefix</body><body package="DST_Sample">eventId	^eventId</body><body package="DST_Sample">eventId: anInteger	eventId := anInteger</body><body package="DST_Sample">interfaceId	^interfaceId</body><body package="DST_Sample">interfaceId: anArray	interfaceId := anArray</body><body package="DST_Sample">nextEventId	| id |	id := self eventId.	self eventId: id + 1.	^id</body><body package="DST_Sample">nextInterfaceId	"Cycles interface Ids from 'AAA' through 'ZZZ'."	| x a b c |	x := self interfaceId.	a := x at: 1.	b := x at: 2.	c := x at: 3.	( c == 90 )		ifFalse:	[ c := c + 1 ]		ifTrue:	[ c := 65.				  ( b == 90 )					ifFalse:	[ b := b + 1 ]					ifTrue:	[ b := 65.							  ( a == 90 )								ifFalse:	[ a := a + 1 ]								ifTrue:	[ a := 65 ] ] ].	self interfaceId: ( Array with: a with: b with: c ).	^String withAll: ( self interfaceId collect: [ :z | z asCharacter ] )</body><body package="DST_Sample">nextTryId	| id |	id := self tryId.	self tryId: id + 1.	^id</body><body package="DST_Sample">tryId	^tryId</body><body package="DST_Sample">tryId: anInteger	tryId := anInteger</body></methods><methods><class-id>DST.DemoEventChannelInterface class</class-id> <category>warnings</category><body package="DST_Sample">missingHostNameWarning	^(	'In the ''host'' input field, you must enter either a valid DNS name or an\',		'IP address in canonical form, to specify where the event channel is\',		'to be created.'	) withCRs</body><body package="DST_Sample">missingPortNumberWarning	^(	'In the ''port'' input field, you must enter either a valid port number to\',		'specify where the event channel is to be created.'	) withCRs</body><body package="DST_Sample">namingServiceNonExistentWarning	^(	'You must install the Naming Service\',		'to use the DemoEventChannellnterface.'	) withCRs</body><body package="DST_Sample">orbOffWarning	^(	'You must start up the ORB before using\',		'the DemoEventChannelInterface.'	) withCRs</body></methods><methods><class-id>DST.DemoEventChannelInterface class</class-id> <category>opening conditions</category><body package="DST_Sample">namingServiceExists	"Check whether the Naming Service is available.  If not, open 	a warning dialog and answer false.  Otherwise answer true."	| namingServiceExists |	( namingServiceExists := ORBObject listInitialServices includes: #NameService )		ifFalse:	[ Dialog warn: self namingServiceNonExistentWarning ].	^namingServiceExists</body><body package="DST_Sample">orbOn	"Check whether the ORB is started.  If not, open a warning 	dialog and answer false.  Otherwise answer true."	| orbOn |	( orbOn := ( ORBObject hostId notNil and: [ ORBDaemon running ] ) )		ifFalse:	[ Dialog warn: self orbOffWarning ].	^orbOn</body></methods><methods><class-id>DST.DemoEventChannelInterface class</class-id> <category>class initialization</category><body package="DST_Sample">initialize	" DemoEventChannelInterface initialize. "	ChannelClassName := 'DemoEventChannel' asDSTName.	ChannelNamePrefix := 'DemoEventChannel'.	eventId := 0.	interfaceId := #( 65 65 65 ).	tryId := 0.</body></methods><methods><class-id>DST.DemoEventChannelInterface class</class-id> <category>interface opening</category><body package="DST_Sample">startupConditionsFulfilled	"These are the default, minimal operational 	requirements of BroadcastChannelInterface."	^( self orbOn and: 		[ self namingServiceExists ] )</body></methods><methods><class-id>DST.DSTSampleComputeService</class-id> <category>repository</category><body package="DST_Sample">CORBAName0	"Answer the name of the receiver's CORBA interface in the IDL repository."	"Completion of the exercise in the DST ADG will result in a method like this one."	^#'::DSTSampleComputeService::DSTSampleComputeServiceInterface'</body><body package="DST_Sample">abstractClassId0	"Answer the abstract class id of the receiver."	"Completion of the exercise in the DST ADG will result in a method like this one."	^'c815c088-4901-0000-02d8-2421ae000000' asUUID</body></methods><methods><class-id>DST.DSTSampleComputeService</class-id> <category>computing - fibonacci numbers</category><body package="DST_Sample">nthCalculativeFibonacciNumber: aPositiveInteger	"... *usually* answers the nth Fibonacci number."	"... is sometimes one off."	"... trades on the relationship between the Fibonacci numbers and the golden ratio."	"... overflows the range of a Double with fairly small values of aPositiveInteger, that is, any over 604."	| f n |	f := 5 sqrt asDouble.	n := aPositiveInteger asDouble.	^( ( ( ( 1.0 asDouble + f ) ** n ) - ( ( 1.0 asDouble - f ) ** n ) )				/ ( ( 2.0 asDouble ** n ) * f ) ) rounded</body><body package="DST_Sample">nthIterativeFibonacciNumber: aPositiveInteger	"... answers the nth Fibonacci number, at comparatively small expense."	| n fa fb fc |	n := aPositiveInteger.	fa := 1.	fb := 0.	fc := 0.	[ n == 0 ]		whileFalse:			[	fc := fa + fb.				fb := fa.				fa := fc.				n := n - 1.			].	^fb</body><body package="DST_Sample">nthRecursiveFibonacciNumber: aPositiveInteger	"... answers the nth Fibonacci number."	"... begins to exceed remote request timeout limits with values of an Integer &gt; 30."	"... begins to take a very, very long time -- sure to exceed the message timeout limit -- with values of aPositiveInteger &gt; 40."		^( ( aPositiveInteger == 0 ) or: [ aPositiveInteger == 1 ] )			ifTrue:	[ aPositiveInteger ]			ifFalse:	[ ( self nthRecursiveFibonacciNumber: ( aPositiveInteger - 1 ) ) + 						( self nthRecursiveFibonacciNumber: ( aPositiveInteger - 2 ) ) ]</body></methods><methods><class-id>DST.DSTSampleComputeService</class-id> <category>initialize-release</category><body package="DST_Sample">initialize	random := MinimumStandardRandom new.	computeServers := OrderedCollection with: self.	self registerInstance</body><body package="DST_Sample">registerInstance	"Register instance with lifecycle service."	DSTObjRef registerObject: self</body><body package="DST_Sample">release	self unregisterInstance.	super release</body><body package="DST_Sample">unregisterInstance	"Remove the reference to self from the lifecycle service."	DSTObjRef unRegisterObject: self</body></methods><methods><class-id>DST.DSTSampleComputeService</class-id> <category>computing - primality tests</category><body package="DST_Sample">divisorFor: aPositiveInteger1 between: aPositiveInteger2 and: aPositiveInteger3	"... a toy utility for spreading the search for divisors over several computation servers."	aPositiveInteger2 to: aPositiveInteger3 do: 		[ :d |  ( 0 == ( aPositiveInteger1 \\ d  ) ) 			ifTrue: [ ^d ] ].	^nil</body><body package="DST_Sample">exhaustivePrime: aPositiveInteger	"... the expensive primality test."	( aPositiveInteger &lt; 2 )		 ifTrue: [ ^false ].	2 to: ( aPositiveInteger sqrt rounded ) do: 		[ :d |  ( 0 == ( aPositiveInteger \\ d  ) ) 			ifTrue: [ ^false ] ].	^true</body><body package="DST_Sample">fermatPrime: aPositiveInteger	"Do not invoke this method to test for primality using the Fermat test.  Use 'fermatPrime:withTrials:'."	| testNumber expmod |	testNumber := self randomIntegerLessThan: aPositiveInteger.	expmod := self 				base: testNumber				exponent: aPositiveInteger 				modulo: aPositiveInteger.	^testNumber = expmod</body><body package="DST_Sample">fermatPrime: aPositiveInteger1 withTrials: aPositiveInteger2	"Increasing the number of trials increases the reliability of the Fermat test for primality.  One pass gives better than 50% odds that the number tested is prime; two passes gives better than 75% odds; and so on."	"((( DSTSampleComputeService new fermatPrime: 101 withTrials: 11 )))"		| number trials |	( aPositiveInteger1 == 1 )		ifTrue:	[ ^false ].	number := aPositiveInteger1.	trials := aPositiveInteger2.	( trials == 0 )		ifTrue:	[ ^true ].	^( self fermatPrime: number )		ifTrue:	[ self fermatPrime: number withTrials: ( trials - 1 ) ]		ifFalse:	[ false ]</body><body package="DST_Sample">nthExhaustivePrime: aPositiveInteger	"Answers the nth prime number."	| s n p |		s := n := p := 0.	[ n == aPositiveInteger ]		whileFalse:			[	s := s + 1.				( self exhaustivePrime: s )					ifTrue:	[	n := n + 1.								p := s.							]			].	^p</body><body package="DST_Sample">nthFermatPrime: aPositiveInteger	"... correctly answers the nth prime number, until it reaches the first Carmichael number."	"... some non-primes, know as Carmichael numbers, fool the Fermat test."	| s n p |	s := n := p := 0.	[ n == aPositiveInteger ]		whileFalse:			[	s := s + 1.				( self fermatPrime: s withTrials: 11 )					ifTrue:	[	n := n + 1.								p := s.							]			].	^p</body></methods><methods><class-id>DST.DSTSampleComputeService</class-id> <category>utility</category><body package="DST_Sample">base: base exponent: exponent modulo:modulo	| t |		( exponent == 0 )		ifTrue:	[ ^1 ].	^( exponent even )		ifTrue:	[	t := self base: base exponent: ( exponent / 2 ) modulo: modulo.					( t * t ) \\ modulo				]		ifFalse:	[	t := self base: base exponent: ( exponent - 1 ) modulo: modulo.					( base * t ) \\ modulo				]</body><body package="DST_Sample">randomIntegerLessThan: aPositiveInteger	^( self random next * aPositiveInteger ) truncated</body></methods><methods><class-id>DST.DSTSampleComputeService</class-id> <category>computing - carmichael numbers</category><body package="DST_Sample">carmichaelNumber: aPositiveInteger	"Carmichael numbers are non-primes that fool the Fermat test."	^( self fermatPrime: aPositiveInteger withTrials: 11 )		and: [ ( self exhaustivePrime: aPositiveInteger ) not ]</body><body package="DST_Sample">nthCarmichaelNumber: aPositiveInteger	"Answers the nth Carmichael number."	"((( DSTSampleComputeService new nthCarmichaelNumber: 5 )))"	| s n p |		s := n := p := 0.	[ n == aPositiveInteger ]		whileFalse:			[	s := s + 1.				( self carmichaelNumber: s )					ifTrue:	[	n := n + 1.								p := s.							]			].	^p</body></methods><methods><class-id>DST.DSTSampleComputeService</class-id> <category>accessing</category><body package="DST_Sample">random	^random</body></methods><methods><class-id>DST.DSTSampleComputeService</class-id> <category>computing - documentation</category><body package="DST_Sample">slowComputationWith: aPositiveInteger1 and: aPositiveInteger2 	"... finds the first Carmichael number detected between the two positive integers supplied as arguments.  Carmichael numbers are non-primes that deceive the Fermat test for primality.  The IDL for this function places some limitations on its remote invocation.  Any argument over (2^32)-1 will exceed the range of an unsigned long, and any returned result over (2^64)-1 will exceed the range of an unsigned long long.  Futhermore, when invoking this or any other potentially long-running method remotely, care must be taken either not to exceed the IIOP message and receive timeouts, or to adjust those timeouts, now set to 5 minutes and 10 minutes respectively.  Also note that the implementation returns 0 if no Carmichael number is found in the specified range.  If you wished the return value to be a 'nil' in that case, in the IDL you would have to specify the return type using the UnssgnedLongLongOrNil union shown in 'DSTRepository&gt;&gt;DSTSampleComputeService'.  All of the examples below should have a running time well below the timeouts.  The last example below has a running time about ten times greater than the first."	"(((	| s |		s := ORBObject namingService contextResolve: DSTSampleComputeService serviceName.		s slowComputationWith: 5100000 and: 5200000.		s slowComputationWith: 4770000 and: 4910000.		s slowComputationWith: 3830000 and: 4340000."	aPositiveInteger1 to: aPositiveInteger2 do:		[ :n | ( self carmichaelNumber: n ) ifTrue: [ ^n ] ].	^0</body></methods><methods><class-id>DST.DSTSampleComputeService class</class-id> <category>naming</category><body package="DST_Sample">createDefaultService	"Return the service.  If no instance exists, create one and, register it with 	the naming service."	"DSTSampleComputeService createDefaultService"	DefaultService isNil		ifTrue:	[	DefaultService := DSTSampleComputeService new.					ORBObject namingService contextBind: self serviceName to: DefaultService				].	^DefaultService</body><body package="DST_Sample">destroyDefaultService	"Remove the singleton instance of the service from the class variable, 	the naming service, and the lifecycle service."	"DSTSampleComputeService destroyDefaultService"	( DefaultService isNil )		ifFalse:	[	DefaultService release.					DefaultService := nil.					ORBObject namingService contextUnBind: self serviceName.				]</body><body package="DST_Sample">serviceName	^DSTName onString: 'DSTSampleComputeService'.</body></methods><methods><class-id>DST.DSTSampleComputeService class</class-id> <category>instance creation</category><body package="DST_Sample">new	^super new initialize</body></methods><methods><class-id>DST.DemoEventChannelInterface class</class-id> <category>interface specs</category><body package="DST_Sample">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Demo Event Channel Interface' 			#min: #(#{Core.Point} 426 560 ) 			#max: #(#{Core.Point} 426 560 ) 			#bounds: #(#{Graphics.Rectangle} 512 208 938 768 ) 			#isEventDriven: true ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 163 257 405 278 ) 					#name: #unregisterAsPullConsumer 					#flags: 40 					#isOpaque: true 					#model: #unregisterAsPullConsumer 					#label: 'unregister as pull consumer' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 163 173 405 194 ) 					#name: #unregisterAsPushSupplier 					#flags: 40 					#isOpaque: true 					#model: #unregisterAsPushSupplier 					#label: 'unregister as push supplier' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 163 201 405 222 ) 					#name: #unregisterAsPushConsumer 					#flags: 40 					#isOpaque: true 					#model: #unregisterAsPushConsumer 					#label: 'unregister as push consumer' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 163 229 405 250 ) 					#name: #unregisterAsPullSupplier 					#flags: 40 					#isOpaque: true 					#model: #unregisterAsPullSupplier 					#label: 'unregister as pull supplier' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 163 229 405 250 ) 					#name: #registerAsPullSupplier 					#flags: 40 					#isOpaque: true 					#model: #registerAsPullSupplier 					#label: ' register as pull supplier' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 163 201 405 222 ) 					#name: #registerAsPushConsumer 					#flags: 40 					#isOpaque: true 					#model: #registerAsPushConsumer 					#label: 'register as push consumer' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 163 257 405 278 ) 					#name: #registerAsPullConsumer 					#flags: 40 					#isOpaque: true 					#model: #registerAsPullConsumer 					#label: 'register as pull consumer' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 163 173 405 194 ) 					#name: #registerAsPushSupplier 					#flags: 40 					#isOpaque: true 					#model: #registerAsPushSupplier 					#label: 'register as push supplier' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 210 94 405 115 ) 					#name: #destroyChannel 					#isOpaque: true 					#model: #destroyChannel 					#label: 'destroy demo event channel' ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.Rectangle} 9 6 416 150 ) 					#name: #channelGroupBox 					#label: 'Demo Event Channel' 					#style: #DSTdefault ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 157 34 ) 					#name: #channelHostLabel 					#label: 'on host' 					#style: #DSTdefault ) 				#(#{UI.RegionSpec} 					#layout: #(#{Graphics.Rectangle} 141 40 156 55 ) 					#name: #channelExists 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #red ) ) 					#lineWidth: 1 					#regionType: #ellipse ) 				#(#{UI.RegionSpec} 					#layout: #(#{Graphics.Rectangle} 141 61 156 76 ) 					#name: #isPushSupplier 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #red ) ) 					#lineWidth: 1 					#regionType: #ellipse ) 				#(#{UI.RegionSpec} 					#layout: #(#{Graphics.Rectangle} 141 82 156 97 ) 					#name: #isPushConsumer 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #red ) ) 					#lineWidth: 1 					#regionType: #ellipse ) 				#(#{UI.RegionSpec} 					#layout: #(#{Graphics.Rectangle} 141 103 156 118 ) 					#name: #isPullSupplier 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #red ) ) 					#lineWidth: 1 					#regionType: #ellipse ) 				#(#{UI.RegionSpec} 					#layout: #(#{Graphics.Rectangle} 141 124 156 139 ) 					#name: #isPullConsumer 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #red ) ) 					#lineWidth: 1 					#regionType: #ellipse ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 210 66 405 87 ) 					#name: #createChannel 					#isOpaque: true 					#model: #createChannel 					#label: 'create demo event channel' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 210 30 315 55 ) 					#name: #channelHostName 					#model: #channelHostName 					#alignment: #center 					#style: #DSTdefault 					#isReadOnly: false ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 210 122 405 143 ) 					#name: #refreshInterfaceState 					#model: #obtainChannelReference 					#label: '(re)acquire channel reference' ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.Rectangle} 9 152 415 285 ) 					#name: #registrationGroupBox 					#label: 'Demo Event Channel Interface' 					#style: #DSTdefault ) 				#(#{UI.RegionSpec} 					#layout: #(#{Graphics.Rectangle} 141 175 156 190 ) 					#name: #hasPushSupplier 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #red ) ) 					#lineWidth: 1 					#regionType: #ellipse ) 				#(#{UI.RegionSpec} 					#layout: #(#{Graphics.Rectangle} 141 259 156 274 ) 					#name: #hasPullConsumer 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #red ) ) 					#lineWidth: 1 					#regionType: #ellipse ) 				#(#{UI.RegionSpec} 					#layout: #(#{Graphics.Rectangle} 141 231 156 246 ) 					#name: #hasPullSupplier 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #red ) ) 					#lineWidth: 1 					#regionType: #ellipse ) 				#(#{UI.RegionSpec} 					#layout: #(#{Graphics.Rectangle} 141 203 156 218 ) 					#name: #hasPushConsumer 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #red ) ) 					#lineWidth: 1 					#regionType: #ellipse ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 16 173 58 194 ) 					#name: #interfaceId 					#flags: 0 					#model: #interfaceId 					#tabable: false 					#isReadOnly: true ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.Rectangle} 9 293 415 550 ) 					#label: 'Event List' 					#style: #DSTdefault ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.Rectangle} 19 315 317 510 ) 					#name: #eventList 					#model: #eventList 					#style: #DSTdefault 					#selectionType: #highlight ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 18 515 405 541 ) 					#name: #clearEventList 					#model: #clearEventList 					#label: 'clear event list' 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 325 34 ) 					#name: #channlePortLabel 					#label: 'port' 					#style: #DSTdefault ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 355 30 405 55 ) 					#name: #channelPortNumber 					#model: #channelPortNumber 					#type: #number ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 325 365 405 386 ) 					#name: #pullEvent 					#flags: 40 					#model: #pullEvent 					#label: 'pullEvent' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 325 390 405 411 ) 					#name: #pull 					#flags: 40 					#model: #pull 					#label: 'pull' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 325 315 405 336 ) 					#name: #pushEvent 					#flags: 40 					#model: #pushEvent 					#label: 'pushEvent' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 325 415 405 436 ) 					#name: #tryPull 					#flags: 40 					#model: #tryPull 					#label: 'tryPull:' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 325 465 405 486 ) 					#name: #tryPullLoop 					#flags: 40 					#model: #tryPullLoop 					#label: 'tryPull: loop' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 325 440 405 461 ) 					#name: #pullLoop 					#flags: 40 					#model: #pullLoop 					#label: 'pull loop' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 325 490 405 511 ) 					#name: #killLoop 					#flags: 40 					#model: #killLoop 					#label: 'kill loop' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 93 34 ) 					#name: #existsLabel 					#label: 'exists' 					#style: #DSTdefault ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 37 55 ) 					#name: #isPushSupplierLabel 					#label: 'is push supplier' 					#style: #DSTdefault ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 43 98 ) 					#name: #isPullSupplierLabel 					#label: 'is pull supplier' 					#style: #DSTdefault ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 26 77 ) 					#name: #isPushConsumerLabel 					#label: 'is push consumer' 					#style: #DSTdefault ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 32 119 ) 					#name: #isPullConsumerLabel 					#label: 'is pull consumer' 					#style: #DSTdefault ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 65 30 90 55 ) 					#name: #channelNumber 					#model: #channelNumber 					#type: #number ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 13 34 ) 					#name: #channelLabel 					#label: 'channel' 					#style: #DSTdefault ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 325 340 405 361 ) 					#name: #pushLoop 					#flags: 40 					#model: #pushLoop 					#label: 'push loop' ) ) ) )</body></methods><initialize><class-id>DST.DemoEventChannelInterface</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>DSTMessageInterceptor</name><environment>DST</environment><super>DST.DSTInterceptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Interceptors</category><attributes><package>DST_Core</package></attributes></class><class><name>DSTRequestInterceptor</name><environment>DST</environment><super>DST.DSTInterceptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Interceptors</category><attributes><package>DST_Core</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>DSTEventChannel</name><environment>DST</environment><super>DST.DSTPersistentObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pushSuppliers pullSuppliers pushConsumers pullConsumers exportedProxies </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COS-Events</category><attributes><package>DST_COS_Services</package></attributes></class></st-source>