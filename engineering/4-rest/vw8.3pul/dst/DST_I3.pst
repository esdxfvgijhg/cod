<?xml version="1.0"?><st-source><!-- Name: DST_I3Notice: Copyright 1999-2013 Cincom Systems, Inc.  All rights reserved.Comment: DST_I3 contains the Implicit Interface Invocation mechanism for DST, which provides Smalltalk-to-Smalltalk connectivity without the need to write IDL.Copyright: Copyright © 1999-2001 Cincom Systems, Inc.All Rights ReservedThis product contains copyrighted third-party software.Copyright © 1993-1995 Hewlett-Packard Company.All Rights ReservedDbIdentifier: bear73DbTrace: 464622DbUsername: tkoganDbVersion: 8.1 - 1DevelopmentPrerequisites: #(#(#any 'DST_Core' '') #(#any 'BOSS' ''))Namespace: Smalltalk.DSTPackageName: DST_I3Parcel: #('DST_I3')ParcelName: DST_I3PrerequisiteDescriptions: #(#(#name 'DST_Core') #(#name 'BOSS' #componentType #package))PrerequisiteParcels: #(#('DST_Core' '') #('BOSS' ''))PrintStringCache: (8.1 - 1,tkogan)Version: 8.1 - 1Date: 1:09:21 PM January 29, 2016 --><time-stamp>From VisualWorks®, Pre-Release 8.2 (jan16.4) of January 29, 2016 on January 29, 2016 at 1:09:21 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>DSTI3RemoteReader</name><environment>DST</environment><super>Kernel.BOSSReader</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>DST-I3</category><attributes><package>DST_I3</package></attributes></class><comment><class-id>DST.DSTI3RemoteReader</class-id><body>I read and unpackage objects from a stream that were written by some remote image</body></comment><class><name>DSTModuleI3</name><environment>DST</environment><super>DST.DSTModuleI3Null</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>DST-Modules</category><attributes><package>DST_I3</package></attributes></class><class><name>DSTI3Operation</name><environment>DST</environment><super>DST.DSToperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>DST-I3</category><attributes><package>DST_I3</package></attributes></class><comment><class-id>DST.DSTI3Operation</class-id><body>I'm a generic smalltalk operation which will marshall/unmarshall any message arguments to/from a given CDR stream by using a remoteStream on top of the CDR stream.I will be used in place of a DSToperation for bypassing IDL interface.</body></comment><class><name>DSTI3ObjRef</name><environment>DST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>object </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>DST-I3</category><attributes><package>DST_I3</package></attributes></class><comment><class-id>DST.DSTI3ObjRef</class-id><body>I am a wraper for passing out a object reference to a remote site. I'm not a proxy whichdoes the message forwarding.  I knows how to marshall an local object on the wire so that at the remote site it can be structured into a DSTObjRef.   I am being used whenever a local object is pass by reference in remoteWriter.Instance Variables:	object	&lt;Object&gt; the local object to be marshalled as a remote object reference.Shared Class Variables:	TransferModeDictionary	&lt;WeakKeyDictionary&gt; transferModes for individual objects.	TransferModesClass	&lt;Class&gt; the dictionary class used for the TransferModeDictionary</body></comment><class><name>DSTI3RemoteWriter</name><environment>DST</environment><super>Kernel.BOSSWriter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>DST-I3</category><attributes><package>DST_I3</package></attributes></class><comment><class-id>DST.DSTI3RemoteWriter</class-id><body>I package objects and write them on a stream to be read on some remote image. If an object is passedByValue I package it just like my superclass. If not I package a proxy (DSTI3ObjRef) for it. When tracing an object, I first ask it the passing modes for all its instances (see Object&gt;&gt;passInstVars) and tracing the object accordingly. Other than my superclass, I do not package dependents.</body></comment><class><name>DSTI3OperationInfo</name><environment>DST</environment><super>DST.DSToperationInfo</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>DST-I3</category><attributes><package>DST_I3</package></attributes></class><comment><class-id>DST.DSTI3OperationInfo</class-id><body>I'm a generic operation info  for the generic DSTI3OperationI will be used in place of a DSToperationInfo for bypassing IDL interface.</body></comment><class><name>DSTI3RemoteStream</name><environment>DST</environment><super>Kernel.BinaryObjectStorage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>predefinedObjects </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>DST-I3</category><attributes><package>DST_I3</package></attributes></class><comment><class-id>DST.DSTI3RemoteStream</class-id><body>I am a BinaryObjectStream suitable to exchange objects between multiple images.Instance Variables:	predefinedObjects  &lt;OrderedCollection&gt; of predefined well known objects like: nil, true, fase.	</body></comment><shared-variable><name>TransferModeDictionary</name><environment>DST.DSTI3ObjRef</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_I3</package></attributes></shared-variable><shared-variable><name>TransferModesClass</name><environment>DST.DSTI3ObjRef</environment><private>false</private><constant>false</constant><category>As yet unclassified </category><initializer>DST.WeakKeyDictionary</initializer><attributes><package>DST_I3</package></attributes></shared-variable><shared-variable><name>BufferingLevel</name><environment>DST.DSTI3RemoteStream</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_I3</package></attributes></shared-variable><methods><class-id>DST.DSTI3RemoteReader</class-id> <category>private-reading</category><body package="DST_I3">importSelectorAt: class with: inst	| answer sel |	answer := super importSelectorAt: class with: inst.	sel := AbstractBinaryObjectStorage importSelectors at: class.	(sel == #importByteSymbol: or: [sel == #importClass:])		ifTrue: [storage addPredefinedObject: answer].	^answer</body><body package="DST_I3">potentiallyDeferImmutabilityChangeOf: inst basedOn: flags	^self</body><body package="DST_I3">readBitsClass: classsize: sizeforward: forwardspecial: specialdeferredBodies: deferredBodiesindex: index	| answer |	answer := stream next: size.	forward		ifTrue:			["can only happen if object has dependents"				deferredBodies add: (Array with: index - 1 with: class)			]		ifFalse:			[				special					ifTrue: [answer changeClassToThatOf: '']					ifFalse:						[							self change: answer toInstanceOf: class.							(swapBytes and: [(ByteClasses at: class ifAbsent: [nil]) == nil])								ifTrue: [answer reverseByteOrder]						]			].	^answer</body></methods><methods><class-id>DST.DSTModuleI3 class</class-id> <category>class initialization</category><body package="DST_I3">initialize	DSTModules i3Module: self</body><body package="DST_I3">obsolete	"This class is being removed from the system."	DSTModules initializeI3Module.	^super obsolete</body></methods><methods><class-id>DST.DSTModuleI3 class</class-id> <category>testing</category><body package="DST_I3">isLoaded	"Is this module loaded."	^true</body></methods><methods><class-id>DST.DSTModuleI3 class</class-id> <category>accessing</category><body package="DST_I3">newOperationFor: aSymbol	"... return a new operation. If I3 is not not available or not configured, return nil."	^( ORBDaemon configurationManager isI3On )		ifTrue:	[ DSTI3Operation newFor: aSymbol ]		ifFalse:	[ nil ]</body><body package="DST_I3">newOperationInfoForInterface: anInterface selector: aSelector 	"Return a new operation info. If not available or not configured, 	return nil."	^ORBDaemon configurationManager isI3On		ifTrue: [DSTI3OperationInfo newForInterface: anInterface selector: aSelector]		ifFalse: [nil]</body></methods><methods><class-id>DST.DSTI3Operation</class-id> <category>marshalling</category><body package="DST_I3">marshallArguments: argArray on: aStream 	"marshall the arguments onto the stream"	"marshall argArray on a remoteStream and put all contents on aStream"	(DSTI3RemoteStream onNew: aStream) nextPut: argArray.</body><body package="DST_I3">marshallResult: result on: aStream withArgs: argArray 	"marshall the result  onto the stream"	(DSTI3RemoteStream onNew: aStream) nextPut: result.</body><body package="DST_I3">unMarshallArgumentsFrom: aStream 	"unmarshall the arguments from the stream"	^(DSTI3RemoteStream onOldNoScan: aStream) next</body><body package="DST_I3">unMarshallResultsFrom: aPacket withArgs: argArray 	"un-marshall the results from the stream"	^(DSTI3RemoteStream onOldNoScan: aPacket) next</body><body package="DST_I3">unMarshallServiceContextFrom: aStream 	"unmarshall the service context from the stream. This method relies 	on the fact that the active process was newly created and has an 	unset ORB context"	| cxtList orbCxt |	cxtList := (DSTI3RemoteStream onOldNoScan: aStream) next.	cxtList isEmpty		ifFalse: 			[orbCxt := Processor activeProcess orbContext.			cxtList do: [:cxt | orbCxt addServiceContext: cxt]]</body></methods><methods><class-id>DST.DSTI3Operation</class-id> <category>accessing</category><body package="DST_I3">definedIn: aMetaObject 		^self</body><body package="DST_I3">exceptionOf: aSymbol 	^nil</body><body package="DST_I3">findCorbaExceptionFor: anException 	"return the appropriate error so that it can be marshalled on a stream"	| ex param exType |	ex := ORBObject standardExceptions at: #UNKNOWN.	param := Dictionary with: #minor -&gt; 0 with: #completed -&gt; #COMPLETED_MAYBE.	exType := #systemException.	^Array		with: ex		with: param		with: exType</body><body package="DST_I3">isNormal	"return if the receiver has default (normal) invocation 	semantics"	^true</body><body package="DST_I3">isOneWay	"return if the receiver has been specified to have the one-way (asynchronous) attribute"	^false</body><body package="DST_I3">localOp: aSymbol 	aSymbol first == $*		ifTrue: [localOp := (aSymbol copyFrom: 2 to: aSymbol size) asSymbol]		ifFalse: [localOp := aSymbol]</body><body package="DST_I3">name	^name isNil ifTrue:[name := ('*', self localOp) asSymbol] ifFalse:[name]</body><body package="DST_I3">opSelector	"return the operation's selector"	^localOp</body><body package="DST_I3">signature	"Return the signature for the operation. The last parameter is the 	return value."	^localOp</body></methods><methods><class-id>DST.DSTI3Operation</class-id> <category>printing</category><body package="DST_I3">printOn: aStream	"print the receiver's printname on the stream"	aStream nextPutAll: 'operation ' , self localOp asString.</body></methods><methods><class-id>DST.DSTI3Operation class</class-id> <category>instance creation</category><body package="DST_I3">newFor: aSymbol	^super new localOp: aSymbol</body></methods><methods><class-id>DST.DSTI3ObjRef</class-id> <category>accessing</category><body package="DST_I3">isPassedByValue	"I should always passed by value"	^true</body><body package="DST_I3">object: anObject	"We need to register anObject to keep it persistent	before we pass its reference out"	DSTObjRef registerObject: anObject.	object := anObject</body></methods><methods><class-id>DST.DSTI3ObjRef</class-id> <category>binary storage</category><body package="DST_I3">representBinaryOn: binWriter		^MessageSend		receiver: ORBObject		selector: #stringToObject:		argument: (ORBObject objectToString: object)</body></methods><methods><class-id>DST.DSTI3ObjRef class</class-id> <category>accessing</category><body package="DST_I3">transferModeDictionary	^TransferModeDictionary</body><body package="DST_I3">transferModes	^TransferModeDictionary</body></methods><methods><class-id>DST.DSTI3ObjRef class</class-id> <category>instance creation</category><body package="DST_I3">newFor: anObject	^super new object: anObject</body></methods><methods><class-id>DST.DSTI3ObjRef class</class-id> <category>initializing</category><body package="DST_I3">flushTransferModeDictionary	TransferModeDictionary := TransferModesClass new: 10</body><body package="DST_I3">initialize	self flushTransferModeDictionary</body><body package="DST_I3">removing	TransferModeDictionary := nil</body></methods><methods><class-id>DST.DSTI3RemoteWriter</class-id> <category>representation</category><body package="DST_I3">represent: anObject	"This is the representation method for otherwise undistinguished objects.	The default is to ask the object if it is PassByValue, and if so, what representation to use.	If the object is not PassByValue, represent it by a forwarder"	^anObject isPassedByValue		ifTrue: [super represent: anObject]		ifFalse: [super represent: (DSTI3ObjRef newFor: anObject)]</body></methods><methods><class-id>DST.DSTI3RemoteWriter</class-id> <category>private-tracing</category><body package="DST_I3">localTraceThrough: anObject body: body class: aClass	| class flags objx bodyCopy |	bodyCopy := nil.	class := body class.	flags := AbstractBinaryObjectStorage flagHasShortOops.	class isBits ifFalse:		[			1 to: class instSize do:				[:i |					| inst |					inst := body instVarAt: i.					inst isBehavior						ifTrue:							[								inst := DSTI3ObjRef newFor: inst.								bodyCopy isNil ifTrue: [bodyCopy := body shallowCopy].								bodyCopy instVarAt: i put: inst							]						ifFalse:							[								i &lt;= anObject passInstVars size ifTrue:									[										| mode |										mode := anObject passInstVars at: i.										bodyCopy isNil ifTrue: [bodyCopy := body shallowCopy].										inst := mode == #ref											ifTrue: [DSTI3ObjRef newFor: inst]											ifFalse:												[													mode == #value														ifTrue: [inst copy passByValue]														ifFalse:															[																mode 																	ifTrue: [inst]																	ifFalse: [nil]															]												].										bodyCopy instVarAt: i put: inst									]							].					((self trace: inst) bitAnd: self shortOopMask) = 0 ifFalse: [flags := 0]				].			class isVariable ifTrue:				[					1 to: body basicSize do:						[:i |							| inst |							inst := body basicAt: i.							inst isBehavior ifTrue:								[									inst := DSTI3ObjRef newFor: inst.									bodyCopy isNil ifTrue: [bodyCopy := body shallowCopy].									bodyCopy basicAt: i put: inst								].							((self trace: inst) bitAnd: self shortOopMask) = 0 ifFalse: [flags := 0]						]				]		].	objx := self encode: anObject.	objx &lt; 0		ifTrue: [objx := self assign: anObject]		ifFalse: [flags := flags + AbstractBinaryObjectStorage flagHasForwardReferences].	self		record: anObject		body: (bodyCopy ifNil: [body])		class: aClass		flags: flags		index: objx.	^objx</body><body package="DST_I3">trace: anObject body: body class: aClass	" Record anObject in the objects dictionary,	and trace its dependents and body if needed.	The caller has already traced the class. "	| class objx |	class := body class.	class isBits ifTrue:		[			objx := self assign: anObject.			self record: anObject body: body class: aClass flags: 0 index: objx.			^objx		].	" Recursively trace the contents of the body.	If the object has circular references,	the trace may assign the object index. "	anObject == nil ifFalse: [objects at: anObject put: -2].	^self localTraceThrough: anObject body: body class: aClass</body><body package="DST_I3">traceNewOrImmediate: anObject	| selector value |	selector := traceClasses at: anObject class ifAbsent: [#traceUnknown:].	value := selector == #represent:		ifTrue: [self traceRepresent: anObject]		ifFalse: [self perform: selector with: anObject].	value == nil ifTrue:  "use standard representation"		[			self trace: anObject class.			^self trace: anObject body: anObject class: anObject class		].	value isInteger ifTrue: [^value].  "internal method returned objx"	" Trace a generic object with special handling. "	(value isMemberOf: Association) ifTrue:  "special reader index"		[			"Check to make sure that the representation			is minimally compatible with the index. "			| index arg |			index := value key.			arg := value value.			arg class isBits = index odd ifFalse:				[self error: 'Incompatible representation'.  ^nil].			^self trace: anObject body: arg class: index		].	^super		trace: anObject		body: (Array with: value receiver with: value selector) , value arguments		class: AbstractBinaryObjectStorage indexImportSend</body></methods><methods><class-id>DST.DSTI3OperationInfo</class-id> <category>creation</category><body package="DST_I3">interface: aDSTInterface selector: aSymbol	interface := aDSTInterface.	selector :=  aSymbol.	operation := DSTI3Operation newFor: aSymbol.</body><body package="DST_I3">newForInterface: aDSTInterface selector: aSymbol	interface := aDSTInterface.	selector :=  aSymbol.	operation := DSTI3Operation newFor: aSymbol.</body></methods><methods><class-id>DST.DSTI3OperationInfo class</class-id> <category>instance creation</category><body package="DST_I3">newFor: aSymbol	^super new selector: aSymbol</body><body package="DST_I3">newForInterface: aDSTInterface selector: aSymbol	^self new interface: aDSTInterface selector: aSymbol</body></methods><methods><class-id>DST.DSTI3RemoteStream</class-id> <category>writing</category><body package="DST_I3">nextCommit: anObject	self writer nextPut: anObject.	stream commit.	^anObject</body></methods><methods><class-id>DST.DSTI3RemoteStream</class-id> <category>private-writing</category><body package="DST_I3">addPredefinedObject: anObject	self predefinedObjects add: anObject</body><body package="DST_I3">assignIndexFor: anObject	" Assign the next object index, and return it. "	(anObject isBehavior or: [anObject isSymbol])		ifTrue: [self addPredefinedObject: anObject].	^super assignIndexFor: anObject</body></methods><methods><class-id>DST.DSTI3RemoteStream</class-id> <category>private - accessing</category><body package="DST_I3">defaultReaderClass	^DSTI3RemoteReader</body><body package="DST_I3">defaultWriterClass	^DSTI3RemoteWriter</body><body package="DST_I3">predefinedObjects	^predefinedObjects</body><body package="DST_I3">predefinedObjects: anObject	predefinedObjects := anObject</body></methods><methods><class-id>DST.DSTI3RemoteStream</class-id> <category>private-initialize-release</category><body package="DST_I3">initializePredefinedObjects	self predefinedObjects: super predefinedObjects asOrderedCollection.	super initializePredefinedObjects</body><body package="DST_I3">readWriteMapsInitialSize	^256</body></methods><methods><class-id>DST.DSTI3RemoteStream</class-id> <category>private-initialize</category><body package="DST_I3">cleanup	"Cleanup maps"	self predefinedObjects size &gt; BufferingLevel		ifTrue: [self initialize.]</body></methods><methods><class-id>DST.DSTI3RemoteStream class</class-id> <category>defualt</category><body package="DST_I3">defaultSourceMode	"What should the default source code policy be if	the user doesn't specify it?"	^#discard</body></methods><methods><class-id>DST.DSTI3RemoteStream class</class-id> <category>class initialization</category><body package="DST_I3">initialize	"BufferingLevel is how many objects we buffer in 	reader/writer's predefined object table.	Raise the BufferingLevel will greately increase the 	marshalling speed if objects are send out repeatly	but it may also cause the inconsistence problem	between buffered object copies."	BufferingLevel := 0</body></methods><methods><class-id>DST.DSTI3RemoteStream class</class-id> <category>instance creation</category><body package="DST_I3">on: aStream	^self basicNew on: aStream</body></methods><methods><class-id>DST.DSTI3RemoteStream class</class-id> <category>private - instance creation</category><body package="DST_I3">newInstance	^self basicNew</body></methods><methods><class-id>Core.Object</class-id> <category>I3</category><body package="DST_I3">isPassedByValue	"Deside wether or not this object should pass by value.	The defalut pass mode is by reference"	^self isPassedByValueDefault: false</body><body package="DST_I3">isPassedByValueDefault: aBoolean	^DSTI3ObjRef transferModeDictionary at: self ifAbsent: [aBoolean]</body><body package="DST_I3">passByReference	DSTI3ObjRef transferModeDictionary at: self put: false</body><body package="DST_I3">passByValue	DSTI3ObjRef transferModeDictionary at: self put: true</body><body package="DST_I3">passInstVars	"E.g., #(true false ref value):	the first instVar is passed according to its own specification.	the second is not passed (resulting in nil).	the third is passed by reference.	the fourth is passed by value.	the fifth, sixth, etc., are passed according to their specs"	^#()</body></methods><methods><class-id>UI.Menu</class-id> <category>I3</category><body package="DST_I3">isPassedByValue	^self isPassedByValueDefault: true</body></methods><methods><class-id>Core.Message</class-id> <category>I3</category><body package="DST_I3">isPassedByValue	^self isPassedByValueDefault: true</body></methods><methods><class-id>Core.LinkedList</class-id> <category>I3</category><body package="DST_I3">isPassedByValue	^self isPassedByValueDefault: false</body></methods><methods><class-id>Core.Metaclass</class-id> <category>I3</category><body package="DST_I3">isPassedByValue	^self soleInstance isPassedByValue</body></methods><methods><class-id>Core.Collection</class-id> <category>I3</category><body package="DST_I3">isPassedByValue	^self isPassedByValueDefault: true</body></methods><methods><class-id>Core.Class</class-id> <category>I3</category><body package="DST_I3">isPassedByValue	^true</body></methods><methods><class-id>Kernel.RemoteString</class-id> <category>I3</category><body package="DST_I3">isPassedByValue	^self isPassedByValueDefault: true</body></methods><methods><class-id>Kernel.BOSSRegisteredObject</class-id> <category>I3</category><body package="DST_I3">isPassedByValue	^self isPassedByValueDefault: true</body></methods><methods><class-id>OS.Filename</class-id> <category>I3</category><body package="DST_I3">isPassedByValue	^self isPassedByValueDefault: true</body></methods><methods><class-id>Core.UninterpretedBytes</class-id> <category>I3</category><body package="DST_I3">isPassedByValue	^self isPassedByValueDefault: true</body></methods><methods><class-id>Kernel.BOSSContents</class-id> <category>I3</category><body package="DST_I3">isPassedByValue	^self isPassedByValueDefault: true</body></methods><methods><class-id>Core.Magnitude</class-id> <category>I3</category><body package="DST_I3">isPassedByValue	^self isPassedByValueDefault: true</body></methods><methods><class-id>Core.Exception</class-id> <category>I3</category><body package="DST_I3">isPassedByValue	^self isPassedByValueDefault: true</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>I3</category><body package="DST_I3">isPassedByValue	^self isPassedByValueDefault: true</body></methods><methods><class-id>Core.ReadStream</class-id> <category>I3</category><body package="DST_I3">isPassedByValue	^self isPassedByValueDefault: true</body></methods><methods><class-id>Kernel.BOSSCompiledCodeHolder</class-id> <category>I3</category><body package="DST_I3">isPassedByValue	^self isPassedByValueDefault: true</body></methods><methods><class-id>Kernel.BlockClosure</class-id> <category>I3</category><body package="DST_I3">isPassedByValue	^false</body></methods><methods><class-id>Graphics.Geometric</class-id> <category>I3</category><body package="DST_I3">isPassedByValue	^self isPassedByValueDefault: true</body></methods><methods><class-id>Core.Signal</class-id> <category>I3</category><body package="DST_I3">isPassedByValue	^self isPassedByValueDefault: true</body></methods><methods><class-id>Kernel.CompiledBlock</class-id> <category>I3</category><body package="DST_I3">isPassedByValue	^self isPassedByValueDefault: true</body></methods><methods><class-id>Kernel.CodeReader</class-id> <category>I3</category><body package="DST_I3">readFromConnection: ioConnection	stream := CodeReaderStream on: ioConnection.	[self readPackage] ensure: [stream close. stream := nil]</body></methods><initialize><class-id>DST.DSTModuleI3</class-id></initialize><initialize><class-id>DST.DSTI3ObjRef</class-id></initialize><initialize><class-id>DST.DSTI3RemoteStream</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>DSTModuleI3Null</name><environment>DST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>DST-Modules</category><attributes><package>DST_Core</package></attributes></class><class><name>DSToperation</name><environment>DST</environment><super>DST.DSTMetaObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>localOp signature sync raises context access </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>DST_Core</package></attributes></class><class><name>Message</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector args </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>DSToperationInfo</name><environment>DST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>interface operation selector opIndex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>DST_Core</package></attributes></class><class><name>BOSSWriter</name><environment>Kernel</environment><super>Kernel.BOSSAbstractWriter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Binary Storage</category><attributes><package>BOSS</package></attributes></class><class><name>BOSSCompiledCodeHolder</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>class selector category codeClass codeContents source </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Binary Storage</category><attributes><package>BOSS</package></attributes></class><class><name>Signal</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parent mayProceed notifierString nameClass nameMessage exceptionClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>Metaclass</name><environment>Core</environment><super>Core.ClassDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>thisClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>Class</name><environment>Core</environment><super>Core.ClassDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name classPool environment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>UndefinedObject</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>RemoteString</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sourceKey </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Support</category><attributes><package>Kernel-Support</package></attributes></class><class><name>CodeReader</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream pointer format parcelName versionString dateString timeString numNamedObjects numClasses numExtensionMethods definedObjects definedBindings definedExternals classes classSelectors categories packageEnvironment packageUndeclared extensionMethods objectSpaceSize objectSpace symbolNum twoByteSymbolNum stringNum twoByteStringNum byteArrayNum floatNum doubleNum fixedNum largePositiveNum largeNegativeNum mclassNum mclassclassNum refNamObjNum scopeZonesNum defObjOrganizerNum classOrganizerNum arbClassNum arbObjectNum messageSendIndices properties userStringsNum namedObjects namedObjectsNum postLoadObjects streamDir sourceFile hideSource importMaps overriddenExtensions versionSelectionBlock warningSuppressionBlock preReadBlock currentSuperclass mustRecompile lateOperations updates tempSourceFile compilationManager </inst-vars><class-inst-vars></class-inst-vars><imports>			Behavior.*			</imports><category>System-Code Storage</category><attributes><package>System-Code Storage</package></attributes></class><class><name>Filename</name><environment>OS</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>osName publicName logicalName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Support</category><attributes><package>OS-Support</package></attributes></class><class><name>Geometric</name><environment>Graphics</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Geometry</category><attributes><package>Graphics-Geometry</package></attributes></class><class><name>Menu</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>items groupSizes adornment selectionMemory </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Menus</category><attributes><package>Interface-Menus</package></attributes></class><class><name>BinaryObjectStorage</name><environment>Kernel</environment><super>Kernel.AbstractBinaryObjectStorage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Binary Storage</category><attributes><package>BOSS</package></attributes></class><class><name>Magnitude</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>Collection</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>UninterpretedBytes</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Exception</name><environment>Core</environment><super>Core.GenericException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>BlockClosure</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method outerContext copiedValues </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>BOSSReader</name><environment>Kernel</environment><super>Kernel.BOSSAbstractReader</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Binary Storage</category><attributes><package>BOSS</package></attributes></class><class><name>BOSSContents</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>object </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Binary Storage</category><attributes><package>BOSS</package></attributes></class><class><name>ReadStream</name><environment>Core</environment><super>Core.InternalStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>LinkedList</name><environment>Core</environment><super>Core.SequenceableCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>firstLink lastLink </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Sequenceable</category><attributes><package>Collections-Sequenceable</package></attributes></class><class><name>CompiledBlock</name><environment>Kernel</environment><super>Kernel.CompiledCode</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>outerMethod </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>BOSSRegisteredObject</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name valueBlock writerClass value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Binary Storage</category><attributes><package>BOSS</package></attributes></class></st-source>