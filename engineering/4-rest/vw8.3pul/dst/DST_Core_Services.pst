<?xml version="1.0"?><st-source><!-- Name: DST_Core_ServicesNotice: Copyright 1999-2013 Cincom Systems, Inc.  All rights reserved.Comment: DST_Core_Services contains the implementation of the core DST services: the Naming Service and the LifeCycle Service.Copyright: Copyright © 1999-2001 Cincom Systems, Inc.All Rights ReservedThis product contains copyrighted third-party software.Copyright © 1993-1995 Hewlett-Packard Company.All Rights ReservedDbIdentifier: bear73DbTrace: 464619DbUsername: tkoganDbVersion: 8.1 - 1DevelopmentPrerequisites: #(#(#any 'DST_Core' '') #(#any 'BOSS' '') #(#any 'DST_Core_IDL' '') #(#any 'DST_Core_Services_IDL' ''))Namespace: Smalltalk.DSTPackageName: DST_Core_ServicesParcel: #('DST_Core_Services')ParcelName: DST_Core_ServicesPrerequisiteDescriptions: #(#(#name 'DST_Core') #(#name 'BOSS' #componentType #package) #(#name 'DST_Core_IDL' #componentType #package) #(#name 'DST_Core_Services_IDL' #componentType #package))PrerequisiteParcels: #(#('DST_Core' '') #('BOSS' '') #('DST_Core_IDL' '') #('DST_Core_Services_IDL' ''))PrintStringCache: (8.1 - 1,tkogan)Version: 8.1 - 1Date: 1:09:21 PM January 29, 2016 --><time-stamp>From VisualWorks®, Pre-Release 8.2 (jan16.4) of January 29, 2016 on January 29, 2016 at 1:09:21 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>DSTBindingIterator</name><environment>DST</environment><super>Core.ReadStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COS-Naming</category><attributes><package>DST_Core_Services</package></attributes></class><comment><class-id>DST.DSTBindingIterator</class-id><body>Along with DSTName, DSTNameComponent, and DSTNameContext, the DSTBindingIterator class supports the Naming Service that is an extension to the CORBA 1.1 specifications. This naming service associates an object with a name to provide unique identification in a distributed environment.Specifically, instances of DSTBindingIterator allow a client to iterate through the set of bindings contained in a naming context (using inherited methods nextN: and nextOne).For a complete description of the Naming Service, see the class comment for DSTNameContext.</body></comment><class><name>DSTNamingServiceConfiguration</name><environment>DST</environment><super>DST.DSTServiceConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>DST-Configuration</category><attributes><package>DST_Core_Services</package></attributes></class><comment><class-id>DST.DSTNamingServiceConfiguration</class-id><body>Instances of this class store settings information for the naming service. Provides for the configuration of the naming service from these settings.</body></comment><class><name>DSTName</name><environment>DST</environment><super>Core.OrderedCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COS-Naming</category><attributes><package>DST_Core_Services</package></attributes></class><comment><class-id>DST.DSTName</class-id><body>Instances of this class represent an ordered sequence of compound names (DSTNameComponents) as specified by Hewlett Packard Company's and SunSoft Inc.'s Naming Services extension to CORBA 1.1. For a complete description of the Naming Service, see the class comment for DSTNameContext.A name is an ordered sequence of components. An instance of DSTName with a single component is called a simple name.  A name with multiple components is called a compound name. Each component except the last is used to name a context; the last component denotes the bound object. In the following example,  both component1 and component2 are used to name a context, while the last component refers to the bound object.		&lt;component1 ; component2 ; component3&gt;</body></comment><class><name>DSTNameComponent</name><environment>DST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>identifier kind </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COS-Naming</category><attributes><package>DST_Core_Services</package></attributes></class><comment><class-id>DST.DSTNameComponent</class-id><body>Instances of this class represent an ordered sequence of compound names (DSTNameComponents) as specified by Hewlett Packard Company's and SunSoft Inc.'s  Naming Service extension to CORBA 1.1.  These instances function as Names Libraries that hide the underlying representation of names from clients. This allows name representations to evolve without affecting existing clients. For a complete description of the Naming Service, see the class comment for SunNameContext.Instance variables:	identifier	&lt;String&gt; holding the identifier attribute	kind			&lt;String&gt; holding the kind attributeTo avoid issues of differing name syntax, the naming service always deals with names in their structural form, which consists of two attributes: the IDENTIFIER ATTRIBUTE and the KIND ATTRIBUTE. Both the identifier attribute and the kind attribute are represented as IDL strings.  The kind attribute adds descriptive power to names in a syntax independent way. In the absence of such a feature, users normally resort to syntactic convention. For example, in Unix, suffixes such as ".c", ".o" etc. are used. Applications like the C compiler depend on such syntactic convention to make name transformations such as from foo.c to foo.o. Unfortunately, such syntactic convention is not explicit; software that does not depend on the syntactic conventions for names does not have to be changed to adopt to new conventions. Thus, name components have an attribute called kind to address the needs of such applications. As examples, the value of the kind attribute might be "c_source", "object_code", "executable", "postscript" or "". The naming service does not interpret, assign or manage these values in any way. Higher levels of software may make policies about the use and management of these values.</body></comment><class><name>DSTNameContext</name><environment>DST</environment><super>DST.DSTPersistentObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bindings nContexts </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COS-Naming</category><attributes><package>DST_Core_Services</package></attributes></class><comment><class-id>DST.DSTNameContext</class-id><body>Along with classes DSTName and DSTNameComponent, DSTNameContext supports the Naming Service that is an extension to the CORBA 1.1 specifications. This naming service associates an object with a name to provide unique identification in a distributed environment.  An instance of class DSTNameContext is an object that contains a set of name bindings in which each name is unique.  This object is a non leaf node in a naming graph (as described below).Instance Variables:	bindings		&lt;Dictionary&gt; of name-to-object associations	nContexts	&lt;Set&gt; of naming contexts which have been bound using the method 						contextBindContext.ABOUT  THE  NAMING  SERVICEA name-to-object association is called a NAME BINDING. A NAMING CONTEXT is an object that contains a set of name bindings in which each name is unique. Different names can be bound to an object in the same or different contexts at the same time.A name binding is always defined relative to a naming context.  Methods in protocol NamingContextBind handle binding, rebinding and unbinding.  Unbinding removes a name binding from a context. Rebinding removes a name from its current context and binds it to a new context.To RESOLVE A NAME is to determine the object associated with the name in a given context.  Once an object is bound, it can be found via the methods in protocol NamingContextResolve. NOTE: Naming contexts that are bound using contextBindContext:to: participate in name resolution when compound names are passed to resolve, while naming contexts that are bound using contextBind:to: do not.STRUCTURES OF NAMING CONTEXTSBecause a context is like any other object, it can also be bound to a name in some naming context. By binding contexts in other contexts we can create a NAMING GRAPH -- a directed graph with nodes and labeled edges where the nodes are contexts. We can use more complex names for referring to an object in a naming graph. Given a context in some naming graph, we can use a sequence of names to refer to an object; the sequence of names defines a path in the naming graph to navigate the resolution process. Such a sequence of names is called a compound name.  (A name with a single component is called a simple name.)The  methods that support creating new contexts are newContext and bindNewContext.  The destroyContext method is used to destroy a naming context. The listContext: method iterates through a context's bindings.</body></comment><class><name>DSTFactoryFinder</name><environment>DST</environment><super>DST.DSTNameContext</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COS-LifeCycle</category><attributes><package>DST_Core_Services</package></attributes></class><comment><class-id>DST.DSTFactoryFinder</class-id><body>Every application object must be contained by some other object, except for certain special objects which can be thought of as representing an abstract location.  These special objects must support the FactoryFinder interface.  FactoryFinders are NamingContexts which contain the Factory objects defined for an abstract location.  Factory objects, in this implementation, are Smalltalk class objects which have been registered during the Initialize Factories phase of the ORB initialization.  To cause a class to be registered in this fashion, provide an instance method #abstractClassId which returns the appropriate UUID value for the class.</body></comment><methods><class-id>DST.DSTBindingIterator</class-id> <category>repository</category><body package="DST_Core_Services">CORBAName	"return the name of my CORBA interface in the repository"	^#'::CosNaming::BindingIterator'</body></methods><methods><class-id>DST.DSTBindingIterator</class-id> <category>BindingIterator</category><body package="DST_Core_Services">nextN: n bindingList: aBindingList 	"return the next element of the receiver"	"Iterators do not raise an exception if they go out of range. Therefore 	we return a result that consists of a nil object ID and an 'invalid' 	number."	self atEnd		ifTrue: 			[aBindingList value: #().			^false]		ifFalse: 			[aBindingList value: (self nextAvailable: n).			^true]</body><body package="DST_Core_Services">nextOne: aBinding 	"return the next element of the receiver"	"Iterators do not raise an exception if they go out of range. Therefore 	we return a result that consists of a nil object ID and an 'invalid' 	number."	self atEnd		ifTrue: 			[aBinding value: self class dummyBinding.			^false]		ifFalse: 			[aBinding value: self next.			^true]</body></methods><methods><class-id>DST.DSTBindingIterator class</class-id> <category>instance creation</category><body package="DST_Core_Services">on: aCollection 	"Answer a new instance of the receiver, streaming over aCollection. Since 	this iterator will be exported, register it as a lifecycle object"	| bi |	bi := super on: aCollection.	DSTObjRef registerFactoryObject: bi.	^bi</body></methods><methods><class-id>DST.DSTBindingIterator class</class-id> <category>constants</category><body package="DST_Core_Services">dummyBinding	^Dictionary 			with: #bindingName -&gt; 'nil' asDSTName			with: #bindingType -&gt; (CORBAConstants at: #'::CosNaming::BindingType::nobject')</body></methods><methods><class-id>DST.DSTNamingServiceConfiguration</class-id> <category>configuring</category><body package="DST_Core_Services">configure	"configure the naming service for this image"	| kind |	ORBDaemon running ifFalse: [^self].	kind := self settingFor: #kind.	ORBObject namingService: (kind == #filename			ifTrue: [ORBObject referenceFromFile: (self settingFor: #filename) asFilename]			ifFalse: [kind == #hostname					ifTrue: [self orbFromHostname resolveInitialReferences: #NameService]					ifFalse: [ORBObject namingService isLocal							ifTrue: [ORBObject namingService]							ifFalse: [DSTNameContext new]]])</body></methods><methods><class-id>DST.DSTNamingServiceConfiguration</class-id> <category>accessing</category><body package="DST_Core_Services">orderOfConfiguration	"Return the order in which a service should be configured at system startup. 	The smaller the number, the earlier the service should be configurd. "	^2</body></methods><methods><class-id>DST.DSTNamingServiceConfiguration class</class-id> <category>accessing</category><body package="DST_Core_Services">configurationName	"Return a symbol identifying this configuration"	^#namingService</body></methods><methods><class-id>DST.DSTNamingServiceConfiguration class</class-id> <category>class initialization</category><body package="DST_Core_Services">initialize	"self initialize"	self addService</body><body package="DST_Core_Services">release	self removeService</body></methods><methods><class-id>DST.DSTName</class-id> <category>repository</category><body package="DST_Core_Services">CORBAType	"return an instance of the DSTmetaObject subclass which can marshall an 	instance of the receiver."	^ORBObject lookupMetaId: #'::CosNaming::Name'</body></methods><methods><class-id>DST.DSTName</class-id> <category>Name</category><body package="DST_Core_Services">allButLast	^self copyFrom: 1 to: self size - 1</body><body package="DST_Core_Services">base: number 	"return the first number components of the receiver"	^self copyFrom: 1 to: number</body><body package="DST_Core_Services">rest: number 	"return the components after number"	^self copyFrom: number + 1 to: self size.</body></methods><methods><class-id>DST.DSTName</class-id> <category>conversion</category><body package="DST_Core_Services">asDSTName	"Return a DSTName on the receiver"	^self</body></methods><methods><class-id>DST.DSTName class</class-id> <category>instance creation</category><body package="DST_Core_Services">on: aNCArray 	"create a new name given the name components"	| obj |	obj := self new.	1 to: aNCArray size do: [:elem | (aNCArray at: elem) class == DSTNameComponent			ifTrue: [obj add: (aNCArray at: elem)]			ifFalse: [obj add: (DSTNameComponent on: (aNCArray at: elem))]].	^obj</body><body package="DST_Core_Services">onComponent: aNameComponent 	"create a new name given the name components"	^(self new) add: aNameComponent; yourself</body><body package="DST_Core_Services">onString: aNameString 	"return a new name on the given name string"	^self with: (DSTNameComponent on: aNameString)</body><body package="DST_Core_Services">onStrings: aNameArray	| obj |	obj := self new.	aNameArray do: [:st | obj add: (DSTNameComponent on: st)].	^obj</body></methods><methods><class-id>DST.DSTNameComponent</class-id> <category>comparing</category><body package="DST_Core_Services">= anObject 	"Answer whether the receiver and the argument represent the same object.	If = is redefined in any subclass, consider also redefining the message hash."	^( anObject class == self class )		and: [ identifier = anObject identifier &amp; ( kind = anObject kind ) ]</body><body package="DST_Core_Services">hash	"Answer with a SmallInteger unique to the receiver."	^self printString hash</body></methods><methods><class-id>DST.DSTNameComponent</class-id> <category>Name Component</category><body package="DST_Core_Services">id	"return the value of the identifier"	^self identifier</body><body package="DST_Core_Services">id: anIdentifier 	"set the value of the identifier"	self identifier: anIdentifier</body><body package="DST_Core_Services">kind	"return the value of the kind"	^kind</body><body package="DST_Core_Services">kind: aKind	"set the value of the kind"	kind := aKind</body></methods><methods><class-id>DST.DSTNameComponent</class-id> <category>accessing</category><body package="DST_Core_Services">identifier	"return the value of the identifier"	^identifier</body><body package="DST_Core_Services">identifier: anIdentifier 	"set the value of the identifier"	identifier := anIdentifier</body></methods><methods><class-id>DST.DSTNameComponent</class-id> <category>printing</category><body package="DST_Core_Services">printOn: aStream	identifier isNil ifTrue: [^aStream nextPutAll: '''?'''].	aStream nextPut: $' ; nextPutAll: identifier; nextPut: $: .	kind isNil ifTrue: [^aStream nextPut: $' ].	aStream nextPutAll: kind; nextPut: $' .</body></methods><methods><class-id>DST.DSTNameComponent</class-id> <category>repository</category><body package="DST_Core_Services">CORBAType	"return an instance of the DSTmetaObject subclass which can marshall an 	instance of the receiver."	^ORBObject lookupMetaId: #'::CosNaming::NameComponent'</body></methods><methods><class-id>DST.DSTNameComponent class</class-id> <category>instance creation</category><body package="DST_Core_Services">id: aString kind: bString	^self new id: aString; kind: bString; yourself</body><body package="DST_Core_Services">on: aString 	^self new identifier: aString; kind: ''; yourself</body></methods><methods><class-id>DST.DSTNameContext</class-id> <category>NamingContextBind</category><body package="DST_Core_Services">bindNewContext: aName 	"create a new name context and bind it to the name in the receiver"	| nc |	nc := self newContext.	self contextBindContext: aName to: nc.	^nc</body><body package="DST_Core_Services">contextBind: aName to: anObject 	"Bind the name to the object in the context of the receiver.	Altered in 5i to handle 'kind' correctly."	| comp |	aName isEmpty		ifTrue: [^self invalidNameError]		ifFalse: 			[comp := aName last.			aName size &gt; 1				ifTrue: [^(self contextResolve: (aName base: aName size - 1))						contextBind: (DSTName onComponent: comp)						to: anObject]				ifFalse: [^self						basicBind: comp						to: anObject						rebind: false]]</body><body package="DST_Core_Services">contextBindContext: aName to: aNameContext 	"bind the name to the naming context in the context of the receiver"	| comp |	aName isEmpty		ifTrue: [^self invalidNameError]		ifFalse: 			[comp := aName last.			aName size &gt; 1				ifTrue: [^(self contextResolve: (aName base: aName size - 1))						contextBindContext: (DSTName onString: comp identifier)						to: aNameContext]				ifFalse: [^self						basicBindContext: comp						to: aNameContext						rebind: false]]</body><body package="DST_Core_Services">contextReBind: aName to: anObject	"bind the name to the object in the context of the receiver"	| comp |	aName isEmpty		ifTrue: [^self invalidNameError]		ifFalse: 			[comp := aName last.			aName size &gt; 1				ifTrue: [^(self contextResolve: (aName base: aName size - 1))						contextReBind: (DSTName onString: comp identifier)						to: anObject]				ifFalse: [^self						basicBind: comp						to: anObject						rebind: true]]</body><body package="DST_Core_Services">contextReBindContext: aName to: aNameContext 	"bind the name to the naming context in the context of the receiver"	| comp |	aName isEmpty		ifTrue: [^self invalidNameError]		ifFalse: 			[comp := aName last.			aName size &gt; 1				ifTrue: [^(self contextResolve: (aName base: aName size - 1))						contextReBindContext: (DSTName onString: comp identifier)						to: aNameContext]				ifFalse: [^self						basicBindContext: comp						to: aNameContext						rebind: true]]</body><body package="DST_Core_Services">contextUnBind: aName 	"unbind the name in the context of the receiver"	| comp |	aName isEmpty		ifTrue: [^self invalidNameError]		ifFalse: 			[comp := aName last.			aName size &gt; 1				ifTrue: [^(self contextResolve: (aName base: aName size - 1))						contextUnBind: (DSTName onString: comp identifier)]				ifFalse: [bindings removeKey: comp ifAbsent: [^self							notFoundError: #missing_node							restOfName: aName].						nContexts remove: comp ifAbsent: []]]</body><body package="DST_Core_Services">destroyContext	"delete all bindings associated with the receiver"	(bindings isNil or: [bindings isEmpty])		ifTrue: [super destroy]		ifFalse: [^self notEmptyError]</body><body package="DST_Core_Services">newContext	"return a new name context"	| nc |	nc := self class new initialize.	DSTObjRef registerFactoryObject: nc.	^nc</body></methods><methods><class-id>DST.DSTNameContext</class-id> <category>NamingContextResolve</category><body package="DST_Core_Services">contextResolve: aName 	"return the object which is bound to the name in the context of the 	receiver"	| comp rest cxt |	aName isEmpty		ifTrue: [^self invalidNameError]		ifFalse: 			[comp := aName  first.			rest := aName rest: 1.			cxt := bindings at: comp ifAbsent: [^self notFoundError: #'missing_node' restOfName: aName].			rest isEmpty				ifTrue: [^cxt]				ifFalse: [(cxt isKindOf: DSTNameContext)						ifTrue: [(nContexts includes: comp)								ifTrue: [^cxt contextResolve: rest]								ifFalse: [^self notFoundError: #'not_context' restOfName: aName]]						ifFalse: [(cxt isKindOf: DSTName)								ifTrue: [^(self contextResolve: cxt)										contextResolve: rest]								ifFalse: [^self notFoundError: #'not_context' restOfName: aName]]]]</body><body package="DST_Core_Services">listContext: anInt 	"return a list of binding that is the number of anInt. If there are not 	that many bindings then return as many as there are. If there are 	more bindings then return a binding iterator with the remaining 	bindings."	| res |	res := OrderedCollection new.	bindings associationsDo: [:assoc | res add: (self bInfo: assoc)].	res := res asArray.	res size &gt; anInt &amp; (anInt &gt;= 0)		ifTrue: [^(Dictionary				with: #bl -&gt; (res copyFrom: 1 to: anInt)				with: #bi -&gt; (DSTBindingIterator on: (res copyFrom: anInt + 1 to: res size)))]		ifFalse: [^(Dictionary				with: #bl -&gt; res				with: #bi -&gt; nil)]</body><body package="DST_Core_Services">listContext: anInt bindingList: aList bindingIterator: anIterator 	"return a list of binding that is the number of anInt. If there are not 	that many bindings then return as many as there are. If there are 	more bindings then return a binding iterator with the remaining 	bindings."	| res |	res := OrderedCollection new.	bindings associationsDo: [:assoc | res add: (self bInfo: assoc)].	res := res asArray.	res size &gt; anInt &amp; (anInt &gt;= 0)		ifTrue: 			[aList value: (res copyFrom: 1 to: anInt).			anIterator value: (DSTBindingIterator on: (res copyFrom: anInt + 1 to: res size))]		ifFalse: 			[aList value: res.			anIterator value: nil]</body></methods><methods><class-id>DST.DSTNameContext</class-id> <category>exceptions</category><body package="DST_Core_Services">alreadyBoundError	"raises AlreadyBound exception specified in IDL interface"	^(CORBAConstants at: #'::CosNaming::NamingContext::AlreadyBound')		raiseWith: Dictionary new errorString: ' name is already bound'</body><body package="DST_Core_Services">cannotProceedError: aNamingContext nameComponent: aNameComponent 	"raises CannotProceed exception specified in IDL interface"	^(CORBAConstants at: #'::CosNaming::NamingContext::CannotProceed')		raiseWith: (Dictionary with: #cxt -&gt; aNamingContext with: #restOfName -&gt; aNameComponent)		errorString: ' unable to proceed'</body><body package="DST_Core_Services">invalidNameError	"raises InvalidName exception specified in IDL interface"	^(CORBAConstants at: #'::CosNaming::NamingContext::InvalidName')		raiseWith: Dictionary new errorString: ' invalid name'</body><body package="DST_Core_Services">notEmptyError	"raises NotEmpty exception specified in IDL interface"	^(CORBAConstants at: #'::CosNaming::NamingContext::NotEmpty')		raiseWith: Dictionary new errorString: ' naming context contains bindings'</body><body package="DST_Core_Services">notFoundError: aReason restOfName: aName 	"raises NotFound exception specified in IDL interface"	^(CORBAConstants at: #'::CosNaming::NamingContext::NotFound')		raiseWith: (Dictionary with: #why -&gt; aReason with: #restOfName -&gt; aName)		errorString: ' name not found'</body></methods><methods><class-id>DST.DSTNameContext</class-id> <category>private</category><body package="DST_Core_Services">bInfo: assoc 	"return a binding info record for the association"	| key typ |	key := assoc key.	(nContexts includes: key)		ifTrue: [typ := #ncontext]		ifFalse: [typ := #nobject].	^Dictionary with: #bindingName -&gt; (DSTName onComponent: key) with: #bindingType -&gt; typ</body><body package="DST_Core_Services">basicBind: aNameComponent to: anObject rebind: reBind	"bind the name to the object in the context of the receiver where the 	name is atomic"	(aNameComponent isKindOf: DSTNameComponent)		ifFalse: [^self invalidNameError].	(bindings includesKey: aNameComponent) &amp; reBind not		ifTrue: [^self alreadyBoundError]		ifFalse: [bindings at: aNameComponent put: anObject]</body><body package="DST_Core_Services">basicBindContext: aNameComponent to: aNamingContext rebind: reBind	"bind the name to the naming context in the context of the receiver where the 	name is atomic"	(aNameComponent isKindOf: DSTNameComponent)		ifFalse: [^self invalidNameError].	(aNamingContext isKindOf: DSTNameContext)		ifFalse: [^self cannotProceedError: aNamingContext							nameComponent: aNameComponent].						(bindings includesKey: aNameComponent) &amp; reBind not		ifTrue: [^self alreadyBoundError]		ifFalse: [bindings at: aNameComponent put: aNamingContext.				nContexts add: aNameComponent]</body></methods><methods><class-id>DST.DSTNameContext</class-id> <category>repository</category><body package="DST_Core_Services">CORBAName	"return the name of my CORBA interface in the repository"	^#'::CosNaming::NamingContext'</body><body package="DST_Core_Services">abstractClassId	"return the abstract class Id of the receiver"	^'5b92f5d1-7e12-0000-020f-1c6813000000' asUUID</body></methods><methods><class-id>DST.DSTNameContext</class-id> <category>initialization</category><body package="DST_Core_Services">initialize	"initialize the receiver"	super initialize.	bindings := Dictionary new: 500.	nContexts := Set new.</body></methods><methods><class-id>DST.DSTNameContext class</class-id> <category>errror handling</category><body package="DST_Core_Services">alreadyBoundSignal	"Answer the signal used for AlreadyBound errors"	^CORBAConstants at: #'::CosNaming::NamingContext::AlreadyBound'</body><body package="DST_Core_Services">cannotProceedSignal	"Answer the signal used for Cannot Proceed errors"	^CORBAConstants at: #'::CosNaming::NamingContext::CannotProceed'</body><body package="DST_Core_Services">invalidNameSignal	"Answer the signal used for InvalidName errors"	^CORBAConstants at: #'::CosNaming::NamingContext::InvalidName'</body><body package="DST_Core_Services">notEmptySignal	"Answer the signal used for raises NotEmpty errors"	^CORBAConstants at: #'::CosNaming::NamingContext::NotEmpty'</body><body package="DST_Core_Services">notFoundSignal	"Answer the signal used for NotFound errors"	^CORBAConstants at: #'::CosNaming::NamingContext::NotFound'</body></methods><methods><class-id>DST.DSTNameContext class</class-id> <category>utilities</category><body package="DST_Core_Services">findOrCreateContext: aContextName	"Like mkdir -p. If parent does not exist, create parent first. Start looking from root"	^self findOrCreateContext: aContextName startFrom: ORBObject namingService</body><body package="DST_Core_Services">findOrCreateContext: aContextName startFrom: root 	"Like mkdir -p. If parent does not exist, create parent first."	| cxt |	aContextName inject: root		into: 			[:parent :rest | 			| nodeName |			nodeName := DSTName onComponent: rest.			[cxt := parent contextResolve: nodeName]				on: DSTNameContext notFoundSignal do: [:ex | cxt := parent bindNewContext: nodeName]].	^cxt</body><body package="DST_Core_Services">printNameTreeOn: aStream	"ls -lR format"	"self 		printNameTreeOn: String new writeStream" 	^self 		printNameTreeOn: aStream 		startFrom: ORBObject namingService</body><body package="DST_Core_Services">printNameTreeOn: aStream startFrom: aContext 	"ls -lR format"	"self 		printNameTreeOn: String new writeStream 		startFrom: ORBObject namingService"	| iter list |	list := nil asValue.	iter := nil asValue.	aContext listContext: 100 bindingList: list bindingIterator: iter.	aStream nextPutAll: '/'; cr.	list value do: [:binding |		| comp type obj |		comp := (binding value at: #bindingName) first.		type := (binding value at: #bindingType) printString.		obj := aContext contextResolve: (DSTName onComponent: comp).		aStream tab; nextPutAll: '{', comp id, ':', (comp kind notNil ifTrue:[comp kind]), ' , ', type, ', '.		aStream nextPutAll: 			(obj isLocal				ifTrue:['a local ', obj class asString]				ifFalse:[obj printString]).		aStream nextPut: $}; cr].	aStream cr.	list value do: [:binding |		| ctx namebind type |		namebind := binding value at: #bindingName.		type := binding value at: #bindingType.		ctx := aContext contextResolve: namebind.		type == #ncontext ifTrue: [			aStream nextPutAll: namebind first id, ':', (namebind first kind notNil ifTrue:[namebind first kind]).			self printNameTreeOn: aStream startFrom: ctx]].	^aStream contents</body></methods><methods><class-id>DST.DSTFactoryFinder</class-id> <category>FactoryFinderObject</category><body package="DST_Core_Services">createAndInternalize: aStream 	"internalize a new instance from the stream"	| bos stream obj | 	stream := aStream contents readStream.	aStream destroy.	bos := BinaryObjectStorage onOldNoScan: stream.	obj := self createObject: bos next.	obj copyPersistentState: bos next.	^obj</body><body package="DST_Core_Services">createObject: abstractClassID 	"create a minimally initialized copy of the given class"	| factory |	factory := bindings at: (DSTNameComponent on: abstractClassID printString)				ifAbsent: [^(CORBAConstants at: #'::CosLifeCycle::FactoryRepresentative::CannotCreateObject')						raiseWith: (Dictionary with: #reason -&gt; 'Cannot find factory')].	^DSTObjRef registerFactoryObject: factory new</body><body package="DST_Core_Services">factoryFinder	"the factory finder of a factory finder is self"	^self</body></methods><methods><class-id>DST.DSTFactoryFinder</class-id> <category>FactoryFinder</category><body package="DST_Core_Services">findFactoriesKey: aFactoryKey 	"return the list of factories which match the given key (aNaming::Name)" 	^Array with: (self contextResolve: aFactoryKey)</body></methods><methods><class-id>DST.DSTFactoryFinder</class-id> <category>repository</category><body package="DST_Core_Services">CORBAName	"return the name of my CORBA interface in the repository"	^#'::CosLifeCycle::FactoryFinderObject'</body></methods><methods><class-id>DST.DSTFactoryFinder class</class-id> <category>class initialization</category><body package="DST_Core_Services">initialize	"self initialize"	(ORBObject dependents includes: self)		ifFalse: [ORBObject addDependent: self]</body><body package="DST_Core_Services">obsolete	"self obsolete"	ORBObject removeDependent: self.	^super obsolete</body></methods><methods><class-id>DST.DSTFactoryFinder class</class-id> <category>updating</category><body package="DST_Core_Services">update: aspect with: param from: orb	aspect == #startedORB		ifTrue: [(ORBObject listInitialServices includes: #FactoryFinder)					ifFalse: [ORBObject initializeFactories]]</body></methods><methods><class-id>DST.DSTObjRef class</class-id> <category>utilities</category><body package="DST_Core_Services">destroyLifeCycleObjectsForClass: aClass 	"administration utility to destroy the objects in the LifeCycle table for 	a specific class of object"	self lifeCycleObjects do: [:obj | (obj isKindOf: aClass)			ifTrue: [obj destroy]]</body></methods><methods><class-id>DST.DSTObjRef class</class-id> <category>accessing</category><body package="DST_Core_Services">lifeCycleObjects	^LifeCycleObjects</body></methods><methods><class-id>DST.DSTObjRef class</class-id> <category>creation-registration</category><body package="DST_Core_Services">registerFactoryObject: obj 	"add the object to the set of registered objects"	(obj isKindOf: self)		ifFalse: [LifeCycleObjects add: obj].	^obj</body><body package="DST_Core_Services">unRegisterLifeCycleObject: anObject 	"remove the object from the set of life cycle objects"	LifeCycleObjects remove: anObject ifAbsent: [].	self unRegisterObject: anObject</body></methods><methods><class-id>DST.ORBObject class</class-id> <category>GenericFactory</category><body package="DST_Core_Services">createObjectKey: aKey criteria: aCriteria 	"create a minimally initialized copy of the receiver"	| facts |	aCriteria isEmpty ifFalse: [(CORBAConstants at: #'::CosLifeCycle::CannotMeetCriteria')			raiseWith: (Dictionary with: #invalidCriteria -&gt; aCriteria)].		[facts := Factories findFactoriesKey: aKey.	^DSTObjRef registerFactoryObject: facts first new]		on: Object errorSignal do: [:ex | (CORBAConstants at: #'::CosLifeCycle::NoFactory')			raiseWith: (Dictionary with: #searchKey -&gt; aKey)]</body></methods><methods><class-id>DST.ORBObject class</class-id> <category>ORB-factories</category><body package="DST_Core_Services">enumerateFactories	"enumerate the set of potential child classes the receiver can create"	| r1 r2 classes objs bindings fact |	r1 := OrderedCollection new.	r2 := OrderedCollection new.	bindings := nil asValue.	Factories		listContext: -1		bindingList: bindings		bindingIterator: nil asValue.	fact := (bindings value collect: [:f | (f at: #bindingType)					== #nobject					ifTrue: [Factories contextResolve: (f at: #bindingName)]					ifFalse: [nil]]) asSet.	classes := fact select: [:c | c includesSelector: #productName].	objs := classes collect: [:cls | cls basicNew].	(objs asSortedCollection: [:a :b | a productName &lt; b productName])		do: [:obj | (r1 includes: obj productName)				ifFalse: 					[r1 add: obj productName.					r2 add: (Dictionary with: #productName -&gt; obj productName with: #factoryID -&gt; obj ACL)]].	^r2</body><body package="DST_Core_Services">factoryFinder	"return the local factory finder"	^Factories</body></methods><methods><class-id>DST.ORBObject class</class-id> <category>ORB-init-coslifec</category><body package="DST_Core_Services">factoryFinder: aFactoryFinder	Factories := aFactoryFinder.	self addInitialService: Factories name: #FactoryFinder</body></methods><methods><class-id>DST.ORBObject class</class-id> <category>ORB-factories</category><body package="DST_Core_Services">factoryStatistics	"Utility - display factory implementation statistics"	| tot met |	Transcript show: 'Counting Classes'; cr.	tot := ORBObject withAllSubclasses asSortedCollection: [:a :b | a selectors size &gt; b selectors size].	Transcript show: 'Total no of classes = ' , tot size printString; cr.	met := DSTMetaObject withAllSubclasses.	Transcript show: '	' , 'Total metaclasses = ' , met size printString; cr.	Transcript show: '	' , 'Total classes = ' , (tot size - met size) printString; cr; cr.	1 to: 15 do: [:i | Transcript show: '	' , i printString , '	' , (tot at: i) name , ' has ' , (tot at: i) selectors size printString , ' selectors'; cr].	tot sortBlock: [:a :b | a instSize - a superclass instSize &gt; (b instSize - b superclass instSize)].	Transcript cr.	1 to: 15 do: [:i | Transcript show: '	' , i printString , '	' , (tot at: i) name , ' has ' , ((tot at: i) instSize - (tot at: i) superclass instSize) printString , ' instance variables'; cr]</body></methods><methods><class-id>DST.ORBObject class</class-id> <category>ORB-init-coslifec</category><body package="DST_Core_Services">initializeFactories	"check EPVs with their interface in the repository, and register 	factory instances"	| abscl configMgr |	configMgr := ORBDaemon configurationManager.	self factoryFinder: DSTFactoryFinder new initialize.	configMgr log: '\Registering Classes as Factories' withCRs.	abscl := Set new: 100.	Object allSubclassesDo: [:cl | ((cl includesSelector: #abstractClassId)					and: [(cl inheritsFrom: DSTObjRef) not]) ifTrue: [abscl add: cl]].	abscl := abscl asSortedCollection: [:a :b | a name &lt; b name].	abscl remove: DSTObjRef.	abscl		do: 			[:cl | 			| epv clid obj if |			clid := cl basicNew abstractClassId.			Factories contextBind: (DSTName onString: clid printString)				to: cl.			Factories contextBind: (DSTName onString: cl name asString)				to: cl.			(self remoteRepository isNil and: [cl includesSelector: #CORBAName])				ifTrue: 					[if := cl basicNew getInterface.					if isNil						ifTrue: [configMgr log: ('\***interface for "' , cl name , '"  is undefined\') withCRs]						ifFalse: 							[epv := if fullEntryPointVector.							obj := cl basicNew.							epv do: [:sel | (obj respondsTo: sel)									ifFalse: [configMgr log: '\WARNING: method for "' withCRs , sel , '" is not implemented in "' , cl name , '"']]]]]</body></methods><methods><class-id>DST.ORBObject class</class-id> <category>ORB-naming</category><body package="DST_Core_Services">namingService	"Return the naming service"	^NamingService		ifNil: 			[self namingService: DSTNameContext new.			NamingService]</body><body package="DST_Core_Services">namingService: anObject 	"set the naming service to the give object"	(anObject class == DSTNameContext or: [anObject isKindOf: DSTObjRef])		ifTrue: [NamingService := anObject.				self addInitialService: anObject name: #NameService]		ifFalse: [self badParamError: 0]</body><body package="DST_Core_Services">namingServiceBind: aName to: anObj 	"Bind the Object to Naming Service at the Specified Name. If the 	Naming Service is Not Initialized, Disregard the Request"	self namingService contextReBind: aName to: anObj</body></methods><methods><class-id>DST.ORBObject class</class-id> <category>ORB-init-coslifec</category><body package="DST_Core_Services">registerAsFactory: aClass	"... intended for use by knowledgeable users in load and post load actions."	| cid |	( self factoryFinder isNil )		ifTrue:	[ self factoryFinder: DSTFactoryFinder new initialize ].	( aClass includesSelector: #abstractClassId )		ifFalse:	[ ^nil ].	( aClass inheritsFrom: DSTObjRef )		ifTrue:	[ ^nil ].	( aClass name == #DSTObjRef )		ifTrue:	[ ^nil ].	cid := aClass basicNew abstractClassId.	Factories contextBind: ( DSTName onString: cid printString)				to: aClass.	Factories contextBind: ( DSTName onString: aClass name asString)				to: aClass.</body></methods><methods><class-id>DST.ORBObject class</class-id> <category>GenericFactory</category><body package="DST_Core_Services">supportsKey: aKey 	"return if the key is supported"	^(Factories findFactoriesKey: aKey) isEmpty not</body></methods><methods><class-id>DST.ORBObject class</class-id> <category>ORB-init-coslifec</category><body package="DST_Core_Services">unregisterAsFactory: aClass	"... intended for use by knowledgeable users in load and post load actions."	| cid |	( self factoryFinder isNil )		ifTrue:	[ ^nil ].	( aClass includesSelector: #abstractClassId )		ifFalse:	[ ^nil ].	( aClass inheritsFrom: DSTObjRef )		ifTrue:	[ ^nil ].	( aClass name == #DSTObjRef )		ifTrue:	[ ^nil ].	cid := aClass basicNew abstractClassId.	[	Factories contextUnBind: ( DSTName onString: cid printString )	]	on: DSTNameContext notFoundSignal		do: [ :ex | ].	[	Factories contextUnBind: ( DSTName onString: aClass name asString)	]	on: DSTNameContext notFoundSignal		do: [ :ex | ].</body></methods><methods><class-id>DST.ORBObject</class-id> <category>LifeCycle</category><body package="DST_Core_Services">copyFactoryFinder: aFactoryFinder criteria: aCriteria 	"copy the receiver to the location of the factory finder"	aCriteria isEmpty ifFalse: [(CORBAConstants at: #'::CosLifeCycle::CannotMeetCriteria')			raiseWith: (Dictionary with: #invalidCriteria -&gt; aCriteria)			errorString: ' Copy criteria not supported'].	^aFactoryFinder asLocal createAndInternalize: self externalize</body></methods><methods><class-id>DST.ORBObject</class-id> <category>BasicLifecycle</category><body package="DST_Core_Services">copyPersistentState: persistentState 	"copy persistent state from the persistentState vector into my instance 	variables.  Should be overridden by all copyable subclasses"</body></methods><methods><class-id>DST.ORBObject</class-id> <category>FactoryRep</category><body package="DST_Core_Services">createObject: abstractClassID 	"create a minimally initialized copy of the given class"   	^self factoryFinder createObject: abstractClassID</body></methods><methods><class-id>DST.ORBObject</class-id> <category>BasicLifecycle</category><body package="DST_Core_Services">destroy	"destroy the receiver. Unmap it from the ORB, then convert it to a 	dead object"	super destroy.	1 to: self class instSize do: [:i | self instVarAt: i put: ORBDeadObject deadObject]</body><body package="DST_Core_Services">externalize 	"serialize the persistent state of the receiver onto a new stream"	| stream boss | 	stream := WriteStream on: ByteArray new.	boss := BinaryObjectStorage onNew: stream.	boss nextPut: self ACL; nextPut: self persistentState.	^stream</body><body package="DST_Core_Services">externalize: aStream 	"serialize the persistent state of the receiver onto the stream"	| stream boss | 	stream := aStream contents writeStream.	boss := BinaryObjectStorage onNew: stream.	boss nextPut: self ACL; nextPut: self persistentState.	aStream nextPutAll: stream contents.</body></methods><methods><class-id>DST.ORBObject</class-id> <category>FactoryRep</category><body package="DST_Core_Services">factoryFinder	"return the factory finder of the receiver" 	^self class factoryFinder asRemotable</body></methods><methods><class-id>DST.ORBObject</class-id> <category>BasicLifecycle</category><body package="DST_Core_Services">internalize: aStream 	"internalize a new instance from the stream"	| bos stream  | 	stream := aStream contents readStream.	aStream destroy.	bos := BinaryObjectStorage onOldNoScan: stream.	bos next.	self copyPersistentState: bos next.</body></methods><methods><class-id>DST.ORBObject</class-id> <category>LifeCycle</category><body package="DST_Core_Services">moveFactoryFinder: aFactoryFinder criteria: aCriteria 	"move the receiver to the location of the factory finder"	aCriteria isEmpty ifFalse: [(CORBAConstants at: #'::CosLifeCycle::CannotMeetCriteria')			raiseWith: (Dictionary with: #invalidCriteria -&gt; aCriteria)			errorString: ' Move criteria not supported'].	(CORBAConstants at: #'::CosLifeCycle::NotMovable')		raiseWith: (Dictionary with: #reason -&gt; 'move not implemented')		errorString: ' Move not supported'</body></methods><methods><class-id>Core.String</class-id> <category>DST</category><body package="DST_Core_Services">asDSTName	"Return a DSTName on the receiver"	^DSTName onString: self</body></methods><methods><class-id>Core.Array</class-id> <category>DST</category><body package="DST_Core_Services">asDSTName	"Return a DSTName on the receiver"	^DSTName on: self</body></methods><methods><class-id>Core.Object</class-id> <category>DST</category><body package="DST_Core_Services">destroy	"destroy the receiver. Unmap it from the ORB and let it be ephemeral 	once again"	DSTObjRef unRegisterLifeCycleObject: self</body></methods><initialize><class-id>DST.DSTNamingServiceConfiguration</class-id></initialize><initialize><class-id>DST.DSTFactoryFinder</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>OrderedCollection</name><environment>Core</environment><super>Core.SequenceableCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>firstIndex lastIndex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Sequenceable</category><attributes><package>Collections-Sequenceable</package></attributes></class><class><name>Array</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>ORBObject</name><environment>DST</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>accessControlList </inst-vars><class-inst-vars>abstractClassId classAbstractClassId accessControlList </class-inst-vars><imports></imports><category>CORBA-Core</category><attributes><package>DST_Core</package></attributes></class><class><name>ReadStream</name><environment>Core</environment><super>Core.InternalStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>DSTServiceConfiguration</name><environment>DST</environment><super>DST.DSTConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>DST-Configuration</category><attributes><package>DST_Core</package></attributes></class><class><name>DSTPersistentObject</name><environment>DST</environment><super>DST.ORBObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>objectId </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Core</category><attributes><package>DST_Core</package></attributes></class></st-source>