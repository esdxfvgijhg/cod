<?xml version="1.0"?><st-source><!-- Name: DST_Core_Services_IDLNotice: Copyright 1999-2013 Cincom Systems, Inc.  All rights reserved.Comment: DST_Core_services_IDL contains the IDL required by the Name Service and the Lifecycle Service.Copyright: Copyright © 1999-2001 Cincom Systems, Inc.All Rights ReservedThis product contains copyrighted third-party software.Copyright © 1993-1995 Hewlett-Packard Company.All Rights ReservedDbIdentifier: bear73DbTrace: 464618DbUsername: tkoganDbVersion: 8.1 - 1DevelopmentPrerequisites: #(#(#any 'DST_Repository' '') #(#any 'DST_IDLCompiler' ''))PackageName: DST_Core_Services_IDLParcel: #('DST_Core_Services_IDL')ParcelName: DST_Core_Services_IDLPrerequisiteDescriptions: #(#(#name 'DST_Repository' #componentType #package) #(#name 'DST_IDLCompiler' #componentType #package))PrerequisiteParcels: #(#('DST_Repository' '') #('DST_IDLCompiler' ''))PrintStringCache: (8.1 - 1,tkogan)Version: 8.1 - 1Date: 1:09:21 PM January 29, 2016 --><time-stamp>From VisualWorks®, Pre-Release 8.2 (jan16.4) of January 29, 2016 on January 29, 2016 at 1:09:21 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><methods><class-id>DST.DSTRepository</class-id> <category>CORE</category><body package="DST_Core_Services_IDL">// CosLifeCycle//// This module defines the CORBA COSS interfaces for object// Lifecycles.// module CosLifeCycle  {	#pragma prefix "omg.org/CosLifeCycle"	typedef CosNaming::Name Key;	typedef Object Factory;	typedef sequence&lt;Factory&gt; Factories;	typedef struct  NVP {CosNaming::Istring name; any value; } NameValuePair;	typedef sequence&lt;NameValuePair&gt; Criteria;	exception NoFactory {Key search_key; };	exception NotCopyable {string reason; };	exception NotMovable {string reason; };	exception NotRemovable {string reason; };	exception InvalidCriteria {Criteria invalid_criteria; };	exception CannotMeetCriteria {Criteria invalid_criteria; };	// 	// FactoryFinders are objects which can return factory objects	// 	interface FactoryFinder {		#pragma selector find_factories findFactoriesKey:		Factories find_factories (in Key factory_key)						raises (NoFactory);	};	// 	// This interface defines the basic lifecycle operations on objects	// 	interface LifeCycleObject {		#pragma  selector copy copyFactoryFinder:criteria:		LifeCycleObject copy (in FactoryFinder there, in Criteria the_criteria)							raises (NoFactory,									NotCopyable,									InvalidCriteria,									CannotMeetCriteria);		#pragma  selector move moveFactoryFinder:criteria:		void move (in FactoryFinder there, in Criteria the_criteria)					raises (NoFactory,							NotMovable,							InvalidCriteria,							CannotMeetCriteria);		#pragma  selector remove destroy		void remove ()					raises (NotRemovable);	};	// 	// A GenericFactory is an object which can create other objects	// 	interface GenericFactory {		#pragma  selector supports supportsKey:		boolean supports (in Key k);		#pragma  selector create_object createObjectKey:criteria:		Object create_object (in Key k, in Criteria the_criteria)						raises (NoFactory, InvalidCriteria, CannotMeetCriteria);	};	// 	// This interface defines the createObject() convenience	// operation. It is inherited by:	// 	CompoundLifecycles::Lifecycle	// 	PSSplit::Presentation	// 	DistributedSmalltalk::FactoryFinderObject	// 	interface FactoryRepresentative {		// This really belongs in LifeCycle, but alas...		typedef CORBA::ORBId AclassId;		readonly attribute AclassId abstract_class_id;		exception CannotCreateObject {string reason; };		#pragma  selector get_factory_finder factoryFinder		// This operation is used to return the factory finder which is		// nearest an object.		FactoryFinder get_factory_finder ();		#pragma  selector create_object createObject:		// This operation is used to create an instance of a particular		// abstract class which is registered with the receiver. Failure		// indicates that a more protracted interaction with the		// factoryFinder of the receiver is indicated.		Object create_object (in AclassId abstract_class_id)						raises (CannotCreateObject);	};	// 	// This interface defines the factory finder operations	// 	interface FactoryFinderObject :					CosNaming::NamingContext, 					FactoryFinder, 					FactoryRepresentative	{		#pragma  selector create_and_internalize createAndInternalize:		// This operation is used to internalize a new object from the		// given stream		Object create_and_internalize (in SmalltalkTypes::Stream s)						raises (NoFactory, StreamError);	};};</body><body package="DST_Core_Services_IDL">// CosNaming//// This module defines the CORBA COS interfaces for Naming.// module CosNaming  {	#pragma prefix "omg.org/CosNaming"	// An internationalized string, for now	typedef string Istring;	#pragma  class NameComponent DSTNameComponent	struct  NameComponent {Istring id; Istring kind; };	#pragma class Name DSTName	typedef sequence&lt;NameComponent&gt; Name;	enum BindingType {nobject, ncontext};	struct  Binding {Name binding_name; BindingType binding_type; };	typedef sequence&lt;Binding&gt; BindingList;	// 	// This interface defines the operations associated with accessing	// name contexts. A name context associates objects with names	// in a unique mapping. Once an object is bound, it can be	// retrieved by via one of the resolution operations. This interface	// may be used by objects wishing to support uniform name	// resolution but which have their own mechanisms to perform	// the binding operations.	// 	interface NamingContext {		enum NotFoundReason {missing_node, not_context, not_object};		exception NotFound {NotFoundReason why; Name rest_of_name; };		exception CannotProceed {NamingContext cxt; Name rest_of_name; };		exception InvalidName {};		exception AlreadyBound {};		exception NotEmpty {};		#pragma  selector bind contextBind:to:		// This operation binds a name to an object		void bind (in Name n, in Object obj)					raises (NotFound,							CannotProceed,							InvalidName,							AlreadyBound);		#pragma  selector rebind contextReBind:to:		// This operation associates a name with a different bound		// entity		void rebind (in Name n, in Object obj)					raises (NotFound, CannotProceed, InvalidName);		#pragma  selector bind_context contextBindContext:to:		// This operation binds a name to a naming context		void bind_context (in Name n, in NamingContext nc)					raises (NotFound,							CannotProceed,							InvalidName,							AlreadyBound);		#pragma  selector rebind_context contextReBindContext:to:		// This operation associates a name to a different bound		// naming context		void rebind_context (in Name n, in NamingContext nc)					raises (NotFound, CannotProceed, InvalidName);		#pragma  selector resolve contextResolve:		// This operation returns the object which is bound to the		// name in the receiver		Object resolve (in Name n)						raises (NotFound, CannotProceed, InvalidName);		#pragma  selector unbind contextUnBind:		// This operation deletes the name binding from the receiver		void unbind (in Name n)					raises (NotFound, CannotProceed, InvalidName);		// This operation returns a new context		NamingContext new_context ();		#pragma  selector bind_new_context bindNewContext:		// This operation creates a new context and binds it to the		// given name.		NamingContext bind_new_context (in Name n)							raises (NotFound,									AlreadyBound,									CannotProceed,									InvalidName);		#pragma  selector destroy destroyContext		// This operation deletes the receiver		void destroy ()					raises (NotEmpty);		#pragma  selector list listContext:bindingList:bindingIterator:		// This operation returns a name list containing the bindings		// of the receiver		void list (						in unsigned long how_many,						out BindingList bl,						out BindingIterator bi);	};	// 	// A binding iterator is an object which can return portions of a	// long list of bindings	// 	interface BindingIterator {		#pragma  selector next_one nextOne:		// This operation returns the next binding and whether there		// are more or not		boolean next_one (out Binding b);		#pragma  selector next_n nextN:bindingList:		// This operation returns the next n bindings and whether		// there are more or not		boolean next_n (in unsigned long howMany, out BindingList bl);		// This operation deletes the receiver		void destroy ();	};////	Note that DST does not yet provide an implementation of the NamingContextExt//	interface.  It is provided as a convenience for interoperation with ORBs that do.//	interface NamingContextExt : NamingContext {	    typedef string StringName;	    typedef string Address;	    typedef string URLString;	    StringName to_string (in Name n)			raises (InvalidName);	    Name to_name (in StringName sn)			raises (InvalidName);	    exception InvalidAddress {};	    URLString to_url (in Address addr,			      in StringName sn)			raises (InvalidAddress, InvalidName);	    Object resolve_str (in StringName sn)			raises (NotFound, CannotProceed, InvalidName);	};};</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>DSTRepository</name><environment>DST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Repository</category><attributes><package>DST_Repository</package></attributes></class></st-source>