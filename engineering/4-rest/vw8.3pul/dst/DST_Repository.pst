<?xml version="1.0"?><st-source><!-- Name: DST_RepositoryNotice: Copyright 1999-2013 Cincom Systems, Inc.  All rights reserved.Comment: DST_Repository contains the DSTRepository class.Copyright: Copyright © 1999-2001 Cincom Systems, Inc.All Rights ReservedThis product contains copyrighted third-party software.Copyright © 1993-1995 Hewlett-Packard Company.All Rights ReservedDbIdentifier: bear73DbTrace: 464616DbUsername: tkoganDbVersion: 8.1 - 1DevelopmentPrerequisites: #(#(#any 'DST_IDLCompiler' '') #(#any 'DST_Core' ''))DisregardedPrerequisites: #(#(#name 'AT Parser Compiler' #componentType #package))PackageName: DST_RepositoryParcel: #('DST_Repository')ParcelName: DST_RepositoryPrerequisiteDescriptions: #(#(#name 'DST_IDLCompiler') #(#name 'DST_Core' #componentType #package))PrerequisiteParcels: #(#('DST_IDLCompiler' '') #('DST_Core' ''))PrintStringCache: (8.1 - 1,tkogan)Version: 8.1 - 1Date: 1:09:21 PM January 29, 2016 --><time-stamp>From VisualWorks®, Pre-Release 8.2 (jan16.4) of January 29, 2016 on January 29, 2016 at 1:09:21 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>DSTRepository</name><environment>DST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Repository</category><attributes><package>DST_Repository</package></attributes></class><comment><class-id>DST.DSTRepository</class-id><body>This class is the sole repository of IDL source code.</body></comment><shared-variable><name>Mutex</name><environment>DST.DSTRepository</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Repository</package></attributes></shared-variable><methods><class-id>DST.DSTRepository class</class-id> <category>compiler</category><body package="DST_Repository">compilerClass	^IDLCompiler</body><body package="DST_Repository">sourceCodeForMethod: method at: messageSelector 	"If the source is not availabe, i.e. we parcel in a IDL selector (module), we have to generate the source	from the metaObject because the decompile is not working"	^method getSourceForUserIfNone:		[(self new perform: messageSelector) getIDLDefinition]</body><body package="DST_Repository">sourceCodeTemplate	"Answer an expression to be edited and evaluated in order to 	define methods in this class."	^( #{DSTIDLGenerator} isDefined )		ifTrue:	[ #{DSTIDLGenerator} value newModuleStub: 'newModuleName' ]		ifFalse:	[ String new ]</body></methods><methods><class-id>DST.DSTRepository class</class-id> <category>accessing</category><body package="DST_Repository">accessMutex	"return the mutex controlling access"	Mutex == nil ifTrue: [Mutex := RecursionLock new].	^Mutex</body></methods><methods><class-id>DST.DSTRepository class</class-id> <category>method dictionary</category><body package="DST_Repository">addSelector: aSelector withMethod: aCompiledMethod  super addSelector: aSelector withMethod: aCompiledMethod.  ORBObject repositoryClass == DSTRepository   	ifTrue:	[ Cursor wait showWhile:				[ ORBObject replaceInRepository: ( aCompiledMethod at: 1 )				]			].</body><body package="DST_Repository">removeSelector: aSymbol 	"Remove the message whose selector is aSymbol from the 	method dictionary of the receiver, if it is there. Answer nil 	otherwise."	self accessMutex		critical: 			[super removeSelector: aSymbol.			ORBObject removeInRepository: aSymbol]</body></methods><methods><class-id>DST.ORBObject class</class-id> <category>ORB-repository</category><body package="DST_Repository">removeInRepository: aSelector 	"Remove the meta object in the repository linked to aSelector"	^self replaceInRepository: aSelector with: nil</body><body package="DST_Repository">replaceInRepository: mo 	"replace the meta object in the repository"	DSTRepository accessMutex critical: [^self replaceInRepository: mo printName asSymbol with: mo]</body><body package="DST_Repository">replaceInRepository: aSelector with: aMetaObject 	"Replace the meta object in the repository linked to aSelector with 	aMetaObject. If aMetaObject is nil, then the old meta object is just 	removed from the repository"	| old cmethod |	LocalRepository isNil ifTrue: [^nil].	old := LocalRepository metaObjectOf: aSelector.	old notNil ifTrue: [LocalRepository removeMetaObject: old].	aMetaObject notNil ifTrue: [	LocalRepository addMetaObject: aMetaObject].	DSTinterface withAllSubclasses do: [:cl | cl allInstances do: [:if | if name isSymbol ifTrue: [if updateInheritance]]].	"replace the old meta object with the new one in the DSTRepository method"	cmethod :=  DSTRepository compiledMethodAt: aSelector ifAbsent: [].	cmethod notNil ifTrue: [cmethod at: 1 put: aMetaObject]</body></methods><methods><class-id>DST.IDLCompiler class</class-id> <category>public access</category><body package="DST_Repository">importIDL: aString category: aCategory 	"Import IDL in the form of a string into the interface repository. 	The importation proceeds as follows: 	1) Create (if necessary) aCategory in DSTRepository 	2) Preprocess the incoming IDL file 	3) Format the incoming IDL source 	3) Compile the formatted IDL source."	| stream cs text |	cs := aCategory asSymbol.	stream := aString readStream.	(DSTRepository organization categories includes: cs)		ifFalse: [DSTRepository organization addCategory: cs].	stream := self preprocess: stream.	stream reset.	[stream atEnd]		whileFalse: 			[text := DSTRepository compilerClass new						format: stream						in: DSTRepository						notifying: nil.			DSTRepository				compile: text				classified: aCategory				notifying: nil]</body><body package="DST_Repository">importIDLFile: aPathString category: aCategory 	"Import an IDL file into the interface repository. 	The importation proceeds as follows: 	1) Create (if necessary) aCategory in DSTRepository 	2) Preprocess the incoming IDL file 	3) Format the incoming IDL source 	3) Compile the formatted IDL source."	| stream cs text |	cs := aCategory asSymbol.	stream := aPathString asFilename readStream.		[(DSTRepository organization categories includes: cs)		ifFalse: [DSTRepository organization addCategory: cs].	stream := self preprocess: stream.	stream reset.	[stream atEnd]		whileFalse: 			[text := DSTRepository compilerClass new						format: stream						in: DSTRepository						notifying: nil.			DSTRepository				compile: text				classified: aCategory				notifying: nil]]		ensure: [stream close]</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class></st-source>